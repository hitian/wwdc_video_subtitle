1
00:00:07,516 --> 00:00:19,500
[ Music ]

2
00:00:29,516 --> 00:00:32,546
[ Applause ]

3
00:00:33,046 --> 00:00:33,576
&gt;&gt; Good afternoon.

4
00:00:35,086 --> 00:00:38,386
So I'm going to talk to you

5
00:00:38,386 --> 00:00:41,056
to structure your programs

6
00:00:41,056 --> 00:00:44,816
and what we've done this year

7
00:00:45,656 --> 00:00:46,216
My name is Matt.

8
00:00:46,816 --> 00:00:48,476
I'm going to be joined

9
00:00:49,476 --> 00:00:53,996
We're both on the Darwin

10
00:00:54,196 --> 00:00:56,936
So when you create a new

11
00:00:56,936 --> 00:00:59,366
to have something that looks

12
00:00:59,716 --> 00:01:00,816
You have your application.

13
00:00:59,716 --> 00:01:00,816
You have your application.

14
00:01:01,016 --> 00:01:03,376
That application

15
00:01:04,676 --> 00:01:08,316
That main thread is responsible

16
00:01:08,316 --> 00:01:09,816
that powers your user interface.

17
00:01:10,336 --> 00:01:16,426
As you start to add code to

18
00:01:16,426 --> 00:01:19,316
to find the performance of

19
00:01:19,316 --> 00:01:20,066
quite drastically.

20
00:01:20,606 --> 00:01:24,316
For instance, if you start to

21
00:01:24,316 --> 00:01:29,796
say data transforms or image

22
00:01:29,796 --> 00:01:32,416
you're going to find

23
00:01:32,736 --> 00:01:33,946
suffers drastically.

24
00:01:34,786 --> 00:01:38,896
On macOS, this can be the

25
00:01:39,146 --> 00:01:41,466
On iOS, it could be

26
00:01:41,466 --> 00:01:42,906
Your user interface

27
00:01:42,906 --> 00:01:44,426
or maybe even stop entirely.

28
00:01:44,766 --> 00:01:48,726
So I'm going to take you

29
00:01:48,726 --> 00:01:51,416
to struct your application to

30
00:01:51,616 --> 00:01:54,456
And later on in the talk, Pierre

31
00:01:54,456 --> 00:01:56,866
through some more

32
00:01:57,556 --> 00:02:01,206
So how do we deal with

33
00:01:57,556 --> 00:02:01,206
So how do we deal with

34
00:02:05,216 --> 00:02:07,456
We have to start by

35
00:02:07,456 --> 00:02:08,985
of concurrency to

36
00:02:09,175 --> 00:02:12,336
Concurrency allows multiple

37
00:02:12,336 --> 00:02:13,636
to run at the same time.

38
00:02:14,216 --> 00:02:17,116
On our system, you achieve

39
00:02:17,926 --> 00:02:20,956
A CPU core can execute one of

40
00:02:21,496 --> 00:02:23,966
but the payoff for

41
00:02:24,116 --> 00:02:25,726
the penalty for introducing

42
00:02:25,726 --> 00:02:28,226
to your application is

43
00:02:28,576 --> 00:02:29,916
to maintain your thread safety.

44
00:02:30,406 --> 00:02:32,886
The other threads that you've

45
00:02:32,886 --> 00:02:35,716
effects of you breaking your

46
00:02:35,716 --> 00:02:37,296
performing operations

47
00:02:38,266 --> 00:02:39,966
This becomes a bit of a problem.

48
00:02:41,456 --> 00:02:42,266
So how can we help?

49
00:02:42,546 --> 00:02:45,926
Well, GCD is the concurrency

50
00:02:46,336 --> 00:02:50,116
It helps you write code,

51
00:02:50,116 --> 00:02:51,866
on everything from

52
00:02:52,276 --> 00:02:53,796
through all of our iOS devices.

53
00:02:54,306 --> 00:02:56,616
Apple TVs and all

54
00:02:57,996 --> 00:03:00,656
So in order to help you

55
00:02:57,996 --> 00:03:00,656
So in order to help you

56
00:03:00,656 --> 00:03:04,056
we introduce some abstractions

57
00:03:05,166 --> 00:03:08,206
That is, dispatch

58
00:03:08,506 --> 00:03:12,986
A dispatch queue is a construct

59
00:03:12,986 --> 00:03:14,286
of work to that queue.

60
00:03:14,546 --> 00:03:15,906
In Swift, this is closures.

61
00:03:16,376 --> 00:03:19,366
And dispatch will

62
00:03:20,266 --> 00:03:21,646
and service that work for you.

63
00:03:22,076 --> 00:03:24,666
And when dispatch is finished

64
00:03:24,666 --> 00:03:26,056
on that thread, it can tear

65
00:03:26,056 --> 00:03:28,036
that worker thread

66
00:03:29,016 --> 00:03:32,046
As I said before, you can

67
00:03:33,056 --> 00:03:35,026
and on those threads,

68
00:03:35,216 --> 00:03:39,816
And then finally, on the first

69
00:03:39,816 --> 00:03:41,336
thread, and the main

70
00:03:41,526 --> 00:03:44,616
It gets both a main run

71
00:03:45,776 --> 00:03:50,316
So dispatch queues have two main

72
00:03:50,316 --> 00:03:53,536
for them, the first of which

73
00:03:54,366 --> 00:03:57,256
This is where you can queue

74
00:03:57,436 --> 00:04:00,656
to your dispatch queue,

75
00:03:57,436 --> 00:04:00,656
to your dispatch queue,

76
00:04:01,066 --> 00:04:03,946
will bring up a thread

77
00:04:04,636 --> 00:04:07,006
Dispatch will one by

78
00:04:07,006 --> 00:04:08,046
that queue and execute them.

79
00:04:12,076 --> 00:04:14,466
And then when it's finished

80
00:04:14,616 --> 00:04:15,826
the system will reclaim

81
00:04:15,826 --> 00:04:16,685
that it bought up for you.

82
00:04:17,146 --> 00:04:21,305
The second mode of execution

83
00:04:22,236 --> 00:04:25,566
This is where, for instance,

84
00:04:25,566 --> 00:04:27,486
as we had before,

85
00:04:27,486 --> 00:04:28,646
with some asynchronous work.

86
00:04:28,826 --> 00:04:32,206
But you have your own

87
00:04:32,206 --> 00:04:34,726
to run code on that queue

88
00:04:35,056 --> 00:04:38,766
You can submit that work

89
00:04:39,386 --> 00:04:40,546
and then that's where

90
00:04:41,296 --> 00:04:43,536
It will wait there until

91
00:04:43,536 --> 00:04:44,986
to execute has completed.

92
00:04:45,506 --> 00:04:47,846
We might add some more

93
00:04:47,846 --> 00:04:50,706
and then dispatch will

94
00:04:50,706 --> 00:04:52,236
to service the items

95
00:04:52,826 --> 00:04:54,886
Again, the asynchronous

96
00:04:54,886 --> 00:04:57,846
and then when it comes time

97
00:04:57,846 --> 00:04:58,726
that you've asked to run.

98
00:04:59,456 --> 00:05:02,476
The dispatch queue will pass

99
00:04:59,456 --> 00:05:02,476
The dispatch queue will pass

100
00:05:02,476 --> 00:05:06,646
that was waiting, execute

101
00:05:06,646 --> 00:05:08,486
of the dispatch queue

102
00:05:08,556 --> 00:05:10,616
to a worker thread

103
00:05:11,396 --> 00:05:14,246
It will continue to drain the

104
00:05:15,116 --> 00:05:17,926
and then also reclaim the

105
00:05:18,696 --> 00:05:21,016
So now I've shown you how

106
00:05:21,136 --> 00:05:21,716
to dispatch.

107
00:05:22,006 --> 00:05:24,566
How do we use that to help

108
00:05:24,566 --> 00:05:25,156
had earlier?

109
00:05:26,236 --> 00:05:29,766
What we want to do is get the

110
00:05:29,766 --> 00:05:32,276
causing you to block

111
00:05:32,516 --> 00:05:36,086
and we do that by taking

112
00:05:36,086 --> 00:05:38,856
on that main thread and

113
00:05:38,856 --> 00:05:42,996
So you can take the

114
00:05:42,996 --> 00:05:43,996
with a dispatch queue.

115
00:05:44,716 --> 00:05:46,776
And now when you want

116
00:05:47,166 --> 00:05:51,286
you can move the value of that

117
00:05:51,896 --> 00:05:55,386
on the other queue,

118
00:05:55,386 --> 00:05:56,956
and then send it back

119
00:05:57,946 --> 00:05:59,036
This allows you to perform

120
00:05:59,036 --> 00:06:02,516
that work while the main thread

121
00:05:59,036 --> 00:06:02,516
that work while the main thread

122
00:06:03,526 --> 00:06:05,376
So what does that look

123
00:06:06,696 --> 00:06:07,866
Well, it's really simple.

124
00:06:08,366 --> 00:06:10,876
So first of all, you can

125
00:06:11,126 --> 00:06:13,836
to submit your work to by just

126
00:06:14,096 --> 00:06:17,386
It takes a label, and that

127
00:06:17,386 --> 00:06:18,736
as you're writing

128
00:06:20,536 --> 00:06:23,726
Dispatch queues execute

129
00:06:23,726 --> 00:06:25,266
in first in, first out order.

130
00:06:25,466 --> 00:06:27,686
That is, the order that

131
00:06:27,686 --> 00:06:29,986
to the queue is the order that

132
00:06:31,076 --> 00:06:34,346
And then you can use the async

133
00:06:34,636 --> 00:06:37,356
to submit work to that queue.

134
00:06:38,086 --> 00:06:41,016
So now that we've actually

135
00:06:41,016 --> 00:06:43,226
here to a different

136
00:06:43,226 --> 00:06:44,246
that back to the main thread?

137
00:06:45,366 --> 00:06:46,846
That's very simple too.

138
00:06:47,256 --> 00:06:50,316
The dispatch main queue

139
00:06:50,316 --> 00:06:52,896
that you execute on it on

140
00:06:54,696 --> 00:06:58,016
This means you can just

141
00:06:58,156 --> 00:07:00,646
and then call async

142
00:06:58,156 --> 00:07:00,646
and then call async

143
00:07:01,006 --> 00:07:02,296
and that code will execute,

144
00:07:02,296 --> 00:07:04,626
and you can update your

145
00:07:05,456 --> 00:07:08,566
As you can see, it's very simple

146
00:07:08,566 --> 00:07:10,656
to another queue and back

147
00:07:11,126 --> 00:07:14,826
So now we've seen how to

148
00:07:14,826 --> 00:07:15,876
and put it on different threads.

149
00:07:16,876 --> 00:07:18,966
It comes at somewhat of a cost.

150
00:07:20,106 --> 00:07:23,816
You have to control a

151
00:07:24,436 --> 00:07:28,896
The thread pool that dispatch

152
00:07:29,036 --> 00:07:33,216
you achieve in order to use all

153
00:07:34,516 --> 00:07:37,436
However, when you

154
00:07:37,436 --> 00:07:40,076
if you wait for other parts of

155
00:07:40,076 --> 00:07:42,976
in sys calls those

156
00:07:42,976 --> 00:07:45,346
that are blocked can cause

157
00:07:45,516 --> 00:07:48,276
Dispatch is trying to give you

158
00:07:48,576 --> 00:07:51,696
by giving you a new thread to

159
00:07:52,556 --> 00:07:54,856
This means it's very important

160
00:07:54,856 --> 00:07:57,786
of dispatch queues to

161
00:07:58,346 --> 00:08:00,106
Otherwise, you can

162
00:07:58,346 --> 00:08:00,106
Otherwise, you can

163
00:08:00,826 --> 00:08:01,666
Another thread will come up,

164
00:08:01,666 --> 00:08:03,996
and you will block

165
00:08:03,996 --> 00:08:06,476
And this pattern is something

166
00:08:07,266 --> 00:08:09,396
We covered thread

167
00:08:09,616 --> 00:08:11,956
in last year's talk,

168
00:08:11,956 --> 00:08:13,286
and Efficient Apps with GCD.

169
00:08:13,696 --> 00:08:18,206
So I recommend you go back

170
00:08:20,476 --> 00:08:22,636
So now we've seen how

171
00:08:22,636 --> 00:08:25,586
like getting work off of the

172
00:08:25,856 --> 00:08:27,916
But how do we actually apply

173
00:08:28,396 --> 00:08:32,296
Well, if we go back to

174
00:08:32,525 --> 00:08:35,586
what you want to do is identify

175
00:08:35,806 --> 00:08:37,066
with independent data flow.

176
00:08:37,436 --> 00:08:39,596
So as we've seen, it

177
00:08:39,976 --> 00:08:41,206
or you might have a database.

178
00:08:41,515 --> 00:08:44,816
You want to take those

179
00:08:45,046 --> 00:08:48,186
into distinct subsystems,

180
00:08:48,186 --> 00:08:51,246
to back those subsystems

181
00:08:52,356 --> 00:08:54,856
This will give each subsystem

182
00:08:54,856 --> 00:08:57,936
on independently without

183
00:08:57,936 --> 00:08:59,806
of having too many queues

184
00:09:00,346 --> 00:09:03,196
And we saw a couple of

185
00:09:03,196 --> 00:09:04,156
to chain work together.

186
00:09:04,956 --> 00:09:08,176
That is where you can

187
00:09:08,176 --> 00:09:09,456
and then to another queue,

188
00:09:09,796 --> 00:09:11,286
and then back to,

189
00:09:12,126 --> 00:09:14,436
But there's a second

190
00:09:14,436 --> 00:09:15,846
that we feel is equally useful.

191
00:09:15,846 --> 00:09:19,096
That is grouping work and

192
00:09:20,456 --> 00:09:22,376
If you have a single

193
00:09:22,376 --> 00:09:25,686
to spawn multiple different

194
00:09:25,686 --> 00:09:27,466
to make progress if

195
00:09:27,526 --> 00:09:30,416
when those work items is

196
00:09:31,316 --> 00:09:34,416
And in order to do that,

197
00:09:35,446 --> 00:09:38,146
So if we do back to the

198
00:09:38,376 --> 00:09:42,486
if the user interface spawns off

199
00:09:43,466 --> 00:09:45,486
you can create a dispatch group.

200
00:09:46,586 --> 00:09:49,116
Dispatch groups are here

201
00:09:50,176 --> 00:09:53,036
and they're very simple

202
00:09:53,206 --> 00:09:55,256
You just create a

203
00:09:56,576 --> 00:10:01,476
And now when you submit work to

204
00:09:56,576 --> 00:10:01,476
And now when you submit work to

205
00:10:01,776 --> 00:10:03,866
as an optional parameter

206
00:10:05,046 --> 00:10:07,636
You can add more work to

207
00:10:07,636 --> 00:10:08,556
to different queues,

208
00:10:08,876 --> 00:10:10,416
but associate it

209
00:10:10,616 --> 00:10:14,216
And each time you

210
00:10:14,536 --> 00:10:16,356
the group will increment

211
00:10:16,356 --> 00:10:17,696
that it's expecting to complete.

212
00:10:19,816 --> 00:10:22,126
Then finally, once you've

213
00:10:22,666 --> 00:10:25,456
you can ask the group

214
00:10:25,456 --> 00:10:27,246
that work is finished,

215
00:10:27,246 --> 00:10:30,456
so on a queue that

216
00:10:30,986 --> 00:10:34,106
So now one by one, these

217
00:10:34,716 --> 00:10:37,766
and as they execute the count

218
00:10:37,766 --> 00:10:40,196
in the group will

219
00:10:40,196 --> 00:10:41,056
item completes.

220
00:10:41,716 --> 00:10:44,636
And when, finally, the last

221
00:10:45,246 --> 00:10:48,106
the group will go ahead and

222
00:10:48,386 --> 00:10:51,816
to the queue that

223
00:10:51,816 --> 00:10:54,636
So here, we submitted

224
00:10:54,636 --> 00:10:57,546
to the main queue, and it

225
00:10:58,076 --> 00:11:03,636
Now there's a third pattern

226
00:10:58,076 --> 00:11:03,636
Now there's a third pattern

227
00:11:04,286 --> 00:11:08,096
These two have been asynchronous

228
00:11:08,146 --> 00:11:09,666
to deal with synchronous

229
00:11:10,196 --> 00:11:12,946
You can use synchronous

230
00:11:13,286 --> 00:11:16,506
to help you serialize

231
00:11:17,716 --> 00:11:20,626
Serial queues, dispatch

232
00:11:21,566 --> 00:11:24,626
And you can use this for its

233
00:11:24,976 --> 00:11:28,176
That is, when you submit work

234
00:11:28,436 --> 00:11:30,456
you know the work that

235
00:11:30,456 --> 00:11:32,416
on that queue isn't

236
00:11:33,756 --> 00:11:36,436
You can use this to build

237
00:11:36,436 --> 00:11:38,466
to the thread safe

238
00:11:38,466 --> 00:11:40,556
from your subsystem

239
00:11:41,166 --> 00:11:43,536
So for instance, here

240
00:11:43,946 --> 00:11:45,956
and you can return a

241
00:11:46,466 --> 00:11:49,436
and we will capture that value

242
00:11:49,436 --> 00:11:51,906
to you as that work

243
00:11:52,376 --> 00:11:56,696
However, you have to be

244
00:11:56,696 --> 00:11:58,806
to introduce this

245
00:11:58,806 --> 00:12:01,746
to introduce a lock ordering

246
00:11:58,806 --> 00:12:01,746
to introduce a lock ordering

247
00:12:01,826 --> 00:12:03,986
Now, what does that mean?

248
00:12:04,176 --> 00:12:07,686
Well, if you have the subsystems

249
00:12:07,686 --> 00:12:10,276
from one place to another

250
00:12:10,566 --> 00:12:13,486
and then finally, you end up

251
00:12:13,866 --> 00:12:15,066
Well, now we have a deadlock.

252
00:12:16,226 --> 00:12:17,466
Pierre's going to come and talk

253
00:12:17,466 --> 00:12:19,856
about deadlocks later

254
00:12:27,046 --> 00:12:29,986
So now we've seen a bit how

255
00:12:30,356 --> 00:12:31,756
in your application as a whole.

256
00:12:31,936 --> 00:12:35,706
How can we also apply it to

257
00:12:36,486 --> 00:12:39,056
Well, you can use dispatch

258
00:12:39,056 --> 00:12:41,256
that you submit, and to do so,

259
00:12:41,256 --> 00:12:44,586
we need to introduce

260
00:12:45,116 --> 00:12:48,116
These are classes that provide

261
00:12:48,156 --> 00:12:50,046
of the work that you are

262
00:12:50,636 --> 00:12:54,136
So it allows you as the

263
00:12:54,136 --> 00:12:56,006
of the code that you are

264
00:12:56,476 --> 00:13:00,116
And dispatch can use that to

265
00:12:56,476 --> 00:13:00,116
And dispatch can use that to

266
00:13:00,116 --> 00:13:01,656
that you've given us.

267
00:13:02,036 --> 00:13:04,016
That is, the code

268
00:13:04,016 --> 00:13:05,226
at a different CPU priority,

269
00:13:05,416 --> 00:13:07,706
different IO scheduling

270
00:13:08,296 --> 00:13:12,246
And we covered QoS in detail in

271
00:13:12,246 --> 00:13:14,326
Building Responsive and

272
00:13:15,296 --> 00:13:17,436
So how do we actually

273
00:13:18,866 --> 00:13:20,796
Well, it's as simple

274
00:13:21,316 --> 00:13:23,956
You can pass the

275
00:13:24,036 --> 00:13:25,246
as another optional parameter.

276
00:13:25,246 --> 00:13:27,996
So here, we're submitting

277
00:13:29,166 --> 00:13:33,016
And if you come along later

278
00:13:33,016 --> 00:13:36,036
at a higher QoS, dispatch will

279
00:13:36,036 --> 00:13:36,996
inversion that's created.

280
00:13:37,656 --> 00:13:41,066
That is, it will raise the

281
00:13:41,246 --> 00:13:43,616
on the dispatch queue

282
00:13:44,606 --> 00:13:46,546
so that they execute quicker

283
00:13:46,546 --> 00:13:48,786
and you actually get

284
00:13:48,786 --> 00:13:50,196
through as quickly

285
00:13:51,206 --> 00:13:53,196
However, it's important

286
00:13:53,646 --> 00:13:55,536
this doesn't help your

287
00:13:55,756 --> 00:13:58,516
All that does here is elevate

288
00:13:58,516 --> 00:14:01,406
so it executes as quickly as

289
00:13:58,516 --> 00:14:01,406
so it executes as quickly as

290
00:14:02,646 --> 00:14:06,106
And then you can also

291
00:14:06,366 --> 00:14:08,086
that have a specific QoS class.

292
00:14:08,486 --> 00:14:09,846
This is very helpful,

293
00:14:10,156 --> 00:14:12,936
if you have background work

294
00:14:12,936 --> 00:14:14,926
at background, you

295
00:14:15,116 --> 00:14:16,806
that executes all

296
00:14:16,806 --> 00:14:18,826
And when you submit

297
00:14:19,076 --> 00:14:21,006
that's the QoS that we'll get.

298
00:14:21,756 --> 00:14:26,726
So on a more granular

299
00:14:27,616 --> 00:14:30,676
to a dispatch queue, it

300
00:14:30,676 --> 00:14:31,806
at the point where you async.

301
00:14:32,916 --> 00:14:35,136
Now, execution context

302
00:14:35,646 --> 00:14:37,766
It also means the login

303
00:14:38,826 --> 00:14:41,336
But if you want more

304
00:14:41,606 --> 00:14:45,346
you can use DispatchWorkItem

305
00:14:45,556 --> 00:14:47,646
where you have more control

306
00:14:49,006 --> 00:14:52,886
For instance, here we're

307
00:14:53,076 --> 00:14:57,206
with assignCurrentContext,

308
00:14:57,206 --> 00:15:00,696
of the execution context at the

309
00:14:57,206 --> 00:15:00,696
of the execution context at the

310
00:15:00,906 --> 00:15:02,576
rather than the time

311
00:15:02,576 --> 00:15:03,466
to your dispatch queue.

312
00:15:04,506 --> 00:15:07,366
This means you can create

313
00:15:07,366 --> 00:15:10,066
and when you do finally

314
00:15:10,066 --> 00:15:12,616
to dispatch with the properties

315
00:15:13,336 --> 00:15:14,986
And now while we're

316
00:15:15,246 --> 00:15:17,816
there's another part that's very

317
00:15:18,186 --> 00:15:20,106
and that is waiting

318
00:15:20,186 --> 00:15:24,876
You can use the wait method on

319
00:15:24,876 --> 00:15:26,636
to dispatch that you

320
00:15:26,636 --> 00:15:28,436
to complete before

321
00:15:30,956 --> 00:15:33,486
Dispatch will respond by

322
00:15:33,486 --> 00:15:35,936
of work ahead of

323
00:15:35,936 --> 00:15:38,046
like it did with priority

324
00:15:38,046 --> 00:15:43,956
And it can do this because

325
00:15:43,956 --> 00:15:46,316
where it was submitted, which

326
00:15:46,616 --> 00:15:49,756
And therefore, dispatch knows

327
00:15:49,886 --> 00:15:51,696
in order to get your

328
00:15:52,146 --> 00:15:56,156
And it's very important to

329
00:15:56,156 --> 00:15:58,656
on Semaphores and

330
00:15:58,656 --> 00:15:59,776
ownership information.

331
00:16:00,096 --> 00:16:02,806
This means if you wait on

332
00:16:02,806 --> 00:16:05,446
to cause the things in front

333
00:16:05,626 --> 00:16:06,786
to execute any quicker.

334
00:16:07,466 --> 00:16:09,756
And now I'd like to invite

335
00:16:09,836 --> 00:16:12,436
He's going to take you through

336
00:16:13,516 --> 00:16:19,646
[ Applause ]

337
00:16:20,146 --> 00:16:20,566
&gt;&gt; Thank you, Matt.

338
00:16:22,596 --> 00:16:25,976
So with Matt, we've

339
00:16:26,096 --> 00:16:28,096
from the perspective

340
00:16:28,316 --> 00:16:30,796
I will walk you through more

341
00:16:31,056 --> 00:16:32,816
from the perspective

342
00:16:33,946 --> 00:16:35,956
But first, a note about Swift.

343
00:16:39,336 --> 00:16:42,536
Synchronization is not part

344
00:16:44,196 --> 00:16:47,826
You only have one grand key

345
00:16:47,826 --> 00:16:50,126
which is that your

346
00:16:50,126 --> 00:16:51,416
initialized atomically.

347
00:16:52,526 --> 00:16:55,106
But what you don't have is

348
00:16:55,106 --> 00:16:59,516
that your class properties are

349
00:16:59,516 --> 00:17:01,296
of your classes aren't

350
00:16:59,516 --> 00:17:01,296
of your classes aren't

351
00:17:01,826 --> 00:17:05,016
What that means is that if

352
00:17:05,016 --> 00:17:07,415
in our initialize

353
00:17:07,836 --> 00:17:10,516
your lazy initializer

354
00:17:11,705 --> 00:17:13,096
So you have to synchronize.

355
00:17:14,326 --> 00:17:17,766
The language doesn't give us

356
00:17:18,175 --> 00:17:21,226
but that doesn't mean that

357
00:17:22,226 --> 00:17:26,886
There is no such thing

358
00:17:27,435 --> 00:17:31,756
What that means for you is

359
00:17:31,756 --> 00:17:34,166
that if you forget a

360
00:17:34,626 --> 00:17:37,976
you will end up with crashes

361
00:17:37,976 --> 00:17:40,236
of the user of your apps.

362
00:17:41,496 --> 00:17:44,646
I invite you to go

363
00:17:44,646 --> 00:17:45,976
that happened earlier this week

364
00:17:45,976 --> 00:17:49,906
about T San, which

365
00:17:50,746 --> 00:17:53,766
Which is a tool that

366
00:17:53,766 --> 00:17:56,476
in your app you're missing

367
00:17:56,726 --> 00:18:01,816
So what do we use

368
00:17:56,726 --> 00:18:01,816
So what do we use

369
00:18:02,876 --> 00:18:05,166
Traditionally you

370
00:18:05,956 --> 00:18:10,086
And in Swift, since you have

371
00:18:10,086 --> 00:18:13,796
at your disposition, you will

372
00:18:13,876 --> 00:18:15,346
traditional C locks.

373
00:18:15,986 --> 00:18:18,936
However, Swift assumes

374
00:18:18,936 --> 00:18:22,066
that is taught can be

375
00:18:22,256 --> 00:18:24,276
with a mutex or with a lock.

376
00:18:24,656 --> 00:18:26,366
So we really discourage you

377
00:18:26,366 --> 00:18:28,906
from using these kind

378
00:18:32,056 --> 00:18:37,466
If you want to a traditional

379
00:18:37,466 --> 00:18:41,326
is Foundation.Lock, because

380
00:18:41,326 --> 00:18:44,876
based C locks, it's a class,

381
00:18:44,916 --> 00:18:46,766
of the problems I

382
00:18:46,766 --> 00:18:49,966
However, suddenly that means

383
00:18:49,966 --> 00:18:51,496
that you're locating

384
00:18:51,686 --> 00:18:53,466
which may be undesirable

385
00:18:54,186 --> 00:18:56,716
And if you want something

386
00:18:56,716 --> 00:19:00,096
like the locks that you have

387
00:18:56,716 --> 00:19:00,096
like the locks that you have

388
00:19:00,096 --> 00:19:04,236
into Objective-C and introduce

389
00:19:04,236 --> 00:19:06,236
that has your lock as an ivar.

390
00:19:07,626 --> 00:19:10,486
And then you will expose

391
00:19:10,576 --> 00:19:14,246
and a try lock if you need it

392
00:19:14,246 --> 00:19:18,856
to call from Swift when you

393
00:19:20,406 --> 00:19:24,556
You will notice on that slide

394
00:19:24,816 --> 00:19:26,926
It's a new API that

395
00:19:26,926 --> 00:19:29,676
It's not prone to

396
00:19:30,006 --> 00:19:33,566
It doesn't spin, unlike the

397
00:19:34,536 --> 00:19:38,026
It's most important

398
00:19:38,676 --> 00:19:43,106
That being said, this is a GCD

399
00:19:43,106 --> 00:19:46,806
to do is to use dispatch queues

400
00:19:47,996 --> 00:19:50,946
The first reason why is that

401
00:19:50,946 --> 00:19:54,566
to misuse than a

402
00:19:55,046 --> 00:19:57,746
Your code will run

403
00:19:57,746 --> 00:20:00,036
which means that you

404
00:19:57,746 --> 00:20:00,036
which means that you

405
00:20:01,106 --> 00:20:03,916
The other thing is that

406
00:20:03,916 --> 00:20:06,976
integrated with the run time

407
00:20:08,596 --> 00:20:12,066
So how do we use

408
00:20:12,286 --> 00:20:15,196
I will walk you through

409
00:20:15,376 --> 00:20:17,966
of implementing an

410
00:20:19,106 --> 00:20:23,926
So here we have this object

411
00:20:24,426 --> 00:20:26,816
that we want to access

412
00:20:26,876 --> 00:20:29,666
We will use a queue

413
00:20:30,816 --> 00:20:33,406
How do we write our

414
00:20:34,626 --> 00:20:35,456
The getter is just

415
00:20:35,456 --> 00:20:38,976
about returning this

416
00:20:40,056 --> 00:20:41,536
It gives us mutual exclusion.

417
00:20:41,746 --> 00:20:43,086
Matt talked about this earlier.

418
00:20:43,086 --> 00:20:45,866
And the setter is as simple.

419
00:20:46,086 --> 00:20:49,176
You will just set your new

420
00:20:49,266 --> 00:20:50,546
of sync and your queue.

421
00:20:51,806 --> 00:20:55,096
This pattern is pretty simple,

422
00:20:55,176 --> 00:20:59,686
to products significantly

423
00:21:00,236 --> 00:21:02,306
I told you that queues

424
00:21:02,306 --> 00:21:04,786
with your debugging tools.

425
00:21:04,786 --> 00:21:06,606
They also have more features.

426
00:21:07,166 --> 00:21:10,226
And new in this release, we

427
00:21:11,526 --> 00:21:14,296
It lets you express that you

428
00:21:14,616 --> 00:21:17,796
that really need to hang

429
00:21:18,366 --> 00:21:20,566
and you had that this way.

430
00:21:22,126 --> 00:21:24,296
A dispatch precondition

431
00:21:25,376 --> 00:21:27,586
Sometimes the opposite

432
00:21:27,756 --> 00:21:31,536
You want to make sure that a

433
00:21:31,536 --> 00:21:34,336
on that queue, because you

434
00:21:34,336 --> 00:21:38,556
with that queue, and you express

435
00:21:39,446 --> 00:21:40,386
that you're not in the queue.

436
00:21:41,676 --> 00:21:45,606
So that's about synchronization,

437
00:21:47,176 --> 00:21:49,846
And as Matt said

438
00:21:49,846 --> 00:21:52,696
if you can just organize

439
00:21:52,696 --> 00:21:54,196
that your passing

440
00:21:54,196 --> 00:21:56,376
that don't need synchronization

441
00:21:57,026 --> 00:22:00,396
However, in real life code, you

442
00:21:57,026 --> 00:22:00,396
However, in real life code, you

443
00:22:00,396 --> 00:22:02,076
from simple, obvious subsystems.

444
00:22:02,876 --> 00:22:06,346
What that means is that

445
00:22:06,346 --> 00:22:08,726
reference in these

446
00:22:08,726 --> 00:22:12,646
of them actually

447
00:22:14,166 --> 00:22:18,336
I will now walk you through

448
00:22:19,046 --> 00:22:22,116
that will help you get

449
00:22:22,116 --> 00:22:25,516
up with weird crashes that

450
00:22:27,356 --> 00:22:31,666
Your state machine starts

451
00:22:31,996 --> 00:22:33,916
Setup is about creating

452
00:22:34,106 --> 00:22:42,166
and giving it the property you

453
00:22:42,166 --> 00:22:45,066
Second, you will want

454
00:22:45,526 --> 00:22:48,306
What that means is that you

455
00:22:48,306 --> 00:22:49,826
known to other subsystems.

456
00:22:50,076 --> 00:22:53,386
You start using it in

457
00:22:53,386 --> 00:22:54,956
in performance duties.

458
00:22:56,306 --> 00:22:57,666
And then the hard part starts.

459
00:22:57,666 --> 00:22:59,166
You want to get rid

460
00:22:59,516 --> 00:23:02,356
And so the third

461
00:22:59,516 --> 00:23:02,356
And so the third

462
00:23:05,096 --> 00:23:09,566
Invalidation is about making

463
00:23:09,566 --> 00:23:12,486
all your subsystems know that

464
00:23:12,946 --> 00:23:15,506
so that, fourth, it

465
00:23:16,086 --> 00:23:17,236
So let's look back.

466
00:23:17,806 --> 00:23:21,626
Setup, activation,

467
00:23:22,306 --> 00:23:29,076
This is quite abstract,

468
00:23:29,076 --> 00:23:31,996
through a more concrete example

469
00:23:32,626 --> 00:23:35,956
Let's go back to the application

470
00:23:36,636 --> 00:23:39,306
and focus on two

471
00:23:40,546 --> 00:23:42,916
First, we have our

472
00:23:43,246 --> 00:23:48,166
which will handle stuff such

473
00:23:48,396 --> 00:23:52,246
And I will assume that you

474
00:23:52,246 --> 00:23:55,736
of state changes in your

475
00:23:55,736 --> 00:23:58,316
for example, for our

476
00:23:58,706 --> 00:24:00,756
when it starts performing

477
00:23:58,706 --> 00:24:00,756
when it starts performing

478
00:24:00,756 --> 00:24:03,706
we present a visual

479
00:24:04,636 --> 00:24:08,986
And then when the data transform

480
00:24:08,986 --> 00:24:10,626
that visual indication

481
00:24:11,766 --> 00:24:15,196
So how do we implement

482
00:24:16,256 --> 00:24:19,416
So we remember the

483
00:24:19,566 --> 00:24:23,536
Setup is about you picking

484
00:24:23,626 --> 00:24:26,096
for your code, and the

485
00:24:26,196 --> 00:24:27,536
That's really up to you.

486
00:24:28,886 --> 00:24:31,486
Then we'll want to

487
00:24:32,156 --> 00:24:34,026
and that's activation.

488
00:24:34,146 --> 00:24:35,036
We activate it.

489
00:24:35,526 --> 00:24:36,986
What does that mean

490
00:24:37,706 --> 00:24:38,726
What that means is that we want

491
00:24:38,726 --> 00:24:41,556
to start receiving these

492
00:24:41,626 --> 00:24:44,266
state changes notifications,

493
00:24:44,266 --> 00:24:48,686
with that subsystem, and

494
00:24:48,686 --> 00:24:49,936
to be received on

495
00:24:49,936 --> 00:24:54,806
We're doing UI we want to

496
00:24:55,026 --> 00:24:58,706
Now that it's activated,

497
00:24:59,046 --> 00:24:59,956
That you want to do.

498
00:24:59,956 --> 00:25:00,946
That's your animation.

499
00:24:59,956 --> 00:25:00,946
That's your animation.

500
00:25:00,946 --> 00:25:04,686
That's your very nice

501
00:25:06,016 --> 00:25:08,146
But then, there are

502
00:25:08,146 --> 00:25:10,296
that maybe don't need

503
00:25:10,476 --> 00:25:13,606
or that maybe don't use the

504
00:25:13,606 --> 00:25:17,326
and you want to reclaim the

505
00:25:17,356 --> 00:25:20,026
and you want to get rid of it.

506
00:25:20,246 --> 00:25:22,766
It's very tempting

507
00:25:23,006 --> 00:25:25,216
the main thread is

508
00:25:25,216 --> 00:25:27,156
that really owns

509
00:25:27,156 --> 00:25:31,856
so I will get rid of it

510
00:25:32,306 --> 00:25:33,996
and register it from

511
00:25:33,996 --> 00:25:35,136
and hope for the best.

512
00:25:36,286 --> 00:25:38,276
That doesn't work,

513
00:25:38,406 --> 00:25:40,436
through two examples of why.

514
00:25:41,696 --> 00:25:43,906
So let's step back a bit.

515
00:25:44,356 --> 00:25:47,136
Our BusyController is

516
00:25:47,136 --> 00:25:49,526
from the main queue and

517
00:25:50,396 --> 00:25:52,246
However, when we registered it

518
00:25:52,716 --> 00:25:56,036
with the data transform

519
00:25:56,336 --> 00:25:59,116
that reference was taken

520
00:25:59,326 --> 00:26:02,656
onto this object, which means

521
00:25:59,326 --> 00:26:02,656
onto this object, which means

522
00:26:02,656 --> 00:26:05,106
of the reference that

523
00:26:06,696 --> 00:26:10,906
there's still one left, which

524
00:26:10,906 --> 00:26:13,016
which means that it

525
00:26:13,016 --> 00:26:14,336
it doesn't get collected,

526
00:26:14,336 --> 00:26:17,486
and you end up with

527
00:26:18,916 --> 00:26:21,506
However, you're very

528
00:26:21,546 --> 00:26:23,186
and you know how to fix that.

529
00:26:23,186 --> 00:26:26,106
Weak references, and I

530
00:26:26,936 --> 00:26:28,476
However, that's not

531
00:26:29,186 --> 00:26:33,116
because this is not really

532
00:26:33,566 --> 00:26:36,186
The graph object is

533
00:26:36,886 --> 00:26:39,626
It's not uncommon to have

534
00:26:39,626 --> 00:26:41,316
and a whole bunch

535
00:26:41,756 --> 00:26:46,986
such as this octopus

536
00:26:48,726 --> 00:26:50,806
We will continue getting rid

537
00:26:50,806 --> 00:26:52,326
of that reference

538
00:26:52,326 --> 00:26:55,196
And unlike before, this

539
00:26:55,196 --> 00:26:58,166
because this octopus object

540
00:26:59,216 --> 00:27:02,896
But then, if we get rid of that

541
00:26:59,216 --> 00:27:02,896
But then, if we get rid of that

542
00:27:02,896 --> 00:27:06,626
of the data transform

543
00:27:06,866 --> 00:27:09,416
It will get rid of that

544
00:27:09,416 --> 00:27:12,276
on the BusyController,

545
00:27:12,276 --> 00:27:16,456
will run beyond discretion,

546
00:27:17,506 --> 00:27:20,306
And then you have a problem,

547
00:27:20,306 --> 00:27:22,516
that to do that you

548
00:27:22,516 --> 00:27:25,376
with the dispatch queue that

549
00:27:25,996 --> 00:27:34,016
And you guessed it, we

550
00:27:34,016 --> 00:27:36,596
Actually, that bug is so common

551
00:27:37,276 --> 00:27:40,826
that we've made it an

552
00:27:40,826 --> 00:27:48,386
If you run that code on the

553
00:27:48,836 --> 00:27:52,066
and on OS X or in the simulator,

554
00:27:52,416 --> 00:27:55,576
the crash report you get

555
00:27:55,576 --> 00:27:57,526
application specific information

556
00:27:57,766 --> 00:28:00,636
that actually points you toward

557
00:27:57,766 --> 00:28:00,636
that actually points you toward

558
00:28:00,846 --> 00:28:02,116
so that you can fix it easily.

559
00:28:03,086 --> 00:28:05,346
Okay, so now we know

560
00:28:05,346 --> 00:28:06,646
to unregister from deinit.

561
00:28:06,786 --> 00:28:09,866
How do we fix that?

562
00:28:10,076 --> 00:28:14,056
We fix that by having our

563
00:28:14,056 --> 00:28:15,836
be an explicit function call.

564
00:28:16,256 --> 00:28:20,626
And under this invalidation,

565
00:28:23,516 --> 00:28:28,026
Also, since we have

566
00:28:28,136 --> 00:28:30,056
because this object,

567
00:28:30,056 --> 00:28:32,626
really should be managed from

568
00:28:32,626 --> 00:28:35,466
to make sure that users of

569
00:28:35,966 --> 00:28:37,986
So you will want to

570
00:28:37,986 --> 00:28:40,426
that this only happens

571
00:28:40,426 --> 00:28:42,246
or the main queue, even.

572
00:28:42,686 --> 00:28:46,786
But that's not quite it.

573
00:28:47,496 --> 00:28:48,976
We have a last problem.

574
00:28:49,536 --> 00:28:52,636
Remember, this all

575
00:28:53,546 --> 00:28:56,626
and you have this subsystem,

576
00:28:56,866 --> 00:29:00,006
who is sending you

577
00:28:56,866 --> 00:29:00,006
who is sending you

578
00:29:00,766 --> 00:29:02,816
and you may have some

579
00:29:02,816 --> 00:29:04,046
at the time you're invalidating.

580
00:29:04,536 --> 00:29:05,536
How do we resolve that?

581
00:29:06,266 --> 00:29:10,346
Well, you want to track

582
00:29:11,156 --> 00:29:12,016
And what does that mean?

583
00:29:13,166 --> 00:29:14,486
Well, just what it is.

584
00:29:14,926 --> 00:29:18,776
You want to track invalidation,

585
00:29:18,846 --> 00:29:21,036
in your object, and you

586
00:29:21,996 --> 00:29:26,736
At the same time, let's

587
00:29:27,106 --> 00:29:28,946
and make sure, enforce,

588
00:29:29,026 --> 00:29:30,756
that before your

589
00:29:30,756 --> 00:29:32,556
it has been properly

590
00:29:32,556 --> 00:29:33,836
It will help you find bugs.

591
00:29:35,726 --> 00:29:36,786
Why is it interesting?

592
00:29:37,026 --> 00:29:41,976
Because now, in your code

593
00:29:41,976 --> 00:29:44,276
for the state transitions,

594
00:29:44,276 --> 00:29:46,536
that the object was invalidated

595
00:29:46,536 --> 00:29:48,756
and actually drop the

596
00:29:48,756 --> 00:29:54,056
and update the UI in a

597
00:29:54,266 --> 00:29:56,866
Okay, that was quite

598
00:29:57,536 --> 00:30:00,406
However, I hope that you

599
00:29:57,536 --> 00:30:00,406
However, I hope that you

600
00:30:00,406 --> 00:30:03,476
at your applications and your

601
00:30:03,476 --> 00:30:06,346
where this pattern will help

602
00:30:06,346 --> 00:30:08,686
of your code, and

603
00:30:09,586 --> 00:30:12,886
It should also not

604
00:30:12,926 --> 00:30:18,176
given that we're giving you

605
00:30:18,236 --> 00:30:21,476
whose purpose in life is

606
00:30:21,476 --> 00:30:23,486
follow exactly the same pattern.

607
00:30:25,176 --> 00:30:33,346
So let's look at the GCD

608
00:30:34,716 --> 00:30:37,436
So we remember the

609
00:30:37,886 --> 00:30:40,586
Setup for dispatch objects

610
00:30:40,586 --> 00:30:43,326
when you build the object and

611
00:30:43,576 --> 00:30:46,456
Matt already showed labels

612
00:30:46,546 --> 00:30:50,726
And here, we also have

613
00:30:51,026 --> 00:30:53,756
where we monitor all the

614
00:30:54,716 --> 00:30:56,906
Sources also have handlers,

615
00:30:57,436 --> 00:30:59,706
and the event handler

616
00:30:59,706 --> 00:31:03,656
that will run when the resource

617
00:30:59,706 --> 00:31:03,656
that will run when the resource

618
00:31:03,656 --> 00:31:04,856
and that is events pending.

619
00:31:05,786 --> 00:31:08,406
For the resource that

620
00:31:08,406 --> 00:31:10,346
that's when there is

621
00:31:10,956 --> 00:31:14,746
Once you've set up your

622
00:31:14,746 --> 00:31:19,486
you want to use it

623
00:31:20,936 --> 00:31:22,576
New in this release, we've made

624
00:31:22,876 --> 00:31:26,866
that step an API

625
00:31:27,816 --> 00:31:30,016
It used to be that

626
00:31:30,106 --> 00:31:32,766
the initial resume had

627
00:31:33,326 --> 00:31:35,756
We've actually now

628
00:31:36,296 --> 00:31:38,836
and activation be two

629
00:31:39,596 --> 00:31:43,056
Also in resume activate can

630
00:31:43,096 --> 00:31:44,896
and it only acts once.

631
00:31:46,676 --> 00:31:49,046
The contract however is that

632
00:31:49,046 --> 00:31:51,876
you won't mutate the properties

633
00:31:54,196 --> 00:31:59,766
We've also found that creating

634
00:32:00,186 --> 00:32:02,596
creating them initially

635
00:32:03,006 --> 00:32:06,646
and we've added a new attribute

636
00:32:06,646 --> 00:32:09,456
and is actually named

637
00:32:10,316 --> 00:32:13,026
Once the queue is created, you

638
00:32:13,346 --> 00:32:18,246
configure it the way you like,

639
00:32:19,066 --> 00:32:22,746
Many of the dispatch objects

640
00:32:22,746 --> 00:32:25,076
invalidation, such

641
00:32:25,396 --> 00:32:27,856
because they become

642
00:32:27,856 --> 00:32:28,966
of you stopping using them.

643
00:32:30,286 --> 00:32:32,236
However, the story is quite

644
00:32:32,236 --> 00:32:35,706
and sources have an

645
00:32:35,876 --> 00:32:36,686
It's called Cancel.

646
00:32:37,756 --> 00:32:41,856
Cancellation in sources does

647
00:32:41,856 --> 00:32:43,676
which is that you

648
00:32:43,866 --> 00:32:44,876
for the thing you're monitoring.

649
00:32:45,956 --> 00:32:48,096
But it's not only that it does.

650
00:32:48,446 --> 00:32:50,616
The second thing it

651
00:32:50,616 --> 00:32:54,656
up a cancellation handler on

652
00:32:55,856 --> 00:32:58,736
it will run on the target of

653
00:33:00,226 --> 00:33:04,496
It is actually where you want

654
00:33:04,536 --> 00:33:07,396
that you're monitoring,

655
00:33:07,396 --> 00:33:08,156
frame memory.

656
00:33:08,736 --> 00:33:14,426
Last, but not least,

657
00:33:14,426 --> 00:33:16,576
when your handlers

658
00:33:17,546 --> 00:33:19,196
Handlers are closures.

659
00:33:19,506 --> 00:33:22,276
They capture via subjects

660
00:33:23,036 --> 00:33:24,766
They can be part of

661
00:33:25,336 --> 00:33:30,956
Calling cancellation is how you

662
00:33:31,606 --> 00:33:40,046
It's why it's very important

663
00:33:40,696 --> 00:33:46,556
So you remember a bit earlier,

664
00:33:46,556 --> 00:33:48,856
in our code, because

665
00:33:49,616 --> 00:33:53,086
that concurrently used

666
00:33:53,166 --> 00:33:54,616
in a way that you can expect.

667
00:33:56,096 --> 00:33:57,396
Dispatch is no different,

668
00:33:57,796 --> 00:34:00,556
and expects that at the time

669
00:33:57,796 --> 00:34:00,556
and expects that at the time

670
00:34:00,556 --> 00:34:01,666
it's in a different state,

671
00:34:02,846 --> 00:34:05,386
and dispatch expects

672
00:34:05,926 --> 00:34:08,386
First, that your

673
00:34:09,065 --> 00:34:13,036
And second, that they

674
00:34:13,936 --> 00:34:17,366
The reason why is that being

675
00:34:17,436 --> 00:34:20,565
that you as a developer

676
00:34:20,565 --> 00:34:23,716
to run the code associated with

677
00:34:23,775 --> 00:34:24,856
to get rid of the object.

678
00:34:31,045 --> 00:34:37,686
Okay. So we've seen today how

679
00:34:37,686 --> 00:34:42,005
in terms of data flows and how

680
00:34:42,005 --> 00:34:45,565
into fairly independent

681
00:34:46,406 --> 00:34:49,065
for communication purposes.

682
00:34:49,616 --> 00:34:52,926
If you need to synchronize

683
00:34:53,606 --> 00:34:58,026
we also showed you how you can

684
00:34:58,246 --> 00:35:00,656
And finally, when you

685
00:34:58,246 --> 00:35:00,656
And finally, when you

686
00:35:01,016 --> 00:35:05,056
in a very heavily concurrent

687
00:35:05,056 --> 00:35:07,386
and invalidation to

688
00:35:08,726 --> 00:35:14,436
Here is a link that will show

689
00:35:14,436 --> 00:35:15,016
with this talk.

690
00:35:15,976 --> 00:35:19,856
And a few related sessions

691
00:35:19,856 --> 00:35:22,676
with dispatch, you

692
00:35:22,676 --> 00:35:24,686
because they are

693
00:35:25,796 --> 00:35:26,526
And that's it.

694
00:35:26,716 --> 00:35:29,436
It was Concurrency with GCD.

695
00:35:30,508 --> 00:35:32,508
[ Applause ]
