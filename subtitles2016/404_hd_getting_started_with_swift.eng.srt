1
00:00:07,516 --> 00:00:18,516
[ Music ]

2
00:00:19,516 --> 00:00:22,566
[ Applause ]

3
00:00:23,066 --> 00:00:26,586
&gt;&gt; Hello, and welcome to

4
00:00:26,586 --> 00:00:28,956
I'm Dave Addey, and together

5
00:00:28,956 --> 00:00:31,526
and Alex, I'd like to

6
00:00:31,526 --> 00:00:32,826
of the Swift Programming

7
00:00:33,836 --> 00:00:36,936
In the next 60 minutes you'll

8
00:00:36,936 --> 00:00:38,926
to be able to read

9
00:00:38,926 --> 00:00:42,186
to start writing it, too.

10
00:00:42,446 --> 00:00:45,226
So let's start by taking a

11
00:00:45,286 --> 00:00:48,626
of the language, and here's

12
00:00:48,996 --> 00:00:51,196
I've written a constant,

13
00:00:51,826 --> 00:00:54,016
it's called language,

14
00:00:54,076 --> 00:00:57,416
And this colon in the middle,

15
00:00:57,596 --> 00:00:58,866
this means is of type.

16
00:00:59,206 --> 00:01:02,836
So language is of type string,

17
00:00:59,206 --> 00:01:02,836
So language is of type string,

18
00:01:02,836 --> 00:01:05,886
of Swift, using a string

19
00:01:06,076 --> 00:01:06,856
Let's make a few more.

20
00:01:07,426 --> 00:01:09,526
Let's have an integer

21
00:01:09,636 --> 00:01:11,546
We'll that to 2014.

22
00:01:11,546 --> 00:01:13,196
And a Boolean called isAwesome.

23
00:01:13,546 --> 00:01:15,986
And we'll set that to true.

24
00:01:16,126 --> 00:01:19,276
Now, you might notice that none

25
00:01:19,566 --> 00:01:21,456
The language's name

26
00:01:21,706 --> 00:01:22,936
nor is the year it

27
00:01:23,816 --> 00:01:26,186
And two years on,

28
00:01:26,186 --> 00:01:28,166
so that can probably

29
00:01:29,046 --> 00:01:30,846
And this is the general

30
00:01:31,386 --> 00:01:32,786
If something doesn't

31
00:01:32,976 --> 00:01:35,726
we declare it as a constant.

32
00:01:35,726 --> 00:01:37,876
Now, you might also

33
00:01:38,686 --> 00:01:41,656
Constants and variables tend to

34
00:01:42,076 --> 00:01:45,986
and types, such as String, Ints

35
00:01:47,306 --> 00:01:48,876
Now, if we look at the

36
00:01:49,406 --> 00:01:52,476
it's pretty obvious, actually,

37
00:01:52,956 --> 00:01:54,306
an integer and a Boolean,

38
00:01:54,836 --> 00:01:58,586
and where this is the case

39
00:01:58,586 --> 00:02:00,346
We don't actually need

40
00:01:58,586 --> 00:02:00,346
We don't actually need

41
00:02:00,956 --> 00:02:03,126
So you still get things

42
00:02:03,126 --> 00:02:04,906
but you don't have to

43
00:02:06,326 --> 00:02:07,746
So that's some constants.

44
00:02:08,015 --> 00:02:08,856
What about variables?

45
00:02:08,856 --> 00:02:10,606
Things do sometimes

46
00:02:10,795 --> 00:02:12,576
So here's a variable

47
00:02:12,936 --> 00:02:14,726
and it's for the

48
00:02:14,726 --> 00:02:15,526
This has changed.

49
00:02:16,116 --> 00:02:17,926
So let's bring it

50
00:02:19,376 --> 00:02:21,456
Now, if I try to do

51
00:02:22,036 --> 00:02:25,276
if I try to set isAwesome to

52
00:02:25,276 --> 00:02:27,166
that it was an error,

53
00:02:29,266 --> 00:02:31,636
So a common thing to want

54
00:02:31,636 --> 00:02:33,196
to build strings

55
00:02:33,736 --> 00:02:36,146
We could do this by

56
00:02:36,146 --> 00:02:39,136
as shown here, but Swift

57
00:02:39,626 --> 00:02:42,216
known as string interpolation,

58
00:02:42,606 --> 00:02:46,096
And we can put strings and other

59
00:02:46,426 --> 00:02:49,296
by wrapping them in parentheses

60
00:02:49,596 --> 00:02:51,756
Here we're making the

61
00:02:53,246 --> 00:02:54,986
We're not just limited

62
00:02:54,986 --> 00:02:56,426
We can add other values as well,

63
00:02:56,426 --> 00:02:58,456
such as integers here

64
00:02:59,146 --> 00:03:01,696
And we could even add

65
00:02:59,146 --> 00:03:01,696
And we could even add

66
00:03:01,696 --> 00:03:03,536
We can add year +

67
00:03:03,536 --> 00:03:05,176
that would work for

68
00:03:06,376 --> 00:03:09,426
Now, strings in Swift are

69
00:03:09,866 --> 00:03:12,416
They're just as happy

70
00:03:12,416 --> 00:03:13,876
with dog, cows or with flags.

71
00:03:15,036 --> 00:03:18,086
And the same also

72
00:03:18,086 --> 00:03:19,106
and variables you create.

73
00:03:19,106 --> 00:03:21,646
You can use pretty much

74
00:03:21,646 --> 00:03:24,826
of your constants and variables.

75
00:03:24,826 --> 00:03:26,036
Talking of [inaudible]

76
00:03:26,036 --> 00:03:29,466
Swift does all the hard work

77
00:03:29,466 --> 00:03:30,946
to be an individual character,

78
00:03:31,396 --> 00:03:33,716
regardless of how your string

79
00:03:34,066 --> 00:03:35,176
or how it appears on screen.

80
00:03:35,716 --> 00:03:38,636
So here I have a

81
00:03:39,476 --> 00:03:43,206
You might think that this

82
00:03:43,206 --> 00:03:46,296
D, O, G, ?, !, dog face.

83
00:03:47,266 --> 00:03:48,096
But you would be wrong.

84
00:03:49,046 --> 00:03:50,966
There are five characters

85
00:03:51,786 --> 00:03:54,716
This is a special character

86
00:03:54,716 --> 00:03:56,126
mark, which is really,

87
00:03:56,126 --> 00:04:00,456
really good for expressing

88
00:03:56,126 --> 00:04:00,456
really good for expressing

89
00:04:00,456 --> 00:04:03,406
Now, if you don't believe me,

90
00:04:03,816 --> 00:04:06,216
Every string has a

91
00:04:06,336 --> 00:04:08,386
It gives us a collection of

92
00:04:08,386 --> 00:04:11,166
and we can access the count

93
00:04:11,476 --> 00:04:12,456
to see how many there are.

94
00:04:13,276 --> 00:04:14,716
If we pass that to

95
00:04:15,116 --> 00:04:17,386
we find out that we do,

96
00:04:18,245 --> 00:04:21,636
But if you still don't

97
00:04:21,636 --> 00:04:24,396
over each of those characters

98
00:04:24,396 --> 00:04:26,526
and print each one of

99
00:04:26,876 --> 00:04:29,076
and you can see we do,

100
00:04:29,726 --> 00:04:30,626
D, O, G, ?!

101
00:04:31,136 --> 00:04:33,866
and dog face.

102
00:04:35,616 --> 00:04:39,456
Now, in addition to all of these

103
00:04:39,456 --> 00:04:41,096
some built-in collections.

104
00:04:41,516 --> 00:04:43,136
We have array and dictionary.

105
00:04:43,656 --> 00:04:45,586
You might know dictionary

106
00:04:45,586 --> 00:04:46,976
or map table from

107
00:04:47,856 --> 00:04:49,566
And the easiest way

108
00:04:49,616 --> 00:04:51,226
or a dictionary is

109
00:04:51,306 --> 00:04:53,706
This is an array literal

110
00:04:53,706 --> 00:04:55,676
on the outside and

111
00:04:56,756 --> 00:04:59,806
Here we have an array of

112
00:05:01,066 --> 00:05:02,356
Dictionaries look very similar.

113
00:05:02,826 --> 00:05:04,866
Their keys and values are

114
00:05:05,336 --> 00:05:08,096
Here we have a dictionary whose

115
00:05:08,556 --> 00:05:09,816
and whose values are integers.

116
00:05:11,716 --> 00:05:15,336
Now, you might notice from

117
00:05:15,596 --> 00:05:17,516
that they're all the same

118
00:05:18,356 --> 00:05:20,956
It wouldn't make sense to insert

119
00:05:21,326 --> 00:05:24,096
to have an integer or

120
00:05:24,096 --> 00:05:25,676
That would be just weird.

121
00:05:26,446 --> 00:05:28,676
For names we always

122
00:05:28,676 --> 00:05:30,736
and in Swift we can

123
00:05:30,736 --> 00:05:34,156
We can say we want an array

124
00:05:34,156 --> 00:05:35,296
as we get anything out of it,

125
00:05:35,296 --> 00:05:37,446
we can do string

126
00:05:37,946 --> 00:05:39,066
So this is how we write that.

127
00:05:39,066 --> 00:05:40,706
This is how we write

128
00:05:40,706 --> 00:05:42,316
a string with square

129
00:05:43,606 --> 00:05:46,626
But as we saw earlier

130
00:05:46,626 --> 00:05:49,076
from the right hand side

131
00:05:49,726 --> 00:05:52,336
Swift works it out for us,

132
00:05:52,336 --> 00:05:53,936
We actually don't need

133
00:05:54,386 --> 00:05:56,556
It's clear we want

134
00:05:57,976 --> 00:05:58,976
The same goes for

135
00:05:59,336 --> 00:06:02,276
Here it's clear we want string

136
00:05:59,336 --> 00:06:02,276
Here it's clear we want string

137
00:06:02,516 --> 00:06:04,206
so Swift can infer

138
00:06:04,356 --> 00:06:08,346
but everything is

139
00:06:08,526 --> 00:06:11,486
Swift has all of the loops you

140
00:06:11,826 --> 00:06:14,476
We have a while loop that checks

141
00:06:14,476 --> 00:06:15,396
executing its body.

142
00:06:16,046 --> 00:06:17,086
And a repeat-while loop,

143
00:06:17,486 --> 00:06:19,836
which executes its body once

144
00:06:19,836 --> 00:06:20,976
to see if it should continue.

145
00:06:21,506 --> 00:06:25,096
And as we saw earlier, we have

146
00:06:25,096 --> 00:06:26,556
to iterate over the

147
00:06:27,476 --> 00:06:30,466
But that's not the only thing

148
00:06:31,546 --> 00:06:33,696
We can use it to

149
00:06:34,336 --> 00:06:37,026
Here we have a range that

150
00:06:37,026 --> 00:06:39,206
and includes most of those

151
00:06:39,206 --> 00:06:41,376
to print five entries

152
00:06:42,186 --> 00:06:44,786
We write this as 1...5.

153
00:06:45,056 --> 00:06:46,216
That is called a closed range

154
00:06:46,216 --> 00:06:47,626
because it includes

155
00:06:48,726 --> 00:06:51,646
However, sometimes it's useful

156
00:06:51,646 --> 00:06:53,856
up to one less than

157
00:06:54,586 --> 00:06:55,886
Here's an example of

158
00:06:56,806 --> 00:06:58,986
I have an array of

159
00:06:58,986 --> 00:06:59,966
to print the first five.

160
00:07:00,766 --> 00:07:02,726
Now, because array

161
00:07:02,726 --> 00:07:04,986
I actually want indices

162
00:07:05,726 --> 00:07:08,006
So for that we can use the

163
00:07:08,406 --> 00:07:10,926
..&lt; because it runs the one less

164
00:07:10,926 --> 00:07:12,576
than the final number,

165
00:07:14,696 --> 00:07:16,756
We can use a for-in

166
00:07:16,756 --> 00:07:18,616
Here we're printing

167
00:07:18,616 --> 00:07:19,656
of the names in our array.

168
00:07:20,486 --> 00:07:22,176
And we can also use

169
00:07:23,056 --> 00:07:25,726
Now, note here that we're

170
00:07:25,726 --> 00:07:28,676
and the value, the name and

171
00:07:29,596 --> 00:07:32,296
And this is an example of

172
00:07:32,296 --> 00:07:34,626
which lets you combine those

173
00:07:34,626 --> 00:07:35,646
and use them at the same time.

174
00:07:35,736 --> 00:07:37,816
And we'll see another

175
00:07:38,496 --> 00:07:39,886
And it makes for

176
00:07:40,086 --> 00:07:41,286
when iterating over

177
00:07:43,276 --> 00:07:45,466
So how would we modify

178
00:07:46,456 --> 00:07:49,096
Well, here's my packing

179
00:07:49,266 --> 00:07:51,576
I've declared it as a

180
00:07:52,276 --> 00:07:54,896
but I've included the

181
00:07:55,526 --> 00:08:01,796
Now, at WWDC 2014 I

182
00:07:55,526 --> 00:08:01,796
Now, at WWDC 2014 I

183
00:08:02,386 --> 00:08:05,536
and it was a nightmare, so I'm

184
00:08:06,286 --> 00:08:08,286
So let's check that

185
00:08:08,286 --> 00:08:09,906
in this array is

186
00:08:10,026 --> 00:08:12,716
After 2014, if I put it on

187
00:08:13,666 --> 00:08:15,066
We do this using a subscript,

188
00:08:15,476 --> 00:08:18,316
writing an index inside square

189
00:08:18,576 --> 00:08:19,756
and if we print this value,

190
00:08:19,876 --> 00:08:22,956
I have indeed remembered

191
00:08:23,186 --> 00:08:24,986
Socks and shoes will

192
00:08:24,986 --> 00:08:26,186
for a week of the conference.

193
00:08:26,186 --> 00:08:27,106
I'll need more things.

194
00:08:27,616 --> 00:08:28,886
So let's append a new item.

195
00:08:28,946 --> 00:08:31,186
Let's append some trousers

196
00:08:31,186 --> 00:08:32,916
which we do using

197
00:08:33,405 --> 00:08:35,616
But there's a problem here.

198
00:08:36,816 --> 00:08:39,726
The conference is in America and

199
00:08:40,346 --> 00:08:42,535
they call them pants,

200
00:08:42,676 --> 00:08:44,316
to cause all kinds of confusion.

201
00:08:44,966 --> 00:08:46,696
So let's change a

202
00:08:47,226 --> 00:08:48,926
Let's change this

203
00:08:49,246 --> 00:08:50,986
Again, we use a subscript

204
00:08:51,146 --> 00:08:52,566
to change the item in index two.

205
00:08:52,936 --> 00:08:54,206
Jeans are called the

206
00:08:54,206 --> 00:08:55,326
so this shouldn't

207
00:08:57,406 --> 00:08:59,016
Now, the conference

208
00:08:59,166 --> 00:09:00,756
where it is always

209
00:08:59,166 --> 00:09:00,756
where it is always

210
00:09:01,436 --> 00:09:02,806
so let's add a few more items.

211
00:09:02,806 --> 00:09:06,506
Let's add some shorts, some

212
00:09:07,266 --> 00:09:10,346
We can do this using the append

213
00:09:10,346 --> 00:09:12,566
in a compatible array,

214
00:09:13,186 --> 00:09:16,466
and they all get

215
00:09:16,526 --> 00:09:19,346
That said, whilst the

216
00:09:20,006 --> 00:09:23,216
it's in San Francisco, where

217
00:09:23,956 --> 00:09:26,596
So maybe let's change those

218
00:09:26,596 --> 00:09:28,286
with a hoodie and

219
00:09:29,206 --> 00:09:31,656
We can do this by passing

220
00:09:32,076 --> 00:09:34,046
And note that we're changing

221
00:09:34,166 --> 00:09:37,766
this is still perfectly

222
00:09:38,006 --> 00:09:38,906
So what about a dictionary?

223
00:09:38,906 --> 00:09:40,036
Let's modify a dictionary.

224
00:09:40,656 --> 00:09:43,976
Well, here I have my ages

225
00:09:44,476 --> 00:09:47,346
I'd like to add somebody else

226
00:09:47,346 --> 00:09:50,556
by adding a value for a key

227
00:09:50,556 --> 00:09:51,136
a subscript.

228
00:09:51,356 --> 00:09:52,156
Here I've added Justyn.

229
00:09:52,726 --> 00:09:56,036
But thinking about it, it was

230
00:09:56,396 --> 00:09:57,676
so this value is now incorrect.

231
00:09:57,676 --> 00:09:59,956
I need to update it, which I

232
00:10:00,156 --> 00:10:02,896
I just assign a different

233
00:10:03,036 --> 00:10:04,216
and now my dictionary's correct.

234
00:10:06,716 --> 00:10:09,446
What if I want to retrieve

235
00:10:10,176 --> 00:10:13,546
What if I want to see if we have

236
00:10:13,546 --> 00:10:15,016
or perhaps for Daniel?

237
00:10:16,456 --> 00:10:18,996
Well, there might be a value in

238
00:10:18,996 --> 00:10:22,166
but there might not, and we

239
00:10:22,626 --> 00:10:24,296
and this is a great use case

240
00:10:24,296 --> 00:10:25,906
for a Swift feature

241
00:10:25,906 --> 00:10:28,916
If we tried this for Amy,

242
00:10:29,276 --> 00:10:31,576
we might expect a

243
00:10:31,736 --> 00:10:34,976
But if we tried it for Daryl,

244
00:10:34,976 --> 00:10:37,976
There's no value here for Daryl.

245
00:10:38,186 --> 00:10:38,886
Think of it like this.

246
00:10:40,046 --> 00:10:42,716
There either is a value in the

247
00:10:43,086 --> 00:10:46,466
that's for Amy, or there's

248
00:10:46,946 --> 00:10:47,756
as in the case of Daryl.

249
00:10:47,836 --> 00:10:51,716
So what we have here

250
00:10:52,336 --> 00:10:54,026
which we write as

251
00:10:54,736 --> 00:10:56,776
And the question mark means

252
00:10:57,176 --> 00:10:58,306
but there might not.

253
00:10:59,716 --> 00:11:02,096
Now, we can check to

254
00:10:59,716 --> 00:11:02,096
Now, we can check to

255
00:11:02,336 --> 00:11:03,686
by comparing it against nil.

256
00:11:03,686 --> 00:11:05,126
Nil is just a special way,

257
00:11:05,126 --> 00:11:06,926
a shorthand way of

258
00:11:07,456 --> 00:11:09,926
If we try this for

259
00:11:10,076 --> 00:11:12,536
we'd print the message.

260
00:11:12,536 --> 00:11:13,216
Age not found.

261
00:11:13,896 --> 00:11:16,646
If we try this for Amy,

262
00:11:16,946 --> 00:11:20,996
so it doesn't equal nil and

263
00:11:21,146 --> 00:11:23,416
Typically, however, we don't

264
00:11:23,416 --> 00:11:24,846
We actually want to

265
00:11:25,486 --> 00:11:28,526
and Swift has a really good

266
00:11:28,526 --> 00:11:31,216
which we write as if let.

267
00:11:31,256 --> 00:11:34,616
Now, this says here the

268
00:11:34,616 --> 00:11:38,826
for Amy, let a new constant

269
00:11:38,826 --> 00:11:42,006
And then we can use that

270
00:11:42,916 --> 00:11:45,256
And note that we use it

271
00:11:45,256 --> 00:11:46,356
It's not optional anymore.

272
00:11:47,416 --> 00:11:50,026
The if statements checks

273
00:11:50,216 --> 00:11:51,646
and gives us back

274
00:11:51,756 --> 00:11:53,396
that we can do integer

275
00:11:55,436 --> 00:11:57,696
So we've seen a few

276
00:11:57,986 --> 00:11:59,706
Here's another that

277
00:12:00,046 --> 00:12:03,116
There are two things to

278
00:12:04,096 --> 00:12:06,036
Firstly, we don't

279
00:12:06,036 --> 00:12:07,876
around the conditions so we can

280
00:12:09,066 --> 00:12:12,516
And secondly, we do add

281
00:12:12,516 --> 00:12:14,656
of the statement to make

282
00:12:14,656 --> 00:12:18,256
of code are going to be run.

283
00:12:18,306 --> 00:12:21,156
In addition to if, we also

284
00:12:21,566 --> 00:12:23,676
and this is useful for

285
00:12:23,676 --> 00:12:24,606
more powerful matches.

286
00:12:25,386 --> 00:12:28,176
This switches over the

287
00:12:28,176 --> 00:12:30,876
or a variable and matches

288
00:12:31,496 --> 00:12:34,386
So, for example, we can have

289
00:12:34,826 --> 00:12:36,826
where the value is

290
00:12:36,826 --> 00:12:39,156
to print a simple happy

291
00:12:40,256 --> 00:12:41,826
We can also match

292
00:12:42,396 --> 00:12:44,526
Here matching any value that

293
00:12:45,666 --> 00:12:48,886
And we can match more complex

294
00:12:49,136 --> 00:12:53,276
which says that a temporary

295
00:12:53,276 --> 00:12:54,386
value that we're

296
00:12:55,426 --> 00:12:58,956
check if it will divide

297
00:12:59,366 --> 00:13:01,646
use it to print a

298
00:12:59,366 --> 00:13:01,646
use it to print a

299
00:13:02,016 --> 00:13:04,436
for anyone who's

300
00:13:04,656 --> 00:13:06,036
or some other significant age.

301
00:13:06,586 --> 00:13:10,286
But there's a problem with

302
00:13:11,336 --> 00:13:13,626
What would happen if we wanted

303
00:13:13,626 --> 00:13:17,316
who was 41, or 97 or 56?

304
00:13:17,316 --> 00:13:20,046
Well, they wouldn't

305
00:13:20,386 --> 00:13:21,766
and that seems really

306
00:13:21,826 --> 00:13:25,026
especially on their birthday.

307
00:13:25,096 --> 00:13:26,406
Frankly, Swift helps

308
00:13:27,166 --> 00:13:29,896
Swift makes sure that every

309
00:13:29,896 --> 00:13:32,186
that you don't accidentally

310
00:13:32,186 --> 00:13:33,556
of the cases that

311
00:13:34,416 --> 00:13:36,986
And in this case we can

312
00:13:37,426 --> 00:13:40,666
which catches every other case

313
00:13:41,026 --> 00:13:45,876
and just says, Happy

314
00:13:45,876 --> 00:13:47,026
Here's another switch statement.

315
00:13:48,176 --> 00:13:52,066
This one takes a string value,

316
00:13:52,066 --> 00:13:54,776
that indicates whether that

317
00:13:55,496 --> 00:13:58,286
and we'll use both of these

318
00:13:58,286 --> 00:14:01,056
out an appropriate message to

319
00:13:58,286 --> 00:14:01,056
out an appropriate message to

320
00:14:01,056 --> 00:14:02,416
to log into a restricted area.

321
00:14:03,326 --> 00:14:06,496
And to do this we can

322
00:14:06,496 --> 00:14:09,746
at the same time using a tuple,

323
00:14:11,006 --> 00:14:12,496
So this means we can

324
00:14:12,496 --> 00:14:13,646
really interesting use cases,

325
00:14:13,646 --> 00:14:14,946
some really interesting

326
00:14:15,636 --> 00:14:17,616
We can have the case where

327
00:14:17,716 --> 00:14:19,936
and the password is

328
00:14:19,936 --> 00:14:21,286
to welcome back our

329
00:14:23,046 --> 00:14:26,206
Now, in the case of a guest we

330
00:14:26,206 --> 00:14:28,816
into the restricted area even

331
00:14:29,496 --> 00:14:31,246
and so we can ignore

332
00:14:31,466 --> 00:14:32,496
by writing an underscore,

333
00:14:33,406 --> 00:14:36,896
and this means just match

334
00:14:37,036 --> 00:14:39,896
For all other users we actually

335
00:14:39,896 --> 00:14:40,266
name is.

336
00:14:40,266 --> 00:14:41,546
We just care about the password.

337
00:14:41,996 --> 00:14:45,046
So we can ignore the user

338
00:14:45,476 --> 00:14:47,246
we've switched on

339
00:14:47,246 --> 00:14:48,456
with the password's validity.

340
00:14:49,056 --> 00:14:51,586
To do this we create a temporary

341
00:14:52,526 --> 00:14:55,456
and we then use the ternary

342
00:14:55,776 --> 00:14:57,476
that's the question

343
00:14:57,616 --> 00:15:01,336
to say if it's valid,

344
00:14:57,616 --> 00:15:01,336
to say if it's valid,

345
00:15:01,806 --> 00:15:03,586
otherwise, use this message.

346
00:15:04,896 --> 00:15:06,876
So let's run that through

347
00:15:06,876 --> 00:15:10,096
If we take our administrator,

348
00:15:10,436 --> 00:15:12,676
they get a special administrator

349
00:15:13,746 --> 00:15:15,216
If we try this for

350
00:15:15,216 --> 00:15:18,386
even though their password is

351
00:15:18,386 --> 00:15:19,466
you can't come in message.

352
00:15:19,886 --> 00:15:22,656
If we try it for Bob,

353
00:15:23,176 --> 00:15:24,856
he gets the welcome

354
00:15:25,436 --> 00:15:28,406
But if his password is not

355
00:15:30,436 --> 00:15:32,956
Now, there is one

356
00:15:33,226 --> 00:15:34,286
about this switch statement,

357
00:15:34,936 --> 00:15:37,426
and that's that it doesn't

358
00:15:37,706 --> 00:15:40,186
And the reason it doesn't

359
00:15:40,416 --> 00:15:42,566
It's already complete.

360
00:15:42,566 --> 00:15:46,206
If we take a look at

361
00:15:46,816 --> 00:15:49,626
this actually covers all

362
00:15:49,626 --> 00:15:51,026
that we haven't already

363
00:15:51,506 --> 00:15:53,556
and so the switch

364
00:15:53,556 --> 00:15:55,976
without needing a default.

365
00:15:56,086 --> 00:15:58,596
So those are some of the

366
00:15:59,086 --> 00:16:01,426
I'd now like to hand over to my

367
00:15:59,086 --> 00:16:01,426
I'd now like to hand over to my

368
00:16:01,426 --> 00:16:03,366
to functions and

369
00:16:05,016 --> 00:16:08,816
[ Applause ]

370
00:16:09,316 --> 00:16:09,546
&gt;&gt; All right.

371
00:16:09,756 --> 00:16:10,776
Thanks, Dave, as I was saying.

372
00:16:10,916 --> 00:16:12,226
Let's get started by looking

373
00:16:12,226 --> 00:16:13,706
at how you define a

374
00:16:14,356 --> 00:16:16,796
You define a function

375
00:16:17,166 --> 00:16:19,266
and you implement it

376
00:16:19,806 --> 00:16:22,276
Here we've defined a simple

377
00:16:22,586 --> 00:16:24,106
that prints a message

378
00:16:24,496 --> 00:16:27,476
And you call this message

379
00:16:27,996 --> 00:16:30,096
by writing its name,

380
00:16:30,606 --> 00:16:32,246
followed by an empty

381
00:16:32,946 --> 00:16:35,166
So let's add a parameter

382
00:16:35,166 --> 00:16:38,096
that indicates whether the

383
00:16:39,176 --> 00:16:41,656
You write the parameter's

384
00:16:41,656 --> 00:16:43,836
and the parameter's

385
00:16:43,836 --> 00:16:46,176
when you declare a

386
00:16:47,076 --> 00:16:48,866
Here we've added a

387
00:16:48,996 --> 00:16:49,906
which is of type Bool.

388
00:16:50,576 --> 00:16:52,036
And when you call the function,

389
00:16:52,036 --> 00:16:54,236
the parameter's name

390
00:16:54,236 --> 00:16:57,796
for the argument you pass in.

391
00:16:57,796 --> 00:17:00,356
Labeling your arguments

392
00:16:57,796 --> 00:17:00,356
Labeling your arguments

393
00:17:00,356 --> 00:17:03,196
and makes the purpose or

394
00:17:03,196 --> 00:17:06,086
In this case, if you left

395
00:17:06,415 --> 00:17:08,215
someone reading your

396
00:17:08,215 --> 00:17:10,846
that true just indicated whether

397
00:17:10,846 --> 00:17:11,376
at all.

398
00:17:13,215 --> 00:17:15,016
So you can shout a message,

399
00:17:15,016 --> 00:17:16,536
to send the message to.

400
00:17:16,536 --> 00:17:19,036
Let's add another parameter

401
00:17:19,036 --> 00:17:19,935
to someone in particular.

402
00:17:20,476 --> 00:17:23,306
So here we've added a

403
00:17:23,596 --> 00:17:24,596
which is of type string,

404
00:17:24,776 --> 00:17:26,455
and we've included

405
00:17:26,935 --> 00:17:28,926
in our message using

406
00:17:30,236 --> 00:17:32,456
And now when you call the

407
00:17:32,456 --> 00:17:33,406
in the recipient's name.

408
00:17:34,666 --> 00:17:37,046
Now, although the message

409
00:17:37,476 --> 00:17:39,446
it doesn't read very

410
00:17:40,246 --> 00:17:43,106
sendMessage recipient

411
00:17:44,046 --> 00:17:46,156
When you call a function, you

412
00:17:46,156 --> 00:17:49,256
In this case you'd like it to

413
00:17:49,256 --> 00:17:52,046
to Morgan, which forms a

414
00:17:52,596 --> 00:17:54,646
And you could do this

415
00:17:54,646 --> 00:17:56,686
of the parameter, which

416
00:17:56,686 --> 00:17:59,786
of the argument label, and this

417
00:17:59,786 --> 00:18:02,276
better when you call it,

418
00:17:59,786 --> 00:18:02,276
better when you call it,

419
00:18:03,076 --> 00:18:06,236
but it doesn't work so well

420
00:18:07,286 --> 00:18:09,816
Inside the body you really

421
00:18:09,816 --> 00:18:13,316
not a preposition, hey

422
00:18:14,696 --> 00:18:16,456
But sometimes there

423
00:18:16,456 --> 00:18:20,276
that works well both inside the

424
00:18:20,276 --> 00:18:21,226
when you call the function.

425
00:18:22,166 --> 00:18:23,876
In Swift you don't have

426
00:18:24,676 --> 00:18:27,216
When a parameter's name

427
00:18:27,896 --> 00:18:29,236
for the argument

428
00:18:29,716 --> 00:18:33,006
you can explicitly provide

429
00:18:33,326 --> 00:18:35,856
You write the explicit

430
00:18:35,856 --> 00:18:36,726
of the parameter's name.

431
00:18:37,016 --> 00:18:39,596
Here we've added to as an

432
00:18:39,596 --> 00:18:42,436
in addition to the recipient

433
00:18:42,436 --> 00:18:44,126
that you can use to when

434
00:18:44,746 --> 00:18:48,286
sendMessage to Morgan, and you

435
00:18:48,286 --> 00:18:49,366
the body of the function.

436
00:18:49,906 --> 00:18:53,546
Let's add one more

437
00:18:53,546 --> 00:18:56,226
which lets you provide a custom

438
00:18:57,256 --> 00:18:59,736
Here we've added a message

439
00:19:00,376 --> 00:19:01,536
Now when you call the function,

440
00:19:01,536 --> 00:19:04,716
you can pass on your

441
00:19:04,846 --> 00:19:07,176
Now, once again, this

442
00:19:07,626 --> 00:19:09,266
but it doesn't read

443
00:19:10,166 --> 00:19:12,646
sendMessage message

444
00:19:13,706 --> 00:19:16,436
The message label isn't

445
00:19:16,486 --> 00:19:19,336
of the first argument

446
00:19:19,336 --> 00:19:21,256
from the base name of the

447
00:19:22,026 --> 00:19:24,956
Here the argument label actually

448
00:19:24,956 --> 00:19:28,276
In the cases like these, you

449
00:19:28,276 --> 00:19:29,226
of the parameter's name.

450
00:19:30,366 --> 00:19:32,626
And this means that you don't

451
00:19:32,976 --> 00:19:37,106
when you call the function.

452
00:19:37,226 --> 00:19:39,346
And now our function reads

453
00:19:39,466 --> 00:19:41,456
sendMessage, See you

454
00:19:42,006 --> 00:19:46,506
Now, it's not very often that

455
00:19:46,546 --> 00:19:49,536
so we usually pass in

456
00:19:49,536 --> 00:19:52,486
and in Swift you can actually

457
00:19:52,486 --> 00:19:53,906
in the declaration

458
00:19:54,716 --> 00:19:57,416
Whenever a parameter has a

459
00:19:57,896 --> 00:20:01,536
you can provide that value as

460
00:19:57,896 --> 00:20:01,536
you can provide that value as

461
00:20:01,536 --> 00:20:04,096
by assigning a default

462
00:20:04,706 --> 00:20:06,216
right after the type

463
00:20:07,126 --> 00:20:08,926
and now when you call the

464
00:20:08,926 --> 00:20:12,466
out the corresponding argument

465
00:20:14,876 --> 00:20:16,966
And when you're deciding

466
00:20:16,966 --> 00:20:20,796
to use an explicit argument

467
00:20:20,796 --> 00:20:22,906
to provide default

468
00:20:23,246 --> 00:20:25,626
remember that functions

469
00:20:25,996 --> 00:20:27,216
but they're used repeatedly.

470
00:20:27,516 --> 00:20:30,386
So the most important thing is

471
00:20:30,386 --> 00:20:31,916
and concisely when it's called.

472
00:20:32,296 --> 00:20:35,146
Now, to learn much

473
00:20:35,146 --> 00:20:36,236
of things you should consider

474
00:20:36,516 --> 00:20:37,816
when you're writing

475
00:20:38,986 --> 00:20:41,446
check out the Swift

476
00:20:42,066 --> 00:20:44,796
So we've looked at lots of

477
00:20:45,296 --> 00:20:47,756
Let's take a look at some of

478
00:20:48,896 --> 00:20:50,206
Let's say you want

479
00:20:50,206 --> 00:20:51,856
that returns a first

480
00:20:52,076 --> 00:20:53,176
that has a given prefix.

481
00:20:54,656 --> 00:20:58,556
The function takes a string

482
00:20:59,046 --> 00:21:01,856
and it returns the string

483
00:20:59,046 --> 00:21:01,856
and it returns the string

484
00:21:02,016 --> 00:21:04,826
As you can see, you use an

485
00:21:04,826 --> 00:21:06,376
of values your function

486
00:21:06,806 --> 00:21:07,726
In this case a string.

487
00:21:08,636 --> 00:21:09,966
So let's see how it works.

488
00:21:11,196 --> 00:21:13,956
First use a for-in loop to

489
00:21:13,956 --> 00:21:16,766
in the array and then you

490
00:21:16,766 --> 00:21:17,686
given prefix.

491
00:21:18,256 --> 00:21:21,926
You need to check whether the

492
00:21:21,926 --> 00:21:23,306
strings.hasprefix method.

493
00:21:23,336 --> 00:21:27,236
If it does, you're done and you

494
00:21:27,236 --> 00:21:28,746
by writing it in a

495
00:21:30,516 --> 00:21:31,726
But what do you return

496
00:21:31,726 --> 00:21:34,166
if the array doesn't contain

497
00:21:35,196 --> 00:21:37,586
Well, because this function was

498
00:21:37,906 --> 00:21:40,726
the only option you have

499
00:21:41,056 --> 00:21:42,236
in this case the empty string.

500
00:21:43,056 --> 00:21:44,426
But this is not good Swift code.

501
00:21:45,556 --> 00:21:48,136
However, as Dave showed

502
00:21:48,136 --> 00:21:50,386
for representing values

503
00:21:51,786 --> 00:21:54,076
So you just need to change the

504
00:21:54,076 --> 00:21:56,426
to be an optional string

505
00:21:56,426 --> 00:21:58,876
after string, and now

506
00:21:59,066 --> 00:22:00,316
when the string isn't found.

507
00:21:59,066 --> 00:22:00,316
when the string isn't found.

508
00:22:01,336 --> 00:22:03,916
And because the function

509
00:22:04,166 --> 00:22:06,256
you can call it safely

510
00:22:07,626 --> 00:22:10,376
Now, notice that Swift infers

511
00:22:10,806 --> 00:22:13,436
so there's no need to

512
00:22:14,256 --> 00:22:16,736
So we've looked at some of

513
00:22:16,986 --> 00:22:19,796
and return values of various

514
00:22:19,876 --> 00:22:22,796
integers, arrays and

515
00:22:23,446 --> 00:22:25,836
Let's take a look at writing

516
00:22:28,036 --> 00:22:30,236
Let's say you want to write a

517
00:22:30,236 --> 00:22:31,886
of numbers based

518
00:22:33,036 --> 00:22:34,786
Let's think about what

519
00:22:34,786 --> 00:22:39,396
It's going to take in an array

520
00:22:39,396 --> 00:22:41,606
in the array it's going to

521
00:22:41,606 --> 00:22:43,266
that number in the

522
00:22:44,296 --> 00:22:46,536
For example, if you wanted

523
00:22:46,536 --> 00:22:48,506
to contain only the

524
00:22:49,516 --> 00:22:51,656
you could test whether each

525
00:22:52,416 --> 00:22:54,386
In this case, of

526
00:22:54,546 --> 00:22:57,336
so it's included in

527
00:22:58,096 --> 00:23:00,176
If a number isn't

528
00:22:58,096 --> 00:23:00,176
If a number isn't

529
00:23:00,176 --> 00:23:03,096
the filtering function just

530
00:23:03,096 --> 00:23:05,696
to test, and so on through

531
00:23:06,736 --> 00:23:10,766
Now, let's look at writing

532
00:23:10,936 --> 00:23:12,876
The function declaration

533
00:23:12,876 --> 00:23:16,276
but what type do you put in for

534
00:23:17,056 --> 00:23:19,236
As you saw a few moments

535
00:23:19,236 --> 00:23:20,156
to include a number

536
00:23:20,156 --> 00:23:23,416
in the filtered result is

537
00:23:23,736 --> 00:23:26,146
not just a simple value,

538
00:23:27,256 --> 00:23:31,176
and in Swift functions can take

539
00:23:32,066 --> 00:23:33,966
So what does the type

540
00:23:33,966 --> 00:23:37,566
Well, all function types in

541
00:23:38,186 --> 00:23:40,226
The type of the function's

542
00:23:40,736 --> 00:23:43,716
go inside of the parentheses,

543
00:23:43,716 --> 00:23:45,446
and the function's return type.

544
00:23:46,056 --> 00:23:48,996
So, for example, here's our

545
00:23:48,996 --> 00:23:49,556
from earlier.

546
00:23:50,296 --> 00:23:52,176
It has the type,

547
00:23:52,406 --> 00:23:54,956
because it doesn't take

548
00:23:55,886 --> 00:23:58,306
Here void just means it

549
00:23:59,486 --> 00:24:01,796
And in Swift if your function

550
00:23:59,486 --> 00:24:01,796
And in Swift if your function

551
00:24:01,796 --> 00:24:03,966
you don't need to write

552
00:24:09,056 --> 00:24:11,046
And here's the firstString

553
00:24:11,506 --> 00:24:13,196
Its signature is a

554
00:24:13,526 --> 00:24:15,496
but its type follows

555
00:24:16,356 --> 00:24:18,456
It takes a string,

556
00:24:18,456 --> 00:24:19,616
and it returns an

557
00:24:20,456 --> 00:24:23,236
So now that you've seen this

558
00:24:23,286 --> 00:24:24,776
it's pretty clear how you need

559
00:24:24,776 --> 00:24:26,796
to finish the declaration

560
00:24:27,936 --> 00:24:30,546
The includeNumber

561
00:24:31,086 --> 00:24:33,886
that takes an integer and

562
00:24:33,886 --> 00:24:37,386
that type as Int in

563
00:24:38,236 --> 00:24:40,116
So let's go ahead and write

564
00:24:40,476 --> 00:24:44,186
You need to build up an

565
00:24:44,326 --> 00:24:45,826
so here's a variable

566
00:24:46,056 --> 00:24:48,246
It's been initialized to

567
00:24:49,386 --> 00:24:51,146
And as you iterate through

568
00:24:51,146 --> 00:24:52,876
pass into the function, you need

569
00:24:52,876 --> 00:24:54,556
to check whether each

570
00:24:54,556 --> 00:24:55,496
in the result array.

571
00:24:56,946 --> 00:25:00,146
To do that you pass each number

572
00:24:56,946 --> 00:25:00,146
To do that you pass each number

573
00:25:00,616 --> 00:25:02,816
and notice that inside

574
00:25:02,816 --> 00:25:05,946
the includeNumber parameter

575
00:25:06,026 --> 00:25:08,526
of the function it's passed

576
00:25:08,526 --> 00:25:09,826
that you can call

577
00:25:09,826 --> 00:25:11,146
that you do any other function.

578
00:25:11,246 --> 00:25:13,876
So that's how you

579
00:25:13,976 --> 00:25:15,826
that takes another

580
00:25:16,576 --> 00:25:18,476
But how do you call one of

581
00:25:19,636 --> 00:25:21,126
Well, first you're going

582
00:25:21,126 --> 00:25:22,186
to pass into filterInts.

583
00:25:22,956 --> 00:25:24,286
So here's an array of numbers

584
00:25:24,526 --> 00:25:26,836
and a simple function

585
00:25:27,086 --> 00:25:28,756
that indicates whether

586
00:25:29,796 --> 00:25:32,836
As you can see, the type

587
00:25:32,836 --> 00:25:35,836
of divisibleByTwo

588
00:25:35,836 --> 00:25:37,146
of the includeNumber parameter.

589
00:25:37,866 --> 00:25:42,686
So that means that we can pass

590
00:25:43,206 --> 00:25:44,896
as an argument to filterInts.

591
00:25:45,436 --> 00:25:48,546
You do this by simply

592
00:25:48,546 --> 00:25:52,436
of the divisibleByTwo function

593
00:25:52,436 --> 00:25:53,736
of only the even numbers.

594
00:25:54,906 --> 00:25:56,996
Now, notice that you don't

595
00:25:57,246 --> 00:25:59,526
when you pass in the

596
00:25:59,806 --> 00:26:02,046
and that's because you're

597
00:25:59,806 --> 00:26:02,046
and that's because you're

598
00:26:02,566 --> 00:26:05,236
Instead, it's called later

599
00:26:05,726 --> 00:26:09,956
Also notice that we passed in

600
00:26:11,336 --> 00:26:14,266
but you could have passed

601
00:26:14,586 --> 00:26:16,836
for instance, if you just

602
00:26:17,106 --> 00:26:19,666
without needing to create

603
00:26:20,936 --> 00:26:24,126
The same is true for passing

604
00:26:26,616 --> 00:26:29,616
It's not very likely that the

605
00:26:29,616 --> 00:26:30,806
find much reuse.

606
00:26:31,286 --> 00:26:32,846
And it would be pretty

607
00:26:32,846 --> 00:26:35,666
to make a new function every

608
00:26:35,666 --> 00:26:37,146
in a different filterInt

609
00:26:37,726 --> 00:26:40,916
And if you look at the important

610
00:26:40,916 --> 00:26:43,046
you can see that

611
00:26:43,046 --> 00:26:46,476
at all is really just a

612
00:26:47,736 --> 00:26:51,456
divisibleByTwo is just a

613
00:26:51,456 --> 00:26:52,636
that you see highlighted.

614
00:26:54,496 --> 00:26:57,126
And in Swift, just as you

615
00:26:57,496 --> 00:27:00,226
or a literal array, you can

616
00:26:57,496 --> 00:27:00,226
or a literal array, you can

617
00:27:00,826 --> 00:27:02,826
without a name called

618
00:27:03,156 --> 00:27:04,286
and pass it around in your code.

619
00:27:05,496 --> 00:27:08,136
The syntax for writing a closure

620
00:27:08,136 --> 00:27:09,266
to a function declaration,

621
00:27:09,266 --> 00:27:10,876
except that it doesn't

622
00:27:11,356 --> 00:27:14,496
You write the entire body

623
00:27:14,496 --> 00:27:17,766
of the curly braces and you

624
00:27:18,106 --> 00:27:20,406
from its signature

625
00:27:20,936 --> 00:27:24,536
as in use the parameter

626
00:27:24,536 --> 00:27:26,166
of this closure,

627
00:27:26,166 --> 00:27:30,886
Now, this is the most

628
00:27:30,886 --> 00:27:33,546
to write a closure, but

629
00:27:33,546 --> 00:27:35,376
Swift can infer a

630
00:27:35,376 --> 00:27:37,656
from the context

631
00:27:39,216 --> 00:27:42,686
For example, the function type

632
00:27:42,886 --> 00:27:44,866
from the type of the

633
00:27:45,926 --> 00:27:47,996
and this means you don't

634
00:27:48,536 --> 00:27:51,046
And when the entire body

635
00:27:51,046 --> 00:27:54,076
of the closure is a single

636
00:27:54,856 --> 00:27:56,906
you don't need to write

637
00:27:57,506 --> 00:28:01,426
So this is much cleaner syntax,

638
00:27:57,506 --> 00:28:01,426
So this is much cleaner syntax,

639
00:28:01,426 --> 00:28:05,396
so short, even the number

640
00:28:06,216 --> 00:28:09,236
And in cases like these Swift

641
00:28:09,236 --> 00:28:10,636
names, so there's no need

642
00:28:10,636 --> 00:28:13,366
to even write the parameter

643
00:28:13,886 --> 00:28:17,436
These implicit arguments

644
00:28:17,436 --> 00:28:18,626
and a number beginning at 0.

645
00:28:18,626 --> 00:28:21,676
So $0 refers to the first

646
00:28:21,676 --> 00:28:23,076
$1 the second, and so on.

647
00:28:23,236 --> 00:28:25,916
And even though these

648
00:28:25,916 --> 00:28:29,226
in any closure expression,

649
00:28:29,226 --> 00:28:32,566
so doesn't make your

650
00:28:33,676 --> 00:28:36,606
Now, you've seen that Swift

651
00:28:36,606 --> 00:28:37,456
for writing closures,

652
00:28:38,096 --> 00:28:42,026
but passing them directly inside

653
00:28:42,026 --> 00:28:43,396
little punctuation heavy.

654
00:28:44,206 --> 00:28:45,996
A closing curly brace right next

655
00:28:45,996 --> 00:28:48,196
to a closing paren

656
00:28:48,196 --> 00:28:53,206
However, when the closure is the

657
00:28:53,206 --> 00:28:56,076
as it is in this case,

658
00:28:56,076 --> 00:28:59,176
as a trailing closure right

659
00:29:00,426 --> 00:29:03,606
And as you'll see later, if

660
00:29:03,606 --> 00:29:06,436
to a function, you can drop

661
00:29:07,046 --> 00:29:09,846
Now, trailing closures

662
00:29:10,446 --> 00:29:12,946
when the closure contains

663
00:29:13,886 --> 00:29:16,256
For example, here's a

664
00:29:16,486 --> 00:29:19,846
that determines whether the sum

665
00:29:21,156 --> 00:29:24,956
Trailing closure syntax ensures

666
00:29:24,956 --> 00:29:28,776
with multiline functionality

667
00:29:29,316 --> 00:29:34,006
Now, the filterInts function is

668
00:29:34,006 --> 00:29:37,326
to do is filter integers,

669
00:29:37,326 --> 00:29:39,196
to filter arrays of other

670
00:29:40,506 --> 00:29:42,566
For example, say you

671
00:29:42,916 --> 00:29:45,376
and you want a filtered array

672
00:29:45,376 --> 00:29:47,426
that have less than a

673
00:29:48,776 --> 00:29:51,006
You could do this by writing

674
00:29:51,006 --> 00:29:51,976
like the one you see here,

675
00:29:52,776 --> 00:29:54,956
and since you've already

676
00:29:55,466 --> 00:29:58,166
let's see whether you can

677
00:29:59,316 --> 00:30:01,536
Well, first, you'd obviously

678
00:29:59,316 --> 00:30:01,536
Well, first, you'd obviously

679
00:30:01,766 --> 00:30:03,226
and change all the

680
00:30:03,226 --> 00:30:05,246
to numbers to refer to strings.

681
00:30:06,566 --> 00:30:08,036
And next you need to change all

682
00:30:08,036 --> 00:30:11,146
of the Int types

683
00:30:11,696 --> 00:30:14,766
And because the behavior

684
00:30:14,766 --> 00:30:16,436
of these two functions

685
00:30:16,436 --> 00:30:17,876
for both integers and strings,

686
00:30:18,346 --> 00:30:19,756
there's really nothing

687
00:30:19,906 --> 00:30:21,336
They're essentially

688
00:30:22,406 --> 00:30:23,646
And now you have this function

689
00:30:23,646 --> 00:30:24,946
that filters an array

690
00:30:26,146 --> 00:30:28,456
Now, if you want a

691
00:30:28,456 --> 00:30:32,186
for other kinds of types, you

692
00:30:32,186 --> 00:30:34,496
and over and over again

693
00:30:35,166 --> 00:30:37,536
but this would obviously

694
00:30:38,696 --> 00:30:41,676
So instead, you can write

695
00:30:41,676 --> 00:30:43,496
with arrays of any kind of type.

696
00:30:43,946 --> 00:30:45,436
This is called a

697
00:30:46,456 --> 00:30:48,956
So let's look at

698
00:30:48,956 --> 00:30:51,106
Writing one is not

699
00:30:51,106 --> 00:30:52,096
than what you've seen already.

700
00:30:53,016 --> 00:30:54,846
First you change the

701
00:30:55,226 --> 00:30:58,176
So, for example, the function's

702
00:30:58,176 --> 00:31:00,536
rather than filterInts

703
00:30:58,176 --> 00:31:00,536
rather than filterInts

704
00:31:01,716 --> 00:31:04,406
Next, and more importantly, you

705
00:31:04,406 --> 00:31:07,266
that you see here with

706
00:31:07,976 --> 00:31:09,906
but you don't know

707
00:31:10,956 --> 00:31:13,666
So instead, what you really

708
00:31:14,206 --> 00:31:16,986
The actual type is determined

709
00:31:17,446 --> 00:31:19,836
Here we filled in

710
00:31:20,576 --> 00:31:22,746
with a generic type

711
00:31:23,686 --> 00:31:25,066
And so that you can

712
00:31:25,066 --> 00:31:28,316
between type parameters and

713
00:31:28,316 --> 00:31:31,916
like strings or integers,

714
00:31:31,916 --> 00:31:34,996
up front inside of the

715
00:31:34,996 --> 00:31:36,086
after the function's name.

716
00:31:36,866 --> 00:31:39,126
And now you have a generic

717
00:31:39,126 --> 00:31:44,566
with an array that

718
00:31:44,626 --> 00:31:47,126
You call this kind of function

719
00:31:47,486 --> 00:31:49,896
You don't need to specify the

720
00:31:49,896 --> 00:31:51,976
to work with because

721
00:31:51,976 --> 00:31:54,586
from the values you pass in.

722
00:31:54,786 --> 00:31:56,816
Filtering is such

723
00:31:56,816 --> 00:32:00,226
that the Swift standard library

724
00:31:56,816 --> 00:32:00,226
that the Swift standard library

725
00:32:00,226 --> 00:32:02,136
with any kind of

726
00:32:02,946 --> 00:32:05,366
It works in basically

727
00:32:05,366 --> 00:32:08,736
as the filter function you just

728
00:32:08,736 --> 00:32:10,416
so you call it using

729
00:32:10,816 --> 00:32:12,786
names.filter, as you see here.

730
00:32:13,436 --> 00:32:16,586
The Swift standard

731
00:32:16,586 --> 00:32:19,356
of other methods that take

732
00:32:19,966 --> 00:32:22,456
And another really useful

733
00:32:22,806 --> 00:32:24,956
and it also works with any

734
00:32:25,336 --> 00:32:29,196
Map returns a new array

735
00:32:29,196 --> 00:32:30,896
of a plan enclosure

736
00:32:31,396 --> 00:32:33,636
So here's an example that

737
00:32:33,636 --> 00:32:35,006
of short names from above.

738
00:32:35,226 --> 00:32:38,276
It passes a closure that

739
00:32:40,656 --> 00:32:42,496
You can even chain

740
00:32:42,496 --> 00:32:44,556
to perform multiple operations.

741
00:32:44,946 --> 00:32:46,816
So, for example, you can

742
00:32:46,816 --> 00:32:48,966
and the upper casing

743
00:32:49,596 --> 00:32:52,036
By chaining these two

744
00:32:52,036 --> 00:32:52,716
dot notation.

745
00:32:53,266 --> 00:32:55,926
The filtering happens first,

746
00:32:55,926 --> 00:32:56,976
on the filtered array,

747
00:32:57,246 --> 00:32:59,616
which then finally returns

748
00:33:01,546 --> 00:33:02,976
And this reads nicely even

749
00:33:02,976 --> 00:33:05,126
when you're using the

750
00:33:05,636 --> 00:33:09,706
So the combination of closures

751
00:33:09,706 --> 00:33:13,596
as arguments makes it possible

752
00:33:14,426 --> 00:33:18,226
powerful code in a concise

753
00:33:18,956 --> 00:33:21,186
So we've looked at

754
00:33:21,186 --> 00:33:23,026
and even a bit of

755
00:33:23,296 --> 00:33:25,606
I'd like to invite Alex

756
00:33:25,606 --> 00:33:26,976
about data types in Swift.

757
00:33:27,516 --> 00:33:33,906
[ Applause ]

758
00:33:34,406 --> 00:33:35,096
&gt;&gt; Thanks, Brian.

759
00:33:36,236 --> 00:33:38,816
You've seen how to use

760
00:33:39,626 --> 00:33:41,066
Now let's take a look at how

761
00:33:41,066 --> 00:33:44,426
to create some data

762
00:33:44,676 --> 00:33:46,136
Let's start with structures.

763
00:33:46,766 --> 00:33:48,856
You create one like this.

764
00:33:49,086 --> 00:33:51,476
You write the struct

765
00:33:51,476 --> 00:33:52,726
by the name of a structure.

766
00:33:53,206 --> 00:33:54,486
Here, rectangle.

767
00:33:55,896 --> 00:34:01,726
Then inside the curly braces

768
00:33:55,896 --> 00:34:01,726
Then inside the curly braces

769
00:34:01,726 --> 00:34:02,566
of the structure.

770
00:34:03,776 --> 00:34:07,356
Properties use the same

771
00:34:07,356 --> 00:34:09,315
for variables and constants.

772
00:34:10,876 --> 00:34:14,456
Both properties here have

773
00:34:14,456 --> 00:34:17,735
of the declaration, so

774
00:34:18,136 --> 00:34:20,356
by just writing rectangle,

775
00:34:21,206 --> 00:34:22,936
followed by a pair

776
00:34:24,005 --> 00:34:27,726
And to access the properties,

777
00:34:29,735 --> 00:34:33,766
You don't have to provide a

778
00:34:33,766 --> 00:34:34,996
of the types declaration.

779
00:34:35,496 --> 00:34:37,636
In fact, most of

780
00:34:38,386 --> 00:34:43,176
More often, you write just the

781
00:34:43,275 --> 00:34:44,666
when you create the instance.

782
00:34:46,206 --> 00:34:47,846
So another property

783
00:34:47,846 --> 00:34:51,366
of a rectangle besides its

784
00:34:52,636 --> 00:34:54,966
You wouldn't want to

785
00:34:55,166 --> 00:34:58,736
You'd have to update it every

786
00:34:59,586 --> 00:35:03,976
What you want is a property

787
00:34:59,586 --> 00:35:03,976
What you want is a property

788
00:35:03,976 --> 00:35:06,456
at the point you need

789
00:35:06,456 --> 00:35:08,706
that using a computed property.

790
00:35:10,206 --> 00:35:14,996
To make a computed property,

791
00:35:15,096 --> 00:35:19,216
and its type, you write a

792
00:35:19,216 --> 00:35:23,476
for computing and returning the

793
00:35:24,766 --> 00:35:27,536
Even though it's computed

794
00:35:27,746 --> 00:35:30,266
you still access it

795
00:35:31,776 --> 00:35:33,796
There's more that you

796
00:35:34,476 --> 00:35:38,936
You can have setters and

797
00:35:38,936 --> 00:35:42,786
out information about those

798
00:35:43,326 --> 00:35:45,386
of the Swift Programming

799
00:35:47,716 --> 00:35:50,956
Just like you can define

800
00:35:51,346 --> 00:35:52,936
you can also define methods.

801
00:35:54,276 --> 00:35:57,666
They use the same syntax you've

802
00:35:58,976 --> 00:36:03,546
And just like properties, you

803
00:35:58,976 --> 00:36:03,546
And just like properties, you

804
00:36:03,786 --> 00:36:08,416
when you need to call them.

805
00:36:08,616 --> 00:36:12,286
You've seen this syntax a few

806
00:36:13,066 --> 00:36:15,506
Let's look at what it does

807
00:36:17,256 --> 00:36:20,076
It looks a little bit

808
00:36:20,226 --> 00:36:21,736
because of the parenthesis,

809
00:36:22,226 --> 00:36:24,356
but it's actually

810
00:36:25,136 --> 00:36:29,556
So far we've been using a

811
00:36:29,556 --> 00:36:32,946
member wise initializer

812
00:36:33,056 --> 00:36:34,826
for you on structures.

813
00:36:35,766 --> 00:36:37,926
Here's what it would

814
00:36:37,926 --> 00:36:39,986
that initializer out explicitly.

815
00:36:41,276 --> 00:36:46,036
You write the init keyword and

816
00:36:46,126 --> 00:36:47,796
for the rectangle's properties.

817
00:36:49,046 --> 00:36:52,036
Notice that there are two

818
00:36:52,686 --> 00:36:57,676
There's a property and there's

819
00:36:58,356 --> 00:37:00,706
to explicitly refer

820
00:36:58,356 --> 00:37:00,706
to explicitly refer

821
00:37:01,646 --> 00:37:04,406
So that's how you write

822
00:37:06,516 --> 00:37:10,036
There's enough code in

823
00:37:10,396 --> 00:37:14,536
that it could benefit from some

824
00:37:14,536 --> 00:37:17,146
that in Swift is

825
00:37:18,136 --> 00:37:21,196
An extension lets

826
00:37:21,456 --> 00:37:22,626
to an existing type.

827
00:37:23,926 --> 00:37:28,626
In Swift you can use extensions

828
00:37:29,846 --> 00:37:33,626
Core functionality can go in

829
00:37:33,626 --> 00:37:39,256
and additional functionality can

830
00:37:40,586 --> 00:37:43,216
You're not limited to

831
00:37:43,916 --> 00:37:47,516
If you need to, you can extend

832
00:37:47,856 --> 00:37:51,246
such as foundation or

833
00:37:53,306 --> 00:37:56,386
You saw earlier how you

834
00:37:56,836 --> 00:37:59,046
which performs the

835
00:37:59,486 --> 00:38:00,926
on data of different types.

836
00:37:59,486 --> 00:38:00,926
on data of different types.

837
00:38:02,056 --> 00:38:04,326
You can also make

838
00:38:04,826 --> 00:38:07,206
which contains data

839
00:38:08,336 --> 00:38:10,076
The syntax looks very similar.

840
00:38:10,646 --> 00:38:15,186
You still have the generic type

841
00:38:15,346 --> 00:38:16,026
after the name.

842
00:38:16,776 --> 00:38:20,166
This example attaches

843
00:38:20,166 --> 00:38:21,816
of some kind of element.

844
00:38:23,216 --> 00:38:26,326
This would be a useful data

845
00:38:26,586 --> 00:38:31,386
to populate a table view that

846
00:38:31,856 --> 00:38:35,956
You create a generic

847
00:38:35,956 --> 00:38:39,606
like an instance

848
00:38:39,806 --> 00:38:43,076
Here you can see if you

849
00:38:44,236 --> 00:38:47,896
board games and primes

850
00:38:49,016 --> 00:38:51,196
One is an array of strings

851
00:38:51,436 --> 00:38:53,586
and the other is an

852
00:38:54,066 --> 00:38:56,256
They have different

853
00:38:57,076 --> 00:39:00,116
so they are different types.

854
00:38:57,076 --> 00:39:00,116
so they are different types.

855
00:39:00,296 --> 00:39:02,016
You don't have to

856
00:39:02,746 --> 00:39:06,076
Swift infers what

857
00:39:08,036 --> 00:39:09,606
So that's structures.

858
00:39:11,356 --> 00:39:14,596
Another data type

859
00:39:15,816 --> 00:39:19,106
You write class before

860
00:39:19,106 --> 00:39:21,256
about structures still applies.

861
00:39:21,706 --> 00:39:25,376
Properties, methods,

862
00:39:26,086 --> 00:39:30,826
So why would you want

863
00:39:30,986 --> 00:39:35,286
One reason is that your code

864
00:39:35,316 --> 00:39:38,266
of a class from several

865
00:39:38,346 --> 00:39:41,236
and that's different than

866
00:39:41,236 --> 00:39:42,196
for structures.

867
00:39:42,736 --> 00:39:45,926
A structure acts

868
00:39:46,936 --> 00:39:51,476
For example, in a game, if

869
00:39:52,436 --> 00:39:55,466
and then give player2

870
00:39:55,846 --> 00:39:58,076
you have two independent scores.

871
00:39:59,066 --> 00:40:03,756
Changing player2's score

872
00:39:59,066 --> 00:40:03,756
Changing player2's score

873
00:40:04,936 --> 00:40:10,166
However, both players need to

874
00:40:10,646 --> 00:40:12,616
when they log their high scores.

875
00:40:13,936 --> 00:40:18,786
Since it's a class, that's

876
00:40:18,786 --> 00:40:23,256
When player2 gets a new

877
00:40:23,256 --> 00:40:26,996
to the file, both

878
00:40:28,596 --> 00:40:32,146
If you're coming from another

879
00:40:32,476 --> 00:40:35,256
you might be used to

880
00:40:35,916 --> 00:40:38,426
and in Swift you don't

881
00:40:38,526 --> 00:40:40,086
as often as you might think.

882
00:40:41,346 --> 00:40:45,826
Anytime it makes sense to check

883
00:40:46,936 --> 00:40:50,016
you usually want a value

884
00:40:51,316 --> 00:40:55,896
For more information about how

885
00:40:56,256 --> 00:40:58,756
there's a great talk

886
00:40:59,416 --> 00:41:03,036
Another reason to use

887
00:40:59,416 --> 00:41:03,036
Another reason to use

888
00:41:03,036 --> 00:41:05,336
to subclass an existing class.

889
00:41:06,616 --> 00:41:09,716
For example, suppose

890
00:41:09,976 --> 00:41:12,766
that gives you this

891
00:41:12,766 --> 00:41:14,706
of core fish functionality.

892
00:41:16,096 --> 00:41:18,656
You can subclass it

893
00:41:19,296 --> 00:41:22,166
like a FlyingFish can

894
00:41:23,176 --> 00:41:27,786
You indicate that this is a

895
00:41:28,636 --> 00:41:31,836
Subclasses can also

896
00:41:32,326 --> 00:41:34,346
to provide their

897
00:41:35,536 --> 00:41:37,136
Like this ComplainingFish.

898
00:41:37,656 --> 00:41:41,816
It swims like a normal fish, it

899
00:41:44,666 --> 00:41:49,706
You write super.swim to call

900
00:41:50,826 --> 00:41:52,706
This code doesn't compile yet.

901
00:41:54,006 --> 00:41:56,306
When you override

902
00:41:56,746 --> 00:42:00,816
you have to mark it

903
00:41:56,746 --> 00:42:00,816
you have to mark it

904
00:42:01,666 --> 00:42:03,326
and now this code works.

905
00:42:04,616 --> 00:42:08,666
Just like it's an error to

906
00:42:09,206 --> 00:42:12,076
it's also an error

907
00:42:12,346 --> 00:42:14,316
when you don't override

908
00:42:15,766 --> 00:42:19,656
That means if you misspell a

909
00:42:19,656 --> 00:42:22,066
to override, Swift tells you

910
00:42:22,066 --> 00:42:26,266
about the error right

911
00:42:26,446 --> 00:42:29,146
A segue can also

912
00:42:30,436 --> 00:42:35,056
For example, fish that has an

913
00:42:35,946 --> 00:42:38,686
ComplainingFish needs

914
00:42:38,806 --> 00:42:41,006
with both a name

915
00:42:42,796 --> 00:42:46,686
Inside the initializer

916
00:42:46,686 --> 00:42:49,506
for the properties

917
00:42:50,376 --> 00:42:53,726
and then you call super.init

918
00:42:54,866 --> 00:42:58,096
to let the superclass

919
00:42:59,536 --> 00:43:02,186
There's more you can

920
00:42:59,536 --> 00:43:02,186
There's more you can

921
00:43:02,516 --> 00:43:04,296
especially around classes.

922
00:43:05,146 --> 00:43:09,396
You can read all about it

923
00:43:09,616 --> 00:43:11,676
of the Swift Programming

924
00:43:13,306 --> 00:43:15,596
You've seen how you

925
00:43:16,026 --> 00:43:18,746
Now let's talk about

926
00:43:20,366 --> 00:43:22,716
Continuing the game example,

927
00:43:23,066 --> 00:43:25,456
suppose you have this

928
00:43:26,586 --> 00:43:28,686
Since every player

929
00:43:29,056 --> 00:43:31,936
there's a method to do that.

930
00:43:32,006 --> 00:43:33,706
You have two kinds of players.

931
00:43:34,576 --> 00:43:37,756
You have a HumanPlayer

932
00:43:38,016 --> 00:43:39,826
by showing UI to the user.

933
00:43:40,606 --> 00:43:44,476
And you have a ComputerPlayer

934
00:43:44,736 --> 00:43:47,016
by finding the best legal move.

935
00:43:48,276 --> 00:43:51,236
So the question then

936
00:43:51,306 --> 00:43:53,196
in the base class

937
00:43:54,556 --> 00:43:57,656
Well, there's no shared behavior

938
00:43:57,966 --> 00:44:00,486
between human and

939
00:43:57,966 --> 00:44:00,486
between human and

940
00:44:01,126 --> 00:44:05,296
There isn't any shared

941
00:44:05,296 --> 00:44:10,066
And in the surrounding code you

942
00:44:10,256 --> 00:44:11,536
of the player base class.

943
00:44:12,586 --> 00:44:15,596
So this method should

944
00:44:16,306 --> 00:44:20,636
The only reasonable thing you

945
00:44:20,636 --> 00:44:24,586
of fatal error to help

946
00:44:24,586 --> 00:44:25,846
in the development process.

947
00:44:26,596 --> 00:44:31,966
All the player class is doing

948
00:44:32,066 --> 00:44:36,216
to be a player, that every

949
00:44:37,026 --> 00:44:39,726
It's a sort of blueprint

950
00:44:41,276 --> 00:44:43,696
In Swift you express this kind

951
00:44:43,696 --> 00:44:46,696
of relationship using

952
00:44:47,436 --> 00:44:51,636
Protocols specify requirements

953
00:44:52,736 --> 00:44:56,086
They're like interfaces

954
00:44:56,396 --> 00:44:58,566
that you might know

955
00:44:59,836 --> 00:45:02,526
You make one using

956
00:44:59,836 --> 00:45:02,526
You make one using

957
00:45:03,626 --> 00:45:07,506
And because it describes

958
00:45:07,506 --> 00:45:11,156
to fulfill, you don't

959
00:45:12,656 --> 00:45:17,516
Types conform to a protocol by

960
00:45:18,426 --> 00:45:22,446
and you declare conformance

961
00:45:23,006 --> 00:45:25,166
just like you do when

962
00:45:25,996 --> 00:45:30,026
At this point you're

963
00:45:30,516 --> 00:45:33,496
so these methods are

964
00:45:34,916 --> 00:45:36,896
So you don't write override.

965
00:45:39,256 --> 00:45:42,856
There's no real reason these

966
00:45:43,406 --> 00:45:45,096
so let's make them structures.

967
00:45:46,616 --> 00:45:50,346
And let's take a closer

968
00:45:50,936 --> 00:45:56,106
It has a few other properties,

969
00:45:56,106 --> 00:46:02,146
And if you make an instance of

970
00:45:56,106 --> 00:46:02,146
And if you make an instance of

971
00:46:02,416 --> 00:46:04,566
You get a default

972
00:46:05,106 --> 00:46:08,266
because the standard

973
00:46:08,546 --> 00:46:12,356
from any type to a string.

974
00:46:12,546 --> 00:46:15,336
But what if you wanted to

975
00:46:15,526 --> 00:46:17,236
to print a nicer description?

976
00:46:18,146 --> 00:46:21,846
The standard library also

977
00:46:21,846 --> 00:46:23,556
CustomStringConvertible

978
00:46:24,016 --> 00:46:27,826
which lets you provide a custom

979
00:46:27,826 --> 00:46:29,216
that protocol looks like.

980
00:46:30,196 --> 00:46:33,496
It has one requirement --

981
00:46:34,996 --> 00:46:38,656
Any type that conforms

982
00:46:38,656 --> 00:46:39,736
custom description.

983
00:46:40,766 --> 00:46:44,026
Okay. So where should

984
00:46:44,026 --> 00:46:45,166
description property.

985
00:46:46,656 --> 00:46:50,236
Remember from earlier how you

986
00:46:50,236 --> 00:46:52,866
extensions with core

987
00:46:53,306 --> 00:46:54,756
in type declarations,

988
00:46:55,146 --> 00:46:57,996
and additional functionality

989
00:46:59,246 --> 00:47:02,706
Having a custom string

990
00:46:59,246 --> 00:47:02,706
Having a custom string

991
00:47:02,706 --> 00:47:04,196
into the second category.

992
00:47:04,506 --> 00:47:08,446
It's not core functionality, so

993
00:47:09,126 --> 00:47:13,316
Here's how you extend a type

994
00:47:14,536 --> 00:47:17,486
You write colon

995
00:47:17,786 --> 00:47:18,746
in the first line.

996
00:47:19,996 --> 00:47:23,156
And then you implement the

997
00:47:23,156 --> 00:47:24,186
extension body.

998
00:47:26,196 --> 00:47:29,226
Now when you call print,

999
00:47:29,226 --> 00:47:30,266
string conversion.

1000
00:47:31,656 --> 00:47:35,576
There's a lot that you can

1001
00:47:35,576 --> 00:47:39,756
and extensions to organize your

1002
00:47:40,336 --> 00:47:43,706
For more information

1003
00:47:43,956 --> 00:47:47,756
on Protocol Oriented

1004
00:47:48,956 --> 00:47:54,376
That brings us to the last data

1005
00:47:55,356 --> 00:47:59,026
You use an enumeration when

1006
00:47:59,026 --> 00:48:00,496
that you know ahead of time.

1007
00:47:59,026 --> 00:48:00,496
that you know ahead of time.

1008
00:48:01,336 --> 00:48:04,056
Here's an enumeration

1009
00:48:04,246 --> 00:48:07,436
and right alignment for text.

1010
00:48:07,626 --> 00:48:09,126
When you use an enumeration,

1011
00:48:09,546 --> 00:48:12,796
you use dot notation

1012
00:48:14,056 --> 00:48:17,726
Here there are only two

1013
00:48:17,936 --> 00:48:19,476
if you write them on one line.

1014
00:48:21,336 --> 00:48:24,886
Because an enumeration has

1015
00:48:25,176 --> 00:48:29,906
it's very common to use one

1016
00:48:30,156 --> 00:48:33,356
for each enumeration case.

1017
00:48:33,826 --> 00:48:37,266
Writing alignment over and

1018
00:48:37,776 --> 00:48:39,596
and here it's not necessary.

1019
00:48:41,076 --> 00:48:43,596
The switch is considering

1020
00:48:44,246 --> 00:48:46,546
so the only possible

1021
00:48:46,666 --> 00:48:50,356
for are enumeration cases

1022
00:48:51,366 --> 00:48:54,416
That means you can omit

1023
00:48:54,906 --> 00:48:56,726
and write just .left.

1024
00:48:58,296 --> 00:49:01,776
Also, notice that there's

1025
00:48:58,296 --> 00:49:01,776
Also, notice that there's

1026
00:49:02,956 --> 00:49:05,336
That's for the same

1027
00:49:06,246 --> 00:49:10,116
The switch already covers

1028
00:49:10,706 --> 00:49:13,926
so there's nothing left for

1029
00:49:15,256 --> 00:49:18,766
Omitting the default case

1030
00:49:19,256 --> 00:49:23,306
If you come back later and

1031
00:49:23,776 --> 00:49:28,036
but forget to update the switch,

1032
00:49:28,666 --> 00:49:30,486
until you add the missing code.

1033
00:49:32,476 --> 00:49:34,446
Now let's take a quick look

1034
00:49:34,786 --> 00:49:38,146
at two more things you

1035
00:49:40,796 --> 00:49:44,786
You can associate values

1036
00:49:45,716 --> 00:49:51,206
For example, the alignment can

1037
00:49:52,616 --> 00:49:55,376
and you can get that

1038
00:49:55,586 --> 00:50:00,536
out as part of the switch case.

1039
00:49:55,586 --> 00:50:00,536
out as part of the switch case.

1040
00:50:00,736 --> 00:50:05,796
You can also give each

1041
00:50:06,006 --> 00:50:09,776
from some other type, such

1042
00:50:11,376 --> 00:50:14,546
which lets you improve

1043
00:50:15,076 --> 00:50:18,566
by using enumerations

1044
00:50:21,276 --> 00:50:25,896
You've seen a lot of Swift this

1045
00:50:25,896 --> 00:50:27,096
to show you everything.

1046
00:50:28,036 --> 00:50:31,546
One last thing I'd like to

1047
00:50:33,416 --> 00:50:38,996
In Swift you can use an

1048
00:50:40,556 --> 00:50:43,216
You use throws to

1049
00:50:43,366 --> 00:50:44,836
that can throw an error.

1050
00:50:46,836 --> 00:50:51,676
You write defer before a block

1051
00:50:51,906 --> 00:50:53,586
whether or not there's an error,

1052
00:50:54,176 --> 00:50:58,466
and that execution happens

1053
00:50:58,466 --> 00:51:00,106
such as returning

1054
00:50:58,466 --> 00:51:00,106
such as returning

1055
00:51:03,446 --> 00:51:06,496
Before calling code that

1056
00:51:06,836 --> 00:51:11,546
you mark it with try,

1057
00:51:11,716 --> 00:51:14,786
and throw errors

1058
00:51:16,056 --> 00:51:18,586
For all the details

1059
00:51:19,196 --> 00:51:21,386
take a look at the

1060
00:51:21,786 --> 00:51:23,746
in the Swift Programming

1061
00:51:25,586 --> 00:51:29,396
You can find a link to that

1062
00:51:31,356 --> 00:51:34,326
There are lots of other

1063
00:51:34,326 --> 00:51:36,956
out later this week or on video.

1064
00:51:37,736 --> 00:51:37,976
Thank you.

1065
00:51:38,516 --> 00:51:46,150
[ Applause ]
