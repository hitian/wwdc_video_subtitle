1
00:00:07,516 --> 00:00:18,500
[ Music ]

2
00:00:25,516 --> 00:00:31,546
[ Applause ]

3
00:00:32,046 --> 00:00:32,716
&gt;&gt; So, hello everyone.

4
00:00:33,026 --> 00:00:35,416
My name is Fiona and this

5
00:00:36,146 --> 00:00:40,776
And I work on the iOS GPU

6
00:00:40,776 --> 00:00:43,356
to make your shaders run

7
00:00:43,436 --> 00:00:46,176
and to make them run as

8
00:00:46,636 --> 00:00:49,056
And I'm here to talk

9
00:00:49,166 --> 00:00:52,136
Advanced Metal Shader

10
00:00:52,136 --> 00:00:53,666
and Polishing your

11
00:00:54,006 --> 00:00:56,286
Our compiler is based on LVM.

12
00:00:56,906 --> 00:00:58,546
And we work with the

13
00:00:58,546 --> 00:01:01,636
to make LVM more suitable

14
00:00:58,546 --> 00:01:01,636
to make LVM more suitable

15
00:01:03,806 --> 00:01:06,006
Here's a quick overview of

16
00:01:06,006 --> 00:01:06,856
in case you missed them,

17
00:01:06,856 --> 00:01:08,966
and don't worry you can

18
00:01:09,416 --> 00:01:11,736
Yesterday we had part one

19
00:01:12,326 --> 00:01:14,556
and earlier today we had part

20
00:01:14,616 --> 00:01:16,516
in Metal, because there's quite

21
00:01:17,326 --> 00:01:18,946
And of course here's

22
00:01:19,586 --> 00:01:20,786
the one you're watching

23
00:01:22,206 --> 00:01:24,646
So in this presentation we're

24
00:01:24,646 --> 00:01:26,956
of things you can do to

25
00:01:27,266 --> 00:01:28,696
to make your code faster.

26
00:01:29,566 --> 00:01:32,606
And some of this stuff is

27
00:01:32,606 --> 00:01:35,046
and later GPUs including

28
00:01:35,046 --> 00:01:36,636
that has never been

29
00:01:36,816 --> 00:01:39,176
And some of it will

30
00:01:39,466 --> 00:01:42,306
And we'll be noting that with

31
00:01:42,506 --> 00:01:44,996
for slides that are

32
00:01:46,056 --> 00:01:50,006
And additionally, we'll be

33
00:01:50,496 --> 00:01:53,036
That is things that may not

34
00:01:53,036 --> 00:01:55,466
of micro optimizations

35
00:01:55,826 --> 00:01:58,026
but if you run into these,

36
00:01:58,026 --> 00:02:01,486
so much performance, nothing is

37
00:01:58,026 --> 00:02:01,486
so much performance, nothing is

38
00:02:01,776 --> 00:02:04,226
So it's always worth making

39
00:02:04,566 --> 00:02:05,386
And those will be marked

40
00:02:05,386 --> 00:02:07,036
with the triangle icon,

41
00:02:08,205 --> 00:02:10,586
Before we go on, this

42
00:02:10,996 --> 00:02:12,136
This is the last step.

43
00:02:12,886 --> 00:02:15,446
There's no point to doing

44
00:02:15,446 --> 00:02:17,756
until you've done the

45
00:02:17,896 --> 00:02:19,466
like watching the

46
00:02:19,466 --> 00:02:21,766
from optimizing your

47
00:02:21,836 --> 00:02:22,976
of your engine and so forth.

48
00:02:23,656 --> 00:02:26,226
Optimizing your later shader

49
00:02:26,226 --> 00:02:28,036
you do.

50
00:02:28,036 --> 00:02:30,356
And, this presentation

51
00:02:30,436 --> 00:02:31,936
for experienced shader authors.

52
00:02:32,506 --> 00:02:34,766
Perhaps you've worked on Metal

53
00:02:34,766 --> 00:02:37,686
to get more into optimizing your

54
00:02:37,686 --> 00:02:40,286
to Metal, but you've done a

55
00:02:40,286 --> 00:02:42,346
on other platforms and

56
00:02:42,346 --> 00:02:44,276
to optimize better

57
00:02:44,276 --> 00:02:46,606
this is the presentation

58
00:02:48,396 --> 00:02:50,886
So you may have seen this

59
00:02:50,886 --> 00:02:51,916
of the previous Metal talks.

60
00:02:52,426 --> 00:02:54,436
And we will be focusing

61
00:02:54,496 --> 00:02:56,456
on the programmable

62
00:02:56,456 --> 00:02:58,316
as you can see there,

63
00:02:59,336 --> 00:03:00,596
So first, Alex is going to go

64
00:02:59,336 --> 00:03:00,596
So first, Alex is going to go

65
00:03:00,596 --> 00:03:02,506
over some shader

66
00:03:02,506 --> 00:03:03,536
and higher level issues.

67
00:03:03,916 --> 00:03:06,846
After which, I'll return

68
00:03:06,846 --> 00:03:09,096
down and dirty shader

69
00:03:12,516 --> 00:03:17,546
[ Applause ]

70
00:03:18,046 --> 00:03:18,456
&gt;&gt; Thanks, Fiona.

71
00:03:18,456 --> 00:03:19,956
Let me start by explaining

72
00:03:19,956 --> 00:03:21,256
of shader performance

73
00:03:21,776 --> 00:03:22,986
These are the things that

74
00:03:22,986 --> 00:03:24,616
that you have right

75
00:03:24,616 --> 00:03:26,116
into source level optimizations.

76
00:03:26,546 --> 00:03:27,776
Usually the impact of the kind

77
00:03:27,776 --> 00:03:29,716
of changes you'll

78
00:03:29,716 --> 00:03:32,176
or potentially hide other

79
00:03:32,176 --> 00:03:32,966
that you make elsewhere.

80
00:03:33,336 --> 00:03:34,936
So I'm going to talk

81
00:03:34,936 --> 00:03:36,716
Address space selection

82
00:03:37,226 --> 00:03:39,056
buffer preloading, dealing

83
00:03:39,056 --> 00:03:40,436
with fragment function

84
00:03:40,436 --> 00:03:42,276
and how to optimize

85
00:03:42,276 --> 00:03:45,676
So, let's start with

86
00:03:46,246 --> 00:03:48,886
So since this functionality

87
00:03:48,886 --> 00:03:50,596
in all shading languages,

88
00:03:50,866 --> 00:03:53,816
So, GPUs have multiple paths

89
00:03:53,816 --> 00:03:56,936
And these paths are optimized

90
00:03:57,086 --> 00:03:59,846
and they have different

91
00:04:00,706 --> 00:04:03,806
In Metal, we expose control

92
00:04:03,956 --> 00:04:06,926
to the developer by requiring

93
00:04:07,356 --> 00:04:09,386
arguments and pointers

94
00:04:09,386 --> 00:04:11,096
with which address

95
00:04:11,766 --> 00:04:14,726
So a couple of the address

96
00:04:14,726 --> 00:04:16,786
to getting information

97
00:04:17,055 --> 00:04:20,416
The first of which is

98
00:04:21,086 --> 00:04:23,296
This is an address space with

99
00:04:23,296 --> 00:04:25,016
You can read and write data

100
00:04:25,016 --> 00:04:28,076
you can pass as much data as

101
00:04:28,076 --> 00:04:30,756
that you specify at the API

102
00:04:30,756 --> 00:04:31,486
alignment requirements.

103
00:04:32,156 --> 00:04:35,866
On the other end of things, you

104
00:04:36,086 --> 00:04:38,246
As the name implies, this is

105
00:04:38,246 --> 00:04:39,856
but there are a couple of

106
00:04:40,316 --> 00:04:42,136
There are limits on how

107
00:04:42,256 --> 00:04:44,426
through this address space, and

108
00:04:44,426 --> 00:04:46,966
that you specify at the API

109
00:04:46,966 --> 00:04:47,716
alignment requirements.

110
00:04:48,296 --> 00:04:51,016
However, this is the address

111
00:04:51,016 --> 00:04:52,036
with a lot of data reuse.

112
00:04:52,036 --> 00:04:53,016
So you want to take advantage

113
00:04:53,016 --> 00:04:54,766
of this address space

114
00:04:55,786 --> 00:04:58,336
Figuring out whether or not the

115
00:04:58,336 --> 00:05:00,116
sense for your buffer

116
00:04:58,336 --> 00:05:00,116
sense for your buffer

117
00:05:00,116 --> 00:05:01,846
of asking yourself

118
00:05:02,636 --> 00:05:05,176
The first question is, do I

119
00:05:05,176 --> 00:05:07,786
And if you have a potentially

120
00:05:07,786 --> 00:05:08,946
this is usually a

121
00:05:08,946 --> 00:05:10,716
to be using the device

122
00:05:11,466 --> 00:05:14,656
Additionally, you want to

123
00:05:15,056 --> 00:05:16,526
in your buffer is being read.

124
00:05:16,576 --> 00:05:20,606
And if these items can

125
00:05:21,046 --> 00:05:22,756
this is usually a sign

126
00:05:22,756 --> 00:05:23,866
into the constant address space.

127
00:05:24,536 --> 00:05:27,016
So let's put this into practice

128
00:05:27,016 --> 00:05:28,726
from some vertex shaders.

129
00:05:29,496 --> 00:05:31,886
First, you have regular,

130
00:05:32,396 --> 00:05:36,376
So as you can see, each vertex

131
00:05:36,706 --> 00:05:39,046
And each vertex is the only one

132
00:05:39,046 --> 00:05:40,536
So there's essentially

133
00:05:40,536 --> 00:05:42,646
This is the kind of thing

134
00:05:42,646 --> 00:05:45,396
in the device address space.

135
00:05:46,816 --> 00:05:51,626
Next, you have projection

136
00:05:51,926 --> 00:05:55,426
Now, typically what you have

137
00:05:55,426 --> 00:05:59,926
of these objects, and they're

138
00:06:00,686 --> 00:06:03,206
So with this kind of complete

139
00:06:03,206 --> 00:06:04,636
to be in the constant

140
00:06:04,826 --> 00:06:09,036
Let's mix things up a little bit

141
00:06:09,036 --> 00:06:11,276
and take a look at

142
00:06:11,276 --> 00:06:14,816
So hopefully in this case

143
00:06:14,816 --> 00:06:15,836
of bones that you're handling.

144
00:06:16,706 --> 00:06:20,186
But if you look at each

145
00:06:20,186 --> 00:06:21,956
by every vertex that

146
00:06:21,956 --> 00:06:25,046
and that also is a potential

147
00:06:25,046 --> 00:06:26,086
And so this really ought to be

148
00:06:26,086 --> 00:06:29,116
on the constant address

149
00:06:29,316 --> 00:06:31,176
Finally, let's look

150
00:06:31,756 --> 00:06:35,266
As you can see all vertices

151
00:06:35,266 --> 00:06:37,756
in the instance will read

152
00:06:38,396 --> 00:06:40,916
but on the other hand you have

153
00:06:40,916 --> 00:06:42,396
of instances, so this

154
00:06:42,396 --> 00:06:44,226
in the device address

155
00:06:45,616 --> 00:06:48,356
For an example of why address

156
00:06:48,356 --> 00:06:49,406
for performance, let's move

157
00:06:49,406 --> 00:06:51,206
on to our next topic,

158
00:06:52,746 --> 00:06:55,226
So Fiona will spend some

159
00:06:55,226 --> 00:06:57,396
to actually optimize loads and

160
00:06:57,396 --> 00:06:59,856
but for many cases the best

161
00:06:59,856 --> 00:07:02,186
to actually off load this

162
00:06:59,856 --> 00:07:02,186
to actually off load this

163
00:07:02,676 --> 00:07:04,906
So we can do this

164
00:07:05,456 --> 00:07:06,856
context buffers and

165
00:07:07,616 --> 00:07:11,086
But this relies on knowing

166
00:07:11,086 --> 00:07:13,936
in your shaders and what address

167
00:07:14,866 --> 00:07:17,056
So let's start with

168
00:07:17,426 --> 00:07:20,136
So the idea here is

169
00:07:20,136 --> 00:07:21,156
through the constant

170
00:07:21,156 --> 00:07:23,016
what we can actually do is

171
00:07:23,016 --> 00:07:25,456
into special constant

172
00:07:25,456 --> 00:07:26,536
for the ALU to access.

173
00:07:27,286 --> 00:07:28,116
So we can do this as long

174
00:07:28,116 --> 00:07:29,826
as we know exactly

175
00:07:30,726 --> 00:07:32,776
If your offsets are

176
00:07:32,776 --> 00:07:33,786
this is straightforward.

177
00:07:34,036 --> 00:07:34,936
But if your offsets aren't known

178
00:07:34,936 --> 00:07:37,976
until run time then we need a

179
00:07:37,976 --> 00:07:39,416
about how much data

180
00:07:39,986 --> 00:07:42,346
So indicating this

181
00:07:42,346 --> 00:07:44,876
to the compiler is usually

182
00:07:45,016 --> 00:07:46,476
First, you need to make

183
00:07:46,476 --> 00:07:47,676
in the constant address space.

184
00:07:48,696 --> 00:07:50,256
And additionally

185
00:07:50,256 --> 00:07:51,696
that your accesses are

186
00:07:53,296 --> 00:07:55,436
The best way to do this

187
00:07:55,696 --> 00:07:57,726
by reference rather than

188
00:07:58,056 --> 00:08:00,676
If you're passing only a

189
00:07:58,056 --> 00:08:00,676
If you're passing only a

190
00:08:00,676 --> 00:08:02,396
this is straightforward, you

191
00:08:02,396 --> 00:08:05,106
to references and change

192
00:08:05,296 --> 00:08:07,976
This is a little different

193
00:08:07,976 --> 00:08:09,006
that you know is bounded.

194
00:08:09,666 --> 00:08:12,656
So what you do in this case is

195
00:08:12,656 --> 00:08:14,946
and pass that struct

196
00:08:14,946 --> 00:08:16,176
than passing the

197
00:08:16,936 --> 00:08:18,966
So we can put this into

198
00:08:19,536 --> 00:08:21,426
at a forward lighting

199
00:08:21,776 --> 00:08:23,176
So as you can see in sort

200
00:08:23,176 --> 00:08:26,246
of the original version what we

201
00:08:26,246 --> 00:08:27,756
that are passed as

202
00:08:27,756 --> 00:08:29,806
And this doesn't expose the

203
00:08:30,616 --> 00:08:31,586
So we can do better than this.

204
00:08:32,306 --> 00:08:33,676
Instead if we note the number

205
00:08:33,676 --> 00:08:36,946
of lights is bonded what we can

206
00:08:36,946 --> 00:08:39,056
and the count together into

207
00:08:40,356 --> 00:08:43,116
And we can pass that struct

208
00:08:43,116 --> 00:08:43,986
as a reference like this.

209
00:08:44,616 --> 00:08:46,526
And so that gets us

210
00:08:48,366 --> 00:08:49,346
Let's look at another example

211
00:08:49,346 --> 00:08:51,086
of how this can affect

212
00:08:52,156 --> 00:08:55,206
So, there are many ways to

213
00:08:55,206 --> 00:08:57,786
but what we find is that the

214
00:08:57,786 --> 00:09:00,036
that you make can have a big

215
00:08:57,786 --> 00:09:00,036
that you make can have a big

216
00:09:00,036 --> 00:09:01,236
that you achieve in practice.

217
00:09:01,696 --> 00:09:05,496
One pattern that's common

218
00:09:05,496 --> 00:09:07,456
to accumulate the

219
00:09:08,456 --> 00:09:10,776
And what you can see form the

220
00:09:10,776 --> 00:09:13,436
is that it can potentially read

221
00:09:13,436 --> 00:09:15,306
and that means that your

222
00:09:15,306 --> 00:09:20,026
Now, on the other hand if you're

223
00:09:20,026 --> 00:09:21,246
such that each light is handled

224
00:09:21,246 --> 00:09:24,006
in its own draw call

225
00:09:24,006 --> 00:09:27,206
that each light only needs

226
00:09:27,206 --> 00:09:29,506
and it's shader and that

227
00:09:29,536 --> 00:09:31,666
in the constant address space

228
00:09:32,026 --> 00:09:33,476
and take advantage

229
00:09:34,336 --> 00:09:36,546
In practice we see

230
00:09:36,546 --> 00:09:38,176
that this is a significant

231
00:09:38,176 --> 00:09:42,416
Now let's talk about

232
00:09:42,776 --> 00:09:44,386
The idea of vertex

233
00:09:44,386 --> 00:09:46,656
to reuse the same dedicated

234
00:09:46,656 --> 00:09:47,936
for a fix function

235
00:09:48,226 --> 00:09:51,666
And we can do this for regular

236
00:09:51,666 --> 00:09:53,216
that you access your

237
00:09:53,216 --> 00:09:54,456
like fix function

238
00:09:54,876 --> 00:09:55,896
So what that means

239
00:09:55,896 --> 00:09:58,976
to be indexing using the

240
00:09:59,046 --> 00:10:01,316
Now we can handle a couple

241
00:09:59,046 --> 00:10:01,316
Now we can handle a couple

242
00:10:01,316 --> 00:10:04,216
to the vertex or instance IDs

243
00:10:04,216 --> 00:10:06,916
and that's with or

244
00:10:06,916 --> 00:10:09,216
or instance offsets you might

245
00:10:09,876 --> 00:10:12,206
Of course the easiest way to

246
00:10:12,206 --> 00:10:15,116
to use the Metal vertex

247
00:10:15,116 --> 00:10:15,926
wherever possible.

248
00:10:15,926 --> 00:10:18,156
But if you are writing

249
00:10:18,826 --> 00:10:20,496
we strongly suggest that

250
00:10:20,496 --> 00:10:23,126
so that vertexes fetch linearly

251
00:10:23,366 --> 00:10:26,196
Note that this doesn't preclude

252
00:10:26,196 --> 00:10:28,996
like if you were rendering quads

253
00:10:29,446 --> 00:10:33,256
to all vertices in the quad,

254
00:10:33,256 --> 00:10:35,526
like indexing by vertex

255
00:10:35,526 --> 00:10:36,926
because this just

256
00:10:38,106 --> 00:10:42,086
So now let's move on to a couple

257
00:10:42,686 --> 00:10:47,016
In iOS 10 we introduced the

258
00:10:47,016 --> 00:10:48,436
from within your

259
00:10:48,626 --> 00:10:50,186
And this has interesting

260
00:10:50,186 --> 00:10:51,156
for hidden surface removal.

261
00:10:52,246 --> 00:10:54,446
So prior to this you might have

262
00:10:54,446 --> 00:10:57,386
that a fragment wouldn't

263
00:10:57,386 --> 00:10:59,286
as an opaque fragment

264
00:10:59,956 --> 00:11:02,176
So this is no longer

265
00:10:59,956 --> 00:11:02,176
So this is no longer

266
00:11:02,176 --> 00:11:03,926
if your fragment function

267
00:11:03,926 --> 00:11:05,656
because those resource

268
00:11:06,836 --> 00:11:09,046
So instead your behavior

269
00:11:09,346 --> 00:11:10,346
on what's come before.

270
00:11:10,346 --> 00:11:12,956
And specifically what

271
00:11:12,956 --> 00:11:14,776
or not you've enabled

272
00:11:14,776 --> 00:11:15,686
on your fragment function.

273
00:11:16,116 --> 00:11:19,236
If you have enabled

274
00:11:19,916 --> 00:11:21,296
once it's rasterized as long

275
00:11:21,296 --> 00:11:23,666
as it also passes the early

276
00:11:24,066 --> 00:11:26,366
If you haven't specified

277
00:11:26,496 --> 00:11:28,146
then your fragment

278
00:11:28,146 --> 00:11:29,306
as long as it's rasterized.

279
00:11:30,136 --> 00:11:32,276
So from a perspective of

280
00:11:32,276 --> 00:11:34,376
what you want to do is

281
00:11:34,376 --> 00:11:35,116
wherever possible.

282
00:11:35,116 --> 00:11:36,466
But there are a couple

283
00:11:36,466 --> 00:11:38,536
that you can do to improve

284
00:11:39,676 --> 00:11:41,796
And most of these boil

285
00:11:41,836 --> 00:11:44,406
You want to draw these objects,

286
00:11:44,466 --> 00:11:47,046
the objects where the fragment

287
00:11:47,376 --> 00:11:48,516
after opaque objects.

288
00:11:48,716 --> 00:11:50,586
And if you're using these

289
00:11:50,586 --> 00:11:52,536
and stencil buffers,

290
00:11:52,536 --> 00:11:54,766
that you sort these

291
00:11:55,646 --> 00:11:57,816
Note that this guidance

292
00:11:57,816 --> 00:11:59,506
if you've been dealing

293
00:11:59,506 --> 00:12:01,676
that do discard or modify

294
00:11:59,506 --> 00:12:01,676
that do discard or modify

295
00:12:01,676 --> 00:12:05,536
Now let's talk about

296
00:12:05,736 --> 00:12:08,546
Since the defining

297
00:12:08,546 --> 00:12:10,366
that you can structure your

298
00:12:11,036 --> 00:12:14,736
Let's talk about what factors

299
00:12:14,796 --> 00:12:16,386
on iOS.

300
00:12:17,076 --> 00:12:19,226
First we have computer

301
00:12:20,576 --> 00:12:24,856
So on A8 and later GPUs

302
00:12:24,856 --> 00:12:27,486
that it takes to launch a

303
00:12:27,586 --> 00:12:28,836
So if you don't do enough work

304
00:12:28,836 --> 00:12:31,376
from within a single compute

305
00:12:31,376 --> 00:12:33,036
it leaves the hardware

306
00:12:33,036 --> 00:12:34,266
and leave performance

307
00:12:36,046 --> 00:12:38,716
And a good way to deal with

308
00:12:38,716 --> 00:12:41,116
for writing computer

309
00:12:41,116 --> 00:12:43,466
to actually process multiple

310
00:12:43,466 --> 00:12:44,666
in a single compute threat.

311
00:12:45,166 --> 00:12:48,276
And in particular a pattern

312
00:12:48,276 --> 00:12:50,416
to reuse values not

313
00:12:50,416 --> 00:12:53,586
through thread group memory, but

314
00:12:53,586 --> 00:12:57,106
for one work item when you're

315
00:12:57,296 --> 00:12:58,426
in the same compute thread.

316
00:12:58,426 --> 00:13:00,916
And it's best to illustrate

317
00:12:58,426 --> 00:13:00,916
And it's best to illustrate

318
00:13:01,696 --> 00:13:04,226
So this is a syllable

319
00:13:04,226 --> 00:13:06,226
of the most straightforward

320
00:13:06,226 --> 00:13:07,966
it reads as a three-

321
00:13:08,366 --> 00:13:10,576
and produces one output pixel.

322
00:13:11,146 --> 00:13:15,696
So if instead we

323
00:13:15,696 --> 00:13:17,416
of processing multiple

324
00:13:17,876 --> 00:13:18,876
in a single compute thread,

325
00:13:18,876 --> 00:13:20,476
we get something

326
00:13:21,086 --> 00:13:24,536
Notice now that we're striding

327
00:13:24,916 --> 00:13:27,126
So processing the first pixel

328
00:13:27,126 --> 00:13:28,556
We read the 3 by 3 region.

329
00:13:29,046 --> 00:13:31,246
We apply the filter and

330
00:13:31,786 --> 00:13:34,716
But now let's look at

331
00:13:35,006 --> 00:13:38,516
So stents are striding by

332
00:13:38,516 --> 00:13:40,426
to make sure that there is

333
00:13:41,486 --> 00:13:42,546
And now we read its data.

334
00:13:43,386 --> 00:13:45,536
Note here that a 2 by 3 region

335
00:13:45,536 --> 00:13:47,576
of what this pixel

336
00:13:47,576 --> 00:13:48,416
by the previous pixel.

337
00:13:48,416 --> 00:13:49,376
So we don't need

338
00:13:49,376 --> 00:13:50,776
we can reuse those old values.

339
00:13:51,016 --> 00:13:52,396
All we need to load now is the 1

340
00:13:52,396 --> 00:13:54,646
by 3 region that's

341
00:13:55,786 --> 00:13:58,166
After which, we can apply

342
00:13:58,916 --> 00:14:02,496
Note that as a result we're

343
00:13:58,916 --> 00:14:02,496
Note that as a result we're

344
00:14:02,496 --> 00:14:05,276
instead of the old 9, but

345
00:14:05,276 --> 00:14:07,816
So this is a significant

346
00:14:07,816 --> 00:14:09,126
of texture reads per pixel.

347
00:14:09,866 --> 00:14:13,466
Of course this pattern doesn't

348
00:14:14,026 --> 00:14:16,086
Sometimes you do still

349
00:14:16,086 --> 00:14:16,856
through thread group memory.

350
00:14:17,456 --> 00:14:20,396
And in that case, when you're

351
00:14:20,396 --> 00:14:24,286
in a thread group, an important

352
00:14:24,286 --> 00:14:26,906
that you want to use the barrier

353
00:14:26,906 --> 00:14:28,476
for the threads that

354
00:14:29,326 --> 00:14:33,436
In particular, if your thread

355
00:14:34,116 --> 00:14:35,966
the regular thread

356
00:14:35,966 --> 00:14:37,156
in Metal is unnecessary.

357
00:14:37,626 --> 00:14:41,346
What you can use instead is the

358
00:14:41,346 --> 00:14:42,536
introduced in iOS 10.

359
00:14:43,476 --> 00:14:47,076
And what we find is actually

360
00:14:47,076 --> 00:14:48,336
to fit within a single SIMD

361
00:14:48,336 --> 00:14:52,426
and using SIMD group barrier

362
00:14:52,426 --> 00:14:54,406
to use a larger thread

363
00:14:54,406 --> 00:14:55,266
that additional reuse,

364
00:14:55,266 --> 00:14:57,146
but having to use thread

365
00:14:57,706 --> 00:15:01,136
So that wraps things up

366
00:14:57,706 --> 00:15:01,136
So that wraps things up

367
00:15:01,946 --> 00:15:04,596
make sure you're using the

368
00:15:04,596 --> 00:15:06,106
for each of your buffer

369
00:15:06,106 --> 00:15:07,386
to the guidelines

370
00:15:08,546 --> 00:15:09,916
Structure your data

371
00:15:09,916 --> 00:15:11,696
to take maximal advantage

372
00:15:11,696 --> 00:15:12,996
and vertex buffer preloading.

373
00:15:14,526 --> 00:15:16,426
Make sure you're using early

374
00:15:16,426 --> 00:15:18,576
as many fragments as possible

375
00:15:18,646 --> 00:15:19,796
when you're doing

376
00:15:20,336 --> 00:15:23,096
Put enough work in

377
00:15:23,096 --> 00:15:24,386
so you're not being limited

378
00:15:24,386 --> 00:15:26,506
by your compute thread

379
00:15:27,056 --> 00:15:29,336
And use the smallest barrier

380
00:15:29,336 --> 00:15:31,126
to synchronize between

381
00:15:31,446 --> 00:15:33,926
And with that I'd like to pass

382
00:15:33,926 --> 00:15:34,796
into tuning shader code.

383
00:15:35,516 --> 00:15:40,956
[ Applause ]

384
00:15:41,456 --> 00:15:42,006
&gt;&gt; Thank you, Alex.

385
00:15:43,306 --> 00:15:46,476
So, before jumping into the

386
00:15:46,476 --> 00:15:48,686
over some general

387
00:15:48,686 --> 00:15:50,846
and the bottlenecks

388
00:15:50,846 --> 00:15:52,336
And all of you may be

389
00:15:52,536 --> 00:15:54,146
but I figure I should

390
00:15:54,836 --> 00:15:58,596
So with GPUs typically you

391
00:15:58,696 --> 00:16:01,116
And it's fairly common for

392
00:15:58,696 --> 00:16:01,116
And it's fairly common for

393
00:16:01,116 --> 00:16:02,336
by one of those resources.

394
00:16:02,596 --> 00:16:04,186
And so for example if

395
00:16:04,186 --> 00:16:06,406
by memory bandwidth,

396
00:16:06,406 --> 00:16:08,836
in your shader will often

397
00:16:08,886 --> 00:16:09,966
performance improvement.

398
00:16:10,616 --> 00:16:13,036
And while it is important to

399
00:16:13,036 --> 00:16:15,846
and focus on them to

400
00:16:16,356 --> 00:16:18,796
there is actually still

401
00:16:18,796 --> 00:16:19,826
that aren't bottlenecks.

402
00:16:19,826 --> 00:16:22,336
For example, in that example

403
00:16:22,336 --> 00:16:25,356
at memory usage, but then

404
00:16:25,356 --> 00:16:28,866
to be more efficient, you

405
00:16:28,866 --> 00:16:30,566
if you are not improving

406
00:16:30,726 --> 00:16:32,046
And of course being on mobile,

407
00:16:32,346 --> 00:16:34,016
saving power is always

408
00:16:34,286 --> 00:16:35,996
So it's not something to ignore,

409
00:16:36,106 --> 00:16:38,536
just because your frame rate

410
00:16:38,696 --> 00:16:41,256
So there's four typical

411
00:16:41,256 --> 00:16:43,506
in mind in shaders here.

412
00:16:43,656 --> 00:16:45,596
The first is fairly

413
00:16:45,846 --> 00:16:47,696
The amount of math

414
00:16:48,626 --> 00:16:50,936
The second is memory bandwidth,

415
00:16:50,966 --> 00:16:53,746
the amount of data that the GPU

416
00:16:54,116 --> 00:16:55,846
The other two are

417
00:16:55,846 --> 00:16:57,716
The first one is

418
00:16:58,076 --> 00:17:00,466
Which represents the

419
00:16:58,076 --> 00:17:00,466
Which represents the

420
00:17:00,466 --> 00:17:01,486
that can be performed.

421
00:17:01,946 --> 00:17:04,026
And this can come up in the case

422
00:17:04,066 --> 00:17:06,086
where you have smaller

423
00:17:06,086 --> 00:17:08,346
or you're using a lot of thread

424
00:17:09,096 --> 00:17:11,236
And the last one, which I'll

425
00:17:11,236 --> 00:17:13,816
about later is latency

426
00:17:13,816 --> 00:17:15,146
You may have heard about that,

427
00:17:15,226 --> 00:17:17,236
but I will save that

428
00:17:18,616 --> 00:17:20,656
So to try to alleviate

429
00:17:20,656 --> 00:17:23,116
and improve overall shader

430
00:17:23,455 --> 00:17:25,136
we're going to look

431
00:17:25,165 --> 00:17:26,766
of optimization opportunity

432
00:17:27,665 --> 00:17:28,996
And the first one is data types.

433
00:17:29,076 --> 00:17:31,376
And the first thing to consider

434
00:17:31,376 --> 00:17:34,366
when optimizing your shader

435
00:17:34,846 --> 00:17:36,726
And the most important

436
00:17:36,726 --> 00:17:38,726
when you're choosing

437
00:17:38,726 --> 00:17:42,206
and later GPUs have

438
00:17:42,856 --> 00:17:45,846
which means that for example if

439
00:17:45,916 --> 00:17:49,226
that's twice the register

440
00:17:49,756 --> 00:17:51,916
potentially twice the

441
00:17:52,316 --> 00:17:53,826
it's just twice as much stuff.

442
00:17:54,626 --> 00:17:57,116
So, accordingly you

443
00:17:57,116 --> 00:18:00,026
you will get faster performance,

444
00:17:57,116 --> 00:18:00,026
you will get faster performance,

445
00:18:00,266 --> 00:18:01,706
by using smaller data types.

446
00:18:02,006 --> 00:18:04,496
Use half and short for

447
00:18:05,276 --> 00:18:07,226
Energy wise, half is

448
00:18:07,766 --> 00:18:09,526
And float is cheaper

449
00:18:09,886 --> 00:18:12,676
but even among integers,

450
00:18:12,676 --> 00:18:13,296
than bigger ones.

451
00:18:13,866 --> 00:18:17,136
And the most effective thing

452
00:18:17,136 --> 00:18:20,816
to use half for texture reads

453
00:18:20,816 --> 00:18:23,036
of the time you really do

454
00:18:23,446 --> 00:18:26,166
And note I do not mean

455
00:18:26,226 --> 00:18:29,006
I mean the data types you're

456
00:18:29,006 --> 00:18:30,806
of a texture sample

457
00:18:32,116 --> 00:18:36,656
And one aspect of A8 in later

458
00:18:37,146 --> 00:18:39,346
and makes using smaller

459
00:18:39,346 --> 00:18:40,656
than on some other GPUs is

460
00:18:40,986 --> 00:18:43,986
that data type conversions

461
00:18:44,166 --> 00:18:48,226
even between float and half,

462
00:18:48,256 --> 00:18:51,336
to worry, oh am I introducing

463
00:18:51,336 --> 00:18:53,006
by trying to use half here?

464
00:18:53,266 --> 00:18:54,496
Is this going to cost too much?

465
00:18:54,496 --> 00:18:55,286
Is it worth it or not?

466
00:18:55,746 --> 00:18:58,266
No it's probably fast because

467
00:18:58,626 --> 00:19:00,576
so you can use half wherever

468
00:18:58,626 --> 00:19:00,576
so you can use half wherever

469
00:19:00,576 --> 00:19:01,626
about that part of it.

470
00:19:01,766 --> 00:19:03,526
The one thing to keep

471
00:19:03,586 --> 00:19:05,356
that half-precision numerics

472
00:19:05,356 --> 00:19:08,106
and limitations are

473
00:19:08,996 --> 00:19:11,496
And a common bug

474
00:19:11,496 --> 00:19:16,386
for example is people will

475
00:19:17,506 --> 00:19:19,766
but that is actually infinity.

476
00:19:20,236 --> 00:19:22,666
Because that's bigger

477
00:19:22,666 --> 00:19:25,116
And so by being aware of

478
00:19:25,116 --> 00:19:27,146
you'll better be able to

479
00:19:27,146 --> 00:19:28,486
and shouldn't use half.

480
00:19:28,486 --> 00:19:31,116
And less likely to encounter

481
00:19:32,076 --> 00:19:34,216
So one example application

482
00:19:34,216 --> 00:19:38,766
for using smaller integer

483
00:19:39,356 --> 00:19:41,976
And as those of you who worked

484
00:19:41,976 --> 00:19:44,506
thread IDs are used

485
00:19:45,076 --> 00:19:47,916
And so making them smaller

486
00:19:47,966 --> 00:19:51,796
performance of arithmetic, and

487
00:19:52,696 --> 00:19:57,076
And so local thread IDs, there's

488
00:19:57,176 --> 00:19:58,616
for them as in this case,

489
00:19:58,936 --> 00:20:01,436
because local thread IDs can't

490
00:19:58,936 --> 00:20:01,436
because local thread IDs can't

491
00:20:02,076 --> 00:20:04,836
For global thread IDs, usually

492
00:20:05,316 --> 00:20:06,946
because most of the

493
00:20:06,946 --> 00:20:08,316
that many global tread IDs.

494
00:20:08,316 --> 00:20:09,646
Of course it depends

495
00:20:10,056 --> 00:20:13,786
But in most cases, you won't

496
00:20:14,276 --> 00:20:15,526
so it is said you can do this.

497
00:20:16,186 --> 00:20:19,426
And this is going to be lower

498
00:20:19,426 --> 00:20:22,326
because all of the arithmetic

499
00:20:22,326 --> 00:20:23,296
going to be faster.

500
00:20:23,576 --> 00:20:28,076
So I highly recommend

501
00:20:28,636 --> 00:20:31,696
Additionally, keep in mind

502
00:20:31,696 --> 00:20:33,856
which of course includes

503
00:20:33,856 --> 00:20:37,126
of an operation is defined by

504
00:20:37,886 --> 00:20:39,946
For example, if you're

505
00:20:40,276 --> 00:20:43,566
that's a float operation not a

506
00:20:44,156 --> 00:20:47,456
So accordingly, make sure

507
00:20:47,456 --> 00:20:51,386
when not necessary, because

508
00:20:51,436 --> 00:20:53,786
to be a half operation, it

509
00:20:54,256 --> 00:20:55,546
into a float operation.

510
00:20:55,586 --> 00:20:57,126
Because by the language

511
00:20:57,126 --> 00:20:59,886
that's actually a float

512
00:20:59,886 --> 00:21:01,056
of the inputs is float.

513
00:20:59,886 --> 00:21:01,056
of the inputs is float.

514
00:21:01,856 --> 00:21:03,776
And so you probably

515
00:21:04,636 --> 00:21:06,516
This will actually

516
00:21:06,516 --> 00:21:08,116
This will actually be faster.

517
00:21:08,696 --> 00:21:10,206
This is probably what you mean.

518
00:21:10,556 --> 00:21:11,586
So be careful not

519
00:21:11,586 --> 00:21:14,066
to inadvertently introduce

520
00:21:14,066 --> 00:21:19,216
into your code when

521
00:21:19,216 --> 00:21:21,836
And while I did mention that

522
00:21:21,836 --> 00:21:24,556
there's one exception to

523
00:21:25,156 --> 00:21:27,606
Remember as I said that

524
00:21:27,606 --> 00:21:30,686
and later GPUs is

525
00:21:31,466 --> 00:21:34,806
And so char is not going to

526
00:21:34,806 --> 00:21:35,606
or anything like that

527
00:21:35,606 --> 00:21:38,126
and furthermore there's no

528
00:21:38,506 --> 00:21:40,006
So it sort of has

529
00:21:40,246 --> 00:21:43,296
It's not overly expensive if you

530
00:21:43,616 --> 00:21:45,616
But it may result in

531
00:21:45,836 --> 00:21:48,746
So don't unnecessarily

532
00:21:48,746 --> 00:21:53,706
that don't actually need it.

533
00:21:53,966 --> 00:21:57,216
So next we have arithmetic

534
00:21:57,436 --> 00:21:58,826
and pretty much everything

535
00:21:58,826 --> 00:22:00,946
in this category

536
00:21:58,826 --> 00:22:00,946
in this category

537
00:22:01,416 --> 00:22:05,106
The first thing you can do

538
00:22:05,106 --> 00:22:05,856
whenever possible.

539
00:22:06,336 --> 00:22:07,846
They're optimized

540
00:22:07,846 --> 00:22:09,016
for a variety of functions.

541
00:22:09,206 --> 00:22:11,006
They're already optimized

542
00:22:11,316 --> 00:22:13,426
It's generally better than

543
00:22:14,426 --> 00:22:18,076
And in particular,

544
00:22:18,156 --> 00:22:20,256
that are usually

545
00:22:21,446 --> 00:22:24,416
And this is because GPUs

546
00:22:24,526 --> 00:22:27,176
Operations that can be

547
00:22:27,176 --> 00:22:28,406
and output of instructions.

548
00:22:28,956 --> 00:22:31,876
And for A8 and later GPUs

549
00:22:32,246 --> 00:22:35,176
absolute value, and

550
00:22:35,176 --> 00:22:36,686
these three operations in green.

551
00:22:37,076 --> 00:22:41,666
So, there's no point to trying

552
00:22:41,666 --> 00:22:44,046
up your code by avoiding

553
00:22:44,046 --> 00:22:45,386
they're almost always free.

554
00:22:45,716 --> 00:22:48,426
And because they're free,

555
00:22:48,426 --> 00:22:50,306
There's no way to

556
00:22:50,956 --> 00:22:54,486
A8 and later GPUs, like a lot

557
00:22:54,486 --> 00:22:56,556
of others nowadays,

558
00:22:57,226 --> 00:22:59,586
And while shaders are

559
00:22:59,636 --> 00:23:02,386
the compiler is going to split

560
00:22:59,636 --> 00:23:02,386
the compiler is going to split

561
00:23:02,866 --> 00:23:05,256
Of course, there's no downside

562
00:23:05,906 --> 00:23:08,996
I mean often it's clearer,

563
00:23:09,026 --> 00:23:12,496
often it fits what you're trying

564
00:23:12,496 --> 00:23:15,076
than writing scaler code

565
00:23:15,076 --> 00:23:15,936
and the code you're

566
00:23:16,546 --> 00:23:19,456
So there's no point in

567
00:23:19,456 --> 00:23:23,126
that doesn't really fit a vector

568
00:23:23,126 --> 00:23:24,776
to end up the same

569
00:23:24,866 --> 00:23:27,066
and you're kind of

570
00:23:27,326 --> 00:23:29,216
However, as a side

571
00:23:29,216 --> 00:23:32,146
into more detail a lot later,

572
00:23:32,146 --> 00:23:35,186
do have vector load in store

573
00:23:35,186 --> 00:23:36,156
vector arithmetic.

574
00:23:36,596 --> 00:23:38,926
So this only applies

575
00:23:41,006 --> 00:23:43,626
Instruction Level Parallelism

576
00:23:43,626 --> 00:23:45,326
of you may have used

577
00:23:45,326 --> 00:23:47,336
especially if you've

578
00:23:47,866 --> 00:23:51,896
But on A8 and later GPUs this

579
00:23:51,896 --> 00:23:54,176
to try to optimize for

580
00:23:54,176 --> 00:23:55,266
against registry usage,

581
00:23:55,266 --> 00:23:57,376
and registry usage

582
00:23:57,966 --> 00:24:01,096
So a common pattern you may

583
00:23:57,966 --> 00:24:01,096
So a common pattern you may

584
00:24:01,096 --> 00:24:03,406
where you have multiple

585
00:24:03,406 --> 00:24:07,016
to better deal with

586
00:24:07,816 --> 00:24:11,376
But on A8 and later GPUs this

587
00:24:11,776 --> 00:24:13,906
You'd be better off just

588
00:24:14,156 --> 00:24:16,606
Of course this applies to

589
00:24:16,656 --> 00:24:18,686
than the artificial

590
00:24:19,256 --> 00:24:21,986
Just write what you mean, don't

591
00:24:21,986 --> 00:24:23,346
to get more ILP out of it.

592
00:24:23,346 --> 00:24:26,166
It's probably not going to

593
00:24:26,166 --> 00:24:28,906
you just might get worse code.

594
00:24:29,686 --> 00:24:33,306
So one fairly nice feature

595
00:24:33,386 --> 00:24:35,916
that they have very

596
00:24:35,916 --> 00:24:37,746
that is the ternary operator.

597
00:24:38,476 --> 00:24:40,966
And historically it's

598
00:24:40,966 --> 00:24:43,536
to use clever tricks,

599
00:24:43,536 --> 00:24:46,536
to perform select

600
00:24:46,916 --> 00:24:49,066
to avoid those branches

601
00:24:49,596 --> 00:24:52,986
But on modern GPUs this is

602
00:24:52,986 --> 00:24:56,846
and especially on A8 later GPUs

603
00:24:56,846 --> 00:24:57,786
through this cleverness.

604
00:24:57,786 --> 00:25:00,116
It's not going to figure

605
00:24:57,786 --> 00:25:00,116
It's not going to figure

606
00:25:00,646 --> 00:25:02,776
And really, this is really ugly.

607
00:25:03,586 --> 00:25:04,756
You could just have

608
00:25:04,756 --> 00:25:07,596
And this is going to be faster,

609
00:25:07,596 --> 00:25:08,246
to show what you mean.

610
00:25:08,966 --> 00:25:12,776
Like before, being overly clever

611
00:25:12,776 --> 00:25:14,656
trying to do and

612
00:25:16,846 --> 00:25:18,676
Now, this is a potential

613
00:25:18,676 --> 00:25:20,116
hopefully this won't

614
00:25:21,066 --> 00:25:26,106
On modern GPUs most of them

615
00:25:26,106 --> 00:25:28,796
or modulus instructions,

616
00:25:29,616 --> 00:25:33,876
So avoid divisional

617
00:25:33,906 --> 00:25:36,666
that are not literal

618
00:25:36,746 --> 00:25:38,876
the new feature mentioned in

619
00:25:39,556 --> 00:25:43,036
So in this example, what we

620
00:25:43,036 --> 00:25:45,426
where the denominator

621
00:25:45,736 --> 00:25:47,756
that will be very, very slow.

622
00:25:47,756 --> 00:25:49,356
Think hundreds of clock seconds.

623
00:25:50,346 --> 00:25:52,506
But these other two examples,

624
00:25:52,736 --> 00:25:53,256
Those are fine.

625
00:25:53,626 --> 00:25:56,926
So don't feel like you

626
00:25:57,616 --> 00:25:59,976
So, finally the topic

627
00:26:00,996 --> 00:26:04,166
So in Metal, fast-math

628
00:26:04,416 --> 00:26:07,286
And this is because compiler

629
00:26:07,576 --> 00:26:09,616
critical to performance

630
00:26:10,046 --> 00:26:13,156
They can give off in 50%

631
00:26:13,396 --> 00:26:14,946
over having fast-math off.

632
00:26:14,946 --> 00:26:16,466
So it's no wonder

633
00:26:17,236 --> 00:26:20,226
And so what exactly do

634
00:26:20,846 --> 00:26:22,396
Well, the first is that some

635
00:26:22,546 --> 00:26:25,206
of the Metal built-in functions

636
00:26:25,206 --> 00:26:27,646
guarantees between

637
00:26:27,646 --> 00:26:30,146
And so in some of them they will

638
00:26:30,436 --> 00:26:33,236
in fast-math mode to

639
00:26:34,576 --> 00:26:37,626
The compiler may increase

640
00:26:37,626 --> 00:26:39,886
of your operations like

641
00:26:39,886 --> 00:26:40,686
add instructions.

642
00:26:41,306 --> 00:26:44,206
It will not decrease the

643
00:26:44,696 --> 00:26:48,086
So for example if you write a

644
00:26:48,086 --> 00:26:50,296
operation that is at

645
00:26:50,376 --> 00:26:51,566
Not a math operation.

646
00:26:52,096 --> 00:26:54,386
So if you want to write half

647
00:26:54,466 --> 00:26:56,576
that, the compiler will

648
00:26:56,576 --> 00:26:57,556
because it's not allowed to.

649
00:26:57,626 --> 00:27:00,456
It can't your precision

650
00:26:57,626 --> 00:27:00,456
It can't your precision

651
00:27:00,976 --> 00:27:03,896
We do ignore strict if not

652
00:27:03,896 --> 00:27:06,686
and sign zero semantics,

653
00:27:06,686 --> 00:27:08,986
because without that

654
00:27:08,986 --> 00:27:10,926
that x times zero

655
00:27:11,906 --> 00:27:16,246
But we will not introduce a new

656
00:27:16,666 --> 00:27:20,466
because in practice

657
00:27:20,466 --> 00:27:22,496
to annoy developers,

658
00:27:22,496 --> 00:27:25,256
and we don't want to do that.

659
00:27:25,256 --> 00:27:28,576
And the compiler will perform

660
00:27:28,846 --> 00:27:30,676
but it will not do

661
00:27:30,676 --> 00:27:34,046
And really this just comes

662
00:27:34,046 --> 00:27:36,356
and makes it faster versus

663
00:27:36,526 --> 00:27:38,406
And we don't want to break code.

664
00:27:39,476 --> 00:27:44,006
So if you absolutely cannot use

665
00:27:44,446 --> 00:27:47,116
there are some ways to recover

666
00:27:48,156 --> 00:27:51,866
Metal has a fused multiply-add

667
00:27:52,286 --> 00:27:54,266
Which allows you to

668
00:27:54,266 --> 00:27:55,496
multiply-add instructions.

669
00:27:55,806 --> 00:27:57,146
And of course if

670
00:27:57,146 --> 00:27:59,336
the compiler is not even

671
00:27:59,386 --> 00:28:02,866
it cannot change one bit of

672
00:27:59,386 --> 00:28:02,866
it cannot change one bit of

673
00:28:03,366 --> 00:28:05,886
So if you want to use

674
00:28:05,886 --> 00:28:07,296
and fast-math is

675
00:28:07,296 --> 00:28:08,406
to have to use the built-in.

676
00:28:08,526 --> 00:28:11,086
And that will regain

677
00:28:11,476 --> 00:28:14,896
not all of it, but

678
00:28:15,136 --> 00:28:17,386
So, on our third

679
00:28:18,456 --> 00:28:21,116
Predicated GP control flow

680
00:28:21,116 --> 00:28:22,856
of you may already

681
00:28:22,896 --> 00:28:24,826
But here's a quick review

682
00:28:25,606 --> 00:28:28,046
Control flow that is

683
00:28:28,046 --> 00:28:30,016
that is every thread is

684
00:28:30,496 --> 00:28:31,326
is generally fast.

685
00:28:31,856 --> 00:28:35,056
And this is true even if

686
00:28:35,566 --> 00:28:39,776
So if your program doesn't

687
00:28:39,826 --> 00:28:44,786
to be uniform when it runs,

688
00:28:44,786 --> 00:28:46,936
And similarly, the

689
00:28:46,936 --> 00:28:50,476
different lanes doing different

690
00:28:50,476 --> 00:28:52,346
it potentially may

691
00:28:52,346 --> 00:28:55,476
of the different paths

692
00:28:55,476 --> 00:28:57,746
which only takes

693
00:28:58,386 --> 00:29:01,876
And as a result it does more

694
00:28:58,386 --> 00:29:01,876
And as a result it does more

695
00:29:01,906 --> 00:29:04,126
that inefficient control

696
00:29:04,126 --> 00:29:06,696
of the bottlenecks, because it

697
00:29:06,756 --> 00:29:09,396
doing more stuff, whatever

698
00:29:11,246 --> 00:29:16,176
So, the one suggestion I'll make

699
00:29:16,176 --> 00:29:18,376
to avoid switch fall-throughs.

700
00:29:18,666 --> 00:29:20,786
And these are fairly

701
00:29:21,096 --> 00:29:24,006
But on GPUs they can potentially

702
00:29:24,266 --> 00:29:28,446
because the compiler has to do

703
00:29:28,446 --> 00:29:30,806
to make them fit within the

704
00:29:30,806 --> 00:29:34,006
And often this will involve

705
00:29:34,006 --> 00:29:36,636
of nasty things you probably

706
00:29:37,216 --> 00:29:39,966
So if you can find a nice way to

707
00:29:39,966 --> 00:29:41,636
in your code, you'll

708
00:29:42,526 --> 00:29:45,076
So now we're on to

709
00:29:45,366 --> 00:29:46,166
Memory access.

710
00:29:46,446 --> 00:29:48,296
And we'll start with

711
00:29:48,526 --> 00:29:50,156
that people most

712
00:29:50,156 --> 00:29:54,946
and that is dynamically indexed

713
00:29:55,116 --> 00:29:56,516
Now that's quite a mouthful,

714
00:29:56,516 --> 00:29:59,506
but a lot of you probably

715
00:29:59,506 --> 00:30:00,466
that looks vaguely like this.

716
00:29:59,506 --> 00:30:00,466
that looks vaguely like this.

717
00:30:01,046 --> 00:30:04,626
You have an array that consist

718
00:30:04,626 --> 00:30:08,226
in runtime and vary between each

719
00:30:08,226 --> 00:30:10,986
And you index it to the

720
00:30:10,986 --> 00:30:12,076
that is also a variable.

721
00:30:12,416 --> 00:30:15,026
That is a dynamically indexed

722
00:30:15,846 --> 00:30:18,436
Now before we go on, I'm

723
00:30:18,436 --> 00:30:20,966
for grabs at the idea that

724
00:30:20,966 --> 00:30:22,456
I'm going to explain why.

725
00:30:23,306 --> 00:30:26,446
So, on CPUs typically you

726
00:30:26,546 --> 00:30:29,506
maybe a dozen threads, and you

727
00:30:29,546 --> 00:30:30,276
between those threads.

728
00:30:30,396 --> 00:30:33,126
So every thread can have

729
00:30:33,126 --> 00:30:35,366
of stack space before they

730
00:30:35,406 --> 00:30:36,506
to head off to main memory.

731
00:30:37,336 --> 00:30:40,956
On a GPU you often have tens of

732
00:30:41,016 --> 00:30:43,976
And they're all sharing

733
00:30:44,256 --> 00:30:46,356
So when it comes down to

734
00:30:46,356 --> 00:30:48,436
very little space

735
00:30:49,206 --> 00:30:52,176
It's just not meant for that,

736
00:30:52,176 --> 00:30:54,966
as a general rule,

737
00:30:54,966 --> 00:30:57,276
if you're using the

738
00:30:57,326 --> 00:31:00,786
It's so slow that almost

739
00:30:57,326 --> 00:31:00,786
It's so slow that almost

740
00:31:00,786 --> 00:31:01,156
been better.

741
00:31:02,696 --> 00:31:06,856
And an example for a real

742
00:31:06,856 --> 00:31:09,586
of the program it needed

743
00:31:09,586 --> 00:31:12,376
for vectors, so it

744
00:31:12,376 --> 00:31:14,836
an array of two float

745
00:31:14,916 --> 00:31:16,336
between them using

746
00:31:16,336 --> 00:31:18,996
And that caused a

747
00:31:18,996 --> 00:31:21,076
in this program even though it's

748
00:31:21,546 --> 00:31:24,036
It can be pretty significant.

749
00:31:24,716 --> 00:31:27,516
And of course every time we

750
00:31:27,516 --> 00:31:30,936
going to try harder and harder

751
00:31:31,546 --> 00:31:34,706
to avoid generating these stack

752
00:31:35,806 --> 00:31:38,186
Now I'll show you two

753
00:31:39,636 --> 00:31:42,876
This other one, you can

754
00:31:42,976 --> 00:31:43,666
not variables.

755
00:31:44,026 --> 00:31:46,706
It's not a non-constant

756
00:31:47,266 --> 00:31:50,706
because the values don't vary

757
00:31:50,706 --> 00:31:51,856
to be duplicated per thread.

758
00:31:52,426 --> 00:31:54,506
So that's okay.

759
00:31:54,856 --> 00:31:56,406
And this one is also okay.

760
00:31:56,616 --> 00:31:57,136
Wait, why?

761
00:31:57,136 --> 00:31:59,486
It's still a dynamically indexed

762
00:32:00,116 --> 00:32:02,646
But it's only done dynamically

763
00:32:03,266 --> 00:32:06,116
And the compiler is going

764
00:32:06,476 --> 00:32:09,526
In fact, your compiler

765
00:32:09,526 --> 00:32:12,426
that is accessing the stack to

766
00:32:13,256 --> 00:32:15,836
So in this case after it's

767
00:32:15,836 --> 00:32:17,326
dynamically indexed,

768
00:32:17,326 --> 00:32:18,796
And this is worth mentioning,

769
00:32:18,796 --> 00:32:20,706
because this is a fairly

770
00:32:20,706 --> 00:32:23,336
of graphics code and I don't

771
00:32:23,336 --> 00:32:24,676
that when it's probably fine.

772
00:32:25,516 --> 00:32:27,986
So now that we've gone

773
00:32:27,986 --> 00:32:30,236
to not do certain types

774
00:32:30,536 --> 00:32:32,426
let's go on to making

775
00:32:32,426 --> 00:32:34,556
that we do actually fast.

776
00:32:35,416 --> 00:32:38,066
Now while A8 and later

777
00:32:38,066 --> 00:32:41,236
as I went over earlier, they

778
00:32:42,006 --> 00:32:45,546
And one big vector loading

779
00:32:45,546 --> 00:32:48,746
than multiple smaller ones

780
00:32:49,616 --> 00:32:52,266
And this typically effects the

781
00:32:52,326 --> 00:32:53,266
because if you're running

782
00:32:53,266 --> 00:32:55,186
through a loads,

783
00:32:56,266 --> 00:33:00,136
And, so as of iOS 10, one of

784
00:32:56,266 --> 00:33:00,136
And, so as of iOS 10, one of

785
00:33:00,136 --> 00:33:03,186
is we will try to vectorize

786
00:33:03,186 --> 00:33:05,396
to neighboring memory

787
00:33:05,626 --> 00:33:07,766
because again it can give

788
00:33:08,956 --> 00:33:12,656
But nevertheless, this is one

789
00:33:12,656 --> 00:33:14,286
with the compiler

790
00:33:14,536 --> 00:33:15,436
and I'll give an example.

791
00:33:16,436 --> 00:33:18,336
So as you can see here,

792
00:33:18,436 --> 00:33:21,016
that does some arithmetic and

793
00:33:21,876 --> 00:33:25,066
but on each iteration,

794
00:33:25,506 --> 00:33:27,696
Now we would want that

795
00:33:27,696 --> 00:33:29,856
because one is better than two.

796
00:33:29,856 --> 00:33:32,096
And the compiler wants that too.

797
00:33:32,096 --> 00:33:34,976
It wants to try to vectorize

798
00:33:34,976 --> 00:33:36,886
and C aren't next to

799
00:33:36,886 --> 00:33:37,896
so there's nothing it can do.

800
00:33:37,896 --> 00:33:39,976
The compiler's not allowed

801
00:33:40,256 --> 00:33:41,156
so we've got two loads.

802
00:33:42,186 --> 00:33:43,436
There's two solutions to this.

803
00:33:44,036 --> 00:33:46,536
Number one, of course,

804
00:33:46,536 --> 00:33:47,966
now it's a vector

805
00:33:48,696 --> 00:33:49,996
One load, a set of

806
00:33:51,176 --> 00:33:54,946
Also, as of iOS 10, this

807
00:33:55,276 --> 00:33:56,986
because here, we've

808
00:33:56,986 --> 00:33:58,486
to put the values

809
00:33:58,836 --> 00:34:00,936
so the compiler can

810
00:33:58,836 --> 00:34:00,936
so the compiler can

811
00:34:00,936 --> 00:34:01,936
when it's doing it.

812
00:34:02,256 --> 00:34:05,286
And this is an example again

813
00:34:05,636 --> 00:34:08,616
you've allowed the compiler to

814
00:34:08,726 --> 00:34:11,295
because you understand

815
00:34:11,295 --> 00:34:13,766
You understand how the

816
00:34:13,766 --> 00:34:15,246
to make the compiler happy

817
00:34:15,516 --> 00:34:18,916
and make it able to

818
00:34:19,835 --> 00:34:23,216
So, another thing to keep in

819
00:34:23,216 --> 00:34:26,235
that A8 and later GPUs

820
00:34:26,235 --> 00:34:31,735
for device memory addressing,

821
00:34:32,406 --> 00:34:35,065
The offset for accessing

822
00:34:35,065 --> 00:34:36,406
within a signed integer.

823
00:34:36,876 --> 00:34:39,335
Smaller types like short

824
00:34:39,335 --> 00:34:40,916
in fact they're highly

825
00:34:41,416 --> 00:34:43,545
because those do also fit

826
00:34:44,366 --> 00:34:47,786
However, of course uint does

827
00:34:47,786 --> 00:34:49,076
out of range of signed integer.

828
00:34:49,696 --> 00:34:54,076
And so if the compiler

829
00:34:54,076 --> 00:34:56,716
where the offset is a

830
00:34:56,775 --> 00:34:58,896
that it will safely fit

831
00:34:59,266 --> 00:35:01,596
it has to manually

832
00:34:59,266 --> 00:35:01,596
it has to manually

833
00:35:02,156 --> 00:35:04,086
rather than letting the

834
00:35:04,366 --> 00:35:05,656
And that can waste power,

835
00:35:05,786 --> 00:35:08,886
it can waste ALU

836
00:35:09,006 --> 00:35:10,066
It's not good.

837
00:35:10,626 --> 00:35:15,396
So, change your offset to

838
00:35:15,396 --> 00:35:16,426
And of course taking advantage

839
00:35:16,426 --> 00:35:18,606
to this will typically

840
00:35:21,496 --> 00:35:23,626
So now on to our final

841
00:35:23,626 --> 00:35:25,476
over earlier, latency

842
00:35:26,266 --> 00:35:28,496
So one of the core

843
00:35:28,496 --> 00:35:30,316
of modern GPUs is

844
00:35:30,316 --> 00:35:32,146
by using large scale

845
00:35:32,646 --> 00:35:34,866
So when they're waiting for

846
00:35:34,866 --> 00:35:36,856
like a texture read,

847
00:35:36,856 --> 00:35:37,896
and run another thread instead

848
00:35:37,896 --> 00:35:39,336
of sitting there doing

849
00:35:39,336 --> 00:35:40,536
And this is fairly important

850
00:35:40,536 --> 00:35:43,426
because texture reads typically

851
00:35:43,426 --> 00:35:44,656
to complete on average.

852
00:35:47,306 --> 00:35:49,536
And so the more latency

853
00:35:49,536 --> 00:35:52,066
the more threads you need

854
00:35:52,606 --> 00:35:53,776
and how many threads

855
00:35:54,236 --> 00:35:56,526
Well it's limited by the fact

856
00:35:56,526 --> 00:35:58,116
of resources that are shared

857
00:35:58,116 --> 00:35:59,696
between threads in

858
00:36:00,016 --> 00:36:02,706
So clearly depending on

859
00:36:02,706 --> 00:36:04,596
you have a limitation on

860
00:36:04,846 --> 00:36:07,006
And the two things that

861
00:36:07,006 --> 00:36:08,766
of registers and

862
00:36:09,316 --> 00:36:11,136
So if you use more

863
00:36:11,306 --> 00:36:12,606
now you can't have

864
00:36:12,716 --> 00:36:13,126
Simple enough.

865
00:36:13,606 --> 00:36:17,626
And if you use more thread group

866
00:36:17,626 --> 00:36:18,646
into the same problem,

867
00:36:18,806 --> 00:36:20,936
more thread your memory per

868
00:36:21,726 --> 00:36:25,316
And you can actually check out

869
00:36:25,636 --> 00:36:29,416
by using MTLComputePipeLineState

870
00:36:29,416 --> 00:36:31,306
maxTotalThreadsPerThreadgroup,

871
00:36:31,646 --> 00:36:33,826
which will tell you what

872
00:36:33,826 --> 00:36:36,776
of your shader is based

873
00:36:36,846 --> 00:36:39,486
and the thread group

874
00:36:40,006 --> 00:36:42,346
And so when we say a

875
00:36:42,626 --> 00:36:44,426
it means you have

876
00:36:44,496 --> 00:36:45,806
to hide the latency of a shader.

877
00:36:45,806 --> 00:36:47,436
And there's two things

878
00:36:47,696 --> 00:36:49,616
you can either reduce the

879
00:36:50,016 --> 00:36:52,296
your save registers

880
00:36:52,476 --> 00:36:54,546
that is preventing you

881
00:36:57,066 --> 00:37:02,236
So, since it's kind of

882
00:36:57,066 --> 00:37:02,236
So, since it's kind of

883
00:37:02,236 --> 00:37:03,856
in a very large complex shader.

884
00:37:04,246 --> 00:37:06,356
I'll go over a little bit

885
00:37:06,356 --> 00:37:08,516
that will hopefully give you

886
00:37:08,516 --> 00:37:10,496
to think about latency

887
00:37:10,496 --> 00:37:12,926
of mentally model

888
00:37:14,166 --> 00:37:16,666
So, here's an example

889
00:37:17,066 --> 00:37:19,686
We have a texture sample,

890
00:37:19,686 --> 00:37:21,786
of that texture sample

891
00:37:21,786 --> 00:37:24,306
and then we do another texture

892
00:37:24,986 --> 00:37:26,056
We have to wait twice.

893
00:37:26,056 --> 00:37:28,706
Because we have to wait once

894
00:37:29,016 --> 00:37:31,566
And we have to wait again

895
00:37:31,566 --> 00:37:32,836
from the second texture sample.

896
00:37:32,836 --> 00:37:36,566
So that's two serial

897
00:37:37,026 --> 00:37:38,716
for a total of twice

898
00:37:40,326 --> 00:37:42,416
Now here's an example

899
00:37:42,416 --> 00:37:43,456
It looks a lot like the other,

900
00:37:43,456 --> 00:37:45,716
except we're not using

901
00:37:46,906 --> 00:37:51,086
But typically, we can't

902
00:37:51,346 --> 00:37:54,366
The if statement acts an

903
00:37:54,706 --> 00:37:56,746
So, we automatically have

904
00:37:56,886 --> 00:37:59,796
to wait here anyways even though

905
00:38:00,116 --> 00:38:01,636
So we still get twice

906
00:38:02,006 --> 00:38:04,386
As you noticed the GPU

907
00:38:04,456 --> 00:38:05,656
about your data dependencies.

908
00:38:06,046 --> 00:38:09,406
It only cares about what the

909
00:38:09,966 --> 00:38:13,106
and so the second one will

910
00:38:13,106 --> 00:38:15,196
as the first one, even

911
00:38:15,196 --> 00:38:16,016
dependency there.

912
00:38:16,846 --> 00:38:19,426
And then finally

913
00:38:19,426 --> 00:38:21,326
where you just have two

914
00:38:21,946 --> 00:38:23,826
and they can both

915
00:38:24,456 --> 00:38:26,626
and then we can have

916
00:38:26,746 --> 00:38:29,186
So it's 1 x instead

917
00:38:30,226 --> 00:38:32,386
So, what are you going to

918
00:38:32,696 --> 00:38:36,146
So in many real world

919
00:38:36,146 --> 00:38:38,466
to tradeoff between

920
00:38:39,046 --> 00:38:41,946
And a common example of this

921
00:38:41,946 --> 00:38:45,956
where based on one texture read

922
00:38:45,956 --> 00:38:48,776
to do anything in this shader,

923
00:38:48,776 --> 00:38:50,436
And that can be very useful.

924
00:38:50,436 --> 00:38:53,366
Because now all that work

925
00:38:53,366 --> 00:38:54,546
where you don't need

926
00:38:55,026 --> 00:38:56,056
you're saving all that work.

927
00:38:56,346 --> 00:38:57,036
That's great.

928
00:38:57,386 --> 00:39:01,816
But now you're increasing

929
00:38:57,386 --> 00:39:01,816
But now you're increasing

930
00:39:02,596 --> 00:39:04,156
by reducing the amount

931
00:39:05,026 --> 00:39:09,256
But you're also increasing

932
00:39:09,316 --> 00:39:12,866
to do the first texture read,

933
00:39:13,306 --> 00:39:14,956
then do your early

934
00:39:15,336 --> 00:39:18,616
and then do whatever other

935
00:39:18,996 --> 00:39:20,626
And well is it faster?

936
00:39:20,626 --> 00:39:21,106
Is it not?

937
00:39:21,476 --> 00:39:23,976
Often you just have to test.

938
00:39:24,386 --> 00:39:26,756
Because which is faster

939
00:39:26,756 --> 00:39:28,966
on your shader, but it's

940
00:39:28,966 --> 00:39:32,026
of that often is a real

941
00:39:32,096 --> 00:39:33,436
to experiment to

942
00:39:34,246 --> 00:39:35,976
Now, while there isn't

943
00:39:35,976 --> 00:39:39,056
there is one particular

944
00:39:39,056 --> 00:39:43,016
and later GPUs and that is

945
00:39:43,016 --> 00:39:45,556
at least two texture

946
00:39:45,556 --> 00:39:47,706
to get full ability

947
00:39:48,206 --> 00:39:49,086
One is not enough.

948
00:39:49,896 --> 00:39:51,656
If you have to do

949
00:39:51,706 --> 00:39:53,816
But if you have some choice

950
00:39:53,816 --> 00:39:55,726
in how you arrange your

951
00:39:55,946 --> 00:39:58,066
if you allow it to do

952
00:39:58,266 --> 00:39:59,416
you may get better performance.

953
00:40:01,326 --> 00:40:02,236
So, in summary.

954
00:40:03,576 --> 00:40:06,436
Make sure you pick the correct

955
00:40:06,436 --> 00:40:09,556
layouts and so forth, because

956
00:40:09,556 --> 00:40:11,676
to hurt so much that often

957
00:40:11,676 --> 00:40:12,816
in the presentation will matter.

958
00:40:14,326 --> 00:40:15,646
Work with the compiler.

959
00:40:15,646 --> 00:40:16,506
Write what you mean.

960
00:40:17,086 --> 00:40:18,476
Don't try to be too clever,

961
00:40:18,476 --> 00:40:20,966
or the compiler won't know what

962
00:40:21,406 --> 00:40:22,786
and won't be able to do its job.

963
00:40:23,656 --> 00:40:25,456
Plus, it's easier to

964
00:40:26,976 --> 00:40:28,566
Keep an eye out for

965
00:40:28,566 --> 00:40:30,156
not just the

966
00:40:30,386 --> 00:40:32,796
They're often not as obvious,

967
00:40:32,796 --> 00:40:35,326
up as often, but when

968
00:40:35,456 --> 00:40:37,716
And they will hurt so

969
00:40:37,716 --> 00:40:39,346
of micro-optimizations

970
00:40:40,986 --> 00:40:42,466
And feel free to experiment.

971
00:40:42,696 --> 00:40:44,926
There's a number of rule

972
00:40:44,926 --> 00:40:47,646
where there's simply

973
00:40:48,076 --> 00:40:49,946
And try them both,

974
00:40:51,936 --> 00:40:54,486
So, if you want more

975
00:40:54,486 --> 00:40:55,886
The video of the talk

976
00:40:55,886 --> 00:40:59,946
Here are the other session if

977
00:40:59,946 --> 00:41:01,406
the videos will be online.

978
00:40:59,946 --> 00:41:01,406
the videos will be online.

979
00:41:02,936 --> 00:41:03,246
Thank you.
