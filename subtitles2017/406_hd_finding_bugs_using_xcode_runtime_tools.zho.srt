1
00:00:17,551 --> 00:00:19,353
<c.magenta>（使用Xcode运行时工具发现漏洞）</c>

2
00:00:19,486 --> 00:00:20,320
<c.magenta>大家好</c>

3
00:00:24,191 --> 00:00:28,562
<c.magenta>欢迎参加“使用Xcode运行时工具</c>

4
00:00:30,397 --> 00:00:33,734
<c.magenta>我是库巴</c>

5
00:00:33,967 --> 00:00:35,169
<c.magenta>程序分析团队工程师</c>

6
00:00:35,602 --> 00:00:38,672
<c.magenta>今天 我们讨论</c>

7
00:00:39,173 --> 00:00:41,675
<c.magenta>在程序运行时使用工具发现漏洞</c>

8
00:00:42,176 --> 00:00:43,010
<c.magenta>让我们开始</c>

9
00:00:44,745 --> 00:00:46,780
<c.magenta>Xcode通过多种方法</c>

10
00:00:46,847 --> 00:00:49,183
<c.magenta>显示程序中的漏洞</c>

11
00:00:49,316 --> 00:00:51,552
<c.magenta>例如 通过编辑器错误消息</c>

12
00:00:52,052 --> 00:00:53,020
<c.magenta>编译器警告</c>

13
00:00:53,687 --> 00:00:54,655
<c.magenta>分析器警告</c>

14
00:00:55,289 --> 00:00:56,190
<c.magenta>或测试错误等</c>

15
00:00:57,191 --> 00:00:58,592
<c.magenta>去年 在Xcode 8中</c>

16
00:00:58,659 --> 00:01:02,462
<c.magenta>我们增加一个全新的类别</c>

17
00:00:58,659 --> 00:01:02,462
<c.magenta>我们增加一个全新的类别</c>

18
00:01:03,497 --> 00:01:05,966
<c.magenta>这些问题是在程序运行时</c>

19
00:01:06,200 --> 00:01:07,467
<c.magenta>使用多个不同的工具发现的</c>

20
00:01:09,303 --> 00:01:12,339
<c.magenta>当你像以前一样运行和调试程序时</c>

21
00:01:12,439 --> 00:01:15,309
<c.magenta>这些工具在运行时发现和检测漏洞</c>

22
00:01:15,375 --> 00:01:19,313
<c.magenta>然后在Xcode运行时问题导航器中</c>

23
00:01:20,314 --> 00:01:23,984
<c.magenta>如果你没有注意到这个导航器</c>

24
00:01:24,051 --> 00:01:27,187
<c.magenta>Xcode会指示它发现一些运行时问题</c>

25
00:01:27,721 --> 00:01:30,757
<c.magenta>显示这个紫色警告图标</c>

26
00:01:33,060 --> 00:01:35,929
<c.magenta>你可以在导航器中点击这些问题</c>

27
00:01:36,096 --> 00:01:40,267
<c.magenta>编辑器将会告诉你</c>

28
00:01:42,069 --> 00:01:43,770
<c.magenta>漏洞来源可能各不相同</c>

29
00:01:43,837 --> 00:01:46,473
<c.magenta>因为不同的工具报告不同类型的漏洞</c>

30
00:01:46,974 --> 00:01:47,808
<c.magenta>今天我们的演讲中</c>

31
00:01:47,875 --> 00:01:50,010
<c.magenta>讨论的所有这些工具</c>

32
00:01:50,143 --> 00:01:52,980
<c.magenta>可以在方案编辑器的诊断阶段找到它们</c>

33
00:01:53,514 --> 00:01:56,350
<c.magenta>在Xcode 9中</c>

34
00:01:56,783 --> 00:01:59,786
<c.magenta>你们可以看到</c>

35
00:02:00,087 --> 00:02:03,390
<c.magenta>Threat Sanitizer、</c>

36
00:02:03,524 --> 00:02:05,192
<c.magenta>和Main Thread Checker</c>

37
00:02:05,726 --> 00:02:09,496
<c.magenta>这些工具在程序运行时发现漏洞</c>

38
00:02:10,062 --> 00:02:12,633
<c.magenta>今天我们将会讨论这些工具</c>

39
00:02:13,200 --> 00:02:15,469
<c.magenta>首先 我们来看</c>

40
00:02:15,536 --> 00:02:17,571
<c.magenta>它是Xcode 9中的全新工具</c>

41
00:02:19,072 --> 00:02:22,276
<c.magenta>然后我会讨论Address Sanitizer</c>

42
00:02:22,342 --> 00:02:25,479
<c.magenta>以及今年我们对这些工具所做的改进</c>

43
00:02:26,647 --> 00:02:29,016
<c.magenta>我们将会介绍另外一个全新工具</c>

44
00:02:29,116 --> 00:02:30,851
<c.magenta>Undefined Behavior Sanitizer</c>

45
00:02:31,785 --> 00:02:34,621
<c.magenta>最后 我们介绍一些小技巧</c>

46
00:02:35,122 --> 00:02:37,024
<c.magenta>让你们能够高效率地使用这些工具</c>

47
00:02:38,058 --> 00:02:38,992
<c.magenta>让我们开始</c>

48
00:02:41,128 --> 00:02:44,364
<c.magenta>Main Thread Checker</c>

49
00:02:44,431 --> 00:02:48,135
<c.magenta>它检查一些常用API的违规</c>

50
00:02:49,136 --> 00:02:52,739
<c.magenta>重点检查UI更新和多线程</c>

51
00:02:53,740 --> 00:02:57,878
<c.magenta>一些API要求你仅在主线程中使用它们</c>

52
00:02:58,745 --> 00:03:01,415
<c.magenta>例如 AppKit和UIKit框架中的</c>

53
00:02:58,745 --> 00:03:01,415
<c.magenta>例如 AppKit和UIKit框架中的</c>

54
00:03:01,481 --> 00:03:03,417
<c.magenta>许多API都这样做</c>

55
00:03:04,084 --> 00:03:07,421
<c.magenta>大多数macOS和iOS图形应用程序</c>

56
00:03:07,754 --> 00:03:10,057
<c.magenta>假设你使用这些框架</c>

57
00:03:10,457 --> 00:03:12,426
<c.magenta>就应该知道这些限制</c>

58
00:03:12,559 --> 00:03:14,862
<c.magenta>即 必须在主线程中调用这些API</c>

59
00:03:15,562 --> 00:03:17,764
<c.magenta>这很容易做到</c>

60
00:03:17,831 --> 00:03:20,167
<c.magenta>我们只需要确保</c>

61
00:03:21,502 --> 00:03:22,769
<c.magenta>但是 有一些任务</c>

62
00:03:22,836 --> 00:03:25,172
<c.magenta>你并不想在主线程上执行它们</c>

63
00:03:25,372 --> 00:03:27,441
<c.magenta>比如下载 这时你需要等待数据到达</c>

64
00:03:27,508 --> 00:03:29,276
<c.magenta>另外还有图像处理任务</c>

65
00:03:29,343 --> 00:03:32,112
<c.magenta>通常需要大量的计算</c>

66
00:03:33,247 --> 00:03:36,149
<c.magenta>因此应该将这些任务移出主线程</c>

67
00:03:36,350 --> 00:03:38,085
<c.magenta>使UI保持快速响应</c>

68
00:03:38,151 --> 00:03:41,255
<c.magenta>而且不会阻止应用中的用户交互</c>

69
00:03:42,222 --> 00:03:45,826
<c.magenta>但是 这些任务也需要触发UI更新</c>

70
00:03:46,760 --> 00:03:50,831
<c.magenta>如果这些UI更新调用</c>

71
00:03:51,532 --> 00:03:53,467
<c.magenta>将需要在主线程中进行更新</c>

72
00:03:53,567 --> 00:03:55,435
<c.magenta>很容易犯的错误是</c>

73
00:03:55,502 --> 00:03:58,372
<c.magenta>在不合适的线程中</c>

74
00:03:59,139 --> 00:04:00,874
<c.magenta>这可能会造成严重后果</c>

75
00:03:59,139 --> 00:04:00,874
<c.magenta>这可能会造成严重后果</c>

76
00:04:01,175 --> 00:04:04,811
<c.magenta>如果UI更新缺失</c>

77
00:04:05,145 --> 00:04:06,480
<c.magenta>或者其它显示错误</c>

78
00:04:06,914 --> 00:04:09,816
<c.magenta>甚至可能发生更严重的问题</c>

79
00:04:10,350 --> 00:04:11,752
<c.magenta>因此 为了避免这些问题</c>

80
00:04:12,085 --> 00:04:15,556
<c.magenta>我们需要确保 仅在主线程中</c>

81
00:04:16,623 --> 00:04:19,392
<c.magenta>为此 我想为大家介绍</c>

82
00:04:19,459 --> 00:04:21,128
<c.magenta>我为大家进行展示</c>

83
00:04:30,771 --> 00:04:32,806
<c.magenta>这里一个简单的应用程序</c>

84
00:04:32,873 --> 00:04:34,942
<c.magenta>它从互联网下载一些数据</c>

85
00:04:35,375 --> 00:04:38,846
<c.magenta>从这个长URL下载一个文件</c>

86
00:04:38,912 --> 00:04:40,981
<c.magenta>这个网站是</c>

87
00:04:41,281 --> 00:04:44,651
<c.magenta>要下载的文件是</c>

88
00:04:45,052 --> 00:04:46,119
<c.magenta>它是一个zip文件</c>

89
00:04:46,186 --> 00:04:48,155
<c.magenta>几兆大小</c>

90
00:04:48,222 --> 00:04:50,657
<c.magenta>它是一个示例下载文件</c>

91
00:04:51,692 --> 00:04:55,762
<c.magenta>为了下载这个文件</c>

92
00:04:55,829 --> 00:04:57,064
<c.magenta>这是一个Foundation类</c>

93
00:04:57,130 --> 00:04:59,533
<c.magenta>是一种方便的文件下载方法</c>

94
00:05:02,069 --> 00:05:04,304
<c.magenta>应用的UI非常简单</c>

95
00:05:05,272 --> 00:05:08,542
<c.magenta>含有一个按钮和一个进度条</c>

96
00:05:08,609 --> 00:05:12,713
<c.magenta>我们可以实现</c>

97
00:05:12,779 --> 00:05:16,116
<c.magenta>在这个回调中</c>

98
00:05:16,350 --> 00:05:17,985
<c.magenta>让我们运行这个程序</c>

99
00:05:18,118 --> 00:05:22,523
<c.magenta>看它是否显示下载进度</c>

100
00:05:22,890 --> 00:05:25,726
<c.magenta>点击按钮开始下载</c>

101
00:05:26,126 --> 00:05:28,295
<c.magenta>可以看到</c>

102
00:05:28,462 --> 00:05:31,198
<c.magenta>因为进度条在开始位置卡住了</c>

103
00:05:31,632 --> 00:05:34,801
<c.magenta>现在 因为某种原因</c>

104
00:05:35,969 --> 00:05:39,206
<c.magenta>因此我想</c>

105
00:05:39,273 --> 00:05:41,808
<c.magenta>或者URLSession工作不正常</c>

106
00:05:42,543 --> 00:05:43,577
<c.magenta>此功能的最大好处是</c>

107
00:05:43,644 --> 00:05:45,679
<c.magenta>我不需要猜测哪里出了问题</c>

108
00:05:45,846 --> 00:05:47,614
<c.magenta>Xcode已经找到问题</c>

109
00:05:48,182 --> 00:05:50,317
<c.magenta>我们返回Xcode</c>

110
00:05:50,551 --> 00:05:54,521
<c.magenta>它告诉我们</c>

111
00:05:55,589 --> 00:05:57,991
<c.magenta>让我们点击这个运行时问题</c>

112
00:05:58,058 --> 00:06:00,360
<c.magenta>你会看到导航器</c>

113
00:05:58,058 --> 00:06:00,360
<c.magenta>你会看到导航器</c>

114
00:06:00,661 --> 00:06:02,262
<c.magenta>没有切换到Runtime Issues导航器</c>

115
00:06:02,996 --> 00:06:03,897
<c.magenta>它告诉我</c>

116
00:06:03,964 --> 00:06:07,301
<c.magenta>我在后台线程中调用一些UI API</c>

117
00:06:08,769 --> 00:06:10,103
<c.magenta>我点击问题</c>

118
00:06:10,170 --> 00:06:13,874
<c.magenta>查看含有无效API代码的代码块</c>

119
00:06:14,441 --> 00:06:15,342
<c.magenta>在本例中</c>

120
00:06:15,676 --> 00:06:18,512
<c.magenta>我们在后台线程中</c>

121
00:06:18,579 --> 00:06:21,215
<c.magenta>为进度指示条设置一个新值</c>

122
00:06:21,515 --> 00:06:23,550
<c.magenta>而这应该是在主线程中完成的</c>

123
00:06:25,786 --> 00:06:26,854
<c.magenta>因此这是一个异常</c>

124
00:06:26,920 --> 00:06:30,057
<c.magenta>因为我想要在后台线程中执行这个代码</c>

125
00:06:30,324 --> 00:06:32,860
<c.magenta>实际上 我没有在代码中</c>

126
00:06:34,061 --> 00:06:36,597
<c.magenta>因此实际问题是</c>

127
00:06:36,663 --> 00:06:40,200
<c.magenta>犯了错误</c>

128
00:06:40,667 --> 00:06:43,504
<c.magenta>在这一行</c>

129
00:06:43,804 --> 00:06:47,875
<c.magenta>指定用于进度回调</c>

130
00:06:47,941 --> 00:06:50,611
<c.magenta>和下载完成回调的视图</c>

131
00:06:51,078 --> 00:06:53,914
<c.magenta>我没有提供队列</c>

132
00:06:54,014 --> 00:06:56,116
<c.magenta>这意味着我并不关心</c>

133
00:06:56,183 --> 00:06:59,653
<c.magenta>URLSession可能会在后台队列中</c>

134
00:07:01,722 --> 00:07:05,993
<c.magenta>现在 我们知道</c>

135
00:07:06,293 --> 00:07:08,795
<c.magenta>为了解决这个问题 我可能使用GCD</c>

136
00:07:08,862 --> 00:07:11,598
<c.magenta>将UI更新操作</c>

137
00:07:12,165 --> 00:07:15,335
<c.magenta>在本例中</c>

138
00:07:15,402 --> 00:07:18,038
<c.magenta>直接在主队列上进行回调</c>

139
00:07:18,105 --> 00:07:19,273
<c.magenta>我们将会这样做</c>

140
00:07:20,507 --> 00:07:24,211
<c.magenta>我要求它在主队列上进行回调</c>

141
00:07:24,478 --> 00:07:26,580
<c.magenta>让我们多次运行程序</c>

142
00:07:26,647 --> 00:07:28,515
<c.magenta>查看这是否会解决我们的问题</c>

143
00:07:29,716 --> 00:07:31,285
<c.magenta>点击按钮</c>

144
00:07:31,552 --> 00:07:33,687
<c.magenta>会看到进度条平滑地行进</c>

145
00:07:33,754 --> 00:07:35,989
<c.magenta>表示正在下载</c>

146
00:07:40,060 --> 00:07:40,894
<c.magenta>谢谢</c>

147
00:07:43,530 --> 00:07:45,032
<c.magenta>现在我切换到幻灯片</c>

148
00:07:49,069 --> 00:07:49,903
<c.magenta>在这里</c>

149
00:07:51,605 --> 00:07:54,374
<c.magenta>我们看到一个例子</c>

150
00:07:54,441 --> 00:07:58,111
<c.magenta>显示Main Thread Checker</c>

151
00:07:58,245 --> 00:08:00,247
<c.magenta>因为我们在错误线程中调用一些API</c>

152
00:07:58,245 --> 00:08:00,247
<c.magenta>因为我们在错误线程中调用一些API</c>

153
00:08:00,881 --> 00:08:03,984
<c.magenta>请注意 我并没有启用这两个选项</c>

154
00:08:04,117 --> 00:08:06,119
<c.magenta>因为在你使用Xcode调试器时</c>

155
00:08:06,253 --> 00:08:08,155
<c.magenta>默认已经启用它们</c>

156
00:08:10,457 --> 00:08:12,526
<c.magenta>如果想要在Xcode中找到这个代码</c>

157
00:08:13,327 --> 00:08:16,530
<c.magenta>可以在诊断步骤看到它</c>

158
00:08:16,997 --> 00:08:19,132
<c.magenta>你会注意到 在Xcode 9中</c>

159
00:08:19,266 --> 00:08:21,835
<c.magenta>有一个复选项 其名称为</c>

160
00:08:22,603 --> 00:08:25,205
<c.magenta>在这里</c>

161
00:08:26,306 --> 00:08:30,210
<c.magenta>如果想要调试器停止</c>

162
00:08:30,644 --> 00:08:32,746
<c.magenta>可以选择“Pause on Issues”复选框</c>

163
00:08:33,280 --> 00:08:36,183
<c.magenta>然后调试器将会在检查到问题后停止</c>

164
00:08:36,250 --> 00:08:38,818
<c.magenta>你可以查看当前的程序状态</c>

165
00:08:39,318 --> 00:08:40,687
<c.magenta>分析发生了什么问题</c>

166
00:08:42,289 --> 00:08:43,457
<c.magenta>（常见问题）</c>

167
00:08:43,524 --> 00:08:45,792
<c.magenta>现在 我们来讨论一些常见的问题</c>

168
00:08:46,860 --> 00:08:48,695
<c.magenta>这些问题让</c>

169
00:08:49,496 --> 00:08:50,764
<c.magenta>在演示中可以看到</c>

170
00:08:51,031 --> 00:08:57,037
<c.magenta>后台线程中</c>

171
00:08:57,237 --> 00:08:58,405
<c.magenta>经常会进行网络回调</c>

172
00:08:59,239 --> 00:09:02,342
<c.magenta>你们需要注意</c>

173
00:08:59,239 --> 00:09:02,342
<c.magenta>你们需要注意</c>

174
00:09:02,576 --> 00:09:03,710
<c.magenta>进行UI更新</c>

175
00:09:04,645 --> 00:09:05,913
<c.magenta>另外 当你创建和销毁</c>

176
00:09:05,979 --> 00:09:09,249
<c.magenta>NSView或UIView对象时</c>

177
00:09:09,349 --> 00:09:11,952
<c.magenta>也需要在主线程中完成这些工作</c>

178
00:09:13,887 --> 00:09:16,523
<c.magenta>如果你在编写库或框架</c>

179
00:09:16,657 --> 00:09:19,126
<c.magenta>提供一些异步API</c>

180
00:09:19,660 --> 00:09:22,095
<c.magenta>当设计这些API时</c>

181
00:09:22,496 --> 00:09:23,330
<c.magenta>让我们来看看</c>

182
00:09:26,033 --> 00:09:27,701
<c.magenta>假设我们想要设计一个API</c>

183
00:09:27,768 --> 00:09:30,470
<c.magenta>用于执行长时间和高密度的计算</c>

184
00:09:30,537 --> 00:09:33,207
<c.magenta>它以异步方式运行</c>

185
00:09:34,575 --> 00:09:38,846
<c.magenta>API的调用函数需要</c>

186
00:09:38,912 --> 00:09:41,481
<c.magenta>这个收尾程序将用作</c>

187
00:09:41,548 --> 00:09:43,150
<c.magenta>因此 当任务完成时</c>

188
00:09:43,617 --> 00:09:46,486
<c.magenta>API将调用</c>

189
00:09:47,387 --> 00:09:49,556
<c.magenta>但是 这个代码示例中</c>

190
00:09:49,923 --> 00:09:52,459
<c.magenta>哪个队列或线程</c>

191
00:09:53,227 --> 00:09:55,195
<c.magenta>在不合适的线程中处理这些代码时</c>

192
00:09:55,262 --> 00:09:57,664
<c.magenta>很容易产生错误</c>

193
00:10:01,568 --> 00:10:04,805
<c.magenta>良好的API应该要求甚至强制用户</c>

194
00:10:05,038 --> 00:10:08,509
<c.magenta>规定哪个视图应该用于完成处理程序</c>

195
00:10:08,575 --> 00:10:10,544
<c.magenta>如果你阅读这段代码示例</c>

196
00:10:10,878 --> 00:10:14,014
<c.magenta>很容易看到</c>

197
00:10:14,081 --> 00:10:15,582
<c.magenta>不需要阅读API文档</c>

198
00:10:15,649 --> 00:10:17,618
<c.magenta>就可以知道这一点</c>

199
00:10:20,187 --> 00:10:21,021
<c.magenta>前面我说过</c>

200
00:10:21,221 --> 00:10:24,625
<c.magenta>Main Thread Checker检测</c>

201
00:10:25,259 --> 00:10:27,895
<c.magenta>它支持AppKit、UIKit和WebKit</c>

202
00:10:27,961 --> 00:10:30,163
<c.magenta>它们是最常用的三个框架</c>

203
00:10:30,230 --> 00:10:33,867
<c.magenta>而且它们的许多API</c>

204
00:10:33,934 --> 00:10:35,569
<c.magenta>都具有相同的主线程要求</c>

205
00:10:36,770 --> 00:10:39,473
<c.magenta>我们的工具支持Swift和C语言</c>

206
00:10:39,773 --> 00:10:43,043
<c.magenta>与其它工具相比</c>

207
00:10:43,610 --> 00:10:45,412
<c.magenta>并不需要重新编译</c>

208
00:10:46,013 --> 00:10:48,081
<c.magenta>你甚至可以它们用于</c>

209
00:10:49,716 --> 00:10:52,519
<c.magenta>其最大的好处是</c>

210
00:10:52,586 --> 00:10:53,954
<c.magenta>你不需要做任何事情</c>

211
00:10:54,021 --> 00:10:55,856
<c.magenta>就可以通过工具获得警告信息</c>

212
00:10:55,923 --> 00:10:58,525
<c.magenta>当你使用Xcode调试器时</c>

213
00:10:59,660 --> 00:11:01,195
<c.magenta>这就是Main Thread Checker</c>

214
00:10:59,660 --> 00:11:01,195
<c.magenta>这就是Main Thread Checker</c>

215
00:11:01,428 --> 00:11:03,297
<c.magenta>Xcode 9包含的一个全新工具</c>

216
00:11:12,072 --> 00:11:16,844
<c.magenta>接下来 我们讨论</c>

217
00:11:17,411 --> 00:11:20,948
<c.magenta>接下来我们讨论Address Sanitizer</c>

218
00:11:22,182 --> 00:11:26,286
<c.magenta>两年前 Address Sanitizer</c>

219
00:11:26,353 --> 00:11:28,288
<c.magenta>实践证明它是一个很不错的工具</c>

220
00:11:28,355 --> 00:11:30,557
<c.magenta>因为它能够发现严重的安全问题</c>

221
00:11:30,691 --> 00:11:33,627
<c.magenta>例如 内存释放后使用问题</c>

222
00:11:34,695 --> 00:11:35,963
<c.magenta>另外 当尝试诊断</c>

223
00:11:36,029 --> 00:11:38,498
<c.magenta>难以重现的崩溃问题时</c>

224
00:11:38,565 --> 00:11:41,568
<c.magenta>因为它确定崩溃原因</c>

225
00:11:41,969 --> 00:11:45,038
<c.magenta>在发生崩溃时</c>

226
00:11:45,105 --> 00:11:46,206
<c.magenta>发现内存异常问题</c>

227
00:11:46,273 --> 00:11:48,642
<c.magenta>确定哪些相关代码</c>

228
00:11:49,643 --> 00:11:51,678
<c.magenta>如果你想知道</c>

229
00:11:51,745 --> 00:11:53,680
<c.magenta>以及它可以发现哪些漏洞</c>

230
00:11:53,747 --> 00:11:56,884
<c.magenta>建议你们观看</c>

231
00:11:57,084 --> 00:11:59,920
<c.magenta>其名称为“高级调试技术</c>

232
00:12:00,654 --> 00:12:02,489
<c.magenta>在那个演讲中</c>

233
00:12:02,556 --> 00:12:05,359
<c.magenta>并讨论其底层工作原理</c>

234
00:12:06,994 --> 00:12:11,231
<c.magenta>Address Sanitizer集成到</c>

235
00:12:11,465 --> 00:12:12,299
<c.magenta>让我们来看看</c>

236
00:12:12,499 --> 00:12:14,434
<c.magenta>如果你想要使用Address Sanitizer</c>

237
00:12:14,535 --> 00:12:16,570
<c.magenta>需要做的是</c>

238
00:12:16,637 --> 00:12:19,873
<c.magenta>你会发现有一个复选框</c>

239
00:12:20,307 --> 00:12:21,842
<c.magenta>选中后将会启用此工具</c>

240
00:12:22,809 --> 00:12:25,345
<c.magenta>在Xcode 9中有另外一个复选框</c>

241
00:12:25,512 --> 00:12:29,416
<c.magenta>名称为</c>

242
00:12:29,650 --> 00:12:31,185
<c.magenta>后面我将会介绍这个功能</c>

243
00:12:31,952 --> 00:12:33,053
<c.magenta>你还会注意到</c>

244
00:12:33,320 --> 00:12:35,789
<c.magenta>我们增加了</c>

245
00:12:35,856 --> 00:12:38,659
<c.magenta>因此可以同时启用这两个工具</c>

246
00:12:41,094 --> 00:12:43,430
<c.magenta>然后 你可以运行和调试你的应用</c>

247
00:12:43,497 --> 00:12:44,665
<c.magenta>就像以前一样</c>

248
00:12:45,165 --> 00:12:48,569
<c.magenta>如果程序没有任何内存问题</c>

249
00:12:48,635 --> 00:12:52,206
<c.magenta>没有发生内存违规</c>

250
00:12:52,773 --> 00:12:55,108
<c.magenta>Address Sanitizer</c>

251
00:12:55,475 --> 00:12:58,745
<c.magenta>但是如果发现问题</c>

252
00:12:58,812 --> 00:13:00,280
<c.magenta>并描述问题是什么</c>

253
00:12:58,812 --> 00:13:00,280
<c.magenta>并描述问题是什么</c>

254
00:13:00,347 --> 00:13:01,481
<c.magenta>在本例中</c>

255
00:13:01,882 --> 00:13:04,551
<c.magenta>我们意外地使用</c>

256
00:13:05,052 --> 00:13:06,186
<c.magenta>这是一个严重的漏洞</c>

257
00:13:07,054 --> 00:13:09,056
<c.magenta>当Address Sanitizer发现漏洞时</c>

258
00:13:09,223 --> 00:13:12,025
<c.magenta>将会显示</c>

259
00:13:12,192 --> 00:13:14,027
<c.magenta>关于所访问的内存的详细信息</c>

260
00:13:14,461 --> 00:13:16,496
<c.magenta>我们不仅会看到内存地址</c>

261
00:13:16,830 --> 00:13:18,665
<c.magenta>还会看到描述信息</c>

262
00:13:18,866 --> 00:13:20,767
<c.magenta>比如内存堆区有多大</c>

263
00:13:20,934 --> 00:13:23,170
<c.magenta>访问了哪些超范围字节</c>

264
00:13:23,704 --> 00:13:27,207
<c.magenta>还会获得内存分配和</c>

265
00:13:27,441 --> 00:13:30,043
<c.magenta>描述内存的分配和释放方式</c>

266
00:13:30,544 --> 00:13:31,845
<c.magenta>当你处理内存释放后使用问题时</c>

267
00:13:31,912 --> 00:13:34,081
<c.magenta>这些都是非常有用的信息</c>

268
00:13:34,448 --> 00:13:37,251
<c.magenta>因为它们可以帮助你诊断问题</c>

269
00:13:39,753 --> 00:13:42,222
<c.magenta>我们已经对</c>

270
00:13:42,289 --> 00:13:43,924
<c.magenta>现在来看我们今年</c>

271
00:13:43,991 --> 00:13:45,325
<c.magenta>增加的一些新功能</c>

272
00:13:45,559 --> 00:13:47,961
<c.magenta>此工具检查两类新漏洞</c>

273
00:13:48,161 --> 00:13:50,197
<c.magenta>即use-after-scope</c>

274
00:13:50,264 --> 00:13:52,799
<c.magenta>此工具还兼容Malloc Scribble</c>

275
00:13:52,966 --> 00:13:54,401
<c.magenta>让我们来看一些例子</c>

276
00:13:56,837 --> 00:13:58,071
<c.magenta>在代码示例中</c>

277
00:13:58,539 --> 00:14:01,074
<c.magenta>假设我们在if表达式语句中</c>

278
00:13:58,539 --> 00:14:01,074
<c.magenta>假设我们在if表达式语句中</c>

279
00:14:01,141 --> 00:14:02,976
<c.magenta>定义一个变量</c>

280
00:14:04,478 --> 00:14:07,181
<c.magenta>有一个指针指向这个变量</c>

281
00:14:07,981 --> 00:14:10,717
<c.magenta>然后 在if语句之外</c>

282
00:14:11,118 --> 00:14:13,587
<c.magenta>我们使用这个指针保存一个新值</c>

283
00:14:14,221 --> 00:14:17,491
<c.magenta>这是一个新值</c>

284
00:14:17,658 --> 00:14:19,760
<c.magenta>Address Sanitizer</c>

285
00:14:19,993 --> 00:14:21,495
<c.magenta>并且描述问题</c>

286
00:14:24,097 --> 00:14:28,035
<c.magenta>另一种类型的漏洞发生在</c>

287
00:14:28,302 --> 00:14:30,103
<c.magenta>使用指针时</c>

288
00:14:30,170 --> 00:14:31,772
<c.magenta>从函数中返回之后</c>

289
00:14:31,839 --> 00:14:35,609
<c.magenta>在本例中</c>

290
00:14:36,376 --> 00:14:38,478
<c.magenta>这意味着</c>

291
00:14:38,745 --> 00:14:40,414
<c.magenta>指针已经不再有效</c>

292
00:14:40,814 --> 00:14:42,115
<c.magenta>如果尝试使用这个指针</c>

293
00:14:42,482 --> 00:14:44,318
<c.magenta>就会访问垃圾内存</c>

294
00:14:44,484 --> 00:14:46,320
<c.magenta>这时Address Sanitizer</c>

295
00:14:46,386 --> 00:14:48,255
<c.magenta>并描述错误信息</c>

296
00:14:48,789 --> 00:14:51,491
<c.magenta>但是这种检查并不是默认启用的</c>

297
00:14:51,558 --> 00:14:53,527
<c.magenta>因为它会占用一些额外开销</c>

298
00:14:53,594 --> 00:14:54,761
<c.magenta>你应该启用此功能</c>

299
00:14:54,995 --> 00:14:58,165
<c.magenta>为此 你应该选中</c>

300
00:14:58,298 --> 00:14:59,967
<c.magenta>方案编辑器中的复选框</c>

301
00:15:02,703 --> 00:15:04,338
<c.magenta>（ADDRESS SANITIZER与SWIFT）</c>

302
00:15:04,404 --> 00:15:07,074
<c.magenta>现在 如果使用Swift开发项目</c>

303
00:15:07,407 --> 00:15:08,642
<c.magenta>你可能会想</c>

304
00:15:08,809 --> 00:15:10,844
<c.magenta>我什么要使用Address Sanitizer？</c>

305
00:15:12,012 --> 00:15:13,714
<c.magenta>Swift是一种更安全的语言</c>

306
00:15:13,814 --> 00:15:16,216
<c.magenta>但是现实情况是</c>

307
00:15:16,283 --> 00:15:18,886
<c.magenta>它们的C和Objective-C代码</c>

308
00:15:19,052 --> 00:15:21,989
<c.magenta>对于C和 Objective-C代码</c>

309
00:15:22,456 --> 00:15:24,491
<c.magenta>Address Sanitizer</c>

310
00:15:24,558 --> 00:15:26,360
<c.magenta>它会发现这些部分的</c>

311
00:15:26,426 --> 00:15:27,661
<c.magenta>代码中的内存问题</c>

312
00:15:29,096 --> 00:15:31,832
<c.magenta>你们一些人可能使用不安全的指针类型</c>

313
00:15:32,366 --> 00:15:33,934
<c.magenta>这意味着</c>

314
00:15:34,868 --> 00:15:35,736
<c.magenta>会产生内存安全问题</c>

315
00:15:35,802 --> 00:15:37,504
<c.magenta>当使用这些指针时</c>

316
00:15:37,738 --> 00:15:39,139
<c.magenta>让我们来看代码示例</c>

317
00:15:40,440 --> 00:15:43,076
<c.magenta>在这个代码中 有一个字符串</c>

318
00:15:43,143 --> 00:15:47,247
<c.magenta>我要将它转换成为</c>

319
00:15:47,614 --> 00:15:48,682
<c.magenta>使用不安全的窗口</c>

320
00:15:50,217 --> 00:15:53,921
<c.magenta>我要做的是调用</c>

321
00:15:54,087 --> 00:15:56,456
<c.magenta>这将会为我</c>

322
00:15:58,025 --> 00:16:00,093
<c.magenta>为我提供一个不安全的指针</c>

323
00:15:58,025 --> 00:16:00,093
<c.magenta>为我提供一个不安全的指针</c>

324
00:16:00,160 --> 00:16:02,229
<c.magenta>在这个结束处理中</c>

325
00:16:03,297 --> 00:16:06,466
<c.magenta>如果在处理程序之外</c>

326
00:16:06,800 --> 00:16:08,702
<c.magenta>就违反了C字符串规则</c>

327
00:16:08,769 --> 00:16:13,974
<c.magenta>这意味着 我尝试使用</c>

328
00:16:14,141 --> 00:16:15,909
<c.magenta>也就是说 我在尝试访问无效的内容</c>

329
00:16:15,976 --> 00:16:18,812
<c.magenta>Address Sanitizer</c>

330
00:16:18,879 --> 00:16:21,248
<c.magenta>无效地使用不安全指针的情况</c>

331
00:16:25,118 --> 00:16:26,453
<c.magenta>为了修复这个问题 我们需要确保</c>

332
00:16:26,520 --> 00:16:29,223
<c.magenta>仅在结束处理程序之内</c>

333
00:16:29,723 --> 00:16:32,059
<c.magenta>不安全指针</c>

334
00:16:32,125 --> 00:16:35,162
<c.magenta>因此 我们进入结束处理代码</c>

335
00:16:35,362 --> 00:16:37,364
<c.magenta>修复问题</c>

336
00:16:37,898 --> 00:16:39,766
<c.magenta>我们可以进一步简化代码</c>

337
00:16:39,833 --> 00:16:42,236
<c.magenta>完全移除本地变量</c>

338
00:16:42,870 --> 00:16:44,271
<c.magenta>一个良好的做法是</c>

339
00:16:44,738 --> 00:16:48,475
<c.magenta>始终不要将不安全的指针</c>

340
00:16:49,877 --> 00:16:53,046
<c.magenta>因此 如果要在Swift项目中</c>

341
00:16:53,380 --> 00:16:55,916
<c.magenta>我强烈建议你</c>

342
00:16:55,983 --> 00:16:57,551
<c.magenta>以确保</c>

343
00:16:57,618 --> 00:17:00,120
<c.magenta>不会错误地使用不安全的指针</c>

344
00:16:57,618 --> 00:17:00,120
<c.magenta>不会错误地使用不安全的指针</c>

345
00:17:03,423 --> 00:17:08,028
<c.magenta>我们已经了解Address Sanitizer</c>

346
00:17:08,395 --> 00:17:12,098
<c.magenta>但是 对于一般性调试</c>

347
00:17:13,200 --> 00:17:16,403
<c.magenta>因为当你调试项目时</c>

348
00:17:16,470 --> 00:17:20,207
<c.magenta>你可能会想要知道</c>

349
00:17:20,874 --> 00:17:22,209
<c.magenta>我有一个好消息要告诉你</c>

350
00:17:22,409 --> 00:17:24,278
<c.magenta>如果你运行Address Sanitizer</c>

351
00:17:24,744 --> 00:17:27,915
<c.magenta>这将能够告诉你</c>

352
00:17:27,981 --> 00:17:29,383
<c.magenta>分配回溯信息</c>

353
00:17:30,184 --> 00:17:32,586
<c.magenta>另外 还提供已经释放的内存的</c>

354
00:17:32,653 --> 00:17:34,488
<c.magenta>释放回溯信息</c>

355
00:17:35,255 --> 00:17:36,423
<c.magenta>此外 它还会告知</c>

356
00:17:36,490 --> 00:17:38,825
<c.magenta>哪些内存字节是有效和无效的</c>

357
00:17:40,027 --> 00:17:40,861
<c.magenta>让我们来看看</c>

358
00:17:41,328 --> 00:17:44,331
<c.magenta>这次的例子不是内存崩溃</c>

359
00:17:44,498 --> 00:17:47,067
<c.magenta>这是一个普通调试会话</c>

360
00:17:47,267 --> 00:17:49,403
<c.magenta>我进入一个函数的代码行</c>

361
00:17:50,804 --> 00:17:53,941
<c.magenta>我可以控制点击变量视图中的任何变量</c>

362
00:17:54,608 --> 00:17:58,912
<c.magenta>如果变量是一个指针</c>

363
00:18:01,114 --> 00:18:03,617
<c.magenta>通常这会提供一个视图</c>

364
00:18:03,717 --> 00:18:05,786
<c.magenta>显示内存对象字节信息</c>

365
00:18:06,687 --> 00:18:08,889
<c.magenta>但若启用Address Sanitizer</c>

366
00:18:09,056 --> 00:18:12,226
<c.magenta>可以在导航器中查看内存项目</c>

367
00:18:12,693 --> 00:18:15,195
<c.magenta>将会显示该内存的分配</c>

368
00:18:15,262 --> 00:18:16,129
<c.magenta>和释放线程跟踪</c>

369
00:18:18,398 --> 00:18:21,168
<c.magenta>在这个内在视图中 你还会注意到</c>

370
00:18:21,235 --> 00:18:23,504
<c.magenta>一些字节显示为灰色</c>

371
00:18:24,605 --> 00:18:27,407
<c.magenta>灰色字节表示无效内存</c>

372
00:18:27,541 --> 00:18:29,776
<c.magenta>是禁止访问的内存</c>

373
00:18:30,077 --> 00:18:33,013
<c.magenta>意味着你的程序不能访问这些字节</c>

374
00:18:33,146 --> 00:18:34,781
<c.magenta>如果访问 就会产生错误</c>

375
00:18:34,915 --> 00:18:37,017
<c.magenta>Address Sanitizer</c>

376
00:18:39,186 --> 00:18:42,122
<c.magenta>还可以在lldb文本控制台上</c>

377
00:18:42,189 --> 00:18:44,057
<c.magenta>访问内存对象的分配</c>

378
00:18:44,258 --> 00:18:45,659
<c.magenta>和释放信息</c>

379
00:18:45,926 --> 00:18:48,262
<c.magenta>我们可以使用这个指令调用内存历史</c>

380
00:18:48,428 --> 00:18:51,365
<c.magenta>将它作为表达式进行传递</c>

381
00:18:52,633 --> 00:18:55,636
<c.magenta>在本例中 我们直接使用这个指针值</c>

382
00:18:55,836 --> 00:18:57,504
<c.magenta>文本控制台将会在文本输出中</c>

383
00:18:57,938 --> 00:19:00,641
<c.magenta>打印分配和释放线程跟踪信息</c>

384
00:18:57,938 --> 00:19:00,641
<c.magenta>打印分配和释放线程跟踪信息</c>

385
00:19:04,044 --> 00:19:05,546
<c.magenta>我希望你们知道</c>

386
00:19:05,679 --> 00:19:08,515
<c.magenta>Address Sanitizer</c>

387
00:19:08,582 --> 00:19:10,851
<c.magenta>适用于C语言和Swift</c>

388
00:19:11,318 --> 00:19:13,720
<c.magenta>帮助处理内存损坏和崩溃问题</c>

389
00:19:14,254 --> 00:19:17,624
<c.magenta>这是一个非常有用的工具</c>

390
00:19:18,625 --> 00:19:20,294
<c.magenta>现在 让我们来看</c>

391
00:19:20,460 --> 00:19:24,665
<c.magenta>另一种类型的崩溃和</c>

392
00:19:24,731 --> 00:19:25,933
<c.magenta>即多线程问题</c>

393
00:19:26,733 --> 00:19:29,770
<c.magenta>Thread Sanitizer</c>

394
00:19:32,439 --> 00:19:35,843
<c.magenta>前面我说过Thread Sanitizer</c>

395
00:19:35,943 --> 00:19:37,477
<c.magenta>例如数据争用</c>

396
00:19:38,612 --> 00:19:41,114
<c.magenta>这些多线程问题</c>

397
00:19:41,548 --> 00:19:44,251
<c.magenta>通常具有时间敏感性</c>

398
00:19:44,618 --> 00:19:47,821
<c.magenta>这意味着</c>

399
00:19:49,289 --> 00:19:52,059
<c.magenta>Thread Sanitizer</c>

400
00:19:52,192 --> 00:19:54,328
<c.magenta>即两个内存访问发生冲突</c>

401
00:19:54,461 --> 00:19:57,731
<c.magenta>而且能够发现特定程序运行期间</c>

402
00:19:57,798 --> 00:19:59,666
<c.magenta>并不明显的数据争用</c>

403
00:20:01,034 --> 00:20:05,038
<c.magenta>即使竞争内存访问发生在不同的时间</c>

404
00:20:05,172 --> 00:20:07,174
<c.magenta>但是它们之间不是同步的</c>

405
00:20:07,341 --> 00:20:08,408
<c.magenta>仍然是竞争的</c>

406
00:20:08,575 --> 00:20:10,611
<c.magenta>Thread Sanitizer能够发现这个问题</c>

407
00:20:11,512 --> 00:20:14,648
<c.magenta>那是因为下次运行程序时</c>

408
00:20:15,349 --> 00:20:16,850
<c.magenta>时间将会发生错位</c>

409
00:20:16,917 --> 00:20:19,720
<c.magenta>可能会产生内存错误</c>

410
00:20:20,187 --> 00:20:23,357
<c.magenta>Thread Sanitizer能够发现内存争用</c>

411
00:20:25,592 --> 00:20:28,962
<c.magenta>这个工具适用于64位macOS</c>

412
00:20:29,029 --> 00:20:31,698
<c.magenta>如果想要更多了解底层技术</c>

413
00:20:31,765 --> 00:20:36,003
<c.magenta>建议你们观看去年的WWDC演讲</c>

414
00:20:36,069 --> 00:20:38,172
<c.magenta>名称为“Thread Sanitizer</c>

415
00:20:41,108 --> 00:20:42,476
<c.magenta>前面我说过“数据争用”</c>

416
00:20:42,910 --> 00:20:44,077
<c.magenta>让我们来看它们是什么</c>

417
00:20:46,046 --> 00:20:47,414
<c.magenta>任何共享数据</c>

418
00:20:47,781 --> 00:20:50,384
<c.magenta>任何在多线程之间共享的可变数据</c>

419
00:20:50,651 --> 00:20:52,219
<c.magenta>都需要同步访问</c>

420
00:20:52,853 --> 00:20:56,190
<c.magenta>如果共享可变变量未能同步</c>

421
00:20:56,590 --> 00:20:57,858
<c.magenta>就意味着发生数据争用</c>

422
00:20:57,991 --> 00:21:00,027
<c.magenta>数据争用是未定义的行为</c>

423
00:20:57,991 --> 00:21:00,027
<c.magenta>数据争用是未定义的行为</c>

424
00:21:01,328 --> 00:21:02,796
<c.magenta>存在数据争用时</c>

425
00:21:02,863 --> 00:21:05,299
<c.magenta>程序可能发生内存错误和崩溃</c>

426
00:21:05,566 --> 00:21:07,768
<c.magenta>不仅C语言</c>

427
00:21:07,835 --> 00:21:09,503
<c.magenta>且Swift代码也存在这些问题</c>

428
00:21:10,103 --> 00:21:11,839
<c.magenta>让我们来看Swift中的例子</c>

429
00:21:14,074 --> 00:21:17,344
<c.magenta>在本例中 有一个名称为EventLog的类</c>

430
00:21:17,711 --> 00:21:20,948
<c.magenta>它有一个简单的函数</c>

431
00:21:21,315 --> 00:21:23,717
<c.magenta>打印一些文本信息到输出</c>

432
00:21:24,484 --> 00:21:25,719
<c.magenta>此函数还跟踪</c>

433
00:21:26,119 --> 00:21:29,523
<c.magenta>调用此log函数的lastEventSource</c>

434
00:21:30,023 --> 00:21:31,592
<c.magenta>将这些信息</c>

435
00:21:31,692 --> 00:21:34,695
<c.magenta>保存到一个共享属性</c>

436
00:21:35,262 --> 00:21:38,899
<c.magenta>这是一个可选属性</c>

437
00:21:38,966 --> 00:21:40,801
<c.magenta>当用户调用log函数时</c>

438
00:21:41,101 --> 00:21:45,272
<c.magenta>将会加入此特定的日志源</c>

439
00:21:46,006 --> 00:21:47,608
<c.magenta>假设我们有两个线程</c>

440
00:21:47,908 --> 00:21:51,178
<c.magenta>两个线程都同时调用log函数</c>

441
00:21:51,445 --> 00:21:54,214
<c.magenta>假设线程一是网络子线程</c>

442
00:21:54,281 --> 00:21:56,183
<c.magenta>它记录某些下载完成情况</c>

443
00:21:56,750 --> 00:21:57,851
<c.magenta>第二个线程</c>

444
00:21:58,118 --> 00:22:00,020
<c.magenta>代表我们的数据子系统</c>

445
00:21:58,118 --> 00:22:00,020
<c.magenta>代表我们的数据子系统</c>

446
00:22:00,087 --> 00:22:02,022
<c.magenta>记录查询完成情况</c>

447
00:22:03,290 --> 00:22:04,458
<c.magenta>这就是数据争用</c>

448
00:22:05,359 --> 00:22:08,795
<c.magenta>因为两个线程同时访问同一内存位置</c>

449
00:22:09,963 --> 00:22:11,832
<c.magenta>Thread Sanitizer对此发出警告</c>

450
00:22:13,534 --> 00:22:14,501
<c.magenta>为了修复这个问题</c>

451
00:22:15,903 --> 00:22:17,371
<c.magenta>我们需要引入同步机制</c>

452
00:22:17,504 --> 00:22:21,141
<c.magenta>最简单的方法</c>

453
00:22:21,808 --> 00:22:23,844
<c.magenta>因此队列是串行的</c>

454
00:22:24,144 --> 00:22:27,014
<c.magenta>一次仅执行一个工作项目</c>

455
00:22:28,315 --> 00:22:29,249
<c.magenta>如果我们将log函数主体</c>

456
00:22:30,384 --> 00:22:33,387
<c.magenta>封装到queue.async之中</c>

457
00:22:34,288 --> 00:22:36,056
<c.magenta>这将提供正确的同步</c>

458
00:22:36,423 --> 00:22:38,425
<c.magenta>你们会发现 这里我使用async</c>

459
00:22:38,492 --> 00:22:40,093
<c.magenta>因为我们并不需要等待</c>

460
00:22:40,160 --> 00:22:42,129
<c.magenta>此函数完成</c>

461
00:22:42,196 --> 00:22:44,831
<c.magenta>因为此函数并不提供任何结果</c>

462
00:22:44,898 --> 00:22:46,366
<c.magenta>因此并不需要等待</c>

463
00:22:46,767 --> 00:22:50,037
<c.magenta>这不仅会修复争用问题</c>

464
00:22:50,871 --> 00:22:53,073
<c.magenta>因为现在无论任何人调用log函数</c>

465
00:22:53,340 --> 00:22:55,742
<c.magenta>将不需要等待打印函数结束</c>

466
00:22:58,378 --> 00:23:01,281
<c.magenta>这样确保整个类的线程安全</c>

467
00:22:58,378 --> 00:23:01,281
<c.magenta>这样确保整个类的线程安全</c>

468
00:23:01,381 --> 00:23:03,116
<c.magenta>我们可以从多线程调用log函数</c>

469
00:23:05,285 --> 00:23:08,789
<c.magenta>Grand Central Dispatch</c>

470
00:23:08,856 --> 00:23:10,190
<c.magenta>分派队列</c>

471
00:23:10,657 --> 00:23:11,925
<c.magenta>可以在Swift中使用</c>

472
00:23:11,992 --> 00:23:14,328
<c.magenta>应该成为首选的同步方法</c>

473
00:23:14,828 --> 00:23:18,532
<c.magenta>即使有其它同步机制</c>

474
00:23:18,699 --> 00:23:21,902
<c.magenta>GCD是轻量级的</c>

475
00:23:22,769 --> 00:23:26,740
<c.magenta>一个良好的做法是将数据</c>

476
00:23:26,974 --> 00:23:29,076
<c.magenta>仅从这些队列访问数据</c>

477
00:23:29,776 --> 00:23:32,646
<c.magenta>这将保证仅以同步方法</c>

478
00:23:32,713 --> 00:23:33,947
<c.magenta>使用你的数据</c>

479
00:23:34,681 --> 00:23:38,452
<c.magenta>如果你想了解</c>

480
00:23:38,585 --> 00:23:41,955
<c.magenta>我建议你们</c>

481
00:23:42,022 --> 00:23:44,658
<c.magenta>名称为“GCD和Swift 3并发程序设计”</c>

482
00:23:47,094 --> 00:23:48,695
<c.magenta>让我们来看</c>

483
00:23:48,762 --> 00:23:51,598
<c.magenta>Xcode 9中增加的</c>

484
00:23:52,132 --> 00:23:54,568
<c.magenta>此工具能够检测集合争用</c>

485
00:23:54,935 --> 00:23:57,938
<c.magenta>和Swift代码特有的</c>

486
00:23:58,005 --> 00:24:00,140
<c.magenta>新漏洞类</c>

487
00:23:58,005 --> 00:24:00,140
<c.magenta>新漏洞类</c>

488
00:24:02,409 --> 00:24:06,013
<c.magenta>在以前Thread Sanitizer</c>

489
00:24:06,213 --> 00:24:07,648
<c.magenta>原始内存访问争用</c>

490
00:24:07,814 --> 00:24:09,316
<c.magenta>类似于前面的例子</c>

491
00:24:09,383 --> 00:24:12,286
<c.magenta>在上例中 我们直接访问某些存储属性</c>

492
00:24:13,420 --> 00:24:16,390
<c.magenta>但是 对于大型数据结构</c>

493
00:24:16,456 --> 00:24:17,658
<c.magenta>例如集合数据</c>

494
00:24:18,225 --> 00:24:20,127
<c.magenta>请考虑这个示例代码</c>

495
00:24:20,661 --> 00:24:24,498
<c.magenta>在Objective-C中我们使用</c>

496
00:24:25,065 --> 00:24:27,167
<c.magenta>这两个线程使用相同的实例</c>

497
00:24:27,234 --> 00:24:30,437
<c.magenta>假设线程一查找词典中的值</c>

498
00:24:30,604 --> 00:24:32,940
<c.magenta>第二个线程尝试写入词典</c>

499
00:24:33,707 --> 00:24:36,109
<c.magenta>现在Xcode 9中的新功能</c>

500
00:24:36,176 --> 00:24:38,212
<c.magenta>能够检测此争用问题</c>

501
00:24:41,548 --> 00:24:43,917
<c.magenta>集合争用是一个常见的错误</c>

502
00:24:44,985 --> 00:24:48,989
<c.magenta>在Xcode 9中我们能够检测</c>

503
00:24:49,056 --> 00:24:49,890
<c.magenta>这些问题</c>

504
00:24:50,290 --> 00:24:51,425
<c.magenta>请注意 这要求</c>

505
00:24:51,491 --> 00:24:54,294
<c.magenta>你们使用macOS、</c>

506
00:24:54,461 --> 00:24:56,997
<c.magenta>我们能够检测</c>

507
00:24:57,064 --> 00:25:00,767
<c.magenta>和NSMutableDictionary以及</c>

508
00:24:57,064 --> 00:25:00,767
<c.magenta>和NSMutableDictionary以及</c>

509
00:25:01,668 --> 00:25:04,505
<c.magenta>在这方面 我想要展示实际运行原理</c>

510
00:25:20,521 --> 00:25:22,789
<c.magenta>我获得采用Swift代码之前的</c>

511
00:25:23,123 --> 00:25:26,326
<c.magenta>旧版本WWDC应用</c>

512
00:25:26,393 --> 00:25:28,362
<c.magenta>的源代码</c>

513
00:25:28,462 --> 00:25:30,130
<c.magenta>这个版本是</c>

514
00:25:30,197 --> 00:25:32,199
<c.magenta>完全用Objective-C编写的</c>

515
00:25:32,399 --> 00:25:34,701
<c.magenta>你可以看到</c>

516
00:25:34,768 --> 00:25:37,004
<c.magenta>此程序是在2011年编写的</c>

517
00:25:38,405 --> 00:25:41,108
<c.magenta>是几年前编写的</c>

518
00:25:41,175 --> 00:25:43,043
<c.magenta>使用一些过时的概念</c>

519
00:25:43,110 --> 00:25:46,246
<c.magenta>比如显式线程同步 而不是使用GCD</c>

520
00:25:46,446 --> 00:25:49,183
<c.magenta>但是我想展示给你们看</c>

521
00:25:49,249 --> 00:25:51,518
<c.magenta>即使配合其它同步机制</c>

522
00:25:53,787 --> 00:25:55,556
<c.magenta>我展示给你们看的文件</c>

523
00:25:55,956 --> 00:25:58,959
<c.magenta>实现一个类 名称为</c>

524
00:25:59,026 --> 00:26:00,627
<c.magenta>它用作基类</c>

525
00:25:59,026 --> 00:26:00,627
<c.magenta>它用作基类</c>

526
00:26:00,694 --> 00:26:03,230
<c.magenta>以便在此应用中完成所有网络处理</c>

527
00:26:03,897 --> 00:26:07,901
<c.magenta>我所做的是</c>

528
00:26:08,368 --> 00:26:10,938
<c.magenta>让我们来看</c>

529
00:26:12,005 --> 00:26:14,541
<c.magenta>首先 转到“产品”方案</c>

530
00:26:14,608 --> 00:26:17,778
<c.magenta>确保启用</c>

531
00:26:18,345 --> 00:26:21,381
<c.magenta>调出方案编辑</c>

532
00:26:21,448 --> 00:26:24,318
<c.magenta>你们可以看到</c>

533
00:26:24,918 --> 00:26:27,487
<c.magenta>现在我在这个模拟器中运行这个应用</c>

534
00:26:29,990 --> 00:26:32,626
<c.magenta>应用在模拟器中启动时</c>

535
00:26:32,693 --> 00:26:35,729
<c.magenta>将会启动多个网络连接</c>

536
00:26:36,997 --> 00:26:40,367
<c.magenta>因此 它将会使用这个文件</c>

537
00:26:41,101 --> 00:26:42,636
<c.magenta>你们注意到</c>

538
00:26:42,703 --> 00:26:46,540
<c.magenta>Xcode在问题导航器中报告争用情况</c>

539
00:26:47,908 --> 00:26:49,977
<c.magenta>这个问题报告一个争用问题</c>

540
00:26:50,043 --> 00:26:52,613
<c.magenta>让我们点击这个问题</c>

541
00:26:52,679 --> 00:26:54,314
<c.magenta>进入含有这个争用问题的代码行</c>

542
00:26:54,481 --> 00:26:58,919
<c.magenta>在这个例子中 可以看到</c>

543
00:27:00,287 --> 00:27:03,390
<c.magenta>此代码的目标是</c>

544
00:27:03,457 --> 00:27:04,658
<c.magenta>维护一个活跃连接列表</c>

545
00:27:04,725 --> 00:27:07,327
<c.magenta>我们跟踪监测这个列表</c>

546
00:27:08,629 --> 00:27:11,532
<c.magenta>在创建一些新URL连接之后</c>

547
00:27:11,598 --> 00:27:13,000
<c.magenta>我们将它添加到列表</c>

548
00:27:14,067 --> 00:27:15,536
<c.magenta>可以在任何线程中完成这些工作</c>

549
00:27:15,702 --> 00:27:18,238
<c.magenta>任何线程可以创建新URL连接</c>

550
00:27:18,839 --> 00:27:20,641
<c.magenta>如果我们在导航器中</c>

551
00:27:20,707 --> 00:27:22,242
<c.magenta>再次查看问题详情</c>

552
00:27:22,376 --> 00:27:23,610
<c.magenta>我们可以看到</c>

553
00:27:23,677 --> 00:27:27,047
<c.magenta>有个线程三调用addObject</c>

554
00:27:27,481 --> 00:27:30,250
<c.magenta>另外线程五</c>

555
00:27:30,484 --> 00:27:32,452
<c.magenta>调用addObject</c>

556
00:27:33,253 --> 00:27:36,223
<c.magenta>如果查看API调用函数</c>

557
00:27:36,290 --> 00:27:40,227
<c.magenta>我们将会看到</c>

558
00:27:41,061 --> 00:27:44,531
<c.magenta>因此这是一个问题</c>

559
00:27:44,765 --> 00:27:46,800
<c.magenta>访问这个可变数组</c>

560
00:27:47,868 --> 00:27:50,604
<c.magenta>我可以轻松地解决这个问题</c>

561
00:27:50,671 --> 00:27:54,208
<c.magenta>因为我注意到</c>

562
00:27:54,274 --> 00:27:56,009
<c.magenta>在进行某种同步处理</c>

563
00:27:56,076 --> 00:27:58,545
<c.magenta>它使用这个名称为</c>

564
00:27:59,012 --> 00:28:01,715
<c.magenta>分派相同的工作到特定线程</c>

565
00:27:59,012 --> 00:28:01,715
<c.magenta>分派相同的工作到特定线程</c>

566
00:28:01,849 --> 00:28:03,851
<c.magenta>在本例中</c>

567
00:28:04,351 --> 00:28:07,421
<c.magenta>这个显式线程</c>

568
00:28:07,855 --> 00:28:09,489
<c.magenta>这是一个单线程</c>

569
00:28:09,556 --> 00:28:13,560
<c.magenta>进行串行工作的同步处理</c>

570
00:28:13,861 --> 00:28:16,730
<c.magenta>因为这是一个单线程</c>

571
00:28:17,331 --> 00:28:21,735
<c.magenta>为了解决这个问题</c>

572
00:28:22,035 --> 00:28:24,371
<c.magenta>转移到同步处理代码块 比如这个</c>

573
00:28:25,005 --> 00:28:26,206
<c.magenta>这应该能够解决这个争用问题</c>

574
00:28:26,273 --> 00:28:30,811
<c.magenta>因为现在我们只能够</c>

575
00:28:31,044 --> 00:28:34,081
<c.magenta>访问活跃连接数组</c>

576
00:28:34,314 --> 00:28:37,251
<c.magenta>现在 我们再次在模拟器中运行应用</c>

577
00:28:37,417 --> 00:28:39,419
<c.magenta>让我们查看这是否会修复争用问题</c>

578
00:28:40,888 --> 00:28:42,489
<c.magenta>应用再次启用时</c>

579
00:28:42,589 --> 00:28:45,325
<c.magenta>将会触发多个网络连接</c>

580
00:28:45,626 --> 00:28:48,929
<c.magenta>现在程序运行时</c>

581
00:28:48,996 --> 00:28:51,565
<c.magenta>不再报告任何运行时问题</c>

582
00:28:55,102 --> 00:28:58,405
<c.magenta>（演示 - THREAD SANITIZER</c>

583
00:29:01,508 --> 00:29:03,877
<c.magenta>你已经看到</c>

584
00:29:03,944 --> 00:29:05,779
<c.magenta>Objective-C代码中的争用问题</c>

585
00:29:06,446 --> 00:29:07,281
<c.magenta>那么Swift又如何呢？</c>

586
00:29:08,482 --> 00:29:10,817
<c.magenta>同样的检测功能也适用于Swift代码</c>

587
00:29:11,018 --> 00:29:13,320
<c.magenta>在本例中 如果我们有一个字符串数组</c>

588
00:29:13,987 --> 00:29:15,455
<c.magenta>而且有两个线程</c>

589
00:29:15,522 --> 00:29:17,958
<c.magenta>一个线程查找数组中的值</c>

590
00:29:18,058 --> 00:29:20,227
<c.magenta>另一个线程写入数组</c>

591
00:29:20,961 --> 00:29:23,897
<c.magenta>Thread Sanitizer会发现争用问题</c>

592
00:29:25,265 --> 00:29:28,836
<c.magenta>解决这个问题需要</c>

593
00:29:29,236 --> 00:29:33,006
<c.magenta>确保仅在相同的同步代码块内</c>

594
00:29:33,340 --> 00:29:34,875
<c.magenta>访问数组</c>

595
00:29:34,942 --> 00:29:38,712
<c.magenta>在本例中 线程一</c>

596
00:29:40,681 --> 00:29:41,782
<c.magenta>在本例中必须使用此队列</c>

597
00:29:41,849 --> 00:29:45,953
<c.magenta>因为我们需要从计算处理中输出值</c>

598
00:29:46,019 --> 00:29:49,056
<c.magenta>需要在字典中查找值</c>

599
00:29:49,122 --> 00:29:50,724
<c.magenta>因此我们需要等待结果</c>

600
00:29:50,791 --> 00:29:52,392
<c.magenta>这里我使用queue.sync</c>

601
00:29:52,659 --> 00:29:55,195
<c.magenta>但是对于第二线程</c>

602
00:29:55,262 --> 00:29:58,398
<c.magenta>因为代码块不提供任何输出</c>

603
00:29:58,465 --> 00:30:00,033
<c.magenta>因此不需要等待代码完成</c>

604
00:29:58,465 --> 00:30:00,033
<c.magenta>因此不需要等待代码完成</c>

605
00:30:03,303 --> 00:30:05,672
<c.magenta>因此 你可能注意到</c>

606
00:30:05,739 --> 00:30:08,008
<c.magenta>我没有将这个问题称为数据争用</c>

607
00:30:08,509 --> 00:30:11,578
<c.magenta>相反 警告信息说</c>

608
00:30:13,013 --> 00:30:16,884
<c.magenta>Swift访问竞争</c>

609
00:30:17,284 --> 00:30:18,952
<c.magenta>这些规则适用于所有数据结构</c>

610
00:30:19,086 --> 00:30:21,588
<c.magenta>不仅适用于数组和词典</c>

611
00:30:21,655 --> 00:30:22,956
<c.magenta>甚至自定义的数据类型</c>

612
00:30:23,624 --> 00:30:26,527
<c.magenta>因此 这是Swift 4中的新规则</c>

613
00:30:27,261 --> 00:30:31,164
<c.magenta>此规则要求</c>

614
00:30:31,632 --> 00:30:34,401
<c.magenta>独占性地访问整个结构</c>

615
00:30:35,769 --> 00:30:37,004
<c.magenta>这并不适用于类</c>

616
00:30:37,070 --> 00:30:39,173
<c.magenta>因为类并没有变更方法</c>

617
00:30:39,406 --> 00:30:42,543
<c.magenta>任何类方法都可以更改属性</c>

618
00:30:42,609 --> 00:30:45,512
<c.magenta>仅需要排它性访问</c>

619
00:30:45,579 --> 00:30:47,981
<c.magenta>此方法所更改的属性</c>

620
00:30:49,683 --> 00:30:52,719
<c.magenta>因此 编译器强制要求</c>

621
00:30:53,187 --> 00:30:55,289
<c.magenta>将新规则应用于数据结构</c>

622
00:30:55,355 --> 00:30:58,659
<c.magenta>要求在编译器时间</c>

623
00:30:59,660 --> 00:31:02,663
<c.magenta>但是这种强制要求仅适用于单线程违规</c>

624
00:30:59,660 --> 00:31:02,663
<c.magenta>但是这种强制要求仅适用于单线程违规</c>

625
00:31:02,996 --> 00:31:06,066
<c.magenta>Thread Sanitizer</c>

626
00:31:06,633 --> 00:31:09,269
<c.magenta>如果想要详细了解Swift 4中的</c>

627
00:31:09,336 --> 00:31:12,406
<c.magenta>我建议你们观看</c>

628
00:31:13,307 --> 00:31:17,211
<c.magenta>有一个部分名为“独占性内存访问”</c>

629
00:31:17,277 --> 00:31:19,046
<c.magenta>讲述这些新规则</c>

630
00:31:19,246 --> 00:31:21,748
<c.magenta>并讨论所需要执行的要求</c>

631
00:31:22,716 --> 00:31:24,518
<c.magenta>让我们来看另外一个例子</c>

632
00:31:25,619 --> 00:31:29,756
<c.magenta>假设有个朋友要求我</c>

633
00:31:30,624 --> 00:31:31,792
<c.magenta>我们设计这个数据结构</c>

634
00:31:31,859 --> 00:31:34,027
<c.magenta>它描述这个太空飞船的位置</c>

635
00:31:34,394 --> 00:31:36,063
<c.magenta>另外有一些存储属性</c>

636
00:31:36,363 --> 00:31:40,067
<c.magenta>描述空间和时间坐标</c>

637
00:31:40,734 --> 00:31:43,537
<c.magenta>有一些方法调用此结构</c>

638
00:31:43,871 --> 00:31:46,507
<c.magenta>因为太空飞船</c>

639
00:31:46,740 --> 00:31:49,109
<c.magenta>还可以飞行到相同星球的不同城市</c>

640
00:31:49,710 --> 00:31:51,278
<c.magenta>当然 也可以进行时空旅行</c>

641
00:31:53,113 --> 00:31:55,682
<c.magenta>因此这些方法更改坐标</c>

642
00:31:55,849 --> 00:31:57,417
<c.magenta>它们应该是变更方法</c>

643
00:31:57,751 --> 00:31:58,952
<c.magenta>这意味着我刚才讲到的规则</c>

644
00:31:59,019 --> 00:32:00,988
<c.magenta>适用于所有这些方法</c>

645
00:31:59,019 --> 00:32:00,988
<c.magenta>适用于所有这些方法</c>

646
00:32:01,488 --> 00:32:02,489
<c.magenta>如果有两个线程</c>

647
00:32:02,556 --> 00:32:06,226
<c.magenta>尝试更改太空飞船的位置</c>

648
00:32:06,293 --> 00:32:08,529
<c.magenta>假设线程一</c>

649
00:32:08,595 --> 00:32:09,730
<c.magenta>运送到不同的星球</c>

650
00:32:10,330 --> 00:32:12,666
<c.magenta>第二个线程进行太空飞船的时间旅行</c>

651
00:32:13,233 --> 00:32:15,135
<c.magenta>这是Swift访问竞争问题</c>

652
00:32:16,637 --> 00:32:19,072
<c.magenta>请注意</c>

653
00:32:19,273 --> 00:32:22,209
<c.magenta>哪些函数和方法</c>

654
00:32:22,342 --> 00:32:24,745
<c.magenta>并不重要</c>

655
00:32:25,245 --> 00:32:28,015
<c.magenta>即使时空旅行更改X、Y和Z</c>

656
00:32:28,215 --> 00:32:30,584
<c.magenta>其它方法仅更改时间</c>

657
00:32:31,118 --> 00:32:32,686
<c.magenta>这仍然是Swift访问竞争</c>

658
00:32:33,220 --> 00:32:36,590
<c.magenta>这些规则仅要求</c>

659
00:32:36,757 --> 00:32:39,426
<c.magenta>必须独占性地</c>

660
00:32:39,493 --> 00:32:40,627
<c.magenta>访问整个数据结构</c>

661
00:32:43,263 --> 00:32:46,767
<c.magenta>很重要的一点是</c>

662
00:32:47,067 --> 00:32:50,470
<c.magenta>如果我们尝试修复这个问题</c>

663
00:32:50,737 --> 00:32:53,073
<c.magenta>我们尝试</c>

664
00:32:53,140 --> 00:32:55,142
<c.magenta>使用DispatchQueue</c>

665
00:32:55,209 --> 00:32:59,546
<c.magenta>保护变更函数的主体</c>

666
00:32:59,713 --> 00:33:01,915
<c.magenta>这并不是正确的修复方法</c>

667
00:32:59,713 --> 00:33:01,915
<c.magenta>这并不是正确的修复方法</c>

668
00:33:01,982 --> 00:33:04,852
<c.magenta>仍然是一个违规</c>

669
00:33:05,252 --> 00:33:07,988
<c.magenta>因为我们必须独占性访问数据结构</c>

670
00:33:08,522 --> 00:33:10,524
<c.magenta>以调用变更函数</c>

671
00:33:10,657 --> 00:33:14,428
<c.magenta>在函数内引入同步机制并不足够</c>

672
00:33:17,030 --> 00:33:19,700
<c.magenta>正确的修复方法是</c>

673
00:33:19,766 --> 00:33:22,302
<c.magenta>这些变更方法的调用函数</c>

674
00:33:23,036 --> 00:33:26,607
<c.magenta>假设有一个类描述整个太空飞船</c>

675
00:33:27,774 --> 00:33:29,409
<c.magenta>正确的方法是在这里使用一个类</c>

676
00:33:29,476 --> 00:33:32,546
<c.magenta>因为这个太空飞船有一个身份</c>

677
00:33:32,613 --> 00:33:34,248
<c.magenta>复制这个身份并不合适</c>

678
00:33:34,815 --> 00:33:36,416
<c.magenta>因此在本例中 太空飞船</c>

679
00:33:36,483 --> 00:33:40,387
<c.magenta>可以使用队列保护位置存储属性</c>

680
00:33:40,687 --> 00:33:44,825
<c.magenta>如果我们确保这些方法</c>

681
00:33:45,259 --> 00:33:48,161
<c.magenta>仅在同步代码块内访问数据结构</c>

682
00:33:48,428 --> 00:33:50,330
<c.magenta>这让整个类线程变得安全</c>

683
00:33:53,467 --> 00:33:56,336
<c.magenta>我们已经知道</c>

684
00:33:56,670 --> 00:33:58,338
<c.magenta>你需要同步对共享可变更变量的访问</c>

685
00:33:58,672 --> 00:34:00,374
<c.magenta>可以使用GCD来完成此任务</c>

686
00:33:58,672 --> 00:34:00,374
<c.magenta>可以使用GCD来完成此任务</c>

687
00:34:00,774 --> 00:34:01,708
<c.magenta>这通常比较简单</c>

688
00:34:01,775 --> 00:34:04,511
<c.magenta>类似于将数据与某些串行队列进行关联</c>

689
00:34:04,578 --> 00:34:07,381
<c.magenta>然后仅在队列中访问数据</c>

690
00:34:08,514 --> 00:34:11,752
<c.magenta>Thread Sanitizer是一个很有用的工具</c>

691
00:34:11,818 --> 00:34:13,687
<c.magenta>未进行同步的代码块</c>

692
00:34:14,054 --> 00:34:16,857
<c.magenta>这个问题比较容易解决</c>

693
00:34:18,625 --> 00:34:21,962
<c.magenta>我很高兴告诉你们</c>

694
00:34:22,029 --> 00:34:25,632
<c.magenta>今年我们引入另外一个Sanitizer</c>

695
00:34:25,732 --> 00:34:27,701
<c.magenta>接下来沃顿将会为大家进行介绍</c>

696
00:34:33,473 --> 00:34:34,308
<c.magenta>请沃顿上台</c>

697
00:34:37,744 --> 00:34:42,014
<c.magenta>我是沃顿</c>

698
00:34:42,081 --> 00:34:45,918
<c.magenta>我很高兴告诉你们</c>

699
00:34:45,985 --> 00:34:49,289
<c.magenta>我们发布了一个新工具</c>

700
00:34:49,389 --> 00:34:52,726
<c.magenta>我们帮助你发现更多漏洞</c>

701
00:34:54,094 --> 00:34:57,831
<c.magenta>什么是</c>

702
00:34:58,632 --> 00:35:01,869
<c.magenta>与其它运行时工具一样</c>

703
00:34:58,632 --> 00:35:01,869
<c.magenta>与其它运行时工具一样</c>

704
00:35:01,935 --> 00:35:03,904
<c.magenta>它是一个运行时漏洞排查器</c>

705
00:35:04,404 --> 00:35:06,607
<c.magenta>如其名称所示</c>

706
00:35:06,673 --> 00:35:10,744
<c.magenta>Undefined Behavior Sanitizer</c>

707
00:35:11,378 --> 00:35:15,883
<c.magenta>与Address Sanitizer和</c>

708
00:35:17,150 --> 00:35:20,053
<c.magenta>Undefined Behavior Sanitizer</c>

709
00:35:20,153 --> 00:35:23,056
<c.magenta>它专注于检查</c>

710
00:35:23,123 --> 00:35:24,658
<c.magenta>C语言中的不安全构造</c>

711
00:35:26,059 --> 00:35:28,529
<c.magenta>它兼容其它运行时工具</c>

712
00:35:28,595 --> 00:35:30,831
<c.magenta>能够在我们的所有设备和平台上运行</c>

713
00:35:31,331 --> 00:35:34,768
<c.magenta>如果你想要更详细地了解</c>

714
00:35:34,835 --> 00:35:38,772
<c.magenta>我强烈建议你们观看</c>

715
00:35:38,872 --> 00:35:42,209
<c.magenta>此演讲介绍如何理解未定义的行为</c>

716
00:35:42,543 --> 00:35:45,812
<c.magenta>介绍什么是未定义的行为</c>

717
00:35:46,613 --> 00:35:49,683
<c.magenta>它为什么存在 如何影响你的应用</c>

718
00:35:52,319 --> 00:35:53,787
<c.magenta>现在我们有些好消息告诉你们</c>

719
00:35:57,591 --> 00:35:59,092
<c.magenta>Undefined Behavior Sanitizer</c>

720
00:35:59,159 --> 00:36:02,563
<c.magenta>可以检查15种以上</c>

721
00:35:59,159 --> 00:36:02,563
<c.magenta>可以检查15种以上</c>

722
00:36:03,463 --> 00:36:07,334
<c.magenta>这将帮助提高生产力</c>

723
00:36:07,401 --> 00:36:08,836
<c.magenta>但是此演讲仅简单介绍</c>

724
00:36:08,902 --> 00:36:13,106
<c.magenta>Undefined Behavior Sanitizer</c>

725
00:36:13,173 --> 00:36:15,209
<c.magenta>我们重点关注三个问题</c>

726
00:36:15,342 --> 00:36:20,347
<c.magenta>整型溢出 对齐违规</c>

727
00:36:22,449 --> 00:36:24,017
<c.magenta>让我们先从整型溢出开始</c>

728
00:36:25,619 --> 00:36:29,122
<c.magenta>当算法表达式的结果值过大</c>

729
00:36:29,256 --> 00:36:32,226
<c.magenta>而无法放入变量时</c>

730
00:36:32,960 --> 00:36:36,496
<c.magenta>如果在索引表达式中发生这种漏洞</c>

731
00:36:36,763 --> 00:36:39,166
<c.magenta>比如 对缓冲进行索引</c>

732
00:36:39,399 --> 00:36:42,769
<c.magenta>或在用于计算缓冲区</c>

733
00:36:42,970 --> 00:36:46,874
<c.magenta>可能会造成严重的安全问题</c>

734
00:36:48,308 --> 00:36:51,979
<c.magenta>有时候整形溢出会造成意想不到的结果</c>

735
00:36:52,312 --> 00:36:54,915
<c.magenta>比如 你可能会</c>

736
00:36:54,982 --> 00:36:57,017
<c.magenta>进行大量的加法运算</c>

737
00:36:57,684 --> 00:36:59,019
<c.magenta>举例来说</c>

738
00:36:59,186 --> 00:37:01,555
<c.magenta>你有一个最大整数值 然后对它加1</c>

739
00:36:59,186 --> 00:37:01,555
<c.magenta>你有一个最大整数值 然后对它加1</c>

740
00:37:01,622 --> 00:37:04,725
<c.magenta>你可能会并不得到真正的结果</c>

741
00:37:04,791 --> 00:37:07,127
<c.magenta>这会让你感到困惑</c>

742
00:37:08,462 --> 00:37:12,432
<c.magenta>现在 并非所有类型的整型溢出</c>

743
00:37:12,499 --> 00:37:16,236
<c.magenta>事实上 一些类型的溢出</c>

744
00:37:16,303 --> 00:37:18,539
<c.magenta>比如无符号整型溢出</c>

745
00:37:19,473 --> 00:37:23,277
<c.magenta>但是 无符号整型溢出</c>

746
00:37:23,343 --> 00:37:26,480
<c.magenta>我们强烈建议你</c>

747
00:37:27,381 --> 00:37:29,449
<c.magenta>在本主题末尾部分</c>

748
00:37:31,285 --> 00:37:34,588
<c.magenta>让我们首先来看一个演示</c>

749
00:37:35,322 --> 00:37:38,258
<c.magenta>这里有一个函数</c>

750
00:37:38,325 --> 00:37:40,727
<c.magenta>我们可能经常编写这样的函数</c>

751
00:37:40,827 --> 00:37:41,895
<c.magenta>这是一个求平均值函数</c>

752
00:37:42,262 --> 00:37:45,432
<c.magenta>它接受一个数组和长度值</c>

753
00:37:45,832 --> 00:37:47,134
<c.magenta>设置累加器</c>

754
00:37:47,301 --> 00:37:50,704
<c.magenta>对数据组进行迭代</c>

755
00:37:50,971 --> 00:37:52,406
<c.magenta>得出平均值</c>

756
00:37:53,207 --> 00:37:54,908
<c.magenta>我们想进行测试</c>

757
00:37:54,975 --> 00:37:57,344
<c.magenta>以验证其行为是否正确</c>

758
00:37:58,111 --> 00:38:00,581
<c.magenta>让我们来看测试</c>

759
00:37:58,111 --> 00:38:00,581
<c.magenta>让我们来看测试</c>

760
00:38:01,381 --> 00:38:03,217
<c.magenta>TestNonNegativeAverage</c>

761
00:38:04,218 --> 00:38:05,219
<c.magenta>这个测试非常简单</c>

762
00:38:05,319 --> 00:38:08,222
<c.magenta>我们将会创建一个数组</c>

763
00:38:09,056 --> 00:38:13,527
<c.magenta>在数组中放入伪随机非负整数</c>

764
00:38:13,760 --> 00:38:16,363
<c.magenta>然后进行健全性检查</c>

765
00:38:16,697 --> 00:38:20,000
<c.magenta>我们检查所获取的平均值是否为非负数</c>

766
00:38:20,133 --> 00:38:22,102
<c.magenta>这里有一个断言</c>

767
00:38:24,104 --> 00:38:25,739
<c.magenta>让我们运行测试</c>

768
00:38:25,939 --> 00:38:27,975
<c.magenta>我们转到这里</c>

769
00:38:28,041 --> 00:38:30,477
<c.magenta>成功地进行生成</c>

770
00:38:31,578 --> 00:38:33,647
<c.magenta>我们并没有看到什么</c>

771
00:38:33,714 --> 00:38:36,216
<c.magenta>程序运行结束</c>

772
00:38:36,416 --> 00:38:37,451
<c.magenta>似乎一切顺利</c>

773
00:38:38,352 --> 00:38:41,221
<c.magenta>我们进行细小的改动</c>

774
00:38:41,321 --> 00:38:43,757
<c.magenta>将会向我们描述</c>

775
00:38:43,824 --> 00:38:46,093
<c.magenta>和整型溢出实际上非常微妙</c>

776
00:38:46,393 --> 00:38:47,828
<c.magenta>让我们改变数据长度</c>

777
00:38:48,061 --> 00:38:50,631
<c.magenta>从10,000变为10,001</c>

778
00:38:51,265 --> 00:38:53,700
<c.magenta>保存 然后返回</c>

779
00:38:54,935 --> 00:38:56,069
<c.magenta>运行程序</c>

780
00:38:59,506 --> 00:39:02,476
<c.magenta>断言失败</c>

781
00:38:59,506 --> 00:39:02,476
<c.magenta>断言失败</c>

782
00:39:02,876 --> 00:39:03,911
<c.magenta>这让人感到困惑</c>

783
00:39:03,977 --> 00:39:06,446
<c.magenta>你知道</c>

784
00:39:06,813 --> 00:39:10,017
<c.magenta>我编写的函数也很简单</c>

785
00:39:10,083 --> 00:39:11,652
<c.magenta>只是累加这些整数</c>

786
00:39:11,785 --> 00:39:14,021
<c.magenta>但是突然之间发生这种错误</c>

787
00:39:14,087 --> 00:39:16,290
<c.magenta>导致测试未能通过</c>

788
00:39:17,424 --> 00:39:20,694
<c.magenta>在这些情况下可以使用</c>

789
00:39:20,761 --> 00:39:22,930
<c.magenta>弄清楚真正的问题是什么</c>

790
00:39:23,430 --> 00:39:25,566
<c.magenta>因此我启用这个工具</c>

791
00:39:25,666 --> 00:39:29,536
<c.magenta>我进入Scheme Editor</c>

792
00:39:30,938 --> 00:39:32,272
<c.magenta>选中这个复选框</c>

793
00:39:33,407 --> 00:39:34,308
<c.magenta>然后继续</c>

794
00:39:35,209 --> 00:39:37,477
<c.magenta>再次点击“Run” 重新生成</c>

795
00:39:37,544 --> 00:39:39,746
<c.magenta>这时Undefined Behavior Sanitizer</c>

796
00:39:41,081 --> 00:39:41,915
<c.magenta>我们看这里</c>

797
00:39:42,583 --> 00:39:46,019
<c.magenta>Undefined Behavior Sanitizer</c>

798
00:39:46,086 --> 00:39:48,856
<c.magenta>准确的问题原因</c>

799
00:39:48,989 --> 00:39:51,191
<c.magenta>非常直观地告诉我们</c>

800
00:39:51,325 --> 00:39:53,327
<c.magenta>问题是</c>

801
00:39:53,560 --> 00:39:54,962
<c.magenta>无符号整型溢出</c>

802
00:39:55,128 --> 00:39:57,464
<c.magenta>为我们显示发生溢出的值</c>

803
00:39:57,598 --> 00:39:59,766
<c.magenta>可以看到 数据非常大</c>

804
00:39:59,833 --> 00:40:02,736
<c.magenta>这两个值或它们之和</c>

805
00:39:59,833 --> 00:40:02,736
<c.magenta>这两个值或它们之和</c>

806
00:40:02,803 --> 00:40:04,638
<c.magenta>无法放入32位整数</c>

807
00:40:04,705 --> 00:40:08,675
<c.magenta>其结果是我们获得的</c>

808
00:40:09,443 --> 00:40:11,011
<c.magenta>任何无效结果</c>

809
00:40:11,078 --> 00:40:13,947
<c.magenta>使用其完整表示</c>

810
00:40:15,182 --> 00:40:18,519
<c.magenta>可以通过多种方法解决这个问题</c>

811
00:40:18,752 --> 00:40:21,088
<c.magenta>我建议的两个方法是</c>

812
00:40:21,154 --> 00:40:23,757
<c.magenta>使用不同的算法来计算平均值</c>

813
00:40:24,157 --> 00:40:26,627
<c.magenta>或者在平均值函数中设置约束</c>

814
00:40:26,693 --> 00:40:29,963
<c.magenta>从而避免这个问题</c>

815
00:40:31,665 --> 00:40:36,003
<c.magenta>然后 让我们返回幻灯片</c>

816
00:40:36,403 --> 00:40:39,239
<c.magenta>希望你们发现</c>

817
00:40:39,306 --> 00:40:44,311
<c.magenta>能够让你轻松地发现这些</c>

818
00:40:44,378 --> 00:40:46,213
<c.magenta>导致运行时错误的微妙问题</c>

819
00:40:47,681 --> 00:40:48,515
<c.magenta>好的</c>

820
00:40:50,117 --> 00:40:53,420
<c.magenta>让我们来看</c>

821
00:40:53,820 --> 00:40:55,122
<c.magenta>第二种类型的问题</c>

822
00:40:55,189 --> 00:40:57,758
<c.magenta>它们是内存对齐违规问题</c>

823
00:40:58,892 --> 00:41:01,828
<c.magenta>C语言中的所有类型都有大小</c>

824
00:40:58,892 --> 00:41:01,828
<c.magenta>C语言中的所有类型都有大小</c>

825
00:41:01,962 --> 00:41:04,198
<c.magenta>而且要求进行内存对齐</c>

826
00:41:05,666 --> 00:41:08,402
<c.magenta>如果未对齐地加载或存储到内存块</c>

827
00:41:08,468 --> 00:41:12,840
<c.magenta>程序将发生内存对齐违规</c>

828
00:41:14,041 --> 00:41:18,378
<c.magenta>这是非常难以发现的细微漏洞</c>

829
00:41:18,512 --> 00:41:21,715
<c.magenta>在日常开发工作中</c>

830
00:41:21,782 --> 00:41:24,985
<c.magenta>你可能不会发现这样的问题</c>

831
00:41:25,085 --> 00:41:27,721
<c.magenta>假设你们大多数在Xcode中</c>

832
00:41:27,788 --> 00:41:30,457
<c.magenta>开发应用和框架</c>

833
00:41:30,991 --> 00:41:33,060
<c.magenta>当你最终进行应用分发时</c>

834
00:41:33,393 --> 00:41:35,462
<c.magenta>将需要进行发行配置</c>

835
00:41:35,963 --> 00:41:36,964
<c.magenta>问题在于</c>

836
00:41:37,097 --> 00:41:39,299
<c.magenta>因为编辑器期望</c>

837
00:41:39,366 --> 00:41:42,569
<c.magenta>不发生对齐违规问题</c>

838
00:41:43,203 --> 00:41:46,573
<c.magenta>优化器通常会优化你的代码</c>

839
00:41:46,707 --> 00:41:50,844
<c.magenta>当启用这些优化时</c>

840
00:41:50,911 --> 00:41:52,613
<c.magenta>在运行时崩溃</c>

841
00:41:54,047 --> 00:41:57,117
<c.magenta>Undefined Behavior Sanitizer</c>

842
00:41:57,251 --> 00:41:59,753
<c.magenta>甚至提前在调试配置中</c>

843
00:41:59,820 --> 00:42:00,787
<c.magenta>这样 就不会造成</c>

844
00:41:59,820 --> 00:42:00,787
<c.magenta>这样 就不会造成</c>

845
00:42:00,888 --> 00:42:03,257
<c.magenta>在以后出现难以调试的错误</c>

846
00:42:04,424 --> 00:42:07,294
<c.magenta>在持续性存储中</c>

847
00:42:07,361 --> 00:42:10,163
<c.magenta>进行数据串行化或反串行化的代码</c>

848
00:42:10,230 --> 00:42:11,632
<c.magenta>发生这种类型的错误</c>

849
00:42:12,199 --> 00:42:16,303
<c.magenta>让我们来认真看一个例子</c>

850
00:42:19,039 --> 00:42:21,041
<c.magenta>在本例中</c>

851
00:42:21,141 --> 00:42:24,311
<c.magenta>我想编写一个自定义网络协议</c>

852
00:42:24,378 --> 00:42:26,079
<c.magenta>将它用于我正在开发的聊天程序</c>

853
00:42:27,214 --> 00:42:30,551
<c.magenta>此网络协议的一个基本功能是</c>

854
00:42:30,717 --> 00:42:33,053
<c.magenta>定义一个数据包结构</c>

855
00:42:34,221 --> 00:42:36,356
<c.magenta>此数据包结构包含三个部分</c>

856
00:42:36,857 --> 00:42:40,027
<c.magenta>一个magic字段 表示所使用的协议</c>

857
00:42:41,295 --> 00:42:43,697
<c.magenta>一个payloadLength字段</c>

858
00:42:43,764 --> 00:42:46,133
<c.magenta>说明数据包内的消息长度</c>

859
00:42:46,567 --> 00:42:48,235
<c.magenta>最后是payload本身</c>

860
00:42:48,902 --> 00:42:50,671
<c.magenta>从本例的目的来说</c>

861
00:42:50,737 --> 00:42:53,740
<c.magenta>我假设int是一个四字节整数</c>

862
00:42:54,141 --> 00:42:55,909
<c.magenta>现在 我们需要专注于</c>

863
00:42:56,944 --> 00:42:58,912
<c.magenta>两个方面</c>

864
00:42:58,979 --> 00:43:02,416
<c.magenta>以确保自定义网络协议工作正常</c>

865
00:42:58,979 --> 00:43:02,416
<c.magenta>以确保自定义网络协议工作正常</c>

866
00:43:02,616 --> 00:43:04,284
<c.magenta>它们是发送器和接收器</c>

867
00:43:04,551 --> 00:43:06,520
<c.magenta>我们先来看接收器</c>

868
00:43:07,154 --> 00:43:09,323
<c.magenta>接收器有一个网络缓冲区</c>

869
00:43:09,423 --> 00:43:11,992
<c.magenta>它在这个缓冲区内组装其数据包</c>

870
00:43:12,726 --> 00:43:13,727
<c.magenta>准备好这些数据包</c>

871
00:43:13,827 --> 00:43:14,962
<c.magenta>使数据负载准备就绪</c>

872
00:43:15,295 --> 00:43:18,498
<c.magenta>然后通过网络发送</c>

873
00:43:19,233 --> 00:43:22,169
<c.magenta>从演示的角度来说</c>

874
00:43:22,436 --> 00:43:25,272
<c.magenta>我已经将网络缓冲区的内存</c>

875
00:43:25,339 --> 00:43:28,342
<c.magenta>分割成为多个四字节块</c>

876
00:43:29,877 --> 00:43:32,479
<c.magenta>现在我已很想念库巴</c>

877
00:43:32,613 --> 00:43:35,516
<c.magenta>可是他早就下台了</c>

878
00:43:36,650 --> 00:43:40,020
<c.magenta>我想发送给库巴的第一条信息是</c>

879
00:43:40,754 --> 00:43:44,024
<c.magenta>为此 我首先使用一个magic值</c>

880
00:43:46,426 --> 00:43:49,429
<c.magenta>然后指定消息的长度</c>

881
00:43:49,496 --> 00:43:50,831
<c.magenta>里面共有9个字符</c>

882
00:43:51,798 --> 00:43:52,633
<c.magenta>让我们开始</c>

883
00:43:54,234 --> 00:43:59,139
<c.magenta>最后我指定消息内容</c>

884
00:44:00,774 --> 00:44:03,610
<c.magenta>现在我们来看接收器的功能</c>

885
00:44:05,279 --> 00:44:08,949
<c.magenta>它接收一个指向</c>

886
00:44:09,383 --> 00:44:12,386
<c.magenta>然后将这个指针转换成为</c>

887
00:44:14,121 --> 00:44:17,457
<c.magenta>然后查找数据包内部</c>

888
00:44:18,125 --> 00:44:19,660
<c.magenta>找到magic字段的值</c>

889
00:44:19,726 --> 00:44:22,930
<c.magenta>确保它是正确的值</c>

890
00:44:23,330 --> 00:44:25,132
<c.magenta>然后查看数据负载</c>

891
00:44:26,567 --> 00:44:29,369
<c.magenta>这是第一个数据包</c>

892
00:44:30,270 --> 00:44:31,138
<c.magenta>让我们来看第二条消息</c>

893
00:44:32,840 --> 00:44:35,509
<c.magenta>第二条消息的内容是</c>

894
00:44:36,043 --> 00:44:37,411
<c.magenta>我们进行同样的操作</c>

895
00:44:39,079 --> 00:44:41,582
<c.magenta>找到magic字段值</c>

896
00:44:43,050 --> 00:44:45,919
<c.magenta>放入消息长度 15个字符</c>

897
00:44:46,520 --> 00:44:47,988
<c.magenta>然后是消息本身</c>

898
00:44:49,289 --> 00:44:51,592
<c.magenta>然后转到接收器端</c>

899
00:44:51,859 --> 00:44:54,261
<c.magenta>我们可以看到问题清单</c>

900
00:44:55,229 --> 00:44:59,800
<c.magenta>查看网络字节流中的索引17</c>

901
00:45:00,534 --> 00:45:03,937
<c.magenta>当我们查找</c>

902
00:45:04,004 --> 00:45:05,606
<c.magenta>数据包内的magic值时</c>

903
00:45:06,406 --> 00:45:08,475
<c.magenta>发生内存对齐违规</c>

904
00:45:10,644 --> 00:45:12,145
<c.magenta>这里可以看到</c>

905
00:45:12,412 --> 00:45:14,848
<c.magenta>第二个数据包的magic字段</c>

906
00:45:14,982 --> 00:45:17,150
<c.magenta>没有对齐为四字节边界</c>

907
00:45:17,451 --> 00:45:20,621
<c.magenta>因此在网络字节流中</c>

908
00:45:20,687 --> 00:45:21,989
<c.magenta>会造成内存对齐违规</c>

909
00:45:22,289 --> 00:45:24,525
<c.magenta>Undefined Behavior Sanitizer</c>

910
00:45:24,625 --> 00:45:26,560
<c.magenta>可以非常准确地诊断出这个问题</c>

911
00:45:30,697 --> 00:45:31,732
<c.magenta>如何解决这个问题呢？</c>

912
00:45:31,965 --> 00:45:33,867
<c.magenta>接下我们会讨论两种方法</c>

913
00:45:34,401 --> 00:45:36,870
<c.magenta>第一种方法是</c>

914
00:45:36,937 --> 00:45:39,206
<c.magenta>在网络数据包结构定义</c>

915
00:45:39,273 --> 00:45:41,808
<c.magenta>使用packed属性</c>

916
00:45:42,709 --> 00:45:44,411
<c.magenta>让我们来看这是如何工作的</c>

917
00:45:45,946 --> 00:45:47,181
<c.magenta>你添加packed属性</c>

918
00:45:47,247 --> 00:45:49,683
<c.magenta>这会更改所有结构内的</c>

919
00:45:49,750 --> 00:45:50,851
<c.magenta>所有字段对齐</c>

920
00:45:51,151 --> 00:45:53,987
<c.magenta>这是你所能够获得的</c>

921
00:45:54,621 --> 00:45:57,124
<c.magenta>最低可能性对齐</c>

922
00:45:57,391 --> 00:46:01,361
<c.magenta>这意味着该字段的任何后续加载或存储</c>

923
00:45:57,391 --> 00:46:01,361
<c.magenta>这意味着该字段的任何后续加载或存储</c>

924
00:46:01,428 --> 00:46:02,863
<c.magenta>始终会对齐</c>

925
00:46:03,597 --> 00:46:06,633
<c.magenta>你可能会想</c>

926
00:46:06,733 --> 00:46:08,669
<c.magenta>我想对所有项目使用packed属性</c>

927
00:46:09,169 --> 00:46:10,737
<c.magenta>但是你应该注意</c>

928
00:46:11,071 --> 00:46:12,673
<c.magenta>使用packed属性</c>

929
00:46:12,739 --> 00:46:15,042
<c.magenta>将会更改结构的布局</c>

930
00:46:16,143 --> 00:46:17,978
<c.magenta>很多情况下 它会消除</c>

931
00:46:18,045 --> 00:46:19,780
<c.magenta>编译器自动插入到</c>

932
00:46:19,847 --> 00:46:20,948
<c.magenta>数据结构中的填充</c>

933
00:46:21,615 --> 00:46:24,618
<c.magenta>这可能会降低应用性能</c>

934
00:46:25,452 --> 00:46:28,956
<c.magenta>如果你发现</c>

935
00:46:29,022 --> 00:46:31,158
<c.magenta>packed属性并不适合你的处理</c>

936
00:46:31,358 --> 00:46:32,559
<c.magenta>还有另外一种方法</c>

937
00:46:34,828 --> 00:46:37,497
<c.magenta>你可以使用memcpy函数</c>

938
00:46:37,998 --> 00:46:42,002
<c.magenta>将网络字节流</c>

939
00:46:42,069 --> 00:46:44,137
<c.magenta>或者已经去串行化的数据块</c>

940
00:46:44,872 --> 00:46:47,574
<c.magenta>复制到对齐变量之中</c>

941
00:46:47,641 --> 00:46:49,409
<c.magenta>对齐变量可能位于堆栈或堆之中</c>

942
00:46:50,210 --> 00:46:54,081
<c.magenta>memcpy是安全的</c>

943
00:46:54,147 --> 00:46:59,086
<c.magenta>使访问速度与未对齐访问一样快速</c>

944
00:46:59,419 --> 00:47:01,288
<c.magenta>这是原始未对齐访问所无法企及的</c>

945
00:46:59,419 --> 00:47:01,288
<c.magenta>这是原始未对齐访问所无法企及的</c>

946
00:47:04,057 --> 00:47:07,461
<c.magenta>这就是Undefined Behavior Sanitizer</c>

947
00:47:09,363 --> 00:47:12,332
<c.magenta>让我们来看第三种类型的漏洞</c>

948
00:47:13,333 --> 00:47:15,369
<c.magenta>即nonnull返回值违规</c>

949
00:47:17,371 --> 00:47:20,174
<c.magenta>当函数的返回值</c>

950
00:47:20,240 --> 00:47:23,610
<c.magenta>使用nonnull属性注解时</c>

951
00:47:24,611 --> 00:47:25,812
<c.magenta>将发生这种问题</c>

952
00:47:26,880 --> 00:47:29,016
<c.magenta>但是 函数破坏</c>

953
00:47:29,750 --> 00:47:33,620
<c.magenta>注解所使用的协定</c>

954
00:47:33,754 --> 00:47:35,989
<c.magenta>并且返回nil值</c>

955
00:47:36,657 --> 00:47:40,360
<c.magenta>如果使用Objective-C API</c>

956
00:47:40,460 --> 00:47:43,263
<c.magenta>因为这违反</c>

957
00:47:44,031 --> 00:47:44,865
<c.magenta>返回值注解规则</c>

958
00:47:45,566 --> 00:47:47,467
<c.magenta>这还会导致其他问题</c>

959
00:47:47,534 --> 00:47:49,303
<c.magenta>如果你使用的</c>

960
00:47:49,436 --> 00:47:52,539
<c.magenta>更严格地依赖于</c>

961
00:47:54,441 --> 00:47:55,275
<c.magenta>空属性关联纠错</c>

962
00:47:56,577 --> 00:47:58,812
<c.magenta>因此我们强烈建议你进行这种检查</c>

963
00:47:58,879 --> 00:48:01,748
<c.magenta>如果你的应用</c>

964
00:47:58,879 --> 00:48:01,748
<c.magenta>如果你的应用</c>

965
00:48:03,283 --> 00:48:06,553
<c.magenta>让我们来看一个</c>

966
00:48:07,588 --> 00:48:09,156
<c.magenta>nonnull返回值违规例子</c>

967
00:48:10,490 --> 00:48:14,228
<c.magenta>在本例中</c>

968
00:48:14,461 --> 00:48:16,396
<c.magenta>我有一个太阳系模型</c>

969
00:48:17,598 --> 00:48:19,867
<c.magenta>首先我想要做的是</c>

970
00:48:19,933 --> 00:48:21,969
<c.magenta>建模太阳系中的卫星</c>

971
00:48:22,035 --> 00:48:23,203
<c.magenta>我们开始</c>

972
00:48:23,337 --> 00:48:24,671
<c.magenta>这是行星地球</c>

973
00:48:24,805 --> 00:48:28,308
<c.magenta>地球的最大卫星是月亮</c>

974
00:48:28,542 --> 00:48:31,879
<c.magenta>然后还有火星</c>

975
00:48:31,945 --> 00:48:34,348
<c.magenta>对这个列表进行降序排序</c>

976
00:48:34,615 --> 00:48:36,350
<c.magenta>火卫一是火星的最大卫星</c>

977
00:48:36,416 --> 00:48:37,651
<c.magenta>火卫二是第二大卫星</c>

978
00:48:37,718 --> 00:48:40,254
<c.magenta>很好</c>

979
00:48:41,321 --> 00:48:43,724
<c.magenta>看起来这里的一个输入</c>

980
00:48:43,790 --> 00:48:45,559
<c.magenta>是错误的</c>

981
00:48:47,027 --> 00:48:48,695
<c.magenta>这让人尴尬</c>

982
00:48:49,596 --> 00:48:50,531
<c.magenta>最好删除它</c>

983
00:48:50,964 --> 00:48:52,432
<c.magenta>这样好多了</c>

984
00:48:52,766 --> 00:48:56,603
<c.magenta>我删除例中的遗留代码</c>

985
00:48:57,437 --> 00:48:59,339
<c.magenta>现在列表看上去正确了</c>

986
00:49:00,541 --> 00:49:01,808
<c.magenta>让我们继续</c>

987
00:49:02,009 --> 00:49:03,143
<c.magenta>好的</c>

988
00:49:04,578 --> 00:49:07,314
<c.magenta>我想做的事情是</c>

989
00:49:07,447 --> 00:49:09,850
<c.magenta>获得一个列表</c>

990
00:49:09,917 --> 00:49:11,518
<c.magenta>列出太阳系所有行星的最大卫星</c>

991
00:49:12,553 --> 00:49:16,890
<c.magenta>我要做的事情是</c>

992
00:49:17,691 --> 00:49:21,628
<c.magenta>然后添加每个行星的最大卫星</c>

993
00:49:22,296 --> 00:49:24,298
<c.magenta>这里的问题是</c>

994
00:49:24,364 --> 00:49:26,033
<c.magenta>我已经查询木星的最大卫星</c>

995
00:49:26,366 --> 00:49:29,469
<c.magenta>但是我创建的NS词典中没有这个条目</c>

996
00:49:29,703 --> 00:49:30,637
<c.magenta>因此我获取返回值nil</c>

997
00:49:31,872 --> 00:49:35,209
<c.magenta>Undefined Behavior Sanitizer</c>

998
00:49:37,611 --> 00:49:41,114
<c.magenta>让我们来看</c>

999
00:49:41,181 --> 00:49:43,450
<c.magenta>Undefined Behavior Sanitizer</c>

1000
00:49:43,617 --> 00:49:44,952
<c.magenta>并了解它的运行原理</c>

1001
00:49:45,853 --> 00:49:47,421
<c.magenta>我将为你们展示</c>

1002
00:49:47,721 --> 00:49:51,191
<c.magenta>如何启用这些检查功能</c>

1003
00:49:51,959 --> 00:49:53,727
<c.magenta>这是一个项目生成设置编辑器</c>

1004
00:49:54,294 --> 00:49:57,998
<c.magenta>在这里 可以启用</c>

1005
00:49:58,198 --> 00:50:01,268
<c.magenta>和空属性注解检查功能</c>

1006
00:49:58,198 --> 00:50:01,268
<c.magenta>和空属性注解检查功能</c>

1007
00:50:02,769 --> 00:50:05,839
<c.magenta>这是Undefined Behavior Sanitizer</c>

1008
00:50:16,650 --> 00:50:19,720
<c.magenta>我们已经了解Xcode中</c>

1009
00:50:19,887 --> 00:50:21,188
<c.magenta>一些是新工具 一些经过改进</c>

1010
00:50:21,321 --> 00:50:23,223
<c.magenta>让我们回过头来</c>

1011
00:50:23,757 --> 00:50:25,659
<c.magenta>思考软件质量本身</c>

1012
00:50:25,893 --> 00:50:28,562
<c.magenta>如何有效地使用这些工具？</c>

1013
00:50:31,465 --> 00:50:32,633
<c.magenta>这需要从两个方面着手</c>

1014
00:50:33,500 --> 00:50:36,837
<c.magenta>你需要更多地练习</c>

1015
00:50:37,437 --> 00:50:39,106
<c.magenta>另外应该综合性地使用这些工具</c>

1016
00:50:40,073 --> 00:50:40,908
<c.magenta>让我们来了解</c>

1017
00:50:42,776 --> 00:50:44,344
<c.magenta>（代码检查练习）</c>

1018
00:50:44,411 --> 00:50:48,081
<c.magenta>当你运行含有漏洞的代码时</c>

1019
00:50:48,215 --> 00:50:50,951
<c.magenta>运行时工具帮助你发现这些漏洞</c>

1020
00:50:51,285 --> 00:50:52,686
<c.magenta>也许[听不清]</c>

1021
00:50:52,753 --> 00:50:57,858
<c.magenta>但是你必须运行含有漏洞的代码行</c>

1022
00:50:57,925 --> 00:50:59,893
<c.magenta>才能获得</c>

1023
00:50:59,960 --> 00:51:02,262
<c.magenta>有价值的漏洞诊断信息</c>

1024
00:50:59,960 --> 00:51:02,262
<c.magenta>有价值的漏洞诊断信息</c>

1025
00:51:02,462 --> 00:51:03,497
<c.magenta>因此</c>

1026
00:51:04,097 --> 00:51:06,133
<c.magenta>为了使用更多的代码进行练习</c>

1027
00:51:06,200 --> 00:51:08,168
<c.magenta>发现尽可能多的问题</c>

1028
00:51:09,203 --> 00:51:12,673
<c.magenta>我们建议你</c>

1029
00:51:13,574 --> 00:51:15,475
<c.magenta>我们建议你</c>

1030
00:51:15,542 --> 00:51:18,145
<c.magenta>启用一次这些工具</c>

1031
00:51:18,212 --> 00:51:19,980
<c.magenta>以避免传播漏洞</c>

1032
00:51:20,047 --> 00:51:22,749
<c.magenta>和可能的安全漏洞</c>

1033
00:51:25,385 --> 00:51:27,054
<c.magenta>使用持续性集成</c>

1034
00:51:27,254 --> 00:51:29,923
<c.magenta>让使用运行时工具变得更简单</c>

1035
00:51:30,390 --> 00:51:32,893
<c.magenta>而且 在启用这些工具之后</c>

1036
00:51:32,993 --> 00:51:34,261
<c.magenta>代码检查工作</c>

1037
00:51:34,328 --> 00:51:35,863
<c.magenta>变得更加容易</c>

1038
00:51:36,997 --> 00:51:38,699
<c.magenta>可以确保</c>

1039
00:51:38,866 --> 00:51:41,435
<c.magenta>在检查代码时</c>

1040
00:51:41,502 --> 00:51:42,803
<c.magenta>尽快地发现程序中的漏洞</c>

1041
00:51:43,904 --> 00:51:46,773
<c.magenta>帮助你跟踪程序中的代码检查情况</c>

1042
00:51:46,840 --> 00:51:49,710
<c.magenta>让你能够了解</c>

1043
00:51:49,943 --> 00:51:52,145
<c.magenta>对多少代码进行了检查</c>

1044
00:51:53,413 --> 00:51:55,782
<c.magenta>如果你想要了解</c>

1045
00:51:55,849 --> 00:51:57,651
<c.magenta>和代码检查工作原理</c>

1046
00:51:57,851 --> 00:52:01,922
<c.magenta>建议你们观看</c>

1047
00:51:57,851 --> 00:52:01,922
<c.magenta>建议你们观看</c>

1048
00:52:05,826 --> 00:52:08,395
<c.magenta>确保有效地使用运行时工具的</c>

1049
00:52:08,462 --> 00:52:09,963
<c.magenta>综合性地使用这些工具</c>

1050
00:52:10,497 --> 00:52:13,667
<c.magenta>启用的工具越多</c>

1051
00:52:14,935 --> 00:52:15,769
<c.magenta>有一个例外</c>

1052
00:52:15,836 --> 00:52:18,238
<c.magenta>Address Sanitizer</c>

1053
00:52:18,305 --> 00:52:19,706
<c.magenta>互相不兼容</c>

1054
00:52:19,806 --> 00:52:21,675
<c.magenta>不能同时启用这两个工具</c>

1055
00:52:21,742 --> 00:52:23,477
<c.magenta>但是可以同时启用其它工具</c>

1056
00:52:24,478 --> 00:52:27,848
<c.magenta>前面我们讲过</c>

1057
00:52:27,915 --> 00:52:30,817
<c.magenta>点击“诊断”选项卡</c>

1058
00:52:30,884 --> 00:52:32,519
<c.magenta>可以启用所有这些工具</c>

1059
00:52:33,887 --> 00:52:37,124
<c.magenta>你可能会想</c>

1060
00:52:38,725 --> 00:52:39,993
<c.magenta>实际上并不是这样的</c>

1061
00:52:40,861 --> 00:52:43,096
<c.magenta>至少我的经验告诉我不是这样的</c>

1062
00:52:43,197 --> 00:52:46,300
<c.magenta>关于这些工具的执行和内存开销</c>

1063
00:52:46,366 --> 00:52:48,068
<c.magenta>我们有一些数据</c>

1064
00:52:48,802 --> 00:52:51,839
<c.magenta>我发现</c>

1065
00:52:51,972 --> 00:52:55,275
<c.magenta>在调试整个Xcode程序时</c>

1066
00:52:55,342 --> 00:52:57,377
<c.magenta>我可以同时启用多个运行时工具</c>

1067
00:52:57,644 --> 00:52:59,246
<c.magenta>UI依然反应灵敏</c>

1068
00:53:00,214 --> 00:53:03,116
<c.magenta>希望这些信息能够帮助你更好地决定</c>

1069
00:53:03,183 --> 00:53:04,585
<c.magenta>应该在你的本地设置及持续性集成中</c>

1070
00:53:04,718 --> 00:53:07,321
<c.magenta>启用哪些工具</c>

1071
00:53:07,988 --> 00:53:10,691
<c.magenta>我希望你认识到</c>

1072
00:53:10,757 --> 00:53:13,794
<c.magenta>所有这些工具都非常有价值</c>

1073
00:53:13,961 --> 00:53:16,563
<c.magenta>它们为你发现不同的漏洞</c>

1074
00:53:16,830 --> 00:53:20,000
<c.magenta>必要时应该启用它们</c>

1075
00:53:23,237 --> 00:53:24,371
<c.magenta>让我们进行总结</c>

1076
00:53:24,605 --> 00:53:27,608
<c.magenta>Xcode 9增加新工具</c>

1077
00:53:27,674 --> 00:53:29,710
<c.magenta>帮助你在应用和程序中</c>

1078
00:53:30,377 --> 00:53:32,045
<c.magenta>发现更多的严重漏洞</c>

1079
00:53:33,213 --> 00:53:35,449
<c.magenta>我真心希望</c>

1080
00:53:35,749 --> 00:53:38,685
<c.magenta>以节省调试时间</c>

1081
00:53:38,852 --> 00:53:41,922
<c.magenta>希望你们使用这些工具</c>

1082
00:53:42,322 --> 00:53:44,391
<c.magenta>如果你需要本演讲的更多信息</c>

1083
00:53:44,625 --> 00:53:47,694
<c.magenta>请访问我们的网站</c>

1084
00:53:48,529 --> 00:53:50,364
<c.magenta>另外 一些相关的演讲</c>

1085
00:53:50,564 --> 00:53:53,634
<c.magenta>它们是“Swift新特性”和</c>

1086
00:53:53,934 --> 00:53:55,769
<c.magenta>另外还有GCD演讲</c>

1087
00:53:57,538 --> 00:54:00,707
<c.magenta>以及“LLVM新特性”演讲</c>

1088
00:53:57,538 --> 00:54:00,707
<c.magenta>以及“LLVM新特性”演讲</c>

1089
00:54:00,774 --> 00:54:04,011
<c.magenta>可以帮助你们了解</c>

1090
00:54:05,479 --> 00:54:07,014
<c.magenta>底层Sanitizer技术</c>

1091
00:54:08,248 --> 00:54:10,651
<c.magenta>感谢你们参加本演讲</c>

1092
00:54:10,918 --> 00:54:12,653
<c.magenta>希望你们有所收获</c>
