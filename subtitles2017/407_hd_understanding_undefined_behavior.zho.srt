1
00:00:08,516 --> 00:00:16,500
[背景杂音]

2
00:00:24,056 --> 00:00:24,606
&gt;&gt; 早上好

3
00:00:26,576 --> 00:00:28,376
欢迎来到主题为

4
00:00:28,376 --> 00:00:30,936
理解未定义行为讲解的会议

5
00:00:31,286 --> 00:00:33,076
我知道大家都已经

6
00:00:33,076 --> 00:00:34,886
在调试 Bug 上花费了无数时间

7
00:00:34,886 --> 00:00:36,466
但当你从发布模式

8
00:00:36,466 --> 00:00:38,036
切换到调试模式时

9
00:00:38,036 --> 00:00:38,756
这些 Bug 可能就消失了

10
00:00:39,296 --> 00:00:40,946
你甚至还会因为

11
00:00:41,306 --> 00:00:42,566
无法重现只出现在

12
00:00:42,566 --> 00:00:43,916
用户设备上的 Bug

13
00:00:43,916 --> 00:00:44,616
而丢失用户

14
00:00:45,366 --> 00:00:46,786
这些问题反映出

15
00:00:46,786 --> 00:00:48,246
在你的代码中

16
00:00:48,246 --> 00:00:48,500
可能存在未定义行为

17
00:00:49,956 --> 00:00:51,676
我是 Fred

18
00:00:51,676 --> 00:00:53,626
在客户编译器团队工作

19
00:00:53,626 --> 00:00:55,266
今天首先为大家讲解一下

20
00:00:55,266 --> 00:00:57,176
什么是未定义行为

21
00:00:57,176 --> 00:00:57,846
及其存在的原因

22
00:00:58,586 --> 00:00:59,526
然后我们会深入探讨

23
00:00:59,526 --> 00:01:01,026
编译器并看看它是如何

24
00:00:59,526 --> 00:01:01,026
编译器并看看它是如何

25
00:01:01,026 --> 00:01:02,636
与那些导致细微 Bug

26
00:01:02,636 --> 00:01:04,215
的为定义行为

27
00:01:04,215 --> 00:01:04,726
相互作用的

28
00:01:05,596 --> 00:01:08,496
这些 Bug 不仅可能会

29
00:01:08,496 --> 00:01:09,936
浪费你很多的调试时间

30
00:01:10,446 --> 00:01:11,456
还可能会有一些

31
00:01:11,456 --> 00:01:12,166
安全隐患

32
00:01:12,756 --> 00:01:14,596
来自安全团队的 Ryan

33
00:01:14,896 --> 00:01:16,156
将为您讲解更多这方面的内容

34
00:01:16,346 --> 00:01:18,656
并教您如何使用我们的工具

35
00:01:18,656 --> 00:01:19,666
避免这些问题

36
00:01:20,896 --> 00:01:22,506
最后 我的同事 Anna

37
00:01:22,506 --> 00:01:23,856
会上台讲解

38
00:01:23,856 --> 00:01:25,366
Swift 如何解决

39
00:01:25,366 --> 00:01:25,806
这些问题

40
00:01:27,616 --> 00:01:30,336
那么 什么是未定义行为呢 

41
00:01:32,076 --> 00:01:34,846
当你的代码语法正确

42
00:01:34,846 --> 00:01:36,856
但其行为

43
00:01:36,856 --> 00:01:39,376
却超出了语言允许范围时

44
00:01:39,496 --> 00:01:43,286
未定义行为就会

45
00:01:43,866 --> 00:01:44,046
出现

46
00:01:45,336 --> 00:01:48,106
C 语言和 C++ 语言

47
00:01:48,106 --> 00:01:49,926
在标准上

48
00:01:49,926 --> 00:01:52,166
对未定义行为

49
00:01:52,166 --> 00:01:52,616
有着非常相似的定义

50
00:01:53,106 --> 00:01:54,006
让我们看看

51
00:01:54,006 --> 00:01:55,216
C++ 语言标准是怎么定义的

52
00:01:57,396 --> 00:02:00,126
未定义行为是指

53
00:01:57,396 --> 00:02:00,126
未定义行为是指

54
00:02:00,126 --> 00:02:01,496
此国际标准

55
00:02:01,496 --> 00:02:03,216
没有规定的

56
00:02:03,216 --> 00:02:04,006
行为

57
00:02:04,926 --> 00:02:06,556
这个解释不太有用 是吧

58
00:02:07,286 --> 00:02:11,436
但其实后面还跟着

59
00:02:11,546 --> 00:02:12,846
一个注解和更多细节

60
00:02:12,876 --> 00:02:14,066
但实在太长 就没有放在屏幕上

61
00:02:14,336 --> 00:02:15,176
这里是一个总结

62
00:02:17,706 --> 00:02:18,986
那么 编译器能够做什么呢

63
00:02:19,266 --> 00:02:20,606
如果你参加会议前就知道

64
00:02:20,606 --> 00:02:22,176
未定义行为

65
00:02:22,176 --> 00:02:23,996
那么你也许听说过

66
00:02:23,996 --> 00:02:25,146
如果遇到了未定义

67
00:02:25,146 --> 00:02:26,986
行为 编译器就会

68
00:02:26,986 --> 00:02:28,276
被允许抹掉你的磁盘

69
00:02:29,066 --> 00:02:30,676
我保证这种问题

70
00:02:30,676 --> 00:02:31,046
不会出现

71
00:02:31,916 --> 00:02:32,726
那我能做什么呢

72
00:02:33,766 --> 00:02:35,116
编译器可以选择

73
00:02:35,116 --> 00:02:37,286
给出警告或提示错误

74
00:02:37,286 --> 00:02:38,526
来诊断问题

75
00:02:39,186 --> 00:02:41,076
这是目前为止我们

76
00:02:41,076 --> 00:02:42,516
最倾向于使用的解决方式

77
00:02:42,516 --> 00:02:43,976
它对开发人员来说非常可行

78
00:02:43,976 --> 00:02:44,826
可以避免问题

79
00:02:44,826 --> 00:02:45,296
并规避问题来源

80
00:02:45,606 --> 00:02:48,866
编译器还可以选择

81
00:02:48,866 --> 00:02:50,416
以文本形式诊断问题

82
00:02:51,106 --> 00:02:52,806
基本上 是选择

83
00:02:52,976 --> 00:02:54,086
定义那些标准所未定义

84
00:02:54,086 --> 00:02:54,696
的行为

85
00:02:55,416 --> 00:02:57,466
我们并不常用这个方法

86
00:02:57,466 --> 00:02:58,376
但是有一些

87
00:02:58,376 --> 00:02:59,936
未定义行为

88
00:02:59,936 --> 00:03:01,496
是常见的不支持行为

89
00:02:59,936 --> 00:03:01,496
是常见的不支持行为

90
00:03:04,286 --> 00:03:05,916
最后 编译器可能会产生

91
00:03:05,916 --> 00:03:07,846
不可预料的结果

92
00:03:08,336 --> 00:03:09,826
这会是我们今天

93
00:03:09,826 --> 00:03:10,836
讨论的重点

94
00:03:12,056 --> 00:03:14,216
注意 这些不可预料的结果

95
00:03:16,606 --> 00:03:18,526
包括你意图的行为 这就是为什么

96
00:03:18,526 --> 00:03:19,486
某些 Bug 很难被发现

97
00:03:20,616 --> 00:03:23,606
在 C 族语言中

98
00:03:23,606 --> 00:03:25,036
存在大量的

99
00:03:25,036 --> 00:03:25,546
未定义行为

100
00:03:26,226 --> 00:03:27,596
下面是一个简单的例子

101
00:03:28,866 --> 00:03:30,746
C 语言标准在

102
00:03:30,796 --> 00:03:32,996
Annex J 中有一系列未定义行为

103
00:03:32,996 --> 00:03:33,966
的已知来源

104
00:03:33,966 --> 00:03:37,506
大概有 200 种

105
00:03:37,756 --> 00:03:39,016
讲到这里 你可能会

106
00:03:39,016 --> 00:03:41,486
奇怪 为什么未定义行为

107
00:03:41,486 --> 00:03:42,796
也能成为一个问题

108
00:03:42,966 --> 00:03:44,316
为什么不能在标准中

109
00:03:44,316 --> 00:03:45,006
全部定义了呢

110
00:03:45,006 --> 00:03:46,426
是因为人们很懒吗

111
00:03:46,426 --> 00:03:47,546
他们不想定义

112
00:03:47,546 --> 00:03:48,006
所有的行为吗

113
00:03:49,066 --> 00:03:49,846
当然不是

114
00:03:50,686 --> 00:03:51,836
这是一个折衷的选择

115
00:03:52,656 --> 00:03:55,366
C 语言的设计旨在

116
00:03:55,706 --> 00:03:58,096
提高性能 可负担性和

117
00:03:58,096 --> 00:03:59,506
易于实施的

118
00:03:59,506 --> 00:04:00,016
安全性

119
00:03:59,506 --> 00:04:00,016
安全性

120
00:04:01,666 --> 00:04:03,316
C 族语言

121
00:04:03,316 --> 00:04:04,806
继承了这些折衷的选择

122
00:04:06,136 --> 00:04:08,026
这些选择都是有意的

123
00:04:08,246 --> 00:04:09,316
并且在今天的很多情况下

124
00:04:09,316 --> 00:04:10,946
仍然起着很大

125
00:04:10,946 --> 00:04:11,286
的作用

126
00:04:12,266 --> 00:04:16,886
我们的 OS 因此运行的很快

127
00:04:16,886 --> 00:04:18,745
但就像每个折衷方案一样

128
00:04:18,776 --> 00:04:20,416
总是需要付出一些代价

129
00:04:20,416 --> 00:04:22,005
在这个案例中 就需要各位

130
00:04:22,005 --> 00:04:24,196
开发人员来付出代价

131
00:04:24,586 --> 00:04:25,896
所以让大家

132
00:04:25,896 --> 00:04:27,466
了解未定义行为的存在

133
00:04:27,466 --> 00:04:29,926
以及如何处理是至关重要的

134
00:04:30,496 --> 00:04:33,586
就像我说的

135
00:04:33,586 --> 00:04:35,466
未定义行为种类太多

136
00:04:35,546 --> 00:04:37,056
没办法全部提及

137
00:04:37,436 --> 00:04:38,836
但是我们可以看看

138
00:04:38,836 --> 00:04:39,816
一些例子 确保

139
00:04:39,816 --> 00:04:43,136
我们达成共识

140
00:04:43,336 --> 00:04:45,426
第一个例子是使用

141
00:04:45,426 --> 00:04:46,936
未初始化的值

142
00:04:47,646 --> 00:04:49,326
在这个函数里 我们有一个

143
00:04:49,326 --> 00:04:50,396
局部变量值

144
00:04:51,016 --> 00:04:52,386
它在 return 语句中使用

145
00:04:52,386 --> 00:04:55,536
但只有在 if 块的条件

146
00:04:55,536 --> 00:04:57,596
为真时

147
00:04:57,596 --> 00:04:58,346
才会被初始化

148
00:04:59,316 --> 00:05:01,346
如果你将任何正数

149
00:04:59,316 --> 00:05:01,346
如果你将任何正数

150
00:05:01,346 --> 00:05:02,986
传递给此函数 它将调用

151
00:05:02,986 --> 00:05:05,136
未定义行为 因为变量值将会

152
00:05:05,136 --> 00:05:06,626
被使用和初始化

153
00:05:07,986 --> 00:05:09,386
在这个简单的案例中

154
00:05:09,386 --> 00:05:10,646
编译器将捕捉到问题

155
00:05:10,646 --> 00:05:11,376
并发出警告

156
00:05:12,816 --> 00:05:14,416
静态分析也会提供

157
00:05:14,416 --> 00:05:15,976
这些信息 并且能

158
00:05:15,976 --> 00:05:18,156
发现更复杂的

159
00:05:18,316 --> 00:05:21,026
同类问题

160
00:05:22,426 --> 00:05:23,786
第二个例子是

161
00:05:23,786 --> 00:05:24,906
指针偏差

162
00:05:25,256 --> 00:05:28,136
在这个函数中 我们使用一个

163
00:05:28,136 --> 00:05:29,656
字符指针作为参数

164
00:05:30,796 --> 00:05:32,836
但在函数内部 我们将它

165
00:05:32,836 --> 00:05:34,076
用作整数指针

166
00:05:34,786 --> 00:05:36,976
但问题是 并非每个

167
00:05:36,976 --> 00:05:38,376
字符指针都是一个

168
00:05:38,376 --> 00:05:39,236
有效整数指针

169
00:05:40,746 --> 00:05:42,606
整数必须

170
00:05:42,606 --> 00:05:43,076
正确对齐

171
00:05:43,416 --> 00:05:44,886
通常这意味着 它们的地址

172
00:05:44,886 --> 00:05:46,166
需要是 4 的整数倍

173
00:05:47,406 --> 00:05:48,836
当在不同架构之间

174
00:05:48,836 --> 00:05:50,606
移植代码时 这种代码

175
00:05:50,606 --> 00:05:52,086
通常会导致问题

176
00:05:52,206 --> 00:05:53,896
这些架构在硬件层面上

177
00:05:53,896 --> 00:05:55,156
具有不同的

178
00:05:55,526 --> 00:05:56,046
对齐约束

179
00:05:56,856 --> 00:05:58,816
今年 我们在 Xcode 9 中

180
00:05:58,816 --> 00:06:00,246
引入了新的运行时工具

181
00:05:58,816 --> 00:06:00,246
引入了新的运行时工具

182
00:06:00,356 --> 00:06:01,366
叫做“未定义行为杀毒器”

183
00:06:01,366 --> 00:06:02,796
它可以

184
00:06:02,796 --> 00:06:03,660
捕捉到这个问题

185
00:06:07,646 --> 00:06:09,906
最后一个例子是

186
00:06:09,906 --> 00:06:10,516
生命周期

187
00:06:11,706 --> 00:06:13,926
变量仅在

188
00:06:13,926 --> 00:06:15,296
作用域内定义 也就是说

189
00:06:15,416 --> 00:06:17,116
我们的变量仅在其定义的

190
00:06:17,116 --> 00:06:18,436
作用域内被赋值

191
00:06:19,336 --> 00:06:20,946
在这里 我们使用变量

192
00:06:20,946 --> 00:06:22,056
默认值的地址

193
00:06:23,166 --> 00:06:25,416
默认值在 if 块内定义

194
00:06:25,416 --> 00:06:27,556
且只存在于该块

195
00:06:28,036 --> 00:06:29,946
但是我们可以通过在块外部

196
00:06:30,336 --> 00:06:32,116
使用这个指针

197
00:06:32,116 --> 00:06:33,026
来调用未定义行为

198
00:06:34,776 --> 00:06:37,476
同样的 我们的工具

199
00:06:37,476 --> 00:06:37,696
也会捕捉到这个问题

200
00:06:38,606 --> 00:06:42,236
对于我们正在谈论的问题

201
00:06:42,236 --> 00:06:44,366
我们现在有了更好的解决方法

202
00:06:44,366 --> 00:06:46,526
让我们看一下

203
00:06:46,526 --> 00:06:47,816
未定义行为是如何与

204
00:06:49,506 --> 00:06:50,876
编译器互相作用 以及如何

205
00:06:50,876 --> 00:06:51,676
产生了那些意外的 Bug

206
00:06:52,576 --> 00:06:55,546
首先来看一下

207
00:06:55,546 --> 00:06:56,776
编译器 未定义行为

208
00:06:56,776 --> 00:06:58,376
对于编译器来说意味着什么 

209
00:06:59,266 --> 00:07:01,556
编译器并不会主动

210
00:06:59,266 --> 00:07:01,556
编译器并不会主动

211
00:07:01,556 --> 00:07:03,976
寻找未定义行为 并以奇怪的

212
00:07:03,976 --> 00:07:04,386
方式转化它

213
00:07:04,776 --> 00:07:05,706
这不会发生

214
00:07:06,306 --> 00:07:07,616
但是编译器会

215
00:07:07,616 --> 00:07:09,356
假定在你的代码中

216
00:07:09,356 --> 00:07:11,116
是没有未定义行为的

217
00:07:11,556 --> 00:07:12,976
否则你代码的

218
00:07:12,976 --> 00:07:14,086
语义就不会被

219
00:07:14,086 --> 00:07:14,556
很好地定义

220
00:07:15,656 --> 00:07:17,696
通过作出这一假设

221
00:07:17,696 --> 00:07:20,216
编译器会收集信息

222
00:07:20,456 --> 00:07:21,616
来更好地优化你的代码

223
00:07:21,716 --> 00:07:24,756
给大家举几个例子

224
00:07:26,416 --> 00:07:28,296
由于未定义为溢出

225
00:07:28,296 --> 00:07:30,346
分配的整数 如果 X 

226
00:07:30,346 --> 00:07:31,986
被分配整数 则编译器

227
00:07:31,986 --> 00:07:33,976
可以假设 X 低于

228
00:07:33,976 --> 00:07:34,616
X + 1

229
00:07:35,386 --> 00:07:37,326
这是一个非常简单但

230
00:07:37,326 --> 00:07:38,696
非常强大的假设

231
00:07:38,696 --> 00:07:40,226
比如说 在处理循环优化时

232
00:07:40,226 --> 00:07:41,036
就可以作此假设

233
00:07:42,836 --> 00:07:45,826
就像我说过的

234
00:07:45,826 --> 00:07:46,296
指针需要对齐

235
00:07:47,136 --> 00:07:48,416
通过作出假设

236
00:07:48,416 --> 00:07:49,916
编译器可以

237
00:07:49,916 --> 00:07:52,056
使用更强大的内存访问指令

238
00:07:52,056 --> 00:07:53,396
如向量指令

239
00:07:53,396 --> 00:07:55,046
使你的代码

240
00:07:55,046 --> 00:07:55,786
更快地运行

241
00:07:56,356 --> 00:08:00,736
最后一个例子是

242
00:07:56,356 --> 00:08:00,736
最后一个例子是

243
00:08:00,736 --> 00:08:02,246
未定义解引用另一指针

244
00:08:02,246 --> 00:08:03,986
所以编译器可以

245
00:08:03,986 --> 00:08:05,596
假设每一个被解引用的

246
00:08:05,596 --> 00:08:08,456
指针都不是现在的

247
00:08:08,456 --> 00:08:09,976
并使用这些信息来进一步

248
00:08:09,976 --> 00:08:10,696
优化你的代码

249
00:08:12,946 --> 00:08:14,526
让我们更具体一些

250
00:08:14,526 --> 00:08:16,496
看看编译器是

251
00:08:16,496 --> 00:08:17,416
如何工作的

252
00:08:18,346 --> 00:08:19,856
编译器会从很高层级

253
00:08:19,856 --> 00:08:21,336
输入你的源代码

254
00:08:22,236 --> 00:08:23,466
并将其转换成

255
00:08:23,466 --> 00:08:24,666
中间代码

256
00:08:24,996 --> 00:08:27,466
然后应用优化

257
00:08:27,466 --> 00:08:29,016
流水线

258
00:08:29,016 --> 00:08:30,316
来生成

259
00:08:30,676 --> 00:08:30,846
二进制文件

260
00:08:30,846 --> 00:08:32,765
这中间的每一次优化

261
00:08:32,765 --> 00:08:35,076
都有一个目标 那就是

262
00:08:35,076 --> 00:08:37,265
将输入的信息生成

263
00:08:37,265 --> 00:08:39,106
更有效的代码 同时

264
00:08:39,106 --> 00:08:39,796
保留语义

265
00:08:40,326 --> 00:08:44,265
但是大会开始时

266
00:08:44,426 --> 00:08:45,726
我讲了那些在

267
00:08:45,796 --> 00:08:47,376
发布模式下会再现

268
00:08:47,416 --> 00:08:48,386
在调试模式下会消失的 Bug

269
00:08:48,386 --> 00:08:49,526
那么 这种行为

270
00:08:49,526 --> 00:08:50,226
是如何保留的呢

271
00:08:51,266 --> 00:08:52,916
我们来看一个简单的例子

272
00:08:54,056 --> 00:08:55,716
上面是我们的

273
00:08:55,716 --> 00:08:56,066
编译器

274
00:08:57,506 --> 00:08:58,946
它只有一种优化

275
00:08:59,266 --> 00:09:00,416
死代码删除

276
00:08:59,266 --> 00:09:00,416
死代码删除

277
00:09:01,066 --> 00:09:03,886
死代码删除会查找

278
00:09:03,886 --> 00:09:06,666
无法执行的代码

279
00:09:06,666 --> 00:09:08,156
或者对程序运行结果

280
00:09:08,156 --> 00:09:10,186
没有任何影响的代码

281
00:09:10,186 --> 00:09:11,526
并将其删除 从而

282
00:09:11,526 --> 00:09:13,326
使你的 App 变得更小

283
00:09:14,786 --> 00:09:16,166
让我们将这个编译器

284
00:09:16,166 --> 00:09:17,236
应用到一个简单的函数中

285
00:09:18,276 --> 00:09:19,636
这个函数只有两个语句

286
00:09:19,636 --> 00:09:20,916
一个变量赋值

287
00:09:20,916 --> 00:09:22,576
和一个 return 

288
00:09:22,576 --> 00:09:23,006
语句

289
00:09:23,636 --> 00:09:26,906
我们运行死代码删除

290
00:09:27,896 --> 00:09:29,876
并没有使用变量

291
00:09:29,986 --> 00:09:32,426
让我们去掉它

292
00:09:32,686 --> 00:09:34,616
看看这里 我们得到了什么

293
00:09:35,546 --> 00:09:37,216
如果我们将另一个指针传递给

294
00:09:37,216 --> 00:09:38,236
这个函数 会发生什么情况

295
00:09:38,776 --> 00:09:40,646
未优化版本会崩溃

296
00:09:40,646 --> 00:09:42,936
而优化版本将

297
00:09:42,936 --> 00:09:44,346
顺利地返回 42

298
00:09:44,996 --> 00:09:46,476
所以 它们的行为

299
00:09:46,476 --> 00:09:46,956
有差异

300
00:09:47,936 --> 00:09:49,576
但是 通过传递 null 给

301
00:09:49,576 --> 00:09:51,496
此函数 你调用了未定义行为

302
00:09:51,496 --> 00:09:53,756
也就是 未定义解引用

303
00:09:53,756 --> 00:09:54,966
另一个指针

304
00:09:56,156 --> 00:09:57,756
我再说一遍

305
00:09:57,756 --> 00:09:59,566
未定义解引用

306
00:09:59,566 --> 00:10:00,226
另一个指针

307
00:09:59,566 --> 00:10:00,226
另一个指针

308
00:10:00,276 --> 00:10:02,056
它没有被定义为崩溃

309
00:10:03,216 --> 00:10:05,116
如果解引用另一个指针

310
00:10:05,116 --> 00:10:07,456
被定义为崩溃 或者如果

311
00:10:07,456 --> 00:10:08,826
由于某些其他原因 编译器

312
00:10:08,826 --> 00:10:10,166
无法假定该解引用指针

313
00:10:10,546 --> 00:10:12,236
是有效的 那么

314
00:10:12,236 --> 00:10:14,796
在内存访问上进行

315
00:10:14,796 --> 00:10:16,306
任何转换都是

316
00:10:16,306 --> 00:10:17,236
非常困难的

317
00:10:17,396 --> 00:10:19,066
比如说 不能重新排序

318
00:10:19,066 --> 00:10:21,086
不能合并

319
00:10:21,086 --> 00:10:22,206
不能删除无用的部分

320
00:10:22,206 --> 00:10:23,296
就像我们刚才看到的那样

321
00:10:26,166 --> 00:10:27,696
处理内存访问是

322
00:10:27,796 --> 00:10:29,346
编译器工作的一个重要部分

323
00:10:30,586 --> 00:10:31,896
所以 这个例子就告诉大家

324
00:10:32,026 --> 00:10:34,306
未定义行为是如何

325
00:10:34,306 --> 00:10:35,546
在未优化代码和

326
00:10:35,546 --> 00:10:37,046
优化代码间

327
00:10:37,046 --> 00:10:37,816
改变程序行为的

328
00:10:38,436 --> 00:10:39,426
但我还想给大家

329
00:10:39,426 --> 00:10:39,616
展示更多的例子

330
00:10:40,186 --> 00:10:41,536
让我们看一个稍微

331
00:10:41,536 --> 00:10:42,526
复杂的例子

332
00:10:44,136 --> 00:10:45,956
我们再次把编译器

333
00:10:45,956 --> 00:10:47,856
放在上面 把源代码

334
00:10:47,856 --> 00:10:48,276
放在下面

335
00:10:49,206 --> 00:10:51,246
这个例子实际上来源于

336
00:10:51,506 --> 00:10:53,106
一个真实问题

337
00:10:53,106 --> 00:10:54,536
发生在几年前的

338
00:10:54,716 --> 00:10:55,746
开放源代码活动中

339
00:10:55,976 --> 00:10:57,586
所以 不要把它当作

340
00:10:57,586 --> 00:10:58,926
纯理论而忽略它

341
00:11:00,786 --> 00:11:02,426
当你有一个很大的函数

342
00:11:02,616 --> 00:11:03,996
由很多个人在很长

343
00:11:04,076 --> 00:11:05,566
一段时间内修改

344
00:11:05,566 --> 00:11:07,896
就会很容易最后变成

345
00:11:07,896 --> 00:11:09,426
和过去一样的东西

346
00:11:09,426 --> 00:11:10,786
就像这个函数顶端没有使用过的

347
00:11:10,786 --> 00:11:11,406
变量一样

348
00:11:12,606 --> 00:11:14,786
现在 让我们来编译这个代码

349
00:11:15,296 --> 00:11:16,596
我们的新编译器多了

350
00:11:16,596 --> 00:11:17,336
一种优化

351
00:11:17,986 --> 00:11:19,226
冗余空检查

352
00:11:19,226 --> 00:11:19,976
删除

353
00:11:20,916 --> 00:11:22,186
这是死代码删除

354
00:11:22,186 --> 00:11:23,796
的一个专用

355
00:11:23,796 --> 00:11:24,526
版本

356
00:11:24,976 --> 00:11:26,436
它会查找与现在相比

357
00:11:26,436 --> 00:11:28,596
的指针 并尝试确定

358
00:11:28,626 --> 00:11:30,536
静态时在程序的

359
00:11:30,576 --> 00:11:33,336
这一点 是否可以证明

360
00:11:33,726 --> 00:11:36,316
指针是空

361
00:11:36,316 --> 00:11:37,456
还是非空

362
00:11:38,776 --> 00:11:40,296
当可以这样做时

363
00:11:40,296 --> 00:11:41,526
它就会删除永远无法

364
00:11:41,526 --> 00:11:42,366
执行的代码

365
00:11:43,316 --> 00:11:46,626
在这种情况下 p

366
00:11:46,626 --> 00:11:47,846
在函数的第一行将会被

367
00:11:47,846 --> 00:11:48,356
解引用

368
00:11:48,426 --> 00:11:49,856
所以 指针当然

369
00:11:49,856 --> 00:11:50,206
不能为空

370
00:11:50,806 --> 00:11:51,776
让我们把空检查删掉

371
00:11:52,396 --> 00:11:56,376
然后我们来看一下第二种

372
00:11:56,376 --> 00:11:57,066
优化

373
00:11:57,416 --> 00:11:58,656
我们已经知道了死代码

374
00:11:58,656 --> 00:11:59,396
删除

375
00:12:00,116 --> 00:12:01,066
未使用的代码未被使用

376
00:12:01,616 --> 00:12:02,296
会被去掉

377
00:12:03,846 --> 00:12:05,796
这就是我们的

378
00:12:05,796 --> 00:12:06,396
编译结果

379
00:12:07,716 --> 00:12:10,006
现在 让我们进行同样的操作

380
00:12:10,006 --> 00:12:11,596
如果我们将 null 传递给

381
00:12:11,596 --> 00:12:12,166
这个函数会怎么样呢

382
00:12:12,876 --> 00:12:14,956
未优化版本将

383
00:12:14,956 --> 00:12:15,446
崩溃

384
00:12:16,306 --> 00:12:18,356
优化后的版本

385
00:12:18,356 --> 00:12:18,576
也会崩溃

386
00:12:19,436 --> 00:12:20,806
但请注意 它们崩溃的地方

387
00:12:20,806 --> 00:12:21,476
是不同的

388
00:12:21,946 --> 00:12:23,296
未优化版本会在

389
00:12:23,296 --> 00:12:24,086
第一行上崩溃

390
00:12:24,506 --> 00:12:26,116
优化后的版本在

391
00:12:26,116 --> 00:12:26,916
最后一行上崩溃

392
00:12:27,706 --> 00:12:29,296
这中间可能差了

393
00:12:29,296 --> 00:12:30,376
成千上万行

394
00:12:31,226 --> 00:12:32,996
这对于了解

395
00:12:32,996 --> 00:12:34,236
未定义行为

396
00:12:34,236 --> 00:12:34,766
是非常重要的

397
00:12:35,356 --> 00:12:37,786
当未定义行为引起问题时

398
00:12:37,786 --> 00:12:39,996
无论是另一个引用

399
00:12:39,996 --> 00:12:42,136
整数溢出

400
00:12:42,136 --> 00:12:44,126
由于超出限制访问的

401
00:12:44,126 --> 00:12:45,686
内存损坏 或任何

402
00:12:45,686 --> 00:12:47,336
其他类型的未定义行为

403
00:12:47,336 --> 00:12:49,106
你看到的症状通常

404
00:12:49,106 --> 00:12:50,526
与问题的根本原因

405
00:12:50,526 --> 00:12:51,336
相差甚远

406
00:12:53,566 --> 00:12:54,806
还有一件事我想

407
00:12:54,806 --> 00:12:55,306
展示给大家看

408
00:12:56,096 --> 00:12:58,606
我们用一个稍微

409
00:12:58,606 --> 00:12:59,606
不同的编译器

410
00:12:59,606 --> 00:13:00,056
重新启动编译

411
00:12:59,606 --> 00:13:00,056
重新启动编译

412
00:13:01,136 --> 00:13:02,496
如你所见 我们只是

413
00:13:02,646 --> 00:13:03,656
交换了两种优化

414
00:13:04,386 --> 00:13:05,556
我们再次编译相同

415
00:13:05,556 --> 00:13:05,906
的代码

416
00:13:08,366 --> 00:13:10,266
死代码删除 未使用的代码

417
00:13:10,266 --> 00:13:10,906
仍未使用

418
00:13:10,906 --> 00:13:12,056
它消失了

419
00:13:13,696 --> 00:13:15,736
现在我们尝试应用

420
00:13:15,736 --> 00:13:17,330
冗余空检查删除

421
00:13:18,186 --> 00:13:19,846
对于 p 指针的值

422
00:13:19,846 --> 00:13:21,266
没有任何理由进行处理

423
00:13:21,266 --> 00:13:22,786
所以优化

424
00:13:22,786 --> 00:13:24,136
并没有什么

425
00:13:24,136 --> 00:13:24,656
作用

426
00:13:25,176 --> 00:13:27,886
这是我们第二次编译

427
00:13:28,046 --> 00:13:29,366
相同代码的

428
00:13:29,366 --> 00:13:29,616
结果

429
00:13:30,446 --> 00:13:33,036
请注意 在这种情况下

430
00:13:33,036 --> 00:13:34,726
如果将空指针传递到

431
00:13:34,726 --> 00:13:36,466
优化后的版本 则不会

432
00:13:36,886 --> 00:13:37,000
崩溃

433
00:13:39,036 --> 00:13:41,816
现在 假设你的 App

434
00:13:41,816 --> 00:13:43,726
代码在左边

435
00:13:43,726 --> 00:13:44,946
开发人员在这个函数中的某个点

436
00:13:44,946 --> 00:13:46,116
添加了一个空的检查功能

437
00:13:46,116 --> 00:13:48,836
并添加了另一个

438
00:13:48,836 --> 00:13:50,146
函数的参数的一些使用

439
00:13:51,186 --> 00:13:52,586
你可能从来没有意识到

440
00:13:52,586 --> 00:13:54,136
这是一个问题

441
00:13:54,136 --> 00:13:55,566
因为你的编译器就像编译器 2

442
00:13:55,566 --> 00:13:55,846
一样

443
00:13:56,826 --> 00:13:58,646
但是不能保证在将来

444
00:13:58,646 --> 00:14:00,396
它不会出现像编译器 1 中

445
00:13:58,646 --> 00:14:00,396
它不会出现像编译器 1 中

446
00:14:00,396 --> 00:14:02,206
那样的行为 并破坏你的

447
00:14:02,206 --> 00:14:02,486
代码

448
00:14:03,726 --> 00:14:05,356
这可能是关于未定义行为

449
00:14:05,356 --> 00:14:06,606
需要记住的

450
00:14:06,606 --> 00:14:07,476
最重要的事情

451
00:14:07,716 --> 00:14:09,466
你今天没有问题

452
00:14:09,466 --> 00:14:11,226
并不意味着编译器中的

453
00:14:11,226 --> 00:14:12,806
这种变化不会

454
00:14:12,806 --> 00:14:13,866
导致它在

455
00:14:13,866 --> 00:14:14,276
将来崩溃

456
00:14:15,786 --> 00:14:17,266
你的编译器可能

457
00:14:17,266 --> 00:14:18,686
会比你想象中的

458
00:14:18,686 --> 00:14:18,996
更多变

459
00:14:20,966 --> 00:14:22,796
在一天之内 每次

460
00:14:22,796 --> 00:14:24,046
你在调试和发布模式之间

461
00:14:24,046 --> 00:14:25,796
切换时 或者每次

462
00:14:25,796 --> 00:14:26,776
更改优化设置时

463
00:14:26,776 --> 00:14:29,026
都会运行不同的

464
00:14:29,026 --> 00:14:30,396
编译器实例 并将一组

465
00:14:30,396 --> 00:14:31,476
非常不同的转换

466
00:14:31,476 --> 00:14:32,786
应用到你的

467
00:14:32,786 --> 00:14:33,136
代码中

468
00:14:35,016 --> 00:14:36,996
也许更令人惊讶的是

469
00:14:36,996 --> 00:14:38,086
每次你从真实设备

470
00:14:38,086 --> 00:14:39,776
切换到模拟器 或者反过来

471
00:14:39,776 --> 00:14:42,196
你都会定向至

472
00:14:42,196 --> 00:14:43,746
不同的架构

473
00:14:43,746 --> 00:14:45,566
这可能会对未定义行为

474
00:14:45,566 --> 00:14:46,496
产生不同的反应

475
00:14:47,076 --> 00:14:50,746
当然 每次

476
00:14:50,746 --> 00:14:52,656
将 Xcode 升级到一个新的

477
00:14:52,656 --> 00:14:54,656
主要版本时 你都会得到一个

478
00:14:54,656 --> 00:14:55,176
全新的编译器

479
00:14:55,176 --> 00:14:58,176
而且我们一直在努力

480
00:14:58,176 --> 00:14:59,356
使编译器生成更好

481
00:14:59,476 --> 00:15:01,136
更快和更小的代码

482
00:14:59,476 --> 00:15:01,136
更快和更小的代码

483
00:15:02,126 --> 00:15:05,296
许多这些改进

484
00:15:05,296 --> 00:15:06,656
都可能在你的代码中引发

485
00:15:06,656 --> 00:15:07,500
未定义行为

486
00:15:09,336 --> 00:15:12,336
在继续之前

487
00:15:12,616 --> 00:15:13,996
让我来总结一下我们

488
00:15:13,996 --> 00:15:14,886
了解到了哪些关于未定义行为的

489
00:15:14,886 --> 00:15:15,336
信息

490
00:15:17,486 --> 00:15:19,836
未定义行为不会

491
00:15:19,836 --> 00:15:21,176
总是触发 Bug

492
00:15:22,016 --> 00:15:23,406
可能你的一个配置

493
00:15:23,406 --> 00:15:24,936
正在工作时 另一个就

494
00:15:24,936 --> 00:15:25,416
中断了

495
00:15:26,746 --> 00:15:28,706
当未定义行为出现

496
00:15:28,956 --> 00:15:31,166
并中断代码时

497
00:15:31,166 --> 00:15:33,136
你所看到的症状可能

498
00:15:33,296 --> 00:15:35,106
距离问题的根本原因

499
00:15:35,106 --> 00:15:37,316
有数千行之远

500
00:15:37,946 --> 00:15:39,356
或者甚至间隔了几个小时的执行

501
00:15:39,356 --> 00:15:39,886
时间

502
00:15:40,456 --> 00:15:41,486
如果你没有

503
00:15:41,486 --> 00:15:42,676
做好准备的话

504
00:15:42,676 --> 00:15:43,026
这可能真的很难调试

505
00:15:45,076 --> 00:15:48,336
最后一点是

506
00:15:48,336 --> 00:15:50,586
你今天没有任何

507
00:15:50,586 --> 00:15:52,496
已知晓的错误，并不意味着

508
00:15:52,496 --> 00:15:54,036
你不会遇到任何由未定义行为

509
00:15:54,036 --> 00:15:54,886
引起的错误

510
00:15:55,266 --> 00:15:56,556
如果存在未定义行为

511
00:15:56,556 --> 00:15:58,796
就会在将来的

512
00:15:58,796 --> 00:15:59,646
某个时间引发中断

513
00:16:01,016 --> 00:16:03,106
当它引发中断时 可能会

514
00:16:03,106 --> 00:16:04,776
花费你很多的调试时间

515
00:16:04,776 --> 00:16:06,246
但也可能会使你的用户数据处于危险之中

516
00:16:06,246 --> 00:16:07,036
处于危险之中

517
00:16:08,076 --> 00:16:09,516
这是Ryan 他会为你讲解更多的

518
00:16:09,516 --> 00:16:11,096
关于未定义行为的

519
00:16:11,096 --> 00:16:12,206
安全隐患

520
00:16:14,516 --> 00:16:18,896
[掌声]

521
00:16:19,396 --> 00:16:19,816
&gt;&gt; 谢谢 Fred

522
00:16:21,616 --> 00:16:23,276
那么 大家有谁还记得

523
00:16:23,276 --> 00:16:24,496
几年前的“心脏出血“

524
00:16:24,496 --> 00:16:25,126
安全漏洞吗

525
00:16:26,096 --> 00:16:26,916
如果你像我一样

526
00:16:26,916 --> 00:16:27,866
可能不得不会去

527
00:16:27,866 --> 00:16:29,356
100 个不同的网站

528
00:16:29,356 --> 00:16:31,246
修改密码 或者也许

529
00:16:31,486 --> 00:16:33,026
为你自己的后台服务器

530
00:16:33,026 --> 00:16:33,516
打补丁

531
00:16:34,486 --> 00:16:35,446
“心脏出血”是一种

532
00:16:35,446 --> 00:16:37,216
在广泛使用的

533
00:16:37,216 --> 00:16:38,556
OpenSSL 的密码库中的

534
00:16:38,556 --> 00:16:39,506
越界读取

535
00:16:40,196 --> 00:16:41,906
通过向受影响的服务器

536
00:16:41,906 --> 00:16:43,686
发送一个数据包 攻击者

537
00:16:43,686 --> 00:16:44,926
就会收到服务器

538
00:16:44,926 --> 00:16:46,056
进程堆内存的

539
00:16:46,056 --> 00:16:48,136
几千字节 这引发了

540
00:16:48,136 --> 00:16:51,796
相当严重的隐私泄漏

541
00:16:52,056 --> 00:16:53,586
和安全问题

542
00:16:55,696 --> 00:16:58,826
“心脏出血”的越界读取

543
00:16:58,826 --> 00:17:00,236
就是一个未定义行为

544
00:16:58,826 --> 00:17:00,236
就是一个未定义行为

545
00:17:00,236 --> 00:17:01,956
的例子 而事实证明

546
00:17:01,956 --> 00:17:03,316
未定义行为是

547
00:17:03,316 --> 00:17:04,346
许多不同类型的

548
00:17:04,346 --> 00:17:05,026
安全漏洞的

549
00:17:05,026 --> 00:17:05,626
核心

550
00:17:06,465 --> 00:17:08,185
仅举几个例子 你就可以

551
00:17:08,185 --> 00:17:11,556
想到缓冲区溢出

552
00:17:11,556 --> 00:17:14,016
未初始化变量的使用

553
00:17:14,016 --> 00:17:16,766
和 Heat Misuse Bug

554
00:17:16,766 --> 00:17:17,465
比如 Use-After-Free 和 Double Free

555
00:17:18,086 --> 00:17:19,526
还有竞争条件漏洞

556
00:17:22,296 --> 00:17:24,215
所以 请记住 你的用户

557
00:17:24,415 --> 00:17:27,316
信任你的 App  并且可能会

558
00:17:27,526 --> 00:17:29,026
留有他们的个人信息

559
00:17:29,026 --> 00:17:30,926
比如照片或

560
00:17:30,926 --> 00:17:31,766
私人信息

561
00:17:32,196 --> 00:17:32,996
所以你应该尽一切可能

562
00:17:32,996 --> 00:17:34,146
来确保你的 App

563
00:17:34,146 --> 00:17:35,746
的安全

564
00:17:35,746 --> 00:17:36,226
和可靠

565
00:17:37,376 --> 00:17:38,286
如果你是框架

566
00:17:38,286 --> 00:17:39,686
开发人员 就需要记住

567
00:17:39,686 --> 00:17:41,236
你的 App 客户端

568
00:17:41,236 --> 00:17:42,286
会继承所有 Bug

569
00:17:42,286 --> 00:17:43,706
就像所有这些网站都继承了

570
00:17:43,706 --> 00:17:44,676
“心脏出血”漏洞一样

571
00:17:45,256 --> 00:17:48,516
但好消息是

572
00:17:48,516 --> 00:17:49,506
有些工具可以帮助你

573
00:17:50,296 --> 00:17:52,396
目前 开发人员往往

574
00:17:52,396 --> 00:17:54,616
只有在 Bug 以某些方式显现的

575
00:17:54,616 --> 00:17:55,876
情况下才会使用

576
00:17:55,876 --> 00:17:56,166
我们的工具

577
00:17:56,166 --> 00:17:57,326
比如 Bug 出现在了用户的

578
00:17:57,326 --> 00:17:58,066
崩溃日志中 

579
00:17:58,836 --> 00:18:00,566
但如果在早期以及

580
00:17:58,836 --> 00:18:00,566
但如果在早期以及

581
00:18:00,566 --> 00:18:02,636
整个开发过程中就运行工具

582
00:18:02,636 --> 00:18:03,956
我们就可以在它们

583
00:18:03,956 --> 00:18:05,476
发展成问题并影响用户之前

584
00:18:05,476 --> 00:18:08,416
就捕捉到这些问题

585
00:18:08,416 --> 00:18:11,326
我想举一个例子

586
00:18:11,326 --> 00:18:12,826
告诉你们 作为这些工具之一的

587
00:18:12,826 --> 00:18:15,636
“地址杀毒器”是如何拯救

588
00:18:15,636 --> 00:18:16,096
macOS Yosemite 的

589
00:18:17,536 --> 00:18:19,246
在 macOS Yosemite 

590
00:18:19,246 --> 00:18:20,856
公开发布前一个月左右

591
00:18:21,236 --> 00:18:22,396
许多新的崩溃开始

592
00:18:22,396 --> 00:18:23,916
出现在整个系统中

593
00:18:24,446 --> 00:18:26,166
我们预感在一个

594
00:18:26,166 --> 00:18:28,766
低层系统框架中

595
00:18:28,766 --> 00:18:30,796
存在一个堆腐败

596
00:18:30,796 --> 00:18:31,346
Bug

597
00:18:31,966 --> 00:18:32,836
我们当时费了很大力气

598
00:18:32,836 --> 00:18:34,226
重现这个问题

599
00:18:34,846 --> 00:18:35,676
但并没有成功

600
00:18:35,676 --> 00:18:36,776
也没有确切的证据

601
00:18:36,776 --> 00:18:38,436
能够指出一个

602
00:18:38,436 --> 00:18:39,886
特定的函数导致了

603
00:18:39,886 --> 00:18:40,876
堆腐败

604
00:18:41,966 --> 00:18:43,646
所以我们转而使用

605
00:18:43,646 --> 00:18:46,516
一种名为“地址杀毒器”的工具

606
00:18:46,516 --> 00:18:48,096
这在当时是非常新的工具

607
00:18:48,096 --> 00:18:49,256
我们认为它可以捕捉到

608
00:18:49,256 --> 00:18:50,246
这个堆腐败错误

609
00:18:50,366 --> 00:18:51,676
所以 我们测试了一些

610
00:18:51,676 --> 00:18:53,256
系统框架 并加载了

611
00:18:53,256 --> 00:18:53,626
这个工具

612
00:18:53,626 --> 00:18:54,656
当然 “地址杀毒器”

613
00:18:54,656 --> 00:18:55,726
完美地解决了

614
00:18:55,726 --> 00:18:57,516
问题 锁定了

615
00:18:57,516 --> 00:18:59,486
这片代码

616
00:18:59,576 --> 00:19:01,476
总结一下就是

617
00:18:59,576 --> 00:19:01,476
总结一下就是

618
00:19:03,196 --> 00:19:04,886
我们有一个 CF 字符串

619
00:19:04,886 --> 00:19:07,026
并正在构建用户库

620
00:19:07,026 --> 00:19:09,146
缓存目录中的一个

621
00:19:09,146 --> 00:19:10,056
文件路径

622
00:19:11,056 --> 00:19:12,106
然后我们将这个 C 字符串

623
00:19:12,106 --> 00:19:14,026
抱歉 将这个 CF 字符串

624
00:19:14,026 --> 00:19:15,676
转换成一个 C 字符串

625
00:19:16,186 --> 00:19:17,406
所以 我的意思是说 这是

626
00:19:17,406 --> 00:19:18,176
一个非常简单的事情 对吧

627
00:19:18,176 --> 00:19:19,526
我们必须测量 CF 字符串

628
00:19:19,526 --> 00:19:22,206
的长度 然后再将缓冲区

629
00:19:22,206 --> 00:19:23,106
分配到这个有许多

630
00:19:23,106 --> 00:19:25,766
字符的堆上 并将字节

631
00:19:25,766 --> 00:19:26,196
拷贝进去

632
00:19:27,186 --> 00:19:28,876
而且 对了 

633
00:19:28,876 --> 00:19:30,376
我们忘了一件事 就是

634
00:19:30,376 --> 00:19:31,706
C 字符串需要被

635
00:19:31,706 --> 00:19:32,216
空终止

636
00:19:32,966 --> 00:19:35,816
所以我们也要补充这一点

637
00:19:36,046 --> 00:19:38,236
但是我们犯了一个错误

638
00:19:38,236 --> 00:19:38,796
“大小差一”错误

639
00:19:38,856 --> 00:19:40,026
因为当我们计算

640
00:19:40,026 --> 00:19:41,696
所需分配大小时

641
00:19:41,696 --> 00:19:43,036
没有包含这个

642
00:19:43,036 --> 00:19:43,436
空字节

643
00:19:44,706 --> 00:19:46,496
所以实际上我们

644
00:19:46,496 --> 00:19:46,966
溢出了缓冲区

645
00:19:47,566 --> 00:19:50,606
但大部分情况下这对

646
00:19:50,606 --> 00:19:52,006
用户没有任何影响

647
00:19:52,616 --> 00:19:54,266
那是因为堆会

648
00:19:54,266 --> 00:19:55,756
扩大分配

649
00:19:55,756 --> 00:19:56,436
尺寸

650
00:19:56,436 --> 00:19:57,866
在这种情况下 假设我们

651
00:19:57,866 --> 00:19:58,866
将其向上舍入到

652
00:19:58,866 --> 00:20:00,226
16 个字节的下一个倍数

653
00:19:58,866 --> 00:20:00,226
16 个字节的下一个倍数

654
00:20:01,066 --> 00:20:02,176
然后 当我们最后将

655
00:20:02,176 --> 00:20:04,296
空字节写入未使用

656
00:20:04,296 --> 00:20:05,776
空间时 就不会有

657
00:20:05,776 --> 00:20:06,576
任何后果了 对吧

658
00:20:08,436 --> 00:20:11,146
但是让我们看看

659
00:20:11,816 --> 00:20:13,476
当缓冲区中的一个变量

660
00:20:13,476 --> 00:20:15,216
发生变化时会发生什么

661
00:20:15,216 --> 00:20:15,806
那就是用户名

662
00:20:17,166 --> 00:20:19,286
如果用户名的长度

663
00:20:19,286 --> 00:20:20,926
改变了 未使用的

664
00:20:20,926 --> 00:20:22,446
空间量也会改变

665
00:20:22,856 --> 00:20:23,866
而事实证明

666
00:20:23,866 --> 00:20:27,246
如果用户的用户名长度正好是

667
00:20:27,246 --> 00:20:28,986
11个字符 则不会有

668
00:20:28,986 --> 00:20:30,606
任何未使用的空间，那我们最终

669
00:20:30,606 --> 00:20:32,286
会破坏堆上的

670
00:20:32,286 --> 00:20:33,546
相邻对象 导致

671
00:20:33,546 --> 00:20:34,786
代码的其他部分

672
00:20:34,786 --> 00:20:35,246
崩溃

673
00:20:36,076 --> 00:20:37,246
所以这就是为什么

674
00:20:37,246 --> 00:20:39,256
用正常方法捕捉

675
00:20:39,576 --> 00:20:41,886
不到问题 但是“地址杀毒器”

676
00:20:41,886 --> 00:20:43,016
却能够马上

677
00:20:43,016 --> 00:20:43,396
找到它

678
00:20:44,806 --> 00:20:47,056
在这种情况下 这个

679
00:20:47,056 --> 00:20:48,796
缓冲溢出错误可能没有

680
00:20:48,796 --> 00:20:49,996
导致很多安全性后果

681
00:20:50,466 --> 00:20:54,216
但许多其他类似的 Bug

682
00:20:54,396 --> 00:20:55,856
可能会导致可利用的

683
00:20:55,856 --> 00:20:56,566
漏洞

684
00:20:57,326 --> 00:20:58,736
请记住 安全漏洞

685
00:20:59,066 --> 00:21:00,946
通常只有在被利用的时候

686
00:20:59,066 --> 00:21:00,946
通常只有在被利用的时候

687
00:21:01,026 --> 00:21:02,196
才会显现出来

688
00:21:03,146 --> 00:21:04,576
因此 在早期和整个开发过程中

689
00:21:04,576 --> 00:21:06,006
运行的类似于“地址杀毒器”

690
00:21:06,076 --> 00:21:07,596
的工具 可以帮助你

691
00:21:07,596 --> 00:21:09,166
在这些错误到达

692
00:21:09,166 --> 00:21:10,686
客户设备之前将其捕捉

693
00:21:13,676 --> 00:21:15,956
那么 让我们来谈谈

694
00:21:16,256 --> 00:21:17,546
你所掌握的用来捕捉

695
00:21:17,576 --> 00:21:19,416
未定义行为的工具

696
00:21:20,146 --> 00:21:22,616
首先 我们将讨论编译器

697
00:21:22,616 --> 00:21:26,176
Xcode 中的静态分析器

698
00:21:26,206 --> 00:21:29,576
以及杀毒器

699
00:21:29,776 --> 00:21:31,596
“地址杀毒器”“线程杀毒器”

700
00:21:31,596 --> 00:21:33,406
和“未定义行为

701
00:21:33,406 --> 00:21:34,296
杀毒器”

702
00:21:35,236 --> 00:21:36,026
我们先从编译器

703
00:21:36,026 --> 00:21:36,416
开始

704
00:21:37,066 --> 00:21:39,906
编译器会提醒你

705
00:21:39,906 --> 00:21:41,686
部分代码可能有些可疑

706
00:21:41,686 --> 00:21:43,136
并以编译器警告

707
00:21:43,136 --> 00:21:44,226
的形式

708
00:21:44,226 --> 00:21:44,586
提醒你

709
00:21:45,296 --> 00:21:46,286
信不信由你

710
00:21:46,286 --> 00:21:47,196
它们不只是在烦你

711
00:21:48,756 --> 00:21:50,446
Xcode 的每个版本都有

712
00:21:50,536 --> 00:21:51,936
更好的警告功能和

713
00:21:51,936 --> 00:21:53,506
很好的功能 比如 Fixit

714
00:21:53,506 --> 00:21:54,486
所以你只需点按一下

715
00:21:54,486 --> 00:21:54,786
即可解决问题

716
00:21:55,866 --> 00:21:57,366
如果想要了解今年

717
00:21:57,366 --> 00:21:58,766
编译器的新功能

718
00:21:58,766 --> 00:22:00,336
你可以听一下今天下午关于 LLDM 

719
00:21:58,766 --> 00:22:00,336
你可以听一下今天下午关于 LLDM 

720
00:22:00,726 --> 00:22:01,836
新功能的演讲

721
00:22:02,406 --> 00:22:05,786
现在 你可能会想

722
00:22:05,786 --> 00:22:07,286
我的项目是否已经

723
00:22:07,586 --> 00:22:08,606
启用了一组推荐的

724
00:22:08,606 --> 00:22:09,086
警告呢

725
00:22:09,706 --> 00:22:10,656
其实 每次你升级 Xcode 时

726
00:22:10,656 --> 00:22:12,236
都有机会使你的项目

727
00:22:12,236 --> 00:22:13,396
更加的

728
00:22:13,396 --> 00:22:13,946
先进

729
00:22:14,286 --> 00:22:15,376
你也可以随时使用

730
00:22:15,376 --> 00:22:17,356
验证设置选项

731
00:22:17,426 --> 00:22:19,186
进行此操作 这将有助于

732
00:22:19,306 --> 00:22:20,406
系统再次处于良好状态

733
00:22:21,756 --> 00:22:22,556
还有一个我认为

734
00:22:22,556 --> 00:22:23,946
你应该了解的

735
00:22:23,946 --> 00:22:25,296
构建设置是

736
00:22:25,296 --> 00:22:26,646
将警告视为错误

737
00:22:27,806 --> 00:22:29,086
它会像它名字所说的那样

738
00:22:29,086 --> 00:22:29,406
行动

739
00:22:29,816 --> 00:22:31,796
如果你的项目已经编译了

740
00:22:31,796 --> 00:22:33,146
相对较少的警告

741
00:22:33,426 --> 00:22:34,906
那么请考虑开启

742
00:22:34,906 --> 00:22:36,646
这个设置 并强化它的自律

743
00:22:36,646 --> 00:22:38,000
以保持较低的最大并行编译数

744
00:22:41,836 --> 00:22:43,076
现在 我们来谈谈

745
00:22:43,076 --> 00:22:43,526
静态分析仪

746
00:22:44,226 --> 00:22:45,326
你可以将静态分析仪

747
00:22:45,326 --> 00:22:46,646
看作是编译器警告的

748
00:22:46,646 --> 00:22:48,136
加强版本

749
00:22:48,186 --> 00:22:50,546
它会探索你的代码

750
00:22:50,616 --> 00:22:52,556
并发现只有在非常特殊的

751
00:22:52,556 --> 00:22:54,606
条件下才会出现的 Bug

752
00:22:54,606 --> 00:22:55,966
可能在你通常测试

753
00:22:56,066 --> 00:22:58,026
应用程序时都不会遇到的条件

754
00:22:58,776 --> 00:23:01,066
所以我们建议在每次

755
00:22:58,776 --> 00:23:01,066
所以我们建议在每次

756
00:23:01,066 --> 00:23:02,636
编译的过程中进行分析

757
00:23:03,416 --> 00:23:04,386
它有一个专门的构建设置

758
00:23:04,466 --> 00:23:06,416
开启后 在你每次构建

759
00:23:06,416 --> 00:23:08,276
项目时  Xcode 都将运行

760
00:23:08,446 --> 00:23:09,236
一个快速的

761
00:23:09,236 --> 00:23:09,636
分析传递

762
00:23:10,716 --> 00:23:13,116
这可以确保你能

763
00:23:13,256 --> 00:23:14,566
尽快找到

764
00:23:14,566 --> 00:23:16,356
刚刚引入的

765
00:23:16,356 --> 00:23:16,786
Bug

766
00:23:17,936 --> 00:23:19,136
但是分析仪还有一个

767
00:23:19,416 --> 00:23:21,026
更深的模式 可以

768
00:23:21,026 --> 00:23:23,006
随时使用

769
00:23:23,326 --> 00:23:24,136
也是我们建议

770
00:23:24,136 --> 00:23:25,596
在持续集成下

771
00:23:25,596 --> 00:23:27,056
使用的模式 从而

772
00:23:27,056 --> 00:23:28,846
充分利用

773
00:23:28,846 --> 00:23:29,976
静态分析仪的

774
00:23:29,976 --> 00:23:30,676
错误查找功能

775
00:23:34,456 --> 00:23:38,166
接下来我要谈谈

776
00:23:38,776 --> 00:23:39,566
杀毒器

777
00:23:40,656 --> 00:23:43,976
但首先要注意的是

778
00:23:43,976 --> 00:23:45,456
杀毒器是运行时工具

779
00:23:45,456 --> 00:23:47,346
与编译器或静态分析仪不同

780
00:23:47,346 --> 00:23:49,296
为了充分利用

781
00:23:49,296 --> 00:23:51,136
杀毒器 你需要

782
00:23:51,136 --> 00:23:52,446
实际运行一个

783
00:23:52,446 --> 00:23:54,226
只能在实际执行的代码中

784
00:23:55,166 --> 00:23:56,526
找到 Bug 的

785
00:23:56,526 --> 00:23:57,136
练习代码

786
00:23:57,466 --> 00:23:58,196
请记住这一点

787
00:23:59,316 --> 00:24:03,166
它们提供了高度的

788
00:23:59,316 --> 00:24:03,166
它们提供了高度的

789
00:24:03,216 --> 00:24:04,766
错误查找能力

790
00:24:05,076 --> 00:24:07,996
首先 如前所述

791
00:24:07,996 --> 00:24:09,116
我们有“地址杀毒器”

792
00:24:09,766 --> 00:24:11,376
现在 “地址杀毒器”可以捕获

793
00:24:11,376 --> 00:24:12,936
诸如缓冲区溢出

794
00:24:13,006 --> 00:24:14,286
和 Use-After-Free

795
00:24:14,286 --> 00:24:15,156
之类的内存损坏 Bug

796
00:24:15,636 --> 00:24:16,526
而这些与

797
00:24:16,526 --> 00:24:17,396
安全漏洞

798
00:24:17,396 --> 00:24:18,000
高度相关

799
00:24:21,216 --> 00:24:22,956
然后是“线程消毒器”

800
00:24:23,456 --> 00:24:24,796
它可以捕获数据竞争

801
00:24:24,896 --> 00:24:26,026
因此 在你的多线程 App 中

802
00:24:26,706 --> 00:24:28,296
如果两个线程尝试访问

803
00:24:28,356 --> 00:24:30,226
同一片内存 而没有

804
00:24:30,266 --> 00:24:31,716
进行正确的同步 则会发生

805
00:24:31,716 --> 00:24:32,316
数据竞争

806
00:24:33,226 --> 00:24:34,166
但是 “线程消毒器”的一个

807
00:24:34,166 --> 00:24:36,276
好酷地方是 它甚至可以

808
00:24:36,276 --> 00:24:37,556
捕捉到潜在的数据竞争

809
00:24:38,236 --> 00:24:40,056
所以 即使在执行

810
00:24:40,056 --> 00:24:41,486
App 时一切看起来似乎

811
00:24:41,486 --> 00:24:43,526
都很好的情况下“线程消毒器”

812
00:24:43,526 --> 00:24:45,406
都可能会告诉你 两个操作

813
00:24:45,406 --> 00:24:46,526
是否有可能会

814
00:24:46,526 --> 00:24:48,106
以不同的顺序发生 并导致

815
00:24:48,106 --> 00:24:49,000
你的 App 行为不当

816
00:24:52,066 --> 00:24:54,206
Xcode 9 中新增的是

817
00:24:54,206 --> 00:24:55,726
“未定义行为杀毒器”

818
00:24:56,686 --> 00:24:58,726
它可以捕获超过 15 种

819
00:24:58,726 --> 00:25:01,196
不同类型的未定义行为

820
00:24:58,726 --> 00:25:01,196
不同类型的未定义行为

821
00:25:01,196 --> 00:25:02,566
扩展了“地址杀毒器”

822
00:25:02,566 --> 00:25:04,776
或“线程杀毒器”的功能

823
00:25:04,776 --> 00:25:06,206
以便你获得强的 Bug

824
00:25:06,206 --> 00:25:06,516
查找能力

825
00:25:07,236 --> 00:25:08,516
因此 它捕获的一些这些类型的

826
00:25:08,516 --> 00:25:09,736
未定义行为包括

827
00:25:09,736 --> 00:25:11,576
分配整数溢出和

828
00:25:11,576 --> 00:25:13,366
紧密匹配 Bug

829
00:25:13,426 --> 00:25:15,076
这也与某些

830
00:25:15,076 --> 00:25:16,426
环境下的

831
00:25:16,426 --> 00:25:17,496
安全漏洞

832
00:25:17,496 --> 00:25:17,976
有关

833
00:25:17,976 --> 00:25:21,846
所有的杀毒器

834
00:25:21,846 --> 00:25:23,136
都为你提供了丰富而且

835
00:25:23,136 --> 00:25:25,086
富含信息的诊断程序

836
00:25:25,086 --> 00:25:26,936
帮助你锁定 Bug 出现的

837
00:25:26,936 --> 00:25:27,646
根本原因

838
00:25:28,306 --> 00:25:29,776
你可以在“运行时问题

839
00:25:29,776 --> 00:25:30,886
导航器”中找到很多

840
00:25:30,886 --> 00:25:32,956
非常有用的信息

841
00:25:32,956 --> 00:25:36,026
例如在 Bug 执行期间

842
00:25:36,026 --> 00:25:39,756
重要部分的

843
00:25:39,926 --> 00:25:40,266
堆栈回溯信息

844
00:25:40,436 --> 00:25:41,736
所以 我们建议在开发过程中

845
00:25:41,736 --> 00:25:43,736
启动杀毒器

846
00:25:44,066 --> 00:25:45,036
你可以在诊断选项卡下的

847
00:25:45,036 --> 00:25:46,236
Scheme 编辑器中

848
00:25:46,236 --> 00:25:46,486
执行此操作

849
00:25:47,636 --> 00:25:48,576
你也可以在这里

850
00:25:48,576 --> 00:25:50,816
将它启动 来运行你的

851
00:25:50,816 --> 00:25:51,216
单元测试

852
00:25:51,506 --> 00:25:53,356
记住 杀毒器需要

853
00:25:53,636 --> 00:25:55,386
良好的代码覆盖 以便

854
00:25:55,436 --> 00:25:56,926
在整个程序中

855
00:25:56,926 --> 00:25:58,126
查找 Bug  这是

856
00:25:58,126 --> 00:25:59,366
你的单元测试可以提供的

857
00:25:59,956 --> 00:26:02,836
你可以在“使用 Xcode 运行时工具

858
00:25:59,956 --> 00:26:02,836
你可以在“使用 Xcode 运行时工具

859
00:26:02,836 --> 00:26:04,546
查找错误”讲座中

860
00:26:04,546 --> 00:26:05,626
了解更多关于 Xcode 

861
00:26:05,626 --> 00:26:07,686
今年新的杀毒器和

862
00:26:07,686 --> 00:26:09,966
其他的运行时工具

863
00:26:12,416 --> 00:26:15,756
所以 这些是你可以用来

864
00:26:15,756 --> 00:26:16,936
追踪未定义行为的

865
00:26:16,936 --> 00:26:19,056
五个强大工具 还可以

866
00:26:19,056 --> 00:26:21,116
用来解决未定义行为

867
00:26:21,116 --> 00:26:22,786
可能产生的一些

868
00:26:23,246 --> 00:26:23,886
安全漏洞

869
00:26:24,886 --> 00:26:26,026
但在继续之前

870
00:26:26,026 --> 00:26:27,156
还有一件事我想

871
00:26:27,206 --> 00:26:28,786
谈一下 那就是

872
00:26:28,786 --> 00:26:29,536
语言本身

873
00:26:29,536 --> 00:26:33,066
你可以将语言的

874
00:26:33,066 --> 00:26:34,736
使用作为编写

875
00:26:34,736 --> 00:26:36,426
安全可靠代码的

876
00:26:36,426 --> 00:26:37,026
第一道防线

877
00:26:37,816 --> 00:26:39,406
考虑到这一点 

878
00:26:39,406 --> 00:26:41,126
你应该更注重

879
00:26:41,126 --> 00:26:43,076
库和语言为你提供的

880
00:26:43,076 --> 00:26:44,186
安全结构

881
00:26:45,086 --> 00:26:47,246
例如  Objective C 中的

882
00:26:47,246 --> 00:26:48,566
自动引用

883
00:26:48,566 --> 00:26:48,996
计数

884
00:26:49,396 --> 00:26:53,036
或者 C++ 中的智能指针

885
00:26:53,036 --> 00:26:54,206
可以将你从繁重的手动内存

886
00:26:54,206 --> 00:26:56,176
管理中解脱出来

887
00:26:56,176 --> 00:26:57,746
从而避免 Bug

888
00:26:58,796 --> 00:27:00,956
如果你的标准库

889
00:26:58,796 --> 00:27:00,956
如果你的标准库

890
00:27:00,956 --> 00:27:02,116
为你提供容器类 

891
00:27:02,116 --> 00:27:03,906
例如基础的 NSarray

892
00:27:03,906 --> 00:27:06,436
它们会自动

893
00:27:06,436 --> 00:27:07,666
检查其边界 则不必

894
00:27:07,666 --> 00:27:08,746
太过担心

895
00:27:08,746 --> 00:27:09,526
缓冲区溢出

896
00:27:10,086 --> 00:27:13,446
但是 了解你的语言

897
00:27:13,446 --> 00:27:14,706
在安全和保障方面

898
00:27:14,706 --> 00:27:16,836
所做的折衷

899
00:27:16,836 --> 00:27:17,966
才是关键所在

900
00:27:18,596 --> 00:27:20,316
当在你的代码中这些是

901
00:27:20,316 --> 00:27:21,876
非常重要的因素时

902
00:27:22,506 --> 00:27:24,936
请考虑使用 Swift

903
00:27:24,936 --> 00:27:25,956
这种语言从最开始

904
00:27:25,956 --> 00:27:28,186
设计时就消除了

905
00:27:28,186 --> 00:27:30,126
所有类别的

906
00:27:30,126 --> 00:27:30,536
未定义行为

907
00:27:31,496 --> 00:27:32,676
为了向你们介绍更多相关内容

908
00:27:33,256 --> 00:27:34,086
我想邀请我的

909
00:27:34,086 --> 00:27:35,786
同事 Anna 来为大家继续讲解

910
00:27:37,516 --> 00:27:41,566
[掌声] 

911
00:27:42,066 --> 00:27:42,796
&gt;&gt; 谢谢你 Ryan

912
00:27:44,066 --> 00:27:46,816
现在让我们来谈谈

913
00:27:46,876 --> 00:27:49,076
未定义行为和 Swift

914
00:27:49,296 --> 00:27:50,446
你可以在 Swift 中

915
00:27:50,446 --> 00:27:52,986
编写适合性能的代码

916
00:27:52,986 --> 00:27:54,226
这种语言会

917
00:27:54,226 --> 00:27:55,756
进行不同的权衡

918
00:27:55,756 --> 00:27:57,316
同时它被设计在默认的情况下

919
00:27:57,316 --> 00:27:57,816
更加安全

920
00:27:57,976 --> 00:28:00,056
从前面的例子可以看出

921
00:27:57,976 --> 00:28:00,056
从前面的例子可以看出

922
00:28:00,056 --> 00:28:02,426
未定义行为可以

923
00:28:02,506 --> 00:28:04,956
引入非常微妙的错误

924
00:28:04,956 --> 00:28:07,186
从而导致

925
00:28:07,186 --> 00:28:07,786
安全漏洞

926
00:28:08,406 --> 00:28:10,236
这在来自 Swift.org 的这段代码中

927
00:28:10,236 --> 00:28:11,586
进行了简单总结

928
00:28:12,276 --> 00:28:14,116
未定义行为是

929
00:28:14,116 --> 00:28:14,776
安全的敌人

930
00:28:16,076 --> 00:28:17,966
Swift 的安全性

931
00:28:17,966 --> 00:28:18,666
在很多层面都很重要

932
00:28:19,136 --> 00:28:20,846
让我们看看针对 Ryan

933
00:28:20,846 --> 00:28:22,606
和 Fred 谈到的一些

934
00:28:22,896 --> 00:28:24,526
未定义行为的主要来源

935
00:28:24,756 --> 00:28:26,246
如何使用 Swift 中的

936
00:28:26,246 --> 00:28:27,156
不同技术进行解决

937
00:28:27,606 --> 00:28:29,366
更严格的类型系统给了

938
00:28:29,366 --> 00:28:31,426
我们可选的类型

939
00:28:31,516 --> 00:28:33,546
这静态地预防了解引用

940
00:28:33,546 --> 00:28:34,426
空点

941
00:28:35,216 --> 00:28:36,606
初始化变量的使用

942
00:28:36,606 --> 00:28:38,746
通过明确的初始化

943
00:28:38,746 --> 00:28:40,216
被消除了

944
00:28:40,816 --> 00:28:42,466
缓冲区和整数溢出

945
00:28:42,466 --> 00:28:44,776
将会在运行时被检查 就像

946
00:28:44,776 --> 00:28:46,586
Objective C  一样

947
00:28:46,586 --> 00:28:48,336
自动引用计数

948
00:28:48,336 --> 00:28:51,166
是冻结后  Swift 作出的响应

949
00:28:51,296 --> 00:28:52,736
它允许开发人员

950
00:28:52,736 --> 00:28:54,106
不专注于手动管理

951
00:28:54,106 --> 00:28:54,946
内存的问题

952
00:28:55,816 --> 00:28:57,336
让我们更详细地

953
00:28:57,336 --> 00:28:58,026
研究一下

954
00:28:59,546 --> 00:29:01,876
可选类型是 Swift

955
00:28:59,546 --> 00:29:01,876
可选类型是 Swift

956
00:29:01,876 --> 00:29:03,186
对解引用空点的响应

957
00:29:03,556 --> 00:29:05,396
Swift 有两种类型

958
00:29:05,986 --> 00:29:07,726
这里 我们有一个不可选的蛋糕

959
00:29:08,376 --> 00:29:09,806
和一个可选的蛋糕 你可以

960
00:29:09,806 --> 00:29:11,636
认为后者中有蛋糕

961
00:29:11,636 --> 00:29:13,246
或认为它只是一个空

962
00:29:13,246 --> 00:29:13,656
盒子

963
00:29:14,566 --> 00:29:16,286
现在 作为 Swift 工具

964
00:29:16,286 --> 00:29:18,176
我可以向你保证 不确定盒子中是否有蛋糕

965
00:29:18,176 --> 00:29:20,196
这样的 Bug 绝对不会像

966
00:29:20,196 --> 00:29:22,106
这个美味的三层巧克力蛋糕

967
00:29:22,106 --> 00:29:22,926
一样令人愉悦

968
00:29:23,376 --> 00:29:26,676
所以 在使用可选类型的值

969
00:29:26,676 --> 00:29:28,136
之前 须先进行

970
00:29:28,136 --> 00:29:28,396
检查

971
00:29:29,106 --> 00:29:30,346
假设我们有一个函数叫做

972
00:29:30,346 --> 00:29:32,656
接收包 声明将返回

973
00:29:32,656 --> 00:29:34,356
一个可选的

974
00:29:34,356 --> 00:29:34,966
蛋糕类型

975
00:29:36,126 --> 00:29:37,966
不要高兴的太早

976
00:29:37,966 --> 00:29:40,526
除非你已经检查并确定

977
00:29:40,526 --> 00:29:41,636
它不会返回为 nil

978
00:29:42,436 --> 00:29:44,000
有可能蛋糕是个谎言

979
00:29:47,536 --> 00:29:49,636
请注意  Swift 的语法提供了

980
00:29:49,636 --> 00:29:51,466
可以轻松检查可选类型

981
00:29:51,466 --> 00:29:53,796
的功能 特别是能

982
00:29:53,796 --> 00:29:55,356
减轻开发人员

983
00:29:55,356 --> 00:29:56,506
使用此类型的负担

984
00:29:57,846 --> 00:30:00,256
另一个重要的提醒是

985
00:29:57,846 --> 00:30:00,256
另一个重要的提醒是

986
00:30:00,256 --> 00:30:01,776
你不应该滥用第四个

987
00:30:01,776 --> 00:30:04,246
解包操作符

988
00:30:04,246 --> 00:30:05,376
对于这种操作符 如果值为 nil

989
00:30:05,376 --> 00:30:06,726
则会停止该程序的执行

990
00:30:07,556 --> 00:30:09,376
如果 API 已经声明

991
00:30:09,376 --> 00:30:11,306
将返回一个可选类型

992
00:30:11,586 --> 00:30:12,966
就意味着它可能返回 nil

993
00:30:12,966 --> 00:30:14,656
所以要先进行检查

994
00:30:14,946 --> 00:30:16,336
第四个解包操作符

995
00:30:16,336 --> 00:30:18,716
只能在极少数情况下使用

996
00:30:18,716 --> 00:30:20,766
就是当开发人员确定

997
00:30:20,766 --> 00:30:22,266
并且可以保证返回值

998
00:30:22,266 --> 00:30:23,616
永远不会为 nil 的时候

999
00:30:23,906 --> 00:30:25,416
然而 它不能在

1000
00:30:25,416 --> 00:30:26,356
类型系统中被编码

1001
00:30:27,076 --> 00:30:28,436
举个例子 当你从

1002
00:30:28,436 --> 00:30:29,886
App 数据包中

1003
00:30:29,956 --> 00:30:30,906
加载图像资源时

1004
00:30:33,016 --> 00:30:34,866
Swift 还有一个

1005
00:30:34,866 --> 00:30:36,796
隐含解开的可选类型的

1006
00:30:36,796 --> 00:30:37,086
概念

1007
00:30:37,836 --> 00:30:39,576
此类型与可选类型

1008
00:30:39,576 --> 00:30:40,216
类似

1009
00:30:40,426 --> 00:30:41,966
然而 在这里编译器并不强制

1010
00:30:41,966 --> 00:30:45,996
使用这些值

1011
00:30:46,076 --> 00:30:48,736
在使用之前会

1012
00:30:48,736 --> 00:30:50,066
先检查这些值

1013
00:30:50,066 --> 00:30:51,226
不保证编译时间

1014
00:30:52,736 --> 00:30:54,266
请注意 这种类型

1015
00:30:54,266 --> 00:30:55,836
仍然比 C 指针类型

1016
00:30:55,836 --> 00:30:58,746
安全得多 因为使用它的是

1017
00:30:58,746 --> 00:30:59,776
已定义行为

1018
00:31:00,536 --> 00:31:02,016
如果值为 nil  那么程序就会

1019
00:31:02,016 --> 00:31:04,216
停止执行

1020
00:31:04,766 --> 00:31:07,306
这使得该模型更加

1021
00:31:07,306 --> 00:31:07,926
安全

1022
00:31:08,496 --> 00:31:11,216
现在 此类型应该在

1023
00:31:11,276 --> 00:31:12,216
确定有值的属性中

1024
00:31:12,216 --> 00:31:13,606
使用

1025
00:31:13,976 --> 00:31:15,096
然而 它们不能在

1026
00:31:15,096 --> 00:31:16,536
构造函数中被初始化

1027
00:31:17,266 --> 00:31:18,796
你们中的一些人可能会把它用于

1028
00:31:18,796 --> 00:31:19,906
IB 输出口

1029
00:31:20,766 --> 00:31:22,656
然而 隐含解开的可选类型

1030
00:31:22,656 --> 00:31:24,166
的另一个来源是

1031
00:31:24,436 --> 00:31:26,306
来自 Objective C 和

1032
00:31:26,306 --> 00:31:28,076
C 的 API 的指针类型

1033
00:31:29,056 --> 00:31:31,096
这个来源颠覆了

1034
00:31:31,096 --> 00:31:32,786
Swift 可选类型的类型安全性

1035
00:31:33,136 --> 00:31:34,206
那我们能做什么呢

1036
00:31:34,816 --> 00:31:37,506
在 Swift 发布的时候

1037
00:31:37,506 --> 00:31:38,936
我们还向 Apple LLDM 

1038
00:31:38,936 --> 00:31:40,686
编译器添加了

1039
00:31:40,686 --> 00:31:41,246
可空性注解

1040
00:31:41,856 --> 00:31:43,946
在 C 语言中

1041
00:31:44,246 --> 00:31:46,536
这个注释传达了

1042
00:31:46,536 --> 00:31:48,096
API 的意图 但也用于

1043
00:31:48,096 --> 00:31:49,806
增强 Swift 的接口

1044
00:31:50,536 --> 00:31:52,626
它们允许我们将不安全的

1045
00:31:52,656 --> 00:31:54,206
C 指针映射到可选

1046
00:31:54,206 --> 00:31:54,636
类型

1047
00:31:55,406 --> 00:31:56,716
我们来看这个例子

1048
00:31:57,306 --> 00:31:58,936
我们在 NSview 中

1049
00:31:58,966 --> 00:32:00,376
有一个 ancestorSharedWithView 方法

1050
00:31:58,966 --> 00:32:00,376
有一个 ancestorSharedWithView 方法

1051
00:32:00,376 --> 00:32:02,936
如你所见 它需要一个

1052
00:32:02,936 --> 00:32:04,836
非空的参数 因为

1053
00:32:04,836 --> 00:32:06,766
在 nil 和某个值之间

1054
00:32:06,766 --> 00:32:09,166
寻找祖先是没有

1055
00:32:09,166 --> 00:32:09,626
意义的

1056
00:32:10,416 --> 00:32:11,956
另一方面 它的

1057
00:32:11,956 --> 00:32:13,496
返回值为空 因为

1058
00:32:13,496 --> 00:32:15,416
两个视图可能没有

1059
00:32:15,416 --> 00:32:16,646
相同的祖先

1060
00:32:18,526 --> 00:32:20,676
现在 你可以在这里看到

1061
00:32:20,846 --> 00:32:22,626
可空性直接映射到

1062
00:32:22,626 --> 00:32:23,706
Swift 界面

1063
00:32:24,066 --> 00:32:25,276
非空映射到

1064
00:32:25,276 --> 00:32:27,326
非可选值 可空

1065
00:32:27,326 --> 00:32:29,416
映射到可选值

1066
00:32:29,936 --> 00:32:32,296
好消息是 大多数

1067
00:32:32,296 --> 00:32:34,606
Apple API 已经通过

1068
00:32:34,606 --> 00:32:35,956
可空性注解进行了

1069
00:32:35,956 --> 00:32:36,626
审核和注释

1070
00:32:37,666 --> 00:32:40,076
但是 如果你有 API 或

1071
00:32:40,076 --> 00:32:42,046
只是 C 或 Objective C 代码

1072
00:32:42,046 --> 00:32:44,196
与 Swift 进行互操作 你也可以

1073
00:32:44,196 --> 00:32:45,216
从这些注解中

1074
00:32:45,216 --> 00:32:45,906
受益

1075
00:32:46,846 --> 00:32:48,716
此外 你可以使用

1076
00:32:48,966 --> 00:32:50,026
静态分析器

1077
00:32:50,026 --> 00:32:51,996
警告和

1078
00:32:51,996 --> 00:32:53,546
“未定义行为消毒器”等工具

1079
00:32:53,546 --> 00:32:55,746
来找到在你的 C

1080
00:32:55,746 --> 00:32:57,226
或 Objective C 代码中的

1081
00:32:57,226 --> 00:32:59,106
注解方式不一致的地方

1082
00:32:59,766 --> 00:33:01,706
我真的非常喜欢下面这个

1083
00:32:59,766 --> 00:33:01,706
我真的非常喜欢下面这个

1084
00:33:01,706 --> 00:33:03,626
例子 因为它突出

1085
00:33:03,626 --> 00:33:05,256
了 LLDM 编译器， 

1086
00:33:05,256 --> 00:33:07,716
Swift 编译器和

1087
00:33:07,716 --> 00:33:09,796
框架三者如何一起合作的改进

1088
00:33:09,796 --> 00:33:12,000
进一步使整个生态系统受益

1089
00:33:15,126 --> 00:33:17,106
Swift 明确初始化是基于

1090
00:33:17,106 --> 00:33:18,906
深层代码分析的

1091
00:33:18,906 --> 00:33:19,966
诊断功能

1092
00:33:20,746 --> 00:33:23,226
Swift 的编译器保证

1093
00:33:23,226 --> 00:33:26,276
使用值之前

1094
00:33:26,276 --> 00:33:27,266
将它们初始化

1095
00:33:28,236 --> 00:33:30,206
这个检查是通过

1096
00:33:30,206 --> 00:33:32,166
你整个程序的所有分支

1097
00:33:32,166 --> 00:33:32,606
完成的

1098
00:33:33,096 --> 00:33:34,406
我们来看一下这个例子

1099
00:33:34,976 --> 00:33:36,746
在这里 编译器将会检查

1100
00:33:36,786 --> 00:33:39,246
我的实例是否在

1101
00:33:39,586 --> 00:33:42,276
此代码段的 if 和 else 

1102
00:33:42,736 --> 00:33:44,446
分支上初始化 

1103
00:33:44,736 --> 00:33:47,056
然后才允许你继续

1104
00:33:47,056 --> 00:33:49,646
使用此值

1105
00:33:49,646 --> 00:33:51,246
现在 我们来谈谈缓冲区和

1106
00:33:51,246 --> 00:33:52,886
整数溢出 这是

1107
00:33:52,886 --> 00:33:55,196
安全问题的最大

1108
00:33:55,196 --> 00:33:55,506
来源

1109
00:33:56,526 --> 00:33:58,166
溢出只需要增加一个整数

1110
00:33:58,286 --> 00:34:00,596
Swift 就会终止

1111
00:33:58,286 --> 00:34:00,596
Swift 就会终止

1112
00:34:00,596 --> 00:34:01,246
程序的执行

1113
00:34:02,826 --> 00:34:04,126
你可能会问

1114
00:34:04,346 --> 00:34:05,866
为什么运行时检查没有问题呢

1115
00:34:05,946 --> 00:34:07,926
如果出现 Bug 且

1116
00:34:07,926 --> 00:34:10,766
你的缓冲区溢出了

1117
00:34:10,766 --> 00:34:12,706
尽管你的程序会停止运行时检查也会好于

1118
00:34:12,706 --> 00:34:14,186
运行时检查也会好于

1119
00:34:14,186 --> 00:34:14,815
它

1120
00:34:15,496 --> 00:34:17,516
Swift 中的行为

1121
00:34:17,516 --> 00:34:20,005
比 C 中的更加

1122
00:34:20,005 --> 00:34:21,315
一致并具有更高的可调试性

1123
00:34:21,315 --> 00:34:23,376
最重要的是它提供了非常高的

1124
00:34:23,376 --> 00:34:24,876
安全性保证

1125
00:34:25,476 --> 00:34:26,946
缓冲区溢出是不可

1126
00:34:26,946 --> 00:34:27,746
利用的

1127
00:34:28,536 --> 00:34:30,096
它不会导致攻击者

1128
00:34:30,096 --> 00:34:31,946
获得你的程序的

1129
00:34:31,946 --> 00:34:33,255
执行控制能力

1130
00:34:34,775 --> 00:34:36,235
注意 如果你需要用到

1131
00:34:36,235 --> 00:34:38,005
整数包装行为

1132
00:34:38,005 --> 00:34:41,065
仍然可以使用

1133
00:34:41,065 --> 00:34:43,356
溢出操作符 这也是安全的

1134
00:34:43,356 --> 00:34:44,806
而且只是执行

1135
00:34:44,806 --> 00:34:45,255
模数运算

1136
00:34:45,696 --> 00:34:49,926
现在 大家

1137
00:34:49,926 --> 00:34:51,525
可能想到的一个问题是

1138
00:34:51,525 --> 00:34:53,585
Swift 中存在

1139
00:34:53,585 --> 00:34:54,000
未定义行为吗

1140
00:34:55,275 --> 00:34:57,085
答案是肯定的 但是这种

1141
00:34:57,085 --> 00:35:00,216
情况是非常罕见的 并且通常情况下我们

1142
00:34:57,085 --> 00:35:00,216
情况是非常罕见的 并且通常情况下我们

1143
00:35:00,216 --> 00:35:01,876
知道自己在选择不安全的

1144
00:35:01,876 --> 00:35:02,876
行为

1145
00:35:03,396 --> 00:35:06,676
例如我们需要 C 的

1146
00:35:06,676 --> 00:35:07,656
互操作性

1147
00:35:07,656 --> 00:35:09,226
我们需要与这些类型进行

1148
00:35:09,226 --> 00:35:09,906
数据通信

1149
00:35:10,306 --> 00:35:12,276
不安全的指针 不安全的

1150
00:35:12,276 --> 00:35:13,476
可变原始缓冲指针

1151
00:35:14,256 --> 00:35:15,946
注意 你可以仅仅通过查看

1152
00:35:15,946 --> 00:35:17,726
它们的名字就知道

1153
00:35:17,726 --> 00:35:18,786
它们是不安全的

1154
00:35:18,786 --> 00:35:22,336
所以 如果你的应用程序使用 C 

1155
00:35:22,546 --> 00:35:24,746
或 Objective C 

1156
00:35:24,746 --> 00:35:25,916
其他用到这些类型的方式

1157
00:35:25,916 --> 00:35:27,296
我强烈推荐使用

1158
00:35:27,296 --> 00:35:28,336
“地址杀毒器”

1159
00:35:28,576 --> 00:35:30,926
它会发现这种不安全

1160
00:35:31,226 --> 00:35:33,296
可能会给你的代码带来的

1161
00:35:33,296 --> 00:35:34,176
内存损坏

1162
00:35:34,436 --> 00:35:38,266
现在  另一个 Swift

1163
00:35:38,326 --> 00:35:39,566
不安全的例子是

1164
00:35:39,606 --> 00:35:40,366
同时访问

1165
00:35:40,956 --> 00:35:42,676
Swift 正在通过强制执行

1166
00:35:42,676 --> 00:35:44,006
独占内存访问

1167
00:35:44,006 --> 00:35:45,666
将这个典型固定在

1168
00:35:45,666 --> 00:35:46,136
本版本中

1169
00:35:46,846 --> 00:35:48,126
为了更清楚地理解

1170
00:35:48,126 --> 00:35:49,566
让我们来看一个非常简单的

1171
00:35:49,566 --> 00:35:50,276
例子

1172
00:35:50,276 --> 00:35:54,006
在这里我们有一个函数

1173
00:35:54,006 --> 00:35:55,726
含有两个 inout 参数

1174
00:35:56,306 --> 00:35:57,676
inout 表示该函数

1175
00:35:57,676 --> 00:35:58,886
可能会更改这些

1176
00:35:58,886 --> 00:35:59,446
参数的值

1177
00:36:00,216 --> 00:36:02,206
调用此函数并

1178
00:36:02,206 --> 00:36:04,066
将两个指向相同内存的值

1179
00:36:04,066 --> 00:36:06,436
传递给它 可能会导致

1180
00:36:06,436 --> 00:36:07,826
不可预测的行为

1181
00:36:09,176 --> 00:36:10,846
对于你们当中

1182
00:36:10,846 --> 00:36:12,396
熟悉 C 中的 restrict 的人

1183
00:36:12,396 --> 00:36:14,266
这是非常相似的

1184
00:36:14,446 --> 00:36:16,666
但是在 Swift 中 此行为

1185
00:36:16,666 --> 00:36:17,256
是默认开启的

1186
00:36:17,736 --> 00:36:20,646
接下来是一个关于这个问题的

1187
00:36:20,646 --> 00:36:23,116
非常简单抽象

1188
00:36:23,116 --> 00:36:23,716
的例子

1189
00:36:23,716 --> 00:36:25,046
我非常推荐大家

1190
00:36:25,046 --> 00:36:26,716
去看“Swift 新特性”讲座

1191
00:36:26,716 --> 00:36:28,596
以获得更多的例子

1192
00:36:28,596 --> 00:36:30,706
了解在代码中这些问题是如何可见的

1193
00:36:30,706 --> 00:36:32,766
以及它们与代码的关联

1194
00:36:33,716 --> 00:36:36,206
为了解决这个问题 Swift 

1195
00:36:36,396 --> 00:36:38,336
可以选择将其声明为

1196
00:36:38,336 --> 00:36:39,986
未定义行为

1197
00:36:41,036 --> 00:36:43,716
然而 Swift 并

1198
00:36:43,716 --> 00:36:44,766
没有改变 因为

1199
00:36:44,766 --> 00:36:46,376
未定义行为是

1200
00:36:46,376 --> 00:36:47,546
语言中安全性和可实施解决方案

1201
00:36:47,546 --> 00:36:49,246
这些提供强有力保障手段

1202
00:36:49,276 --> 00:36:50,976
的一个敌人

1203
00:36:51,456 --> 00:36:54,506
在这里 找到正确的

1204
00:36:54,506 --> 00:36:55,736
解决方案是一种

1205
00:36:55,736 --> 00:36:55,986
平衡的举动

1206
00:36:56,436 --> 00:36:58,036
最好是静态地诊断一切

1207
00:36:58,036 --> 00:37:00,156
但是通常情况下

1208
00:36:58,036 --> 00:37:00,156
但是通常情况下

1209
00:37:00,156 --> 00:37:01,606
都会造成

1210
00:37:01,606 --> 00:37:03,436
类型系统很难使用

1211
00:37:04,126 --> 00:37:05,506
另一个解决方案是运行时

1212
00:37:05,506 --> 00:37:05,976
检查

1213
00:37:05,976 --> 00:37:07,986
然而 语言运行时

1214
00:37:07,986 --> 00:37:09,146
必须是高性能

1215
00:37:09,716 --> 00:37:10,836
且高效的

1216
00:37:10,976 --> 00:37:12,576
任何额外检查的系统

1217
00:37:12,576 --> 00:37:13,906
都不能占用过高的系统资源

1218
00:37:14,446 --> 00:37:17,366
因此 Swift 项目提出的

1219
00:37:17,366 --> 00:37:19,626
解决方案包括

1220
00:37:19,756 --> 00:37:20,986
紧实语言

1221
00:37:20,986 --> 00:37:22,876
遵循更严格的规则

1222
00:37:23,576 --> 00:37:24,856
以及结合使用

1223
00:37:24,856 --> 00:37:27,176
静态和动态检查

1224
00:37:27,176 --> 00:37:29,876
确保在同一个

1225
00:37:29,876 --> 00:37:31,436
线程中不会发生

1226
00:37:31,866 --> 00:37:32,000
意外共享

1227
00:37:34,296 --> 00:37:35,666
遗憾的是 

1228
00:37:35,666 --> 00:37:37,606
在线程之间检查访问独占性

1229
00:37:37,606 --> 00:37:39,566
成本太高

1230
00:37:40,146 --> 00:37:41,276
这里所做的折衷

1231
00:37:41,276 --> 00:37:43,196
是依靠工具

1232
00:37:43,586 --> 00:37:45,116
特别是“线程杀毒器”

1233
00:37:45,396 --> 00:37:47,306
以捕捉涉及

1234
00:37:47,306 --> 00:37:50,326
多线程访问的违规行为

1235
00:37:50,496 --> 00:37:51,736
一般来说 使用“线程消毒器”

1236
00:37:51,736 --> 00:37:53,366
对你的 Swift 代码

1237
00:37:53,366 --> 00:37:55,346
非常有益 因为数据竞争

1238
00:37:55,346 --> 00:37:57,686
和访问竞争是 Swift 中的未定义行为 

1239
00:37:57,686 --> 00:37:59,406
并且可能

1240
00:37:59,406 --> 00:38:00,596
导致内存损坏

1241
00:37:59,406 --> 00:38:00,596
导致内存损坏

1242
00:38:01,196 --> 00:38:02,846
有关此工具的更多信息

1243
00:38:02,846 --> 00:38:05,106
请观看“使用 Xcode 运行时工具查找 Bug”

1244
00:38:05,316 --> 00:38:06,986
的演讲

1245
00:38:07,386 --> 00:38:10,626
总之 安全是 Swift 的一个设计

1246
00:38:10,626 --> 00:38:11,156
选择

1247
00:38:11,396 --> 00:38:12,716
该语言提供了许多

1248
00:38:12,716 --> 00:38:14,426
解决方案来避免未定义行为

1249
00:38:14,426 --> 00:38:16,466
并阻止开发人员

1250
00:38:16,466 --> 00:38:18,836
引入微妙和

1251
00:38:18,836 --> 00:38:19,906
可利用的 Bug

1252
00:38:20,596 --> 00:38:24,266
今天我们讨论了未定义行为

1253
00:38:24,266 --> 00:38:25,906
以及不同的语言如何

1254
00:38:25,906 --> 00:38:26,986
解决这个问题

1255
00:38:27,536 --> 00:38:29,866
C 语言使用未定义行为

1256
00:38:30,036 --> 00:38:31,916
进行轻量化和

1257
00:38:31,916 --> 00:38:32,806
优化

1258
00:38:33,436 --> 00:38:34,736
然而 我们已经看到了

1259
00:38:34,736 --> 00:38:36,486
这可能会导致非常微妙和

1260
00:38:36,486 --> 00:38:38,306
难以调试的 Bug  甚至会

1261
00:38:38,306 --> 00:38:39,806
引入安全漏洞

1262
00:38:40,366 --> 00:38:42,386
Swift 选择遵循不同的

1263
00:38:42,606 --> 00:38:44,116
路径 并且被设计成

1264
00:38:44,116 --> 00:38:45,176
在默认情况下更安全

1265
00:38:46,596 --> 00:38:48,036
最后 无论你

1266
00:38:48,036 --> 00:38:49,646
选择哪种语言 请使用所有

1267
00:38:49,646 --> 00:38:51,156
可用的工具作为

1268
00:38:51,156 --> 00:38:52,516
应用程序发布和测试过程的

1269
00:38:52,516 --> 00:38:52,946
一部分

1270
00:38:53,416 --> 00:38:55,076
这将使你的应用程序更加

1271
00:38:55,076 --> 00:38:57,000
安全可靠

1272
00:39:00,086 --> 00:39:01,136
这里是我们

1273
00:39:01,136 --> 00:39:02,226
今天提到的一些

1274
00:39:02,226 --> 00:39:02,636
相关会议

1275
00:39:03,176 --> 00:39:04,896
非常感谢 祝你

1276
00:39:04,896 --> 00:39:06,660
愉快地度过今天接下来的时间

1277
00:39:07,516 --> 00:39:10,500
[掌声]
