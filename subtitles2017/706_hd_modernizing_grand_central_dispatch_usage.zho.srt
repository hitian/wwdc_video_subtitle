1
00:00:17,818 --> 00:00:21,255
<c.magenta>（现代化GCD用法</c>

2
00:00:22,356 --> 00:00:23,524
<c.magenta>早上好 欢迎参加</c>

3
00:00:23,590 --> 00:00:26,360
<c.magenta>现代化中心调度GCD用法演讲</c>

4
00:00:26,426 --> 00:00:28,595
<c.magenta>我是Daniel Chimene</c>

5
00:00:28,862 --> 00:00:31,698
<c.magenta>我和我的同事们今天要跟大家谈谈</c>

6
00:00:31,765 --> 00:00:34,234
<c.magenta>如何利用中心调度</c>

7
00:00:34,468 --> 00:00:36,103
<c.magenta>在你的应用中获得最佳性能</c>

8
00:00:37,471 --> 00:00:38,438
<c.magenta>作为应用开发人员</c>

9
00:00:38,772 --> 00:00:40,974
<c.magenta>你会花成百上千个小时</c>

10
00:00:41,041 --> 00:00:43,410
<c.magenta>为你的用户打造出色体验</c>

11
00:00:43,477 --> 00:00:45,612
<c.magenta>利用你强大的设备</c>

12
00:00:46,613 --> 00:00:49,349
<c.magenta>你想让你的用户拥有出色的体验</c>

13
00:00:49,583 --> 00:00:50,684
<c.magenta>不仅是在一台设备上</c>

14
00:00:51,218 --> 00:00:53,854
<c.magenta>而是在Apple的各种设备上</c>

15
00:00:56,723 --> 00:01:00,394
<c.magenta>GCD的目的是帮助你动态地</c>

16
00:00:56,723 --> 00:01:00,394
<c.magenta>GCD的目的是帮助你动态地</c>

17
00:01:00,460 --> 00:01:03,697
<c.magenta>从单核的Apple Watch</c>

18
00:01:04,431 --> 00:01:06,033
<c.magenta>你不必太过担心</c>

19
00:01:06,099 --> 00:01:08,569
<c.magenta>你的用户运行的是哪种硬件</c>

20
00:01:09,036 --> 00:01:10,737
<c.magenta>但会出现不确定的模式</c>

21
00:01:10,804 --> 00:01:14,241
<c.magenta>可能会影响你代码的可扩展性和效率</c>

22
00:01:14,308 --> 00:01:16,310
<c.magenta>无论是高端还是低端都一样</c>

23
00:01:17,177 --> 00:01:18,879
<c.magenta>这也是我们今天要谈的内容</c>

24
00:01:19,313 --> 00:01:20,647
<c.magenta>我们要帮助你确保</c>

25
00:01:20,714 --> 00:01:22,649
<c.magenta>你放到应用中的代码</c>

26
00:01:22,716 --> 00:01:24,818
<c.magenta>会给用户打造一种出色的体验</c>

27
00:01:25,485 --> 00:01:27,387
<c.magenta>可以在各种设备间进行转换</c>

28
00:01:28,989 --> 00:01:32,392
<c.magenta>你可能用过GCD API</c>

29
00:01:32,926 --> 00:01:35,696
<c.magenta>还有其它创建提示</c>

30
00:01:36,230 --> 00:01:39,433
<c.magenta>这些只是并发性技术的一些接口</c>

31
00:01:39,499 --> 00:01:41,235
<c.magenta>我们叫作中心调度GCD</c>

32
00:01:41,668 --> 00:01:44,805
<c.magenta>今天我们要看看GCD底层的东西</c>

33
00:01:45,405 --> 00:01:48,041
<c.magenta>这是一场充斥着各种信息的高级演讲</c>

34
00:01:48,342 --> 00:01:51,245
<c.magenta>那么让我们立即开始吧</c>

35
00:01:52,012 --> 00:01:53,680
<c.magenta>我们的设备中出色的芯片</c>

36
00:01:53,747 --> 00:01:55,983
<c.magenta>随着时间的推移速度变得越来越快</c>

37
00:01:56,250 --> 00:01:57,384
<c.magenta>然而 速度快</c>

38
00:01:57,451 --> 00:02:00,220
<c.magenta>并不只是因为芯片自身变快了</c>

39
00:01:57,451 --> 00:02:00,220
<c.magenta>并不只是因为芯片自身变快了</c>

40
00:02:00,287 --> 00:02:03,090
<c.magenta>还因为它们在运行你的代码方面</c>

41
00:02:03,156 --> 00:02:04,224
<c.magenta>并且它们</c>

42
00:02:04,291 --> 00:02:07,160
<c.magenta>随着时间的过去也在学习你代码的作用</c>

43
00:02:10,430 --> 00:02:14,067
<c.magenta>然而如果你的代码远离了内核</c>

44
00:02:14,701 --> 00:02:16,570
<c.magenta>那么它将不再利用</c>

45
00:02:16,637 --> 00:02:18,906
<c.magenta>那个内核所创建的历史</c>

46
00:02:18,972 --> 00:02:22,509
<c.magenta>你可能会把性能丢开</c>

47
00:02:23,243 --> 00:02:25,712
<c.magenta>我们在我们自己的框架中</c>

48
00:02:25,779 --> 00:02:27,681
<c.magenta>当我们应用一些优化技巧时</c>

49
00:02:27,748 --> 00:02:29,550
<c.magenta>我们今天也要讨论这些优化技巧</c>

50
00:02:29,616 --> 00:02:34,655
<c.magenta>我们看到简单的变更就会很大程度上</c>

51
00:02:34,721 --> 00:02:36,790
<c.magenta>（速度快了1.3倍</c>

52
00:02:36,857 --> 00:02:38,525
<c.magenta>那么通过这些技巧</c>

53
00:02:38,592 --> 00:02:41,962
<c.magenta>你可以用更少量的工作</c>

54
00:02:42,663 --> 00:02:44,932
<c.magenta>今天我们要深入研究</c>

55
00:02:44,998 --> 00:02:48,068
<c.magenta>我们系统底层是如何运作你的代码的</c>

56
00:02:48,135 --> 00:02:50,470
<c.magenta>那么你可以调整你的代码以最好地利用</c>

57
00:02:50,537 --> 00:02:51,905
<c.magenta>GCD所提供的功能</c>

58
00:02:52,639 --> 00:02:54,308
<c.magenta>我们今天要讨论一些东西</c>

59
00:02:55,075 --> 00:02:57,611
<c.magenta>首先我们要讨论如何最好地表达</c>

60
00:02:57,945 --> 00:02:59,379
<c.magenta>并行和并发</c>

61
00:03:00,013 --> 00:03:02,049
<c.magenta>如何选择最佳方式</c>

62
00:03:02,115 --> 00:03:04,651
<c.magenta>向GCD表达并发</c>

63
00:03:05,519 --> 00:03:07,721
<c.magenta>我们要介绍一下统一队列身份</c>

64
00:03:07,788 --> 00:03:09,823
<c.magenta>这是GCD底层的一个重要改进</c>

65
00:03:09,890 --> 00:03:11,592
<c.magenta>是我们今年发布的</c>

66
00:03:11,658 --> 00:03:14,061
<c.magenta>我们最后要给你们演示</c>

67
00:03:14,127 --> 00:03:15,662
<c.magenta>通过仪表</c>

68
00:03:16,630 --> 00:03:19,433
<c.magenta>那么让我们先讨论并行和并发</c>

69
00:03:20,400 --> 00:03:21,268
<c.magenta>那么…</c>

70
00:03:23,637 --> 00:03:25,138
<c.magenta>为了演讲的目的</c>

71
00:03:25,205 --> 00:03:28,675
<c.magenta>我们要谈谈平行</c>

72
00:03:29,309 --> 00:03:32,346
<c.magenta>同时在多个不同的内核上并行执行</c>

73
00:03:32,713 --> 00:03:35,048
<c.magenta>并发是关于你如何构造</c>

74
00:03:35,115 --> 00:03:38,352
<c.magenta>你应用的独立组件使其同时运行</c>

75
00:03:39,119 --> 00:03:41,121
<c.magenta>那么区分这两个概念有一个简单的方式</c>

76
00:03:41,188 --> 00:03:42,089
<c.magenta>就是明白</c>

77
00:03:42,155 --> 00:03:44,758
<c.magenta>并行通常需要多内核</c>

78
00:03:44,825 --> 00:03:46,560
<c.magenta>你想同时使用全部的内核</c>

79
00:03:46,627 --> 00:03:49,463
<c.magenta>而并发甚至可以在单核系统中实现</c>

80
00:03:49,530 --> 00:03:51,532
<c.magenta>它是关于你如何介入</c>

81
00:03:51,865 --> 00:03:53,867
<c.magenta>作为应用的一部分的不同任务</c>

82
00:03:53,934 --> 00:03:55,869
<c.magenta>那么让我们从并行开始谈</c>

83
00:03:56,303 --> 00:03:58,839
<c.magenta>以及当你在写应用时如何使用它</c>

84
00:03:59,673 --> 00:04:00,607
<c.magenta>那么</c>

85
00:03:59,673 --> 00:04:00,607
<c.magenta>那么</c>

86
00:04:00,941 --> 00:04:04,545
<c.magenta>让我们想象一下你正在开发一款应用</c>

87
00:04:04,845 --> 00:04:07,881
<c.magenta>你希望能利用Mac Pro上的多核</c>

88
00:04:07,948 --> 00:04:09,716
<c.magenta>来更快地处理这些图片</c>

89
00:04:10,350 --> 00:04:12,719
<c.magenta>于是你就把图片分别放到组块中</c>

90
00:04:13,520 --> 00:04:15,789
<c.magenta>并且让每个内核</c>

91
00:04:17,558 --> 00:04:18,492
<c.magenta>并行地处理这些组块</c>

92
00:04:19,392 --> 00:04:20,527
<c.magenta>这就提升了你的速度</c>

93
00:04:20,594 --> 00:04:22,629
<c.magenta>因为多核同时</c>

94
00:04:22,696 --> 00:04:24,331
<c.magenta>处理图片的不同部分</c>

95
00:04:25,332 --> 00:04:27,534
<c.magenta>那么你要如何实施呢？嗯 首先</c>

96
00:04:28,802 --> 00:04:30,237
<c.magenta>你应该停下来思考</c>

97
00:04:30,437 --> 00:04:32,606
<c.magenta>你是否可以利用我们系统框架</c>

98
00:04:33,407 --> 00:04:36,443
<c.magenta>比如Accelerate框架有内嵌支持</c>

99
00:04:36,743 --> 00:04:39,313
<c.magenta>可以支持高级图片算法的并行执行</c>

100
00:04:40,013 --> 00:04:44,218
<c.magenta>Metal和Core图片</c>

101
00:04:45,853 --> 00:04:48,722
<c.magenta>嗯 假如说你已经决定自己实施</c>

102
00:04:48,789 --> 00:04:52,159
<c.magenta>GCD会给你提供一个工具</c>

103
00:04:52,960 --> 00:04:56,897
<c.magenta>你向GCD表达并行的模式是使用一个</c>

104
00:04:57,231 --> 00:04:59,733
<c.magenta>它会让框架优化并行</c>

105
00:04:59,967 --> 00:05:01,101
<c.magenta>因为它知道你正在尝试</c>

106
00:04:59,967 --> 00:05:01,101
<c.magenta>因为它知道你正在尝试</c>

107
00:05:01,168 --> 00:05:03,637
<c.magenta>利用所有内核实现并行计算</c>

108
00:05:04,571 --> 00:05:07,574
<c.magenta>concurrentPerform是一个循环并行</c>

109
00:05:07,641 --> 00:05:10,644
<c.magenta>会自动负载平衡系统中</c>

110
00:05:11,211 --> 00:05:14,481
<c.magenta>Swift 当你与Swift一起用时</c>

111
00:05:14,548 --> 00:05:17,050
<c.magenta>运行你所有计算的正确情境</c>

112
00:05:17,117 --> 00:05:18,886
<c.magenta>今年 我们把同样的功能</c>

113
00:05:18,952 --> 00:05:21,121
<c.magenta>引入了Objective C的接口</c>

114
00:05:21,755 --> 00:05:23,557
<c.magenta>通过调度应用自动关键字来调度应用</c>

115
00:05:24,324 --> 00:05:25,826
<c.magenta>这替换了Q参数</c>

116
00:05:26,426 --> 00:05:28,028
<c.magenta>允许系统</c>

117
00:05:28,095 --> 00:05:30,397
<c.magenta>自动选择运行你代码的正确情境</c>

118
00:05:31,331 --> 00:05:33,367
<c.magenta>那么现在让我们看一下另一个参数</c>

119
00:05:33,433 --> 00:05:34,868
<c.magenta>即重复技术</c>

120
00:05:35,202 --> 00:05:38,505
<c.magenta>这是在系统中</c>

121
00:05:39,339 --> 00:05:41,041
<c.magenta>在这里你要如何选择一个适当的值呢？</c>

122
00:05:41,775 --> 00:05:45,212
<c.magenta>你可能认为适当的值应该是内核的数量</c>

123
00:05:45,279 --> 00:05:46,146
<c.magenta>让我们想象一下</c>

124
00:05:47,047 --> 00:05:49,850
<c.magenta>我们正在一个三核系统中</c>

125
00:05:50,017 --> 00:05:51,685
<c.magenta>在这里你可以看到理想情况</c>

126
00:05:52,119 --> 00:05:54,388
<c.magenta>也就是三个代码块在全部</c>

127
00:05:55,022 --> 00:05:57,157
<c.magenta>但现实世界总是不会这么完美</c>

128
00:05:57,791 --> 00:05:59,393
<c.magenta>如果第三个内核</c>

129
00:05:59,459 --> 00:06:01,128
<c.magenta>被占用执行UI渲染会发生什么呢？</c>

130
00:05:59,459 --> 00:06:01,128
<c.magenta>被占用执行UI渲染会发生什么呢？</c>

131
00:06:03,297 --> 00:06:04,765
<c.magenta>嗯 情况就会变成这样</c>

132
00:06:04,831 --> 00:06:08,569
<c.magenta>负载平衡器必须得把那第三个代码块</c>

133
00:06:08,936 --> 00:06:11,438
<c.magenta>以便执行第三个代码块</c>

134
00:06:11,905 --> 00:06:13,874
<c.magenta>我们的CPU闲置</c>

135
00:06:13,941 --> 00:06:17,778
<c.magenta>我们可以利用这段时间</c>

136
00:06:18,145 --> 00:06:20,080
<c.magenta>那么相反 我们的工作花的时间更长</c>

137
00:06:21,281 --> 00:06:22,482
<c.magenta>那么如何修复呢？</c>

138
00:06:22,549 --> 00:06:25,118
<c.magenta>嗯 我们可以增加重复计数</c>

139
00:06:26,486 --> 00:06:28,622
<c.magenta>并给负载平衡器提供更多的灵活性</c>

140
00:06:29,723 --> 00:06:31,325
<c.magenta>看起来不错 堵上那个窟窿了</c>

141
00:06:31,859 --> 00:06:35,662
<c.magenta>但其实这里还有一个窟窿</c>

142
00:06:36,196 --> 00:06:37,998
<c.magenta>我们也可以利用那段时间</c>

143
00:06:39,766 --> 00:06:44,004
<c.magenta>那么正如提姆在周一的演讲上所说的</c>

144
00:06:46,740 --> 00:06:50,110
<c.magenta>然后我们就填上这个窟窿了</c>

145
00:06:50,410 --> 00:06:53,113
<c.magenta>我们用了系统上全部可用的资源</c>

146
00:06:53,614 --> 00:06:56,049
<c.magenta>这是一个非常简单的例子</c>

147
00:06:56,717 --> 00:06:58,151
<c.magenta>要处理实际的复杂性</c>

148
00:06:58,552 --> 00:07:00,521
<c.magenta>你得使用更大的量级</c>

149
00:06:58,552 --> 00:07:00,521
<c.magenta>你得使用更大的量级</c>

150
00:07:00,854 --> 00:07:02,022
<c.magenta>比如1000</c>

151
00:07:03,123 --> 00:07:04,825
<c.magenta>你可以使用足够大的重复计数</c>

152
00:07:05,092 --> 00:07:07,961
<c.magenta>以便负载平衡器可以灵活地</c>

153
00:07:08,028 --> 00:07:10,797
<c.magenta>并最大限度地利用</c>

154
00:07:10,864 --> 00:07:12,366
<c.magenta>系统中可用的资源</c>

155
00:07:13,100 --> 00:07:16,637
<c.magenta>然而你应该确保平衡</c>

156
00:07:16,703 --> 00:07:20,674
<c.magenta>相对于并行循环中每个代码块</c>

157
00:07:21,708 --> 00:07:24,311
<c.magenta>请记住每个CPU并不总是全部可用</c>

158
00:07:24,478 --> 00:07:27,247
<c.magenta>系统中同时还运行着许多任务</c>

159
00:07:28,248 --> 00:07:31,485
<c.magenta>此外 并不是每个辅助线程</c>

160
00:07:32,452 --> 00:07:35,255
<c.magenta>那么回顾一下 如果你有并行问题</c>

161
00:07:35,956 --> 00:07:38,559
<c.magenta>确保利用一切可用的系统框架</c>

162
00:07:38,625 --> 00:07:40,994
<c.magenta>你可以用它们的能力来解决你的问题</c>

163
00:07:42,062 --> 00:07:44,631
<c.magenta>此外 确保利用自动负载平衡</c>

164
00:07:44,698 --> 00:07:46,300
<c.magenta>位于concurrentPerform内</c>

165
00:07:46,366 --> 00:07:48,735
<c.magenta>给它提供一定的灵活性以最好地利用它</c>

166
00:07:50,003 --> 00:07:51,638
<c.magenta>那么这是关于并行的讨论</c>

167
00:07:51,939 --> 00:07:55,242
<c.magenta>现在让我们回到主话题上 即并发</c>

168
00:07:56,610 --> 00:07:58,445
<c.magenta>那么并发</c>

169
00:07:59,580 --> 00:08:01,782
<c.magenta>让我们想象一下</c>

170
00:07:59,580 --> 00:08:01,782
<c.magenta>让我们想象一下</c>

171
00:08:02,883 --> 00:08:05,853
<c.magenta>你会如何构造它？嗯 你从把它拆解到</c>

172
00:08:05,919 --> 00:08:08,555
<c.magenta>组成应用的独立子系统中开始</c>

173
00:08:09,223 --> 00:08:11,058
<c.magenta>思考一下如何把新闻应用拆解</c>

174
00:08:11,358 --> 00:08:14,628
<c.magenta>到其独立的子系统中</c>

175
00:08:14,695 --> 00:08:16,630
<c.magenta>是渲染UI的 这就是主线程</c>

176
00:08:16,697 --> 00:08:20,200
<c.magenta>你可能有一个存储这些文章的数据库</c>

177
00:08:20,734 --> 00:08:22,369
<c.magenta>且你可能还有一个联网的子系统</c>

178
00:08:22,436 --> 00:08:24,137
<c.magenta>从网络上获取这些文章</c>

179
00:08:24,738 --> 00:08:26,406
<c.magenta>为了给你一个更好的描述</c>

180
00:08:26,473 --> 00:08:28,842
<c.magenta>以及如何拆解到子系统中</c>

181
00:08:29,243 --> 00:08:32,980
<c.magenta>让我们在一个现代化系统上</c>

182
00:08:33,413 --> 00:08:39,019
<c.magenta>那么假如这个时间轴</c>

183
00:08:39,086 --> 00:08:40,988
<c.magenta>让我们想象一下</c>

184
00:08:41,054 --> 00:08:44,658
<c.magenta>其它CPU都忙于其它任务</c>

185
00:08:44,925 --> 00:08:47,694
<c.magenta>无论什么时候只能有一个线程</c>

186
00:08:48,529 --> 00:08:50,731
<c.magenta>那么当用户在新闻应用中点击按钮</c>

187
00:08:51,031 --> 00:08:53,534
<c.magenta>并刷新文章列表时会发生什么？</c>

188
00:08:54,134 --> 00:08:56,870
<c.magenta>嗯 这些界面会渲染对那个按钮的响应</c>

189
00:08:56,937 --> 00:08:59,406
<c.magenta>然后给数据库发送异步指令</c>

190
00:09:00,140 --> 00:09:02,910
<c.magenta>然后数据库就决定它需要刷新文章</c>

191
00:09:02,976 --> 00:09:06,013
<c.magenta>它会对联网子系统选择另一个命令</c>

192
00:09:06,880 --> 00:09:09,616
<c.magenta>然而在这点上 用户再次触摸应用</c>

193
00:09:09,917 --> 00:09:13,854
<c.magenta>因为数据库脱离应用的主线程</c>

194
00:09:14,288 --> 00:09:17,457
<c.magenta>OS可以立即切换CPU处理UI线程</c>

195
00:09:17,791 --> 00:09:19,560
<c.magenta>它可以立即响应用户</c>

196
00:09:19,626 --> 00:09:22,462
<c.magenta>而无需等待数据库线程执行完成</c>

197
00:09:23,630 --> 00:09:26,400
<c.magenta>这就是把工作从主线程上脱离的好处</c>

198
00:09:28,468 --> 00:09:30,537
<c.magenta>当用户界面完成响应时</c>

199
00:09:30,971 --> 00:09:33,574
<c.magenta>CPU就可以切换回数据库线程</c>

200
00:09:33,740 --> 00:09:35,876
<c.magenta>然后完成联网任务</c>

201
00:09:36,510 --> 00:09:38,745
<c.magenta>像这样利用并发</c>

202
00:09:39,112 --> 00:09:40,948
<c.magenta>可以让你创建响应性的应用</c>

203
00:09:41,215 --> 00:09:43,851
<c.magenta>主线程总是响应用户的行动</c>

204
00:09:44,084 --> 00:09:47,487
<c.magenta>而无需等待应用的其它部分完成</c>

205
00:09:48,155 --> 00:09:50,591
<c.magenta>那么让我们看看对于CPU来说</c>

206
00:09:51,425 --> 00:09:52,826
<c.magenta>上边的这些白线</c>

207
00:09:52,893 --> 00:09:55,195
<c.magenta>显示的是子系统之间的内容切换</c>

208
00:09:55,963 --> 00:09:58,031
<c.magenta>接触开关是当CPU</c>

209
00:09:58,098 --> 00:10:01,335
<c.magenta>在不同的子系统之间</c>

210
00:09:58,098 --> 00:10:01,335
<c.magenta>在不同的子系统之间</c>

211
00:10:01,902 --> 00:10:05,072
<c.magenta>如果你想这在你的应用中是什么样的</c>

212
00:10:05,138 --> 00:10:06,940
<c.magenta>你可以使用仪表系统进行追踪</c>

213
00:10:07,007 --> 00:10:09,643
<c.magenta>可以给你显示CPU和线程正在做什么</c>

214
00:10:09,710 --> 00:10:11,178
<c.magenta>当它们在你的应用中运行时</c>

215
00:10:11,678 --> 00:10:13,380
<c.magenta>如果你想了解更多信息</c>

216
00:10:13,447 --> 00:10:15,616
<c.magenta>你可以参看去年的</c>

217
00:10:15,682 --> 00:10:18,385
<c.magenta>仪表团队描述了你该如何使用系统追踪</c>

218
00:10:19,286 --> 00:10:23,557
<c.magenta>那么这个情境切换的概念是</c>

219
00:10:24,024 --> 00:10:26,660
<c.magenta>让我们看看何时会发生这些情境切换</c>

220
00:10:26,727 --> 00:10:27,861
<c.magenta>以及导致情境切换的原因</c>

221
00:10:28,362 --> 00:10:29,229
<c.magenta>嗯</c>

222
00:10:29,596 --> 00:10:31,965
<c.magenta>当高优先级线程需要CPU时会发生</c>

223
00:10:32,032 --> 00:10:33,100
<c.magenta>正如我们之前看到过的</c>

224
00:10:33,166 --> 00:10:35,402
<c.magenta>UI线程会先于数据库线程</c>

225
00:10:35,969 --> 00:10:38,805
<c.magenta>当线程结束当前任务时</c>

226
00:10:39,306 --> 00:10:41,341
<c.magenta>或等待取得资源时</c>

227
00:10:41,742 --> 00:10:44,178
<c.magenta>或等待异步请求完成时也会发生</c>

228
00:10:44,845 --> 00:10:47,147
<c.magenta>然而 通过并发的强大力量</c>

229
00:10:47,481 --> 00:10:49,550
<c.magenta>也会伴随着强大的责任</c>

230
00:10:49,616 --> 00:10:51,585
<c.magenta>你拥有太多好东西了</c>

231
00:10:52,886 --> 00:10:56,323
<c.magenta>假如说你正在网络</c>

232
00:10:56,890 --> 00:10:57,824
<c.magenta>在你的CPU上</c>

233
00:10:58,392 --> 00:10:59,560
<c.magenta>切换几个情境没问题</c>

234
00:10:59,626 --> 00:11:02,062
<c.magenta>这就是并发的能力所在</c>

235
00:10:59,626 --> 00:11:02,062
<c.magenta>这就是并发的能力所在</c>

236
00:11:02,629 --> 00:11:05,132
<c.magenta>然而如果你要做上千次切换</c>

237
00:11:05,199 --> 00:11:08,202
<c.magenta>连续迅速切换 你就有大麻烦啦</c>

238
00:11:08,268 --> 00:11:09,670
<c.magenta>你就开始丢失性能</c>

239
00:11:09,937 --> 00:11:12,673
<c.magenta>因为这里的每一条白线</c>

240
00:11:13,073 --> 00:11:14,641
<c.magenta>情境切换的消耗也增加了</c>

241
00:11:14,708 --> 00:11:17,144
<c.magenta>并不只是说执行情境切换的时间</c>

242
00:11:17,477 --> 00:11:19,313
<c.magenta>还有内核所创建的历史</c>

243
00:11:19,379 --> 00:11:21,548
<c.magenta>它必须得在每次情境切换后</c>

244
00:11:23,550 --> 00:11:25,485
<c.magenta>你可能还会有其它影响因素</c>

245
00:11:25,552 --> 00:11:29,489
<c.magenta>比如可能还有其它线程</c>

246
00:11:30,490 --> 00:11:33,126
<c.magenta>每次切换情境时</c>

247
00:11:33,193 --> 00:11:34,962
<c.magenta>剩余的线程队列都必须等待疏通</c>

248
00:11:35,028 --> 00:11:38,932
<c.magenta>那么你可能会被队列中的其它线程</c>

249
00:11:39,600 --> 00:11:42,736
<c.magenta>那么让我们看看</c>

250
00:11:43,637 --> 00:11:46,607
<c.magenta>那么今天我们要讲的是三个主要原因</c>

251
00:11:46,907 --> 00:11:50,577
<c.magenta>第一是反复等待独占资源</c>

252
00:11:50,844 --> 00:11:53,614
<c.magenta>在独立的运作之间反复切换</c>

253
00:11:53,680 --> 00:11:56,216
<c.magenta>并且在线程间反复跳过某个运作</c>

254
00:11:56,950 --> 00:11:59,820
<c.magenta>你注意到我反复几次提到了反复这个词</c>

255
00:12:00,587 --> 00:12:01,555
<c.magenta>我是刻意这么说的</c>

256
00:12:03,257 --> 00:12:05,225
<c.magenta>情境切换几次是没问题的</c>

257
00:12:05,559 --> 00:12:08,395
<c.magenta>这就是并发的作用</c>

258
00:12:08,662 --> 00:12:12,065
<c.magenta>然而当你重复切换太多次时</c>

259
00:12:13,400 --> 00:12:15,402
<c.magenta>那么让我们来看第一种情况</c>

260
00:12:15,469 --> 00:12:17,838
<c.magenta>也就是独占资源</c>

261
00:12:18,672 --> 00:12:19,873
<c.magenta>什么时候会发生这种情况？</c>

262
00:12:20,407 --> 00:12:24,845
<c.magenta>嗯 这种发生的主要情况是</c>

263
00:12:24,912 --> 00:12:28,182
<c.magenta>而大量线程都尝试获取那个锁定时</c>

264
00:12:29,483 --> 00:12:31,818
<c.magenta>那么如何了解你的应用中</c>

265
00:12:31,885 --> 00:12:33,787
<c.magenta>嗯 我们可以返回到系统追踪</c>

266
00:12:34,354 --> 00:12:36,857
<c.magenta>我们可以在仪表中</c>

267
00:12:37,191 --> 00:12:39,726
<c.magenta>那么假如说它显示我们有许多线程</c>

268
00:12:39,793 --> 00:12:41,228
<c.magenta>只运行很短的时间</c>

269
00:12:41,295 --> 00:12:43,363
<c.magenta>并且它们会在一个小串联中相互转换</c>

270
00:12:44,264 --> 00:12:46,767
<c.magenta>让我们主要关注第一个线程</c>

271
00:12:47,835 --> 00:12:51,839
<c.magenta>我们有这个蓝色线</c>

272
00:12:52,539 --> 00:12:55,042
<c.magenta>而红色线表示执行系统调用的时间</c>

273
00:12:55,108 --> 00:12:57,477
<c.magenta>在本例中</c>

274
00:12:58,579 --> 00:13:00,214
<c.magenta>这显示出它绝大部分时间</c>

275
00:12:58,579 --> 00:13:00,214
<c.magenta>这显示出它绝大部分时间</c>

276
00:13:00,280 --> 00:13:02,883
<c.magenta>都在等待无声文本变为可用</c>

277
00:13:02,950 --> 00:13:06,220
<c.magenta>在内核上的时间很短 只有10毫秒</c>

278
00:13:06,987 --> 00:13:09,857
<c.magenta>系统中有大量情境切换</c>

279
00:13:09,923 --> 00:13:11,825
<c.magenta>通过顶部的情境切换条显示</c>

280
00:13:13,794 --> 00:13:15,629
<c.magenta>那么是什么原因导致了这样的情况？</c>

281
00:13:15,863 --> 00:13:17,865
<c.magenta>让我们返回去看那个简单的时间轴</c>

282
00:13:18,298 --> 00:13:21,168
<c.magenta>了解如何…如何获取情境[听不清]…</c>

283
00:13:22,135 --> 00:13:24,471
<c.magenta>如何用完过度的负债</c>

284
00:13:25,239 --> 00:13:27,708
<c.magenta>那么你可以及时了解到这种阶梯式模式</c>

285
00:13:28,008 --> 00:13:29,776
<c.magenta>每个线程都只运行很短的时间</c>

286
00:13:29,843 --> 00:13:31,545
<c.magenta>然后就把CPU让给下一个线程</c>

287
00:13:31,612 --> 00:13:33,180
<c.magenta>以此类推 然后等待很长时间</c>

288
00:13:33,914 --> 00:13:35,816
<c.magenta>你想让你的应用看起来像这样</c>

289
00:13:36,683 --> 00:13:39,419
<c.magenta>你必须 CPU每次只能专注于一件事</c>

290
00:13:39,620 --> 00:13:41,355
<c.magenta>完成它 然后再执行下一个任务</c>

291
00:13:42,322 --> 00:13:44,525
<c.magenta>那么这里发生了什么</c>

292
00:13:44,691 --> 00:13:46,560
<c.magenta>让我们放大其中一个阶梯</c>

293
00:13:47,628 --> 00:13:51,231
<c.magenta>那么在这里我们正在专注两个线程</c>

294
00:13:51,765 --> 00:13:53,534
<c.magenta>并且顶部有CPU</c>

295
00:13:54,234 --> 00:13:55,836
<c.magenta>我们在这里添加了一个新的锁定追踪</c>

296
00:13:55,969 --> 00:13:58,105
<c.magenta>表明了锁定的状态以及哪个线程拥有它</c>

297
00:13:58,305 --> 00:13:59,339
<c.magenta>在本例中</c>

298
00:13:59,406 --> 00:14:02,543
<c.magenta>蓝色线程拥有这个锁定</c>

299
00:13:59,406 --> 00:14:02,543
<c.magenta>蓝色线程拥有这个锁定</c>

300
00:14:03,443 --> 00:14:05,379
<c.magenta>那么当蓝色线程解锁时</c>

301
00:14:05,445 --> 00:14:07,447
<c.magenta>那个锁定的所有权就转给了绿色线程</c>

302
00:14:07,514 --> 00:14:08,615
<c.magenta>因为它是队列中的下一个</c>

303
00:14:09,449 --> 00:14:13,587
<c.magenta>然而当蓝色线程转回来再次获取锁定时</c>

304
00:14:13,654 --> 00:14:16,590
<c.magenta>它不会成功 因为绿色线程预定了锁定</c>

305
00:14:16,657 --> 00:14:20,093
<c.magenta>它强制进行情境切换</c>

306
00:14:20,494 --> 00:14:23,497
<c.magenta>我们切换到了绿色线程</c>

307
00:14:24,097 --> 00:14:25,933
<c.magenta>结束锁定 我们可以反复这个过程</c>

308
00:14:27,034 --> 00:14:28,202
<c.magenta>有时候很有帮助</c>

309
00:14:28,268 --> 00:14:29,903
<c.magenta>你希望等待锁定的每一个线程</c>

310
00:14:29,970 --> 00:14:31,872
<c.magenta>都有机会获取资源</c>

311
00:14:32,606 --> 00:14:35,742
<c.magenta>然而如果锁定的工作方式</c>

312
00:14:36,543 --> 00:14:39,880
<c.magenta>让我们再从开始做</c>

313
00:14:40,881 --> 00:14:45,385
<c.magenta>那么这一次当蓝色线程解锁时</c>

314
00:14:45,853 --> 00:14:47,621
<c.magenta>锁定的所有权被公开拍卖了</c>

315
00:14:48,622 --> 00:14:51,992
<c.magenta>蓝色线程可以再次获取锁定</c>

316
00:14:52,059 --> 00:14:54,795
<c.magenta>并保留在CPU上</c>

317
00:14:55,495 --> 00:14:56,697
<c.magenta>那可能会导致绿色线程很难</c>

318
00:14:56,763 --> 00:14:59,366
<c.magenta>有机会获取锁定</c>

319
00:14:59,433 --> 00:15:02,803
<c.magenta>但它减少了强制情景切换的次数…</c>

320
00:14:59,433 --> 00:15:02,803
<c.magenta>但它减少了强制情景切换的次数…</c>

321
00:15:02,870 --> 00:15:06,640
<c.magenta>是蓝色线程为了重新获取锁定</c>

322
00:15:08,008 --> 00:15:09,843
<c.magenta>那么回顾一下当我们谈到锁定竞争时</c>

323
00:15:10,143 --> 00:15:13,547
<c.magenta>你实际上是想确保</c>

324
00:15:13,847 --> 00:15:15,349
<c.magenta>了解是否存在问题</c>

325
00:15:15,415 --> 00:15:20,254
<c.magenta>如果你这么做了 这种不公平的锁定</c>

326
00:15:20,320 --> 00:15:21,822
<c.magenta>或全局状态 你的应用</c>

327
00:15:21,889 --> 00:15:24,124
<c.magenta>可能会发生的锁定会跌很多很多次</c>

328
00:15:25,526 --> 00:15:27,728
<c.magenta>当提到锁定时 我还想谈另外一件事</c>

329
00:15:27,995 --> 00:15:29,096
<c.magenta>就是锁定的所有权</c>

330
00:15:29,863 --> 00:15:31,832
<c.magenta>那么请记住我们之前的锁定追踪</c>

331
00:15:32,499 --> 00:15:35,135
<c.magenta>运行时间知道接下来是哪个线程</c>

332
00:15:36,003 --> 00:15:37,638
<c.magenta>我们可以利用那种能力</c>

333
00:15:37,704 --> 00:15:40,440
<c.magenta>自动计算你应用中的优先级反转</c>

334
00:15:40,507 --> 00:15:42,342
<c.magenta>在等待锁定的线程</c>

335
00:15:43,043 --> 00:15:44,978
<c.magenta>甚至启用其它优化</c>

336
00:15:45,045 --> 00:15:47,347
<c.magenta>比如让CPU转到拥有锁定的线程上</c>

337
00:15:47,748 --> 00:15:49,816
<c.magenta>稍后Pierre会跟大家讨论这个话题</c>

338
00:15:49,883 --> 00:15:51,151
<c.magenta>当我们谈同步调度时</c>

339
00:15:52,186 --> 00:15:53,487
<c.magenta>我们通常会有这个问题</c>

340
00:15:53,987 --> 00:15:56,557
<c.magenta>哪些基元有这种能力而哪些没有呢？</c>

341
00:15:57,457 --> 00:16:00,494
<c.magenta>让我们看看哪些低等级基元可以实现</c>

342
00:15:57,457 --> 00:16:00,494
<c.magenta>让我们看看哪些低等级基元可以实现</c>

343
00:16:01,495 --> 00:16:04,531
<c.magenta>那么拥有单一</c>

344
00:16:04,932 --> 00:16:07,100
<c.magenta>比如连续队列和OS的不公平锁定</c>

345
00:16:08,202 --> 00:16:10,504
<c.magenta>然而不对称基元</c>

346
00:16:10,571 --> 00:16:13,807
<c.magenta>比如调度信号和调度群就没有这种能力</c>

347
00:16:13,974 --> 00:16:17,311
<c.magenta>因为运行时间不知道哪个线程</c>

348
00:16:18,612 --> 00:16:21,381
<c.magenta>最终 拥有多个所有者的基元</c>

349
00:16:21,448 --> 00:16:23,851
<c.magenta>比如私人化的并发队列和读或写锁定</c>

350
00:16:24,251 --> 00:16:25,719
<c.magenta>系统就不用利用那些</c>

351
00:16:25,786 --> 00:16:27,521
<c.magenta>因为它们不是只有一个所有者</c>

352
00:16:28,488 --> 00:16:31,959
<c.magenta>当你选择基元时 要考虑你是否</c>

353
00:16:32,025 --> 00:16:34,228
<c.magenta>涉及多基元的线程交互</c>

354
00:16:35,095 --> 00:16:38,599
<c.magenta>比如拥有较低优先级</c>

355
00:16:39,800 --> 00:16:42,970
<c.magenta>如果是这样的话</c>

356
00:16:43,370 --> 00:16:45,472
<c.magenta>确保你的UI线程</c>

357
00:16:45,539 --> 00:16:47,941
<c.magenta>不会因为等待</c>

358
00:16:49,810 --> 00:16:50,844
<c.magenta>那么总的来说</c>

359
00:16:50,911 --> 00:16:54,114
<c.magenta>这些效率低的行为</c>

360
00:16:54,481 --> 00:16:57,317
<c.magenta>仅仅通过看代码是很难发现这些问题的</c>

361
00:16:57,818 --> 00:17:00,320
<c.magenta>你应该在仪表系统追踪中进行观察</c>

362
00:16:57,818 --> 00:17:00,320
<c.magenta>你应该在仪表系统追踪中进行观察</c>

363
00:17:00,721 --> 00:17:02,990
<c.magenta>形象化应用的真实行为</c>

364
00:17:03,357 --> 00:17:05,759
<c.magenta>以便你可以利用正确的锁定执行任务</c>

365
00:17:06,527 --> 00:17:08,295
<c.magenta>那么我刚才谈了</c>

366
00:17:08,362 --> 00:17:11,231
<c.magenta>情境切换列表中的第一个原因</c>

367
00:17:12,566 --> 00:17:13,733
<c.magenta>要谈</c>

368
00:17:13,800 --> 00:17:15,935
<c.magenta>应用可能会拥有过度情境</c>

369
00:17:16,170 --> 00:17:18,505
<c.magenta>让我们欢迎我的同事</c>

370
00:17:18,571 --> 00:17:22,608
<c.magenta>跟大家谈谈如何通过GDC管理并发</c>

371
00:17:22,675 --> 00:17:23,877
<c.magenta>以避免这些陷阱</c>

372
00:17:31,618 --> 00:17:33,020
<c.magenta>好的 谢谢Daniel</c>

373
00:17:33,086 --> 00:17:34,254
<c.magenta>（使用GCD处理并发）</c>

374
00:17:34,321 --> 00:17:37,090
<c.magenta>那么我们今天要讲很多内容</c>

375
00:17:37,157 --> 00:17:39,860
<c.magenta>讲太多GCD的基本原理</c>

376
00:17:40,394 --> 00:17:43,697
<c.magenta>如果你刚接触这个技术</c>

377
00:17:43,764 --> 00:17:46,567
<c.magenta>这里有一些WWDC之前发布的演讲</c>

378
00:17:47,034 --> 00:17:50,103
<c.magenta>是前几年我们做的演讲</c>

379
00:17:50,671 --> 00:17:52,806
<c.magenta>那么我鼓励你查看这些视频</c>

380
00:17:53,941 --> 00:17:56,944
<c.magenta>我们还会涉及GCD的一些基本概念</c>

381
00:17:57,010 --> 00:17:59,580
<c.magenta>让我们从调度连续队列开始讲</c>

382
00:18:00,581 --> 00:18:04,218
<c.magenta>这真的是GCD中基本的同步基元</c>

383
00:18:04,818 --> 00:18:07,988
<c.magenta>它提供互斥以及FIFO排序</c>

384
00:18:08,055 --> 00:18:11,792
<c.magenta>这是刚才Daniel提到的其中一个</c>

385
00:18:13,293 --> 00:18:15,829
<c.magenta>它在队列运作中有一个并发原子</c>

386
00:18:15,896 --> 00:18:17,231
<c.magenta>所以多线程</c>

387
00:18:17,297 --> 00:18:19,566
<c.magenta>排队同时处理队列是没问题的</c>

388
00:18:19,867 --> 00:18:22,536
<c.magenta>以及系统提供的单一DQS线程</c>

389
00:18:22,603 --> 00:18:24,671
<c.magenta>在队列之外执行异步运作也是没问题的</c>

390
00:18:25,405 --> 00:18:27,508
<c.magenta>那么让我们实际看个例子</c>

391
00:18:28,442 --> 00:18:31,778
<c.magenta>在这里我们创建了一个串行序列</c>

392
00:18:32,346 --> 00:18:34,448
<c.magenta>它会给你留下一个印象</c>

393
00:18:34,615 --> 00:18:38,051
<c.magenta>只要你还没有用它</c>

394
00:18:38,785 --> 00:18:39,887
<c.magenta>现在想象一下有两个线程</c>

395
00:18:39,953 --> 00:18:42,422
<c.magenta>同时出现并调用queue.async方法</c>

396
00:18:42,656 --> 00:18:44,725
<c.magenta>来向这个队列提交一些异步任务</c>

397
00:18:45,392 --> 00:18:47,327
<c.magenta>我们刚提到过</c>

398
00:18:47,394 --> 00:18:50,731
<c.magenta>而项会进入队列 以便它们能出现</c>

399
00:18:52,299 --> 00:18:54,101
<c.magenta>因为这是个异步方法</c>

400
00:18:54,168 --> 00:18:58,505
<c.magenta>这个方法会返回并且线程可以继续</c>

401
00:18:58,572 --> 00:19:01,375
<c.magenta>那么也许这第一个线程</c>

402
00:18:58,572 --> 00:19:01,375
<c.magenta>那么也许这第一个线程</c>

403
00:19:01,975 --> 00:19:03,944
<c.magenta>这就是你与队列同步交互的方式</c>

404
00:19:04,311 --> 00:19:06,180
<c.magenta>因为这是个有序基元</c>

405
00:19:06,246 --> 00:19:08,982
<c.magenta>它的作用是它将作为</c>

406
00:19:09,550 --> 00:19:13,487
<c.magenta>以便线程可以等待直到轮到它</c>

407
00:19:14,555 --> 00:19:18,759
<c.magenta>现在有了这个自动辅助线程</c>

408
00:19:19,092 --> 00:19:21,195
<c.magenta>它可以执行异步工作</c>

409
00:19:21,261 --> 00:19:23,664
<c.magenta>直到你排到那个占位符那儿</c>

410
00:19:23,730 --> 00:19:25,966
<c.magenta>那时候队列的所有者将会转交给线程</c>

411
00:19:26,033 --> 00:19:29,069
<c.magenta>在queue.sync中等待</c>

412
00:19:31,238 --> 00:19:34,875
<c.magenta>那么下一个概念是调度源</c>

413
00:19:35,042 --> 00:19:37,411
<c.magenta>这是GCD中的事件监控基元</c>

414
00:19:37,778 --> 00:19:38,979
<c.magenta>在这里我们设置了一个</c>

415
00:19:39,313 --> 00:19:41,348
<c.magenta>用于监控一个默认基元的可读性</c>

416
00:19:41,682 --> 00:19:43,450
<c.magenta>如果你有读取资源构造器的话</c>

417
00:19:44,251 --> 00:19:46,987
<c.magenta>你在队列中传递它 就是源的目标队列</c>

418
00:19:47,321 --> 00:19:50,123
<c.magenta>也是我们执行源的事件处理的地方</c>

419
00:19:50,457 --> 00:19:52,259
<c.magenta>在这里只需要从默认描述符中读取</c>

420
00:19:53,026 --> 00:19:55,162
<c.magenta>这个目标队列还是你可能会放置</c>

421
00:19:55,229 --> 00:19:57,531
<c.magenta>应该与这个运作</c>

422
00:19:57,598 --> 00:19:59,600
<c.magenta>比如处理所读取的数据</c>

423
00:20:00,667 --> 00:20:02,736
<c.magenta>那么我们给源设置了取消处理器</c>

424
00:20:02,936 --> 00:20:06,340
<c.magenta>是源如何将它们</c>

425
00:20:07,040 --> 00:20:08,375
<c.magenta>最终当一切都设置好之后</c>

426
00:20:08,442 --> 00:20:10,577
<c.magenta>你需要调用源并激活以开始监控</c>

427
00:20:11,645 --> 00:20:14,047
<c.magenta>那么值得注意的是源只是</c>

428
00:20:14,348 --> 00:20:17,518
<c.magenta>OS中一个更通用的模式的实例</c>

429
00:20:17,684 --> 00:20:21,655
<c.magenta>其中包括可以按照你指定的目标队列</c>

430
00:20:22,055 --> 00:20:23,590
<c.magenta>那么如果你熟悉XPC</c>

431
00:20:23,657 --> 00:20:26,660
<c.magenta>那可以作为</c>

432
00:20:27,995 --> 00:20:31,298
<c.magenta>并且值得注意的是我们今天</c>

433
00:20:31,365 --> 00:20:34,334
<c.magenta>一般来说都可以应用到全部这种对象上</c>

434
00:20:36,270 --> 00:20:38,305
<c.magenta>那么把这两个概念结合到一起</c>

435
00:20:38,372 --> 00:20:40,607
<c.magenta>我们就得到了一个目标队列等级</c>

436
00:20:44,945 --> 00:20:47,581
<c.magenta>那么在这里我们有两个源</c>

437
00:20:47,648 --> 00:20:50,651
<c.magenta>S1、S2 队列是Q1和Q2</c>

438
00:20:50,884 --> 00:20:53,187
<c.magenta>我们构造一个小的树形结构</c>

439
00:20:53,253 --> 00:20:55,155
<c.magenta>通过添加另一个连续队列</c>

440
00:20:55,455 --> 00:20:58,692
<c.magenta>通过在底部添加互斥队列EQ</c>

441
00:20:59,326 --> 00:21:02,462
<c.magenta>我们的实现方式是通过把可选目标参数</c>

442
00:20:59,326 --> 00:21:02,462
<c.magenta>我们的实现方式是通过把可选目标参数</c>

443
00:21:02,529 --> 00:21:04,164
<c.magenta>传给调度队列构造器</c>

444
00:21:05,232 --> 00:21:09,102
<c.magenta>那么这就为整个树形结构</c>

445
00:21:09,503 --> 00:21:13,807
<c.magenta>每次只能执行其中一个源</c>

446
00:21:14,441 --> 00:21:17,277
<c.magenta>但它为队列1和队列2</c>

447
00:21:17,344 --> 00:21:18,679
<c.magenta>保持了独立的单项队列顺序</c>

448
00:21:19,179 --> 00:21:20,914
<c.magenta>那么让我们具体来看看我所表达的意思</c>

449
00:21:22,649 --> 00:21:24,952
<c.magenta>在这里我有两个队列</c>

450
00:21:25,018 --> 00:21:27,354
<c.magenta>它们以指定顺序排列</c>

451
00:21:27,754 --> 00:21:30,090
<c.magenta>因为我们底部有这个额外的连续队列</c>

452
00:21:30,157 --> 00:21:33,260
<c.magenta>还有执行 那么它们将在EQ中执行</c>

453
00:21:33,627 --> 00:21:35,996
<c.magenta>并且会有一个单一辅助线程执行这些</c>

454
00:21:36,063 --> 00:21:39,900
<c.magenta>为你提供互斥属性的项</c>

455
00:21:40,167 --> 00:21:43,504
<c.magenta>但正如你所看到的</c>

456
00:21:43,904 --> 00:21:47,040
<c.magenta>并保留各自在原始队列中的顺序</c>

457
00:21:49,443 --> 00:21:54,114
<c.magenta>那么我们今天涉及到的最后一个</c>

458
00:21:55,282 --> 00:21:58,752
<c.magenta>这其实是以前详细谈过的一个概念</c>

459
00:21:58,819 --> 00:22:03,857
<c.magenta>尤其是在2014年的能力性能</c>

460
00:21:58,819 --> 00:22:03,857
<c.magenta>尤其是在2014年的能力性能</c>

461
00:22:04,224 --> 00:22:07,661
<c.magenta>那么如果这对于你来说不熟悉</c>

462
00:22:08,462 --> 00:22:11,565
<c.magenta>但我们今天要讲的主要是</c>

463
00:22:11,832 --> 00:22:13,534
<c.magenta>优先级的抽象概念</c>

464
00:22:14,701 --> 00:22:17,137
<c.magenta>我们会用到术语QOS和优先级</c>

465
00:22:17,204 --> 00:22:20,140
<c.magenta>在接下来的演讲中会交替出现</c>

466
00:22:21,275 --> 00:22:23,677
<c.magenta>我们的系统上的服务级别有四种质量</c>

467
00:22:23,744 --> 00:22:26,380
<c.magenta>最高的是用户交互性UI、</c>

468
00:22:26,547 --> 00:22:32,953
<c.magenta>到用户发起（或IN）、效用（UT）</c>

469
00:22:33,954 --> 00:22:37,424
<c.magenta>那么让我们看看要如何结合服务质量</c>

470
00:22:37,491 --> 00:22:39,826
<c.magenta>通过我们刚看过的目标队列等级</c>

471
00:22:40,294 --> 00:22:42,095
<c.magenta>在这个等级中 树结构中的每个节点</c>

472
00:22:42,162 --> 00:22:44,998
<c.magenta>其实都可以有一个与之</c>

473
00:22:45,732 --> 00:22:48,802
<c.magenta>那么比如说源2可能与用户界面相关</c>

474
00:22:49,102 --> 00:22:50,437
<c.magenta>它可能会针对事件被监控</c>

475
00:22:50,504 --> 00:22:52,906
<c.magenta>一旦触发事件</c>

476
00:22:52,973 --> 00:22:57,044
<c.magenta>那么有可能我们想把这个UI标签</c>

477
00:22:57,911 --> 00:22:59,646
<c.magenta>另一个常见的用例是</c>

478
00:22:59,913 --> 00:23:04,451
<c.magenta>把标签放在互斥队列中</c>

479
00:22:59,913 --> 00:23:04,451
<c.magenta>把标签放在互斥队列中</c>

480
00:23:04,618 --> 00:23:08,722
<c.magenta>从而树形结构中的全部都能在这个</c>

481
00:23:10,357 --> 00:23:14,261
<c.magenta>现在如果这个队列中的任意其它项</c>

482
00:23:14,528 --> 00:23:17,331
<c.magenta>我们将使用这个属性结构的等级</c>

483
00:23:17,397 --> 00:23:19,700
<c.magenta>如果它没有</c>

484
00:23:21,435 --> 00:23:26,673
<c.magenta>源触发其实就像</c>

485
00:23:26,874 --> 00:23:29,910
<c.magenta>在发生之前也一样</c>

486
00:23:30,143 --> 00:23:32,679
<c.magenta>最终进入互斥队列执行</c>

487
00:23:34,181 --> 00:23:37,184
<c.magenta>对于用户空间的异步运作</c>

488
00:23:37,251 --> 00:23:39,753
<c.magenta>通常是由那个</c>

489
00:23:40,120 --> 00:23:44,625
<c.magenta>现在我们有一个用户发起的线程</c>

490
00:23:44,691 --> 00:23:47,661
<c.magenta>到队列中 并最终执行到E队列中</c>

491
00:23:48,295 --> 00:23:50,531
<c.magenta>现在也许我们有源2</c>

492
00:23:50,597 --> 00:23:53,634
<c.magenta>与这个高优先级的UI相关事件一起</c>

493
00:23:53,700 --> 00:23:57,204
<c.magenta>源2执行其事件处理器</c>

494
00:23:58,205 --> 00:24:01,575
<c.magenta>那么现在你会注意到我们</c>

495
00:23:58,205 --> 00:24:01,575
<c.magenta>那么现在你会注意到我们</c>

496
00:24:01,642 --> 00:24:04,778
<c.magenta>我们的队列中有三个项</c>

497
00:24:04,945 --> 00:24:08,849
<c.magenta>前边是一些低优先级项</c>

498
00:24:09,616 --> 00:24:12,819
<c.magenta>系统为你解决了这种倒置</c>

499
00:24:13,120 --> 00:24:16,690
<c.magenta>比当前队列中所有项都高的</c>

500
00:24:17,891 --> 00:24:20,827
<c.magenta>我们一定要记住右边的这个树形图</c>

501
00:24:20,894 --> 00:24:23,130
<c.magenta>因为稍后它会再次出现</c>

502
00:24:26,934 --> 00:24:29,837
<c.magenta>让我们继续我们的主话题</c>

503
00:24:29,903 --> 00:24:34,174
<c.magenta>即如何使用我们刚学到的知识</c>

504
00:24:35,943 --> 00:24:38,579
<c.magenta>让我们返回去看Daniel</c>

505
00:24:38,745 --> 00:24:41,381
<c.magenta>稍微多关注一点联网子系统</c>

506
00:24:43,016 --> 00:24:45,719
<c.magenta>在联网子系统中 你必须监控</c>

507
00:24:45,786 --> 00:24:47,421
<c.magenta>内核中的一些网络连接</c>

508
00:24:47,921 --> 00:24:49,957
<c.magenta>有了GCD 你可以用调度源</c>

509
00:24:50,023 --> 00:24:51,859
<c.magenta>和调度队列实现</c>

510
00:24:52,192 --> 00:24:54,161
<c.magenta>但当然了在任何网络子系统中</c>

511
00:24:54,228 --> 00:24:57,097
<c.magenta>你通常不仅仅有一个网络连接</c>

512
00:24:57,698 --> 00:24:59,867
<c.magenta>它们会复制同样的设置</c>

513
00:25:00,701 --> 00:25:03,871
<c.magenta>那么让我们主要关注右边的这三个连接</c>

514
00:25:04,037 --> 00:25:05,472
<c.magenta>看看它们是如何执行的</c>

515
00:25:06,940 --> 00:25:08,509
<c.magenta>如果触发了第一个连接</c>

516
00:25:08,809 --> 00:25:10,978
<c.magenta>跟我们刚看到的一样</c>

517
00:25:11,044 --> 00:25:14,581
<c.magenta>我们会排在那个源的事件处理器的最后</c>

518
00:25:15,115 --> 00:25:17,651
<c.magenta>当然如果同时触发了其它两个连接</c>

519
00:25:17,718 --> 00:25:19,786
<c.magenta>它们仍会复制</c>

520
00:25:20,020 --> 00:25:21,288
<c.magenta>而事件处理器排在最后</c>

521
00:25:22,022 --> 00:25:25,259
<c.magenta>因为你在底部有这三个独立的连续队列</c>

522
00:25:25,425 --> 00:25:27,160
<c.magenta>你其实已经请求系统给你提供</c>

523
00:25:27,227 --> 00:25:29,196
<c.magenta>三个独立的并发情境</c>

524
00:25:29,663 --> 00:25:33,200
<c.magenta>如果全部三个同时被激活</c>

525
00:25:33,367 --> 00:25:35,502
<c.magenta>三个线程用于执行时间处理器</c>

526
00:25:36,603 --> 00:25:39,740
<c.magenta>现在这也许就是你想要的</c>

527
00:25:40,140 --> 00:25:45,012
<c.magenta>但常见的情况是这些事件处理器很小</c>

528
00:25:45,078 --> 00:25:48,115
<c.magenta>从网络中读取一些数据</c>

529
00:25:48,682 --> 00:25:51,552
<c.magenta>此外正如我们之前所看到的</c>

530
00:25:51,618 --> 00:25:53,153
<c.magenta>你可能有很多很多连接</c>

531
00:25:53,220 --> 00:25:56,323
<c.magenta>如果你的子系统中有许多网络连接的话</c>

532
00:25:57,157 --> 00:25:59,860
<c.magenta>那么这可能会导致这种</c>

533
00:26:00,027 --> 00:26:03,463
<c.magenta>情境切换模式的出现</c>

534
00:26:03,530 --> 00:26:05,432
<c.magenta>就是你执行少量工作</c>

535
00:26:05,499 --> 00:26:08,569
<c.magenta>情境切换到另一个线程</c>

536
00:26:09,436 --> 00:26:12,706
<c.magenta>那么我们该如何改善</c>

537
00:26:13,273 --> 00:26:17,044
<c.magenta>我们可以应用我们刚谈到的那个</c>

538
00:26:17,444 --> 00:26:20,414
<c.magenta>只需要在底部放一个额外的连续队列</c>

539
00:26:20,480 --> 00:26:24,718
<c.magenta>并形成一个等级即可 你可以获得</c>

540
00:26:24,785 --> 00:26:26,253
<c.magenta>全部这些连接的单一互斥情境</c>

541
00:26:26,720 --> 00:26:29,823
<c.magenta>如果它们同时被触发</c>

542
00:26:29,890 --> 00:26:32,426
<c.magenta>事件处理器将会排在目标队列的最后</c>

543
00:26:32,492 --> 00:26:34,995
<c.magenta>但因为底部有了这个额外的连续队列</c>

544
00:26:35,062 --> 00:26:37,264
<c.magenta>它是单一线程</c>

545
00:26:37,331 --> 00:26:40,200
<c.magenta>而不是由我们之前的那个多线程来执行</c>

546
00:26:41,134 --> 00:26:45,205
<c.magenta>那么看起来像是个非常简单的修改</c>

547
00:26:45,272 --> 00:26:48,709
<c.magenta>将我们自己某些代码的性能</c>

548
00:26:49,009 --> 00:26:51,712
<c.magenta>正如Daniel之前提到过的一样</c>

549
00:26:55,516 --> 00:26:59,186
<c.magenta>那么这是如何避免问题模式的一个例子</c>

550
00:26:59,253 --> 00:27:01,522
<c.magenta>关于在独立运作之间反复切换的问题</c>

551
00:26:59,253 --> 00:27:01,522
<c.magenta>关于在独立运作之间反复切换的问题</c>

552
00:27:02,422 --> 00:27:05,025
<c.magenta>但它却归入了一个通用标题</c>

553
00:27:05,092 --> 00:27:08,028
<c.magenta>多余的和不受控制的并发</c>

554
00:27:09,329 --> 00:27:13,100
<c.magenta>解决办法之一就是同时激活许多队列</c>

555
00:27:13,367 --> 00:27:14,568
<c.magenta>其中一个例子是</c>

556
00:27:14,635 --> 00:27:17,971
<c.magenta>我们刚才看到的那个需要独立的源模式</c>

557
00:27:18,038 --> 00:27:21,275
<c.magenta>如果你有独立或对象队列也可以解决</c>

558
00:27:21,542 --> 00:27:24,178
<c.magenta>如果你的应用中许多对象</c>

559
00:27:24,244 --> 00:27:26,747
<c.magenta>并且你同时给赋予它们异步运作</c>

560
00:27:26,813 --> 00:27:29,216
<c.magenta>你就可以得到一模一样的效果</c>

561
00:27:31,018 --> 00:27:33,453
<c.magenta>如果你有许多工作项</c>

562
00:27:33,520 --> 00:27:35,656
<c.magenta>同时提交到全局并发队列 也可以解决</c>

563
00:27:36,356 --> 00:27:38,192
<c.magenta>特别是如果有工作项阻塞时</c>

564
00:27:38,725 --> 00:27:42,129
<c.magenta>全局并发队列的运作方式是</c>

565
00:27:42,396 --> 00:27:43,697
<c.magenta>当现有线程阻塞了</c>

566
00:27:43,764 --> 00:27:46,700
<c.magenta>给你提供并发的持续性良好等级</c>

567
00:27:47,034 --> 00:27:48,869
<c.magenta>但如果这些线程再次阻塞</c>

568
00:27:49,036 --> 00:27:51,839
<c.magenta>你可以用一个叫作线程爆炸的东西</c>

569
00:27:52,873 --> 00:27:54,875
<c.magenta>在这个话题中 我们要接触到一些细节</c>

570
00:27:54,942 --> 00:27:59,146
<c.magenta>在2015年的“用GCD创建响应性</c>

571
00:27:59,646 --> 00:28:01,515
<c.magenta>那么如果你不熟悉这些</c>

572
00:27:59,646 --> 00:28:01,515
<c.magenta>那么如果你不熟悉这些</c>

573
00:28:01,582 --> 00:28:03,550
<c.magenta>我建议你参看那场演讲的视频</c>

574
00:28:04,785 --> 00:28:06,787
<c.magenta>那么如何选择适当数量的并发</c>

575
00:28:06,854 --> 00:28:09,489
<c.magenta>以避免这些问题模式呢？</c>

576
00:28:10,290 --> 00:28:12,326
<c.magenta>以前我们推荐给你的一个方法是</c>

577
00:28:12,392 --> 00:28:14,661
<c.magenta>给子系统使用一个队列</c>

578
00:28:16,129 --> 00:28:17,898
<c.magenta>那么返回到我们的新闻应用</c>

579
00:28:17,965 --> 00:28:20,567
<c.magenta>我们用户界面已经有了一个队列</c>

580
00:28:20,634 --> 00:28:23,103
<c.magenta>我们可以给网络连接选择一个连续队列</c>

581
00:28:23,170 --> 00:28:26,006
<c.magenta>并另外给数据库子系统选择一个</c>

582
00:28:27,007 --> 00:28:29,810
<c.magenta>但我们今天学了另一种</c>

583
00:28:29,877 --> 00:28:32,579
<c.magenta>其实就是给每个子系统</c>

584
00:28:35,916 --> 00:28:38,752
<c.magenta>这就给子系统提供了一个互斥情境</c>

585
00:28:38,819 --> 00:28:43,223
<c.magenta>你可以让队列中余下的事件</c>

586
00:28:43,290 --> 00:28:47,060
<c.magenta>只把那个网络队列</c>

587
00:28:47,127 --> 00:28:49,930
<c.magenta>就是位于队列等级底部的那个队列</c>

588
00:28:54,735 --> 00:28:57,538
<c.magenta>但那可能是一个太过简单的模式</c>

589
00:28:57,604 --> 00:28:59,773
<c.magenta>对于复杂应用或复杂子系统来说</c>

590
00:29:00,174 --> 00:29:01,842
<c.magenta>这里的重点是</c>

591
00:29:02,009 --> 00:29:04,144
<c.magenta>在应用中拥有固定数量的连续队列等级</c>

592
00:29:04,611 --> 00:29:06,813
<c.magenta>拥有额外队列等级对于</c>

593
00:29:07,047 --> 00:29:10,217
<c.magenta>比如第二队列等级</c>

594
00:29:10,284 --> 00:29:12,486
<c.magenta>或较大的工作项 那么第一个队列等级</c>

595
00:29:12,553 --> 00:29:14,821
<c.magenta>就是主要的队列等级</c>

596
00:29:14,888 --> 00:29:16,490
<c.magenta>外面进来的请求</c>

597
00:29:18,425 --> 00:29:21,128
<c.magenta>这个情境中需要思考的另一个重点</c>

598
00:29:21,428 --> 00:29:24,731
<c.magenta>是提交给那些子系统的工作的间隔</c>

599
00:29:25,766 --> 00:29:28,969
<c.magenta>你想使用相当大的工作项</c>

600
00:29:29,236 --> 00:29:31,972
<c.magenta>以实现我们之前看到过的那种情况</c>

601
00:29:32,039 --> 00:29:35,809
<c.magenta>也就是CP有足够长的时间</c>

602
00:29:36,143 --> 00:29:38,512
<c.magenta>以达到一种高效的性能状态</c>

603
00:29:39,980 --> 00:29:42,916
<c.magenta>一旦你处于子系统内部</c>

604
00:29:43,250 --> 00:29:47,354
<c.magenta>就有必要把子系统细分为</c>

605
00:29:47,421 --> 00:29:51,158
<c.magenta>并且用更精细的间隔来改善</c>

606
00:29:51,592 --> 00:29:54,661
<c.magenta>比如你可以拆分你的工作并重新异步</c>

607
00:29:54,728 --> 00:29:56,663
<c.magenta>到你队列等级中的另一个队列</c>

608
00:29:56,730 --> 00:29:58,198
<c.magenta>那并不会导致情境切换</c>

609
00:29:58,265 --> 00:30:00,033
<c.magenta>因为你已经在那个子系统中了</c>

610
00:29:58,265 --> 00:30:00,033
<c.magenta>因为你已经在那个子系统中了</c>

611
00:30:03,437 --> 00:30:05,973
<c.magenta>那么总的来说我们在这部分</c>

612
00:30:06,940 --> 00:30:10,878
<c.magenta>我们了解了如何把队列和源</c>

613
00:30:11,245 --> 00:30:13,714
<c.magenta>如何使用固定数量的连续队列等级</c>

614
00:30:13,780 --> 00:30:16,216
<c.magenta>使GCD获得一个不错的并发间隔</c>

615
00:30:16,683 --> 00:30:20,921
<c.magenta>以及如何合适地拆分你的工作项</c>

616
00:30:20,988 --> 00:30:24,157
<c.magenta>用于之前讲的并行工作</c>

617
00:30:24,224 --> 00:30:27,094
<c.magenta>在子系统内以及子系统之间</c>

618
00:30:28,028 --> 00:30:30,531
<c.magenta>好的 我要把舞台交给Pierre</c>

619
00:30:30,597 --> 00:30:33,100
<c.magenta>他会深入探讨我们对GCD的改进</c>

620
00:30:33,166 --> 00:30:36,136
<c.magenta>在单一线程上执行队列等级</c>

621
00:30:36,370 --> 00:30:38,005
<c.magenta>来利用这个改进</c>

622
00:30:44,378 --> 00:30:45,412
<c.magenta>谢谢Daniel</c>

623
00:30:47,047 --> 00:30:51,618
<c.magenta>那么的确我们今年</c>

624
00:30:51,685 --> 00:30:54,521
<c.magenta>以剔除某些多余的情境切换</c>

625
00:30:54,588 --> 00:30:56,657
<c.magenta>并执行单一队列等级</c>

626
00:30:56,723 --> 00:30:59,593
<c.magenta>就像Daniel在单一线程上</c>

627
00:31:00,460 --> 00:31:04,598
<c.magenta>为此我们创建了一个新概念</c>

628
00:31:04,665 --> 00:31:07,267
<c.magenta>我们叫作统一队列身份</c>

629
00:31:07,334 --> 00:31:09,403
<c.magenta>我们会逐步带你认识它是如何工作的</c>

630
00:31:11,471 --> 00:31:14,107
<c.magenta>那么其实这部分内容…</c>

631
00:31:14,708 --> 00:31:18,312
<c.magenta>开始…将主要关注单一队列等级</c>

632
00:31:18,378 --> 00:31:20,180
<c.magenta>比如Daniel刚展示的那几个</c>

633
00:31:20,514 --> 00:31:24,518
<c.magenta>然而我们会处理一些简化的</c>

634
00:31:24,785 --> 00:31:27,421
<c.magenta>底部有互斥情境</c>

635
00:31:27,487 --> 00:31:31,692
<c.magenta>GCD内部的注释并不是为了</c>

636
00:31:34,027 --> 00:31:35,696
<c.magenta>那么当你创建[听不清]情境时</c>

637
00:31:35,762 --> 00:31:37,564
<c.magenta>你通常会调度队列构造器</c>

638
00:31:38,332 --> 00:31:41,869
<c.magenta>那只会给你的应用留下一个印象</c>

639
00:31:42,302 --> 00:31:44,137
<c.magenta>你可能要做的第一件事</c>

640
00:31:44,304 --> 00:31:46,940
<c.magenta>就是给它调度最近编码的项</c>

641
00:31:48,141 --> 00:31:51,044
<c.magenta>那么你的应用中将有代码会在这里</c>

642
00:31:51,612 --> 00:31:54,515
<c.magenta>并在队列中[听不清]排队</c>

643
00:31:55,649 --> 00:31:58,352
<c.magenta>以前当那种情况发生时</c>

644
00:31:58,418 --> 00:32:01,455
<c.magenta>给系统调度一个匿名线程</c>

645
00:31:58,418 --> 00:32:01,455
<c.magenta>给系统调度一个匿名线程</c>

646
00:32:01,622 --> 00:32:04,825
<c.magenta>并且那个匿名线程必须要做的决心</c>

647
00:32:04,892 --> 00:32:06,927
<c.magenta>稍后会在你应用内部发生</c>

648
00:32:08,262 --> 00:32:12,933
<c.magenta>在这种情况下 我们进行了修改</c>

649
00:32:13,100 --> 00:32:16,136
<c.magenta>绑定到你的队列的统一队列身份</c>

650
00:32:16,336 --> 00:32:19,173
<c.magenta>恰好要在内核中代表你的队列</c>

651
00:32:20,073 --> 00:32:22,676
<c.magenta>我们可以给那个对象绑定</c>

652
00:32:22,743 --> 00:32:24,678
<c.magenta>那么在这里就是备份</c>

653
00:32:25,746 --> 00:32:28,182
<c.magenta>那会导致系统请求线程</c>

654
00:32:28,849 --> 00:32:32,386
<c.magenta>线程请求 就是幻灯片上的虚线</c>

655
00:32:32,586 --> 00:32:36,990
<c.magenta>有时可能不会实现</c>

656
00:32:37,224 --> 00:32:38,692
<c.magenta>也许系统已加载了足够多</c>

657
00:32:38,759 --> 00:32:41,195
<c.magenta>甚至不值得再提供给你一个线程</c>

658
00:32:43,897 --> 00:32:45,933
<c.magenta>稍后你应用的其它路径</c>

659
00:32:46,099 --> 00:32:49,269
<c.magenta>可能实际上会尝试让更多工作排队</c>

660
00:32:49,336 --> 00:32:52,472
<c.magenta>这里有一个UT[听不清]项</c>

661
00:32:54,007 --> 00:32:57,845
<c.magenta>我们可以使用队列身份</c>

662
00:32:57,911 --> 00:32:59,279
<c.magenta>来查看和解决优先级倒置问题</c>

663
00:32:59,346 --> 00:33:01,381
<c.magenta>并利用那个线程请求的优先级</c>

664
00:32:59,346 --> 00:33:01,381
<c.magenta>并利用那个线程请求的优先级</c>

665
00:33:01,915 --> 00:33:05,586
<c.magenta>也许那就是系统所需要的小的推进</c>

666
00:33:05,652 --> 00:33:07,421
<c.magenta>要在此给你一个线程来执行你的工作</c>

667
00:33:08,021 --> 00:33:11,525
<c.magenta>但这个线程是排程器中的队列</c>

668
00:33:11,925 --> 00:33:14,962
<c.magenta>原因是你的应用中有另一个线程</c>

669
00:33:15,028 --> 00:33:17,464
<c.magenta>与队列交互并同步工作</c>

670
00:33:17,531 --> 00:33:19,733
<c.magenta>以较高的优先级 甚至通常会被遮住</c>

671
00:33:21,768 --> 00:33:24,538
<c.magenta>现在我们有了那个统一队列身份</c>

672
00:33:24,738 --> 00:33:27,674
<c.magenta>因为那个线程必须阻塞占位符的排队</c>

673
00:33:27,741 --> 00:33:33,547
<c.magenta>这是Daniel之前刚跟你们谈过的</c>

674
00:33:33,614 --> 00:33:35,649
<c.magenta>那个线程在统一队列身份上的同步执行</c>

675
00:33:35,716 --> 00:33:37,651
<c.magenta>对于异步工作我们采取了同样的方式</c>

676
00:33:37,718 --> 00:33:39,319
<c.magenta>[听不清]</c>

677
00:33:39,486 --> 00:33:41,822
<c.magenta>但现在我们以单一身份</c>

678
00:33:41,889 --> 00:33:45,459
<c.magenta>和同步部分</c>

679
00:33:45,626 --> 00:33:48,962
<c.magenta>我们可以应用一个优化 并直接切换</c>

680
00:33:49,029 --> 00:33:51,865
<c.magenta>阻塞你通过排程器队列的线程</c>

681
00:33:51,932 --> 00:33:55,002
<c.magenta>并注册队列延迟 就是Daniel在最开始</c>

682
00:33:55,068 --> 00:33:57,237
<c.magenta>讲到排程器时跟大家介绍的</c>

683
00:33:58,105 --> 00:34:00,073
<c.magenta>那么这就是统一队列身份</c>

684
00:33:58,105 --> 00:34:00,073
<c.magenta>那么这就是统一队列身份</c>

685
00:34:00,140 --> 00:34:02,910
<c.magenta>处理异步和同步工作项的方式</c>

686
00:34:05,412 --> 00:34:09,049
<c.magenta>现在我们如何把它用在事件上？</c>

687
00:34:09,850 --> 00:34:12,886
<c.magenta>那么这是我们一直在用的小树形图</c>

688
00:34:13,320 --> 00:34:16,056
<c.magenta>让我们看看这些源的创建</c>

689
00:34:17,357 --> 00:34:20,092
<c.magenta>当你用makeResource工厂按钮</c>

690
00:34:20,726 --> 00:34:24,031
<c.magenta>你就设置了一堆事件</c>

691
00:34:24,464 --> 00:34:27,634
<c.magenta>但有意思的是当你激活对象时</c>

692
00:34:29,770 --> 00:34:34,641
<c.magenta>就在那时我们才意识到</c>

693
00:34:34,708 --> 00:34:37,277
<c.magenta>你的源将在那个QOS上</c>

694
00:34:37,511 --> 00:34:39,545
<c.magenta>因为它是从你的队列等级中继承来的</c>

695
00:34:40,112 --> 00:34:43,217
<c.magenta>我们现在还知道通过新系统</c>

696
00:34:43,449 --> 00:34:46,286
<c.magenta>处理器最终会</c>

697
00:34:46,353 --> 00:34:49,922
<c.magenta>在队列执行互斥情境中执行</c>

698
00:34:50,824 --> 00:34:53,726
<c.magenta>现在将会在前端注册源</c>

699
00:34:53,793 --> 00:34:57,531
<c.magenta>通过我稍早之前谈到过的同步统一身份</c>

700
00:34:59,600 --> 00:35:04,638
<c.magenta>如果我们看一下树形图上</c>

701
00:34:59,600 --> 00:35:04,638
<c.magenta>如果我们看一下树形图上</c>

702
00:35:05,138 --> 00:35:08,308
<c.magenta>我们的创建方式与第一个十分相似</c>

703
00:35:08,809 --> 00:35:11,044
<c.magenta>除了当你设置处理器时</c>

704
00:35:11,111 --> 00:35:14,414
<c.magenta>要指定你想要的QOS</c>

705
00:35:15,382 --> 00:35:18,085
<c.magenta>有意思的是在激活状态时</c>

706
00:35:18,151 --> 00:35:20,187
<c.magenta>这是我们在快照中时</c>

707
00:35:20,354 --> 00:35:24,157
<c.magenta>和以前一样 当我们从你的等级</c>

708
00:35:24,424 --> 00:35:26,126
<c.magenta>在这里我们从你的暗示中获取它</c>

709
00:35:26,793 --> 00:35:30,030
<c.magenta>我们回想一下 它们将在</c>

710
00:35:30,097 --> 00:35:31,765
<c.magenta>同一个执行情境中执行两个源</c>

711
00:35:31,832 --> 00:35:34,468
<c.magenta>并将第二个源再次注册到最前面</c>

712
00:35:34,635 --> 00:35:36,770
<c.magenta>第二个源在内核中有统一身份</c>

713
00:35:39,506 --> 00:35:45,045
<c.magenta>那么我们尝试要做的是</c>

714
00:35:45,279 --> 00:35:49,016
<c.magenta>的是一个我们在OS之前的阶段</c>

715
00:35:49,216 --> 00:35:53,453
<c.magenta>相关运作会脱离老线程</c>

716
00:35:53,620 --> 00:35:55,355
<c.magenta>让我们看看它通常是如何运作的</c>

717
00:35:56,089 --> 00:35:59,159
<c.magenta>那么请记住这是我们的队列等级</c>

718
00:36:00,394 --> 00:36:01,929
<c.magenta>让我们打开你在本次演讲中</c>

719
00:36:01,995 --> 00:36:05,132
<c.magenta>多次看到过的时间轴</c>

720
00:36:05,632 --> 00:36:08,402
<c.magenta>顶部是CPU 但现在有一个新追踪</c>

721
00:36:08,468 --> 00:36:12,439
<c.magenta>执行队列卡将表示</c>

722
00:36:12,506 --> 00:36:14,608
<c.magenta>在任意时刻该队列上正在执行什么</c>

723
00:36:16,109 --> 00:36:18,712
<c.magenta>那么这是运行时间真正的运作方式</c>

724
00:36:18,779 --> 00:36:22,349
<c.magenta>在我们进入macOS Sierra</c>

725
00:36:23,016 --> 00:36:25,953
<c.magenta>那么让我们看看如果第一个源</c>

726
00:36:26,620 --> 00:36:29,323
<c.magenta>正如我所说的 之前线程请求是异步的</c>

727
00:36:29,389 --> 00:36:32,459
<c.magenta>我们会请求一个异步线程</c>

728
00:36:32,626 --> 00:36:34,127
<c.magenta>然后我们会查看事件</c>

729
00:36:35,395 --> 00:36:38,031
<c.magenta>当我们在应用内查看事件时</c>

730
00:36:38,098 --> 00:36:42,536
<c.magenta>我们才会意识到这个事件</c>

731
00:36:42,603 --> 00:36:44,271
<c.magenta>然后我们会在让事件处理器排队</c>

732
00:36:46,039 --> 00:36:47,574
<c.magenta>但因为队列是未经声明的队列</c>

733
00:36:47,641 --> 00:36:50,511
<c.magenta>线程实际上可以变成那个队列</c>

734
00:36:50,577 --> 00:36:53,680
<c.magenta>并开始为那个源执行指定的处理器</c>

735
00:36:54,314 --> 00:36:55,249
<c.magenta>我们会这么做</c>

736
00:36:55,849 --> 00:36:57,551
<c.magenta>现在有意思的是</c>

737
00:36:57,618 --> 00:36:59,887
<c.magenta>当触发优先级较高的第二个源时</c>

738
00:37:00,721 --> 00:37:01,622
<c.magenta>实际上情况一模一样</c>

739
00:37:02,122 --> 00:37:03,724
<c.magenta>因为它在这里是一个等级QOS</c>

740
00:37:03,891 --> 00:37:06,226
<c.magenta>优先级较高 这就是你现在正在执行的</c>

741
00:37:07,427 --> 00:37:09,396
<c.magenta>我们会打开一个新的异步线程</c>

742
00:37:09,463 --> 00:37:11,431
<c.magenta>在线程上提交那个优先级较高的事件</c>

743
00:37:13,200 --> 00:37:14,968
<c.magenta>并查看那个事件是什么意思</c>

744
00:37:15,035 --> 00:37:18,105
<c.magenta>直到那时我们才注意到</c>

745
00:37:18,172 --> 00:37:20,941
<c.magenta>然后把处理器排在我们</c>

746
00:37:21,608 --> 00:37:24,178
<c.magenta>正如你所看到的</c>

747
00:37:24,711 --> 00:37:26,547
<c.magenta>就是那个优先级较高的事件的情境</c>

748
00:37:27,147 --> 00:37:30,017
<c.magenta>但我们不能促进进展</c>

749
00:37:30,083 --> 00:37:31,952
<c.magenta>第二个线程不能接受</c>

750
00:37:32,019 --> 00:37:33,887
<c.magenta>已经与某个线程相关联的队列</c>

751
00:37:33,954 --> 00:37:34,922
<c.magenta>我们不能接受它</c>

752
00:37:35,489 --> 00:37:36,456
<c.magenta>那么线程就结束了</c>

753
00:37:36,523 --> 00:37:40,227
<c.magenta>正如Daniel所阐述过的</c>

754
00:37:40,761 --> 00:37:43,030
<c.magenta>这是我们所做的工作</c>

755
00:37:43,096 --> 00:37:44,831
<c.magenta>就是实际上取得进展的那个</c>

756
00:37:44,898 --> 00:37:48,869
<c.magenta>我们执行第一个处理器余下的部分</c>

757
00:37:50,504 --> 00:37:51,738
<c.magenta>那么正如你所看到的</c>

758
00:37:51,805 --> 00:37:54,208
<c.magenta>我们使用两个线程和两次情境切换</c>

759
00:37:54,274 --> 00:37:57,110
<c.magenta>你实际上不想针对一个</c>

760
00:37:58,679 --> 00:38:04,818
<c.magenta>我们在macOS High Sierra和iOS 11中</c>

761
00:37:58,679 --> 00:38:04,818
<c.magenta>我们在macOS High Sierra和iOS 11中</c>

762
00:38:05,819 --> 00:38:07,154
<c.magenta>我们摆脱了那个线程</c>

763
00:38:08,622 --> 00:38:09,523
<c.magenta>[听不清]</c>

764
00:38:10,157 --> 00:38:15,262
<c.magenta>当然了 我们还摆脱了</c>

765
00:38:15,329 --> 00:38:16,663
<c.magenta>那是多余的</c>

766
00:38:17,664 --> 00:38:19,299
<c.magenta>这当然很重要 因为</c>

767
00:38:19,733 --> 00:38:22,069
<c.magenta>跟Daniel通过那个触摸事件给你展示</c>

768
00:38:22,135 --> 00:38:25,539
<c.magenta>占先及优先级时所发生的不一样</c>

769
00:38:26,106 --> 00:38:30,344
<c.magenta>我们可以利用</c>

770
00:38:30,410 --> 00:38:33,347
<c.magenta>相对独立并且响应性更强</c>

771
00:38:33,614 --> 00:38:36,283
<c.magenta>在这里我们没有从任何情境切换中受益</c>

772
00:38:36,550 --> 00:38:41,054
<c.magenta>因为这些事件处理器</c>

773
00:38:41,121 --> 00:38:43,490
<c.magenta>那么提前知道那个事件</c>

774
00:38:44,858 --> 00:38:48,695
<c.magenta>如果你看一下…今天的流程</c>

775
00:38:48,762 --> 00:38:49,963
<c.magenta>看起来更应该是这样的</c>

776
00:38:52,199 --> 00:38:53,500
<c.magenta>这里发生了什么？</c>

777
00:38:55,202 --> 00:38:57,104
<c.magenta>那个流程中最重要的事</c>

778
00:38:57,171 --> 00:39:00,307
<c.magenta>就是现在如果你查看线程 它叫作EQ</c>

779
00:38:57,171 --> 00:39:00,307
<c.magenta>就是现在如果你查看线程 它叫作EQ</c>

780
00:39:00,374 --> 00:39:02,442
<c.magenta>因为它是统一身份的一个部分</c>

781
00:39:02,509 --> 00:39:04,978
<c.magenta>线程和EQ从根本上说是同一个对象</c>

782
00:39:05,312 --> 00:39:08,182
<c.magenta>而内核知道它其实正在执行队列</c>

783
00:39:08,248 --> 00:39:10,851
<c.magenta>在CPU标签上反映出来了</c>

784
00:39:10,918 --> 00:39:12,286
<c.magenta>那就会运行你的队列</c>

785
00:39:14,488 --> 00:39:19,393
<c.magenta>然而你可能会问</c>

786
00:39:19,459 --> 00:39:21,795
<c.magenta>提交第二个事件而不需要帮手</c>

787
00:39:21,862 --> 00:39:23,363
<c.magenta>这是个好问题</c>

788
00:39:25,432 --> 00:39:28,702
<c.magenta>当事件被触发时</c>

789
00:39:28,769 --> 00:39:29,937
<c.magenta>你会在哪儿处理它</c>

790
00:39:30,337 --> 00:39:31,672
<c.magenta>我们只需要标记线程</c>

791
00:39:32,472 --> 00:39:33,407
<c.magenta>不需要帮手</c>

792
00:39:34,241 --> 00:39:38,278
<c.magenta>在第一个可能的时间</c>

793
00:39:38,979 --> 00:39:42,349
<c.magenta>我们就会注意到那个线程被你标记了</c>

794
00:39:42,950 --> 00:39:45,652
<c.magenta>当我们让事件出列时需要隐藏时间</c>

795
00:39:46,153 --> 00:39:48,255
<c.magenta>藏在第一个处理器结束之后</c>

796
00:39:48,689 --> 00:39:51,191
<c.magenta>我们可以从内核中获取事件并查看</c>

797
00:39:51,258 --> 00:39:53,827
<c.magenta>然后把它们的处理器</c>

798
00:39:55,829 --> 00:39:59,032
<c.magenta>那么我们为什么</c>

799
00:39:59,867 --> 00:40:01,301
<c.magenta>原因是你</c>

800
00:39:59,867 --> 00:40:01,301
<c.magenta>原因是你</c>

801
00:40:01,635 --> 00:40:06,573
<c.magenta>这样可以理解如何最好地利用</c>

802
00:40:06,640 --> 00:40:09,843
<c.magenta>运行时间使用了</c>

803
00:40:09,910 --> 00:40:12,012
<c.magenta>在你的应用中优化行为</c>

804
00:40:13,213 --> 00:40:15,482
<c.magenta>并且进入按钮知道如何暗示</c>

805
00:40:15,549 --> 00:40:19,887
<c.magenta>以及何时正确地暗示运行时间</c>

806
00:40:21,955 --> 00:40:25,993
<c.magenta>这就导致我今天跟大家讲</c>

807
00:40:26,059 --> 00:40:29,997
<c.magenta>以最大限度地利用</c>

808
00:40:33,166 --> 00:40:35,369
<c.magenta>现在实际上只需要两个步骤</c>

809
00:40:35,802 --> 00:40:38,872
<c.magenta>就可以充分利用那个技术了</c>

810
00:40:38,939 --> 00:40:42,142
<c.magenta>第一个步骤是在激活后没有变化</c>

811
00:40:42,676 --> 00:40:45,279
<c.magenta>第二个步骤是特别关注</c>

812
00:40:45,345 --> 00:40:48,115
<c.magenta>目标队列等级</c>

813
00:40:49,116 --> 00:40:50,117
<c.magenta>那么这是什么意思？</c>

814
00:40:51,251 --> 00:40:53,887
<c.magenta>没有变化越过激活其实是说</c>

815
00:40:53,954 --> 00:40:57,724
<c.magenta>当你在调度对象上有任意属性时</c>

816
00:40:57,791 --> 00:41:01,161
<c.magenta>一旦你激活对象</c>

817
00:40:57,791 --> 00:41:01,161
<c.magenta>一旦你激活对象</c>

818
00:41:01,628 --> 00:41:02,796
<c.magenta>第二个例子</c>

819
00:41:04,398 --> 00:41:07,634
<c.magenta>这是我们在本场演讲中</c>

820
00:41:08,335 --> 00:41:10,671
<c.magenta>那个[听不清]能力</c>

821
00:41:11,772 --> 00:41:14,074
<c.magenta>并且你会设置一堆属性、处理器；</c>

822
00:41:14,141 --> 00:41:17,544
<c.magenta>事件处理器、同意处理器</c>

823
00:41:18,178 --> 00:41:21,481
<c.magenta>你甚至可以修改几次 这没问题</c>

824
00:41:22,983 --> 00:41:24,351
<c.magenta>当你激活源时</c>

825
00:41:26,353 --> 00:41:29,556
<c.magenta>这里的联系是你应该停止改变你的对象</c>

826
00:41:30,257 --> 00:41:31,391
<c.magenta>诱惑力很大</c>

827
00:41:31,692 --> 00:41:34,294
<c.magenta>事后 比如说修改源的目标队列</c>

828
00:41:34,361 --> 00:41:35,462
<c.magenta>那将会导致问题</c>

829
00:41:35,796 --> 00:41:38,732
<c.magenta>原因就是我早些时候所展示过的</c>

830
00:41:38,799 --> 00:41:42,603
<c.magenta>在激活时</c>

831
00:41:42,669 --> 00:41:45,606
<c.magenta>将来我们将按照那个快照做出决策</c>

832
00:41:46,907 --> 00:41:50,377
<c.magenta>如果你在事后修改了目标队列等级</c>

833
00:41:50,444 --> 00:41:53,447
<c.magenta>它会阻碍那个快照 使其失效</c>

834
00:41:53,514 --> 00:41:56,250
<c.magenta>那将会导致一些列非常重要的优化失败</c>

835
00:41:56,316 --> 00:41:59,653
<c.magenta>比如优先级倒置避免[听不清]GCD</c>

836
00:41:59,720 --> 00:42:02,556
<c.magenta>我之前展示的</c>

837
00:41:59,720 --> 00:42:02,556
<c.magenta>我之前展示的</c>

838
00:42:02,623 --> 00:42:04,024
<c.magenta>同步调度的直接切换</c>

839
00:42:04,091 --> 00:42:08,061
<c.magenta>这些都是我们刚刚看过的防御型</c>

840
00:42:10,564 --> 00:42:11,398
<c.magenta>我会坚持</c>

841
00:42:11,465 --> 00:42:14,635
<c.magenta>Daniel之前的观点</c>

842
00:42:15,235 --> 00:42:19,139
<c.magenta>就是你们中有许多人可能从来不需要</c>

843
00:42:19,206 --> 00:42:21,408
<c.magenta>这没问题 这就是它的运作方式</c>

844
00:42:22,242 --> 00:42:26,413
<c.magenta>你实际上很可能在系统框架中</c>

845
00:42:26,480 --> 00:42:30,484
<c.magenta>每次你有框架时 你就会调度队列</c>

846
00:42:30,551 --> 00:42:34,655
<c.magenta>它们会以你的名义在队列上</c>

847
00:42:34,721 --> 00:42:36,890
<c.magenta>在底层 它们拥有其中一个源</c>

848
00:42:37,224 --> 00:42:40,694
<c.magenta>那么如果你修改了系统的假设</c>

849
00:42:41,562 --> 00:42:43,463
<c.magenta>全部这些</c>

850
00:42:43,530 --> 00:42:44,364
<c.magenta>优化</c>

851
00:42:46,533 --> 00:42:50,804
<c.magenta>那么我希望很清楚地表达了一点</c>

852
00:42:50,871 --> 00:42:53,373
<c.magenta>非常重要 你必须保护它</c>

853
00:42:54,641 --> 00:42:57,511
<c.magenta>这是什么意思？需要怎么做？</c>

854
00:42:58,745 --> 00:43:00,848
<c.magenta>第一种方式是一个很简单的建议</c>

855
00:42:58,745 --> 00:43:00,848
<c.magenta>第一种方式是一个很简单的建议</c>

856
00:43:00,914 --> 00:43:02,583
<c.magenta>就是当你创建等级时</c>

857
00:43:03,250 --> 00:43:06,186
<c.magenta>从底部开始往顶部创建</c>

858
00:43:07,487 --> 00:43:11,959
<c.magenta>当你看到幻灯片上的这个树形图</c>

859
00:43:12,025 --> 00:43:15,529
<c.magenta>那儿有一些很宽的窟窿</c>

860
00:43:15,762 --> 00:43:18,398
<c.magenta>如果你按那个顺序创建</c>

861
00:43:20,467 --> 00:43:21,368
<c.magenta>然而</c>

862
00:43:21,435 --> 00:43:25,005
<c.magenta>当你有一个很大的应用或当你隐藏框架</c>

863
00:43:25,072 --> 00:43:28,242
<c.magenta>并把其中一个队列传给</c>

864
00:43:29,209 --> 00:43:33,881
<c.magenta>你们公司的另一个团队时</c>

865
00:43:34,248 --> 00:43:36,083
<c.magenta>你可能想锁定这些关系</c>

866
00:43:36,149 --> 00:43:38,619
<c.magenta>以便没有任何人可以在事后改变它们</c>

867
00:43:40,787 --> 00:43:42,389
<c.magenta>实际上你可以</c>

868
00:43:42,456 --> 00:43:45,359
<c.magenta>通过我们的一种叫作</c>

869
00:43:45,425 --> 00:43:49,730
<c.magenta>我们去年引入了这种技术</c>

870
00:43:49,796 --> 00:43:51,164
<c.magenta>你就可以停下来听我讲</c>

871
00:43:51,231 --> 00:43:54,067
<c.magenta>因为你已经在那种形式中了</c>

872
00:43:55,602 --> 00:43:58,939
<c.magenta>然而如果你有一个现有的基于云的应用</c>

873
00:43:59,006 --> 00:44:02,609
<c.magenta>你需要一些额外的步骤</c>

874
00:43:59,006 --> 00:44:02,609
<c.magenta>你需要一些额外的步骤</c>

875
00:44:05,812 --> 00:44:08,815
<c.magenta>那么让我们重点看一下</c>

876
00:44:09,783 --> 00:44:15,022
<c.magenta>当你用Objective-C创建时</c>

877
00:44:15,422 --> 00:44:18,158
<c.magenta>你创建你的队列 然后第二步</c>

878
00:44:18,225 --> 00:44:21,528
<c.magenta>把Q1的目标队列设置为EQ</c>

879
00:44:22,162 --> 00:44:24,498
<c.magenta>这并不会保护你的队列等级</c>

880
00:44:24,565 --> 00:44:27,467
<c.magenta>任何人都可以再次调用调度目标队列</c>

881
00:44:27,534 --> 00:44:28,836
<c.magenta>并打乱你的全部假设</c>

882
00:44:29,069 --> 00:44:30,137
<c.magenta>这可不妙</c>

883
00:44:30,904 --> 00:44:32,940
<c.magenta>有一个简单的步骤可以</c>

884
00:44:33,006 --> 00:44:34,908
<c.magenta>修复那段代码让它变得安全</c>

885
00:44:35,309 --> 00:44:38,612
<c.magenta>就是采用我们去年引入的一个新API</c>

886
00:44:38,679 --> 00:44:40,981
<c.magenta>即用调度目标队列的创建</c>

887
00:44:41,048 --> 00:44:43,283
<c.magenta>这是一个单一的自动化步骤</c>

888
00:44:43,350 --> 00:44:48,121
<c.magenta>将创建队列</c>

889
00:44:49,823 --> 00:44:51,491
<c.magenta>就是这样 这就是这两个步骤</c>

890
00:44:51,558 --> 00:44:53,427
<c.magenta>通过这两个步骤你可以</c>

891
00:44:53,493 --> 00:44:55,395
<c.magenta>很好地[听不清] 非常简单</c>

892
00:44:56,897 --> 00:45:01,535
<c.magenta>另外 与Daniel刚才给你们演示的</c>

893
00:44:56,897 --> 00:45:01,535
<c.magenta>另外 与Daniel刚才给你们演示的</c>

894
00:45:01,835 --> 00:45:04,671
<c.magenta>寻找何时做出了错误的决定</c>

895
00:45:04,738 --> 00:45:07,574
<c.magenta>非常具有挑战性</c>

896
00:45:07,641 --> 00:45:11,445
<c.magenta>我们发现在现有的基于云的应用中</c>

897
00:45:12,346 --> 00:45:16,450
<c.magenta>这也就是我们为什么</c>

898
00:45:16,517 --> 00:45:19,419
<c.magenta>来寻找现有应用中的问题点的原因</c>

899
00:45:19,987 --> 00:45:22,523
<c.magenta>我将把舞台交换给Daniel</c>

900
00:45:29,363 --> 00:45:30,197
<c.magenta>谢谢Pierre</c>

901
00:45:31,665 --> 00:45:32,766
<c.magenta>好的 让我们开始吧</c>

902
00:45:32,833 --> 00:45:35,969
<c.magenta>请注意我们即将看到的这个</c>

903
00:45:36,036 --> 00:45:38,672
<c.magenta>目前Xcode 9中还没有</c>

904
00:45:38,739 --> 00:45:42,176
<c.magenta>但你们很快就能用了</c>

905
00:45:43,277 --> 00:45:44,244
<c.magenta>那么对于这个演示</c>

906
00:45:44,311 --> 00:45:47,714
<c.magenta>让我们具体分析一下</c>

907
00:45:48,582 --> 00:45:50,584
<c.magenta>如果你点击底部的这个</c>

908
00:45:50,651 --> 00:45:54,388
<c.magenta>这个应用会向服务器</c>

909
00:45:54,454 --> 00:45:57,224
<c.magenta>以便读取URL列表</c>

910
00:45:57,291 --> 00:46:00,394
<c.magenta>然后就显示在WebViews中</c>

911
00:45:57,291 --> 00:46:00,394
<c.magenta>然后就显示在WebViews中</c>

912
00:46:01,161 --> 00:46:04,565
<c.magenta>那么让我们深入Xcode查看</c>

913
00:46:06,133 --> 00:46:10,971
<c.magenta>那么这是Xcode中的创建连接方法</c>

914
00:46:11,371 --> 00:46:13,140
<c.magenta>非常简单 我们有一个循环</c>

915
00:46:13,207 --> 00:46:16,543
<c.magenta>也许只是创建一些套接口</c>

916
00:46:17,277 --> 00:46:21,281
<c.magenta>我们通过其中一个调度读取</c>

917
00:46:21,348 --> 00:46:23,450
<c.magenta>就是我们在本场演讲中</c>

918
00:46:23,784 --> 00:46:25,686
<c.magenta>在这里查看API是受信任的</c>

919
00:46:26,553 --> 00:46:30,290
<c.magenta>然后我们可以为那个调度源</c>

920
00:46:30,357 --> 00:46:33,227
<c.magenta>当套接口可读时 我们就从中读取</c>

921
00:46:33,293 --> 00:46:36,029
<c.magenta>通过读取系统调用 直到没有可用数据</c>

922
00:46:36,763 --> 00:46:40,567
<c.magenta>一旦我们有了数据</c>

923
00:46:40,634 --> 00:46:42,569
<c.magenta>通过这个process 0方法</c>

924
00:46:43,670 --> 00:46:45,873
<c.magenta>那么让我们创建并运行</c>

925
00:46:45,939 --> 00:46:48,242
<c.magenta>了解它是如何执行的</c>

926
00:46:51,044 --> 00:46:53,413
<c.magenta>那么我们在仪表中</c>

927
00:46:53,480 --> 00:46:55,315
<c.magenta>除了系统追踪中的常见追踪</c>

928
00:46:55,382 --> 00:46:57,684
<c.magenta>我们还添加了这个新的GCD性能仪表</c>

929
00:46:58,085 --> 00:47:00,954
<c.magenta>当我们点击它时</c>

930
00:46:58,085 --> 00:47:00,954
<c.magenta>当我们点击它时</c>

931
00:47:01,021 --> 00:47:03,357
<c.magenta>被报告为有性能问题</c>

932
00:47:03,757 --> 00:47:06,159
<c.magenta>其中一个就是这个激活事件后改变</c>

933
00:47:06,226 --> 00:47:08,996
<c.magenta>我们还可以看到随着时间轴</c>

934
00:47:09,329 --> 00:47:11,498
<c.magenta>你还可以点击这里的一个事件</c>

935
00:47:11,565 --> 00:47:13,834
<c.magenta>比如在激活事件之后点击这个改变目标</c>

936
00:47:14,501 --> 00:47:18,138
<c.magenta>这个列表将会把我们直接带到那儿</c>

937
00:47:18,205 --> 00:47:21,642
<c.magenta>我们可以公开仪表右侧的向后追踪</c>

938
00:47:21,708 --> 00:47:24,745
<c.magenta>那将会给我们显示这个事件</c>

939
00:47:25,179 --> 00:47:28,215
<c.magenta>那么在这里比如说是</c>

940
00:47:29,550 --> 00:47:33,053
<c.magenta>如果我们双击这个框架</c>

941
00:47:33,120 --> 00:47:34,821
<c.magenta>问题所在的代码行</c>

942
00:47:35,389 --> 00:47:38,959
<c.magenta>这是几上是一个目标队列调用</c>

943
00:47:39,426 --> 00:47:41,528
<c.magenta>就像刚跟你说过的这个模式</c>

944
00:47:41,795 --> 00:47:44,031
<c.magenta>要修复这个问题</c>

945
00:47:44,097 --> 00:47:46,200
<c.magenta>用在Xcode中打开文件快捷按钮</c>

946
00:47:47,167 --> 00:47:49,736
<c.magenta>那么在这里</c>

947
00:47:49,803 --> 00:47:53,140
<c.magenta>的确是在这行 在事件处理器有调度源</c>

948
00:47:53,207 --> 00:47:54,942
<c.magenta>设置发生在激活之后</c>

949
00:47:55,475 --> 00:47:57,678
<c.magenta>那么在这个例子中 非常容易修复</c>

950
00:47:57,744 --> 00:48:01,648
<c.magenta>我们只需要把这两行往下挪</c>

951
00:47:57,744 --> 00:48:01,648
<c.magenta>我们只需要把这两行往下挪</c>

952
00:48:01,715 --> 00:48:04,852
<c.magenta>我们在设置源之后激活而不是之前</c>

953
00:48:05,519 --> 00:48:07,254
<c.magenta>那么让我们返回仪表并查看</c>

954
00:48:07,321 --> 00:48:09,556
<c.magenta>我们现在能在系统追踪中看到什么</c>

955
00:48:09,857 --> 00:48:13,193
<c.magenta>看起来跟以前一样</c>

956
00:48:13,260 --> 00:48:16,496
<c.magenta>你将看到没有检测到</c>

957
00:48:16,797 --> 00:48:18,765
<c.magenta>如果你用了这个仪表</c>

958
00:48:19,566 --> 00:48:22,669
<c.magenta>那么当然这对于这个应用来说很简单</c>

959
00:48:24,571 --> 00:48:26,840
<c.magenta>那么让我们重点看一下</c>

960
00:48:26,907 --> 00:48:29,376
<c.magenta>这会给我们显示许多网络事件处理器</c>

961
00:48:29,810 --> 00:48:32,179
<c.magenta>这些是我们应用中的源事件处理器</c>

962
00:48:32,679 --> 00:48:35,015
<c.magenta>那么你要如何设法</c>

963
00:48:35,616 --> 00:48:37,184
<c.magenta>实际上理解起来很有意思</c>

964
00:48:37,251 --> 00:48:39,720
<c.magenta>因为这是你可以应用到</c>

965
00:48:39,786 --> 00:48:42,256
<c.magenta>以在仪表中了解它是如何执行的</c>

966
00:48:43,790 --> 00:48:47,060
<c.magenta>嗯 让我们返回到Xcode</c>

967
00:48:47,127 --> 00:48:50,163
<c.magenta>当我们设置源及其源事件处理器时</c>

968
00:48:50,230 --> 00:48:53,000
<c.magenta>我们就对那个</c>

969
00:48:53,066 --> 00:48:55,102
<c.magenta>并尝试了解它的时间安排</c>

970
00:48:55,502 --> 00:48:56,737
<c.magenta>为了在仪表中看到它</c>

971
00:48:56,803 --> 00:48:59,806
<c.magenta>我们增加了</c>

972
00:48:59,873 --> 00:49:01,408
<c.magenta>放在处理器的开始</c>

973
00:48:59,873 --> 00:49:01,408
<c.magenta>放在处理器的开始</c>

974
00:49:01,475 --> 00:49:04,111
<c.magenta>以及kdebug signpost end函数</c>

975
00:49:04,378 --> 00:49:06,713
<c.magenta>这就是它所需要做的工作 让这段代码</c>

976
00:49:06,780 --> 00:49:10,217
<c.magenta>突出显示在仪表系统追踪的点追踪中</c>

977
00:49:10,951 --> 00:49:12,719
<c.magenta>那么如果你切换回仪表</c>

978
00:49:12,786 --> 00:49:15,756
<c.magenta>就是点追踪顶部的这些红点</c>

979
00:49:15,822 --> 00:49:19,293
<c.magenta>我们可以看到在向后追踪中</c>

980
00:49:19,359 --> 00:49:20,661
<c.magenta>与其中一个事件相匹配了</c>

981
00:49:21,562 --> 00:49:25,599
<c.magenta>如果你放大点追踪中的一个</c>

982
00:49:25,666 --> 00:49:28,335
<c.magenta>你可以看到有许多事件处理器</c>

983
00:49:28,402 --> 00:49:30,938
<c.magenta>非常紧凑地发生</c>

984
00:49:31,104 --> 00:49:33,640
<c.magenta>鼠标悬浮在其中一个处理器上</c>

985
00:49:33,707 --> 00:49:36,009
<c.magenta>它们只执行了非常短的一段时间</c>

986
00:49:36,343 --> 00:49:39,813
<c.magenta>弹出会告诉我们它所执行的时间长度</c>

987
00:49:39,880 --> 00:49:42,716
<c.magenta>我们甚至可以看到</c>

988
00:49:42,783 --> 00:49:45,619
<c.magenta>同时并发执行</c>

989
00:49:46,386 --> 00:49:48,121
<c.magenta>那么这是我们应用中的</c>

990
00:49:48,188 --> 00:49:50,290
<c.magenta>其中一个潜在的不利并行</c>

991
00:49:50,357 --> 00:49:52,326
<c.magenta>是看起来</c>

992
00:49:52,392 --> 00:49:54,328
<c.magenta>不会在代码中导致并行的东西</c>

993
00:49:54,394 --> 00:49:57,998
<c.magenta>但实际上却以并发方式</c>

994
00:49:58,065 --> 00:50:00,067
<c.magenta>并导致了潜在的额外情境切换</c>

995
00:49:58,065 --> 00:50:00,067
<c.magenta>并导致了潜在的额外情境切换</c>

996
00:50:01,468 --> 00:50:05,239
<c.magenta>那么为了更好地理解</c>

997
00:50:05,439 --> 00:50:07,674
<c.magenta>以及执行这段代码的系统追踪</c>

998
00:50:12,579 --> 00:50:14,448
<c.magenta>在这里我已经突出了三个辅助线程</c>

999
00:50:14,515 --> 00:50:16,149
<c.magenta>就是执行这些事件处理器的辅助线程</c>

1000
00:50:16,483 --> 00:50:20,387
<c.magenta>我们之前可以看到</c>

1001
00:50:20,921 --> 00:50:22,556
<c.magenta>这也是它们运行的时间</c>

1002
00:50:22,823 --> 00:50:24,892
<c.magenta>但在这里我们可以看到它们再一次</c>

1003
00:50:24,958 --> 00:50:27,761
<c.magenta>在这个区域运行了很短的时间</c>

1004
00:50:27,928 --> 00:50:31,565
<c.magenta>并且我们可以识别它们</c>

1005
00:50:31,632 --> 00:50:33,534
<c.magenta>是我们之前在事件处理器中看到的</c>

1006
00:50:34,134 --> 00:50:37,070
<c.magenta>我们可以通过再一次查看</c>

1007
00:50:37,137 --> 00:50:40,240
<c.magenta>并查看 是的就是我们在</c>

1008
00:50:40,307 --> 00:50:42,376
<c.magenta>且它从我们的套接口中</c>

1009
00:50:44,144 --> 00:50:46,613
<c.magenta>查看其它线程 重复了同一种模式</c>

1010
00:50:46,680 --> 00:50:49,049
<c.magenta>你可以看到那里发生的是</c>

1011
00:50:49,116 --> 00:50:50,851
<c.magenta>或多或少都在同一个时间框架中</c>

1012
00:50:50,918 --> 00:50:53,820
<c.magenta>那么也就是在第二个线程上</c>

1013
00:50:53,987 --> 00:50:56,790
<c.magenta>它们实际上做的是同样的事 重叠了</c>

1014
00:50:57,858 --> 00:51:01,161
<c.magenta>如果这些事在单一线程上执行</c>

1015
00:50:57,858 --> 00:51:01,161
<c.magenta>如果这些事在单一线程上执行</c>

1016
00:51:01,228 --> 00:51:02,496
<c.magenta>对于我们的程序来说会更棒</c>

1017
00:51:02,563 --> 00:51:05,199
<c.magenta>在这里我们并没有真正从并发中受益</c>

1018
00:51:05,265 --> 00:51:07,534
<c.magenta>因为我们执行的是这种很短的代码</c>

1019
00:51:07,901 --> 00:51:10,304
<c.magenta>很可能坏处大于益处</c>

1020
00:51:10,370 --> 00:51:12,206
<c.magenta>从添加这些额外情境切换的角度来说</c>

1021
00:51:13,040 --> 00:51:15,108
<c.magenta>那么让我们应用我们之前看到的模式</c>

1022
00:51:15,175 --> 00:51:17,344
<c.magenta>来修复这个示例应用中的这个问题</c>

1023
00:51:17,811 --> 00:51:19,146
<c.magenta>返回到Xcode</c>

1024
00:51:19,213 --> 00:51:21,849
<c.magenta>让我们看看我们要如何</c>

1025
00:51:23,050 --> 00:51:25,285
<c.magenta>那么当你在这个函数框架顶部</c>

1026
00:51:25,352 --> 00:51:28,155
<c.magenta>正如你所看到的</c>

1027
00:51:28,222 --> 00:51:30,691
<c.magenta>我们很简单地就实现了</c>

1028
00:51:31,458 --> 00:51:33,560
<c.magenta>那会创建一个独立的连续队列</c>

1029
00:51:33,627 --> 00:51:36,196
<c.magenta>并不会连接到我们应用中的任何东西</c>

1030
00:51:36,563 --> 00:51:38,465
<c.magenta>这根我们之前看到的例子一模一样</c>

1031
00:51:38,532 --> 00:51:40,934
<c.magenta>就是那个联网子系统的例子</c>

1032
00:51:41,635 --> 00:51:44,404
<c.magenta>那么让我们修复这个问题</c>

1033
00:51:44,471 --> 00:51:47,241
<c.magenta>通过在所有队列的底部为全部</c>

1034
00:51:47,608 --> 00:51:49,843
<c.magenta>我们通过添加 或通过切换到</c>

1035
00:51:49,910 --> 00:51:52,579
<c.magenta>调度队列 调度队列是通过</c>

1036
00:51:52,646 --> 00:51:54,248
<c.magenta>之前给你介绍的这个目标函数创建的</c>

1037
00:51:57,684 --> 00:51:59,920
<c.magenta>在这里我们添加了调度队列</c>

1038
00:52:00,220 --> 00:52:03,991
<c.magenta>并且我们将单一互斥队列</c>

1039
00:52:04,191 --> 00:52:06,693
<c.magenta>并且这个连续队列是我们</c>

1040
00:52:07,427 --> 00:52:10,664
<c.magenta>然后我们再次创建并运行</c>

1041
00:52:11,565 --> 00:52:12,833
<c.magenta>现在看起来很不一样了</c>

1042
00:52:14,434 --> 00:52:17,905
<c.magenta>在这里我们仍然有同样的点追踪</c>

1043
00:52:17,971 --> 00:52:21,808
<c.magenta>但正如你所看到的</c>

1044
00:52:21,875 --> 00:52:24,778
<c.magenta>并且有一个单一辅助线程</c>

1045
00:52:25,245 --> 00:52:27,014
<c.magenta>如果我们放大其中一个集群</c>

1046
00:52:27,080 --> 00:52:30,083
<c.magenta>我们可以看到这实际上是</c>

1047
00:52:30,150 --> 00:52:33,887
<c.magenta>接连不断地执行</c>

1048
00:52:34,221 --> 00:52:36,790
<c.magenta>当你再放大其中某个事件时</c>

1049
00:52:36,857 --> 00:52:40,260
<c.magenta>你可以看到它仍然执行</c>

1050
00:52:40,327 --> 00:52:42,296
<c.magenta>并做出了同样的读取系统调用</c>

1051
00:52:42,729 --> 00:52:44,598
<c.magenta>但现在问题小多了</c>

1052
00:52:44,665 --> 00:52:46,567
<c.magenta>因为这全部发生在一个单线程上</c>

1053
00:52:49,870 --> 00:52:50,704
<c.magenta>（找到问题点）</c>

1054
00:52:50,771 --> 00:52:53,373
<c.magenta>那么这看起来可能像是一个很简单、</c>

1055
00:52:53,440 --> 00:52:54,474
<c.magenta>但值得注意的是</c>

1056
00:52:54,541 --> 00:52:58,812
<c.magenta>正是这种小的调整导致</c>

1057
00:52:58,879 --> 00:53:01,381
<c.magenta>我们自己的某些框架代码的性能</c>

1058
00:52:58,879 --> 00:53:01,381
<c.magenta>我们自己的某些框架代码的性能</c>

1059
00:53:01,448 --> 00:53:03,150
<c.magenta>这正是Daniel在演讲</c>

1060
00:53:03,417 --> 00:53:06,019
<c.magenta>那么像这样的很小的修改</c>

1061
00:53:10,891 --> 00:53:13,360
<c.magenta>好了 让我们回顾一下</c>

1062
00:53:14,094 --> 00:53:16,063
<c.magenta>Daniel在一开始就跟大家具体谈了</c>

1063
00:53:16,129 --> 00:53:20,601
<c.magenta>在不必要的情况下不离开内核的方式</c>

1064
00:53:20,667 --> 00:53:22,836
<c.magenta>从而它可以达到最高效的性能状态</c>

1065
00:53:23,504 --> 00:53:27,474
<c.magenta>我们看了调整能力</c>

1066
00:53:27,541 --> 00:53:30,143
<c.magenta>以及在应用中的子系统之间</c>

1067
00:53:30,210 --> 00:53:32,446
<c.magenta>以及这些子系统内部的工作转移</c>

1068
00:53:33,113 --> 00:53:36,683
<c.magenta>我们还谈了如何通过GCD</c>

1069
00:53:36,750 --> 00:53:39,720
<c.magenta>通过在应用中使用固定数量的连续队列</c>

1070
00:53:40,087 --> 00:53:43,156
<c.magenta>并且Pierre跟你们一起演示了</c>

1071
00:53:43,223 --> 00:53:46,827
<c.magenta>以充分地利用OS中对硬件的改进</c>

1072
00:53:47,628 --> 00:53:49,663
<c.magenta>最后我们了解了如何使用仪表</c>

1073
00:53:49,730 --> 00:53:53,033
<c.magenta>在我们的应用中发现问题点</c>

1074
00:53:55,169 --> 00:53:58,772
<c.magenta>要获取更多关于本场演讲的信息</c>

1075
00:53:58,839 --> 00:54:03,477
<c.magenta>这里有GCD的文档链接以及演讲视频</c>

1076
00:53:58,839 --> 00:54:03,477
<c.magenta>这里有GCD的文档链接以及演讲视频</c>

1077
00:54:03,544 --> 00:54:07,681
<c.magenta>本周还有一些相关演讲</c>

1078
00:54:07,748 --> 00:54:11,185
<c.magenta>已经结束了的有Core ML介绍</c>

1079
00:54:11,251 --> 00:54:14,321
<c.magenta>会帮助你处理并行</c>

1080
00:54:14,388 --> 00:54:16,390
<c.magenta>在你的应用中</c>

1081
00:54:16,957 --> 00:54:20,827
<c.magenta>最后两场可以帮助你处理</c>

1082
00:54:20,894 --> 00:54:23,230
<c.magenta>和改善应用的不同方面</c>

1083
00:54:24,064 --> 00:54:26,066
<c.magenta>就这样了 我想谢谢大家的参与</c>

1084
00:54:26,133 --> 00:54:28,502
<c.magenta>如果你有任何疑问</c>
