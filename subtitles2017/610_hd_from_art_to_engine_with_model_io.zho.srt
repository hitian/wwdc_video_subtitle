1
00:00:28,836 --> 00:00:29,846
&gt;&gt; 大家好 我是 Nick

2
00:00:29,846 --> 00:00:30,336
Porcino

3
00:00:30,476 --> 00:00:32,116
我在游戏技术团队

4
00:00:32,116 --> 00:00:34,426
工作 今天在这里我想谈谈

5
00:00:34,426 --> 00:00:36,736
如何将你的艺术作品

6
00:00:36,826 --> 00:00:39,186
从最初的素材开始

7
00:00:39,186 --> 00:00:41,176
通过 Model I/O 引入到引擎

8
00:00:41,276 --> 00:00:41,676
欢迎大家

9
00:00:42,546 --> 00:00:46,006
所以在最开始 我想

10
00:00:46,006 --> 00:00:48,276
先帮大家回想一下 Model I/O 是什么

11
00:00:49,006 --> 00:00:50,766
Model I/O 是 Apple 为

12
00:00:50,766 --> 00:00:51,726
构建管道设计的成套工具

13
00:00:51,956 --> 00:00:53,776
你们可以用它来导入或导出 3D

14
00:00:53,776 --> 00:00:55,646
素材 包括多个行业的

15
00:00:55,646 --> 00:00:58,006
标准文件格式 例如

16
00:00:58,436 --> 00:01:00,546
常见的 Wavefront OBJ

17
00:00:58,436 --> 00:01:00,546
常见的 Wavefront OBJ

18
00:01:00,656 --> 00:01:02,206
以及更现代点的 像是

19
00:01:02,206 --> 00:01:03,056
Pixar 的 USD

20
00:01:03,646 --> 00:01:06,126
它可以描绘几何结构

21
00:01:06,126 --> 00:01:07,986
材质 光线照相机

22
00:01:08,086 --> 00:01:11,416
三维像素化 灯光以及

23
00:01:11,416 --> 00:01:12,126
各种其他的东西

24
00:01:12,566 --> 00:01:14,226
它也可以进行数据格式转换

25
00:01:14,556 --> 00:01:16,146
这样不管你所拿到的素材

26
00:01:16,146 --> 00:01:17,506
原始创作时是

27
00:01:17,506 --> 00:01:18,636
什么格式

28
00:01:18,806 --> 00:01:21,576
你都可以使它们符合

29
00:01:21,576 --> 00:01:22,866
特定的步幅和布局

30
00:01:22,866 --> 00:01:23,896
以满足 Metal 的需求

31
00:01:24,476 --> 00:01:25,416
另外还有各种

32
00:01:25,416 --> 00:01:27,196
处理工具 我们

33
00:01:27,196 --> 00:01:28,436
在演讲最后会简要地

34
00:01:28,436 --> 00:01:31,276
评价一下它们

35
00:01:31,486 --> 00:01:33,986
今年我们对

36
00:01:33,986 --> 00:01:35,356
Model I/O 做了很多改进

37
00:01:35,396 --> 00:01:37,486
这里我想向大家推荐

38
00:01:37,486 --> 00:01:39,196
我们的开发人员网站 帮助大家了解更多

39
00:01:39,416 --> 00:01:41,556
为了让大家

40
00:01:41,896 --> 00:01:43,046
大致了解接下来的内容

41
00:01:43,626 --> 00:01:44,676
我们对导入器

42
00:01:44,676 --> 00:01:45,206
做了改进

43
00:01:45,206 --> 00:01:46,936
我们得到过很多这样的反馈

44
00:01:46,936 --> 00:01:49,086
当他们加载了外部

45
00:01:49,136 --> 00:01:50,306
文件格式 他们就会遇到

46
00:01:50,306 --> 00:01:50,816
问题

47
00:01:50,816 --> 00:01:52,126
我们已经根据需求进行了

48
00:01:52,646 --> 00:01:53,486
修正

49
00:01:53,906 --> 00:01:54,986
我们引入了对

50
00:01:54,986 --> 00:01:56,276
蒙皮角色动画的支持

51
00:01:56,676 --> 00:01:57,856
这点稍后

52
00:01:57,856 --> 00:01:59,876
会讲到

53
00:02:00,376 --> 00:02:02,026
我们支持融合变形

54
00:02:02,306 --> 00:02:03,656
如果你有一个角色的两种表情

55
00:02:03,656 --> 00:02:04,936
微笑以及皱眉

56
00:02:04,936 --> 00:02:06,536
利用这个数据结构

57
00:02:06,536 --> 00:02:07,516
你可以实现两个表情间的转换

58
00:02:07,966 --> 00:02:09,346
并且我们还有变换栈

59
00:02:09,836 --> 00:02:12,426
对应数据在不同

60
00:02:12,426 --> 00:02:13,966
程序中的状态 例如

61
00:02:13,966 --> 00:02:16,796
在 Maya 中动画将被

62
00:02:16,796 --> 00:02:17,926
分为

63
00:02:17,926 --> 00:02:19,326
旋转 技巧

64
00:02:19,326 --> 00:02:21,046
翻译 并以特定

65
00:02:21,046 --> 00:02:21,406
的顺序摆放

66
00:02:22,196 --> 00:02:23,566
去年我们给了大家一个

67
00:02:23,566 --> 00:02:25,976
矩阵 今年我们能用

68
00:02:26,366 --> 00:02:28,516
你们在创作工具时用的

69
00:02:28,626 --> 00:02:30,406
同样的构件组成

70
00:02:30,406 --> 00:02:31,026
动画

71
00:02:31,866 --> 00:02:36,096
现在最重要的是 Model I/O

72
00:02:36,346 --> 00:02:38,076
能够让你们对你们的数据有

73
00:02:38,076 --> 00:02:38,446
统一的视图

74
00:02:39,096 --> 00:02:42,046
所以如果你打开一个素材

75
00:02:42,046 --> 00:02:43,226
不管它原本是什么格式

76
00:02:43,226 --> 00:02:45,276
Model I/O 将

77
00:02:45,276 --> 00:02:48,036
对它进行标准化 这样你就可以

78
00:02:48,036 --> 00:02:49,726
遍历它 写一个

79
00:02:49,726 --> 00:02:51,096
代码环 它将知道

80
00:02:51,096 --> 00:02:51,986
如何每次以统一的方式

81
00:02:51,986 --> 00:02:54,556
处理所有的数据

82
00:02:54,556 --> 00:02:55,836
对你加载的每一项素材

83
00:02:55,836 --> 00:02:56,836
都是如此

84
00:02:56,836 --> 00:02:58,306
这个我放到屏幕

85
00:02:58,306 --> 00:02:59,756
上的素材

86
00:03:00,126 --> 00:03:01,436
只是车的一个小

87
00:03:01,466 --> 00:03:01,876
部件

88
00:03:02,056 --> 00:03:03,446
它有一个摄像头 还有

89
00:03:03,446 --> 00:03:03,746
光

90
00:03:04,036 --> 00:03:05,216
这辆车被分解为

91
00:03:05,216 --> 00:03:05,956
各种部件

92
00:03:05,956 --> 00:03:06,956
它有各种不同的材质

93
00:03:07,836 --> 00:03:09,526
不管我加载的是何种场景

94
00:03:09,526 --> 00:03:11,696
它都将是这样的

95
00:03:11,696 --> 00:03:12,766
并且它非常容易

96
00:03:12,766 --> 00:03:13,246
遍历

97
00:03:13,396 --> 00:03:15,546
这也是为什么 Model I/O

98
00:03:16,196 --> 00:03:18,206
真的非常容易使用 并且在管道中

99
00:03:18,206 --> 00:03:18,776
非常有用 

100
00:03:20,686 --> 00:03:22,916
现在 我们想创造

101
00:03:22,916 --> 00:03:23,696
像这样的东西

102
00:03:23,696 --> 00:03:25,186
这将是我的一个小

103
00:03:25,936 --> 00:03:26,046
游戏

104
00:03:26,046 --> 00:03:28,476
这个游戏将由

105
00:03:28,476 --> 00:03:30,466
一些艺术素材组成 它们

106
00:03:30,466 --> 00:03:32,046
已经在另外一个工具中准备好了

107
00:03:32,166 --> 00:03:33,466
这个工具可以是 Maya Blender 或者

108
00:03:33,466 --> 00:03:34,146
任何其他你喜欢的工具

109
00:03:34,706 --> 00:03:36,456
然后还需要有模型

110
00:03:36,456 --> 00:03:37,716
需要有模型上的

111
00:03:37,716 --> 00:03:38,356
材料

112
00:03:38,636 --> 00:03:40,086
将有动画

113
00:03:40,776 --> 00:03:41,896
各种各样的纹理

114
00:03:42,356 --> 00:03:43,546
我们将会从各种

115
00:03:43,546 --> 00:03:45,556
不同的文件中整合

116
00:03:45,606 --> 00:03:46,126
一个场景

117
00:03:47,316 --> 00:03:51,626
一个艺术家在创造

118
00:03:51,626 --> 00:03:54,106
素材时 他们处于一个特别

119
00:03:54,146 --> 00:03:56,056
复杂的环境中

120
00:03:56,056 --> 00:03:57,676
有很多他们可以使用的工具

121
00:03:58,066 --> 00:04:00,776
对于艺术家来说 艺术作品以及

122
00:03:58,066 --> 00:04:00,776
对于艺术家来说 艺术作品以及

123
00:04:00,776 --> 00:04:02,846
Maya 和 Blender 这些工具的意义

124
00:04:02,846 --> 00:04:04,706
就像源代码

125
00:04:04,706 --> 00:04:05,246
对于程序员的意义

126
00:04:05,696 --> 00:04:07,106
它有各种各样

127
00:04:07,326 --> 00:04:08,546
对迭代和开发

128
00:04:08,546 --> 00:04:10,026
非常有用的东西 但是

129
00:04:10,076 --> 00:04:11,576
那些并不能让它被运用到

130
00:04:11,576 --> 00:04:12,036
运行中 

131
00:04:12,036 --> 00:04:12,896
你们不需要交付代码 你们

132
00:04:12,896 --> 00:04:13,906
要交付的是编译代码

133
00:04:14,516 --> 00:04:16,495
正如你们在应用程序中

134
00:04:17,396 --> 00:04:18,666
为你们的对象编写

135
00:04:18,666 --> 00:04:19,516
源一样 我们将

136
00:04:19,516 --> 00:04:21,976
编写适用于引擎的

137
00:04:21,976 --> 00:04:22,426
最佳素材

138
00:04:23,536 --> 00:04:26,296
现在 制作基于 UI 的小工具

139
00:04:26,296 --> 00:04:28,686
是非常有吸引力的

140
00:04:29,526 --> 00:04:30,926
所以也许通过一些拖放 以及

141
00:04:30,926 --> 00:04:32,056
很多其他的操作去点击

142
00:04:32,096 --> 00:04:33,206
滑动等

143
00:04:33,206 --> 00:04:34,756
去构造那个工具

144
00:04:34,876 --> 00:04:35,866
这个过程将会很有意思

145
00:04:35,866 --> 00:04:37,106
而且最初使用的几次

146
00:04:37,106 --> 00:04:37,736
也会很有意思

147
00:04:38,306 --> 00:04:40,796
但是当我完成我的第一辆车

148
00:04:40,926 --> 00:04:42,136
艺术家又给了我另外 12 辆

149
00:04:42,136 --> 00:04:43,576
车的时候 那么

150
00:04:43,576 --> 00:04:44,966
我就必须把他们都拖进来

151
00:04:44,966 --> 00:04:46,326
一次又一次地去重复

152
00:04:46,326 --> 00:04:47,416
点击同样的

153
00:04:47,416 --> 00:04:47,736
按钮吗

154
00:04:48,146 --> 00:04:49,346
那样这个工具很快就会变得

155
00:04:49,616 --> 00:04:51,256
让人非常有负担

156
00:04:51,886 --> 00:04:52,986
这里我们要讲讲

157
00:04:52,986 --> 00:04:56,966
如何通过管道批量处理

158
00:04:56,966 --> 00:04:57,526
这个操作

159
00:04:58,566 --> 00:05:00,566
我们将从图案

160
00:04:58,566 --> 00:05:00,566
我们将从图案

161
00:05:00,566 --> 00:05:01,156
开始

162
00:05:01,606 --> 00:05:03,506
我将使用一个导出器

163
00:05:03,686 --> 00:05:05,406
将它转换为素材

164
00:05:07,026 --> 00:05:08,696
我们将使用 Model I/O 将

165
00:05:08,696 --> 00:05:10,846
这个素材转换为

166
00:05:10,846 --> 00:05:11,846
引擎就绪数据

167
00:05:12,426 --> 00:05:14,806
我们将在我们的引擎里

168
00:05:14,806 --> 00:05:17,686
加载这个引擎就绪

169
00:05:17,686 --> 00:05:18,026
数据

170
00:05:18,076 --> 00:05:19,506
我们将把它转换为

171
00:05:19,506 --> 00:05:21,216
Metal 缓冲文件 然后 Metal

172
00:05:21,366 --> 00:05:22,336
将制作一张好看的图片

173
00:05:23,586 --> 00:05:28,656
所以第一步是

174
00:05:28,856 --> 00:05:29,686
导出艺术作品

175
00:05:30,246 --> 00:05:33,696
在我们的

176
00:05:33,696 --> 00:05:35,436
这个例子中 我们使用的是 Maya

177
00:05:35,766 --> 00:05:37,236
我们有一个 Python

178
00:05:37,236 --> 00:05:38,646
脚本 它将浏览 Maya

179
00:05:38,646 --> 00:05:39,566
找到所有的东西

180
00:05:40,116 --> 00:05:42,776
它遍历复杂的层级

181
00:05:42,776 --> 00:05:46,256
和文件 然后导出一个

182
00:05:46,256 --> 00:05:46,826
素材文件

183
00:05:47,556 --> 00:05:50,216
正如我之前提到的

184
00:05:50,316 --> 00:05:51,796
选择文件格式非常

185
00:05:51,796 --> 00:05:53,116
重要 我们不会

186
00:05:53,116 --> 00:05:54,906
使用齿轮处

187
00:05:54,906 --> 00:05:55,896
有点长的东西

188
00:05:55,896 --> 00:05:57,476
例如 Wavefront OBJ 我们将

189
00:05:58,506 --> 00:06:00,156
使用比较新的

190
00:05:58,506 --> 00:06:00,156
使用比较新的

191
00:06:00,156 --> 00:06:01,486
现代的东西 也就是 Pixar 的

192
00:06:01,486 --> 00:06:02,736
USD 文件

193
00:06:02,736 --> 00:06:03,146
格式

194
00:06:03,146 --> 00:06:06,956
现在我们要简要

195
00:06:06,956 --> 00:06:10,106
介绍一下它 首先

196
00:06:10,346 --> 00:06:11,166
它有一个网站

197
00:06:11,166 --> 00:06:12,476
你可以在那儿看到网址

198
00:06:12,476 --> 00:06:15,086
在这里你可以找到

199
00:06:15,086 --> 00:06:16,186
你可能想知道的关于

200
00:06:16,186 --> 00:06:17,476
USD 的细节和各种

201
00:06:18,066 --> 00:06:18,686
信息

202
00:06:18,826 --> 00:06:21,546
现在可以在他们的网站上

203
00:06:21,546 --> 00:06:22,706
找到 Pixar 的 USD 文件格式

204
00:06:22,706 --> 00:06:25,646
这些文件多年以来用于

205
00:06:25,646 --> 00:06:27,146
制作动画

206
00:06:27,146 --> 00:06:27,866
长片

207
00:06:28,266 --> 00:06:30,436
大家可能还

208
00:06:30,436 --> 00:06:31,966
记得在去年的 SceneKit

209
00:06:31,966 --> 00:06:33,416
展示 我们把

210
00:06:33,416 --> 00:06:35,276
USD 整合到

211
00:06:35,276 --> 00:06:37,676
iOS 和 macOS

212
00:06:37,676 --> 00:06:39,366
操作系统当中

213
00:06:39,836 --> 00:06:41,326
我们一直在和

214
00:06:41,326 --> 00:06:43,126
Pixar 共同努力以不断改善

215
00:06:43,126 --> 00:06:45,166
整合情况 并且添加了

216
00:06:45,166 --> 00:06:45,826
新的功能

217
00:06:46,536 --> 00:06:49,556
那么是什么让 USD

218
00:06:49,556 --> 00:06:52,006
变得比之前所有的

219
00:06:52,836 --> 00:06:54,556
都更强大呢

220
00:06:54,556 --> 00:06:57,226
正是因为我们

221
00:06:57,226 --> 00:06:58,826
把大量的文件

222
00:06:58,996 --> 00:07:00,346
组合在一起

223
00:06:58,996 --> 00:07:00,346
组合在一起

224
00:07:00,346 --> 00:07:01,486
创造一个复杂的场景

225
00:07:02,006 --> 00:07:04,376
在这个样本里

226
00:07:04,376 --> 00:07:07,426
我从我们的赛道里面

227
00:07:07,776 --> 00:07:09,826
拆出了一些部件 或者从我们

228
00:07:09,826 --> 00:07:12,266
有赛道的游戏里面 然后把它们运用到

229
00:07:12,266 --> 00:07:13,766
建筑物 赛道 轮胎 

230
00:07:13,766 --> 00:07:15,286
墙壁 车辆以及一些轮子中 

231
00:07:15,696 --> 00:07:17,566
我们逐级将这些

232
00:07:17,566 --> 00:07:19,356
组合成一个单独的

233
00:07:19,356 --> 00:07:19,686
文件

234
00:07:20,256 --> 00:07:22,006
正如我之前给你们看的

235
00:07:22,006 --> 00:07:24,496
那张表格 Model I/O

236
00:07:24,496 --> 00:07:26,296
将把一切都解读为

237
00:07:27,076 --> 00:07:28,576
容易遍历的格式

238
00:07:28,676 --> 00:07:30,396
当我们只要将文件加载到

239
00:07:30,396 --> 00:07:31,806
Model I/O 中就可以实现这点

240
00:07:32,476 --> 00:07:34,726
还有一件特别棒的事

241
00:07:34,906 --> 00:07:36,416
另外一个你们可以从

242
00:07:36,416 --> 00:07:37,826
USD 中得到的特别棒的东西

243
00:07:37,826 --> 00:07:39,196
就是变化的概念

244
00:07:39,556 --> 00:07:42,116
这对艺术家来说是一个

245
00:07:42,116 --> 00:07:43,556
非常强大的工具

246
00:07:43,556 --> 00:07:44,156
他们可以用它来创造

247
00:07:44,156 --> 00:07:44,596
场景

248
00:07:44,596 --> 00:07:46,006
如果你希望跑道上

249
00:07:46,006 --> 00:07:47,516
有很多车 我可以用

250
00:07:47,516 --> 00:07:49,156
USD 做的就是先做一个汽车

251
00:07:49,156 --> 00:07:50,826
文件 然后我可以获得

252
00:07:50,826 --> 00:07:51,996
各种颜色的变化

253
00:07:52,036 --> 00:07:53,306
大家可以看到这里有黄色的

254
00:07:53,306 --> 00:07:54,176
绿色的 红色的

255
00:07:54,486 --> 00:07:56,626
还有各种模型的变化

256
00:07:56,626 --> 00:07:58,026
有翼片的和没有翼片的

257
00:07:58,546 --> 00:07:59,996
我可以在文件里引用它们

258
00:07:59,996 --> 00:08:02,246
选择我所需要的

259
00:07:59,996 --> 00:08:02,246
选择我所需要的

260
00:08:02,246 --> 00:08:04,536
版本 然后 Model I/O

261
00:08:04,826 --> 00:08:05,826
将会对它们进行平面化

262
00:08:05,826 --> 00:08:06,946
这样当你在

263
00:08:06,946 --> 00:08:08,426
遍历数据结构

264
00:08:08,426 --> 00:08:10,096
寻找你的

265
00:08:10,096 --> 00:08:12,016
缓冲数据时 它将为你

266
00:08:12,016 --> 00:08:12,886
找到合适的东西

267
00:08:13,586 --> 00:08:16,326
我还想提到的一点是

268
00:08:16,376 --> 00:08:17,966
USD 有

269
00:08:18,336 --> 00:08:21,536
ASCII 格式以及一个快速的二进制

270
00:08:21,536 --> 00:08:21,976
格式

271
00:08:22,386 --> 00:08:25,266
网格由成千上万的

272
00:08:25,266 --> 00:08:26,546
顶点和法线等组成

273
00:08:26,546 --> 00:08:27,626
我将把它输出为

274
00:08:27,626 --> 00:08:28,306
二进制

275
00:08:28,736 --> 00:08:30,496
但是另一方面 如果我只是

276
00:08:30,496 --> 00:08:31,816
随机地使用这个

277
00:08:31,816 --> 00:08:35,285
数据 我可以写一个

278
00:08:35,285 --> 00:08:37,326
像这样的文本 这里我

279
00:08:37,356 --> 00:08:41,285
有一个有关

280
00:08:41,285 --> 00:08:44,626
一辆车的动画世界 这个车将被引用

281
00:08:45,066 --> 00:08:47,146
我只是改变了

282
00:08:47,146 --> 00:08:49,476
这辆车的颜色 并且我把它放在

283
00:08:49,476 --> 00:08:50,686
动画场景中

284
00:08:50,686 --> 00:08:52,116
大家知道它并不是根据它的

285
00:08:52,426 --> 00:08:53,536
通用规则来进行动画绘制的

286
00:08:54,356 --> 00:08:56,796
这点对

287
00:08:56,796 --> 00:08:58,686
创造变化和

288
00:08:58,686 --> 00:09:00,706
离线试验迭代素材来说

289
00:08:58,686 --> 00:09:00,706
离线试验迭代素材来说

290
00:09:01,116 --> 00:09:01,726
具有十分强大的功能

291
00:09:02,486 --> 00:09:06,056
我们将构建的是

292
00:09:06,056 --> 00:09:07,746
一个小的工具 它将

293
00:09:07,906 --> 00:09:08,796
把 USD

294
00:09:08,796 --> 00:09:10,736
素材转化为

295
00:09:10,876 --> 00:09:13,856
引擎就绪的数据

296
00:09:14,046 --> 00:09:16,016
命令行工具

297
00:09:16,816 --> 00:09:19,296
拥有命令行工具

298
00:09:19,296 --> 00:09:20,696
可以给我们带来的

299
00:09:20,696 --> 00:09:22,356
好处就是

300
00:09:22,356 --> 00:09:22,796
可复制性

301
00:09:22,856 --> 00:09:24,096
它可复制是因为具有

302
00:09:24,096 --> 00:09:25,076
命令行参数

303
00:09:26,306 --> 00:09:27,836
这些工具的操作可以保持

304
00:09:28,076 --> 00:09:29,396
一致因为我们有

305
00:09:29,396 --> 00:09:30,896
定义良好的输入和输出

306
00:09:30,896 --> 00:09:31,946
以及参数

307
00:09:31,946 --> 00:09:34,006
它将可编写脚本

308
00:09:34,506 --> 00:09:36,606
你可以分批处理你的工具

309
00:09:36,606 --> 00:09:37,846
将你的工具排好顺序

310
00:09:39,096 --> 00:09:39,806
它将给我们带来

311
00:09:39,866 --> 00:09:41,406
可扩展性 这是

312
00:09:41,406 --> 00:09:42,396
图形用户

313
00:09:42,396 --> 00:09:44,876
界面工具所没有的 因为我们

314
00:09:44,876 --> 00:09:46,406
可以不中断地进行

315
00:09:46,406 --> 00:09:47,076
自动操作

316
00:09:47,536 --> 00:09:49,276
例如 艺术家可能

317
00:09:49,276 --> 00:09:50,786
在某处有一个 Dropbox 文件

318
00:09:51,126 --> 00:09:51,966
他们会把

319
00:09:51,966 --> 00:09:53,366
所有的素材都放进去

320
00:09:53,366 --> 00:09:54,486
无论何时 只要他们准备好将它们整合进

321
00:09:54,486 --> 00:09:55,816
引擎 我们

322
00:09:55,816 --> 00:09:57,076
都可以用一个小脚本

323
00:09:57,076 --> 00:09:58,386
对该目录进行监测

324
00:09:59,046 --> 00:10:00,316
任何时候当它注意到有新

325
00:09:59,046 --> 00:10:00,316
任何时候当它注意到有新

326
00:10:00,316 --> 00:10:02,286
文件时 我们将要介绍的

327
00:10:02,286 --> 00:10:03,426
处理器

328
00:10:03,476 --> 00:10:05,336
将自动运行 使文件

329
00:10:05,336 --> 00:10:07,106
引擎就绪 然后移动它

330
00:10:07,466 --> 00:10:09,046
这样当你们构建 Xcode 时

331
00:10:09,156 --> 00:10:10,036
所有的素材将被

332
00:10:10,036 --> 00:10:11,826
自动导入

333
00:10:11,826 --> 00:10:12,396
为你们的游戏做好准备

334
00:10:13,576 --> 00:10:15,136
最后 这种工具

335
00:10:15,136 --> 00:10:16,616
是可组合的 这正是

336
00:10:16,616 --> 00:10:18,266
表格右边的小弧线

337
00:10:18,266 --> 00:10:19,676
所表明的

338
00:10:20,186 --> 00:10:21,466
如果我们的场景中有多个工具

339
00:10:21,496 --> 00:10:23,516
它是可组合的

340
00:10:23,516 --> 00:10:24,536
它们都可以读写

341
00:10:24,536 --> 00:10:26,546
同样的数据块 然后我就

342
00:10:26,676 --> 00:10:28,326
可以将一个工具送进另外一个中

343
00:10:28,326 --> 00:10:30,236
我可以用一个工具来

344
00:10:30,236 --> 00:10:32,826
提取所有的网格 然后对它们进行

345
00:10:32,826 --> 00:10:33,446
光照贴图

346
00:10:33,446 --> 00:10:35,086
我可能做另外一个工具来寻找

347
00:10:35,086 --> 00:10:36,316
所有的纹理 然后做一个

348
00:10:36,316 --> 00:10:36,956
纹理清单

349
00:10:37,426 --> 00:10:39,016
我做了很多像这样的小工具

350
00:10:39,016 --> 00:10:40,266
然后把他们一起放进

351
00:10:40,716 --> 00:10:41,916
工作流程中

352
00:10:43,196 --> 00:10:47,136
所以 这个样本

353
00:10:47,136 --> 00:10:47,656
还是非常简单的

354
00:10:48,006 --> 00:10:49,976
它并不像很多其他的

355
00:10:49,976 --> 00:10:52,276
最佳实践

356
00:10:52,276 --> 00:10:54,316
它只是为了给大家

357
00:10:54,316 --> 00:10:55,866
一个简化的数据格式

358
00:10:55,866 --> 00:10:57,026
让大家更容易理解

359
00:10:57,186 --> 00:10:58,266
这样大家便可以将

360
00:10:58,266 --> 00:10:59,276
我们所讲的与你们

361
00:10:59,276 --> 00:10:59,886
在代码中所看到的相匹配

362
00:11:00,386 --> 00:11:01,446
其中并没有压缩 因为

363
00:11:01,536 --> 00:11:02,646
你们不会想模糊

364
00:11:02,646 --> 00:11:03,746
正在进行的操作

365
00:11:04,766 --> 00:11:06,036
它的目的是成为你们

366
00:11:06,036 --> 00:11:08,816
开始构建你们自己的

367
00:11:08,816 --> 00:11:10,476
管道工具的起点

368
00:11:10,476 --> 00:11:11,986
用它们匹配

369
00:11:11,986 --> 00:11:13,336
你们自己的引擎和数据

370
00:11:13,336 --> 00:11:13,916
格式

371
00:11:14,336 --> 00:11:17,196
我还想谈一点

372
00:11:17,196 --> 00:11:18,626
有关我们组合在一起的

373
00:11:18,626 --> 00:11:19,406
玩具引擎

374
00:11:20,856 --> 00:11:21,786
它内部有一个非常简单的

375
00:11:21,786 --> 00:11:22,576
渲染程序

376
00:11:22,576 --> 00:11:23,676
它都是用 Swift 和

377
00:11:23,676 --> 00:11:23,976
Metal 编写的

378
00:11:24,356 --> 00:11:25,536
它是一个单通道的

379
00:11:25,536 --> 00:11:26,826
渲染程序 基于实物的

380
00:11:26,826 --> 00:11:28,986
着色器 对象副本 蒙皮

381
00:11:28,986 --> 00:11:30,976
骨骼动画以及多种

382
00:11:30,976 --> 00:11:31,456
材质 

383
00:11:32,176 --> 00:11:34,596
那里标出了好多

384
00:11:34,596 --> 00:11:35,076
要点

385
00:11:35,806 --> 00:11:37,186
它有一个非常直接的

386
00:11:37,186 --> 00:11:37,776
渲染循环

387
00:11:38,216 --> 00:11:39,846
在左边我们有

388
00:11:39,846 --> 00:11:41,796
那个表格以及一些需要绘制的网格

389
00:11:42,876 --> 00:11:44,326
对于我们想画的所有事物

390
00:11:44,326 --> 00:11:45,526
我们都会设置

391
00:11:46,016 --> 00:11:47,736
转换缓冲 蒙皮数据

392
00:11:47,736 --> 00:11:49,466
顶点缓冲 设置我们的管道

393
00:11:49,466 --> 00:11:51,326
状态 材质均一

394
00:11:51,646 --> 00:11:52,606
以及碎片纹理

395
00:11:52,906 --> 00:11:53,836
我们将会为制作

396
00:11:54,106 --> 00:11:55,536
好看的画面而绘制

397
00:11:55,536 --> 00:11:55,896
索引的原语

398
00:11:56,526 --> 00:11:59,776
我们把那个工具叫作

399
00:11:59,776 --> 00:12:00,466
baker 

400
00:11:59,776 --> 00:12:00,466
baker 

401
00:12:01,706 --> 00:12:03,666
那么我们要烤什么呢

402
00:12:06,136 --> 00:12:08,246
首先 我们要烤

403
00:12:08,246 --> 00:12:09,586
几何结构和

404
00:12:09,586 --> 00:12:11,246
变换 事物的

405
00:12:11,246 --> 00:12:12,896
样子 其所在位置

406
00:12:14,006 --> 00:12:16,016
纹理路径以及材质

407
00:12:16,016 --> 00:12:17,146
这样在我们绘制那些

408
00:12:17,146 --> 00:12:18,076
东西的时候 我们知道

409
00:12:18,076 --> 00:12:18,776
它们将呈现的样子

410
00:12:19,316 --> 00:12:20,836
实例化数据 这样当我们有

411
00:12:21,236 --> 00:12:23,026
多个轮子的时候 将

412
00:12:23,026 --> 00:12:24,296
有信息可以告诉

413
00:12:24,296 --> 00:12:26,366
我们如何高效地将那个轮子的

414
00:12:26,366 --> 00:12:27,606
多个副本放在何处

415
00:12:28,356 --> 00:12:30,146
转换动画 这样就

416
00:12:30,146 --> 00:12:31,536
可以让事物进行动画化

417
00:12:32,216 --> 00:12:33,866
最后我们将谈一下

418
00:12:33,866 --> 00:12:35,196
蒙皮和角色

419
00:12:35,196 --> 00:12:35,696
动画

420
00:12:36,306 --> 00:12:40,116
首先是几何机构和

421
00:12:40,116 --> 00:12:41,046
转换

422
00:12:42,496 --> 00:12:44,666
了解基本计算机

423
00:12:44,666 --> 00:12:45,656
绘图的话 你应该

424
00:12:45,656 --> 00:12:47,046
熟悉场景图

425
00:12:47,806 --> 00:12:48,946
这里我们有一个转换

426
00:12:48,946 --> 00:12:49,786
层级 

427
00:12:49,926 --> 00:12:51,926
有转换节点 A

428
00:12:51,926 --> 00:12:52,756
和 B

429
00:12:53,126 --> 00:12:55,426
A 可能是一个世界节点

430
00:12:55,586 --> 00:12:56,826
它可能只是提供

431
00:12:56,826 --> 00:12:57,816
一个恒等

432
00:12:57,816 --> 00:12:58,616
变换

433
00:12:58,616 --> 00:13:01,196
B 是一个转换节点 它说明

434
00:12:58,616 --> 00:13:01,196
B 是一个转换节点 它说明

435
00:13:01,196 --> 00:13:02,436
了车在世界中所处的位置

436
00:13:02,966 --> 00:13:05,686
我的赛车现在只有一个轮子

437
00:13:05,686 --> 00:13:06,566
假装你们可以在

438
00:13:06,566 --> 00:13:07,776
我的幻灯片下面看到

439
00:13:07,776 --> 00:13:08,296
其他的轮子

440
00:13:08,806 --> 00:13:10,086
我们还有车身

441
00:13:10,946 --> 00:13:14,756
转换层级工作的方式是

442
00:13:14,756 --> 00:13:16,976
如果我移动了

443
00:13:16,976 --> 00:13:18,236
母节点 那个母节点

444
00:13:18,236 --> 00:13:19,286
下面的一切

445
00:13:19,446 --> 00:13:23,036
都会作为整体一起移动

446
00:13:23,176 --> 00:13:25,666
我们想做的是 

447
00:13:25,666 --> 00:13:26,976
要把那个信息放入

448
00:13:27,356 --> 00:13:29,316
我们的引擎中 这样它

449
00:13:29,316 --> 00:13:30,196
马上就可以对其进行渲染

450
00:13:30,526 --> 00:13:32,836
我们希望简洁地进行编码

451
00:13:32,836 --> 00:13:34,736
使操作容易

452
00:13:34,736 --> 00:13:36,126
存储并且

453
00:13:36,126 --> 00:13:37,586
不需要我去修复

454
00:13:37,586 --> 00:13:39,706
指示器或者任何其他的

455
00:13:40,256 --> 00:13:40,366
此类事物

456
00:13:40,586 --> 00:13:42,866
我将要做的是

457
00:13:42,866 --> 00:13:43,826
平面化

458
00:13:43,826 --> 00:13:46,056
并且直线化那个

459
00:13:46,056 --> 00:13:46,426
队列

460
00:13:46,836 --> 00:13:47,836
我希望我不需要再说

461
00:13:47,836 --> 00:13:48,216
那个单词了

462
00:13:48,796 --> 00:13:52,016
我们将进行一队列的

463
00:13:52,186 --> 00:13:53,666
本地转换

464
00:13:53,966 --> 00:13:56,446
第一个可能是

465
00:13:56,446 --> 00:13:58,216
世界

466
00:13:58,276 --> 00:13:59,226
矩阵

467
00:13:59,946 --> 00:14:01,526
然后有另外一个矩阵告诉我们

468
00:13:59,946 --> 00:14:01,526
然后有另外一个矩阵告诉我们

469
00:14:01,526 --> 00:14:02,406
车的位置

470
00:14:03,276 --> 00:14:05,046
另外一个矩阵告诉我

471
00:14:05,046 --> 00:14:06,296
轮子在哪里

472
00:14:07,276 --> 00:14:08,556
另外一个矩阵告诉我

473
00:14:08,556 --> 00:14:09,436
车身在哪里

474
00:14:09,436 --> 00:14:12,286
我将分配指标

475
00:14:12,286 --> 00:14:13,056
因为稍后它们将会

476
00:14:13,056 --> 00:14:14,126
非常有用

477
00:14:14,566 --> 00:14:16,586
0 1 2 3 将是

478
00:14:16,616 --> 00:14:20,386
场景图的

479
00:14:20,956 --> 00:14:21,086
中序遍历

480
00:14:21,266 --> 00:14:22,776
现在我将对那棵树

481
00:14:22,776 --> 00:14:23,336
进行编码

482
00:14:24,176 --> 00:14:25,436
我将编写另外

483
00:14:25,436 --> 00:14:26,606
一队列母指标

484
00:14:26,726 --> 00:14:29,176
第一条是 nil

485
00:14:29,176 --> 00:14:32,086
这个世界没有亲项

486
00:14:33,156 --> 00:14:36,626
这辆车的 root B 的亲项在

487
00:14:36,626 --> 00:14:38,166
索引 0 中 也就是世界

488
00:14:39,716 --> 00:14:42,926
轮子的亲项在

489
00:14:43,106 --> 00:14:45,216
B 转换节点下 其他的

490
00:14:45,216 --> 00:14:46,246
轮子也将是如此

491
00:14:47,456 --> 00:14:49,666
车身的亲项也在

492
00:14:49,666 --> 00:14:50,156
那个节点之下

493
00:14:51,126 --> 00:14:53,896
所以我们编码了一个图表

494
00:14:54,546 --> 00:14:55,836
最后我们希望能够

495
00:14:55,836 --> 00:14:57,516
告诉引擎需要

496
00:14:57,516 --> 00:14:59,136
绘制什么 所以我们将绘制

497
00:14:59,136 --> 00:15:01,186
一个轮子 它在索引 2 下面

498
00:14:59,136 --> 00:15:01,186
一个轮子 它在索引 2 下面

499
00:15:01,296 --> 00:15:03,196
然后我们将绘制在

500
00:15:03,456 --> 00:15:04,606
索引 3 的车身

501
00:15:05,476 --> 00:15:08,756
我们用特别容易

502
00:15:08,936 --> 00:15:09,906
编写的方式描述了

503
00:15:09,906 --> 00:15:10,266
我们的场景

504
00:15:11,586 --> 00:15:13,606
现在我们也只需要

505
00:15:13,606 --> 00:15:14,596
描述需要画的内容

506
00:15:15,056 --> 00:15:17,196
这将是一个顶点

507
00:15:17,196 --> 00:15:19,936
描述符 也就是将

508
00:15:19,936 --> 00:15:21,216
告诉 Metal 以下信息的队列

509
00:15:21,216 --> 00:15:22,526
这些是标准的 这些是纹理

510
00:15:22,526 --> 00:15:23,496
坐标 这些是

511
00:15:23,496 --> 00:15:25,476
位置 真正的顶点可以

512
00:15:25,476 --> 00:15:26,476
自行缓冲

513
00:15:26,476 --> 00:15:28,316
然后索引缓冲器

514
00:15:28,316 --> 00:15:29,876
会表明这些

515
00:15:30,096 --> 00:15:31,346
指数对应

516
00:15:31,346 --> 00:15:32,966
这些顶点缓冲区里的三角形

517
00:15:33,526 --> 00:15:38,336
有了我们一致的

518
00:15:38,916 --> 00:15:39,886
数据结构 是很容易

519
00:15:39,886 --> 00:15:40,436
做到这点的

520
00:15:40,956 --> 00:15:41,986
我们会把所有的对象

521
00:15:41,986 --> 00:15:44,566
放在 MDLAsset 对象里运行一遍

522
00:15:44,716 --> 00:15:46,656
在我们导入它之后

523
00:15:47,396 --> 00:15:50,036
如果对象可以被放入

524
00:15:50,116 --> 00:15:52,956
MDLMesh 里面铸造 我们将拿出 MDLMesh

525
00:15:52,956 --> 00:15:54,896
以及顶点描述符 它将

526
00:15:54,896 --> 00:15:56,166
告诉我们是否获得

527
00:15:56,166 --> 00:15:59,026
位置及正常状态

528
00:15:59,086 --> 00:16:00,696
对于在网格里的所有

529
00:15:59,086 --> 00:16:00,696
对于在网格里的所有

530
00:16:00,816 --> 00:16:02,436
顶点缓冲区 我们

531
00:16:02,436 --> 00:16:04,366
将根据顶点缓冲区和

532
00:16:04,616 --> 00:16:07,196
其长度创建 NSData 

533
00:16:07,476 --> 00:16:09,536
点点点

534
00:16:09,536 --> 00:16:10,696
会告诉我们要

535
00:16:10,696 --> 00:16:12,016
把 NSData 存储在

536
00:16:12,016 --> 00:16:13,406
某处供编码使用

537
00:16:13,946 --> 00:16:17,166
然后我们将在

538
00:16:17,166 --> 00:16:18,356
子网格中运行 这里要快速

539
00:16:18,576 --> 00:16:20,006
介绍一下什么是子网格

540
00:16:20,396 --> 00:16:21,536
因为我刚刚提到了

541
00:16:21,536 --> 00:16:22,786
这个词 我们可以想想

542
00:16:22,786 --> 00:16:24,266
轮子 轮子有

543
00:16:24,266 --> 00:16:26,266
一个橡胶轮胎和一个金属圈

544
00:16:26,386 --> 00:16:26,606
对吧

545
00:16:27,036 --> 00:16:28,356
所以我们可能将有

546
00:16:28,356 --> 00:16:29,866
两种材质 所以需要有两种

547
00:16:29,866 --> 00:16:30,526
绘制调用

548
00:16:30,966 --> 00:16:31,756
但是它还是一个网格

549
00:16:31,756 --> 00:16:32,706
他们将共用很多

550
00:16:32,706 --> 00:16:33,826
顶点 例如

551
00:16:33,826 --> 00:16:35,696
轮胎和金属圈之间的

552
00:16:35,696 --> 00:16:36,106
交叉点

553
00:16:36,106 --> 00:16:37,426
所以我们将创建两个

554
00:16:37,426 --> 00:16:40,336
子网格用来索引金属圈

555
00:16:40,586 --> 00:16:42,466
以及轮胎 他们都有自己

556
00:16:42,466 --> 00:16:44,566
独立的索引缓冲器和

557
00:16:44,566 --> 00:16:44,976
网格

558
00:16:45,196 --> 00:16:47,386
我们将运行它们 然后

559
00:16:47,536 --> 00:16:47,686
铸造它们

560
00:16:47,686 --> 00:16:49,146
如果我们成功地铸造了它们 我们就

561
00:16:49,146 --> 00:16:51,896
创建了一些 NSData

562
00:16:51,896 --> 00:16:52,626
并且可以将之存储起来

563
00:16:53,256 --> 00:16:55,946
最后对于素材里面的所有

564
00:16:57,126 --> 00:16:59,136
对象 我们将

565
00:16:59,136 --> 00:17:01,696
发现对象是否进行过

566
00:16:59,136 --> 00:17:01,696
发现对象是否进行过

567
00:17:01,696 --> 00:17:04,425
变换 然后拿到它的

568
00:17:04,425 --> 00:17:05,856
矩阵 然后把它存在

569
00:17:05,856 --> 00:17:06,116
队列中  

570
00:17:06,766 --> 00:17:08,526
完善 NSEncode 并将之归档

571
00:17:08,945 --> 00:17:10,316
这些是将

572
00:17:10,316 --> 00:17:11,876
进入光盘中的缓冲器

573
00:17:12,276 --> 00:17:14,316
网格数据 描述符 

574
00:17:14,316 --> 00:17:16,336
顶点以及索引缓冲器

575
00:17:16,336 --> 00:17:18,306
对场景中参数

576
00:17:18,366 --> 00:17:21,746
进行直线化后的

577
00:17:21,976 --> 00:17:23,646
场景数据 最后

578
00:17:23,646 --> 00:17:24,935
关于在哪里放置

579
00:17:24,935 --> 00:17:26,366
这些东西的

580
00:17:26,366 --> 00:17:26,715
变换数据

581
00:17:27,165 --> 00:17:31,016
接下来 我们将拿出

582
00:17:31,336 --> 00:17:33,336
所有的材质数据

583
00:17:33,896 --> 00:17:37,076
对于每一个子网格 我们

584
00:17:37,076 --> 00:17:38,406
将找出它

585
00:17:38,876 --> 00:17:39,646
可能对应一个材质

586
00:17:39,646 --> 00:17:41,186
如果我们有一个材质 那么我们

587
00:17:41,186 --> 00:17:42,926
将需要找到我们的着色器

588
00:17:43,186 --> 00:17:45,216
所需要的指数

589
00:17:45,496 --> 00:17:47,036
如果我们的着色器需要扩散

590
00:17:47,036 --> 00:17:49,086
色彩和粗糙度 那么我将

591
00:17:49,086 --> 00:17:50,836
问 MDLMaterial 你有

592
00:17:50,836 --> 00:17:52,936
哪些值 我将

593
00:17:53,046 --> 00:17:54,316
确定它为定标

594
00:17:54,316 --> 00:17:56,956
值还是纹理 然后我们

595
00:17:56,956 --> 00:17:58,466
将拿出并且记录它们

596
00:17:59,606 --> 00:18:01,026
同样 这些代码都是非常

597
00:17:59,606 --> 00:18:01,026
同样 这些代码都是非常

598
00:18:01,026 --> 00:18:01,646
直接的

599
00:18:02,996 --> 00:18:04,206
如果子网格有一种材质

600
00:18:04,206 --> 00:18:06,836
它将在所有属性中运行一遍

601
00:18:07,336 --> 00:18:08,456
这里我没有向你们展示是因为

602
00:18:08,456 --> 00:18:10,046
我只是为我们的运行时着色器

603
00:18:10,046 --> 00:18:11,206
过滤出那些

604
00:18:11,206 --> 00:18:11,936
我们真正在意的东西

605
00:18:11,986 --> 00:18:13,676
但是一旦我们到了

606
00:18:13,676 --> 00:18:14,576
需要把它过滤掉的那个点

607
00:18:14,576 --> 00:18:17,096
我们将问 嗨 属性

608
00:18:17,096 --> 00:18:18,636
你是字符串还是网址

609
00:18:19,006 --> 00:18:20,466
如果是这样的话 我们将参考一个

610
00:18:20,466 --> 00:18:21,836
纹理 然后我们直接

611
00:18:21,836 --> 00:18:23,056
为之后编写出纹理通道

612
00:18:23,876 --> 00:18:25,406
不然我们就需要

613
00:18:25,826 --> 00:18:27,666
检查你是否只是一个统一

614
00:18:27,666 --> 00:18:28,996
属性 例如你是否是

615
00:18:28,996 --> 00:18:31,026
浮动值或者颜色或者

616
00:18:31,026 --> 00:18:32,536
类似的东西 如果是这样的 

617
00:18:32,536 --> 00:18:33,276
那么我们将把它

618
00:18:33,276 --> 00:18:33,636
写出来

619
00:18:33,636 --> 00:18:37,956
然后再次 这是我们

620
00:18:37,956 --> 00:18:39,026
在之前的步骤里

621
00:18:39,026 --> 00:18:40,326
写出的数据 也就是

622
00:18:40,376 --> 00:18:41,326
场景图和网格 

623
00:18:42,436 --> 00:18:43,866
现在我将写出

624
00:18:43,866 --> 00:18:48,416
材质均一和纹理通道

625
00:18:48,556 --> 00:18:50,566
最后进行实例化

626
00:18:53,556 --> 00:18:56,756
也就是在这里我们的汽车

627
00:18:56,756 --> 00:18:57,656
将有不只一个

628
00:18:57,716 --> 00:18:57,956
轮子

629
00:18:57,956 --> 00:18:59,856
你可能

630
00:18:59,856 --> 00:19:01,386
想多次使用

631
00:18:59,856 --> 00:19:01,386
想多次使用

632
00:19:01,386 --> 00:19:02,756
单一的网格

633
00:19:03,476 --> 00:19:07,206
现在我的车有两个轮子了

634
00:19:07,386 --> 00:19:10,386
要把这个多次

635
00:19:10,386 --> 00:19:12,086
存储在存储器里面

636
00:19:12,086 --> 00:19:12,556
有点浪费 对吧

637
00:19:12,556 --> 00:19:14,376
它们都是同样的轮子

638
00:19:14,376 --> 00:19:15,106
只不过重复了多次

639
00:19:15,626 --> 00:19:18,866
所以 Model I/O 在

640
00:19:18,966 --> 00:19:21,496
MDLAsset 里有一个叫控制队列的东西

641
00:19:22,186 --> 00:19:24,866
当你加载一个通过实例化

642
00:19:24,866 --> 00:19:26,886
来复制数据的 Pixar USD 文件时

643
00:19:26,886 --> 00:19:28,686
Model I/O

644
00:19:28,686 --> 00:19:30,726
会注意到这点 并且收集

645
00:19:30,726 --> 00:19:32,056
所有复制对象 把它们放入

646
00:19:32,056 --> 00:19:35,026
控制队列中 而不是

647
00:19:35,026 --> 00:19:36,936
存储在单个的网格

648
00:19:37,096 --> 00:19:39,016
的节点中 相反只是引用

649
00:19:39,136 --> 00:19:40,546
它 只需要存储引用回

650
00:19:40,546 --> 00:19:42,066
控制队列的

651
00:19:42,066 --> 00:19:42,266
MDLObjective 就行

652
00:19:42,686 --> 00:19:44,086
我们就是这么做到重复利用的

653
00:19:44,616 --> 00:19:46,246
而且 由于 Metal 有非常棒的

654
00:19:46,246 --> 00:19:48,076
实例化设备 这将

655
00:19:48,076 --> 00:19:51,876
对我们非常有益

656
00:19:52,096 --> 00:19:54,396
我们将再次

657
00:19:54,396 --> 00:19:55,976
平面化各个层级 并且

658
00:19:55,976 --> 00:19:58,596
直线化队列 

659
00:19:58,626 --> 00:19:59,376
和我们之前做的一样

660
00:20:00,206 --> 00:20:02,266
现在在右侧 你可以

661
00:20:02,266 --> 00:20:03,526
看到我在索引 2 3 4

662
00:20:03,526 --> 00:20:06,126
队列中有两个轮子

663
00:20:06,536 --> 00:20:07,666
但是我们希望成批处理

664
00:20:07,666 --> 00:20:08,766
那些东西 但是我们

665
00:20:08,766 --> 00:20:13,086
现在就要做这个

666
00:20:13,296 --> 00:20:14,536
我们把这些轮胎分组

667
00:20:14,536 --> 00:20:16,926
放在一起 现在我们在底部

668
00:20:16,926 --> 00:20:17,816
有了车身

669
00:20:18,396 --> 00:20:19,136
我们只要再存储

670
00:20:19,136 --> 00:20:20,706
一点点数据 也就是

671
00:20:20,706 --> 00:20:22,046
实例计数

672
00:20:22,196 --> 00:20:23,766
现在有两个轮子和一个车身

673
00:20:25,046 --> 00:20:25,826
最后它将有四个

674
00:20:25,826 --> 00:20:26,496
轮子的 相信我

675
00:20:28,206 --> 00:20:30,656
我们将调出

676
00:20:30,656 --> 00:20:31,666
我们之前已经存储好的

677
00:20:31,666 --> 00:20:33,106
数据 再到场景

678
00:20:33,106 --> 00:20:35,386
组成数据 我们将

679
00:20:35,386 --> 00:20:36,356
添加实例计数

680
00:20:37,406 --> 00:20:39,846
我们做了这些就可以得到

681
00:20:39,846 --> 00:20:41,676
一个包含多种材质和对象的

682
00:20:41,676 --> 00:20:42,786
实例化场景

683
00:20:43,346 --> 00:20:46,016
接下来我希望交给

684
00:20:46,306 --> 00:20:48,136
Nicholas 来向大家展示

685
00:20:48,286 --> 00:20:49,266
这些是如何从最开始

686
00:20:49,266 --> 00:20:49,586
再到组合到一起的

687
00:20:51,516 --> 00:20:54,500
［掌声］

688
00:21:05,096 --> 00:21:06,016
&gt;&gt;我要向大家展示用 Model I/O

689
00:21:06,016 --> 00:21:07,846
可以多么容易地

690
00:21:07,846 --> 00:21:09,206
把我们的素材变换为

691
00:21:09,206 --> 00:21:10,196
引擎就绪的数据

692
00:21:10,276 --> 00:21:12,376
我这里有两个文件夹

693
00:21:12,376 --> 00:21:13,646
第一个文件夹里有我们的艺术

694
00:21:13,646 --> 00:21:14,076
素材

695
00:21:14,616 --> 00:21:16,176
它包含了动画数据

696
00:21:16,806 --> 00:21:18,706
汽车 采用了蒙皮动画的方式

697
00:21:18,706 --> 00:21:19,786
它还有一堆材质

698
00:21:20,446 --> 00:21:21,476
所以我们想做的就是我们希望

699
00:21:21,476 --> 00:21:23,896
创建一个 baker 

700
00:21:23,896 --> 00:21:25,626
它可以把这个数据变为引擎

701
00:21:25,626 --> 00:21:26,796
数据 然后把它放在

702
00:21:26,796 --> 00:21:27,616
第二个文件夹里 

703
00:21:28,246 --> 00:21:31,216
这里我们有我们的

704
00:21:31,216 --> 00:21:32,736
baker 项目 我们要做的

705
00:21:32,736 --> 00:21:33,996
就是我们要

706
00:21:34,096 --> 00:21:35,506
慢慢地把它扩展 以从这些

707
00:21:35,506 --> 00:21:37,256
艺术素材中提取更多的

708
00:21:37,256 --> 00:21:37,696
数据

709
00:21:38,176 --> 00:21:39,126
从最简单的开始

710
00:21:39,166 --> 00:21:40,956
让我们来导出

711
00:21:40,956 --> 00:21:42,236
几何结构和转换

712
00:21:42,956 --> 00:21:44,146
为了做这点 我们将浏览

713
00:21:44,146 --> 00:21:46,186
场景图分级并且

714
00:21:46,186 --> 00:21:47,786
寻找任何是 MDLMesh 类型的

715
00:21:48,526 --> 00:21:48,626
对象

716
00:21:51,076 --> 00:21:52,156
然后我们将存储

717
00:21:52,156 --> 00:21:55,636
顶点描述符 所有的

718
00:21:55,636 --> 00:21:58,816
顶点缓冲区 然后我们

719
00:21:58,816 --> 00:22:00,326
将迭代所有的

720
00:21:58,816 --> 00:22:00,326
将迭代所有的

721
00:22:00,386 --> 00:22:02,696
子网格并且拿到索引

722
00:22:02,726 --> 00:22:03,076
缓冲器

723
00:22:06,896 --> 00:22:07,896
我们将再一次浏览

724
00:22:07,936 --> 00:22:10,256
场景图 这次

725
00:22:10,256 --> 00:22:12,836
我们要寻找的是所有

726
00:22:12,836 --> 00:22:14,066
有转换组件的

727
00:22:14,066 --> 00:22:14,576
对象

728
00:22:15,456 --> 00:22:16,906
如果有的话 我们只需要存储

729
00:22:16,906 --> 00:22:17,396
矩阵就行

730
00:22:17,526 --> 00:22:19,546
第一个例子

731
00:22:19,546 --> 00:22:19,846
就是这样

732
00:22:19,846 --> 00:22:20,726
让我们运行

733
00:22:20,726 --> 00:22:20,906
它

734
00:22:26,076 --> 00:22:27,166
大家会注意到在第二个

735
00:22:27,166 --> 00:22:28,446
文件夹里 我们有一个新文档

736
00:22:28,446 --> 00:22:29,726
这就是我们的引擎就绪

737
00:22:30,406 --> 00:22:30,536
数据

738
00:22:31,956 --> 00:22:33,336
这里的第二个项目将是

739
00:22:33,336 --> 00:22:34,386
我们的引擎 它将

740
00:22:34,386 --> 00:22:35,486
读取那个数据 并且

741
00:22:35,486 --> 00:22:36,086
对其进行渲染

742
00:22:36,086 --> 00:22:37,086
我们来看看现在的

743
00:22:37,136 --> 00:22:37,376
成果

744
00:22:37,636 --> 00:22:40,066
你可能注意到 我们的

745
00:22:40,066 --> 00:22:41,336
一个赛道上有两辆车 但是

746
00:22:41,336 --> 00:22:42,126
还有颜色需要处理 

747
00:22:42,126 --> 00:22:43,746
那么让我们扩展 baker 

748
00:22:43,746 --> 00:22:45,116
让它也支持材质

749
00:22:50,046 --> 00:22:52,516
我们不需要寻找

750
00:22:52,516 --> 00:22:53,326
子网格上的索引缓冲器

751
00:22:53,376 --> 00:22:54,256
我们需要看看

752
00:22:54,316 --> 00:22:55,206
它是否有一个材质

753
00:22:55,206 --> 00:22:55,656
属性

754
00:22:56,116 --> 00:22:57,936
如果有的话 那么就有五个

755
00:22:57,986 --> 00:22:58,986
和以下相关的属性

756
00:22:58,986 --> 00:23:01,516
语义 baseColor 金属材质的

757
00:22:58,986 --> 00:23:01,516
语义 baseColor 金属材质的

758
00:23:02,346 --> 00:23:04,686
粗糙度 碰撞以及

759
00:23:04,686 --> 00:23:05,996
ambientOcclusion 这些我们

760
00:23:05,996 --> 00:23:06,266
在意的东西

761
00:23:07,066 --> 00:23:08,046
并且当我们在属性里

762
00:23:08,076 --> 00:23:09,306
读取到相关的东西 我们将迭代

763
00:23:09,396 --> 00:23:11,116
浏览所有的属性

764
00:23:11,116 --> 00:23:11,886
并检查类型

765
00:23:12,436 --> 00:23:15,296
如果类型是 float 或者

766
00:23:15,346 --> 00:23:17,486
float3 我们就可以假定它是均一的

767
00:23:17,876 --> 00:23:19,826
并且我们也将记录它

768
00:23:20,706 --> 00:23:22,516
不然 如果它是字符串或网址

769
00:23:22,516 --> 00:23:24,156
我们将记录

770
00:23:24,156 --> 00:23:24,806
纹理通道

771
00:23:25,796 --> 00:23:27,036
现在让我们来运行第二个

772
00:23:27,036 --> 00:23:28,026
例子 看看我们可以在我们的

773
00:23:28,026 --> 00:23:29,846
引擎获得何种输出

774
00:23:35,046 --> 00:23:36,076
现在我没有一个赛道

775
00:23:36,076 --> 00:23:36,966
两辆车 现在还有

776
00:23:36,966 --> 00:23:37,496
材质

777
00:23:38,256 --> 00:23:40,016
我们进一步进行扩展

778
00:23:40,016 --> 00:23:41,176
并支持实例化

779
00:23:46,256 --> 00:23:48,006
之前在浏览场景图时

780
00:23:48,006 --> 00:23:49,296
我们只考虑了

781
00:23:49,346 --> 00:23:49,746
网格

782
00:23:49,896 --> 00:23:51,056
现在我们想要考虑所有

783
00:23:51,056 --> 00:23:52,436
在素材控制队列中

784
00:23:52,436 --> 00:23:53,366
的网格

785
00:23:54,196 --> 00:23:55,436
所以我们浏览控制网格

786
00:23:56,226 --> 00:23:57,246
收集所有是 MDLMesh 类型的

787
00:23:57,246 --> 00:23:59,006
对象 然后像之前那样

788
00:23:59,446 --> 00:24:00,396
存储它

789
00:23:59,446 --> 00:24:00,396
存储它

790
00:24:01,246 --> 00:24:02,336
并且 我们还需要

791
00:24:02,336 --> 00:24:04,566
记录所有控制网格

792
00:24:04,566 --> 00:24:05,236
引用的对象

793
00:24:05,236 --> 00:24:06,756
这点我们可以在

794
00:24:06,756 --> 00:24:07,646
实例化属性中找到

795
00:24:08,216 --> 00:24:11,836
然后我们可以按网格区分

796
00:24:11,836 --> 00:24:14,346
实例 得出实例

797
00:24:14,346 --> 00:24:14,666
计数

798
00:24:15,696 --> 00:24:16,616
这样就完成了

799
00:24:21,146 --> 00:24:22,256
现在让我们再运行一下

800
00:24:22,336 --> 00:24:22,846
我们的场景

801
00:24:23,496 --> 00:24:26,126
现在我们有多辆车

802
00:24:26,126 --> 00:24:27,346
我们用实例化对它们进行渲染

803
00:24:28,146 --> 00:24:28,766
交回给你了 Nick

804
00:24:31,516 --> 00:24:36,026
［掌声］

805
00:24:36,526 --> 00:24:37,586
&gt;&gt;接下来 我们要讲一讲

806
00:24:37,806 --> 00:24:39,486
变换动画

807
00:24:40,106 --> 00:24:43,856
变换动画是

808
00:24:43,856 --> 00:24:46,346
随时间改变的变换

809
00:24:47,776 --> 00:24:49,826
现在让我们再考虑一下我们的

810
00:24:49,826 --> 00:24:51,266
场景图

811
00:24:51,876 --> 00:24:54,556
现在 在起点线上我们有

812
00:24:54,966 --> 00:24:56,866
一辆车 现在我想

813
00:24:56,866 --> 00:24:58,656
做这么一个动画

814
00:24:58,766 --> 00:25:00,866
例如在车发动之前

815
00:24:58,766 --> 00:25:00,866
例如在车发动之前

816
00:25:00,866 --> 00:25:02,006
车身稍微摆动

817
00:25:02,006 --> 00:25:03,826
一下 然后车再

818
00:25:03,826 --> 00:25:04,626
开走

819
00:25:05,266 --> 00:25:06,436
为了实现这个效果

820
00:25:06,436 --> 00:25:07,586
我需要在车身节点 D

821
00:25:07,586 --> 00:25:10,736
以及整个对象的

822
00:25:10,736 --> 00:25:14,956
根节点上录制

823
00:25:14,956 --> 00:25:16,396
一些动画数据来把它

824
00:25:16,396 --> 00:25:18,406
移走 也就是节点 B

825
00:25:18,966 --> 00:25:19,906
我将要记录

826
00:25:19,906 --> 00:25:21,986
两个节点的

827
00:25:21,986 --> 00:25:22,786
动画路径

828
00:25:24,256 --> 00:25:26,476
同样有了 Model I/O

829
00:25:26,476 --> 00:25:27,836
这点特别容易做到

830
00:25:29,116 --> 00:25:31,186
和之前一样 我们浏览所有的

831
00:25:31,186 --> 00:25:32,326
对象 寻找

832
00:25:32,326 --> 00:25:34,826
变换组件 

833
00:25:34,826 --> 00:25:36,356
当我们找到它们的时候 我们将

834
00:25:36,356 --> 00:25:36,916
对它们进行附加

835
00:25:37,446 --> 00:25:38,396
但是现在我们还需要做

836
00:25:38,396 --> 00:25:40,356
一件事 那就是我们将

837
00:25:40,516 --> 00:25:42,366
询问变换它是否

838
00:25:42,456 --> 00:25:45,086
有键控时间

839
00:25:45,706 --> 00:25:47,796
如果没有键控时间

840
00:25:48,076 --> 00:25:50,096
那么计数为 0 我们

841
00:25:50,096 --> 00:25:51,076
直接使用就行

842
00:25:51,456 --> 00:25:52,956
如果有 1 个键控时间

843
00:25:53,066 --> 00:25:53,976
我将把它看做

844
00:25:53,976 --> 00:25:54,526
恒定

845
00:25:54,826 --> 00:25:56,726
所以我们只需要寻找计数

846
00:25:56,766 --> 00:25:58,396
大于 1 的就行 

847
00:26:01,056 --> 00:26:03,296
我们现在要真正使用

848
00:26:03,526 --> 00:26:04,966
Swift 一个非常不同寻常

849
00:26:04,966 --> 00:26:05,626
非常酷的部分

850
00:26:06,066 --> 00:26:06,736
我喜欢这个部分

851
00:26:06,736 --> 00:26:08,996
我们将使用地图

852
00:26:09,246 --> 00:26:09,736
闭合

853
00:26:10,306 --> 00:26:12,936
我们将做的是

854
00:26:13,116 --> 00:26:14,956
根据时间对

855
00:26:14,956 --> 00:26:17,746
动画进行取样

856
00:26:17,746 --> 00:26:20,136
我们将创建

857
00:26:21,236 --> 00:26:22,496
与那些时间对应的

858
00:26:22,496 --> 00:26:24,446
新队列的变换 并将之

859
00:26:24,446 --> 00:26:24,926
附加在我们的缓冲器上

860
00:26:25,446 --> 00:26:27,306
现在把绘图操作

861
00:26:27,306 --> 00:26:29,176
拆开一下

862
00:26:29,436 --> 00:26:31,076
第一行说的是

863
00:26:31,076 --> 00:26:32,076
samplesTimes.map

864
00:26:32,486 --> 00:26:33,546
幻灯片上没有

865
00:26:33,546 --> 00:26:34,526
显示的是 sampleTimes

866
00:26:34,526 --> 00:26:36,226
从哪里来

867
00:26:36,816 --> 00:26:39,796
这是另外一个队列的

868
00:26:40,416 --> 00:26:42,876
keyTimes 你在这里

869
00:26:42,876 --> 00:26:43,276
可以做两件事情

870
00:26:43,646 --> 00:26:45,286
一件事是你让

871
00:26:45,286 --> 00:26:47,286
sampleTimes 队列就是

872
00:26:47,316 --> 00:26:51,626
transform.keyTimes 队列 或者如果

873
00:26:51,626 --> 00:26:53,646
相反你只是想要

874
00:26:53,646 --> 00:26:55,506
艺术家放进文件

875
00:26:55,506 --> 00:26:57,216
中的时间点 例如如果

876
00:26:57,216 --> 00:26:58,586
你想以恒定帧频

877
00:26:58,586 --> 00:27:00,166
对时间进行取样 

878
00:26:58,586 --> 00:27:00,166
对时间进行取样 

879
00:27:00,546 --> 00:27:01,556
你可以在你希望

880
00:27:01,556 --> 00:27:03,886
的帧频下合成

881
00:27:04,056 --> 00:27:05,486
一队列变换时间

882
00:27:05,486 --> 00:27:07,226
例如 60 帧每秒

883
00:27:07,886 --> 00:27:09,536
所以当你在进行这个绘图

884
00:27:09,536 --> 00:27:12,096
操作的时候 闭合进行了

885
00:27:12,096 --> 00:27:14,126
变换 在对应队列中

886
00:27:14,126 --> 00:27:16,546
相应值的时间下

887
00:27:16,546 --> 00:27:17,906
获取本地

888
00:27:17,906 --> 00:27:18,236
变换

889
00:27:18,436 --> 00:27:19,936
我觉得这特别酷

890
00:27:21,256 --> 00:27:23,436
这是我们已经导出

891
00:27:23,436 --> 00:27:24,276
的数据

892
00:27:25,466 --> 00:27:27,986
它非常直接地

893
00:27:27,986 --> 00:27:29,336
对本地变换动画

894
00:27:29,336 --> 00:27:30,016
进行了编码

895
00:27:30,906 --> 00:27:34,746
最后蒙皮和

896
00:27:34,746 --> 00:27:35,686
角色动画

897
00:27:36,546 --> 00:27:40,386
现在我们将要拿出一辆

898
00:27:40,386 --> 00:27:42,966
小车 它

899
00:27:42,966 --> 00:27:44,046
很明显是一辆卡通车

900
00:27:44,406 --> 00:27:46,296
我们将让它可以

901
00:27:46,296 --> 00:27:48,756
扭动它的鼻子 或者

902
00:27:48,756 --> 00:27:49,026
做其他动画效果

903
00:27:50,206 --> 00:27:53,686
正如我们之前所看到的

904
00:27:53,686 --> 00:27:55,546
网格将有几何结构

905
00:27:55,656 --> 00:27:56,536
以及其他类似的

906
00:27:56,536 --> 00:27:57,656
我们之前谈论过的

907
00:27:57,656 --> 00:28:00,056
缓冲器 但是它还有

908
00:27:57,656 --> 00:28:00,056
缓冲器 但是它还有

909
00:28:00,056 --> 00:28:02,496
一个被嵌入骨架的

910
00:28:02,496 --> 00:28:02,966
新东西

911
00:28:03,256 --> 00:28:05,216
我希望大家可以看到这个小小的

912
00:28:05,216 --> 00:28:06,036
绿色的骨头

913
00:28:07,036 --> 00:28:08,186
它们将被放置在

914
00:28:08,186 --> 00:28:09,396
轮子中 在下面车的

915
00:28:09,396 --> 00:28:10,476
“脊柱”位置也有一些

916
00:28:11,686 --> 00:28:15,496
那些骨头通过

917
00:28:15,496 --> 00:28:17,876
艺术家们的绘画步骤

918
00:28:17,876 --> 00:28:19,186
和顶点绑定

919
00:28:19,616 --> 00:28:22,786
所以左边的有

920
00:28:23,506 --> 00:28:25,156
一根骨头和车的前部

921
00:28:25,216 --> 00:28:26,646
绑定 靠保险杠

922
00:28:26,646 --> 00:28:27,756
还有鼻子承重

923
00:28:28,166 --> 00:28:29,506
然后在右边

924
00:28:29,826 --> 00:28:32,026
我们选择了在车身背部

925
00:28:32,026 --> 00:28:33,536
的一根骨头和

926
00:28:33,536 --> 00:28:35,086
轮子相连 所以当这根

927
00:28:35,086 --> 00:28:37,746
骨头移动时 它将影响到

928
00:28:37,746 --> 00:28:39,316
车身背部的翼片以及

929
00:28:40,026 --> 00:28:42,156
那个轮子

930
00:28:42,356 --> 00:28:44,776
我还需要提一下

931
00:28:44,776 --> 00:28:46,356
这种数据需要

932
00:28:46,386 --> 00:28:48,686
你在你的着色器中多做一点

933
00:28:48,686 --> 00:28:49,086
工作

934
00:28:49,726 --> 00:28:53,696
我们还需要一些信息

935
00:28:53,696 --> 00:28:54,856
为我们之前还没有做过的

936
00:28:54,856 --> 00:28:55,896
发车做准备

937
00:28:56,516 --> 00:28:59,236
特别是 我们有

938
00:28:59,236 --> 00:29:03,806
jointWeights per vertex 以及

939
00:28:59,236 --> 00:29:03,806
jointWeights per vertex 以及

940
00:29:03,806 --> 00:29:07,326
jointIndices 也就是一小

941
00:29:07,326 --> 00:29:11,076
队列指数 我们将向

942
00:29:11,076 --> 00:29:13,186
它们调用和顶点位置

943
00:29:13,626 --> 00:29:16,226
相对应节点的

944
00:29:16,226 --> 00:29:17,196
矩阵调色

945
00:29:17,676 --> 00:29:21,046
如果有两个节点或者骨头

946
00:29:21,046 --> 00:29:23,426
同时作用于一个特定顶点

947
00:29:23,796 --> 00:29:25,476
那么当我进行变换时 

948
00:29:25,476 --> 00:29:27,666
那些骨头的指数将

949
00:29:28,136 --> 00:29:30,076
和顶点一起再加上一些重量

950
00:29:30,076 --> 00:29:34,276
当我在着色器中

951
00:29:34,846 --> 00:29:36,986
对它们进行变换时 它们将

952
00:29:36,986 --> 00:29:39,506
全部被结合起来 顶点

953
00:29:39,506 --> 00:29:41,606
将移动到其最后的变形

954
00:29:41,606 --> 00:29:42,156
位置 

955
00:29:44,656 --> 00:29:47,536
为了从正在进行的几何结构和

956
00:29:47,836 --> 00:29:50,146
其他变换中

957
00:29:50,256 --> 00:29:52,846
单独编码骨架 

958
00:29:52,846 --> 00:29:54,066
我们还需要更多的

959
00:29:54,066 --> 00:29:54,576
信息

960
00:29:55,146 --> 00:29:57,036
那就是表格

961
00:29:57,036 --> 00:29:57,716
底部中的

962
00:29:57,716 --> 00:29:58,266
骨架

963
00:29:58,266 --> 00:29:59,886
我们把它分隔开来

964
00:30:02,366 --> 00:30:04,656
所以和我们之前所做的一样

965
00:30:04,656 --> 00:30:07,586
我们将浏览绘图

966
00:30:07,586 --> 00:30:09,976
然后根据浏览顺序 0 1 2 3

967
00:30:10,096 --> 00:30:14,816
分配指数

968
00:30:15,036 --> 00:30:16,896
我们将对骨架图中的

969
00:30:16,946 --> 00:30:20,086
亲项进行编码

970
00:30:20,356 --> 00:30:21,906
和我们之前对几何图所做的

971
00:30:21,906 --> 00:30:22,336
一样

972
00:30:22,806 --> 00:30:25,046
我不会再细讲

973
00:30:25,046 --> 00:30:26,576
它的工作原理

974
00:30:26,576 --> 00:30:27,576
因为这和之前的

975
00:30:27,576 --> 00:30:27,926
完全一样

976
00:30:29,156 --> 00:30:32,106
现在我们需要对

977
00:30:32,466 --> 00:30:35,396
每一根骨头进行编码

978
00:30:35,396 --> 00:30:37,886
它们会真正影响到顶点

979
00:30:38,566 --> 00:30:43,486
层级中骨头的索引

980
00:30:43,566 --> 00:30:46,446
以及逆绑定

981
00:30:46,446 --> 00:30:46,826
姿势

982
00:30:47,336 --> 00:30:48,806
在之前的幻灯片中

983
00:30:48,806 --> 00:30:50,316
提到着色器的部分有一些

984
00:30:50,486 --> 00:30:52,766
数学运算提到某种

985
00:30:52,766 --> 00:30:53,716
调色矩阵

986
00:30:54,286 --> 00:30:56,396
逆向绑定姿势

987
00:30:56,396 --> 00:30:58,026
将需要你用多一点的

988
00:30:58,026 --> 00:31:00,236
数学运算来帮你把

989
00:30:58,026 --> 00:31:00,236
数学运算来帮你把

990
00:31:00,236 --> 00:31:02,416
顶点放入右侧空间

991
00:31:02,416 --> 00:31:03,496
使之更容易混合

992
00:31:03,786 --> 00:31:05,336
我将让大家看一个

993
00:31:05,336 --> 00:31:06,496
例子 以了解变换的

994
00:31:06,496 --> 00:31:07,236
具体细节

995
00:31:08,776 --> 00:31:10,056
我们将浏览它们中的

996
00:31:10,056 --> 00:31:11,916
每一项 然后把那些

997
00:31:12,076 --> 00:31:13,436
矩阵和指数存储起来 

998
00:31:14,086 --> 00:31:16,026
最后 做一个

999
00:31:16,026 --> 00:31:18,326
动画片段 我们将

1000
00:31:18,486 --> 00:31:20,696
录制和动画片段中

1001
00:31:20,696 --> 00:31:22,416
每根骨头

1002
00:31:22,476 --> 00:31:26,416
对应的动画

1003
00:31:26,576 --> 00:31:29,426
所以从代码的角度

1004
00:31:29,426 --> 00:31:30,356
它和我们之前看到的非常像

1005
00:31:31,246 --> 00:31:32,466
我们将浏览对象

1006
00:31:32,466 --> 00:31:34,396
找到对象是否有

1007
00:31:34,396 --> 00:31:35,296
蒙皮

1008
00:31:36,486 --> 00:31:38,496
蒙皮和骨架等

1009
00:31:38,496 --> 00:31:40,256
相对应 是在

1010
00:31:40,326 --> 00:31:42,286
Model I/O 全新的

1011
00:31:42,766 --> 00:31:44,576
MDLSkinDeformerComponent 中编码的

1012
00:31:45,006 --> 00:31:46,826
所以如果我们发现一个蒙皮变形器

1013
00:31:46,826 --> 00:31:49,936
组件 我们将再次

1014
00:31:49,936 --> 00:31:51,316
利用

1015
00:31:51,746 --> 00:31:55,536
Swift 地图闭合 利用

1016
00:31:55,536 --> 00:31:57,776
Model I/O 从文件中读取

1017
00:31:57,776 --> 00:31:59,796
并且存储的

1018
00:31:59,796 --> 00:32:00,176
jointBindTransforms

1019
00:31:59,796 --> 00:32:00,176
jointBindTransforms

1020
00:32:00,916 --> 00:32:02,546
我们将利用这个单指令

1021
00:32:02,546 --> 00:32:05,406
倒转来倒置它们

1022
00:32:05,776 --> 00:32:06,646
因为数学运算需要

1023
00:32:06,646 --> 00:32:08,346
将它存储在一个队列中

1024
00:32:09,036 --> 00:32:12,836
然后这里是我们到现在为止

1025
00:32:12,896 --> 00:32:14,146
存储的所有数据

1026
00:32:15,496 --> 00:32:17,416
我们将调出

1027
00:32:17,416 --> 00:32:19,066
骨架数据 逆向绑定

1028
00:32:19,066 --> 00:32:20,856
变换和色斑映射

1029
00:32:20,856 --> 00:32:22,786
的连接点 以及

1030
00:32:22,786 --> 00:32:24,466
骨架亲项指数

1031
00:32:25,466 --> 00:32:30,156
我想请 Nicholas

1032
00:32:30,216 --> 00:32:32,576
再次上台来向我们展示一下

1033
00:32:32,576 --> 00:32:33,196
它现在的样子

1034
00:32:35,516 --> 00:32:39,500
［掌声］

1035
00:32:47,506 --> 00:32:48,856
&gt;&gt;从我们上次的地方开始 我们

1036
00:32:48,856 --> 00:32:50,336
有一个赛道 多辆

1037
00:32:50,336 --> 00:32:51,736
汽车使用实例化进行渲染

1038
00:32:52,356 --> 00:32:53,576
现在我们再让它

1039
00:32:53,646 --> 00:32:54,836
支持动画效果

1040
00:32:55,306 --> 00:32:57,106
之前在我们浏览

1041
00:32:57,106 --> 00:32:58,176
场景图的时候 我们寻找

1042
00:32:58,176 --> 00:32:59,616
任何有变换组件的

1043
00:32:59,616 --> 00:33:00,846
对象 然后我们假定它是

1044
00:32:59,616 --> 00:33:00,846
对象 然后我们假定它是

1045
00:33:00,846 --> 00:33:01,456
恒定的

1046
00:33:02,146 --> 00:33:02,916
现在我们希望知道

1047
00:33:02,916 --> 00:33:04,146
变换是否会随着时间而改变

1048
00:33:04,146 --> 00:33:05,466
找到这个答案的最简单的办法

1049
00:33:05,466 --> 00:33:06,566
就是看看

1050
00:33:06,566 --> 00:33:07,996
keyTimes.count 是否大于

1051
00:33:07,996 --> 00:33:08,246
1

1052
00:33:09,196 --> 00:33:10,796
如果是 为了达到

1053
00:33:10,796 --> 00:33:12,856
样本的目的 我们将

1054
00:33:13,176 --> 00:33:14,316
在特定时间间隙取样

1055
00:33:14,436 --> 00:33:16,756
我们对它们进行取样

1056
00:33:16,876 --> 00:33:17,376
然后存储

1057
00:33:17,526 --> 00:33:18,626
动画就是这样的

1058
00:33:18,656 --> 00:33:19,466
现在让我们来运行这个

1059
00:33:19,466 --> 00:33:20,596
例子 看看我们的引擎

1060
00:33:20,596 --> 00:33:21,686
可以得到哪种输出

1061
00:33:28,046 --> 00:33:29,186
大家注意到

1062
00:33:29,246 --> 00:33:30,406
前面的车已经发动了

1063
00:33:31,556 --> 00:33:32,926
最后我们来

1064
00:33:32,926 --> 00:33:33,706
加上蒙皮

1065
00:33:33,706 --> 00:33:34,786
现在让我们把 baker 扩展到

1066
00:33:34,786 --> 00:33:35,706
支持蒙皮

1067
00:33:38,156 --> 00:33:40,276
所以你需要的除了有

1068
00:33:40,276 --> 00:33:41,376
网格数据 还有

1069
00:33:41,376 --> 00:33:43,436
蒙皮数据

1070
00:33:43,436 --> 00:33:45,186
所以我们需要检查

1071
00:33:45,186 --> 00:33:47,276
看看 MDLMesh 是否有

1072
00:33:47,276 --> 00:33:48,976
和 MDLSkinDeformer 一致的组件

1073
00:33:50,086 --> 00:33:51,906
如果有 那么我们

1074
00:33:51,906 --> 00:33:52,936
还需要两点额外信息

1075
00:33:52,936 --> 00:33:54,066
也就是我们需要知道

1076
00:33:54,166 --> 00:33:55,706
骨架如何和蒙皮网格绑定

1077
00:33:55,706 --> 00:33:57,366
我们还需要知道

1078
00:33:57,366 --> 00:33:58,106
动画数据

1079
00:33:58,286 --> 00:34:00,466
所以我们找到了 jointPaths 队列

1080
00:33:58,286 --> 00:34:00,466
所以我们找到了 jointPaths 队列

1081
00:34:00,466 --> 00:34:01,646
中所有的绑定

1082
00:34:01,646 --> 00:34:02,856
骨架连接点

1083
00:34:03,476 --> 00:34:06,516
然后我们找到

1084
00:34:06,516 --> 00:34:07,456
jointBindTransforms 中的

1085
00:34:07,456 --> 00:34:08,666
骨架绑定姿势

1086
00:34:08,666 --> 00:34:11,416
现在我们已经知道我们的

1087
00:34:11,416 --> 00:34:12,536
骨架长什么样子了 让我们

1088
00:34:12,536 --> 00:34:15,076
继续根据时间对

1089
00:34:15,196 --> 00:34:16,676
骨架连接点变换进行取样

1090
00:34:16,676 --> 00:34:18,266
和我们之前对本地对象

1091
00:34:18,266 --> 00:34:18,906
变换所做的一样

1092
00:34:20,076 --> 00:34:21,275
我们根据特定的时间间隔

1093
00:34:21,275 --> 00:34:24,106
进行取样 存储矩阵

1094
00:34:24,106 --> 00:34:25,956
然后我们把它分解为

1095
00:34:25,956 --> 00:34:27,116
四元数旋转

1096
00:34:28,335 --> 00:34:30,996
翻译 然后把它存储在

1097
00:34:30,996 --> 00:34:31,866
动画片段中

1098
00:34:32,956 --> 00:34:33,806
现在让我们来运行这个

1099
00:34:33,806 --> 00:34:34,295
例子

1100
00:34:47,056 --> 00:34:48,146
所以现在我们有了一辆蒙皮汽车

1101
00:34:48,996 --> 00:34:50,335
我再总结一下我们所做的

1102
00:34:50,545 --> 00:34:51,476
我们用 Model I/O 构建了

1103
00:34:51,516 --> 00:34:52,906
一个简单的 baker

1104
00:34:52,906 --> 00:34:54,036
它可以导出几何结构和

1105
00:34:54,036 --> 00:34:55,916
变换 再加点代码

1106
00:34:55,916 --> 00:34:57,256
我们就可以对它进行扩展

1107
00:34:57,256 --> 00:34:58,586
使它支持材质

1108
00:34:58,586 --> 00:35:00,206
实例化 动画以及

1109
00:34:58,586 --> 00:35:00,206
实例化 动画以及

1110
00:35:00,206 --> 00:35:01,156
蒙皮动画

1111
00:35:01,896 --> 00:35:03,266
这五个例子以及

1112
00:35:03,266 --> 00:35:04,296
引擎都放在

1113
00:35:04,336 --> 00:35:05,746
这个环节的代码样本中

1114
00:35:05,746 --> 00:35:07,186
大家可以根据自己的引擎需求进行

1115
00:35:07,186 --> 00:35:07,376
修改

1116
00:35:08,026 --> 00:35:09,726
交回给你了 Nick

1117
00:35:10,216 --> 00:35:12,216
［掌声］

1118
00:35:12,416 --> 00:35:13,016
&gt;&gt; 好的

1119
00:35:14,776 --> 00:35:16,206
快速总结一下

1120
00:35:16,906 --> 00:35:19,406
我们展示了如何把图案

1121
00:35:19,406 --> 00:35:22,346
从最初的素材创作

1122
00:35:22,476 --> 00:35:24,686
程序变成 Pixar 的 USD

1123
00:35:24,686 --> 00:35:25,816
文件格式

1124
00:35:26,696 --> 00:35:28,916
我们运用 Model I/O 将

1125
00:35:28,916 --> 00:35:31,036
素材变换为引擎就绪

1126
00:35:31,036 --> 00:35:34,916
数据 我们对它们进行编码

1127
00:35:34,916 --> 00:35:36,246
然后把它们在光盘中归档

1128
00:35:36,786 --> 00:35:38,766
我们利用 Swift 和 Metal

1129
00:35:38,816 --> 00:35:41,036
进行了简单的渲染

1130
00:35:41,136 --> 00:35:42,136
制作了一个小游戏

1131
00:35:42,706 --> 00:35:44,676
我们加载了所有的数据

1132
00:35:45,226 --> 00:35:47,846
然后我们将它进行动画化 而且我们绘制了

1133
00:35:47,846 --> 00:35:48,726
一些漂亮的画面

1134
00:35:49,626 --> 00:35:52,576
那么接下来呢

1135
00:35:52,736 --> 00:35:56,036
我会鼓励大家去

1136
00:35:56,036 --> 00:35:58,106
看看 Model I/O

1137
00:35:58,316 --> 00:35:59,686
内置的其他

1138
00:35:59,686 --> 00:35:59,836
设备

1139
00:36:00,356 --> 00:36:01,816
我们还有非常多其他工具

1140
00:36:01,986 --> 00:36:04,076
可以帮助大家构建

1141
00:36:04,076 --> 00:36:04,926
自己的工具

1142
00:36:05,266 --> 00:36:07,086
你们自己的适用于管道链的

1143
00:36:07,086 --> 00:36:07,376
工具

1144
00:36:08,036 --> 00:36:10,226
例如 如果你有一个

1145
00:36:10,226 --> 00:36:12,376
由多个对象组成的场景

1146
00:36:12,776 --> 00:36:14,266
你可以进行一个光照映射

1147
00:36:14,266 --> 00:36:14,906
操作

1148
00:36:15,096 --> 00:36:17,096
Model I/O 可以制作多种

1149
00:36:17,096 --> 00:36:18,536
射线 它将让光线四处跳动

1150
00:36:19,296 --> 00:36:21,066
它会将场景作为

1151
00:36:21,066 --> 00:36:22,296
优先事项 并且为你存储

1152
00:36:22,296 --> 00:36:22,706
所有的数据

1153
00:36:23,436 --> 00:36:26,656
它还有可以做

1154
00:36:26,656 --> 00:36:28,346
紫外线解相位的工具 我们有一个

1155
00:36:28,346 --> 00:36:30,516
小的飞机 我们可以把它

1156
00:36:30,516 --> 00:36:32,316
分为小的逻辑块

1157
00:36:32,366 --> 00:36:33,366
这样就易于绘图

1158
00:36:33,976 --> 00:36:38,326
它还有其他的操作 例如

1159
00:36:38,426 --> 00:36:40,006
这里它可以计算环境光

1160
00:36:40,006 --> 00:36:40,546
遮蔽

1161
00:36:40,906 --> 00:36:42,636
例如这个小

1162
00:36:42,636 --> 00:36:44,766
飞机 我们已经做了光线投射

1163
00:36:44,766 --> 00:36:47,006
来计算从外部

1164
00:36:47,006 --> 00:36:48,256
表面的可及性并

1165
00:36:48,256 --> 00:36:49,996
进行编码

1166
00:36:49,996 --> 00:36:51,706
飞机表面有一个信号 那么

1167
00:36:51,706 --> 00:36:54,306
你的着色器对你场景中

1168
00:36:54,306 --> 00:36:55,726
对象的渲染将会更接近

1169
00:36:56,116 --> 00:36:56,866
实景

1170
00:36:56,866 --> 00:37:00,176
这里还有一件

1171
00:36:56,866 --> 00:37:00,176
这里还有一件

1172
00:37:00,266 --> 00:37:01,246
你能做的有意思的事

1173
00:37:01,936 --> 00:37:04,056
我们有各种各样 

1174
00:37:04,056 --> 00:37:06,156
处理 360 度图像的工具

1175
00:37:06,486 --> 00:37:07,936
它们对于为 VR 等

1176
00:37:08,056 --> 00:37:09,356
制作全景图像

1177
00:37:09,356 --> 00:37:10,206
非常有用

1178
00:37:10,916 --> 00:37:13,516
在最左边你们

1179
00:37:13,516 --> 00:37:16,546
可以看到一张 360 度的图片

1180
00:37:16,546 --> 00:37:17,646
它是用你们知道的那种

1181
00:37:17,646 --> 00:37:18,616
小相机拍摄的

1182
00:37:19,136 --> 00:37:21,056
Model I/O 可以将它转换为

1183
00:37:21,056 --> 00:37:22,396
可供硬件使用的立方体地图

1184
00:37:22,586 --> 00:37:24,136
它也可以把一个立方体地图

1185
00:37:24,136 --> 00:37:25,136
转换回为它另外一种

1186
00:37:25,136 --> 00:37:25,596
格式

1187
00:37:25,806 --> 00:37:27,416
边上两个

1188
00:37:27,416 --> 00:37:29,056
模糊的栏

1189
00:37:29,256 --> 00:37:31,626
可以为你预计算

1190
00:37:31,626 --> 00:37:35,646
基于实物着色的

1191
00:37:36,246 --> 00:37:36,936
辐照度卷积

1192
00:37:37,226 --> 00:37:38,866
我们制作了一些

1193
00:37:38,866 --> 00:37:40,276
系数可以为

1194
00:37:40,276 --> 00:37:41,276
你的着色器所用 这样如果我们

1195
00:37:41,276 --> 00:37:42,816
把一个对象放到场景中

1196
00:37:42,816 --> 00:37:43,776
它将会找到它合适的

1197
00:37:43,776 --> 00:37:44,516
物理位置

1198
00:37:44,906 --> 00:37:46,216
它里面有很多

1199
00:37:46,216 --> 00:37:46,806
类似的东西

1200
00:37:46,806 --> 00:37:47,966
希望大家可以自己去

1201
00:37:47,966 --> 00:37:48,556
探索

1202
00:37:49,186 --> 00:37:53,146
Nicolas 刚刚也提到

1203
00:37:53,366 --> 00:37:55,346
样本在会议的网站上

1204
00:37:55,546 --> 00:37:57,736
可以供大家下载

1205
00:37:57,736 --> 00:37:59,746
所以希望大家能去用

1206
00:37:59,746 --> 00:38:00,976
那个小车的代码 或者找到其他的

1207
00:37:59,746 --> 00:38:00,976
那个小车的代码 或者找到其他的

1208
00:38:01,116 --> 00:38:02,166
例如那些消失的轮子

1209
00:38:04,466 --> 00:38:05,956
另外还有其他的

1210
00:38:05,956 --> 00:38:07,386
有意思的环节

1211
00:38:07,386 --> 00:38:08,966
大家可以按需要观看 以了解

1212
00:38:08,966 --> 00:38:09,816
有关这些话题的更多内容

1213
00:38:10,286 --> 00:38:13,396
其他环节有 “介绍 Metal 2”

1214
00:38:13,396 --> 00:38:15,966
“SceneKit 的新功能” 还有

1215
00:38:15,966 --> 00:38:18,316
一个我想向大家推荐的是去年大会的

1216
00:38:18,316 --> 00:38:19,926
“SceneKit 的新功能”

1217
00:38:19,926 --> 00:38:21,856
在那里我们详细

1218
00:38:21,856 --> 00:38:23,756
介绍了与 USD 的

1219
00:38:23,756 --> 00:38:24,066
融合

1220
00:38:24,066 --> 00:38:28,006
2015 年的大会也有

1221
00:38:28,146 --> 00:38:30,736
介绍 Model I/O 的相关环节

1222
00:38:30,736 --> 00:38:32,376
那里我们非常详细地

1223
00:38:32,376 --> 00:38:33,586
介绍了各种数据

1224
00:38:33,586 --> 00:38:35,306
结构 以及在那些结构上的

1225
00:38:35,306 --> 00:38:36,056
操作

1226
00:38:36,626 --> 00:38:37,766
那么 就到这里

1227
00:38:38,686 --> 00:38:40,476
感谢大家的聆听 希望

1228
00:38:40,476 --> 00:38:40,976
你们喜欢

1229
00:38:41,508 --> 00:38:43,508
［掌声］
