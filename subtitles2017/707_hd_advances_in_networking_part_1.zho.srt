1
00:00:08,516 --> 00:00:15,500
[ 欢呼 ]

2
00:00:22,516 --> 00:00:28,836
[ 掌声 ]

3
00:00:29,336 --> 00:00:30,516
&gt;&gt;  女士们  先生们  下午好

4
00:00:31,456 --> 00:00:32,516
我希望你们到目前

5
00:00:32,776 --> 00:00:34,256
在苹果开发者大会上都很开心

6
00:00:35,386 --> 00:00:37,126
我叫 Stuart Cheshire

7
00:00:37,126 --> 00:00:37,966
我会为你们介绍网络结构

8
00:00:40,616 --> 00:00:41,626
内容很多

9
00:00:41,626 --> 00:00:43,396
所以我们直接开始吧

10
00:00:44,126 --> 00:00:45,896
演讲两个部分

11
00:00:47,196 --> 00:00:49,716
第一部分  我会向你们

12
00:00:49,716 --> 00:00:52,136
介绍一些这几年

13
00:00:52,246 --> 00:00:53,806
工作中的技术的

14
00:00:53,806 --> 00:00:54,906
更新

15
00:00:55,846 --> 00:00:57,756
基于显示反馈的协议（ECN）

16
00:00:58,246 --> 00:01:00,016
是通过互联网

17
00:00:58,246 --> 00:01:00,016
是通过互联网

18
00:01:00,016 --> 00:01:01,746
管理流量的一个新方法

19
00:01:01,746 --> 00:01:04,635
并且不会造成数据包丢失  而 IPv6

20
00:01:04,635 --> 00:01:07,836
我相信你们也都知道

21
00:01:07,836 --> 00:01:10,076
是一个新兴的互联网协议

22
00:01:11,646 --> 00:01:12,846
我们将向你们介绍一些

23
00:01:12,986 --> 00:01:15,336
iOS 上的网络堆栈中的

24
00:01:15,336 --> 00:01:17,476
一些新变化  以及一些

25
00:01:17,476 --> 00:01:18,956
现在可用于网络扩展的

26
00:01:18,956 --> 00:01:20,956
新工具

27
00:01:20,956 --> 00:01:23,756
最后  我们将告诉你们

28
00:01:23,756 --> 00:01:25,366
一些关于多路径协议的

29
00:01:25,676 --> 00:01:27,776
好消息

30
00:01:28,346 --> 00:01:30,186
我们使用的 iPhone 

31
00:01:30,186 --> 00:01:32,356
本质上都是多路径设备

32
00:01:32,426 --> 00:01:33,746
它们有不止一个电台

33
00:01:33,746 --> 00:01:35,276
然而今天大多数时候

34
00:01:35,276 --> 00:01:37,686
我们每次只使用其中一个

35
00:01:38,966 --> 00:01:40,446
是时候让我们开始

36
00:01:40,856 --> 00:01:42,386
使用我们的多路径设备的

37
00:01:42,386 --> 00:01:43,436
多路径协议了

38
00:01:46,236 --> 00:01:48,816
休息过后  在第二部分

39
00:01:48,816 --> 00:01:50,356
我们会谈到 URLSession 的

40
00:01:50,356 --> 00:01:52,686
一些新进展和

41
00:01:52,796 --> 00:01:54,176
可用的 API

42
00:01:54,596 --> 00:01:56,986
我们将会给出一些

43
00:01:57,086 --> 00:01:58,816
建议和指导

44
00:01:59,676 --> 00:02:00,596
并且会告诉你们一些

45
00:01:59,676 --> 00:02:00,596
并且会告诉你们一些

46
00:02:00,596 --> 00:02:02,786
即将发生的新进展

47
00:02:02,786 --> 00:02:04,046
的最新消息

48
00:02:06,016 --> 00:02:07,346
那么让我们先从 ECN

49
00:02:08,205 --> 00:02:09,306
基于显示反馈的协议 开始

50
00:02:12,616 --> 00:02:14,026
有时你或许会听到

51
00:02:14,026 --> 00:02:15,686
人们谈起网络拥塞

52
00:02:16,356 --> 00:02:18,576
好像是一个坏事

53
00:02:18,936 --> 00:02:20,786
然而传输协议的工作

54
00:02:21,116 --> 00:02:22,696
正是要通过网络

55
00:02:22,696 --> 00:02:24,556
最大限度的传送数据

56
00:02:24,556 --> 00:02:26,946
而它的方法就是传送的

57
00:02:26,946 --> 00:02:28,646
越来越快

58
00:02:28,966 --> 00:02:30,396
直到它传送的过快为止

59
00:02:30,776 --> 00:02:32,466
从某种意义上来说  它是在

60
00:02:32,466 --> 00:02:33,616
进行一个破坏性实验

61
00:02:35,716 --> 00:02:37,566
所以  如果网络的编程

62
00:02:37,566 --> 00:02:39,156
正确  它应当发生

63
00:02:39,156 --> 00:02:39,836
拥塞

64
00:02:40,946 --> 00:02:43,006
在两个设备之间的任何路径上

65
00:02:43,366 --> 00:02:44,986
会有一个链接  它有

66
00:02:45,036 --> 00:02:46,116
最低的通量

67
00:02:46,116 --> 00:02:47,416
最差的容量

68
00:02:47,416 --> 00:02:48,276
它就是那个瓶颈

69
00:02:48,906 --> 00:02:50,786
传输协议的工作

70
00:02:50,786 --> 00:02:53,226
就是去解决

71
00:02:53,226 --> 00:02:54,556
它在瓶颈链接中的部分

72
00:02:55,206 --> 00:02:56,296
如果你把 12 MB

73
00:02:56,296 --> 00:02:58,706
输入一个 10 MB 的链接

74
00:02:58,706 --> 00:03:00,836
那就不可避免的

75
00:02:58,706 --> 00:03:00,836
那就不可避免的

76
00:03:00,836 --> 00:03:01,656
会出错

77
00:03:02,106 --> 00:03:03,376
短时间内  它可以

78
00:03:03,376 --> 00:03:05,146
存在缓存中

79
00:03:05,146 --> 00:03:06,266
但当设备缓存不足时

80
00:03:06,266 --> 00:03:07,696
它就没有了其他选择  只好

81
00:03:07,696 --> 00:03:08,426
丢失数据包

82
00:03:09,206 --> 00:03:11,146
当它丢失数据包时

83
00:03:11,146 --> 00:03:12,846
这是在提示发送者

84
00:03:12,846 --> 00:03:14,216
它已经运行过快

85
00:03:14,216 --> 00:03:14,896
需要放慢一点

86
00:03:16,086 --> 00:03:18,276
问题在于

87
00:03:18,276 --> 00:03:20,606
通过丢失数据包来

88
00:03:20,606 --> 00:03:21,766
向发送者来传递这个信息

89
00:03:21,766 --> 00:03:22,896
是代价很大的

90
00:03:23,916 --> 00:03:26,096
如果数据包来自一个无线设备

91
00:03:26,096 --> 00:03:27,216
那么就需要很多电量

92
00:03:27,216 --> 00:03:28,316
来发送它们

93
00:03:28,956 --> 00:03:31,116
它使用无限频谱

94
00:03:31,116 --> 00:03:32,466
一种网络容量  来实现发送那些数据包

95
00:03:33,866 --> 00:03:36,096
而当你丢掉它们后

96
00:03:36,096 --> 00:03:37,286
它们必须被重新传输

97
00:03:37,936 --> 00:03:40,316
现在  对你的 app 而言

98
00:03:40,316 --> 00:03:42,136
这些数据包丢失和重新传输

99
00:03:42,136 --> 00:03:44,036
都是隐形的  因为 TCP 或

100
00:03:44,036 --> 00:03:45,196
传输协议就把它们解决了

101
00:03:47,436 --> 00:03:48,676
或者我应该说  几乎隐形

102
00:03:49,986 --> 00:03:51,576
数据包丢失是看不到的  但是

103
00:03:51,576 --> 00:03:52,916
它所导致的延迟却是可见的

104
00:03:54,396 --> 00:03:55,846
你的 app 可能需要

105
00:03:55,846 --> 00:03:57,586
等待那些被重新传输的

106
00:03:57,586 --> 00:04:00,396
数据  这就会导致

107
00:03:57,586 --> 00:04:00,396
数据  这就会导致

108
00:04:00,686 --> 00:04:02,326
更慢  更拖沓的用户体验

109
00:04:04,106 --> 00:04:05,256
有了 ECN

110
00:04:05,256 --> 00:04:07,206
当这个

111
00:04:07,206 --> 00:04:09,966
瓶颈发现

112
00:04:09,966 --> 00:04:12,066
数据开始排起长队等候传输的时候

113
00:04:12,066 --> 00:04:13,606
它不会等到缓存不足

114
00:04:13,606 --> 00:04:16,046
它会立刻

115
00:04:16,125 --> 00:04:17,596
在 IP 数据包标题中设一个字节

116
00:04:17,596 --> 00:04:19,815
表明遭遇拥塞

117
00:04:19,815 --> 00:04:21,836
这就是一个对发送者的暗示

118
00:04:22,125 --> 00:04:24,216
发送者会放缓传输

119
00:04:24,216 --> 00:04:25,946
让网络调整

120
00:04:25,946 --> 00:04:28,456
发送者的传输速率而不必

121
00:04:28,456 --> 00:04:29,166
损失数据

122
00:04:30,436 --> 00:04:31,856
ECN 的一个副作用是

123
00:04:32,106 --> 00:04:34,076
它同时鼓励了 ECN

124
00:04:34,106 --> 00:04:36,056
在网络中配置更智能的

125
00:04:36,056 --> 00:04:37,606
排队算法  这也是

126
00:04:37,606 --> 00:04:38,626
一件好事情

127
00:04:39,566 --> 00:04:42,316
如果你的设备比较单纯

128
00:04:42,416 --> 00:04:44,866
只用一个

129
00:04:44,866 --> 00:04:47,216
先到先得的排队算法

130
00:04:47,466 --> 00:04:48,596
一直填满队列  直到

131
00:04:48,596 --> 00:04:49,296
缓存不足

132
00:04:49,896 --> 00:04:51,796
此时如果有一个数据包到达

133
00:04:51,796 --> 00:04:52,576
它就没什么选择了

134
00:04:52,576 --> 00:04:53,566
它只能丢失数据

135
00:04:54,276 --> 00:04:56,806
所以你不能在一个愚蠢的 5-0 排队算法上

136
00:04:56,806 --> 00:04:57,956
使用 ECN

137
00:04:58,656 --> 00:05:00,026
你得用一个智能的排队算法

138
00:04:58,656 --> 00:05:00,026
你得用一个智能的排队算法

139
00:05:00,556 --> 00:05:01,736
而那些智能的排队算法

140
00:05:01,736 --> 00:05:03,726
可以让队列保持在较短状态

141
00:05:03,776 --> 00:05:06,796
并且在情况变得太糟糕之前

142
00:05:06,796 --> 00:05:08,276
就发信号通知拥塞

143
00:05:08,766 --> 00:05:10,536
它们可以帮助你将

144
00:05:10,536 --> 00:05:13,396
网络中的延迟最小化

145
00:05:13,396 --> 00:05:14,446
并且消灭缓存过满的问题

146
00:05:19,046 --> 00:05:20,596
客户端  服务器和网络三个部分必须

147
00:05:20,596 --> 00:05:22,616
协同工作

148
00:05:23,216 --> 00:05:26,396
ECN 才能工作

149
00:05:29,966 --> 00:05:31,686
我很高兴告诉你们

150
00:05:31,846 --> 00:05:33,806
在我们最近一次对

151
00:05:33,806 --> 00:05:35,506
Alexa 前 100 万网站的调查中

152
00:05:35,866 --> 00:05:37,516
几乎四分之三

153
00:05:37,516 --> 00:05:38,806
都已经支持 ECN 了

154
00:05:39,786 --> 00:05:41,646
对于大部分情况来说

155
00:05:41,646 --> 00:05:42,836
这并不是因为网络管理员

156
00:05:42,836 --> 00:05:44,316
做了一个智慧的决定

157
00:05:44,346 --> 00:05:46,626
来支持 ECN

158
00:05:46,626 --> 00:05:48,166
这只不过是因为它是

159
00:05:48,166 --> 00:05:50,056
默认的 Linux 内核的一部分 

160
00:05:50,056 --> 00:05:50,776
所以他们可以免费获取

161
00:05:51,506 --> 00:05:53,756
好消息是

162
00:05:53,756 --> 00:05:55,266
Alexa前 100 万网站中的

163
00:05:55,266 --> 00:05:57,146
几乎四分之三都已经

164
00:05:57,146 --> 00:05:58,456
支持 ECN 所以这是服务器要解决的问题了

165
00:06:00,586 --> 00:06:02,976
在客户端这方面  我们一直在

166
00:06:02,976 --> 00:06:04,646
苹果进行实验

167
00:06:05,566 --> 00:06:09,056
在iOS 10.3中  对于

168
00:06:09,056 --> 00:06:11,386
Wi-Fi  以太网和一些移动运营商中

169
00:06:11,386 --> 00:06:13,216
所有符合条件的 TCP 连接

170
00:06:13,216 --> 00:06:16,086
我们抛硬币随机选取

171
00:06:16,086 --> 00:06:18,286
一半的 TCP 连接将

172
00:06:18,416 --> 00:06:18,986
提出 ECN 请求

173
00:06:20,256 --> 00:06:21,976
我们这么做是为了估测

174
00:06:21,976 --> 00:06:23,716
网络是否对 ECN 安全

175
00:06:24,146 --> 00:06:26,066
五年前  这样对实验

176
00:06:26,066 --> 00:06:27,176
或许会产生

177
00:06:27,176 --> 00:06:27,996
不同的结果

178
00:06:27,996 --> 00:06:29,656
有的旧的防火墙

179
00:06:29,656 --> 00:06:31,296
和 middlebox 会因为

180
00:06:31,296 --> 00:06:32,936
ECN 而混乱

181
00:06:33,836 --> 00:06:36,146
好消息是我们

182
00:06:36,146 --> 00:06:38,446
在全世界范围内大面积进行这个实验

183
00:06:38,606 --> 00:06:41,966
并未看到

184
00:06:41,966 --> 00:06:42,996
任何新闻  并没有听到任何

185
00:06:42,996 --> 00:06:44,116
客户抱怨

186
00:06:44,116 --> 00:06:45,226
网络瘫痪

187
00:06:45,716 --> 00:06:48,346
在我们为

188
00:06:48,346 --> 00:06:51,646
考察设备表现如何而检测的

189
00:06:51,646 --> 00:06:53,706
各项 AWD 指标中

190
00:06:53,706 --> 00:06:55,756
我们没有发现任何在

191
00:06:56,136 --> 00:06:57,836
数据包丢失  重新传输

192
00:06:57,836 --> 00:06:59,146
重新排序或其他我们所关心的

193
00:06:59,146 --> 00:07:00,576
指标方面有任何明显区别

194
00:06:59,146 --> 00:07:00,576
指标方面有任何明显区别

195
00:07:00,986 --> 00:07:03,026
所以  看起来

196
00:07:03,026 --> 00:07:04,906
现在的网络使用 ECN 是安全的

197
00:07:05,996 --> 00:07:08,016
现在我们已经不再期待会看到

198
00:07:08,346 --> 00:07:10,896
任何网络拥塞标记

199
00:07:11,156 --> 00:07:12,636
因为在

200
00:07:12,666 --> 00:07:13,916
客户端和服务器执行

201
00:07:13,916 --> 00:07:15,646
ECN 之前  有太多太多事情 

202
00:07:15,646 --> 00:07:17,426
刺激网络运营商

203
00:07:17,426 --> 00:07:18,746
来使用它了

204
00:07:19,406 --> 00:07:21,836
确实  在世界上大部分地方

205
00:07:22,486 --> 00:07:24,876
我们几乎都看不到拥塞标记了

206
00:07:25,466 --> 00:07:27,606
然而当我们再进一步观察

207
00:07:28,306 --> 00:07:31,956
我们看到在墨西哥

208
00:07:31,956 --> 00:07:34,976
我们采集的的设备报告中

209
00:07:34,976 --> 00:07:36,426
3% 的数据中

210
00:07:36,796 --> 00:07:38,486
至少有一个包经历了拥塞

211
00:07:39,916 --> 00:07:41,316
在法国  这个数字是 6%

212
00:07:42,106 --> 00:07:43,936
在阿根廷  这个数字是 30%

213
00:07:44,786 --> 00:07:45,946
我不知道阿根廷人在搞什么

214
00:07:45,946 --> 00:07:47,176
但是看起来

215
00:07:47,246 --> 00:07:48,766
他们已经在

216
00:07:48,766 --> 00:07:50,356
开始部署 ECN 了

217
00:07:50,356 --> 00:07:52,056
如果这是真的

218
00:07:52,056 --> 00:07:52,836
干得好  阿根廷

219
00:07:52,836 --> 00:07:53,596
这就很神奇了

220
00:07:54,276 --> 00:07:57,886
总结一下

221
00:07:57,886 --> 00:08:00,526
服务器支持 ECN 客户端也

222
00:07:57,886 --> 00:08:00,526
服务器支持 ECN 客户端也

223
00:08:00,526 --> 00:08:03,116
支持 ECN 我们已经判定在 iOS 11

224
00:08:03,116 --> 00:08:04,186
它是安全的

225
00:08:04,186 --> 00:08:06,466
100%的可用连接

226
00:08:07,416 --> 00:08:09,086
都会在无线网络  以太网或

227
00:08:09,306 --> 00:08:11,456
一些特定的运营商中使用

228
00:08:12,196 --> 00:08:14,826
如果你在运营商工作

229
00:08:14,826 --> 00:08:16,026
而不在这个项目中

230
00:08:16,296 --> 00:08:18,956
你可以联系你的运营商

231
00:08:18,956 --> 00:08:21,506
在苹果的公关人员  他们会帮你

232
00:08:21,506 --> 00:08:22,926
进入这个项目

233
00:08:22,926 --> 00:08:24,506
让你的网络也支持 ECN 

234
00:08:25,486 --> 00:08:26,996
现在舞台已经搭好

235
00:08:27,196 --> 00:08:28,136
用户在使用它

236
00:08:28,346 --> 00:08:29,476
服务器也在使用它

237
00:08:29,936 --> 00:08:32,366
世界上的任何 ISP 或网络运营商

238
00:08:32,366 --> 00:08:35,346
可以使用

239
00:08:35,346 --> 00:08:36,926
并且马上使他们的用户

240
00:08:36,966 --> 00:08:38,436
获得更好的体验

241
00:08:39,655 --> 00:08:41,366
一个关于 ECN 的常见的误区

242
00:08:41,366 --> 00:08:43,385
就是它必须在整个网络的

243
00:08:43,385 --> 00:08:45,536
所有路径上都实现

244
00:08:45,536 --> 00:08:46,986
端到端的支持

245
00:08:47,246 --> 00:08:48,126
但事实并不是这样

246
00:08:48,836 --> 00:08:50,836
你只需要让

247
00:08:50,836 --> 00:08:53,446
一处支持 ECN 就可以享受它

248
00:08:53,446 --> 00:08:54,146
带来的福利

249
00:08:56,286 --> 00:08:58,006
如我所说  在两个设备之间的

250
00:08:58,006 --> 00:08:59,576
任何路径上  一般都有一个

251
00:08:59,576 --> 00:09:01,646
链接是瓶颈链接

252
00:08:59,576 --> 00:09:01,646
链接是瓶颈链接

253
00:09:01,646 --> 00:09:04,566
对于你们中的大部分

254
00:09:04,566 --> 00:09:06,136
在家使用宽带的人而言

255
00:09:06,136 --> 00:09:07,276
那个瓶颈其实

256
00:09:07,526 --> 00:09:09,726
是人为设置的

257
00:09:10,516 --> 00:09:11,866
你可能购买的是 10MB

258
00:09:11,866 --> 00:09:14,046
或者 20MB 又或者 50MB 的

259
00:09:14,046 --> 00:09:16,526
服务  而你的 ISP 供应商

260
00:09:16,556 --> 00:09:18,956
提供这个服务的方式

261
00:09:19,286 --> 00:09:20,746
就是人为地把数据

262
00:09:20,746 --> 00:09:21,916
掐到你付钱购买的那个速度上

263
00:09:23,066 --> 00:09:25,076
所以你几乎所有连接的

264
00:09:25,076 --> 00:09:27,026
路径上的一个队列

265
00:09:27,026 --> 00:09:29,476
就是存在于你的

266
00:09:29,476 --> 00:09:31,726
ISP 的前端设备的那个

267
00:09:31,826 --> 00:09:33,516
你的数据在这个前端设备上被节流

268
00:09:34,536 --> 00:09:35,866
这是路径上唯一

269
00:09:35,866 --> 00:09:37,706
需要通过设置二进位

270
00:09:37,706 --> 00:09:39,296
来标记拥塞的地方

271
00:09:39,356 --> 00:09:40,546
而非通过丢失数据包

272
00:09:40,546 --> 00:09:43,266
而你的用户可以获得

273
00:09:43,266 --> 00:09:45,046
一个更快  响应更良好的

274
00:09:45,046 --> 00:09:45,876
网络环境

275
00:09:46,546 --> 00:09:48,526
我想请出

276
00:09:48,526 --> 00:09:49,876
我的同事 David

277
00:09:49,876 --> 00:09:51,426
Schinazzi 到台上来

278
00:09:51,736 --> 00:09:52,776
给你们讲一些新的信息

279
00:09:54,516 --> 00:09:59,546
[ 掌声 ]

280
00:10:00,046 --> 00:10:00,976
&gt;&gt;  大家下午好

281
00:10:01,676 --> 00:10:03,606
我叫 David Schinazzi 是一个

282
00:10:03,606 --> 00:10:04,866
苹果的核心网络工程师

283
00:10:04,866 --> 00:10:06,306
我想首先

284
00:10:06,306 --> 00:10:08,496
谈一谈 IPv6

285
00:10:08,746 --> 00:10:10,036
给你们一些最新的情况

286
00:10:11,156 --> 00:10:13,346
尤其是你正在

287
00:10:13,346 --> 00:10:14,526
写一些要用到网络的 app 的话

288
00:10:14,526 --> 00:10:16,116
你需要关注一下

289
00:10:18,036 --> 00:10:20,176
你们之中也许有人知道

290
00:10:20,736 --> 00:10:21,916
昨天是全球 IPv6

291
00:10:21,916 --> 00:10:23,886
投入使用五周年

292
00:10:25,426 --> 00:10:28,216
五年前的昨天

293
00:10:28,216 --> 00:10:30,346
网上的许多内容提供者

294
00:10:30,346 --> 00:10:31,896
聚到一起

295
00:10:31,896 --> 00:10:32,686
启用了 IPv6

296
00:10:32,776 --> 00:10:35,346
它运行良好  所以他们

297
00:10:35,346 --> 00:10:37,196
没有关闭它  但是那之后发生了什么呢？

298
00:10:38,306 --> 00:10:40,376
这个图像显示的是

299
00:10:40,376 --> 00:10:42,776
在过去几年中的客户端设备使用情况

300
00:10:42,836 --> 00:10:45,146
那时候  不到 1% 的设备

301
00:10:45,146 --> 00:10:46,706
支持 IPv6

302
00:10:47,046 --> 00:10:48,506
现在  数字几乎达到 20%

303
00:10:49,306 --> 00:10:51,076
很重要的一点是

304
00:10:51,076 --> 00:10:52,886
如果你为苹果设备写 app 的话

305
00:10:52,886 --> 00:10:54,686
在苹果设备使用最多的市场

306
00:10:54,686 --> 00:10:55,946
这些数字一般来说

307
00:10:55,946 --> 00:10:56,936
会更高

308
00:10:58,356 --> 00:10:59,416
尤其是对蜂窝数据来说

309
00:10:59,416 --> 00:11:02,996
几乎与我们合作的

310
00:10:59,416 --> 00:11:02,996
几乎与我们合作的

311
00:11:02,996 --> 00:11:04,586
所有运营商现在都使用

312
00:11:04,586 --> 00:11:06,196
双栈  就是说他们

313
00:11:06,196 --> 00:11:08,416
同时提供 IPv4 和 IPv6

314
00:11:08,536 --> 00:11:11,716
好消息是  这样的效果更好

315
00:11:12,686 --> 00:11:14,156
所以我们事实上

316
00:11:14,306 --> 00:11:15,106
依据很多我们的设备所作出的连接

317
00:11:15,106 --> 00:11:16,476
而进行估测

318
00:11:16,976 --> 00:11:19,206
HTTPS 请求的加载速度提高了

319
00:11:19,206 --> 00:11:22,006
15-30% 这意味着 

320
00:11:22,006 --> 00:11:23,166
如果你同时打开了两个 app

321
00:11:23,166 --> 00:11:24,836
你就会发现其中的区别

322
00:11:25,626 --> 00:11:27,286
你的用户也会看到区别

323
00:11:28,786 --> 00:11:29,926
所以如果你至今仍不知道

324
00:11:29,926 --> 00:11:31,776
是否支持 IPv6

325
00:11:32,366 --> 00:11:34,356
你需要检查一下

326
00:11:34,356 --> 00:11:35,726
联系你的服务器团队  确保他们

327
00:11:35,726 --> 00:11:36,376
能够支持 IPv6

328
00:11:36,376 --> 00:11:38,216
你可无法负担得起

329
00:11:38,216 --> 00:11:39,366
一直拖着不用它

330
00:11:41,266 --> 00:11:42,536
另一个重要的我想谈的趋势

331
00:11:42,536 --> 00:11:43,996
是 NAT64

332
00:11:43,996 --> 00:11:46,536
我们从两年前的 WWDC

333
00:11:46,536 --> 00:11:48,976
开始讨论这件事

334
00:11:48,976 --> 00:11:49,916
去年我们把它变成了一个 App Store 的准入要求

335
00:11:49,916 --> 00:11:52,316
现在它来了

336
00:11:52,846 --> 00:11:54,676
它已经在一个

337
00:11:54,676 --> 00:11:56,926
美国的主流运营商上

338
00:11:56,926 --> 00:12:00,336
投入使用了几个月  每个设备

339
00:11:56,926 --> 00:12:00,336
投入使用了几个月  每个设备

340
00:12:00,606 --> 00:12:01,206
都是只支持 v6 的

341
00:12:01,726 --> 00:12:03,306
它们没有 IPv4 地址

342
00:12:03,346 --> 00:12:05,456
它们只能通过 IPv6 交流

343
00:12:06,256 --> 00:12:07,486
但那并不意味着你

344
00:12:07,486 --> 00:12:08,896
不能与 v4 服务器交流

345
00:12:08,896 --> 00:12:10,426
因为有一个叫做 NAT64 的网络盒子

346
00:12:10,746 --> 00:12:13,426
设备就仍然可以

347
00:12:13,426 --> 00:12:14,846
连接到那些服务器

348
00:12:14,946 --> 00:12:16,046
然而  这样你就无法获得

349
00:12:16,046 --> 00:12:17,226
那些我们谈到的

350
00:12:17,226 --> 00:12:18,356
本地使用 v6 的性能优势了

351
00:12:20,606 --> 00:12:21,966
但是  最重要的是

352
00:12:21,966 --> 00:12:23,996
app 需要确保它

353
00:12:23,996 --> 00:12:25,076
支持 IPv6

354
00:12:25,206 --> 00:12:27,096
如果它试图连接到 IPv4

355
00:12:27,096 --> 00:12:28,156
这是行不通的

356
00:12:29,126 --> 00:12:30,156
那么你要怎么做呢

357
00:12:30,546 --> 00:12:31,376
其实非常简单

358
00:12:31,976 --> 00:12:33,756
如果你使用我们的高级 API

359
00:12:34,006 --> 00:12:35,786
比如 URLSession CFNetwork

360
00:12:36,176 --> 00:12:37,536
系统库会替你完成所有这些

361
00:12:37,536 --> 00:12:38,596
繁重工作

362
00:12:38,966 --> 00:12:39,976
你不需要担心任何

363
00:12:40,006 --> 00:12:42,136
IPv4 或 IPv6 的事情

364
00:12:42,136 --> 00:12:43,146
它会自动运行

365
00:12:43,556 --> 00:12:45,536
你需要避免的是

366
00:12:45,536 --> 00:12:47,936
在 API 上使用 Legacy IPv4

367
00:12:48,466 --> 00:12:50,046
直接在你的 app 上

368
00:12:50,046 --> 00:12:53,146
输入一个 IPv4 地址  或者使用

369
00:12:53,146 --> 00:12:54,156
预先检查

370
00:12:54,846 --> 00:12:57,346
比方说  如果你在

371
00:12:57,346 --> 00:12:59,036
进行连接之前检查

372
00:12:59,036 --> 00:13:00,366
设备是否是 IPv4 地址

373
00:12:59,036 --> 00:13:00,366
设备是否是 IPv4 地址

374
00:13:00,366 --> 00:13:00,936
就是行不通的

375
00:13:03,486 --> 00:13:05,346
并且

376
00:13:05,346 --> 00:13:06,316
你需要考虑它的另一个原因是

377
00:13:06,316 --> 00:13:07,916
这是一个 app 的审查标准

378
00:13:08,946 --> 00:13:10,496
任何 app 不管是新的

379
00:13:10,856 --> 00:13:12,826
还是一个升级版本  要在 app store 上架

380
00:13:12,826 --> 00:13:13,546
都必须具备此性能

381
00:13:14,076 --> 00:13:16,036
每一个 app 都会在一个

382
00:13:16,266 --> 00:13:18,666
只有 IPv6 的 NAT64 网络环境中被测试

383
00:13:18,666 --> 00:13:20,256
如果它无法运行  你就无法

384
00:13:20,256 --> 00:13:21,236
让它上架

385
00:13:21,886 --> 00:13:23,196
然而  我要祝贺

386
00:13:23,196 --> 00:13:24,776
所有的开发者

387
00:13:24,776 --> 00:13:26,676
因为你们都已经修正了

388
00:13:26,676 --> 00:13:28,246
你们的 app  我们现在已经几乎

389
00:13:28,246 --> 00:13:29,196
不用拒绝任何 app 了

390
00:13:29,596 --> 00:13:30,356
干得好

391
00:13:32,076 --> 00:13:34,066
如果你希望我给出一些关于

392
00:13:34,066 --> 00:13:34,986
如何保证一切正常的

393
00:13:34,986 --> 00:13:37,126
建议  开发者网站上有一个

394
00:13:37,126 --> 00:13:38,676
部分叫做

395
00:13:38,676 --> 00:13:40,696
支持 supporting IPv6 DNS64/NAT64

396
00:13:40,696 --> 00:13:41,466
网站

397
00:13:41,626 --> 00:13:42,896
你也随时可以加入我们

398
00:13:42,896 --> 00:13:45,196
明天和周五的实验室  提出任何问题

399
00:13:49,046 --> 00:13:50,626
现在我想换个话题

400
00:13:50,626 --> 00:13:52,426
聊聊在设备本身的网络架构问题

401
00:13:52,426 --> 00:13:54,646
然后向你们介绍

402
00:13:54,646 --> 00:13:55,946
今年我们称之为用户空间网络架构的

403
00:13:55,946 --> 00:13:57,416
东西

404
00:13:58,646 --> 00:14:00,596
你或许对

405
00:13:58,646 --> 00:14:00,596
你或许对

406
00:14:00,666 --> 00:14:01,826
网络堆栈的传统模型很熟悉

407
00:14:01,826 --> 00:14:04,396
在这种模型中

408
00:14:04,396 --> 00:14:05,806
内核承担了很多繁重的工作

409
00:14:06,436 --> 00:14:08,796
所以诸如 Wi-Fi  IP

410
00:14:08,796 --> 00:14:10,486
TCP 等协议都是在内核中处理的 

411
00:14:11,536 --> 00:14:12,796
那样就有一个边界叫做

412
00:14:12,896 --> 00:14:14,866
BSD socket API

413
00:14:15,256 --> 00:14:16,486
而其他的都在 app 内部

414
00:14:16,486 --> 00:14:17,126
进行处理

415
00:14:17,846 --> 00:14:18,906
我的意思是  在

416
00:14:18,906 --> 00:14:20,006
app 运行过程之内  而不

417
00:14:20,006 --> 00:14:20,846
是在你的代码之内

418
00:14:21,186 --> 00:14:22,376
它有可能在系统库里面

419
00:14:22,376 --> 00:14:24,196
但是 HTTPS 或者 TLS 这样的协议

420
00:14:24,196 --> 00:14:26,096
就会被在这个过程中被处理

421
00:14:27,456 --> 00:14:29,456
在 iOS 11 中我们第一次提出了

422
00:14:29,456 --> 00:14:31,696
我们正在

423
00:14:31,696 --> 00:14:33,456
将 app 中的一切都统一起来

424
00:14:34,386 --> 00:14:36,216
这就意味着

425
00:14:36,216 --> 00:14:37,826
各个协议的联系可以更紧密

426
00:14:37,826 --> 00:14:40,076
一切都会具有更高性能

427
00:14:40,756 --> 00:14:42,786
我们注意到它会大量

428
00:14:42,786 --> 00:14:44,826
减少 CPU 的使用量

429
00:14:44,826 --> 00:14:46,196
让你能有更多

430
00:14:46,196 --> 00:14:48,116
的动画时间  不仅如此

431
00:14:48,116 --> 00:14:49,146
最终用户会有更长的续航时间

432
00:14:51,756 --> 00:14:53,076
我要提醒的是

433
00:14:53,076 --> 00:14:54,806
你只有在使用一个

434
00:14:54,806 --> 00:14:56,006
高等级 IPI

435
00:14:56,006 --> 00:14:57,206
比如 URLSession 时才可以获取这个协议

436
00:14:57,756 --> 00:14:59,226
如果你依然在使用 CBSD 插座的话

437
00:14:59,226 --> 00:15:00,246
你就无法获得这些性能优势了

438
00:14:59,226 --> 00:15:00,246
你就无法获得这些性能优势了

439
00:15:02,156 --> 00:15:04,236
我还要提出的一点

440
00:15:04,236 --> 00:15:05,996
就是

441
00:15:05,996 --> 00:15:08,196
Network Kernel Extensions 

442
00:15:08,196 --> 00:15:10,296
它依赖于内核中的

443
00:15:10,296 --> 00:15:12,406
传统 BSD 插座，我们很快就不会再使用了

444
00:15:13,466 --> 00:15:15,516
如果你还在使用它们的话

445
00:15:15,516 --> 00:15:17,666
请现在就开始向

446
00:15:17,666 --> 00:15:19,196
网络扩展框架过渡

447
00:15:19,596 --> 00:15:20,716
如果你有任何问题的话

448
00:15:20,716 --> 00:15:22,016
可以来找我们讨论

449
00:15:23,456 --> 00:15:24,326
说到网络扩展框架

450
00:15:24,326 --> 00:15:26,726
我想向你们介绍

451
00:15:26,726 --> 00:15:29,116
关于Wi-Fi配置和

452
00:15:29,546 --> 00:15:31,126
扩展 DNS 的两款今年新开发的 API

453
00:15:32,976 --> 00:15:35,416
新的框架是两年前

454
00:15:35,416 --> 00:15:37,536
提出的

455
00:15:37,536 --> 00:15:39,226
有四个主要部分

456
00:15:39,976 --> 00:15:42,736
NEVPNManager 允许你配置

457
00:15:43,656 --> 00:15:45,356
设备上的 VPN 堆栈

458
00:15:46,446 --> 00:15:48,336
NETunnelProvider 允许你

459
00:15:48,336 --> 00:15:49,706
构建自己的用户 VPN 协议

460
00:15:51,076 --> 00:15:52,806
NEHotspotHelper 允许你

461
00:15:53,166 --> 00:15:54,926
自定义你的设备如何

462
00:15:55,456 --> 00:15:57,736
验证 Wi-Fi 热点

463
00:15:58,306 --> 00:16:00,096
最后 NEFilterProvider

464
00:15:58,306 --> 00:16:00,096
最后 NEFilterProvider

465
00:16:00,096 --> 00:16:01,786
允许你建立一个安全的

466
00:16:01,896 --> 00:16:03,246
基于设备的内容过滤器

467
00:16:03,916 --> 00:16:05,426
我不会过于详细地

468
00:16:05,426 --> 00:16:07,366
解释这个 API 的四个部分

469
00:16:07,366 --> 00:16:09,536
不过两年前有一场 WWDC 会议

470
00:16:09,536 --> 00:16:11,536
讲了很多关于这个的细节

471
00:16:13,956 --> 00:16:16,346
现在我们来讨论关于热点配置的问题

472
00:16:18,396 --> 00:16:20,616
你们或许有过这样的经历

473
00:16:20,616 --> 00:16:22,356
买来一个

474
00:16:22,356 --> 00:16:24,326
智能相机

475
00:16:24,736 --> 00:16:26,296
你把它从盒子里拿出来

476
00:16:26,296 --> 00:16:27,746
它就告诉你  在你的 iphone 上加入这个

477
00:16:27,746 --> 00:16:30,486
Wi-Fi 网络来

478
00:16:30,486 --> 00:16:32,256
配置这个 app

479
00:16:32,256 --> 00:16:33,726
然后在这个 app 里它会告诉你

480
00:16:33,726 --> 00:16:35,196
打开设置  选择 Wi-Fi

481
00:16:35,196 --> 00:16:36,976
输入密码  整个过程非常麻烦

482
00:16:37,716 --> 00:16:38,976
用户可能会输错密码

483
00:16:39,596 --> 00:16:40,756
他们也可能会忘记

484
00:16:40,756 --> 00:16:42,016
设置 app 在哪

485
00:16:42,406 --> 00:16:43,686
我们收到了很多

486
00:16:43,686 --> 00:16:45,186
开发者的请求  寻求一个

487
00:16:45,186 --> 00:16:46,186
更好的解决方案

488
00:16:46,896 --> 00:16:48,666
我们就添加了这个

489
00:16:48,666 --> 00:16:50,496
简单的 API 允许你

490
00:16:50,496 --> 00:16:52,946
做任何可以在 app 中做的操作

491
00:16:53,516 --> 00:16:57,676
[ 掌声 ]

492
00:16:58,176 --> 00:16:59,786
现在用户再也不必

493
00:16:59,786 --> 00:17:01,076
关掉 app 他们会收到一个

494
00:16:59,786 --> 00:17:01,076
关掉 app 他们会收到一个

495
00:17:01,076 --> 00:17:02,626
提示以确认他们

496
00:17:02,676 --> 00:17:03,886
是否想做某个操作

497
00:17:04,165 --> 00:17:05,526
他们点击“加入”  就可以

498
00:17:05,526 --> 00:17:06,076
联入 Wi-Fi

499
00:17:06,076 --> 00:17:07,256
就这么简单

500
00:17:07,616 --> 00:17:10,185
你可以把这个 API 设置成

501
00:17:10,185 --> 00:17:10,925
暂时的

502
00:17:10,925 --> 00:17:13,326
如果你正在为一个智能设备

503
00:17:13,326 --> 00:17:14,546
开发一个配置 appc

504
00:17:14,546 --> 00:17:16,396
你只会希望你在用 app 的时候

505
00:17:16,396 --> 00:17:18,175
才联入这个 Wi-Fi

506
00:17:19,146 --> 00:17:20,636
所以  如果用户想要

507
00:17:20,636 --> 00:17:21,695
关掉你的 app 然后

508
00:17:21,695 --> 00:17:23,026
做其他的事情

509
00:17:23,026 --> 00:17:24,656
设备会自动断开这个

510
00:17:24,656 --> 00:17:27,126
Wi-Fi 并且加入

511
00:17:27,126 --> 00:17:28,256
其他的 Wi-Fi 网络

512
00:17:28,956 --> 00:17:31,096
你也可以用这个 API 达到

513
00:17:31,256 --> 00:17:32,696
传统意义上使用 Wi-Fi 的目的

514
00:17:33,126 --> 00:17:34,196
比如  如果你正在为一个连锁咖啡店

515
00:17:34,196 --> 00:17:36,446
开发 app

516
00:17:36,446 --> 00:17:37,336
希望你的用户能够

517
00:17:37,336 --> 00:17:38,656
在这些咖啡店里自动

518
00:17:38,656 --> 00:17:39,496
联入 Wi-Fi

519
00:17:40,236 --> 00:17:41,786
当然 CPI 支持

520
00:17:41,786 --> 00:17:43,936
所有我们的 Wi-Fi 协议栈今天

521
00:17:43,936 --> 00:17:46,036
支持的所有认证方式

522
00:17:47,346 --> 00:17:48,566
让我来向你们展示这有多简单

523
00:17:48,566 --> 00:17:50,876
这是一些关于以上两个例子

524
00:17:50,876 --> 00:17:52,506
的示范代码

525
00:17:52,506 --> 00:17:53,856
如果你想配置一个照相机

526
00:17:53,856 --> 00:17:55,586
你只需要

527
00:17:55,586 --> 00:17:57,356
用 Wi-Fi 的名字和密码

528
00:17:57,356 --> 00:17:58,616
创建一个配置

529
00:17:59,426 --> 00:18:01,136
然后设置要加入的那个网络的属性

530
00:17:59,426 --> 00:18:01,136
然后设置要加入的那个网络的属性

531
00:18:01,136 --> 00:18:02,276
表明你想在

532
00:18:02,276 --> 00:18:04,396
设备或者用户关掉

533
00:18:04,606 --> 00:18:07,236
你的 app 时断开连接

534
00:18:07,236 --> 00:18:07,836
然后应用这个配置

535
00:18:09,606 --> 00:18:11,646
然后检查结果是否成功

536
00:18:12,726 --> 00:18:14,116
咖啡店那个例子其实

537
00:18:14,116 --> 00:18:15,516
更加简单  你只需要创建一个

538
00:18:15,516 --> 00:18:17,946
配置  应用

539
00:18:18,046 --> 00:18:18,356
然后就完成了

540
00:18:20,516 --> 00:18:21,956
现在我想谈谈

541
00:18:21,956 --> 00:18:23,206
DNS proxy provider

542
00:18:24,646 --> 00:18:26,716
CPL 允许你自定义

543
00:18:27,826 --> 00:18:29,666
iPhone 或其他 iOS 设备

544
00:18:29,666 --> 00:18:33,666
与 DNS 互动的方式

545
00:18:33,846 --> 00:18:35,326
所以这个 API 就是允许你用最

546
00:18:35,326 --> 00:18:36,986
简单的方式将所有请求都

547
00:18:37,046 --> 00:18:39,106
转到你自己的一个解析器上

548
00:18:39,956 --> 00:18:41,496
比方说  如果这个

549
00:18:41,496 --> 00:18:43,756
解析器有更好的功能

550
00:18:43,756 --> 00:18:44,696
你甚至可以用它来获取

551
00:18:44,696 --> 00:18:46,576
单个的 DNS 请求并且

552
00:18:46,576 --> 00:18:49,276
通过一个自定义协议发送他们

553
00:18:49,446 --> 00:18:53,006
比如基于 TLS 的 DNS 或基于 GTP 的 DNS 等

554
00:18:53,796 --> 00:18:55,856
那么这就是今年关于

555
00:18:55,856 --> 00:18:56,996
网络扩展的一些最新进展

556
00:18:57,446 --> 00:18:59,456
一个小提示  这是一个

557
00:18:59,456 --> 00:19:02,366
非常强大的 API 所以

558
00:18:59,456 --> 00:19:02,366
非常强大的 API 所以

559
00:19:02,436 --> 00:19:03,606
它做任何事情都必须要求

560
00:19:03,606 --> 00:19:05,686
X-code 能力和权限

561
00:19:05,686 --> 00:19:07,266
也包括用户的同意

562
00:19:08,176 --> 00:19:10,286
现在我想请

563
00:19:10,286 --> 00:19:11,586
Christoph Paasch 到台上

564
00:19:11,586 --> 00:19:13,056
谈谈多路径设备的有关内容

565
00:19:14,516 --> 00:19:16,706
[ 掌声 ]

566
00:19:17,206 --> 00:19:17,826
&gt;&gt;  谢谢 David

567
00:19:18,826 --> 00:19:19,716
大家好

568
00:19:20,686 --> 00:19:22,016
我是 Christoph Paasch

569
00:19:22,076 --> 00:19:23,446
我是苹果的一个网络工程师

570
00:19:23,526 --> 00:19:25,506
我将会向你们展示

571
00:19:25,506 --> 00:19:27,766
我们在 iOS 11 中提供的

572
00:19:27,766 --> 00:19:29,156
能够提高你的

573
00:19:29,156 --> 00:19:31,186
app 在移动设备上的网络连接的

574
00:19:31,476 --> 00:19:32,406
一些新技术

575
00:19:35,306 --> 00:19:37,386
你们肯定都经历过

576
00:19:38,096 --> 00:19:39,496
你正在使用 app

577
00:19:39,736 --> 00:19:41,286
而你的 app 正在

578
00:19:41,286 --> 00:19:43,276
从互联网上下载东西

579
00:19:43,276 --> 00:19:45,466
你一边用着 app

580
00:19:45,466 --> 00:19:47,036
一边从家走出来

581
00:19:48,246 --> 00:19:49,326
现在  当你正从你家

582
00:19:49,326 --> 00:19:51,056
走出来时  你也正

583
00:19:51,106 --> 00:19:52,606
离你的 Wi-Fi 接入点

584
00:19:52,606 --> 00:19:54,726
越来越远  这基本上

585
00:19:54,726 --> 00:19:56,706
意味着你在 Wi-Fi 上创建的连接

586
00:19:56,706 --> 00:19:58,496
也正在变得

587
00:19:58,496 --> 00:20:00,656
越来越慢

588
00:19:58,496 --> 00:20:00,656
越来越慢

589
00:20:00,656 --> 00:20:03,686
最终你的 app 也会

590
00:20:03,686 --> 00:20:05,236
越来越慢

591
00:20:05,236 --> 00:20:06,416
因为它已经无法从网上

592
00:20:06,416 --> 00:20:07,556
下载内容了

593
00:20:08,806 --> 00:20:10,156
只有当你与蜂窝数据

594
00:20:10,156 --> 00:20:12,076
重新建立了一个连接之后

595
00:20:12,076 --> 00:20:13,976
它才能够

596
00:20:14,246 --> 00:20:16,026
重新再开始下载

597
00:20:17,186 --> 00:20:19,096
现在  这件事发生的

598
00:20:19,206 --> 00:20:21,136
原因是我今天使用的

599
00:20:21,136 --> 00:20:23,266
协议是几十年之前

600
00:20:23,306 --> 00:20:24,926
开发的  它被创建出来时

601
00:20:24,926 --> 00:20:26,446
还没有考虑到

602
00:20:26,446 --> 00:20:28,296
移动设备的问题

603
00:20:29,636 --> 00:20:31,996
现在  苹果在几年前

604
00:20:32,046 --> 00:20:33,816
就已经意识到了这个问题

605
00:20:33,816 --> 00:20:36,246
我们在 iOS 中有相应的技术

606
00:20:36,366 --> 00:20:38,496
来对症下药

607
00:20:40,086 --> 00:20:42,206
从 iOS 9 起我们推出了 Wi-F Assist

608
00:20:42,206 --> 00:20:44,936
现在在 iOS 11 中

609
00:20:44,936 --> 00:20:46,246
我们进一步更新了这一功能

610
00:20:47,306 --> 00:20:48,566
我们推出了一个

611
00:20:48,566 --> 00:20:50,496
新的多路径传输协议

612
00:20:50,766 --> 00:20:52,406
叫做 Multipath TCP

613
00:20:52,406 --> 00:20:54,666
并且在 iOS 11 中我们将把它开源

614
00:20:54,666 --> 00:20:56,436
作为一个公共的 API

615
00:20:58,516 --> 00:21:00,906
现在我们先

616
00:20:58,516 --> 00:21:00,906
现在我们先

617
00:21:00,906 --> 00:21:04,376
回顾一下

618
00:21:04,376 --> 00:21:05,596
我们想要解决的是

619
00:21:05,596 --> 00:21:08,496
哪些情况

620
00:21:08,606 --> 00:21:10,466
当你的手机联入

621
00:21:10,466 --> 00:21:12,686
一个良好的 Wi-Fi 网络时

622
00:21:12,686 --> 00:21:13,856
你会创建一个连接

623
00:21:13,856 --> 00:21:15,086
并且你只会从

624
00:21:15,086 --> 00:21:17,336
Wi-Fi 网络中进行下载

625
00:21:18,356 --> 00:21:20,416
如果你的用户正在

626
00:21:20,416 --> 00:21:22,196
走出 Wi-Fi 的覆盖范围  或者离开

627
00:21:22,196 --> 00:21:24,166
Wi-Fi 的接入点  信号强度就会

628
00:21:24,166 --> 00:21:25,486
越来越低

629
00:21:25,486 --> 00:21:27,106
连接也会越来越慢

630
00:21:27,106 --> 00:21:28,846
而最终它会

631
00:21:28,846 --> 00:21:29,856
完全停止

632
00:21:31,416 --> 00:21:32,946
接下来如果你还想

633
00:21:32,946 --> 00:21:34,946
继续下载数据的话

634
00:21:34,946 --> 00:21:36,836
你就需要

635
00:21:36,836 --> 00:21:37,806
在数据网络上创建

636
00:21:37,806 --> 00:21:39,556
一个新的连接

637
00:21:39,556 --> 00:21:41,256
然后从那一刻起

638
00:21:41,256 --> 00:21:42,486
你就再次一切就绪了

639
00:21:42,486 --> 00:21:44,736
你的 app 又可以响应

640
00:21:44,736 --> 00:21:45,876
从服务器发出的数据了

641
00:21:47,466 --> 00:21:49,036
如果你想应对这个情况

642
00:21:49,036 --> 00:21:50,336
在你的 app 的

643
00:21:50,336 --> 00:21:52,186
应用层面

644
00:21:52,186 --> 00:21:53,786
你需要做以下

645
00:21:53,786 --> 00:21:55,366
几件事情

646
00:21:55,656 --> 00:21:58,006
首先你需要记录

647
00:21:58,006 --> 00:21:59,316
你在做的一切事情

648
00:21:59,356 --> 00:22:01,106
因为你不知道什么时候

649
00:21:59,356 --> 00:22:01,106
因为你不知道什么时候

650
00:22:01,106 --> 00:22:04,556
Wi-Fi 会断开

651
00:22:04,556 --> 00:22:05,746
所以你就需要记住

652
00:22:05,746 --> 00:22:06,856
你所做过的一切操作以及

653
00:22:06,856 --> 00:22:08,236
正在传输的请求

654
00:22:09,806 --> 00:22:12,946
第二  你需要一种可以

655
00:22:13,046 --> 00:22:15,186
检测到 Wi-Fi 的方法

656
00:22:15,186 --> 00:22:16,836
所以你需要设法

657
00:22:16,836 --> 00:22:18,206
监测 Wi-Fi 连接的进展情况

658
00:22:20,496 --> 00:22:22,406
现在  一旦你

659
00:22:22,406 --> 00:22:24,206
发现 Wi-Fi 已经不可用 

660
00:22:24,206 --> 00:22:26,436
或者已经无法

661
00:22:26,436 --> 00:22:27,766
提供你需要的服务时

662
00:22:27,766 --> 00:22:29,266
你就需要

663
00:22:29,266 --> 00:22:30,506
创建一个数据网络中的新连接

664
00:22:31,146 --> 00:22:32,776
这就是说你需要进行一个

665
00:22:32,956 --> 00:22:36,146
DSN 重连 TCP 重连和

666
00:22:36,146 --> 00:22:37,136
一个 TLS 重连

667
00:22:37,726 --> 00:22:39,596
只有在这几个步骤完成之后

668
00:22:39,946 --> 00:22:41,676
你才可以通过

669
00:22:41,676 --> 00:22:44,366
蜂窝数据接口

670
00:22:44,366 --> 00:22:46,166
来实现数据传输

671
00:22:46,166 --> 00:22:47,316
你的 app 才可以继续运行

672
00:22:48,786 --> 00:22:49,946
在应用层面完成这些

673
00:22:49,946 --> 00:22:52,526
操作是非常繁琐的

674
00:22:52,836 --> 00:22:54,166
而这只是我们想要解决的

675
00:22:54,206 --> 00:22:55,926
情况之一

676
00:22:57,736 --> 00:22:59,186
我们来看另一个情况

677
00:22:59,966 --> 00:23:01,616
大概是当你在一个

678
00:22:59,966 --> 00:23:01,616
大概是当你在一个

679
00:23:01,616 --> 00:23:03,236
很差的 Wi-Fi 下的情况

680
00:23:03,756 --> 00:23:05,856
比方说  你坐在一个

681
00:23:05,996 --> 00:23:07,226
咖啡馆里  你连接的是

682
00:23:07,226 --> 00:23:08,176
一个公共热点

683
00:23:09,126 --> 00:23:10,586
通常这个公共热点

684
00:23:10,876 --> 00:23:12,386
都是运行良好的

685
00:23:13,066 --> 00:23:14,986
然而有时候很多

686
00:23:14,986 --> 00:23:16,406
其他用户也在咖啡馆里

687
00:23:16,406 --> 00:23:17,876
也许他们中的一个正在

688
00:23:17,876 --> 00:23:19,226
下载一个特别大的文件

689
00:23:20,086 --> 00:23:23,126
由于大部分时候

690
00:23:23,126 --> 00:23:24,646
这个网络并没有一个

691
00:23:24,646 --> 00:23:27,116
智能的队列管理系统

692
00:23:27,116 --> 00:23:28,746
下载这个大型文件可能会

693
00:23:28,746 --> 00:23:30,086
在网络内部造成

694
00:23:30,086 --> 00:23:32,076
缓存过满  而这个

695
00:23:32,076 --> 00:23:35,056
塞子将会使其他

696
00:23:35,056 --> 00:23:36,796
网络连接都特别慢

697
00:23:37,776 --> 00:23:39,796
这就意味着

698
00:23:39,796 --> 00:23:42,336
你的 app 将无法

699
00:23:42,336 --> 00:23:43,776
从互联网

700
00:23:43,776 --> 00:23:45,636
下载数据了

701
00:23:47,266 --> 00:23:48,496
如果你想在

702
00:23:48,496 --> 00:23:49,566
你的 app 中解决

703
00:23:49,566 --> 00:23:51,596
这种问题

704
00:23:51,596 --> 00:23:53,226
你需要在 Wi-Fi 和数据网络上都

705
00:23:53,226 --> 00:23:55,766
创建一个接口  当你

706
00:23:55,766 --> 00:23:57,506
发现 Wi-Fi 情况已经

707
00:23:57,506 --> 00:23:59,596
不够好

708
00:23:59,596 --> 00:24:01,186
数据延迟已经过高时

709
00:23:59,596 --> 00:24:01,186
数据延迟已经过高时

710
00:24:01,626 --> 00:24:02,796
你可以把一小部分数据

711
00:24:02,796 --> 00:24:04,896
通过蜂窝数据传输

712
00:24:04,896 --> 00:24:06,306
这样你的 app 就可以继续运行

713
00:24:07,256 --> 00:24:08,936
一旦 Wi-Fi 再次变好

714
00:24:08,936 --> 00:24:10,476
你可以再次

715
00:24:10,476 --> 00:24:11,866
把你所有的流量都切换到 Wi-Fi 连接

716
00:24:12,846 --> 00:24:14,136
在应用层面完成

717
00:24:14,136 --> 00:24:15,306
这个操作可以说极其困难

718
00:24:18,746 --> 00:24:22,326
这让我们开发了 Wi-Fi

719
00:24:22,326 --> 00:24:24,626
Assist  它是我们从 

720
00:24:24,626 --> 00:24:27,066
iOS 9 起为了

721
00:24:27,266 --> 00:24:29,376
解决这些情况而推出的技术

722
00:24:32,606 --> 00:24:34,896
只要我们在一个不太理想的 Wi-Fi 环境下

723
00:24:34,896 --> 00:24:36,556
Wi-Fi Assist 就会被打开

724
00:24:36,556 --> 00:24:38,746
不太理想的意思就是

725
00:24:38,746 --> 00:24:40,536
Wi-Fi 的信号强度非常低

726
00:24:41,526 --> 00:24:44,186
只要手机和 iOS

727
00:24:44,186 --> 00:24:46,816
发现了这一点

728
00:24:46,816 --> 00:24:49,126
我们会在

729
00:24:49,126 --> 00:24:50,946
Wi-Fi 和数据网络之间

730
00:24:50,946 --> 00:24:51,606
优胜劣汰

731
00:24:53,446 --> 00:24:55,096
当你创建一个新的

732
00:24:55,096 --> 00:24:56,656
连接时  我们会首先

733
00:24:56,656 --> 00:24:58,486
试图关闭与

734
00:24:58,486 --> 00:24:59,086
Wi-Fi 的连接

735
00:25:00,406 --> 00:25:02,566
之后很快

736
00:25:02,566 --> 00:25:03,666
如果这个连接没有被成功创建

737
00:25:03,666 --> 00:25:05,826
我们会继续

738
00:25:05,826 --> 00:25:08,276
创建一个对数据网络的链接

739
00:25:08,276 --> 00:25:10,286
这样我们就可以  如果

740
00:25:10,396 --> 00:25:12,996
蜂窝数据胜出的话

741
00:25:13,096 --> 00:25:15,296
就开始使用数据网络

742
00:25:16,386 --> 00:25:19,996
那么这会使用

743
00:25:19,996 --> 00:25:21,836
一点点蜂窝数据

744
00:25:21,836 --> 00:25:24,396
所以作为 Wi-Fi Assist 的一部分  我们

745
00:25:24,396 --> 00:25:25,846
限制你的 app

746
00:25:26,176 --> 00:25:28,256
在这种情况

747
00:25:28,286 --> 00:25:29,766
可以使用的数据总量

748
00:25:30,236 --> 00:25:31,736
我们在 Wi-Fi Assist 的使用上

749
00:25:31,736 --> 00:25:33,566
获得了很大成功  因为它可以

750
00:25:33,566 --> 00:25:34,726
在 Wi-Fi 情况不好时

751
00:25:34,726 --> 00:25:36,576
建立起一个连接

752
00:25:38,266 --> 00:25:40,006
我们也看到了

753
00:25:40,006 --> 00:25:41,866
数据卡壳情况

754
00:25:41,866 --> 00:25:43,126
大量缩减

755
00:25:43,446 --> 00:25:45,436
如果你的 app 使用

756
00:25:45,436 --> 00:25:47,566
URLSession API 你就可以免费

757
00:25:47,566 --> 00:25:48,786
获得 Wi-Fi Assist

758
00:25:49,476 --> 00:25:51,196
它会自动生效

759
00:25:51,196 --> 00:25:53,436
你不需要在你的 API 中

760
00:25:53,436 --> 00:25:54,036
做任何更改

761
00:25:54,036 --> 00:25:56,186
你也不用在服务器中

762
00:25:56,256 --> 00:25:58,236
做任何更改  它会自动工作

763
00:26:01,046 --> 00:26:03,236
现在 Wi-Fi Assist

764
00:26:03,236 --> 00:26:04,866
的问题是它是在一个数据流创建时

765
00:26:04,866 --> 00:26:05,836
进行这些工作的

766
00:26:06,646 --> 00:26:08,576
正如我之前所说的  一旦

767
00:26:08,576 --> 00:26:10,786
一个数据流被创建了

768
00:26:10,786 --> 00:26:12,126
它就会一直呆在这个接口上

769
00:26:12,486 --> 00:26:16,126
所以如果使用了

770
00:26:16,476 --> 00:26:17,806
而因为某些原因

771
00:26:17,806 --> 00:26:19,896
Wi-Fi 接口胜出

772
00:26:19,896 --> 00:26:21,156
这个已经创建的数据流

773
00:26:21,156 --> 00:26:23,336
将会一直呆在这个 Wi-Fi 接口上

774
00:26:24,496 --> 00:26:26,166
即使在那之后 Wi-Fi 

775
00:26:26,166 --> 00:26:28,576
开始变糟  这个数据流

776
00:26:28,576 --> 00:26:30,096
会变得越来越慢

777
00:26:30,096 --> 00:26:31,446
最终卡住

778
00:26:33,276 --> 00:26:36,686
所以  为了解决这个问题

779
00:26:36,746 --> 00:26:40,096
唯一的方法是创建一个

780
00:26:40,096 --> 00:26:42,126
新的客户端和服务器

781
00:26:42,126 --> 00:26:44,246
都遵守的协议

782
00:26:45,426 --> 00:26:47,346
这就是 Multipath TCP

783
00:26:49,596 --> 00:26:52,166
Multipath TCP 是一种

784
00:26:52,166 --> 00:26:53,366
专门为移动设备设计的

785
00:26:53,626 --> 00:26:56,446
协议

786
00:26:59,016 --> 00:27:01,186
Multipath TCP 由 IETF 提出

787
00:26:59,016 --> 00:27:01,186
Multipath TCP 由 IETF 提出

788
00:27:01,186 --> 00:27:04,926
作为一个标准

789
00:27:04,996 --> 00:27:07,136
它提供和 TCP 完全一样的服务

790
00:27:07,136 --> 00:27:08,916
这意味着它是一个

791
00:27:08,916 --> 00:27:11,266
可靠的字节流服务

792
00:27:11,896 --> 00:27:14,096
如果你正在使用 HTTP

793
00:27:14,096 --> 00:27:16,596
使用 TLS 或 HTTPS 你可以使用 Multipath

794
00:27:17,116 --> 00:27:19,846
TCP

795
00:27:20,706 --> 00:27:22,846
另外 它建立在 TCP 之上

796
00:27:22,846 --> 00:27:26,216
所以它吸收了我们

797
00:27:26,216 --> 00:27:27,646
年复一年开发 TCP

798
00:27:27,646 --> 00:27:29,086
的大量经验

799
00:27:30,626 --> 00:27:32,016
它也得益于

800
00:27:32,016 --> 00:27:33,656
它从 TCP 提供的

801
00:27:33,656 --> 00:27:35,576
拥塞控制中得到的

802
00:27:35,576 --> 00:27:36,146
可靠性

803
00:27:37,436 --> 00:27:39,596
在 TCP 之上

804
00:27:39,596 --> 00:27:41,246
它提供的是一种

805
00:27:41,246 --> 00:27:42,926
将流量从

806
00:27:42,926 --> 00:27:44,966
Wi-Fi 接口无缝对接到

807
00:27:44,966 --> 00:27:46,856
蜂窝数据接口的方式

808
00:27:46,856 --> 00:27:48,376
无论什么时候它发现 Wi-Fi 环境

809
00:27:48,376 --> 00:27:50,316
不够好  它同时允许

810
00:27:50,316 --> 00:27:52,326
把流量接回 Wi-Fi 接口

811
00:27:52,326 --> 00:27:53,976
这样你的 app 就不会

812
00:27:54,236 --> 00:27:55,816
消耗过多的移动数据

813
00:27:56,706 --> 00:27:59,466
如果你有一个对延迟敏感的

814
00:27:59,466 --> 00:28:01,246
交互式数据流  它还可以

815
00:27:59,466 --> 00:28:01,246
交互式数据流  它还可以

816
00:28:01,246 --> 00:28:02,906
帮你选择最佳接口

817
00:28:07,226 --> 00:28:09,246
那么让我们再

818
00:28:09,246 --> 00:28:10,896
进一步深入了解一下 Multipath TCP

819
00:28:10,896 --> 00:28:13,266
如果你在 URLSession API 上

820
00:28:13,266 --> 00:28:14,836
开发 app

821
00:28:14,836 --> 00:28:18,506
那么 Multipath TCP

822
00:28:18,966 --> 00:28:20,196
就正好在它下面

823
00:28:20,976 --> 00:28:23,346
所以对你来说  你并不需要

824
00:28:23,346 --> 00:28:24,806
担心那些

825
00:28:24,806 --> 00:28:25,866
不同的接口

826
00:28:27,566 --> 00:28:28,976
现在  当你

827
00:28:28,976 --> 00:28:31,466
发送数据时  你是在

828
00:28:31,466 --> 00:28:33,146
通过 URLSession

829
00:28:33,146 --> 00:28:35,786
API 来发送的  这部分数据

830
00:28:35,786 --> 00:28:37,776
将会通过在 MPTCP 堆栈上的 URLSession

831
00:28:37,776 --> 00:28:40,036
实现发送  而 MPTCP 堆栈

832
00:28:40,036 --> 00:28:41,486
负责将这些数据规划

833
00:28:41,536 --> 00:28:43,436
使它通过 Wi-Fi 或蜂窝数据发送

834
00:28:45,936 --> 00:28:47,846
那么它是如何实现

835
00:28:47,846 --> 00:28:50,096
在 Wi-Fi 和蜂窝数据之间的规划的呢

836
00:28:50,556 --> 00:28:52,136
它是通过创建

837
00:28:52,136 --> 00:28:54,316
所谓的 TCP 子数据流实现的

838
00:28:55,336 --> 00:28:57,746
这些 TCP 子流

839
00:28:57,746 --> 00:28:59,086
每个接口都有一个  它们实际上是

840
00:28:59,216 --> 00:29:00,936
完整的 TCP 连接

841
00:28:59,216 --> 00:29:00,936
完整的 TCP 连接

842
00:29:01,816 --> 00:29:03,926
而 MPTCP 就要负责

843
00:29:03,926 --> 00:29:05,666
确保数据是通过它们

844
00:29:05,666 --> 00:29:07,436
实现传输的

845
00:29:08,526 --> 00:29:10,486
它还负责创造

846
00:29:10,486 --> 00:29:11,926
和销毁这些 TCP 子流

847
00:29:12,836 --> 00:29:15,316
那么  从你在

848
00:29:15,316 --> 00:29:17,536
URLSession 之上的这一层面来说

849
00:29:17,586 --> 00:29:19,546
你可能根本都意识不到这些子流的存在

850
00:29:20,076 --> 00:29:22,426
MPTCP 决定什么时候创建

851
00:29:22,426 --> 00:29:24,286
这些子流  什么时候

852
00:29:24,286 --> 00:29:25,236
把它们销毁

853
00:29:26,256 --> 00:29:29,286
现在  其实 Multipath TCP 已经并不是

854
00:29:29,286 --> 00:29:30,166
那么新鲜的一件事了

855
00:29:30,946 --> 00:29:32,406
我们在 iOS 中其实

856
00:29:32,406 --> 00:29:34,436
已经使用了好几年了

857
00:29:34,536 --> 00:29:37,466
我们从 iOS 7 开始就把它用到了 Siri 上

858
00:29:39,576 --> 00:29:42,036
现在 Siri 是一个很特别的 app

859
00:29:43,756 --> 00:29:45,776
对很多人而言  当他们使用 Siri 时

860
00:29:45,776 --> 00:29:47,216
他们可能正在

861
00:29:47,216 --> 00:29:49,216
走出家门  举个例子

862
00:29:49,216 --> 00:29:50,416
当他们正往外走时

863
00:29:50,416 --> 00:29:52,426
他们叫 Siri

864
00:29:52,926 --> 00:29:54,326
帮他们给一个朋友发信息

865
00:29:54,326 --> 00:29:54,896
打个比方

866
00:29:55,726 --> 00:29:57,956
所以 Siri 经常遇到

867
00:29:57,956 --> 00:29:59,406
这种 Wi-Fi 变得

868
00:29:59,406 --> 00:30:00,736
越来越糟糕

869
00:29:59,406 --> 00:30:00,736
越来越糟糕

870
00:30:00,736 --> 00:30:02,586
最终连接断掉的情况

871
00:30:03,726 --> 00:30:04,526
现在问题在于  这种

872
00:30:04,526 --> 00:30:06,816
Siri 为了发送

873
00:30:06,816 --> 00:30:08,636
数据到服务器然后获取

874
00:30:08,636 --> 00:30:11,376
响应而建立的连接

875
00:30:11,376 --> 00:30:12,786
这种数据  是非常

876
00:30:12,786 --> 00:30:14,556
关键的  因为如果这个

877
00:30:14,556 --> 00:30:16,706
连接崩溃的话

878
00:30:16,706 --> 00:30:17,846
它将无法获得响应

879
00:30:19,046 --> 00:30:20,546
它同时对时间也

880
00:30:20,546 --> 00:30:22,406
极其敏感  因为用户往往

881
00:30:22,406 --> 00:30:24,046
真的是盯着

882
00:30:24,046 --> 00:30:25,306
手机屏幕等待它的回复

883
00:30:26,716 --> 00:30:28,996
同时它也是一个容量很低的连接

884
00:30:30,146 --> 00:30:31,486
并没有发送很多数据

885
00:30:32,396 --> 00:30:33,876
所以  即使我们有时候

886
00:30:33,876 --> 00:30:35,746
用蜂窝数据来发送一些数据

887
00:30:35,746 --> 00:30:37,736
也不会占用很多流量

888
00:30:37,736 --> 00:30:39,926
因为不会是很多数据  最多几个 KB

889
00:30:43,486 --> 00:30:45,566
现在  因为这些免费的

890
00:30:45,566 --> 00:30:47,246
性能  我们对 Siri

891
00:30:47,246 --> 00:30:49,266
使用 Multipath TCP

892
00:30:49,856 --> 00:30:52,166
的方式成了

893
00:30:52,166 --> 00:30:54,826
每当一个用户使用 Siri 时

894
00:30:54,826 --> 00:30:57,726
我们在 Wi-Fi 接口和蜂窝数据接口上 

895
00:30:57,726 --> 00:30:59,846
各创建一个 TCP 数据子流

896
00:31:00,916 --> 00:31:02,536
我们让这些子流随时都

897
00:31:02,536 --> 00:31:04,686
做好马上发送数据的准备 

898
00:31:04,686 --> 00:31:06,956
确保我们不会遭遇太多的响应延迟

899
00:31:08,506 --> 00:31:09,796
当我们安排数据流时

900
00:31:09,796 --> 00:31:11,706
我们会首选 Wi-Fi 连接

901
00:31:12,386 --> 00:31:13,566
但是如果我们发现

902
00:31:13,566 --> 00:31:15,606
Wi-Fi 连接上的延迟太高

903
00:31:15,606 --> 00:31:17,676
无法快速获得响应时

904
00:31:17,676 --> 00:31:21,476
我们就会毫不犹豫地

905
00:31:21,476 --> 00:31:23,106
在蜂窝数据连接上发送数据

906
00:31:25,456 --> 00:31:27,736
现在  关于

907
00:31:27,736 --> 00:31:30,116
Multipath TCP 的这些应用我们都取得了很大成功

908
00:31:32,526 --> 00:31:34,526
有一个特别的标准

909
00:31:34,526 --> 00:31:36,526
我们称之为第一个词时间

910
00:31:37,016 --> 00:31:38,646
意思是用户在屏幕上

911
00:31:38,646 --> 00:31:40,346
看到第一个词之前

912
00:31:40,346 --> 00:31:42,136
所需要到时间

913
00:31:42,136 --> 00:31:44,906
这个标准

914
00:31:44,906 --> 00:31:46,936
在最糟糕的情况下

915
00:31:47,026 --> 00:31:49,016
就是 Wi-Fi 已经极其差的情况

916
00:31:49,016 --> 00:31:51,616
我们把它称之为 第 95 个百分值

917
00:31:51,616 --> 00:31:55,276
它已经

918
00:31:55,276 --> 00:31:56,956
提高了 20%

919
00:31:57,296 --> 00:31:58,446
就减少延迟而言

920
00:31:58,446 --> 00:32:00,286
由于 Multipath TCP 的存在

921
00:31:58,446 --> 00:32:00,286
由于 Multipath TCP 的存在

922
00:32:00,286 --> 00:32:02,016
我们也得以大幅缩短延迟时间

923
00:32:04,796 --> 00:32:07,716
由于用户往往

924
00:32:07,836 --> 00:32:10,616
在走出 Wi-Fi 区域时

925
00:32:10,616 --> 00:32:13,356
使用 Siri 我们把

926
00:32:13,356 --> 00:32:14,896
网络失误

927
00:32:15,226 --> 00:32:16,766
已经比

928
00:32:16,816 --> 00:32:18,846
普通 TCP 情况下降低了五倍

929
00:32:21,096 --> 00:32:24,286
我们在 Siri 身上已经

930
00:32:24,346 --> 00:32:28,876
取得了成功  我们也收到了

931
00:32:28,876 --> 00:32:30,826
很多新开发者的请求

932
00:32:31,256 --> 00:32:32,976
希望我们可用公开

933
00:32:32,976 --> 00:32:34,696
Multipath TCP 的 API

934
00:32:35,846 --> 00:32:38,976
现在  在 iOS 11 中  我们走出了

935
00:32:38,976 --> 00:32:40,846
这一步  我们向你们公开了

936
00:32:40,846 --> 00:32:43,406
这个 API 方便你们开始使用

937
00:32:45,516 --> 00:32:49,500
[ 掌声 ]

938
00:32:52,046 --> 00:32:54,136
要开始使用这个 API 之前

939
00:32:54,136 --> 00:32:56,926
我需要告诉你们三件事

940
00:32:56,926 --> 00:32:58,996
我会在接下来的

941
00:32:58,996 --> 00:33:00,556
一分钟后挨个谈到

942
00:32:58,996 --> 00:33:00,556
一分钟后挨个谈到

943
00:33:02,066 --> 00:33:04,216
首先  因为它是一个新的

944
00:33:04,216 --> 00:33:06,406
协议  我们将会需要服务器支持

945
00:33:08,046 --> 00:33:08,976
一旦你拥有了服务器支持

946
00:33:08,976 --> 00:33:10,896
你可以开始选择

947
00:33:11,076 --> 00:33:13,046
你的哪些连接

948
00:33:13,046 --> 00:33:14,536
可以从 MPTCP 中获益

949
00:33:15,756 --> 00:33:17,496
然后  当我们选好了

950
00:33:17,496 --> 00:33:19,366
这些连接以后  第三步

951
00:33:19,366 --> 00:33:21,826
你可以开始选择加入

952
00:33:21,826 --> 00:33:23,596
URLSession API

953
00:33:24,196 --> 00:33:26,586
我们从 Multipath TCP 的

954
00:33:26,586 --> 00:33:28,686
服务器支持开始吧

955
00:33:29,686 --> 00:33:33,696
目前  它是一个比较新的协议

956
00:33:34,546 --> 00:33:36,856
所以在默认情况下

957
00:33:36,856 --> 00:33:38,796
大部分的服务器设施是

958
00:33:38,796 --> 00:33:40,466
不支持 Multipath TCP 的

959
00:33:41,136 --> 00:33:43,486
也就是说  你需要

960
00:33:43,746 --> 00:33:45,416
更新或修改你的

961
00:33:45,416 --> 00:33:47,796
服务器设施  让它开始

962
00:33:47,796 --> 00:33:49,256
支持 Multipath TCP

963
00:33:50,016 --> 00:33:51,666
然而  我们带来了好消息

964
00:33:51,746 --> 00:33:54,356
如果你在某些知名的

965
00:33:54,356 --> 00:33:55,696
供应商那里购买了负载均衡器

966
00:33:55,696 --> 00:33:58,346
很可能

967
00:33:58,346 --> 00:34:00,036
这个供应商已经

968
00:33:58,346 --> 00:34:00,036
这个供应商已经

969
00:34:00,036 --> 00:34:01,946
支持了Multipath TCP

970
00:34:02,986 --> 00:34:06,006
所以请询问你的服务器团队

971
00:34:06,006 --> 00:34:07,606
请他们查看他们使用的

972
00:34:07,606 --> 00:34:08,616
负载均衡器手册

973
00:34:09,335 --> 00:34:11,186
你也可以询问你的供应商

974
00:34:11,186 --> 00:34:13,775
他们是否支持 Multipath TCP

975
00:34:13,775 --> 00:34:17,056
如果他们支持的话

976
00:34:17,056 --> 00:34:18,126
你所要做的就只是

977
00:34:18,126 --> 00:34:19,746
在你的服务器配置中启用它

978
00:34:20,106 --> 00:34:21,696
从那一刻起

979
00:34:21,696 --> 00:34:23,525
你就可以开始使用

980
00:34:23,525 --> 00:34:25,106
Multipath TCP 了

981
00:34:26,196 --> 00:34:28,815
然而  如果你的服务器 

982
00:34:29,045 --> 00:34:30,666
使用的是 Linux

983
00:34:31,616 --> 00:34:33,036
主流的 Linux 内核

984
00:34:33,036 --> 00:34:34,686
目前尚未支持 Multipath

985
00:34:34,686 --> 00:34:37,196
TCP 但是在这个网站上

986
00:34:37,196 --> 00:34:38,976
有一种新的 Linux 内核

987
00:34:38,976 --> 00:34:41,085
你可以下载安装

988
00:34:41,085 --> 00:34:43,806
它可以

989
00:34:43,806 --> 00:34:45,666
为你的服务器提供 Multipath TCP 

990
00:34:48,036 --> 00:34:50,196
在这个网站上

991
00:34:50,196 --> 00:34:52,126
你可以找到 AWS 和 Google

992
00:34:52,126 --> 00:34:54,886
Compute Engine 安装

993
00:34:54,886 --> 00:34:57,126
Multipath TCP 的说明

994
00:34:57,346 --> 00:34:59,626
我们也跟

995
00:34:59,626 --> 00:35:01,366
这个新的 Linux 内核的开源社区

996
00:34:59,626 --> 00:35:01,366
这个新的 Linux 内核的开源社区

997
00:35:01,656 --> 00:35:04,146
一起合作来进行维护

998
00:35:05,066 --> 00:35:08,066
另外  我们跟开源社区一起

999
00:35:08,066 --> 00:35:10,116
合作  使这个

1000
00:35:10,116 --> 00:35:12,436
Multipath TCP 的代码

1001
00:35:12,436 --> 00:35:14,026
可以用于主流内核

1002
00:35:14,026 --> 00:35:15,536
使所有

1003
00:35:15,536 --> 00:35:17,136
版本  所有的 Linux

1004
00:35:17,136 --> 00:35:18,956
版本都可以默认获取

1005
00:35:21,436 --> 00:35:22,606
现在如果你有你的

1006
00:35:22,606 --> 00:35:23,676
服务器设施  并且有一些

1007
00:35:23,676 --> 00:35:25,516
在负载均衡器背后的

1008
00:35:25,516 --> 00:35:26,566
后端服务器

1009
00:35:26,566 --> 00:35:28,406
我是说 Linux 的负载均衡器

1010
00:35:29,036 --> 00:35:31,176
要想在你的服务器环境中

1011
00:35:31,176 --> 00:35:32,956
获取 Multipath TCP

1012
00:35:32,956 --> 00:35:34,786
你所要做的

1013
00:35:34,786 --> 00:35:37,436
就只是在这个负载均衡器上

1014
00:35:38,216 --> 00:35:39,856
更新你的 Linux 内核

1015
00:35:39,856 --> 00:35:42,646
你可以在上面放一个 HTTP 代理服务器

1016
00:35:42,646 --> 00:35:44,876
比如 HAProxy 或者

1017
00:35:44,876 --> 00:35:47,336
nginx  然后从那一刻起

1018
00:35:47,576 --> 00:35:48,996
一切就绪

1019
00:35:48,996 --> 00:35:50,546
你就可以开始使用 Multipath TCP了

1020
00:35:52,036 --> 00:35:54,916
所以  在这周结束后

1021
00:35:54,916 --> 00:35:56,406
当你们回到公司

1022
00:35:56,946 --> 00:35:58,516
去跟你们的服务器团队聊聊

1023
00:35:58,716 --> 00:35:59,936
告诉他们把

1024
00:35:59,936 --> 00:36:01,776
服务器为

1025
00:35:59,936 --> 00:36:01,776
服务器为

1026
00:36:01,776 --> 00:36:04,536
Multipath TCP 做好准备 

1027
00:36:05,296 --> 00:36:07,566
当你的服务器

1028
00:36:07,566 --> 00:36:11,136
准备好以后

1029
00:36:11,136 --> 00:36:12,196
然后你就可以开始

1030
00:36:12,196 --> 00:36:13,646
查看你的 app 中的

1031
00:36:13,646 --> 00:36:16,036
连接  以及它们中的哪些

1032
00:36:16,036 --> 00:36:17,766
可以从 Multipath TCP 受益最多

1033
00:36:19,926 --> 00:36:22,136
我们公开的 Multipath

1034
00:36:22,136 --> 00:36:24,856
TCP 服务

1035
00:36:24,856 --> 00:36:26,736
使用 MPTCP

1036
00:36:26,736 --> 00:36:28,646
提供两种不同模式的服务

1037
00:36:29,276 --> 00:36:31,436
第一个是一个交接模式

1038
00:36:31,436 --> 00:36:33,246
为你的长时间连接

1039
00:36:33,246 --> 00:36:35,486
提供高度的可靠性

1040
00:36:37,676 --> 00:36:39,886
第二个是一个交互模式

1041
00:36:39,936 --> 00:36:41,886
就是我们在 Siri 上使用的那个模式

1042
00:36:43,386 --> 00:36:44,786
这个模式为你的

1043
00:36:44,786 --> 00:36:46,426
交互性的和对延迟敏感的连接

1044
00:36:46,546 --> 00:36:48,146
保证了较低的响应延迟

1045
00:36:50,936 --> 00:36:53,786
我们从交接模式开始

1046
00:36:55,016 --> 00:36:57,216
交接模式可以

1047
00:36:57,216 --> 00:36:59,786
把数据流从 Wi-Fi 移动到数据网络

1048
00:37:00,076 --> 00:37:02,676
以及从数据网络移回 Wi-Fi

1049
00:37:03,756 --> 00:37:06,946
当你处于一个

1050
00:37:06,946 --> 00:37:08,866
Wi-Fi 覆盖很好的网络环境中时

1051
00:37:08,866 --> 00:37:10,436
你可以选择进入

1052
00:37:10,436 --> 00:37:12,496
交接模式

1053
00:37:12,496 --> 00:37:13,886
然后你会仅在 Wi-Fi 网络中

1054
00:37:14,056 --> 00:37:16,006
创建一个连接

1055
00:37:16,006 --> 00:37:17,956
我们将只使用 Wi-Fi 网络

1056
00:37:17,956 --> 00:37:20,026
不用使用任何蜂窝数据

1057
00:37:21,706 --> 00:37:23,626
不过  如果用户正在

1058
00:37:23,626 --> 00:37:25,136
走出 Wi-Fi 区域

1059
00:37:25,396 --> 00:37:26,866
并且 Wi-Fi 信号正在变弱

1060
00:37:26,866 --> 00:37:29,806
当我们发现这个情况时

1061
00:37:29,806 --> 00:37:32,146
我们就会打开

1062
00:37:32,546 --> 00:37:35,796
蜂窝数据网络

1063
00:37:35,796 --> 00:37:37,726
在蜂窝数据接口

1064
00:37:37,796 --> 00:37:39,966
创建一个 TCP 子流

1065
00:37:39,966 --> 00:37:42,116
从那时起你的 app

1066
00:37:42,116 --> 00:37:43,636
将开始使用蜂窝数据

1067
00:37:45,186 --> 00:37:47,046
如果现在用户正在

1068
00:37:47,046 --> 00:37:49,406
回到 Wi-Fi 信号好的区域

1069
00:37:49,486 --> 00:37:51,246
我们会再次关掉数据网络

1070
00:37:51,246 --> 00:37:53,366
将所有的数据流

1071
00:37:53,836 --> 00:37:55,146
都移回到 Wi-Fi 网络

1072
00:37:56,166 --> 00:37:57,986
这允许我们

1073
00:37:58,366 --> 00:38:00,356
不惜一切代价的最小化蜂窝数据用量

1074
00:37:58,366 --> 00:38:00,356
不惜一切代价的最小化蜂窝数据用量

1075
00:38:03,026 --> 00:38:04,996
我们鼓励你把它用在

1076
00:38:04,996 --> 00:38:07,056
你的常用的长时间的连接上

1077
00:38:08,496 --> 00:38:10,226
这些连接是你无法

1078
00:38:10,396 --> 00:38:12,506
轻易重启的  或者无法从最开始

1079
00:38:12,506 --> 00:38:13,586
重启的

1080
00:38:14,666 --> 00:38:15,936
这种连接会从

1081
00:38:15,936 --> 00:38:17,266
交接模式中获益最多

1082
00:38:19,026 --> 00:38:22,036
正如我所提到的  Multipath

1083
00:38:22,036 --> 00:38:24,616
TCP 现在是 Wi-Fi

1084
00:38:24,616 --> 00:38:27,206
Assist 的一部分，而在 Wi-Fi Assist 中

1085
00:38:27,206 --> 00:38:30,116
我们设置了一些限制条件来

1086
00:38:30,146 --> 00:38:31,586
限制我们用数据网络发送的

1087
00:38:31,586 --> 00:38:32,886
数据量

1088
00:38:34,116 --> 00:38:38,606
所以我们鼓励你们

1089
00:38:38,606 --> 00:38:40,826
只在低容量的连接中

1090
00:38:40,826 --> 00:38:41,826
使用交接模式

1091
00:38:43,086 --> 00:38:44,506
因为如果你达到了 Wi-Fi

1092
00:38:44,506 --> 00:38:46,156
Assist 的上限  我们会停止使用

1093
00:38:46,156 --> 00:38:47,686
数据网络连接  因为我们

1094
00:38:47,686 --> 00:38:49,506
不希望你的 app

1095
00:38:49,506 --> 00:38:50,836
看起来是

1096
00:38:50,836 --> 00:38:52,086
消耗过多数据网络的那种

1097
00:38:52,086 --> 00:38:55,386
所以请记住当你

1098
00:38:55,386 --> 00:38:57,126
在为你的连接选择

1099
00:38:57,126 --> 00:38:57,886
交接模式时

1100
00:38:58,486 --> 00:39:00,106
不要用于大型的数据传输

1101
00:38:58,486 --> 00:39:00,106
不要用于大型的数据传输

1102
00:39:00,106 --> 00:39:01,526
不要几 GB 几 GB 的

1103
00:39:01,526 --> 00:39:03,746
下载数据

1104
00:39:05,226 --> 00:39:07,936
从周一开始

1105
00:39:07,936 --> 00:39:09,856
你在拿到的第一个测试版中

1106
00:39:09,856 --> 00:39:11,446
就可以使用交接模式服务

1107
00:39:14,016 --> 00:39:15,246
那么让我们继续

1108
00:39:15,246 --> 00:39:17,776
谈谈交互模式

1109
00:39:17,776 --> 00:39:19,526
这个模式可以为你的

1110
00:39:19,526 --> 00:39:21,226
对延迟敏感的和抗活跃的连接

1111
00:39:21,226 --> 00:39:22,366
减少数据延迟

1112
00:39:24,816 --> 00:39:26,296
当你开始使用

1113
00:39:26,296 --> 00:39:27,536
交互模式时

1114
00:39:27,536 --> 00:39:29,546
我们马上会同时使用 Wi-Fi 网络和数据网络

1115
00:39:29,546 --> 00:39:31,666
即使 Wi-Fi 的信号很好

1116
00:39:31,666 --> 00:39:33,736
因为我们希望

1117
00:39:33,736 --> 00:39:35,096
可以立刻安排好数据流

1118
00:39:35,096 --> 00:39:38,246
以减少数据的延迟

1119
00:39:39,436 --> 00:39:41,296
我们会首选 Wi-Fi 接口

1120
00:39:41,296 --> 00:39:43,156
但是一旦我们发现

1121
00:39:43,156 --> 00:39:44,546
Wi-Fi 信号不够好

1122
00:39:44,546 --> 00:39:47,276
我们会毫不犹豫地

1123
00:39:47,276 --> 00:39:48,566
使用数据网络来发送数据

1124
00:39:50,496 --> 00:39:54,026
所以，在你的

1125
00:39:54,026 --> 00:39:56,006
交互性极强和对延迟非常敏感的

1126
00:39:56,006 --> 00:39:58,116
数据流上使用它  这种数据流

1127
00:39:58,116 --> 00:39:59,386
并不会传输大量的数据

1128
00:39:59,386 --> 00:40:01,386
因为我们设置了

1129
00:39:59,386 --> 00:40:01,386
因为我们设置了

1130
00:40:01,386 --> 00:40:03,286
Wi-Fi Assist 上限

1131
00:40:03,286 --> 00:40:05,386
所以如果你的数据流

1132
00:40:05,386 --> 00:40:06,926
达到了这个上限

1133
00:40:06,926 --> 00:40:09,106
我们会停止使用数据网络

1134
00:40:10,216 --> 00:40:12,396
Multipath TCP 会尽最大努力

1135
00:40:12,396 --> 00:40:14,226
来减少这些

1136
00:40:14,226 --> 00:40:15,336
连接的数据延迟

1137
00:40:15,816 --> 00:40:17,946
它会消耗一定的蜂窝数据

1138
00:40:17,946 --> 00:40:20,106
你们会在接下来的一个

1139
00:40:20,106 --> 00:40:22,076
测试版中看到

1140
00:40:22,076 --> 00:40:24,656
并可以开始使用

1141
00:40:27,246 --> 00:40:29,706
现在我们有了服务器

1142
00:40:29,706 --> 00:40:32,596
也选好了

1143
00:40:32,596 --> 00:40:33,916
哪些连接可以从

1144
00:40:33,916 --> 00:40:35,596
交接模式获益  哪些

1145
00:40:35,596 --> 00:40:37,166
连接可以从

1146
00:40:37,166 --> 00:40:38,146
交互模式获益

1147
00:40:39,676 --> 00:40:41,346
你现在可以开始使用

1148
00:40:41,346 --> 00:40:42,746
URLSession 配置属性

1149
00:40:42,746 --> 00:40:44,806
来把 API 用到你的

1150
00:40:44,806 --> 00:40:45,926
连接上

1151
00:40:47,456 --> 00:40:49,306
我们用一个很简单的方法展示它

1152
00:40:50,256 --> 00:40:52,136
你要做的就是

1153
00:40:52,136 --> 00:40:54,066
在你的 URLSession 的配置属性中

1154
00:40:54,066 --> 00:40:56,306
设置你想要的 Multipath 服务种类 

1155
00:40:58,116 --> 00:40:59,046
你可以在

1156
00:40:59,046 --> 00:41:01,106
交接模式和交互模式

1157
00:40:59,046 --> 00:41:01,106
交接模式和交互模式

1158
00:41:01,156 --> 00:41:03,136
之间选择  然后你就可以

1159
00:41:03,336 --> 00:41:04,206
开始使用了

1160
00:41:04,386 --> 00:41:06,886
你的连接会尝试使用

1161
00:41:06,886 --> 00:41:08,636
Multipath TCP 并且

1162
00:41:09,086 --> 00:41:10,976
从中获益

1163
00:41:12,226 --> 00:41:14,066
为了使用它

1164
00:41:14,066 --> 00:41:15,766
你需要在

1165
00:41:15,766 --> 00:41:20,106
Xcode 中添加 Multipath 

1166
00:41:20,106 --> 00:41:21,436
然后才能开始使用

1167
00:41:22,036 --> 00:41:26,736
这就是

1168
00:41:26,736 --> 00:41:28,316
我今天需要讲的最后一件事

1169
00:41:28,996 --> 00:41:30,136
即聚合模式

1170
00:41:32,746 --> 00:41:35,006
现在  想像一下  你已经联入

1171
00:41:35,006 --> 00:41:36,906
Wi-Fi  并且它每秒钟

1172
00:41:36,906 --> 00:41:38,856
向你提供 1MB 的通过量

1173
00:41:40,486 --> 00:41:41,366
另一方面

1174
00:41:41,466 --> 00:41:43,236
你还有蜂窝数据

1175
00:41:43,236 --> 00:41:44,706
它也每秒钟提供 1MB 的通过量

1176
00:41:46,176 --> 00:41:47,106
如果你可以把

1177
00:41:47,106 --> 00:41:48,996
它们结合到一起

1178
00:41:48,996 --> 00:41:50,636
变成一个更大的网络  每秒提供

1179
00:41:50,636 --> 00:41:51,706
2MB 的通过量  不是很好吗

1180
00:41:52,986 --> 00:41:54,856
Multipath TCP 正是为你

1181
00:41:54,856 --> 00:41:55,736
提供了这个服务

1182
00:41:56,536 --> 00:41:58,006
它允许将

1183
00:41:58,006 --> 00:41:59,666
多个网络的不同容量

1184
00:41:59,886 --> 00:42:01,866
结合成一个更大的连接

1185
00:41:59,886 --> 00:42:01,866
结合成一个更大的连接

1186
00:42:04,656 --> 00:42:08,536
我们把这个聚合模式

1187
00:42:08,536 --> 00:42:10,166
提供给你们用于实验

1188
00:42:10,166 --> 00:42:11,146
.

1189
00:42:11,846 --> 00:42:13,356
为什么说是实验呢

1190
00:42:14,036 --> 00:42:15,926
如果我们把

1191
00:42:15,926 --> 00:42:17,496
两种网络的容量结合起来

1192
00:42:17,496 --> 00:42:19,646
我们会消耗一些

1193
00:42:19,646 --> 00:42:21,286
蜂窝数据

1194
00:42:21,916 --> 00:42:25,126
我们希望你们能够想一想

1195
00:42:25,726 --> 00:42:27,486
在你的 app 中

1196
00:42:27,486 --> 00:42:29,416
有哪些连接是可以

1197
00:42:29,416 --> 00:42:31,056
通过一个稍高的

1198
00:42:31,126 --> 00:42:34,176
但是以蜂窝数据用量为代价的通过量

1199
00:42:34,176 --> 00:42:35,646
而受益呢

1200
00:42:37,616 --> 00:42:38,636
如果你想要使用

1201
00:42:38,636 --> 00:42:40,376
聚合模式  你只需要

1202
00:42:40,376 --> 00:42:42,366
进入你手机上的

1203
00:42:42,366 --> 00:42:43,786
开发者设置

1204
00:42:43,786 --> 00:42:46,446
滑动滑块来启用

1205
00:42:46,446 --> 00:42:48,366
聚合模式  然后

1206
00:42:48,366 --> 00:42:50,036
从那时起

1207
00:42:50,036 --> 00:42:51,656
你就可以开始实验

1208
00:42:51,656 --> 00:42:53,356
aggregation URLSession

1209
00:42:53,356 --> 00:42:54,486
配置属性了

1210
00:42:56,586 --> 00:42:58,576
这个模式在

1211
00:42:58,576 --> 00:42:59,816
用户的设备上是不可用的

1212
00:43:01,876 --> 00:43:04,276
所以你可以

1213
00:43:04,276 --> 00:43:05,636
在接下来的一个测试版中

1214
00:43:05,636 --> 00:43:08,756
开始测试聚合模式

1215
00:43:08,866 --> 00:43:11,176
那么  让我们来总结一下

1216
00:43:13,386 --> 00:43:16,226
在 iOS 中  我们非常清楚

1217
00:43:16,226 --> 00:43:18,556
在移动设备上

1218
00:43:18,556 --> 00:43:20,336
使用不同接口的问题

1219
00:43:21,836 --> 00:43:24,076
我们从 iOS 9 开始开发了 Wi-Fi Assist

1220
00:43:24,076 --> 00:43:27,606
我们看到使用 Wi-Fi Assist 有很多好处

1221
00:43:30,056 --> 00:43:32,076
在 iOS 11 中  我们进一步对它进行了升级

1222
00:43:33,336 --> 00:43:34,936
我们在 Wi-Fi Assist 中添加了 Multipath

1223
00:43:34,936 --> 00:43:37,186
协议

1224
00:43:38,146 --> 00:43:39,916
而在 iOS 11 中  这个协议  即 Multipath TCP

1225
00:43:39,916 --> 00:43:42,476
是作为一个公开 API 开源

1226
00:43:43,506 --> 00:43:45,136
你可以在你的 app 中使用它的交接模式

1227
00:43:45,136 --> 00:43:47,186
或者是交互模式

1228
00:43:48,046 --> 00:43:51,196
来进一步提高你的

1229
00:43:51,196 --> 00:43:52,476
用户体验

1230
00:43:54,436 --> 00:43:58,176
说了这么多  你们接下来有一段

1231
00:43:58,276 --> 00:43:59,056
休息时间

1232
00:43:59,436 --> 00:44:01,296
这是网络架构部分的

1233
00:43:59,436 --> 00:44:01,296
这是网络架构部分的

1234
00:44:01,296 --> 00:44:02,276
上半场

1235
00:44:03,076 --> 00:44:04,536
休息结束后，会继续

1236
00:44:04,536 --> 00:44:06,396
下半场

1237
00:44:06,396 --> 00:44:08,616
在下半场会议中

1238
00:44:08,616 --> 00:44:11,096
将会谈到在 URLSession 层面的一些

1239
00:44:11,096 --> 00:44:13,276
好用的 API

1240
00:44:13,276 --> 00:44:14,946
以优化你的 app 的

1241
00:44:14,946 --> 00:44:15,606
网络结构

1242
00:44:16,466 --> 00:44:16,836
谢谢
