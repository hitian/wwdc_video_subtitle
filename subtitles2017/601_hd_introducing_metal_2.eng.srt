1
00:00:21,516 --> 00:00:27,956
[ Applause ]

2
00:00:28,456 --> 00:00:28,916
&gt;&gt; Welcome.

3
00:00:29,436 --> 00:00:30,996
We introduced the host of new

4
00:00:30,996 --> 00:00:32,576
technologies with Metal 2 to

5
00:00:32,856 --> 00:00:34,846
allow you to make better,

6
00:00:35,116 --> 00:00:36,896
faster, and more efficient

7
00:00:36,896 --> 00:00:37,706
applications.

8
00:00:38,206 --> 00:00:39,396
My name is Michal and together

9
00:00:39,396 --> 00:00:40,856
with my colleague Richard we'll

10
00:00:40,856 --> 00:00:42,756
explore three main themes today.

11
00:00:44,546 --> 00:00:46,546
With Metal 2 we are continuing

12
00:00:46,756 --> 00:00:48,656
our direction of moving the

13
00:00:48,656 --> 00:00:50,526
expensive things to happen less

14
00:00:50,526 --> 00:00:52,266
frequently and making sure that

15
00:00:52,266 --> 00:00:54,376
the frequent things are really,

16
00:00:54,376 --> 00:00:55,176
really cheap.

17
00:00:55,656 --> 00:00:57,356
Over the years we introduced

18
00:00:57,646 --> 00:01:00,226
precompiled shaders, render

19
00:00:57,646 --> 00:01:00,226
precompiled shaders, render

20
00:01:00,226 --> 00:01:02,286
state objects, Metal Heap last

21
00:01:02,286 --> 00:01:04,566
year all to make sure that you

22
00:01:04,566 --> 00:01:06,416
can move the costly operations

23
00:01:06,576 --> 00:01:08,796
outside of your main application

24
00:01:09,346 --> 00:01:09,446
loop.

25
00:01:10,096 --> 00:01:13,836
We gave you 10 times more draw

26
00:01:13,836 --> 00:01:15,886
calls by switching from open GL

27
00:01:16,206 --> 00:01:16,696
to Metal.

28
00:01:17,616 --> 00:01:18,996
And this year we are introducing

29
00:01:18,996 --> 00:01:21,496
our new binding API that gives

30
00:01:21,496 --> 00:01:22,866
you some more.

31
00:01:22,866 --> 00:01:24,426
And so we will talk about it a

32
00:01:24,426 --> 00:01:24,946
bit further.

33
00:01:26,446 --> 00:01:29,006
We are also putting GPU more in

34
00:01:29,006 --> 00:01:32,016
a driving seat with GPU driven

35
00:01:32,016 --> 00:01:32,856
pipelines.

36
00:01:33,426 --> 00:01:35,326
And you will be able to create

37
00:01:35,326 --> 00:01:37,966
new, novel algorithms, new

38
00:01:37,966 --> 00:01:40,316
rendering techniques, and whole

39
00:01:40,926 --> 00:01:43,276
unique experiences utilizing

40
00:01:43,276 --> 00:01:45,176
Metal 2 on modern GPUs.

41
00:01:45,546 --> 00:01:46,366
Well, speaking of the

42
00:01:46,366 --> 00:01:49,096
experiences, we have a lot of

43
00:01:49,096 --> 00:01:50,306
new features in Metal and we

44
00:01:50,306 --> 00:01:51,726
have three other sessions that I

45
00:01:51,726 --> 00:01:52,746
would love you to attend.

46
00:01:53,586 --> 00:01:56,786
VR is coming to Mac this year

47
00:01:56,786 --> 00:01:58,986
and with the new iMacs we are

48
00:01:58,986 --> 00:02:01,486
giving you really powerful GPUs.

49
00:01:58,986 --> 00:02:01,486
giving you really powerful GPUs.

50
00:02:01,976 --> 00:02:04,056
The external GPU is coming to

51
00:02:04,106 --> 00:02:05,646
MacBook Pro to give you the same

52
00:02:05,646 --> 00:02:06,006
power.

53
00:02:06,726 --> 00:02:09,166
And this all enables your users

54
00:02:09,515 --> 00:02:11,566
and your content creators to

55
00:02:11,566 --> 00:02:14,156
experience VR in ways not

56
00:02:14,156 --> 00:02:14,936
possible before.

57
00:02:15,576 --> 00:02:17,746
Tomorrow's session will show you

58
00:02:18,486 --> 00:02:22,136
how to use our display -- direct

59
00:02:22,136 --> 00:02:23,876
display technology -- to get

60
00:02:23,876 --> 00:02:25,996
your content to HMD quick and

61
00:02:25,996 --> 00:02:26,846
with low latency.

62
00:02:28,176 --> 00:02:29,906
You'll learn about the new Metal

63
00:02:29,906 --> 00:02:32,066
API editions for VR and our new

64
00:02:32,066 --> 00:02:33,066
Tools editions.

65
00:02:35,856 --> 00:02:38,266
Machine learning is quickly

66
00:02:38,266 --> 00:02:40,296
becoming a key feature of our

67
00:02:40,296 --> 00:02:42,076
devices in many, many

68
00:02:42,076 --> 00:02:42,976
applications.

69
00:02:42,976 --> 00:02:45,056
And with Metal 2 you can use

70
00:02:45,056 --> 00:02:47,786
Metal performance shaders to

71
00:02:47,876 --> 00:02:49,726
utilize the power of the GPU for

72
00:02:49,726 --> 00:02:53,446
machine learning on both test up

73
00:02:53,546 --> 00:02:54,536
and mobile devices.

74
00:02:55,376 --> 00:02:56,786
And you're probably staring at

75
00:02:56,916 --> 00:02:58,256
that picture behind me and

76
00:02:58,256 --> 00:02:59,486
thinking, "How's that done?"

77
00:02:59,776 --> 00:03:01,316
Well, we have a session for you

78
00:02:59,776 --> 00:03:01,316
Well, we have a session for you

79
00:03:01,316 --> 00:03:03,776
on Thursday where you will learn

80
00:03:03,776 --> 00:03:05,416
about this and about the machine

81
00:03:05,416 --> 00:03:07,256
learning primitives -- the image

82
00:03:07,256 --> 00:03:08,796
processing primitives -- we have

83
00:03:09,036 --> 00:03:10,966
in our Metal performance

84
00:03:10,966 --> 00:03:11,506
shaders.

85
00:03:13,036 --> 00:03:15,576
Lastly, our tools have seen the

86
00:03:15,576 --> 00:03:17,566
biggest advancement yet with

87
00:03:17,566 --> 00:03:18,146
Metal 2.

88
00:03:18,256 --> 00:03:19,856
You'll be able to debug your

89
00:03:19,856 --> 00:03:21,006
applications quicker.

90
00:03:21,556 --> 00:03:23,266
You can drill down to problems

91
00:03:23,686 --> 00:03:26,796
easier and we are exposing, for

92
00:03:26,796 --> 00:03:28,226
example GPU performance

93
00:03:28,226 --> 00:03:29,866
counters, to make sure that you

94
00:03:29,866 --> 00:03:33,566
can find your hotspots and your

95
00:03:33,566 --> 00:03:36,126
application fast pass quicker.

96
00:03:37,416 --> 00:03:39,786
So I hope I got you excited

97
00:03:40,056 --> 00:03:41,946
about the few days ahead and

98
00:03:41,946 --> 00:03:44,076
let's get back to the present

99
00:03:44,076 --> 00:03:45,336
with the content of today's

100
00:03:45,336 --> 00:03:45,866
session.

101
00:03:51,426 --> 00:03:53,576
So we'll start with argument

102
00:03:53,576 --> 00:03:55,946
buffers, probably our biggest

103
00:03:55,996 --> 00:03:57,686
core framework addition this

104
00:03:57,686 --> 00:03:57,916
year.

105
00:03:58,716 --> 00:04:00,756
argument buffers provide an

106
00:03:58,716 --> 00:04:00,756
argument buffers provide an

107
00:04:00,756 --> 00:04:03,426
efficient new way of configuring

108
00:04:03,426 --> 00:04:05,946
which buffers, textures, and

109
00:04:06,416 --> 00:04:07,986
samplers your application can

110
00:04:07,986 --> 00:04:11,356
use freeing up considerable

111
00:04:11,356 --> 00:04:13,246
amount of CPU resources and

112
00:04:13,246 --> 00:04:15,026
actually enabling completely new

113
00:04:15,026 --> 00:04:16,366
schedules for the GPU at the

114
00:04:16,366 --> 00:04:17,086
same time.

115
00:04:18,196 --> 00:04:20,726
Then we'll talk about Raster

116
00:04:20,726 --> 00:04:22,966
Order Groups, a new fragment

117
00:04:22,966 --> 00:04:24,516
shader synchronization primitive

118
00:04:25,006 --> 00:04:26,856
that allows you to precisely

119
00:04:26,856 --> 00:04:28,566
control the order in which

120
00:04:28,786 --> 00:04:30,426
fragment shaders access common

121
00:04:30,426 --> 00:04:33,026
memory, enabling you new use

122
00:04:33,026 --> 00:04:34,726
cases for example of

123
00:04:35,286 --> 00:04:37,186
programmable blending on MacOS

124
00:04:37,246 --> 00:04:41,466
or voxelization [phonetic] order

125
00:04:41,516 --> 00:04:42,626
independent transparency.

126
00:04:43,466 --> 00:04:44,866
And then we'll switch to the

127
00:04:44,866 --> 00:04:46,656
topic of display and we talk

128
00:04:46,656 --> 00:04:48,396
about the new ProMotion Displays

129
00:04:48,396 --> 00:04:50,496
on iPads and how to best drive

130
00:04:50,496 --> 00:04:51,526
them using Metal.

131
00:04:51,526 --> 00:04:54,396
And we'll also give you a recap

132
00:04:54,446 --> 00:04:57,376
of our best practices of getting

133
00:04:57,376 --> 00:04:58,876
your content from your render

134
00:04:58,876 --> 00:05:02,606
targets to the glass as quickly

135
00:04:58,876 --> 00:05:02,606
targets to the glass as quickly

136
00:05:02,606 --> 00:05:04,046
as possible and with the least

137
00:05:04,046 --> 00:05:04,996
amount of latency.

138
00:05:05,576 --> 00:05:07,686
And finally we'll finish with a

139
00:05:08,106 --> 00:05:10,036
survey of all the other Metal

140
00:05:10,036 --> 00:05:12,316
features that we added to align

141
00:05:12,566 --> 00:05:15,436
iOS and macOS platforms into one

142
00:05:15,786 --> 00:05:16,976
big, common Metal ecosystem.

143
00:05:22,336 --> 00:05:26,186
So the argument buffers.

144
00:05:26,536 --> 00:05:28,556
Let's look at what they are and

145
00:05:28,716 --> 00:05:29,266
how they work.

146
00:05:29,316 --> 00:05:30,806
And I will need an example for

147
00:05:30,806 --> 00:05:33,776
that so let's think of a simple

148
00:05:33,776 --> 00:05:36,166
material that those who actually

149
00:05:36,166 --> 00:05:39,456
wrote any sort of 3D render

150
00:05:39,456 --> 00:05:40,046
program would know.

151
00:05:40,466 --> 00:05:42,326
In your material you have a

152
00:05:42,326 --> 00:05:44,936
bunch of numerical constants, a

153
00:05:45,106 --> 00:05:46,236
bunch of textures -- probably

154
00:05:46,236 --> 00:05:47,416
more than two now a days --

155
00:05:47,466 --> 00:05:48,016
assembler.

156
00:05:48,686 --> 00:05:53,196
And this is what you need to

157
00:05:53,196 --> 00:05:54,726
send to the GPU to be able to

158
00:05:54,726 --> 00:05:56,056
render your primitive.

159
00:05:56,516 --> 00:05:58,566
Now the texture objects are

160
00:05:59,456 --> 00:06:01,026
interesting because they contain

161
00:05:59,456 --> 00:06:01,026
interesting because they contain

162
00:06:01,166 --> 00:06:03,506
both texture properties such as

163
00:06:03,506 --> 00:06:06,626
width, height, pixel format

164
00:06:06,626 --> 00:06:08,866
perhaps, and then a pointer to a

165
00:06:08,866 --> 00:06:10,176
blob of memory which contains

166
00:06:10,176 --> 00:06:11,196
all the pretty pixels.

167
00:06:11,196 --> 00:06:13,896
Well, unfortunately we are not

168
00:06:13,896 --> 00:06:14,766
really interested in those

169
00:06:14,766 --> 00:06:15,926
pixels in this presentation.

170
00:06:15,926 --> 00:06:18,636
So off it goes and we'll only be

171
00:06:18,636 --> 00:06:20,426
talking about boring texture

172
00:06:20,426 --> 00:06:20,916
states.

173
00:06:22,156 --> 00:06:24,456
So with traditional argument

174
00:06:24,456 --> 00:06:26,566
model we allow you to put all

175
00:06:26,566 --> 00:06:29,106
the constants into a Metal

176
00:06:29,106 --> 00:06:30,216
buffer and we created this

177
00:06:30,216 --> 00:06:32,126
indirection so that it's easy

178
00:06:32,126 --> 00:06:33,846
for you to use and also it gives

179
00:06:33,846 --> 00:06:36,136
GPU the unfiltered, direct

180
00:06:36,136 --> 00:06:37,926
access to all the data.

181
00:06:39,136 --> 00:06:41,166
However, when it comes to things

182
00:06:41,166 --> 00:06:43,386
like textures or samplers you

183
00:06:43,386 --> 00:06:44,446
still need to go through quite

184
00:06:44,446 --> 00:06:46,266
about of an API and in your

185
00:06:46,266 --> 00:06:47,686
rendering loop you'll set the

186
00:06:47,686 --> 00:06:50,066
buffer, set all the textures,

187
00:06:50,676 --> 00:06:52,146
samplers, and only after that

188
00:06:52,146 --> 00:06:53,396
you can finally draw.

189
00:06:53,446 --> 00:06:55,676
And even though Metal is really

190
00:06:55,676 --> 00:06:57,676
optimized this is quite a few

191
00:06:57,676 --> 00:06:59,336
API codes and if you multiply it

192
00:06:59,336 --> 00:07:00,286
with the number of objects you

193
00:06:59,336 --> 00:07:00,286
with the number of objects you

194
00:07:00,286 --> 00:07:02,766
need to render, every frame, and

195
00:07:02,766 --> 00:07:04,046
the fact that you need to do all

196
00:07:04,046 --> 00:07:06,156
this work every frame, it

197
00:07:06,156 --> 00:07:09,026
actually at some point limits

198
00:07:09,026 --> 00:07:10,136
the amount of objects that you

199
00:07:10,136 --> 00:07:13,826
can put on the screen.

200
00:07:13,826 --> 00:07:17,126
With argument buffers we decided

201
00:07:17,126 --> 00:07:19,076
that we would like to extend

202
00:07:19,486 --> 00:07:21,476
this very convenient indirection

203
00:07:21,786 --> 00:07:23,026
that we have for constants to

204
00:07:23,026 --> 00:07:23,626
everything.

205
00:07:23,626 --> 00:07:26,046
So you can actually put texture

206
00:07:26,046 --> 00:07:28,226
state, samplers, pointers to

207
00:07:28,226 --> 00:07:29,696
another buffer into an argument

208
00:07:29,696 --> 00:07:31,456
buffer and this really

209
00:07:31,456 --> 00:07:34,036
simplifies your rendering

210
00:07:34,036 --> 00:07:35,656
pipeline because -- well,

211
00:07:35,656 --> 00:07:37,956
suddenly the only thing you need

212
00:07:37,956 --> 00:07:40,386
to do is set the buffer and

213
00:07:41,426 --> 00:07:41,806
draw.

214
00:07:42,016 --> 00:07:43,316
And you probably figured out

215
00:07:43,316 --> 00:07:46,196
that with this few API calls you

216
00:07:46,196 --> 00:07:47,126
can put more objects on the

217
00:07:47,126 --> 00:07:49,996
screen, and as you'll see later,

218
00:07:50,236 --> 00:07:51,726
you can do actually even better

219
00:07:51,726 --> 00:07:54,006
with argument buffers.

220
00:07:54,656 --> 00:07:55,536
So we've done a bunch of

221
00:07:55,536 --> 00:07:58,746
benchmarks and run argument

222
00:07:58,746 --> 00:07:59,976
buffers on our devices.

223
00:08:04,426 --> 00:08:05,886
And this is for example what you

224
00:08:05,886 --> 00:08:07,616
get on iPhone 7.

225
00:08:08,196 --> 00:08:10,196
While with traditional model,

226
00:08:10,526 --> 00:08:13,546
quite unsurprisingly, the cost

227
00:08:13,646 --> 00:08:16,366
of your draw call scales, with

228
00:08:16,366 --> 00:08:17,756
the amount of resources you use

229
00:08:18,246 --> 00:08:22,016
in a draw call, with argument

230
00:08:22,016 --> 00:08:25,096
buffers the cost stays pretty

231
00:08:25,096 --> 00:08:26,736
low and almost flat.

232
00:08:26,736 --> 00:08:29,976
So this already shows that for

233
00:08:29,976 --> 00:08:31,436
example with a very simple

234
00:08:31,436 --> 00:08:33,496
shader, with just two resources,

235
00:08:33,496 --> 00:08:35,956
with texture and a buffer, or

236
00:08:36,126 --> 00:08:37,785
two textures, you're getting

237
00:08:37,785 --> 00:08:39,535
seven times the performance

238
00:08:39,535 --> 00:08:40,135
improvement.

239
00:08:40,135 --> 00:08:42,186
With eight textures or eight

240
00:08:42,186 --> 00:08:45,146
resources, however you want to

241
00:08:45,146 --> 00:08:47,286
mix it up, you are getting 18

242
00:08:47,286 --> 00:08:48,996
times performance improvement on

243
00:08:48,996 --> 00:08:50,966
iPhone 7 and it goes even better

244
00:08:50,966 --> 00:08:52,696
with 16 resources, obviously.

245
00:08:55,106 --> 00:08:58,116
So I already talked about the

246
00:08:58,116 --> 00:08:58,896
performance.

247
00:08:58,986 --> 00:09:01,316
I hinted toward a new use -- new

248
00:08:58,986 --> 00:09:01,316
I hinted toward a new use -- new

249
00:09:01,316 --> 00:09:01,906
use schedules.

250
00:09:01,906 --> 00:09:04,486
And we'll talk about this in a

251
00:09:04,486 --> 00:09:04,866
minute.

252
00:09:05,066 --> 00:09:06,456
And the last point -- the last

253
00:09:06,456 --> 00:09:08,166
benefit of argument buffers I

254
00:09:08,166 --> 00:09:09,616
would like to bring up is the

255
00:09:09,616 --> 00:09:10,376
ease of use.

256
00:09:10,976 --> 00:09:13,856
And it comes from the fact that

257
00:09:13,856 --> 00:09:15,546
argument buffers are ultimately

258
00:09:15,716 --> 00:09:16,686
an extension of buffers.

259
00:09:16,686 --> 00:09:17,966
So you can, for example go ahead

260
00:09:17,966 --> 00:09:19,406
and prepare them ahead of the

261
00:09:19,406 --> 00:09:21,116
time, let's say when your game

262
00:09:21,116 --> 00:09:23,426
is loading, and then don't have

263
00:09:23,476 --> 00:09:25,216
to worry about it anymore during

264
00:09:25,216 --> 00:09:26,386
your rendering loop, further

265
00:09:26,556 --> 00:09:27,836
improving your performance.

266
00:09:28,786 --> 00:09:30,356
Or you can mix them with a

267
00:09:30,356 --> 00:09:31,606
traditional binding model, for

268
00:09:31,606 --> 00:09:33,866
example even within a single

269
00:09:34,066 --> 00:09:36,376
draw call, which means that your

270
00:09:36,376 --> 00:09:38,186
adoption can be as simple as

271
00:09:38,366 --> 00:09:39,746
using our new tools to figure

272
00:09:39,746 --> 00:09:40,986
out what is your most expensive

273
00:09:41,256 --> 00:09:43,626
loop in our application and

274
00:09:43,626 --> 00:09:44,946
optimizing that and then maybe

275
00:09:44,946 --> 00:09:46,526
return to the rest in a year

276
00:09:46,526 --> 00:09:49,626
when you have time.

277
00:09:49,746 --> 00:09:52,936
And lastly, the argument buffers

278
00:09:52,936 --> 00:09:55,246
are supported across all Metal

279
00:09:55,246 --> 00:09:55,786
devices.

280
00:09:55,786 --> 00:09:57,986
So once you take this adoption

281
00:09:57,986 --> 00:09:59,356
step and you get all the

282
00:09:59,356 --> 00:10:00,956
performance you can keep using

283
00:09:59,356 --> 00:10:00,956
performance you can keep using

284
00:10:00,956 --> 00:10:02,556
it on all Metal devices.

285
00:10:02,986 --> 00:10:04,076
The ease of use actually

286
00:10:04,076 --> 00:10:05,796
translates really well to the

287
00:10:05,796 --> 00:10:06,426
shaders.

288
00:10:06,426 --> 00:10:07,836
And since we will be looking at

289
00:10:07,836 --> 00:10:10,666
the shaders quite a bit during

290
00:10:10,666 --> 00:10:12,576
this section -- this is an

291
00:10:12,576 --> 00:10:14,806
example of the material I gave

292
00:10:14,806 --> 00:10:15,676
you in the beginning.

293
00:10:16,666 --> 00:10:19,266
And as you can see, the textures

294
00:10:19,266 --> 00:10:21,596
in the sampler are part of the

295
00:10:21,596 --> 00:10:23,366
structure, and that's the main

296
00:10:23,366 --> 00:10:24,746
thing to take away from this is

297
00:10:25,296 --> 00:10:28,616
that your argument buffer is

298
00:10:28,616 --> 00:10:29,976
just a structure in a shader and

299
00:10:29,976 --> 00:10:31,316
you can use all the language

300
00:10:31,686 --> 00:10:33,066
that you have at your disposal

301
00:10:33,066 --> 00:10:35,266
to make embedded structures, to

302
00:10:35,266 --> 00:10:38,856
organize your data, or use erase

303
00:10:38,856 --> 00:10:39,576
or pointers.

304
00:10:39,766 --> 00:10:40,976
It just really works.

305
00:10:42,216 --> 00:10:44,486
So let's now look at the three

306
00:10:44,766 --> 00:10:46,216
main new features of argument

307
00:10:46,216 --> 00:10:47,586
buffers, the first one being

308
00:10:47,676 --> 00:10:48,946
dynamic indexing.

309
00:10:50,276 --> 00:10:53,346
And great example of it is crowd

310
00:10:53,346 --> 00:10:53,826
rendering.

311
00:10:53,826 --> 00:10:56,056
If you played some of the recent

312
00:10:56,056 --> 00:10:57,436
Open World games you've seen

313
00:10:57,436 --> 00:11:00,686
that games try to render large

314
00:10:57,436 --> 00:11:00,686
that games try to render large

315
00:11:00,686 --> 00:11:02,506
crowds full of unique, varying

316
00:11:02,986 --> 00:11:05,036
characters in order to make

317
00:11:05,036 --> 00:11:07,546
these beautiful, immersive

318
00:11:07,606 --> 00:11:08,166
worlds.

319
00:11:08,696 --> 00:11:10,116
Well, actually that's quite a

320
00:11:10,116 --> 00:11:12,246
costly thing to do if you need

321
00:11:12,246 --> 00:11:13,706
to create so many draw calls.

322
00:11:15,076 --> 00:11:16,936
With argument buffers we already

323
00:11:16,936 --> 00:11:19,416
said that we could put all the

324
00:11:19,416 --> 00:11:20,876
properties required for let's

325
00:11:20,876 --> 00:11:22,096
say a character into a single

326
00:11:22,096 --> 00:11:24,006
argument buffer, bind it, and

327
00:11:24,006 --> 00:11:25,566
save all that performance on the

328
00:11:25,566 --> 00:11:27,686
CPU, but actually we can do

329
00:11:27,686 --> 00:11:27,966
better.

330
00:11:27,966 --> 00:11:30,246
We can for example create an

331
00:11:30,416 --> 00:11:32,236
array of argument buffers where

332
00:11:32,546 --> 00:11:35,266
each element represents single

333
00:11:35,266 --> 00:11:35,726
character.

334
00:11:36,306 --> 00:11:37,476
And then it suddenly becomes

335
00:11:37,476 --> 00:11:38,696
very, very simple because what

336
00:11:38,696 --> 00:11:40,856
you need to do is set this big

337
00:11:40,856 --> 00:11:44,016
buffer, this one API call, issue

338
00:11:44,126 --> 00:11:46,046
single instance draw call, let's

339
00:11:46,046 --> 00:11:47,646
say with 1,000 instances because

340
00:11:47,646 --> 00:11:49,126
I would like 1,000 characters on

341
00:11:49,126 --> 00:11:49,496
screen.

342
00:11:50,096 --> 00:11:51,186
That's second API call.

343
00:11:51,256 --> 00:11:53,626
And after that it's all on the

344
00:11:53,626 --> 00:11:54,176
GPU.

345
00:11:54,176 --> 00:11:55,576
In a vertex shader you use

346
00:11:55,576 --> 00:11:57,426
instance ID to pick the right

347
00:11:57,426 --> 00:12:00,926
element from the array, get the

348
00:11:57,426 --> 00:12:00,926
element from the array, get the

349
00:12:00,926 --> 00:12:02,266
character, put it somewhere

350
00:12:02,266 --> 00:12:03,036
where it needs to be in the

351
00:12:03,036 --> 00:12:04,496
world, give it the right pose,

352
00:12:04,496 --> 00:12:05,646
if it's for example mid-walk

353
00:12:05,646 --> 00:12:07,766
cycle, and then in the fragment

354
00:12:07,766 --> 00:12:10,176
shader again you use the

355
00:12:10,176 --> 00:12:12,146
instance ID and pick the right

356
00:12:12,146 --> 00:12:13,516
materials, the right hair color

357
00:12:13,516 --> 00:12:14,446
to finalize the look.

358
00:12:14,716 --> 00:12:17,056
So we are suddenly getting from

359
00:12:17,576 --> 00:12:19,916
tens, hundreds, maybe thousands

360
00:12:19,916 --> 00:12:22,316
of draw calls to a single one.

361
00:12:22,636 --> 00:12:24,156
And it's faster on the CPU.

362
00:12:24,246 --> 00:12:25,386
It's faster on the GPU.

363
00:12:26,036 --> 00:12:29,466
And this is how simple it looks

364
00:12:29,466 --> 00:12:30,036
in a shader.

365
00:12:31,166 --> 00:12:33,066
Pretty much your argument buffer

366
00:12:33,066 --> 00:12:35,516
becomes an array of structures.

367
00:12:36,966 --> 00:12:40,156
You pick the right element using

368
00:12:40,156 --> 00:12:41,506
instance ID referenced within

369
00:12:41,506 --> 00:12:42,856
and you can, for example take

370
00:12:42,856 --> 00:12:44,526
the pointer and pass it to your

371
00:12:44,526 --> 00:12:46,176
helper methods or whatever you

372
00:12:46,226 --> 00:12:49,176
need to do to process data.

373
00:12:49,256 --> 00:12:51,496
The second great feature of

374
00:12:51,536 --> 00:12:53,206
argument buffers is the ability

375
00:12:53,806 --> 00:12:56,436
of the GPU to set resources.

376
00:12:56,436 --> 00:12:57,656
And we actually created an

377
00:12:57,656 --> 00:12:58,546
example for this.

378
00:12:59,486 --> 00:13:01,586
We created a particle simulation

379
00:12:59,486 --> 00:13:01,586
We created a particle simulation

380
00:13:01,586 --> 00:13:03,876
running completely on the GPU.

381
00:13:04,466 --> 00:13:06,036
And I'll tell you how we done

382
00:13:06,036 --> 00:13:08,216
that and we'll see the -- we'll

383
00:13:08,216 --> 00:13:09,506
see it in action later.

384
00:13:10,256 --> 00:13:11,836
So we created an array of

385
00:13:12,086 --> 00:13:13,316
argument buffers where each

386
00:13:13,366 --> 00:13:16,296
element is single particle --

387
00:13:16,296 --> 00:13:17,756
and I guess you already spotted

388
00:13:17,756 --> 00:13:19,196
a trend here.

389
00:13:19,766 --> 00:13:23,716
Our simulation kernel then

390
00:13:24,596 --> 00:13:26,696
treats and simulates one

391
00:13:26,696 --> 00:13:28,796
particle per thread, but we want

392
00:13:28,796 --> 00:13:29,966
to actually go further and we

393
00:13:29,966 --> 00:13:32,906
want it to be able to create the

394
00:13:32,906 --> 00:13:36,416
particles in the kernel as well,

395
00:13:36,416 --> 00:13:37,006
on the GPU.

396
00:13:37,006 --> 00:13:39,106
So in order to do that, and to

397
00:13:39,106 --> 00:13:41,316
give it the right materials, we

398
00:13:41,316 --> 00:13:43,016
also have argument buffer with

399
00:13:43,076 --> 00:13:44,686
all the different materials that

400
00:13:44,686 --> 00:13:45,806
we would like our particles to

401
00:13:45,806 --> 00:13:46,176
have.

402
00:13:46,906 --> 00:13:48,896
And our simulation kernel then,

403
00:13:49,386 --> 00:13:50,866
every time you do an action in

404
00:13:51,186 --> 00:13:53,826
our little demo, the simulation

405
00:13:53,826 --> 00:13:54,776
kernel looks into the

406
00:13:54,776 --> 00:13:57,066
environment and sees what's the

407
00:13:57,806 --> 00:13:59,446
correct, most appropriate

408
00:13:59,446 --> 00:13:59,906
material.

409
00:14:00,056 --> 00:14:01,596
And let's say if you are in the

410
00:14:01,596 --> 00:14:04,126
forest, we pick moss as the

411
00:14:04,286 --> 00:14:05,786
right, appropriate material for

412
00:14:05,786 --> 00:14:08,696
a rock and copy it to the

413
00:14:09,126 --> 00:14:10,126
particle itself.

414
00:14:11,366 --> 00:14:13,226
If you're on the rocks we pick

415
00:14:13,226 --> 00:14:14,106
the rock material.

416
00:14:14,106 --> 00:14:15,946
On the hill we pick grass.

417
00:14:16,826 --> 00:14:18,506
So this way everything stays on

418
00:14:18,506 --> 00:14:22,796
the GPU and it actually looks in

419
00:14:22,796 --> 00:14:24,206
the shader just as simple as I

420
00:14:24,206 --> 00:14:24,946
describe it.

421
00:14:25,336 --> 00:14:26,756
If you want to modify data on

422
00:14:26,756 --> 00:14:30,156
your GPU you bind it as a device

423
00:14:30,156 --> 00:14:31,486
buffer and start assigning

424
00:14:31,486 --> 00:14:33,866
values as you are used to, but

425
00:14:33,866 --> 00:14:34,986
also this time around you can

426
00:14:34,986 --> 00:14:37,146
copy textures or copy the whole

427
00:14:37,146 --> 00:14:38,676
structure and it's really this

428
00:14:38,676 --> 00:14:38,966
simple.

429
00:14:40,106 --> 00:14:42,346
And the last great feature I

430
00:14:42,346 --> 00:14:44,576
would like to mention is ability

431
00:14:44,576 --> 00:14:47,116
of argument buffers to reference

432
00:14:47,116 --> 00:14:48,116
another argument buffer.

433
00:14:48,116 --> 00:14:50,106
So this way you can actually go

434
00:14:50,106 --> 00:14:52,936
ahead and create a reusable and

435
00:14:53,026 --> 00:14:55,816
complex object hierarchy just as

436
00:14:55,816 --> 00:14:59,076
you are used to from C++ Swift,

437
00:14:59,296 --> 00:15:00,046
Objective-C.

438
00:14:59,296 --> 00:15:00,046
Objective-C.

439
00:15:00,566 --> 00:15:03,676
Let's say in the example of our

440
00:15:04,376 --> 00:15:06,496
renderer, if you have a ton of

441
00:15:06,536 --> 00:15:09,076
objects, but you probably have

442
00:15:09,726 --> 00:15:11,046
very few materials, so what you

443
00:15:11,046 --> 00:15:14,556
can do is reference the material

444
00:15:14,556 --> 00:15:15,866
from each object and save some

445
00:15:15,866 --> 00:15:18,336
memory or you can build your

446
00:15:18,336 --> 00:15:19,716
scene graph as a binary tree

447
00:15:19,716 --> 00:15:21,566
where actually you point to the

448
00:15:21,566 --> 00:15:25,186
objects and the tree nodes as

449
00:15:25,186 --> 00:15:26,436
you need them, as you would be

450
00:15:26,436 --> 00:15:27,526
used to from the CPU.

451
00:15:27,906 --> 00:15:29,396
And you can share this data with

452
00:15:29,396 --> 00:15:30,086
the CPU as well.

453
00:15:31,536 --> 00:15:32,846
So these are the main features.

454
00:15:32,846 --> 00:15:34,526
And let's look at the support

455
00:15:34,526 --> 00:15:35,026
matrix.

456
00:15:35,596 --> 00:15:37,036
We have two tiers.

457
00:15:37,266 --> 00:15:39,796
The tier one is supported across

458
00:15:39,796 --> 00:15:42,466
all Metal devices and you get

459
00:15:42,466 --> 00:15:43,386
the CPU performance

460
00:15:43,386 --> 00:15:43,926
improvements.

461
00:15:43,926 --> 00:15:44,866
You get the new schedule

462
00:15:44,866 --> 00:15:45,276
language.

463
00:15:45,766 --> 00:15:49,096
But because of the limitations

464
00:15:49,096 --> 00:15:52,296
of the GPUs this tier does not

465
00:15:52,896 --> 00:15:54,526
-- is not able to utilize the

466
00:15:55,016 --> 00:15:56,486
GPU driven use cases that I

467
00:15:56,486 --> 00:15:57,346
mentioned earlier.

468
00:15:57,776 --> 00:15:58,916
With tier two however you are

469
00:15:58,916 --> 00:16:00,586
getting all of this -- so you

470
00:15:58,916 --> 00:16:00,586
getting all of this -- so you

471
00:16:00,586 --> 00:16:02,396
get all the new use cases -- and

472
00:16:02,396 --> 00:16:04,126
we are also really increasing

473
00:16:04,126 --> 00:16:05,736
the amount of resources you can

474
00:16:05,736 --> 00:16:06,176
access.

475
00:16:06,176 --> 00:16:07,416
Your shaders can access half a

476
00:16:07,466 --> 00:16:10,406
million textures and buffers to

477
00:16:10,406 --> 00:16:11,676
-- for you to do this -- do

478
00:16:11,676 --> 00:16:12,806
these new algorithms.

479
00:16:13,696 --> 00:16:15,696
While tier one is supported on

480
00:16:15,986 --> 00:16:18,526
all Metal devices, tier two is

481
00:16:18,526 --> 00:16:19,826
something you need to query for.

482
00:16:20,306 --> 00:16:22,216
But don't worry, the support is

483
00:16:22,216 --> 00:16:22,846
really wide.

484
00:16:23,556 --> 00:16:25,016
All the Macs with these three

485
00:16:25,016 --> 00:16:26,166
GPUs are tier two.

486
00:16:26,626 --> 00:16:28,436
All the new MacBook Pros, the

487
00:16:28,436 --> 00:16:29,676
latest MacBook, the last tier

488
00:16:29,676 --> 00:16:31,586
MacBooks Pros are tier two.

489
00:16:31,586 --> 00:16:33,316
So you can go ahead and have

490
00:16:33,416 --> 00:16:33,586
fun.

491
00:16:34,106 --> 00:16:35,546
Now let's look at the demo I

492
00:16:35,546 --> 00:16:36,136
promised you.

493
00:16:36,226 --> 00:16:39,116
We will be showing three videos

494
00:16:39,426 --> 00:16:41,416
with three different features.

495
00:16:41,986 --> 00:16:43,936
The real time rendered terrain,

496
00:16:44,136 --> 00:16:45,846
with material that changes

497
00:16:45,846 --> 00:16:48,346
dynamically, we place some

498
00:16:48,346 --> 00:16:50,616
vegetation by the GPU on the

499
00:16:50,616 --> 00:16:51,716
terrain to make it interesting,

500
00:16:52,116 --> 00:16:53,326
and we have all these nice

501
00:16:53,326 --> 00:16:56,076
particles that I mentioned

502
00:16:56,076 --> 00:16:56,436
before.

503
00:16:56,656 --> 00:16:59,516
So, as you see, we are painting

504
00:17:00,006 --> 00:17:01,246
high on the terrain.

505
00:17:01,246 --> 00:17:02,496
We can changing sculpting the

506
00:17:02,496 --> 00:17:03,466
terrain and the material

507
00:17:03,466 --> 00:17:04,326
actually follows.

508
00:17:04,626 --> 00:17:05,796
And this is a great thing about

509
00:17:05,796 --> 00:17:08,425
argument buffers because they

510
00:17:08,425 --> 00:17:10,965
allowed us to create a one big

511
00:17:11,665 --> 00:17:13,506
argument buffer with all the

512
00:17:13,506 --> 00:17:16,406
possible materials as layers in

513
00:17:16,406 --> 00:17:18,455
there and when we are rendering

514
00:17:18,455 --> 00:17:20,576
the terrain in a pixel shader we

515
00:17:20,576 --> 00:17:21,736
are looking at things like

516
00:17:22,076 --> 00:17:24,846
terrain height, slope, the

517
00:17:25,116 --> 00:17:27,406
amount of sun that reaches

518
00:17:27,606 --> 00:17:29,166
certain pixels, and based on

519
00:17:29,166 --> 00:17:30,976
these properties and some others

520
00:17:30,976 --> 00:17:33,866
we do decide what are the best

521
00:17:34,026 --> 00:17:35,446
and most appropriate materials

522
00:17:35,446 --> 00:17:36,466
for that given pixel.

523
00:17:36,896 --> 00:17:38,046
And this is all happening in

524
00:17:38,046 --> 00:17:40,746
real time, whereas previously we

525
00:17:40,746 --> 00:17:42,436
would have to go ahead and split

526
00:17:42,436 --> 00:17:44,316
the terrain in small pieces

527
00:17:44,766 --> 00:17:47,466
offline, analyze which pieces

528
00:17:47,466 --> 00:17:49,206
need which textures in order to

529
00:17:49,206 --> 00:17:50,676
make it as optimal as possible,

530
00:17:51,236 --> 00:17:53,166
and only then render it.

531
00:17:53,166 --> 00:17:55,386
So we are going from a

532
00:17:55,456 --> 00:17:56,546
pre-processing step, which is

533
00:17:56,546 --> 00:17:58,366
heavy and prevents real time

534
00:17:58,366 --> 00:18:00,496
modification, to something that

535
00:17:58,366 --> 00:18:00,496
modification, to something that

536
00:18:00,496 --> 00:18:02,226
is real time, without -- sorry

537
00:18:02,286 --> 00:18:04,716
-- without preprocessing and

538
00:18:04,716 --> 00:18:05,626
completely dynamic.

539
00:18:08,976 --> 00:18:11,986
And we added vegetation on it

540
00:18:12,296 --> 00:18:14,086
and as you see the vegetation is

541
00:18:14,086 --> 00:18:16,196
also context sensitive.

542
00:18:17,026 --> 00:18:18,766
You see the palm trees on the

543
00:18:18,766 --> 00:18:19,136
sand.

544
00:18:19,136 --> 00:18:20,826
You see the little tiny apple

545
00:18:20,826 --> 00:18:21,816
trees on the hills.

546
00:18:23,446 --> 00:18:25,536
And while the vegetation itself

547
00:18:25,536 --> 00:18:28,176
is fairly traditional instance

548
00:18:28,176 --> 00:18:29,776
rendering, the power of the

549
00:18:29,776 --> 00:18:32,396
argument buffers here is that it

550
00:18:32,396 --> 00:18:34,086
allows us to share the same

551
00:18:34,416 --> 00:18:36,006
terrain material with all the

552
00:18:36,006 --> 00:18:37,846
same properties and the same

553
00:18:37,846 --> 00:18:39,646
terrain analysis function

554
00:18:40,126 --> 00:18:41,486
between two completely separate

555
00:18:41,486 --> 00:18:43,446
pieces of code.

556
00:18:43,676 --> 00:18:45,246
While terrain rendering uses all

557
00:18:45,246 --> 00:18:47,326
this data to render pixels, the

558
00:18:47,326 --> 00:18:48,796
computer that places the

559
00:18:48,796 --> 00:18:50,316
geometry, the vegetation,

560
00:18:50,686 --> 00:18:51,956
actually analyzes the same

561
00:18:51,956 --> 00:18:53,786
materials to figure out what is

562
00:18:53,786 --> 00:18:56,266
the best type of tree to place

563
00:18:56,266 --> 00:18:57,026
in the given spot.

564
00:18:57,486 --> 00:18:58,616
And this is very easy because

565
00:18:58,616 --> 00:18:59,836
every time we make a change

566
00:19:00,166 --> 00:19:01,566
nothing actually changes in our

567
00:19:01,566 --> 00:19:02,686
code because we just add new

568
00:19:02,686 --> 00:19:04,516
layers or change our analysis

569
00:19:04,516 --> 00:19:06,806
function, whereas previously we

570
00:19:06,806 --> 00:19:08,526
would have to maybe juggle 70

571
00:19:08,526 --> 00:19:10,226
textures between two completely

572
00:19:10,226 --> 00:19:11,776
separate code basis in order to

573
00:19:11,816 --> 00:19:17,036
make them run in sync.

574
00:19:17,216 --> 00:19:19,406
Lastly, we have the particles.

575
00:19:19,406 --> 00:19:22,226
I hope you can see that they

576
00:19:22,226 --> 00:19:25,146
nicely get the material of the

577
00:19:25,146 --> 00:19:25,916
terrain there.

578
00:19:26,876 --> 00:19:28,606
Now what I did not mention is

579
00:19:28,606 --> 00:19:30,866
that this all is rendered with

580
00:19:31,126 --> 00:19:32,816
again a single draw call.

581
00:19:32,816 --> 00:19:34,756
We are rendering 16,000

582
00:19:35,086 --> 00:19:38,006
particles here with single draw

583
00:19:38,006 --> 00:19:39,776
call, with absolutely no

584
00:19:39,816 --> 00:19:41,586
involvement on the CPU.

585
00:19:42,406 --> 00:19:44,486
And not only do particles have

586
00:19:44,826 --> 00:19:46,316
unique materials, they actually

587
00:19:46,316 --> 00:19:47,486
have unique shapes because

588
00:19:47,766 --> 00:19:48,876
argument buffers allow --

589
00:19:48,936 --> 00:19:50,176
actually allow you to change

590
00:19:50,176 --> 00:19:52,166
your vertex buffer per draw

591
00:19:52,166 --> 00:19:52,466
call.

592
00:19:53,526 --> 00:19:56,076
This is something where if you

593
00:19:56,076 --> 00:19:58,466
try to do that without argument

594
00:19:58,466 --> 00:20:01,956
buffers, we had to create a

595
00:19:58,466 --> 00:20:01,956
buffers, we had to create a

596
00:20:01,956 --> 00:20:04,496
complicated control hand over

597
00:20:04,496 --> 00:20:06,856
between GPU that simulates and

598
00:20:06,856 --> 00:20:08,036
the CPU that tries to come up

599
00:20:08,036 --> 00:20:09,866
with the best set of draw calls

600
00:20:09,866 --> 00:20:11,356
to represent all this variety.

601
00:20:11,776 --> 00:20:13,396
So with argument buffers this

602
00:20:13,396 --> 00:20:17,116
became just very, very simple.

603
00:20:18,346 --> 00:20:21,706
Okay, so enough pretty pictures.

604
00:20:22,296 --> 00:20:25,226
And let's wrap my portion of the

605
00:20:25,226 --> 00:20:28,406
session with a look at some APIs

606
00:20:28,406 --> 00:20:29,716
and some best practices.

607
00:20:29,986 --> 00:20:33,426
As I mentioned before, argument

608
00:20:33,426 --> 00:20:34,926
buffers are an extension of

609
00:20:34,926 --> 00:20:37,426
Metal buffers and that means all

610
00:20:37,426 --> 00:20:39,286
of our API related to buffers

611
00:20:39,286 --> 00:20:39,776
just works.

612
00:20:39,776 --> 00:20:40,946
You can go ahead and take

613
00:20:40,946 --> 00:20:42,196
argument buffer, copy it

614
00:20:42,196 --> 00:20:43,456
somewhere else; you can blitz it

615
00:20:43,456 --> 00:20:44,976
between CPU and GPU.

616
00:20:45,826 --> 00:20:48,106
And while argument buffers look

617
00:20:48,106 --> 00:20:51,266
like structures on the GPU for

618
00:20:51,266 --> 00:20:54,796
shaders, on the CPU you will use

619
00:20:54,796 --> 00:20:56,816
MTLArgumentEncoder objects to

620
00:20:56,816 --> 00:20:57,716
fill up the content.

621
00:20:58,676 --> 00:21:02,196
This abstraction allows Metal to

622
00:20:58,676 --> 00:21:02,196
This abstraction allows Metal to

623
00:21:02,196 --> 00:21:04,696
create the most optimal memory

624
00:21:05,186 --> 00:21:06,686
representation for any given

625
00:21:06,686 --> 00:21:08,316
argument buffer on that specific

626
00:21:08,316 --> 00:21:09,376
GPU that you are actually

627
00:21:09,376 --> 00:21:09,716
running.

628
00:21:10,206 --> 00:21:11,506
So you get the best performance.

629
00:21:11,896 --> 00:21:13,266
It also frees you, as the

630
00:21:13,266 --> 00:21:14,686
developer, from all these

631
00:21:15,646 --> 00:21:19,956
details and worries about, for

632
00:21:19,956 --> 00:21:21,956
example how each GPU represents

633
00:21:22,096 --> 00:21:22,966
what the texture is.

634
00:21:22,966 --> 00:21:23,986
Where does it live in memory?

635
00:21:24,616 --> 00:21:26,746
All of this changes from

636
00:21:26,886 --> 00:21:28,776
platform to platform and we hide

637
00:21:28,776 --> 00:21:31,356
it between a simple interface so

638
00:21:31,356 --> 00:21:32,616
that you can write very simple

639
00:21:32,616 --> 00:21:33,826
and effective applications.

640
00:21:34,506 --> 00:21:37,106
So I hope you're not worried

641
00:21:37,106 --> 00:21:38,006
about the encoder that I

642
00:21:38,006 --> 00:21:38,376
mentioned.

643
00:21:38,376 --> 00:21:39,886
It's really, really simple to

644
00:21:39,886 --> 00:21:40,286
use.

645
00:21:41,346 --> 00:21:42,396
For example, if you want to

646
00:21:42,396 --> 00:21:43,856
create an argument encoder for

647
00:21:43,856 --> 00:21:46,386
this argument buffer all you

648
00:21:46,386 --> 00:21:49,886
need to do is get your Metal

649
00:21:49,886 --> 00:21:51,386
function that uses the argument

650
00:21:51,386 --> 00:21:53,736
buffer and ask the Metal

651
00:21:53,736 --> 00:21:55,386
function for the encoder and

652
00:21:55,386 --> 00:21:56,116
that's about this.

653
00:21:56,116 --> 00:21:57,386
This is all you needed to do.

654
00:21:57,386 --> 00:21:59,526
You get an object and you start

655
00:21:59,526 --> 00:22:02,066
using a familiar set texture or

656
00:21:59,526 --> 00:22:02,066
using a familiar set texture or

657
00:22:02,486 --> 00:22:04,586
filling constant API that is

658
00:22:04,586 --> 00:22:05,906
very, very similar to how you've

659
00:22:05,906 --> 00:22:08,666
been using Metal with command

660
00:22:08,666 --> 00:22:09,016
encoder.

661
00:22:09,016 --> 00:22:11,916
So this also plays into what I

662
00:22:11,916 --> 00:22:15,116
said about ease of use and

663
00:22:15,116 --> 00:22:15,846
transition.

664
00:22:16,866 --> 00:22:18,736
There are multiple other ways of

665
00:22:18,736 --> 00:22:20,546
creating the encoder.

666
00:22:20,546 --> 00:22:21,786
You can go more explicit with

667
00:22:21,786 --> 00:22:22,686
the descriptor, but that's

668
00:22:22,686 --> 00:22:24,706
something you should look into

669
00:22:24,876 --> 00:22:26,036
in documentation if you need

670
00:22:26,036 --> 00:22:27,326
such thing.

671
00:22:27,326 --> 00:22:28,956
We advise you to actually go and

672
00:22:29,566 --> 00:22:30,866
get argument encoders from the

673
00:22:30,866 --> 00:22:31,386
shaders.

674
00:22:33,846 --> 00:22:36,706
Now with all those interactions,

675
00:22:36,706 --> 00:22:38,396
GPU being able to step in and

676
00:22:38,396 --> 00:22:40,436
modify the argument buffers or

677
00:22:41,036 --> 00:22:42,286
you know dynamic indexing and

678
00:22:42,286 --> 00:22:44,356
half a million textures, all

679
00:22:44,356 --> 00:22:47,526
that in a mix, it's not really

680
00:22:47,906 --> 00:22:49,366
possible for Metal to figure out

681
00:22:49,366 --> 00:22:50,466
what -- for example what

682
00:22:50,466 --> 00:22:52,226
textures or buffers do actually

683
00:22:52,226 --> 00:22:55,396
intend to use in your rendering,

684
00:22:55,396 --> 00:22:57,006
but luckily you as a developer

685
00:22:57,006 --> 00:22:58,916
have pretty good idea about

686
00:22:58,916 --> 00:22:59,126
that.

687
00:22:59,126 --> 00:23:01,276
So we ask you with argument

688
00:22:59,126 --> 00:23:01,276
So we ask you with argument

689
00:23:01,276 --> 00:23:02,716
buffers to be quite explicit

690
00:23:02,716 --> 00:23:03,066
about it.

691
00:23:04,266 --> 00:23:05,776
If you are using Heaps, and

692
00:23:06,646 --> 00:23:08,336
absolutely you should use Heaps

693
00:23:08,336 --> 00:23:09,896
to get the best performance out

694
00:23:09,896 --> 00:23:12,506
of your platform and the best

695
00:23:12,506 --> 00:23:13,766
way of organizing your data, the

696
00:23:14,366 --> 00:23:15,586
only thing you need to do is

697
00:23:15,586 --> 00:23:16,936
tell Metal that you intend to

698
00:23:16,936 --> 00:23:18,886
use a Heap , or multiple Heaps,

699
00:23:18,886 --> 00:23:19,816
it's up to you.

700
00:23:19,816 --> 00:23:22,356
And -- this is -- this makes

701
00:23:22,356 --> 00:23:24,196
sure that the textures are

702
00:23:24,196 --> 00:23:25,546
available for you in the

703
00:23:25,546 --> 00:23:27,696
rendering loop.

704
00:23:27,696 --> 00:23:29,066
If you want to do something more

705
00:23:29,066 --> 00:23:30,076
specific, let's say you would

706
00:23:30,076 --> 00:23:32,586
like to write to a render target

707
00:23:32,586 --> 00:23:34,556
from inside a shader, or you

708
00:23:34,556 --> 00:23:35,626
would like to read from a dev

709
00:23:35,626 --> 00:23:38,466
buffer, you use a more specific

710
00:23:38,466 --> 00:23:40,466
API and tell Metal that you

711
00:23:40,466 --> 00:23:42,476
intend to change resource and --

712
00:23:43,476 --> 00:23:44,516
with a specific way.

713
00:23:44,516 --> 00:23:46,076
And again, it's as simple as

714
00:23:46,076 --> 00:23:46,166
this.

715
00:23:46,166 --> 00:23:46,836
You don't need to do anything

716
00:23:46,836 --> 00:23:46,976
else.

717
00:23:50,506 --> 00:23:52,196
So let's start out with a couple

718
00:23:52,196 --> 00:23:53,116
of best practices.

719
00:23:53,116 --> 00:23:55,986
I think if you know Metal they

720
00:23:55,986 --> 00:23:58,076
are very, very similar to what

721
00:23:58,076 --> 00:24:00,076
we are telling you about using

722
00:23:58,076 --> 00:24:00,076
we are telling you about using

723
00:24:00,076 --> 00:24:00,716
Metal buffers.

724
00:24:01,156 --> 00:24:02,586
The best way to organize your

725
00:24:02,586 --> 00:24:04,706
data is by usage pattern.

726
00:24:04,706 --> 00:24:05,856
And you probably have a ton of

727
00:24:05,856 --> 00:24:08,406
properties that do not change

728
00:24:08,686 --> 00:24:09,306
per frame.

729
00:24:09,396 --> 00:24:10,536
So put them into an argument

730
00:24:10,536 --> 00:24:11,956
buffer and share it with all the

731
00:24:11,956 --> 00:24:13,166
objects so you will save memory

732
00:24:13,166 --> 00:24:13,536
this way.

733
00:24:14,286 --> 00:24:16,076
The same -- on the same -- on

734
00:24:16,076 --> 00:24:17,756
the other hand you will probably

735
00:24:17,756 --> 00:24:19,566
have a lot of properties that

736
00:24:19,566 --> 00:24:21,106
actually do change for every

737
00:24:21,106 --> 00:24:23,496
object and you need to manage

738
00:24:23,496 --> 00:24:24,346
them every frame.

739
00:24:24,346 --> 00:24:26,946
And for these I think the best

740
00:24:26,946 --> 00:24:28,066
way is to put those into

741
00:24:28,066 --> 00:24:29,226
separate argument buffers so

742
00:24:29,226 --> 00:24:30,396
that you can double buffer it or

743
00:24:30,396 --> 00:24:32,056
whatever is your management

744
00:24:32,056 --> 00:24:34,786
scheme and you don't need to do

745
00:24:34,786 --> 00:24:36,576
all the other copies to keep all

746
00:24:36,576 --> 00:24:37,266
the data in there.

747
00:24:37,706 --> 00:24:39,186
And then you will likely have a

748
00:24:39,186 --> 00:24:41,326
ton of argument buffers that

749
00:24:41,786 --> 00:24:43,286
just don't change at all.

750
00:24:43,286 --> 00:24:44,456
Let's say the materials, or

751
00:24:45,026 --> 00:24:46,816
maybe some other properties, and

752
00:24:46,966 --> 00:24:49,296
for these just create them at

753
00:24:49,296 --> 00:24:50,296
the initialization of your

754
00:24:50,296 --> 00:24:53,826
application and keep using them.

755
00:24:54,026 --> 00:24:57,576
Similar to Metal buffers, think

756
00:24:57,576 --> 00:24:59,816
about your data locality and how

757
00:24:59,816 --> 00:25:01,566
you actually use your argument

758
00:24:59,816 --> 00:25:01,566
you actually use your argument

759
00:25:01,566 --> 00:25:01,916
buffers.

760
00:25:02,246 --> 00:25:03,816
If, for example you have three

761
00:25:03,816 --> 00:25:06,076
textures that are accessed in a

762
00:25:06,076 --> 00:25:08,776
shader, one after another, then

763
00:25:09,316 --> 00:25:10,836
the best thing you can do is

764
00:25:10,836 --> 00:25:12,046
actually put those textures

765
00:25:12,046 --> 00:25:13,216
close to each other in argument

766
00:25:13,216 --> 00:25:14,566
buffers so that you maximize the

767
00:25:14,566 --> 00:25:16,466
use of GPU caches.

768
00:25:17,376 --> 00:25:18,146
And as I mentioned at the

769
00:25:18,146 --> 00:25:20,736
beginning, traditional argument

770
00:25:20,736 --> 00:25:23,716
model is not going anywhere and

771
00:25:23,716 --> 00:25:25,576
you should take advantage of it

772
00:25:25,576 --> 00:25:26,776
and mix it with the argument

773
00:25:26,776 --> 00:25:28,116
buffers whenever it's more

774
00:25:28,116 --> 00:25:28,786
convenient.

775
00:25:29,296 --> 00:25:30,626
So let's say if you need to

776
00:25:30,626 --> 00:25:32,256
change a single texture for

777
00:25:33,376 --> 00:25:35,786
every object, for example a cube

778
00:25:35,786 --> 00:25:37,606
reflection, it probably would be

779
00:25:37,606 --> 00:25:38,786
an overhead to create argument

780
00:25:38,786 --> 00:25:40,096
buffer just for that and upload

781
00:25:40,096 --> 00:25:40,896
it every frame.

782
00:25:40,896 --> 00:25:42,826
So just use the traditional

783
00:25:42,826 --> 00:25:43,526
model for this.

784
00:25:43,656 --> 00:25:46,216
That's it about argument

785
00:25:46,216 --> 00:25:46,576
buffers.

786
00:25:46,576 --> 00:25:50,256
I really hope you will adopt our

787
00:25:50,256 --> 00:25:52,516
new API and get some creative

788
00:25:52,806 --> 00:25:53,596
use cases out of it.

789
00:25:54,136 --> 00:25:57,456
And please welcome Richard, who

790
00:25:57,546 --> 00:25:59,156
will talk about the Raster Order

791
00:25:59,156 --> 00:25:59,506
Groups.

792
00:26:00,556 --> 00:26:02,556
[ Applause ]

793
00:26:02,596 --> 00:26:03,016
&gt;&gt; Thank you.

794
00:26:05,046 --> 00:26:06,686
Hello. So thank you Michal.

795
00:26:06,826 --> 00:26:07,776
So I'm going to take you through

796
00:26:07,776 --> 00:26:08,436
the rest of the day's

797
00:26:08,436 --> 00:26:10,006
presentation, starting with

798
00:26:10,046 --> 00:26:10,936
Raster Order Groups.

799
00:26:12,476 --> 00:26:14,196
So this is a new feature that

800
00:26:14,196 --> 00:26:16,636
gives you control over the GPU's

801
00:26:16,726 --> 00:26:17,866
thread scheduling to run

802
00:26:18,196 --> 00:26:19,686
fragment shooter threads, in

803
00:26:19,746 --> 00:26:20,086
order.

804
00:26:20,686 --> 00:26:22,096
This allows overlapping fragment

805
00:26:22,096 --> 00:26:23,266
shooter threads to communicate

806
00:26:23,266 --> 00:26:24,876
through memory, where before it

807
00:26:24,876 --> 00:26:27,366
wasn't always really possible to

808
00:26:27,366 --> 00:26:28,286
do in most cases.

809
00:26:28,646 --> 00:26:30,246
So this opens up a whole new set

810
00:26:30,246 --> 00:26:31,266
of graphics algorithms that were

811
00:26:31,266 --> 00:26:32,956
not practically achievable with

812
00:26:33,156 --> 00:26:34,206
just write only access to your

813
00:26:34,206 --> 00:26:36,196
frame buffers or onward access

814
00:26:36,196 --> 00:26:37,216
memory to device memory.

815
00:26:38,476 --> 00:26:40,986
For example, one of our key --

816
00:26:40,986 --> 00:26:42,226
one of the key applications for

817
00:26:42,306 --> 00:26:43,156
this is Order-independent

818
00:26:43,156 --> 00:26:43,926
transparency.

819
00:26:44,746 --> 00:26:46,106
We've been -- already talked a

820
00:26:46,106 --> 00:26:47,476
lot today about how to reduce

821
00:26:47,476 --> 00:26:48,596
the CP usage of your Metal

822
00:26:48,596 --> 00:26:50,356
application and this feature

823
00:26:50,356 --> 00:26:52,006
lets you build or an algorithm

824
00:26:52,476 --> 00:26:54,456
to include blending back to

825
00:26:54,456 --> 00:26:56,116
front without having to pay the

826
00:26:56,116 --> 00:26:57,526
CPU cost of triangle level

827
00:26:57,526 --> 00:26:57,896
sorting.

828
00:26:59,536 --> 00:27:00,736
There's also been lots of

829
00:26:59,536 --> 00:27:00,736
There's also been lots of

830
00:27:00,736 --> 00:27:01,836
investigations into advanced

831
00:27:01,836 --> 00:27:03,176
techniques such as dual layer

832
00:27:03,396 --> 00:27:04,236
G-buffers, which can

833
00:27:04,236 --> 00:27:05,946
substantially improve post

834
00:27:05,946 --> 00:27:07,596
processing results, or using the

835
00:27:07,596 --> 00:27:08,846
GPU rasterizer to sort of

836
00:27:08,846 --> 00:27:10,196
voxelize triangle meshes.

837
00:27:11,056 --> 00:27:12,716
For both of these onward

838
00:27:12,716 --> 00:27:13,826
accesses to memory has been a

839
00:27:13,826 --> 00:27:15,336
really large barrier to

840
00:27:15,336 --> 00:27:16,516
efficient implementations.

841
00:27:17,296 --> 00:27:18,976
But probably the simplest and

842
00:27:18,976 --> 00:27:20,566
most common application for this

843
00:27:20,566 --> 00:27:21,836
feature is just implementing

844
00:27:21,836 --> 00:27:22,776
custom blend equations.

845
00:27:23,656 --> 00:27:25,076
iOS hardware could always do

846
00:27:25,076 --> 00:27:27,336
this pretty natively, but this

847
00:27:27,336 --> 00:27:29,406
is not something that desktop

848
00:27:29,406 --> 00:27:31,066
hardware has traditionally been

849
00:27:31,066 --> 00:27:31,686
able to do.

850
00:27:32,656 --> 00:27:33,906
So I'm going to use custom

851
00:27:33,906 --> 00:27:34,986
blending as an example

852
00:27:34,986 --> 00:27:36,076
application to introduce this

853
00:27:36,076 --> 00:27:36,346
feature.

854
00:27:38,076 --> 00:27:40,086
Okay, so pretty typical case of

855
00:27:40,126 --> 00:27:41,316
triangle blending; one triangle

856
00:27:41,316 --> 00:27:41,836
over another.

857
00:27:42,776 --> 00:27:45,036
Pretty much all modern GPU APIs

858
00:27:45,036 --> 00:27:46,386
guarantee that blending happens

859
00:27:46,386 --> 00:27:47,426
in draw call order.

860
00:27:47,566 --> 00:27:48,856
It provides this nice,

861
00:27:48,926 --> 00:27:50,416
convenient illusion of serial

862
00:27:50,416 --> 00:27:50,946
execution.

863
00:27:51,796 --> 00:27:53,376
But of course what's really

864
00:27:53,376 --> 00:27:54,586
going on behind the scenes is

865
00:27:54,676 --> 00:27:56,026
GPU hardware's highly parallel.

866
00:27:56,026 --> 00:27:57,056
It's going to be running

867
00:27:57,056 --> 00:27:58,256
multiple threads concurrently.

868
00:27:58,836 --> 00:28:00,296
And only this fixed-function

869
00:27:58,836 --> 00:28:00,296
And only this fixed-function

870
00:28:00,296 --> 00:28:01,786
blend step at the end is going

871
00:28:01,786 --> 00:28:03,046
to be delayed until everything

872
00:28:03,046 --> 00:28:05,776
gets put back in order again.

873
00:28:05,776 --> 00:28:06,876
There's this implicit wait that

874
00:28:06,876 --> 00:28:08,906
happens before that blend step.

875
00:28:10,476 --> 00:28:12,686
Things change however if the

876
00:28:12,686 --> 00:28:13,616
ordering -- if we need to put

877
00:28:13,616 --> 00:28:14,766
things in order not at the end

878
00:28:14,766 --> 00:28:16,326
of our fragment shooter, but

879
00:28:16,416 --> 00:28:18,066
right in the middle because in

880
00:28:18,066 --> 00:28:20,156
this case triangle one wants to

881
00:28:20,156 --> 00:28:21,316
write something to memory that

882
00:28:21,316 --> 00:28:22,596
triangle two's threads want to

883
00:28:22,596 --> 00:28:23,026
read from.

884
00:28:23,306 --> 00:28:25,016
If we want triangle two to be

885
00:28:25,016 --> 00:28:26,236
able to build upon and consume

886
00:28:26,236 --> 00:28:28,026
triangle one's data we need to

887
00:28:28,026 --> 00:28:28,906
get that ordering back.

888
00:28:29,646 --> 00:28:32,366
And so that's pretty much what

889
00:28:32,366 --> 00:28:33,576
Raster Order Groups provides.

890
00:28:34,706 --> 00:28:37,116
So I'm going to jump over to a

891
00:28:37,206 --> 00:28:38,156
shader code example.

892
00:28:39,806 --> 00:28:41,116
So if I want to implement custom

893
00:28:41,116 --> 00:28:42,466
blending, an initial attempt

894
00:28:42,636 --> 00:28:44,456
that does not work is going to

895
00:28:44,456 --> 00:28:45,726
be to replace my classic

896
00:28:45,726 --> 00:28:46,696
graphics frame buffer with a

897
00:28:46,696 --> 00:28:47,996
read to write texture and

898
00:28:47,996 --> 00:28:49,696
perform all of my rendering and

899
00:28:49,696 --> 00:28:50,636
blending directly to this

900
00:28:50,636 --> 00:28:50,956
texture.

901
00:28:51,776 --> 00:28:53,976
But of course if the threads

902
00:28:53,976 --> 00:28:55,206
that I'm blending over have yet

903
00:28:55,206 --> 00:28:56,416
to execute, or concurrently

904
00:28:56,416 --> 00:28:59,066
executing, this is -- this whole

905
00:28:59,166 --> 00:29:00,596
remodify/write sequence is going

906
00:28:59,166 --> 00:29:00,596
remodify/write sequence is going

907
00:29:00,596 --> 00:29:01,546
to create a race condition.

908
00:29:02,076 --> 00:29:03,876
So how do we use Raster Order

909
00:29:03,876 --> 00:29:05,146
Groups to fix this?

910
00:29:05,316 --> 00:29:07,416
It's really, really easy.

911
00:29:08,626 --> 00:29:10,146
All I have to do is add a new

912
00:29:10,276 --> 00:29:12,996
attribute to the memory that has

913
00:29:12,996 --> 00:29:14,086
conflicting accesses.

914
00:29:14,866 --> 00:29:16,906
At this point the compiler and

915
00:29:16,906 --> 00:29:17,636
the hardware are going to

916
00:29:17,636 --> 00:29:18,876
cooperate to be able to

917
00:29:18,876 --> 00:29:20,616
implicitly take the entire range

918
00:29:20,866 --> 00:29:21,806
of [inaudible] shader that

919
00:29:21,806 --> 00:29:22,996
accesses that memory from the

920
00:29:22,996 --> 00:29:24,176
very first to the very last

921
00:29:24,176 --> 00:29:25,386
access and turn it into a

922
00:29:25,386 --> 00:29:26,366
critical section behind the

923
00:29:26,366 --> 00:29:26,836
scenes.

924
00:29:28,806 --> 00:29:29,826
You can also apply this

925
00:29:29,826 --> 00:29:31,296
attribute to normal device

926
00:29:31,296 --> 00:29:33,846
memory pointers, not just

927
00:29:34,536 --> 00:29:34,886
textures.

928
00:29:34,886 --> 00:29:37,606
So with that we get the thread

929
00:29:37,606 --> 00:29:38,536
schedule that we want.

930
00:29:39,216 --> 00:29:40,406
Thread one will proceed and

931
00:29:40,406 --> 00:29:42,116
write to memory and thread two

932
00:29:42,116 --> 00:29:43,526
is going to stop and wait until

933
00:29:43,526 --> 00:29:46,046
thread one's write's complete

934
00:29:46,046 --> 00:29:47,916
giving us basically race free

935
00:29:47,916 --> 00:29:51,576
access to this memory.

936
00:29:51,926 --> 00:29:53,096
Oh, there's one other really

937
00:29:53,096 --> 00:29:54,106
important topic and that's

938
00:29:54,106 --> 00:29:56,016
talking about which threads are

939
00:29:56,016 --> 00:29:57,266
synchronizing with each other.

940
00:29:57,706 --> 00:29:59,656
So of course GPU hardware's

941
00:29:59,656 --> 00:30:00,486
going to be running not just

942
00:29:59,656 --> 00:30:00,486
going to be running not just

943
00:30:00,486 --> 00:30:02,296
two, but tens of thousands of

944
00:30:02,296 --> 00:30:05,146
threads at the same time and in

945
00:30:05,246 --> 00:30:06,396
fact it's probably executing

946
00:30:06,436 --> 00:30:07,746
every single thread from both of

947
00:30:07,746 --> 00:30:09,136
these triangles simultaneously.

948
00:30:09,616 --> 00:30:12,056
So of all of these thousands --

949
00:30:12,056 --> 00:30:12,816
tens of thousands -- of threads,

950
00:30:12,816 --> 00:30:13,966
which one synchronizes with each

951
00:30:13,966 --> 00:30:14,176
other?

952
00:30:15,836 --> 00:30:17,786
So I've highlighted one pixel

953
00:30:17,786 --> 00:30:18,986
here because that's the answer

954
00:30:18,986 --> 00:30:19,586
to this question.

955
00:30:20,356 --> 00:30:21,876
You -- this feature only

956
00:30:21,876 --> 00:30:22,846
synchronizes against other

957
00:30:22,846 --> 00:30:23,986
threads that your current

958
00:30:23,986 --> 00:30:25,526
fragment shooter thread overlaps

959
00:30:25,526 --> 00:30:27,516
with, those other threads that

960
00:30:27,596 --> 00:30:29,106
are targeting the same frame

961
00:30:29,106 --> 00:30:31,146
buffer xy location, targeting

962
00:30:31,146 --> 00:30:32,886
the same multi-sample location,

963
00:30:33,196 --> 00:30:34,306
targeting the same render target

964
00:30:34,306 --> 00:30:34,786
index.

965
00:30:36,726 --> 00:30:37,776
If I wanted -- and it

966
00:30:37,776 --> 00:30:39,096
specifically does not provide

967
00:30:39,136 --> 00:30:40,756
any guarantees at all against --

968
00:30:40,756 --> 00:30:41,836
that you can safely access

969
00:30:41,836 --> 00:30:43,376
memory that are written by any

970
00:30:43,376 --> 00:30:44,276
neighboring pixels.

971
00:30:45,366 --> 00:30:46,816
If you do need to have these

972
00:30:46,816 --> 00:30:48,496
kind of area -- or region of

973
00:30:48,496 --> 00:30:49,726
influence -- kind of algorithms

974
00:30:50,096 --> 00:30:51,156
then you will need to go back to

975
00:30:51,156 --> 00:30:52,326
using full memory barriers

976
00:30:52,356 --> 00:30:53,736
between draw call -- or full API

977
00:30:53,736 --> 00:30:54,916
barriers between draw calls or

978
00:30:54,916 --> 00:30:55,666
render passes.

979
00:30:56,376 --> 00:30:57,846
But this comes at a much higher

980
00:30:57,846 --> 00:30:59,656
performance cost and it does not

981
00:30:59,656 --> 00:31:00,876
work in the case where you have

982
00:30:59,656 --> 00:31:00,876
work in the case where you have

983
00:31:00,876 --> 00:31:02,236
triangle overlap within a single

984
00:31:02,236 --> 00:31:02,696
draw call.

985
00:31:03,336 --> 00:31:05,256
But for these common algorithms

986
00:31:05,256 --> 00:31:06,806
that you do have only need

987
00:31:06,806 --> 00:31:08,206
overlap only synchronization,

988
00:31:08,836 --> 00:31:09,976
Raster Order Groups can get the

989
00:31:09,976 --> 00:31:11,286
job done at a substantially

990
00:31:11,286 --> 00:31:13,866
lower performance cost.

991
00:31:13,866 --> 00:31:15,486
So this is a pretty actually

992
00:31:15,676 --> 00:31:16,716
easy one and that's really all

993
00:31:16,716 --> 00:31:17,356
I've got to say about it.

994
00:31:17,396 --> 00:31:19,546
Raster Order Groups lets you

995
00:31:19,546 --> 00:31:21,246
efficiently wait for overlapping

996
00:31:21,516 --> 00:31:24,046
and only overlapping threads to

997
00:31:24,046 --> 00:31:25,136
finish their access to memory,

998
00:31:25,806 --> 00:31:27,586
which enables a collection of GP

999
00:31:27,586 --> 00:31:28,736
algorithms that were previously

1000
00:31:28,736 --> 00:31:30,026
just too inefficient to use

1001
00:31:30,026 --> 00:31:31,296
practically in GPU hardware.

1002
00:31:33,516 --> 00:31:35,766
This middle of shader thread

1003
00:31:35,766 --> 00:31:37,076
summarization is a feature of

1004
00:31:37,076 --> 00:31:38,556
the latest GPU hardware, so it

1005
00:31:38,556 --> 00:31:39,286
is something you do need to

1006
00:31:39,286 --> 00:31:40,426
check for at run time.

1007
00:31:41,106 --> 00:31:42,446
In particular it's supported on

1008
00:31:42,446 --> 00:31:43,896
the newest AMD Vega GPUs

1009
00:31:43,896 --> 00:31:45,256
announced this week as well as

1010
00:31:45,256 --> 00:31:46,356
the past couple years' worth of

1011
00:31:46,356 --> 00:31:47,216
Intel GPUs.

1012
00:31:49,136 --> 00:31:50,196
And that brings us on to our

1013
00:31:50,196 --> 00:31:51,286
second feature and that is the

1014
00:31:51,286 --> 00:31:52,616
new iPad Pro's ProMotion

1015
00:31:52,616 --> 00:31:52,966
Display.

1016
00:32:01,056 --> 00:32:02,486
So ProMotion, this is a

1017
00:32:02,616 --> 00:32:04,006
particularly great feature for

1018
00:32:04,006 --> 00:32:05,186
graphics and game developers and

1019
00:32:05,186 --> 00:32:06,226
so I really want to show you

1020
00:32:06,226 --> 00:32:07,626
what you can do with it.

1021
00:32:07,946 --> 00:32:10,466
This is the first of a sequence

1022
00:32:10,466 --> 00:32:11,606
of timeline diagrams I'm going

1023
00:32:11,606 --> 00:32:13,946
to show you, showing us when the

1024
00:32:13,946 --> 00:32:15,606
GPU starts and finishes

1025
00:32:15,606 --> 00:32:16,916
producing a frame, and then when

1026
00:32:16,916 --> 00:32:18,056
that same frame finally gets

1027
00:32:18,056 --> 00:32:19,256
onto the glass for the user to

1028
00:32:19,256 --> 00:32:19,526
see.

1029
00:32:20,646 --> 00:32:22,116
The first and most obvious thing

1030
00:32:22,116 --> 00:32:23,356
that ProMotion does is we can

1031
00:32:23,356 --> 00:32:25,146
now render at 120 frames per

1032
00:32:25,146 --> 00:32:25,556
second.

1033
00:32:27,316 --> 00:32:28,896
This feels absolutely fantastic

1034
00:32:28,896 --> 00:32:29,896
for anything that has really

1035
00:32:29,896 --> 00:32:31,616
high speed animations, for

1036
00:32:31,616 --> 00:32:32,796
anything that's latency critical

1037
00:32:32,796 --> 00:32:34,096
such as tracking user touch or

1038
00:32:34,096 --> 00:32:34,756
pencil input.

1039
00:32:35,576 --> 00:32:37,876
And it does have some catches.

1040
00:32:37,876 --> 00:32:40,336
You of course only get half as

1041
00:32:40,336 --> 00:32:42,146
much CPU and GPU time available

1042
00:32:42,146 --> 00:32:43,596
per frame so you really have to

1043
00:32:43,596 --> 00:32:44,356
pay a lot of attention to

1044
00:32:44,356 --> 00:32:46,196
optimization and it does

1045
00:32:46,196 --> 00:32:47,276
increase overall system power

1046
00:32:47,276 --> 00:32:47,836
consumption.

1047
00:32:48,816 --> 00:32:49,546
But if you've got the right

1048
00:32:49,546 --> 00:32:51,506
content, where this matters, it

1049
00:32:51,506 --> 00:32:52,686
gets a really payoff for the

1050
00:32:52,686 --> 00:32:53,576
user experience.

1051
00:32:55,006 --> 00:32:56,566
But ProMotion goes a lot farther

1052
00:32:56,566 --> 00:32:58,096
than 120 frames per second

1053
00:32:58,096 --> 00:32:58,436
rendering.

1054
00:32:59,176 --> 00:33:01,626
It also provides much more

1055
00:32:59,176 --> 00:33:01,626
It also provides much more

1056
00:33:01,626 --> 00:33:03,496
flexibility regarding when to

1057
00:33:03,496 --> 00:33:04,546
swap the next image onto the

1058
00:33:04,546 --> 00:33:05,016
glass.

1059
00:33:05,726 --> 00:33:07,776
We're not limited to just 120 or

1060
00:33:07,776 --> 00:33:09,906
30 or 60 frames per second.

1061
00:33:10,486 --> 00:33:12,816
ProMotion behaves much more

1062
00:33:12,816 --> 00:33:14,056
gracefully as your application's

1063
00:33:14,056 --> 00:33:15,446
performance moves up and down

1064
00:33:15,716 --> 00:33:16,756
compared to a fixed frame rate

1065
00:33:16,756 --> 00:33:17,166
display.

1066
00:33:18,376 --> 00:33:21,186
For example, here I have a

1067
00:33:21,226 --> 00:33:22,586
timeline diagram of a title

1068
00:33:22,586 --> 00:33:23,926
that, you know just -- is just

1069
00:33:23,926 --> 00:33:24,986
doing too much GPU work to

1070
00:33:24,986 --> 00:33:26,356
target 60 frames per second.

1071
00:33:26,516 --> 00:33:27,226
You know they're producing

1072
00:33:27,226 --> 00:33:28,906
frames every about 21

1073
00:33:28,906 --> 00:33:30,366
milliseconds or about 48 frames

1074
00:33:30,366 --> 00:33:30,836
per second.

1075
00:33:31,576 --> 00:33:33,466
The GPU is perfectly happy to do

1076
00:33:33,466 --> 00:33:35,526
that, but on the display side we

1077
00:33:35,526 --> 00:33:37,076
can only refresh once every 16

1078
00:33:37,076 --> 00:33:38,176
milliseconds and so we end up

1079
00:33:38,176 --> 00:33:38,976
with this beating pattern.

1080
00:33:39,046 --> 00:33:40,126
There's this stuttering that the

1081
00:33:40,126 --> 00:33:41,866
user feels where some frames are

1082
00:33:41,866 --> 00:33:42,916
on the glass a lot longer than

1083
00:33:42,916 --> 00:33:43,356
others.

1084
00:33:44,056 --> 00:33:47,006
And it's not nice at all.

1085
00:33:47,306 --> 00:33:48,866
And so pretty much universally

1086
00:33:48,866 --> 00:33:49,846
what applications do in this

1087
00:33:49,846 --> 00:33:50,586
case is they all have to

1088
00:33:50,586 --> 00:33:51,976
artificially constrain the frame

1089
00:33:51,976 --> 00:33:53,776
rate all the way down to 30

1090
00:33:53,776 --> 00:33:56,336
frames per second.

1091
00:33:56,336 --> 00:33:57,686
They're basically trading away

1092
00:33:57,686 --> 00:33:59,036
their peak frame rate in order

1093
00:33:59,036 --> 00:33:59,926
to get some level of

1094
00:33:59,926 --> 00:34:00,556
consistency.

1095
00:33:59,926 --> 00:34:00,556
consistency.

1096
00:34:02,176 --> 00:34:04,146
ProMotion does much better here.

1097
00:34:04,616 --> 00:34:05,636
So if I just take the same

1098
00:34:05,636 --> 00:34:06,596
application, move it to a

1099
00:34:06,596 --> 00:34:09,126
ProMotion display, it does this

1100
00:34:09,126 --> 00:34:09,755
to our timeline.

1101
00:34:10,826 --> 00:34:12,036
We now have a refresh point

1102
00:34:12,036 --> 00:34:13,596
every four milliseconds rather

1103
00:34:13,596 --> 00:34:14,356
than every 16.

1104
00:34:15,266 --> 00:34:16,646
Our timeline gets pulled in,

1105
00:34:16,866 --> 00:34:18,286
even with the GPU doing exactly

1106
00:34:18,286 --> 00:34:19,286
the same work as before.

1107
00:34:19,906 --> 00:34:21,976
The display can now present at

1108
00:34:21,976 --> 00:34:23,626
an entirely consistent 48 frames

1109
00:34:23,626 --> 00:34:24,136
per second.

1110
00:34:24,985 --> 00:34:26,466
The user is now getting both the

1111
00:34:26,466 --> 00:34:28,176
best possible frame rate and

1112
00:34:28,176 --> 00:34:30,156
perfect consistency from frame

1113
00:34:30,156 --> 00:34:30,545
to frame.

1114
00:34:31,186 --> 00:34:32,116
This tradeoff that we had to

1115
00:34:32,116 --> 00:34:33,056
make is completely gone.

1116
00:34:34,246 --> 00:34:37,096
Furthermore -- so a second

1117
00:34:37,096 --> 00:34:38,996
example is that this time in

1118
00:34:38,996 --> 00:34:41,295
application that wanted to make

1119
00:34:41,295 --> 00:34:42,936
60 frames per second, but one

1120
00:34:42,936 --> 00:34:44,666
frame just ran a bit long and we

1121
00:34:44,666 --> 00:34:48,295
missed our deadline.

1122
00:34:48,295 --> 00:34:49,886
On a fixed frame rate display we

1123
00:34:49,886 --> 00:34:50,826
end up on the display side with

1124
00:34:50,826 --> 00:34:51,856
a pattern that looks very

1125
00:34:51,856 --> 00:34:53,126
similar to what we saw before.

1126
00:34:54,585 --> 00:34:56,416
ProMotion can fix this too.

1127
00:34:57,576 --> 00:34:58,626
So frame one's time on the

1128
00:34:58,626 --> 00:34:59,866
glass, rather than it being

1129
00:34:59,866 --> 00:35:01,336
extended by 16 milliseconds, is

1130
00:34:59,866 --> 00:35:01,336
extended by 16 milliseconds, is

1131
00:35:01,336 --> 00:35:02,666
now only extended by four.

1132
00:35:03,126 --> 00:35:04,526
The degree of stutter that the

1133
00:35:04,526 --> 00:35:06,446
user experiences is tremendously

1134
00:35:06,446 --> 00:35:09,066
reduced and then frame two and

1135
00:35:09,066 --> 00:35:11,336
three, their latency gets pulled

1136
00:35:11,336 --> 00:35:12,286
right back into where they were

1137
00:35:12,286 --> 00:35:12,796
before.

1138
00:35:13,426 --> 00:35:14,736
The system recovers right back

1139
00:35:14,736 --> 00:35:15,886
onto the timeline right away,

1140
00:35:16,336 --> 00:35:19,136
latency is improved, and your

1141
00:35:19,136 --> 00:35:20,446
application can proceed on.

1142
00:35:20,516 --> 00:35:21,306
We've just gotten right back to

1143
00:35:21,306 --> 00:35:22,756
where we wanted to be.

1144
00:35:23,416 --> 00:35:26,126
So put it all together, it just

1145
00:35:26,126 --> 00:35:27,816
makes animation just feel that

1146
00:35:27,816 --> 00:35:29,136
much more robust and solid no

1147
00:35:29,136 --> 00:35:30,786
matter what's going on.

1148
00:35:31,906 --> 00:35:33,816
So how do you actually go about

1149
00:35:33,816 --> 00:35:35,116
taking advantage of this?

1150
00:35:35,756 --> 00:35:38,576
For normal UIKit animation, such

1151
00:35:38,576 --> 00:35:39,546
as scrolling through lists or

1152
00:35:39,546 --> 00:35:41,506
views, iOS will do this entirely

1153
00:35:41,506 --> 00:35:42,516
for you out of the box.

1154
00:35:43,016 --> 00:35:44,506
It will render it 120 frames per

1155
00:35:44,506 --> 00:35:45,456
second when appropriate.

1156
00:35:45,526 --> 00:35:47,606
It will use the flexible display

1157
00:35:47,696 --> 00:35:48,466
times when appropriate.

1158
00:35:50,206 --> 00:35:51,256
Metal applications though tend

1159
00:35:51,256 --> 00:35:52,286
to be much more aware of their

1160
00:35:52,286 --> 00:35:53,466
timing and so for those we've

1161
00:35:53,466 --> 00:35:54,446
made this an opt in feature.

1162
00:35:55,766 --> 00:35:57,886
Opting in is done really easily

1163
00:35:57,886 --> 00:35:59,186
just by adding a new entry to

1164
00:35:59,186 --> 00:36:00,106
your application bundles

1165
00:35:59,186 --> 00:36:00,106
your application bundles

1166
00:36:00,106 --> 00:36:00,866
info.plist.

1167
00:36:01,596 --> 00:36:03,206
Once you do this the timing

1168
00:36:03,206 --> 00:36:04,616
behavior of our three Metal

1169
00:36:04,616 --> 00:36:06,266
presentation API changes a

1170
00:36:06,266 --> 00:36:06,536
little bit.

1171
00:36:06,536 --> 00:36:07,536
And so I'm going to walk you

1172
00:36:07,536 --> 00:36:08,846
through those three APIs and how

1173
00:36:08,846 --> 00:36:09,456
they change now.

1174
00:36:10,226 --> 00:36:12,066
So the first of our Metal

1175
00:36:12,066 --> 00:36:14,046
presentation APIs is just

1176
00:36:14,466 --> 00:36:14,966
present.

1177
00:36:15,616 --> 00:36:18,216
It's -- it says present

1178
00:36:18,216 --> 00:36:20,156
immediately; schedule my image

1179
00:36:20,156 --> 00:36:21,206
to be put on the glass at the

1180
00:36:21,206 --> 00:36:22,676
very next available refresh

1181
00:36:22,726 --> 00:36:24,306
point after the GPU finishes.

1182
00:36:25,376 --> 00:36:26,596
On fixed frame rate hardware

1183
00:36:26,596 --> 00:36:28,566
that's 16 milliseconds and on

1184
00:36:28,566 --> 00:36:29,956
iPad Pro that's now four

1185
00:36:29,956 --> 00:36:30,626
milliseconds.

1186
00:36:31,296 --> 00:36:32,866
This is the easiest API to use

1187
00:36:32,866 --> 00:36:33,726
because it takes no runs.

1188
00:36:33,726 --> 00:36:35,046
So it's the API that most of the

1189
00:36:35,046 --> 00:36:35,966
people in this room are already

1190
00:36:35,966 --> 00:36:36,296
using.

1191
00:36:37,416 --> 00:36:38,476
It's also the API that gives you

1192
00:36:38,476 --> 00:36:40,056
the lowest latency access to the

1193
00:36:40,056 --> 00:36:40,466
display.

1194
00:36:41,296 --> 00:36:43,236
It works identically on both our

1195
00:36:43,236 --> 00:36:44,596
fixed frame rate and ProMotion

1196
00:36:44,596 --> 00:36:46,636
hardware, but once you opt in it

1197
00:36:46,636 --> 00:36:47,486
starts working with much, much

1198
00:36:47,486 --> 00:36:47,976
better granularity.

1199
00:36:51,646 --> 00:36:53,116
The second of our Metal

1200
00:36:53,116 --> 00:36:54,996
presentation APIs is present

1201
00:36:54,996 --> 00:36:56,036
with minimum duration.

1202
00:36:56,806 --> 00:36:59,236
So this one says, whenever this

1203
00:36:59,236 --> 00:37:00,766
image lands on the glass, keep

1204
00:36:59,236 --> 00:37:00,766
image lands on the glass, keep

1205
00:37:00,766 --> 00:37:01,836
it there for a certain fixed

1206
00:37:01,836 --> 00:37:02,486
amount of time.

1207
00:37:03,046 --> 00:37:03,956
So if my image lands on the

1208
00:37:03,956 --> 00:37:04,966
glass here, it's going to stay

1209
00:37:04,966 --> 00:37:06,076
for 33 milliseconds.

1210
00:37:06,076 --> 00:37:08,176
And if my start time shifts so

1211
00:37:08,176 --> 00:37:08,896
does the end time.

1212
00:37:09,576 --> 00:37:11,116
This is the API you'd use if you

1213
00:37:11,116 --> 00:37:12,386
want perfect consistency in

1214
00:37:12,386 --> 00:37:13,796
frame rate from frame to frame.

1215
00:37:14,416 --> 00:37:16,146
This is particularly useful in

1216
00:37:16,146 --> 00:37:17,616
30 frames per seconds -- on 60

1217
00:37:17,856 --> 00:37:19,406
rate per seconds displays,

1218
00:37:19,406 --> 00:37:20,316
although it's also sometimes

1219
00:37:20,316 --> 00:37:21,446
useful on ProMotion as well.

1220
00:37:22,416 --> 00:37:24,706
But our third presentation

1221
00:37:24,706 --> 00:37:25,916
varying is the most interesting

1222
00:37:25,916 --> 00:37:26,386
by far.

1223
00:37:26,596 --> 00:37:28,406
It's present at a specific time

1224
00:37:28,736 --> 00:37:30,486
and it does exactly what it

1225
00:37:30,486 --> 00:37:30,996
sounds like.

1226
00:37:31,736 --> 00:37:33,106
If the GPU's done well before

1227
00:37:33,106 --> 00:37:34,436
the designated time, the display

1228
00:37:34,436 --> 00:37:34,836
will wait.

1229
00:37:35,196 --> 00:37:36,556
If the GPU runs over your

1230
00:37:36,556 --> 00:37:37,966
deadline the display will pick

1231
00:37:37,966 --> 00:37:39,606
it up at the very next available

1232
00:37:39,606 --> 00:37:40,536
point afterwards.

1233
00:37:41,666 --> 00:37:44,256
This is the key API to use if

1234
00:37:44,256 --> 00:37:45,376
you want to build fully custom

1235
00:37:45,376 --> 00:37:46,596
animation and timing loops.

1236
00:37:47,286 --> 00:37:49,036
This API to present and time,

1237
00:37:49,116 --> 00:37:50,656
combined with ProMotion display

1238
00:37:51,096 --> 00:37:52,286
basically lets you leave behind

1239
00:37:52,286 --> 00:37:53,446
the concept of a fixed frame

1240
00:37:53,446 --> 00:37:54,696
rate entirely and render your

1241
00:37:54,696 --> 00:37:56,206
content exactly for the time the

1242
00:37:56,206 --> 00:37:57,196
user is going to see it.

1243
00:37:58,006 --> 00:37:59,296
If you want to keep your Metal

1244
00:37:59,296 --> 00:38:00,516
view perfectly in synch with

1245
00:37:59,296 --> 00:38:00,516
view perfectly in synch with

1246
00:38:00,516 --> 00:38:01,416
something else happening on the

1247
00:38:01,416 --> 00:38:03,386
system, such as audio, or if you

1248
00:38:03,386 --> 00:38:04,236
want to basically provide the

1249
00:38:04,236 --> 00:38:05,476
appearance of zero latency at

1250
00:38:05,476 --> 00:38:06,606
all and be able to forward

1251
00:38:06,606 --> 00:38:07,766
project your animation for

1252
00:38:07,766 --> 00:38:09,176
exactly when the user's going to

1253
00:38:09,176 --> 00:38:11,036
see your content this is what

1254
00:38:11,036 --> 00:38:11,846
lets you do that.

1255
00:38:13,266 --> 00:38:14,116
Now of course the trick is

1256
00:38:14,116 --> 00:38:15,326
implementing that project next

1257
00:38:15,326 --> 00:38:15,896
display time.

1258
00:38:15,896 --> 00:38:16,596
That's your function.

1259
00:38:17,616 --> 00:38:18,776
To make that work you do need

1260
00:38:18,776 --> 00:38:19,986
some feedback from the system to

1261
00:38:19,986 --> 00:38:21,146
help you determine what your

1262
00:38:21,146 --> 00:38:22,166
actual performance is.

1263
00:38:22,196 --> 00:38:23,356
And so we've added that as well.

1264
00:38:24,646 --> 00:38:26,966
So a Metal drawable object is a

1265
00:38:26,966 --> 00:38:28,156
transient object that tracks the

1266
00:38:28,156 --> 00:38:29,496
lifetime of one image you've

1267
00:38:29,496 --> 00:38:30,746
rendered all the way through the

1268
00:38:30,746 --> 00:38:31,516
display system.

1269
00:38:31,736 --> 00:38:34,896
It can now be queried for the

1270
00:38:34,896 --> 00:38:36,426
specific time that frame lands

1271
00:38:36,426 --> 00:38:37,606
on the glass and you can also

1272
00:38:37,606 --> 00:38:38,346
get a call back when that

1273
00:38:38,346 --> 00:38:38,866
happens.

1274
00:38:39,906 --> 00:38:41,466
So now you can know when your

1275
00:38:41,466 --> 00:38:42,696
image is landing on the glass,

1276
00:38:43,076 --> 00:38:44,656
when they're being removed, and

1277
00:38:44,656 --> 00:38:45,696
you have the key signal to know

1278
00:38:45,696 --> 00:38:47,356
when you are or are not making

1279
00:38:47,356 --> 00:38:48,436
the designated timing that you

1280
00:38:48,436 --> 00:38:49,876
intended and are giving you the

1281
00:38:49,876 --> 00:38:51,156
signal to adjust for future

1282
00:38:51,156 --> 00:38:51,706
frames.

1283
00:38:54,176 --> 00:38:56,146
So that's the story of ProMotion

1284
00:38:56,146 --> 00:38:57,276
and what you need to do to make

1285
00:38:57,276 --> 00:38:58,296
use of it on the future -- on

1286
00:38:58,296 --> 00:38:59,326
these new iPad Pros.

1287
00:38:59,936 --> 00:39:01,566
It's incredibly easy to get more

1288
00:38:59,936 --> 00:39:01,566
It's incredibly easy to get more

1289
00:39:01,566 --> 00:39:02,706
consistent and higher frame

1290
00:39:02,706 --> 00:39:05,256
rates with almost no code

1291
00:39:05,256 --> 00:39:06,496
changing at all in most

1292
00:39:06,496 --> 00:39:07,246
applications.

1293
00:39:07,646 --> 00:39:10,306
From there it gives you a menu

1294
00:39:10,306 --> 00:39:11,606
of options to decide what

1295
00:39:11,606 --> 00:39:12,766
display time model is going to

1296
00:39:12,766 --> 00:39:13,906
best benefit your particular

1297
00:39:13,906 --> 00:39:14,126
app.

1298
00:39:14,976 --> 00:39:16,356
A really, really fast paced

1299
00:39:16,406 --> 00:39:18,216
Twitch arcade game or something

1300
00:39:18,216 --> 00:39:19,986
tracking touch or pencil input

1301
00:39:19,986 --> 00:39:21,286
probably wants to go for 120

1302
00:39:21,286 --> 00:39:22,036
frames per second.

1303
00:39:22,646 --> 00:39:24,386
A really high end rendering

1304
00:39:24,386 --> 00:39:25,766
title might want to stick with

1305
00:39:25,836 --> 00:39:27,156
30 or 60 frames per second or

1306
00:39:27,156 --> 00:39:28,176
somewhere in between and just

1307
00:39:28,176 --> 00:39:30,456
enjoy the consistency benefits.

1308
00:39:31,136 --> 00:39:32,266
And applications that want to

1309
00:39:32,266 --> 00:39:33,166
really take control of their

1310
00:39:33,166 --> 00:39:34,506
timing loop have entirely new

1311
00:39:34,506 --> 00:39:35,546
capabilities here as well.

1312
00:39:36,776 --> 00:39:37,956
But regardless of what your app

1313
00:39:37,956 --> 00:39:39,966
actually is, ProMotion gives you

1314
00:39:39,966 --> 00:39:41,186
this powerful new tool to

1315
00:39:41,186 --> 00:39:42,446
support its specific animation

1316
00:39:42,446 --> 00:39:42,726
needs.

1317
00:39:42,726 --> 00:39:45,306
So that's ProMotion.

1318
00:39:46,016 --> 00:39:48,846
So moving on, I have a different

1319
00:39:48,936 --> 00:39:50,346
display topic to talk about and

1320
00:39:50,346 --> 00:39:51,256
that is a feature we're calling

1321
00:39:51,256 --> 00:39:52,326
Direct 2 Display.

1322
00:39:54,236 --> 00:39:56,206
So the story of what happens

1323
00:39:56,206 --> 00:39:58,036
after your GPU finishes

1324
00:39:58,036 --> 00:39:59,306
rendering your content and the

1325
00:39:59,306 --> 00:40:00,426
display is actually a little bit

1326
00:39:59,306 --> 00:40:00,426
display is actually a little bit

1327
00:40:00,426 --> 00:40:01,066
more complicated.

1328
00:40:01,116 --> 00:40:02,886
And then your image can take two

1329
00:40:02,886 --> 00:40:04,836
paths to the display; GPU

1330
00:40:04,836 --> 00:40:07,016
composition and direct to

1331
00:40:08,116 --> 00:40:08,306
display.

1332
00:40:08,426 --> 00:40:10,256
The first of those is a -- your

1333
00:40:10,256 --> 00:40:11,956
typical user interface scenario

1334
00:40:12,486 --> 00:40:13,446
where I've got a collection of

1335
00:40:13,446 --> 00:40:15,086
views or layers or windows and

1336
00:40:15,086 --> 00:40:17,426
the like and at this point the

1337
00:40:17,426 --> 00:40:18,376
system is going to take all of

1338
00:40:18,376 --> 00:40:19,136
these and composite them

1339
00:40:19,136 --> 00:40:19,496
together.

1340
00:40:19,636 --> 00:40:20,776
It's going to scale any content

1341
00:40:20,776 --> 00:40:21,396
to fit the display.

1342
00:40:21,396 --> 00:40:21,906
It's going to perform

1343
00:40:21,906 --> 00:40:22,796
color/space conversion.

1344
00:40:22,796 --> 00:40:23,746
It's going to perform -- apply

1345
00:40:23,746 --> 00:40:24,776
any core image filters or

1346
00:40:24,776 --> 00:40:26,056
blending and it's going to

1347
00:40:26,056 --> 00:40:27,516
produce the one, final combined

1348
00:40:27,516 --> 00:40:28,636
image that the user sees.

1349
00:40:30,776 --> 00:40:32,436
This is really, really critical

1350
00:40:32,436 --> 00:40:33,676
abstraction for full-featured

1351
00:40:33,676 --> 00:40:34,586
user interfaces.

1352
00:40:35,106 --> 00:40:38,136
But it's also all done on the

1353
00:40:38,136 --> 00:40:39,186
GPU and it takes some time and

1354
00:40:39,186 --> 00:40:39,706
memory there.

1355
00:40:40,436 --> 00:40:41,746
And if we're basically building,

1356
00:40:41,746 --> 00:40:42,646
you know a full-screen

1357
00:40:42,646 --> 00:40:44,046
application, you know it's a

1358
00:40:44,046 --> 00:40:45,136
little bit overkill for that.

1359
00:40:45,136 --> 00:40:46,316
And so that's where direct

1360
00:40:46,316 --> 00:40:48,106
display mode comes in.

1361
00:40:48,256 --> 00:40:49,236
If none of these operations are

1362
00:40:49,236 --> 00:40:51,496
actually required, we can point

1363
00:40:51,496 --> 00:40:52,936
the display hardware directly at

1364
00:40:52,976 --> 00:40:54,216
the memory you just rendered to

1365
00:40:54,586 --> 00:40:55,856
and so without any middleman at

1366
00:40:55,856 --> 00:40:55,986
all.

1367
00:40:57,646 --> 00:40:59,026
So how do you enable this?

1368
00:40:59,406 --> 00:41:01,196
It turns out there is no single

1369
00:40:59,406 --> 00:41:01,196
It turns out there is no single

1370
00:41:01,196 --> 00:41:02,716
turn it on API for direct to

1371
00:41:02,716 --> 00:41:03,146
display.

1372
00:41:03,916 --> 00:41:05,566
This mode is really an omission

1373
00:41:05,566 --> 00:41:06,796
of anything that requires the

1374
00:41:06,796 --> 00:41:08,166
GPU compositer to intervene.

1375
00:41:08,836 --> 00:41:10,386
When the compositer takes a look

1376
00:41:10,386 --> 00:41:11,596
at the set-up of your scene and

1377
00:41:11,596 --> 00:41:13,026
says there's nothing it needs to

1378
00:41:13,026 --> 00:41:14,686
do here it will just step out of

1379
00:41:14,686 --> 00:41:15,626
the way.

1380
00:41:16,426 --> 00:41:18,176
So how can you set up your scene

1381
00:41:18,176 --> 00:41:20,726
to get the compositer to step

1382
00:41:20,726 --> 00:41:22,756
out of the way?

1383
00:41:23,216 --> 00:41:23,706
So this is pretty

1384
00:41:23,706 --> 00:41:24,916
straightforward, an intuitive

1385
00:41:24,966 --> 00:41:26,166
feel of, does my content need

1386
00:41:26,166 --> 00:41:27,106
any kind of nontrurial

1387
00:41:27,106 --> 00:41:27,846
[phonetic] processing is a

1388
00:41:27,846 --> 00:41:29,336
pretty good intuitive start.

1389
00:41:30,066 --> 00:41:31,146
But more specifically you do

1390
00:41:31,146 --> 00:41:32,166
want your layer to be opaque.

1391
00:41:32,726 --> 00:41:33,756
I don't want to be blending over

1392
00:41:33,756 --> 00:41:34,096
anything.

1393
00:41:34,716 --> 00:41:36,616
We don't want to apply anything

1394
00:41:36,616 --> 00:41:37,716
that requires that core

1395
00:41:37,716 --> 00:41:38,666
animation or the window server

1396
00:41:38,916 --> 00:41:39,946
modify our pixels.

1397
00:41:39,946 --> 00:41:40,836
We don't want to put on rounded

1398
00:41:40,836 --> 00:41:42,406
corners in our view or masking

1399
00:41:42,406 --> 00:41:44,326
or filters or the like.

1400
00:41:45,656 --> 00:41:46,896
We do want to be full-screen.

1401
00:41:47,226 --> 00:41:49,496
If your content does not

1402
00:41:49,496 --> 00:41:51,256
actually match the aspect ratio

1403
00:41:51,256 --> 00:41:52,436
of the display it is okay to put

1404
00:41:52,436 --> 00:41:53,896
a full-screen, opaque, black

1405
00:41:53,896 --> 00:41:55,016
background layer to sort of give

1406
00:41:55,016 --> 00:41:56,396
a black bar kind of effect.

1407
00:41:56,396 --> 00:41:57,216
But in the end we want to

1408
00:41:57,216 --> 00:41:58,516
basically obscure everything.

1409
00:42:01,456 --> 00:42:02,656
We do want to pick render

1410
00:42:02,656 --> 00:42:03,636
resolutions that match the

1411
00:42:03,636 --> 00:42:04,306
native panel.

1412
00:42:05,176 --> 00:42:06,416
So this is actually a little bit

1413
00:42:06,416 --> 00:42:07,616
tricky because all of our --

1414
00:42:07,616 --> 00:42:09,056
both on macOS and iOS we ship

1415
00:42:09,056 --> 00:42:10,556
hardware that has a virtual

1416
00:42:10,556 --> 00:42:12,446
desktop modes or resolution

1417
00:42:12,446 --> 00:42:13,696
modes that are larger than the

1418
00:42:13,696 --> 00:42:14,676
actual physical panel.

1419
00:42:14,766 --> 00:42:16,216
And the last thing we want to do

1420
00:42:16,216 --> 00:42:17,356
is spend time rendering too many

1421
00:42:17,356 --> 00:42:18,256
pixels only to have to spend

1422
00:42:18,286 --> 00:42:19,456
time on the GPU to scale it all

1423
00:42:19,456 --> 00:42:19,976
back down again.

1424
00:42:24,466 --> 00:42:25,846
And finally, you want to pick a

1425
00:42:25,846 --> 00:42:26,976
color, space, and pixel format

1426
00:42:26,976 --> 00:42:28,046
that the display hardware is

1427
00:42:28,046 --> 00:42:29,186
happy to read from directly.

1428
00:42:30,116 --> 00:42:31,126
And so this one, there's any

1429
00:42:31,126 --> 00:42:32,216
infinite number of combinations

1430
00:42:32,216 --> 00:42:33,986
here so I want to help out by

1431
00:42:33,986 --> 00:42:34,656
giving you a little bit of a

1432
00:42:34,656 --> 00:42:35,986
white list of some particularly

1433
00:42:35,986 --> 00:42:36,916
common and efficient

1434
00:42:36,916 --> 00:42:37,576
combinations.

1435
00:42:39,926 --> 00:42:41,596
So right on the top is our good

1436
00:42:41,596 --> 00:42:44,556
old friend; SRGB8888.

1437
00:42:44,556 --> 00:42:45,496
This is pretty much the

1438
00:42:45,496 --> 00:42:46,986
universal pixel format that most

1439
00:42:46,986 --> 00:42:48,806
applications use and all

1440
00:42:48,806 --> 00:42:50,626
hardware is happy to read.

1441
00:42:50,626 --> 00:42:51,776
And so for most people that's

1442
00:42:51,776 --> 00:42:52,196
all they need.

1443
00:42:53,666 --> 00:42:55,876
But we've been shipping wide

1444
00:42:55,876 --> 00:42:58,096
color gamut P3 displays on both

1445
00:42:58,096 --> 00:43:00,806
our macOS and iOS hardware and

1446
00:42:58,096 --> 00:43:00,806
our macOS and iOS hardware and

1447
00:43:01,106 --> 00:43:02,246
if your application does want to

1448
00:43:02,246 --> 00:43:03,766
start making use of this ability

1449
00:43:03,766 --> 00:43:04,926
to represent more colors, you

1450
00:43:04,926 --> 00:43:06,016
need to pay a bit more

1451
00:43:06,016 --> 00:43:06,396
attention.

1452
00:43:06,396 --> 00:43:09,676
In both the -- the concepts are

1453
00:43:09,676 --> 00:43:11,086
the same between iOS and macOS,

1454
00:43:11,086 --> 00:43:11,996
although the details differ a

1455
00:43:11,996 --> 00:43:13,316
little bit.

1456
00:43:13,316 --> 00:43:14,686
In both cases we do want to

1457
00:43:14,686 --> 00:43:15,846
render to attend the pixel

1458
00:43:17,266 --> 00:43:20,106
format, but note that if you

1459
00:43:20,106 --> 00:43:21,566
render P3 content onto a P3

1460
00:43:21,566 --> 00:43:23,286
display that's fine, but if you

1461
00:43:23,286 --> 00:43:25,686
render P3 content onto an SRGB

1462
00:43:25,686 --> 00:43:28,166
display the system -- the GP

1463
00:43:28,166 --> 00:43:29,266
compositer might have to get

1464
00:43:29,266 --> 00:43:30,326
involved to crush the color

1465
00:43:30,326 --> 00:43:31,426
space back down to fit the

1466
00:43:31,426 --> 00:43:31,796
display.

1467
00:43:32,706 --> 00:43:34,206
And so this is -- P3 is not

1468
00:43:34,206 --> 00:43:34,816
something you want to do

1469
00:43:34,816 --> 00:43:35,996
universally, all the time.

1470
00:43:36,106 --> 00:43:37,166
you do want to take a look at

1471
00:43:37,226 --> 00:43:39,466
the current display and make

1472
00:43:39,466 --> 00:43:40,616
this a conditional thing.

1473
00:43:40,986 --> 00:43:43,356
So finally, for completeness I'm

1474
00:43:43,356 --> 00:43:44,726
also going to list RGBA float

1475
00:43:44,726 --> 00:43:45,866
16, which is sort of the

1476
00:43:45,866 --> 00:43:48,116
universal, wide gamut, high

1477
00:43:48,116 --> 00:43:49,406
dynamic range pixel format.

1478
00:43:49,956 --> 00:43:52,086
Although, in -- I do -- it's

1479
00:43:52,086 --> 00:43:53,266
also necessary for MacOS's

1480
00:43:53,266 --> 00:43:54,466
extended data range feature.

1481
00:43:55,196 --> 00:43:56,076
Although it is worth noting that

1482
00:43:56,076 --> 00:43:57,476
it does require GPU compositing

1483
00:43:57,476 --> 00:43:57,976
in all cases.

1484
00:44:01,646 --> 00:44:02,566
So I mentioned, you do want to

1485
00:44:02,566 --> 00:44:03,776
be a little bit conditional if

1486
00:44:03,776 --> 00:44:04,716
you write an application that's

1487
00:44:04,716 --> 00:44:05,586
wide color aware.

1488
00:44:06,376 --> 00:44:07,776
Fortunately, both UIKit and

1489
00:44:07,776 --> 00:44:08,596
AppKit provide really convenient

1490
00:44:08,596 --> 00:44:08,976
APIs to check that.

1491
00:44:13,256 --> 00:44:14,786
So the last step is, how do you

1492
00:44:14,786 --> 00:44:16,056
know if you're actually on the

1493
00:44:16,056 --> 00:44:17,646
directed display path?

1494
00:44:17,646 --> 00:44:18,676
So this is a screen shot of our

1495
00:44:18,676 --> 00:44:19,966
Metal system trace tool and

1496
00:44:19,966 --> 00:44:20,566
instruments.

1497
00:44:20,676 --> 00:44:23,376
And Metal system trace is pretty

1498
00:44:23,426 --> 00:44:25,006
much a developer tool that will

1499
00:44:25,006 --> 00:44:26,656
give you a live timeline of the

1500
00:44:26,656 --> 00:44:27,886
CPU and the GPU in the display.

1501
00:44:28,216 --> 00:44:30,106
Pretty much a real-world version

1502
00:44:30,106 --> 00:44:30,996
of the diagrams I've been

1503
00:44:30,996 --> 00:44:31,636
showing you in this

1504
00:44:31,636 --> 00:44:32,236
presentation.

1505
00:44:33,396 --> 00:44:35,216
So in this case, I want to

1506
00:44:35,216 --> 00:44:36,596
highlight my three frames that

1507
00:44:36,596 --> 00:44:37,016
I've rendered.

1508
00:44:37,546 --> 00:44:39,106
The color-time intervals are my

1509
00:44:39,106 --> 00:44:40,126
own application's rendering.

1510
00:44:41,296 --> 00:44:42,716
And the gray time intervals are

1511
00:44:42,716 --> 00:44:44,446
some other processes in the GPU.

1512
00:44:44,496 --> 00:44:46,806
I can get more details down at

1513
00:44:46,806 --> 00:44:47,666
the bottom of the window or I

1514
00:44:47,666 --> 00:44:48,306
can see it's coming from

1515
00:44:48,306 --> 00:44:50,836
backboard D, our iOS composition

1516
00:44:50,836 --> 00:44:51,406
process.

1517
00:44:51,596 --> 00:44:52,606
So this is the case where my

1518
00:44:52,606 --> 00:44:53,676
application is going down the

1519
00:44:53,676 --> 00:44:55,946
GPU compositing path.

1520
00:44:55,946 --> 00:44:56,896
Going back and revisiting some

1521
00:44:56,896 --> 00:44:59,166
of our best practices can remove

1522
00:44:59,166 --> 00:45:00,486
that from the picture and now I

1523
00:44:59,166 --> 00:45:00,486
that from the picture and now I

1524
00:45:00,486 --> 00:45:02,116
can rerun my Metal system trace

1525
00:45:02,556 --> 00:45:04,026
and see that I have a timeline

1526
00:45:04,026 --> 00:45:05,626
where, you know I've got the GPU

1527
00:45:05,716 --> 00:45:06,616
completely and entirely to

1528
00:45:06,616 --> 00:45:06,976
myself.

1529
00:45:10,046 --> 00:45:12,006
So that's it for direct to

1530
00:45:12,146 --> 00:45:12,756
display.

1531
00:45:12,756 --> 00:45:14,086
Our system compositors can make

1532
00:45:14,086 --> 00:45:15,406
a lot of magic happen behind the

1533
00:45:15,406 --> 00:45:16,746
scenes to make full-featured

1534
00:45:16,746 --> 00:45:18,626
user interfaces possible, but

1535
00:45:18,626 --> 00:45:19,706
that can come at a performance

1536
00:45:19,706 --> 00:45:20,976
cost because they use the GPU to

1537
00:45:20,976 --> 00:45:21,426
do it.

1538
00:45:22,396 --> 00:45:23,456
By being a little bit aware of

1539
00:45:23,456 --> 00:45:24,036
what you're asking the

1540
00:45:24,036 --> 00:45:25,536
compositer to do, or more

1541
00:45:25,536 --> 00:45:26,896
importantly by not asking what

1542
00:45:26,896 --> 00:45:28,186
you're not asking the compositer

1543
00:45:28,186 --> 00:45:30,046
to do, it can get out of the way

1544
00:45:30,046 --> 00:45:31,816
without using the GPU, returning

1545
00:45:31,816 --> 00:45:32,766
some of that time to you.

1546
00:45:33,496 --> 00:45:35,536
Direct to display is supported

1547
00:45:35,536 --> 00:45:37,046
on iOS and Tos and always has

1548
00:45:37,046 --> 00:45:39,056
been and its support is new to

1549
00:45:39,056 --> 00:45:40,356
macOS High Sierra for Metal

1550
00:45:40,356 --> 00:45:40,976
applications.

1551
00:45:45,366 --> 00:45:46,536
So with that I want to touch on

1552
00:45:46,536 --> 00:45:48,136
our last topic of the day and

1553
00:45:48,136 --> 00:45:50,576
that's everything else.

1554
00:45:50,616 --> 00:45:51,716
There's a lot more that we've

1555
00:45:51,716 --> 00:45:52,826
added to the core frameworks and

1556
00:45:52,826 --> 00:45:54,056
sheeting language for Metal 2.

1557
00:45:54,056 --> 00:45:55,306
And so I'm not going to dive

1558
00:45:55,306 --> 00:45:56,226
deep into any of these things,

1559
00:45:56,226 --> 00:45:56,896
but I do want to give you a

1560
00:45:56,896 --> 00:45:57,236
survey.

1561
00:45:57,716 --> 00:46:01,036
So right off the bat we've added

1562
00:45:57,716 --> 00:46:01,036
So right off the bat we've added

1563
00:46:01,036 --> 00:46:02,026
some new APIs to be able to

1564
00:46:02,026 --> 00:46:03,916
query how much GPU memory's

1565
00:46:03,916 --> 00:46:05,316
being allocated for each buffer,

1566
00:46:05,316 --> 00:46:06,446
for each texture, for each Heap.

1567
00:46:06,736 --> 00:46:08,996
This actually takes into account

1568
00:46:08,996 --> 00:46:09,576
things that just generally

1569
00:46:09,576 --> 00:46:10,666
happen behind the scenes, like

1570
00:46:10,666 --> 00:46:12,496
alignment and various padding.

1571
00:46:13,156 --> 00:46:13,996
So this can give you a more

1572
00:46:13,996 --> 00:46:15,356
accurate view of how much GPU

1573
00:46:15,356 --> 00:46:16,586
memory you're actually using.

1574
00:46:16,586 --> 00:46:19,466
We also have a roll-up query on

1575
00:46:19,466 --> 00:46:22,006
the Metal device, which is the

1576
00:46:22,006 --> 00:46:23,766
entire GPU memory usage for your

1577
00:46:23,766 --> 00:46:24,786
entire process.

1578
00:46:25,106 --> 00:46:26,716
And this is particularly notable

1579
00:46:26,716 --> 00:46:28,616
because that also counts all of

1580
00:46:28,616 --> 00:46:29,616
the memory that the driver needs

1581
00:46:29,616 --> 00:46:30,966
to allocate that's not otherwise

1582
00:46:30,966 --> 00:46:33,156
visible to you; things like

1583
00:46:33,156 --> 00:46:34,676
memory to put shader code in or

1584
00:46:34,676 --> 00:46:35,686
command buffers or anything

1585
00:46:35,686 --> 00:46:36,076
else.

1586
00:46:36,576 --> 00:46:37,516
So this can give you where

1587
00:46:37,516 --> 00:46:38,216
you're at relative -- you know

1588
00:46:38,216 --> 00:46:38,946
everything all in compared to

1589
00:46:38,946 --> 00:46:39,976
your memory usage target.

1590
00:46:43,736 --> 00:46:44,666
We have a couple compute

1591
00:46:44,666 --> 00:46:45,586
oriented additions.

1592
00:46:46,026 --> 00:46:47,246
The first of those is that we've

1593
00:46:47,246 --> 00:46:48,276
added a set of shading language

1594
00:46:48,276 --> 00:46:49,636
functions to help -- to allow

1595
00:46:49,636 --> 00:46:50,826
you to transfer data directly

1596
00:46:50,826 --> 00:46:51,976
between threads in a SIMD group.

1597
00:46:52,176 --> 00:46:54,306
If you're not familiar; GPU

1598
00:46:54,306 --> 00:46:55,526
hardware typically gains an

1599
00:46:55,746 --> 00:46:57,606
individual vertex fragment and

1600
00:46:57,606 --> 00:46:59,586
compute shader thread into SIMD

1601
00:46:59,586 --> 00:47:00,756
groups and executes them

1602
00:46:59,586 --> 00:47:00,756
groups and executes them

1603
00:47:00,756 --> 00:47:01,986
together for greater efficiency.

1604
00:47:02,536 --> 00:47:04,266
This are also called wayfrencer

1605
00:47:04,266 --> 00:47:04,726
[phonetic] warps.

1606
00:47:05,766 --> 00:47:07,386
Within a group these threads do

1607
00:47:07,386 --> 00:47:08,506
have some ability to directly

1608
00:47:08,506 --> 00:47:09,756
communicate without having to

1609
00:47:09,756 --> 00:47:10,796
load and store through memory.

1610
00:47:11,386 --> 00:47:13,126
They can read values directly

1611
00:47:13,126 --> 00:47:14,226
out of one thread's register and

1612
00:47:14,226 --> 00:47:15,096
write them to another thread's

1613
00:47:15,096 --> 00:47:15,666
register.

1614
00:47:15,796 --> 00:47:16,516
And that's what these new

1615
00:47:16,516 --> 00:47:17,506
standard library functions

1616
00:47:17,506 --> 00:47:17,816
allow.

1617
00:47:18,916 --> 00:47:21,516
So in this case broadcast means

1618
00:47:21,516 --> 00:47:22,756
I can read a data directly --

1619
00:47:22,856 --> 00:47:24,226
read a field directly out of

1620
00:47:24,226 --> 00:47:25,526
thread zero's registers and

1621
00:47:25,526 --> 00:47:26,406
write it directly into the

1622
00:47:26,406 --> 00:47:27,866
registers of 16 other threads

1623
00:47:27,866 --> 00:47:28,796
that happen to be part of this

1624
00:47:28,796 --> 00:47:28,976
group.

1625
00:47:33,146 --> 00:47:34,606
Our second compute addition is

1626
00:47:34,606 --> 00:47:35,776
to give you more flexibility in

1627
00:47:35,776 --> 00:47:37,086
how big your thread groups are.

1628
00:47:37,936 --> 00:47:39,576
So for example if I have a pixel

1629
00:47:39,576 --> 00:47:40,556
bird here that I want to run

1630
00:47:40,556 --> 00:47:41,916
some pretty classic image

1631
00:47:41,916 --> 00:47:44,866
processing kernel over, but then

1632
00:47:44,866 --> 00:47:45,936
I've written my compute kernel

1633
00:47:45,936 --> 00:47:47,666
such that I'm using four by four

1634
00:47:47,716 --> 00:47:48,516
thread groups everywhere.

1635
00:47:49,906 --> 00:47:50,936
Well, this leads to some

1636
00:47:50,936 --> 00:47:52,246
problems because I've got -- if

1637
00:47:52,246 --> 00:47:53,716
my image is not a nice multiple

1638
00:47:53,716 --> 00:47:55,056
of my thread group size I've got

1639
00:47:55,056 --> 00:47:56,066
a bunch of stray threads on the

1640
00:47:56,066 --> 00:47:56,396
side.

1641
00:47:57,056 --> 00:47:59,766
I mean this means that I've got

1642
00:47:59,766 --> 00:48:01,726
to dive into those and say when

1643
00:47:59,766 --> 00:48:01,726
to dive into those and say when

1644
00:48:01,726 --> 00:48:02,546
I actually write my code.

1645
00:48:02,546 --> 00:48:03,466
I have to be defensive.

1646
00:48:03,466 --> 00:48:04,326
Am I out of bounds?

1647
00:48:04,326 --> 00:48:05,146
I have to handle it in some

1648
00:48:05,146 --> 00:48:05,736
special way.

1649
00:48:05,736 --> 00:48:07,136
It's doable but annoying.

1650
00:48:07,976 --> 00:48:09,006
It also means that we're just

1651
00:48:09,006 --> 00:48:10,126
wasting GPU cycles.

1652
00:48:10,646 --> 00:48:12,926
So non-uniform thread group

1653
00:48:12,926 --> 00:48:14,536
sizes, unless you declare what

1654
00:48:14,536 --> 00:48:15,476
dimensions you want to run your

1655
00:48:15,476 --> 00:48:16,896
kernel over, without being

1656
00:48:16,896 --> 00:48:18,136
multiple thread group sizes.

1657
00:48:18,736 --> 00:48:20,156
So the hard working, smaller

1658
00:48:20,156 --> 00:48:21,766
thread groups along the edges of

1659
00:48:21,766 --> 00:48:23,536
my grid, in order to say -- in

1660
00:48:23,536 --> 00:48:24,466
order to just shave off that

1661
00:48:24,466 --> 00:48:26,006
unnecessary work it both

1662
00:48:26,096 --> 00:48:28,456
improves GPU performance and

1663
00:48:28,456 --> 00:48:29,556
just makes your kernels easier

1664
00:48:29,556 --> 00:48:29,976
to write.

1665
00:48:34,236 --> 00:48:35,206
We've added support for a view

1666
00:48:35,206 --> 00:48:35,896
port arrays.

1667
00:48:36,206 --> 00:48:37,736
You can now configure up to 16

1668
00:48:37,736 --> 00:48:39,396
simultaneous view ports and your

1669
00:48:39,396 --> 00:48:41,146
vertex shader can select, per

1670
00:48:41,146 --> 00:48:42,776
triangle, which view port that

1671
00:48:42,776 --> 00:48:43,916
triangle gets presented into.

1672
00:48:44,626 --> 00:48:45,596
I'm not going to go further into

1673
00:48:45,596 --> 00:48:46,256
this because it will be

1674
00:48:46,256 --> 00:48:48,026
discussed in detail tomorrow in

1675
00:48:48,026 --> 00:48:49,176
the VR with Metal 2 session.

1676
00:48:49,546 --> 00:48:50,546
It is particularly valuable for

1677
00:48:50,546 --> 00:48:51,346
efficiently rendering to the

1678
00:48:51,346 --> 00:48:51,976
left and right eyes.

1679
00:48:56,666 --> 00:48:57,476
We've added the ability to

1680
00:48:57,476 --> 00:48:59,126
choose where in each pixel your

1681
00:48:59,126 --> 00:49:00,076
multi-sample locations are

1682
00:48:59,126 --> 00:49:00,076
multi-sample locations are

1683
00:49:00,076 --> 00:49:00,606
supported.

1684
00:49:01,566 --> 00:49:02,776
This lets you do a few

1685
00:49:02,776 --> 00:49:04,356
interesting things including

1686
00:49:04,356 --> 00:49:05,366
maybe toggling your sample

1687
00:49:05,366 --> 00:49:07,256
positions every other frame and

1688
00:49:07,256 --> 00:49:08,396
giving you some new -- you know

1689
00:49:08,396 --> 00:49:09,376
valuable input into some

1690
00:49:09,376 --> 00:49:10,386
temporal anti-aliasing

1691
00:49:10,386 --> 00:49:11,066
algorithms.

1692
00:49:15,716 --> 00:49:17,206
In the vein of trying to keep --

1693
00:49:17,266 --> 00:49:18,726
of working to bring our

1694
00:49:18,726 --> 00:49:19,756
platforms up to date to have

1695
00:49:19,806 --> 00:49:20,816
them have the same feature set

1696
00:49:20,816 --> 00:49:21,856
wherever possible, we've brought

1697
00:49:21,856 --> 00:49:23,356
resource Heaps, shipped last

1698
00:49:23,356 --> 00:49:25,586
year in iOS 10 to macOS High

1699
00:49:25,586 --> 00:49:26,366
Sierra this year.

1700
00:49:26,616 --> 00:49:28,826
So I'm going to actually do a

1701
00:49:28,826 --> 00:49:29,926
little bit of a refresher on

1702
00:49:29,926 --> 00:49:32,196
this because good use of your

1703
00:49:32,196 --> 00:49:33,906
Heaps is really important to

1704
00:49:33,906 --> 00:49:34,816
getting the most out of argument

1705
00:49:34,816 --> 00:49:35,246
buffers.

1706
00:49:36,606 --> 00:49:37,986
So Heaps are of course where I

1707
00:49:37,986 --> 00:49:38,896
can allocate a big slab of

1708
00:49:38,896 --> 00:49:40,786
memory up front rather than

1709
00:49:40,786 --> 00:49:42,416
going to the kernel to -- I want

1710
00:49:42,506 --> 00:49:43,926
memory for texture a, and I want

1711
00:49:43,926 --> 00:49:45,046
memory for texture b and so

1712
00:49:45,046 --> 00:49:45,416
forth.

1713
00:49:45,826 --> 00:49:46,896
I can go to the kernel and get

1714
00:49:46,896 --> 00:49:49,036
memory right up front and of

1715
00:49:49,036 --> 00:49:50,626
course put textures -- you know

1716
00:49:50,626 --> 00:49:51,556
add and remove textures and

1717
00:49:51,556 --> 00:49:52,906
buffers to -- without having to

1718
00:49:52,976 --> 00:49:55,396
go back to the system.

1719
00:49:55,466 --> 00:49:56,766
This has a few advantages.

1720
00:49:56,946 --> 00:49:58,206
It means that I can bind

1721
00:49:58,206 --> 00:49:59,116
everything in that Heap much

1722
00:49:59,116 --> 00:49:59,726
more efficiently.

1723
00:49:59,916 --> 00:50:00,666
There's much less software

1724
00:49:59,916 --> 00:50:00,666
There's much less software

1725
00:50:00,666 --> 00:50:01,026
overhead.

1726
00:50:01,786 --> 00:50:02,966
It means that we can oftentimes

1727
00:50:02,966 --> 00:50:03,936
pack that memory a little bit

1728
00:50:03,936 --> 00:50:04,466
closer together.

1729
00:50:04,466 --> 00:50:05,536
We can save some padding and

1730
00:50:05,536 --> 00:50:06,686
alignment, save you a little bit

1731
00:50:06,686 --> 00:50:07,056
of memory.

1732
00:50:08,096 --> 00:50:10,116
It means when we delete memory

1733
00:50:10,426 --> 00:50:11,816
we don't give memory back to the

1734
00:50:11,816 --> 00:50:12,236
system.

1735
00:50:12,576 --> 00:50:13,296
That could be good or bad.

1736
00:50:13,996 --> 00:50:15,666
It means when we allocate new

1737
00:50:15,666 --> 00:50:16,526
memory -- when we allocate a new

1738
00:50:16,526 --> 00:50:17,676
texture it means we don't have

1739
00:50:17,676 --> 00:50:18,656
to go back to the system and get

1740
00:50:18,656 --> 00:50:18,976
new memory.

1741
00:50:22,476 --> 00:50:23,386
It also means that you can

1742
00:50:23,386 --> 00:50:24,916
choose to alias these textures

1743
00:50:24,916 --> 00:50:25,476
with each other.

1744
00:50:26,256 --> 00:50:27,606
If I have -- you typically

1745
00:50:27,606 --> 00:50:29,456
render targets or intermediate

1746
00:50:29,456 --> 00:50:31,126
render targets between different

1747
00:50:31,126 --> 00:50:32,666
passes in my render graph.

1748
00:50:33,076 --> 00:50:34,176
It means that if I have two

1749
00:50:34,176 --> 00:50:34,886
different intermediates that

1750
00:50:34,886 --> 00:50:36,616
just don't have to exist at the

1751
00:50:36,616 --> 00:50:37,966
same point in time I can alias

1752
00:50:37,966 --> 00:50:38,926
them over each other and I can

1753
00:50:38,926 --> 00:50:43,416
save tons of memory like this.

1754
00:50:44,096 --> 00:50:46,066
So that's it for a quick survey

1755
00:50:46,866 --> 00:50:47,906
of Heaps.

1756
00:50:47,996 --> 00:50:50,196
We've added linear textures from

1757
00:50:50,386 --> 00:50:52,056
iOS to macOS.

1758
00:50:52,296 --> 00:50:53,366
Linear textures allows you to

1759
00:50:53,366 --> 00:50:55,146
create a texture directly from a

1760
00:50:55,146 --> 00:50:56,736
Metal buffer without any copies

1761
00:50:56,786 --> 00:50:57,216
at all.

1762
00:50:59,306 --> 00:51:00,266
We've extended our function

1763
00:50:59,306 --> 00:51:00,266
We've extended our function

1764
00:51:00,266 --> 00:51:01,736
constant feature a little bit.

1765
00:51:01,736 --> 00:51:02,766
A quick refresher, function

1766
00:51:02,766 --> 00:51:03,656
constants allow you to

1767
00:51:03,656 --> 00:51:04,886
specialize by codes.

1768
00:51:05,026 --> 00:51:05,926
When you've done all your front

1769
00:51:05,926 --> 00:51:07,466
end compilation offline you can

1770
00:51:07,466 --> 00:51:08,636
then tweak and customize your

1771
00:51:08,636 --> 00:51:09,886
uber shader bi-code a little bit

1772
00:51:10,106 --> 00:51:11,296
before actual generating final

1773
00:51:11,296 --> 00:51:11,856
machine code.

1774
00:51:12,716 --> 00:51:14,046
If you have a classic uber

1775
00:51:14,046 --> 00:51:15,156
shader this can save you the

1776
00:51:15,156 --> 00:51:16,206
cost of having to re-run the

1777
00:51:16,206 --> 00:51:17,836
compiler front end for every

1778
00:51:17,836 --> 00:51:18,726
single permutation.

1779
00:51:19,806 --> 00:51:21,016
So we've made this a bit more

1780
00:51:21,016 --> 00:51:22,546
flexible and added a few more

1781
00:51:22,546 --> 00:51:25,136
cases where you can use these

1782
00:51:25,246 --> 00:51:26,286
specialized arguments.

1783
00:51:28,046 --> 00:51:29,106
We've added some extra vertex

1784
00:51:29,106 --> 00:51:29,796
array formats.

1785
00:51:29,826 --> 00:51:31,196
We had some missing one and two

1786
00:51:31,196 --> 00:51:32,396
component vertex formats.

1787
00:51:32,546 --> 00:51:34,366
And we've also added BGRA vertex

1788
00:51:34,366 --> 00:51:34,916
formats.

1789
00:51:37,576 --> 00:51:38,616
We've brought iOS surface

1790
00:51:38,616 --> 00:51:40,306
texture support from macOS to

1791
00:51:40,436 --> 00:51:40,846
iOS.

1792
00:51:40,846 --> 00:51:42,716
And we've also brought dual

1793
00:51:42,716 --> 00:51:44,156
sourced blending to iOS as well,

1794
00:51:44,446 --> 00:51:46,666
also particularly useful in some

1795
00:51:46,666 --> 00:51:47,926
deferred shading scenarios.

1796
00:51:50,706 --> 00:51:52,756
So that's -- brings us to the

1797
00:51:52,756 --> 00:51:56,086
end of introducing Metal 2.

1798
00:51:56,166 --> 00:51:57,586
My colleague, Michal, started

1799
00:51:57,586 --> 00:51:58,976
with giving you a little bit of

1800
00:51:58,976 --> 00:52:00,266
an overview of the overall scope

1801
00:51:58,976 --> 00:52:00,266
an overview of the overall scope

1802
00:52:00,266 --> 00:52:00,806
of Metal 2.

1803
00:52:01,126 --> 00:52:03,686
From VR to external GPUs, to

1804
00:52:04,056 --> 00:52:05,206
machine learning, and to new

1805
00:52:05,206 --> 00:52:06,886
developer tools and performance

1806
00:52:07,306 --> 00:52:08,026
analysis.

1807
00:52:08,026 --> 00:52:08,986
Of that, the pieces that we

1808
00:52:08,986 --> 00:52:10,936
really covered today are our

1809
00:52:10,936 --> 00:52:12,456
next big push toward reducing

1810
00:52:12,576 --> 00:52:13,926
CPU overhead using argument

1811
00:52:13,926 --> 00:52:14,386
buffers.

1812
00:52:15,006 --> 00:52:16,506
Argument buffers also unlock the

1813
00:52:16,506 --> 00:52:17,856
ability for the GPU to start

1814
00:52:17,886 --> 00:52:18,956
taking a little bit of its own

1815
00:52:18,956 --> 00:52:19,866
destiny when it comes to

1816
00:52:19,866 --> 00:52:21,126
configuring shader arguments,

1817
00:52:21,126 --> 00:52:22,536
which is one less reason to take

1818
00:52:22,536 --> 00:52:24,676
back to the CPU.

1819
00:52:25,586 --> 00:52:27,356
Raster Order Groups let us start

1820
00:52:27,356 --> 00:52:28,666
using the rasterizer for things

1821
00:52:28,666 --> 00:52:30,186
beyond basic in order blending.

1822
00:52:31,356 --> 00:52:32,476
We can now start taking

1823
00:52:32,476 --> 00:52:34,056
advantage of the latest hardware

1824
00:52:34,056 --> 00:52:36,566
capabilities to do, you know,

1825
00:52:36,566 --> 00:52:38,386
vox slice triangle meshes or set

1826
00:52:38,616 --> 00:52:40,316
transparency blending either in

1827
00:52:40,316 --> 00:52:41,226
order or independent.

1828
00:52:41,296 --> 00:52:42,216
They're both -- it makes them

1829
00:52:42,216 --> 00:52:42,816
both possible.

1830
00:52:44,016 --> 00:52:46,656
For the new iPad Pros, ProMotion

1831
00:52:46,656 --> 00:52:47,726
gives you very fine grained

1832
00:52:47,726 --> 00:52:49,126
control over exactly how your

1833
00:52:49,126 --> 00:52:50,226
animations are presented to the

1834
00:52:50,226 --> 00:52:51,886
user, giving you the ability to

1835
00:52:51,886 --> 00:52:53,656
get both peak frame rates and

1836
00:52:53,656 --> 00:52:54,736
the lowest possible latency.

1837
00:52:55,136 --> 00:52:57,736
Direct to display provides you a

1838
00:52:57,736 --> 00:52:59,116
path to reclaim a little bit of

1839
00:52:59,116 --> 00:53:00,436
GPU performance from the system

1840
00:52:59,116 --> 00:53:00,436
GPU performance from the system

1841
00:53:00,526 --> 00:53:01,706
by being aware of what our

1842
00:53:01,706 --> 00:53:02,956
compositors do on your behalf.

1843
00:53:06,336 --> 00:53:07,536
So you'll be able to find the

1844
00:53:07,536 --> 00:53:08,426
video and the slides for this

1845
00:53:08,426 --> 00:53:11,216
session on the WWDC2017 website.

1846
00:53:11,876 --> 00:53:15,096
We have three other sessions on

1847
00:53:15,096 --> 00:53:15,996
Metal 2 this year.

1848
00:53:16,596 --> 00:53:18,536
In particular, tomorrow

1849
00:53:18,536 --> 00:53:19,456
afternoon we're going to have a

1850
00:53:19,456 --> 00:53:20,696
session dedicated to VR and

1851
00:53:20,696 --> 00:53:21,136
Metal 2.

1852
00:53:21,326 --> 00:53:22,886
This is going to go deep into

1853
00:53:22,886 --> 00:53:24,706
what your application needs to

1854
00:53:24,706 --> 00:53:26,456
do and a conceptual overview of

1855
00:53:26,456 --> 00:53:28,426
how to do VR rendering, dive

1856
00:53:28,426 --> 00:53:30,056
into specifically how to do VR

1857
00:53:30,056 --> 00:53:32,106
with the combination of Metal 2

1858
00:53:32,106 --> 00:53:34,076
and the Steam VR toolkit.

1859
00:53:34,076 --> 00:53:36,086
It's also going to go into using

1860
00:53:36,086 --> 00:53:37,326
Metal with external GPU

1861
00:53:37,326 --> 00:53:37,736
hardware.

1862
00:53:39,666 --> 00:53:40,376
On Thursday we have a

1863
00:53:40,376 --> 00:53:42,286
doubleheader starting with Metal

1864
00:53:42,286 --> 00:53:43,676
2 optimization and debugging.

1865
00:53:43,996 --> 00:53:45,716
This is going to go into what's

1866
00:53:45,716 --> 00:53:46,726
new in our developer and

1867
00:53:46,726 --> 00:53:48,106
performance tools and all the

1868
00:53:48,106 --> 00:53:49,376
new workflows that enables to

1869
00:53:49,376 --> 00:53:50,086
help you build the best

1870
00:53:50,086 --> 00:53:51,076
applications possible.

1871
00:53:51,286 --> 00:53:52,826
And it's going to be followed up

1872
00:53:52,826 --> 00:53:54,336
right after that with using

1873
00:53:54,336 --> 00:53:55,276
Metal 2 for compute.

1874
00:53:55,656 --> 00:53:57,126
And that's going to really have

1875
00:53:57,126 --> 00:53:58,896
a big focus this year on using

1876
00:53:58,896 --> 00:54:00,206
the GPU for machine learning

1877
00:53:58,896 --> 00:54:00,206
the GPU for machine learning

1878
00:54:00,206 --> 00:54:00,916
applications.

1879
00:54:00,916 --> 00:54:01,946
We've added a whole lot this

1880
00:54:01,946 --> 00:54:03,806
year and we want to show you

1881
00:54:03,806 --> 00:54:05,166
everything we've done.

1882
00:54:07,206 --> 00:54:08,386
I want to point you to a couple

1883
00:54:08,426 --> 00:54:10,206
of last year's WWDC sessions.

1884
00:54:11,286 --> 00:54:12,626
The first, What's New in Metal

1885
00:54:12,626 --> 00:54:14,186
Part One is where we did a deep

1886
00:54:14,186 --> 00:54:15,786
dive on resource Heaps.

1887
00:54:16,196 --> 00:54:17,146
And instead if you're looking to

1888
00:54:17,146 --> 00:54:18,026
get the best performance out of

1889
00:54:18,026 --> 00:54:19,836
argument buffers, argument

1890
00:54:19,836 --> 00:54:20,936
buffers and Heaps were built to

1891
00:54:20,936 --> 00:54:22,716
go together and so I highly

1892
00:54:22,716 --> 00:54:23,836
encourage you to go check out

1893
00:54:23,836 --> 00:54:26,336
the video and really -- and, you

1894
00:54:26,436 --> 00:54:28,416
know basically plan your

1895
00:54:28,416 --> 00:54:29,326
application around both of those

1896
00:54:29,326 --> 00:54:29,686
together.

1897
00:54:29,756 --> 00:54:31,196
They cover that in a lot more

1898
00:54:31,196 --> 00:54:32,516
detail than we did here today.

1899
00:54:34,056 --> 00:54:36,016
Second, if the conversation

1900
00:54:36,016 --> 00:54:38,076
about direct to display and wide

1901
00:54:38,076 --> 00:54:39,436
gamut and wide color interested

1902
00:54:39,436 --> 00:54:40,996
you we have a whole session that

1903
00:54:40,996 --> 00:54:41,916
really goes deep into the

1904
00:54:41,916 --> 00:54:43,066
concepts and the specifics

1905
00:54:43,066 --> 00:54:44,066
behind that, we also talked

1906
00:54:44,066 --> 00:54:44,656
about last year.

1907
00:54:45,706 --> 00:54:47,676
With that I think we'll wrap it

1908
00:54:47,676 --> 00:54:47,796
up.

1909
00:54:47,796 --> 00:54:48,886
I thank you for all attending

1910
00:54:48,886 --> 00:54:49,596
and I hope you enjoy the

1911
00:54:49,596 --> 00:54:50,266
remainder of your week.

1912
00:54:50,266 --> 00:54:50,906
So thank you.

1913
00:54:51,516 --> 00:54:55,500
[ Applause ]
