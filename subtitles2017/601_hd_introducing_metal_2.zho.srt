1
00:00:21,516 --> 00:00:27,956
[ 掌声 ]

2
00:00:28,456 --> 00:00:28,916
&gt;&gt; 欢迎

3
00:00:29,436 --> 00:00:30,996
我们结合 Metal 2

4
00:00:30,996 --> 00:00:32,576
推出了许多

5
00:00:32,856 --> 00:00:34,846
新的技术 能让你们制作

6
00:00:35,116 --> 00:00:36,896
更好 更快 

7
00:00:36,896 --> 00:00:37,706
更有效率的应用

8
00:00:38,206 --> 00:00:39,396
我是 Michal

9
00:00:39,396 --> 00:00:40,856
我和我的同事 Richard

10
00:00:40,856 --> 00:00:42,756
今天将给大家介绍三个主题

11
00:00:44,546 --> 00:00:46,546
通过使用 Metal2 

12
00:00:46,756 --> 00:00:48,656
我们将继续减少

13
00:00:48,656 --> 00:00:50,526
高代价操作的发生

14
00:00:50,526 --> 00:00:52,266
并确保

15
00:00:52,266 --> 00:00:54,376
常用的操作

16
00:00:54,376 --> 00:00:55,176
只花费很少的代价

17
00:00:55,656 --> 00:00:57,356
历年来 我们介绍过

18
00:00:57,646 --> 00:01:00,226
预编译着色器

19
00:00:57,646 --> 00:01:00,226
预编译着色器

20
00:01:00,226 --> 00:01:02,286
渲染状态对象和去年的 Metal 堆

21
00:01:02,286 --> 00:01:04,566
以保证你能将

22
00:01:04,566 --> 00:01:06,416
高代价的操作

23
00:01:06,576 --> 00:01:08,796
移除出你的

24
00:01:09,346 --> 00:01:09,446
主要应用循环

25
00:01:10,096 --> 00:01:13,836
通过将 open GL 换成 Metal

26
00:01:13,836 --> 00:01:15,886
我们能给你提供 10 倍多的

27
00:01:16,206 --> 00:01:16,696
绘图调用

28
00:01:17,616 --> 00:01:18,996
今年 我们将介绍

29
00:01:18,996 --> 00:01:21,496
新的绑定 API

30
00:01:21,496 --> 00:01:22,866
它能为你提供更多的功能

31
00:01:22,866 --> 00:01:24,426
因此我们将

32
00:01:24,426 --> 00:01:24,946
进一步介绍它

33
00:01:26,446 --> 00:01:29,006
通过 GPU 驱动流水线

34
00:01:29,006 --> 00:01:32,016
我们将进一步把 GPU 放在

35
00:01:32,016 --> 00:01:32,856
驱动的位置

36
00:01:33,426 --> 00:01:35,326
而通过在现代 GPU 上使用 Metal 2  

37
00:01:35,326 --> 00:01:37,966
你将可以创造新的算法

38
00:01:37,966 --> 00:01:40,316
新的绘制技术

39
00:01:40,926 --> 00:01:43,276
并获得完全独一无二的

40
00:01:43,276 --> 00:01:45,176
体验

41
00:01:45,546 --> 00:01:46,366
当然 说到体验

42
00:01:46,366 --> 00:01:49,096
我们在 Metal 里

43
00:01:49,096 --> 00:01:50,306
增加了很多新功能

44
00:01:50,306 --> 00:01:51,726
同时我们还有其他三个会议

45
00:01:51,726 --> 00:01:52,746
我非常希望大家能参加

46
00:01:53,586 --> 00:01:56,786
Mac 在今年迎来了 VR 技术 

47
00:01:56,786 --> 00:01:58,986
通过新的 iMac  我们将

48
00:01:58,986 --> 00:02:01,486
为你提供非常强大的 GPU	

49
00:01:58,986 --> 00:02:01,486
为你提供非常强大的 GPU	

50
00:02:01,976 --> 00:02:04,056
即将登陆 MacBook Pro 的

51
00:02:04,106 --> 00:02:05,646
外部 GPU 也将给你同样

52
00:02:05,646 --> 00:02:06,006
强大的功能

53
00:02:06,726 --> 00:02:09,166
这些都能让你的用户和

54
00:02:09,515 --> 00:02:11,566
你的内容创作者

55
00:02:11,566 --> 00:02:14,156
获得前所未有的

56
00:02:14,156 --> 00:02:14,936
VR 体验

57
00:02:15,576 --> 00:02:17,746
明天的会议将向你展示

58
00:02:18,486 --> 00:02:22,136
如何使用我们的

59
00:02:22,136 --> 00:02:23,876
直接显示技术

60
00:02:23,876 --> 00:02:25,996
来使你的内容快速并且

61
00:02:25,996 --> 00:02:26,846
低延迟地到达 HMD

62
00:02:28,176 --> 00:02:29,906
你将学到新的

63
00:02:29,906 --> 00:02:32,066
为了 VR 制作的 Metal API 版和新的

64
00:02:32,066 --> 00:02:33,066
工具版

65
00:02:35,856 --> 00:02:38,266
机器学习正非常迅速地

66
00:02:38,266 --> 00:02:40,296
在很多应用中成为

67
00:02:40,296 --> 00:02:42,076
我们设备的

68
00:02:42,076 --> 00:02:42,976
关键功能

69
00:02:42,976 --> 00:02:45,056
你可以用通过 Metal 2

70
00:02:45,056 --> 00:02:47,786
来使用 Metal 性能着色器

71
00:02:47,876 --> 00:02:49,726
并利用 GPU 的能力

72
00:02:49,726 --> 00:02:53,446
在测试中和

73
00:02:53,546 --> 00:02:54,536
移动设备上进行机器学习

74
00:02:55,376 --> 00:02:56,786
你可能正盯着

75
00:02:56,916 --> 00:02:58,256
我身后的图片

76
00:02:58,256 --> 00:02:59,486
在想 “这是怎么做到的？”

77
00:02:59,776 --> 00:03:01,316
我们有一个会议

78
00:02:59,776 --> 00:03:01,316
我们有一个会议

79
00:03:01,316 --> 00:03:03,776
将在周四举行

80
00:03:03,776 --> 00:03:05,416
从中你能学到这个以及

81
00:03:05,416 --> 00:03:07,256
机器学习原语

82
00:03:07,256 --> 00:03:08,796
也就是我们的 

83
00:03:09,036 --> 00:03:10,966
Metal 性能着色器里面的

84
00:03:10,966 --> 00:03:11,506
图像处理原语

85
00:03:13,036 --> 00:03:15,576
最后 在 Metal 2 引擎下

86
00:03:15,576 --> 00:03:17,566
我们的工具已经取得了

87
00:03:17,566 --> 00:03:18,146
重大的提升

88
00:03:18,256 --> 00:03:19,856
你将可以快速的

89
00:03:19,856 --> 00:03:21,006
对你的应用进行故障排查

90
00:03:21,556 --> 00:03:23,266
你能更容易的发现问题

91
00:03:23,686 --> 00:03:26,796
我们还将曝光一些东西

92
00:03:26,796 --> 00:03:28,226
例如 GPU 性能计数器

93
00:03:28,226 --> 00:03:29,866
以确保你能

94
00:03:29,866 --> 00:03:33,566
找到你的热点

95
00:03:33,566 --> 00:03:36,126
你的程序也将运行的更快

96
00:03:37,416 --> 00:03:39,786
好了 我希望我已经使你们

97
00:03:40,056 --> 00:03:41,946
为未来几天感到兴奋

98
00:03:41,946 --> 00:03:44,076
现在我们回到

99
00:03:44,076 --> 00:03:45,336
今天会议的

100
00:03:45,336 --> 00:03:45,866
内容

101
00:03:51,426 --> 00:03:53,576
我们将从参数缓冲器开始

102
00:03:53,576 --> 00:03:55,946
这也可能是我们今年

103
00:03:55,996 --> 00:03:57,686
在核心框架上增加的

104
00:03:57,686 --> 00:03:57,916
最重要的内容

105
00:03:58,716 --> 00:04:00,756
参数缓冲器能提供一个

106
00:03:58,716 --> 00:04:00,756
参数缓冲器能提供一个

107
00:04:00,756 --> 00:04:03,426
全新的高效方式来

108
00:04:03,426 --> 00:04:05,946
配置缓冲器 纹理和

109
00:04:06,416 --> 00:04:07,986
采样器  使你的应用能够使用

110
00:04:07,986 --> 00:04:11,356
被释放出来的

111
00:04:11,356 --> 00:04:13,246
可观的 CPU 资源

112
00:04:13,246 --> 00:04:15,026
并能使 GPU 

113
00:04:15,026 --> 00:04:16,366
真正同时运行

114
00:04:16,366 --> 00:04:17,086
全新的计划

115
00:04:18,196 --> 00:04:20,726
下面我们来谈谈光栅顺序组

116
00:04:20,726 --> 00:04:22,966
一种新的片段着色器

117
00:04:22,966 --> 00:04:24,516
同步原语

118
00:04:25,006 --> 00:04:26,856
它能让你

119
00:04:26,856 --> 00:04:28,566
精确的控制

120
00:04:28,786 --> 00:04:30,426
片段着色器接入公共存储器的顺序

121
00:04:30,426 --> 00:04:33,026
使得你能够使用

122
00:04:33,026 --> 00:04:34,726
例如

123
00:04:35,286 --> 00:04:37,186
MacOS 上的可编程混合

124
00:04:37,246 --> 00:04:41,466
或者体素化

125
00:04:41,516 --> 00:04:42,626
顺序无关的半透明渲染

126
00:04:43,466 --> 00:04:44,866
然后我们将话题转到

127
00:04:44,866 --> 00:04:46,656
显示上来  我们将谈到

128
00:04:46,656 --> 00:04:48,396
iPad 上全新的 ProMotion 显示器

129
00:04:48,396 --> 00:04:50,496
以及如何使用 Metal

130
00:04:50,496 --> 00:04:51,526
去运行它

131
00:04:51,526 --> 00:04:54,396
我们也将简要重述

132
00:04:54,446 --> 00:04:57,376
如何用最快的速度

133
00:04:57,376 --> 00:04:58,876
以及最少的延迟

134
00:04:58,876 --> 00:05:02,606
使你的内容

135
00:04:58,876 --> 00:05:02,606
使你的内容

136
00:05:02,606 --> 00:05:04,046
从渲染目标

137
00:05:04,046 --> 00:05:04,996
传递到眼镜上

138
00:05:05,576 --> 00:05:07,686
最后我们将以一个

139
00:05:08,106 --> 00:05:10,036
关于所有其他

140
00:05:10,036 --> 00:05:12,316
被我们加入到 iOS 和 MacOS 平台里

141
00:05:12,566 --> 00:05:15,436
以配合 Metal 生态系统的 Metal 功能调查

142
00:05:15,786 --> 00:05:16,976
结束今天的会议

143
00:05:22,336 --> 00:05:26,186
好的 关于参数缓冲器

144
00:05:26,536 --> 00:05:28,556
让我们来看看它们是什么

145
00:05:28,716 --> 00:05:29,266
以及它们如何运作的

146
00:05:29,316 --> 00:05:30,806
我将需要举个例子

147
00:05:30,806 --> 00:05:33,776
让我们想象一个简单的材料

148
00:05:33,776 --> 00:05:36,166
一个那些写过

149
00:05:36,166 --> 00:05:39,456
3D 渲染程序的人

150
00:05:39,456 --> 00:05:40,046
都会明白的材料

151
00:05:40,466 --> 00:05:42,326
在你的材料里有

152
00:05:42,326 --> 00:05:44,936
大量的数值常量

153
00:05:45,106 --> 00:05:46,236
大量的纹理

154
00:05:46,236 --> 00:05:47,416
以及多于每天两个的

155
00:05:47,466 --> 00:05:48,016
汇编程序

156
00:05:48,686 --> 00:05:53,196
而这就是你需要发送给

157
00:05:53,196 --> 00:05:54,726
GPU 来

158
00:05:54,726 --> 00:05:56,056
渲染你的原语的东西

159
00:05:56,516 --> 00:05:58,566
纹理对象很有趣

160
00:05:59,456 --> 00:06:01,026
因为他们

161
00:05:59,456 --> 00:06:01,026
因为他们

162
00:06:01,166 --> 00:06:03,506
不仅包含了纹理属性 例如

163
00:06:03,506 --> 00:06:06,626
宽 高 甚至还有像素格式

164
00:06:06,626 --> 00:06:08,866
它同时还包含了一个

165
00:06:08,866 --> 00:06:10,176
容纳所有美丽像素的

166
00:06:10,176 --> 00:06:11,196
内存的指针

167
00:06:11,196 --> 00:06:13,896
不幸的是 我们今天的会议

168
00:06:13,896 --> 00:06:14,766
对那些像素

169
00:06:14,766 --> 00:06:15,926
不是很感兴趣

170
00:06:15,926 --> 00:06:18,636
所以我们会放下它

171
00:06:18,636 --> 00:06:20,426
而仅仅讨论乏味的

172
00:06:20,426 --> 00:06:20,916
纹理状态

173
00:06:22,156 --> 00:06:24,456
传统的参数模型

174
00:06:24,456 --> 00:06:26,566
允许你将所有的

175
00:06:26,566 --> 00:06:29,106
常量放在 Metal 缓存器中

176
00:06:29,106 --> 00:06:30,216
然后我们创建这个

177
00:06:30,216 --> 00:06:32,126
间接方式 这样你能轻松的

178
00:06:32,126 --> 00:06:33,846
使用它 同时它还可以

179
00:06:33,846 --> 00:06:36,136
在 GPU 未过滤的情况下

180
00:06:36,136 --> 00:06:37,926
直接接入所有的数据

181
00:06:39,136 --> 00:06:41,166
但是 当面对类似

182
00:06:41,166 --> 00:06:43,386
纹理或者采样器时

183
00:06:43,386 --> 00:06:44,446
你还是需要

184
00:06:44,446 --> 00:06:46,266
通过一个 API

185
00:06:46,266 --> 00:06:47,686
在你的渲染循环中

186
00:06:47,686 --> 00:06:50,066
设置缓存器 所有的纹理

187
00:06:50,676 --> 00:06:52,146
以及采样器 只有如此

188
00:06:52,146 --> 00:06:53,396
你才能最终开始绘制工作

189
00:06:53,446 --> 00:06:55,676
即使 Metal 已经

190
00:06:55,676 --> 00:06:57,676
被高度优化了 这里还是存在

191
00:06:57,676 --> 00:06:59,336
一小部分 API 代码 

192
00:06:59,336 --> 00:07:00,286
如果你将每一帧要渲染的对象数量

193
00:06:59,336 --> 00:07:00,286
如果你将每一帧要渲染的对象数量

194
00:07:00,286 --> 00:07:02,766
和它相乘

195
00:07:02,766 --> 00:07:04,046
而事实上你确实需要

196
00:07:04,046 --> 00:07:06,156
对每一帧都做这些工作

197
00:07:06,156 --> 00:07:09,026
实际这在某种程度上限制了

198
00:07:09,026 --> 00:07:10,136
你能放在屏幕上的

199
00:07:10,136 --> 00:07:13,826
对象数量

200
00:07:13,826 --> 00:07:17,126
通过使用参数缓冲器

201
00:07:17,126 --> 00:07:19,076
我们希望拓展

202
00:07:19,486 --> 00:07:21,476
这种对常量来说方便的间接取值

203
00:07:21,786 --> 00:07:23,026
使它能应用于

204
00:07:23,026 --> 00:07:23,626
所有的东西

205
00:07:23,626 --> 00:07:26,046
事实上你可以将纹理状态

206
00:07:26,046 --> 00:07:28,226
采样器以及指向另一个缓存器的指针

207
00:07:28,226 --> 00:07:29,696
都放入一个参数缓存器中

208
00:07:29,696 --> 00:07:31,456
这可以很大程度上

209
00:07:31,456 --> 00:07:34,036
简化你的渲染流水线

210
00:07:34,036 --> 00:07:35,656
因为突然间

211
00:07:35,656 --> 00:07:37,956
你要做的唯一一件事

212
00:07:37,956 --> 00:07:40,386
就是设置缓存器

213
00:07:41,426 --> 00:07:41,806
然后绘制

214
00:07:42,016 --> 00:07:43,316
你可能发现了

215
00:07:43,316 --> 00:07:46,196
因为更少的 API 调用

216
00:07:46,196 --> 00:07:47,126
你可以在屏幕上放置更多对象了

217
00:07:47,126 --> 00:07:49,996
正如你将看到的那样

218
00:07:50,236 --> 00:07:51,726
事实上 你可以使用参数缓存器

219
00:07:51,726 --> 00:07:54,006
做到更好

220
00:07:54,656 --> 00:07:55,536
好了 我们已经做了很多

221
00:07:55,536 --> 00:07:58,746
基准测试 并在

222
00:07:58,746 --> 00:07:59,976
我们的设备上运行了参数缓冲器

223
00:08:04,426 --> 00:08:05,886
这是你将在 iPhone 7 上

224
00:08:05,886 --> 00:08:07,616
看到的例子

225
00:08:08,196 --> 00:08:10,196
使用传统的模型

226
00:08:10,526 --> 00:08:13,546
一点都不令人惊讶

227
00:08:13,646 --> 00:08:16,366
在你的绘制调用中

228
00:08:16,366 --> 00:08:17,756
用到的资源会很庞大

229
00:08:18,246 --> 00:08:22,016
而使用参数缓存器

230
00:08:22,016 --> 00:08:25,096
这个代价会很低

231
00:08:25,096 --> 00:08:26,736
甚至没有

232
00:08:26,736 --> 00:08:29,976
这已经证明了

233
00:08:29,976 --> 00:08:31,436
通过一个简单的着色器

234
00:08:31,436 --> 00:08:33,496
两个资源

235
00:08:33,496 --> 00:08:35,956
以及纹理和一个缓存器

236
00:08:36,126 --> 00:08:37,785
或者两个纹理

237
00:08:37,785 --> 00:08:39,535
你将获得 7 倍的

238
00:08:39,535 --> 00:08:40,135
性能提升

239
00:08:40,135 --> 00:08:42,186
有 8 个纹理或者 8 个资源

240
00:08:42,186 --> 00:08:45,146
如果你希望能

241
00:08:45,146 --> 00:08:47,286
将他们混合起来

242
00:08:47,286 --> 00:08:48,996
你将在 iPhone 7 上获得 18 倍的性能提升

243
00:08:48,996 --> 00:08:50,966
显然 他能在16 个资源的时候

244
00:08:50,966 --> 00:08:52,696
运行的更好

245
00:08:55,106 --> 00:08:58,116
好了 性能方面

246
00:08:58,116 --> 00:08:58,896
我就讲到这里

247
00:08:58,986 --> 00:09:01,316
接下来我将介绍一个新功能

248
00:08:58,986 --> 00:09:01,316
接下来我将介绍一个新功能

249
00:09:01,316 --> 00:09:01,906
新的使用计划

250
00:09:01,906 --> 00:09:04,486
我们稍后会

251
00:09:04,486 --> 00:09:04,866
谈到它

252
00:09:05,066 --> 00:09:06,456
最后一个要点

253
00:09:06,456 --> 00:09:08,166
最后一个我想讲到的

254
00:09:08,166 --> 00:09:09,616
参数缓存器的好处

255
00:09:09,616 --> 00:09:10,376
是使用的方便性

256
00:09:10,976 --> 00:09:13,856
这是因为

257
00:09:13,856 --> 00:09:15,546
参数缓存器实际上

258
00:09:15,716 --> 00:09:16,686
是一个缓存器的扩展

259
00:09:16,686 --> 00:09:17,966
所以你能

260
00:09:17,966 --> 00:09:19,406
例如 提前把它准备好

261
00:09:19,406 --> 00:09:21,116
比如当你的游戏正在缓冲

262
00:09:21,116 --> 00:09:23,426
而你不需要

263
00:09:23,476 --> 00:09:25,216
在你的渲染循环时再担心它 

264
00:09:25,216 --> 00:09:26,386
这将进一步

265
00:09:26,556 --> 00:09:27,836
提升你的性能

266
00:09:28,786 --> 00:09:30,356
或者你可以将它们

267
00:09:30,356 --> 00:09:31,606
与一个传统的混合模型结合

268
00:09:31,606 --> 00:09:33,866
比如在一个

269
00:09:34,066 --> 00:09:36,376
单一的绘制调用中

270
00:09:36,376 --> 00:09:38,186
这意味着你可以简单的

271
00:09:38,366 --> 00:09:39,746
用我们的工具

272
00:09:39,746 --> 00:09:40,986
来判断哪些是你应用里

273
00:09:41,256 --> 00:09:43,626
代价最高的循环

274
00:09:43,626 --> 00:09:44,946
你可以优化它

275
00:09:44,946 --> 00:09:46,526
然后你可以在剩下的一年中处理余下的问题

276
00:09:46,526 --> 00:09:49,626
在你有时间的时候

277
00:09:49,746 --> 00:09:52,936
最后 参数缓存器

278
00:09:52,936 --> 00:09:55,246
支持所有的

279
00:09:55,246 --> 00:09:55,786
Metal 设备

280
00:09:55,786 --> 00:09:57,986
所以 只要你使用了它

281
00:09:57,986 --> 00:09:59,356
你会拥有它所有的性能

282
00:09:59,356 --> 00:10:00,956
你也可以在所有的 Metal 设备上

283
00:09:59,356 --> 00:10:00,956
你也可以在所有的 Metal 设备上

284
00:10:00,956 --> 00:10:02,556
继续使用它

285
00:10:02,986 --> 00:10:04,076
使用的方便性 事实上

286
00:10:04,076 --> 00:10:05,796
也很好的应用在了

287
00:10:05,796 --> 00:10:06,426
着色器上

288
00:10:06,426 --> 00:10:07,836
我们将在本次会议中

289
00:10:07,836 --> 00:10:10,666
谈到一点关于

290
00:10:10,666 --> 00:10:12,576
着色器的内容 

291
00:10:12,576 --> 00:10:14,806
这是我在会议开始时给大家

292
00:10:14,806 --> 00:10:15,676
提出的例子

293
00:10:16,666 --> 00:10:19,266
你可以看到

294
00:10:19,266 --> 00:10:21,596
采样器中的纹理是

295
00:10:21,596 --> 00:10:23,366
结构的一部分

296
00:10:23,366 --> 00:10:24,746
这也是你们要从这里学到的主要内容

297
00:10:25,296 --> 00:10:28,616
那就是参数缓存器

298
00:10:28,616 --> 00:10:29,976
只是一个在着色器里的结构

299
00:10:29,976 --> 00:10:31,316
你可以使用处理器里的

300
00:10:31,686 --> 00:10:33,066
所有语言

301
00:10:33,066 --> 00:10:35,266
去创造嵌入结构

302
00:10:35,266 --> 00:10:38,856
去组织你的数据 使用删除

303
00:10:38,856 --> 00:10:39,576
或者指针

304
00:10:39,766 --> 00:10:40,976
它能运行的很好

305
00:10:42,216 --> 00:10:44,486
现在让我们看看

306
00:10:44,766 --> 00:10:46,216
参数缓存器的三个主要的新功能

307
00:10:46,216 --> 00:10:47,586
第一个就是

308
00:10:47,676 --> 00:10:48,946
动态索引

309
00:10:50,276 --> 00:10:53,346
一个非常好的例子

310
00:10:53,346 --> 00:10:53,826
就是批量渲染

311
00:10:53,826 --> 00:10:56,056
如果你最近玩了

312
00:10:56,056 --> 00:10:57,436
一些开放世界游戏 你会看到

313
00:10:57,436 --> 00:11:00,686
这些游戏试图渲染

314
00:10:57,436 --> 00:11:00,686
这些游戏试图渲染

315
00:11:00,686 --> 00:11:02,506
大量特殊的

316
00:11:02,986 --> 00:11:05,036
不同角色 来创造一个

317
00:11:05,036 --> 00:11:07,546
美丽的 拟真的

318
00:11:07,606 --> 00:11:08,166
世界

319
00:11:08,696 --> 00:11:10,116
事实上

320
00:11:10,116 --> 00:11:12,246
如果你需要进行这么多绘制调用 

321
00:11:12,246 --> 00:11:13,706
是一件代价很高的事情

322
00:11:15,076 --> 00:11:16,936
我们提到过 使用参数缓存器

323
00:11:16,936 --> 00:11:19,416
我们可以将所有的

324
00:11:19,416 --> 00:11:20,876
所需属性 比如

325
00:11:20,876 --> 00:11:22,096
一个人物

326
00:11:22,096 --> 00:11:24,006
放入一个单独的参数缓存器  绑定它

327
00:11:24,006 --> 00:11:25,566
这可以节省所有的 CPU 性能

328
00:11:25,566 --> 00:11:27,686
不过我们可以

329
00:11:27,686 --> 00:11:27,966
做的更好

330
00:11:27,966 --> 00:11:30,246
例如 我们可以 

331
00:11:30,416 --> 00:11:32,236
创建一个参数缓存器队列

332
00:11:32,546 --> 00:11:35,266
其中每个元素代表一个

333
00:11:35,266 --> 00:11:35,726
字符

334
00:11:36,306 --> 00:11:37,476
然后 这会变得非常简单

335
00:11:37,476 --> 00:11:38,696
因为你需要做的

336
00:11:38,696 --> 00:11:40,856
就是设置这个大的缓存器

337
00:11:40,856 --> 00:11:44,016
这是第一次的 API 调用

338
00:11:44,126 --> 00:11:46,046
它可以处理单一的绘制调用实例

339
00:11:46,046 --> 00:11:47,646
比如说 1000 个实例

340
00:11:47,646 --> 00:11:49,126
因为我希望有 1000 个人物

341
00:11:49,126 --> 00:11:49,496
显示在屏幕上

342
00:11:50,096 --> 00:11:51,186
这是第二次 API 调用

343
00:11:51,256 --> 00:11:53,626
完成之后 

344
00:11:53,626 --> 00:11:54,176
它就都在 GPU 上了

345
00:11:54,176 --> 00:11:55,576
在顶点着色里

346
00:11:55,576 --> 00:11:57,426
你可以用实例 ID 从队列中

347
00:11:57,426 --> 00:12:00,926
选择正确的元素

348
00:11:57,426 --> 00:12:00,926
选择正确的元素

349
00:12:00,926 --> 00:12:02,266
获得人物并将他

350
00:12:02,266 --> 00:12:03,036
放置在世界里需要他的地方

351
00:12:03,036 --> 00:12:04,496
给他正确的姿势

352
00:12:04,496 --> 00:12:05,646
假如是步行周期中间

353
00:12:05,646 --> 00:12:07,766
在片段着色器中

354
00:12:07,766 --> 00:12:10,176
你再一次使用

355
00:12:10,176 --> 00:12:12,146
实例 ID 然后选择正确的材料 

356
00:12:12,146 --> 00:12:13,516
正确的发色来

357
00:12:13,516 --> 00:12:14,446
完成这个人物的外貌

358
00:12:14,716 --> 00:12:17,056
所以 我们能很快将

359
00:12:17,576 --> 00:12:19,916
成千上万的绘制调用

360
00:12:19,916 --> 00:12:22,316
变成单一的一次调用

361
00:12:22,636 --> 00:12:24,156
而且它能在 CPU 中运行的更快

362
00:12:24,246 --> 00:12:25,386
在 GPU 中也更快

363
00:12:26,036 --> 00:12:29,466
在着色中

364
00:12:29,466 --> 00:12:30,036
它看上去就是如此简单

365
00:12:31,166 --> 00:12:33,066
很大程度上你的参数缓存器

366
00:12:33,066 --> 00:12:35,516
成为了一队列的结构

367
00:12:36,966 --> 00:12:40,156
你可以使用内置的实例 ID

368
00:12:40,156 --> 00:12:41,506
来选择正确的元素

369
00:12:41,506 --> 00:12:42,856
然后你可以 比如

370
00:12:42,856 --> 00:12:44,526
选择指针 然后将它传递给你的

371
00:12:44,526 --> 00:12:46,176
辅助方法或者任何

372
00:12:46,226 --> 00:12:49,176
处理数据所需的方法

373
00:12:49,256 --> 00:12:51,496
参数缓存器的第二个优秀功能

374
00:12:51,536 --> 00:12:53,206
是 GPU 设置资源

375
00:12:53,806 --> 00:12:56,436
的能力

376
00:12:56,436 --> 00:12:57,656
事实上我们为它

377
00:12:57,656 --> 00:12:58,546
创造了一个例子

378
00:12:59,486 --> 00:13:01,586
我们创造了一个

379
00:12:59,486 --> 00:13:01,586
我们创造了一个

380
00:13:01,586 --> 00:13:03,876
完全在 GPU 上运行的粒子仿真

381
00:13:04,466 --> 00:13:06,036
让我来告诉你我们怎么做的

382
00:13:06,036 --> 00:13:08,216
我们将看到

383
00:13:08,216 --> 00:13:09,506
我们一会儿将看到它运行

384
00:13:10,256 --> 00:13:11,836
所以我们创建了一队

385
00:13:12,086 --> 00:13:13,316
参数缓存器 他们中每一个

386
00:13:13,366 --> 00:13:16,296
元素是一个单个的粒子

387
00:13:16,296 --> 00:13:17,756
我猜你已经看到了

388
00:13:17,756 --> 00:13:19,196
这里的趋势

389
00:13:19,766 --> 00:13:23,716
随后我们的仿真核将

390
00:13:24,596 --> 00:13:26,696
每线程的对一个粒子进行仿真

391
00:13:26,696 --> 00:13:28,796
但是我们想要

392
00:13:28,796 --> 00:13:29,966
走得更远

393
00:13:29,966 --> 00:13:32,906
我们希望使 GPU

394
00:13:32,906 --> 00:13:36,416
在核心中

395
00:13:36,416 --> 00:13:37,006
也能创造粒子

396
00:13:37,006 --> 00:13:39,106
所以 为了实现这个目标

397
00:13:39,106 --> 00:13:41,316
给予它正确的材料

398
00:13:41,316 --> 00:13:43,016
我们也有

399
00:13:43,076 --> 00:13:44,686
我们希望粒子拥有的

400
00:13:44,686 --> 00:13:45,806
所有不同材质的

401
00:13:45,806 --> 00:13:46,176
参数缓存器

402
00:13:46,906 --> 00:13:48,896
我们的仿真核

403
00:13:49,386 --> 00:13:50,866
每一次你想在样本里做一个动作时

404
00:13:51,186 --> 00:13:53,826
这个仿真核就会

405
00:13:53,826 --> 00:13:54,776
观察环境

406
00:13:54,776 --> 00:13:57,066
看看哪些是

407
00:13:57,806 --> 00:13:59,446
正确的 合适的

408
00:13:59,446 --> 00:13:59,906
材料

409
00:14:00,056 --> 00:14:01,596
打个比方 如果你在

410
00:14:01,596 --> 00:14:04,126
一片森林里 我们选择苔藓

411
00:14:04,286 --> 00:14:05,786
作为一块岩石最正确合适的材料

412
00:14:05,786 --> 00:14:08,696
然后将它复制到

413
00:14:09,126 --> 00:14:10,126
粒子上

414
00:14:11,366 --> 00:14:13,226
如果你在岩石上

415
00:14:13,226 --> 00:14:14,106
我们选择岩石材料

416
00:14:14,106 --> 00:14:15,946
在山上我们选择草

417
00:14:16,826 --> 00:14:18,506
像这样 所有东西都在 GPU 上

418
00:14:18,506 --> 00:14:22,796
它的着色真的就和

419
00:14:22,796 --> 00:14:24,206
我描述的一样

420
00:14:24,206 --> 00:14:24,946
那么简单

421
00:14:25,336 --> 00:14:26,756
如果你想在你的 GPU 上

422
00:14:26,756 --> 00:14:30,156
修改数据 你可以将它作为设备缓存器捆绑

423
00:14:30,156 --> 00:14:31,486
然后像你以前一样

424
00:14:31,486 --> 00:14:33,866
开始赋值

425
00:14:33,866 --> 00:14:34,986
但是这次你要

426
00:14:34,986 --> 00:14:37,146
复制纹理或者复制整个的

427
00:14:37,146 --> 00:14:38,676
结构 

428
00:14:38,676 --> 00:14:38,966
这非常简单

429
00:14:40,106 --> 00:14:42,346
我想介绍的

430
00:14:42,346 --> 00:14:44,576
最后一个参数缓存器的

431
00:14:44,576 --> 00:14:47,116
优秀功能是

432
00:14:47,116 --> 00:14:48,116
它可以引用另外一个参数缓存器

433
00:14:48,116 --> 00:14:50,106
这样你可以

434
00:14:50,106 --> 00:14:52,936
创建一个可重复使用的

435
00:14:53,026 --> 00:14:55,816
复杂对象层级

436
00:14:55,816 --> 00:14:59,076
就像 C++ Swift

437
00:14:59,296 --> 00:15:00,046
和 Objective-C 一样

438
00:14:59,296 --> 00:15:00,046
和 Objective-C 一样

439
00:15:00,566 --> 00:15:03,676
打个比方 在我们的渲染器的例子中

440
00:15:04,376 --> 00:15:06,496
如果你有大量的对象

441
00:15:06,536 --> 00:15:09,076
但你可能只有

442
00:15:09,726 --> 00:15:11,046
很少的材料 你可以做的是

443
00:15:11,046 --> 00:15:14,556
从每个对象引用材料

444
00:15:14,556 --> 00:15:15,866
省下一些内存

445
00:15:15,866 --> 00:15:18,336
或者你可以

446
00:15:18,336 --> 00:15:19,716
将布景图构建成二进制树形网络

447
00:15:19,716 --> 00:15:21,566
在这里 当你需要时 你可以指向

448
00:15:21,566 --> 00:15:25,186
对象和树的节点

449
00:15:25,186 --> 00:15:26,436
就像你原来

450
00:15:26,436 --> 00:15:27,526
在 CPU 里使用一样

451
00:15:27,906 --> 00:15:29,396
你也可以和 CPU 分享

452
00:15:29,396 --> 00:15:30,086
这些数据

453
00:15:31,536 --> 00:15:32,846
这些就是主要的功能

454
00:15:32,846 --> 00:15:34,526
现在让我们来看看

455
00:15:34,526 --> 00:15:35,026
支持矩阵

456
00:15:35,596 --> 00:15:37,036
我们有两个层级

457
00:15:37,266 --> 00:15:39,796
层级一是被所有

458
00:15:39,796 --> 00:15:42,466
Metal 设备支持的

459
00:15:42,466 --> 00:15:43,386
你也可以提升 CPU

460
00:15:43,386 --> 00:15:43,926
的性能

461
00:15:43,926 --> 00:15:44,866
你可以得到新的

462
00:15:44,866 --> 00:15:45,276
计划语言

463
00:15:45,766 --> 00:15:49,096
但是因为 GPU 的限制

464
00:15:49,096 --> 00:15:52,296
这个层级

465
00:15:52,896 --> 00:15:54,526
不能够像我之前提到的

466
00:15:55,016 --> 00:15:56,486
通过利用 GPU 驱动

467
00:15:56,486 --> 00:15:57,346
来使用用例

468
00:15:57,776 --> 00:15:58,916
但是如果使用层级二

469
00:15:58,916 --> 00:16:00,586
你可以得到所有的

470
00:15:58,916 --> 00:16:00,586
你可以得到所有的

471
00:16:00,586 --> 00:16:02,396
所有的新用例

472
00:16:02,396 --> 00:16:04,126
我们也同样

473
00:16:04,126 --> 00:16:05,736
大幅提高了你能接入的

474
00:16:05,736 --> 00:16:06,176
资源

475
00:16:06,176 --> 00:16:07,416
你的渲染器能接入

476
00:16:07,466 --> 00:16:10,406
50 万的纹理和缓存器

477
00:16:10,406 --> 00:16:11,676
让你能做这些

478
00:16:11,676 --> 00:16:12,806
新的算法

479
00:16:13,696 --> 00:16:15,696
尽管层级一在所有设备上

480
00:16:15,986 --> 00:16:18,526
都被支持  层级二是

481
00:16:18,526 --> 00:16:19,826
你需要查询得到的

482
00:16:20,306 --> 00:16:22,216
但是不用担心 这个支持

483
00:16:22,216 --> 00:16:22,846
非常广泛

484
00:16:23,556 --> 00:16:25,016
所有拥有这三个 GPU 的 Mac

485
00:16:25,016 --> 00:16:26,166
都有层级二

486
00:16:26,626 --> 00:16:28,436
所有新的 MacBook Pro 

487
00:16:28,436 --> 00:16:29,676
最新的 MacBook 最后层级的 MacBook Pro

488
00:16:29,676 --> 00:16:31,586
都有层级二

489
00:16:31,586 --> 00:16:33,316
所以你大可以

490
00:16:33,416 --> 00:16:33,586
玩得高兴

491
00:16:34,106 --> 00:16:35,546
现在 让我们来看看

492
00:16:35,546 --> 00:16:36,136
我承诺过给你们的样本

493
00:16:36,226 --> 00:16:39,116
我们将展示三个视频

494
00:16:39,426 --> 00:16:41,416
其中包含三个不同功能

495
00:16:41,986 --> 00:16:43,936
这个被实时渲染的地形

496
00:16:44,136 --> 00:16:45,846
有动态变化的材料

497
00:16:45,846 --> 00:16:48,346
我们利用 GPU 在地形上

498
00:16:48,346 --> 00:16:50,616
放置一些植物

499
00:16:50,616 --> 00:16:51,716
来让它更有趣

500
00:16:52,116 --> 00:16:53,326
我们也有这些我

501
00:16:53,326 --> 00:16:56,076
之前提到过的漂亮的

502
00:16:56,076 --> 00:16:56,436
粒子

503
00:16:56,656 --> 00:16:59,516
所以 就像你看到的

504
00:17:00,006 --> 00:17:01,246
我们在地形上绘制高度

505
00:17:01,246 --> 00:17:02,496
我们可以改变地表侵蚀

506
00:17:02,496 --> 00:17:03,466
随后材料也会

507
00:17:03,466 --> 00:17:04,326
跟着变化

508
00:17:04,626 --> 00:17:05,796
这就是参数缓存器优秀的地方

509
00:17:05,796 --> 00:17:08,425
因为它们

510
00:17:08,425 --> 00:17:10,965
能让我们创建一个大的

511
00:17:11,665 --> 00:17:13,506
参数缓存器

512
00:17:13,506 --> 00:17:16,406
所有的可用材料和层级都在里面

513
00:17:16,406 --> 00:17:18,455
当我们在一个像素着色器中

514
00:17:18,455 --> 00:17:20,576
渲染地形时

515
00:17:20,576 --> 00:17:21,736
我们看到的是

516
00:17:22,076 --> 00:17:24,846
地形的高度 坡度

517
00:17:25,116 --> 00:17:27,406
有多少阳光到达特定的

518
00:17:27,606 --> 00:17:29,166
像素 基于这些属性

519
00:17:29,166 --> 00:17:30,976
和其他属性

520
00:17:30,976 --> 00:17:33,866
我们能判断什么是用于

521
00:17:34,026 --> 00:17:35,446
这个像素上的最好的

522
00:17:35,446 --> 00:17:36,466
和最适合的材料

523
00:17:36,896 --> 00:17:38,046
这些都是

524
00:17:38,046 --> 00:17:40,746
实时发生的  在以前我们可能需要

525
00:17:40,746 --> 00:17:42,436
在线下

526
00:17:42,436 --> 00:17:44,316
将地形拆成小块

527
00:17:44,766 --> 00:17:47,466
分析哪些小块

528
00:17:47,466 --> 00:17:49,206
需要哪些纹理

529
00:17:49,206 --> 00:17:50,676
以使它最优化

530
00:17:51,236 --> 00:17:53,166
然后才能渲染它

531
00:17:53,166 --> 00:17:55,386
所以我们将一个

532
00:17:55,456 --> 00:17:56,546
预处理的步骤

533
00:17:56,546 --> 00:17:58,366
一个繁重的非实时的

534
00:17:58,366 --> 00:18:00,496
修改操作 变成了一个

535
00:17:58,366 --> 00:18:00,496
修改操作 变成了一个

536
00:18:00,496 --> 00:18:02,226
实时的 抱歉

537
00:18:02,286 --> 00:18:04,716
不需要处理的

538
00:18:04,716 --> 00:18:05,626
完全动态的步骤

539
00:18:08,976 --> 00:18:11,986
我们在上面加上植被

540
00:18:12,296 --> 00:18:14,086
你可以看到植被

541
00:18:14,086 --> 00:18:16,196
也是环境敏感的

542
00:18:17,026 --> 00:18:18,766
你看沙滩上的

543
00:18:18,766 --> 00:18:19,136
棕榈树

544
00:18:19,136 --> 00:18:20,826
你看山丘上

545
00:18:20,826 --> 00:18:21,816
小小的苹果树

546
00:18:23,446 --> 00:18:25,536
植被本身还是一个

547
00:18:25,536 --> 00:18:28,176
非常传统的实例渲染

548
00:18:28,176 --> 00:18:29,776
参数缓存器在这里

549
00:18:29,776 --> 00:18:32,396
能做到的是

550
00:18:32,396 --> 00:18:34,086
它使我们能将

551
00:18:34,416 --> 00:18:36,006
所有的相同属性

552
00:18:36,006 --> 00:18:37,846
分享给同样的地形材料

553
00:18:37,846 --> 00:18:39,646
并在完全分离的

554
00:18:40,126 --> 00:18:41,486
代码中间进行

555
00:18:41,486 --> 00:18:43,446
同样的地形分析功能

556
00:18:43,676 --> 00:18:45,246
当地形渲染器用

557
00:18:45,246 --> 00:18:47,326
所有这些数据去渲染像素时

558
00:18:47,326 --> 00:18:48,796
放置几何形状

559
00:18:48,796 --> 00:18:50,316
和植被的电脑

560
00:18:50,686 --> 00:18:51,956
事实上分析了相同的

561
00:18:51,956 --> 00:18:53,786
材料以判断

562
00:18:53,786 --> 00:18:56,266
最合适放置在指定地点上的

563
00:18:56,266 --> 00:18:57,026
是哪一种树

564
00:18:57,486 --> 00:18:58,616
这非常简单因为

565
00:18:58,616 --> 00:18:59,836
每次我们在做改变的时候

566
00:19:00,166 --> 00:19:01,566
我们的代码事实上没有任何变化

567
00:19:01,566 --> 00:19:02,686
我们只是增加了新的

568
00:19:02,686 --> 00:19:04,516
层级或者改变了我们的分析

569
00:19:04,516 --> 00:19:06,806
功能  可能从前我们需要

570
00:19:06,806 --> 00:19:08,526
在两个完全分离的

571
00:19:08,526 --> 00:19:10,226
代码中间处理大概 70 个纹理

572
00:19:10,226 --> 00:19:11,776
以使他们能

573
00:19:11,816 --> 00:19:17,036
同步的运行

574
00:19:17,216 --> 00:19:19,406
最后 我们有粒子

575
00:19:19,406 --> 00:19:22,226
我希望你们注意到

576
00:19:22,226 --> 00:19:25,146
他们已经找到了

577
00:19:25,146 --> 00:19:25,916
地形的材料

578
00:19:26,876 --> 00:19:28,606
我之前没有提到的是

579
00:19:28,606 --> 00:19:30,866
这些全都是被

580
00:19:31,126 --> 00:19:32,816
单个的绘制调用渲染的

581
00:19:32,816 --> 00:19:34,756
我们这里使用单个的绘制调用

582
00:19:35,086 --> 00:19:38,006
渲染了 16000 个粒子

583
00:19:38,006 --> 00:19:39,776
这个过程中完全没有

584
00:19:39,816 --> 00:19:41,586
CPU 的参与

585
00:19:42,406 --> 00:19:44,486
而且粒子不只是有

586
00:19:44,826 --> 00:19:46,316
特殊的材料 它们事实上

587
00:19:46,316 --> 00:19:47,486
还有特殊的形状 因为

588
00:19:47,766 --> 00:19:48,876
参数缓存器

589
00:19:48,936 --> 00:19:50,176
允许你在每个

590
00:19:50,176 --> 00:19:52,166
绘制调用里

591
00:19:52,166 --> 00:19:52,466
改变你的顶点缓存

592
00:19:53,526 --> 00:19:56,076
如果你试着不用

593
00:19:56,076 --> 00:19:58,466
参数缓存器去处理它 

594
00:19:58,466 --> 00:20:01,956
我们需要创建一个

595
00:19:58,466 --> 00:20:01,956
我们需要创建一个

596
00:20:01,956 --> 00:20:04,496
复杂的控件

597
00:20:04,496 --> 00:20:06,856
在负责模仿的 GPU 和

598
00:20:06,856 --> 00:20:08,036
试图得到最佳

599
00:20:08,036 --> 00:20:09,866
绘制调用组的 CPU 之间

600
00:20:09,866 --> 00:20:11,356
来代表所有的这些变量

601
00:20:11,776 --> 00:20:13,396
有了参数缓存器

602
00:20:13,396 --> 00:20:17,116
这将变得非常非常简单

603
00:20:18,346 --> 00:20:21,706
好了 看够了美丽的图片

604
00:20:22,296 --> 00:20:25,226
让我们以一些

605
00:20:25,226 --> 00:20:28,406
API 和一些实践例子

606
00:20:28,406 --> 00:20:29,716
来结束我的部分

607
00:20:29,986 --> 00:20:33,426
就像我提到的那样

608
00:20:33,426 --> 00:20:34,926
参数缓存器是 Metal 缓存器的

609
00:20:34,926 --> 00:20:37,426
延伸 这意味着

610
00:20:37,426 --> 00:20:39,286
所有与缓存器有关的 API 

611
00:20:39,286 --> 00:20:39,776
都能运行

612
00:20:39,776 --> 00:20:40,946
你可以找一个

613
00:20:40,946 --> 00:20:42,196
参数缓存器 将它复制到

614
00:20:42,196 --> 00:20:43,456
别的地方 你可以将它

615
00:20:43,456 --> 00:20:44,976
放到 CPU 和 GPU 中间

616
00:20:45,826 --> 00:20:48,106
尽管参数缓存器

617
00:20:48,106 --> 00:20:51,266
看起来像渲染器在 GPU 里的结构

618
00:20:51,266 --> 00:20:54,796
在 CPU 里你将用到

619
00:20:54,796 --> 00:20:56,816
MTLArgumentEncoder 对象去

620
00:20:56,816 --> 00:20:57,716
填充内容

621
00:20:58,676 --> 00:21:02,196
这样的抽象能让 Metal

622
00:20:58,676 --> 00:21:02,196
这样的抽象能让 Metal

623
00:21:02,196 --> 00:21:04,696
为任何 

624
00:21:05,186 --> 00:21:06,686
实际运行的特定 GPU 上的

625
00:21:06,686 --> 00:21:08,316
指定参数缓存器

626
00:21:08,316 --> 00:21:09,376
创建一个最优化的

627
00:21:09,376 --> 00:21:09,716
内存表征

628
00:21:10,206 --> 00:21:11,506
这样你就可以得到最好的性能

629
00:21:11,896 --> 00:21:13,266
作为一个研发者

630
00:21:13,266 --> 00:21:14,686
它同时也将把你

631
00:21:15,646 --> 00:21:19,956
从焦虑的细节中解放出来

632
00:21:19,956 --> 00:21:21,956
例如 每个 GPU 如何体现

633
00:21:22,096 --> 00:21:22,966
什么是纹理

634
00:21:22,966 --> 00:21:23,986
它在存储器中应该放在什么位置

635
00:21:24,616 --> 00:21:26,746
所有这些从平台到平台的变化

636
00:21:26,886 --> 00:21:28,776
我们将它们隐藏在

637
00:21:28,776 --> 00:21:31,356
简单的界面之间

638
00:21:31,356 --> 00:21:32,616
这样你就可以写出非常简单的

639
00:21:32,616 --> 00:21:33,826
有效率的应用了

640
00:21:34,506 --> 00:21:37,106
希望你们没有

641
00:21:37,106 --> 00:21:38,006
为了我前面提到的

642
00:21:38,006 --> 00:21:38,376
编码器感到发愁

643
00:21:38,376 --> 00:21:39,886
它真的用起来非常非常

644
00:21:39,886 --> 00:21:40,286
简单

645
00:21:41,346 --> 00:21:42,396
举个例子 如果你想要

646
00:21:42,396 --> 00:21:43,856
为这个参数缓存器创建一个 参数编码器

647
00:21:43,856 --> 00:21:46,386
你只需要

648
00:21:46,386 --> 00:21:49,886
让你的 Metal 使用

649
00:21:49,886 --> 00:21:51,386
参数缓存器功能

650
00:21:51,386 --> 00:21:53,736
然后让 Metal 功能

651
00:21:53,736 --> 00:21:55,386
调用编码器

652
00:21:55,386 --> 00:21:56,116
就行了

653
00:21:56,116 --> 00:21:57,386
这就是你要做的全部了

654
00:21:57,386 --> 00:21:59,526
你得到一个对象 你开始

655
00:21:59,526 --> 00:22:02,066
使用一个熟悉的纹理

656
00:21:59,526 --> 00:22:02,066
使用一个熟悉的纹理

657
00:22:02,486 --> 00:22:04,586
或者像你在

658
00:22:04,586 --> 00:22:05,906
Metal 里使用

659
00:22:05,906 --> 00:22:08,666
命令编码器一样

660
00:22:08,666 --> 00:22:09,016
去填满 API

661
00:22:09,016 --> 00:22:11,916
这对我提到过的

662
00:22:11,916 --> 00:22:15,116
过渡和使用的便捷性

663
00:22:15,116 --> 00:22:15,846
也有效

664
00:22:16,866 --> 00:22:18,736
还有很多创建编码器的

665
00:22:18,736 --> 00:22:20,546
方法

666
00:22:20,546 --> 00:22:21,786
你可以使描述符

667
00:22:21,786 --> 00:22:22,686
更精确 但是

668
00:22:22,686 --> 00:22:24,706
如果你需要的话

669
00:22:24,876 --> 00:22:26,036
你可能要去查找

670
00:22:26,036 --> 00:22:27,326
参考资料

671
00:22:27,326 --> 00:22:28,956
我们建议你

672
00:22:29,566 --> 00:22:30,866
直接从着色器里获得

673
00:22:30,866 --> 00:22:31,386
参数编码器

674
00:22:33,846 --> 00:22:36,706
现在 有了这些交互

675
00:22:36,706 --> 00:22:38,396
GPU 可以介入

676
00:22:38,396 --> 00:22:40,436
修改参数缓存器

677
00:22:41,036 --> 00:22:42,286
或者动态的索引

678
00:22:42,286 --> 00:22:44,356
以及 50 万个纹理 如果这些全部混合起来

679
00:22:44,356 --> 00:22:47,526
Metal 不太可能

680
00:22:47,906 --> 00:22:49,366
去分辨

681
00:22:49,366 --> 00:22:50,466
例如在渲染的时候

682
00:22:50,466 --> 00:22:52,226
应该使用

683
00:22:52,226 --> 00:22:55,396
哪些纹理和缓存器

684
00:22:55,396 --> 00:22:57,006
但幸运的是 作为一个开发者

685
00:22:57,006 --> 00:22:58,916
你对此有

686
00:22:58,916 --> 00:22:59,126
很好的解决方法

687
00:22:59,126 --> 00:23:01,276
所以我们要求你

688
00:22:59,126 --> 00:23:01,276
所以我们要求你

689
00:23:01,276 --> 00:23:02,716
对参数缓存器

690
00:23:02,716 --> 00:23:03,066
尽量的熟悉

691
00:23:04,266 --> 00:23:05,776
如果你在使用堆

692
00:23:06,646 --> 00:23:08,336
当然你需要使用堆

693
00:23:08,336 --> 00:23:09,896
在你的平台上获得

694
00:23:09,896 --> 00:23:12,506
最佳的性能

695
00:23:12,506 --> 00:23:13,766
以及组织数据的最佳方式

696
00:23:14,366 --> 00:23:15,586
你唯一要做的事

697
00:23:15,586 --> 00:23:16,936
就是告诉 Metal 你想要用一个堆

698
00:23:16,936 --> 00:23:18,886
或者多个堆

699
00:23:18,886 --> 00:23:19,816
这由你来决定

700
00:23:19,816 --> 00:23:22,356
这保证了

701
00:23:22,356 --> 00:23:24,196
在渲染循环中

702
00:23:24,196 --> 00:23:25,546
纹理是

703
00:23:25,546 --> 00:23:27,696
可用的

704
00:23:27,696 --> 00:23:29,066
如果你想做到更具体

705
00:23:29,066 --> 00:23:30,076
比如你想要

706
00:23:30,076 --> 00:23:32,586
从一个内部的着色器

707
00:23:32,586 --> 00:23:34,556
写入渲染目标 或者你

708
00:23:34,556 --> 00:23:35,626
想从一个 dev 缓存器进行读取

709
00:23:35,626 --> 00:23:38,466
你可以使用一个更加具体的 API

710
00:23:38,466 --> 00:23:40,466
然后告诉 Metal

711
00:23:40,466 --> 00:23:42,476
你想要用

712
00:23:43,476 --> 00:23:44,516
特殊的方式改变资源

713
00:23:44,516 --> 00:23:46,076
再一次的

714
00:23:46,076 --> 00:23:46,166
就是这样简单

715
00:23:46,166 --> 00:23:46,836
任何其他的事

716
00:23:46,836 --> 00:23:46,976
你都不用做

717
00:23:50,506 --> 00:23:52,196
让我们开始讲讲

718
00:23:52,196 --> 00:23:53,116
几个最佳的实践例子

719
00:23:53,116 --> 00:23:55,986
我想如果你了解 Metal

720
00:23:55,986 --> 00:23:58,076
它和我们向你介绍的

721
00:23:58,076 --> 00:24:00,076
Metal 缓存器

722
00:23:58,076 --> 00:24:00,076
Metal 缓存器

723
00:24:00,076 --> 00:24:00,716
十分相似

724
00:24:01,156 --> 00:24:02,586
组织你的数据的最佳

725
00:24:02,586 --> 00:24:04,706
方式是用 使用模式

726
00:24:04,706 --> 00:24:05,856
你可能有很多属性

727
00:24:05,856 --> 00:24:08,406
它们不会随着

728
00:24:08,686 --> 00:24:09,306
每个帧进行变化

729
00:24:09,396 --> 00:24:10,536
所以 将它们放入

730
00:24:10,536 --> 00:24:11,956
参数缓存器 将它和所有的

731
00:24:11,956 --> 00:24:13,166
对象共享 

732
00:24:13,166 --> 00:24:13,536
这样你将节省内存

733
00:24:14,286 --> 00:24:16,076
同样的 另一方面

734
00:24:16,076 --> 00:24:17,756
你可能有很多

735
00:24:17,756 --> 00:24:19,566
属性 它们也确实随着每个

736
00:24:19,566 --> 00:24:21,106
对象进行变化

737
00:24:21,106 --> 00:24:23,496
你需要在每一帧下

738
00:24:23,496 --> 00:24:24,346
对它们进行管理

739
00:24:24,346 --> 00:24:26,946
对于这个问题 我认为

740
00:24:26,946 --> 00:24:28,066
最好的方式是

741
00:24:28,066 --> 00:24:29,226
将它们发给不同的参数缓存器

742
00:24:29,226 --> 00:24:30,396
这样你可对它进行双重缓存

743
00:24:30,396 --> 00:24:32,056
或者对任何你的管理计划

744
00:24:32,056 --> 00:24:34,786
进行两次运行 你不用

745
00:24:34,786 --> 00:24:36,576
通过其他的复制

746
00:24:36,576 --> 00:24:37,266
来使所有的数据存在里面

747
00:24:37,706 --> 00:24:39,186
然后你会有

748
00:24:39,186 --> 00:24:41,326
一些完全不会

749
00:24:41,786 --> 00:24:43,286
改变的参数缓存器

750
00:24:43,286 --> 00:24:44,456
比如材料 或者

751
00:24:45,026 --> 00:24:46,816
一些其他的属性

752
00:24:46,966 --> 00:24:49,296
对于它们 你可以

753
00:24:49,296 --> 00:24:50,296
在应用的初始化里创建它们

754
00:24:50,296 --> 00:24:53,826
然后继续应用它们

755
00:24:54,026 --> 00:24:57,576
和 Metal 缓存器相似

756
00:24:57,576 --> 00:24:59,816
想想你的数据位置 以及

757
00:24:59,816 --> 00:25:01,566
你将如何使用

758
00:24:59,816 --> 00:25:01,566
你将如何使用

759
00:25:01,566 --> 00:25:01,916
你的参数缓存器

760
00:25:02,246 --> 00:25:03,816
假如你有

761
00:25:03,816 --> 00:25:06,076
3 个纹理 接入了着色器

762
00:25:06,076 --> 00:25:08,776
一个接一个

763
00:25:09,316 --> 00:25:10,836
这时你能做的最好的事就是

764
00:25:10,836 --> 00:25:12,046
在参数缓存器里将这些

765
00:25:12,046 --> 00:25:13,216
纹理放置在相距很近的地方

766
00:25:13,216 --> 00:25:14,566
这样你才能最大化

767
00:25:14,566 --> 00:25:16,466
GPU 的缓存

768
00:25:17,376 --> 00:25:18,146
就像我在会议开始时提到的

769
00:25:18,146 --> 00:25:20,736
传统的参数模型

770
00:25:20,736 --> 00:25:23,716
不能运用到每个地方

771
00:25:23,716 --> 00:25:25,576
你要合理使用它

772
00:25:25,576 --> 00:25:26,776
并且在能使情况更方便的时候

773
00:25:26,776 --> 00:25:28,116
将它和参数缓存器

774
00:25:28,116 --> 00:25:28,786
混合使用

775
00:25:29,296 --> 00:25:30,626
比方说你需要对

776
00:25:30,626 --> 00:25:32,256
改变每个对象的单个纹理

777
00:25:33,376 --> 00:25:35,786
比如一个立方体的倒影

778
00:25:35,786 --> 00:25:37,606
只为这个创建一个

779
00:25:37,606 --> 00:25:38,786
参数缓存器然后

780
00:25:38,786 --> 00:25:40,096
每一帧都上载它 可能是一个

781
00:25:40,096 --> 00:25:40,896
系统开销

782
00:25:40,896 --> 00:25:42,826
所以 在这里我们

783
00:25:42,826 --> 00:25:43,526
使用传统的模型

784
00:25:43,656 --> 00:25:46,216
这就是

785
00:25:46,216 --> 00:25:46,576
关于参数缓存器的内容

786
00:25:46,576 --> 00:25:50,256
我真诚的希望大家能使用

787
00:25:50,256 --> 00:25:52,516
我们的新 API 并创新性的

788
00:25:52,806 --> 00:25:53,596
使用它

789
00:25:54,136 --> 00:25:57,456
请大家欢迎 Richard

790
00:25:57,546 --> 00:25:59,156
他将为大家介绍

791
00:25:59,156 --> 00:25:59,506
光栅顺序组

792
00:26:00,556 --> 00:26:02,556
[ 掌声 ]

793
00:26:02,596 --> 00:26:03,016
&gt;&gt; 谢谢

794
00:26:05,046 --> 00:26:06,686
大家好 谢谢你 Michal

795
00:26:06,826 --> 00:26:07,776
我将带领大家度过

796
00:26:07,776 --> 00:26:08,436
下面的展示时间

797
00:26:08,436 --> 00:26:10,006
让我们从

798
00:26:10,046 --> 00:26:10,936
光栅顺序组开始

799
00:26:12,476 --> 00:26:14,196
这是个新的功能

800
00:26:14,196 --> 00:26:16,636
它能让你控制 GPU 的

801
00:26:16,726 --> 00:26:17,866
线性调度

802
00:26:18,196 --> 00:26:19,686
以有序的运行

803
00:26:19,746 --> 00:26:20,086
片段射击线

804
00:26:20,686 --> 00:26:22,096
这让重叠的片段射击线

805
00:26:22,096 --> 00:26:23,266
能够通过存储器进行沟通

806
00:26:23,266 --> 00:26:24,876
在这之前

807
00:26:24,876 --> 00:26:27,366
大多数情况下

808
00:26:27,366 --> 00:26:28,286
是实现不了的

809
00:26:28,646 --> 00:26:30,246
所以 这开启了一个

810
00:26:30,246 --> 00:26:31,266
全新的图像算法

811
00:26:31,266 --> 00:26:32,956
如果只写入了对你的

812
00:26:33,156 --> 00:26:34,206
帧缓存器的接口或者

813
00:26:34,206 --> 00:26:36,196
接入设备存储器

814
00:26:36,196 --> 00:26:37,216
这是很难实现的

815
00:26:38,476 --> 00:26:40,986
举个例子 

816
00:26:40,986 --> 00:26:42,226
我们的关键应用中的一个

817
00:26:42,306 --> 00:26:43,156
是顺序无关的

818
00:26:43,156 --> 00:26:43,926
透明渲染

819
00:26:44,746 --> 00:26:46,106
我们今天已经谈了很多

820
00:26:46,106 --> 00:26:47,476
如何降低你的 Metal 应用

821
00:26:47,476 --> 00:26:48,596
的 CPU 使用量的问题

822
00:26:48,596 --> 00:26:50,356
这个功能

823
00:26:50,356 --> 00:26:52,006
让你创建一个算法

824
00:26:52,476 --> 00:26:54,456
以实现前后颠倒的混合

825
00:26:54,456 --> 00:26:56,116
而不用为

826
00:26:56,116 --> 00:26:57,526
三角水平筛选

827
00:26:57,526 --> 00:26:57,896
而消耗 CPU

828
00:26:59,536 --> 00:27:00,736
这里有很多针对

829
00:26:59,536 --> 00:27:00,736
这里有很多针对

830
00:27:00,736 --> 00:27:01,836
类似

831
00:27:01,836 --> 00:27:03,176
双层的 G-buffer

832
00:27:03,396 --> 00:27:04,236
的先进技术的研究

833
00:27:04,236 --> 00:27:05,946
这种缓存器能

834
00:27:05,946 --> 00:27:07,596
极大的提升 后处理结果 或者用

835
00:27:07,596 --> 00:27:08,846
GPU 的光栅器

836
00:27:08,846 --> 00:27:10,196
来像素化三角形网格

837
00:27:11,056 --> 00:27:12,716
对于这些存储器

838
00:27:12,716 --> 00:27:13,826
的前端接口

839
00:27:13,826 --> 00:27:15,336
在他们通往高效应用的路上

840
00:27:15,336 --> 00:27:16,516
还有很大的阻碍

841
00:27:17,296 --> 00:27:18,976
可能对于这个功能而言

842
00:27:18,976 --> 00:27:20,566
最简单最通俗的应用

843
00:27:20,566 --> 00:27:21,836
是执行

844
00:27:21,836 --> 00:27:22,776
定制混合方程

845
00:27:23,656 --> 00:27:25,076
iOS 的硬件能很自然的

846
00:27:25,076 --> 00:27:27,336
支持这样做 

847
00:27:27,336 --> 00:27:29,406
但是

848
00:27:29,406 --> 00:27:31,066
这不是传统的台式机

849
00:27:31,066 --> 00:27:31,686
的硬件能够做到的

850
00:27:32,656 --> 00:27:33,906
所以我们将定制混合

851
00:27:33,906 --> 00:27:34,986
作为一个范例应用

852
00:27:34,986 --> 00:27:36,076
来介绍

853
00:27:36,076 --> 00:27:36,346
这个功能

854
00:27:38,076 --> 00:27:40,086
三角混合的经典例子

855
00:27:40,126 --> 00:27:41,316
是一个三角在

856
00:27:41,316 --> 00:27:41,836
另一个之上

857
00:27:42,776 --> 00:27:45,036
几乎所有现代的 GPU API

858
00:27:45,036 --> 00:27:46,386
都能保证在绘制调用命令中

859
00:27:46,386 --> 00:27:47,426
可以进行混合

860
00:27:47,566 --> 00:27:48,856
它能证明

861
00:27:48,926 --> 00:27:50,416
这个简便的

862
00:27:50,416 --> 00:27:50,946
串行执行的假想

863
00:27:51,796 --> 00:27:53,376
但是 事实上在幕后

864
00:27:53,376 --> 00:27:54,586
发生的事是

865
00:27:54,676 --> 00:27:56,026
GPU 硬件是高度并行的

866
00:27:56,026 --> 00:27:57,056
它将

867
00:27:57,056 --> 00:27:58,256
同时运行多个线程

868
00:27:58,836 --> 00:28:00,296
只有这个固定功能的

869
00:27:58,836 --> 00:28:00,296
只有这个固定功能的

870
00:28:00,296 --> 00:28:01,786
混合步骤最后能

871
00:28:01,786 --> 00:28:03,046
延迟到所有东西

872
00:28:03,046 --> 00:28:05,776
都重新有序排列之后	

873
00:28:05,776 --> 00:28:06,876
在混合步骤之前

874
00:28:06,876 --> 00:28:08,906
有一个隐式等待

875
00:28:10,476 --> 00:28:12,686
事情可能会随着顺序改变

876
00:28:12,686 --> 00:28:13,616
如果我们不是需要在

877
00:28:13,616 --> 00:28:14,766
片段射击的最后

878
00:28:14,766 --> 00:28:16,326
将事情排序 而是

879
00:28:16,416 --> 00:28:18,066
在正中间 因为如果这样

880
00:28:18,066 --> 00:28:20,156
三角一号想要在存储器里

881
00:28:20,156 --> 00:28:21,316
写东西 三角二号

882
00:28:21,316 --> 00:28:22,596
可以进行

883
00:28:22,596 --> 00:28:23,026
读取

884
00:28:23,306 --> 00:28:25,016
如果我们希望三角二号

885
00:28:25,016 --> 00:28:26,236
能够在其上增加 以及

886
00:28:26,236 --> 00:28:28,026
自定义三角一号的数据

887
00:28:28,026 --> 00:28:28,906
我们需要回到那个排序

888
00:28:29,646 --> 00:28:32,366
这基本上就是

889
00:28:32,366 --> 00:28:33,576
光栅顺序组可以提供的功能

890
00:28:34,706 --> 00:28:37,116
现在我要讲到

891
00:28:37,206 --> 00:28:38,156
着色器代码的例子

892
00:28:39,806 --> 00:28:41,116
如果我想要执行

893
00:28:41,116 --> 00:28:42,466
自定义的混合 一个无效

894
00:28:42,636 --> 00:28:44,456
初期的尝试

895
00:28:44,456 --> 00:28:45,726
将会替换我经典的

896
00:28:45,726 --> 00:28:46,696
图像帧缓存器

897
00:28:46,696 --> 00:28:47,996
为一个读写纹理

898
00:28:47,996 --> 00:28:49,696
它会直接对这个纹理

899
00:28:49,696 --> 00:28:50,636
执行渲染

900
00:28:50,636 --> 00:28:50,956
和混合

901
00:28:51,776 --> 00:28:53,976
当然如果我混合的线程

902
00:28:53,976 --> 00:28:55,206
还没有执行

903
00:28:55,206 --> 00:28:56,416
或者正在执行

904
00:28:56,416 --> 00:28:59,066
这整个

905
00:28:59,166 --> 00:29:00,596
修改编写顺序

906
00:28:59,166 --> 00:29:00,596
修改编写顺序

907
00:29:00,596 --> 00:29:01,546
会创建一个竞争条件

908
00:29:02,076 --> 00:29:03,876
所以我们如何使用光栅顺序组

909
00:29:03,876 --> 00:29:05,146
去修复它呢

910
00:29:05,316 --> 00:29:07,416
这非常非常简单

911
00:29:08,626 --> 00:29:10,146
我要做的就是

912
00:29:10,276 --> 00:29:12,996
在有冲突访问的存储器上

913
00:29:12,996 --> 00:29:14,086
添加一个新的属性

914
00:29:14,866 --> 00:29:16,906
这时 编译程序和硬件

915
00:29:16,906 --> 00:29:17,636
会开始

916
00:29:17,636 --> 00:29:18,876
合作 

917
00:29:18,876 --> 00:29:20,616
使整个一系列的着色器

918
00:29:20,866 --> 00:29:21,806
接入存储器

919
00:29:21,806 --> 00:29:22,996
从一开始

920
00:29:22,996 --> 00:29:24,176
到最后全部接入

921
00:29:24,176 --> 00:29:25,386
然后在屏幕后面将它

922
00:29:25,386 --> 00:29:26,366
转变成一个

923
00:29:26,366 --> 00:29:26,836
临界区

924
00:29:28,806 --> 00:29:29,826
你也可以将

925
00:29:29,826 --> 00:29:31,296
这个属性应用于普通的

926
00:29:31,296 --> 00:29:33,846
设备存储器指针上

927
00:29:34,536 --> 00:29:34,886
而不仅仅在纹理上

928
00:29:34,886 --> 00:29:37,606
所以通过这样做 我们得到了

929
00:29:37,606 --> 00:29:38,536
我们想要的线性调度

930
00:29:39,216 --> 00:29:40,406
线程一将继续运行

931
00:29:40,406 --> 00:29:42,116
和写入内存 而线程二号

932
00:29:42,116 --> 00:29:43,526
将停止 直到

933
00:29:43,526 --> 00:29:46,046
线程一的写入完成

934
00:29:46,046 --> 00:29:47,916
并给我们一个对

935
00:29:47,916 --> 00:29:51,576
存储器的几乎无冲突接入

936
00:29:51,926 --> 00:29:53,096
有一个

937
00:29:53,096 --> 00:29:54,106
非常重要的话题

938
00:29:54,106 --> 00:29:56,016
线程是

939
00:29:56,016 --> 00:29:57,266
相互同步的

940
00:29:57,706 --> 00:29:59,656
当然 GPU 硬件

941
00:29:59,656 --> 00:30:00,486
将要运行不止两个

942
00:29:59,656 --> 00:30:00,486
将要运行不止两个

943
00:30:00,486 --> 00:30:02,296
而是同时运行

944
00:30:02,296 --> 00:30:05,146
成千上万个线程

945
00:30:05,246 --> 00:30:06,396
事实上它可能

946
00:30:06,436 --> 00:30:07,746
从这些三角中

947
00:30:07,746 --> 00:30:09,136
同时运行

948
00:30:09,616 --> 00:30:12,056
所以 所有这些成千上万的

949
00:30:12,056 --> 00:30:12,816
线程

950
00:30:12,816 --> 00:30:13,966
哪个是彼此

951
00:30:13,966 --> 00:30:14,176
同步的

952
00:30:15,836 --> 00:30:17,786
我在这里高亮了像素

953
00:30:17,786 --> 00:30:18,986
因为这是这个问题的

954
00:30:18,986 --> 00:30:19,586
答案

955
00:30:20,356 --> 00:30:21,876
你 这个功能

956
00:30:21,876 --> 00:30:22,846
只能和其他线程同步

957
00:30:22,846 --> 00:30:23,986
即那些当下与你的

958
00:30:23,986 --> 00:30:25,526
片段射击线程重叠的

959
00:30:25,526 --> 00:30:27,516
那些线程

960
00:30:27,596 --> 00:30:29,106
对准同样的帧缓存的

961
00:30:29,106 --> 00:30:31,146
xy 位置的线程  对准同样的

962
00:30:31,146 --> 00:30:32,886
多样本的位置的线程

963
00:30:33,196 --> 00:30:34,306
对准同样的

964
00:30:34,306 --> 00:30:34,786
渲染目标指数的线程

965
00:30:36,726 --> 00:30:37,776
如果我希望

966
00:30:37,776 --> 00:30:39,096
它没有具体提供

967
00:30:39,136 --> 00:30:40,756
任何的保证

968
00:30:40,756 --> 00:30:41,836
让你能安全的

969
00:30:41,836 --> 00:30:43,376
由相邻像素写入的

970
00:30:43,376 --> 00:30:44,276
内存

971
00:30:45,366 --> 00:30:46,816
如果你的确需要这样的

972
00:30:46,816 --> 00:30:48,496
区域或者影响区域

973
00:30:48,496 --> 00:30:49,726
这样的算法

974
00:30:50,096 --> 00:30:51,156
你就需要回去使用

975
00:30:51,156 --> 00:30:52,326
绘制调用之间的完整内存屏障

976
00:30:52,356 --> 00:30:53,736
或者绘制调用或

977
00:30:53,736 --> 00:30:54,916
渲染通道之间的

978
00:30:54,916 --> 00:30:55,666
完整 API 屏障

979
00:30:56,376 --> 00:30:57,846
但是这会导致更加高的性能代价

980
00:30:57,846 --> 00:30:59,656
它也不能在

981
00:30:59,656 --> 00:31:00,876
你的三角与单个的

982
00:30:59,656 --> 00:31:00,876
你的三角与单个的

983
00:31:00,876 --> 00:31:02,236
绘制调用重叠时

984
00:31:02,236 --> 00:31:02,696
使用

985
00:31:03,336 --> 00:31:05,256
但是对于这些常用算法

986
00:31:05,256 --> 00:31:06,806
你只需要重叠

987
00:31:06,806 --> 00:31:08,206
只需要同步

988
00:31:08,836 --> 00:31:09,976
光栅顺序组能在

989
00:31:09,976 --> 00:31:11,286
大幅减少性能代价的情况下

990
00:31:11,286 --> 00:31:13,866
完成任务

991
00:31:13,866 --> 00:31:15,486
这是很简单的

992
00:31:15,676 --> 00:31:16,716
对于这个问题  这真的是

993
00:31:16,716 --> 00:31:17,356
我要说的全部了

994
00:31:17,396 --> 00:31:19,546
光栅顺序组让你

995
00:31:19,546 --> 00:31:21,246
高效的等待重叠

996
00:31:21,516 --> 00:31:24,046
并且只让重叠的线程来

997
00:31:24,046 --> 00:31:25,136
结束它们对存储器的访问

998
00:31:25,806 --> 00:31:27,586
这能让

999
00:31:27,586 --> 00:31:28,736
之前的一部分

1000
00:31:28,736 --> 00:31:30,026
太没有效率的 GPU 算法

1001
00:31:30,026 --> 00:31:31,296
在 GPU 硬件上被很好的使用

1002
00:31:33,516 --> 00:31:35,766
着色器中间线程的

1003
00:31:35,766 --> 00:31:37,076
总结是最新的

1004
00:31:37,076 --> 00:31:38,556
GPU 硬件的功能

1005
00:31:38,556 --> 00:31:39,286
你真的需要运行它来

1006
00:31:39,286 --> 00:31:40,426
试试看

1007
00:31:41,106 --> 00:31:42,446
特别的是

1008
00:31:42,446 --> 00:31:43,896
它被最新的 这一周刚发布的

1009
00:31:43,896 --> 00:31:45,256
AMD Vega GPU 支持 并且

1010
00:31:45,256 --> 00:31:46,356
也被过去几年的 Intel GPU

1011
00:31:46,356 --> 00:31:47,216
所支持

1012
00:31:49,136 --> 00:31:50,196
这就要提到

1013
00:31:50,196 --> 00:31:51,286
第二个功能 那就是

1014
00:31:51,286 --> 00:31:52,616
新的 iPad Pro 的 ProMotion

1015
00:31:52,616 --> 00:31:52,966
显示器

1016
00:32:01,056 --> 00:32:02,486
ProMotion 对

1017
00:32:02,616 --> 00:32:04,006
图形和游戏开发者来说

1018
00:32:04,006 --> 00:32:05,186
是一个很优秀的功能

1019
00:32:05,186 --> 00:32:06,226
我非常想向大家展示

1020
00:32:06,226 --> 00:32:07,626
我能用它干什么

1021
00:32:07,946 --> 00:32:10,466
这是第一个序列

1022
00:32:10,466 --> 00:32:11,606
的时间线图

1023
00:32:11,606 --> 00:32:13,946
我将向你们展示

1024
00:32:13,946 --> 00:32:15,606
它展示了当 GPU 开始和结束

1025
00:32:15,606 --> 00:32:16,916
制作帧 以及当

1026
00:32:16,916 --> 00:32:18,056
同样的帧

1027
00:32:18,056 --> 00:32:19,256
最终到达眼镜 使用户能够看到

1028
00:32:19,256 --> 00:32:19,526
的时间

1029
00:32:20,646 --> 00:32:22,116
ProMotion 做的第一件也是最明显的事

1030
00:32:22,116 --> 00:32:23,356
是使我们现在能

1031
00:32:23,356 --> 00:32:25,146
以每秒 120 帧

1032
00:32:25,146 --> 00:32:25,556
进行渲染

1033
00:32:27,316 --> 00:32:28,896
这对任何要求

1034
00:32:28,896 --> 00:32:29,896
高速动画制作的东西

1035
00:32:29,896 --> 00:32:31,616
对任何要求

1036
00:32:31,616 --> 00:32:32,796
严苛延迟的东西

1037
00:32:32,796 --> 00:32:34,096
例如对用户触摸的追踪或者铅笔输入

1038
00:32:34,096 --> 00:32:34,756
都非常好用

1039
00:32:35,576 --> 00:32:37,876
它确实有很多抓取

1040
00:32:37,876 --> 00:32:40,336
对于每个帧 你当然只有

1041
00:32:40,336 --> 00:32:42,146
一半的 CPU 和 GPU 时间能够用

1042
00:32:42,146 --> 00:32:43,596
所以你需要

1043
00:32:43,596 --> 00:32:44,356
花很多精力去

1044
00:32:44,356 --> 00:32:46,196
优化它 

1045
00:32:46,196 --> 00:32:47,276
这也会增加整个系统的

1046
00:32:47,276 --> 00:32:47,836
能量消耗

1047
00:32:48,816 --> 00:32:49,546
但是如果你得到了正确的内容

1048
00:32:49,546 --> 00:32:51,506
在它起作用的地方

1049
00:32:51,506 --> 00:32:52,686
它会回报在

1050
00:32:52,686 --> 00:32:53,576
用户体验上

1051
00:32:55,006 --> 00:32:56,566
但是 ProMotion 做到的

1052
00:32:56,566 --> 00:32:58,096
每秒渲染 120 帧

1053
00:32:58,096 --> 00:32:58,436
还要多

1054
00:32:59,176 --> 00:33:01,626
它同样为

1055
00:32:59,176 --> 00:33:01,626
它同样为

1056
00:33:01,626 --> 00:33:03,496
何时调换下一个图像到眼镜上

1057
00:33:03,496 --> 00:33:04,546
提供更多的

1058
00:33:04,546 --> 00:33:05,016
灵活性

1059
00:33:05,726 --> 00:33:07,776
我们没有限制 每秒渲染 120 帧

1060
00:33:07,776 --> 00:33:09,906
30 帧或者 60 帧

1061
00:33:10,486 --> 00:33:12,816
当你的应用执行

1062
00:33:12,816 --> 00:33:14,056
上下移动时

1063
00:33:14,056 --> 00:33:15,446
相比于

1064
00:33:15,716 --> 00:33:16,756
固定帧率的显示器

1065
00:33:16,756 --> 00:33:17,166
ProMotion 表现的更好

1066
00:33:18,376 --> 00:33:21,186
举个例子 我这里有

1067
00:33:21,226 --> 00:33:22,586
一个时间线图 它有点

1068
00:33:22,586 --> 00:33:23,926
你懂的

1069
00:33:23,926 --> 00:33:24,986
只是为了

1070
00:33:24,986 --> 00:33:26,356
达到每秒 60 帧消耗了太多 GPU

1071
00:33:26,516 --> 00:33:27,226
你知道他们

1072
00:33:27,226 --> 00:33:28,906
每 21 毫秒制作一个帧

1073
00:33:28,906 --> 00:33:30,366
或者说 1 秒制作

1074
00:33:30,366 --> 00:33:30,836
48 帧

1075
00:33:31,576 --> 00:33:33,466
GPU 很乐意这样做

1076
00:33:33,466 --> 00:33:35,526
但是在显示器这一边

1077
00:33:35,526 --> 00:33:37,076
我们只能每 16 毫秒刷新一次

1078
00:33:37,076 --> 00:33:38,176
最后我们只能得到

1079
00:33:38,176 --> 00:33:38,976
一个跳跃模式

1080
00:33:39,046 --> 00:33:40,126
这种不顺畅就使得

1081
00:33:40,126 --> 00:33:41,866
用户在眼镜上感觉到

1082
00:33:41,866 --> 00:33:42,916
有些帧

1083
00:33:42,916 --> 00:33:43,356
比其他的要慢得多

1084
00:33:44,056 --> 00:33:47,006
这一点也不好

1085
00:33:47,306 --> 00:33:48,866
基本上全世界

1086
00:33:48,866 --> 00:33:49,846
在这种情况下通用的做法

1087
00:33:49,846 --> 00:33:50,586
就是

1088
00:33:50,586 --> 00:33:51,976
人为的将帧率

1089
00:33:51,976 --> 00:33:53,776
降低到

1090
00:33:53,776 --> 00:33:56,336
每秒 30 帧

1091
00:33:56,336 --> 00:33:57,686
他们基本上是

1092
00:33:57,686 --> 00:33:59,036
将峰顶的帧率交换出去

1093
00:33:59,036 --> 00:33:59,926
以换得一定程度的

1094
00:33:59,926 --> 00:34:00,556
连续性

1095
00:33:59,926 --> 00:34:00,556
连续性

1096
00:34:02,176 --> 00:34:04,146
ProMotion 在这里做的好很多

1097
00:34:04,616 --> 00:34:05,636
如果我用

1098
00:34:05,636 --> 00:34:06,596
相同的应用

1099
00:34:06,596 --> 00:34:09,126
将它移动到一个 ProMotion 显示器上

1100
00:34:09,126 --> 00:34:09,755
它会对我们的时间线造成这样的影响

1101
00:34:10,826 --> 00:34:12,036
现在 我们

1102
00:34:12,036 --> 00:34:13,596
每 4 毫秒有了一个刷新点

1103
00:34:13,596 --> 00:34:14,356
而不是每 16 毫秒

1104
00:34:15,266 --> 00:34:16,646
我们赚得了时间

1105
00:34:16,866 --> 00:34:18,286
尽管 GPU 做着

1106
00:34:18,286 --> 00:34:19,286
和以前一样的工作

1107
00:34:19,906 --> 00:34:21,976
现在这个显示器

1108
00:34:21,976 --> 00:34:23,626
持续的

1109
00:34:23,626 --> 00:34:24,136
每秒显示 48 帧

1110
00:34:24,985 --> 00:34:26,466
用户现在既能

1111
00:34:26,466 --> 00:34:28,176
有最好的帧率

1112
00:34:28,176 --> 00:34:30,156
又能体验最佳的

1113
00:34:30,156 --> 00:34:30,545
持续性

1114
00:34:31,186 --> 00:34:32,116
我们以前做的交换

1115
00:34:32,116 --> 00:34:33,056
已经完全不需要了

1116
00:34:34,246 --> 00:34:37,096
此外 第二个例子是

1117
00:34:37,096 --> 00:34:38,996
这次 应用想要

1118
00:34:38,996 --> 00:34:41,295
制作每秒 60 帧

1119
00:34:41,295 --> 00:34:42,936
但是一帧运行的时间

1120
00:34:42,936 --> 00:34:44,666
稍微久了一点

1121
00:34:44,666 --> 00:34:48,295
我们做过了最后期限

1122
00:34:48,295 --> 00:34:49,886
在一个固定帧率的显示器上

1123
00:34:49,886 --> 00:34:50,826
在显示器这一边

1124
00:34:50,826 --> 00:34:51,856
我们可能会运用

1125
00:34:51,856 --> 00:34:53,126
与之前看到的相同的模式

1126
00:34:54,585 --> 00:34:56,416
ProMotion 同样可以修复这个问题

1127
00:34:57,576 --> 00:34:58,626
一号帧一旦在眼镜上

1128
00:34:58,626 --> 00:34:59,866
它将不会

1129
00:34:59,866 --> 00:35:01,336
被扩展到 16 毫秒

1130
00:34:59,866 --> 00:35:01,336
被扩展到 16 毫秒

1131
00:35:01,336 --> 00:35:02,666
而只是现在的 4 毫秒

1132
00:35:03,126 --> 00:35:04,526
用户感觉到的断断续续

1133
00:35:04,526 --> 00:35:06,446
会被极大程度的减少

1134
00:35:06,446 --> 00:35:09,066
二号帧和三号帧

1135
00:35:09,066 --> 00:35:11,336
他们的延迟被

1136
00:35:11,336 --> 00:35:12,286
拉回到

1137
00:35:12,286 --> 00:35:12,796
之前到位置

1138
00:35:13,426 --> 00:35:14,736
系统立刻

1139
00:35:14,736 --> 00:35:15,886
回到时间线上

1140
00:35:16,336 --> 00:35:19,136
延迟被提高

1141
00:35:19,136 --> 00:35:20,446
你的应用可以继续执行了

1142
00:35:20,516 --> 00:35:21,306
我们正好回到了

1143
00:35:21,306 --> 00:35:22,756
我们希望到达的位置

1144
00:35:23,416 --> 00:35:26,126
所以总结起来

1145
00:35:26,126 --> 00:35:27,816
它将动画变得

1146
00:35:27,816 --> 00:35:29,136
更坚定 更稳固

1147
00:35:29,136 --> 00:35:30,786
无论发生什么

1148
00:35:31,906 --> 00:35:33,816
那么你到底该

1149
00:35:33,816 --> 00:35:35,116
如何运用这些优势呢

1150
00:35:35,756 --> 00:35:38,576
对于一般的 UIKit 动画而言

1151
00:35:38,576 --> 00:35:39,546
例如 滚动观看目录或者视图

1152
00:35:39,546 --> 00:35:41,506
iOS 将完全以新的方式

1153
00:35:41,506 --> 00:35:42,516
来完成

1154
00:35:43,016 --> 00:35:44,506
它将在适合的时候

1155
00:35:44,506 --> 00:35:45,456
每秒渲染 120 帧

1156
00:35:45,526 --> 00:35:47,606
它也将在适合的时候

1157
00:35:47,696 --> 00:35:48,466
运用灵活的显示时间

1158
00:35:50,206 --> 00:35:51,256
Metal 应用

1159
00:35:51,256 --> 00:35:52,286
对时间更加敏感

1160
00:35:52,286 --> 00:35:53,466
所以对我们已经完成的功能

1161
00:35:53,466 --> 00:35:54,446
这是一个功能的选择

1162
00:35:55,766 --> 00:35:57,886
这个选择非常简单

1163
00:35:57,886 --> 00:35:59,186
你只需要在 bundle 目录下

1164
00:35:59,186 --> 00:36:00,106
的 info.plist 里添加一个

1165
00:35:59,186 --> 00:36:00,106
的 info.plist 里添加一个

1166
00:36:00,106 --> 00:36:00,866
新的入口

1167
00:36:01,596 --> 00:36:03,206
一旦你做了这个计时的行为

1168
00:36:03,206 --> 00:36:04,616
我们的三个 Metal 显示的

1169
00:36:04,616 --> 00:36:06,266
API 会出现

1170
00:36:06,266 --> 00:36:06,536
小的变化

1171
00:36:06,536 --> 00:36:07,536
我将为你们

1172
00:36:07,536 --> 00:36:08,846
介绍这三个 API 以及

1173
00:36:08,846 --> 00:36:09,456
他们如何改变的

1174
00:36:10,226 --> 00:36:12,066
我们的第一个

1175
00:36:12,066 --> 00:36:14,046
Metal 展示 API

1176
00:36:14,466 --> 00:36:14,966
正在进行

1177
00:36:15,616 --> 00:36:18,216
它即将

1178
00:36:18,216 --> 00:36:20,156
在 GPU 结束之后的下一个

1179
00:36:20,156 --> 00:36:21,206
可以使用的刷新点上

1180
00:36:21,206 --> 00:36:22,676
把我的图像

1181
00:36:22,726 --> 00:36:24,306
显示在眼镜上

1182
00:36:25,376 --> 00:36:26,596
在固定帧率的硬件上

1183
00:36:26,596 --> 00:36:28,566
这是 16 毫秒

1184
00:36:28,566 --> 00:36:29,956
在 iPad Pro 上

1185
00:36:29,956 --> 00:36:30,626
现在是 4 毫秒

1186
00:36:31,296 --> 00:36:32,866
这是使用最简单的 API

1187
00:36:32,866 --> 00:36:33,726
因为它不需要运行

1188
00:36:33,726 --> 00:36:35,046
因此它也是在这个房间里的

1189
00:36:35,046 --> 00:36:35,966
大部分人都在使用的

1190
00:36:35,966 --> 00:36:36,296
API

1191
00:36:37,416 --> 00:36:38,476
这也是让你以

1192
00:36:38,476 --> 00:36:40,056
最低延迟

1193
00:36:40,056 --> 00:36:40,466
接入显示屏的 API

1194
00:36:41,296 --> 00:36:43,236
它一样能工作在我们的

1195
00:36:43,236 --> 00:36:44,596
固定帧率以及 ProMotion

1196
00:36:44,596 --> 00:36:46,636
硬件上 一旦你选择它

1197
00:36:46,636 --> 00:36:47,486
它将以非常好的粒度

1198
00:36:47,486 --> 00:36:47,976
进行工作

1199
00:36:51,646 --> 00:36:53,116
我们的第二个

1200
00:36:53,116 --> 00:36:54,996
Metal 展示 API

1201
00:36:54,996 --> 00:36:56,036
可以显示最短时间

1202
00:36:56,806 --> 00:36:59,236
图像无论何时

1203
00:36:59,236 --> 00:37:00,766
登陆眼镜

1204
00:36:59,236 --> 00:37:00,766
登陆眼镜

1205
00:37:00,766 --> 00:37:01,836
它将能使它固定在眼镜里

1206
00:37:01,836 --> 00:37:02,486
一段时间

1207
00:37:03,046 --> 00:37:03,956
如果我的图片在眼镜里

1208
00:37:03,956 --> 00:37:04,966
被放了在这里

1209
00:37:04,966 --> 00:37:06,076
它将持续 33 微秒

1210
00:37:06,076 --> 00:37:08,176
如果我的开始时间变化了

1211
00:37:08,176 --> 00:37:08,896
结束时间也会相应变化

1212
00:37:09,576 --> 00:37:11,116
如果你想要

1213
00:37:11,116 --> 00:37:12,386
帧与帧之间

1214
00:37:12,386 --> 00:37:13,796
有完美的连续性的帧率 这就是你要的 API

1215
00:37:14,416 --> 00:37:16,146
它在每秒 30 帧的时候

1216
00:37:16,146 --> 00:37:17,616
在每秒 60 帧的显示屏上

1217
00:37:17,856 --> 00:37:19,406
尤其有效

1218
00:37:19,406 --> 00:37:20,316
虽然它有时候在

1219
00:37:20,316 --> 00:37:21,446
ProMotion 上也很有效

1220
00:37:22,416 --> 00:37:24,706
而我们第三个展示的

1221
00:37:24,706 --> 00:37:25,916
变化是

1222
00:37:25,916 --> 00:37:26,386
目前最有趣的

1223
00:37:26,596 --> 00:37:28,406
它会在特定的时间显示

1224
00:37:28,736 --> 00:37:30,486
它做的事情和它听起来

1225
00:37:30,486 --> 00:37:30,996
一样

1226
00:37:31,736 --> 00:37:33,106
如果 GPU 在设定时间之前

1227
00:37:33,106 --> 00:37:34,436
就早早完成了 显示器会

1228
00:37:34,436 --> 00:37:34,836
等候

1229
00:37:35,196 --> 00:37:36,556
如果 GPU 超过了你的

1230
00:37:36,556 --> 00:37:37,966
时间限制 显示器会

1231
00:37:37,966 --> 00:37:39,606
在下一个可用的点将它

1232
00:37:39,606 --> 00:37:40,536
取出

1233
00:37:41,666 --> 00:37:44,256
如果你想创建一个完全

1234
00:37:44,256 --> 00:37:45,376
定制的动画和时间循环

1235
00:37:45,376 --> 00:37:46,596
这就是关键的 API

1236
00:37:47,286 --> 00:37:49,036
这个 API 的展示和时间

1237
00:37:49,116 --> 00:37:50,656
和 ProMotion 显示器相结合

1238
00:37:51,096 --> 00:37:52,286
基本上可以让你抛弃

1239
00:37:52,286 --> 00:37:53,446
固定帧率的概念

1240
00:37:53,446 --> 00:37:54,696
在用户将要

1241
00:37:54,696 --> 00:37:56,206
看到内容的时候

1242
00:37:56,206 --> 00:37:57,196
再进行渲染

1243
00:37:58,006 --> 00:37:59,296
如果你想要你的 Metal 视图

1244
00:37:59,296 --> 00:38:00,516
和其他正在系统里发生的东西

1245
00:37:59,296 --> 00:38:00,516
和其他正在系统里发生的东西

1246
00:38:00,516 --> 00:38:01,416
完全同步

1247
00:38:01,416 --> 00:38:03,386
例如音频 或者你想要

1248
00:38:03,386 --> 00:38:04,236
为所有的外观提供

1249
00:38:04,236 --> 00:38:05,476
零延时

1250
00:38:05,476 --> 00:38:06,606
然后在你的用户

1251
00:38:06,606 --> 00:38:07,766
将要看到内容的时候

1252
00:38:07,766 --> 00:38:09,176
再推进对象

1253
00:38:09,176 --> 00:38:11,036
这是能让你实现这些

1254
00:38:11,036 --> 00:38:11,846
的工具

1255
00:38:13,266 --> 00:38:14,116
当然在这里的技巧

1256
00:38:14,116 --> 00:38:15,326
是在下一个显示时间

1257
00:38:15,326 --> 00:38:15,896
执行对象

1258
00:38:15,896 --> 00:38:16,596
这就是你的功能

1259
00:38:17,616 --> 00:38:18,776
为了实现它 你需要一些

1260
00:38:18,776 --> 00:38:19,986
来自系统的反馈

1261
00:38:19,986 --> 00:38:21,146
来帮助你抉择

1262
00:38:21,146 --> 00:38:22,166
你真正执行的是什么

1263
00:38:22,196 --> 00:38:23,356
现在我们也把它加上了

1264
00:38:24,646 --> 00:38:26,966
所以 Metal 可绘制对象

1265
00:38:26,966 --> 00:38:28,156
是一个暂时的对象

1266
00:38:28,156 --> 00:38:29,496
它可以在显示系统里

1267
00:38:29,496 --> 00:38:30,746
追踪一个被你渲染的图像

1268
00:38:30,746 --> 00:38:31,516
的一生

1269
00:38:31,736 --> 00:38:34,896
现在它可以在特定的

1270
00:38:34,896 --> 00:38:36,426
图像显示在眼镜上时被查询到

1271
00:38:36,426 --> 00:38:37,606
当这件事发生时

1272
00:38:37,606 --> 00:38:38,346
你也可以获得一个

1273
00:38:38,346 --> 00:38:38,866
回调函数

1274
00:38:39,906 --> 00:38:41,466
所以现在你可以知道你的图片

1275
00:38:41,466 --> 00:38:42,696
什么时候会显示在眼镜上

1276
00:38:43,076 --> 00:38:44,656
以及它们被移除的时间

1277
00:38:44,656 --> 00:38:45,696
你有关键的信号 能够使你知道

1278
00:38:45,696 --> 00:38:47,356
什么时候你在获得

1279
00:38:47,356 --> 00:38:48,436
你预期中的时间 

1280
00:38:48,436 --> 00:38:49,876
什么时候你没有

1281
00:38:49,876 --> 00:38:51,156
然后给你一个信号

1282
00:38:51,156 --> 00:38:51,706
以调整未来的帧

1283
00:38:54,176 --> 00:38:56,146
这就是 ProMotion 的故事

1284
00:38:56,146 --> 00:38:57,276
你将在未来 

1285
00:38:57,276 --> 00:38:58,296
在新的 iPad Pro 上

1286
00:38:58,296 --> 00:38:59,326
使用它

1287
00:38:59,936 --> 00:39:01,566
在应用中几乎没有代码改变

1288
00:38:59,936 --> 00:39:01,566
在应用中几乎没有代码改变

1289
00:39:01,566 --> 00:39:02,706
的情况下

1290
00:39:02,706 --> 00:39:05,256
要想获得更多的连续性和

1291
00:39:05,256 --> 00:39:06,496
更高的帧率是

1292
00:39:06,496 --> 00:39:07,246
非常容易的

1293
00:39:07,646 --> 00:39:10,306
从这里开始 它将给你一个选项菜单

1294
00:39:10,306 --> 00:39:11,606
让你选择哪一个

1295
00:39:11,606 --> 00:39:12,766
显示时间模型会

1296
00:39:12,766 --> 00:39:13,906
对你的 app

1297
00:39:13,906 --> 00:39:14,126
产生更多好处

1298
00:39:14,976 --> 00:39:16,356
一个非常非常快的

1299
00:39:16,406 --> 00:39:18,216
Twitch 电子游戏或者

1300
00:39:18,216 --> 00:39:19,986
需要对触摸和铅笔输入进行追踪的应用

1301
00:39:19,986 --> 00:39:21,286
可能需要达到

1302
00:39:21,286 --> 00:39:22,036
每秒 120 帧

1303
00:39:22,646 --> 00:39:24,386
一个非常高端的渲染标题

1304
00:39:24,386 --> 00:39:25,766
可能需要保持

1305
00:39:25,836 --> 00:39:27,156
每秒 30 帧到 60 帧

1306
00:39:27,156 --> 00:39:28,176
或者这之间的一个数

1307
00:39:28,176 --> 00:39:30,456
以享受稳定连续的优势

1308
00:39:31,136 --> 00:39:32,266
一些想要

1309
00:39:32,266 --> 00:39:33,166
完全掌控它们的

1310
00:39:33,166 --> 00:39:34,506
时间循环的应用在这里

1311
00:39:34,506 --> 00:39:35,546
有全新的功能

1312
00:39:36,776 --> 00:39:37,956
无论你的 app 是什么

1313
00:39:37,956 --> 00:39:39,966
ProMotion 给予你这个

1314
00:39:39,966 --> 00:39:41,186
强大的新工具

1315
00:39:41,186 --> 00:39:42,446
去支持它特定的

1316
00:39:42,446 --> 00:39:42,726
动画需求

1317
00:39:42,726 --> 00:39:45,306
这就是 ProMotion

1318
00:39:46,016 --> 00:39:48,846
接下来 我有一个完全不同的

1319
00:39:48,936 --> 00:39:50,346
显示话题要谈一谈

1320
00:39:50,346 --> 00:39:51,256
那就是我们称为直接显示的

1321
00:39:51,256 --> 00:39:52,326
功能

1322
00:39:54,236 --> 00:39:56,206
所以在你的 GPU 

1323
00:39:56,206 --> 00:39:58,036
完成渲染你的

1324
00:39:58,036 --> 00:39:59,306
内容和显示之后

1325
00:39:59,306 --> 00:40:00,426
发生的事情会变的

1326
00:39:59,306 --> 00:40:00,426
发生的事情会变的

1327
00:40:00,426 --> 00:40:01,066
复杂一些

1328
00:40:01,116 --> 00:40:02,886
然后你的图像有两条

1329
00:40:02,886 --> 00:40:04,836
可以通往显示屏的路径

1330
00:40:04,836 --> 00:40:07,016
由 GPU 组合

1331
00:40:08,116 --> 00:40:08,306
然后直接放到显示屏上显示

1332
00:40:08,426 --> 00:40:10,256
它们中的第一个是

1333
00:40:10,256 --> 00:40:11,956
你的经典用户界面场景

1334
00:40:12,486 --> 00:40:13,446
我会在这里获得一系列的

1335
00:40:13,446 --> 00:40:15,086
视图 层级 和窗口

1336
00:40:15,086 --> 00:40:17,426
然后这个时候

1337
00:40:17,426 --> 00:40:18,376
系统会将

1338
00:40:18,376 --> 00:40:19,136
它们统统取出

1339
00:40:19,136 --> 00:40:19,496
然后将它们组合起来

1340
00:40:19,636 --> 00:40:20,776
它将缩放任何内容的比例

1341
00:40:20,776 --> 00:40:21,396
以适应显示屏

1342
00:40:21,396 --> 00:40:21,906
它将展示

1343
00:40:21,906 --> 00:40:22,796
色彩和空间的变换

1344
00:40:22,796 --> 00:40:23,746
它将进行

1345
00:40:23,746 --> 00:40:24,776
任何核心的图像过滤或者

1346
00:40:24,776 --> 00:40:26,056
混合 然后它将

1347
00:40:26,056 --> 00:40:27,516
产生一个用户看到的

1348
00:40:27,516 --> 00:40:28,636
最终的组合图像

1349
00:40:30,776 --> 00:40:32,436
这对于功能完善的

1350
00:40:32,436 --> 00:40:33,676
用户界面

1351
00:40:33,676 --> 00:40:34,586
是非常关键的抽象

1352
00:40:35,106 --> 00:40:38,136
但是它也全部是在 GPU 上完成

1353
00:40:38,136 --> 00:40:39,186
而且它会消耗一些时间和

1354
00:40:39,186 --> 00:40:39,706
内存

1355
00:40:40,436 --> 00:40:41,746
如果我们创建一个

1356
00:40:41,746 --> 00:40:42,646
全屏幕的应用

1357
00:40:42,646 --> 00:40:44,046
这对它来说

1358
00:40:44,046 --> 00:40:45,136
就有点过度了

1359
00:40:45,136 --> 00:40:46,316
这就是直接显示模式

1360
00:40:46,316 --> 00:40:48,106
介入的时候了

1361
00:40:48,256 --> 00:40:49,236
如果这些操作都没有被要求

1362
00:40:49,236 --> 00:40:51,496
我们可以

1363
00:40:51,496 --> 00:40:52,936
直接让显示器硬件指向你

1364
00:40:52,976 --> 00:40:54,216
刚刚渲染过的内存

1365
00:40:54,586 --> 00:40:55,856
而不需要任何

1366
00:40:55,856 --> 00:40:55,986
中间人

1367
00:40:57,646 --> 00:40:59,026
我们怎么做到的呢

1368
00:40:59,406 --> 00:41:01,196
事实证明 其实没有一个

1369
00:40:59,406 --> 00:41:01,196
事实证明 其实没有一个

1370
00:41:01,196 --> 00:41:02,716
API 能够直接

1371
00:41:02,716 --> 00:41:03,146
指向显示器

1372
00:41:03,916 --> 00:41:05,566
这个模式实际上是

1373
00:41:05,566 --> 00:41:06,796
任何需要 GPU 组合器

1374
00:41:06,796 --> 00:41:08,166
介入的遗漏

1375
00:41:08,836 --> 00:41:10,386
当组合器看到你的

1376
00:41:10,386 --> 00:41:11,596
场景设置 然后发现

1377
00:41:11,596 --> 00:41:13,026
这里没有需要它做的

1378
00:41:13,026 --> 00:41:14,686
这时候

1379
00:41:14,686 --> 00:41:15,626
它将离开

1380
00:41:16,426 --> 00:41:18,176
所以 你应该怎样设置你的场景

1381
00:41:18,176 --> 00:41:20,726
以使合成器

1382
00:41:20,726 --> 00:41:22,756
直接离开

1383
00:41:23,216 --> 00:41:23,706
其实这是

1384
00:41:23,706 --> 00:41:24,916
非常直观的感受

1385
00:41:24,966 --> 00:41:26,166
我的内容是否需要任何

1386
00:41:26,166 --> 00:41:27,106
非重要过程

1387
00:41:27,106 --> 00:41:27,846
语音处理就是一个

1388
00:41:27,846 --> 00:41:29,336
非常直观的开始

1389
00:41:30,066 --> 00:41:31,146
但更具体来说

1390
00:41:31,146 --> 00:41:32,166
你希望你的层级是不透明的

1391
00:41:32,726 --> 00:41:33,756
我不希望它与任何东西

1392
00:41:33,756 --> 00:41:34,096
混合

1393
00:41:34,716 --> 00:41:36,616
我们不想运用任何

1394
00:41:36,616 --> 00:41:37,716
需要核心动画或者

1395
00:41:37,716 --> 00:41:38,666
窗口服务器

1396
00:41:38,916 --> 00:41:39,946
来修改我们的像素

1397
00:41:39,946 --> 00:41:40,836
我们不想在我们的视图里

1398
00:41:40,836 --> 00:41:42,406
或者遮蔽或者过滤器这一类的东西

1399
00:41:42,406 --> 00:41:44,326
放置圆角控件

1400
00:41:45,656 --> 00:41:46,896
我们想创建一个全屏幕

1401
00:41:47,226 --> 00:41:49,496
如果你的内容

1402
00:41:49,496 --> 00:41:51,256
不完全符合

1403
00:41:51,256 --> 00:41:52,436
屏幕的纵横比例 

1404
00:41:52,436 --> 00:41:53,896
你可以用全屏的 不透明的 黑色的

1405
00:41:53,896 --> 00:41:55,016
背景层来给予

1406
00:41:55,016 --> 00:41:56,396
黑色菜单栏一类的效果

1407
00:41:56,396 --> 00:41:57,216
但是最终我们还是希望

1408
00:41:57,216 --> 00:41:58,516
能模糊所有的东西

1409
00:42:01,456 --> 00:42:02,656
我们希望选择一个

1410
00:42:02,656 --> 00:42:03,636
能匹配本来面板的

1411
00:42:03,636 --> 00:42:04,306
渲染分辨率

1412
00:42:05,176 --> 00:42:06,416
这是有一点技巧性的

1413
00:42:06,416 --> 00:42:07,616
因为我们所有的

1414
00:42:07,616 --> 00:42:09,056
在 macOS 和 iOS 上搭载的

1415
00:42:09,056 --> 00:42:10,556
硬件都是有

1416
00:42:10,556 --> 00:42:12,446
虚拟桌面模式或者分辨率模式

1417
00:42:12,446 --> 00:42:13,696
它们都比真实的物理面板

1418
00:42:13,696 --> 00:42:14,676
要大

1419
00:42:14,766 --> 00:42:16,216
我们想做的最后一件事

1420
00:42:16,216 --> 00:42:17,356
是花时间去渲染很多的

1421
00:42:17,356 --> 00:42:18,256
像素 其实只要

1422
00:42:18,286 --> 00:42:19,456
在 GPU 上花时间然后再把时间

1423
00:42:19,456 --> 00:42:19,976
缩减回来就行了

1424
00:42:24,466 --> 00:42:25,846
最后 你想选择

1425
00:42:25,846 --> 00:42:26,976
颜色 空间 像素帧

1426
00:42:26,976 --> 00:42:28,046
那些显示硬件

1427
00:42:28,046 --> 00:42:29,186
会很高兴的直接读取的内容

1428
00:42:30,116 --> 00:42:31,126
在这里 

1429
00:42:31,126 --> 00:42:32,216
这里有无限组合数

1430
00:42:32,216 --> 00:42:33,986
所以在这里我想

1431
00:42:33,986 --> 00:42:34,656
给你们一个

1432
00:42:34,656 --> 00:42:35,986
关于一些特殊

1433
00:42:35,986 --> 00:42:36,916
和高效组合数

1434
00:42:36,916 --> 00:42:37,576
的白名单

1435
00:42:39,926 --> 00:42:41,596
在最上方是我们的

1436
00:42:41,596 --> 00:42:44,556
老朋友 SRGB8888

1437
00:42:44,556 --> 00:42:45,496
这基本上是绝大多数应用

1438
00:42:45,496 --> 00:42:46,986
通用的像素格式

1439
00:42:46,986 --> 00:42:48,806
也是所有硬件都

1440
00:42:48,806 --> 00:42:50,626
乐于读取的

1441
00:42:50,626 --> 00:42:51,776
对于大多数人来说

1442
00:42:51,776 --> 00:42:52,196
这就是他们需要的全部了

1443
00:42:53,666 --> 00:42:55,876
但是我们已经在

1444
00:42:55,876 --> 00:42:58,096
macOS 和 iOS 硬件上都

1445
00:42:58,096 --> 00:43:00,806
搭载了广色域的 P3 显示器

1446
00:42:58,096 --> 00:43:00,806
搭载了广色域的 P3 显示器

1447
00:43:01,106 --> 00:43:02,246
如果你的应用

1448
00:43:02,246 --> 00:43:03,766
希望开始运用这个功能

1449
00:43:03,766 --> 00:43:04,926
来显示更多的颜色

1450
00:43:04,926 --> 00:43:06,016
你需要

1451
00:43:06,016 --> 00:43:06,396
注意一下这里

1452
00:43:06,396 --> 00:43:09,676
在这里 iOS 和 macOS 两者的概念

1453
00:43:09,676 --> 00:43:11,086
是一样的

1454
00:43:11,086 --> 00:43:11,996
虽然在细节上

1455
00:43:11,996 --> 00:43:13,316
有所不同

1456
00:43:13,316 --> 00:43:14,686
在这两者中 我们都希望

1457
00:43:14,686 --> 00:43:15,846
渲染加入像素格式

1458
00:43:17,266 --> 00:43:20,106
但是请注意 如果你

1459
00:43:20,106 --> 00:43:21,566
在 P3 显示器上

1460
00:43:21,566 --> 00:43:23,286
渲染 P3 的内容 那没有问题 

1461
00:43:23,286 --> 00:43:25,686
但如果你渲染了 P3 内容

1462
00:43:25,686 --> 00:43:28,166
然后在 SRGB 的系统里去显示

1463
00:43:28,166 --> 00:43:29,266
那么 GPU 合成器可能会

1464
00:43:29,266 --> 00:43:30,326
参与进来并将色域

1465
00:43:30,326 --> 00:43:31,426
压缩以适应

1466
00:43:31,426 --> 00:43:31,796
显示器

1467
00:43:32,706 --> 00:43:34,206
所以 P3

1468
00:43:34,206 --> 00:43:34,816
不是你在任何时间

1469
00:43:34,816 --> 00:43:35,996
都想要做的

1470
00:43:36,106 --> 00:43:37,166
你最好看一看

1471
00:43:37,226 --> 00:43:39,466
当下的显示器是什么

1472
00:43:39,466 --> 00:43:40,616
然后在现有条件下工作

1473
00:43:40,986 --> 00:43:43,356
最后  为了完整性

1474
00:43:43,356 --> 00:43:44,726
我也要列出 RGBA float 16

1475
00:43:44,726 --> 00:43:45,866
它基本上是

1476
00:43:45,866 --> 00:43:48,116
普遍适应的 宽色域 

1477
00:43:48,116 --> 00:43:49,406
高动态范围的像素格式

1478
00:43:49,956 --> 00:43:52,086
虽然

1479
00:43:52,086 --> 00:43:53,266
这对 macOS 的

1480
00:43:53,266 --> 00:43:54,466
扩展数据范围功能也很必要

1481
00:43:55,196 --> 00:43:56,076
值得注意的是

1482
00:43:56,076 --> 00:43:57,476
它也确实需要在所有情况下

1483
00:43:57,476 --> 00:43:57,976
运行组成 GPU 组合

1484
00:44:01,646 --> 00:44:02,566
所以就像我提到的 

1485
00:44:02,566 --> 00:44:03,776
如果你编写了一个 

1486
00:44:03,776 --> 00:44:04,716
广色域识别的应用

1487
00:44:04,716 --> 00:44:05,586
你确实需要考虑条件

1488
00:44:06,376 --> 00:44:07,776
幸运的是 UIKit 和

1489
00:44:07,776 --> 00:44:08,596
AppKit 都提供了非常

1490
00:44:08,596 --> 00:44:08,976
简便的 API 检查方式

1491
00:44:13,256 --> 00:44:14,786
所以 最后一步是 你怎么知道

1492
00:44:14,786 --> 00:44:16,056
你是否在

1493
00:44:16,056 --> 00:44:17,646
定向显示路径上

1494
00:44:17,646 --> 00:44:18,676
这张截屏显示的是

1495
00:44:18,676 --> 00:44:19,966
Metal 系统的

1496
00:44:19,966 --> 00:44:20,566
追踪工具

1497
00:44:20,676 --> 00:44:23,376
Metal 系统追踪是

1498
00:44:23,426 --> 00:44:25,006
一个能给你实时的

1499
00:44:25,006 --> 00:44:26,656
CPU 和 GPU 显示器时间轴的

1500
00:44:26,656 --> 00:44:27,886
开发工具

1501
00:44:28,216 --> 00:44:30,106
这基本上是

1502
00:44:30,106 --> 00:44:30,996
我之前给大家展示过的

1503
00:44:30,996 --> 00:44:31,636
图像的

1504
00:44:31,636 --> 00:44:32,236
真实版本

1505
00:44:33,396 --> 00:44:35,216
所以在这里

1506
00:44:35,216 --> 00:44:36,596
我要将渲染过的三个帧

1507
00:44:36,596 --> 00:44:37,016
高亮显示出来

1508
00:44:37,546 --> 00:44:39,106
这个有颜色的时间间隔是我

1509
00:44:39,106 --> 00:44:40,126
自己的应用渲染

1510
00:44:41,296 --> 00:44:42,716
这个灰色的间隔是

1511
00:44:42,716 --> 00:44:44,446
GPU 里的其他过程

1512
00:44:44,496 --> 00:44:46,806
我能在窗口底部

1513
00:44:46,806 --> 00:44:47,666
获得更多细节

1514
00:44:47,666 --> 00:44:48,306
我也能从背板 D 上看到它

1515
00:44:48,306 --> 00:44:50,836
这是 iOS 合成

1516
00:44:50,836 --> 00:44:51,406
的过程

1517
00:44:51,596 --> 00:44:52,606
这是我的应用

1518
00:44:52,606 --> 00:44:53,676
到 GPU 合成路径上的

1519
00:44:53,676 --> 00:44:55,946
例子

1520
00:44:55,946 --> 00:44:56,896
回到之前 重新访问

1521
00:44:56,896 --> 00:44:59,166
一些我们的最佳实践例子

1522
00:44:59,166 --> 00:45:00,486
会将它们从图片上移除

1523
00:44:59,166 --> 00:45:00,486
会将它们从图片上移除

1524
00:45:00,486 --> 00:45:02,116
现在我可以返还我的 Metal 系统追踪

1525
00:45:02,556 --> 00:45:04,026
我有一个时间轴

1526
00:45:04,026 --> 00:45:05,626
可以通过它看到我已经

1527
00:45:05,716 --> 00:45:06,616
完全的

1528
00:45:06,616 --> 00:45:06,976
拥有了 GPU

1529
00:45:10,046 --> 00:45:12,006
这就是

1530
00:45:12,146 --> 00:45:12,756
直接显示

1531
00:45:12,756 --> 00:45:14,086
我们的系统合成器可以

1532
00:45:14,086 --> 00:45:15,406
在屏幕后制造很多魔法

1533
00:45:15,406 --> 00:45:16,746
以使全功能的

1534
00:45:16,746 --> 00:45:18,626
用户界面成为可能

1535
00:45:18,626 --> 00:45:19,706
但是这会产生性能消耗

1536
00:45:19,706 --> 00:45:20,976
因为要使用 GPU 来

1537
00:45:20,976 --> 00:45:21,426
做到它

1538
00:45:22,396 --> 00:45:23,456
通过了解

1539
00:45:23,456 --> 00:45:24,036
你在要求

1540
00:45:24,036 --> 00:45:25,536
合成器做什么 或者

1541
00:45:25,536 --> 00:45:26,896
更重要的是 别问

1542
00:45:26,896 --> 00:45:28,186
你没让合成器做的事

1543
00:45:28,186 --> 00:45:30,046
它就能不使用 GPU

1544
00:45:30,046 --> 00:45:31,816
从而离开

1545
00:45:31,816 --> 00:45:32,766
并返还给你一些时间

1546
00:45:33,496 --> 00:45:35,536
iOS 和 Tos 一直

1547
00:45:35,536 --> 00:45:37,046
支持直接显示

1548
00:45:37,046 --> 00:45:39,056
这对 macOS High Sierra 的

1549
00:45:39,056 --> 00:45:40,356
Metal 应用来说是

1550
00:45:40,356 --> 00:45:40,976
全新的

1551
00:45:45,366 --> 00:45:46,536
所以 讲到它 我想提到今天的

1552
00:45:46,536 --> 00:45:48,136
最后一个话题和

1553
00:45:48,136 --> 00:45:50,576
一些其他的东西

1554
00:45:50,616 --> 00:45:51,716
我们为 Metal 2 

1555
00:45:51,716 --> 00:45:52,826
在核心结构和设计语言上

1556
00:45:52,826 --> 00:45:54,056
做了很多添加

1557
00:45:54,056 --> 00:45:55,306
所以现在我不打算

1558
00:45:55,306 --> 00:45:56,226
深入的讲这些东西

1559
00:45:56,226 --> 00:45:56,896
但是我想先给你们一个

1560
00:45:56,896 --> 00:45:57,236
调查

1561
00:45:57,716 --> 00:46:01,036
我们很快的添加了

1562
00:45:57,716 --> 00:46:01,036
我们很快的添加了

1563
00:46:01,036 --> 00:46:02,026
新的 API 使它能够

1564
00:46:02,026 --> 00:46:03,916
质询 GPU

1565
00:46:03,916 --> 00:46:05,316
为每个缓存器

1566
00:46:05,316 --> 00:46:06,446
每个纹理 每个堆分配了多少内存

1567
00:46:06,736 --> 00:46:08,996
这将屏幕后

1568
00:46:08,996 --> 00:46:09,576
发生的事情

1569
00:46:09,576 --> 00:46:10,666
考虑在了其中

1570
00:46:10,666 --> 00:46:12,496
例如对齐和多种填充

1571
00:46:13,156 --> 00:46:13,996
这能为你究竟

1572
00:46:13,996 --> 00:46:15,356
使用了多少 GPU 内存

1573
00:46:15,356 --> 00:46:16,586
提供一个更准确的视角

1574
00:46:16,586 --> 00:46:19,466
我们在 Metal 设备上也有

1575
00:46:19,466 --> 00:46:22,006
一个折叠查询

1576
00:46:22,006 --> 00:46:23,766
它是你整个处理过程的

1577
00:46:23,766 --> 00:46:24,786
GPU 内存使用情况

1578
00:46:25,106 --> 00:46:26,716
这是尤其显著的

1579
00:46:26,716 --> 00:46:28,616
因为它包括了

1580
00:46:28,616 --> 00:46:29,616
所有对你不可见的

1581
00:46:29,616 --> 00:46:30,966
由驱动程序分配的内存

1582
00:46:30,966 --> 00:46:33,156
类似于

1583
00:46:33,156 --> 00:46:34,676
放置着色器代码的内存

1584
00:46:34,676 --> 00:46:35,686
命令缓存器或者其他类似的

1585
00:46:35,686 --> 00:46:36,076
东西

1586
00:46:36,576 --> 00:46:37,516
这能让你知道你

1587
00:46:37,516 --> 00:46:38,216
在哪里是关联的

1588
00:46:38,216 --> 00:46:38,946
你知道所有东西的

1589
00:46:38,946 --> 00:46:39,976
内存使用目标

1590
00:46:43,736 --> 00:46:44,666
我们有几个

1591
00:46:44,666 --> 00:46:45,586
面向计算机的添加

1592
00:46:46,026 --> 00:46:47,246
我们第一个添加的

1593
00:46:47,246 --> 00:46:48,276
是一系列着色语言功能

1594
00:46:48,276 --> 00:46:49,636
以帮助

1595
00:46:49,636 --> 00:46:50,826
你能够在 SIMD 组的

1596
00:46:50,826 --> 00:46:51,976
线程之间转换

1597
00:46:52,176 --> 00:46:54,306
如果你还不熟悉的话

1598
00:46:54,306 --> 00:46:55,526
GPU 硬件获得一个

1599
00:46:55,746 --> 00:46:57,606
单个顶点片段

1600
00:46:57,606 --> 00:46:59,586
然后计算着色器线程进入

1601
00:46:59,586 --> 00:47:00,756
SIMD 组 然后一起执行它们

1602
00:46:59,586 --> 00:47:00,756
SIMD 组 然后一起执行它们

1603
00:47:00,756 --> 00:47:01,986
以获得更好的效率

1604
00:47:02,536 --> 00:47:04,266
它们也被称为

1605
00:47:04,266 --> 00:47:04,726
wayfrencer warp

1606
00:47:05,766 --> 00:47:07,386
在一个组里 这些线程

1607
00:47:07,386 --> 00:47:08,506
有能力不加载或者

1608
00:47:08,506 --> 00:47:09,756
储存内存 

1609
00:47:09,756 --> 00:47:10,796
直接进行对话

1610
00:47:11,386 --> 00:47:13,126
它们可以从一个

1611
00:47:13,126 --> 00:47:14,226
线程的寄存器读取值然后

1612
00:47:14,226 --> 00:47:15,096
将它们写入另一个

1613
00:47:15,096 --> 00:47:15,666
线程寄存器

1614
00:47:15,796 --> 00:47:16,516
这些就是

1615
00:47:16,516 --> 00:47:17,506
新的标准库

1616
00:47:17,506 --> 00:47:17,816
允许的内容

1617
00:47:18,916 --> 00:47:21,516
这里的广播意味着

1618
00:47:21,516 --> 00:47:22,756
我能直接从线程零的寄存器

1619
00:47:22,856 --> 00:47:24,226
读取数据

1620
00:47:24,226 --> 00:47:25,526
直接读取数据域

1621
00:47:25,526 --> 00:47:26,406
然后直接将它写进

1622
00:47:26,406 --> 00:47:27,866
正好同属于这一个组里的

1623
00:47:27,866 --> 00:47:28,796
其他 16 个线程的

1624
00:47:28,796 --> 00:47:28,976
寄存器

1625
00:47:33,146 --> 00:47:34,606
我们第二个增加

1626
00:47:34,606 --> 00:47:35,776
让你根据你的线程组大小

1627
00:47:35,776 --> 00:47:37,086
获得更多灵活性

1628
00:47:37,936 --> 00:47:39,576
例如 如果我有一个

1629
00:47:39,576 --> 00:47:40,556
像素鸟 我想要运行

1630
00:47:40,556 --> 00:47:41,916
一些漂亮的经典图像的

1631
00:47:41,916 --> 00:47:44,866
处理内核

1632
00:47:44,866 --> 00:47:45,936
但是我已经将计算内核

1633
00:47:45,936 --> 00:47:47,666
所有地方都写成了 4 乘 4 的

1634
00:47:47,716 --> 00:47:48,516
线程组

1635
00:47:49,906 --> 00:47:50,936
好吧 这导致了一些问题

1636
00:47:50,936 --> 00:47:52,246
因为

1637
00:47:52,246 --> 00:47:53,716
如果我的图片不是我的线程组的

1638
00:47:53,716 --> 00:47:55,056
数倍

1639
00:47:55,056 --> 00:47:56,066
我会产生

1640
00:47:56,066 --> 00:47:56,396
很多偏离线程

1641
00:47:57,056 --> 00:47:59,766
我想这意味着

1642
00:47:59,766 --> 00:48:01,726
我需要对它进行深入了解

1643
00:47:59,766 --> 00:48:01,726
我需要对它进行深入了解

1644
00:48:01,726 --> 00:48:02,546
然后当我真的要编写代码的时候

1645
00:48:02,546 --> 00:48:03,466
我必须要谨慎

1646
00:48:03,466 --> 00:48:04,326
我越界了吗

1647
00:48:04,326 --> 00:48:05,146
我需要用特殊的方法

1648
00:48:05,146 --> 00:48:05,736
来处理它

1649
00:48:05,736 --> 00:48:07,136
这是可行的 但是令人恼火

1650
00:48:07,976 --> 00:48:09,006
这基本是意味着

1651
00:48:09,006 --> 00:48:10,126
我们只是在浪费 GPU 循环

1652
00:48:10,646 --> 00:48:12,926
所以非一致线程组的大小

1653
00:48:12,926 --> 00:48:14,536
除非你声明

1654
00:48:14,536 --> 00:48:15,476
在不放大线程组大小的情况下

1655
00:48:15,476 --> 00:48:16,896
你想要在哪种维度上

1656
00:48:16,896 --> 00:48:18,136
进行你的核心运行

1657
00:48:18,736 --> 00:48:20,156
所以那些困难的工作

1658
00:48:20,156 --> 00:48:21,766
在我的网格边缘的较小的

1659
00:48:21,766 --> 00:48:23,536
线程组上 

1660
00:48:23,536 --> 00:48:24,466
为了去掉

1661
00:48:24,466 --> 00:48:26,006
不必要的工作

1662
00:48:26,096 --> 00:48:28,456
它不仅提升了 GPU 的性能

1663
00:48:28,456 --> 00:48:29,556
而且还让你的核心变得更

1664
00:48:29,556 --> 00:48:29,976
容易编写

1665
00:48:34,236 --> 00:48:35,206
我们已经加入了

1666
00:48:35,206 --> 00:48:35,896
对视图端口队列的支持

1667
00:48:36,206 --> 00:48:37,736
现在你可以设置最多 16 个

1668
00:48:37,736 --> 00:48:39,396
同步的视图端口

1669
00:48:39,396 --> 00:48:41,146
而你的顶点着色器可以选择

1670
00:48:41,146 --> 00:48:42,776
每个三角想向哪一个视图端口

1671
00:48:42,776 --> 00:48:43,916
进行呈现

1672
00:48:44,626 --> 00:48:45,596
在这里我就不多讲了

1673
00:48:45,596 --> 00:48:46,256
因为明天的 Metal 2

1674
00:48:46,256 --> 00:48:48,026
VR 会议将会讲到关于它的

1675
00:48:48,026 --> 00:48:49,176
细节

1676
00:48:49,546 --> 00:48:50,546
这对左右眼的

1677
00:48:50,546 --> 00:48:51,346
有效渲染是非常

1678
00:48:51,346 --> 00:48:51,976
有价值的

1679
00:48:56,666 --> 00:48:57,476
我们已经加入了一项能力

1680
00:48:57,476 --> 00:48:59,126
它可以选择在每个像素上

1681
00:48:59,126 --> 00:49:00,076
你的多个实例位置

1682
00:48:59,126 --> 00:49:00,076
你的多个实例位置

1683
00:49:00,076 --> 00:49:00,606
在哪里被支持

1684
00:49:01,566 --> 00:49:02,776
这让你能做一些

1685
00:49:02,776 --> 00:49:04,356
有趣的事情 包括

1686
00:49:04,356 --> 00:49:05,366
每隔一帧切换

1687
00:49:05,366 --> 00:49:07,256
你的实例位置

1688
00:49:07,256 --> 00:49:08,396
并给你一些新的 你知道

1689
00:49:08,396 --> 00:49:09,376
将一些有价值的输入加入到

1690
00:49:09,376 --> 00:49:10,386
一些随机采样抗锯齿

1691
00:49:10,386 --> 00:49:11,066
算法里

1692
00:49:15,716 --> 00:49:17,206
为了努力保持

1693
00:49:17,266 --> 00:49:18,726
使我们的平台能跟得上时代

1694
00:49:18,726 --> 00:49:19,756
让他们在任何时候

1695
00:49:19,806 --> 00:49:20,816
都有相同的功能设置

1696
00:49:20,816 --> 00:49:21,856
我们用了

1697
00:49:21,856 --> 00:49:23,356
我们在去年的 iOS 10

1698
00:49:23,356 --> 00:49:25,586
以及今年的 macOS High Sierra 上

1699
00:49:25,586 --> 00:49:26,366
搭载的资源堆

1700
00:49:26,616 --> 00:49:28,826
在这里我要

1701
00:49:28,826 --> 00:49:29,926
做一下刷新

1702
00:49:29,926 --> 00:49:32,196
因为好好使用

1703
00:49:32,196 --> 00:49:33,906
堆

1704
00:49:33,906 --> 00:49:34,816
对于很好的利用参数缓存器

1705
00:49:34,816 --> 00:49:35,246
很重要

1706
00:49:36,606 --> 00:49:37,986
堆使我们能

1707
00:49:37,986 --> 00:49:38,896
预先分配很多

1708
00:49:38,896 --> 00:49:40,786
内存  而不是

1709
00:49:40,786 --> 00:49:42,416
去到内核然后说

1710
00:49:42,506 --> 00:49:43,926
我要纹理 a 的内存

1711
00:49:43,926 --> 00:49:45,046
我要纹理 b 的内存

1712
00:49:45,046 --> 00:49:45,416
等等

1713
00:49:45,826 --> 00:49:46,896
我可以去内核

1714
00:49:46,896 --> 00:49:49,036
预先分配内存

1715
00:49:49,036 --> 00:49:50,626
增减纹理和缓存器的同时

1716
00:49:50,626 --> 00:49:51,556
不需要

1717
00:49:51,556 --> 00:49:52,906
回到

1718
00:49:52,976 --> 00:49:55,396
系统中去

1719
00:49:55,466 --> 00:49:56,766
这样做有一些好处

1720
00:49:56,946 --> 00:49:58,206
这意味着我能

1721
00:49:58,206 --> 00:49:59,116
在这个堆中更高效的

1722
00:49:59,116 --> 00:49:59,726
混合所有东西

1723
00:49:59,916 --> 00:50:00,666
这样会减少很多

1724
00:49:59,916 --> 00:50:00,666
这样会减少很多

1725
00:50:00,666 --> 00:50:01,026
软件开销

1726
00:50:01,786 --> 00:50:02,966
这意味着我们可以

1727
00:50:02,966 --> 00:50:03,936
经常将内存

1728
00:50:03,936 --> 00:50:04,466
压缩的更紧密一些

1729
00:50:04,466 --> 00:50:05,536
我们可以减少一些边距

1730
00:50:05,536 --> 00:50:06,686
和队列 为你省下

1731
00:50:06,686 --> 00:50:07,056
一些内存

1732
00:50:08,096 --> 00:50:10,116
这意味着当我们删除内存时

1733
00:50:10,426 --> 00:50:11,816
我们不会将内存

1734
00:50:11,816 --> 00:50:12,236
返还给系统

1735
00:50:12,576 --> 00:50:13,296
这是好事也是坏事

1736
00:50:13,996 --> 00:50:15,666
这意味着当我们分配

1737
00:50:15,666 --> 00:50:16,526
新内存时

1738
00:50:16,526 --> 00:50:17,676
当我们分配新的纹理时

1739
00:50:17,676 --> 00:50:18,656
我们不用回到系统

1740
00:50:18,656 --> 00:50:18,976
去索取新的内存

1741
00:50:22,476 --> 00:50:23,386
这也意味着你可以

1742
00:50:23,386 --> 00:50:24,916
选择对这些纹理

1743
00:50:24,916 --> 00:50:25,476
进行重命名

1744
00:50:26,256 --> 00:50:27,606
如果我有 

1745
00:50:27,606 --> 00:50:29,456
渲染目标 或者

1746
00:50:29,456 --> 00:50:31,126
在渲染图形的不同通道上对

1747
00:50:31,126 --> 00:50:32,666
渲染图像进行调整

1748
00:50:33,076 --> 00:50:34,176
这意味着

1749
00:50:34,176 --> 00:50:34,886
如果我有两个中间结构

1750
00:50:34,886 --> 00:50:36,616
它们不用同时出现

1751
00:50:36,616 --> 00:50:37,966
我可以

1752
00:50:37,966 --> 00:50:38,926
为他们设置相互命名

1753
00:50:38,926 --> 00:50:43,416
我可以像这样

1754
00:50:44,096 --> 00:50:46,066
省下很多内存

1755
00:50:46,866 --> 00:50:47,906
这是一个对堆的快速调查

1756
00:50:47,996 --> 00:50:50,196
我们在 iOS 到 macOS 里都

1757
00:50:50,386 --> 00:50:52,056
添加了线性纹理

1758
00:50:52,296 --> 00:50:53,366
线性纹理能使你直接从

1759
00:50:53,366 --> 00:50:55,146
Metal 缓存器里创建纹理

1760
00:50:55,146 --> 00:50:56,736
而不用做任何的

1761
00:50:56,786 --> 00:50:57,216
复制工作

1762
00:50:59,306 --> 00:51:00,266
我们也扩展了

1763
00:50:59,306 --> 00:51:00,266
我们也扩展了

1764
00:51:00,266 --> 00:51:01,736
我们功能的稳定性

1765
00:51:01,736 --> 00:51:02,766
一个快速的刷新

1766
00:51:02,766 --> 00:51:03,656
稳定功能让你

1767
00:51:03,656 --> 00:51:04,886
用代码进行特殊化

1768
00:51:05,026 --> 00:51:05,926
当你在线下做完了

1769
00:51:05,926 --> 00:51:07,466
你的前端编译

1770
00:51:07,466 --> 00:51:08,636
你能够在产生最终的

1771
00:51:08,636 --> 00:51:09,886
机器代码之前就

1772
00:51:10,106 --> 00:51:11,296
对超着色器 bi-code 进行一些

1773
00:51:11,296 --> 00:51:11,856
调整和自定义

1774
00:51:12,716 --> 00:51:14,046
如果你有经典的

1775
00:51:14,046 --> 00:51:15,156
超着色器 它能为你省下

1776
00:51:15,156 --> 00:51:16,206
为每个单独序列

1777
00:51:16,206 --> 00:51:17,836
都配置一个前端编译器的

1778
00:51:17,836 --> 00:51:18,726
开销

1779
00:51:19,806 --> 00:51:21,016
所以我们已经将它变得

1780
00:51:21,016 --> 00:51:22,546
更灵活 也添加了一些

1781
00:51:22,546 --> 00:51:25,136
能特殊化参数的

1782
00:51:25,246 --> 00:51:26,286
功能

1783
00:51:28,046 --> 00:51:29,106
我们也增加了一些额外的

1784
00:51:29,106 --> 00:51:29,796
顶点数组格式

1785
00:51:29,826 --> 00:51:31,196
我们遗漏了一个或两个

1786
00:51:31,196 --> 00:51:32,396
组件顶点格式

1787
00:51:32,546 --> 00:51:34,366
我们还增加了 BGRA 顶点

1788
00:51:34,366 --> 00:51:34,916
格式

1789
00:51:37,576 --> 00:51:38,616
我们从 macOS 到 iOS 都

1790
00:51:38,616 --> 00:51:40,306
有 iOS 的

1791
00:51:40,436 --> 00:51:40,846
表面纹理支持

1792
00:51:40,846 --> 00:51:42,716
我们也在 iOS 上加入了

1793
00:51:42,716 --> 00:51:44,156
双源混合

1794
00:51:44,446 --> 00:51:46,666
这在很多延迟渲染场景下

1795
00:51:46,666 --> 00:51:47,926
尤其有用

1796
00:51:50,706 --> 00:51:52,756
这就是我关于 Metal 2

1797
00:51:52,756 --> 00:51:56,086
介绍的最后内容

1798
00:51:56,166 --> 00:51:57,586
我的同事 Michal

1799
00:51:57,586 --> 00:51:58,976
在开始的时候

1800
00:51:58,976 --> 00:52:00,266
向你们介绍了 Metal 2 的

1801
00:51:58,976 --> 00:52:00,266
向你们介绍了 Metal 2 的

1802
00:52:00,266 --> 00:52:00,806
总体范围

1803
00:52:01,126 --> 00:52:03,686
从 VR 到外部 GPU

1804
00:52:04,056 --> 00:52:05,206
到机器学习

1805
00:52:05,206 --> 00:52:06,886
到新的研发者工具和

1806
00:52:07,306 --> 00:52:08,026
性能分析

1807
00:52:08,026 --> 00:52:08,986
我们今天介绍的

1808
00:52:08,986 --> 00:52:10,936
这些内容

1809
00:52:10,936 --> 00:52:12,456
极大地的推动了

1810
00:52:12,576 --> 00:52:13,926
通过使用参数缓存器

1811
00:52:13,926 --> 00:52:14,386
来减少 CPU 开销

1812
00:52:15,006 --> 00:52:16,506
参数缓存器也解锁了

1813
00:52:16,506 --> 00:52:17,856
GPU 的能力

1814
00:52:17,886 --> 00:52:18,956
使它在配置

1815
00:52:18,956 --> 00:52:19,866
着色器参数时

1816
00:52:19,866 --> 00:52:21,126
掌握一些它自己的命运

1817
00:52:21,126 --> 00:52:22,536
这也少了一个

1818
00:52:22,536 --> 00:52:24,676
让它回到 CPU 去的理由

1819
00:52:25,586 --> 00:52:27,356
光栅顺序组让我们

1820
00:52:27,356 --> 00:52:28,666
在基本的东西以外

1821
00:52:28,666 --> 00:52:30,186
使用光栅器来进行混合

1822
00:52:31,356 --> 00:52:32,476
我们现在可以开始

1823
00:52:32,476 --> 00:52:34,056
利用最新的硬件能力去做到

1824
00:52:34,056 --> 00:52:36,566
你知道的

1825
00:52:36,566 --> 00:52:38,386
vox slice 三角网络或者

1826
00:52:38,616 --> 00:52:40,316
设置有序或独立的

1827
00:52:40,316 --> 00:52:41,226
透明混合

1828
00:52:41,296 --> 00:52:42,216
它们都是

1829
00:52:42,216 --> 00:52:42,816
这让它们都变成可能

1830
00:52:44,016 --> 00:52:46,656
对于新的 iPad Pros ProMotion

1831
00:52:46,656 --> 00:52:47,726
能让你对于

1832
00:52:47,726 --> 00:52:49,126
动画如何呈现给用户

1833
00:52:49,126 --> 00:52:50,226
拥有一个细粒度程度的控制

1834
00:52:50,226 --> 00:52:51,886
让你有能力既

1835
00:52:51,886 --> 00:52:53,656
得到峰顶的帧率

1836
00:52:53,656 --> 00:52:54,736
又得到最少的延迟

1837
00:52:55,136 --> 00:52:57,736
直接显示通过发现我们的

1838
00:52:57,736 --> 00:52:59,116
合成器代表你做了什么

1839
00:52:59,116 --> 00:53:00,436
来为你提供

1840
00:52:59,116 --> 00:53:00,436
来为你提供

1841
00:53:00,526 --> 00:53:01,706
重新声明 GPU 执行路径的

1842
00:53:01,706 --> 00:53:02,956
能力

1843
00:53:06,336 --> 00:53:07,536
你可以在

1844
00:53:07,536 --> 00:53:08,426
WWDC2017 的网站上看到

1845
00:53:08,426 --> 00:53:11,216
今天会议的幻灯片和视频

1846
00:53:11,876 --> 00:53:15,096
我们今年还有

1847
00:53:15,096 --> 00:53:15,996
其他三个关于 Metal 2 的会议

1848
00:53:16,596 --> 00:53:18,536
特别要提到的是

1849
00:53:18,536 --> 00:53:19,456
明天下午

1850
00:53:19,456 --> 00:53:20,696
我们的会议将集中讨论

1851
00:53:20,696 --> 00:53:21,136
VR 和 Metal 2

1852
00:53:21,326 --> 00:53:22,886
会议将

1853
00:53:22,886 --> 00:53:24,706
深入讲解你的应用

1854
00:53:24,706 --> 00:53:26,456
需要做什么 以及如何

1855
00:53:26,456 --> 00:53:28,426
做 VR 渲染的概念性简介

1856
00:53:28,426 --> 00:53:30,056
深入讲解

1857
00:53:30,056 --> 00:53:32,106
如何用 Metal 2 和 Steam VR toolkit

1858
00:53:32,106 --> 00:53:34,076
的组合来做 VR

1859
00:53:34,076 --> 00:53:36,086
它也将通过外部的 

1860
00:53:36,086 --> 00:53:37,326
GPU 硬件

1861
00:53:37,326 --> 00:53:37,736
来使用 Metal

1862
00:53:39,666 --> 00:53:40,376
在周四 我们将有

1863
00:53:40,376 --> 00:53:42,286
连续两场会议 以 Metal 2

1864
00:53:42,286 --> 00:53:43,676
的优化和故障排查开始

1865
00:53:43,996 --> 00:53:45,716
会议将介绍

1866
00:53:45,716 --> 00:53:46,726
新的研发项目

1867
00:53:46,726 --> 00:53:48,106
和性能工具

1868
00:53:48,106 --> 00:53:49,376
以及所有的

1869
00:53:49,376 --> 00:53:50,086
帮助你创建尽可能完美应用

1870
00:53:50,086 --> 00:53:51,076
的工作流

1871
00:53:51,286 --> 00:53:52,826
接下去的会议

1872
00:53:52,826 --> 00:53:54,336
将会介绍

1873
00:53:54,336 --> 00:53:55,276
使用 Metal 2 进行计算

1874
00:53:55,656 --> 00:53:57,126
这将是

1875
00:53:57,126 --> 00:53:58,896
今年的重大关注点

1876
00:53:58,896 --> 00:54:00,206
使用 GPU 来做机器学习

1877
00:53:58,896 --> 00:54:00,206
使用 GPU 来做机器学习

1878
00:54:00,206 --> 00:54:00,916
应用

1879
00:54:00,916 --> 00:54:01,946
我们今年做了非常多的

1880
00:54:01,946 --> 00:54:03,806
添加 我们也希望

1881
00:54:03,806 --> 00:54:05,166
向大家展示我们做了哪些事

1882
00:54:07,206 --> 00:54:08,386
我想给大家介绍

1883
00:54:08,426 --> 00:54:10,206
几个去年的 WWDC 会议

1884
00:54:11,286 --> 00:54:12,626
第一个是  Metal 的新鲜事

1885
00:54:12,626 --> 00:54:14,186
第一部分 我们深入的讲解了

1886
00:54:14,186 --> 00:54:15,786
资源堆

1887
00:54:16,196 --> 00:54:17,146
如果你想要得到

1888
00:54:17,146 --> 00:54:18,026
参数缓存器的最好性能

1889
00:54:18,026 --> 00:54:19,836
参数缓存器和堆

1890
00:54:19,836 --> 00:54:20,936
是密不可分的

1891
00:54:20,936 --> 00:54:22,716
所以我非常鼓励

1892
00:54:22,716 --> 00:54:23,836
大家去看看视频

1893
00:54:23,836 --> 00:54:26,336
真的 你可以

1894
00:54:26,436 --> 00:54:28,416
通过一起使用这两项

1895
00:54:28,416 --> 00:54:29,326
来计划

1896
00:54:29,326 --> 00:54:29,686
制作你的应用

1897
00:54:29,756 --> 00:54:31,196
那个视频里比今天的会议

1898
00:54:31,196 --> 00:54:32,516
多讲了很多细节

1899
00:54:34,056 --> 00:54:36,016
第二 如果你对

1900
00:54:36,016 --> 00:54:38,076
直接显示和广色域

1901
00:54:38,076 --> 00:54:39,436
有兴趣

1902
00:54:39,436 --> 00:54:40,996
我们在去年有

1903
00:54:40,996 --> 00:54:41,916
一次会议全程

1904
00:54:41,916 --> 00:54:43,066
都在深入探讨

1905
00:54:43,066 --> 00:54:44,066
它背后的概念

1906
00:54:44,066 --> 00:54:44,656
和特殊性

1907
00:54:45,706 --> 00:54:47,676
在这里 我们今天的会议

1908
00:54:47,676 --> 00:54:47,796
到此结束

1909
00:54:47,796 --> 00:54:48,886
感谢大家的到来

1910
00:54:48,886 --> 00:54:49,596
希望大家

1911
00:54:49,596 --> 00:54:50,266
享受本周剩下的几天

1912
00:54:50,266 --> 00:54:50,906
谢谢大家

1913
00:54:51,516 --> 00:54:55,500
[ 掌声 ]
