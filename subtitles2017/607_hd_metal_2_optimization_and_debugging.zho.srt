1
00:00:07,516 --> 00:00:21,516
谈话声

2
00:00:22,516 --> 00:00:27,556
[掌声]

3
00:00:28,056 --> 00:00:29,076
&gt;&gt; 大家下午好

4
00:00:29,076 --> 00:00:30,446
欢迎来到

5
00:00:30,446 --> 00:00:31,796
Metal 2 优化和调试

6
00:00:31,796 --> 00:00:34,716
你们已经知道 我们今年

7
00:00:34,716 --> 00:00:35,856
有很多关于 Metal 2 的内容

8
00:00:35,856 --> 00:00:37,116
在一些平台上实现了

9
00:00:37,116 --> 00:00:39,106
一些很好的提升 

10
00:00:39,106 --> 00:00:40,966
包括 GP 驱动渲染 机器学习加速 

11
00:00:40,966 --> 00:00:43,936
macOS VR 和

12
00:00:43,936 --> 00:00:45,716
外部 GPU 支持

13
00:00:47,106 --> 00:00:48,466
别忘了还有

14
00:00:48,466 --> 00:00:49,636
高级优化工具

15
00:00:50,186 --> 00:00:52,886
所以 今天下午我们

16
00:00:52,886 --> 00:00:54,536
将会讨论一下当前的

17
00:00:54,666 --> 00:00:56,076
Metal 工具

18
00:00:56,376 --> 00:00:57,906
简要概括一下它们

19
00:00:57,906 --> 00:00:59,536
并介绍一些很棒的

20
00:00:59,536 --> 00:01:01,356
针对 Metal 帧调试工具的提升

21
00:00:59,536 --> 00:01:01,356
针对 Metal 帧调试工具的提升

22
00:01:01,356 --> 00:01:03,136
最后讨论一些

23
00:01:03,136 --> 00:01:04,016
关于 GPU 配置的内容 

24
00:01:04,676 --> 00:01:08,016
首先 我们来看看 帧调试工具

25
00:01:10,226 --> 00:01:12,056
我希望你们都

26
00:01:12,056 --> 00:01:12,776
熟悉这个工具

27
00:01:14,076 --> 00:01:15,376
帧调试工具集成在 Xcode 中

28
00:01:15,376 --> 00:01:17,246
功能齐全

29
00:01:17,246 --> 00:01:20,106
让你可以处理你的

30
00:01:20,106 --> 00:01:22,586
Metal 2 作品

31
00:01:22,966 --> 00:01:24,126
让它成为计算机图形

32
00:01:24,126 --> 00:01:25,086
并且可以进一步检查

33
00:01:25,086 --> 00:01:27,086
状态和资源

34
00:01:27,476 --> 00:01:28,186
让你能够调试和优化

35
00:01:29,076 --> 00:01:33,216
提升帧调试

36
00:01:33,216 --> 00:01:34,006
工具的性能

37
00:01:34,006 --> 00:01:34,886
是我们最近几年

38
00:01:34,886 --> 00:01:36,676
的工作中心之一

39
00:01:36,676 --> 00:01:38,316
我们尤其

40
00:01:38,316 --> 00:01:39,386
注意提升

41
00:01:39,676 --> 00:01:40,346
捕获速度

42
00:01:40,346 --> 00:01:43,096
我很开心告诉大家

43
00:01:43,096 --> 00:01:46,436
与 Xcode 8 相比

44
00:01:46,436 --> 00:01:48,586
Xcode 9 现在的捕获速度

45
00:01:49,106 --> 00:01:50,116
可以达到原来的 10 倍

46
00:01:50,116 --> 00:01:51,556
让你从点按 Capture 按钮

47
00:01:51,556 --> 00:01:52,946
到打开调试工具的时间

48
00:01:52,946 --> 00:01:53,256
大大缩短

49
00:01:56,036 --> 00:01:58,466
如你期待的那样

50
00:01:58,466 --> 00:02:00,036
我们全面支持了 Metal 2 的 API

51
00:01:58,466 --> 00:02:00,036
我们全面支持了 Metal 2 的 API

52
00:02:00,036 --> 00:02:02,006
包括光栅顺序组

53
00:02:02,006 --> 00:02:04,346
采样数组  Viewport 数组

54
00:02:04,346 --> 00:02:06,146
以及全新的像素和

55
00:02:06,146 --> 00:02:07,356
顶点数组格式

56
00:02:07,876 --> 00:02:10,856
在 Metal 2 中

57
00:02:10,856 --> 00:02:12,406
我们花了很大精力

58
00:02:12,406 --> 00:02:14,116
来支持全新的

59
00:02:14,116 --> 00:02:15,296
参数缓冲器

60
00:02:15,936 --> 00:02:17,376
有了它 在缓冲查看器中

61
00:02:17,626 --> 00:02:19,386
你可以看到所有的

62
00:02:19,386 --> 00:02:20,546
参数 缓冲参数

63
00:02:20,646 --> 00:02:22,196
都一行行显示出来

64
00:02:22,196 --> 00:02:23,856
你可以点按它们选择是否要

65
00:02:23,856 --> 00:02:26,516
附上你的采样器 缓冲器

66
00:02:26,516 --> 00:02:32,686
或者其他参数缓冲器

67
00:02:32,686 --> 00:02:33,956
此外 随着对 SteamVR 的自动支持

68
00:02:33,956 --> 00:02:35,196
我们今年开始支持

69
00:02:35,196 --> 00:02:36,456
VR 捕获

70
00:02:36,456 --> 00:02:38,316
我们也为你们提供了

71
00:02:38,316 --> 00:02:40,216
让你们可以以立体的形式

72
00:02:40,216 --> 00:02:40,966
查看你们上传的界面的支持

73
00:02:41,446 --> 00:02:43,526
当你们发送 提交

74
00:02:43,526 --> 00:02:44,576
指令的时候 你将会向

75
00:02:44,576 --> 00:02:46,116
VR 混合器发送你的界面

76
00:02:46,406 --> 00:02:47,786
你会同时看到

77
00:02:47,786 --> 00:02:49,556
左右眼的视图

78
00:02:49,556 --> 00:02:51,106
可以帮助你发现其中的差异

79
00:02:51,676 --> 00:02:56,496
今年的另一个工作重心是

80
00:02:56,716 --> 00:02:58,006
为了要针对更复杂的计算任务

81
00:02:58,006 --> 00:02:59,456
进行捕获  

82
00:02:59,456 --> 00:03:00,416
我们改进了捕获工作流

83
00:02:59,456 --> 00:03:00,416
我们改进了捕获工作流

84
00:03:00,826 --> 00:03:01,836
所以如果你现在

85
00:03:01,896 --> 00:03:04,036
只在 Metal 里做纯计算任务

86
00:03:04,036 --> 00:03:05,396
或者如果你同时有多个

87
00:03:05,396 --> 00:03:07,516
Metal 命令队列  现在我们就可以

88
00:03:07,516 --> 00:03:08,846
更轻松地  准确捕获到你想要

89
00:03:08,846 --> 00:03:09,396
的那部分内容

90
00:03:10,446 --> 00:03:11,526
我们还添加了轻便型

91
00:03:11,526 --> 00:03:13,576
捕获 API  其中内置了一些新的 Metal

92
00:03:13,576 --> 00:03:15,406
捕获作用域对象  我们可以在新建

93
00:03:15,406 --> 00:03:17,416
项目时创建这些对象  然后后期在

94
00:03:17,416 --> 00:03:19,276
每一帧都可以重复利用  可以用来

95
00:03:19,276 --> 00:03:20,136
包裹住之后想捕获的部分

96
00:03:20,546 --> 00:03:21,656
我们稍后会看到这项的演示

97
00:03:21,656 --> 00:03:22,746
这给我们带来了新的可能性

98
00:03:22,746 --> 00:03:25,346
比如说  现在可以把我们所有的

99
00:03:25,626 --> 00:03:28,006
正常渲染任务都包在一个作用域里

100
00:03:28,006 --> 00:03:29,666
把其他那些异步任务  比如说

101
00:03:29,916 --> 00:03:31,126
重新生成我们的密铺因子缓冲区

102
00:03:31,126 --> 00:03:32,866
这一类的任务  归到另一个

103
00:03:32,866 --> 00:03:33,956
作用域里  这样等我们开始捕获的时候

104
00:03:33,956 --> 00:03:35,456
就可以精准地制定区域  获得想要的

105
00:03:35,456 --> 00:03:35,866
结果

106
00:03:37,416 --> 00:03:38,576
我们现在还支持

107
00:03:38,576 --> 00:03:39,266
在我们的应用程序中

108
00:03:39,266 --> 00:03:40,766
用编程方式触发捕获过程

109
00:03:41,316 --> 00:03:43,026
其实我们在自己的测试应用程序里

110
00:03:43,026 --> 00:03:44,256
也经常使用这一功能  用上之后

111
00:03:44,256 --> 00:03:45,436
比如我们可以立马在设备上做一个

112
00:03:45,436 --> 00:03:46,826
什么手势  然后就可以自动触发

113
00:03:47,216 --> 00:03:48,476
帧捕获  我们就不用再

114
00:03:48,476 --> 00:03:53,046
费力切换回 Xcode 去实现这个功能了

115
00:03:53,546 --> 00:03:55,076
今年要宣布的另一个新功能

116
00:03:55,076 --> 00:03:56,676
是 Xcode 的快速预览(Quick Looks)

117
00:03:57,046 --> 00:03:57,606
功能

118
00:03:58,826 --> 00:04:00,766
现在在 CPU 调试工具里

119
00:03:58,826 --> 00:04:00,766
现在在 CPU 调试工具里

120
00:04:00,766 --> 00:04:02,286
有了新的轻便型 Metal

121
00:04:02,286 --> 00:04:02,856
调试功能

122
00:04:03,116 --> 00:04:05,276
假设我们现在再遇到断点

123
00:04:05,276 --> 00:04:07,316
如果包含有 Metal 纹理

124
00:04:07,796 --> 00:04:09,206
快速预览就会从 GPU 里

125
00:04:09,206 --> 00:04:11,426
自动提取 Metal 纹理数据

126
00:04:11,426 --> 00:04:12,716
然后给大家提供实时预览

127
00:04:12,916 --> 00:04:14,106
同样的功能  也支持预览缓冲区

128
00:04:14,106 --> 00:04:14,586
和采样器

129
00:04:15,486 --> 00:04:17,375
对于有些不太方便

130
00:04:17,375 --> 00:04:19,796
做完整帧捕获的项目  这个功能

131
00:04:19,796 --> 00:04:21,736
非常有用  举个例子来说

132
00:04:21,736 --> 00:04:22,786
如果我们要调试的是

133
00:04:22,786 --> 00:04:24,156
资源载入  或者一些设置代码

134
00:04:24,156 --> 00:04:24,546
这一类

135
00:04:24,546 --> 00:04:27,506
另外  如果我们要调试一些

136
00:04:27,506 --> 00:04:28,916
计算任务  用这个断点预览

137
00:04:28,916 --> 00:04:32,606
也会非常方便

138
00:04:33,026 --> 00:04:35,156
去年我们介绍了

139
00:04:35,416 --> 00:04:37,056
在帧调试工具里

140
00:04:37,266 --> 00:04:38,606
全局可用的  丰富的过滤功能

141
00:04:38,686 --> 00:04:41,526
我们可以同时过滤

142
00:04:41,526 --> 00:04:42,946
比如  资源属性  这一类东西

143
00:04:43,426 --> 00:04:44,356
但同时  在帧

144
00:04:44,356 --> 00:04:47,156
导航栏里  我们也可以依据

145
00:04:47,156 --> 00:04:49,606
上下文数据进行过滤  这样如果

146
00:04:49,936 --> 00:04:51,146
我们的过滤条件是一个特定绘制指令

147
00:04:51,146 --> 00:04:52,506
所用的资源  过滤结果就会输出

148
00:04:52,506 --> 00:04:53,566
那个特定的绘制指令

149
00:04:53,756 --> 00:04:55,196
我们今年把这一功能进行了改进

150
00:04:55,196 --> 00:04:56,626
能达到的功能更上一层楼了

151
00:04:56,626 --> 00:04:58,136
现在我们还可以支持在整个

152
00:04:58,136 --> 00:04:59,476
捕获帧内进行数据挖掘

153
00:05:00,156 --> 00:05:01,716
所以现在我们一边输入  程序

154
00:05:01,716 --> 00:05:03,626
就会一边自动返回上下文相关的

155
00:05:03,626 --> 00:05:04,866
自动补全建议

156
00:05:05,706 --> 00:05:07,886
而且我们现在还支持复合术语

157
00:05:08,326 --> 00:05:10,236
所以如果现在先限定某个特定的

158
00:05:10,236 --> 00:05:12,506
编码器  然后再限定某个

159
00:05:12,506 --> 00:05:14,696
纹理  我们现在给你显示

160
00:05:14,696 --> 00:05:15,806
出的的自动补全建议  就会是

161
00:05:15,806 --> 00:05:17,026
那个特定编码器里

162
00:05:17,026 --> 00:05:22,346
实际用到的纹理

163
00:05:22,946 --> 00:05:24,386
这几年来  我们收到

164
00:05:24,386 --> 00:05:25,806
请求最多的一项功能就是

165
00:05:25,806 --> 00:05:27,106
像素审查 (Pixel Inspection) 功能

166
00:05:28,386 --> 00:05:29,496
我们现在终于满足了这一需求

167
00:05:30,386 --> 00:05:32,186
所以现在我们可以针对

168
00:05:32,186 --> 00:05:34,886
每一个独立像素  做详细的审查

169
00:05:35,196 --> 00:05:36,706
不管是在纹理  还是

170
00:05:36,706 --> 00:05:37,486
在渲染目标中

171
00:05:38,046 --> 00:05:39,366
而如果你的渲染

172
00:05:39,366 --> 00:05:40,196
目标中  包含有多个附件

173
00:05:40,196 --> 00:05:41,606
我们还会在同一时间

174
00:05:41,656 --> 00:05:43,366
给你显示出每个

175
00:05:43,366 --> 00:05:45,206
附件内部同等位置处的

176
00:05:45,206 --> 00:05:45,866
像素值

177
00:05:45,976 --> 00:05:47,146
所以如果我们要看着附件调试

178
00:05:47,146 --> 00:05:48,836
颜色值啊  同时还要调试

179
00:05:48,836 --> 00:05:50,136
模版啊之类的东西

180
00:05:50,136 --> 00:05:51,036
就会非常方便

181
00:05:51,346 --> 00:05:52,916
这个功能在调试计算任务

182
00:05:52,916 --> 00:05:54,516
的时候  也非常有用

183
00:05:54,516 --> 00:05:55,746
比如你正在处理图片

184
00:05:55,746 --> 00:05:56,996
假设我们的

185
00:05:56,996 --> 00:05:58,236
CNN 正做到一半  但是想测试一下

186
00:05:58,236 --> 00:05:59,686
看看各个缓冲区里面的实际

187
00:05:59,686 --> 00:06:01,036
数值都是多少  就可以用这个来

188
00:05:59,686 --> 00:06:01,036
数值都是多少  就可以用这个来

189
00:06:01,036 --> 00:06:01,306
审查

190
00:06:03,516 --> 00:06:07,546
[掌声]

191
00:06:08,046 --> 00:06:09,026
我们去年介绍的

192
00:06:09,026 --> 00:06:10,556
另一个新功能  就是

193
00:06:10,556 --> 00:06:12,436
顶点属性观察器  在这里

194
00:06:12,436 --> 00:06:14,336
我们可以看到  所有在传入我们的

195
00:06:14,486 --> 00:06:16,376
顶点着色引擎的顶点数据

196
00:06:16,376 --> 00:06:18,246
数据按照每个顶点分开

197
00:06:18,246 --> 00:06:19,856
显示

198
00:06:20,496 --> 00:06:21,446
好了  今年  我们又添加

199
00:06:21,446 --> 00:06:23,626
了新的功能  现在我们也可以看到

200
00:06:23,626 --> 00:06:25,556
顶点着色引擎输出的顶点数据了

201
00:06:25,696 --> 00:06:27,766
我们还会把这个内联

202
00:06:28,076 --> 00:06:29,776
和之前支持的输入时的数据并列显示

203
00:06:30,146 --> 00:06:31,476
所以在这个例子里  我们可以看到

204
00:06:31,476 --> 00:06:33,306
输入的顶点位置数据  和输出的

205
00:06:33,306 --> 00:06:34,596
顶点位置数据  同时显示在

206
00:06:34,596 --> 00:06:35,000
一起

207
00:06:38,046 --> 00:06:38,866
好了  现在该给大家实际

208
00:06:38,866 --> 00:06:40,076
演示一下我说过的这些新功能了

209
00:06:40,076 --> 00:06:41,256
请允许我邀请我的同事

210
00:06:41,486 --> 00:06:42,686
Max 上台  他将会给大家

211
00:06:42,686 --> 00:06:44,106
演示刚刚说过的这些精彩的

212
00:06:44,106 --> 00:06:45,076
新功能

213
00:06:46,516 --> 00:06:49,556
[掌声]

214
00:06:50,056 --> 00:06:51,956
大家好  很高兴今天在这里见到

215
00:06:51,956 --> 00:06:52,386
大家

216
00:06:52,526 --> 00:06:57,706
我希望大家手头工作进展都不错

217
00:06:57,706 --> 00:06:59,776
而你们都和我们一样  对 Metal 充满

218
00:06:59,776 --> 00:07:00,236
激情

219
00:06:59,776 --> 00:07:00,236
激情

220
00:07:00,636 --> 00:07:02,616
Xcode 的 GPU 调试工具可以帮我们

221
00:07:02,616 --> 00:07:04,456
调试我们的 GPU 和 Metal 占用

222
00:07:04,456 --> 00:07:05,146
情况

223
00:07:05,616 --> 00:07:07,356
我叫作 Max  今天我会帮大家

224
00:07:07,356 --> 00:07:08,496
最优化 (maximize) 你们的调试

225
00:07:08,496 --> 00:07:09,886
体验  给大家演示下新的

226
00:07:09,886 --> 00:07:10,246
功能

227
00:07:11,516 --> 00:07:14,696
[掌声]

228
00:07:15,196 --> 00:07:17,106
让我运行一下我的示例程序

229
00:07:19,576 --> 00:07:21,676
这里渲染出来的  是一幅美丽的

230
00:07:21,676 --> 00:07:24,056
风景  显示出来  雪中

231
00:07:24,056 --> 00:07:26,266
的山脉啦  在风中飘动

232
00:07:26,266 --> 00:07:27,936
的草啦  然后为了让效果

233
00:07:27,936 --> 00:07:29,986
看起来更好  我还添加了一些

234
00:07:29,986 --> 00:07:31,846
颗粒  并让它们在空中闪闪

235
00:07:32,606 --> 00:07:33,176
发光

236
00:07:33,216 --> 00:07:35,636
但就像大家看到的那样

237
00:07:35,636 --> 00:07:37,826
草上面的这些颗粒  看起来

238
00:07:37,826 --> 00:07:39,316
渲染得有点问题

239
00:07:39,546 --> 00:07:41,196
所以让我们看看怎么解决一下

240
00:07:41,756 --> 00:07:46,296
作为调试的第一步  让我们先看看

241
00:07:46,296 --> 00:07:47,336
纹理设置对了没有

242
00:07:47,906 --> 00:07:49,436
我们在渲染循环里设置

243
00:07:49,436 --> 00:07:50,656
一个断点  设置在正要

244
00:07:50,716 --> 00:07:52,116
使用这个纹理的时候

245
00:07:53,216 --> 00:07:54,846
把鼠标悬停在一个变量上

246
00:07:54,846 --> 00:07:57,226
我们就可以看到 Xcode 的数据提示

247
00:07:57,566 --> 00:07:59,446
可通过 Xcode 这个提示快速查看该变量的

248
00:07:59,446 --> 00:08:00,196
纹理数据

249
00:07:59,446 --> 00:08:00,196
纹理数据

250
00:08:00,726 --> 00:08:02,296
这个纹理数据  是实时从 GPU

251
00:08:02,296 --> 00:08:03,996
抓取的  可以帮助我们

252
00:08:03,996 --> 00:08:05,576
快速确认  是否绑定上了正确

253
00:08:05,576 --> 00:08:07,466
的资源  当然  这个功能对于

254
00:08:07,466 --> 00:08:09,136
所有的 Metal 资源都可用

255
00:08:09,856 --> 00:08:12,196
我们目前这个变量的纹理看起来

256
00:08:12,196 --> 00:08:12,916
没有错

257
00:08:13,406 --> 00:08:20,006
那么我们还有什么可以检查的

258
00:08:20,276 --> 00:08:21,786
我们下一步  就可以开始捕获帧

259
00:08:21,786 --> 00:08:22,226
了

260
00:08:22,686 --> 00:08:25,336
只需点击调试栏里的这个

261
00:08:25,336 --> 00:08:27,366
小照相机图标  我们就可以捕获

262
00:08:27,366 --> 00:08:29,866
一帧  但如果我们长按这个图标

263
00:08:30,146 --> 00:08:31,556
就会显示出菜单  可以选择捕获

264
00:08:31,556 --> 00:08:33,596
作用域  或者命令队列

265
00:08:33,876 --> 00:08:36,106
捕获作用域是通过渲染通道

266
00:08:36,306 --> 00:08:37,596
完成

267
00:08:37,846 --> 00:08:39,035
就像我的环境图  这个

268
00:08:39,035 --> 00:08:40,395
我每几帧  才更新

269
00:08:40,395 --> 00:08:41,066
一次

270
00:08:41,826 --> 00:08:43,366
但这个例子里  我们想要

271
00:08:43,366 --> 00:08:44,596
捕获的是渲染过程  因为这个

272
00:08:44,596 --> 00:08:45,636
过程里才会真正开始绘制颗粒

273
00:08:46,866 --> 00:08:49,836
所以我们点击  捕获一下

274
00:08:50,046 --> 00:08:50,946
这就捕获好了

275
00:08:51,476 --> 00:08:54,096
对于那些不太熟悉我们的工具

276
00:08:54,096 --> 00:08:55,956
界面的人  我先给大家

277
00:08:55,956 --> 00:08:56,986
快速讲解一下在这个

278
00:08:56,986 --> 00:08:58,186
界面上  都有些什么东西

279
00:08:58,186 --> 00:09:01,726
在界面左侧  我们可以看到

280
00:08:58,186 --> 00:09:01,726
在界面左侧  我们可以看到

281
00:09:01,726 --> 00:09:02,716
调试工具导航栏

282
00:09:03,186 --> 00:09:04,276
在这里按等级

283
00:09:04,276 --> 00:09:06,396
显示了我们的帧  为了更加

284
00:09:06,396 --> 00:09:08,016
方便大家调试使用  自动

285
00:09:08,016 --> 00:09:10,316
进行了分组  分开了命令缓冲区

286
00:09:10,316 --> 00:09:11,376
和命令编码器

287
00:09:12,346 --> 00:09:13,926
我们的调试组

288
00:09:13,926 --> 00:09:15,936
也显示在这里了  让我们在

289
00:09:15,936 --> 00:09:17,566
微小的层面上也可以掌控调整帧

290
00:09:17,906 --> 00:09:19,856
我们可以选择绘制指令

291
00:09:19,856 --> 00:09:21,526
或者任何其他的 Metal 指令  来审查

292
00:09:21,526 --> 00:09:22,346
其更多细节

293
00:09:23,136 --> 00:09:27,406
位于界面中央的编辑器

294
00:09:27,406 --> 00:09:29,106
向我们展示了绑定的资源

295
00:09:29,496 --> 00:09:30,846
展示了选中的 API 指令中

296
00:09:30,846 --> 00:09:32,986
我们所用到的所有的 Metal 对象

297
00:09:33,986 --> 00:09:35,976
在这里我们也可以看到  为我们的对象

298
00:09:35,976 --> 00:09:37,726
添加标签  可以有效提高调试时的

299
00:09:37,726 --> 00:09:38,536
可读性

300
00:09:38,926 --> 00:09:41,306
我建议大家都养成这个习惯

301
00:09:42,956 --> 00:09:45,026
界面右侧的编辑器

302
00:09:45,026 --> 00:09:46,556
显示的是附件  是最近

303
00:09:46,556 --> 00:09:48,556
一次绘制指令的输出结果

304
00:09:49,136 --> 00:09:50,066
所以不管你什么时候

305
00:09:50,066 --> 00:09:51,416
不管在帧的哪里

306
00:09:51,606 --> 00:09:53,106
都可以马上看到自己在哪一步

307
00:09:53,936 --> 00:09:56,346
在界面最下方  我们有

308
00:09:56,346 --> 00:09:58,166
变量观察器  可以让我们

309
00:09:58,166 --> 00:10:00,156
方便地查看每个 Metal 对象的

310
00:09:58,166 --> 00:10:00,156
方便地查看每个 Metal 对象的

311
00:10:00,156 --> 00:10:01,026
状态

312
00:10:01,506 --> 00:10:03,296
好了  我们回到刚刚颗粒的

313
00:10:03,296 --> 00:10:04,366
问题上

314
00:10:04,786 --> 00:10:06,216
现在我们就可以试验一下超强的

315
00:10:06,216 --> 00:10:07,756
过滤功能

316
00:10:08,496 --> 00:10:11,226
好了  现在我知道  那些颗粒

317
00:10:11,226 --> 00:10:12,666
是在正向渲染过程中某处绘制的

318
00:10:13,316 --> 00:10:15,556
所以让我们试着过滤一下

319
00:10:15,866 --> 00:10:17,576
如果对命令编码器进行过滤

320
00:10:17,976 --> 00:10:20,786
那么结果只会显示这个命令编码器

321
00:10:20,786 --> 00:10:21,926
里的 API 指令

322
00:10:21,926 --> 00:10:22,846
比如像这样

323
00:10:23,446 --> 00:10:25,486
但结果还是太多了

324
00:10:26,646 --> 00:10:28,386
所以我们再添加一个额外的过滤

325
00:10:28,386 --> 00:10:28,736
条件

326
00:10:29,086 --> 00:10:30,616
我们知道会用到颗粒

327
00:10:30,616 --> 00:10:31,066
纹理

328
00:10:34,556 --> 00:10:37,186
如果对纹理进行过滤  那么结果

329
00:10:37,186 --> 00:10:39,476
只会显示使用了此纹理的绘制

330
00:10:39,476 --> 00:10:39,896
指令

331
00:10:40,576 --> 00:10:43,656
这就好了  这两个过滤条件

332
00:10:43,656 --> 00:10:46,046
叠加  就能过滤出唯一的 API 指令

333
00:10:46,046 --> 00:10:47,986
而这一指令正是我们希望进一步研究的

334
00:10:48,726 --> 00:10:49,536
我们来看一下

335
00:10:50,016 --> 00:10:53,296
我们先看一下这个指令绑定的

336
00:10:53,296 --> 00:10:54,166
资源

337
00:10:55,046 --> 00:10:57,026
这里  顶点属性中包含了

338
00:10:57,026 --> 00:10:58,456
输入顶点函数的数据  也包含了

339
00:10:58,456 --> 00:11:01,026
离开顶点函数的数据

340
00:10:58,456 --> 00:11:01,026
离开顶点函数的数据

341
00:11:01,296 --> 00:11:02,616
也许我们就是在这里搞错了

342
00:11:02,616 --> 00:11:05,106
一些几何特征的设定

343
00:11:05,106 --> 00:11:06,196
所以我们看一下  双击

344
00:11:06,196 --> 00:11:06,616
打开

345
00:11:07,626 --> 00:11:09,696
让我们先把这边的附件

346
00:11:09,696 --> 00:11:10,406
隐藏一下

347
00:11:11,626 --> 00:11:13,036
去年  我们给大家展示了

348
00:11:13,036 --> 00:11:14,436
缓冲区一种更好的布局

349
00:11:16,516 --> 00:11:17,836
今年我们还新添加了一些别的东西

350
00:11:18,986 --> 00:11:20,316
在界面眉头  我们可以看到

351
00:11:20,316 --> 00:11:21,746
下方显示的数据是输入还是

352
00:11:21,746 --> 00:11:22,306
输出

353
00:11:23,266 --> 00:11:28,336
如果我们看一下  这边

354
00:11:28,336 --> 00:11:29,626
就是输出的数据  是离开

355
00:11:29,626 --> 00:11:31,106
顶点函数的数据

356
00:11:31,376 --> 00:11:32,966
这些显示了全部颗粒顶点

357
00:11:33,106 --> 00:11:35,776
输出时的位置  我们在这里

358
00:11:35,776 --> 00:11:37,336
可以看到  没有

359
00:11:37,376 --> 00:11:39,286
什么很明显的错误  比如哪个数据

360
00:11:39,286 --> 00:11:41,166
数值过大之类的问题  所以我先

361
00:11:41,166 --> 00:11:42,706
假设这些数据都是正确的

362
00:11:43,446 --> 00:11:45,336
那么我们还可以检查哪里

363
00:11:46,036 --> 00:11:50,386
调试工具导航栏现在还可以让

364
00:11:50,386 --> 00:11:51,836
我们快速定位并进入到当前

365
00:11:51,836 --> 00:11:53,596
绘制指令所相关的所有视图

366
00:11:53,926 --> 00:11:54,846
让我们再切换回

367
00:11:54,846 --> 00:11:55,746
附件看看

368
00:11:56,256 --> 00:12:01,306
我们现在显示了

369
00:11:56,256 --> 00:12:01,306
我们现在显示了

370
00:12:01,306 --> 00:12:01,506
两种渲染目标

371
00:12:02,436 --> 00:12:04,566
颜色  和深度

372
00:12:05,076 --> 00:12:06,796
让我们再审查一些

373
00:12:06,796 --> 00:12:07,376
像素值吧

374
00:12:07,876 --> 00:12:11,586
我们可以使用位于界面右下方的

375
00:12:11,586 --> 00:12:13,156
审查像素按钮  这就可以

376
00:12:13,226 --> 00:12:16,456
唤出一个新工具

377
00:12:16,556 --> 00:12:20,386
一个环形  这个圆环里显示的

378
00:12:20,386 --> 00:12:22,106
数据  和片元函数输出的

379
00:12:22,106 --> 00:12:23,296
数据完全一致

380
00:12:24,246 --> 00:12:26,256
我们可以用鼠标在渲染目标上

381
00:12:26,256 --> 00:12:27,506
随意移动这个圆环

382
00:12:28,386 --> 00:12:29,796
但我们也可以通过方向键

383
00:12:29,796 --> 00:12:31,796
进行精准到像素级别的控制移动

384
00:12:31,796 --> 00:12:33,186
移动之前甚至都不用放大

385
00:12:34,396 --> 00:12:36,566
我们还可以注意到  在所有的

386
00:12:36,566 --> 00:12:37,806
渲染目标上  圆环的移动都是

387
00:12:37,806 --> 00:12:38,956
完全同步的

388
00:12:39,246 --> 00:12:40,976
可让我们同时查看两边的数值

389
00:12:41,256 --> 00:12:43,306
我们现在就找一个

390
00:12:45,056 --> 00:12:45,136
有趣的像素来看一下

391
00:12:45,356 --> 00:12:46,426
我们长按  就可以

392
00:12:46,426 --> 00:12:47,666
立即移动光标

393
00:12:48,286 --> 00:12:51,686
在这个点上  我们可以看出有些

394
00:12:51,686 --> 00:12:52,576
奇怪

395
00:12:53,466 --> 00:12:55,676
这个颗粒的内部和外部

396
00:12:55,676 --> 00:12:57,586
深度数值不一样

397
00:12:58,076 --> 00:12:59,796
这很奇怪  正常情况下

398
00:12:59,796 --> 00:13:00,946
我们的颗粒不应该写入

399
00:12:59,796 --> 00:13:00,946
我们的颗粒不应该写入

400
00:13:00,946 --> 00:13:01,896
深度缓冲区

401
00:13:02,526 --> 00:13:03,896
把这里修好应该很简单

402
00:13:04,316 --> 00:13:05,976
我相信  我们新的 GPU

403
00:13:05,976 --> 00:13:07,536
调试工具也可以帮大家快速地

404
00:13:07,536 --> 00:13:08,886
修好你们 GPU 里的问题

405
00:13:09,906 --> 00:13:11,346
我希望明天早上可以在实验室里

406
00:13:11,346 --> 00:13:13,326
或是在今天的晚些时候

407
00:13:13,326 --> 00:13:14,226
再次看到大家

408
00:13:14,936 --> 00:13:16,296
下面还有请我的同事 Seth

409
00:13:17,516 --> 00:13:23,256
[掌声]

410
00:13:23,756 --> 00:13:26,276
好了  下面我们讲 GPU 性能分析

411
00:13:27,896 --> 00:13:29,796
我们都知道   对于游戏和其他

412
00:13:29,796 --> 00:13:30,896
一些图形应用程序

413
00:13:30,896 --> 00:13:32,596
运行性能至关重要

414
00:13:32,596 --> 00:13:33,966
我们经常需要能够保持

415
00:13:33,966 --> 00:13:35,316
持续稳定的高帧率

416
00:13:36,106 --> 00:13:37,216
但另一方面  我们也

417
00:13:37,216 --> 00:13:38,616
希望能充分利用 GPU

418
00:13:38,616 --> 00:13:40,066
产出图形效果最好的游戏

419
00:13:40,066 --> 00:13:41,756
而同时希望能够提高效率

420
00:13:41,756 --> 00:13:43,106
延长高质量的游戏体验

421
00:13:43,106 --> 00:13:43,846
时间

422
00:13:44,556 --> 00:13:45,726
为了做到以上这些  我们就需要

423
00:13:45,726 --> 00:13:47,206
使用 GPU 性能分析 (Profiling) 工具

424
00:13:47,656 --> 00:13:53,046
我想讲的第一个工具叫作

425
00:13:53,046 --> 00:13:54,546
Metal 系统跟踪 (Metal System Trace)

426
00:13:55,396 --> 00:13:56,236
这个工具可以

427
00:13:56,236 --> 00:13:58,446
用来审查计时问题

428
00:13:58,446 --> 00:14:00,136
我的意思是说  可以审查一些场景

429
00:13:58,446 --> 00:14:00,136
我的意思是说  可以审查一些场景

430
00:14:00,136 --> 00:14:02,446
比如有时 CPU 和 GPU 可能

431
00:14:02,446 --> 00:14:04,656
没有在并行运行

432
00:14:04,656 --> 00:14:06,286
而是因为我们错误地

433
00:14:06,286 --> 00:14:07,836
做了一些同步运行  使得

434
00:14:07,836 --> 00:14:08,726
CPU GPU 被迫无法并行 

435
00:14:08,726 --> 00:14:09,116
转而连续运行

436
00:14:09,796 --> 00:14:10,586
这个工具还可以

437
00:14:10,586 --> 00:14:12,166
用来审查一些场景  比如

438
00:14:12,396 --> 00:14:13,586
我们大部分的帧都是

439
00:14:13,586 --> 00:14:14,676
我们想要的样子

440
00:14:14,676 --> 00:14:15,976
但偶尔会有卡顿

441
00:14:16,246 --> 00:14:17,126
然后我们需要去搞明白

442
00:14:17,126 --> 00:14:18,306
好了  就在卡顿的那里底

443
00:14:18,306 --> 00:14:19,226
到有什么问题

444
00:14:20,106 --> 00:14:21,676
这个工具可以让我们

445
00:14:21,676 --> 00:14:22,966
沿着系统跟踪 Metal 任务

446
00:14:23,046 --> 00:14:25,436
从 CPU 到 GPU 到显示

447
00:14:27,436 --> 00:14:29,606
今年  我们还增加了对 VR

448
00:14:29,606 --> 00:14:31,296
应用程序的支持

449
00:14:31,296 --> 00:14:33,056
包含具体的 VR 跟踪点

450
00:14:33,056 --> 00:14:35,836
可针对的活动有比如  当我们向

451
00:14:35,836 --> 00:14:38,916
虚拟现实头盔查询数据时

452
00:14:38,916 --> 00:14:40,516
向 VR Compositor 提交面层

453
00:14:40,516 --> 00:14:43,086
的时候  当 Compositor 进行

454
00:14:43,086 --> 00:14:45,196
排版生成的时候  还有

455
00:14:45,196 --> 00:14:46,946
最后显示在头戴设备的

456
00:14:47,106 --> 00:14:48,506
屏幕上的时候

457
00:14:49,576 --> 00:14:51,406
事实上  从运动到图像显示

458
00:14:51,406 --> 00:14:53,366
整个过程我们都可以追踪

459
00:14:55,976 --> 00:14:58,266
我们今年还添加了

460
00:14:58,266 --> 00:14:59,566
对 ProMotion 显示

461
00:14:59,566 --> 00:15:02,076
的支持  大家可以在新

462
00:14:59,566 --> 00:15:02,076
的支持  大家可以在新

463
00:15:02,076 --> 00:15:04,096
iPad 上找到  就是这周早些时候

464
00:15:04,096 --> 00:15:06,066
发布的新 iPad Pro  我们还在

465
00:15:06,066 --> 00:15:08,046
macOS 上新增了对外部 GPU 的

466
00:15:08,046 --> 00:15:08,666
支持

467
00:15:09,476 --> 00:15:10,776
另外值得注意的  还有

468
00:15:10,776 --> 00:15:11,906
我们对工具集也新做了很多

469
00:15:11,906 --> 00:15:13,846
很棒的改进  让我们可以更加

470
00:15:13,846 --> 00:15:15,616
便捷地查看其他工具集

471
00:15:15,786 --> 00:15:17,646
和 Metal 系统跟踪一起

472
00:15:17,646 --> 00:15:20,386
比以前整合程度更高了

473
00:15:20,816 --> 00:15:22,776
我们另一个性能分析的工具叫作

474
00:15:22,776 --> 00:15:23,806
GPU 着色器分析器 (GPU Shader Profiler)

475
00:15:24,306 --> 00:15:25,726
是分析着色器性能的

476
00:15:25,726 --> 00:15:26,326
不二选择

477
00:15:27,076 --> 00:15:28,316
我们把这个工具整合进了

478
00:15:28,316 --> 00:15:29,626
帧调试工具里  可以让我们

479
00:15:29,626 --> 00:15:31,466
针对每个绘制指令  每个管道

480
00:15:31,466 --> 00:15:33,116
分别查看着色时间

481
00:15:33,686 --> 00:15:37,416
而且  如果在 iOS 或者 Apple tvOS 上

482
00:15:37,416 --> 00:15:39,236
这个工具还可以让我们分

483
00:15:39,236 --> 00:15:39,956
条查看

484
00:15:41,696 --> 00:15:43,136
我们今年第一个全新的工具

485
00:15:43,136 --> 00:15:44,816
专门为了与 GPU 着色分析器

486
00:15:44,816 --> 00:15:46,006
协同工作而

487
00:15:46,006 --> 00:15:46,496
设计

488
00:15:48,636 --> 00:15:50,296
我们管这个工具叫作 Metal 管道

489
00:15:50,296 --> 00:15:51,046
统计工具 (Metal Pipeline Statistics)

490
00:15:53,036 --> 00:15:55,436
Metal 管道统计工具让我们

491
00:15:55,436 --> 00:15:57,456
可以直连 GPU 编译器

492
00:15:57,456 --> 00:15:59,306
编译器根据我们的着色器

493
00:15:59,306 --> 00:16:00,916
生成机器代码  而这个工具可以

494
00:15:59,306 --> 00:16:00,916
生成机器代码  而这个工具可以

495
00:16:00,916 --> 00:16:02,946
让我们查看这些机器代码的质量

496
00:16:03,016 --> 00:16:03,316
优劣

497
00:16:04,066 --> 00:16:05,176
这个工具会输出一系列

498
00:16:05,176 --> 00:16:06,606
丰富的统计数据  比如

499
00:16:06,756 --> 00:16:08,366
指令数啦  指令混合啦

500
00:16:08,366 --> 00:16:10,236
也就是说  统计

501
00:16:10,236 --> 00:16:11,796
像比如 ALU 内存  或者控制流

502
00:16:11,796 --> 00:16:13,396
这类操作所占的相对比例

503
00:16:13,396 --> 00:16:15,826
而在那些相关的

504
00:16:15,826 --> 00:16:17,216
GPU 上  分析输出结果还会

505
00:16:17,216 --> 00:16:18,866
显示寄存器使用和占用情况

506
00:16:19,306 --> 00:16:21,986
对于这部分 GPU 这些

507
00:16:22,016 --> 00:16:23,436
统计信息至关重要

508
00:16:23,436 --> 00:16:25,306
可以帮助我们理解

509
00:16:25,306 --> 00:16:27,766
同时多少个着色器工作的

510
00:16:27,766 --> 00:16:29,496
限制条件都是什么

511
00:16:30,176 --> 00:16:32,486
也就是说同时可以排

512
00:16:32,646 --> 00:16:33,646
多少个着色场景

513
00:16:34,876 --> 00:16:37,976
但更好用的  是新的

514
00:16:37,976 --> 00:16:39,066
编译器评论功能

515
00:16:39,736 --> 00:16:41,636
有个这个  GPU 编译器就可以

516
00:16:41,636 --> 00:16:43,446
针对你着色器的运行性能

517
00:16:43,666 --> 00:16:44,786
给你反馈出直接的  可操作

518
00:16:44,786 --> 00:16:46,506
的指导  还可以告诉我们具体该改进

519
00:16:46,506 --> 00:16:48,556
哪里  可以避免性能迟缓

520
00:16:48,556 --> 00:16:49,956
从比如慢计算使用情况

521
00:16:50,256 --> 00:16:51,776
寄存器溢出  和堆栈使用

522
00:16:51,776 --> 00:16:52,216
情况

523
00:16:52,796 --> 00:16:56,906
这就好像每个 Xcode 都自带了

524
00:16:56,906 --> 00:16:59,636
一位 GPU 编译器工程师

525
00:17:00,736 --> 00:17:02,806
对于每条评论  下面都会展开解释

526
00:17:02,946 --> 00:17:06,246
到底什么意思  我们可以做什么来

527
00:17:06,316 --> 00:17:08,796
提升性能  还会给我们提供一个链接

528
00:17:08,796 --> 00:17:11,006
点击就可以直接定位到需要修改的

529
00:17:11,076 --> 00:17:11,536
地方

530
00:17:12,695 --> 00:17:13,955
好了  为了给大家演示这个新功能

531
00:17:13,955 --> 00:17:15,036
我想请我的同事 Jose

532
00:17:15,256 --> 00:17:16,935
上台  给大家演示一下

533
00:17:16,935 --> 00:17:18,465
Metal 通道

534
00:17:18,465 --> 00:17:19,086
统计工具

535
00:17:20,516 --> 00:17:22,546
[掌声]

536
00:17:23,046 --> 00:17:23,536
&gt;&gt; 大家好

537
00:17:23,685 --> 00:17:24,526
我是 Jose Enrique

538
00:17:24,606 --> 00:17:26,006
我要为大家展示一个新特性

539
00:17:26,006 --> 00:17:27,556
那就是我们的对 GPU 友好的

540
00:17:27,556 --> 00:17:28,946
调试器 它会助你

541
00:17:29,296 --> 00:17:30,466
产出高质量的产品

542
00:17:30,836 --> 00:17:32,416
大家可以看到 我们

543
00:17:32,526 --> 00:17:33,786
正在重放一个在 iOS 上的

544
00:17:33,976 --> 00:17:35,166
捕捉 Metal 的演示

545
00:17:35,996 --> 00:17:37,956
我要做的第一件事

546
00:17:37,956 --> 00:17:39,286
就是把调试导航视图

547
00:17:39,286 --> 00:17:41,196
从按调用检视帧 (view frame

548
00:17:41,196 --> 00:17:42,766
by call） 改成按性能检视帧 (view frame by

549
00:17:42,766 --> 00:17:43,496
performance)

550
00:17:44,026 --> 00:17:46,916
这会给出 这个视图

551
00:17:46,916 --> 00:17:50,216
会给出你所捕捉的所有

552
00:17:50,216 --> 00:17:53,956
通道 按时间分类的

553
00:17:54,146 --> 00:17:56,066
记住 在 Metal 里 

554
00:17:56,066 --> 00:17:57,156
着色器永远连接到通道上

555
00:17:57,556 --> 00:17:59,556
因此 这是一个列表

556
00:17:59,556 --> 00:18:00,656
上面是所有

557
00:17:59,556 --> 00:18:00,656
上面是所有

558
00:18:00,656 --> 00:18:01,126
捕捉中可以得到的

559
00:18:01,126 --> 00:18:01,466
发起程序组合

560
00:18:02,486 --> 00:18:04,506
我要看一下

561
00:18:04,506 --> 00:18:05,296
最昂贵的通道

562
00:18:05,296 --> 00:18:06,836
去看看我们是否

563
00:18:06,836 --> 00:18:07,866
能改进着色器

564
00:18:08,436 --> 00:18:12,726
我们可以看到这个视图

565
00:18:12,726 --> 00:18:13,586
有三个部分

566
00:18:13,956 --> 00:18:15,686
最上面的是评价 (remarks)

567
00:18:16,296 --> 00:18:17,626
评价是改进

568
00:18:17,626 --> 00:18:19,246
编译器着色器质量的好办法

569
00:18:19,616 --> 00:18:21,576
它会报告最终编译器

570
00:18:22,116 --> 00:18:23,486
合成时产生的问题

571
00:18:24,646 --> 00:18:26,326
要记住 GPU 会

572
00:18:26,326 --> 00:18:28,206
在每一帧中运行着色器上百万次

573
00:18:28,206 --> 00:18:30,046
因此 

574
00:18:30,046 --> 00:18:31,446
你合成的越好

575
00:18:31,446 --> 00:18:33,746
它的性能就会越好

576
00:18:35,096 --> 00:18:36,406
评价还按相关度分类

577
00:18:36,406 --> 00:18:38,766
如果扩张了

578
00:18:38,766 --> 00:18:41,106
它还会告诉你

579
00:18:41,106 --> 00:18:42,986
为什么要上报

580
00:18:42,986 --> 00:18:44,556
再给出建议 该如何预防这种情况

581
00:18:45,456 --> 00:18:45,523
发生

582
00:18:46,226 --> 00:18:47,836
在评价下面

583
00:18:47,836 --> 00:18:49,336
是每个着色器的概况

584
00:18:49,336 --> 00:18:50,496
你可以看到编译器是如何

585
00:18:50,576 --> 00:18:52,986
最终组合

586
00:18:52,986 --> 00:18:54,096
指令比 (instruction

587
00:18:54,166 --> 00:18:54,876
ratio)

588
00:18:56,186 --> 00:18:58,046
最后 我们还有

589
00:18:58,106 --> 00:18:59,306
所用使用这个通道的调回的

590
00:18:59,306 --> 00:18:59,756
列表

591
00:19:00,396 --> 00:19:01,626
这会在我们

592
00:19:01,626 --> 00:19:02,776
迭代我们的着色器时

593
00:19:02,776 --> 00:19:03,396
非常方便

594
00:19:04,426 --> 00:19:06,946
下面让我来展示一个例子

595
00:19:06,946 --> 00:19:08,506
是关于工作流剖析数据的

596
00:19:09,376 --> 00:19:10,976
我们来到最上面的评价部分

597
00:19:11,186 --> 00:19:13,036
寄存器溢出 (Register Spill) 我们可以看到

598
00:19:13,036 --> 00:19:14,846
编译器报告了一个很大的

599
00:19:14,846 --> 00:19:16,946
溢出 有 1040 字节

600
00:19:17,786 --> 00:19:19,246
溢出会导致 GPU

601
00:19:19,246 --> 00:19:21,546
访问内存 这会拖延

602
00:19:21,546 --> 00:19:22,486
你的着色执行

603
00:19:23,856 --> 00:19:24,806
如果能够知道编译器

604
00:19:24,806 --> 00:19:26,326
发生了溢出 并修复它

605
00:19:26,326 --> 00:19:27,376
这会极大地提升你的着色器

606
00:19:27,376 --> 00:19:29,636
性能 但是要找到

607
00:19:29,636 --> 00:19:30,886
编译器在哪里发生溢出

608
00:19:31,296 --> 00:19:32,566
及其原因 这是一个很耗费时间的

609
00:19:32,566 --> 00:19:32,876
事情

610
00:19:33,936 --> 00:19:36,596
但要注意的是第二个和第四个

611
00:19:36,596 --> 00:19:37,106
评价

612
00:19:37,586 --> 00:19:39,156
动态栈存储 (Dynamic Stack Store)

613
00:19:39,156 --> 00:19:39,766
和动态栈读取

614
00:19:40,776 --> 00:19:43,056
如果扩展了 它会给出原因

615
00:19:43,226 --> 00:19:45,046
为什么一个昂贵的栈读取

616
00:19:45,046 --> 00:19:46,716
在本地数组中被反射到

617
00:19:46,716 --> 00:19:47,416
动态偏移上

618
00:19:48,256 --> 00:19:51,096
同时还会给出建议

619
00:19:51,096 --> 00:19:52,256
减少栈访问

620
00:19:52,336 --> 00:19:53,786
消除对于本地数组的

621
00:19:53,786 --> 00:19:54,476
动态访问

622
00:19:55,236 --> 00:19:57,026
这等于在说

623
00:19:57,026 --> 00:19:58,586
在我们的着色器代码中

624
00:19:58,586 --> 00:20:00,116
有一个可变数组在

625
00:19:58,586 --> 00:20:00,116
有一个可变数组在

626
00:20:00,116 --> 00:20:01,936
储存栈 而且我们

627
00:20:01,936 --> 00:20:03,416
在用一些别的可变索引访问它

628
00:20:04,296 --> 00:20:05,996
这在支持 CPU 时

629
00:20:05,996 --> 00:20:07,816
是一个非常常见的模式

630
00:20:07,816 --> 00:20:09,286
但 GPU 不同 我们如果依赖栈的使用

631
00:20:09,286 --> 00:20:11,346
就会造成 GPU 的负担

632
00:20:11,966 --> 00:20:14,726
但要注意建议下面的

633
00:20:14,726 --> 00:20:15,376
话

634
00:20:15,426 --> 00:20:16,916
它有一个准确的行数

635
00:20:17,436 --> 00:20:18,676
这意味着我们选择点击它

636
00:20:18,776 --> 00:20:22,086
就会直接跳转到

637
00:20:22,086 --> 00:20:23,426
着色器代码行

638
00:20:23,426 --> 00:20:25,146
在这里编译器在从

639
00:20:25,146 --> 00:20:26,286
栈数组中读取数据

640
00:20:26,776 --> 00:20:27,896
我们找到编译器溢出了

641
00:20:29,366 --> 00:20:30,656
同时这与我们的共享性能数据

642
00:20:30,656 --> 00:20:31,676
协调得非常好

643
00:20:31,676 --> 00:20:33,116
会让我们知道这一行的高代价

644
00:20:33,116 --> 00:20:34,986
现在我们知道

645
00:20:34,986 --> 00:20:35,666
到底为什么了

646
00:20:37,396 --> 00:20:40,326
着色器执行了两个 pass

647
00:20:41,056 --> 00:20:42,836
第一个 pass 是光线计算

648
00:20:44,166 --> 00:20:46,956
第二个 pass 是

649
00:20:46,956 --> 00:20:47,776
光线积累

650
00:20:48,766 --> 00:20:49,766
这是从 GPU 的角度

651
00:20:49,766 --> 00:20:51,076
与编译器共同工作

652
00:20:51,076 --> 00:20:52,186
来解决问题

653
00:20:52,856 --> 00:20:55,056
我要做的第一件事

654
00:20:55,176 --> 00:20:56,686
是移除栈数组

655
00:20:56,686 --> 00:20:59,756
我要移除它

656
00:20:59,756 --> 00:21:02,366
然后我要

657
00:20:59,756 --> 00:21:02,366
然后我要

658
00:21:02,366 --> 00:21:03,536
第一个循环里

659
00:21:03,536 --> 00:21:04,896
直接计算

660
00:21:04,896 --> 00:21:06,166
光线积累

661
00:21:09,116 --> 00:21:10,736
然后我要移除

662
00:21:10,736 --> 00:21:12,976
第二个循环

663
00:21:13,996 --> 00:21:14,316
不再这样做了

664
00:21:14,316 --> 00:21:15,916
现在我要点击

665
00:21:15,916 --> 00:21:17,396
更新着色器按键 然后

666
00:21:17,396 --> 00:21:17,916
等待结果

667
00:21:18,516 --> 00:21:19,646
这样做会

668
00:21:19,646 --> 00:21:20,966
让编译器进行一次

669
00:21:20,966 --> 00:21:21,776
完整的循环优化

670
00:21:21,776 --> 00:21:24,376
并重新反复使用同样的

671
00:21:24,376 --> 00:21:26,636
减速器而不是去

672
00:21:26,636 --> 00:21:27,596
依赖那个栈

673
00:21:28,906 --> 00:21:30,356
结果出来之后

674
00:21:30,356 --> 00:21:31,786
我们就能看到

675
00:21:31,786 --> 00:21:33,356
前后的合成中的指令比率

676
00:21:33,356 --> 00:21:35,416
已经变小了

677
00:21:35,416 --> 00:21:36,486
同时 这一更改

678
00:21:36,486 --> 00:21:38,006
对通道中用到的每一个绘制调用

679
00:21:38,006 --> 00:21:39,726
的影响也小了

680
00:21:39,726 --> 00:21:41,296
给了我们整个空间性能

681
00:21:41,296 --> 00:21:41,896
的改进

682
00:21:43,046 --> 00:21:44,226
到这里 关于

683
00:21:44,226 --> 00:21:44,986
这个示例

684
00:21:44,986 --> 00:21:46,246
就结束了

685
00:21:46,466 --> 00:21:47,656
交还给我的同事

686
00:21:47,656 --> 00:21:47,926
Seth

687
00:21:49,516 --> 00:21:54,756
[掌声] 

688
00:21:55,256 --> 00:21:56,866
&gt;&gt; 谢谢 Jose

689
00:21:56,966 --> 00:21:59,766
下面讲我们今天要介绍的

690
00:21:59,766 --> 00:22:00,296
最后一样工具

691
00:21:59,766 --> 00:22:00,296
最后一样工具

692
00:22:00,726 --> 00:22:02,286
GPU 计数分析 (GPU Counter Profiling)

693
00:22:02,806 --> 00:22:06,196
大家知道 GPU 构建非常复杂

694
00:22:06,196 --> 00:22:08,056
因为有由多个可编程

695
00:22:08,056 --> 00:22:08,986
的固定功能块组成

696
00:22:08,986 --> 00:22:10,366
的通道

697
00:22:10,366 --> 00:22:12,196
在这个通道中

698
00:22:12,196 --> 00:22:13,396
任何地方都可能出现瓶颈

699
00:22:14,216 --> 00:22:15,476
而且常常是

700
00:22:15,546 --> 00:22:16,936
多个地方同时发生

701
00:22:18,386 --> 00:22:20,986
你们作为 Metal 程序员的任务

702
00:22:20,986 --> 00:22:23,026
是让固定功能瓶颈最小化

703
00:22:23,026 --> 00:22:24,366
同时还要有效地

704
00:22:24,366 --> 00:22:25,966
利用可编程块

705
00:22:28,776 --> 00:22:30,586
要实现这一点 我们的

706
00:22:30,586 --> 00:22:33,166
新 GPU 计数分析是个好工具

707
00:22:33,546 --> 00:22:36,106
它不会直接去到

708
00:22:36,106 --> 00:22:38,236
GPU 帧调试器 而是给你

709
00:22:38,236 --> 00:22:40,286
详细的 GPU 硬件

710
00:22:40,286 --> 00:22:42,866
性能数据 在 macOS 上

711
00:22:42,866 --> 00:22:46,496
以每个 draw call 的频率给出

712
00:22:46,496 --> 00:22:49,066
在 iOS 和 Apple tvOS 上以每个编码器的频率给出

713
00:22:50,036 --> 00:22:51,986
它不会给你

714
00:22:51,986 --> 00:22:54,336
一个复杂的计数列表

715
00:22:54,336 --> 00:22:55,906
这种列表为每个 GPU 发生变化

716
00:22:55,906 --> 00:22:57,676
难以理解 常常无法

717
00:22:58,206 --> 00:22:59,216
告诉你你想知道的事

718
00:22:59,216 --> 00:23:01,576
我们定义了一系列

719
00:22:59,216 --> 00:23:01,576
我们定义了一系列

720
00:23:01,576 --> 00:23:03,236
高等级的字符

721
00:23:03,236 --> 00:23:04,936
对每个 GPU 的意义都相同

722
00:23:05,286 --> 00:23:07,296
所以你不需要针对每个 GPU 的

723
00:23:07,296 --> 00:23:08,666
学习曲线了

724
00:23:10,156 --> 00:23:12,606
这就是计数分析

725
00:23:13,146 --> 00:23:16,726
在左边是图像视图

726
00:23:16,726 --> 00:23:19,506
显示出详细的 GPU

727
00:23:19,546 --> 00:23:21,156
计数图 在右边

728
00:23:21,156 --> 00:23:22,886
是细节窗口

729
00:23:23,606 --> 00:23:25,246
我们一样一样说

730
00:23:26,036 --> 00:23:29,866
在图像视图中

731
00:23:30,276 --> 00:23:33,306
显示了每一帧的计数

732
00:23:33,936 --> 00:23:35,706
X 轴代表绘制调用

733
00:23:35,706 --> 00:23:37,836
或者时间上的编码器

734
00:23:39,036 --> 00:23:40,506
在最上面显示的是 GPU 时间

735
00:23:40,826 --> 00:23:43,206
所有的 GPU 计数分析

736
00:23:43,206 --> 00:23:43,996
都有这个

737
00:23:44,746 --> 00:23:45,886
在它下面

738
00:23:45,886 --> 00:23:47,106
是一系列顶级计数

739
00:23:47,106 --> 00:23:48,706
对应 GPU 通道中的每个阶段

740
00:23:48,706 --> 00:23:50,986
以及一些其他的

741
00:23:50,986 --> 00:23:52,386
顶级计数

742
00:23:52,386 --> 00:23:53,996
对应共享执行单元

743
00:23:53,996 --> 00:23:55,816
比如着色器核心

744
00:23:55,816 --> 00:23:56,836
和测试单元

745
00:23:58,616 --> 00:24:00,796
你可以在每一组

746
00:23:58,616 --> 00:24:00,796
你可以在每一组

747
00:24:00,796 --> 00:24:02,686
深挖到更细节的计数

748
00:24:02,686 --> 00:24:04,726
在每一个阶段中

749
00:24:04,726 --> 00:24:06,966
探索更多数据

750
00:24:06,966 --> 00:24:08,926
这对那些你认为

751
00:24:08,926 --> 00:24:10,616
首当其冲可能是

752
00:24:10,616 --> 00:24:11,816
性能发生问题的

753
00:24:11,976 --> 00:24:13,746
工作流很有用 然后你可以看更多细节

754
00:24:13,746 --> 00:24:14,286
从而发现问题

755
00:24:14,976 --> 00:24:19,586
在细节视图中 

756
00:24:19,586 --> 00:24:20,976
我们会向你展示

757
00:24:20,976 --> 00:24:22,306
和计数图像视图中一样的

758
00:24:22,306 --> 00:24:23,706
计数 但是会展示全部的细节

759
00:24:23,706 --> 00:24:24,226
以数值模拟的方式

760
00:24:25,096 --> 00:24:26,546
为了给它一个背景

761
00:24:26,546 --> 00:24:28,656
我们还会展示出 

762
00:24:28,656 --> 00:24:29,996
这一帧的中值 最大值

763
00:24:29,996 --> 00:24:30,786
以及总数值

764
00:24:31,016 --> 00:24:34,546
图像视图和

765
00:24:34,546 --> 00:24:35,856
细节视图都支持

766
00:24:35,856 --> 00:24:38,136
全面丰富的过滤选项

767
00:24:38,426 --> 00:24:40,036
我们在帧调试器的其他地方也支持

768
00:24:40,036 --> 00:24:42,226
这种选项 所以如果你想同时

769
00:24:42,226 --> 00:24:44,086
查看某个像素数据

770
00:24:44,216 --> 00:24:45,426
和某个内存数据

771
00:24:45,426 --> 00:24:47,336
你可以把搜索项目合并

772
00:24:47,336 --> 00:24:48,776
然后依次查看

773
00:24:48,776 --> 00:24:49,876
你所需要的所有东西

774
00:24:51,406 --> 00:24:54,696
但我要重点指出 

775
00:24:54,696 --> 00:24:56,756
GPU 计数分析是我们

776
00:24:56,756 --> 00:24:58,026
对瓶颈分析的利器

777
00:24:59,016 --> 00:25:00,516
我们用它找出

778
00:24:59,016 --> 00:25:00,516
我们用它找出

779
00:25:00,516 --> 00:25:01,896
在每一个绘制调用

780
00:25:01,896 --> 00:25:03,706
或者每一个编码器中

781
00:25:03,706 --> 00:25:05,536
用过的计数 

782
00:25:05,536 --> 00:25:07,696
对它进行全面分析

783
00:25:07,696 --> 00:25:10,446
这种分析是跨平台基础上的

784
00:25:10,446 --> 00:25:12,716
也是以每个 GPU 为基础的

785
00:25:12,716 --> 00:25:14,506
从而找出每个调用中的潜在瓶颈

786
00:25:16,446 --> 00:25:19,546
除了这个 我们还给你

787
00:25:19,546 --> 00:25:21,416
很多数据 让你知道

788
00:25:21,416 --> 00:25:22,636
发生了什么

789
00:25:23,006 --> 00:25:24,306
什么导致的

790
00:25:24,306 --> 00:25:26,266
然后是直接导航到

791
00:25:26,266 --> 00:25:28,716
受影响地区的直观工作流

792
00:25:30,346 --> 00:25:32,136
现在 所有的瓶颈

793
00:25:32,136 --> 00:25:34,356
以及所有的计数

794
00:25:34,486 --> 00:25:36,606
都会在 Xcode 文件里

795
00:25:36,866 --> 00:25:38,826
有丰富的细节记录

796
00:25:39,166 --> 00:25:40,716
详细解释每一个计数的意义

797
00:25:40,716 --> 00:25:43,276
为什么它特别高

798
00:25:43,276 --> 00:25:44,636
或者特别低

799
00:25:44,636 --> 00:25:46,626
以及你能

800
00:25:46,626 --> 00:25:47,846
做些什么

801
00:25:47,846 --> 00:25:49,306
要展示这个

802
00:25:49,516 --> 00:25:51,086
很棒的 GPU 计数分析特性

803
00:25:51,086 --> 00:25:52,556
我想再次请上我的同事 

804
00:25:52,556 --> 00:25:54,476
Jose 来给大家做

805
00:25:54,476 --> 00:25:56,336
实际应用的演示

806
00:25:57,516 --> 00:25:59,676
[掌声] 

807
00:26:00,176 --> 00:26:00,576
&gt;&gt; 谢谢 Seth

808
00:26:01,176 --> 00:26:02,116
我又来了

809
00:26:02,806 --> 00:26:06,066
这次我要展示的是

810
00:26:06,426 --> 00:26:10,266
GPU 计数器 这个工具

811
00:26:10,266 --> 00:26:11,396
会帮助你分析

812
00:26:11,396 --> 00:26:11,996
GPU 的性能

813
00:26:13,036 --> 00:26:14,066
首先 我要再播放一遍

814
00:26:14,066 --> 00:26:15,286
刚才放过的演示

815
00:26:15,286 --> 00:26:17,496
但这次 我们要从性能角度

816
00:26:17,496 --> 00:26:18,636
注意观看

817
00:26:19,766 --> 00:26:21,596
要注意的第一件事是

818
00:26:21,596 --> 00:26:23,656
新的 GPU 测量

819
00:26:23,656 --> 00:26:24,336
就在 FPS 测量下面

820
00:26:25,366 --> 00:26:26,356
点击它 我们就

821
00:26:26,356 --> 00:26:28,796
来到了 GP 计数视图

822
00:26:29,436 --> 00:26:31,316
我们可以看到

823
00:26:31,316 --> 00:26:32,486
这里有很多数据

824
00:26:33,106 --> 00:26:34,306
这在之前是没有过的

825
00:26:34,476 --> 00:26:36,286
有了这个视图 你们就可以

826
00:26:36,356 --> 00:26:38,216
传输文件 在任意捕捉帧中

827
00:26:38,216 --> 00:26:39,316
你所遇到的任何问题

828
00:26:39,316 --> 00:26:40,296
都可以

829
00:26:41,326 --> 00:26:42,796
我来演示一下要怎么

830
00:26:42,796 --> 00:26:43,776
发现性能问题

831
00:26:45,326 --> 00:26:46,696
首先 我们来看图像

832
00:26:46,696 --> 00:26:47,016
视图

833
00:26:50,206 --> 00:26:51,566
我们看到

834
00:26:51,566 --> 00:26:53,076
在一个捕捉的开始

835
00:26:53,076 --> 00:26:54,016
有一个 GPU 时间的高峰

836
00:26:54,526 --> 00:26:56,356
你要做的第一件事

837
00:26:56,356 --> 00:26:58,746
就是放大去看单一的回调

838
00:26:58,826 --> 00:26:59,876
有更多的

839
00:26:59,876 --> 00:27:00,436
offender

840
00:26:59,876 --> 00:27:00,436
offender

841
00:27:00,946 --> 00:27:01,926
要做到这一点 我只需

842
00:27:01,926 --> 00:27:04,596
捏合缩放 这样就

843
00:27:04,596 --> 00:27:04,846
可以了

844
00:27:05,556 --> 00:27:07,216
任何默认系统行为

845
00:27:07,216 --> 00:27:08,356
都会按你的意愿

846
00:27:08,356 --> 00:27:08,696
工作

847
00:27:09,406 --> 00:27:11,546
现在我会看到这里有一个

848
00:27:11,546 --> 00:27:12,266
高峰

849
00:27:12,456 --> 00:27:14,106
你可以通过点击这个

850
00:27:14,106 --> 00:27:15,306
绘制调用

851
00:27:15,436 --> 00:27:17,856
在所有通道中标记这个高峰

852
00:27:17,856 --> 00:27:19,856
在每一行上悬停会给我们

853
00:27:19,856 --> 00:27:21,396
细节信息 让我们知道

854
00:27:21,396 --> 00:27:23,016
它们分别与这个绘制调用

855
00:27:23,016 --> 00:27:23,936
有多大相关

856
00:27:24,856 --> 00:27:26,896
在这个示例中 Vertex Omission

857
00:27:27,026 --> 00:27:28,506
Vertex Shader 和 Primitives

858
00:27:28,936 --> 00:27:30,546
似乎都没有相关的

859
00:27:30,676 --> 00:27:30,876
影响

860
00:27:31,406 --> 00:27:33,096
与之相反 Fragment Shader

861
00:27:33,716 --> 00:27:35,236
和 Pixels Stored 看起来

862
00:27:35,436 --> 00:27:36,316
相当的高

863
00:27:37,106 --> 00:27:38,836
我们先来看一下 Fragment

864
00:27:38,836 --> 00:27:39,436
Shader

865
00:27:40,396 --> 00:27:42,326
如果我们展开这个组

866
00:27:42,326 --> 00:27:43,796
就能够访问大量的

867
00:27:43,796 --> 00:27:45,596
计数数据 这能给我们

868
00:27:45,656 --> 00:27:47,336
细节信息 让我们知道

869
00:27:47,336 --> 00:27:48,806
着色器阶段发生了什么

870
00:27:49,636 --> 00:27:50,646
最后被计数的

871
00:27:50,646 --> 00:27:52,366
我们可以很快看到 

872
00:27:52,616 --> 00:27:54,476
延时时间高得出奇

873
00:27:54,476 --> 00:27:56,786
超过了 76%

874
00:27:57,486 --> 00:27:58,936
这意味着我们花在

875
00:27:58,936 --> 00:28:00,116
Fragment Shader 上的

876
00:27:58,936 --> 00:28:00,116
Fragment Shader 上的

877
00:28:00,116 --> 00:28:01,586
大多数时间实际上是在等待

878
00:28:01,586 --> 00:28:03,366
一些内存或者数据

879
00:28:04,526 --> 00:28:06,776
这是因为你在

880
00:28:06,776 --> 00:28:08,176
从一个缓冲器

881
00:28:08,176 --> 00:28:10,596
或者从一个纹理中取用

882
00:28:10,596 --> 00:28:11,806
但纹理捕捉应该在这个延迟里

883
00:28:12,406 --> 00:28:14,556
所以让我们去到纹理单元 (Texture

884
00:28:14,556 --> 00:28:16,736
Unit) 看看缓存率

885
00:28:16,736 --> 00:28:16,956
是多少

886
00:28:18,746 --> 00:28:20,526
我们可以立即看到 

887
00:28:20,526 --> 00:28:22,256
纹理缓存率也出奇的高

888
00:28:22,256 --> 00:28:24,586
几乎到了 60%

889
00:28:25,326 --> 00:28:27,246
这意味着超过一半的

890
00:28:27,246 --> 00:28:28,396
纹理样本

891
00:28:28,396 --> 00:28:29,636
都来自视频内存

892
00:28:29,636 --> 00:28:30,766
而不是纹理缓存

893
00:28:31,966 --> 00:28:33,956
现在我们对于当前的问题

894
00:28:33,956 --> 00:28:34,946
有了更好的了解

895
00:28:34,946 --> 00:28:36,966
就来看一看

896
00:28:36,966 --> 00:28:37,636
辅助编辑器吧

897
00:28:38,196 --> 00:28:41,686
我们可以看到 

898
00:28:41,686 --> 00:28:43,406
辅助编辑器提供了

899
00:28:43,506 --> 00:28:45,006
和图像视图一样的

900
00:28:45,006 --> 00:28:46,156
计数信息

901
00:28:46,356 --> 00:28:48,106
这不过这次是以列表视图显示的

902
00:28:48,806 --> 00:28:51,376
但更重要的是 看一下顶部

903
00:28:51,826 --> 00:28:53,286
这是我们的瓶颈访问工具

904
00:28:53,566 --> 00:28:56,406
它会指出我们在

905
00:28:56,406 --> 00:28:58,106
选择的绘制调用内部

906
00:28:58,106 --> 00:29:00,276
分析所有计数时

907
00:28:58,106 --> 00:29:00,276
分析所有计数时

908
00:29:00,276 --> 00:29:01,736
所考虑到的两个相关问题

909
00:29:01,736 --> 00:29:03,076
并指出了我们认为

910
00:29:03,076 --> 00:29:04,976
值得引起你们注意的

911
00:29:04,976 --> 00:29:05,926
任何相关问题

912
00:29:06,266 --> 00:29:07,356
在这个示例里 

913
00:29:07,356 --> 00:29:09,446
标记同样的问题

914
00:29:09,446 --> 00:29:12,776
也就是我们刚才通过检查图表

915
00:29:12,776 --> 00:29:15,646
手动发现的问题 纹理缓存失误率很高

916
00:29:15,876 --> 00:29:17,686
展开之后 它还

917
00:29:17,686 --> 00:29:18,586
给出了建议 告诉我们应该检查

918
00:29:18,586 --> 00:29:18,866
什么

919
00:29:19,636 --> 00:29:21,436
在这个示例里 检查

920
00:29:21,436 --> 00:29:23,446
样本纹理是否有纹理映射

921
00:29:23,486 --> 00:29:25,406
还有关于这个问题的

922
00:29:25,436 --> 00:29:26,786
相关视图的快速导航名称

923
00:29:28,066 --> 00:29:29,656
比如边界资源 (boundary sources)

924
00:29:30,006 --> 00:29:31,266
我们可以立即看到

925
00:29:31,266 --> 00:29:32,886
现在的问题是什么

926
00:29:32,886 --> 00:29:35,866
我们正在获取一个 4 K 乘 4 K 的 RGBA32

927
00:29:35,926 --> 00:29:37,126
浮点纹理

928
00:29:37,126 --> 00:29:38,576
并且这个浮点纹理在 vertex

929
00:29:39,226 --> 00:29:40,126
和 Fragment Shader 里都没有纹理映射

930
00:29:40,476 --> 00:29:43,336
这是一个 256 MB 的纹理

931
00:29:43,336 --> 00:29:44,866
在整个通道里被获取

932
00:29:45,846 --> 00:29:47,816
难怪缓存都被浪费了

933
00:29:48,826 --> 00:29:50,156
想一想我们刚才

934
00:29:50,156 --> 00:29:50,826
做了什么

935
00:29:51,426 --> 00:29:52,486
这是一个非常详细的

936
00:29:52,486 --> 00:29:54,656
关于 GPU 内部工作的视图

937
00:29:55,616 --> 00:29:56,926
你们终于有了能够证明

938
00:29:56,926 --> 00:29:58,216
从纹理中获取

939
00:29:58,216 --> 00:29:59,746
是昂贵的

940
00:29:59,746 --> 00:30:01,226
这件事的数据

941
00:29:59,746 --> 00:30:01,226
这件事的数据

942
00:30:01,226 --> 00:30:02,176
但现在你知道为什么了

943
00:30:03,296 --> 00:30:05,076
访问这个纹理

944
00:30:05,076 --> 00:30:06,216
在 Fragment Shader 上是一个开始

945
00:30:06,216 --> 00:30:08,136
因为它必须从

946
00:30:08,136 --> 00:30:09,196
内置内存中获取数据

947
00:30:09,196 --> 00:30:11,426
这些数据现在在缓存里

948
00:30:12,376 --> 00:30:12,576
已经没有了

949
00:30:12,706 --> 00:30:13,656
这种程度的细节

950
00:30:13,656 --> 00:30:14,716
一般在咨询工具之外

951
00:30:14,716 --> 00:30:15,606
很难见到

952
00:30:16,706 --> 00:30:17,896
解决这个问题现在

953
00:30:17,896 --> 00:30:20,566
取决于平衡 性能

954
00:30:21,006 --> 00:30:22,736
质量和正确率

955
00:30:22,736 --> 00:30:23,926
但你已经展示了

956
00:30:23,926 --> 00:30:25,036
要如何运用 GPU 计数和

957
00:30:25,036 --> 00:30:27,376
GPU 帧调试器 来帮助你

958
00:30:27,376 --> 00:30:30,196
调查 分析 

959
00:30:30,196 --> 00:30:32,016
分辨任何的捕捉信息

960
00:30:32,016 --> 00:30:34,246
任何在你的捕捉里的

961
00:30:34,246 --> 00:30:35,256
性能信息

962
00:30:35,676 --> 00:30:37,056
现在再请我的同事

963
00:30:37,056 --> 00:30:37,586
Seth 回来

964
00:30:38,516 --> 00:30:43,500
[掌声] 

965
00:30:48,386 --> 00:30:48,976
&gt;&gt; 谢谢 Jose

966
00:30:50,696 --> 00:30:52,756
这就是 GPU 计数

967
00:30:52,756 --> 00:30:53,346
分析

968
00:30:53,966 --> 00:30:54,926
和我们今天说过的所有新

969
00:30:54,926 --> 00:30:56,456
特性一样

970
00:30:56,456 --> 00:30:58,676
它是 Xcode Beta 9 里的最大乐趣

971
00:30:59,166 --> 00:31:00,716
它对所有可以使用 Metal 的

972
00:30:59,166 --> 00:31:00,716
它对所有可以使用 Metal 的

973
00:31:00,716 --> 00:31:01,906
GPU 都适用

974
00:31:02,656 --> 00:31:04,356
你们会发现 

975
00:31:04,356 --> 00:31:05,586
越新的 GPU 就有越多的计数可用

976
00:31:05,586 --> 00:31:07,676
因为 GPU 更加现代化了

977
00:31:07,986 --> 00:31:10,086
但所有的 GPU

978
00:31:10,086 --> 00:31:11,976
都会有丰富可用的

979
00:31:11,976 --> 00:31:13,616
计数

980
00:31:14,026 --> 00:31:16,616
尽管如此 我们还是非常

981
00:31:16,616 --> 00:31:17,936
期待你们的反馈

982
00:31:17,936 --> 00:31:18,946
如果你们觉得哪个计数

983
00:31:18,946 --> 00:31:19,696
还没有 它又非常

984
00:31:19,696 --> 00:31:22,156
有价值 那么就请

985
00:31:22,426 --> 00:31:24,606
务必光临实验室

986
00:31:24,606 --> 00:31:26,046
我们会很乐意

987
00:31:26,046 --> 00:31:26,956
进行研究

988
00:31:27,386 --> 00:31:28,986
我们今天说了

989
00:31:28,986 --> 00:31:29,226
什么呢

990
00:31:29,486 --> 00:31:30,586
我们讲到了

991
00:31:30,586 --> 00:31:31,906
Metal 帧调试器的一些很好的改进

992
00:31:31,906 --> 00:31:33,676
包括支持像素检查

993
00:31:33,676 --> 00:31:35,846
检查 Vertex

994
00:31:36,246 --> 00:31:39,256
Shader 输出 丰富的过滤

995
00:31:39,776 --> 00:31:42,186
更好的捕捉支持 

996
00:31:42,186 --> 00:31:44,196
更好的捕捉性能

997
00:31:44,196 --> 00:31:45,696
和 Xcode Metal Quick Look

998
00:31:46,216 --> 00:31:49,206
我们还讲到了

999
00:31:49,206 --> 00:31:50,586
对 Metal 托盘调试器中

1000
00:31:50,586 --> 00:31:53,506
VR 应用的调试和分析的支持

1001
00:31:53,506 --> 00:31:54,876
以及 Metal 系统托盘

1002
00:31:57,356 --> 00:31:59,986
我们讲到了 Metal

1003
00:32:00,056 --> 00:32:01,726
通道数据

1004
00:32:01,726 --> 00:32:03,236
让你们直接进入

1005
00:32:03,236 --> 00:32:04,316
GPU compiler

1006
00:32:04,316 --> 00:32:04,916
获取性能信息

1007
00:32:06,696 --> 00:32:08,516
我们还介绍了 GPU 计数分析

1008
00:32:08,516 --> 00:32:11,586
它让你们能够

1009
00:32:11,586 --> 00:32:13,626
访问 Metal 里的

1010
00:32:13,626 --> 00:32:17,346
GPU 性能计数数据

1011
00:32:17,626 --> 00:32:19,866
更多信息请访问

1012
00:32:19,866 --> 00:32:20,486
网站

1013
00:32:22,166 --> 00:32:23,846
编号是 607

1014
00:32:23,846 --> 00:32:28,276
我还想推荐

1015
00:32:28,276 --> 00:32:29,956
其他的一些演讲

1016
00:32:30,316 --> 00:32:31,756
如果你们没有赶上

1017
00:32:31,756 --> 00:32:33,946
Introducing Metal 2 或者 VR With

1018
00:32:33,946 --> 00:32:35,716
Metal 2 这两场本周早些时候的

1019
00:32:35,716 --> 00:32:38,186
演讲 它们非常值得

1020
00:32:38,186 --> 00:32:39,896
你通过视频来再次观看

1021
00:32:39,896 --> 00:32:41,606
就算你们已经去过

1022
00:32:41,606 --> 00:32:42,736
也请在视频中再次看看它们

1023
00:32:43,066 --> 00:32:45,246
今天下午晚些时候

1024
00:32:45,246 --> 00:32:46,446
还有一场很棒的演讲

1025
00:32:46,446 --> 00:32:47,706
关于使用 Metal 2 进行计算

1026
00:32:47,706 --> 00:32:49,856
在 A 大厅

1027
00:32:49,926 --> 00:32:50,866
4 点 10 分开始

1028
00:32:51,386 --> 00:32:52,996
就到这里

1029
00:32:52,996 --> 00:32:54,216
谢谢大家

1030
00:32:54,556 --> 00:32:56,086
祝你们接下来的

1031
00:32:56,146 --> 00:32:58,436
WWDC 17 有所收获

1032
00:32:58,436 --> 00:32:58,776
谢谢大家
