1
00:00:20,516 --> 00:00:24,546
[掌声]

2
00:00:25,046 --> 00:00:27,656
&gt;&gt; 下午好 欢迎参加

3
00:00:27,656 --> 00:00:28,826
“测试新内容”会议

4
00:00:29,656 --> 00:00:31,196
我叫 Wil 从事

5
00:00:31,236 --> 00:00:33,066
Xcode 和 XCTest 方面的工作

6
00:00:34,166 --> 00:00:36,456
那么 有哪些关于测试的新内容呢

7
00:00:37,206 --> 00:00:38,376
答案是有很多

8
00:00:38,956 --> 00:00:40,316
实际上 由于数量太多 我们

9
00:00:40,316 --> 00:00:41,176
没时间在今天

10
00:00:41,176 --> 00:00:44,076
逐一介绍 

11
00:00:44,076 --> 00:00:44,466
那就开始吧

12
00:00:45,656 --> 00:00:47,656
首先 我们对 Xcode 8.3

13
00:00:47,656 --> 00:00:50,066
和 Xcode 9 都进行了一系列的

14
00:00:50,396 --> 00:00:51,446
改进

15
00:00:51,646 --> 00:00:53,566
我想先把这些改进列举出来

16
00:00:53,566 --> 00:00:54,646
然后再让你

17
00:00:54,646 --> 00:00:56,036
在 XCTest 的参考文档中

18
00:00:56,036 --> 00:00:58,196
详细了解 这份文档

19
00:00:58,196 --> 00:00:59,456
刚进行了大幅度

20
00:00:59,456 --> 00:00:59,916
更新

21
00:01:01,016 --> 00:01:03,016
之后我们会了解一下

22
00:01:03,096 --> 00:01:05,006
用于异步测试的新 API 

23
00:01:05,626 --> 00:01:08,126
多 App 测试

24
00:01:09,296 --> 00:01:10,626
以及 UI 测试的

25
00:01:10,626 --> 00:01:12,016
重要性能改进

26
00:01:12,806 --> 00:01:15,056
最后 我们会以一组

27
00:01:15,056 --> 00:01:16,326
叫做 Activity 附件

28
00:01:16,326 --> 00:01:18,416
和屏幕快照的技术

29
00:01:18,706 --> 00:01:19,586
来收尾

30
00:01:21,076 --> 00:01:22,426
让我们来看一看

31
00:01:22,426 --> 00:01:23,226
这些改进

32
00:01:24,516 --> 00:01:27,826
对于 Xcode 8.3 我们在针对 Siri 意图的

33
00:01:27,826 --> 00:01:30,066
UI 测试中添加了

34
00:01:30,066 --> 00:01:32,566
新的 XCUISiriService

35
00:01:33,366 --> 00:01:35,576
同时 我们在 macOS

36
00:01:35,576 --> 00:01:38,216
的 Touch Bar 中增加了

37
00:01:38,216 --> 00:01:38,946
UI 测试支持

38
00:01:39,576 --> 00:01:44,526
在 Xcode 9 的 XCTest 中 我们

39
00:01:44,556 --> 00:01:46,146
改良了 Swift 接口框架

40
00:01:46,146 --> 00:01:47,946
作为 Swift 4 的一部分

41
00:01:48,106 --> 00:01:50,356
我们还增加了一个

42
00:01:50,356 --> 00:01:52,766
新的基于块的 Teardown API

43
00:01:53,066 --> 00:01:55,266
能够在测试方法中构建

44
00:01:55,266 --> 00:01:57,526
上下文特定的 Teardown

45
00:01:57,526 --> 00:01:59,526
而无需测试类别的

46
00:01:59,866 --> 00:02:01,176
额外状态或

47
00:01:59,866 --> 00:02:01,176
额外状态或

48
00:02:01,176 --> 00:02:01,726
属性

49
00:02:03,136 --> 00:02:05,406
在 UI 测试中 我们为 macOS

50
00:02:05,406 --> 00:02:07,426
的菜单项推出了

51
00:02:07,456 --> 00:02:08,455
新的元素类别

52
00:02:09,526 --> 00:02:11,266
此外 XCUI 元素中

53
00:02:11,386 --> 00:02:13,676
有新的针对

54
00:02:13,676 --> 00:02:15,706
XCUIElement 的 API

55
00:02:15,706 --> 00:02:17,336
从而减少对 sleep() 函数的需求或

56
00:02:17,336 --> 00:02:19,576
测试中其他人工延迟

57
00:02:20,516 --> 00:02:24,546
[掌声]

58
00:02:25,046 --> 00:02:27,296
现在 xcodebuild 命令支持直接通过

59
00:02:27,296 --> 00:02:29,426
CoreSimulator 启动测试

60
00:02:29,426 --> 00:02:30,276
这样你在命令行

61
00:02:30,276 --> 00:02:31,726
运行测试时 就不再会

62
00:02:31,726 --> 00:02:33,096
看到模拟器 App

63
00:02:33,096 --> 00:02:33,296
启动了

64
00:02:33,536 --> 00:02:35,646
同时 我们也很高兴地

65
00:02:35,646 --> 00:02:37,586
宣布 xcodebuild 命令现在支持

66
00:02:37,846 --> 00:02:39,566
并行设备测试了

67
00:02:40,516 --> 00:02:44,546
[掌声]

68
00:02:45,046 --> 00:02:46,426
这意味着如果你传递

69
00:02:46,426 --> 00:02:48,126
多个目标区分符到

70
00:02:48,126 --> 00:02:50,236
xcodebuild 命令那么就可以使用一个平台

71
00:02:50,686 --> 00:02:52,266
一次性创建

72
00:02:52,266 --> 00:02:54,466
所有区分符 然后

73
00:02:54,466 --> 00:02:55,876
为这些目标同时

74
00:02:55,876 --> 00:02:56,826
运行测试

75
00:02:57,286 --> 00:02:58,676
这会极大地提高

76
00:02:59,036 --> 00:03:00,586
许多持续集成情景

77
00:02:59,036 --> 00:03:00,586
许多持续集成情景

78
00:03:00,586 --> 00:03:01,316
的速度

79
00:03:02,476 --> 00:03:05,106
在本地化方面 

80
00:03:05,106 --> 00:03:06,916
你可以在 Xcode 9 中设定运行测试

81
00:03:06,916 --> 00:03:08,436
所使用的语言

82
00:03:08,436 --> 00:03:08,686
和区域

83
00:03:09,366 --> 00:03:11,256
这个 Scheme 选项可以让你

84
00:03:11,256 --> 00:03:12,836
轻松测试你项目的

85
00:03:12,836 --> 00:03:14,936
各种本地化内容

86
00:03:16,176 --> 00:03:18,346
我还想花些时间来

87
00:03:18,466 --> 00:03:19,686
请大家看一看

88
00:03:19,946 --> 00:03:21,586
Xcode Server 的改进

89
00:03:22,536 --> 00:03:25,386
首先 有了 Xcode 9 

90
00:03:25,386 --> 00:03:27,326
就不再需要 macOS 服务器了

91
00:03:28,266 --> 00:03:30,346
你的团队可以直接在 Xcode 的

92
00:03:30,346 --> 00:03:31,756
全新偏好面板

93
00:03:31,756 --> 00:03:33,596
拨一下开关

94
00:03:33,596 --> 00:03:35,296
即可开启

95
00:03:35,326 --> 00:03:35,766
Xcode Server

96
00:03:37,376 --> 00:03:39,176
Xcode Server 也具有

97
00:03:39,176 --> 00:03:40,756
经过优化的配置工作流 

98
00:03:41,356 --> 00:03:43,106
并在 CoreSimulator 和

99
00:03:43,106 --> 00:03:44,756
并行测试中采用了

100
00:03:45,186 --> 00:03:46,116
改进后的 xcodebuild 命令

101
00:03:46,826 --> 00:03:47,966
同时 每个 Scheme 的

102
00:03:47,966 --> 00:03:49,116
本地化支持

103
00:03:49,356 --> 00:03:50,946
会自动覆盖到

104
00:03:50,946 --> 00:03:51,536
你所有的机器人

105
00:03:52,086 --> 00:03:55,546
那么以上就是我们最令人激动的

106
00:03:55,546 --> 00:03:56,516
全新改进

107
00:03:56,516 --> 00:03:57,246
的快速概览

108
00:03:57,576 --> 00:03:59,656
现在 让我们放慢速度 

109
00:03:59,656 --> 00:04:01,066
来仔细看看

110
00:03:59,656 --> 00:04:01,066
来仔细看看

111
00:04:01,186 --> 00:04:02,196
异步测试

112
00:04:03,566 --> 00:04:05,836
异步测试能够

113
00:04:05,836 --> 00:04:07,206
验证没有

114
00:04:07,206 --> 00:04:09,206
立即完成

115
00:04:09,546 --> 00:04:11,346
但随后却回调

116
00:04:11,566 --> 00:04:13,136
闭包 委托方法或其他

117
00:04:13,136 --> 00:04:14,266
延迟完成的代码

118
00:04:15,126 --> 00:04:17,016
这其中含有的任务包括打开文档

119
00:04:17,016 --> 00:04:18,815
后台线程完成

120
00:04:18,815 --> 00:04:19,926
的工作

121
00:04:20,366 --> 00:04:21,435
以及与其他进程

122
00:04:21,435 --> 00:04:23,876
网络 Activity

123
00:04:24,026 --> 00:04:26,246
动画及一系列

124
00:04:26,246 --> 00:04:27,316
UI 测试情景进行的通信

125
00:04:27,896 --> 00:04:31,056
几年前 我们

126
00:04:31,056 --> 00:04:33,596
在 Xcode 6 的异步测试中

127
00:04:33,596 --> 00:04:34,036
推出了API

128
00:04:34,826 --> 00:04:36,986
这些 XCTestCase 上的方法

129
00:04:36,986 --> 00:04:38,636
可以让你定义

130
00:04:38,676 --> 00:04:40,726
调用时的条件或期望 

131
00:04:40,726 --> 00:04:41,916
然后再让测试等待

132
00:04:41,916 --> 00:04:43,186
这些条件或期望

133
00:04:43,186 --> 00:04:43,726
完成或满足

134
00:04:45,356 --> 00:04:47,756
这里是一个简单的例子

135
00:04:48,236 --> 00:04:50,226
这个测试代码的片段

136
00:04:50,226 --> 00:04:51,606
打开了文档 等着它

137
00:04:51,606 --> 00:04:53,336
完成并假设它已经

138
00:04:53,336 --> 00:04:53,866
成功了

139
00:04:54,586 --> 00:04:55,966
期望对象

140
00:04:55,966 --> 00:04:57,596
在文档打开之前就已经

141
00:04:57,596 --> 00:04:57,966
创建了

142
00:04:58,566 --> 00:05:00,436
测试等待该文档在

143
00:04:58,566 --> 00:05:00,436
测试等待该文档在

144
00:05:00,436 --> 00:05:02,406
调用下打开并

145
00:05:02,496 --> 00:05:04,546
在闭包中完成 这使得

146
00:05:04,546 --> 00:05:06,186
测试继续运行

147
00:05:06,186 --> 00:05:08,106
并在等待调用后

148
00:05:08,106 --> 00:05:08,686
执行测试代码

149
00:05:09,396 --> 00:05:10,736
但这是我们在 Xcode 6 里

150
00:05:10,736 --> 00:05:12,416
的初始 API

151
00:05:13,436 --> 00:05:14,686
它的性能已经足够好了

152
00:05:14,686 --> 00:05:15,576
但仍存在一些限制

153
00:05:16,286 --> 00:05:18,106
首先 等待 Timeout String

154
00:05:18,106 --> 00:05:19,216
总是被当成

155
00:05:19,216 --> 00:05:19,796
测试失败来对待

156
00:05:20,346 --> 00:05:22,486
其次 等待需要

157
00:05:22,486 --> 00:05:24,426
测试对象本身

158
00:05:24,426 --> 00:05:26,096
这让提取任何类别的

159
00:05:26,096 --> 00:05:27,876
测试库或

160
00:05:27,916 --> 00:05:28,156
支持代码变得很困难

161
00:05:29,186 --> 00:05:31,076
我们所称的嵌套等待

162
00:05:31,076 --> 00:05:32,606
在这个 API 中也同样不可能

163
00:05:33,076 --> 00:05:34,256
嵌套等待涉及到

164
00:05:34,256 --> 00:05:35,256
需要在外部权重

165
00:05:35,256 --> 00:05:37,526
上下文内等待的

166
00:05:37,916 --> 00:05:39,966
额外期望群组

167
00:05:40,776 --> 00:05:42,866
为了解决这些问题 我们

168
00:05:42,866 --> 00:05:44,166
推出了新一类

169
00:05:44,446 --> 00:05:45,426
XCTWaiter

170
00:05:46,236 --> 00:05:48,126
这一类提取了过去

171
00:05:48,126 --> 00:05:49,076
XCTestCase 中含有的

172
00:05:49,076 --> 00:05:51,296
等待逻辑

173
00:05:51,296 --> 00:05:53,156
并允许你明确声明

174
00:05:53,156 --> 00:05:54,556
正在等待的

175
00:05:54,556 --> 00:05:54,716
期望

176
00:05:55,586 --> 00:05:57,536
超时和其他事件可

177
00:05:57,606 --> 00:05:59,056
通过一个委托 API 进行处理

178
00:05:59,056 --> 00:06:01,066
并且会从等待 API 中

179
00:05:59,056 --> 00:06:01,066
并且会从等待 API 中

180
00:06:01,066 --> 00:06:03,466
作为结果值返回

181
00:06:04,456 --> 00:06:06,316
这就为构建异步测试

182
00:06:06,316 --> 00:06:07,596
提供了

183
00:06:07,596 --> 00:06:09,096
更多的

184
00:06:09,096 --> 00:06:09,656
灵活性

185
00:06:10,206 --> 00:06:12,726
如果我们回到上一个

186
00:06:12,726 --> 00:06:14,526
例子 让我们来看一看

187
00:06:14,526 --> 00:06:16,006
现在等待有哪些

188
00:06:16,006 --> 00:06:16,406
选项

189
00:06:17,766 --> 00:06:20,416
在初始代码中 我们注意到

190
00:06:20,416 --> 00:06:22,076
并未提到任何期望

191
00:06:22,446 --> 00:06:23,146
这是因为

192
00:06:23,146 --> 00:06:25,386
执行是隐式的 

193
00:06:25,386 --> 00:06:27,706
它等待着测试对象

194
00:06:27,736 --> 00:06:29,336
创建的所有活跃期望

195
00:06:30,026 --> 00:06:32,846
而现在 只需要稍微改变 

196
00:06:32,846 --> 00:06:34,916
测试便可实现对文档期望的

197
00:06:34,916 --> 00:06:36,396
显式等待

198
00:06:37,426 --> 00:06:38,976
构建这个的一个

199
00:06:38,976 --> 00:06:41,356
等价的方式是创建

200
00:06:41,356 --> 00:06:43,496
XCTWaiter 的一个实例

201
00:06:43,496 --> 00:06:45,066
并将测试作为托管

202
00:06:46,376 --> 00:06:49,636
还有另一个选择是

203
00:06:49,696 --> 00:06:51,486
采用 XCTWaiter 类方法

204
00:06:51,486 --> 00:06:53,176
进行等待 然后再处理

205
00:06:53,176 --> 00:06:53,916
结果值

206
00:06:54,916 --> 00:06:56,726
这一灵活性使得

207
00:06:56,726 --> 00:06:58,826
在 Helper 方法 嵌套上下文

208
00:06:58,826 --> 00:07:01,516
或在从测试用例中

209
00:06:58,826 --> 00:07:01,516
或在从测试用例中

210
00:07:01,516 --> 00:07:02,776
完全解耦的

211
00:07:02,776 --> 00:07:04,366
测试库代码上使用 XCTWaiter

212
00:07:04,366 --> 00:07:05,216
变得十分容易

213
00:07:06,676 --> 00:07:09,046
除此之外 为了创建

214
00:07:09,046 --> 00:07:10,996
XCTWaiter 我们同时也扩充了

215
00:07:10,996 --> 00:07:13,076
XCTTestExpectation 的 API

216
00:07:13,586 --> 00:07:15,876
目前 初始化程序

217
00:07:15,876 --> 00:07:17,886
已经在公开的 API 中提供

218
00:07:17,886 --> 00:07:19,656
它也从 XCTestCase 中解耦

219
00:07:19,706 --> 00:07:20,676
期望的创建

220
00:07:21,486 --> 00:07:22,696
我们还引入了

221
00:07:22,696 --> 00:07:24,456
期望实现数

222
00:07:24,546 --> 00:07:25,846
属性 在这一属性下 

223
00:07:25,846 --> 00:07:27,296
期望象征着

224
00:07:27,296 --> 00:07:29,206
多次出现的

225
00:07:29,206 --> 00:07:29,716
条件

226
00:07:30,706 --> 00:07:31,976
对于那些根本不该出现的

227
00:07:31,976 --> 00:07:33,956
条件 有一个

228
00:07:33,956 --> 00:07:36,806
针对期望的倒置 API 

229
00:07:37,116 --> 00:07:38,346
这会让 XCTWaiter

230
00:07:38,346 --> 00:07:39,826
只在超时崩溃前

231
00:07:39,826 --> 00:07:41,726
就达到期望的时候

232
00:07:41,726 --> 00:07:43,026
才报告错误

233
00:07:43,876 --> 00:07:46,596
最后 XCTWaiter 可以

234
00:07:46,596 --> 00:07:48,206
加强期望实现

235
00:07:48,206 --> 00:07:50,356
的命令 这是通过利用

236
00:07:50,356 --> 00:07:52,706
等待 API 的可选旗标

237
00:07:53,506 --> 00:07:53,706
实现的

238
00:07:54,236 --> 00:07:56,596
以上 便是异步测试 

239
00:07:56,596 --> 00:07:59,176
XCTWaiter 和我们用于管理期望

240
00:07:59,636 --> 00:08:01,456
的新 API 的进展情况

241
00:07:59,636 --> 00:08:01,456
的新 API 的进展情况

242
00:08:01,456 --> 00:08:03,566
以及一系列

243
00:08:03,566 --> 00:08:04,856
XCTest 期望的

244
00:08:04,856 --> 00:08:05,546
改进情况

245
00:08:06,376 --> 00:08:08,036
这些类均与 XCTestCase

246
00:08:08,036 --> 00:08:10,486
完全解耦并提供了

247
00:08:10,486 --> 00:08:11,996
一个更便捷和

248
00:08:12,086 --> 00:08:13,766
更强大的系统供大家使用

249
00:08:14,326 --> 00:08:17,596
下面 我想介绍一下 UI

250
00:08:17,596 --> 00:08:19,876
测试 尤其是

251
00:08:19,876 --> 00:08:21,006
使用多应用程序的

252
00:08:21,006 --> 00:08:21,876
UI 测试

253
00:08:23,216 --> 00:08:25,056
几乎所有 UI 测试

254
00:08:25,136 --> 00:08:26,916
的起始点都是

255
00:08:27,016 --> 00:08:28,976
XCUIApplication 实例

256
00:08:29,476 --> 00:08:32,035
这一类别可以让你启动并

257
00:08:32,155 --> 00:08:33,066
中断正在测试的 App

258
00:08:33,066 --> 00:08:34,736
同时创建

259
00:08:34,736 --> 00:08:36,726
查询命令以找到用户

260
00:08:36,726 --> 00:08:38,306
接口元素 而后再通过

261
00:08:38,306 --> 00:08:39,645
发送综合事件

262
00:08:39,645 --> 00:08:40,616
使其自动化

263
00:08:42,176 --> 00:08:43,986
UI 测试有一个目标

264
00:08:43,986 --> 00:08:46,066
应用程序概念 也就是指

265
00:08:46,066 --> 00:08:47,376
主要测试的那个

266
00:08:47,376 --> 00:08:48,526
应用程序

267
00:08:48,526 --> 00:08:50,356
在测试的工程设置中 

268
00:08:50,356 --> 00:08:52,356
你可以指定相同工程中的

269
00:08:52,406 --> 00:08:54,426
一个应用程序作为

270
00:08:54,466 --> 00:08:55,666
目标应用程序

271
00:08:56,506 --> 00:08:57,786
这就让你可以调用

272
00:08:57,786 --> 00:08:59,336
XCUIApplication 的

273
00:08:59,336 --> 00:09:01,776
默认初始化程序并创建

274
00:08:59,336 --> 00:09:01,776
默认初始化程序并创建

275
00:09:01,776 --> 00:09:02,616
带有安装

276
00:09:02,616 --> 00:09:04,406
启动和与该应用程序

277
00:09:04,566 --> 00:09:06,336
交互等信息的

278
00:09:06,386 --> 00:09:07,376
实例

279
00:09:08,866 --> 00:09:09,916
这一机制十分

280
00:09:09,916 --> 00:09:11,196
便捷 但却不能用于

281
00:09:11,196 --> 00:09:12,366
测试其他的

282
00:09:12,366 --> 00:09:13,206
应用程序

283
00:09:13,966 --> 00:09:15,306
其他被我们称作

284
00:09:15,306 --> 00:09:17,476
多应用程序情景的例子包括

285
00:09:17,476 --> 00:09:19,466
App 群组 即一个工程中

286
00:09:19,466 --> 00:09:20,516
存在不止一个应用程序

287
00:09:20,516 --> 00:09:21,906
并且它们

288
00:09:21,906 --> 00:09:23,406
进行交互并

289
00:09:23,406 --> 00:09:24,226
传递数据

290
00:09:25,196 --> 00:09:26,366
另一个例子则是

291
00:09:26,366 --> 00:09:28,166
设置 如果你需要将应用程序

292
00:09:28,246 --> 00:09:30,116
的设置自动化并

293
00:09:30,116 --> 00:09:31,636
改变不同测试情景的

294
00:09:31,636 --> 00:09:32,516
偏好

295
00:09:33,246 --> 00:09:34,856
还有另一个例子 即应用程序

296
00:09:34,856 --> 00:09:35,696
扩展

297
00:09:36,646 --> 00:09:39,036
全部应用程序的扩展所需要的不止是

298
00:09:39,036 --> 00:09:40,716
单一的目标应用程序

299
00:09:42,016 --> 00:09:43,766
为了解决这一问题 我们在

300
00:09:43,766 --> 00:09:46,166
XCUIApplication 中添加了新的 API

301
00:09:47,076 --> 00:09:48,836
首先 我们有初始化程序

302
00:09:49,206 --> 00:09:50,686
让你可以通过 Bundle ID

303
00:09:50,866 --> 00:09:52,766
来指定 App 或

304
00:09:52,766 --> 00:09:54,916
也可以在 macOS 中

305
00:09:54,916 --> 00:09:58,056
利用文件 URL 来指定

306
00:09:58,056 --> 00:09:59,766
磁盘中 App 的位置

307
00:10:00,626 --> 00:10:02,686
其次 我们添加了一个 active() 方法

308
00:10:02,686 --> 00:10:04,156
将应用程序

309
00:10:04,186 --> 00:10:05,256
从后台拉到前台

310
00:10:05,256 --> 00:10:06,696
前提是应用程序已经

311
00:10:06,696 --> 00:10:08,296
在运行 如果没有运行 则将启动

312
00:10:08,296 --> 00:10:09,526
新的实例

313
00:10:10,336 --> 00:10:12,226
但启动 API 将首先中断

314
00:10:12,226 --> 00:10:14,556
任何之前的运行实例 

315
00:10:14,556 --> 00:10:16,306
因此你在开始

316
00:10:16,386 --> 00:10:17,586
测试时总是需要

317
00:10:17,586 --> 00:10:18,166
从头开始

318
00:10:18,616 --> 00:10:20,026
active() 方法很有用 尤其是

319
00:10:20,026 --> 00:10:21,576
在那些你

320
00:10:21,576 --> 00:10:22,786
没兴趣清除

321
00:10:22,786 --> 00:10:24,276
此前的状态 但实际上

322
00:10:24,276 --> 00:10:26,056
又想在测试的更早期

323
00:10:26,056 --> 00:10:26,986
重新开始的情景中

324
00:10:28,086 --> 00:10:29,706
最后 还有一个新的状态

325
00:10:29,706 --> 00:10:30,996
属性可以用来

326
00:10:30,996 --> 00:10:32,416
监控正在测试的

327
00:10:32,416 --> 00:10:33,666
应用程序中的变化

328
00:10:34,586 --> 00:10:36,686
那么下面就举几个使用这些 API 的

329
00:10:36,686 --> 00:10:37,466
例子

330
00:10:38,166 --> 00:10:39,416
这一代码使用 Bundle ID

331
00:10:39,416 --> 00:10:41,736
创建了两个

332
00:10:41,776 --> 00:10:42,546
XCUIApplication 实例

333
00:10:42,896 --> 00:10:44,916
这可能是一个 App 群组里的

334
00:10:44,916 --> 00:10:45,796
一对应用程序

335
00:10:46,576 --> 00:10:48,856
在启动和交互

336
00:10:49,016 --> 00:10:51,126
readerApp 后 测试接下来

337
00:10:51,126 --> 00:10:53,186
启动了 writerApp 

338
00:10:53,186 --> 00:10:54,116
最后 在进行了更多的

339
00:10:54,116 --> 00:10:55,886
交互后 应用程序使用 Activate

340
00:10:55,886 --> 00:10:58,286
API 将 readerApp 拉回

341
00:10:58,286 --> 00:11:00,596
前台而没有

342
00:10:58,286 --> 00:11:00,596
前台而没有

343
00:11:00,596 --> 00:11:01,596
在一开始就将之中断

344
00:11:02,176 --> 00:11:04,636
下面我们来看一看实际操作 

345
00:11:04,866 --> 00:11:06,736
有请 Warren Ma 为我们进行

346
00:11:06,736 --> 00:11:07,976
多应用程序 UI 测试的 Demo

347
00:11:08,516 --> 00:11:15,556
[掌声]

348
00:11:16,056 --> 00:11:16,756
谢谢你 Wil

349
00:11:16,996 --> 00:11:19,016
正如威尔刚才描述的那样 

350
00:11:19,016 --> 00:11:21,126
现在在 Xcode 9 中 你可以编写

351
00:11:21,126 --> 00:11:21,946
涉及多个应用程序的

352
00:11:21,946 --> 00:11:23,536
UI 测试 我很高兴

353
00:11:23,536 --> 00:11:24,776
向大家展示如何

354
00:11:24,776 --> 00:11:26,206
将新的 API 纳入

355
00:11:26,206 --> 00:11:27,026
自己的测试集中

356
00:11:27,866 --> 00:11:32,676
那么 下面我想先给大家

357
00:11:32,676 --> 00:11:33,816
展示一下我这里的

358
00:11:33,816 --> 00:11:34,666
两个关联 App

359
00:11:35,436 --> 00:11:36,206
我现在是在一个开发设备上

360
00:11:36,206 --> 00:11:37,576
运行这些程序

361
00:11:37,576 --> 00:11:38,886
我在使用 QuickTime 来向大家展示

362
00:11:38,886 --> 00:11:39,306
屏幕上的内容

363
00:11:40,136 --> 00:11:41,816
第一个是一个信息

364
00:11:41,816 --> 00:11:43,636
发送 App  叫做 writerApp

365
00:11:44,946 --> 00:11:47,086
这里我们有一个用户名 我们还有

366
00:11:47,086 --> 00:11:48,556
一个可以输入的文本视图 

367
00:11:48,556 --> 00:11:51,826
我们可以输入一条测试

368
00:11:51,826 --> 00:11:54,996
信息 点击键盘上的

369
00:11:54,996 --> 00:11:56,846
Return 键 并通过“Send（发送）”按钮

370
00:11:56,846 --> 00:11:58,196
将信息发布在

371
00:11:58,196 --> 00:11:58,546
服务器上

372
00:11:59,736 --> 00:12:00,776
很好 现在信息已经发布了

373
00:11:59,736 --> 00:12:00,776
很好 现在信息已经发布了

374
00:12:01,436 --> 00:12:02,176
那么现在我们要怎样来浏览这些

375
00:12:02,176 --> 00:12:02,646
信息呢

376
00:12:03,466 --> 00:12:04,996
这就是我们第二个 App

377
00:12:04,996 --> 00:12:06,336
readerApp 的任务了

378
00:12:08,316 --> 00:12:10,086
这里列出了所有

379
00:12:10,086 --> 00:12:10,986
发布在服务器上的

380
00:12:10,986 --> 00:12:12,876
信息 而最上面的一条

381
00:12:12,876 --> 00:12:14,736
是最新发布的信息 

382
00:12:14,736 --> 00:12:16,426
也就是我刚刚发布的信息 我们可以

383
00:12:16,426 --> 00:12:17,926
点击信息进行详细地

384
00:12:17,926 --> 00:12:18,356
浏览

385
00:12:18,356 --> 00:12:20,406
然后我们可以返回

386
00:12:20,406 --> 00:12:21,626
信息列表 通过

387
00:12:21,706 --> 00:12:23,426
左上角的“All Messages（所有信息）”

388
00:12:23,426 --> 00:12:23,836
按钮来返回

389
00:12:24,776 --> 00:12:26,736
我们假设你想测试一下

390
00:12:26,736 --> 00:12:28,536
这个过程 即在

391
00:12:28,536 --> 00:12:29,746
writerApp 中输入文本信息

392
00:12:30,146 --> 00:12:31,776
发布在服务器上 然后再

393
00:12:31,776 --> 00:12:33,096
从第二个应用程序中去

394
00:12:33,096 --> 00:12:34,546
验证信息是否出现在信息列表的

395
00:12:34,546 --> 00:12:35,516
第一条

396
00:12:36,076 --> 00:12:37,796
在 Xcode 9 之前 你不得不

397
00:12:37,796 --> 00:12:39,206
为每个应用程序编写

398
00:12:39,306 --> 00:12:41,026
不同的 UI 测试 

399
00:12:41,026 --> 00:12:42,446
那时甚至没有真正的方法

400
00:12:42,446 --> 00:12:43,996
来验证这两者之间的

401
00:12:43,996 --> 00:12:44,756
行为

402
00:12:45,406 --> 00:12:47,186
但现在 有了 Xcode 9 的多 App 测试

403
00:12:47,416 --> 00:12:49,556
Xcode 9 的多 UI 测试

404
00:12:49,556 --> 00:12:51,526
我们可以轻松测试

405
00:12:51,526 --> 00:12:53,096
多个应用程序间的

406
00:12:53,096 --> 00:12:54,086
现实世界情景

407
00:12:54,496 --> 00:12:56,356
为了给大家展示 我们来

408
00:12:56,356 --> 00:12:58,256
快速编写一个 UI 测试

409
00:12:58,456 --> 00:12:59,626
将我刚刚演示的这个工作流

410
00:12:59,626 --> 00:13:00,176
自动化

411
00:12:59,626 --> 00:13:00,176
自动化

412
00:13:01,266 --> 00:13:05,046
好了 那我们测试的

413
00:13:05,046 --> 00:13:08,946
第一步就是启动我们的阅读

414
00:13:08,946 --> 00:13:09,536
应用程序

415
00:13:10,506 --> 00:13:12,366
为了启动这一程序 我们需要

416
00:13:12,366 --> 00:13:13,636
使用它的 Bundle ID

417
00:13:13,676 --> 00:13:14,496
进行初始化

418
00:13:15,516 --> 00:13:16,786
这一步之后 我们就可以继续并

419
00:13:16,786 --> 00:13:20,116
重新启动程序

420
00:13:20,306 --> 00:13:21,346
一旦我们启动了 readerApp 

421
00:13:21,346 --> 00:13:23,066
我们就可以继续

422
00:13:23,066 --> 00:13:24,236
在信息列表中

423
00:13:24,236 --> 00:13:25,226
验证第一条

424
00:13:25,226 --> 00:13:25,726
信息

425
00:13:26,456 --> 00:13:28,466
要做到这一点 我们得点击

426
00:13:28,796 --> 00:13:31,266
列表的第一条信息 我们

427
00:13:31,266 --> 00:13:32,656
可以验证里面的内容

428
00:13:32,656 --> 00:13:34,996
是否是我们想看的那条 最后 

429
00:13:34,996 --> 00:13:36,186
我们可以返回

430
00:13:36,186 --> 00:13:37,466
信息列表 利用左上角的

431
00:13:37,466 --> 00:13:38,126
按钮

432
00:13:39,596 --> 00:13:40,646
一旦我们验证了

433
00:13:40,646 --> 00:13:42,036
列表中的第一条信息 我们

434
00:13:42,036 --> 00:13:43,196
就可以输入文本信息并

435
00:13:43,196 --> 00:13:44,326
通过 writerApp 来将信息发布在

436
00:13:44,326 --> 00:13:44,766
服务器上

437
00:13:45,616 --> 00:13:48,566
要做到这一点 第一步

438
00:13:48,566 --> 00:13:50,616
还是使用 Bundle ID

439
00:13:50,616 --> 00:13:52,456
将 writerApp 初始化 

440
00:13:52,456 --> 00:13:54,066
在这个例子里 ID 是

441
00:13:54,066 --> 00:13:55,596
com.mycompany.Writer

442
00:13:56,506 --> 00:13:58,116
完成这些之后

443
00:13:58,116 --> 00:13:58,816
仅须调用 active() 方法就可以了

444
00:13:59,396 --> 00:14:01,186
现在 activate() 也要等待

445
00:13:59,396 --> 00:14:01,186
现在 activate() 也要等待

446
00:14:01,186 --> 00:14:02,496
应用程序状态在

447
00:14:02,496 --> 00:14:03,556
返回之前成为在前台

448
00:14:03,556 --> 00:14:05,136
运行 因此我们不需要

449
00:14:05,136 --> 00:14:07,276
对应用程序的状态进行任何

450
00:14:07,276 --> 00:14:08,186
手动等待

451
00:14:08,776 --> 00:14:10,236
一旦 active() 返回了 我们就

452
00:14:10,236 --> 00:14:11,446
知道测试进展良好

453
00:14:11,446 --> 00:14:11,856
可以继续了

454
00:14:12,296 --> 00:14:15,006
一旦 writerApp 在前台

455
00:14:15,006 --> 00:14:16,706
运行 我们就可以继续

456
00:14:16,706 --> 00:14:18,206
编写文本信息并

457
00:14:18,206 --> 00:14:19,016
发布在服务器上

458
00:14:19,746 --> 00:14:21,616
要做到这一点 我们要使用

459
00:14:21,616 --> 00:14:23,736
文本框输入我们的

460
00:14:23,736 --> 00:14:26,116
文本信息 然后点击

461
00:14:26,116 --> 00:14:27,536
键盘上的 Return 按钮 

462
00:14:28,356 --> 00:14:29,606
再点击“Send（发送）”

463
00:14:29,606 --> 00:14:30,936
将信息发布到服务器

464
00:14:32,826 --> 00:14:33,956
现在 我们得确保信息

465
00:14:33,956 --> 00:14:35,236
出现在了 readerApp

466
00:14:35,446 --> 00:14:36,416
信息列表

467
00:14:36,416 --> 00:14:36,836
的首条

468
00:14:38,006 --> 00:14:39,176
之前 我们使用了 active() 在

469
00:14:39,176 --> 00:14:40,046
两个应用程序间

470
00:14:40,046 --> 00:14:41,586
转换 而在这个例子中 

471
00:14:41,846 --> 00:14:43,086
让我们使用 iOS 系统

472
00:14:43,086 --> 00:14:44,466
创建的返回应用程序按钮

473
00:14:44,946 --> 00:14:45,946
这个按钮位于屏幕的

474
00:14:45,946 --> 00:14:46,636
左上角

475
00:14:47,246 --> 00:14:50,276
要做到这一点 我们需要

476
00:14:50,276 --> 00:14:52,726
点击返回应用程序按钮

477
00:14:52,966 --> 00:14:54,356
但在这个例子中 由于

478
00:14:54,356 --> 00:14:55,826
我们未使用 active()  因此我们

479
00:14:55,826 --> 00:14:58,036
需要手动等待

480
00:14:58,106 --> 00:14:59,716
应用程序状态在

481
00:14:59,716 --> 00:15:00,756
前台运行 之后

482
00:14:59,716 --> 00:15:00,756
前台运行 之后

483
00:15:00,756 --> 00:15:01,936
才能继续测试

484
00:15:02,726 --> 00:15:04,016
而要做到这一点 我们得利用

485
00:15:04,016 --> 00:15:05,146
基于新 Predicate 的

486
00:15:05,146 --> 00:15:06,146
期望 API

487
00:15:08,596 --> 00:15:10,866
所以 我们得确保

488
00:15:10,866 --> 00:15:13,716
readerApp 的状态在返回

489
00:15:13,716 --> 00:15:14,766
之前在前台

490
00:15:14,766 --> 00:15:15,286
运行

491
00:15:16,636 --> 00:15:18,066
我们在定义了我们的

492
00:15:18,066 --> 00:15:20,186
期望之后 可以继续下一步并

493
00:15:20,186 --> 00:15:21,416
等待这个期望

494
00:15:21,416 --> 00:15:23,246
在超时 10 秒后变为 True

495
00:15:23,246 --> 00:15:24,346
这个时间应该是

496
00:15:24,346 --> 00:15:24,986
绰绰有余的

497
00:15:25,456 --> 00:15:28,076
一旦 readerApp 开始在前台

498
00:15:28,076 --> 00:15:30,056
运行 我们就可以

499
00:15:30,056 --> 00:15:31,536
继续完成

500
00:15:31,536 --> 00:15:33,386
测试的最后一步 也就是

501
00:15:33,386 --> 00:15:34,666
验证信息是否出现

502
00:15:34,666 --> 00:15:36,226
在列表的顶部

503
00:15:36,686 --> 00:15:37,886
同我们刚刚所做的类似 

504
00:15:38,396 --> 00:15:39,236
我们可以点击列表的

505
00:15:39,236 --> 00:15:41,246
第一条信息 然后验证

506
00:15:41,246 --> 00:15:42,596
信息的内容是否是

507
00:15:42,596 --> 00:15:45,056
我们刚刚发布的内容 

508
00:15:45,146 --> 00:15:46,306
然后再返回到

509
00:15:46,306 --> 00:15:46,766
信息列表

510
00:15:47,786 --> 00:15:48,966
下面就让我们实际操作一下

511
00:15:48,966 --> 00:15:50,336
看看真实的测试

512
00:15:50,886 --> 00:15:52,426
首先 我要点击

513
00:15:52,426 --> 00:15:53,756
左栏的

514
00:15:53,756 --> 00:15:53,976
测试方块

515
00:15:59,046 --> 00:16:00,716
这样 当一般情况下你运行

516
00:15:59,046 --> 00:16:00,716
这样 当一般情况下你运行

517
00:16:00,716 --> 00:16:02,186
UI 测试时 就需要安装

518
00:16:02,186 --> 00:16:03,366
所谓的 UI 测试运行器并且

519
00:16:03,716 --> 00:16:04,986
那是除了安装应用

520
00:16:04,986 --> 00:16:07,046
程序外 UI 测试运行的

521
00:16:07,046 --> 00:16:07,646
测试流程

522
00:16:07,866 --> 00:16:09,386
所以 只需要一点点时间

523
00:16:09,386 --> 00:16:10,166
就可以启动了

524
00:16:10,636 --> 00:16:13,256
一旦启动后 测试

525
00:16:13,256 --> 00:16:14,466
便可继续运行

526
00:16:16,836 --> 00:16:18,306
因此同之前一样 测试的

527
00:16:18,306 --> 00:16:19,656
第一步是启动

528
00:16:19,656 --> 00:16:21,806
readerApp 并验证

529
00:16:21,806 --> 00:16:23,466
信息列表中的第一条信息

530
00:16:25,296 --> 00:16:27,516
接下来 我们使用 active() 方法来打开

531
00:16:27,516 --> 00:16:29,196
writerApp 输入我们的测试

532
00:16:29,196 --> 00:16:30,936
信息并发布在

533
00:16:30,936 --> 00:16:31,346
服务器上

534
00:16:32,156 --> 00:16:33,106
然后我们使用返回 App

535
00:16:33,106 --> 00:16:34,206
按钮来转回到

536
00:16:34,206 --> 00:16:35,296
readerApp 并验证

537
00:16:35,296 --> 00:16:36,426
信息是否出现在了列表的

538
00:16:36,426 --> 00:16:36,846
顶部

539
00:16:37,456 --> 00:16:39,336
所以说 利用

540
00:16:39,336 --> 00:16:40,706
这款适用于 Xcode 9 的

541
00:16:40,946 --> 00:16:43,006
超棒多 UI 测试 API

542
00:16:43,006 --> 00:16:44,736
来测试多个应用程序是

543
00:16:44,736 --> 00:16:45,356
多么容易啊

544
00:16:45,626 --> 00:16:46,496
那么下面我就把舞台

545
00:16:46,496 --> 00:16:46,936
交回给 Wil

546
00:16:47,516 --> 00:16:51,546
[掌声]

547
00:16:52,046 --> 00:16:53,546
谢谢你 Warren 真是非常

548
00:16:53,546 --> 00:16:54,136
精彩的介绍

549
00:16:54,746 --> 00:16:56,696
仅仅是通过添加一些新功能 

550
00:16:56,696 --> 00:16:57,796
UI 测试这一领域

551
00:16:57,796 --> 00:16:59,186
的可能性便得到了

552
00:16:59,316 --> 00:16:59,806
极大的拓宽

553
00:17:00,606 --> 00:17:01,856
这个新的初始化程序可以

554
00:17:01,856 --> 00:17:03,626
测试任何应用程序 而且

555
00:17:03,626 --> 00:17:04,955
Activate API 意味着你可以在

556
00:17:04,955 --> 00:17:06,086
多应用程序间

557
00:17:06,086 --> 00:17:08,236
切换而无需重启这些程序 

558
00:17:08,236 --> 00:17:10,596
实现多应用程序 UI 测试

559
00:17:11,616 --> 00:17:14,126
下面 让我们转换一下思路

560
00:17:14,126 --> 00:17:16,226
来谈谈 UI 测试的性能

561
00:17:17,656 --> 00:17:20,096
UI 测试的核心是

562
00:17:20,096 --> 00:17:21,756
你的测试希望

563
00:17:21,756 --> 00:17:23,195
交互的用户接口

564
00:17:24,036 --> 00:17:24,296
元素

565
00:17:24,296 --> 00:17:26,236
这些元素包括按钮 标签

566
00:17:26,236 --> 00:17:27,346
表格视图等等

567
00:17:27,935 --> 00:17:30,026
UI 测试通过创建查询来

568
00:17:30,026 --> 00:17:32,206
描述各元素是如何被发现的

569
00:17:32,816 --> 00:17:35,466
例如 这个按钮元素

570
00:17:35,466 --> 00:17:37,126
有一个

571
00:17:38,076 --> 00:17:40,696
app.navigationBars.buttons 查询

572
00:17:40,696 --> 00:17:41,896
注释为“Done”

573
00:17:42,646 --> 00:17:43,886
这就意味着该元素具有

574
00:17:43,936 --> 00:17:46,506
一个按钮的属性 标签

575
00:17:46,506 --> 00:17:48,556
或 Done 的标题并且

576
00:17:48,556 --> 00:17:50,406
能在导航栏中找到

577
00:17:51,206 --> 00:17:53,116
那么这些查询是怎么工作的呢

578
00:17:54,486 --> 00:17:56,476
查询利用辅助功能数据 

579
00:17:56,946 --> 00:17:58,996
这与 VoiceOver 技术

580
00:17:59,116 --> 00:18:00,876
是一个意思 

581
00:17:59,116 --> 00:18:00,876
是一个意思 

582
00:18:01,376 --> 00:18:02,446
将之作为应用程序的

583
00:18:02,446 --> 00:18:03,916
可被搜索的架构

584
00:18:05,136 --> 00:18:07,126
为了评估一个查询 测试

585
00:18:07,166 --> 00:18:09,616
进程请求对现有数据

586
00:18:09,616 --> 00:18:11,556
进行所谓的快照

587
00:18:12,186 --> 00:18:14,086
这一请求是从测试进程

588
00:18:14,086 --> 00:18:15,816
发送至应用程序的 

589
00:18:15,816 --> 00:18:17,466
所以这些是单独的进程 

590
00:18:17,466 --> 00:18:18,706
在这里我们使用了

591
00:18:18,706 --> 00:18:19,536
进程间通讯

592
00:18:20,676 --> 00:18:21,806
这一请求是从测试进程

593
00:18:21,806 --> 00:18:23,356
发送至应用程序 

594
00:18:23,356 --> 00:18:25,036
现在 应用程序捕捉了

595
00:18:25,036 --> 00:18:28,176
快照数据 进行了排序并

596
00:18:28,176 --> 00:18:30,326
将之传回到测试

597
00:18:30,376 --> 00:18:30,986
进程

598
00:18:31,596 --> 00:18:32,856
一旦测试进程

599
00:18:32,856 --> 00:18:34,606
解包了数据 便能

600
00:18:34,606 --> 00:18:36,546
通过在快照中搜寻

601
00:18:36,546 --> 00:18:37,576
来评估查询

602
00:18:38,356 --> 00:18:40,386
快照是有用的 正是因为

603
00:18:40,606 --> 00:18:42,526
它的运行方式 快照可以

604
00:18:42,526 --> 00:18:45,026
在一瞬间捕捉

605
00:18:45,026 --> 00:18:46,956
UI 状态的原子表征 

606
00:18:46,956 --> 00:18:48,906
但这也带来了一些

607
00:18:48,906 --> 00:18:50,306
性能方面的挑战

608
00:18:50,866 --> 00:18:52,616
如果我们考虑性能的

609
00:18:52,616 --> 00:18:54,656
两个坐标轴 一个是时间 

610
00:18:54,656 --> 00:18:55,806
另一个是内存 

611
00:18:56,556 --> 00:18:58,496
快照在这两方面都

612
00:18:58,496 --> 00:18:59,896
存在潜在问题

613
00:19:00,836 --> 00:19:02,546
对于有数个 UI 元素

614
00:19:02,546 --> 00:19:04,626
的应用程序来说 快照花费的时间过长

615
00:19:04,626 --> 00:19:06,086
例如 对于有着数千行和

616
00:19:06,086 --> 00:19:07,866
大型集合视图的

617
00:19:07,866 --> 00:19:09,436
表格而言 这会

618
00:19:09,436 --> 00:19:11,436
导致超时并会

619
00:19:11,436 --> 00:19:12,586
引发测试失败

620
00:19:13,396 --> 00:19:15,426
如果快照数据太大

621
00:19:15,426 --> 00:19:16,986
那么这对系统的内存压力

622
00:19:16,986 --> 00:19:19,386
可能会导致

623
00:19:19,386 --> 00:19:20,836
进程遭到中断

624
00:19:21,656 --> 00:19:23,056
这些挑战让我们想到了下面这个

625
00:19:23,056 --> 00:19:25,076
问题 即我们如何才能

626
00:19:25,076 --> 00:19:26,976
改善快照的性能

627
00:19:27,466 --> 00:19:28,896
我们总结出来了好几种

628
00:19:28,896 --> 00:19:29,426
方式

629
00:19:30,636 --> 00:19:32,416
首先 我们想要

630
00:19:32,416 --> 00:19:33,536
降低传输各进程

631
00:19:33,606 --> 00:19:35,116
间所有数据

632
00:19:35,116 --> 00:19:36,336
的开销

633
00:19:37,006 --> 00:19:38,406
要做到这一点 我们执行了

634
00:19:38,406 --> 00:19:40,156
所谓的远程查询

635
00:19:40,836 --> 00:19:42,656
有了远程查询 

636
00:19:42,656 --> 00:19:44,596
测试进程便不用请求

637
00:19:44,596 --> 00:19:47,076
快照 实际上只用传送

638
00:19:47,106 --> 00:19:48,286
查询本身 而这

639
00:19:48,286 --> 00:19:49,586
只涉及非常少量的数据

640
00:19:50,466 --> 00:19:51,616
应用程序仍会创建

641
00:19:51,616 --> 00:19:53,306
快照 但将

642
00:19:53,306 --> 00:19:55,226
不再把它传送到任意地方 

643
00:19:55,256 --> 00:19:56,996
而只是评估进程中的

644
00:19:56,996 --> 00:19:58,076
查询

645
00:19:58,576 --> 00:20:00,146
在最后 应用程序仅

646
00:19:58,576 --> 00:20:00,146
在最后 应用程序仅

647
00:20:00,146 --> 00:20:02,376
向测试进程传回结果 

648
00:20:02,376 --> 00:20:04,966
同样只涉及少量的数据

649
00:20:06,106 --> 00:20:09,516
那么这一切的性能怎么样呢

650
00:20:09,516 --> 00:20:11,876
经发现 远程查询的性能

651
00:20:11,876 --> 00:20:13,736
可以将速度提高

652
00:20:13,736 --> 00:20:16,116
20% 并将内存泄漏

653
00:20:16,116 --> 00:20:18,426
减少 30%

654
00:20:18,936 --> 00:20:20,416
这当然是一个良好的开端 但

655
00:20:20,526 --> 00:20:22,146
还远未达到我们脑海中

656
00:20:22,146 --> 00:20:23,106
想要实现的目标

657
00:20:23,106 --> 00:20:25,286
那么这时候 就该我们的第二个

658
00:20:25,626 --> 00:20:27,116
优化项出场了 即

659
00:20:27,116 --> 00:20:27,846
查询分析

660
00:20:28,286 --> 00:20:30,306
我们的目标是减少

661
00:20:30,306 --> 00:20:32,226
快照自身的大小 

662
00:20:32,226 --> 00:20:34,256
收集更少的数据

663
00:20:35,256 --> 00:20:37,406
快照使用了一套固定的

664
00:20:37,406 --> 00:20:39,366
辅助功能属性 但我们认为通过

665
00:20:39,366 --> 00:20:41,046
分析你的查询 

666
00:20:41,046 --> 00:20:43,746
我们可以识别出

667
00:20:43,746 --> 00:20:45,446
一套数量最少的属性 

668
00:20:45,736 --> 00:20:47,286
几乎只占到了许多普通

669
00:20:47,286 --> 00:20:49,446
查询的一半 这极大

670
00:20:49,446 --> 00:20:50,796
减少了收集的

671
00:20:50,796 --> 00:20:51,366
数据量

672
00:20:52,126 --> 00:20:53,746
对于一些具体的元素 

673
00:20:53,746 --> 00:20:56,106
在后续的断言中可能会

674
00:20:56,146 --> 00:20:57,806
需要的其他属性仍可以

675
00:20:57,806 --> 00:21:00,266
按需获取 但

676
00:20:57,806 --> 00:21:00,266
按需获取 但

677
00:21:00,266 --> 00:21:02,686
快照自身将更加

678
00:21:02,686 --> 00:21:03,386
轻便

679
00:21:04,686 --> 00:21:06,066
所以结果发现 查询分析

680
00:21:06,066 --> 00:21:07,616
是性能更加卓越的

681
00:21:07,676 --> 00:21:10,846
优化项 在普通情况下  

682
00:21:11,126 --> 00:21:12,836
速度可提升 50% 并且

683
00:21:12,836 --> 00:21:15,896
内存阈值可降低

684
00:21:15,986 --> 00:21:16,346
约 35%

685
00:21:17,136 --> 00:21:18,996
所以情况看起来相当

686
00:21:18,996 --> 00:21:21,016
不错 但我们想后退一步 

687
00:21:21,016 --> 00:21:22,936
看一看如果

688
00:21:22,936 --> 00:21:24,876
跳出固化的思维 我们是否能够

689
00:21:25,016 --> 00:21:26,726
重新构建一个系统 并

690
00:21:26,726 --> 00:21:28,226
带来事物的变革

691
00:21:28,536 --> 00:21:30,866
这就让我们有了

692
00:21:30,866 --> 00:21:33,336
将快照完全清除的这个想法

693
00:21:33,776 --> 00:21:35,196
那么我们该怎么来做呢

694
00:21:35,246 --> 00:21:37,366
快照给我们提供了

695
00:21:37,706 --> 00:21:39,916
UI 状态的

696
00:21:39,916 --> 00:21:40,646
原子表征

697
00:21:41,216 --> 00:21:42,956
经发现 这得益于

698
00:21:42,956 --> 00:21:45,036
远程查询基础结构 我们

699
00:21:45,036 --> 00:21:46,966
现在具备这一功能仅仅是因为我们

700
00:21:46,966 --> 00:21:48,796
已经在应用程序的

701
00:21:48,796 --> 00:21:49,786
进程中运行

702
00:21:49,786 --> 00:21:50,456
查询

703
00:21:51,146 --> 00:21:53,636
所以 传统查询

704
00:21:53,636 --> 00:21:55,686
通过仔细检查快照

705
00:21:55,686 --> 00:21:58,556
数据来运转 我们

706
00:21:58,716 --> 00:22:01,006
推出了一个叫做 First Match

707
00:21:58,716 --> 00:22:01,006
推出了一个叫做 First Match

708
00:22:01,006 --> 00:22:03,526
的 API 这个 API 会在你找到了

709
00:22:03,526 --> 00:22:05,536
第一个匹配项之后立刻

710
00:22:05,536 --> 00:22:07,526
停止查询 因为

711
00:22:07,526 --> 00:22:09,186
很多时候 检索所有的

712
00:22:09,276 --> 00:22:10,886
数据以便找到

713
00:22:10,886 --> 00:22:12,876
所有可能的匹配项费时过多 

714
00:22:12,876 --> 00:22:14,656
你可以以一个能够

715
00:22:14,756 --> 00:22:17,236
使不同元素独特的精准度来

716
00:22:17,236 --> 00:22:17,686
加以区分

717
00:22:18,656 --> 00:22:21,796
所以 First Match 导致查询

718
00:22:21,796 --> 00:22:23,836
提早返回 并且你可以把它添加到

719
00:22:23,836 --> 00:22:25,196
已有的任意

720
00:22:26,516 --> 00:22:26,606
查询中

721
00:22:27,186 --> 00:22:28,336
下面举个例子来看看 First Match

722
00:22:28,336 --> 00:22:29,786
是怎么添加进我们刚刚

723
00:22:29,786 --> 00:22:30,646
看过的这个查询中

724
00:22:31,456 --> 00:22:33,586
如果设想一下我们

725
00:22:33,636 --> 00:22:35,536
正在测试的应用程序是一个带有

726
00:22:35,536 --> 00:22:37,566
导航栏 表格视图

727
00:22:37,936 --> 00:22:39,606
和数千行表格

728
00:22:39,606 --> 00:22:41,846
的程序 传统的

729
00:22:41,846 --> 00:22:43,496
评估会依依检查

730
00:22:43,556 --> 00:22:45,166
表格中的每一行 

731
00:22:45,166 --> 00:22:46,046
尽管我们要找的

732
00:22:46,046 --> 00:22:47,696
是导航栏的一个按钮

733
00:22:48,166 --> 00:22:50,316
但 First Match 则让我们可以

734
00:22:50,316 --> 00:22:51,846
在找到那个按钮后立刻

735
00:22:51,846 --> 00:22:53,566
停止 并且我们不需要检查

736
00:22:53,566 --> 00:22:56,576
表格中的每一行

737
00:22:56,746 --> 00:22:59,156
那么 First Match 的性能如何呢

738
00:22:59,916 --> 00:23:01,056
可以说 First Match

739
00:22:59,916 --> 00:23:01,056
可以说 First Match

740
00:23:01,056 --> 00:23:02,316
改变了游戏规则

741
00:23:02,796 --> 00:23:04,306
对于很多查询 几乎达到了

742
00:23:04,306 --> 00:23:06,306
一个数量级的提速

743
00:23:06,776 --> 00:23:08,686
并且还完全清除了内存

744
00:23:08,826 --> 00:23:09,606
泄漏

745
00:23:10,516 --> 00:23:16,546
[掌声]

746
00:23:17,046 --> 00:23:18,696
如今 First Match 的

747
00:23:18,696 --> 00:23:20,396
性能提升非常显著 

748
00:23:20,396 --> 00:23:22,226
但重要的是要注意到

749
00:23:22,226 --> 00:23:23,466
传统查询之间的

750
00:23:23,466 --> 00:23:25,516
差异 且不要

751
00:23:25,516 --> 00:23:27,766
不加考虑便

752
00:23:27,766 --> 00:23:29,206
将 First Match 胡乱运用于

753
00:23:29,206 --> 00:23:30,166
整个代码中

754
00:23:30,906 --> 00:23:32,486
传统的查询评估

755
00:23:32,486 --> 00:23:34,586
会找出所有的匹配项 这能够

756
00:23:34,636 --> 00:23:37,106
帮助检测模糊查询 因为

757
00:23:37,106 --> 00:23:38,526
如果你尝试与存在

758
00:23:38,526 --> 00:23:39,716
多个匹配项的元素进行交互 

759
00:23:39,716 --> 00:23:41,376
那么就会造成

760
00:23:41,376 --> 00:23:41,946
失败

761
00:23:42,836 --> 00:23:44,286
First Match 消除了

762
00:23:44,316 --> 00:23:45,756
这一层保护 你的测试只会获得

763
00:23:45,756 --> 00:23:46,586
第一个匹配项

764
00:23:47,146 --> 00:23:48,416
如果应用程序的 UI

765
00:23:48,416 --> 00:23:50,916
发生了变化 那么那个查询

766
00:23:50,916 --> 00:23:53,576
实际上便不够

767
00:23:53,726 --> 00:23:55,646
精确 结果则是

768
00:23:55,646 --> 00:23:58,506
非唯一结果

769
00:23:58,676 --> 00:23:59,866
First Match 便不会提供保护

770
00:23:59,866 --> 00:24:01,546
并且结果会让人意外

771
00:23:59,866 --> 00:24:01,546
并且结果会让人意外

772
00:24:02,096 --> 00:24:03,936
下面让我们来看看一些

773
00:24:04,046 --> 00:24:05,526
示例查询并思考

774
00:24:05,526 --> 00:24:07,086
它们是否适合进行

775
00:24:07,086 --> 00:24:07,946
First Match

776
00:24:08,726 --> 00:24:13,486
app.buttons.firstMatch 不是一个

777
00:24:13,486 --> 00:24:15,626
好的选择 这就像

778
00:24:15,626 --> 00:24:16,846
走进一家杂货店 但只和老板说

779
00:24:16,846 --> 00:24:18,296
“我想要买点吃的”

780
00:24:18,976 --> 00:24:20,726
你可能买到冷冻的鸡肉

781
00:24:20,726 --> 00:24:21,816
或是一块泡泡糖

782
00:24:21,816 --> 00:24:23,316
又或是香蕉 这都说不准

783
00:24:23,816 --> 00:24:26,136
所以 这一类的查询

784
00:24:26,136 --> 00:24:27,886
对于 First Match 来说

785
00:24:27,886 --> 00:24:28,306
还不够精准

786
00:24:29,306 --> 00:24:30,756
现在则稍好了一点 

787
00:24:30,756 --> 00:24:32,536
因为我们在里面

788
00:24:32,536 --> 00:24:34,236
添加了一个标识

789
00:24:34,236 --> 00:24:34,536
字符串

790
00:24:34,536 --> 00:24:36,456
有这么多的应用程序 可能

791
00:24:36,456 --> 00:24:37,536
对目前来说是足够的

792
00:24:38,026 --> 00:24:40,936
但如果再向进一步并且

793
00:24:41,146 --> 00:24:43,156
为查询增加更多的精准度和

794
00:24:43,156 --> 00:24:44,526
更多的细节

795
00:24:44,756 --> 00:24:46,156
就使其能够更适合进行

796
00:24:46,156 --> 00:24:48,116
First Match 并更有可能

797
00:24:48,116 --> 00:24:50,146
在任何地方都保持稳定 

798
00:24:50,146 --> 00:24:51,576
同时仍然具备 First Match

799
00:24:51,576 --> 00:24:53,176
带有的性能

800
00:24:53,176 --> 00:24:53,866
提升

801
00:24:55,966 --> 00:24:58,266
因此在谈论所有这些

802
00:24:58,266 --> 00:25:00,336
优化项时 我们需要给大家

803
00:24:58,266 --> 00:25:00,336
优化项时 我们需要给大家

804
00:25:00,336 --> 00:25:01,666
稍微介绍一下

805
00:25:01,906 --> 00:25:03,876
基于块的 NSPredicates 以及

806
00:25:03,876 --> 00:25:05,116
如何在查询中进行使用

807
00:25:07,136 --> 00:25:09,306
不幸的是 它们同这些

808
00:25:09,306 --> 00:25:11,956
优化项并不兼容 它们

809
00:25:11,956 --> 00:25:13,476
有效禁止了这些优化项

810
00:25:13,526 --> 00:25:15,136
这是因为 首先 

811
00:25:15,136 --> 00:25:16,866
块无法被序列化 

812
00:25:17,096 --> 00:25:18,356
也无法在进程间传递 

813
00:25:18,356 --> 00:25:21,136
这就意味着不存在

814
00:25:21,136 --> 00:25:23,256
远程查询和 First Match

815
00:25:23,966 --> 00:25:25,196
另一个问题是我们

816
00:25:25,196 --> 00:25:26,856
无法内省 我们无法在运行时

817
00:25:26,856 --> 00:25:29,386
查看块并知道

818
00:25:29,516 --> 00:25:30,896
查询实际需要的是

819
00:25:30,896 --> 00:25:31,896
哪些属性

820
00:25:32,326 --> 00:25:33,576
这就意味着当你正在使用

821
00:25:33,576 --> 00:25:34,856
基于块的 NSPredicates 时 

822
00:25:34,856 --> 00:25:36,396
快照性能的

823
00:25:36,396 --> 00:25:38,116
提升也同样

824
00:25:38,116 --> 00:25:39,656
与此无关

825
00:25:40,346 --> 00:25:42,256
幸运的是

826
00:25:42,256 --> 00:25:44,096
测试查询中使用基于

827
00:25:44,096 --> 00:25:45,796
块的 NSPredicates 相对

828
00:25:45,796 --> 00:25:48,066
少见 并且几乎始终可以

829
00:25:48,066 --> 00:25:50,366
与格式字符串或

830
00:25:50,366 --> 00:25:52,106
基于 NSExpression 的

831
00:25:52,106 --> 00:25:52,616
Predicate 互换

832
00:25:53,496 --> 00:25:55,366
现在 如果你发现自己遇到

833
00:25:55,366 --> 00:25:57,566
某个情况 即的确需要基于块的 

834
00:25:57,566 --> 00:25:58,946
Predicate 我的意思是

835
00:25:58,946 --> 00:25:59,936
它们仍然得到支持 它们

836
00:25:59,936 --> 00:26:02,216
仍在运转或甚至

837
00:25:59,936 --> 00:26:02,216
仍在运转或甚至

838
00:26:02,216 --> 00:26:03,796
使用其中之一会

839
00:26:03,796 --> 00:26:05,226
更加便捷

840
00:26:05,386 --> 00:26:06,916
我们想要去了解它 我们

841
00:26:06,916 --> 00:26:08,496
希望你可以提交 Bug 这样

842
00:26:08,496 --> 00:26:11,196
我们就可以给你提供一个

843
00:26:11,246 --> 00:26:13,466
处理相同任务的 API 但其处理方式

844
00:26:13,466 --> 00:26:15,086
能够与查询优化项

845
00:26:15,086 --> 00:26:15,826
兼容

846
00:26:15,826 --> 00:26:17,216
所以 如果你觉得

847
00:26:17,706 --> 00:26:19,596
手头有某些情况需要基于块的

848
00:26:19,596 --> 00:26:20,826
Predicate 我们很想听听你的

849
00:26:20,826 --> 00:26:21,196
看法

850
00:26:21,706 --> 00:26:24,926
以上就是我们对

851
00:26:24,926 --> 00:26:26,086
UI 测试性能提升的

852
00:26:26,086 --> 00:26:26,756
探讨

853
00:26:27,336 --> 00:26:29,236
Xcode 9 中的查询整体来说

854
00:26:29,236 --> 00:26:30,766
应该更快

855
00:26:31,266 --> 00:26:32,546
其中一些提升项 例如

856
00:26:32,546 --> 00:26:35,126
远程查询和 First Match

857
00:26:35,126 --> 00:26:36,996
同样需要最新版的操作系统 比如

858
00:26:36,996 --> 00:26:39,326
最新的 macOS iOS 以及 Apple TVOS

859
00:26:40,006 --> 00:26:42,686
但查询分析的益处即使是在

860
00:26:42,686 --> 00:26:45,126
旧版的操作系统上也可以体现

861
00:26:45,546 --> 00:26:47,076
所以 在 UI 测试性能上 我们

862
00:26:47,076 --> 00:26:49,036
做了很多工作并且我们

863
00:26:49,036 --> 00:26:50,416
也期待看到大家的

864
00:26:50,416 --> 00:26:51,386
测试运行地更加迅速

865
00:26:51,896 --> 00:26:54,146
所以最后 我想再跟大家

866
00:26:54,146 --> 00:26:55,646
分享一个新的

867
00:26:55,646 --> 00:26:57,816
技术群组叫作

868
00:26:57,816 --> 00:26:59,636
Activity 附件与屏幕快照

869
00:27:00,596 --> 00:27:01,976
下面 让我们先来看看 Activity 

870
00:27:01,976 --> 00:27:03,716
这是创建附加结构

871
00:27:03,716 --> 00:27:05,666
运行时间更长的 UI

872
00:27:05,666 --> 00:27:07,666
以及集成测试的一种

873
00:27:07,666 --> 00:27:08,246
新方式

874
00:27:09,166 --> 00:27:11,216
有一个单独的 API 可以

875
00:27:11,216 --> 00:27:12,706
把代码片段进行归类

876
00:27:12,736 --> 00:27:14,006
通过把它们包装在

877
00:27:14,006 --> 00:27:16,156
闭包中再传到新一类

878
00:27:16,456 --> 00:27:17,646
XCTContext 中来实现

879
00:27:18,186 --> 00:27:20,696
这是从 Warren 之前做的 Demo

880
00:27:20,696 --> 00:27:22,636
中得出的一个测试报告

881
00:27:22,636 --> 00:27:23,636
我们还没来得及

882
00:27:23,636 --> 00:27:25,196
去查看 但现在报告已经在

883
00:27:25,196 --> 00:27:25,646
这里

884
00:27:25,776 --> 00:27:26,996
这个测试并没有

885
00:27:26,996 --> 00:27:28,966
很长或很复杂 

886
00:27:28,966 --> 00:27:30,416
但大家可以看到这里面

887
00:27:30,416 --> 00:27:31,176
却有很多的内容

888
00:27:31,766 --> 00:27:33,396
那么来思考一下这 4 个行动

889
00:27:34,156 --> 00:27:35,376
让我们来看看引导这些

890
00:27:35,376 --> 00:27:35,916
行动的代码

891
00:27:37,146 --> 00:27:38,666
我们用一个查询来找到

892
00:27:38,666 --> 00:27:40,406
视图 我们可以点击视图 输入

893
00:27:40,406 --> 00:27:42,196
一些文本并同几个按钮

894
00:27:42,196 --> 00:27:42,636
进行交互

895
00:27:43,316 --> 00:27:44,966
这个代码做了一个很好的逻辑

896
00:27:44,966 --> 00:27:46,176
归类 这个代码

897
00:27:46,176 --> 00:27:48,276
汇集了所有优质咖啡厅

898
00:27:48,276 --> 00:27:49,616
的信息

899
00:27:50,076 --> 00:27:52,286
所以 为这个代码创建一个

900
00:27:52,286 --> 00:27:54,166
XCTActivity 是非常简单的

901
00:27:54,556 --> 00:27:56,486
我们只需把它包装进这个运行

902
00:27:56,486 --> 00:27:58,456
Activity 调用中 给它一个漂亮的

903
00:27:58,456 --> 00:27:59,776
标签 因为这是我们将在测试

904
00:27:59,776 --> 00:28:01,236
报告中所呈现的

905
00:27:59,776 --> 00:28:01,236
报告中所呈现的

906
00:28:01,816 --> 00:28:02,846
下面 让我们来看看这给

907
00:28:02,846 --> 00:28:03,956
测试报告带来了什么改变

908
00:28:04,776 --> 00:28:06,436
我们原本的 4 个 Activity

909
00:28:06,436 --> 00:28:08,576
现在被包在了这个

910
00:28:08,576 --> 00:28:10,756
由咖啡信息组成的新的

911
00:28:10,756 --> 00:28:12,596
Activity 中 你仍然可以进行扩展

912
00:28:12,596 --> 00:28:14,406
来看看初始的且更加

913
00:28:14,406 --> 00:28:16,236
具体的细节

914
00:28:16,776 --> 00:28:18,566
但对于高层的首次

915
00:28:18,566 --> 00:28:19,586
通过 当你在浏览自己的

916
00:28:19,586 --> 00:28:21,366
测试报告时 信息会变得

917
00:28:21,366 --> 00:28:22,946
更加简洁并在语义上

918
00:28:22,946 --> 00:28:23,616
更有意义

919
00:28:24,556 --> 00:28:26,056
在整个更长的运行测试

920
00:28:26,056 --> 00:28:27,466
和在 Helper 方法中使用

921
00:28:27,466 --> 00:28:29,266
这个 API 会让

922
00:28:29,316 --> 00:28:31,086
测试报告更易于

923
00:28:31,086 --> 00:28:31,586
浏览

924
00:28:32,466 --> 00:28:35,206
除了 Activity 我们还

925
00:28:35,206 --> 00:28:36,686
推出了叫做附件的

926
00:28:36,866 --> 00:28:37,646
新功能

927
00:28:38,086 --> 00:28:39,796
长久以来 我们一直希望

928
00:28:39,796 --> 00:28:41,596
能将更丰富的数据添加到

929
00:28:41,596 --> 00:28:43,096
测试报告中

930
00:28:43,686 --> 00:28:45,526
最主要的动机是为了

931
00:28:45,526 --> 00:28:46,876
更容易地

932
00:28:46,876 --> 00:28:49,046
用额外的日志或其他数据来

933
00:28:49,046 --> 00:28:50,506
分流失败 这些数据能够在

934
00:28:50,626 --> 00:28:51,966
失败时提供关于条件的

935
00:28:51,966 --> 00:28:52,436
更多情况

936
00:28:53,496 --> 00:28:54,856
除此之外 这也可以被用来

937
00:28:54,856 --> 00:28:55,876
支持各类

938
00:28:55,936 --> 00:28:57,556
后处理工作流程

939
00:28:57,596 --> 00:28:59,156
比如同你的设计师

940
00:28:59,156 --> 00:29:00,346
坐在一起来看看

941
00:28:59,156 --> 00:29:00,346
坐在一起来看看

942
00:29:00,346 --> 00:29:01,406
屏幕快照

943
00:29:02,846 --> 00:29:04,576
现在附件可以通过便利 API

944
00:29:04,576 --> 00:29:07,096
支持任何类型的二进制

945
00:29:07,096 --> 00:29:09,226
数据 包括字符串

946
00:29:09,226 --> 00:29:11,996
属性列表 可编码的对象 文件

947
00:29:12,586 --> 00:29:13,536
和图像

948
00:29:14,106 --> 00:29:15,856
这些类别中任何一类都可以

949
00:29:16,096 --> 00:29:17,806
轻松添加到测试中 所以当

950
00:29:17,806 --> 00:29:18,866
你阅读测试报告时

951
00:29:18,866 --> 00:29:19,966
数据就在那里了

952
00:29:20,496 --> 00:29:22,206
这就把我们带到了

953
00:29:22,206 --> 00:29:23,516
技术群组的第三大

954
00:29:23,556 --> 00:29:24,766
内容 即

955
00:29:24,766 --> 00:29:25,626
屏幕快照

956
00:29:26,506 --> 00:29:27,916
多年来 在座的很多人都

957
00:29:27,916 --> 00:29:29,716
要求我们提供一个可以

958
00:29:29,716 --> 00:29:31,676
按需显性捕捉

959
00:29:31,816 --> 00:29:32,626
屏幕快照的 API 

960
00:29:32,836 --> 00:29:34,406
我们很高兴地告诉大家

961
00:29:34,406 --> 00:29:35,896
现在我们做到了 希望大家会

962
00:29:35,896 --> 00:29:35,963
喜欢

963
00:29:36,516 --> 00:29:41,876
[掌声]

964
00:29:42,376 --> 00:29:44,416
这个全新的可以提供

965
00:29:44,416 --> 00:29:45,596
屏幕快照的 XCUI 协议

966
00:29:45,596 --> 00:29:48,196
是由 XCUIElement 以及

967
00:29:48,576 --> 00:29:50,976
新的 XCUIScreen 类来执行的

968
00:29:51,456 --> 00:29:52,966
所以 当你使用一个元素并

969
00:29:52,966 --> 00:29:54,366
捕捉一张屏幕快照时

970
00:29:54,366 --> 00:29:56,246
会剪裁到只包含该元素的

971
00:29:56,246 --> 00:29:56,946
图框

972
00:29:56,946 --> 00:29:58,136
如果元素是按钮 你就只会看到按钮

973
00:29:58,136 --> 00:29:59,886
如果元素是窗口 你就会看到

974
00:29:59,886 --> 00:30:00,976
完整的窗口 以此类推

975
00:29:59,886 --> 00:30:00,976
完整的窗口 以此类推

976
00:30:01,076 --> 00:30:03,176
如果你使用屏幕 API 

977
00:30:03,636 --> 00:30:04,686
那么无论屏幕上

978
00:30:04,916 --> 00:30:06,386
显示了什么应用程序 

979
00:30:06,386 --> 00:30:08,216
你都能看到

980
00:30:09,516 --> 00:30:09,596
全屏

981
00:30:09,966 --> 00:30:11,496
现在有了附件和

982
00:30:11,496 --> 00:30:13,396
屏幕快照  在座一些人可能会

983
00:30:13,396 --> 00:30:16,096
疑惑这得多快就

984
00:30:16,096 --> 00:30:17,476
装满硬盘啦

985
00:30:18,996 --> 00:30:20,876
对于附件以及在 UI

986
00:30:20,876 --> 00:30:22,186
测试过程中

987
00:30:22,186 --> 00:30:23,686
自动捕捉的

988
00:30:23,686 --> 00:30:25,406
屏幕快照的默认策略是

989
00:30:25,846 --> 00:30:27,916
如果测试通过了 那我们就

990
00:30:27,916 --> 00:30:28,926
帮你把这些删除

991
00:30:29,546 --> 00:30:30,916
这就假设了在一般情况下

992
00:30:30,916 --> 00:30:33,286
根本不需要它们 但如果

993
00:30:33,286 --> 00:30:34,806
测试失败了 它们才会显现 

994
00:30:34,806 --> 00:30:35,196
出来

995
00:30:35,966 --> 00:30:38,056
现在 你可以在 Scheme 中

996
00:30:38,406 --> 00:30:39,196
覆盖这个策略

997
00:30:39,196 --> 00:30:40,756
在 UI 中存在本地化

998
00:30:40,756 --> 00:30:42,946
控制的相同部分 

999
00:30:43,026 --> 00:30:44,816
你可以告诉我们是否

1000
00:30:44,816 --> 00:30:46,976
希望可以全自动捕捉

1001
00:30:47,276 --> 00:30:48,936
屏幕快照以及是否想要

1002
00:30:48,936 --> 00:30:50,856
把这些屏幕快照和附件删除 

1003
00:30:50,856 --> 00:30:52,376
无论测试成功与否

1004
00:30:53,156 --> 00:30:54,996
在附件类也有

1005
00:30:54,996 --> 00:30:57,066
API 能够让你可以

1006
00:30:57,066 --> 00:30:59,576
根据具体的实例来

1007
00:30:59,576 --> 00:31:01,066
保留或者删除元素 及诸如

1008
00:30:59,576 --> 00:31:01,066
保留或者删除元素 及诸如

1009
00:31:01,066 --> 00:31:01,596
此类的事

1010
00:31:02,186 --> 00:31:04,116
接下来 大家可以在下一个

1011
00:31:04,116 --> 00:31:06,576
关于附件 Activity 和屏幕快照的 Demo 中

1012
00:31:06,576 --> 00:31:08,156
来看看实际的

1013
00:31:08,156 --> 00:31:08,586
场景

1014
00:31:08,916 --> 00:31:10,796
让我们欢迎 Honza Dvorsky

1015
00:31:10,796 --> 00:31:10,976
上台

1016
00:31:11,516 --> 00:31:17,566
[掌声]

1017
00:31:18,066 --> 00:31:18,646
&gt;&gt; 谢谢你 Wil

1018
00:31:19,316 --> 00:31:21,616
下午好 我叫 Honza

1019
00:31:21,716 --> 00:31:23,546
今天我将给大家展示

1020
00:31:26,636 --> 00:31:29,836
我们如何使用 Activity 来

1021
00:31:29,836 --> 00:31:33,036
组织测试 以及如何

1022
00:31:33,036 --> 00:31:35,016
利用新的屏幕快照 API 来

1023
00:31:35,016 --> 00:31:37,696
给你的 UI 进行屏幕快照 最后还会看看

1024
00:31:37,696 --> 00:31:39,536
如何将任意数据添加到

1025
00:31:39,536 --> 00:31:40,286
测试中

1026
00:31:40,996 --> 00:31:42,656
下面 我们首先来看看

1027
00:31:43,156 --> 00:31:44,606
Warren 做的测试的

1028
00:31:44,606 --> 00:31:44,926
测试报告

1029
00:31:45,986 --> 00:31:46,816
我们可以通过

1030
00:31:46,816 --> 00:31:48,116
按住 Control 键的同时单击 

1031
00:31:48,116 --> 00:31:49,796
测试方块并选取

1032
00:31:49,896 --> 00:31:50,696
“Jump to Report（跳转到报告）”

1033
00:31:53,636 --> 00:31:55,506
当我们展开一项测试 我们

1034
00:31:55,506 --> 00:31:56,946
便可以看到测试脚本

1035
00:31:57,486 --> 00:31:59,396
测试脚本包含关于

1036
00:31:59,396 --> 00:32:01,756
测试的全部细节 但

1037
00:31:59,396 --> 00:32:01,756
测试的全部细节 但

1038
00:32:01,756 --> 00:32:03,166
当测试越久 就变得

1039
00:32:03,166 --> 00:32:04,166
越难导航

1040
00:32:07,076 --> 00:32:08,826
此外 我们在这儿看到的是

1041
00:32:08,826 --> 00:32:10,726
类似这些标签和滑动的

1042
00:32:10,726 --> 00:32:12,596
分级步骤 这会

1043
00:32:12,596 --> 00:32:14,266
帮助我们在这些高层

1044
00:32:14,266 --> 00:32:15,776
任务周围组织测试 

1045
00:32:15,776 --> 00:32:18,586
例如 启动应用程序或是

1046
00:32:18,586 --> 00:32:19,876
编写发送一条新的信息

1047
00:32:20,956 --> 00:32:23,356
我们用 Activity 所做的

1048
00:32:23,356 --> 00:32:25,436
正是这个

1049
00:32:27,096 --> 00:32:28,236
下面我们要回到源代码

1050
00:32:28,606 --> 00:32:30,366
来寻找适合包装进第一项

1051
00:32:30,366 --> 00:32:31,376
Activity 的候选项

1052
00:32:32,006 --> 00:32:33,366
比如这一部分代码 

1053
00:32:33,606 --> 00:32:34,976
编写和发送新的信息 

1054
00:32:35,326 --> 00:32:36,016
可以通过它实现

1055
00:32:36,406 --> 00:32:39,916
那么 通过调用 XCTContext.runActivity 

1056
00:32:39,916 --> 00:32:42,316
我们把它包装进一个 Activitiy

1057
00:32:43,006 --> 00:32:44,356
这需要两个参数 

1058
00:32:44,356 --> 00:32:45,406
第一个是 Activity 的名称

1059
00:32:45,406 --> 00:32:47,536
在我们的这个例子里就是

1060
00:32:47,536 --> 00:32:49,356
编写和发送新信息 第二个参数

1061
00:32:49,356 --> 00:32:51,246
是块

1062
00:32:51,246 --> 00:32:52,466
块代表了 Activity 的

1063
00:32:52,466 --> 00:32:52,906
范围

1064
00:32:53,786 --> 00:32:56,006
我们在这里加个大括号 

1065
00:32:57,216 --> 00:32:59,036
就是这样 以上就是在一个

1066
00:32:59,036 --> 00:33:00,736
Activity 中包装一段代码

1067
00:32:59,036 --> 00:33:00,736
Activity 中包装一段代码

1068
00:33:00,736 --> 00:33:01,226
所须要做的全部

1069
00:33:02,776 --> 00:33:04,276
下面 我再给这个

1070
00:33:04,276 --> 00:33:09,066
测试创建更多的 Activity

1071
00:33:09,066 --> 00:33:10,826
我们将重新运行这个测试来

1072
00:33:10,826 --> 00:33:12,126
看看测试报告将如何变动

1073
00:33:12,736 --> 00:33:16,736
你可以看到我包装了

1074
00:33:16,736 --> 00:33:18,986
readerApp 的启动

1075
00:33:18,986 --> 00:33:20,006
对首条信息的

1076
00:33:20,006 --> 00:33:22,446
验证 writerApp 的

1077
00:33:22,446 --> 00:33:24,306
激活以及新信息的

1078
00:33:24,306 --> 00:33:25,886
编写和发送等等

1079
00:33:26,886 --> 00:33:29,066
这是 Warren 之前编写

1080
00:33:29,166 --> 00:33:31,446
的那个文本

1081
00:33:31,486 --> 00:33:33,246
但这一次这些 Activity 和我们

1082
00:33:33,246 --> 00:33:35,206
起的名字将作为

1083
00:33:35,206 --> 00:33:37,766
最高级成员

1084
00:33:37,766 --> 00:33:38,916
包含在输出中

1085
00:33:39,586 --> 00:33:43,936
所以 我们发送了信息

1086
00:33:43,936 --> 00:33:45,866
验证了这是正确的信息 

1087
00:33:47,936 --> 00:33:48,816
我们就完成了

1088
00:33:49,016 --> 00:33:50,516
下面 让我们回到测试

1089
00:33:50,516 --> 00:33:50,976
报告上

1090
00:33:55,176 --> 00:33:56,876
当我们展开脚本时 

1091
00:33:56,876 --> 00:33:58,566
现在我们可以看到内容变得更短 

1092
00:33:59,086 --> 00:34:00,206
并且除此之外 它更好地

1093
00:33:59,086 --> 00:34:00,206
并且除此之外 它更好地

1094
00:34:00,206 --> 00:34:02,106
描述了我们的测试所做的工作

1095
00:34:02,466 --> 00:34:04,026
它启动了 readerApp

1096
00:34:04,536 --> 00:34:06,006
验证了第一条信息

1097
00:34:06,386 --> 00:34:07,656
激活了 writerApp、

1098
00:34:07,806 --> 00:34:09,306
编写并发送了新的信息

1099
00:34:09,306 --> 00:34:09,766
等等

1100
00:34:10,485 --> 00:34:11,656
但如果你还是需要了解

1101
00:34:11,656 --> 00:34:13,166
关于这个 Activity 的所有细节信息 

1102
00:34:13,166 --> 00:34:15,156
所有的子 Activity 都

1103
00:34:15,226 --> 00:34:16,755
隐藏在更深的一层

1104
00:34:17,726 --> 00:34:19,556
所以  Activity 是组织测试

1105
00:34:19,556 --> 00:34:23,226
的一种良好方式

1106
00:34:23,275 --> 00:34:25,166
下面让我们来稍微换换

1107
00:34:25,536 --> 00:34:25,676
思路

1108
00:34:25,676 --> 00:34:27,926
帮助我们设计应用程序的

1109
00:34:27,926 --> 00:34:30,676
设计师们想确定

1110
00:34:30,676 --> 00:34:32,255
我们的信息栏

1111
00:34:32,746 --> 00:34:33,866
完全遵守了他们

1112
00:34:33,866 --> 00:34:35,216
的规范

1113
00:34:35,956 --> 00:34:37,565
所以我们要做的就是编写一个

1114
00:34:37,565 --> 00:34:39,795
捕捉了应用程序视觉状态的

1115
00:34:39,795 --> 00:34:42,315
UI 测试 然后每个晚上

1116
00:34:42,315 --> 00:34:44,076
都在我们的机器人上运行这个

1117
00:34:44,076 --> 00:34:44,456
测试 

1118
00:34:44,906 --> 00:34:46,346
通过这种方式 我们的设计师可以

1119
00:34:46,346 --> 00:34:47,926
在任何想来的时候来看看

1120
00:34:47,956 --> 00:34:49,036
应用程序的外观

1121
00:34:49,696 --> 00:34:53,426
所以这是新的类

1122
00:34:53,426 --> 00:34:54,315
VisualValidationTests

1123
00:34:54,315 --> 00:34:56,806
我已经有了代码可以

1124
00:34:56,876 --> 00:34:58,186
以我想要的方式启动

1125
00:34:58,186 --> 00:35:00,196
应用程序 同时我还有

1126
00:34:58,186 --> 00:35:00,196
应用程序 同时我还有

1127
00:35:00,196 --> 00:35:01,376
空的 Activity 叫做 “Gather Screenshots（获取屏幕快照）”

1128
00:35:01,376 --> 00:35:03,156
我们会把

1129
00:35:03,156 --> 00:35:04,546
我们的屏幕快照放在这里

1130
00:35:05,386 --> 00:35:06,746
我们会捕捉两个屏幕快照 

1131
00:35:06,746 --> 00:35:08,436
第一个是应用程序的

1132
00:35:08,436 --> 00:35:11,056
全屏 而另一个则仅仅截取

1133
00:35:11,056 --> 00:35:11,986
第一个信息栏

1134
00:35:12,516 --> 00:35:16,076
那么 为了捕捉全屏 

1135
00:35:16,366 --> 00:35:18,566
我们使用新的 XCUIScreen API 来

1136
00:35:18,566 --> 00:35:20,416
控制主屏幕

1137
00:35:21,546 --> 00:35:23,456
正如 Wil 所提到的那样 XCUIScreen

1138
00:35:23,456 --> 00:35:25,336
遵循 XCUIScreenshotProviding 协议 

1139
00:35:25,336 --> 00:35:27,216
所以我们可以仅

1140
00:35:27,216 --> 00:35:29,006
要求它自我

1141
00:35:29,006 --> 00:35:29,396
屏幕快照

1142
00:35:29,426 --> 00:35:32,676
现在 我们的内存里有

1143
00:35:32,676 --> 00:35:34,106
屏幕快照 并且我们也想

1144
00:35:34,186 --> 00:35:36,476
在测试中继续保持 

1145
00:35:36,476 --> 00:35:37,726
这时候附件就派上

1146
00:35:37,726 --> 00:35:37,926
用场了

1147
00:35:38,256 --> 00:35:41,766
附件可以保存任何数据

1148
00:35:42,086 --> 00:35:43,666
并且 XCTAttachment 为

1149
00:35:43,666 --> 00:35:45,096
便利初始化程序提供了

1150
00:35:45,096 --> 00:35:46,846
诸如字符串 文件

1151
00:35:46,846 --> 00:35:48,056
图像和屏幕快照等类别

1152
00:35:48,446 --> 00:35:50,986
那么我们要创建一个新的

1153
00:35:50,986 --> 00:35:52,156
附件来保存

1154
00:35:52,156 --> 00:35:52,786
屏幕快照

1155
00:35:54,276 --> 00:35:56,936
正如 Wil 提到的那样 

1156
00:35:56,936 --> 00:35:58,686
一旦测试通过了 屏幕快照

1157
00:35:58,686 --> 00:36:00,146
就被删除了 这个一个默认

1158
00:35:58,686 --> 00:36:00,146
就被删除了 这个一个默认

1159
00:36:00,146 --> 00:36:00,596
行为

1160
00:36:01,606 --> 00:36:02,946
但在我们的例子中 我们希望

1161
00:36:02,946 --> 00:36:04,266
无论测试结果如何

1162
00:36:04,316 --> 00:36:05,876
都保留附件

1163
00:36:06,416 --> 00:36:07,926
我们可以创建一个单独的附件 

1164
00:36:08,396 --> 00:36:10,936
然后自定义附件的生命期让它

1165
00:36:10,936 --> 00:36:11,906
始终保存

1166
00:36:13,176 --> 00:36:14,496
最后 我们把这个

1167
00:36:14,496 --> 00:36:16,526
附件加到 Activity 中 我们会把

1168
00:36:16,526 --> 00:36:18,386
它加到代表了

1169
00:36:18,386 --> 00:36:19,366
收集屏幕快照的

1170
00:36:19,366 --> 00:36:19,976
Activity 中

1171
00:36:24,286 --> 00:36:25,676
现在我们捕捉了全屏 

1172
00:36:25,676 --> 00:36:27,276
我们还想捕捉

1173
00:36:27,276 --> 00:36:28,416
第一个信息栏

1174
00:36:28,506 --> 00:36:31,586
那么首先 我们使用现有的

1175
00:36:31,936 --> 00:36:33,696
UI 测试 API 来获取

1176
00:36:33,696 --> 00:36:35,266
信息栏的 XCUIElement

1177
00:36:36,166 --> 00:36:38,036
XCUIElement 同样遵守

1178
00:36:38,036 --> 00:36:40,156
XCUIScreenshotProviding 协议

1179
00:36:40,156 --> 00:36:41,576
所以我们只须照着同样的

1180
00:36:41,576 --> 00:36:41,806
步骤操作

1181
00:36:42,306 --> 00:36:44,336
我们命令信息栏对自身进行

1182
00:36:44,336 --> 00:36:46,056
屏幕快照 我们为它创建

1183
00:36:46,056 --> 00:36:47,556
一个附件 自定义它的

1184
00:36:47,556 --> 00:36:49,426
生命期并将附件添加到

1185
00:36:49,426 --> 00:36:50,036
Activity 中

1186
00:36:51,416 --> 00:36:52,986
那么现在 让我们来运行测试 

1187
00:36:52,986 --> 00:36:53,576
看看会出现什么

1188
00:36:59,046 --> 00:37:01,136
这是一个简单的测试 只需要

1189
00:36:59,046 --> 00:37:01,136
这是一个简单的测试 只需要

1190
00:37:01,136 --> 00:37:03,956
启动应用程序 捕捉

1191
00:37:03,956 --> 00:37:06,516
两个屏幕快照 把这两个屏幕快照

1192
00:37:06,516 --> 00:37:08,176
作为附件添加

1193
00:37:08,176 --> 00:37:08,976
就完成了

1194
00:37:14,186 --> 00:37:14,536
就是这样

1195
00:37:14,856 --> 00:37:16,636
下面再来看看测试报告

1196
00:37:17,176 --> 00:37:23,076
当我们展开测试时 我们

1197
00:37:23,076 --> 00:37:25,096
看到了获取屏幕快照的

1198
00:37:25,096 --> 00:37:28,246
Activity 它含有两个

1199
00:37:28,246 --> 00:37:29,086
附加以及

1200
00:37:29,086 --> 00:37:29,816
子 Activity

1201
00:37:30,226 --> 00:37:32,086
那么这是代表了第一个

1202
00:37:32,086 --> 00:37:34,416
主屏幕屏幕快照的附件

1203
00:37:34,416 --> 00:37:36,496
而这个代表了

1204
00:37:36,496 --> 00:37:37,616
只有信息栏的

1205
00:37:37,616 --> 00:37:38,196
屏幕快照

1206
00:37:38,986 --> 00:37:41,146
我们可以使用快速预览图标

1207
00:37:41,146 --> 00:37:43,226
来获取预览窗口

1208
00:37:43,226 --> 00:37:45,296
但实际上 我想使用

1209
00:37:45,296 --> 00:37:47,486
这个“Assistant Editor（助理编辑器）”来

1210
00:37:47,486 --> 00:37:47,766
实现

1211
00:37:52,046 --> 00:37:53,476
我们只需选取正确的

1212
00:37:53,736 --> 00:37:56,286
屏幕快照 这就是我们的

1213
00:37:56,386 --> 00:37:59,426
全屏屏幕快照 这个是

1214
00:37:59,426 --> 00:38:00,626
只有第一个信息栏的

1215
00:37:59,426 --> 00:38:00,626
只有第一个信息栏的

1216
00:38:00,626 --> 00:38:01,516
屏幕快照

1217
00:38:02,446 --> 00:38:04,226
这样你就可以看到捕捉

1218
00:38:04,226 --> 00:38:06,146
是多么的简单容易了 

1219
00:38:06,146 --> 00:38:06,396
对吧

1220
00:38:07,516 --> 00:38:12,546
[掌声]

1221
00:38:13,046 --> 00:38:14,216
现在你可以看到通过这个

1222
00:38:14,216 --> 00:38:15,946
新的屏幕快照 API 来真正捕捉

1223
00:38:15,946 --> 00:38:17,036
应用程序中的任何屏幕

1224
00:38:17,526 --> 00:38:19,236
或元素并且利用新的附件 API

1225
00:38:19,616 --> 00:38:21,276
来把屏幕快照添加到测试中

1226
00:38:21,276 --> 00:38:22,376
是多么容易了

1227
00:38:22,376 --> 00:38:25,806
我真心希望大家都能试一试

1228
00:38:25,976 --> 00:38:27,516
好了 那下面我再有请

1229
00:38:27,516 --> 00:38:28,826
Wil 回到台上

1230
00:38:28,826 --> 00:38:29,536
来进行总结

1231
00:38:29,806 --> 00:38:29,976
有请 Wil 

1232
00:38:30,516 --> 00:38:36,686
[掌声]

1233
00:38:37,186 --> 00:38:38,866
谢谢你 Honza 简直

1234
00:38:38,866 --> 00:38:40,396
太精彩了 大家可以看到

1235
00:38:40,396 --> 00:38:41,956
Activity 在改进测试架构

1236
00:38:41,956 --> 00:38:43,956
方面是多么容易 

1237
00:38:43,956 --> 00:38:45,176
使用附件来捕捉

1238
00:38:45,176 --> 00:38:46,956
丰富的数据将使修复测试失败

1239
00:38:46,956 --> 00:38:48,346
变得前所未有的容易

1240
00:38:48,346 --> 00:38:50,596
还有屏幕快照 难道还有人

1241
00:38:50,596 --> 00:38:51,606
不喜欢屏幕快照吗 

1242
00:38:52,216 --> 00:38:53,436
这就是 Activity  附件和

1243
00:38:53,436 --> 00:38:54,926
屏幕快照 这是大家在测试中

1244
00:38:54,926 --> 00:38:56,606
可以使用的一全新的领先

1245
00:38:56,606 --> 00:38:57,126
技术

1246
00:38:57,626 --> 00:39:00,346
所以 今天我们以测试

1247
00:38:57,626 --> 00:39:00,346
所以 今天我们以测试

1248
00:39:00,346 --> 00:39:01,636
新发现作为开头 你也可以看出来 

1249
00:39:01,636 --> 00:39:02,396
内容丰富多样

1250
00:39:03,156 --> 00:39:04,996
我们有很多新的 API 供大家

1251
00:39:04,996 --> 00:39:06,476
使用 今天甚至没来得及将它们

1252
00:39:06,476 --> 00:39:07,416
逐个介绍

1253
00:39:08,236 --> 00:39:11,656
我们有很多新的 API 

1254
00:39:12,086 --> 00:39:14,376
我们也有新的工作流以及

1255
00:39:14,376 --> 00:39:15,896
Xcode 中的持续集成功能 

1256
00:39:15,986 --> 00:39:18,216
还有 xcodebuild 命令和 Xcode Server

1257
00:39:18,216 --> 00:39:20,346
我们还

1258
00:39:20,346 --> 00:39:21,986
极大提升了 UI 测试的

1259
00:39:21,986 --> 00:39:22,406
性能

1260
00:39:22,486 --> 00:39:25,676
最后 感谢大家到场

1261
00:39:26,066 --> 00:39:27,876
通过上方的链接 可以找到

1262
00:39:27,906 --> 00:39:30,346
关于本次会议的所有

1263
00:39:30,346 --> 00:39:31,746
相关资料和

1264
00:39:31,746 --> 00:39:33,076
文件 你想看的全部

1265
00:39:33,076 --> 00:39:33,626
都在这里

1266
00:39:34,376 --> 00:39:36,036
当然 我们在过去举办了

1267
00:39:36,036 --> 00:39:38,076
很多场会议 

1268
00:39:38,076 --> 00:39:39,156
明天还有一场希望大家可以

1269
00:39:39,156 --> 00:39:39,686
参加

1270
00:39:40,286 --> 00:39:42,196
前几年的会议中

1271
00:39:42,196 --> 00:39:43,646
确实有一些很有用的

1272
00:39:43,646 --> 00:39:45,206
信息是关于 Xcode 测试的

1273
00:39:45,206 --> 00:39:47,426
其他方面 都是我们在今天

1274
00:39:47,426 --> 00:39:48,656
没能仔细探讨的

1275
00:39:48,746 --> 00:39:49,016
内容

1276
00:39:49,516 --> 00:39:49,846
感谢大家
