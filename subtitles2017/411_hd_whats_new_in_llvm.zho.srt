1
00:00:07,516 --> 00:00:16,500
[背景对话]

2
00:00:21,516 --> 00:00:25,586
[掌声]

3
00:00:26,086 --> 00:00:28,446
&gt;&gt; 大家好 欢迎来到

4
00:00:28,446 --> 00:00:29,016
“What’s New in LLVM（LLVM 的新内容）”

5
00:00:29,736 --> 00:00:31,396
我是 Devin 是一名工程师

6
00:00:31,396 --> 00:00:32,646
来自程序分析团队

7
00:00:33,636 --> 00:00:35,656
今天 我们有很多非常不错的新

8
00:00:35,656 --> 00:00:36,766
功能和大家

9
00:00:36,766 --> 00:00:37,076
分享

10
00:00:38,266 --> 00:00:39,616
我们首先会介绍

11
00:00:39,846 --> 00:00:41,306
Objective-C 的

12
00:00:41,306 --> 00:00:41,976
可用性检查

13
00:00:41,976 --> 00:00:44,086
可用性检查能够帮助用户安全配置

14
00:00:44,086 --> 00:00:46,136
App 到旧的系统中

15
00:00:47,186 --> 00:00:48,246
然后我们将介绍新的静态

16
00:00:48,246 --> 00:00:49,626
分析器检查和编译器

17
00:00:49,626 --> 00:00:51,506
警告功能 来帮助你找到 Bug

18
00:00:52,676 --> 00:00:54,336
接着我们将讨论为 C++ 开发人员

19
00:00:54,336 --> 00:00:56,196
打造的一些绝妙的新功能

20
00:00:56,646 --> 00:00:58,366
包括 Xcode 代码中的

21
00:00:58,366 --> 00:01:01,056
C++ 重构支持

22
00:00:58,366 --> 00:01:01,056
C++ 重构支持

23
00:01:01,056 --> 00:01:02,866
最后

24
00:01:02,866 --> 00:01:03,996
介绍链接时间优化的更新

25
00:01:04,506 --> 00:01:07,786
让我们先从可用性检查

26
00:01:07,786 --> 00:01:08,000
开始说起

27
00:01:10,556 --> 00:01:12,316
每一次主要的 OS 发布时

28
00:01:12,606 --> 00:01:14,556
我们都会介绍一些非常棒的新功能

29
00:01:14,556 --> 00:01:16,096
你的顾客希望你能把

30
00:01:16,096 --> 00:01:18,046
这些 API 运用到你们的 App 上

31
00:01:19,086 --> 00:01:20,256
但你仍须支持

32
00:01:20,256 --> 00:01:22,626
使用旧 OS 的顾客 虽然

33
00:01:22,626 --> 00:01:24,136
这些 API 在旧的 OS 中无法使用

34
00:01:24,136 --> 00:01:29,246
在我们的平台上 我们支持

35
00:01:29,246 --> 00:01:30,766
反向配置 通过

36
00:01:30,766 --> 00:01:32,686
将基础 SDK 版本

37
00:01:32,946 --> 00:01:34,026
从配置目标版本隔离

38
00:01:34,026 --> 00:01:34,456
来实现

39
00:01:35,296 --> 00:01:36,716
也就是说

40
00:01:36,716 --> 00:01:38,586
即使在旧的系统中进行配置时 

41
00:01:38,586 --> 00:01:41,286
你也可以利用最新的

42
00:01:41,286 --> 00:01:42,496
SDK 进行编译

43
00:01:43,266 --> 00:01:45,736
举个例子 在 Xcode 9 中

44
00:01:45,736 --> 00:01:49,326
如果你使用 iOS 11 SDK  且你的

45
00:01:49,326 --> 00:01:52,086
App 只针对 iOS 11

46
00:01:52,086 --> 00:01:53,716
你会把它也作为配置

47
00:01:53,716 --> 00:01:54,596
目标

48
00:01:55,146 --> 00:01:57,666
但我知道在座的很多人

49
00:01:57,666 --> 00:01:59,466
希望在 iOS 10 中支持你们的用户

50
00:01:59,546 --> 00:02:01,606
给用户一个机会

51
00:01:59,546 --> 00:02:01,606
给用户一个机会

52
00:02:01,606 --> 00:02:02,216
进行升级

53
00:02:03,416 --> 00:02:04,406
要这么做的话 你可以前往

54
00:02:04,406 --> 00:02:07,126
“Build Settings（构建设置）”

55
00:02:07,516 --> 00:02:08,656
选择 10.0 作为配置目标

56
00:02:09,756 --> 00:02:11,346
这可以保证你的 App

57
00:02:11,346 --> 00:02:12,886
能够支持

58
00:02:12,886 --> 00:02:15,296
iOS 10 以及更新系统的

59
00:02:15,296 --> 00:02:15,746
所有版本

60
00:02:15,746 --> 00:02:20,976
这其实有点投机取巧

61
00:02:21,136 --> 00:02:23,416
因为只有调用

62
00:02:23,486 --> 00:02:25,656
系统真正支持的 API

63
00:02:25,656 --> 00:02:26,496
才安全

64
00:02:27,236 --> 00:02:29,476
如果你在旧系统中调用新版本 API

65
00:02:29,476 --> 00:02:31,486
那么你的 App 很可能

66
00:02:31,486 --> 00:02:33,146
崩溃 或出现其他意外

67
00:02:33,146 --> 00:02:33,646
行为

68
00:02:33,646 --> 00:02:37,766
过去 我们推荐

69
00:02:37,766 --> 00:02:39,676
查询 Objective-C 运行时

70
00:02:40,106 --> 00:02:41,896
来确定 API 是否

71
00:02:41,896 --> 00:02:42,386
适用

72
00:02:43,496 --> 00:02:45,236
但是这个方法很容易出错

73
00:02:45,236 --> 00:02:47,346
或被忘记 而且很难

74
00:02:47,346 --> 00:02:47,836
进行测试

75
00:02:49,286 --> 00:02:51,336
而且 它需要不同的

76
00:02:51,436 --> 00:02:54,586
语法来检查每项

77
00:02:55,136 --> 00:02:58,066
全局变量 函数 类

78
00:02:58,576 --> 00:03:00,296
实例方法和

79
00:02:58,576 --> 00:03:00,296
实例方法和

80
00:03:00,296 --> 00:03:00,666
类方法

81
00:03:01,286 --> 00:03:04,956
你们之中在使用 Swift 的人

82
00:03:04,956 --> 00:03:06,896
可能会想 这有什么

83
00:03:06,896 --> 00:03:07,696
大不了的吗

84
00:03:07,956 --> 00:03:09,426
Swift 有一个统一的语法

85
00:03:09,476 --> 00:03:11,516
#available 可在运行时用于查询 API

86
00:03:11,516 --> 00:03:13,466
的可用性 而且

87
00:03:13,466 --> 00:03:16,176
编译器甚至可以在编译时

88
00:03:16,176 --> 00:03:18,346
捕捉缺失的可用性

89
00:03:18,786 --> 00:03:18,876
检查

90
00:03:20,656 --> 00:03:21,936
想要了解更多

91
00:03:21,936 --> 00:03:22,996
关于 Swift 可用性的信息请

92
00:03:22,996 --> 00:03:24,406
前往 WWDC 2015 中的“Swift in Practice”

93
00:03:24,406 --> 00:03:29,276
以了解更多

94
00:03:29,376 --> 00:03:31,396
现在我们将 Swift 类的

95
00:03:31,396 --> 00:03:32,816
可用性检查带入了

96
00:03:32,816 --> 00:03:33,516
Objective-C

97
00:03:34,516 --> 00:03:39,406
[掌声]

98
00:03:39,906 --> 00:03:41,096
我想为大家介绍一下

99
00:03:41,946 --> 00:03:42,000
这个功能

100
00:03:43,046 --> 00:03:44,726
假设你有一个 App

101
00:03:44,896 --> 00:03:46,796
你想把它配置回 iOS 10 中

102
00:03:47,726 --> 00:03:49,536
并且你决定利用

103
00:03:49,716 --> 00:03:51,956
iOS 11 提供的

104
00:03:51,956 --> 00:03:53,806
Vision 框架中全新的

105
00:03:53,806 --> 00:03:55,426
人脸检测 API

106
00:03:56,626 --> 00:03:57,886
当你将这些 API 

107
00:03:57,886 --> 00:04:00,606
添加至 App 并构建时

108
00:03:57,886 --> 00:04:00,606
添加至 App 并构建时

109
00:04:00,606 --> 00:04:02,706
你会收到一个编译器警告

110
00:04:02,706 --> 00:04:04,736
告诉你这些 API 只

111
00:04:04,736 --> 00:04:07,046
适用于 iOS 11 或更新的系统

112
00:04:07,576 --> 00:04:10,336
你可以

113
00:04:10,696 --> 00:04:12,866
通过使用新的@available 结构

114
00:04:12,866 --> 00:04:14,826
查询 API 可用性

115
00:04:14,826 --> 00:04:15,486
来处理这些警告

116
00:04:16,565 --> 00:04:18,656
当 iOS 11 API 适用时

117
00:04:18,656 --> 00:04:20,466
@available 结构返回值为真

118
00:04:20,916 --> 00:04:23,076
这种情况下调用 API 很安全

119
00:04:23,266 --> 00:04:24,266
如果不适用 你可以

120
00:04:24,266 --> 00:04:25,236
提供一个 Fallback（回退）

121
00:04:26,516 --> 00:04:28,636
我们来仔细看看

122
00:04:28,856 --> 00:04:29,000
查询功能

123
00:04:31,046 --> 00:04:35,046
我刚刚提过 在 iOS 11系统或

124
00:04:35,046 --> 00:04:37,176
更新的系统里 它的返回真为值

125
00:04:37,736 --> 00:04:40,026
这个星号是必须的

126
00:04:40,996 --> 00:04:42,676
它表明在其他所有

127
00:04:42,676 --> 00:04:44,976
平台上 查询总会

128
00:04:44,976 --> 00:04:45,796
返回真值

129
00:04:47,166 --> 00:04:48,316
也就是说 如果你

130
00:04:48,316 --> 00:04:49,906
决定将 App 转移至

131
00:04:49,906 --> 00:04:51,806
另一个平台 比如 macOS

132
00:04:52,486 --> 00:04:54,286
那么 默认情况下

133
00:04:54,286 --> 00:04:55,626
它会利用这个新的

134
00:04:55,626 --> 00:04:56,676
人脸检测 API

135
00:04:57,736 --> 00:04:58,656
当然 如果 API

136
00:04:58,656 --> 00:05:00,276
不适用于该 macOS 支持的

137
00:04:58,656 --> 00:05:00,276
不适用于该 macOS 支持的

138
00:05:00,276 --> 00:05:02,146
先前配置目标

139
00:05:02,146 --> 00:05:03,406
编译器

140
00:05:03,406 --> 00:05:04,696
依然会发出警告

141
00:05:04,986 --> 00:05:08,786
所以你需要检查一下

142
00:05:10,066 --> 00:05:11,166
一旦你开始使用

143
00:05:11,166 --> 00:05:12,756
可用性这个功能

144
00:05:12,756 --> 00:05:14,476
你会发现

145
00:05:14,476 --> 00:05:16,536
编写一个只能在 iOS 11

146
00:05:16,846 --> 00:05:18,956
或更新系统上调用的一整套方法

147
00:05:18,956 --> 00:05:19,726
真的非常有用

148
00:05:19,786 --> 00:05:23,236
你可以使用全新的

149
00:05:23,236 --> 00:05:25,056
API 可用性宏

150
00:05:25,056 --> 00:05:25,516
注释这些方法

151
00:05:26,936 --> 00:05:29,316
然后 在这个方法中

152
00:05:29,316 --> 00:05:31,216
无须使用 @available

153
00:05:31,216 --> 00:05:33,356
检查可用性

154
00:05:33,356 --> 00:05:35,386
但是调用该方法的人

155
00:05:35,386 --> 00:05:36,166
需要使用 @available

156
00:05:36,526 --> 00:05:37,366
否则 他们会收到一个

157
00:05:37,366 --> 00:05:37,776
警告

158
00:05:38,136 --> 00:05:42,026
你还可以把这个功能应用于

159
00:05:42,026 --> 00:05:42,886
整个类

160
00:05:43,476 --> 00:05:44,216
而且 你无须

161
00:05:44,216 --> 00:05:46,266
在该类中使用 @available

162
00:05:46,266 --> 00:05:48,046
但实例化该类的人

163
00:05:48,046 --> 00:05:48,766
都需要使用 @available

164
00:05:52,756 --> 00:05:54,446
现在 可用性检查

165
00:05:54,446 --> 00:05:55,946
不仅仅用于 Objective-C 中

166
00:05:56,706 --> 00:05:59,286
通过内建可用性查询 

167
00:05:59,286 --> 00:06:00,916
我们还支持 C 和 C++

168
00:05:59,286 --> 00:06:00,916
我们还支持 C 和 C++

169
00:06:01,856 --> 00:06:03,456
这里的用法和

170
00:06:03,456 --> 00:06:04,346
@available 完全一样

171
00:06:04,656 --> 00:06:05,786
它们有一样的语法

172
00:06:06,356 --> 00:06:07,576
只是名称不同

173
00:06:07,746 --> 00:06:08,926
且名称与 C 和 C++

174
00:06:08,926 --> 00:06:09,626
兼容

175
00:06:10,156 --> 00:06:13,176
你还可以

176
00:06:13,176 --> 00:06:15,196
在 C 中使用 API 可用性宏

177
00:06:15,196 --> 00:06:16,366
但须要包括

178
00:06:16,366 --> 00:06:18,836
<os/availability.h> 头文件 才能

179
00:06:18,836 --> 00:06:19,646
访问

180
00:06:20,096 --> 00:06:23,186
你甚至可以对你的

181
00:06:23,186 --> 00:06:24,756
C++ 类的定义进行注释

182
00:06:24,756 --> 00:06:28,396
那么 我们具体

183
00:06:28,716 --> 00:06:31,716
应该要怎样做呢

184
00:06:31,716 --> 00:06:33,736
对于现有的工程

185
00:06:33,736 --> 00:06:35,566
我们不建议一开始就使用

186
00:06:35,566 --> 00:06:38,816
iOS 11  Apple TVOS 11

187
00:06:38,816 --> 00:06:41,396
macOS 10.13 和 watchOS 4 引入的 API

188
00:06:42,496 --> 00:06:45,226
老版本 SDK 的 API

189
00:06:45,226 --> 00:06:46,406
在编译时不会被检查

190
00:06:47,676 --> 00:06:48,866
也就是说你无须

191
00:06:48,866 --> 00:06:51,576
改变任何现有代码

192
00:06:51,576 --> 00:06:53,596
但如果你决定采用

193
00:06:53,596 --> 00:06:55,856
新的 API 你需要使用

194
00:06:55,856 --> 00:06:57,466
@available 检查新的 API

195
00:06:58,656 --> 00:06:59,726
我们认为这是最佳

196
00:06:59,726 --> 00:07:00,726
也是最安全的

197
00:06:59,726 --> 00:07:00,726
也是最安全的

198
00:07:00,726 --> 00:07:02,386
可用性检查方法 所以我们强烈

199
00:07:02,386 --> 00:07:03,966
推荐大家使用

200
00:07:05,726 --> 00:07:08,896
对于新项目 所有 API

201
00:07:08,896 --> 00:07:10,196
都会在编译时被检查

202
00:07:11,026 --> 00:07:12,376
也就是说你在配置目标

203
00:07:12,376 --> 00:07:13,986
下面引入的所有 API

204
00:07:13,986 --> 00:07:15,976
都需要使用

205
00:07:16,376 --> 00:07:16,566
@available

206
00:07:17,736 --> 00:07:20,036
现有项目也可以选择

207
00:07:20,036 --> 00:07:22,316
这种全 API 行为

208
00:07:22,316 --> 00:07:23,686
前往构建设置

209
00:07:23,686 --> 00:07:25,926
在“Unguarded availability”一栏

210
00:07:25,926 --> 00:07:27,036
选择“Yes (All Versions)”

211
00:07:27,036 --> 00:07:27,386
即可实现

212
00:07:28,186 --> 00:07:30,006
这个方法使

213
00:07:30,006 --> 00:07:31,846
在旧的系统中安全配置 App 

214
00:07:31,846 --> 00:07:33,326
变得更加简单 

215
00:07:33,886 --> 00:07:36,376
以上就是关于可用性检查的介绍

216
00:07:36,726 --> 00:07:37,606
你可以说它现在在

217
00:07:37,606 --> 00:07:40,506
C C++ 和 Objective-C 中

218
00:07:40,506 --> 00:07:41,156
都“@available（可用）”了

219
00:07:42,516 --> 00:07:47,686
[掌声]

220
00:07:48,186 --> 00:07:49,896
好的 我们继续来看

221
00:07:49,896 --> 00:07:50,716
静态分析器

222
00:07:52,096 --> 00:07:54,976
这个分析器擅长

223
00:07:54,976 --> 00:07:56,426
捕捉难以重现的

224
00:07:56,526 --> 00:07:58,706
极端情况 Bug 甚至可以

225
00:07:58,706 --> 00:07:59,876
展示导致 Bug 的

226
00:07:59,876 --> 00:08:01,936
极端事件的

227
00:07:59,876 --> 00:08:01,936
极端事件的

228
00:08:02,016 --> 00:08:03,276
序列

229
00:08:03,556 --> 00:08:04,406
今天 我会向大家

230
00:08:04,406 --> 00:08:05,656
介绍三种

231
00:08:05,656 --> 00:08:07,926
我们添加至该分析器的新的检查方法

232
00:08:07,926 --> 00:08:09,426
NSNumber 可疑比较检查

233
00:08:09,426 --> 00:08:11,466
实例变量中

234
00:08:11,466 --> 00:08:12,756
dispatch_once() 使用

235
00:08:12,756 --> 00:08:14,546
检查 以及 NSMutable 中

236
00:08:14,546 --> 00:08:16,346
自动综合的

237
00:08:16,636 --> 00:08:18,346
copy 属性检查

238
00:08:20,756 --> 00:08:24,596
有一个致命的 Bug 是

239
00:08:24,596 --> 00:08:26,506
错误地将

240
00:08:26,506 --> 00:08:28,396
NSNumber 指针值

241
00:08:28,396 --> 00:08:30,836
与标量“0”相比较 因为

242
00:08:31,036 --> 00:08:33,486
这个操作实际上是将指针值与 nil 相比较

243
00:08:33,486 --> 00:08:34,976
而不是 NSNumber 实例的“0”

244
00:08:36,025 --> 00:08:37,006
我给大家举个例子说明为什么

245
00:08:37,006 --> 00:08:37,936
这个问题很严重

246
00:08:39,116 --> 00:08:40,885
在 hasPhotos 方法中

247
00:08:40,885 --> 00:08:43,706
编程者想要返回“no”

248
00:08:43,856 --> 00:08:45,156
如果相册是空的

249
00:08:46,136 --> 00:08:47,236
但是因为他们

250
00:08:47,236 --> 00:08:49,866
将照片数量计为“nil” 这个结果

251
00:08:49,866 --> 00:08:52,216
实际上将返回“yes” 即使

252
00:08:52,216 --> 00:08:54,266
照片数量

253
00:08:54,316 --> 00:08:55,356
在 NSNumber 实例中计为“0”

254
00:08:56,036 --> 00:08:57,206
所以这时分析器

255
00:08:57,206 --> 00:08:59,876
会发出警告

256
00:09:00,106 --> 00:09:02,336
你可以通过

257
00:09:02,336 --> 00:09:03,986
调用 integerValue 属性

258
00:09:03,986 --> 00:09:06,196
进行整数之间的比较

259
00:09:06,196 --> 00:09:06,756
来纠正这个错误

260
00:09:07,106 --> 00:09:07,686
这个方法很安全

261
00:09:08,236 --> 00:09:11,626
布尔运算的隐式变换

262
00:09:11,626 --> 00:09:14,056
有一个类似的问题

263
00:09:14,446 --> 00:09:16,466
因为也是检查“nil”

264
00:09:16,496 --> 00:09:17,746
而不是数字“0”

265
00:09:18,276 --> 00:09:20,956
这个方法计算

266
00:09:21,046 --> 00:09:23,286
一张照片上出现的人脸数量 鉴于这项

267
00:09:23,286 --> 00:09:24,966
操作成本较高

268
00:09:24,966 --> 00:09:26,576
如果已经计算过数量 

269
00:09:26,576 --> 00:09:27,216
那么值会及早返回

270
00:09:28,276 --> 00:09:29,776
但是读到这个代码的人

271
00:09:30,066 --> 00:09:31,436
可能会觉得它有歧义

272
00:09:32,356 --> 00:09:33,546
如果人脸数量不是“nil”或“0” 

273
00:09:33,546 --> 00:09:35,656
编程者是否打算

274
00:09:35,656 --> 00:09:37,806
提前返回

275
00:09:38,806 --> 00:09:40,396
分析器现在可以

276
00:09:40,396 --> 00:09:41,546
针对这类歧义发出警告

277
00:09:41,976 --> 00:09:44,446
在这种情况下 编程者

278
00:09:44,446 --> 00:09:47,386
如果想让结果为非 nil  她可以

279
00:09:47,476 --> 00:09:49,136
将她的想法直接在代码中表达出来

280
00:09:49,136 --> 00:09:51,126
并沉默分析器的警告

281
00:09:51,126 --> 00:09:53,476
这可以通过明确地添加比较

282
00:09:53,476 --> 00:09:54,896
来实现

283
00:09:55,456 --> 00:09:59,106
你可以在构建设置中

284
00:09:59,106 --> 00:10:00,316
控制检查

285
00:09:59,106 --> 00:10:00,316
控制检查

286
00:10:00,316 --> 00:10:00,656
等级

287
00:10:01,486 --> 00:10:02,956
如果选择“Yes (Aggressive)”

288
00:10:03,606 --> 00:10:05,566
那么分析器在不确定你是否犯错时

289
00:10:05,566 --> 00:10:06,786
就会生成警告

290
00:10:06,786 --> 00:10:08,486
但是它不认为你的

291
00:10:08,486 --> 00:10:09,326
代码是有歧义的

292
00:10:09,946 --> 00:10:13,696
接下来我们介绍 dispatch_once()

293
00:10:16,076 --> 00:10:17,776
多线程优化技术（GCD）提供

294
00:10:17,866 --> 00:10:20,896
了一个非常棒的 API  dispatch_once()

295
00:10:21,096 --> 00:10:22,306
它保证了一个块

296
00:10:22,306 --> 00:10:24,256
会被调用一次 并且只有一次

297
00:10:24,896 --> 00:10:27,276
它对于安全地

298
00:10:27,276 --> 00:10:28,436
初始化共享全局状态

299
00:10:28,436 --> 00:10:28,836
非常有用

300
00:10:29,946 --> 00:10:31,576
在这个例子中 编程者

301
00:10:32,186 --> 00:10:34,186
利用它加载和初始化

302
00:10:34,186 --> 00:10:36,136
一个共享照片数列

303
00:10:37,616 --> 00:10:39,516
dispatch_once() 的第一个参数

304
00:10:39,516 --> 00:10:41,336
是对一个特殊变量

305
00:10:41,336 --> 00:10:43,176
的声明

306
00:10:43,506 --> 00:10:44,696
dispatch_once_t

307
00:10:45,546 --> 00:10:46,846
GCD 利用这一点

308
00:10:47,156 --> 00:10:48,926
确保代码块

309
00:10:48,926 --> 00:10:51,606
只被调用一次

310
00:10:51,686 --> 00:10:53,846
有一点很重要

311
00:10:53,846 --> 00:10:56,046
就是该变量要么是静态变量

312
00:10:56,266 --> 00:10:57,276
要么是全局变量

313
00:10:58,276 --> 00:10:59,756
这是因为 如果出现

314
00:10:59,756 --> 00:11:01,556
该变量

315
00:10:59,756 --> 00:11:01,556
该变量

316
00:11:01,556 --> 00:11:03,266
过去的值是非零的情况

317
00:11:04,086 --> 00:11:05,206
GCD 可能无法保证

318
00:11:05,426 --> 00:11:06,916
在多线代码中进行

319
00:11:06,916 --> 00:11:09,006
有且只有一次

320
00:11:09,006 --> 00:11:09,986
的执行

321
00:11:10,506 --> 00:11:14,356
也就是说

322
00:11:14,576 --> 00:11:17,306
在实例变量

323
00:11:17,306 --> 00:11:19,146
或其他任何可能

324
00:11:19,146 --> 00:11:21,696
被复用过的堆内存中

325
00:11:22,156 --> 00:11:23,316
使用 dispatch_once_t 是不安全的

326
00:11:23,986 --> 00:11:25,056
所以分析器现在会

327
00:11:25,056 --> 00:11:26,486
因此生成警告

328
00:11:27,296 --> 00:11:29,686
为了解决这个问题 你可以使用你

329
00:11:29,786 --> 00:11:31,496
最爱的非递归锁

330
00:11:32,306 --> 00:11:34,076
这里我使用 NSLock 但你

331
00:11:34,076 --> 00:11:35,916
可以使用 OSUnfairLock 或

332
00:11:35,916 --> 00:11:37,016
pthread_mutex

333
00:11:38,416 --> 00:11:41,316
获取锁后 检查

334
00:11:41,316 --> 00:11:42,346
数据是否已经

335
00:11:42,346 --> 00:11:43,506
初始化 如果没有

336
00:11:43,506 --> 00:11:46,336
对数据进行初始化 不要

337
00:11:46,406 --> 00:11:48,346
忘了释放锁

338
00:11:49,236 --> 00:11:50,706
这样能确保

339
00:11:50,706 --> 00:11:52,376
数据初始化有且只有一次

340
00:11:52,376 --> 00:11:54,056
完全符合你的预期

341
00:11:54,416 --> 00:12:00,026
最后 我向大家

342
00:11:54,416 --> 00:12:00,026
最后 我向大家

343
00:12:00,026 --> 00:12:01,576
介绍我们添加至

344
00:12:01,876 --> 00:12:03,786
NSMutable 类自动综合的

345
00:12:03,786 --> 00:12:05,766
copy 属性的检查

346
00:12:07,236 --> 00:12:09,066
copy 属性利用传入值调用其 setter 的

347
00:12:09,066 --> 00:12:11,096
copy 方法

348
00:12:11,096 --> 00:12:12,976
来构建一个 copy

349
00:12:14,006 --> 00:12:16,736
但是调用 copy 可变数组

350
00:12:16,736 --> 00:12:18,916
会导致 copy

351
00:12:18,916 --> 00:12:19,346
不可变

352
00:12:20,416 --> 00:12:21,166
我来解释一下为什么

353
00:12:21,166 --> 00:12:21,676
这是一个问题

354
00:12:22,606 --> 00:12:25,296
这个方法试图

355
00:12:25,296 --> 00:12:27,306
重置照片属性

356
00:12:27,306 --> 00:12:29,406
通过将其设置为一个空的可变数组

357
00:12:29,406 --> 00:12:31,896
然后添加一张单独的照片来实现

358
00:12:33,196 --> 00:12:34,866
但是 这会导致

359
00:12:34,866 --> 00:12:37,236
运行时出现意外

360
00:12:37,236 --> 00:12:39,856
因为你无法

361
00:12:39,856 --> 00:12:41,766
将一个对象添加至不可变数组

362
00:12:42,596 --> 00:12:43,496
你会获得一个异常

363
00:12:44,056 --> 00:12:46,826
这时分析器会发出警告

364
00:12:46,826 --> 00:12:48,166
告知你这些属性

365
00:12:48,216 --> 00:12:50,156
帮助你防止运行

366
00:12:50,156 --> 00:12:50,666
异常

367
00:12:51,216 --> 00:12:53,666
解决方法很简单

368
00:12:54,116 --> 00:12:55,716
你只须明确写出 setter

369
00:12:55,716 --> 00:12:57,516
使其调用

370
00:12:57,516 --> 00:12:58,626
mutableCopy

371
00:12:59,426 --> 00:13:00,326
这可以确保你的

372
00:12:59,426 --> 00:13:00,326
这可以确保你的

373
00:13:00,326 --> 00:13:02,946
属性始终是可变

374
00:13:02,946 --> 00:13:03,000
数组

375
00:13:06,236 --> 00:13:07,706
以上介绍的就是

376
00:13:07,706 --> 00:13:08,736
今年我们添加至

377
00:13:08,736 --> 00:13:09,746
分析器的 3 种新的检查方法

378
00:13:10,606 --> 00:13:11,776
你应该在代码中些运行一下试试

379
00:13:11,776 --> 00:13:13,186
它们会帮助你找到 Bug

380
00:13:14,556 --> 00:13:16,656
为了使用这个功能 大家可以从

381
00:13:16,656 --> 00:13:17,626
Xcode 的“Product（产品） ”菜单中选择“Analyze（分析）”

382
00:13:19,086 --> 00:13:20,606
你甚至可以让 Xcode 在每次编译中运行

383
00:13:20,606 --> 00:13:23,566
分析器 可以通过

384
00:13:23,566 --> 00:13:25,186
前往构建设置

385
00:13:25,186 --> 00:13:27,096
选择“Analyze During ‘Build’”来实现

386
00:13:27,096 --> 00:13:29,086
这可以帮助你

387
00:13:29,086 --> 00:13:30,336
及早并时常捕捉 Bug

388
00:13:30,976 --> 00:13:33,136
如果你对其他

389
00:13:33,136 --> 00:13:34,626
发现 Bug 的工具感兴趣

390
00:13:34,956 --> 00:13:36,496
我强烈推荐在线观看

391
00:13:36,496 --> 00:13:38,266
“Finding Bugs Using Xcode Runtime Tools

392
00:13:38,266 --> 00:13:39,566
（使用 Xcode 运行时工具寻找 Bug）”

393
00:13:39,566 --> 00:13:41,916
以上介绍的就是我们

394
00:13:41,916 --> 00:13:42,466
在分析器方面的新功能

395
00:13:42,916 --> 00:13:44,616
接下来我把时间交给

396
00:13:44,616 --> 00:13:46,266
Duncan 他会向大家介绍

397
00:13:46,266 --> 00:13:47,316
新的编译器警告功能

398
00:13:48,516 --> 00:13:54,046
[掌声]

399
00:13:54,546 --> 00:13:57,766
&gt;&gt;  谢谢你 Devin

400
00:13:58,576 --> 00:14:00,986
Xcode 9 新增了 100 多个

401
00:13:58,576 --> 00:14:00,986
Xcode 9 新增了 100 多个

402
00:14:00,986 --> 00:14:02,526
错误和警告

403
00:14:02,526 --> 00:14:03,426
来帮助在代码中发现 Bug

404
00:14:03,746 --> 00:14:05,626
接下来我们来说说

405
00:14:05,626 --> 00:14:06,466
两个对 Objective-C 很重要的

406
00:14:06,466 --> 00:14:07,166
警告

407
00:14:09,686 --> 00:14:11,896
在 ARC 中 在块中捕捉大多数参数

408
00:14:11,896 --> 00:14:13,346
都很安全

409
00:14:13,876 --> 00:14:16,356
在这个例子中

410
00:14:16,356 --> 00:14:18,256
validateDictionary(usingChecker)

411
00:14:18,256 --> 00:14:21,036
方法使用了 NSDictionary 并

412
00:14:21,036 --> 00:14:22,716
通过调用

413
00:14:22,716 --> 00:14:24,256
enumerateKeysAndObjectsUsingBlock

414
00:14:24,256 --> 00:14:24,886
访问每个条目

415
00:14:26,336 --> 00:14:28,216
块捕捉 checker

416
00:14:28,216 --> 00:14:28,746
参数

417
00:14:29,466 --> 00:14:30,846
这个方法很安全 而且十分

418
00:14:30,846 --> 00:14:31,096
有效

419
00:14:32,906 --> 00:14:34,796
注意 checkObject forKey

420
00:14:35,066 --> 00:14:35,536
可能会失败

421
00:14:36,376 --> 00:14:38,856
块将 stop 设置为“YES”

422
00:14:38,856 --> 00:14:40,226
提前中止枚举

423
00:14:41,576 --> 00:14:43,546
因为这是一个验证

424
00:14:43,546 --> 00:14:45,016
方法 所以应返回

425
00:14:45,016 --> 00:14:46,546
BOOL 并生成一个 NSError

426
00:14:47,116 --> 00:14:48,066
我们来改一下

427
00:14:49,636 --> 00:14:52,006
一起来看一下这个代码

428
00:14:52,356 --> 00:14:54,196
在枚举之前 将 isValid

429
00:14:54,196 --> 00:14:54,896
设置为“YES”

430
00:14:55,586 --> 00:14:57,716
块运行检查器 并

431
00:14:57,716 --> 00:14:58,856
返回成功

432
00:14:59,906 --> 00:15:02,326
如果检查器失效 isValid

433
00:14:59,906 --> 00:15:02,326
如果检查器失效 isValid

434
00:15:02,326 --> 00:15:04,356
设置为“NO” 一个 NSError

435
00:15:04,356 --> 00:15:04,796
将会产生

436
00:15:06,236 --> 00:15:08,616
枚举后 isValid

437
00:15:08,616 --> 00:15:10,916
返回 但这里有一个

438
00:15:10,916 --> 00:15:11,156
Bug

439
00:15:12,596 --> 00:15:14,626
输出参数 比如错误

440
00:15:14,626 --> 00:15:16,066
是隐性自动发布的

441
00:15:16,676 --> 00:15:18,826
在块中为它们赋值

442
00:15:19,566 --> 00:15:20,316
是不安全的

443
00:15:20,926 --> 00:15:22,266
enumerateKeysAndObjectsUsingBlock

444
00:15:22,266 --> 00:15:24,236
调用自动发布池

445
00:15:24,236 --> 00:15:25,586
中的块

446
00:15:26,536 --> 00:15:28,476
当返回时 NSError

447
00:15:28,476 --> 00:15:29,696
同时会被销毁

448
00:15:30,416 --> 00:15:31,796
这个方法不安全

449
00:15:32,316 --> 00:15:36,336
在 Xcode 9 中 这个不安全捕捉

450
00:15:36,336 --> 00:15:37,266
会触发警告

451
00:15:38,496 --> 00:15:40,696
最简单的解决方案是使

452
00:15:40,696 --> 00:15:41,866
输出参数变成

453
00:15:41,866 --> 00:15:42,496
强引用

454
00:15:43,156 --> 00:15:44,576
这样方法能使值

455
00:15:44,816 --> 00:15:46,606
在任何自动发布池中一直存在

456
00:15:47,856 --> 00:15:49,286
这个方法能一直奏效 只要

457
00:15:49,286 --> 00:15:50,876
validateDictionaryUsingChecker 的所有调用器

458
00:15:50,876 --> 00:15:52,496
在使用 ARC

459
00:15:54,026 --> 00:15:55,556
另一个选择是使用

460
00:15:55,556 --> 00:15:56,756
本地块变量

461
00:15:57,836 --> 00:16:00,036
在这个方法中 strongError（强错误）被初始化为

462
00:15:57,836 --> 00:16:00,036
在这个方法中 strongError（强错误）被初始化为

463
00:16:00,036 --> 00:16:00,406
“nil”

464
00:16:01,126 --> 00:16:03,316
如果枚举很早结束

465
00:16:03,566 --> 00:16:05,886
strongError 会安全地存储

466
00:16:05,886 --> 00:16:06,226
NSError

467
00:16:07,466 --> 00:16:09,186
然后 输出参数

468
00:16:09,186 --> 00:16:11,056
在枚举完成之后

469
00:16:11,056 --> 00:16:11,516
完成升级

470
00:16:12,006 --> 00:16:14,816
这是第一个警告

471
00:16:15,656 --> 00:16:16,676
接下来我们介绍第二个警告

472
00:16:17,976 --> 00:16:19,786
在这个例子中 foo() 函数

473
00:16:19,786 --> 00:16:21,476
声明没有任何

474
00:16:21,476 --> 00:16:22,106
参数

475
00:16:23,686 --> 00:16:25,876
在 C 和 Objective-C 中 这意味着

476
00:16:25,876 --> 00:16:27,296
foo() 可以和

477
00:16:27,296 --> 00:16:28,976
任何数或参数类调用

478
00:16:30,026 --> 00:16:31,236
参数列表为空的函数

479
00:16:31,236 --> 00:16:32,696
叫做

480
00:16:32,696 --> 00:16:34,366
非原型声明

481
00:16:35,646 --> 00:16:36,926
这个行为可以追溯至

482
00:16:36,996 --> 00:16:38,886
C 语言早期 当时参数

483
00:16:38,886 --> 00:16:40,256
只列在函数

484
00:16:40,256 --> 00:16:41,716
定义里 但是这个

485
00:16:41,716 --> 00:16:43,496
声明对于类来说并不安全

486
00:16:44,026 --> 00:16:45,416
这绝对不会是

487
00:16:45,416 --> 00:16:45,766
你想要的

488
00:16:46,446 --> 00:16:47,406
不匹配定义的调用

489
00:16:47,406 --> 00:16:49,826
会导致运行时崩溃

490
00:16:50,796 --> 00:16:52,866
在 Xcode 9 中 编译器带有一个

491
00:16:52,866 --> 00:16:54,416
新的警告 加强严格

492
00:16:54,416 --> 00:16:55,026
原型

493
00:16:57,696 --> 00:17:00,126
通常 解决方法是添加空

494
00:16:57,696 --> 00:17:00,126
通常 解决方法是添加空

495
00:17:00,806 --> 00:17:02,656
也就是“0”

496
00:17:02,656 --> 00:17:03,366
参数

497
00:17:03,766 --> 00:17:05,496
任何带有参数的调用都会

498
00:17:05,496 --> 00:17:06,116
引发错误

499
00:17:07,656 --> 00:17:08,965
由于函数指针和块

500
00:17:08,965 --> 00:17:10,756
对于函数有

501
00:17:10,756 --> 00:17:12,796
公用声明语法函数

502
00:17:12,796 --> 00:17:14,086
如果你有以块作为

503
00:17:14,086 --> 00:17:15,896
参数的函数或者方法

504
00:17:15,896 --> 00:17:16,976
你也会看到这个

505
00:17:18,236 --> 00:17:19,836
解决方法和

506
00:17:19,836 --> 00:17:20,955
函数声明一样

507
00:17:21,445 --> 00:17:23,715
添加空 明确规定“0”

508
00:17:23,715 --> 00:17:24,496
参数

509
00:17:25,346 --> 00:17:26,846
这样 如果你输入

510
00:17:26,846 --> 00:17:28,566
错误类的块 你就会得到一个

511
00:17:29,456 --> 00:17:29,566
错误

512
00:17:30,256 --> 00:17:32,286
Xcode 的现代化项目

513
00:17:32,366 --> 00:17:33,826
会在构建设置中开启这些警告

514
00:17:33,826 --> 00:17:35,816
或者你可以

515
00:17:35,846 --> 00:17:37,356
随后通过选择项目

516
00:17:37,356 --> 00:17:39,026
在“Editor（编辑器）”菜单中选择

517
00:17:39,026 --> 00:17:40,346
“Validate Settings（验证设置）”进行升级

518
00:17:40,916 --> 00:17:43,816
你还可以

519
00:17:43,816 --> 00:17:45,486
通过在构建设置中

520
00:17:45,676 --> 00:17:47,266
选择“Yes (Error)” 

521
00:17:47,266 --> 00:17:47,716
升级新的错误警告

522
00:17:49,196 --> 00:17:50,146
以上就是今天关于新的

523
00:17:50,146 --> 00:17:50,706
警告功能的介绍

524
00:17:52,146 --> 00:17:53,516
接下来我们介绍 C++

525
00:17:55,036 --> 00:17:57,466
今年 我们做了很多工作

526
00:17:57,466 --> 00:17:59,286
来改善

527
00:17:59,286 --> 00:18:00,426
Xcode 中的 C++ 体验

528
00:17:59,286 --> 00:18:00,426
Xcode 中的 C++ 体验

529
00:18:01,856 --> 00:18:02,996
包括重构

530
00:18:02,996 --> 00:18:03,426
支持

531
00:18:04,106 --> 00:18:05,866
我们支持很多操作

532
00:18:06,406 --> 00:18:08,286
我带领大家简单了解一下

533
00:18:08,286 --> 00:18:10,536
利用 Xcode 重构 LLVM 的流程

534
00:18:10,536 --> 00:18:13,976
这是一个大型 C++ 代码库

535
00:18:13,976 --> 00:18:15,076
这个是其引擎

536
00:18:16,336 --> 00:18:18,316
但即使你不是一个 C++

537
00:18:18,316 --> 00:18:19,796
开发人员 你仍然可以

538
00:18:19,796 --> 00:18:21,596
了解 Xcode 重构

539
00:18:21,626 --> 00:18:23,096
如何能够改善你的

540
00:18:23,096 --> 00:18:23,336
工作流

541
00:18:23,906 --> 00:18:27,136
我以 InstCombiner 类的

542
00:18:27,136 --> 00:18:28,646
一个成员函数定义

543
00:18:28,646 --> 00:18:29,146
开始

544
00:18:30,276 --> 00:18:31,746
这是组合指令的一个

545
00:18:31,746 --> 00:18:32,466
实用程序

546
00:18:33,766 --> 00:18:35,546
我一直不喜欢

547
00:18:35,546 --> 00:18:37,376
指令的缩写形式 Inst  所以我

548
00:18:37,376 --> 00:18:39,026
在 Xcode 里按住 Command 键点按它

549
00:18:39,026 --> 00:18:39,796
并选择“Rename（重命名）”

550
00:18:41,686 --> 00:18:43,576
即使我不是在类声明中

551
00:18:43,576 --> 00:18:44,746
这个方法依然有效

552
00:18:46,446 --> 00:18:48,026
我觉得指令组合这个名称

553
00:18:48,026 --> 00:18:48,516
更加清楚

554
00:18:50,416 --> 00:18:52,406
Xcode 更新了一个合适的名称

555
00:18:52,406 --> 00:18:53,856
让我节省了很多

556
00:18:53,856 --> 00:18:54,096
寻找的时间

557
00:18:54,726 --> 00:18:57,096
我再次确认了类

558
00:18:57,096 --> 00:18:57,736
声明

559
00:18:58,266 --> 00:18:59,266
它也升级了

560
00:19:00,346 --> 00:19:02,846
它在 CRTP 基类中的使用也升级了

561
00:19:02,846 --> 00:19:04,216
变成了 InstVisitor

562
00:19:05,556 --> 00:19:07,496
InstVisitor 使用一样的

563
00:19:07,496 --> 00:19:08,746
缩写

564
00:19:08,806 --> 00:19:10,036
InstCombineWorklist 也是

565
00:19:10,636 --> 00:19:11,726
但是这方面我最好留待

566
00:19:11,726 --> 00:19:12,336
下一次再介绍

567
00:19:14,216 --> 00:19:15,796
鉴于我们可以改变一个类的

568
00:19:15,796 --> 00:19:17,046
成员函数的名称

569
00:19:17,046 --> 00:19:18,766
我接着操作

570
00:19:18,796 --> 00:19:19,856
更加复杂的流程

571
00:19:20,596 --> 00:19:21,556
这是一个模板

572
00:19:21,556 --> 00:19:23,176
特化的简化类

573
00:19:23,176 --> 00:19:26,026
一个用于智能

574
00:19:26,026 --> 00:19:27,646
指针和自定义迭代器上的实用程序

575
00:19:28,156 --> 00:19:30,746
我认为 getSimplifiedValue()

576
00:19:30,816 --> 00:19:32,956
函数的命名

577
00:19:32,956 --> 00:19:33,406
是错误的

578
00:19:34,066 --> 00:19:35,626
它应该使用 STL 命名

579
00:19:35,626 --> 00:19:37,396
惯例 正如它的类的名称一样

580
00:19:38,416 --> 00:19:39,526
我再次选择“Rename”

581
00:19:40,886 --> 00:19:42,056
从项目中将模板特化

582
00:19:42,056 --> 00:19:43,826
绑到一起

583
00:19:43,826 --> 00:19:46,146
很复杂 但是

584
00:19:46,146 --> 00:19:47,586
Xcode 可以处理

585
00:19:48,256 --> 00:19:50,466
这个特化

586
00:19:50,466 --> 00:19:52,656
之前升级过

587
00:19:52,656 --> 00:19:53,846
主要模板声明也升级过

588
00:19:54,996 --> 00:19:56,326
这下面还有另一个特化

589
00:19:56,326 --> 00:19:58,246
也经过了

590
00:19:58,926 --> 00:19:59,000
修正

591
00:20:01,396 --> 00:20:03,386
接下来 我们来到 Constants.h

592
00:20:03,676 --> 00:20:04,856
这里有个类叫做

593
00:20:04,896 --> 00:20:06,556
ConstantInt 代表

594
00:20:06,736 --> 00:20:07,616
常量整数

595
00:20:08,736 --> 00:20:09,816
这个类拥有便利

596
00:20:09,816 --> 00:20:11,476
函数 能够得到真值和

597
00:20:11,476 --> 00:20:12,466
假值

598
00:20:13,666 --> 00:20:15,516
我给 getMax() 函数

599
00:20:15,516 --> 00:20:17,406
添加了声明 以得到

600
00:20:17,406 --> 00:20:18,816
最大整数值

601
00:20:20,296 --> 00:20:21,976
然后我按住 Command 键并点按

602
00:20:21,976 --> 00:20:23,146
为它们生成缺失的

603
00:20:23,146 --> 00:20:26,086
函数定义

604
00:20:26,686 --> 00:20:28,476
这时它们在 Constants.cpp 中

605
00:20:29,576 --> 00:20:31,486
我喜欢它的地方在于

606
00:20:31,486 --> 00:20:32,666
函数显示在

607
00:20:32,666 --> 00:20:33,076
文件夹中的位置

608
00:20:34,276 --> 00:20:35,556
我的新定义

609
00:20:35,556 --> 00:20:37,356
在上一个成员

610
00:20:37,356 --> 00:20:38,926
函数定义为同一类 ConstantInt 之后生成

611
00:20:38,926 --> 00:20:42,186
但在成员函数

612
00:20:42,186 --> 00:20:43,476
定义为另一个类之前

613
00:20:43,476 --> 00:20:44,196
生成

614
00:20:45,496 --> 00:20:46,996
这也正是我想要的

615
00:20:46,996 --> 00:20:47,196
结果

616
00:20:48,516 --> 00:20:53,826
[掌声]

617
00:20:54,326 --> 00:20:56,006
LLVM 有很多代表整数

618
00:20:56,006 --> 00:20:57,076
的代码

619
00:20:57,626 --> 00:20:58,896
我看了下这个最大

620
00:20:58,896 --> 00:21:00,636
公约数函数 然后

621
00:20:58,896 --> 00:21:00,636
公约数函数 然后

622
00:21:00,636 --> 00:21:02,996
注意到一个本地变量 Pow2

623
00:21:02,996 --> 00:21:03,916
它的计算

624
00:21:03,916 --> 00:21:04,466
非常复杂

625
00:21:05,836 --> 00:21:07,686
这个计算真的应该归入

626
00:21:07,686 --> 00:21:08,546
它自己的函数

627
00:21:10,346 --> 00:21:11,856
我挑了一些代码 打开

628
00:21:11,856 --> 00:21:13,566
上下文菜单

629
00:21:13,566 --> 00:21:15,276
点按“Extract Function（提取函数）”

630
00:21:15,276 --> 00:21:17,156
挑选过程比较马虎

631
00:21:17,156 --> 00:21:19,016
但是 Xcode 很聪明

632
00:21:19,016 --> 00:21:20,136
还是奏效了

633
00:21:21,466 --> 00:21:23,116
这样我就直接进入了

634
00:21:23,116 --> 00:21:24,266
屏幕底部的

635
00:21:24,266 --> 00:21:24,656
重命名

636
00:21:25,466 --> 00:21:27,976
我选择 countCommonPowersOf2

637
00:21:29,276 --> 00:21:30,496
我们向上滚动 看一下这个

638
00:21:30,496 --> 00:21:31,036
定义

639
00:21:31,776 --> 00:21:33,886
这个关键就是

640
00:21:33,886 --> 00:21:35,626
参数 A 和 B

641
00:21:35,656 --> 00:21:36,926
是自动

642
00:21:36,926 --> 00:21:37,626
被引用捕捉的

643
00:21:38,696 --> 00:21:40,286
这一点很重要因为它们

644
00:21:40,286 --> 00:21:41,046
正在被修改

645
00:21:41,826 --> 00:21:45,206
提取函数纠正了这个问题

646
00:21:45,856 --> 00:21:47,336
提取这个函数是一个

647
00:21:47,336 --> 00:21:49,336
利用提前返回

648
00:21:49,336 --> 00:21:50,996
清理代码的好机会

649
00:21:53,496 --> 00:21:55,466
我很开心

650
00:21:55,466 --> 00:21:56,996
我在循环展开的

651
00:21:56,996 --> 00:21:58,386
优化程序中发现了

652
00:21:58,386 --> 00:21:58,866
这个代码

653
00:21:59,976 --> 00:22:02,666
我在一个 if 语句中

654
00:21:59,976 --> 00:22:02,666
我在一个 if 语句中

655
00:22:02,736 --> 00:22:03,686
发现了 getLoopFor() 的调用

656
00:22:05,066 --> 00:22:06,586
这个相同的函数再次被调用

657
00:22:06,586 --> 00:22:08,696
为相同的参数 就在下面的

658
00:22:08,696 --> 00:22:11,206
一个 while 循环中

659
00:22:11,776 --> 00:22:13,446
getLoopFor 做了一个散列表

660
00:22:13,446 --> 00:22:14,786
查询 这并不容易

661
00:22:15,596 --> 00:22:17,146
因为 while 循环不

662
00:22:17,146 --> 00:22:18,816
改变散列表

663
00:22:18,816 --> 00:22:20,446
我按住 Command 键点击它 选择

664
00:22:20,546 --> 00:22:22,356
“Extract Repeated Expression（提取重复表达）”

665
00:22:24,286 --> 00:22:25,526
这个方法将

666
00:22:25,526 --> 00:22:27,056
函数调用的结果存储在本地

667
00:22:27,056 --> 00:22:28,896
变量中 所以只调用

668
00:22:28,896 --> 00:22:30,636
一次 接着我马上使用

669
00:22:30,636 --> 00:22:31,676
重命名

670
00:22:32,286 --> 00:22:35,036
我选择了 LoopLatch 这个名称

671
00:22:35,606 --> 00:22:37,566
很简单

672
00:22:38,066 --> 00:22:39,856
提取和重命名

673
00:22:39,856 --> 00:22:40,256
放在一起很清晰

674
00:22:42,676 --> 00:22:44,706
重构之后 我

675
00:22:44,706 --> 00:22:45,846
觉得我需要写一些新的代码

676
00:22:47,266 --> 00:22:48,856
ArrayRef 是一个

677
00:22:48,856 --> 00:22:50,526
连续值的泛化引用

678
00:22:50,996 --> 00:22:52,776
无论是在 STL 矢量中

679
00:22:52,886 --> 00:22:54,806
还是在 LLVM 自定义数据

680
00:22:54,806 --> 00:22:55,466
结构中

681
00:22:56,466 --> 00:22:58,016
注意 ArrayRef

682
00:22:58,016 --> 00:22:59,886
数组中数值类的

683
00:22:59,886 --> 00:23:00,286
模版化

684
00:22:59,886 --> 00:23:00,286
模版化

685
00:23:01,356 --> 00:23:03,116
我认为

686
00:23:03,116 --> 00:23:04,626
比较两组 ArrayRefs 应该是有用的

687
00:23:05,486 --> 00:23:06,886
为什么不执行一个

688
00:23:06,886 --> 00:23:07,476
字符串一样的比较呢

689
00:23:08,466 --> 00:23:09,896
我需要从零循环至

690
00:23:09,896 --> 00:23:11,416
左右之间

691
00:23:11,416 --> 00:23:12,766
的最小值

692
00:23:13,586 --> 00:23:14,756
当我点击

693
00:23:14,756 --> 00:23:16,796
左边后面的点时 代码完成

694
00:23:16,796 --> 00:23:17,276
开始生效

695
00:23:18,286 --> 00:23:20,666
请记住 左边是

696
00:23:20,706 --> 00:23:21,886
<T> 的模板化

697
00:23:22,366 --> 00:23:24,866
很酷

698
00:23:25,626 --> 00:23:27,676
代码完成可以利用

699
00:23:27,676 --> 00:23:29,716
模板 这是 Xcode 9 的新功能

700
00:23:30,516 --> 00:23:36,226
[掌声]

701
00:23:36,726 --> 00:23:38,526
这就是 Xcode 的 C++ 重构和

702
00:23:38,526 --> 00:23:39,966
代码完成

703
00:23:40,316 --> 00:23:43,226
接下来我们来谈一谈

704
00:23:43,226 --> 00:23:44,926
C++17 标准的新特点

705
00:23:45,436 --> 00:23:49,056
我会从 STL 的元组开始

706
00:23:49,056 --> 00:23:51,476
这个类来自于 C++11 非常有用

707
00:23:51,476 --> 00:23:53,166
它支持多个返回值

708
00:23:54,126 --> 00:23:55,536
但是对它进行分解很麻烦

709
00:23:56,386 --> 00:23:58,176
分解需要

710
00:23:58,176 --> 00:24:00,706
变量连结 类型

711
00:23:58,176 --> 00:24:00,706
变量连结 类型

712
00:24:00,706 --> 00:24:02,716
无法推理

713
00:24:02,716 --> 00:24:03,856
变量的名称需要

714
00:24:03,856 --> 00:24:04,486
复制

715
00:24:05,746 --> 00:24:07,906
C++17 通过

716
00:24:07,906 --> 00:24:10,136
结构化绑定解决了这个问题

717
00:24:10,136 --> 00:24:11,676
它将名称直接和

718
00:24:11,836 --> 00:24:12,886
返回元组元素绑定

719
00:24:14,666 --> 00:24:16,066
这个功能很棒

720
00:24:16,226 --> 00:24:17,436
有了这个方法

721
00:24:17,436 --> 00:24:18,126
利用元组将变得容易得多

722
00:24:18,706 --> 00:24:20,016
结构化绑定可以运用在

723
00:24:20,016 --> 00:24:21,526
很多方面

724
00:24:22,246 --> 00:24:23,976
它还可以以创新的方法

725
00:24:24,016 --> 00:24:25,316
运用在旧式数据类上 比如

726
00:24:25,416 --> 00:24:25,676
Point

727
00:24:26,726 --> 00:24:28,476
语法和

728
00:24:28,476 --> 00:24:29,316
元组完全一样

729
00:24:29,596 --> 00:24:32,486
以上是结构化绑定

730
00:24:33,136 --> 00:24:35,656
另一个功能是

731
00:24:35,656 --> 00:24:36,586
if 语句中的初始化

732
00:24:38,216 --> 00:24:39,006
这里举个例子

733
00:24:39,806 --> 00:24:41,656
初始化程序

734
00:24:41,656 --> 00:24:43,176
在路径字符串中找到了最后的斜杠

735
00:24:43,876 --> 00:24:45,616
斜杠变量范围

736
00:24:45,616 --> 00:24:46,906
限定在 if 语句中

737
00:24:48,626 --> 00:24:50,016
接着 条件检查

738
00:24:50,176 --> 00:24:51,456
斜杠是否被找到

739
00:24:52,926 --> 00:24:55,296
如果找到的话 斜杠将被用于

740
00:24:55,296 --> 00:24:57,556
切分路径

741
00:24:58,036 --> 00:24:59,086
这个功能也一样适用于

742
00:24:59,086 --> 00:24:59,906
switch 语句

743
00:25:01,406 --> 00:25:02,786
最小化斜杠变量

744
00:25:02,786 --> 00:25:04,946
的范围有助于防止

745
00:25:04,946 --> 00:25:05,406
Bug

746
00:25:06,136 --> 00:25:07,656
如果函数继续

747
00:25:07,896 --> 00:25:09,606
如果我们尝试复用斜杠变量

748
00:25:09,666 --> 00:25:11,086
会得到一个错误

749
00:25:11,926 --> 00:25:13,866
这是好事 因为逻辑上这

750
00:25:13,866 --> 00:25:14,506
是不相关的

751
00:25:15,026 --> 00:25:18,756
接下来我们介绍

752
00:25:18,756 --> 00:25:19,806
模板化函数的一个功能

753
00:25:21,556 --> 00:25:23,356
Advance 是一个简单的

754
00:25:23,356 --> 00:25:24,736
先行迭代器的模板

755
00:25:24,736 --> 00:25:25,226
算法

756
00:25:26,006 --> 00:25:27,446
它已经配置在 STL 中很长时间了

757
00:25:27,446 --> 00:25:29,546
今天我们把它作为

758
00:25:29,546 --> 00:25:30,076
一个例子

759
00:25:31,166 --> 00:25:32,616
一个大于 0 的 n 它推动

760
00:25:32,616 --> 00:25:35,086
迭代器向前 一个小于 0 的 n 

761
00:25:35,086 --> 00:25:36,076
它使

762
00:25:36,076 --> 00:25:37,566
迭代器后退

763
00:25:38,776 --> 00:25:40,536
比如 你有时候可能想

764
00:25:40,536 --> 00:25:42,376
在一张链表中

765
00:25:42,376 --> 00:25:43,036
预先查看 5 个节点

766
00:25:43,766 --> 00:25:45,546
Advance 会一个一个

767
00:25:45,546 --> 00:25:46,026
向前计数

768
00:25:47,936 --> 00:25:50,406
相同的代码也可以用来得到

769
00:25:50,406 --> 00:25:51,706
一个字符串的第五个字符

770
00:25:52,346 --> 00:25:53,826
用相同的接口

771
00:25:53,826 --> 00:25:55,496
在两个数据结构中先行 

772
00:25:55,496 --> 00:25:56,276
效果很好

773
00:25:57,486 --> 00:25:59,656
但是这个代码

774
00:25:59,656 --> 00:26:00,236
在字符串中运行很慢

775
00:25:59,656 --> 00:26:00,236
在字符串中运行很慢

776
00:26:00,676 --> 00:26:02,156
对于有随机访问迭代器的

777
00:26:02,156 --> 00:26:03,976
数组字符串

778
00:26:03,976 --> 00:26:04,616
我们不需要循环

779
00:26:05,416 --> 00:26:06,946
Operator + 会跳转到

780
00:26:06,946 --> 00:26:07,636
概念时

781
00:26:08,186 --> 00:26:11,516
但是添加一个简单的 if 语句

782
00:26:11,516 --> 00:26:13,116
没有效果 因为它只是一个

783
00:26:13,156 --> 00:26:14,076
运行时检查

784
00:26:15,196 --> 00:26:17,146
它的主体需要

785
00:26:17,146 --> 00:26:19,166
为所有模板实例化进行编译

786
00:26:19,506 --> 00:26:21,016
但是链表迭代器不能

787
00:26:21,016 --> 00:26:22,516
配置 Operator +

788
00:26:23,016 --> 00:26:25,766
我们面临一个问题

789
00:26:27,246 --> 00:26:29,246
Advance 需要一个通用接口

790
00:26:29,246 --> 00:26:30,906
为链表和字符串

791
00:26:31,696 --> 00:26:34,386
和数组的快速路径

792
00:26:34,566 --> 00:26:34,666
进行编译

793
00:26:34,966 --> 00:26:36,206
经典解决方法是

794
00:26:36,206 --> 00:26:37,666
一种叫做编译时

795
00:26:37,666 --> 00:26:39,366
派发的技术 其逻辑被

796
00:26:39,366 --> 00:26:40,686
分解成过载帮助函数

797
00:26:40,686 --> 00:26:42,436
且 Advance 基于

798
00:26:42,436 --> 00:26:44,146
编译时类特性调用

799
00:26:44,146 --> 00:26:45,426
合适的过载

800
00:26:45,946 --> 00:26:48,496
编译时派发是有效的

801
00:26:48,866 --> 00:26:50,566
它也是 C++ 库的作者们

802
00:26:50,566 --> 00:26:51,656
努力工作了几十年的成果

803
00:26:52,816 --> 00:26:54,236
即使这是一个很先进的技术

804
00:26:54,536 --> 00:26:55,986
我们要做的却

805
00:26:56,036 --> 00:26:56,566
非常简单

806
00:26:58,276 --> 00:27:00,376
原先无效的代码

807
00:26:58,276 --> 00:27:00,376
原先无效的代码

808
00:27:00,586 --> 00:27:01,746
其实也很容易理解

809
00:27:03,016 --> 00:27:06,876
在 C++17 中 constexpr if 可以让

810
00:27:06,876 --> 00:27:08,076
你很自然地表达这个

811
00:27:08,316 --> 00:27:08,906
逻辑

812
00:27:10,826 --> 00:27:12,796
constexpr if 在实例化模板时

813
00:27:12,796 --> 00:27:14,276
删除了不用的路径

814
00:27:14,276 --> 00:27:16,256
所以链表代码

815
00:27:16,256 --> 00:27:18,896
会继续编译 但是 Advance

816
00:27:18,896 --> 00:27:20,276
会使用字符串和数组的

817
00:27:20,276 --> 00:27:22,586
快速路径

818
00:27:23,266 --> 00:27:25,616
constexpr if 使得阅读和

819
00:27:25,616 --> 00:27:27,636
书写通用代码

820
00:27:27,636 --> 00:27:28,006
变得更加简单

821
00:27:30,956 --> 00:27:32,726
最后在结束之前 我们介绍一个新的

822
00:27:32,726 --> 00:27:34,016
字符串程序库功能

823
00:27:35,276 --> 00:27:38,146
STL 字符串类有着丰富的

824
00:27:38,146 --> 00:27:40,136
API 但它并不一直是

825
00:27:40,136 --> 00:27:40,656
合适的工具

826
00:27:41,716 --> 00:27:43,136
这个例子可能看起来

827
00:27:43,136 --> 00:27:43,636
有点眼熟

828
00:27:44,486 --> 00:27:46,456
这个函数切分用于寻找

829
00:27:46,456 --> 00:27:48,036
路径参数的最后一个

830
00:27:48,036 --> 00:27:48,456
斜杠

831
00:27:48,996 --> 00:27:51,816
如果它找到斜杠 它会将

832
00:27:51,816 --> 00:27:53,686
路径切分为目录和

833
00:27:53,686 --> 00:27:54,236
文件名

834
00:27:55,556 --> 00:27:57,116
当没有斜杠时 它会将

835
00:27:57,116 --> 00:27:58,466
完整路径返回至文件名

836
00:27:59,996 --> 00:28:02,436
由于字符串的 API

837
00:27:59,996 --> 00:28:02,436
由于字符串的 API

838
00:28:02,436 --> 00:28:04,386
这个代码很容易编写

839
00:28:04,866 --> 00:28:06,126
但是有性能方面的

840
00:28:06,126 --> 00:28:06,436
问题

841
00:28:07,836 --> 00:28:09,986
切分返回了

842
00:28:09,986 --> 00:28:10,386
字符串的 copy 

843
00:28:11,586 --> 00:28:12,986
大量使用函数 比如 split()

844
00:28:12,986 --> 00:28:15,046
可能引发昂贵的

845
00:28:15,046 --> 00:28:15,776
配置问题

846
00:28:17,686 --> 00:28:20,206
C++17 有一个

847
00:28:20,206 --> 00:28:21,266
引用字符串的新功能

848
00:28:22,206 --> 00:28:23,106
叫做字符串视图

849
00:28:24,396 --> 00:28:26,076
字符串视图封装未处理的

850
00:28:26,076 --> 00:28:27,266
const char * 和

851
00:28:27,266 --> 00:28:27,876
size_t

852
00:28:29,066 --> 00:28:30,666
它有丰富的 API

853
00:28:30,666 --> 00:28:32,486
就像字符串一样 所以很方便用于

854
00:28:32,486 --> 00:28:33,426
字符串处理

855
00:28:34,856 --> 00:28:36,476
而且顾名思义

856
00:28:36,506 --> 00:28:37,046
它只是一个视图

857
00:28:37,936 --> 00:28:40,106
它没有任何存储

858
00:28:40,106 --> 00:28:43,036
所以永远无法生成 copy

859
00:28:43,486 --> 00:28:44,706
字符串视图

860
00:28:44,706 --> 00:28:46,286
性能很好 但是

861
00:28:46,286 --> 00:28:48,866
有一个问题 字符串并不永远

862
00:28:48,866 --> 00:28:49,406
都是安全的

863
00:28:51,156 --> 00:28:52,306
因为它没有自己的

864
00:28:52,306 --> 00:28:54,426
存储 在原始字符串破坏或修改后

865
00:28:54,456 --> 00:28:56,036
使用字符串视图

866
00:28:56,036 --> 00:28:58,206
可能引发

867
00:28:58,206 --> 00:28:59,236
UAF 问题

868
00:29:01,336 --> 00:29:02,876
引用原始字符串文字 如“resources/images”

869
00:29:02,946 --> 00:29:05,936
一直很安全

870
00:29:05,936 --> 00:29:08,396
因为原始字符串文字

871
00:29:08,426 --> 00:29:09,306
有程序生命

872
00:29:09,306 --> 00:29:09,826
周期

873
00:29:12,036 --> 00:29:13,146
将字符串视图

874
00:29:13,146 --> 00:29:15,556
作为参数是安全的 但是需要避免

875
00:29:15,556 --> 00:29:16,956
越过函数返回

876
00:29:17,086 --> 00:29:18,336
存储字符串视图参数

877
00:29:21,056 --> 00:29:23,286
注意返回值

878
00:29:23,826 --> 00:29:25,466
如果字符串视图来自

879
00:29:25,466 --> 00:29:26,916
一个参数 那么使用它很安全

880
00:29:26,916 --> 00:29:28,406
只要参数

881
00:29:28,576 --> 00:29:30,046
不改变或不受到损坏

882
00:29:31,186 --> 00:29:32,956
在这个例子里 使用目录和

883
00:29:32,956 --> 00:29:35,446
文件名十分安全 只要

884
00:29:35,446 --> 00:29:38,236
路径保持不变

885
00:29:38,236 --> 00:29:38,616
保持有效

886
00:29:39,126 --> 00:29:42,546
但如果我们用计算字符串代替路径

887
00:29:42,546 --> 00:29:44,806
那么访问

888
00:29:44,916 --> 00:29:46,666
目录或文件

889
00:29:46,746 --> 00:29:48,216
都会引起 UAF 问题

890
00:29:49,816 --> 00:29:52,226
根本原因在于切分

891
00:29:52,226 --> 00:29:53,476
越过了临时对象

892
00:29:54,136 --> 00:29:56,006
切分调用之后临时对象被损坏

893
00:29:56,006 --> 00:29:57,566
而且其引用

894
00:29:57,566 --> 00:29:59,116
变得无效

895
00:30:01,156 --> 00:30:03,276
访问临时对象会引起

896
00:30:03,276 --> 00:30:04,316
不明确的行为

897
00:30:05,156 --> 00:30:06,696
AddressSanitizer 可以捕捉这个

898
00:30:06,746 --> 00:30:06,966
Bug

899
00:30:08,176 --> 00:30:09,706
大家可以观看“Understanding Undefined Behavior”

900
00:30:09,706 --> 00:30:11,226
了解更多关于这种 Bug 的信息

901
00:30:11,226 --> 00:30:13,196
还可以观看

902
00:30:13,196 --> 00:30:15,236
“Finding Bugs Using Xcode Runtime Tools”

903
00:30:15,236 --> 00:30:16,656
了解处理 Bug 的

904
00:30:16,916 --> 00:30:17,000
工具

905
00:30:18,476 --> 00:30:20,386
字符串视图是我今天

906
00:30:20,386 --> 00:30:21,526
和大家分享的 C++17 的最后一个功能

907
00:30:22,656 --> 00:30:26,426
为了测试 C++17

908
00:30:26,426 --> 00:30:27,996
在你的构建设置中

909
00:30:27,996 --> 00:30:28,456
设置 C++ 语言

910
00:30:29,236 --> 00:30:32,086
C++17 为你提供

911
00:30:32,086 --> 00:30:33,786
没有扩展名的标准化语言

912
00:30:34,646 --> 00:30:37,056
GNU++17 添加了常用的

913
00:30:37,056 --> 00:30:37,716
拓展名

914
00:30:38,216 --> 00:30:40,726
现在 我快速地给大家介绍一下

915
00:30:40,726 --> 00:30:41,766
关于链接时优化的更新

916
00:30:43,136 --> 00:30:45,196
链接时优化 或简称 LTO

917
00:30:45,826 --> 00:30:47,576
在链接时间内优化

918
00:30:47,576 --> 00:30:49,386
可执行文件模糊

919
00:30:49,386 --> 00:30:50,716
源文件之间的界限

920
00:30:50,716 --> 00:30:52,106
支持优化最大化

921
00:30:53,076 --> 00:30:54,516
去年我们介绍的

922
00:30:54,516 --> 00:30:55,996
增量式 LTO

923
00:30:55,996 --> 00:30:56,866
已经代表了目前的最新技术水平

924
00:30:57,766 --> 00:30:59,636
想要了解更多信息 请观看去年

925
00:30:59,636 --> 00:31:01,176
“What’s New in LLVM”的相关视频

926
00:30:59,636 --> 00:31:01,176
“What’s New in LLVM”的相关视频

927
00:31:02,146 --> 00:31:06,036
过去 在大型 C++ 程序中

928
00:31:06,036 --> 00:31:08,346
使用 LTO 时 我们推荐更改

929
00:31:08,346 --> 00:31:10,476
Debug Info Level Build

930
00:31:10,476 --> 00:31:12,906
设置为

931
00:31:12,906 --> 00:31:13,746
Line Tables Only

932
00:31:14,846 --> 00:31:16,306
但是在 Xcode 9 中 我们将

933
00:31:16,306 --> 00:31:17,946
增量式 LTO 的技术

934
00:31:17,946 --> 00:31:18,356
提升到了一个新的水平

935
00:31:19,666 --> 00:31:20,926
我们一起来看看链接

936
00:31:20,996 --> 00:31:23,296
Apple LLVM 编译器所需要的时间

937
00:31:24,166 --> 00:31:26,716
在 Xcode 8 中 一个有着完整调试信息的干净链接

938
00:31:26,716 --> 00:31:28,596
需要 6 分钟 

939
00:31:28,596 --> 00:31:29,056
的时间

940
00:31:29,706 --> 00:31:30,796
Line Tables Only 快了

941
00:31:30,796 --> 00:31:32,296
3.5 分钟

942
00:31:33,706 --> 00:31:35,506
Xcode 9 中配备完整调试信息

943
00:31:35,506 --> 00:31:38,266
的增量式 LTO

944
00:31:38,266 --> 00:31:38,566
的速度快了 35%

945
00:31:39,406 --> 00:31:40,616
Line Tables Only 还是更快

946
00:31:40,616 --> 00:31:42,756
但是现在只需要

947
00:31:42,756 --> 00:31:44,036
90 秒

948
00:31:44,516 --> 00:31:46,906
这是干净的链接

949
00:31:47,616 --> 00:31:50,006
增量式 LTO 的真正作用

950
00:31:50,006 --> 00:31:52,236
在于其快速的增量式

951
00:31:52,236 --> 00:31:52,776
创建

952
00:31:53,356 --> 00:31:55,446
当只有一个文件夹改变时

953
00:31:55,446 --> 00:31:56,346
链接不会重复

954
00:31:56,346 --> 00:31:58,206
不必要的优化

955
00:31:59,456 --> 00:32:01,426
在 Xcode 8 中 一个 Apple LLVM 编译器

956
00:31:59,456 --> 00:32:01,426
在 Xcode 8 中 一个 Apple LLVM 编译器

957
00:32:01,426 --> 00:32:02,816
配备有完整调试信息的

958
00:32:02,816 --> 00:32:05,716
增量式链接

959
00:32:05,716 --> 00:32:08,126
只需要 21 秒

960
00:32:08,126 --> 00:32:09,526
比 Line Tables Only 快了 2 倍多

961
00:32:10,376 --> 00:32:12,436
这也是我们过去建议

962
00:32:12,436 --> 00:32:14,186
改变调试信息水平

963
00:32:15,096 --> 00:32:16,746
的原因

964
00:32:16,916 --> 00:32:18,236
但是在 Xcode 9 中 相同的

965
00:32:18,236 --> 00:32:19,456
增量式链接

966
00:32:19,506 --> 00:32:21,046
的速度快了 2.5 倍

967
00:32:21,556 --> 00:32:23,186
只需要 8 秒

968
00:32:23,186 --> 00:32:24,816
它甚至比

969
00:32:24,816 --> 00:32:26,116
去年的 Line Tables Only 模式还快

970
00:32:26,986 --> 00:32:28,716
如果你过去考虑过增量式 LTO

971
00:32:28,716 --> 00:32:30,226
但是没想过改变你的

972
00:32:30,226 --> 00:32:32,236
调试信息水平

973
00:32:32,236 --> 00:32:32,746
那么现在是时候再次考虑了

974
00:32:33,516 --> 00:32:39,156
[掌声]

975
00:32:39,656 --> 00:32:40,876
我们建议

976
00:32:40,906 --> 00:32:43,806
今天就开启增量式 LTO 即使

977
00:32:43,806 --> 00:32:45,246
你已经正在使用完整信息调试

978
00:32:45,846 --> 00:32:49,366
以上就是“What’s New In LLVM”的全部内容

979
00:32:50,596 --> 00:32:52,876
使用 @available 确保

980
00:32:52,876 --> 00:32:54,986
在支持旧的 OS 时安全使用新的 API

981
00:32:55,816 --> 00:32:57,146
创建时运行

982
00:32:57,146 --> 00:32:57,616
静态分析器

983
00:32:58,916 --> 00:33:00,846
使用 Xcode 重构代码

984
00:32:58,916 --> 00:33:00,846
使用 Xcode 重构代码

985
00:33:01,906 --> 00:33:03,326
试试 C++17 的

986
00:33:03,326 --> 00:33:04,556
新功能

987
00:33:05,336 --> 00:33:07,656
开启增量式 LTO

988
00:33:07,656 --> 00:33:09,116
升级性能 而不用

989
00:33:09,116 --> 00:33:10,766
牺牲增量式创建

990
00:33:10,766 --> 00:33:11,046
时间

991
00:33:12,126 --> 00:33:13,796
想要了解更多信息 请登录

992
00:33:13,796 --> 00:33:14,296
我们的网站

993
00:33:15,406 --> 00:33:16,516
我建议各位观看我们的

994
00:33:16,516 --> 00:33:17,446
相关会议

995
00:33:18,246 --> 00:33:18,576
谢谢大家

996
00:33:19,516 --> 00:33:22,500
[掌声]
