1
00:00:17,551 --> 00:00:21,154
<c.magenta>（通过框架性能案例研究</c>

2
00:00:24,591 --> 00:00:26,360
<c.magenta>大家下午好</c>

3
00:00:26,426 --> 00:00:28,662
<c.magenta>今天 我和我的同事</c>

4
00:00:28,729 --> 00:00:31,865
<c.magenta>和大家一起讨论</c>

5
00:00:32,566 --> 00:00:35,769
<c.magenta>如今 我们所有人</c>

6
00:00:35,903 --> 00:00:37,538
<c.magenta>我们希望笔记本电脑飞速运行</c>

7
00:00:37,604 --> 00:00:40,807
<c.magenta>希望我们的手机和平板电脑</c>

8
00:00:41,175 --> 00:00:43,777
<c.magenta>期待我们的桌面电脑</c>

9
00:00:43,977 --> 00:00:44,945
<c.magenta>事实上</c>

10
00:00:45,045 --> 00:00:47,648
<c.magenta>所有这些设备</c>

11
00:00:48,081 --> 00:00:50,651
<c.magenta>我们的任务是</c>

12
00:00:52,252 --> 00:00:54,188
<c.magenta>我们需要从不同维度来评价性能</c>

13
00:00:54,254 --> 00:00:57,457
<c.magenta>例如 代码的运行速度</c>

14
00:00:57,658 --> 00:00:59,960
<c.magenta>以及内存占用大小等</c>

15
00:01:00,394 --> 00:01:01,795
<c.magenta>由于具有多个不同的维度</c>

16
00:01:01,862 --> 00:01:03,931
<c.magenta>我们如何使用图形</c>

17
00:01:04,697 --> 00:01:06,967
<c.magenta>这里有一个框架</c>

18
00:01:07,234 --> 00:01:09,670
<c.magenta>进行形象化描述</c>

19
00:01:09,903 --> 00:01:12,906
<c.magenta>其中的一个轴</c>

20
00:01:13,140 --> 00:01:14,908
<c.magenta>另一个轴表示处理频率</c>

21
00:01:16,009 --> 00:01:19,746
<c.magenta>如果你需要处理大量的数据</c>

22
00:01:20,047 --> 00:01:22,516
<c.magenta>那么其性能水平</c>

23
00:01:22,649 --> 00:01:27,654
<c.magenta>这样的话很有可能会</c>

24
00:01:27,888 --> 00:01:31,758
<c.magenta>你需要花费大量的时间</c>

25
00:01:32,492 --> 00:01:34,161
<c.magenta>但是 如果你处理的</c>

26
00:01:34,228 --> 00:01:37,464
<c.magenta>数据量比较小</c>

27
00:01:37,531 --> 00:01:39,600
<c.magenta>那么性能水平</c>

28
00:01:39,766 --> 00:01:41,068
<c.magenta>老实说</c>

29
00:01:41,335 --> 00:01:43,170
<c.magenta>你并不希望</c>

30
00:01:43,237 --> 00:01:44,805
<c.magenta>来优化性能</c>

31
00:01:45,539 --> 00:01:49,476
<c.magenta>第二象限和第四象限</c>

32
00:01:49,710 --> 00:01:51,078
<c.magenta>它们的性能水平</c>

33
00:01:51,144 --> 00:01:53,347
<c.magenta>在很大程度上</c>

34
00:01:53,413 --> 00:01:54,348
<c.magenta>在这些情况下</c>

35
00:01:54,414 --> 00:02:00,053
<c.magenta>你希望能够结合实际应用</c>

36
00:01:54,414 --> 00:02:00,053
<c.magenta>你希望能够结合实际应用</c>

37
00:02:00,254 --> 00:02:01,755
<c.magenta>然后 根据性能指标</c>

38
00:02:01,822 --> 00:02:04,124
<c.magenta>来确定是否值得花时间</c>

39
00:02:04,191 --> 00:02:05,626
<c.magenta>进行修改</c>

40
00:02:07,694 --> 00:02:09,596
<c.magenta>在本版本中 我们深入地研究</c>

41
00:02:09,663 --> 00:02:12,032
<c.magenta>确保我们能够理解</c>

42
00:02:12,099 --> 00:02:13,534
<c.magenta>优化性能</c>

43
00:02:13,700 --> 00:02:15,235
<c.magenta>对于应用开发也是如此</c>

44
00:02:15,903 --> 00:02:18,005
<c.magenta>我们对Foundation</c>

45
00:02:18,071 --> 00:02:19,540
<c.magenta>非常重要的改变</c>

46
00:02:20,274 --> 00:02:23,177
<c.magenta>当然</c>

47
00:02:23,343 --> 00:02:26,246
<c.magenta>我们进行大量的工作</c>

48
00:02:26,313 --> 00:02:27,848
<c.magenta>之间的桥接</c>

49
00:02:28,015 --> 00:02:32,219
<c.magenta>以提升它们的运行速度</c>

50
00:02:33,687 --> 00:02:37,024
<c.magenta>现在 许多应用</c>

51
00:02:37,090 --> 00:02:40,027
<c.magenta>它们被用作口令</c>

52
00:02:40,093 --> 00:02:41,728
<c.magenta>显示在屏幕上</c>

53
00:02:42,062 --> 00:02:44,064
<c.magenta>高效率的字符串处理</c>

54
00:02:44,298 --> 00:02:46,600
<c.magenta>对于提升应用性能具有很大意义</c>

55
00:02:46,700 --> 00:02:49,503
<c.magenta>作为关键性内容的</c>

56
00:02:49,570 --> 00:02:51,205
<c.magenta>显示给用户</c>

57
00:02:52,139 --> 00:02:54,208
<c.magenta>当然</c>

58
00:02:54,341 --> 00:02:56,643
<c.magenta>是为了帮助你们提升应用运行速度</c>

59
00:02:56,743 --> 00:02:58,245
<c.magenta>你们想要减少资源占用</c>

60
00:02:58,445 --> 00:03:00,447
<c.magenta>使用更少的资源</c>

61
00:02:58,445 --> 00:03:00,447
<c.magenta>使用更少的资源</c>

62
00:03:00,514 --> 00:03:03,984
<c.magenta>不要着急</c>

63
00:03:04,051 --> 00:03:06,019
<c.magenta>今天 我们将会</c>

64
00:03:06,353 --> 00:03:10,357
<c.magenta>并为你们介绍一些</c>

65
00:03:11,592 --> 00:03:14,761
<c.magenta>前面我说过</c>

66
00:03:14,828 --> 00:03:16,363
<c.magenta>进行大量的性能优化</c>

67
00:03:16,563 --> 00:03:19,266
<c.magenta>在Foundation中</c>

68
00:03:19,399 --> 00:03:21,668
<c.magenta>让我们来看一些代表性例子</c>

69
00:03:22,369 --> 00:03:25,138
<c.magenta>我们对NSCalendar日期枚举</c>

70
00:03:25,272 --> 00:03:29,343
<c.magenta>不仅减少内存占用</c>

71
00:03:29,810 --> 00:03:31,044
<c.magenta>在以前</c>

72
00:03:31,111 --> 00:03:34,882
<c.magenta>很难进行</c>

73
00:03:35,182 --> 00:03:39,186
<c.magenta>经过更新的</c>

74
00:03:39,253 --> 00:03:42,890
<c.magenta>不仅更快速 而且</c>

75
00:03:42,956 --> 00:03:44,791
<c.magenta>长期以来没解决的</c>

76
00:03:46,093 --> 00:03:47,594
<c.magenta>但是 在我们进行更改时</c>

77
00:03:47,661 --> 00:03:51,031
<c.magenta>必须考虑这些更改</c>

78
00:03:51,465 --> 00:03:53,534
<c.magenta>在Foundation和Core Foundation中</c>

79
00:03:53,667 --> 00:03:57,004
<c.magenta>我们在一些位置</c>

80
00:03:57,471 --> 00:03:58,906
<c.magenta>我们深入分析</c>

81
00:03:58,972 --> 00:04:01,508
<c.magenta>Foundation 中的</c>

82
00:03:58,972 --> 00:04:01,508
<c.magenta>Foundation 中的</c>

83
00:04:01,675 --> 00:04:05,012
<c.magenta>决定转移到</c>

84
00:04:05,212 --> 00:04:08,882
<c.magenta>这让服务质量</c>

85
00:04:10,050 --> 00:04:12,519
<c.magenta>在服务质量方面</c>

86
00:04:12,719 --> 00:04:16,156
<c.magenta>NSOperation和OperationQueue</c>

87
00:04:16,390 --> 00:04:18,257
<c.magenta>以提升实现的正确水平</c>

88
00:04:18,325 --> 00:04:20,560
<c.magenta>从而提高</c>

89
00:04:20,894 --> 00:04:23,697
<c.magenta>你将会看到一些</c>

90
00:04:24,031 --> 00:04:27,935
<c.magenta>在重负载应用中</c>

91
00:04:28,001 --> 00:04:31,338
<c.magenta>最高可达25%</c>

92
00:04:32,906 --> 00:04:35,809
<c.magenta>在研究Swift</c>

93
00:04:36,210 --> 00:04:40,080
<c.magenta>我们发现</c>

94
00:04:40,547 --> 00:04:42,216
<c.magenta>在Foundation中</c>

95
00:04:42,282 --> 00:04:44,251
<c.magenta>一些集合类型</c>

96
00:04:44,318 --> 00:04:47,354
<c.magenta>现在将使用写时复制</c>

97
00:04:48,622 --> 00:04:51,058
<c.magenta>那么 什么是写时复制？</c>

98
00:04:51,658 --> 00:04:55,429
<c.magenta>写时复制是一种机制</c>

99
00:04:55,762 --> 00:04:59,032
<c.magenta>在这种机制中</c>

100
00:04:59,099 --> 00:05:01,134
<c.magenta>直到发生变更</c>

101
00:04:59,099 --> 00:05:01,134
<c.magenta>直到发生变更</c>

102
00:05:01,668 --> 00:05:03,437
<c.magenta>当发生变更时</c>

103
00:05:03,604 --> 00:05:06,507
<c.magenta>突变方</c>

104
00:05:06,573 --> 00:05:08,609
<c.magenta>从而允许</c>

105
00:05:08,942 --> 00:05:12,446
<c.magenta>简而言之</c>

106
00:05:12,913 --> 00:05:15,215
<c.magenta>这意味着</c>

107
00:05:15,282 --> 00:05:17,985
<c.magenta>可变容器时 不会占用任何资源</c>

108
00:05:19,052 --> 00:05:22,556
<c.magenta>在以前</c>

109
00:05:22,689 --> 00:05:24,191
<c.magenta>占用线性执行时间</c>

110
00:05:24,558 --> 00:05:26,360
<c.magenta>现在 无论何时复制它们</c>

111
00:05:26,493 --> 00:05:29,530
<c.magenta>资源耗用始终不变</c>

112
00:05:30,063 --> 00:05:31,965
<c.magenta>让我们来看一个例子</c>

113
00:05:32,032 --> 00:05:34,668
<c.magenta>以了解</c>

114
00:05:36,170 --> 00:05:37,404
<c.magenta>在这个例子中</c>

115
00:05:37,471 --> 00:05:39,139
<c.magenta>我们创建一个新可变数组</c>

116
00:05:39,740 --> 00:05:42,142
<c.magenta>创建之后</c>

117
00:05:42,209 --> 00:05:46,246
<c.magenta>我们得到一个COW后备存储</c>

118
00:05:47,047 --> 00:05:51,952
<c.magenta>我们需要做一些工作</c>

119
00:05:52,653 --> 00:05:56,089
<c.magenta>在这个例子中</c>

120
00:05:56,657 --> 00:05:59,026
<c.magenta>发生复制时</c>

121
00:05:59,126 --> 00:06:01,895
<c.magenta>在应用中</c>

122
00:05:59,126 --> 00:06:01,895
<c.magenta>在应用中</c>

123
00:06:02,129 --> 00:06:04,932
<c.magenta>是分配新集合</c>

124
00:06:05,265 --> 00:06:07,568
<c.magenta>实际上 你不必复制</c>

125
00:06:07,835 --> 00:06:11,138
<c.magenta>因此在本例中 我们仍然指向</c>

126
00:06:11,338 --> 00:06:13,473
<c.magenta>存储项目数量为零</c>

127
00:06:14,241 --> 00:06:17,411
<c.magenta>以后</c>

128
00:06:17,711 --> 00:06:21,615
<c.magenta>所发生的情况是</c>

129
00:06:21,982 --> 00:06:25,953
<c.magenta>获得一个指向共享</c>

130
00:06:26,253 --> 00:06:27,821
<c.magenta>为了进行变更</c>

131
00:06:27,888 --> 00:06:30,090
<c.magenta>必须从后备存储进行复制</c>

132
00:06:30,324 --> 00:06:33,093
<c.magenta>以确保</c>

133
00:06:34,361 --> 00:06:36,396
<c.magenta>但是你必须考虑</c>

134
00:06:36,463 --> 00:06:39,800
<c.magenta>大多数应用</c>

135
00:06:39,867 --> 00:06:43,170
<c.magenta>而不再进行</c>

136
00:06:43,637 --> 00:06:45,172
<c.magenta>因此你可以看到</c>

137
00:06:45,239 --> 00:06:48,075
<c.magenta>利用此功能</c>

138
00:06:48,141 --> 00:06:51,445
<c.magenta>大幅的提升</c>

139
00:06:52,279 --> 00:06:54,681
<c.magenta>现在 让我们来看</c>

140
00:06:54,748 --> 00:06:55,983
<c.magenta>使用这项技术</c>

141
00:06:56,917 --> 00:06:59,019
<c.magenta>假设我是一名开发者</c>

142
00:06:59,319 --> 00:07:01,822
<c.magenta>我编写这样的代码 并附有注释</c>

143
00:06:59,319 --> 00:07:01,822
<c.magenta>我编写这样的代码 并附有注释</c>

144
00:07:02,189 --> 00:07:05,759
<c.magenta>希望我的同事</c>

145
00:07:05,826 --> 00:07:07,828
<c.magenta>以提升性能</c>

146
00:07:08,295 --> 00:07:10,397
<c.magenta>但是这里有一个小陷阱</c>

147
00:07:10,664 --> 00:07:13,634
<c.magenta>如果需要用到</c>

148
00:07:13,901 --> 00:07:16,370
<c.magenta>那么可能将会</c>

149
00:07:16,436 --> 00:07:18,639
<c.magenta>这意味着</c>

150
00:07:18,972 --> 00:07:20,174
<c.magenta>这不是我们想要的</c>

151
00:07:20,774 --> 00:07:23,343
<c.magenta>由于现在复制不会占用资源</c>

152
00:07:23,577 --> 00:07:25,913
<c.magenta>因此每次都可以进行同样的操作</c>

153
00:07:25,979 --> 00:07:27,981
<c.magenta>而不必担心</c>

154
00:07:28,715 --> 00:07:29,550
<c.magenta>这非常不错</c>

155
00:07:30,484 --> 00:07:32,920
<c.magenta>这不仅仅是资产的</c>

156
00:07:33,220 --> 00:07:36,056
<c.magenta>很多情况下 可变容器</c>

157
00:07:36,557 --> 00:07:40,294
<c.magenta>在这个例子中</c>

158
00:07:40,360 --> 00:07:41,995
<c.magenta>NSArray的一个子类</c>

159
00:07:42,462 --> 00:07:45,632
<c.magenta>其返回值是</c>

160
00:07:45,732 --> 00:07:48,135
<c.magenta>这应该很安全 是吧？</c>

161
00:07:48,735 --> 00:07:51,471
<c.magenta>但不幸的是</c>

162
00:07:51,538 --> 00:07:53,073
<c.magenta>存在一些后果</c>

163
00:07:53,340 --> 00:07:56,243
<c.magenta>如果我们查看</c>

164
00:07:56,543 --> 00:07:57,477
<c.magenta>情况不妙</c>

165
00:07:57,544 --> 00:08:00,380
<c.magenta>它们可能具有</c>

166
00:07:57,544 --> 00:08:00,380
<c.magenta>它们可能具有</c>

167
00:08:00,914 --> 00:08:04,751
<c.magenta>因此</c>

168
00:08:04,985 --> 00:08:06,486
<c.magenta>确保获得正确的结果</c>

169
00:08:06,553 --> 00:08:09,189
<c.magenta>而不必担心</c>

170
00:08:10,390 --> 00:08:14,628
<c.magenta>还有另一个例子</c>

171
00:08:14,862 --> 00:08:15,929
<c.magenta>在Swift中</c>

172
00:08:16,864 --> 00:08:20,133
<c.magenta>无论何时</c>

173
00:08:20,400 --> 00:08:24,438
<c.magenta>都必须进行复制</c>

174
00:08:24,905 --> 00:08:27,808
<c.magenta>如果你将数据转换为</c>

175
00:08:27,875 --> 00:08:30,611
<c.magenta>任何NSArray类型</c>

176
00:08:30,744 --> 00:08:32,312
<c.magenta>以前的实现</c>

177
00:08:32,379 --> 00:08:35,582
<c.magenta>必须花费</c>

178
00:08:35,649 --> 00:08:37,017
<c.magenta>才能够进行复制</c>

179
00:08:37,417 --> 00:08:39,119
<c.magenta>如果使用保护性的方法</c>

180
00:08:39,520 --> 00:08:42,655
<c.magenta>复制将不会</c>

181
00:08:42,722 --> 00:08:45,392
<c.magenta>因此不会降低性能</c>

182
00:08:47,661 --> 00:08:48,795
<c.magenta>在Swift 3中</c>

183
00:08:49,296 --> 00:08:52,766
<c.magenta>我们为Foundation</c>

184
00:08:53,267 --> 00:08:55,602
<c.magenta>这种做法</c>

185
00:08:55,669 --> 00:08:58,639
<c.magenta>将NSData引导向</c>

186
00:08:59,439 --> 00:09:01,675
<c.magenta>我们对数据进行大量研究</c>

187
00:08:59,439 --> 00:09:01,675
<c.magenta>我们对数据进行大量研究</c>

188
00:09:01,742 --> 00:09:04,378
<c.magenta>理解常见的用例</c>

189
00:09:04,444 --> 00:09:06,513
<c.magenta>和情况并改进数据</c>

190
00:09:06,580 --> 00:09:09,249
<c.magenta>让它能够</c>

191
00:09:09,917 --> 00:09:14,721
<c.magenta>在这个版本中</c>

192
00:09:14,788 --> 00:09:16,323
<c.magenta>我们研究</c>

193
00:09:16,390 --> 00:09:18,926
<c.magenta>在执行常见任务时的</c>

194
00:09:19,026 --> 00:09:20,561
<c.magenta>比如获取数据计数</c>

195
00:09:20,661 --> 00:09:23,730
<c.magenta>偏移位置的</c>

196
00:09:24,631 --> 00:09:28,569
<c.magenta>一些实现的情况</c>

197
00:09:28,802 --> 00:09:32,472
<c.magenta>一般来说 几行机器指令</c>

198
00:09:32,906 --> 00:09:35,776
<c.magenta>但是 当表示</c>

199
00:09:36,176 --> 00:09:38,679
<c.magenta>少数几行指令</c>

200
00:09:38,946 --> 00:09:40,547
<c.magenta>就可能带来很大的变化</c>

201
00:09:41,982 --> 00:09:44,284
<c.magenta>这段代码看上去非常简单</c>

202
00:09:45,719 --> 00:09:48,488
<c.magenta>但是它具有</c>

203
00:09:48,555 --> 00:09:51,792
<c.magenta>揭示我们可以</c>

204
00:09:52,593 --> 00:09:55,762
<c.magenta>首先 数据是一个集合</c>

205
00:09:55,929 --> 00:09:59,066
<c.magenta>它可以具有标注</c>

206
00:09:59,633 --> 00:10:02,769
<c.magenta>因此 这意味着</c>

207
00:09:59,633 --> 00:10:02,769
<c.magenta>因此 这意味着</c>

208
00:10:03,003 --> 00:10:04,605
<c.magenta>不一定是零</c>

209
00:10:04,872 --> 00:10:08,609
<c.magenta>索引类似于</c>

210
00:10:09,042 --> 00:10:11,545
<c.magenta>这段代码</c>

211
00:10:12,312 --> 00:10:14,147
<c.magenta>我们使用它来帮助理解</c>

212
00:10:14,214 --> 00:10:16,283
<c.magenta>需要改进数据的哪些部分</c>

213
00:10:16,783 --> 00:10:19,086
<c.magenta>这里的两个问题是</c>

214
00:10:19,453 --> 00:10:21,321
<c.magenta>所要处理的数据量是多少</c>

215
00:10:21,488 --> 00:10:23,524
<c.magenta>另外 调用次数是多少？</c>

216
00:10:23,957 --> 00:10:25,425
<c.magenta>其性能水平位于哪个象限？</c>

217
00:10:26,193 --> 00:10:30,330
<c.magenta>正确的答案是</c>

218
00:10:30,797 --> 00:10:34,334
<c.magenta>最可能的情况是</c>

219
00:10:34,935 --> 00:10:36,970
<c.magenta>我们的确这样做了</c>

220
00:10:38,372 --> 00:10:40,207
<c.magenta>上方的蓝色曲线</c>

221
00:10:40,274 --> 00:10:42,543
<c.magenta>表示初始的Swift 3 Data版本</c>

222
00:10:43,043 --> 00:10:48,048
<c.magenta>进行标注时</c>

223
00:10:48,115 --> 00:10:51,118
<c.magenta>这是在我进行分析时</c>

224
00:10:51,919 --> 00:10:57,157
<c.magenta>由于处理数据</c>

225
00:10:57,491 --> 00:11:00,294
<c.magenta>因此速度应该非常快</c>

226
00:10:57,491 --> 00:11:00,294
<c.magenta>因此速度应该非常快</c>

227
00:11:00,961 --> 00:11:04,698
<c.magenta>经过改进之后</c>

228
00:11:04,865 --> 00:11:05,899
<c.magenta>提升非常明显</c>

229
00:11:06,433 --> 00:11:08,902
<c.magenta>如果你以前曾经使用Data</c>

230
00:11:09,236 --> 00:11:11,538
<c.magenta>就可以知道其优点</c>

231
00:11:12,172 --> 00:11:14,808
<c.magenta>它将能够与</c>

232
00:11:14,942 --> 00:11:18,111
<c.magenta>获取和使用Data的</c>

233
00:11:20,714 --> 00:11:21,548
<c.magenta>谢谢</c>

234
00:11:23,817 --> 00:11:26,687
<c.magenta>需要提醒你们的是</c>

235
00:11:26,753 --> 00:11:30,090
<c.magenta>这些例子</c>

236
00:11:30,257 --> 00:11:32,759
<c.magenta>但是 它们确实</c>

237
00:11:32,993 --> 00:11:34,695
<c.magenta>还需要改进</c>

238
00:11:35,729 --> 00:11:38,398
<c.magenta>通常 我们认为</c>

239
00:11:38,465 --> 00:11:39,766
<c.magenta>可以用数组表示</c>

240
00:11:39,833 --> 00:11:42,436
<c.magenta>对于少量数据 确实可以</c>

241
00:11:42,536 --> 00:11:43,704
<c.magenta>工作也很正常</c>

242
00:11:44,104 --> 00:11:46,473
<c.magenta>但是 从某种角度来说</c>

243
00:11:46,540 --> 00:11:50,344
<c.magenta>这也存在隐藏的开销</c>

244
00:11:51,111 --> 00:11:52,312
<c.magenta>会增加复杂性</c>

245
00:11:52,379 --> 00:11:54,047
<c.magenta>有很多这样的边界例子</c>

246
00:11:54,181 --> 00:11:55,782
<c.magenta>我们已经考虑到这一点</c>

247
00:11:56,049 --> 00:11:58,986
<c.magenta>由于能够进行互操作</c>

248
00:11:59,052 --> 00:12:02,789
<c.magenta>转换成为基本C4</c>

249
00:11:59,052 --> 00:12:02,789
<c.magenta>转换成为基本C4</c>

250
00:12:04,124 --> 00:12:06,693
<c.magenta>有时候我们更喜欢老做法</c>

251
00:12:06,760 --> 00:12:10,464
<c.magenta>使用可靠的malloc方法</c>

252
00:12:10,864 --> 00:12:12,733
<c.magenta>不幸的是</c>

253
00:12:12,833 --> 00:12:16,069
<c.magenta>这可能会错失</c>

254
00:12:16,236 --> 00:12:19,006
<c.magenta>比如</c>

255
00:12:19,072 --> 00:12:21,708
<c.magenta>而不需要</c>

256
00:12:21,775 --> 00:12:24,311
<c.magenta>交回给缓冲区</c>

257
00:12:25,179 --> 00:12:27,281
<c.magenta>Data为你完成所有这些工作</c>

258
00:12:27,347 --> 00:12:29,950
<c.magenta>你不必担心</c>

259
00:12:30,017 --> 00:12:33,220
<c.magenta>你不必担心</c>

260
00:12:33,287 --> 00:12:36,924
<c.magenta>比如</c>

261
00:12:39,159 --> 00:12:42,563
<c.magenta>这两行代码</c>

262
00:12:42,796 --> 00:12:44,598
<c.magenta>但是它们用处不大</c>

263
00:12:44,798 --> 00:12:46,567
<c.magenta>在某些情况</c>

264
00:12:46,633 --> 00:12:49,536
<c.magenta>你需要能够处理</c>

265
00:12:49,770 --> 00:12:51,071
<c.magenta>另一些情况下</c>

266
00:12:51,138 --> 00:12:54,441
<c.magenta>你想要能够</c>

267
00:12:55,108 --> 00:12:56,944
<c.magenta>因此 Data有两个API</c>

268
00:12:57,010 --> 00:12:59,012
<c.magenta>其中一个是Subdata</c>

269
00:12:59,146 --> 00:13:00,647
<c.magenta>它创建一个副本</c>

270
00:12:59,146 --> 00:13:00,647
<c.magenta>它创建一个副本</c>

271
00:13:00,714 --> 00:13:03,283
<c.magenta>如果你需要</c>

272
00:13:03,450 --> 00:13:05,819
<c.magenta>而只想保留其中一部分</c>

273
00:13:06,119 --> 00:13:09,656
<c.magenta>带有范围参数的Subdata</c>

274
00:13:10,424 --> 00:13:13,894
<c.magenta>我们已经更改Data</c>

275
00:13:14,061 --> 00:13:16,997
<c.magenta>或类型的子集</c>

276
00:13:17,331 --> 00:13:19,566
<c.magenta>无论你是否使用范围语法</c>

277
00:13:19,633 --> 00:13:22,002
<c.magenta>举例来说 即使有这样的范围</c>

278
00:13:22,803 --> 00:13:26,673
<c.magenta>你也可以将它用作窗口</c>

279
00:13:26,940 --> 00:13:29,309
<c.magenta>如果你需要</c>

280
00:13:29,376 --> 00:13:31,378
<c.magenta>只需要进行分析</c>

281
00:13:31,578 --> 00:13:34,214
<c.magenta>而且数据本身</c>

282
00:13:34,615 --> 00:13:38,318
<c.magenta>然后 使用数据片段</c>

283
00:13:38,385 --> 00:13:41,288
<c.magenta>让你轻松地访问数据</c>

284
00:13:43,557 --> 00:13:46,560
<c.magenta>我们多次</c>

285
00:13:46,793 --> 00:13:50,631
<c.magenta>这里我们需要</c>

286
00:13:51,498 --> 00:13:55,135
<c.magenta>在右侧</c>

287
00:13:55,669 --> 00:13:57,437
<c.magenta>在这些例子中</c>

288
00:13:57,638 --> 00:13:59,806
<c.magenta>它们将Foundation类型</c>

289
00:13:59,907 --> 00:14:01,308
<c.magenta>桥接到Core Foundation类型</c>

290
00:13:59,907 --> 00:14:01,308
<c.magenta>桥接到Core Foundation类型</c>

291
00:14:01,842 --> 00:14:04,511
<c.magenta>或者从Foundation类型</c>

292
00:14:05,212 --> 00:14:09,183
<c.magenta>在转换过程中不会产生开销</c>

293
00:14:09,383 --> 00:14:11,818
<c.magenta>因此 在这个例子中</c>

294
00:14:11,885 --> 00:14:15,489
<c.magenta>将NSArray桥接到CFArray</c>

295
00:14:16,123 --> 00:14:18,525
<c.magenta>这只是重新解释指针</c>

296
00:14:19,359 --> 00:14:22,529
<c.magenta>但是这里有少量的资源开销</c>

297
00:14:22,663 --> 00:14:27,801
<c.magenta>当你传递对象</c>

298
00:14:28,502 --> 00:14:30,304
<c.magenta>你会得到一些东西</c>

299
00:14:30,537 --> 00:14:32,306
<c.magenta>我们将会</c>

300
00:14:33,340 --> 00:14:37,711
<c.magenta>在Swift桥接中</c>

301
00:14:37,778 --> 00:14:40,013
<c.magenta>你需要</c>

302
00:14:40,080 --> 00:14:41,415
<c.magenta>桥接到结构类型</c>

303
00:14:42,382 --> 00:14:44,551
<c.magenta>或者也可以</c>

304
00:14:44,685 --> 00:14:47,521
<c.magenta>从结构类型</c>

305
00:14:48,956 --> 00:14:52,793
<c.magenta>但是这些例子中的</c>

306
00:14:52,960 --> 00:14:55,229
<c.magenta>因此 无论何时从Objective-C导入</c>

307
00:14:55,395 --> 00:14:58,365
<c.magenta>或者 在本例中</c>

308
00:14:58,599 --> 00:15:00,601
<c.magenta>在二者之间进行转换</c>

309
00:14:58,599 --> 00:15:00,601
<c.magenta>在二者之间进行转换</c>

310
00:15:00,767 --> 00:15:03,003
<c.magenta>这时会产生开销</c>

311
00:15:04,538 --> 00:15:06,540
<c.magenta>但是区别在于</c>

312
00:15:06,607 --> 00:15:09,943
<c.magenta>这些开销</c>

313
00:15:10,944 --> 00:15:12,513
<c.magenta>让我们来深入了解</c>

314
00:15:12,779 --> 00:15:14,214
<c.magenta>我知道这看上去有点吓人/b&gt;</c>

315
00:15:14,648 --> 00:15:16,383
<c.magenta>如果不使用写时复制</c>

316
00:15:16,450 --> 00:15:17,518
<c.magenta>这并不会…</c>

317
00:15:17,584 --> 00:15:19,853
<c.magenta>CFArray 并不实现写时复制</c>

318
00:15:21,054 --> 00:15:24,791
<c.magenta>但是当你传递</c>

319
00:15:24,858 --> 00:15:26,793
<c.magenta>到CFArrayGetCount时</c>

320
00:15:27,127 --> 00:15:30,731
<c.magenta>它将魔术般地</c>

321
00:15:31,532 --> 00:15:33,233
<c.magenta>让我们来进一步</c>

322
00:15:33,300 --> 00:15:36,370
<c.magenta>弄清楚这与</c>

323
00:15:38,906 --> 00:15:40,841
<c.magenta>这里进行了简化</c>

324
00:15:41,141 --> 00:15:44,645
<c.magenta>首先 我们使用数组</c>

325
00:15:44,912 --> 00:15:47,247
<c.magenta>我们发现</c>

326
00:15:47,648 --> 00:15:51,485
<c.magenta>如果不是 我们会知道</c>

327
00:15:51,618 --> 00:15:54,788
<c.magenta>我们获得</c>

328
00:15:56,523 --> 00:15:58,258
<c.magenta>让我们更深入地分析</c>

329
00:15:58,926 --> 00:16:00,994
<c.magenta>它检查</c>

330
00:15:58,926 --> 00:16:00,994
<c.magenta>它检查</c>

331
00:16:01,061 --> 00:16:02,996
<c.magenta>参照预期的类表</c>

332
00:16:03,230 --> 00:16:04,097
<c.magenta>因此 事实上</c>

333
00:16:04,831 --> 00:16:07,467
<c.magenta>它会进行</c>

334
00:16:07,534 --> 00:16:09,336
<c.magenta>和一次函数调用 以确定</c>

335
00:16:09,403 --> 00:16:12,906
<c.magenta>是否需调用</c>

336
00:16:12,973 --> 00:16:14,908
<c.magenta>Objective-C方法</c>

337
00:16:16,343 --> 00:16:17,945
<c.magenta>让我们进行总结</c>

338
00:16:18,111 --> 00:16:22,616
<c.magenta>转换为数组</c>

339
00:16:22,683 --> 00:16:25,185
<c.magenta>仅仅是重新解释指针</c>

340
00:16:25,819 --> 00:16:28,922
<c.magenta>其使用过程</c>

341
00:16:29,823 --> 00:16:32,726
<c.magenta>但是这只会产生</c>

342
00:16:32,993 --> 00:16:37,030
<c.magenta>但是在极少数情况</c>

343
00:16:37,397 --> 00:16:39,967
<c.magenta>因此 性能水平可能</c>

344
00:16:40,033 --> 00:16:42,970
<c.magenta>位于第三象限</c>

345
00:16:44,905 --> 00:16:48,242
<c.magenta>现在 我们来看另一种做法</c>

346
00:16:48,609 --> 00:16:52,112
<c.magenta>请记住</c>

347
00:16:52,312 --> 00:16:54,648
<c.magenta>或者使用Objective-C API</c>

348
00:16:55,082 --> 00:16:57,284
<c.magenta>无论何时使用桥接引用类型</c>

349
00:16:57,918 --> 00:17:01,655
<c.magenta>编译器将会</c>

350
00:16:57,918 --> 00:17:01,655
<c.magenta>编译器将会</c>

351
00:17:01,855 --> 00:17:04,458
<c.magenta>反过来</c>

352
00:17:04,525 --> 00:17:06,859
<c.magenta>为Data调用</c>

353
00:17:08,262 --> 00:17:11,265
<c.magenta>当Data初始化时</c>

354
00:17:11,464 --> 00:17:12,965
<c.magenta>将会将存储数据</c>

355
00:17:13,099 --> 00:17:16,136
<c.magenta>复制到数据的</c>

356
00:17:16,270 --> 00:17:18,539
<c.magenta>我们不仅需要保留</c>

357
00:17:18,605 --> 00:17:21,441
<c.magenta>数据的</c>

358
00:17:21,642 --> 00:17:22,675
<c.magenta>而且必须确保</c>

359
00:17:22,742 --> 00:17:25,412
<c.magenta>我们不会使用</c>

360
00:17:25,546 --> 00:17:27,214
<c.magenta>因为这会产生漏洞</c>

361
00:17:28,080 --> 00:17:31,785
<c.magenta>你可以看到</c>

362
00:17:31,852 --> 00:17:34,354
<c.magenta>或代理或其他子类</c>

363
00:17:34,821 --> 00:17:38,125
<c.magenta>这可能是一个</c>

364
00:17:39,660 --> 00:17:41,828
<c.magenta>我们完成所有桥接</c>

365
00:17:41,895 --> 00:17:43,330
<c.magenta>再来看性能图</c>

366
00:17:44,164 --> 00:17:46,733
<c.magenta>这次</c>

367
00:17:46,800 --> 00:17:49,603
<c.magenta>桥接并没有占用过多资源</c>

368
00:17:49,736 --> 00:17:52,840
<c.magenta>通常情况下</c>

369
00:17:53,207 --> 00:17:55,509
<c.magenta>仅复制限定的部分</c>

370
00:17:55,809 --> 00:17:58,645
<c.magenta>因此 性能水平</c>

371
00:17:59,279 --> 00:18:02,749
<c.magenta>但是 对于子类之外的</c>

372
00:17:59,279 --> 00:18:02,749
<c.magenta>但是 对于子类之外的</c>

373
00:18:02,816 --> 00:18:04,484
<c.magenta>比如可变数据</c>

374
00:18:04,551 --> 00:18:08,288
<c.magenta>复制可能导致</c>

375
00:18:08,589 --> 00:18:11,959
<c.magenta>因此 如果你需要</c>

376
00:18:12,226 --> 00:18:16,230
<c.magenta>或者在桥接之间</c>

377
00:18:16,763 --> 00:18:19,333
<c.magenta>你应该结合这些有用的范例</c>

378
00:18:19,399 --> 00:18:22,336
<c.magenta>利用更好的测量参数</c>

379
00:18:23,337 --> 00:18:26,773
<c.magenta>这种模式</c>

380
00:18:26,874 --> 00:18:29,743
<c.magenta>也适用于Swift中的</c>

381
00:18:29,977 --> 00:18:32,946
<c.magenta>比如数组</c>

382
00:18:33,380 --> 00:18:36,650
<c.magenta>说到字符串</c>

383
00:18:37,317 --> 00:18:38,151
<c.magenta>接下来</c>

384
00:18:38,218 --> 00:18:42,956
<c.magenta>唐娜将会和大家一起</c>

385
00:18:48,428 --> 00:18:49,263
<c.magenta>谢谢 菲力浦</c>

386
00:18:51,899 --> 00:18:52,900
<c.magenta>字符串</c>

387
00:18:52,966 --> 00:18:55,269
<c.magenta>可能是使用频率最高的</c>

388
00:18:55,636 --> 00:18:56,737
<c.magenta>如果你是应用开发者</c>

389
00:18:56,837 --> 00:18:58,739
<c.magenta>你的应用在使用时</c>

390
00:18:58,805 --> 00:19:01,208
<c.magenta>成百上千的</c>

391
00:18:58,805 --> 00:19:01,208
<c.magenta>成百上千的</c>

392
00:19:01,742 --> 00:19:03,143
<c.magenta>如果你是框架开发者</c>

393
00:19:03,210 --> 00:19:05,279
<c.magenta>每次用户</c>

394
00:19:05,445 --> 00:19:07,481
<c.magenta>框架可能产生和更改字符串</c>

395
00:19:07,881 --> 00:19:09,850
<c.magenta>这些字符串</c>

396
00:19:10,017 --> 00:19:11,485
<c.magenta>发生变化</c>

397
00:19:11,952 --> 00:19:13,987
<c.magenta>字符串并不会单独使用</c>

398
00:19:14,188 --> 00:19:15,489
<c.magenta>你需要与框架交互</c>

399
00:19:15,556 --> 00:19:17,157
<c.magenta>利用字符串完成一些工作</c>

400
00:19:17,224 --> 00:19:20,527
<c.magenta>无论分割</c>

401
00:19:20,727 --> 00:19:22,362
<c.magenta>或是简单地在屏幕上呈现</c>

402
00:19:22,763 --> 00:19:26,266
<c.magenta>你可能需要改进</c>

403
00:19:26,333 --> 00:19:30,871
<c.magenta>理解字符串、范围、</c>

404
00:19:30,938 --> 00:19:33,874
<c.magenta>在此理解基础上</c>

405
00:19:34,708 --> 00:19:36,777
<c.magenta>在我们讨论</c>

406
00:19:36,977 --> 00:19:37,978
<c.magenta>我想回过头来</c>

407
00:19:38,045 --> 00:19:40,180
<c.magenta>重复菲力浦讲过的一些内容</c>

408
00:19:40,314 --> 00:19:41,281
<c.magenta>简要讨论</c>

409
00:19:41,348 --> 00:19:44,184
<c.magenta>如何评价</c>

410
00:19:46,186 --> 00:19:48,822
<c.magenta>很重要的一点是</c>

411
00:19:48,889 --> 00:19:50,524
<c.magenta>你必须</c>

412
00:19:51,325 --> 00:19:53,393
<c.magenta>我们很容易</c>

413
00:19:53,560 --> 00:19:57,197
<c.magenta>专注于优化</c>

414
00:19:57,364 --> 00:19:59,666
<c.magenta>但是 如果方案不能反映</c>

415
00:19:59,733 --> 00:20:01,969
<c.magenta>用户如何</c>

416
00:19:59,733 --> 00:20:01,969
<c.magenta>用户如何</c>

417
00:20:02,336 --> 00:20:04,071
<c.magenta>那么优化它们</c>

418
00:20:04,137 --> 00:20:05,172
<c.magenta>多么大的作用</c>

419
00:20:06,039 --> 00:20:07,407
<c.magenta>因此 如果你</c>

420
00:20:07,641 --> 00:20:10,377
<c.magenta>使用的方案反映</c>

421
00:20:10,444 --> 00:20:13,247
<c.magenta>你可以分析</c>

422
00:20:13,614 --> 00:20:16,750
<c.magenta>在做这项工作时你应该回忆</c>

423
00:20:16,984 --> 00:20:18,785
<c.magenta>我处理的数据量有多大？</c>

424
00:20:18,852 --> 00:20:20,487
<c.magenta>代码的运行频率如何？</c>

425
00:20:21,955 --> 00:20:23,357
<c.magenta>另外我们要使用性能象限图</c>

426
00:20:23,824 --> 00:20:26,560
<c.magenta>但我们需要</c>

427
00:20:26,693 --> 00:20:28,095
<c.magenta>以适用于字符串和文本</c>

428
00:20:28,562 --> 00:20:30,197
<c.magenta>总体思想是相同的</c>

429
00:20:30,364 --> 00:20:31,465
<c.magenta>但是对于字符串</c>

430
00:20:31,532 --> 00:20:33,734
<c.magenta>我们需要考虑</c>

431
00:20:33,867 --> 00:20:35,802
<c.magenta>和代码的运行频率</c>

432
00:20:37,471 --> 00:20:39,740
<c.magenta>在我们回顾这些主题时</c>

433
00:20:39,806 --> 00:20:41,108
<c.magenta>这些规模和频率概念</c>

434
00:20:42,543 --> 00:20:44,278
<c.magenta>首先 让我们来看</c>

435
00:20:45,012 --> 00:20:46,647
<c.magenta>我们会讨论范围</c>

436
00:20:46,713 --> 00:20:48,315
<c.magenta>和字符串索引的精妙之处</c>

437
00:20:48,949 --> 00:20:51,285
<c.magenta>最后 我们将会分享一些技术</c>

438
00:20:51,351 --> 00:20:53,787
<c.magenta>文本布局</c>

439
00:20:54,922 --> 00:20:56,390
<c.magenta>我们先来看</c>

440
00:20:58,025 --> 00:21:00,427
<c.magenta>我们的第一个例子</c>

441
00:20:58,025 --> 00:21:00,427
<c.magenta>我们的第一个例子</c>

442
00:21:02,095 --> 00:21:03,630
<c.magenta>假设我有一个这样的标签</c>

443
00:21:03,697 --> 00:21:05,265
<c.magenta>我想要访问它的文本</c>

444
00:21:07,267 --> 00:21:09,169
<c.magenta>在Swift中</c>

445
00:21:10,103 --> 00:21:13,407
<c.magenta>我们要求UIKit框架</c>

446
00:21:14,241 --> 00:21:16,543
<c.magenta>因此 界面看起来是这样的</c>

447
00:21:18,178 --> 00:21:20,647
<c.magenta>但是 请注意</c>

448
00:21:20,781 --> 00:21:23,116
<c.magenta>UILabel在Objective-C中实现</c>

449
00:21:24,685 --> 00:21:27,487
<c.magenta>因此 虽然我们的可变文本</c>

450
00:21:27,754 --> 00:21:29,823
<c.magenta>后备存储实际上是一个NSString</c>

451
00:21:29,890 --> 00:21:31,625
<c.magenta>是从Objective-C桥接过来的</c>

452
00:21:33,527 --> 00:21:35,095
<c.magenta>让我们来看看</c>

453
00:21:35,162 --> 00:21:36,897
<c.magenta>请求获取标签的文本时</c>

454
00:21:38,265 --> 00:21:40,300
<c.magenta>框架中的NSString</c>

455
00:21:40,767 --> 00:21:42,536
<c.magenta>Swift的字符串是一个值类型</c>

456
00:21:43,103 --> 00:21:45,772
<c.magenta>因此 如果我们向框架</c>

457
00:21:46,073 --> 00:21:48,542
<c.magenta>当进行Swift桥接时</c>

458
00:21:49,943 --> 00:21:53,347
<c.magenta>但是 我们并不知道在桥接之后</c>

459
00:21:53,647 --> 00:21:55,849
<c.magenta>为了保留Swift值语义</c>

460
00:21:55,983 --> 00:21:57,951
<c.magenta>框架必须复制它</c>

461
00:21:58,919 --> 00:22:02,122
<c.magenta>幸运的是 在本例中</c>

462
00:21:58,919 --> 00:22:02,122
<c.magenta>幸运的是 在本例中</c>

463
00:22:02,356 --> 00:22:04,224
<c.magenta>因此 当框架进行复制时</c>

464
00:22:04,291 --> 00:22:06,760
<c.magenta>将经过优化</c>

465
00:22:06,827 --> 00:22:08,829
<c.magenta>因为这只是增大引用数量</c>

466
00:22:11,965 --> 00:22:14,034
<c.magenta>但是 如果我们</c>

467
00:22:14,168 --> 00:22:16,436
<c.magenta>我们回到图表</c>

468
00:22:17,905 --> 00:22:20,974
<c.magenta>在本例中 初始字符串</c>

469
00:22:21,074 --> 00:22:23,010
<c.magenta>即使进行完整复制</c>

470
00:22:23,844 --> 00:22:24,945
<c.magenta>影响也是非常小的</c>

471
00:22:26,013 --> 00:22:27,281
<c.magenta>大多数情况下 UILabel</c>

472
00:22:27,347 --> 00:22:28,949
<c.magenta>仅包含短字符串</c>

473
00:22:29,016 --> 00:22:30,717
<c.magenta>这些字符串用于UI显示</c>

474
00:22:31,251 --> 00:22:34,321
<c.magenta>因此 你可能不会</c>

475
00:22:34,721 --> 00:22:37,357
<c.magenta>大多数情况下</c>

476
00:22:37,691 --> 00:22:40,227
<c.magenta>因此 桥接复制</c>

477
00:22:43,096 --> 00:22:46,166
<c.magenta>但是 让我们来看</c>

478
00:22:46,233 --> 00:22:47,334
<c.magenta>比如在NSTextStorage中</c>

479
00:22:49,069 --> 00:22:49,903
<c.magenta>NSTextStorage</c>

480
00:22:49,970 --> 00:22:52,039
<c.magenta>是TextKit背后的</c>

481
00:22:52,506 --> 00:22:54,608
<c.magenta>它用于在Cocoa 和Cocoa Touch中</c>

482
00:22:54,675 --> 00:22:56,076
<c.magenta>比如你在这里所看到的</c>

483
00:22:57,144 --> 00:22:59,146
<c.magenta>因此 如果你处理文本视图</c>

484
00:22:59,413 --> 00:23:00,848
<c.magenta>你需要能够</c>

485
00:22:59,413 --> 00:23:00,848
<c.magenta>你需要能够</c>

486
00:23:00,914 --> 00:23:02,182
<c.magenta>文本</c>

487
00:23:03,217 --> 00:23:04,785
<c.magenta>这是Swift中的内容</c>

488
00:23:07,921 --> 00:23:09,356
<c.magenta>这是生成的界面</c>

489
00:23:10,257 --> 00:23:13,794
<c.magenta>这是Objective-C界面</c>

490
00:23:14,962 --> 00:23:16,997
<c.magenta>但是请注意 NSTextStorage</c>

491
00:23:17,064 --> 00:23:19,733
<c.magenta>是NSMutableAttributedString的</c>

492
00:23:21,435 --> 00:23:24,471
<c.magenta>由于这里NSTextStorage</c>

493
00:23:24,671 --> 00:23:27,508
<c.magenta>因此我们希望</c>

494
00:23:27,574 --> 00:23:28,809
<c.magenta>频繁发生变化</c>

495
00:23:29,977 --> 00:23:32,946
<c.magenta>文本存储的内容</c>

496
00:23:33,013 --> 00:23:35,482
<c.magenta>可能是MB</c>

497
00:23:36,216 --> 00:23:37,284
<c.magenta>因此 为了确保效率</c>

498
00:23:37,351 --> 00:23:39,620
<c.magenta>框架仅保留</c>

499
00:23:39,920 --> 00:23:42,656
<c.magenta>当你请求文本存储中的</c>

500
00:23:43,190 --> 00:23:45,459
<c.magenta>将会得到</c>

501
00:23:45,526 --> 00:23:47,227
<c.magenta>它指向可变字符串</c>

502
00:23:49,730 --> 00:23:50,664
<c.magenta>现在 让我们再来看一看</c>

503
00:23:50,731 --> 00:23:51,732
<c.magenta>发生了什么</c>

504
00:23:51,798 --> 00:23:53,634
<c.magenta>当我们从Swift中</c>

505
00:23:55,769 --> 00:23:58,005
<c.magenta>与前面一样</c>

506
00:23:58,071 --> 00:24:00,941
<c.magenta>当进行桥接时</c>

507
00:23:58,071 --> 00:24:00,941
<c.magenta>当进行桥接时</c>

508
00:24:01,441 --> 00:24:02,943
<c.magenta>框架将会进行复制</c>

509
00:24:04,011 --> 00:24:05,579
<c.magenta>但与UILabel例子不一样</c>

510
00:24:05,646 --> 00:24:08,515
<c.magenta>在这里 底层NSString</c>

511
00:24:09,316 --> 00:24:10,784
<c.magenta>因此 此复制将会占用大量资源</c>

512
00:24:11,818 --> 00:24:12,819
<c.magenta>如我们前面所述</c>

513
00:24:12,886 --> 00:24:16,423
<c.magenta>textStorage更适合</c>

514
00:24:16,823 --> 00:24:18,759
<c.magenta>其大小可能是MB</c>

515
00:24:18,825 --> 00:24:21,195
<c.magenta>因此 这种复制</c>

516
00:24:23,564 --> 00:24:24,865
<c.magenta>现在 让我们看看</c>

517
00:24:24,932 --> 00:24:26,600
<c.magenta>当我们请求</c>

518
00:24:28,535 --> 00:24:31,104
<c.magenta>NSMutableString是一个引用类型</c>

519
00:24:32,139 --> 00:24:34,007
<c.magenta>因为没有进行桥接</c>

520
00:24:34,575 --> 00:24:36,176
<c.magenta>从而避免占用大量资源的复制操作</c>

521
00:24:37,511 --> 00:24:39,413
<c.magenta>这种情况源自于</c>

522
00:24:39,479 --> 00:24:41,181
<c.magenta>Swift的值语义与</c>

523
00:24:41,315 --> 00:24:42,816
<c.magenta>NSTextStorage设计之间的不匹配</c>

524
00:24:42,950 --> 00:24:44,618
<c.magenta>而需要使用引用语义</c>

525
00:24:44,685 --> 00:24:46,753
<c.magenta>针对文本</c>

526
00:24:47,754 --> 00:24:49,890
<c.magenta>因此 现在Apple</c>

527
00:24:49,957 --> 00:24:51,792
<c.magenta>但是我们还没有很好的解决方法</c>

528
00:24:51,925 --> 00:24:54,161
<c.magenta>因此 你们应该认识到</c>

529
00:24:54,394 --> 00:24:56,396
<c.magenta>如果你要处理</c>

530
00:24:56,463 --> 00:24:59,066
<c.magenta>并进行文本存储</c>

531
00:24:59,299 --> 00:25:00,901
<c.magenta>即使你不打算改变文本内容</c>

532
00:24:59,299 --> 00:25:00,901
<c.magenta>即使你不打算改变文本内容</c>

533
00:25:03,070 --> 00:25:04,137
<c.magenta>但是 当你</c>

534
00:25:04,204 --> 00:25:06,073
<c.magenta>将所有字符串访问</c>

535
00:25:06,139 --> 00:25:07,441
<c.magenta>让我们再次考虑性能象限图</c>

536
00:25:08,208 --> 00:25:10,043
<c.magenta>由于TextStorage API /b&gt;</c>

537
00:25:10,210 --> 00:25:13,480
<c.magenta>从频率的角度来看</c>

538
00:25:13,714 --> 00:25:15,182
<c.magenta>因此 真正的问题是</c>

539
00:25:15,449 --> 00:25:18,652
<c.magenta>你希望TextStorage</c>

540
00:25:20,120 --> 00:25:23,123
<c.magenta>1 KB？</c>

541
00:25:23,323 --> 00:25:25,292
<c.magenta>如果你使用字符串资产</c>

542
00:25:26,960 --> 00:25:29,162
<c.magenta>如果是1MB</c>

543
00:25:29,229 --> 00:25:30,731
<c.magenta>性能水平将位于第一象限</c>

544
00:25:30,864 --> 00:25:32,766
<c.magenta>你可能想要</c>

545
00:25:34,001 --> 00:25:37,004
<c.magenta>如果是1GB 那我真的希望</c>

546
00:25:39,106 --> 00:25:41,542
<c.magenta>前面我说过 我们正在</c>

547
00:25:41,642 --> 00:25:43,544
<c.magenta>请在未来的版本中</c>

548
00:25:45,412 --> 00:25:46,914
<c.magenta>现在 我们对于</c>

549
00:25:46,980 --> 00:25:49,283
<c.magenta>具有更透彻的理解</c>

550
00:25:52,553 --> 00:25:54,821
<c.magenta>我不知道你们是怎么想的</c>

551
00:25:54,888 --> 00:25:57,291
<c.magenta>使用范围和字符串索引时</c>

552
00:25:58,225 --> 00:26:00,127
<c.magenta>为了弄清楚原因 让我们来看</c>

553
00:25:58,225 --> 00:26:00,127
<c.magenta>为了弄清楚原因 让我们来看</c>

554
00:26:00,260 --> 00:26:02,162
<c.magenta>一个字符串 它含有用手捂脸的表情</c>

555
00:26:02,229 --> 00:26:04,398
<c.magenta>这有一点</c>

556
00:26:06,600 --> 00:26:07,568
<c.magenta>这是我们的字符串</c>

557
00:26:07,801 --> 00:26:10,003
<c.magenta>是一个长字符串</c>

558
00:26:10,771 --> 00:26:13,440
<c.magenta>这个角色</c>

559
00:26:13,674 --> 00:26:15,209
<c.magenta>有一个黄色的捂脸表情</c>

560
00:26:15,876 --> 00:26:18,645
<c.magenta>一个肤色修改器</c>

561
00:26:19,146 --> 00:26:20,314
<c.magenta>还有一个性别修改器</c>

562
00:26:21,415 --> 00:26:23,817
<c.magenta>这些图形组成部分</c>

563
00:26:24,017 --> 00:26:25,953
<c.magenta>字符串中还有</c>

564
00:26:26,019 --> 00:26:28,655
<c.magenta>一个零宽度连接器</c>

565
00:26:29,289 --> 00:26:31,425
<c.magenta>让我们来看</c>

566
00:26:31,491 --> 00:26:32,392
<c.magenta>Unicode Scalar值</c>

567
00:26:32,492 --> 00:26:33,961
<c.magenta>你可能不熟悉这个名词</c>

568
00:26:34,094 --> 00:26:37,097
<c.magenta>Unicode Scalar值是一个21位数字</c>

569
00:26:37,164 --> 00:26:39,299
<c.magenta>唯一地表示</c>

570
00:26:40,067 --> 00:26:42,669
<c.magenta>这是构成字符串的</c>

571
00:26:42,836 --> 00:26:45,606
<c.magenta>以及与这些值</c>

572
00:26:46,106 --> 00:26:48,509
<c.magenta>如果你从Unicode Scalar角度</c>

573
00:26:48,775 --> 00:26:50,310
<c.magenta>就会发现 它实际上</c>

574
00:26:50,377 --> 00:26:51,645
<c.magenta>其长度为5</c>

575
00:26:53,247 --> 00:26:54,381
<c.magenta>目前一切正常</c>

576
00:26:54,448 --> 00:26:56,416
<c.magenta>如果你使用</c>

577
00:26:56,884 --> 00:26:58,852
<c.magenta>但是如果你使用NSAttributedString</c>

578
00:26:59,186 --> 00:27:01,622
<c.magenta>或任何使用NSRange</c>

579
00:26:59,186 --> 00:27:01,622
<c.magenta>或任何使用NSRange</c>

580
00:27:01,989 --> 00:27:04,024
<c.magenta>它们实际上使用UTF-16</c>

581
00:27:04,558 --> 00:27:06,760
<c.magenta>因此 若你从UTF-16</c>

582
00:27:06,827 --> 00:27:09,696
<c.magenta>它实际上包含7个值</c>

583
00:27:10,464 --> 00:27:12,966
<c.magenta>这很容易让人感到困惑</c>

584
00:27:13,033 --> 00:27:15,035
<c.magenta>和字符串索引范围时</c>

585
00:27:16,904 --> 00:27:18,205
<c.magenta>因此 让我们来消除这些困惑</c>

586
00:27:18,272 --> 00:27:20,307
<c.magenta>我们来讨论</c>

587
00:27:20,374 --> 00:27:21,875
<c.magenta>它大量使用NSRange</c>

588
00:27:23,677 --> 00:27:24,978
<c.magenta>这里有一个字符串</c>

589
00:27:26,146 --> 00:27:28,282
<c.magenta>我想使用它</c>

590
00:27:28,348 --> 00:27:31,118
<c.magenta>并且将一个表情的</c>

591
00:27:34,154 --> 00:27:35,322
<c.magenta>这个工作比较复杂</c>

592
00:27:35,389 --> 00:27:38,025
<c.magenta>我自己都好几次</c>

593
00:27:39,560 --> 00:27:41,128
<c.magenta>我可能需要在网上查找</c>

594
00:27:41,195 --> 00:27:42,229
<c.magenta>然后</c>

595
00:27:42,362 --> 00:27:44,264
<c.magenta>我可能会编写</c>

596
00:27:45,232 --> 00:27:47,201
<c.magenta>看上去并不合适</c>

597
00:27:47,267 --> 00:27:50,003
<c.magenta>在这个字符串API</c>

598
00:27:51,071 --> 00:27:54,007
<c.magenta>我必须获取我的初始字符串</c>

599
00:27:54,074 --> 00:27:56,510
<c.magenta>然后使用NSString</c>

600
00:27:56,743 --> 00:27:57,778
<c.magenta>然后 我必须回过头来</c>

601
00:27:58,078 --> 00:27:59,980
<c.magenta>再次使用我的初始字符串</c>

602
00:28:00,047 --> 00:28:01,448
<c.magenta>创建我的NSMutableAttributedString</c>

603
00:28:01,849 --> 00:28:03,784
<c.magenta>哎 我可不喜欢这样做</c>

604
00:28:04,318 --> 00:28:05,485
<c.magenta>没有人喜欢这样做</c>

605
00:28:06,920 --> 00:28:08,856
<c.magenta>一个好消息是</c>

606
00:28:09,089 --> 00:28:11,425
<c.magenta>因为在Swift 4中</c>

607
00:28:11,491 --> 00:28:12,926
<c.magenta>引入新的初始化器</c>

608
00:28:13,560 --> 00:28:17,030
<c.magenta>因此 当我们使用</c>

609
00:28:17,631 --> 00:28:20,901
<c.magenta>同样的代码将会变得如此简短</c>

610
00:28:20,968 --> 00:28:23,704
<c.magenta>从而更容易识读</c>

611
00:28:24,204 --> 00:28:26,773
<c.magenta>这里使用的</c>

612
00:28:26,840 --> 00:28:28,542
<c.magenta>获取范围和Swift字符串</c>

613
00:28:28,609 --> 00:28:30,310
<c.magenta>并使用它创建NSRange</c>

614
00:28:30,377 --> 00:28:33,247
<c.magenta>你可以将它直接</c>

615
00:28:35,649 --> 00:28:37,718
<c.magenta>现在 让我们</c>

616
00:28:37,784 --> 00:28:39,553
<c.magenta>也就是从NSRange</c>

617
00:28:41,555 --> 00:28:42,523
<c.magenta>请看这个简单的例子</c>

618
00:28:42,589 --> 00:28:44,291
<c.magenta>假设我们有这样的html代码</c>

619
00:28:44,525 --> 00:28:46,260
<c.magenta>我们想要</c>

620
00:28:46,960 --> 00:28:48,295
<c.magenta>为此</c>

621
00:28:48,829 --> 00:28:51,131
<c.magenta>我们将使用NSRegularExpression</c>

622
00:28:51,198 --> 00:28:52,432
<c.magenta>然后将它们追加到字符串</c>

623
00:28:52,699 --> 00:28:53,567
<c.magenta>听上去很正确 是吧？</c>

624
00:28:55,602 --> 00:28:57,304
<c.magenta>但是NSRegularExpression API</c>

625
00:28:57,404 --> 00:28:59,339
<c.magenta>从我的匹配组中</c>

626
00:28:59,473 --> 00:29:01,074
<c.magenta>我需要字符串索引的范围</c>

627
00:28:59,473 --> 00:29:01,074
<c.magenta>我需要字符串索引的范围</c>

628
00:29:01,141 --> 00:29:02,743
<c.magenta>以便将内容追加到我的Swift字符串</c>

629
00:29:04,178 --> 00:29:06,446
<c.magenta>在这些新初始化器</c>

630
00:29:06,813 --> 00:29:08,048
<c.magenta>我们可能会使用这样的代码</c>

631
00:29:08,115 --> 00:29:10,384
<c.magenta>从NSRange</c>

632
00:29:11,151 --> 00:29:12,319
<c.magenta>请回忆几分钟前</c>

633
00:29:12,386 --> 00:29:15,055
<c.magenta>我们讲过的捂脸表情</c>

634
00:29:15,122 --> 00:29:16,423
<c.magenta>它的长度为7</c>

635
00:29:16,490 --> 00:29:18,392
<c.magenta>而从Unicode Scalar 的角度来看</c>

636
00:29:18,659 --> 00:29:23,263
<c.magenta>这段代码有一点复杂</c>

637
00:29:23,597 --> 00:29:24,698
<c.magenta>到Unicode Scalar的转换工作</c>

638
00:29:26,433 --> 00:29:27,968
<c.magenta>但是现在</c>

639
00:29:28,035 --> 00:29:29,269
<c.magenta>你不必自己完成这些工作</c>

640
00:29:29,803 --> 00:29:32,072
<c.magenta>我们可以获取NSRange</c>

641
00:29:32,372 --> 00:29:34,708
<c.magenta>然后用它创建</c>

642
00:29:34,775 --> 00:29:36,243
<c.magenta>然后直接追加到字符串</c>

643
00:29:36,844 --> 00:29:39,213
<c.magenta>这更加方便</c>

644
00:29:39,913 --> 00:29:41,281
<c.magenta>这些新初始化器</c>

645
00:29:41,348 --> 00:29:42,850
<c.magenta>我希望你们使用它们</c>

646
00:29:42,916 --> 00:29:44,918
<c.magenta>进行所有的Range</c>

647
00:29:47,321 --> 00:29:48,155
<c.magenta>谢谢</c>

648
00:29:49,923 --> 00:29:51,191
<c.magenta>关于Range就是这些</c>

649
00:29:51,258 --> 00:29:53,126
<c.magenta>让我们来讨论文本布局</c>

650
00:29:54,962 --> 00:29:55,796
<c.magenta>文本是硬内容</c>

651
00:29:56,597 --> 00:29:57,965
<c.magenta>在界面上 它看上去比较简单</c>

652
00:29:58,432 --> 00:29:59,766
<c.magenta>因为每个人都知道文本内容是什么</c>

653
00:30:00,100 --> 00:30:01,902
<c.magenta>所有人每天都会看到它</c>

654
00:30:02,236 --> 00:30:04,238
<c.magenta>文本常见而又普通</c>

655
00:30:04,771 --> 00:30:08,141
<c.magenta>因此 人们认为</c>

656
00:30:09,243 --> 00:30:10,410
<c.magenta>其实并不简单</c>

657
00:30:10,978 --> 00:30:12,880
<c.magenta>文本会带来</c>

658
00:30:12,946 --> 00:30:14,481
<c.magenta>因为它的大小变化多样</c>

659
00:30:16,717 --> 00:30:17,584
<c.magenta>请思考这样的例子</c>

660
00:30:17,651 --> 00:30:22,389
<c.magenta>我们的iOS有40个本地化版本</c>

661
00:30:23,690 --> 00:30:27,327
<c.magenta>watchOS有39个</c>

662
00:30:28,562 --> 00:30:29,830
<c.magenta>在所有这些平台上</c>

663
00:30:29,897 --> 00:30:32,799
<c.magenta>我们支持300种其它语言的</c>

664
00:30:34,468 --> 00:30:36,537
<c.magenta>每种语言都有</c>

665
00:30:36,603 --> 00:30:38,438
<c.magenta>比如</c>

666
00:30:38,839 --> 00:30:41,141
<c.magenta>这些会影响到分行</c>

667
00:30:41,275 --> 00:30:42,943
<c.magenta>从而影响文本布局</c>

668
00:30:43,143 --> 00:30:44,811
<c.magenta>进而影响文本呈现</c>

669
00:30:45,345 --> 00:30:46,847
<c.magenta>我们的框架</c>

670
00:30:46,914 --> 00:30:48,482
<c.magenta>处理所有这些语言</c>

671
00:30:50,217 --> 00:30:51,118
<c.magenta>如果这还不能说明问题</c>

672
00:30:51,185 --> 00:30:52,853
<c.magenta>让我们来看</c>

673
00:30:52,986 --> 00:30:54,388
<c.magenta>在执行文本和呈现时</c>

674
00:30:54,488 --> 00:30:56,123
<c.magenta>框架需要考虑的其它一些因素</c>

675
00:30:56,590 --> 00:30:57,991
<c.magenta>我们必须考虑所有这些因素</c>

676
00:30:58,058 --> 00:31:00,861
<c.magenta>以正确、高性能地</c>

677
00:30:58,058 --> 00:31:00,861
<c.magenta>以正确、高性能地</c>

678
00:31:01,094 --> 00:31:01,995
<c.magenta>因此我建议你们</c>

679
00:31:02,062 --> 00:31:04,631
<c.magenta>尽可能地</c>

680
00:31:05,532 --> 00:31:08,702
<c.magenta>由于要考虑许多不同的可变因素</c>

681
00:31:08,769 --> 00:31:10,838
<c.magenta>多种底层</c>

682
00:31:11,471 --> 00:31:14,408
<c.magenta>必须根据具体的情况</c>

683
00:31:14,474 --> 00:31:16,476
<c.magenta>而且必须满足多个条件</c>

684
00:31:16,610 --> 00:31:17,711
<c.magenta>以正确地应用策略</c>

685
00:31:18,812 --> 00:31:20,614
<c.magenta>我想要提醒你们</c>

686
00:31:20,681 --> 00:31:22,616
<c.magenta>当你们在标准控件基础上</c>

687
00:31:22,683 --> 00:31:24,017
<c.magenta>必须非常小心</c>

688
00:31:24,551 --> 00:31:26,653
<c.magenta>因为呈现条件或</c>

689
00:31:26,820 --> 00:31:29,489
<c.magenta>可能会让你的优化失效</c>

690
00:31:31,124 --> 00:31:32,459
<c.magenta>为了描述我的含义</c>

691
00:31:32,526 --> 00:31:35,362
<c.magenta>让我们来看一个例子</c>

692
00:31:37,464 --> 00:31:38,565
<c.magenta>曾经有一位开发者</c>

693
00:31:39,032 --> 00:31:41,668
<c.magenta>想要在她的应用中</c>

694
00:31:42,603 --> 00:31:45,072
<c.magenta>而且每个标签</c>

695
00:31:45,305 --> 00:31:47,107
<c.magenta>后面是一行普通文本</c>

696
00:31:48,141 --> 00:31:51,211
<c.magenta>她想要手动设置标准边框</c>

697
00:31:51,278 --> 00:31:52,946
<c.magenta>这是出于商业原因</c>

698
00:31:54,882 --> 00:31:57,784
<c.magenta>她使用属性字符串</c>

699
00:31:59,486 --> 00:32:02,256
<c.magenta>但是她注意到</c>

700
00:31:59,486 --> 00:32:02,256
<c.magenta>但是她注意到</c>

701
00:32:02,322 --> 00:32:04,091
<c.magenta>低于她的预期</c>

702
00:32:04,892 --> 00:32:06,393
<c.magenta>因此她进行分析</c>

703
00:32:06,793 --> 00:32:09,396
<c.magenta>结果发现</c>

704
00:32:09,463 --> 00:32:11,398
<c.magenta>花费了大量的时间</c>

705
00:32:13,066 --> 00:32:14,701
<c.magenta>于是 她做了一些试验</c>

706
00:32:15,002 --> 00:32:19,973
<c.magenta>然后注意到</c>

707
00:32:20,207 --> 00:32:21,842
<c.magenta>应用滚动显示性能将会得到提升</c>

708
00:32:22,242 --> 00:32:23,610
<c.magenta>“这太神奇了” 她心里想到</c>

709
00:32:23,877 --> 00:32:24,711
<c.magenta>于是她修改应用</c>

710
00:32:24,778 --> 00:32:26,346
<c.magenta>每个行都使用单独的标签</c>

711
00:32:26,547 --> 00:32:27,948
<c.magenta>然后她感到很高兴</c>

712
00:32:28,015 --> 00:32:31,618
<c.magenta>直到有一天 她的公司</c>

713
00:32:33,053 --> 00:32:35,489
<c.magenta>于是她使用中文</c>

714
00:32:36,056 --> 00:32:37,591
<c.magenta>她吃惊地发现</c>

715
00:32:37,891 --> 00:32:41,028
<c.magenta>滚动显示性能</c>

716
00:32:42,262 --> 00:32:43,430
<c.magenta>这到底是怎么了？</c>

717
00:32:44,998 --> 00:32:47,868
<c.magenta>这位开发者</c>

718
00:32:48,268 --> 00:32:50,938
<c.magenta>她看到许多短字符串</c>

719
00:32:51,305 --> 00:32:53,106
<c.magenta>从而让性能水平落入第二象限</c>

720
00:32:54,508 --> 00:32:56,143
<c.magenta>因此 她采取一些措施</c>

721
00:32:56,276 --> 00:32:57,744
<c.magenta>找到改进突破口</c>

722
00:32:57,811 --> 00:32:59,513
<c.magenta>于是进行优化</c>

723
00:33:00,447 --> 00:33:03,083
<c.magenta>但是 当输入数据</c>

724
00:33:03,217 --> 00:33:05,385
<c.magenta>优化无法</c>

725
00:33:06,286 --> 00:33:08,088
<c.magenta>为了弄清楚原因 我们进行事后分析</c>

726
00:33:09,489 --> 00:33:10,457
<c.magenta>在这个例子中</c>

727
00:33:10,724 --> 00:33:12,926
<c.magenta>初始条件</c>

728
00:33:13,060 --> 00:33:14,928
<c.magenta>更快速地显示</c>

729
00:33:15,596 --> 00:33:18,265
<c.magenta>优化方法</c>

730
00:33:18,398 --> 00:33:20,267
<c.magenta>利用这样一个特性</c>

731
00:33:20,334 --> 00:33:23,770
<c.magenta>属性化字符串</c>

732
00:33:25,472 --> 00:33:28,308
<c.magenta>但是 要实现更快速的呈现</c>

733
00:33:28,909 --> 00:33:30,944
<c.magenta>快速呈现方案会走捷径</c>

734
00:33:31,011 --> 00:33:33,080
<c.magenta>对输入数据和</c>

735
00:33:33,146 --> 00:33:34,381
<c.magenta>进行特定的预测</c>

736
00:33:34,615 --> 00:33:37,317
<c.magenta>在本例中 使用中文文本</c>

737
00:33:37,384 --> 00:33:39,086
<c.magenta>强制在框架内</c>

738
00:33:39,152 --> 00:33:40,988
<c.magenta>呈现路径</c>

739
00:33:42,055 --> 00:33:42,923
<c.magenta>在此基础上</c>

740
00:33:42,990 --> 00:33:44,791
<c.magenta>将双行字符串</c>

741
00:33:44,858 --> 00:33:47,761
<c.magenta>意味着将需要</c>

742
00:33:50,097 --> 00:33:52,966
<c.magenta>此外应用使用陈旧的布局方法</c>

743
00:33:53,033 --> 00:33:55,569
<c.magenta>手动设置边框</c>

744
00:33:56,270 --> 00:33:58,172
<c.magenta>因此一般来说</c>

745
00:33:58,238 --> 00:34:00,807
<c.magenta>比如自动布局</c>

746
00:33:58,238 --> 00:34:00,807
<c.magenta>比如自动布局</c>

747
00:34:00,874 --> 00:34:01,708
<c.magenta>特定条件下的性能问题</c>

748
00:34:01,775 --> 00:34:03,410
<c.magenta>因为多数应用都会使用这些技术</c>

749
00:34:03,477 --> 00:34:04,912
<c.magenta>且在这些方面</c>

750
00:34:04,978 --> 00:34:06,113
<c.magenta>最大的影响</c>

751
00:34:07,047 --> 00:34:08,282
<c.magenta>以自动布局为例</c>

752
00:34:08,348 --> 00:34:10,617
<c.magenta>文本系统缓存</c>

753
00:34:10,851 --> 00:34:12,219
<c.magenta>这可以切实地提升性能</c>

754
00:34:12,286 --> 00:34:14,188
<c.magenta>但是由于这个应用</c>

755
00:34:14,721 --> 00:34:15,856
<c.magenta>因此无法利用这一优势</c>

756
00:34:17,190 --> 00:34:18,192
<c.magenta>因此请记住</c>

757
00:34:18,559 --> 00:34:20,694
<c.magenta>有一些策略和技巧</c>

758
00:34:20,761 --> 00:34:23,797
<c.magenta>改进应用中的文本布局</c>

759
00:34:25,666 --> 00:34:26,733
<c.magenta>若你一直在认真听讲</c>

760
00:34:26,800 --> 00:34:28,668
<c.magenta>你可能已知道</c>

761
00:34:30,237 --> 00:34:32,139
<c.magenta>使用标准标签</c>

762
00:34:32,306 --> 00:34:33,907
<c.magenta>其它的幕后工作请交给我们</c>

763
00:34:34,675 --> 00:34:37,177
<c.magenta>在框架中</c>

764
00:34:37,244 --> 00:34:39,413
<c.magenta>因为它能够概览地</c>

765
00:34:39,478 --> 00:34:41,547
<c.magenta>并且提供关于</c>

766
00:34:42,516 --> 00:34:44,384
<c.magenta>当我们进行性能优化之后</c>

767
00:34:44,451 --> 00:34:46,286
<c.magenta>你们将自动获得这些好处</c>

768
00:34:46,887 --> 00:34:48,054
<c.magenta>来看一个例子</c>

769
00:34:48,422 --> 00:34:51,058
<c.magenta>在macOS 10.13中 NSTextField的</c>

770
00:34:51,123 --> 00:34:54,360
<c.magenta>文本呈现速度提高三倍</c>

771
00:34:54,527 --> 00:34:55,529
<c.magenta>速度达到5.7毫秒/帧</c>

772
00:34:55,762 --> 00:34:59,132
<c.magenta>相比以前的</c>

773
00:34:59,800 --> 00:35:01,735
<c.magenta>你们将会免费</c>

774
00:34:59,800 --> 00:35:01,735
<c.magenta>你们将会免费</c>

775
00:35:01,802 --> 00:35:03,437
<c.magenta>如果你们使用</c>

776
00:35:03,871 --> 00:35:04,872
<c.magenta>因此 使用标准控制</c>

777
00:35:04,938 --> 00:35:07,007
<c.magenta>确实是很好的做法</c>

778
00:35:10,444 --> 00:35:12,546
<c.magenta>第二个策略</c>

779
00:35:13,080 --> 00:35:14,948
<c.magenta>应该使用最新的布局方法</c>

780
00:35:15,516 --> 00:35:16,917
<c.magenta>我们认真地研究了</c>

781
00:35:16,984 --> 00:35:18,018
<c.magenta>使用新技术</c>

782
00:35:18,085 --> 00:35:20,287
<c.magenta>所获得的文本布局和呈现性能提升</c>

783
00:35:20,888 --> 00:35:22,623
<c.magenta>通过采用这些新技术</c>

784
00:35:22,689 --> 00:35:25,158
<c.magenta>将很少会遇到</c>

785
00:35:25,225 --> 00:35:26,860
<c.magenta>边界情况</c>

786
00:35:30,797 --> 00:35:32,432
<c.magenta>接下来介绍一个基本技巧</c>

787
00:35:32,799 --> 00:35:34,668
<c.magenta>如果你使用NSAttributedString</c>

788
00:35:34,968 --> 00:35:35,903
<c.magenta>有一些属性</c>

789
00:35:35,969 --> 00:35:38,438
<c.magenta>对于布局和呈现来说</c>

790
00:35:39,339 --> 00:35:41,275
<c.magenta>如果你没有</c>

791
00:35:41,375 --> 00:35:44,178
<c.magenta>文本系统将需要处理它们</c>

792
00:35:44,545 --> 00:35:46,446
<c.magenta>因此 如果你自己提供</c>

793
00:35:46,513 --> 00:35:48,115
<c.magenta>在呈现属性化字符串时</c>

794
00:35:48,348 --> 00:35:49,650
<c.magenta>可以节约一些时间</c>

795
00:35:52,186 --> 00:35:53,153
<c.magenta>同样地</c>

796
00:35:53,453 --> 00:35:54,655
<c.magenta>显式指定写入方向和对齐</c>

797
00:35:54,721 --> 00:35:57,491
<c.magenta>而不是使用默认设置</c>

798
00:35:57,558 --> 00:35:59,059
<c.magenta>少量的性能提升</c>

799
00:35:59,960 --> 00:36:01,061
<c.magenta>这将帮助你节约一些时间</c>

800
00:35:59,960 --> 00:36:01,061
<c.magenta>这将帮助你节约一些时间</c>

801
00:36:01,128 --> 00:36:02,996
<c.magenta>因为文本系统</c>

802
00:36:03,063 --> 00:36:05,399
<c.magenta>无需花费时间来确定</c>

803
00:36:06,500 --> 00:36:07,968
<c.magenta>但是请记住</c>

804
00:36:08,035 --> 00:36:10,204
<c.magenta>你必须绝对确定</c>

805
00:36:10,270 --> 00:36:12,206
<c.magenta>不会包含混合式写入方向</c>

806
00:36:12,539 --> 00:36:14,675
<c.magenta>现在 我们已经在</c>

807
00:36:14,875 --> 00:36:17,311
<c.magenta>一个优化方法是</c>

808
00:36:17,444 --> 00:36:20,147
<c.magenta>可以让平衡点</c>

809
00:36:23,584 --> 00:36:26,086
<c.magenta>这些代码描述如何</c>

810
00:36:26,420 --> 00:36:29,389
<c.magenta>如果你知道你的所有标签</c>

811
00:36:29,723 --> 00:36:31,658
<c.magenta>你可以设置换行模式</c>

812
00:36:32,392 --> 00:36:34,628
<c.magenta>默认情况下</c>

813
00:36:34,795 --> 00:36:36,930
<c.magenta>当你这样做时</c>

814
00:36:36,997 --> 00:36:38,198
<c.magenta>在哪些位置进行分行</c>

815
00:36:38,599 --> 00:36:40,367
<c.magenta>如果你使用</c>

816
00:36:40,467 --> 00:36:43,136
<c.magenta>将会跳过这个分行</c>

817
00:36:43,203 --> 00:36:45,172
<c.magenta>文本呈现速度</c>

818
00:36:47,875 --> 00:36:50,410
<c.magenta>最后进行总结</c>

819
00:36:50,511 --> 00:36:52,312
<c.magenta>从Foundation 中的</c>

820
00:36:52,546 --> 00:36:54,548
<c.magenta>到字符串桥接和文本处理</c>

821
00:36:55,182 --> 00:36:56,984
<c.magenta>如果你只能记住本演讲中的</c>

822
00:36:57,217 --> 00:36:58,085
<c.magenta>那么应该是这个图表</c>

823
00:36:58,685 --> 00:37:00,654
<c.magenta>请使用规模和频率概念</c>

824
00:36:58,685 --> 00:37:00,654
<c.magenta>请使用规模和频率概念</c>

825
00:37:00,787 --> 00:37:03,390
<c.magenta>最低限度减少代码中的</c>

826
00:37:03,724 --> 00:37:05,259
<c.magenta>不要专注于不常用的项目</c>

827
00:37:05,592 --> 00:37:07,261
<c.magenta>在不确定时 应该进行评估</c>

828
00:37:10,063 --> 00:37:12,833
<c.magenta>想了解更多内容</c>

829
00:37:12,933 --> 00:37:14,234
<c.magenta>本演讲是244</c>

830
00:37:15,769 --> 00:37:19,406
<c.magenta>另外请观看</c>

831
00:37:19,840 --> 00:37:22,309
<c.magenta>它们非常不错 遗憾的是</c>

832
00:37:23,277 --> 00:37:24,945
<c.magenta>谢谢</c>
