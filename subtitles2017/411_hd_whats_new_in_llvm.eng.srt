1
00:00:07,516 --> 00:00:16,500
[ Background Conversations ]

2
00:00:21,516 --> 00:00:25,586
[ Applause ]

3
00:00:26,086 --> 00:00:28,446
&gt;&gt; Hello. Welcome to What's New

4
00:00:28,446 --> 00:00:29,016
in LLVM.

5
00:00:29,736 --> 00:00:31,396
I'm Devin, an engineer on the

6
00:00:31,396 --> 00:00:32,646
Program Analysis Team.

7
00:00:33,636 --> 00:00:35,656
We've got a lot of great, new

8
00:00:35,656 --> 00:00:36,766
features to tell you about

9
00:00:36,766 --> 00:00:37,076
today.

10
00:00:38,266 --> 00:00:39,616
We'll start by introducing you

11
00:00:39,846 --> 00:00:41,306
to availability checking for

12
00:00:41,306 --> 00:00:41,976
Objective-C.

13
00:00:41,976 --> 00:00:44,086
This will help you safely deploy

14
00:00:44,086 --> 00:00:46,136
your apps back to older OS's.

15
00:00:47,186 --> 00:00:48,246
Then, we'll describe new static

16
00:00:48,246 --> 00:00:49,626
analyzer checks and compiler

17
00:00:49,626 --> 00:00:51,506
warnings to help you find bugs.

18
00:00:52,676 --> 00:00:54,336
We'll dive into some fantastic,

19
00:00:54,336 --> 00:00:56,196
new features for C++ developers,

20
00:00:56,646 --> 00:00:58,366
including a tour of refactoring

21
00:00:58,366 --> 00:01:01,056
support for C++ in Xcode, and

22
00:00:58,366 --> 00:01:01,056
support for C++ in Xcode, and

23
00:01:01,056 --> 00:01:02,866
wrap up with an update on

24
00:01:02,866 --> 00:01:03,996
link-time optimization.

25
00:01:04,506 --> 00:01:07,786
Let's start with availability

26
00:01:07,786 --> 00:01:08,000
checking.

27
00:01:10,556 --> 00:01:12,316
Every major OS release comes

28
00:01:12,606 --> 00:01:14,556
with great, new features, and

29
00:01:14,556 --> 00:01:16,096
your customers expect you to

30
00:01:16,096 --> 00:01:18,046
adopt these APIs in your apps.

31
00:01:19,086 --> 00:01:20,256
But you still have to support

32
00:01:20,256 --> 00:01:22,626
your users on older OS's where

33
00:01:22,626 --> 00:01:24,136
those APIs aren't available.

34
00:01:24,136 --> 00:01:29,246
On our platforms, we support

35
00:01:29,246 --> 00:01:30,766
backwards deployment by

36
00:01:30,766 --> 00:01:32,686
separating the Base SDK version

37
00:01:32,946 --> 00:01:34,026
from the deployment target

38
00:01:34,026 --> 00:01:34,456
version.

39
00:01:35,296 --> 00:01:36,716
What this means is that you will

40
00:01:36,716 --> 00:01:38,586
always compile against the

41
00:01:38,586 --> 00:01:41,286
newest SDK, even when deploying

42
00:01:41,286 --> 00:01:42,496
back to older OS's.

43
00:01:43,266 --> 00:01:45,736
So for example, in Xcode 9, you

44
00:01:45,736 --> 00:01:49,326
use the iOS 11 SDK, and if your

45
00:01:49,326 --> 00:01:52,086
app only targets iOS 11, you'll

46
00:01:52,086 --> 00:01:53,716
use that as the deployment

47
00:01:53,716 --> 00:01:54,596
target as well.

48
00:01:55,146 --> 00:01:57,666
But I know a lot of you will

49
00:01:57,666 --> 00:01:59,466
want to support your users on

50
00:01:59,546 --> 00:02:01,606
iOS 10 to give them a chance to

51
00:01:59,546 --> 00:02:01,606
iOS 10 to give them a chance to

52
00:02:01,606 --> 00:02:02,216
upgrade.

53
00:02:03,416 --> 00:02:04,406
To do that, you can go to your

54
00:02:04,406 --> 00:02:07,126
Build settings and select 10.0

55
00:02:07,516 --> 00:02:08,656
for your deployment target.

56
00:02:09,756 --> 00:02:11,346
This is a promise on the part of

57
00:02:11,346 --> 00:02:12,886
your app that it will support

58
00:02:12,886 --> 00:02:15,296
all versions of iOS 10 and

59
00:02:15,296 --> 00:02:15,746
greater.

60
00:02:15,746 --> 00:02:20,976
Now, this can be tricky because

61
00:02:21,136 --> 00:02:23,416
it's only safe to call APIs that

62
00:02:23,486 --> 00:02:25,656
are actually available on the

63
00:02:25,656 --> 00:02:26,496
running OS.

64
00:02:27,236 --> 00:02:29,476
If you call in newer API on an

65
00:02:29,476 --> 00:02:31,486
older OS, then your app could

66
00:02:31,486 --> 00:02:33,146
crash or have other unexpected

67
00:02:33,146 --> 00:02:33,646
behavior.

68
00:02:33,646 --> 00:02:37,766
In the past, we've recommended

69
00:02:37,766 --> 00:02:39,676
querying the Objective-C runtime

70
00:02:40,106 --> 00:02:41,896
to determine whether an API is

71
00:02:41,896 --> 00:02:42,386
available.

72
00:02:43,496 --> 00:02:45,236
But this was easy to get wrong

73
00:02:45,236 --> 00:02:47,346
or even forget, and it was hard

74
00:02:47,346 --> 00:02:47,836
to test.

75
00:02:49,286 --> 00:02:51,336
Further, it required a different

76
00:02:51,436 --> 00:02:54,586
syntax for checking each of

77
00:02:55,136 --> 00:02:58,066
globals, functions, classes,

78
00:02:58,576 --> 00:03:00,296
instance methods, and class

79
00:02:58,576 --> 00:03:00,296
instance methods, and class

80
00:03:00,296 --> 00:03:00,666
methods.

81
00:03:01,286 --> 00:03:04,956
Now, those of you using Swift

82
00:03:04,956 --> 00:03:06,896
may be wondering, what's the big

83
00:03:06,896 --> 00:03:07,696
deal here?

84
00:03:07,956 --> 00:03:09,426
Swift has a unified syntax,

85
00:03:09,476 --> 00:03:11,516
#available, for querying API

86
00:03:11,516 --> 00:03:13,466
availability at runtime, and the

87
00:03:13,466 --> 00:03:16,176
compiler can even catch missing

88
00:03:16,176 --> 00:03:18,346
availability checks at compile

89
00:03:18,786 --> 00:03:18,876
time.

90
00:03:20,656 --> 00:03:21,936
For more information on

91
00:03:21,936 --> 00:03:22,996
availability in Swift, you

92
00:03:22,996 --> 00:03:24,406
should check out the Swift in

93
00:03:24,406 --> 00:03:29,276
Practice talk from WWDC 2015.

94
00:03:29,376 --> 00:03:31,396
Today we brought Swift-style

95
00:03:31,396 --> 00:03:32,816
availability checking to

96
00:03:32,816 --> 00:03:33,516
Objective-C.

97
00:03:34,516 --> 00:03:39,406
[ Applause ]

98
00:03:39,906 --> 00:03:41,096
I would love to tell you about

99
00:03:41,946 --> 00:03:42,000
it.

100
00:03:43,046 --> 00:03:44,726
So suppose you have an app that

101
00:03:44,896 --> 00:03:46,796
you're deploying back to iOS 10

102
00:03:47,726 --> 00:03:49,536
and you decide to take advantage

103
00:03:49,716 --> 00:03:51,956
of the fantastic, new face

104
00:03:51,956 --> 00:03:53,806
detection APIs from the Vision

105
00:03:53,806 --> 00:03:55,426
framework in iOS 11.

106
00:03:56,626 --> 00:03:57,886
When you add these APIs to your

107
00:03:57,886 --> 00:04:00,606
app and then build, you will now

108
00:03:57,886 --> 00:04:00,606
app and then build, you will now

109
00:04:00,606 --> 00:04:02,706
get a compiler warning telling

110
00:04:02,706 --> 00:04:04,736
you that these APIs are only

111
00:04:04,736 --> 00:04:07,046
available in iOS 11 or newer.

112
00:04:07,576 --> 00:04:10,336
You can address these warnings

113
00:04:10,696 --> 00:04:12,866
by using the new @available

114
00:04:12,866 --> 00:04:14,826
construct to query for API

115
00:04:14,826 --> 00:04:15,486
availability.

116
00:04:16,565 --> 00:04:18,656
This will return true when iOS

117
00:04:18,656 --> 00:04:20,466
11 APIs are available.

118
00:04:20,916 --> 00:04:23,076
It's safe to call them.

119
00:04:23,266 --> 00:04:24,266
And if they're not, you can

120
00:04:24,266 --> 00:04:25,236
provide a fallback.

121
00:04:26,516 --> 00:04:28,636
Let's take a closer look at the

122
00:04:28,856 --> 00:04:29,000
query.

123
00:04:31,046 --> 00:04:35,046
As I mentioned, on iOS 11 or

124
00:04:35,046 --> 00:04:37,176
greater, this will return true.

125
00:04:37,736 --> 00:04:40,026
The star is required.

126
00:04:40,996 --> 00:04:42,676
It indicates that on all other

127
00:04:42,676 --> 00:04:44,976
platforms, the query always

128
00:04:44,976 --> 00:04:45,796
returns true.

129
00:04:47,166 --> 00:04:48,316
What this means is that if you

130
00:04:48,316 --> 00:04:49,906
decide to port your app to

131
00:04:49,906 --> 00:04:51,806
another platform -- say, macOS

132
00:04:52,486 --> 00:04:54,286
-- then by default it will take

133
00:04:54,286 --> 00:04:55,626
advantage of the new face

134
00:04:55,626 --> 00:04:56,676
detection APIs.

135
00:04:57,736 --> 00:04:58,656
Of course, the compiler will

136
00:04:58,656 --> 00:05:00,276
still warn you if your port to

137
00:04:58,656 --> 00:05:00,276
still warn you if your port to

138
00:05:00,276 --> 00:05:02,146
macOS supports an earlier

139
00:05:02,146 --> 00:05:03,406
deployment target where those

140
00:05:03,406 --> 00:05:04,696
APIs aren't available.

141
00:05:04,986 --> 00:05:08,786
So you'll need to add a check.

142
00:05:10,066 --> 00:05:11,166
Once you've been working with

143
00:05:11,166 --> 00:05:12,756
availability for a while, you

144
00:05:12,756 --> 00:05:14,476
will find that it's really

145
00:05:14,476 --> 00:05:16,536
useful to write entire methods

146
00:05:16,846 --> 00:05:18,956
that will only be called on iOS

147
00:05:18,956 --> 00:05:19,726
11 or greater.

148
00:05:19,786 --> 00:05:23,236
You can annotate these methods

149
00:05:23,236 --> 00:05:25,056
with the new API availability

150
00:05:25,056 --> 00:05:25,516
macro.

151
00:05:26,936 --> 00:05:29,316
Then, inside that method, you

152
00:05:29,316 --> 00:05:31,216
don't need to use @available to

153
00:05:31,216 --> 00:05:33,356
check for availability, but

154
00:05:33,356 --> 00:05:35,386
anyone who calls the method will

155
00:05:35,386 --> 00:05:36,166
need to do so.

156
00:05:36,526 --> 00:05:37,366
Otherwise, they'll get a

157
00:05:37,366 --> 00:05:37,776
warning.

158
00:05:38,136 --> 00:05:42,026
You can similarly apply this to

159
00:05:42,026 --> 00:05:42,886
entire classes.

160
00:05:43,476 --> 00:05:44,216
Then, you don't need to use

161
00:05:44,216 --> 00:05:46,266
@available inside the class, but

162
00:05:46,266 --> 00:05:48,046
anyone who instantiates it will

163
00:05:48,046 --> 00:05:48,766
need to do so.

164
00:05:52,756 --> 00:05:54,446
Now, availability checking is

165
00:05:54,446 --> 00:05:55,946
not just for Objective-C.

166
00:05:56,706 --> 00:05:59,286
We also support C and C++ with

167
00:05:59,286 --> 00:06:00,916
the builtin available query.

168
00:05:59,286 --> 00:06:00,916
the builtin available query.

169
00:06:01,856 --> 00:06:03,456
This acts exactly like

170
00:06:03,456 --> 00:06:04,346
@available.

171
00:06:04,656 --> 00:06:05,786
It has the same syntax.

172
00:06:06,356 --> 00:06:07,576
It just has a different name

173
00:06:07,746 --> 00:06:08,926
that's compatible with C and

174
00:06:08,926 --> 00:06:09,626
C++.

175
00:06:10,156 --> 00:06:13,176
You can also use the API

176
00:06:13,176 --> 00:06:15,196
availability macro in C, but you

177
00:06:15,196 --> 00:06:16,366
will need to include the os

178
00:06:16,366 --> 00:06:18,836
availability.h header to get

179
00:06:18,836 --> 00:06:19,646
access to it.

180
00:06:20,096 --> 00:06:23,186
And you can even annotate your

181
00:06:23,186 --> 00:06:24,756
C++ class definitions.

182
00:06:24,756 --> 00:06:28,396
All right, so how's this going

183
00:06:28,716 --> 00:06:31,716
to work in practice?

184
00:06:31,716 --> 00:06:33,736
For existing projects, we will

185
00:06:33,736 --> 00:06:35,566
warn starting with APIs

186
00:06:35,566 --> 00:06:38,816
introduced in iOS 11, tvOS 11,

187
00:06:38,816 --> 00:06:41,396
macOS 10.13, and watchOS 4.

188
00:06:42,496 --> 00:06:45,226
APIs from older SDKs will not be

189
00:06:45,226 --> 00:06:46,406
checked at compile time.

190
00:06:47,676 --> 00:06:48,866
This means that you won't need

191
00:06:48,866 --> 00:06:51,576
to change any existing code, but

192
00:06:51,576 --> 00:06:53,596
if you do decide to adopt the

193
00:06:53,596 --> 00:06:55,856
new APIs, you'll need to use

194
00:06:55,856 --> 00:06:57,466
@available to check for them.

195
00:06:58,656 --> 00:06:59,726
We think this is the best and

196
00:06:59,726 --> 00:07:00,726
safest way to check for

197
00:06:59,726 --> 00:07:00,726
safest way to check for

198
00:07:00,726 --> 00:07:02,386
availability, and so we highly

199
00:07:02,386 --> 00:07:03,966
encourage you to use it.

200
00:07:05,726 --> 00:07:08,896
For new projects, all APIs will

201
00:07:08,896 --> 00:07:10,196
be checked at compile time.

202
00:07:11,026 --> 00:07:12,376
This means you'll need to use

203
00:07:12,376 --> 00:07:13,986
@available for all APIs

204
00:07:13,986 --> 00:07:15,976
introduced after your deployment

205
00:07:16,376 --> 00:07:16,566
target.

206
00:07:17,736 --> 00:07:20,036
Existing projects can opt in to

207
00:07:20,036 --> 00:07:22,316
this all-API behavior by going

208
00:07:22,316 --> 00:07:23,686
to the Build settings and

209
00:07:23,686 --> 00:07:25,926
selecting Yes (All Versions) for

210
00:07:25,926 --> 00:07:27,036
the Unguarded availability

211
00:07:27,036 --> 00:07:27,386
setting.

212
00:07:28,186 --> 00:07:30,006
This is going to make it a lot

213
00:07:30,006 --> 00:07:31,846
easier to safely deploy your

214
00:07:31,846 --> 00:07:33,326
apps back to older OS's.

215
00:07:33,886 --> 00:07:36,376
So that's availability checking.

216
00:07:36,726 --> 00:07:37,606
You could say it's now

217
00:07:37,606 --> 00:07:40,506
@available for C, C++, and

218
00:07:40,506 --> 00:07:41,156
Objective-C.

219
00:07:42,516 --> 00:07:47,686
[ Applause ]

220
00:07:48,186 --> 00:07:49,896
All right, let's move on to the

221
00:07:49,896 --> 00:07:50,716
static analyzer.

222
00:07:52,096 --> 00:07:54,976
The analyzer is great at

223
00:07:54,976 --> 00:07:56,426
catching hard-to-reproduce

224
00:07:56,526 --> 00:07:58,706
edge-case bugs, and it can even

225
00:07:58,706 --> 00:07:59,876
show you the sequence of

226
00:07:59,876 --> 00:08:01,936
corner-case events that led to

227
00:07:59,876 --> 00:08:01,936
corner-case events that led to

228
00:08:02,016 --> 00:08:03,276
those bugs.

229
00:08:03,556 --> 00:08:04,406
Today I'm going to tell you

230
00:08:04,406 --> 00:08:05,656
about three new checks that

231
00:08:05,656 --> 00:08:07,926
we've added to the analyzer: a

232
00:08:07,926 --> 00:08:09,426
check for suspicious comparison

233
00:08:09,426 --> 00:08:11,466
of NSNumber, a check for use of

234
00:08:11,466 --> 00:08:12,756
dispatch once on instance

235
00:08:12,756 --> 00:08:14,546
variables, and a check for

236
00:08:14,546 --> 00:08:16,346
auto-synthesized copy properties

237
00:08:16,636 --> 00:08:18,346
of NSMutable type.

238
00:08:20,756 --> 00:08:24,596
A particularly pernicious bug is

239
00:08:24,596 --> 00:08:26,506
to mistakenly compare an

240
00:08:26,506 --> 00:08:28,396
NSNumber pointer value to the

241
00:08:28,396 --> 00:08:30,836
scalar zero because this

242
00:08:31,036 --> 00:08:33,486
actually compares to nil and not

243
00:08:33,486 --> 00:08:34,976
the zero NSNumber instance.

244
00:08:36,025 --> 00:08:37,006
Here's an example of how this

245
00:08:37,006 --> 00:08:37,936
can be a problem.

246
00:08:39,116 --> 00:08:40,885
In the hasPhotos method, the

247
00:08:40,885 --> 00:08:43,706
programmer intends to return no

248
00:08:43,856 --> 00:08:45,156
when the photo album is empty,

249
00:08:46,136 --> 00:08:47,236
but because they're comparing

250
00:08:47,236 --> 00:08:49,866
the photo count to nil, this

251
00:08:49,866 --> 00:08:52,216
will actually return yes, even

252
00:08:52,216 --> 00:08:54,266
when photo count holds the zero

253
00:08:54,316 --> 00:08:55,356
NSNumber instance.

254
00:08:56,036 --> 00:08:57,206
And so the analyzer will now

255
00:08:57,206 --> 00:08:59,876
warn about this.

256
00:09:00,106 --> 00:09:02,336
You can fix this error by

257
00:09:02,336 --> 00:09:03,986
instead calling the integerValue

258
00:09:03,986 --> 00:09:06,196
property to compare integers to

259
00:09:06,196 --> 00:09:06,756
integers.

260
00:09:07,106 --> 00:09:07,686
This is safe.

261
00:09:08,236 --> 00:09:11,626
There's a similar problem with

262
00:09:11,626 --> 00:09:14,056
implicit conversions to Booleans

263
00:09:14,446 --> 00:09:16,466
because these also check for nil

264
00:09:16,496 --> 00:09:17,746
and not the zero number.

265
00:09:18,276 --> 00:09:20,956
This method counts the number of

266
00:09:21,046 --> 00:09:23,286
faces in a photo, and since this

267
00:09:23,286 --> 00:09:24,966
is an expensive operation, it

268
00:09:24,966 --> 00:09:26,576
returns early if they've already

269
00:09:26,576 --> 00:09:27,216
been counted.

270
00:09:28,276 --> 00:09:29,776
But someone reading this code

271
00:09:30,066 --> 00:09:31,436
might find it ambiguous.

272
00:09:32,356 --> 00:09:33,546
Did the programmer intend to

273
00:09:33,546 --> 00:09:35,656
return early if face count was

274
00:09:35,656 --> 00:09:37,806
non-nil or non-zero?

275
00:09:38,806 --> 00:09:40,396
The analyzer will now warn about

276
00:09:40,396 --> 00:09:41,546
this kind of ambiguity.

277
00:09:41,976 --> 00:09:44,446
In this case, the programmer

278
00:09:44,446 --> 00:09:47,386
meant non-nil, and so she can

279
00:09:47,476 --> 00:09:49,136
express her intent directly in

280
00:09:49,136 --> 00:09:51,126
the code and silence the

281
00:09:51,126 --> 00:09:53,476
analyzer warning by adding the

282
00:09:53,476 --> 00:09:54,896
comparison explicitly.

283
00:09:55,456 --> 00:09:59,106
You can control the level of

284
00:09:59,106 --> 00:10:00,316
this check in your Build

285
00:09:59,106 --> 00:10:00,316
this check in your Build

286
00:10:00,316 --> 00:10:00,656
setting.

287
00:10:01,486 --> 00:10:02,956
If you choose Yes (Aggressive),

288
00:10:03,606 --> 00:10:05,566
then the analyzer will warn when

289
00:10:05,566 --> 00:10:06,786
it's not sure that you've made a

290
00:10:06,786 --> 00:10:08,486
mistake, but it does think your

291
00:10:08,486 --> 00:10:09,326
code is ambiguous.

292
00:10:09,946 --> 00:10:13,696
Let's move on to dispatch once.

293
00:10:16,076 --> 00:10:17,776
Grand Central Dispatch provides

294
00:10:17,866 --> 00:10:20,896
a fantastic API, dispatch once,

295
00:10:21,096 --> 00:10:22,306
that guarantees that a block is

296
00:10:22,306 --> 00:10:24,256
called once and only once.

297
00:10:24,896 --> 00:10:27,276
It is really useful for safely

298
00:10:27,276 --> 00:10:28,436
initializing shared global

299
00:10:28,436 --> 00:10:28,836
state.

300
00:10:29,946 --> 00:10:31,576
In this example, the programmer

301
00:10:32,186 --> 00:10:34,186
uses it to load and initialize a

302
00:10:34,186 --> 00:10:36,136
shared array of photos.

303
00:10:37,616 --> 00:10:39,516
The first argument to dispatch

304
00:10:39,516 --> 00:10:41,336
once is the address of a

305
00:10:41,336 --> 00:10:43,176
variable of a special type,

306
00:10:43,506 --> 00:10:44,696
dispatch once t.

307
00:10:45,546 --> 00:10:46,846
Grand Central Dispatch uses this

308
00:10:47,156 --> 00:10:48,926
to make sure that the block is

309
00:10:48,926 --> 00:10:51,606
only called once.

310
00:10:51,686 --> 00:10:53,846
Now, it's really important that

311
00:10:53,846 --> 00:10:56,046
this variable be either a static

312
00:10:56,266 --> 00:10:57,276
or a global variable.

313
00:10:58,276 --> 00:10:59,756
That's because if it's ever been

314
00:10:59,756 --> 00:11:01,556
the case that the variable held

315
00:10:59,756 --> 00:11:01,556
the case that the variable held

316
00:11:01,556 --> 00:11:03,266
a non-zero value in the past,

317
00:11:04,086 --> 00:11:05,206
then Grand Central Dispatch

318
00:11:05,426 --> 00:11:06,916
might not be able to make the

319
00:11:06,916 --> 00:11:09,006
once and only once guarantee in

320
00:11:09,006 --> 00:11:09,986
multithreaded code.

321
00:11:10,506 --> 00:11:14,356
What this means is that it's not

322
00:11:14,576 --> 00:11:17,306
safe to use dispatch once t in

323
00:11:17,306 --> 00:11:19,146
instance variables or, indeed,

324
00:11:19,146 --> 00:11:21,696
in any other memory on the heap

325
00:11:22,156 --> 00:11:23,316
that might have been reused.

326
00:11:23,986 --> 00:11:25,056
And so the analyzer will now

327
00:11:25,056 --> 00:11:26,486
warn about this.

328
00:11:27,296 --> 00:11:29,686
To fix this, you can use your

329
00:11:29,786 --> 00:11:31,496
favorite non-recursive lock.

330
00:11:32,306 --> 00:11:34,076
Here I'll use NSLock, but you

331
00:11:34,076 --> 00:11:35,916
could use OSUnfairLock or a

332
00:11:35,916 --> 00:11:37,016
pthread mutex as well.

333
00:11:38,416 --> 00:11:41,316
After acquiring the lock, check

334
00:11:41,316 --> 00:11:42,346
to see whether the data's

335
00:11:42,346 --> 00:11:43,506
initialized, and if not,

336
00:11:43,506 --> 00:11:46,336
initialize it, and then don't

337
00:11:46,406 --> 00:11:48,346
forget to release the lock.

338
00:11:49,236 --> 00:11:50,706
This will guarantee that the

339
00:11:50,706 --> 00:11:52,376
data's initialized once and only

340
00:11:52,376 --> 00:11:54,056
once, exactly like you expect.

341
00:11:54,416 --> 00:12:00,026
Finally, I'm going to tell you

342
00:11:54,416 --> 00:12:00,026
Finally, I'm going to tell you

343
00:12:00,026 --> 00:12:01,576
about a check that we've added

344
00:12:01,876 --> 00:12:03,786
for auto-synthesized copy

345
00:12:03,786 --> 00:12:05,766
properties of NSMutable types.

346
00:12:07,236 --> 00:12:09,066
Copy properties call the copy

347
00:12:09,066 --> 00:12:11,096
method in their setter on the

348
00:12:11,096 --> 00:12:12,976
passed-in value to story a copy.

349
00:12:14,006 --> 00:12:16,736
But calling copy on a mutable

350
00:12:16,736 --> 00:12:18,916
array results in an immutable

351
00:12:18,916 --> 00:12:19,346
copy.

352
00:12:20,416 --> 00:12:21,166
Here's how this can be a

353
00:12:21,166 --> 00:12:21,676
problem.

354
00:12:22,606 --> 00:12:25,296
It, this method tries to reset

355
00:12:25,296 --> 00:12:27,306
the photos property by setting

356
00:12:27,306 --> 00:12:29,406
it to an empty mutable array and

357
00:12:29,406 --> 00:12:31,896
then adding in a single photo.

358
00:12:33,196 --> 00:12:34,866
Unfortunately, this will lead to

359
00:12:34,866 --> 00:12:37,236
a really nasty surprise at

360
00:12:37,236 --> 00:12:39,856
runtime because you can't add an

361
00:12:39,856 --> 00:12:41,766
object to an immutable array.

362
00:12:42,596 --> 00:12:43,496
You'll get an exception.

363
00:12:44,056 --> 00:12:46,826
The analyzer will now warn you

364
00:12:46,826 --> 00:12:48,166
about these kinds of properties

365
00:12:48,216 --> 00:12:50,156
to help you prevent this runtime

366
00:12:50,156 --> 00:12:50,666
exception.

367
00:12:51,216 --> 00:12:53,666
The fix here is simple.

368
00:12:54,116 --> 00:12:55,716
All you need to do is write the

369
00:12:55,716 --> 00:12:57,516
setter explicitly to have it

370
00:12:57,516 --> 00:12:58,626
call mutableCopy.

371
00:12:59,426 --> 00:13:00,326
This guarantees that your

372
00:12:59,426 --> 00:13:00,326
This guarantees that your

373
00:13:00,326 --> 00:13:02,946
property always holds a mutable

374
00:13:02,946 --> 00:13:03,000
array.

375
00:13:06,236 --> 00:13:07,706
So those are just three of the

376
00:13:07,706 --> 00:13:08,736
new checks that we've added to

377
00:13:08,736 --> 00:13:09,746
the analyzer this year.

378
00:13:10,606 --> 00:13:11,776
You should run it on your code.

379
00:13:11,776 --> 00:13:13,186
It will help you find bugs.

380
00:13:14,556 --> 00:13:16,656
To do that, choose Analyze from

381
00:13:16,656 --> 00:13:17,626
Xcode's Product menu.

382
00:13:19,086 --> 00:13:20,606
You could even have Xcode run

383
00:13:20,606 --> 00:13:23,566
the analyzer on every compile by

384
00:13:23,566 --> 00:13:25,186
going to your Build settings and

385
00:13:25,186 --> 00:13:27,096
enabling Analyze During 'Build.'

386
00:13:27,096 --> 00:13:29,086
This will help you catch your

387
00:13:29,086 --> 00:13:30,336
bugs early and often.

388
00:13:30,976 --> 00:13:33,136
If you're interested in other

389
00:13:33,136 --> 00:13:34,626
tools to help you find bugs, I

390
00:13:34,956 --> 00:13:36,496
highly encourage you to check

391
00:13:36,496 --> 00:13:38,266
out finding bugs using Xcode

392
00:13:38,266 --> 00:13:39,566
runtime tools online.

393
00:13:39,566 --> 00:13:41,916
So that's what's new in the

394
00:13:41,916 --> 00:13:42,466
analyzer.

395
00:13:42,916 --> 00:13:44,616
I'm not going to hand it over to

396
00:13:44,616 --> 00:13:46,266
Duncan, who will tell us about

397
00:13:46,266 --> 00:13:47,316
new compiler warnings.

398
00:13:48,516 --> 00:13:54,046
[ Applause ]

399
00:13:54,546 --> 00:13:57,766
&gt;&gt; Thanks, Devin.

400
00:13:58,576 --> 00:14:00,986
Xcode 9 comes with over 100 new

401
00:13:58,576 --> 00:14:00,986
Xcode 9 comes with over 100 new

402
00:14:00,986 --> 00:14:02,526
errors and warnings to help find

403
00:14:02,526 --> 00:14:03,426
bugs in your code.

404
00:14:03,746 --> 00:14:05,626
Let's talk about two warnings

405
00:14:05,626 --> 00:14:06,466
that are important for

406
00:14:06,466 --> 00:14:07,166
Objective-C.

407
00:14:09,686 --> 00:14:11,896
Under ARC, most parameters are

408
00:14:11,896 --> 00:14:13,346
safe to capture in blocks.

409
00:14:13,876 --> 00:14:16,356
In this example, the

410
00:14:16,356 --> 00:14:18,256
validateDictionary usingChecker

411
00:14:18,256 --> 00:14:21,036
method takes an NSDictionary and

412
00:14:21,036 --> 00:14:22,716
visits every entry by calling

413
00:14:22,716 --> 00:14:24,256
enumerateKeysAndObjects

414
00:14:24,256 --> 00:14:24,886
UsingBlock.

415
00:14:26,336 --> 00:14:28,216
Block captures the checker

416
00:14:28,216 --> 00:14:28,746
parameter.

417
00:14:29,466 --> 00:14:30,846
This is safe and works really

418
00:14:30,846 --> 00:14:31,096
well.

419
00:14:32,906 --> 00:14:34,796
Notice the checkObject forKey

420
00:14:35,066 --> 00:14:35,536
can fail.

421
00:14:36,376 --> 00:14:38,856
The block sets stop to yes to

422
00:14:38,856 --> 00:14:40,226
abort the enumeration early.

423
00:14:41,576 --> 00:14:43,546
Since this is a validation

424
00:14:43,546 --> 00:14:45,016
method, it should also return

425
00:14:45,016 --> 00:14:46,546
BOOL and create an NS error.

426
00:14:47,116 --> 00:14:48,066
Let's make that change.

427
00:14:49,636 --> 00:14:52,006
OK. Let's walk through the code.

428
00:14:52,356 --> 00:14:54,196
Before enumerating, isValid is

429
00:14:54,196 --> 00:14:54,896
set to yes.

430
00:14:55,586 --> 00:14:57,716
The block runs the checker and

431
00:14:57,716 --> 00:14:58,856
returns on success.

432
00:14:59,906 --> 00:15:02,326
If the checker fails, isValid is

433
00:14:59,906 --> 00:15:02,326
If the checker fails, isValid is

434
00:15:02,326 --> 00:15:04,356
set to no and an NS error is

435
00:15:04,356 --> 00:15:04,796
created.

436
00:15:06,236 --> 00:15:08,616
After enumerating, isValid is

437
00:15:08,616 --> 00:15:10,916
returned, but there's a bug

438
00:15:10,916 --> 00:15:11,156
here.

439
00:15:12,596 --> 00:15:14,626
Out parameters like error are

440
00:15:14,626 --> 00:15:16,066
implicitly autoreleasing.

441
00:15:16,676 --> 00:15:18,826
Assigning to them is not safe in

442
00:15:19,566 --> 00:15:20,316
a block.

443
00:15:20,926 --> 00:15:22,266
enumerateKeysAndObjects

444
00:15:22,266 --> 00:15:24,236
UsingBlock calls the block

445
00:15:24,236 --> 00:15:25,586
inside an autorelease pool.

446
00:15:26,536 --> 00:15:28,476
When it returns, the NS error

447
00:15:28,476 --> 00:15:29,696
will get destroyed as well.

448
00:15:30,416 --> 00:15:31,796
It isn't safe to use.

449
00:15:32,316 --> 00:15:36,336
In Xcode 9, this unsafe capture

450
00:15:36,336 --> 00:15:37,266
will trigger a warning.

451
00:15:38,496 --> 00:15:40,696
The easiest fix is to make the

452
00:15:40,696 --> 00:15:41,866
out parameter a strong

453
00:15:41,866 --> 00:15:42,496
reference.

454
00:15:43,156 --> 00:15:44,576
This will keep the value alive

455
00:15:44,816 --> 00:15:46,606
across any autorelease pools.

456
00:15:47,856 --> 00:15:49,286
This works as long as all

457
00:15:49,286 --> 00:15:50,876
callers of validateDictionary

458
00:15:50,876 --> 00:15:52,496
usingChecker are using ARC.

459
00:15:54,026 --> 00:15:55,556
The other option is to use a

460
00:15:55,556 --> 00:15:56,756
local block variable.

461
00:15:57,836 --> 00:16:00,036
Here strongError is initialized

462
00:15:57,836 --> 00:16:00,036
Here strongError is initialized

463
00:16:00,036 --> 00:16:00,406
to nil.

464
00:16:01,126 --> 00:16:03,316
If the enumeration stops early,

465
00:16:03,566 --> 00:16:05,886
strongError safely stores the NS

466
00:16:05,886 --> 00:16:06,226
error.

467
00:16:07,466 --> 00:16:09,186
Then, the out parameter is

468
00:16:09,186 --> 00:16:11,056
updated after the enumeration is

469
00:16:11,056 --> 00:16:11,516
complete.

470
00:16:12,006 --> 00:16:14,816
That's the first warning.

471
00:16:15,656 --> 00:16:16,676
Let's move on to the second.

472
00:16:17,976 --> 00:16:19,786
In this example, the function

473
00:16:19,786 --> 00:16:21,476
foo is declared without any

474
00:16:21,476 --> 00:16:22,106
parameters.

475
00:16:23,686 --> 00:16:25,876
In C and Objective-C, that means

476
00:16:25,876 --> 00:16:27,296
that foo can be called with any

477
00:16:27,296 --> 00:16:28,976
number or type of argument.

478
00:16:30,026 --> 00:16:31,236
A function with an empty

479
00:16:31,236 --> 00:16:32,696
parameter list is called a

480
00:16:32,696 --> 00:16:34,366
non-prototype declaration.

481
00:16:35,646 --> 00:16:36,926
This behavior dates from the

482
00:16:36,996 --> 00:16:38,886
early days of C where parameters

483
00:16:38,886 --> 00:16:40,256
were only listed at function

484
00:16:40,256 --> 00:16:41,716
definitions, but this

485
00:16:41,716 --> 00:16:43,496
declaration is not type safe.

486
00:16:44,026 --> 00:16:45,416
This is never really what you

487
00:16:45,416 --> 00:16:45,766
want.

488
00:16:46,446 --> 00:16:47,406
Calls that don't match the

489
00:16:47,406 --> 00:16:49,826
definition can crash at runtime.

490
00:16:50,796 --> 00:16:52,866
In Xcode 9, the compiler has a

491
00:16:52,866 --> 00:16:54,416
new warning that enforces strict

492
00:16:54,416 --> 00:16:55,026
prototypes.

493
00:16:57,696 --> 00:17:00,126
Usually, the fix is to add void.

494
00:16:57,696 --> 00:17:00,126
Usually, the fix is to add void.

495
00:17:00,806 --> 00:17:02,656
This specifies exactly zero

496
00:17:02,656 --> 00:17:03,366
parameters.

497
00:17:03,766 --> 00:17:05,496
Any calls with arguments will

498
00:17:05,496 --> 00:17:06,116
give an error.

499
00:17:07,656 --> 00:17:08,965
Since function pointers and

500
00:17:08,965 --> 00:17:10,756
blocks have a common declaration

501
00:17:10,756 --> 00:17:12,796
syntax with functions, you'll

502
00:17:12,796 --> 00:17:14,086
also see this if you have a

503
00:17:14,086 --> 00:17:15,896
function or method that takes a

504
00:17:15,896 --> 00:17:16,976
block as an argument.

505
00:17:18,236 --> 00:17:19,836
The fix is the same as with

506
00:17:19,836 --> 00:17:20,955
function declarations.

507
00:17:21,445 --> 00:17:23,715
Add void to specify exactly zero

508
00:17:23,715 --> 00:17:24,496
parameters.

509
00:17:25,346 --> 00:17:26,846
Then, you'll get an error if you

510
00:17:26,846 --> 00:17:28,566
pass in a block with the wrong

511
00:17:29,456 --> 00:17:29,566
type.

512
00:17:30,256 --> 00:17:32,286
Xcode's project modernization

513
00:17:32,366 --> 00:17:33,826
will turn these warnings on in

514
00:17:33,826 --> 00:17:35,816
your Build settings, or you can

515
00:17:35,846 --> 00:17:37,356
upgrade later by selecting your

516
00:17:37,356 --> 00:17:39,026
project and choosing Validate

517
00:17:39,026 --> 00:17:40,346
Settings from the Editor menu.

518
00:17:40,916 --> 00:17:43,816
You can also upgrade new

519
00:17:43,816 --> 00:17:45,486
warnings to errors by selecting

520
00:17:45,676 --> 00:17:47,266
Yes (Error) in the Build

521
00:17:47,266 --> 00:17:47,716
settings.

522
00:17:49,196 --> 00:17:50,146
That's it today for new

523
00:17:50,146 --> 00:17:50,706
warnings.

524
00:17:52,146 --> 00:17:53,516
Let's move on to C++.

525
00:17:55,036 --> 00:17:57,466
This year, we've put a lot of

526
00:17:57,466 --> 00:17:59,286
effort into improving the C++

527
00:17:59,286 --> 00:18:00,426
experience in Xcode.

528
00:17:59,286 --> 00:18:00,426
experience in Xcode.

529
00:18:01,856 --> 00:18:02,996
That includes refactoring

530
00:18:02,996 --> 00:18:03,426
support.

531
00:18:04,106 --> 00:18:05,866
We support a lot of operations.

532
00:18:06,406 --> 00:18:08,286
I'd like to give a short tour of

533
00:18:08,286 --> 00:18:10,536
using Xcode to refactor LLVM.

534
00:18:10,536 --> 00:18:13,976
This is a large C++ code base

535
00:18:13,976 --> 00:18:15,076
that shows off the engine.

536
00:18:16,336 --> 00:18:18,316
But even if you're not a C++

537
00:18:18,316 --> 00:18:19,796
developer, you could still get

538
00:18:19,796 --> 00:18:21,596
an idea of how refactoring in

539
00:18:21,626 --> 00:18:23,096
Xcode can improve your work

540
00:18:23,096 --> 00:18:23,336
flow.

541
00:18:23,906 --> 00:18:27,136
I started at a member function

542
00:18:27,136 --> 00:18:28,646
definition from the InstCombiner

543
00:18:28,646 --> 00:18:29,146
class.

544
00:18:30,276 --> 00:18:31,746
This is a utility for combining

545
00:18:31,746 --> 00:18:32,466
instructions.

546
00:18:33,766 --> 00:18:35,546
I never liked the Inst short

547
00:18:35,546 --> 00:18:37,376
form for instruction, so I

548
00:18:37,376 --> 00:18:39,026
Command-clicked in Xcode and

549
00:18:39,026 --> 00:18:39,796
selected Rename.

550
00:18:41,686 --> 00:18:43,576
This worked even though I wasn't

551
00:18:43,576 --> 00:18:44,746
at the class declaration.

552
00:18:46,446 --> 00:18:48,026
InstructionCombiner is more

553
00:18:48,026 --> 00:18:48,516
clear to me.

554
00:18:50,416 --> 00:18:52,406
Xcode updated the name in place.

555
00:18:52,406 --> 00:18:53,856
This saved me a lot of hunting

556
00:18:53,856 --> 00:18:54,096
around.

557
00:18:54,726 --> 00:18:57,096
I double-checked the class

558
00:18:57,096 --> 00:18:57,736
declaration.

559
00:18:58,266 --> 00:18:59,266
It was updated too.

560
00:19:00,346 --> 00:19:02,846
So was its use in the CRTP base

561
00:19:02,846 --> 00:19:04,216
class, InstVisitor.

562
00:19:05,556 --> 00:19:07,496
InstVisitor uses the same short

563
00:19:07,496 --> 00:19:08,746
form, and so does

564
00:19:08,806 --> 00:19:10,036
InstCombineWorklist.

565
00:19:10,636 --> 00:19:11,726
But I had better leave those for

566
00:19:11,726 --> 00:19:12,336
a separate commit.

567
00:19:14,216 --> 00:19:15,796
Since changing a class name from

568
00:19:15,796 --> 00:19:17,046
one of its member functions

569
00:19:17,046 --> 00:19:18,766
worked, I moved on to something

570
00:19:18,796 --> 00:19:19,856
even more complicated.

571
00:19:20,596 --> 00:19:21,556
I went to a template

572
00:19:21,556 --> 00:19:23,176
specialization for simplified

573
00:19:23,176 --> 00:19:26,026
type, a utility we use on smart

574
00:19:26,026 --> 00:19:27,646
pointers and custom iterators.

575
00:19:28,156 --> 00:19:30,746
I think the function

576
00:19:30,816 --> 00:19:32,956
getSimplifiedValue is named

577
00:19:32,956 --> 00:19:33,406
wrong.

578
00:19:34,066 --> 00:19:35,626
It should use STL naming

579
00:19:35,626 --> 00:19:37,396
conventions like its class name.

580
00:19:38,416 --> 00:19:39,526
I selected Rename again.

581
00:19:40,886 --> 00:19:42,056
Tying together template

582
00:19:42,056 --> 00:19:43,826
specializations from across the

583
00:19:43,826 --> 00:19:46,146
project is complicated, but

584
00:19:46,146 --> 00:19:47,586
Xcode can handle it.

585
00:19:48,256 --> 00:19:50,466
The specialization I was looking

586
00:19:50,466 --> 00:19:52,656
at was updated and so was the

587
00:19:52,656 --> 00:19:53,846
main template declaration.

588
00:19:54,996 --> 00:19:56,326
There's another specialization

589
00:19:56,326 --> 00:19:58,246
right below, and it was fixed

590
00:19:58,926 --> 00:19:59,000
too.

591
00:20:01,396 --> 00:20:03,386
Next, I moved to Constants.h,

592
00:20:03,676 --> 00:20:04,856
where we have a class called

593
00:20:04,896 --> 00:20:06,556
ConstantInt for representing

594
00:20:06,736 --> 00:20:07,616
constant integers.

595
00:20:08,736 --> 00:20:09,816
It has nice convenience

596
00:20:09,816 --> 00:20:11,476
functions for getting true and

597
00:20:11,476 --> 00:20:12,466
false values.

598
00:20:13,666 --> 00:20:15,516
I added declarations for a

599
00:20:15,516 --> 00:20:17,406
getMax function to get the

600
00:20:17,406 --> 00:20:18,816
maximum integer value.

601
00:20:20,296 --> 00:20:21,976
Then, I Command-clicked and

602
00:20:21,976 --> 00:20:23,146
generated the missing function

603
00:20:23,146 --> 00:20:26,086
definitions for each of them.

604
00:20:26,686 --> 00:20:28,476
Here they are in Constants.cpp.

605
00:20:29,576 --> 00:20:31,486
What I like about this is where

606
00:20:31,486 --> 00:20:32,666
the functions showed up in the

607
00:20:32,666 --> 00:20:33,076
file.

608
00:20:34,276 --> 00:20:35,556
My new definitions were

609
00:20:35,556 --> 00:20:37,356
generated after the last member

610
00:20:37,356 --> 00:20:38,926
functions defined for the same

611
00:20:38,926 --> 00:20:42,186
class, ConstantInt, but before

612
00:20:42,186 --> 00:20:43,476
the member functions for the

613
00:20:43,476 --> 00:20:44,196
next class.

614
00:20:45,496 --> 00:20:46,996
This is exactly where I want

615
00:20:46,996 --> 00:20:47,196
them.

616
00:20:48,516 --> 00:20:53,826
[ Applause ]

617
00:20:54,326 --> 00:20:56,006
LVM has lots of code for

618
00:20:56,006 --> 00:20:57,076
representing integers.

619
00:20:57,626 --> 00:20:58,896
I had a look at this greatest

620
00:20:58,896 --> 00:21:00,636
common divisor function, and I

621
00:20:58,896 --> 00:21:00,636
common divisor function, and I

622
00:21:00,636 --> 00:21:02,996
noticed a local variable, Pow2,

623
00:21:02,996 --> 00:21:03,916
that is complicated to

624
00:21:03,916 --> 00:21:04,466
calculate.

625
00:21:05,836 --> 00:21:07,686
Its computation really belongs

626
00:21:07,686 --> 00:21:08,546
in its own function.

627
00:21:10,346 --> 00:21:11,856
I selected the code and opened

628
00:21:11,856 --> 00:21:13,566
the contextual menu, where I

629
00:21:13,566 --> 00:21:15,276
clicked on Extract Function.

630
00:21:15,276 --> 00:21:17,156
I was a little sloppy with my

631
00:21:17,156 --> 00:21:19,016
selection, but Xcode is smart

632
00:21:19,016 --> 00:21:20,136
enough that it worked anyway.

633
00:21:21,466 --> 00:21:23,116
That entered me straight into

634
00:21:23,116 --> 00:21:24,266
rename at the bottom of the

635
00:21:24,266 --> 00:21:24,656
screen.

636
00:21:25,466 --> 00:21:27,976
I chose countCommonPowersOf2.

637
00:21:29,276 --> 00:21:30,496
Let's scroll up and look at the

638
00:21:30,496 --> 00:21:31,036
definition.

639
00:21:31,776 --> 00:21:33,886
The key thing here is that the

640
00:21:33,886 --> 00:21:35,626
arguments A and B were

641
00:21:35,656 --> 00:21:36,926
automatically captured by

642
00:21:36,926 --> 00:21:37,626
reference.

643
00:21:38,696 --> 00:21:40,286
That's important because they're

644
00:21:40,286 --> 00:21:41,046
being modified.

645
00:21:41,826 --> 00:21:45,206
Extract Function got it right.

646
00:21:45,856 --> 00:21:47,336
Extracting the function was a

647
00:21:47,336 --> 00:21:49,336
nice opportunity to clean up the

648
00:21:49,336 --> 00:21:50,996
code to use early returns.

649
00:21:53,496 --> 00:21:55,466
That got me bouncing around a

650
00:21:55,466 --> 00:21:56,996
little, and I found this code in

651
00:21:56,996 --> 00:21:58,386
the optimizer for unrolling

652
00:21:58,386 --> 00:21:58,866
loops.

653
00:21:59,976 --> 00:22:02,666
I noticed a call to getLoopFor

654
00:21:59,976 --> 00:22:02,666
I noticed a call to getLoopFor

655
00:22:02,736 --> 00:22:03,686
and an if statement.

656
00:22:05,066 --> 00:22:06,586
The same function is called with

657
00:22:06,586 --> 00:22:08,696
the same argument again right

658
00:22:08,696 --> 00:22:11,206
below in a while loop.

659
00:22:11,776 --> 00:22:13,446
getLoopFor does a hash table

660
00:22:13,446 --> 00:22:14,786
lookup, which isn't free.

661
00:22:15,596 --> 00:22:17,146
Since the while loop doesn't

662
00:22:17,146 --> 00:22:18,816
change the hash table, I

663
00:22:18,816 --> 00:22:20,446
Command-clicked and selected

664
00:22:20,546 --> 00:22:22,356
Extract Repeated Expression.

665
00:22:24,286 --> 00:22:25,526
This stored the result of the

666
00:22:25,526 --> 00:22:27,056
function call in a local

667
00:22:27,056 --> 00:22:28,896
variable, so it was only called

668
00:22:28,896 --> 00:22:30,636
once, and then I immediately

669
00:22:30,636 --> 00:22:31,676
used Rename.

670
00:22:32,286 --> 00:22:35,036
I chose the name LoopLatch.

671
00:22:35,606 --> 00:22:37,566
That was easy.

672
00:22:38,066 --> 00:22:39,856
Extract and Rename work cleanly

673
00:22:39,856 --> 00:22:40,256
together.

674
00:22:42,676 --> 00:22:44,706
After all that refactoring, I

675
00:22:44,706 --> 00:22:45,846
thought I'd write some new code.

676
00:22:47,266 --> 00:22:48,856
ArrayRef is a generalized

677
00:22:48,856 --> 00:22:50,526
reference to contiguous values,

678
00:22:50,996 --> 00:22:52,776
whether they're in an STL vector

679
00:22:52,886 --> 00:22:54,806
or in one of LVM's custom data

680
00:22:54,806 --> 00:22:55,466
structures.

681
00:22:56,466 --> 00:22:58,016
Notice that ArrayRef is

682
00:22:58,016 --> 00:22:59,886
templated on the value type in

683
00:22:59,886 --> 00:23:00,286
the array.

684
00:22:59,886 --> 00:23:00,286
the array.

685
00:23:01,356 --> 00:23:03,116
I thought it might be useful to

686
00:23:03,116 --> 00:23:04,626
compare two ArrayRefs.

687
00:23:05,486 --> 00:23:06,886
Why not implement a string like

688
00:23:06,886 --> 00:23:07,476
comparison?

689
00:23:08,466 --> 00:23:09,896
I need to loop from zero to the

690
00:23:09,896 --> 00:23:11,416
minimum size between left-hand

691
00:23:11,416 --> 00:23:12,766
side and right-hand side.

692
00:23:13,586 --> 00:23:14,756
When I hit the dot after

693
00:23:14,756 --> 00:23:16,796
left-hand side, code completion

694
00:23:16,796 --> 00:23:17,276
kicked in.

695
00:23:18,286 --> 00:23:20,666
Remember, left-hand side is

696
00:23:20,706 --> 00:23:21,886
templated on T here.

697
00:23:22,366 --> 00:23:24,866
That's pretty cool.

698
00:23:25,626 --> 00:23:27,676
Code completion works with

699
00:23:27,676 --> 00:23:29,716
templates, new in Xcode 9.

700
00:23:30,516 --> 00:23:36,226
[ Applause ]

701
00:23:36,726 --> 00:23:38,526
And that's C++ refactoring and

702
00:23:38,526 --> 00:23:39,966
code completion in Xcode.

703
00:23:40,316 --> 00:23:43,226
Let's talk about a few features

704
00:23:43,226 --> 00:23:44,926
from the C++17 standard.

705
00:23:45,436 --> 00:23:49,056
I'll start with STL's tuple, a

706
00:23:49,056 --> 00:23:51,476
useful type from C++11 that

707
00:23:51,476 --> 00:23:53,166
enables multiple return values.

708
00:23:54,126 --> 00:23:55,536
But decomposing it is awkward.

709
00:23:56,386 --> 00:23:58,176
Decomposition requires a tie

710
00:23:58,176 --> 00:24:00,706
around the variables, the types

711
00:23:58,176 --> 00:24:00,706
around the variables, the types

712
00:24:00,706 --> 00:24:02,716
can't be inferred, and the

713
00:24:02,716 --> 00:24:03,856
variable names need to be

714
00:24:03,856 --> 00:24:04,486
duplicated.

715
00:24:05,746 --> 00:24:07,906
C++17 solves this with

716
00:24:07,906 --> 00:24:10,136
structured binding, which binds

717
00:24:10,136 --> 00:24:11,676
names directly to the returned

718
00:24:11,836 --> 00:24:12,886
tuple elements.

719
00:24:14,666 --> 00:24:16,066
This is a great feature.

720
00:24:16,226 --> 00:24:17,436
Now, it's much easier to work

721
00:24:17,436 --> 00:24:18,126
with tuples.

722
00:24:18,706 --> 00:24:20,016
Structured binding can be used

723
00:24:20,016 --> 00:24:21,526
anywhere get can be used.

724
00:24:22,246 --> 00:24:23,976
It also works out of the box

725
00:24:24,016 --> 00:24:25,316
with plain-old data types like

726
00:24:25,416 --> 00:24:25,676
Point.

727
00:24:26,726 --> 00:24:28,476
The syntax is exactly the same

728
00:24:28,476 --> 00:24:29,316
as with tuples.

729
00:24:29,596 --> 00:24:32,486
That's structured binding.

730
00:24:33,136 --> 00:24:35,656
The next feature is initializers

731
00:24:35,656 --> 00:24:36,586
in if statements.

732
00:24:38,216 --> 00:24:39,006
Here's an example.

733
00:24:39,806 --> 00:24:41,656
The initializer finds the last

734
00:24:41,656 --> 00:24:43,176
slash in a path string.

735
00:24:43,876 --> 00:24:45,616
The slash variable scope is

736
00:24:45,616 --> 00:24:46,906
limited to the if statement.

737
00:24:48,626 --> 00:24:50,016
Then, the condition checks

738
00:24:50,176 --> 00:24:51,456
whether slash was found.

739
00:24:52,926 --> 00:24:55,296
If so, then slash is used to

740
00:24:55,296 --> 00:24:57,556
split the path.

741
00:24:58,036 --> 00:24:59,086
The same feature works for

742
00:24:59,086 --> 00:24:59,906
switch statements.

743
00:25:01,406 --> 00:25:02,786
Minimizing the scope of the

744
00:25:02,786 --> 00:25:04,946
slash variable helps to prevent

745
00:25:04,946 --> 00:25:05,406
bugs.

746
00:25:06,136 --> 00:25:07,656
If this function continues,

747
00:25:07,896 --> 00:25:09,606
we'll get an error if we try to

748
00:25:09,666 --> 00:25:11,086
reuse the slash variable.

749
00:25:11,926 --> 00:25:13,866
This is good because the logic

750
00:25:13,866 --> 00:25:14,506
is unrelated.

751
00:25:15,026 --> 00:25:18,756
Let's move on to a feature for

752
00:25:18,756 --> 00:25:19,806
templated functions.

753
00:25:21,556 --> 00:25:23,356
Advance is a simple template

754
00:25:23,356 --> 00:25:24,736
algorithm for in advancing an

755
00:25:24,736 --> 00:25:25,226
iterator.

756
00:25:26,006 --> 00:25:27,446
It has been in the STL for a

757
00:25:27,446 --> 00:25:29,546
long time, but let's use it as

758
00:25:29,546 --> 00:25:30,076
an example.

759
00:25:31,166 --> 00:25:32,616
For n greater than 0, it moves

760
00:25:32,616 --> 00:25:35,086
the iterator forward, and for n

761
00:25:35,086 --> 00:25:36,076
less than 0, it moves the

762
00:25:36,076 --> 00:25:37,566
iterator backward.

763
00:25:38,776 --> 00:25:40,536
For example, you might want to

764
00:25:40,536 --> 00:25:42,376
look ahead five nodes in a

765
00:25:42,376 --> 00:25:43,036
linked list.

766
00:25:43,766 --> 00:25:45,546
Advance will count forward one

767
00:25:45,546 --> 00:25:46,026
by one.

768
00:25:47,936 --> 00:25:50,406
The same code works for getting

769
00:25:50,406 --> 00:25:51,706
the fifth character in a string.

770
00:25:52,346 --> 00:25:53,826
It's powerful to have the same

771
00:25:53,826 --> 00:25:55,496
interface for advancing in both

772
00:25:55,496 --> 00:25:56,276
data structures.

773
00:25:57,486 --> 00:25:59,656
But this code is really slow for

774
00:25:59,656 --> 00:26:00,236
strings.

775
00:25:59,656 --> 00:26:00,236
strings.

776
00:26:00,676 --> 00:26:02,156
For strings in arrays, which

777
00:26:02,156 --> 00:26:03,976
have random access iterators, we

778
00:26:03,976 --> 00:26:04,616
don't need a loop.

779
00:26:05,416 --> 00:26:06,946
Operator + will jump ahead in

780
00:26:06,946 --> 00:26:07,636
concept time.

781
00:26:08,186 --> 00:26:11,516
But adding a simple if statement

782
00:26:11,516 --> 00:26:13,116
won't work because it's just a

783
00:26:13,156 --> 00:26:14,076
runtime check.

784
00:26:15,196 --> 00:26:17,146
Its body is required to compile

785
00:26:17,146 --> 00:26:19,166
for all template instantiations,

786
00:26:19,506 --> 00:26:21,016
but linked list iterators don't

787
00:26:21,016 --> 00:26:22,516
have operator +.

788
00:26:23,016 --> 00:26:25,766
We have a problem.

789
00:26:27,246 --> 00:26:29,246
Advance needs a common interface

790
00:26:29,246 --> 00:26:30,906
that compiles for linked lists

791
00:26:31,696 --> 00:26:34,386
and a fast path for strings and

792
00:26:34,566 --> 00:26:34,666
arrays.

793
00:26:34,966 --> 00:26:36,206
The classic solution is a

794
00:26:36,206 --> 00:26:37,666
technique called compile time

795
00:26:37,666 --> 00:26:39,366
dispatch, where the logic is

796
00:26:39,366 --> 00:26:40,686
split into overloaded helper

797
00:26:40,686 --> 00:26:42,436
functions and advance calls the

798
00:26:42,436 --> 00:26:44,146
right overload based on a

799
00:26:44,146 --> 00:26:45,426
compile time type trait.

800
00:26:45,946 --> 00:26:48,496
And compile time dispatch works.

801
00:26:48,866 --> 00:26:50,566
It's what C++ Library authors

802
00:26:50,566 --> 00:26:51,656
have been doing for decades.

803
00:26:52,816 --> 00:26:54,236
But it's an advanced technique,

804
00:26:54,536 --> 00:26:55,986
and what we're trying to do is

805
00:26:56,036 --> 00:26:56,566
pretty simple.

806
00:26:58,276 --> 00:27:00,376
The original not working code

807
00:26:58,276 --> 00:27:00,376
The original not working code

808
00:27:00,586 --> 00:27:01,746
was easy to understand.

809
00:27:03,016 --> 00:27:06,876
In C++17, constexpr if allows

810
00:27:06,876 --> 00:27:08,076
you to express this logic

811
00:27:08,316 --> 00:27:08,906
naturally.

812
00:27:10,826 --> 00:27:12,796
constexpr if discards the not

813
00:27:12,796 --> 00:27:14,276
taken paths when instantiating

814
00:27:14,276 --> 00:27:16,256
temples, so the linked list code

815
00:27:16,256 --> 00:27:18,896
will still compile, but advance

816
00:27:18,896 --> 00:27:20,276
will use the fast path for

817
00:27:20,276 --> 00:27:22,586
strings and arrays.

818
00:27:23,266 --> 00:27:25,616
constexpr if makes reading and

819
00:27:25,616 --> 00:27:27,636
writing generic code much

820
00:27:27,636 --> 00:27:28,006
simpler.

821
00:27:30,956 --> 00:27:32,726
Let's finish with a new library

822
00:27:32,726 --> 00:27:34,016
facility for strings.

823
00:27:35,276 --> 00:27:38,146
The STL string class has a rich

824
00:27:38,146 --> 00:27:40,136
API, but it's not always the

825
00:27:40,136 --> 00:27:40,656
right tool.

826
00:27:41,716 --> 00:27:43,136
This example might look

827
00:27:43,136 --> 00:27:43,636
familiar.

828
00:27:44,486 --> 00:27:46,456
The function split searches for

829
00:27:46,456 --> 00:27:48,036
the last slash in the path

830
00:27:48,036 --> 00:27:48,456
argument.

831
00:27:48,996 --> 00:27:51,816
If it finds a slash, it splits

832
00:27:51,816 --> 00:27:53,686
the path into directory and

833
00:27:53,686 --> 00:27:54,236
filename.

834
00:27:55,556 --> 00:27:57,116
Without a slash, it returns the

835
00:27:57,116 --> 00:27:58,466
full path as the filename.

836
00:27:59,996 --> 00:28:02,436
Because of string's API, this

837
00:27:59,996 --> 00:28:02,436
Because of string's API, this

838
00:28:02,436 --> 00:28:04,386
code was easy to write, but

839
00:28:04,866 --> 00:28:06,126
there's a performance problem

840
00:28:06,126 --> 00:28:06,436
lurking.

841
00:28:07,836 --> 00:28:09,986
Split is returning copies of the

842
00:28:09,986 --> 00:28:10,386
string.

843
00:28:11,586 --> 00:28:12,986
Heavy use of functions like

844
00:28:12,986 --> 00:28:15,046
split can introduce expensive

845
00:28:15,046 --> 00:28:15,776
allocations.

846
00:28:17,686 --> 00:28:20,206
C++17 has a new facility for

847
00:28:20,206 --> 00:28:21,266
referencing strings.

848
00:28:22,206 --> 00:28:23,106
It's called string view.

849
00:28:24,396 --> 00:28:26,076
A string view encapsulates a raw

850
00:28:26,076 --> 00:28:27,266
const char [inaudible] and a

851
00:28:27,266 --> 00:28:27,876
size.

852
00:28:29,066 --> 00:28:30,666
It has a rich API, just like

853
00:28:30,666 --> 00:28:32,486
string, so it's convenient for

854
00:28:32,486 --> 00:28:33,426
string manipulation.

855
00:28:34,856 --> 00:28:36,476
And as the name suggests, it's

856
00:28:36,506 --> 00:28:37,046
just a view.

857
00:28:37,936 --> 00:28:40,106
It doesn't own any storage, and

858
00:28:40,106 --> 00:28:43,036
so it never makes a copy.

859
00:28:43,486 --> 00:28:44,706
String view is great for

860
00:28:44,706 --> 00:28:46,286
performance, but there is a

861
00:28:46,286 --> 00:28:48,866
caveat: String view isn't always

862
00:28:48,866 --> 00:28:49,406
safe.

863
00:28:51,156 --> 00:28:52,306
Because it doesn't own its

864
00:28:52,306 --> 00:28:54,426
storage, using a string view

865
00:28:54,456 --> 00:28:56,036
after the original string is

866
00:28:56,036 --> 00:28:58,206
destroyed or modified can cause

867
00:28:58,206 --> 00:28:59,236
a use after free.

868
00:29:01,336 --> 00:29:02,876
Referencing a raw string literal

869
00:29:02,946 --> 00:29:05,936
like resources/images is always

870
00:29:05,936 --> 00:29:08,396
safe because raw string literals

871
00:29:08,426 --> 00:29:09,306
have the lifetime of the

872
00:29:09,306 --> 00:29:09,826
program.

873
00:29:12,036 --> 00:29:13,146
Taking a string view as an

874
00:29:13,146 --> 00:29:15,556
argument is safe, but avoid

875
00:29:15,556 --> 00:29:16,956
storing a string view argument

876
00:29:17,086 --> 00:29:18,336
past the function return.

877
00:29:21,056 --> 00:29:23,286
Be careful of return values.

878
00:29:23,826 --> 00:29:25,466
If a string view is derived from

879
00:29:25,466 --> 00:29:26,916
an argument, it will be safe to

880
00:29:26,916 --> 00:29:28,406
use as long as the argument

881
00:29:28,576 --> 00:29:30,046
isn't changed or destroyed.

882
00:29:31,186 --> 00:29:32,956
In this example, directory and

883
00:29:32,956 --> 00:29:35,446
filename are safe to use as long

884
00:29:35,446 --> 00:29:38,236
as path remains constant and

885
00:29:38,236 --> 00:29:38,616
valid.

886
00:29:39,126 --> 00:29:42,546
But if we replace path with a

887
00:29:42,546 --> 00:29:44,806
computed string, then accessing

888
00:29:44,916 --> 00:29:46,666
either directory or filename

889
00:29:46,746 --> 00:29:48,216
will cause a use after free.

890
00:29:49,816 --> 00:29:52,226
The root cause is that split was

891
00:29:52,226 --> 00:29:53,476
passed a temporary.

892
00:29:54,136 --> 00:29:56,006
The temporary is destroyed after

893
00:29:56,006 --> 00:29:57,566
the call to split, and its

894
00:29:57,566 --> 00:29:59,116
references are invalidated.

895
00:30:01,156 --> 00:30:03,276
Accessing the temporary invokes

896
00:30:03,276 --> 00:30:04,316
undefined behavior.

897
00:30:05,156 --> 00:30:06,696
AddressSanitizer can catch this

898
00:30:06,746 --> 00:30:06,966
bug.

899
00:30:08,176 --> 00:30:09,706
Watch Understanding Undefined

900
00:30:09,706 --> 00:30:11,226
Behavior to learn more about

901
00:30:11,226 --> 00:30:13,196
this kind of bug and Finding

902
00:30:13,196 --> 00:30:15,236
Bugs Using Xcode Runtime Tools

903
00:30:15,236 --> 00:30:16,656
to learn about tools to combat

904
00:30:16,916 --> 00:30:17,000
them.

905
00:30:18,476 --> 00:30:20,386
String view is the last C++17

906
00:30:20,386 --> 00:30:21,526
feature I'll show you today.

907
00:30:22,656 --> 00:30:26,426
To try out C++17, set the C++

908
00:30:26,426 --> 00:30:27,996
language dialect in your Build

909
00:30:27,996 --> 00:30:28,456
settings.

910
00:30:29,236 --> 00:30:32,086
C++17 gives you the standardized

911
00:30:32,086 --> 00:30:33,786
language without extensions.

912
00:30:34,646 --> 00:30:37,056
GNU++17 adds the usual

913
00:30:37,056 --> 00:30:37,716
extensions.

914
00:30:38,216 --> 00:30:40,726
Now, I have a quick update on

915
00:30:40,726 --> 00:30:41,766
link-time optimization.

916
00:30:43,136 --> 00:30:45,196
Link-time optimization, or LTO,

917
00:30:45,826 --> 00:30:47,576
optimizes the executable at link

918
00:30:47,576 --> 00:30:49,386
time, blurring the line between

919
00:30:49,386 --> 00:30:50,716
source files and enabling

920
00:30:50,716 --> 00:30:52,106
powerful optimizations.

921
00:30:53,076 --> 00:30:54,516
Incremental LTO, which we

922
00:30:54,516 --> 00:30:55,996
introduced last year, is the

923
00:30:55,996 --> 00:30:56,866
state of the art.

924
00:30:57,766 --> 00:30:59,636
For more information, watch last

925
00:30:59,636 --> 00:31:01,176
year's talk, What's New in LLVM.

926
00:30:59,636 --> 00:31:01,176
year's talk, What's New in LLVM.

927
00:31:02,146 --> 00:31:06,036
In the past, when using LTO on

928
00:31:06,036 --> 00:31:08,346
large C++ programs, we've

929
00:31:08,346 --> 00:31:10,476
recommended changing the Debug

930
00:31:10,476 --> 00:31:12,906
Info Level Build setting to Line

931
00:31:12,906 --> 00:31:13,746
Tables Only.

932
00:31:14,846 --> 00:31:16,306
But in Xcode 9, we took

933
00:31:16,306 --> 00:31:17,946
incremental LTO to the next

934
00:31:17,946 --> 00:31:18,356
level.

935
00:31:19,666 --> 00:31:20,926
Let's look at the time to link

936
00:31:20,996 --> 00:31:23,296
the Apple LLVM compiler itself.

937
00:31:24,166 --> 00:31:26,716
In Xcode 8, a clean link with

938
00:31:26,716 --> 00:31:28,596
full debug info took almost six

939
00:31:28,596 --> 00:31:29,056
minutes.

940
00:31:29,706 --> 00:31:30,796
Line Tables Only was

941
00:31:30,796 --> 00:31:32,296
three-and-a-half minutes faster.

942
00:31:33,706 --> 00:31:35,506
We sped up incremental LTO with

943
00:31:35,506 --> 00:31:38,266
full debug info by 35% in Xcode

944
00:31:38,266 --> 00:31:38,566
9.

945
00:31:39,406 --> 00:31:40,616
Line Tables Only is still

946
00:31:40,616 --> 00:31:42,756
faster, but the overhead is now

947
00:31:42,756 --> 00:31:44,036
only 90 seconds.

948
00:31:44,516 --> 00:31:46,906
That was a clean link.

949
00:31:47,616 --> 00:31:50,006
The true power of incremental

950
00:31:50,006 --> 00:31:52,236
LTO is its fast incremental

951
00:31:52,236 --> 00:31:52,776
builds.

952
00:31:53,356 --> 00:31:55,446
When only one file changes, the

953
00:31:55,446 --> 00:31:56,346
link doesn't repeat

954
00:31:56,346 --> 00:31:58,206
optimizations unnecessarily.

955
00:31:59,456 --> 00:32:01,426
In Xcode 8, an incremental link

956
00:31:59,456 --> 00:32:01,426
In Xcode 8, an incremental link

957
00:32:01,426 --> 00:32:02,816
of the Apple LLVM compiler

958
00:32:02,816 --> 00:32:05,716
itself took 21 seconds with full

959
00:32:05,716 --> 00:32:08,126
debug info, more than two times

960
00:32:08,126 --> 00:32:09,526
longer than Line Tables Only.

961
00:32:10,376 --> 00:32:12,436
This is why we recommended

962
00:32:12,436 --> 00:32:14,186
changing the debug info level in

963
00:32:15,096 --> 00:32:16,746
the past.

964
00:32:16,916 --> 00:32:18,236
But in Xcode 9, the same

965
00:32:18,236 --> 00:32:19,456
incremental link is

966
00:32:19,506 --> 00:32:21,046
two-and-a-half times faster.

967
00:32:21,556 --> 00:32:23,186
At just over eight seconds, it's

968
00:32:23,186 --> 00:32:24,816
even faster than Line Tables

969
00:32:24,816 --> 00:32:26,116
Only mode was last year.

970
00:32:26,986 --> 00:32:28,716
If you looked at incremental LTO

971
00:32:28,716 --> 00:32:30,226
but didn't want to change your

972
00:32:30,226 --> 00:32:32,236
debug info level, it's time to

973
00:32:32,236 --> 00:32:32,746
look again.

974
00:32:33,516 --> 00:32:39,156
[ Applause ]

975
00:32:39,656 --> 00:32:40,876
We recommend turning on

976
00:32:40,906 --> 00:32:43,806
incremental LTO today, even if

977
00:32:43,806 --> 00:32:45,246
you're using full debug info.

978
00:32:45,846 --> 00:32:49,366
So that's what's new in LLVM.

979
00:32:50,596 --> 00:32:52,876
Use @available to safely use new

980
00:32:52,876 --> 00:32:54,986
APIs when supporting older OS's.

981
00:32:55,816 --> 00:32:57,146
Run the static analyzer while

982
00:32:57,146 --> 00:32:57,616
you build.

983
00:32:58,916 --> 00:33:00,846
Use Xcode to refactor your code.

984
00:32:58,916 --> 00:33:00,846
Use Xcode to refactor your code.

985
00:33:01,906 --> 00:33:03,326
Try out the new features in

986
00:33:03,326 --> 00:33:04,556
C++17.

987
00:33:05,336 --> 00:33:07,656
And turn on incremental LTO to

988
00:33:07,656 --> 00:33:09,116
upgrade your performance without

989
00:33:09,116 --> 00:33:10,766
sacrificing incremental build

990
00:33:10,766 --> 00:33:11,046
time.

991
00:33:12,126 --> 00:33:13,796
For more information, see the

992
00:33:13,796 --> 00:33:14,296
website.

993
00:33:15,406 --> 00:33:16,516
I recommend you watch the

994
00:33:16,516 --> 00:33:17,446
related sessions.

995
00:33:18,246 --> 00:33:18,576
Thank you.

996
00:33:19,516 --> 00:33:22,500
[ Applause ]
