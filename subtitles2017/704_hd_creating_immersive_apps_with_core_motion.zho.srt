1
00:00:20,516 --> 00:00:21,686
&gt;&gt; 大家好

2
00:00:22,276 --> 00:00:23,606
我是 John Blackwell

3
00:00:23,606 --> 00:00:24,676
我是 Core Motion 框架

4
00:00:24,676 --> 00:00:25,426
的一名工程师

5
00:00:25,956 --> 00:00:27,336
今天 我们要讲一讲

6
00:00:27,416 --> 00:00:28,496
通过 Core Motion 框架

7
00:00:28,496 --> 00:00:29,776
来创建沉浸式

8
00:00:29,776 --> 00:00:31,306
应用软件 我们还会

9
00:00:31,306 --> 00:00:32,485
在过程中讨论一些

10
00:00:32,485 --> 00:00:33,886
最佳实践的例子

11
00:00:35,366 --> 00:00:37,376
那么今天 我们将要

12
00:00:37,376 --> 00:00:38,386
涉及到一系列话题

13
00:00:38,896 --> 00:00:40,746
第一就是一个简单的概况

14
00:00:40,746 --> 00:00:42,116
了解 Core Motion 可以提供什么

15
00:00:42,536 --> 00:00:43,816
接下来 我们会讲一下

16
00:00:43,816 --> 00:00:45,816
授权 这对于

17
00:00:45,816 --> 00:00:46,526
我们的很多开发人员来说

18
00:00:46,526 --> 00:00:47,096
是一个经常出现的痛点

19
00:00:47,676 --> 00:00:48,606
然后 我们要看一下

20
00:00:48,606 --> 00:00:50,116
有关 Historic Accelerometer

21
00:00:50,116 --> 00:00:52,336
的一些新版本 再之后我们

22
00:00:52,336 --> 00:00:53,926
要看一下 DeviceMotion

23
00:00:54,166 --> 00:00:55,526
也就我们在 Core Motion

24
00:00:55,526 --> 00:00:56,916
中提供的一个传感器混合体

25
00:00:57,346 --> 00:00:58,526
最后 我们要看一下

26
00:00:58,526 --> 00:01:00,556
Badger with Attitude 它是一款游戏

27
00:00:58,526 --> 00:01:00,556
Badger with Attitude 它是一款游戏

28
00:01:00,556 --> 00:01:01,536
其中我们采用了一些

29
00:01:01,536 --> 00:01:03,116
之前在 DeviceMotion 提到过的

30
00:01:03,116 --> 00:01:04,796
概念 并且将它们付诸

31
00:01:04,885 --> 00:01:05,556
实际应用中

32
00:01:06,686 --> 00:01:08,376
那么好了 我们先

33
00:01:08,376 --> 00:01:09,836
仔细了解一下 Core Motion

34
00:01:09,836 --> 00:01:10,356
框架

35
00:01:13,656 --> 00:01:15,266
Core Motion 框架

36
00:01:15,476 --> 00:01:16,686
提供访问

37
00:01:16,686 --> 00:01:18,186
accelerometer gyroscope

38
00:01:18,436 --> 00:01:19,556
magnetometer 以及

39
00:01:19,556 --> 00:01:20,896
altimeter 的途径 并且通过这一

40
00:01:20,896 --> 00:01:22,476
框架 你可以获取

41
00:01:22,476 --> 00:01:23,586
传感器数据的原始形式 

42
00:01:23,586 --> 00:01:25,576
以及处理过的形式 并且

43
00:01:25,576 --> 00:01:26,886
在你的应用软件中使用它们

44
00:01:28,206 --> 00:01:29,546
现在 有一些

45
00:01:29,546 --> 00:01:30,996
接口可以通过 Core Motion 

46
00:01:30,996 --> 00:01:31,626
获取

47
00:01:32,166 --> 00:01:35,446
第一个就是 CMMotionManager

48
00:01:35,726 --> 00:01:37,406
它帮助获取原始

49
00:01:37,486 --> 00:01:38,806
传感器数据 以及

50
00:01:38,806 --> 00:01:40,116
DeviceMotion 形式的传感器

51
00:01:40,116 --> 00:01:40,916
混合体

52
00:01:42,226 --> 00:01:44,156
CMAltimeter 帮助

53
00:01:44,156 --> 00:01:45,606
获取设备的相关高度

54
00:01:45,606 --> 00:01:45,976
更新

55
00:01:47,456 --> 00:01:49,216
CMPedometer 帮助获取

56
00:01:49,216 --> 00:01:50,836
步数 以作为步数相关

57
00:01:50,836 --> 00:01:52,156
信息 以及

58
00:01:52,156 --> 00:01:53,616
锻炼 暂停 和恢复

59
00:01:53,616 --> 00:01:53,996
活动

60
00:01:55,396 --> 00:01:56,996
MotionActivityManager 帮助

61
00:01:56,996 --> 00:01:58,696
获取设备的活动

62
00:01:58,696 --> 00:02:00,006
情境 例如

63
00:01:58,696 --> 00:02:00,006
情境 例如

64
00:02:00,006 --> 00:02:02,106
走路 跑步 或坐车

65
00:02:02,296 --> 00:02:06,276
CMSensorRecorder

66
00:02:06,416 --> 00:02:07,976
帮助获取

67
00:02:07,976 --> 00:02:08,826
accelerometer 的历史数据

68
00:02:09,496 --> 00:02:13,576
所以这就是一个概况

69
00:02:13,576 --> 00:02:14,616
帮助我们了解 Core Motion 框架

70
00:02:14,616 --> 00:02:15,156
提供什么

71
00:02:15,696 --> 00:02:17,166
接下来 我们来仔细看一下

72
00:02:17,166 --> 00:02:18,196
授权

73
00:02:19,426 --> 00:02:21,456
所以在我刚刚

74
00:02:21,456 --> 00:02:23,906
提到的 API 中 以下四种

75
00:02:23,906 --> 00:02:25,636
都非常敏感 这是由于

76
00:02:25,636 --> 00:02:26,846
所显示的用户私人信息的本质所导致的

77
00:02:29,376 --> 00:02:31,936
为了处理此事 我们会有一个

78
00:02:31,936 --> 00:02:33,426
提示符 在你第一次

79
00:02:33,426 --> 00:02:34,806
唤醒某一个 灵敏的 API 时

80
00:02:34,806 --> 00:02:35,746
它就会出现

81
00:02:37,056 --> 00:02:39,056
记住是当你第一次

82
00:02:39,056 --> 00:02:40,966
唤醒灵敏的 API 时 那个

83
00:02:40,966 --> 00:02:42,336
提示符会出现在用户面前

84
00:02:42,626 --> 00:02:44,056
但是第一次之后 你的

85
00:02:44,056 --> 00:02:45,106
用户就需要到

86
00:02:45,106 --> 00:02:46,006
“设置”来改变

87
00:02:46,006 --> 00:02:47,216
你应用软件的授权

88
00:02:47,216 --> 00:02:47,986
状态

89
00:02:49,306 --> 00:02:50,916
现在 我们来看一看

90
00:02:50,916 --> 00:02:51,996
当你第一次

91
00:02:51,996 --> 00:02:53,036
调用这些 API 中的一个时是怎么样的

92
00:02:53,816 --> 00:02:55,406
这时候 你的用户将

93
00:02:55,406 --> 00:02:56,346
决定他们是否想要

94
00:02:56,346 --> 00:02:57,766
允许访问 Motion

95
00:02:57,766 --> 00:02:59,576
Fitness 数据 或者拒绝访问

96
00:03:00,016 --> 00:03:01,566
作为开发人员 你会

97
00:03:01,566 --> 00:03:02,676
想要处理用户拒绝访问

98
00:03:02,676 --> 00:03:05,166
这一问题

99
00:03:05,286 --> 00:03:07,376
在过去 我们要求你

100
00:03:07,376 --> 00:03:08,406
做这样的事

101
00:03:09,056 --> 00:03:10,596
你需要调用我们灵敏的

102
00:03:10,596 --> 00:03:12,046
API

103
00:03:12,696 --> 00:03:13,826
在这个例子中 我们正在调用

104
00:03:13,826 --> 00:03:15,756
queryPedometerData 然后你

105
00:03:15,756 --> 00:03:17,346
无视从

106
00:03:17,346 --> 00:03:19,336
API 获得的结果 只关注

107
00:03:19,336 --> 00:03:20,146
错误代码

108
00:03:21,026 --> 00:03:22,536
如果代码错误是因为

109
00:03:22,536 --> 00:03:24,376
没有授权 这时

110
00:03:24,376 --> 00:03:25,536
你就可以知道你的应用软件

111
00:03:25,536 --> 00:03:26,886
被拒绝访问动态和

112
00:03:26,886 --> 00:03:27,476
健康数据

113
00:03:28,646 --> 00:03:30,126
现在 我们意识到这种做法

114
00:03:30,126 --> 00:03:30,846
还不够理想

115
00:03:32,166 --> 00:03:33,196
你需要跳过一环一环

116
00:03:33,266 --> 00:03:34,816
来获得你的

117
00:03:34,816 --> 00:03:36,386
授权状态 一旦

118
00:03:36,426 --> 00:03:37,656
你得到了 你就无法知道

119
00:03:37,656 --> 00:03:39,316
为什么你的 App 

120
00:03:39,316 --> 00:03:40,296
被拒绝访问

121
00:03:40,936 --> 00:03:43,326
这就是为什么今年我们

122
00:03:43,326 --> 00:03:44,636
提供了一个授权

123
00:03:44,636 --> 00:03:45,326
地位 API

124
00:03:46,226 --> 00:03:47,606
这个 API 在

125
00:03:47,686 --> 00:03:48,816
之前我提到的四类中

126
00:03:48,816 --> 00:03:50,086
都可用 而且它也在

127
00:03:50,086 --> 00:03:52,076
iOS 系统和 watchOS 系统上可用

128
00:03:52,886 --> 00:03:54,366
让我们进一步看一下

129
00:03:54,366 --> 00:03:56,226
CMAuthorizationStatus 值

130
00:03:56,226 --> 00:03:57,666
你将会从 API 得到它

131
00:03:59,386 --> 00:04:01,596
第一个状态是“notDetermined”

132
00:03:59,386 --> 00:04:01,596
第一个状态是“notDetermined”

133
00:04:01,866 --> 00:04:03,566
它代表着

134
00:04:03,566 --> 00:04:04,866
用户还没有被问及

135
00:04:04,866 --> 00:04:05,856
你应用软件的有关

136
00:04:05,856 --> 00:04:06,466
授权

137
00:04:07,026 --> 00:04:08,806
“Restricted”表示

138
00:04:09,126 --> 00:04:11,386
用户无法

139
00:04:11,386 --> 00:04:12,756
为你的应该改变

140
00:04:12,916 --> 00:04:13,826
授权状态

141
00:04:13,826 --> 00:04:15,426
更确切地说 

142
00:04:15,426 --> 00:04:17,086
当动态和健康

143
00:04:17,156 --> 00:04:18,546
在隐私中被禁用时会出现这样的状态

144
00:04:19,406 --> 00:04:20,495
下一个状态是“denied”

145
00:04:20,656 --> 00:04:21,596
就是指拒绝

146
00:04:21,776 --> 00:04:22,526
你的应用软件

147
00:04:22,526 --> 00:04:24,256
很明确地被用户

148
00:04:24,256 --> 00:04:24,746
拒绝访问

149
00:04:25,156 --> 00:04:26,906
而“authorized”代表你的 App 

150
00:04:26,906 --> 00:04:28,026
已经被允许访问用户的

151
00:04:28,026 --> 00:04:29,006
动态和健康数据

152
00:04:30,586 --> 00:04:32,746
现在 我们回过来看一下

153
00:04:32,746 --> 00:04:33,836
我们之前正在看的

154
00:04:33,836 --> 00:04:34,606
授权确认

155
00:04:34,856 --> 00:04:37,176
第一批最佳实践中有一项

156
00:04:37,176 --> 00:04:38,796
我想要讲一讲

157
00:04:39,126 --> 00:04:40,266
那就是确保你检查了

158
00:04:40,266 --> 00:04:42,006
所给 API 的可用性

159
00:04:42,006 --> 00:04:44,006
在你请求

160
00:04:44,006 --> 00:04:44,946
授权地位之前

161
00:04:45,656 --> 00:04:47,036
在这个例子中 我们正在请求

162
00:04:47,036 --> 00:04:47,896
StepCountingAvailable

163
00:04:48,816 --> 00:04:50,136
接下来你

164
00:04:50,136 --> 00:04:51,476
想要做的就是请求

165
00:04:51,476 --> 00:04:52,496
授权地位

166
00:04:53,106 --> 00:04:54,446
这个时候 是由

167
00:04:54,446 --> 00:04:56,436
你 作为一个开发人员 来决定

168
00:04:56,506 --> 00:04:57,566
想要如何处理

169
00:04:57,566 --> 00:04:59,196
从框架中拿回的

170
00:04:59,396 --> 00:05:00,176
授权

171
00:04:59,396 --> 00:05:00,176
授权

172
00:05:00,596 --> 00:05:01,966
现在你有一个简单的机制

173
00:05:01,966 --> 00:05:04,256
可以来做这件事 无论是在 iOS 系统上还是在

174
00:05:04,366 --> 00:05:04,876
watchOS 系统上

175
00:05:06,336 --> 00:05:08,896
我鼓励你们考虑一下如何

176
00:05:08,896 --> 00:05:09,956
使用授权

177
00:05:09,956 --> 00:05:11,776
地位 App 也就是你应用软件中的

178
00:05:11,776 --> 00:05:13,266
授权地位 API 

179
00:05:13,486 --> 00:05:14,586
而且你应该

180
00:05:14,586 --> 00:05:14,716
使用它

181
00:05:15,516 --> 00:05:16,836
接下来 我们要讲一讲

182
00:05:16,836 --> 00:05:18,066
Historical Accelerometer

183
00:05:19,056 --> 00:05:20,756
Historical Accelerometer 

184
00:05:20,756 --> 00:05:22,196
也叫作 CMSensorRecorder

185
00:05:22,536 --> 00:05:24,336
可以提供 50 赫兹的 accelerometer

186
00:05:24,336 --> 00:05:25,926
数据 而且我们可以

187
00:05:25,926 --> 00:05:27,256
为你的应用软件记录这一数据 当你的

188
00:05:27,256 --> 00:05:28,356
App 在后台运行时

189
00:05:29,556 --> 00:05:31,426
你可以请求最多 36 小时

190
00:05:31,426 --> 00:05:33,406
的 accelerometer 数据 这些

191
00:05:33,406 --> 00:05:34,716
会被以你的名义

192
00:05:34,716 --> 00:05:36,386
最多储存 3 天

193
00:05:37,786 --> 00:05:39,696
现在 Historical Accelerometer 

194
00:05:39,696 --> 00:05:41,176
在 Apple Watch

195
00:05:41,176 --> 00:05:43,476
可用 我很激动

196
00:05:43,476 --> 00:05:45,126
地宣布它现在

197
00:05:45,126 --> 00:05:46,826
也在 iPhone 7 和 7 Plus 上可用

198
00:05:47,886 --> 00:05:49,406
这为你的应用软件开拓了

199
00:05:49,406 --> 00:05:50,996
全新的用例

200
00:05:51,216 --> 00:05:52,206
并且让你思考

201
00:05:52,206 --> 00:05:53,626
要如何在 iPhone 上使用 Historical

202
00:05:53,626 --> 00:05:55,376
Accelerometer 让我们

203
00:05:55,376 --> 00:05:56,316
现在来看一个

204
00:05:56,316 --> 00:05:58,646
简单的应用软件

205
00:05:59,056 --> 00:06:00,496
让我们假设你是一个

206
00:05:59,056 --> 00:06:00,496
让我们假设你是一个

207
00:06:00,496 --> 00:06:02,366
汽车狂粉

208
00:06:02,366 --> 00:06:03,726
你想要构建一款应用软件

209
00:06:03,726 --> 00:06:05,096
帮助你在很长的一段时间内

210
00:06:05,096 --> 00:06:06,736
追踪汽车的

211
00:06:06,736 --> 00:06:06,926
性能

212
00:06:07,736 --> 00:06:09,086
那么我们要怎么样来构建

213
00:06:09,086 --> 00:06:09,306
它呢

214
00:06:09,746 --> 00:06:10,986
好吧 首先我们

215
00:06:10,986 --> 00:06:12,256
想要弄清楚用户

216
00:06:12,256 --> 00:06:14,526
何时驾驶 为此

217
00:06:14,526 --> 00:06:15,726
我们可以使用 Motion Activity

218
00:06:16,266 --> 00:06:17,476
Motion Activity 提供一个

219
00:06:17,476 --> 00:06:19,436
汽车的状态 我们可以用

220
00:06:19,436 --> 00:06:20,566
它来判断何时

221
00:06:20,566 --> 00:06:21,576
用户在驾驶

222
00:06:22,996 --> 00:06:24,316
现在 我想要简单花

223
00:06:24,316 --> 00:06:25,636
几分钟讲一讲

224
00:06:25,636 --> 00:06:26,706
汽车检测

225
00:06:27,336 --> 00:06:29,566
在 iOS 11 系统中 汽车

226
00:06:29,566 --> 00:06:31,036
检测这一块得到了格外的

227
00:06:31,036 --> 00:06:32,156
关注 以此来确保

228
00:06:32,156 --> 00:06:33,626
最佳的效果

229
00:06:34,166 --> 00:06:35,956
在 Motion Activity 中的

230
00:06:35,956 --> 00:06:37,746
汽车状态也

231
00:06:37,746 --> 00:06:39,016
被用来控制 Do

232
00:06:39,016 --> 00:06:40,386
Not Disturb While Driving 这一项功能 

233
00:06:40,386 --> 00:06:41,826
它也可以在你的应用软件中

234
00:06:41,826 --> 00:06:43,186
被使用

235
00:06:43,456 --> 00:06:44,496
比如你想要

236
00:06:44,496 --> 00:06:46,066
在你的用户驾驶时

237
00:06:46,066 --> 00:06:47,406
对应用软件的 UI 进行个性化设置

238
00:06:48,426 --> 00:06:49,766
现在 回到我们的

239
00:06:49,766 --> 00:06:51,156
汽车性能追踪

240
00:06:51,156 --> 00:06:52,666
应用软件 我们下一步

241
00:06:52,666 --> 00:06:54,526
想要做的事 收集

242
00:06:54,766 --> 00:06:55,776
accelerometer 数据

243
00:06:56,256 --> 00:06:57,876
对此 我们可以使用

244
00:06:57,876 --> 00:06:58,546
SensorRecorder

245
00:06:58,846 --> 00:07:00,566
我们可以收集

246
00:06:58,846 --> 00:07:00,566
我们可以收集

247
00:07:00,566 --> 00:07:02,056
用户在驾驶期间的

248
00:07:02,106 --> 00:07:03,336
accelerometer 数据 并且

249
00:07:03,336 --> 00:07:05,276
为用户将数据转换成公制

250
00:07:05,276 --> 00:07:07,066
的 例如

251
00:07:07,066 --> 00:07:07,946
汽车在转弯时的

252
00:07:07,946 --> 00:07:10,376
G 值 或者是最大横向或

253
00:07:10,376 --> 00:07:11,366
纵向加 G 值

254
00:07:12,006 --> 00:07:14,236
现在 你可以考虑通过很多不同的

255
00:07:14,236 --> 00:07:16,036
方式来构建

256
00:07:16,256 --> 00:07:17,956
这种应用软件 但是通过

257
00:07:18,066 --> 00:07:19,816
使用 Motion APIs 你可以

258
00:07:19,816 --> 00:07:20,786
为你的用户提供一个

259
00:07:20,786 --> 00:07:22,796
低功耗 全天候的体验

260
00:07:23,516 --> 00:07:26,206
现在请大家通过

261
00:07:26,206 --> 00:07:28,036
Historical Accelerometer 记住一些

262
00:07:28,036 --> 00:07:29,196
最佳实践

263
00:07:29,766 --> 00:07:31,216
首先 你会想要

264
00:07:31,216 --> 00:07:32,926
为你的应用软件选择

265
00:07:32,926 --> 00:07:34,096
合理的最低持续

266
00:07:34,096 --> 00:07:34,836
时间

267
00:07:35,536 --> 00:07:37,046
所以对于汽车性能

268
00:07:37,046 --> 00:07:38,786
追踪应用软件而言 我们也许不

269
00:07:38,786 --> 00:07:41,116
需要全程 36 小时的数据

270
00:07:41,986 --> 00:07:43,546
像 8 到 12 

271
00:07:43,546 --> 00:07:44,706
小时更合理

272
00:07:45,896 --> 00:07:47,326
接下来的最佳实践就是

273
00:07:47,326 --> 00:07:48,516
要记得考虑 

274
00:07:48,516 --> 00:07:50,506
大批销毁或是减少样本

275
00:07:50,506 --> 00:07:52,386
如果你不需要全部的 50

276
00:07:52,386 --> 00:07:53,626
赫兹 accelerometer 数据的话

277
00:07:54,326 --> 00:07:56,176
这两条建议 这两项

278
00:07:56,176 --> 00:07:58,206
最佳实践会减少

279
00:07:58,206 --> 00:07:59,316
你的应用软件需要进行的

280
00:07:59,316 --> 00:08:00,906
处理量 进而

281
00:07:59,316 --> 00:08:00,906
处理量 进而

282
00:08:00,906 --> 00:08:02,256
也可以节省用户电池的

283
00:08:02,256 --> 00:08:02,666
寿命

284
00:08:03,656 --> 00:08:05,836
现在我鼓励你想一想

285
00:08:06,086 --> 00:08:07,736
你要如何在 iPhone上使用

286
00:08:07,736 --> 00:08:09,546
Historical Accelerometer

287
00:08:10,046 --> 00:08:13,636
下面我们来讲一下

288
00:08:13,636 --> 00:08:14,566
DeviceMotion

289
00:08:15,126 --> 00:08:16,686
DeviceMotion 是指

290
00:08:16,766 --> 00:08:18,536
传感器混合体算法 我们

291
00:08:18,536 --> 00:08:19,826
将它提供在 Core Motion

292
00:08:19,826 --> 00:08:20,306
框架中

293
00:08:21,146 --> 00:08:23,106
现在我们还在

294
00:08:23,106 --> 00:08:23,846
DeviceMotion 中

295
00:08:23,846 --> 00:08:24,686
新加了一些内容

296
00:08:25,966 --> 00:08:27,396
我们在 DeviceMotion 中使用的第一个传感器

297
00:08:27,396 --> 00:08:28,176
是

298
00:08:28,176 --> 00:08:29,446
accelerometer 

299
00:08:29,446 --> 00:08:30,806
通过 accelerometer 我们可以

300
00:08:30,806 --> 00:08:31,776
测量用户

301
00:08:31,776 --> 00:08:33,336
传递的加速度 以及

302
00:08:33,336 --> 00:08:34,535
重力

303
00:08:34,535 --> 00:08:35,025
加速度

304
00:08:36,176 --> 00:08:37,466
gyroscope 帮助我们

305
00:08:37,466 --> 00:08:38,885
准确测量

306
00:08:38,885 --> 00:08:39,716
设备的转动率

307
00:08:40,236 --> 00:08:41,946
而 magnetometer 则帮助我们

308
00:08:41,946 --> 00:08:43,566
测量设备周围的局部域

309
00:08:43,566 --> 00:08:44,876
以及

310
00:08:44,876 --> 00:08:45,906
地球磁场

311
00:08:47,226 --> 00:08:48,886
当我们要处理原始

312
00:08:48,886 --> 00:08:49,866
传感器时 需要记住

313
00:08:49,866 --> 00:08:51,096
一些我们面临的挑战

314
00:08:51,956 --> 00:08:53,176
使用 accelerometer 

315
00:08:53,176 --> 00:08:54,916
我们很难区分

316
00:08:54,916 --> 00:08:55,996
用户的

317
00:08:55,996 --> 00:08:57,826
加速度

318
00:08:58,386 --> 00:09:00,166
和重力加速度

319
00:08:58,386 --> 00:09:00,166
和重力加速度

320
00:09:02,376 --> 00:09:03,566
使用 gyroscope 我们可能

321
00:09:03,566 --> 00:09:04,706
对时间的测量会产生

322
00:09:04,706 --> 00:09:06,986
偏差 使用 magnetometer

323
00:09:06,986 --> 00:09:07,756
我们很难

324
00:09:07,756 --> 00:09:09,256
区分局部域

325
00:09:09,256 --> 00:09:10,586
和地球磁场

326
00:09:11,326 --> 00:09:13,346
这就是为什么我们引入了

327
00:09:13,346 --> 00:09:13,876
DeviceMotion

328
00:09:14,566 --> 00:09:16,306
DeviceMotion 可以提供 3D

329
00:09:16,306 --> 00:09:17,716
追踪 

330
00:09:17,716 --> 00:09:19,236
当设备正在经历自由空间

331
00:09:19,336 --> 00:09:19,846
动态

332
00:09:20,636 --> 00:09:22,156
它通过合并

333
00:09:22,156 --> 00:09:23,826
所有的传感器

334
00:09:23,826 --> 00:09:25,546
重新组织每一个的优点

335
00:09:25,676 --> 00:09:26,476
同时将缺点

336
00:09:26,476 --> 00:09:27,286
最小化

337
00:09:28,246 --> 00:09:30,026
对于开发人员来说 

338
00:09:30,026 --> 00:09:31,856
这意味着你

339
00:09:32,126 --> 00:09:34,066
专注于自己想要如何使用

340
00:09:34,066 --> 00:09:35,466
动态数据 而不是

341
00:09:35,466 --> 00:09:36,766
纠结于如何最好地利用传感器这样的

342
00:09:36,766 --> 00:09:38,036
技术性问题

343
00:09:39,776 --> 00:09:41,016
目前 我们已经在

344
00:09:41,016 --> 00:09:42,496
之前的会议中讲过

345
00:09:42,496 --> 00:09:43,376
DeviceMotion

346
00:09:43,626 --> 00:09:44,796
我希望大家

347
00:09:44,796 --> 00:09:45,116
去看一下

348
00:09:45,436 --> 00:09:46,606
我们详细讲了

349
00:09:46,636 --> 00:09:48,116
传感器和 DeviceMotion

350
00:09:48,116 --> 00:09:48,756
算法

351
00:09:49,216 --> 00:09:51,036
但是今天 我们要考虑的是

352
00:09:51,036 --> 00:09:52,886
如何通过使用

353
00:09:52,886 --> 00:09:54,426
DeviceMotion 的某些部分来

354
00:09:54,426 --> 00:09:55,696
为你的用户创建

355
00:09:55,696 --> 00:09:56,386
沉浸式应用软件

356
00:09:56,386 --> 00:10:00,666
作为一名开发人员 当你

357
00:09:56,386 --> 00:10:00,666
作为一名开发人员 当你

358
00:10:00,666 --> 00:10:01,616
第一次开始使用

359
00:10:01,616 --> 00:10:03,136
DeviceMotion 时 第一件

360
00:10:03,136 --> 00:10:04,256
需要考虑的事情是

361
00:10:04,256 --> 00:10:05,186
参照系

362
00:10:05,416 --> 00:10:07,076
参照系决定了

363
00:10:07,396 --> 00:10:08,906
会使用混合体中的哪一个

364
00:10:08,906 --> 00:10:11,006
传感器 以及如何

365
00:10:11,006 --> 00:10:11,886
计算你应用软件的

366
00:10:11,886 --> 00:10:12,656
空间方位

367
00:10:13,616 --> 00:10:14,786
第一个参照系是

368
00:10:14,956 --> 00:10:17,046
xArbitraryZVertical 

369
00:10:17,046 --> 00:10:18,166
它将 accelerometer 和

370
00:10:18,166 --> 00:10:19,406
gyroscope 合并 但没有使用

371
00:10:19,406 --> 00:10:19,976
magnetometer

372
00:10:20,716 --> 00:10:21,886
其余三个参照系分别是

373
00:10:21,886 --> 00:10:23,536
xArbitraryCorrected

374
00:10:23,856 --> 00:10:25,076
xMagneticNorth 和

375
00:10:25,076 --> 00:10:26,936
xTrueNorthZVertical  同时使用

376
00:10:26,936 --> 00:10:27,626
三种传感器

377
00:10:28,776 --> 00:10:30,216
现在 我们来讲一讲有关第一个

378
00:10:30,216 --> 00:10:31,846
参照系的更多细节

379
00:10:33,166 --> 00:10:34,786
假设你现在有一款很棒的

380
00:10:34,786 --> 00:10:35,876
竞速游戏 

381
00:10:35,876 --> 00:10:37,376
当前

382
00:10:37,596 --> 00:10:39,176
你的用户可以通过触控

383
00:10:39,176 --> 00:10:39,646
进行游戏

384
00:10:40,306 --> 00:10:41,556
这很棒 但是通过使用动态

385
00:10:41,556 --> 00:10:42,716
我们可以提供更加沉浸式的

386
00:10:42,716 --> 00:10:44,526
体验

387
00:10:45,926 --> 00:10:47,956
我们希望我们

388
00:10:47,956 --> 00:10:50,146
可以让用户

389
00:10:50,146 --> 00:10:51,526
通过设别进行驾驶 那么当他们将

390
00:10:51,526 --> 00:10:52,836
他们的车 他们的设备倾斜

391
00:10:52,836 --> 00:10:54,276
到左边时 汽车就会

392
00:10:55,836 --> 00:10:55,996
左转

393
00:10:56,206 --> 00:10:57,496
现在 只要设备是

394
00:10:57,496 --> 00:10:59,466
相对静止的 我们可以用

395
00:10:59,466 --> 00:11:01,226
accelerometer 来估算

396
00:10:59,466 --> 00:11:01,226
accelerometer 来估算

397
00:11:01,306 --> 00:11:03,556
重力 一旦

398
00:11:03,556 --> 00:11:05,186
我们得到了重力 就可以

399
00:11:05,186 --> 00:11:06,466
决定倾斜角度 或者是

400
00:11:06,466 --> 00:11:07,966
重力抵消的角度

401
00:11:08,616 --> 00:11:11,656
但请记住一件事

402
00:11:11,656 --> 00:11:13,126
如果你

403
00:11:13,126 --> 00:11:14,776
让 accelerometer 自行运作的话

404
00:11:14,776 --> 00:11:17,126
有些手势会

405
00:11:17,126 --> 00:11:17,786
很模糊

406
00:11:18,846 --> 00:11:20,476
将装置向右倾斜

407
00:11:20,856 --> 00:11:21,896
对于 accelerometer 来说

408
00:11:21,896 --> 00:11:23,506
和将装置向左滑动

409
00:11:23,506 --> 00:11:24,536
是一样

410
00:11:25,306 --> 00:11:26,636
现在你可以考虑

411
00:11:26,636 --> 00:11:28,106
处理这个问题 通过

412
00:11:28,106 --> 00:11:29,846
将 accelerometer 信号

413
00:11:29,916 --> 00:11:30,236
平均化

414
00:11:31,276 --> 00:11:32,886
这样做的话 你可以减少

415
00:11:32,936 --> 00:11:34,446
来自用户的短期

416
00:11:34,446 --> 00:11:35,916
效应 只留下

417
00:11:35,916 --> 00:11:37,506
长期效应 例如

418
00:11:37,506 --> 00:11:38,226
重力

419
00:11:38,906 --> 00:11:40,786
然而 这样做的话 你

420
00:11:40,786 --> 00:11:41,836
也将注意到你的应用软件

421
00:11:41,836 --> 00:11:43,196
的响应速度会更慢

422
00:11:43,336 --> 00:11:45,396
这时候就需要 DeviceMotion

423
00:11:45,396 --> 00:11:45,916
发挥作用

424
00:11:46,736 --> 00:11:48,516
DeviceMotion 意味着你的

425
00:11:48,516 --> 00:11:49,816
应用软件不需要

426
00:11:49,816 --> 00:11:51,316
建立过滤逻辑就可以

427
00:11:51,316 --> 00:11:53,036
从传感器获取极大的性能

428
00:11:55,276 --> 00:11:57,846
xArbitraryZVertical

429
00:11:57,846 --> 00:11:59,706
参考系就是你

430
00:11:59,706 --> 00:12:00,786
应用软件的默认参考系

431
00:11:59,706 --> 00:12:00,786
应用软件的默认参考系

432
00:12:00,786 --> 00:12:02,276
如果

433
00:12:02,276 --> 00:12:03,886
你在开始

434
00:12:04,116 --> 00:12:05,616
DeviceMotion 更新时没有明确指明是哪个

435
00:12:05,616 --> 00:12:06,106
参考系的话

436
00:12:06,476 --> 00:12:08,136
这个参考系

437
00:12:08,136 --> 00:12:09,646
对于使用来说是很棒的 当你

438
00:12:09,646 --> 00:12:10,936
想要追踪设备各角度的

439
00:12:10,936 --> 00:12:13,706
倾斜的话

440
00:12:13,706 --> 00:12:15,516
在游戏的用例

441
00:12:15,516 --> 00:12:17,306
中 accelerometer 和

442
00:12:17,306 --> 00:12:18,596
gyroscope 合并使用

443
00:12:18,596 --> 00:12:19,976
可以让我们更加

444
00:12:19,976 --> 00:12:21,486
快速且准确地追踪

445
00:12:21,486 --> 00:12:21,936
重力

446
00:12:22,526 --> 00:12:24,256
一旦有了重力 我们就可以

447
00:12:24,256 --> 00:12:25,726
将它转换成倾斜角度设计到

448
00:12:25,726 --> 00:12:26,076
游戏中

449
00:12:27,326 --> 00:12:28,926
现在我们来看看如何

450
00:12:28,926 --> 00:12:30,596
操作 我的同事 Ahmad

451
00:12:30,596 --> 00:12:31,456
一会儿会来到讲台上

452
00:12:31,456 --> 00:12:33,386
向我们展示

453
00:12:33,936 --> 00:12:36,146
这个参考系对于

454
00:12:36,146 --> 00:12:37,816
使用还很棒的一点在于当你

455
00:12:37,816 --> 00:12:39,576
想要追踪用户的

456
00:12:39,576 --> 00:12:39,976
手势时

457
00:12:40,546 --> 00:12:41,926
我希望大家去看一下我们的

458
00:12:41,926 --> 00:12:43,646
样本应用软件 SwingWatch

459
00:12:44,356 --> 00:12:46,166
SwingWatch 是一款在

460
00:12:46,436 --> 00:12:47,906
手表上的 App 

461
00:12:48,066 --> 00:12:49,696
它使用 DeviceMotion 进行追踪

462
00:12:49,696 --> 00:12:51,416
当你在网球比赛中进行正手击球

463
00:12:51,416 --> 00:12:53,116
或者反手击球时

464
00:12:54,236 --> 00:12:55,336
样本代码和

465
00:12:55,336 --> 00:12:56,336
会议都可以在网上找到

466
00:12:56,336 --> 00:12:58,146
我鼓励大家去查看一下

467
00:12:58,956 --> 00:13:00,936
那么 我们来假设你有另一款

468
00:12:58,956 --> 00:13:00,936
那么 我们来假设你有另一款

469
00:13:00,936 --> 00:13:01,346
游戏

470
00:13:02,096 --> 00:13:03,386
假定是一款射击游戏

471
00:13:03,586 --> 00:13:05,666
你的用户可以

472
00:13:05,736 --> 00:13:07,066
通过虚拟的按钮开关进行瞄准

473
00:13:07,486 --> 00:13:09,496
这很棒 但是通过动态

474
00:13:09,496 --> 00:13:10,446
我们可以提供更加具有沉浸式的

475
00:13:10,446 --> 00:13:12,156
体验

476
00:13:15,936 --> 00:13:17,976
我们要做的是

477
00:13:17,976 --> 00:13:19,776
判断用户在哪里

478
00:13:19,776 --> 00:13:21,386
指向设备

479
00:13:21,386 --> 00:13:23,566
并且将这一信息转化

480
00:13:23,656 --> 00:13:25,306
成游戏中的瞄准 为此 我们

481
00:13:25,306 --> 00:13:26,346
想要使用空间方位

482
00:13:27,686 --> 00:13:29,496
空间方位可以提供

483
00:13:29,496 --> 00:13:31,306
旋转角度率

484
00:13:31,306 --> 00:13:32,186
从在你第一次

485
00:13:32,186 --> 00:13:34,086
DeviceMotion 更新时就固定的参考系到

486
00:13:34,086 --> 00:13:35,406
用户当前在 3D 空间中握着的

487
00:13:35,406 --> 00:13:38,346
设备

488
00:13:38,556 --> 00:13:39,946
现在 我们可以考虑用来

489
00:13:39,946 --> 00:13:41,966
获取空间方位的途径是

490
00:13:41,966 --> 00:13:43,826
取得整个原始参数

491
00:13:43,826 --> 00:13:44,226
信号

492
00:13:44,846 --> 00:13:47,256
你的摇摆会决定

493
00:13:47,256 --> 00:13:47,746
空间方位

494
00:13:48,236 --> 00:13:50,106
然而

495
00:13:50,106 --> 00:13:51,966
这一判断空间方位的方法

496
00:13:51,966 --> 00:13:53,926
会随时间产生偏离 这是由于

497
00:13:53,926 --> 00:13:56,936
参数的偏差 这时就需要

498
00:13:56,936 --> 00:13:58,616
xArbitraryCorrectedZVertical

499
00:13:58,616 --> 00:13:59,606
参考系的帮助了

500
00:14:00,196 --> 00:14:01,376
这一参考系通过使用

501
00:14:01,376 --> 00:14:03,076
magnetometer 来改进

502
00:14:03,076 --> 00:14:04,686
我们提供的水平

503
00:14:04,956 --> 00:14:07,236
空间方位预测 作为一名

504
00:14:07,236 --> 00:14:08,626
开发人员 这个参考

505
00:14:08,626 --> 00:14:09,886
系意味着

506
00:14:09,886 --> 00:14:11,546
通过一个固定的中心参考

507
00:14:11,546 --> 00:14:13,386
向你提供可靠的空间方位

508
00:14:13,386 --> 00:14:13,916
性能

509
00:14:14,286 --> 00:14:16,206
所以在游戏中 你的用户可以

510
00:14:16,206 --> 00:14:17,706
来回移动设备然后

511
00:14:17,746 --> 00:14:19,046
找到一个已知的中心

512
00:14:19,046 --> 00:14:19,666
位置

513
00:14:21,166 --> 00:14:22,546
现在 通过使用这个参考系

514
00:14:22,546 --> 00:14:23,756
你还有许多其他的方式

515
00:14:23,756 --> 00:14:24,426
可以考虑

516
00:14:25,046 --> 00:14:26,176
假设你想要构建一款

517
00:14:26,176 --> 00:14:28,356
360 度的相片和视频

518
00:14:28,356 --> 00:14:29,236
播放应用软件

519
00:14:29,236 --> 00:14:30,906
你的用户可以转动

520
00:14:30,906 --> 00:14:32,356
他们的设备然后

521
00:14:32,356 --> 00:14:33,966
回到追准一个中心的状态

522
00:14:34,126 --> 00:14:35,276
这里即对准湖上的

523
00:14:35,276 --> 00:14:35,646
码头

524
00:14:37,286 --> 00:14:38,296
另外一个你可以

525
00:14:38,296 --> 00:14:39,736
考虑使用参考

526
00:14:39,736 --> 00:14:41,366
系的是有关

527
00:14:41,366 --> 00:14:42,766
虚拟现实的房地产的

528
00:14:42,766 --> 00:14:44,646
应用软件 你会想

529
00:14:44,646 --> 00:14:46,636
让你的用户可以

530
00:14:46,636 --> 00:14:47,656
从不同角度环顾房间

531
00:14:47,886 --> 00:14:48,866
而仅需移动他们的设备

532
00:14:50,486 --> 00:14:51,596
假设现在你已经构建了这样的一款

533
00:14:51,596 --> 00:14:53,046
应用软件 你的用户

534
00:14:53,116 --> 00:14:55,066
很喜欢它 但是他们想要

535
00:14:55,066 --> 00:14:56,356
更清楚地了解

536
00:14:56,356 --> 00:14:58,646
窗户的朝向 或者

537
00:14:58,746 --> 00:14:59,736
哪个方向

538
00:14:59,736 --> 00:15:00,766
可以看到日出

539
00:14:59,736 --> 00:15:00,766
可以看到日出

540
00:15:01,096 --> 00:15:03,226
为此 我们想要一个“环境

541
00:15:03,226 --> 00:15:03,676
参考”

542
00:15:05,366 --> 00:15:07,076
现在你可以考虑使用

543
00:15:07,076 --> 00:15:08,136
magnetometer 来完成它

544
00:15:08,136 --> 00:15:09,466
它可以提供一个“环境

545
00:15:09,466 --> 00:15:10,556
参考”而且你的

546
00:15:10,556 --> 00:15:11,906
应用软件可以根据环境

547
00:15:11,906 --> 00:15:12,806
作出适应

548
00:15:13,646 --> 00:15:14,966
然而 使用原始

549
00:15:14,966 --> 00:15:16,846
magnetometer 你会发现

550
00:15:16,846 --> 00:15:17,946
输出容易被

551
00:15:17,946 --> 00:15:18,626
打乱

552
00:15:19,556 --> 00:15:21,406
有一些是

553
00:15:21,406 --> 00:15:23,306
设备固有的 而有一些是

554
00:15:23,306 --> 00:15:24,346
设备外的

555
00:15:25,706 --> 00:15:26,936
这个时候就需要用到最后两个

556
00:15:26,936 --> 00:15:28,026
参考系了

557
00:15:28,566 --> 00:15:30,706
这两个参考系使用

558
00:15:30,706 --> 00:15:32,586
magnetometer 根据环境

559
00:15:32,586 --> 00:15:34,616
适应设备

560
00:15:34,736 --> 00:15:36,956
这些参考

561
00:15:36,956 --> 00:15:38,606
系处理的是磁性

562
00:15:38,746 --> 00:15:40,966
设备级别的效应 

563
00:15:40,966 --> 00:15:42,396
还可以挑战 magnetometer

564
00:15:42,396 --> 00:15:44,266
的状况 可以

565
00:15:44,266 --> 00:15:44,696
使输出变得稳定

566
00:15:46,176 --> 00:15:48,046
那么 在这两个

567
00:15:48,046 --> 00:15:49,656
参考系中作何选择则是

568
00:15:49,656 --> 00:15:50,576
根据你应用软件的

569
00:15:50,576 --> 00:15:51,206
需求

570
00:15:51,646 --> 00:15:52,886
如果你已经获得了

571
00:15:53,076 --> 00:15:54,276
有关真北的数据 

572
00:15:54,486 --> 00:15:55,796
例如 地图数据 

573
00:15:55,796 --> 00:15:57,166
那么使用

574
00:15:57,166 --> 00:15:58,786
xTrueNorthZVertical 参考

575
00:15:58,786 --> 00:15:59,106
系就更合理

576
00:16:00,326 --> 00:16:03,356
那么我们要如何考虑使用

577
00:16:03,356 --> 00:16:04,326
这些参考系呢

578
00:16:04,916 --> 00:16:07,106
其中一个例子是

579
00:16:07,106 --> 00:16:08,816
观星指南应用软件 

580
00:16:08,816 --> 00:16:09,846
你希望你的用户可以通过

581
00:16:09,846 --> 00:16:11,506
将设备对准

582
00:16:11,506 --> 00:16:14,056
天空中的星星来进行识别

583
00:16:14,316 --> 00:16:14,896
另外你还可以

584
00:16:14,896 --> 00:16:15,636
考虑将这些

585
00:16:15,636 --> 00:16:17,106
参考系

586
00:16:17,106 --> 00:16:18,076
运用到增强现实

587
00:16:18,076 --> 00:16:19,756
的应用软件中去 在这类的应用软件中你需要

588
00:16:19,756 --> 00:16:21,736
结合相机数据和

589
00:16:21,736 --> 00:16:22,546
环境参考

590
00:16:22,906 --> 00:16:24,196
为此 我们会建议你

591
00:16:24,196 --> 00:16:25,106
查看 ARKit

592
00:16:25,496 --> 00:16:26,746
ARKit 会议将

593
00:16:26,746 --> 00:16:27,876
紧随本次会议举行

594
00:16:27,876 --> 00:16:32,196
现在 我们再回到

595
00:16:32,196 --> 00:16:33,516
虚拟现实的房地产

596
00:16:33,516 --> 00:16:34,116
应用软件上来

597
00:16:35,286 --> 00:16:35,886
假设你已经构建了一款

598
00:16:35,886 --> 00:16:37,276
应用软件 你的用户也很

599
00:16:37,276 --> 00:16:39,306
喜欢它 但是你想要提供

600
00:16:39,306 --> 00:16:40,696
更多的功能

601
00:16:41,186 --> 00:16:42,416
假设你想要

602
00:16:42,416 --> 00:16:44,166
根据现实的位置

603
00:16:44,166 --> 00:16:45,296
在水平面上添加

604
00:16:45,296 --> 00:16:45,576
地标

605
00:16:46,506 --> 00:16:48,166
我们要怎么

606
00:16:48,166 --> 00:16:48,346
做呢

607
00:16:49,096 --> 00:16:51,006
我们需要的是指向标

608
00:16:52,376 --> 00:16:54,266
指向标为我们提供

609
00:16:54,266 --> 00:16:55,376
设备所指的方向

610
00:16:55,376 --> 00:16:56,346
这是相对于正北而言的

611
00:16:56,786 --> 00:16:58,226
所以当设备指着

612
00:16:58,306 --> 00:17:00,086
正北时 指向标

613
00:16:58,306 --> 00:17:00,086
正北时 指向标

614
00:17:00,086 --> 00:17:03,076
会回到 0 度

615
00:17:03,076 --> 00:17:04,486
当用户旋转他们的设备

616
00:17:04,546 --> 00:17:06,205
指向标的角度也会随之

617
00:17:06,205 --> 00:17:06,586
改变

618
00:17:08,106 --> 00:17:09,556
现在你要考虑的是

619
00:17:09,556 --> 00:17:11,086
通过使用 CoreLocation

620
00:17:11,086 --> 00:17:11,846
获得指向标

621
00:17:12,316 --> 00:17:14,306
CoreLocation 提供一个开始

622
00:17:14,306 --> 00:17:17,006
更新指向标 API 然后你

623
00:17:17,006 --> 00:17:18,796
使用那个指向标

624
00:17:18,796 --> 00:17:20,445
并进行合并 通过

625
00:17:20,445 --> 00:17:21,476
你已经从

626
00:17:21,476 --> 00:17:22,236
DeviceMotion 获取的数据

627
00:17:24,366 --> 00:17:25,256
但要记住

628
00:17:25,256 --> 00:17:26,965
CoreLocation

629
00:17:26,965 --> 00:17:28,926
的指向标可能会合并路线

630
00:17:29,846 --> 00:17:31,216
路线这里是指

631
00:17:31,216 --> 00:17:32,066
设备移动的反响

632
00:17:32,896 --> 00:17:34,646
这对于

633
00:17:34,646 --> 00:17:35,746
逐向

634
00:17:35,746 --> 00:17:37,886
导航应用软件也许是合理的 但是对于

635
00:17:37,886 --> 00:17:39,226
增强现实应用软件来说

636
00:17:39,436 --> 00:17:40,496
就不那么合理了

637
00:17:40,846 --> 00:17:42,296
我希望你可以

638
00:17:42,296 --> 00:17:43,666
听听周四的 CoreLocation 会议

639
00:17:43,666 --> 00:17:45,266
以获取更多细节

640
00:17:46,596 --> 00:17:48,126
此外你可能还考虑

641
00:17:48,126 --> 00:17:49,806
通过我们提供在 DeviceMotion

642
00:17:49,806 --> 00:17:51,376
中的空间方位估算

643
00:17:51,376 --> 00:17:53,276
来获得

644
00:17:53,276 --> 00:17:54,066
指向标

645
00:17:54,586 --> 00:17:56,266
然而 要想在

646
00:17:56,266 --> 00:17:57,476
所有情况下把这件事做正确

647
00:17:57,476 --> 00:17:59,946
绝非容易的事 这也是为什么

648
00:18:00,336 --> 00:18:01,876
今年我们在 DeviceMotion

649
00:18:01,876 --> 00:18:03,716
中添加了指向标 并将它作为

650
00:18:03,716 --> 00:18:04,546
一项顶级的性能

651
00:18:05,896 --> 00:18:07,716
指向标将

652
00:18:07,716 --> 00:18:09,276
accelerometer gyroscope 以及

653
00:18:09,276 --> 00:18:09,896
最重要的

654
00:18:09,896 --> 00:18:11,306
magnetometer 合并起来 利用正北方向

655
00:18:11,306 --> 00:18:12,736
为我们提供设备所指

656
00:18:12,736 --> 00:18:13,656
的方向

657
00:18:15,366 --> 00:18:16,746
记住 指向标

658
00:18:16,746 --> 00:18:19,026
仅在 iOS 系统上提供 同时

659
00:18:19,026 --> 00:18:20,206
磁场特性也是

660
00:18:20,206 --> 00:18:20,606
可用的

661
00:18:22,156 --> 00:18:23,576
现在我们来仔细看一下

662
00:18:23,576 --> 00:18:23,976
API

663
00:18:25,386 --> 00:18:27,066
指向标仅对

664
00:18:27,066 --> 00:18:28,986
xMagneticNorth 和 xTrueNorth

665
00:18:28,986 --> 00:18:29,766
参考系有效

666
00:18:30,126 --> 00:18:31,106
对以其他两个参考系

667
00:18:31,106 --> 00:18:32,146
你会

668
00:18:32,146 --> 00:18:33,326
从指向标收到一个负值

669
00:18:33,326 --> 00:18:36,426
指向标会

670
00:18:36,426 --> 00:18:39,586
从你在你应用软件中

671
00:18:39,586 --> 00:18:41,546
选择的 X 轴上 给你 0 到 359 度

672
00:18:41,546 --> 00:18:42,856
的数值范围 无论是

673
00:18:42,856 --> 00:18:44,356
MagneticNorth 还是 TrueNorth

674
00:18:44,986 --> 00:18:48,016
既然我们有了指向标 我们

675
00:18:48,016 --> 00:18:49,776
就可以用它来

676
00:18:49,776 --> 00:18:50,936
将金门大桥

677
00:18:50,936 --> 00:18:52,606
放置在它

678
00:18:52,606 --> 00:18:52,916
实际的方位上了

679
00:18:55,946 --> 00:18:57,496
现在 通过 DeviceMotion

680
00:18:57,496 --> 00:18:58,686
我们有一些最佳实践

681
00:18:58,686 --> 00:18:59,446
需要记住

682
00:19:00,266 --> 00:19:02,226
首先 你要

683
00:19:02,226 --> 00:19:03,456
确保在开始更新之前

684
00:19:03,456 --> 00:19:04,546
检查所给

685
00:19:04,546 --> 00:19:06,196
参考系的

686
00:19:06,196 --> 00:19:06,746
可用性

687
00:19:07,566 --> 00:19:09,646
为此 你可以使用

688
00:19:09,646 --> 00:19:10,966
availableAttitudeReference

689
00:19:10,966 --> 00:19:11,586
Frame 的 API

690
00:19:12,216 --> 00:19:13,176
它会返回给你一个

691
00:19:13,336 --> 00:19:15,356
CMAttitudeReferenceFrame 位掩码

692
00:19:15,586 --> 00:19:17,016
然后你可以通过

693
00:19:17,016 --> 00:19:17,856
相关的参考系

694
00:19:17,856 --> 00:19:19,136
来确定

695
00:19:19,136 --> 00:19:19,756
可用性

696
00:19:21,086 --> 00:19:22,736
下一件要

697
00:19:22,736 --> 00:19:23,866
记住的是 选择

698
00:19:23,866 --> 00:19:25,556
参考系对于你的应用软件来说

699
00:19:25,556 --> 00:19:26,326
很关键

700
00:19:26,506 --> 00:19:28,416
这会决定

701
00:19:28,416 --> 00:19:29,876
如何计算你应用软件的

702
00:19:29,876 --> 00:19:32,246
空间方位 以及决定哪些

703
00:19:32,246 --> 00:19:34,056
传感器会被

704
00:19:34,056 --> 00:19:34,686
合并

705
00:19:36,286 --> 00:19:37,806
现在 我们已经讲了一些

706
00:19:37,806 --> 00:19:39,686
有关 DeviceMotion 的事

707
00:19:39,686 --> 00:19:40,596
让我们来讲讲更加

708
00:19:40,596 --> 00:19:41,146
实际的东西

709
00:19:41,806 --> 00:19:45,126
我们来讲讲

710
00:19:45,266 --> 00:19:46,296
我们在 DeviceMotion 中讨论过的一些概念

711
00:19:46,296 --> 00:19:48,686
然后通过一个游戏

712
00:19:48,686 --> 00:19:50,516
看看它们的实际应用

713
00:19:51,466 --> 00:19:53,076
Badger with Attitude 是一款游戏

714
00:19:53,256 --> 00:19:54,246
其中我们需要使用

715
00:19:54,536 --> 00:19:56,776
DeviceMotion 为游戏

716
00:19:56,776 --> 00:19:58,616
转换控制 

717
00:19:58,616 --> 00:19:59,806
为此 我会请我的

718
00:19:59,806 --> 00:20:01,516
同事 Ahmad 到台上来

719
00:19:59,806 --> 00:20:01,516
同事 Ahmad 到台上来

720
00:20:01,516 --> 00:20:02,326
跟大家讲一讲这个

721
00:20:03,516 --> 00:20:07,500
[鼓掌]

722
00:20:14,396 --> 00:20:15,186
&gt;&gt; 谢谢你 John

723
00:20:16,676 --> 00:20:17,576
大家好 欢迎来到这里

724
00:20:18,346 --> 00:20:19,406
今天我会讲一讲

725
00:20:19,406 --> 00:20:21,246
有关那些概念的问题 也就是 John

726
00:20:21,246 --> 00:20:22,606
前面提到的 

727
00:20:22,606 --> 00:20:23,656
通过一个实例帮大家加深

728
00:20:23,656 --> 00:20:24,126
了解

729
00:20:24,876 --> 00:20:26,106
我叫 Ahmad 我是

730
00:20:26,106 --> 00:20:27,256
Core Motion 团队的一名

731
00:20:27,256 --> 00:20:27,536
工程师

732
00:20:29,036 --> 00:20:30,296
我将会使用 Badger 这个 App

733
00:20:30,446 --> 00:20:31,666
它是由我们在 SceneKit 

734
00:20:31,666 --> 00:20:32,946
的同事开发的

735
00:20:33,546 --> 00:20:34,626
你也许已经看到过它了

736
00:20:34,626 --> 00:20:35,456
就在去年的会议上

737
00:20:36,096 --> 00:20:37,476
在这款游戏里你需要操控一只很可爱的

738
00:20:37,476 --> 00:20:38,686
小獾 他叫 Bob

739
00:20:39,106 --> 00:20:41,156
他坐在一个采矿车里 在

740
00:20:41,156 --> 00:20:42,766
车轨上颠簸 一路上

741
00:20:42,766 --> 00:20:43,876
挑选宝石和获取能量

742
00:20:44,466 --> 00:20:46,566
所以我们要来讲一讲这款 App

743
00:20:46,566 --> 00:20:48,886
通过现存的滑动操作

744
00:20:49,046 --> 00:20:50,946
并使用 DeviceMotion 将其变成

745
00:20:51,376 --> 00:20:52,806
基于动态的姿势

746
00:20:53,236 --> 00:20:58,546
这是现在商店中可以为你

747
00:20:58,546 --> 00:21:00,396
提供的： 首先我们

748
00:20:58,546 --> 00:21:00,396
提供的： 首先我们

749
00:21:00,396 --> 00:21:01,556
要讲讲现存的

750
00:21:01,556 --> 00:21:03,186
控制 以及我们正在努力

751
00:21:03,186 --> 00:21:03,926
完成的

752
00:21:04,816 --> 00:21:06,446
然后我们会向你展示

753
00:21:06,446 --> 00:21:08,126
关于使用 DeviceMotion 的一些基本的东西

754
00:21:08,906 --> 00:21:10,456
最后 我们用算法

755
00:21:10,456 --> 00:21:12,046
来捕捉那些姿势

756
00:21:12,586 --> 00:21:16,206
在 Badger 这款 App 中

757
00:21:16,206 --> 00:21:17,746
你可以在屏幕上滑动手指

758
00:21:17,746 --> 00:21:19,206
来使獾跳动

759
00:21:20,186 --> 00:21:21,166
如果你下滑手指

760
00:21:21,166 --> 00:21:22,956
獾会低头藏在

761
00:21:22,956 --> 00:21:24,226
手推车里 以避开

762
00:21:24,226 --> 00:21:24,746
障碍物

763
00:21:25,876 --> 00:21:27,366
向左右滑动可以

764
00:21:27,366 --> 00:21:29,306
让獾通过摆动

765
00:21:29,306 --> 00:21:30,196
够到宝石

766
00:21:31,406 --> 00:21:33,176
如果你在这么美丽的

767
00:21:33,176 --> 00:21:34,346
图案上进行操作 

768
00:21:34,346 --> 00:21:35,356
仅仅将它们藏在

769
00:21:35,356 --> 00:21:36,516
手指后面玩游戏的话

770
00:21:36,516 --> 00:21:37,086
就太可惜了

771
00:21:38,516 --> 00:21:39,596
所以 这里我们就将手机作为

772
00:21:39,596 --> 00:21:42,456
控制器 让

773
00:21:42,456 --> 00:21:43,806
用户完全沉浸在

774
00:21:43,806 --> 00:21:45,156
我们为他们构建的体验中

775
00:21:47,456 --> 00:21:48,806
那么首先 我们要检测

776
00:21:48,806 --> 00:21:50,656
用户是否将设备

777
00:21:50,686 --> 00:21:52,226
转向自己来使獾

778
00:21:52,226 --> 00:21:52,636
跳跃

779
00:21:54,456 --> 00:21:55,856
轻微地向下晃动设备

780
00:21:55,856 --> 00:21:57,336
可以使獾

781
00:21:57,336 --> 00:21:58,906
蹲下藏到手推车里

782
00:21:59,796 --> 00:22:02,346
向左或向右倾斜设备

783
00:21:59,796 --> 00:22:02,346
向左或向右倾斜设备

784
00:22:02,346 --> 00:22:04,226
会使獾相应地进行

785
00:22:04,226 --> 00:22:04,786
倾斜

786
00:22:05,336 --> 00:22:09,256
现在我想让你关注在

787
00:22:09,256 --> 00:22:11,646
这些点上 

788
00:22:11,646 --> 00:22:12,966
当你之后在看着

789
00:22:12,966 --> 00:22:15,126
样本代码时想一想它们 或者

790
00:22:15,126 --> 00:22:16,556
想一想如何将动态并进

791
00:22:16,556 --> 00:22:17,366
你的应用软件

792
00:22:17,876 --> 00:22:20,646
正如 John 已经提到的

793
00:22:20,726 --> 00:22:22,236
通过 Core Motion 你可以

794
00:22:22,316 --> 00:22:23,386
直接和传感器进行

795
00:22:23,386 --> 00:22:23,896
互动

796
00:22:24,776 --> 00:22:25,966
拿 accelerometer

797
00:22:25,966 --> 00:22:26,636
来说

798
00:22:27,926 --> 00:22:29,616
只要用户是半静止的状态

799
00:22:29,616 --> 00:22:31,246
那样的输入看上去还行

800
00:22:31,506 --> 00:22:32,946
但是当你开始走动

801
00:22:32,946 --> 00:22:34,846
或者上一辆公交车 你就

802
00:22:34,846 --> 00:22:35,776
必须考虑

803
00:22:35,776 --> 00:22:37,236
这些额外的 加速度

804
00:22:38,286 --> 00:22:39,756
通过 DeviceMotion 我们已经

805
00:22:39,756 --> 00:22:41,216
用其他的传感器 比如

806
00:22:41,216 --> 00:22:43,046
gyro 和 magnetometer 来

807
00:22:43,046 --> 00:22:44,296
对 accelerometer 进行了

808
00:22:44,296 --> 00:22:46,346
很好的补充 我们

809
00:22:46,346 --> 00:22:48,576
为你合并这些输入 这样一来我们可以

810
00:22:48,576 --> 00:22:50,016
将环境因素的影响

811
00:22:50,016 --> 00:22:51,876
最小化 让你专注在

812
00:22:51,876 --> 00:22:53,746
捕捉动态控制上

813
00:22:54,206 --> 00:22:56,446
而不是如何处理

814
00:22:57,606 --> 00:22:58,286
传感器的输入问题

815
00:22:58,896 --> 00:23:01,276
通过 DeviceMotion API 你可以

816
00:22:58,896 --> 00:23:01,276
通过 DeviceMotion API 你可以

817
00:23:01,276 --> 00:23:03,336
以两种不同的方式来质询

818
00:23:03,336 --> 00:23:06,126
样本 即“推”和

819
00:23:06,126 --> 00:23:06,996
“拉”这两种机制

820
00:23:07,376 --> 00:23:09,396
让我们来仔细看一下这

821
00:23:10,106 --> 00:23:10,176
两个机制

822
00:23:12,196 --> 00:23:13,886
“推”这一机制对于

823
00:23:13,886 --> 00:23:15,576
捕捉一定时间内

824
00:23:15,576 --> 00:23:17,336
的分离姿势是很

825
00:23:17,336 --> 00:23:17,656
有用的

826
00:23:19,046 --> 00:23:21,216
在去年的 SwingWatch App 中

827
00:23:21,216 --> 00:23:23,716
我们使用了“推”

828
00:23:23,716 --> 00:23:25,376
这个机制 因此框架

829
00:23:25,376 --> 00:23:27,226
会在固定的间隔内

830
00:23:27,226 --> 00:23:28,906
向我们推一些更新 只要

831
00:23:29,206 --> 00:23:29,666
有更新的话

832
00:23:31,026 --> 00:23:32,056
然后我们会捕捉这些

833
00:23:32,056 --> 00:23:34,256
更新并且检测用户是否

834
00:23:34,256 --> 00:23:35,746
摆动手臂来进行

835
00:23:35,746 --> 00:23:36,906
反手击球或正手击球

836
00:23:38,936 --> 00:23:40,696
这就是 API 的样子

837
00:23:41,286 --> 00:23:43,076
你使用 CMMotionManager 的

838
00:23:43,436 --> 00:23:44,746
开始 DeviceMotion 更新

839
00:23:44,746 --> 00:23:46,626
功能 你提供一个

840
00:23:46,626 --> 00:23:48,076
相关的参考系

841
00:23:49,466 --> 00:23:51,606
提供一个操作线索 来使

842
00:23:51,606 --> 00:23:53,206
你的 motionHandler 尽快

843
00:23:53,206 --> 00:23:54,556
处理那些已有的样本

844
00:23:57,156 --> 00:24:00,416
然而 如果你先要知道

845
00:23:57,156 --> 00:24:00,416
然而 如果你先要知道

846
00:24:00,416 --> 00:24:01,486
设备的当前状态

847
00:24:01,486 --> 00:24:04,126
那么你需要在这里使用

848
00:24:04,126 --> 00:24:05,226
“拉”这个机制

849
00:24:05,836 --> 00:24:07,266
正如我们之后会在

850
00:24:07,266 --> 00:24:09,086
Badger 这款 App 演示 对于倾斜

851
00:24:09,156 --> 00:24:11,366
姿势 我们想要让

852
00:24:11,366 --> 00:24:13,366
獾的倾斜角度

853
00:24:13,366 --> 00:24:14,406
和手机一样

854
00:24:15,316 --> 00:24:17,526
因此我们要确保

855
00:24:17,526 --> 00:24:19,386
为我们的图形应用软件提供

856
00:24:20,016 --> 00:24:21,426
反应灵敏而流畅的体验

857
00:24:23,056 --> 00:24:24,996
“拉”机制的 API 

858
00:24:24,996 --> 00:24:25,826
更简单

859
00:24:26,416 --> 00:24:26,836
你调用

860
00:24:26,836 --> 00:24:28,756
startDeviceMotionUpdates 然后

861
00:24:28,756 --> 00:24:30,036
提供参考系

862
00:24:31,006 --> 00:24:32,156
只要你准备好了 你就

863
00:24:32,156 --> 00:24:33,376
可以从框架中拉取最新的

864
00:24:33,376 --> 00:24:34,916
DeviceMotion 

865
00:24:34,916 --> 00:24:35,366
样本

866
00:24:35,856 --> 00:24:39,226
我们还将发布样本

867
00:24:39,226 --> 00:24:40,446
代码以供使用 你之后

868
00:24:40,446 --> 00:24:42,516
可以看一下 但是现在

869
00:24:42,516 --> 00:24:43,736
让我们先来关注 Core Motion

870
00:24:43,736 --> 00:24:44,336
的部分

871
00:24:44,956 --> 00:24:47,376
那么让我们从它们开始

872
00:24:47,376 --> 00:24:49,216
介绍 Core Motion 框架

873
00:24:49,216 --> 00:24:50,616
然后举一个

874
00:24:50,616 --> 00:24:51,696
CMMotionManager 的例子

875
00:24:52,936 --> 00:24:54,796
然后我们检查一下 DeviceMotion

876
00:24:54,796 --> 00:24:56,236
更新在这个平台是是否

877
00:24:56,236 --> 00:24:56,756
可用

878
00:24:57,266 --> 00:25:00,026
如果你回忆刚才 John

879
00:24:57,266 --> 00:25:00,026
如果你回忆刚才 John

880
00:25:00,026 --> 00:25:02,126
讲的 我们

881
00:25:02,126 --> 00:25:03,806
关注的

882
00:25:03,806 --> 00:25:05,406
关于追踪重力的倾斜姿势也在

883
00:25:05,406 --> 00:25:05,656
设备框中

884
00:25:06,386 --> 00:25:08,116
我们会使用

885
00:25:08,116 --> 00:25:09,896
xArbitraryZVertical 参考

886
00:25:09,896 --> 00:25:11,626
系 我会还会检查它使用在

887
00:25:11,626 --> 00:25:12,646
平台上可用

888
00:25:13,606 --> 00:25:15,616
你也许注意到了在这里我没有

889
00:25:15,906 --> 00:25:17,526
检查授权

890
00:25:17,526 --> 00:25:18,686
这是因为我正在

891
00:25:18,686 --> 00:25:20,096
使用 MotionManager API

892
00:25:20,416 --> 00:25:22,506
它并不访问敏感

893
00:25:22,506 --> 00:25:22,796
数据

894
00:25:24,766 --> 00:25:27,896
接下来的部分 我们会

895
00:25:27,896 --> 00:25:29,866
假定设备属于

896
00:25:29,906 --> 00:25:31,116
最后一种定向 但是

897
00:25:31,116 --> 00:25:32,246
在样本代码中 我们会向你展示

898
00:25:32,246 --> 00:25:34,306
如何捕捉处理其他的

899
00:25:34,306 --> 00:25:35,406
设备定向

900
00:25:38,956 --> 00:25:41,126
对于第一种姿势 当

901
00:25:41,336 --> 00:25:42,976
向自己旋转设备

902
00:25:43,186 --> 00:25:45,296
来使獾起跳时 我们

903
00:25:45,296 --> 00:25:47,366
想要捕捉

904
00:25:47,366 --> 00:25:49,156
手机水平轴的

905
00:25:49,156 --> 00:25:50,986
旋转率数值

906
00:25:51,736 --> 00:25:53,206
在这个例子中 也就是 Y 轴

907
00:25:55,816 --> 00:25:57,286
那么我们还要看一下

908
00:25:57,286 --> 00:25:59,836
DeviceMotion 目标的

909
00:25:59,836 --> 00:26:00,906
旋转率特性

910
00:25:59,836 --> 00:26:00,906
旋转率特性

911
00:26:01,486 --> 00:26:02,946
我们特别选择它

912
00:26:02,946 --> 00:26:04,736
是因为我们与

913
00:26:04,736 --> 00:26:06,376
设备当前的角度不相关

914
00:26:06,376 --> 00:26:08,056
与我们相关的是

915
00:26:08,056 --> 00:26:09,006
那个角度的快速改变

916
00:26:10,286 --> 00:26:12,046
所以如果我们使用旋转率的话

917
00:26:12,096 --> 00:26:14,246
我们就可以检测到快速的

918
00:26:14,316 --> 00:26:16,036
跳动 并且让獾相应地

919
00:26:16,036 --> 00:26:16,646
进行跳跃

920
00:26:17,136 --> 00:26:19,676
这是我们

921
00:26:19,676 --> 00:26:21,786
在很短的一段时间要检测到的

922
00:26:21,786 --> 00:26:23,156
姿势 因此我们要对它

923
00:26:23,156 --> 00:26:26,346
使用“推”机制

924
00:26:26,616 --> 00:26:27,606
让我们来看看它

925
00:26:27,606 --> 00:26:27,976
在代码里是什么样的

926
00:26:28,606 --> 00:26:31,106
最开始 我们要将

927
00:26:31,106 --> 00:26:32,666
更新间隔设为 50 赫兹

928
00:26:33,176 --> 00:26:34,176
你需要在设置的时候

929
00:26:34,176 --> 00:26:34,736
很小心

930
00:26:35,466 --> 00:26:36,496
你希望样本

931
00:26:36,496 --> 00:26:38,006
过来的足够快 这样的话

932
00:26:38,006 --> 00:26:39,406
你就可以捕捉那个姿势

933
00:26:39,876 --> 00:26:41,126
但是也不要太快

934
00:26:41,126 --> 00:26:42,626
那样会提高对计算

935
00:26:42,976 --> 00:26:44,206
和记忆的要求

936
00:26:45,656 --> 00:26:47,716
然后我们开始

937
00:26:47,716 --> 00:26:49,696
使用“推”机制进行 DeviceMotion 更新

938
00:26:49,696 --> 00:26:51,416
提供我们的

939
00:26:51,416 --> 00:26:53,166
xArbitraryZVertical 参考

940
00:26:53,166 --> 00:26:56,216
系 一个“queue” 我正在这里

941
00:26:56,216 --> 00:26:58,586
使用标准操作线索 

942
00:26:58,586 --> 00:26:59,796
最后就是我们的 motionHandler

943
00:27:02,636 --> 00:27:04,186
这就是我们的 motionHandler

944
00:27:04,186 --> 00:27:04,686
的样子

945
00:27:04,946 --> 00:27:06,426
只要样本准备好了

946
00:27:06,426 --> 00:27:07,206
就可以调动它

947
00:27:07,926 --> 00:27:08,966
我们要做的第一件事就是

948
00:27:08,966 --> 00:27:11,606
检查所有的错误

949
00:27:11,606 --> 00:27:13,076
从 DeviceMotion 目标获取旋转率

950
00:27:13,076 --> 00:27:15,426
然后看一下

951
00:27:15,696 --> 00:27:17,516
与我们相关的

952
00:27:17,516 --> 00:27:18,776
Y 轴分量

953
00:27:19,336 --> 00:27:21,016
然后我们将它储存在缓冲存储器中

954
00:27:21,416 --> 00:27:22,436
我这里使用的是循环

955
00:27:22,436 --> 00:27:24,296
缓冲 因此只要

956
00:27:24,296 --> 00:27:25,656
样本过来 我们就可以

957
00:27:25,656 --> 00:27:29,566
积累更多

958
00:27:29,966 --> 00:27:31,226
由于我们为这个应用软件

959
00:27:31,226 --> 00:27:33,266
使用的是 SceneKit 渲染器

960
00:27:33,266 --> 00:27:34,126
我选择渲染器的

961
00:27:34,126 --> 00:27:35,336
updateAtTime 功能

962
00:27:35,826 --> 00:27:37,256
在你渲染一个新的场景之前

963
00:27:37,296 --> 00:27:40,046
它会被调用 这

964
00:27:40,046 --> 00:27:41,286
对于我来说是一个理想的地方

965
00:27:41,286 --> 00:27:42,396
来检查缓存状态

966
00:27:42,396 --> 00:27:44,576
然后更新游戏

967
00:27:45,106 --> 00:27:47,986
我会让你们

968
00:27:47,986 --> 00:27:48,746
自己去发现

969
00:27:48,746 --> 00:27:50,136
应用软件里的哪一个地方最适合

970
00:27:50,136 --> 00:27:51,126
做那件事

971
00:27:52,766 --> 00:27:54,426
然后我只需要检查一下

972
00:27:54,426 --> 00:27:55,816
那种缓存的方式是否跨过了

973
00:27:55,816 --> 00:27:57,336
某一界点使得

974
00:27:57,336 --> 00:27:58,306
獾可以跳跃

975
00:27:59,676 --> 00:28:01,286
记住这个界点

976
00:27:59,676 --> 00:28:01,286
记住这个界点

977
00:28:01,336 --> 00:28:03,216
是可以根据你 App 的特殊需求

978
00:28:03,216 --> 00:28:04,256
来进行转变和调整的

979
00:28:08,316 --> 00:28:10,446
接下来我们要看一下

980
00:28:10,446 --> 00:28:12,166
第二个控制 在第二个控制中当我们

981
00:28:12,166 --> 00:28:13,746
向下晃动设备时

982
00:28:13,746 --> 00:28:14,976
獾会下蹲

983
00:28:16,386 --> 00:28:18,216
对于这个控制 我们要测量的是

984
00:28:18,216 --> 00:28:20,996
用户顺着重力矢量的

985
00:28:20,996 --> 00:28:22,136
加速度

986
00:28:25,076 --> 00:28:26,636
所以我们要看用户的

987
00:28:26,636 --> 00:28:29,116
重力性能 这里

988
00:28:29,116 --> 00:28:31,526
我们选择它是因为哪怕

989
00:28:31,526 --> 00:28:33,326
设备稍微倾斜或

990
00:28:33,326 --> 00:28:35,166
旋转一定角度 用户的

991
00:28:35,166 --> 00:28:36,536
加速度还是

992
00:28:36,536 --> 00:28:38,436
一样的 不管空间方位

993
00:28:38,436 --> 00:28:39,036
如何变化

994
00:28:43,316 --> 00:28:45,546
因此这又是一个

995
00:28:45,546 --> 00:28:47,126
我们要在短时间内检测的

996
00:28:47,126 --> 00:28:48,446
动作 我们也会

997
00:28:48,446 --> 00:28:49,706
使用“推”机制

998
00:28:51,386 --> 00:28:52,546
由于我们已经建立了

999
00:28:52,546 --> 00:28:54,576
“推”机制 我们将会

1000
00:28:54,576 --> 00:28:56,246
返回我们的 motionHandler 

1001
00:28:56,246 --> 00:28:57,646
在那里我们之前存储了那些

1002
00:28:57,646 --> 00:28:58,496
旋转率

1003
00:28:59,006 --> 00:29:02,106
但是这次 我们要将

1004
00:28:59,006 --> 00:29:02,106
但是这次 我们要将

1005
00:29:02,106 --> 00:29:03,806
重力性能排除在

1006
00:29:03,806 --> 00:29:07,116
DeviceMotion 目标外 以及

1007
00:29:07,116 --> 00:29:08,146
用户的加速度

1008
00:29:08,686 --> 00:29:11,916
我们计算

1009
00:29:11,916 --> 00:29:13,716
顺着重力矢量的用户加速度的值

1010
00:29:13,716 --> 00:29:17,536
将它存储在

1011
00:29:17,536 --> 00:29:17,896
一个缓冲器里

1012
00:29:18,626 --> 00:29:21,306
一旦缓冲方式

1013
00:29:21,306 --> 00:29:22,666
超过了某个界点

1014
00:29:23,236 --> 00:29:24,696
我们就会让獾

1015
00:29:24,696 --> 00:29:27,366
蹲在并且藏在手推车里

1016
00:29:28,136 --> 00:29:29,826
所以我们来看一眼这两个

1017
00:29:29,826 --> 00:29:31,886
控制 我们通过在这两个控制

1018
00:29:31,886 --> 00:29:33,506
来监测一小段时间内的动态

1019
00:29:33,506 --> 00:29:35,266
我们还为此使用了

1020
00:29:35,266 --> 00:29:36,346
“推”机制

1021
00:29:37,216 --> 00:29:38,716
让我们来看一下最后一个

1022
00:29:38,766 --> 00:29:40,976
控制 对于这个控制我们的要求

1023
00:29:40,976 --> 00:29:43,816
稍有不同

1024
00:29:44,826 --> 00:29:48,046
对于倾斜控制来说 

1025
00:29:48,046 --> 00:29:49,686
举个简单的例子 当设备被

1026
00:29:49,686 --> 00:29:52,976
垂直拿着时 

1027
00:29:52,976 --> 00:29:54,206
你可以将重力

1028
00:29:54,206 --> 00:29:56,236
矢量分割成 X 轴分量

1029
00:29:56,236 --> 00:29:59,236
和 Y 轴分量 通过运用

1030
00:29:59,236 --> 00:30:00,816
简单的三角学原理 

1031
00:29:59,236 --> 00:30:00,816
简单的三角学原理 

1032
00:30:00,816 --> 00:30:01,646
你可以达到倾斜

1033
00:30:03,006 --> 00:30:05,086
但是由于我们希望这个姿势

1034
00:30:05,086 --> 00:30:06,476
更加灵活

1035
00:30:07,186 --> 00:30:08,636
我们要将重力分成

1036
00:30:08,636 --> 00:30:10,306
Y 轴分量 

1037
00:30:10,306 --> 00:30:12,586
以及在设备 X－Z 轴上的

1038
00:30:12,586 --> 00:30:13,216
分量

1039
00:30:14,066 --> 00:30:15,386
这样一来

1040
00:30:15,386 --> 00:30:19,826
哪怕设备稍微旋转了一定角度 我们也可以

1041
00:30:19,826 --> 00:30:21,286
倾斜手机

1042
00:30:22,576 --> 00:30:23,856
这个控制的不同之处在于

1043
00:30:23,856 --> 00:30:25,326
我们想要知道

1044
00:30:25,766 --> 00:30:27,296
设备的当前状态

1045
00:30:27,366 --> 00:30:28,766
而不是发生的

1046
00:30:28,766 --> 00:30:29,156
分离动态

1047
00:30:30,536 --> 00:30:33,486
这使我们可以让

1048
00:30:33,486 --> 00:30:35,416
獾根据设备的倾斜角度

1049
00:30:35,416 --> 00:30:37,166
倾斜同样的角度 

1050
00:30:37,166 --> 00:30:38,616
并且提供非常灵敏的

1051
00:30:38,616 --> 00:30:39,286
操作体验

1052
00:30:39,786 --> 00:30:42,416
基于那些原因 我们将

1053
00:30:42,416 --> 00:30:44,546
为此控制使用

1054
00:30:45,026 --> 00:30:47,076
“拉”机制

1055
00:30:47,146 --> 00:30:48,366
由于我们已经建立了

1056
00:30:48,366 --> 00:30:50,656
“拉”机制 

1057
00:30:50,656 --> 00:30:51,996
当我们要拉回

1058
00:30:51,996 --> 00:30:54,396
任何时间点的样本时 

1059
00:30:54,396 --> 00:30:54,716
框架都是准备好的

1060
00:30:56,716 --> 00:30:58,606
所以我们要回到我们的渲染器

1061
00:30:58,606 --> 00:30:59,226
功能

1062
00:30:59,456 --> 00:31:00,626
回想一下 它会在

1063
00:30:59,456 --> 00:31:00,626
回想一下 它会在

1064
00:31:00,626 --> 00:31:02,356
你渲染一个新场景之前

1065
00:31:02,356 --> 00:31:02,886
被调用

1066
00:31:03,616 --> 00:31:05,406
这使得它成为了

1067
00:31:05,406 --> 00:31:06,926
我拉回最新样本的最佳

1068
00:31:06,926 --> 00:31:09,076
场所 也是计算和

1069
00:31:09,076 --> 00:31:12,516
更新图画的最佳场所

1070
00:31:12,516 --> 00:31:13,756
所以我们会向 MotionManager

1071
00:31:13,756 --> 00:31:14,986
请求最新的 DeviceMotion

1072
00:31:14,986 --> 00:31:18,016
样本 不考虑

1073
00:31:18,016 --> 00:31:22,096
重力性能 来计算出

1074
00:31:22,096 --> 00:31:23,546
矢量和 X-Z 轴的分量 

1075
00:31:23,976 --> 00:31:28,446
以达到倾斜 也就是

1076
00:31:28,446 --> 00:31:30,246
X—Z 轴分量和

1077
00:31:30,246 --> 00:31:31,056
Y 轴分量的反正切函数

1078
00:31:31,546 --> 00:31:34,686
不要忘记

1079
00:31:34,686 --> 00:31:36,176
让框架知道你和

1080
00:31:36,176 --> 00:31:37,076
DeviceMotion 更新不再相关了

1081
00:31:37,076 --> 00:31:39,106
不再相关了

1082
00:31:39,106 --> 00:31:40,186
如果它之前是有效的话

1083
00:31:41,266 --> 00:31:42,556
这一点很棒

1084
00:31:42,556 --> 00:31:44,166
当你的游戏暂停或结束时

1085
00:31:45,126 --> 00:31:46,786
它可以确保你没有浪费

1086
00:31:46,786 --> 00:31:47,856
多余的电量

1087
00:31:48,846 --> 00:31:50,246
这里你可以看到一个结果

1088
00:31:50,866 --> 00:31:52,426
用户可以

1089
00:31:52,426 --> 00:31:54,766
通过将设备倾斜到一边

1090
00:31:54,766 --> 00:31:57,326
来使獾也以同样的方式倾斜

1091
00:31:57,326 --> 00:32:00,036
向他们的方向倾斜

1092
00:31:57,326 --> 00:32:00,036
向他们的方向倾斜

1093
00:32:00,036 --> 00:32:01,436
设备可以让

1094
00:32:01,436 --> 00:32:05,936
獾跳起来 最后

1095
00:32:05,936 --> 00:32:07,086
向下轻推设备

1096
00:32:07,086 --> 00:32:08,446
可以使獾

1097
00:32:08,446 --> 00:32:10,026
下蹲并躲在手推车里

1098
00:32:10,496 --> 00:32:13,546
这很酷 我们已经

1099
00:32:13,606 --> 00:32:15,576
通过滑动控制和使用

1100
00:32:15,576 --> 00:32:17,926
DeviceMotion 来取代

1101
00:32:17,926 --> 00:32:18,856
原本基于动态的控制

1102
00:32:27,386 --> 00:32:29,126
我很激动地想要看到

1103
00:32:29,126 --> 00:32:30,636
你们能将 DeviceMotion API 应用成什么样

1104
00:32:35,516 --> 00:32:44,576
[鼓掌]

1105
00:32:45,076 --> 00:32:46,196
所以来总结一下

1106
00:32:46,196 --> 00:32:47,246
我们今天讨论的几个关键点

1107
00:32:47,306 --> 00:32:50,276
我们希望你看一下

1108
00:32:50,276 --> 00:32:52,356
授权 API 

1109
00:32:52,356 --> 00:32:53,106
并且检查一下你 App 的

1110
00:32:53,106 --> 00:32:55,616
授权 来看一下你使用的 API

1111
00:32:55,616 --> 00:32:57,226
是否灵敏

1112
00:32:59,666 --> 00:33:00,986
你也许有

1113
00:32:59,666 --> 00:33:00,986
你也许有

1114
00:33:00,986 --> 00:33:02,926
直接使用传感数据的用例

1115
00:33:02,926 --> 00:33:05,166
我们还是希望你

1116
00:33:05,166 --> 00:33:07,626
看一下 DeviceMotion API

1117
00:33:08,016 --> 00:33:09,176
因为我们的传感器混合

1118
00:33:09,176 --> 00:33:10,916
参数可以处理

1119
00:33:10,916 --> 00:33:11,526
绝大多数案例

1120
00:33:11,936 --> 00:33:13,026
它可以排除那些

1121
00:33:13,026 --> 00:33:14,966
环境因素

1122
00:33:14,966 --> 00:33:17,126
因此你可以专注在

1123
00:33:17,126 --> 00:33:18,496
用户的动态控制上

1124
00:33:20,546 --> 00:33:23,346
API 为你提供了一个流畅

1125
00:33:23,346 --> 00:33:24,936
且连贯的体验 

1126
00:33:24,936 --> 00:33:26,826
在所有我们支持的设备上都是如此

1127
00:33:28,056 --> 00:33:29,806
我们本次发布还做了一些改进

1128
00:33:29,806 --> 00:33:31,566
来确保

1129
00:33:31,566 --> 00:33:33,136
当你询问更新时

1130
00:33:33,136 --> 00:33:33,896
可以通过一种

1131
00:33:33,896 --> 00:33:34,796
低能耗的方式

1132
00:33:34,796 --> 00:33:40,566
记住两种不同

1133
00:33:41,076 --> 00:33:43,466
询问更新的方式 

1134
00:33:43,466 --> 00:33:45,226
当你想要捕捉

1135
00:33:45,226 --> 00:33:46,846
很短时间内的一个姿势时使用“推”

1136
00:33:46,916 --> 00:33:49,786
当灵敏性很重要且你

1137
00:33:51,816 --> 00:33:52,756
想要知道设备的

1138
00:33:52,756 --> 00:33:57,436
当前状态时用“拉”

1139
00:33:58,116 --> 00:33:59,196
还有一些会议

1140
00:33:59,196 --> 00:34:00,356
我们觉得你们可能会

1141
00:33:59,196 --> 00:34:00,356
我们觉得你们可能会

1142
00:34:00,356 --> 00:34:01,196
感兴趣

1143
00:34:02,256 --> 00:34:04,436
请关注它们

1144
00:34:04,436 --> 00:34:05,366
如果你有兴趣

1145
00:34:05,366 --> 00:34:06,796
了解更多关于 Badger App 的内容

1146
00:34:06,796 --> 00:34:07,826
请查看去年的 SceneKit

1147
00:34:07,826 --> 00:34:08,246
会议

1148
00:34:09,676 --> 00:34:11,085
在这个链接中 

1149
00:34:11,085 --> 00:34:13,446
你可以获得样本

1150
00:34:13,446 --> 00:34:14,496
代码 以及其他有关 Core Motion

1151
00:34:14,496 --> 00:34:15,286
的文件

1152
00:34:15,815 --> 00:34:19,476
感谢大家今天的出席

1153
00:34:19,476 --> 00:34:20,596
祝大家度过一个美好的夜晚
