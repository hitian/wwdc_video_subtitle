1
00:00:17,618 --> 00:00:21,021
<c.magenta>（在集合和表视图中拖放）</c>

2
00:00:22,556 --> 00:00:23,624
<c.magenta>早上好</c>

3
00:00:23,991 --> 00:00:25,692
<c.magenta>欢迎来到“在集合</c>

4
00:00:25,759 --> 00:00:27,494
<c.magenta>和表视图中拖放”演讲</c>

5
00:00:28,095 --> 00:00:28,962
<c.magenta>我是泰勒·福克斯</c>

6
00:00:29,029 --> 00:00:31,665
<c.magenta>我的同事穆罕默德·吉斯莱维</c>

7
00:00:32,165 --> 00:00:34,268
<c.magenta>遗憾的是我们的另一个同事</c>

8
00:00:34,334 --> 00:00:36,236
<c.magenta>但他在紧急时刻得了急病</c>

9
00:00:36,436 --> 00:00:37,404
<c.magenta>就在本周早些时候</c>

10
00:00:37,471 --> 00:00:39,840
<c.magenta>他是一位很棒的战士</c>

11
00:00:39,907 --> 00:00:41,408
<c.magenta>他恢复得很快</c>

12
00:00:41,575 --> 00:00:43,377
<c.magenta>但很遗憾</c>

13
00:00:43,744 --> 00:00:45,946
<c.magenta>请我们大家给他一些掌声</c>

14
00:00:46,013 --> 00:00:47,548
<c.magenta>要讲的内容付出了很大的努力</c>

15
00:00:50,083 --> 00:00:52,819
<c.magenta>那么让我们谈谈</c>

16
00:00:52,886 --> 00:00:55,322
<c.magenta>在集合视图和表视图中拖放</c>

17
00:00:56,156 --> 00:00:57,925
<c.magenta>我们创建了一个很棒的小应用</c>

18
00:00:58,091 --> 00:00:59,860
<c.magenta>来展示你能</c>

19
00:00:59,927 --> 00:01:01,295
<c.magenta>在集合和表视图中</c>

20
00:00:59,927 --> 00:01:01,295
<c.magenta>在集合和表视图中</c>

21
00:01:01,361 --> 00:01:02,696
<c.magenta>进行拖放的几种方式</c>

22
00:01:03,230 --> 00:01:05,098
<c.magenta>这个应用是一个很棒的照片库</c>

23
00:01:05,165 --> 00:01:06,600
<c.magenta>所以我们有相册</c>

24
00:01:06,667 --> 00:01:07,668
<c.magenta>每个相册里都有照片</c>

25
00:01:07,768 --> 00:01:09,069
<c.magenta>你可以拖放照片</c>

26
00:01:09,136 --> 00:01:10,537
<c.magenta>从一个相册拖放到另一个相册</c>

27
00:01:10,838 --> 00:01:12,673
<c.magenta>你甚至还可以直接将它们放到</c>

28
00:01:12,739 --> 00:01:15,409
<c.magenta>每个相册的表视图中</c>

29
00:01:15,843 --> 00:01:17,444
<c.magenta>并且你可以重新给照片排序</c>

30
00:01:17,511 --> 00:01:19,446
<c.magenta>在实际的集合视图内</c>

31
00:01:20,080 --> 00:01:23,984
<c.magenta>我们要给大家展示</c>

32
00:01:24,084 --> 00:01:26,220
<c.magenta>来向集合和表视图中添加拖放</c>

33
00:01:26,286 --> 00:01:27,554
<c.magenta>到你的应用中</c>

34
00:01:28,922 --> 00:01:32,326
<c.magenta>现在你很可能观看了</c>

35
00:01:32,426 --> 00:01:34,561
<c.magenta>其中有一些</c>

36
00:01:34,628 --> 00:01:36,496
<c.magenta>这个API是在UIKit中</c>

37
00:01:37,297 --> 00:01:39,533
<c.magenta>那么我们有这个很棒的新拖动交互</c>

38
00:01:39,600 --> 00:01:41,602
<c.magenta>和释放交互API层</c>

39
00:01:41,869 --> 00:01:45,005
<c.magenta>在iOS 11中 我们对</c>

40
00:01:45,572 --> 00:01:48,041
<c.magenta>但今天 当然了</c>

41
00:01:48,108 --> 00:01:49,510
<c.magenta>和UITableView</c>

42
00:01:49,877 --> 00:01:51,845
<c.magenta>对于这些类</c>

43
00:01:51,912 --> 00:01:53,680
<c.magenta>我们有专用的较高等级的新API</c>

44
00:01:54,414 --> 00:01:55,516
<c.magenta>那么你可能在想</c>

45
00:01:56,016 --> 00:01:57,451
<c.magenta>我们为什么要给集合和表视图</c>

46
00:01:57,551 --> 00:01:59,253
<c.magenta>添加专用的新API呢？</c>

47
00:01:59,686 --> 00:02:00,621
<c.magenta>这是个好问题</c>

48
00:01:59,686 --> 00:02:00,621
<c.magenta>这是个好问题</c>

49
00:02:01,355 --> 00:02:03,924
<c.magenta>我们想要创建一些专用API</c>

50
00:02:04,124 --> 00:02:06,927
<c.magenta>主要用来处理单元格和索引路径</c>

51
00:02:06,994 --> 00:02:08,794
<c.magenta>我们都知道 集合和表视图</c>

52
00:02:08,862 --> 00:02:09,997
<c.magenta>是符合视图</c>

53
00:02:10,062 --> 00:02:12,299
<c.magenta>会创建大量的小单元格</c>

54
00:02:12,366 --> 00:02:13,467
<c.magenta>并在屏幕上显示出来</c>

55
00:02:14,234 --> 00:02:16,303
<c.magenta>我们意识到我们可以</c>

56
00:02:16,370 --> 00:02:19,039
<c.magenta>通过深度挖掘你所熟悉的</c>

57
00:02:19,106 --> 00:02:20,240
<c.magenta>本地调用和索引路径</c>

58
00:02:20,941 --> 00:02:22,676
<c.magenta>我们还想使</c>

59
00:02:22,743 --> 00:02:24,244
<c.magenta>在整个系统中通过集合和表视图</c>

60
00:02:24,311 --> 00:02:25,512
<c.magenta>创建流畅的动画和获得一致的行为</c>

61
00:02:25,579 --> 00:02:27,915
<c.magenta>变得非常简单</c>

62
00:02:29,049 --> 00:02:30,083
<c.magenta>我们还意识到</c>

63
00:02:30,150 --> 00:02:31,818
<c.magenta>关于用集合视图</c>

64
00:02:31,885 --> 00:02:33,220
<c.magenta>和表视图来处理异步数据加载</c>

65
00:02:33,287 --> 00:02:35,055
<c.magenta>并不是那么简单</c>

66
00:02:35,122 --> 00:02:36,623
<c.magenta>我们准备了一些很酷的新功能</c>

67
00:02:36,690 --> 00:02:38,959
<c.magenta>稍后我们会非常激动地</c>

68
00:02:39,927 --> 00:02:42,763
<c.magenta>最后我想对本次演讲做一个提纲</c>

69
00:02:42,829 --> 00:02:44,364
<c.magenta>我们要展示一些关于</c>

70
00:02:44,431 --> 00:02:46,433
<c.magenta>集合视图和表视图代码的示例</c>

71
00:02:46,834 --> 00:02:49,436
<c.magenta>但你应该知道对于这两个类</c>

72
00:02:49,503 --> 00:02:50,470
<c.magenta>我们有一个一致性API</c>

73
00:02:50,537 --> 00:02:51,772
<c.magenta>所以有时候我们会展示其中一个</c>

74
00:02:51,839 --> 00:02:53,140
<c.magenta>而你应该知道</c>

75
00:02:53,307 --> 00:02:55,342
<c.magenta>[听不清]一些小的不同点</c>

76
00:02:55,409 --> 00:02:56,944
<c.magenta>其它一切都一样</c>

77
00:02:57,010 --> 00:02:59,213
<c.magenta>如果有不同点 我们会指出来的</c>

78
00:02:59,713 --> 00:03:01,648
<c.magenta>好了 让我们看一下</c>

79
00:02:59,713 --> 00:03:01,648
<c.magenta>好了 让我们看一下</c>

80
00:03:02,115 --> 00:03:04,384
<c.magenta>我们要从基础知识开始讲</c>

81
00:03:04,484 --> 00:03:05,652
<c.magenta>如何</c>

82
00:03:05,719 --> 00:03:07,054
<c.magenta>快速获得拖放并运行它们？</c>

83
00:03:07,120 --> 00:03:08,422
<c.magenta>在集合和表视图中</c>

84
00:03:09,356 --> 00:03:12,092
<c.magenta>然后我们主要讲完美释放</c>

85
00:03:12,426 --> 00:03:14,061
<c.magenta>只需要做一点点努力</c>

86
00:03:14,194 --> 00:03:16,763
<c.magenta>你就可以</c>

87
00:03:16,830 --> 00:03:18,966
<c.magenta>看起来特别棒</c>

88
00:03:19,066 --> 00:03:21,235
<c.magenta>我们会给大家展示一些很酷的动画</c>

89
00:03:21,502 --> 00:03:22,636
<c.magenta>还有一大堆很棒的东西</c>

90
00:03:23,170 --> 00:03:25,405
<c.magenta>最后我们会谈谈如何修饰</c>

91
00:03:25,606 --> 00:03:28,308
<c.magenta>一些真的很棒的自定义和附加项</c>

92
00:03:28,375 --> 00:03:29,610
<c.magenta>你可以很好地利用</c>

93
00:03:29,776 --> 00:03:31,645
<c.magenta>从而获得很棒的用户体验</c>

94
00:03:32,412 --> 00:03:34,181
<c.magenta>让我们开始吧</c>

95
00:03:34,248 --> 00:03:35,816
<c.magenta>谈谈在你的集合和表视图中</c>

96
00:03:35,883 --> 00:03:36,950
<c.magenta>获得拖放效果</c>

97
00:03:37,017 --> 00:03:39,319
<c.magenta>的基本知识 穆罕默德</c>

98
00:03:45,125 --> 00:03:45,959
<c.magenta>谢谢 泰勒</c>

99
00:03:47,060 --> 00:03:49,029
<c.magenta>我们想使在你应用的</c>

100
00:03:49,096 --> 00:03:51,131
<c.magenta>集合和表视图中实现拖放</c>

101
00:03:51,198 --> 00:03:52,266
<c.magenta>变得尽可能简单</c>

102
00:03:52,966 --> 00:03:53,934
<c.magenta>为了达到这个目的</c>

103
00:03:54,001 --> 00:03:56,136
<c.magenta>我们引入了两个新委托</c>

104
00:03:56,203 --> 00:03:58,172
<c.magenta>可应用于集合和表视图</c>

105
00:03:59,039 --> 00:04:00,941
<c.magenta>第一个是dragDelegate</c>

106
00:03:59,039 --> 00:04:00,941
<c.magenta>第一个是dragDelegate</c>

107
00:04:01,408 --> 00:04:05,913
<c.magenta>有初始化和自定义拖动方法</c>

108
00:04:06,647 --> 00:04:08,582
<c.magenta>第二个是dropDelegate</c>

109
00:04:08,982 --> 00:04:11,518
<c.magenta>有完成拖动方法</c>

110
00:04:11,585 --> 00:04:13,420
<c.magenta>那么基本上是数据迁移</c>

111
00:04:13,787 --> 00:04:16,557
<c.magenta>自定义释放动画等等</c>

112
00:04:17,991 --> 00:04:20,928
<c.magenta>有一点很重要 这两个协议</c>

113
00:04:20,994 --> 00:04:22,596
<c.magenta>是完全独立的</c>

114
00:04:22,896 --> 00:04:24,698
<c.magenta>你可以使用其中一个</c>

115
00:04:24,998 --> 00:04:27,134
<c.magenta>如果你只想获得其中一种体验的话</c>

116
00:04:27,601 --> 00:04:29,903
<c.magenta>或者两个都用</c>

117
00:04:30,003 --> 00:04:31,505
<c.magenta>来获得拖和放效果</c>

118
00:04:32,005 --> 00:04:35,075
<c.magenta>两个都用还可以解锁额外的功能</c>

119
00:04:35,142 --> 00:04:38,111
<c.magenta>比如在集合或表视图内重新排序</c>

120
00:04:39,379 --> 00:04:41,648
<c.magenta>实施拖动效果非常简单和直接</c>

121
00:04:41,849 --> 00:04:43,717
<c.magenta>你要遵从dragDelegate</c>

122
00:04:44,651 --> 00:04:47,321
<c.magenta>并实施一个必需的方法</c>

123
00:04:49,189 --> 00:04:51,792
<c.magenta>当用户在你的集合视图外</c>

124
00:04:51,859 --> 00:04:54,328
<c.magenta>发起拖动时会调用</c>

125
00:04:54,394 --> 00:04:55,796
<c.magenta>用于在索引路径开启会话的元素</c>

126
00:04:55,863 --> 00:04:57,464
<c.magenta>就是当他们开始拖拽一个单元格时</c>

127
00:04:59,299 --> 00:05:01,034
<c.magenta>应用必须使用</c>

128
00:04:59,299 --> 00:05:01,034
<c.magenta>应用必须使用</c>

129
00:05:01,101 --> 00:05:04,137
<c.magenta>输入会话和索引路径</c>

130
00:05:04,938 --> 00:05:07,474
<c.magenta>来推算如何处理那个拖动</c>

131
00:05:08,442 --> 00:05:13,347
<c.magenta>返回UIDragItems的一个数组</c>

132
00:05:13,847 --> 00:05:16,049
<c.magenta>当返回一个空数组时</c>

133
00:05:16,116 --> 00:05:17,718
<c.magenta>拖动会被忽略</c>

134
00:05:20,387 --> 00:05:23,223
<c.magenta>你可能记得轻触其它元素</c>

135
00:05:23,290 --> 00:05:26,059
<c.magenta>或其它视图并将其添加到</c>

136
00:05:26,126 --> 00:05:27,094
<c.magenta>一个正在进行的拖动中</c>

137
00:05:27,160 --> 00:05:29,596
<c.magenta>是iOS上拖放功能的关键体验</c>

138
00:05:31,498 --> 00:05:32,699
<c.magenta>要在集合和表视图中</c>

139
00:05:32,766 --> 00:05:35,169
<c.magenta>采用这种行为是非常简单的</c>

140
00:05:36,203 --> 00:05:38,539
<c.magenta>在dragDelegate上有一个可选方法</c>

141
00:05:38,772 --> 00:05:42,476
<c.magenta>每当你在集合视图中</c>

142
00:05:42,543 --> 00:05:45,479
<c.magenta>当拖动会话已经启动之后</c>

143
00:05:46,480 --> 00:05:49,316
<c.magenta>在IndexPath点添加会话的元素</c>

144
00:05:49,383 --> 00:05:52,653
<c.magenta>可以让你有机会返回拖动元素</c>

145
00:05:52,920 --> 00:05:55,222
<c.magenta>以将其添加到</c>

146
00:05:56,557 --> 00:05:58,792
<c.magenta>从这个方法中返回一个空数组</c>

147
00:05:58,859 --> 00:06:00,594
<c.magenta>将以通常的方式处理这个轻触操作</c>

148
00:05:58,859 --> 00:06:00,594
<c.magenta>将以通常的方式处理这个轻触操作</c>

149
00:06:00,661 --> 00:06:03,964
<c.magenta>所以它也可以说是一个单元格选择</c>

150
00:06:08,001 --> 00:06:10,804
<c.magenta>接受释放行为同样也很简单</c>

151
00:06:10,904 --> 00:06:13,207
<c.magenta>与dragDelegate类似</c>

152
00:06:13,273 --> 00:06:15,976
<c.magenta>有一个必需的方法可以让你实现</c>

153
00:06:17,311 --> 00:06:19,213
<c.magenta>调用performDropWith协调器</c>

154
00:06:19,513 --> 00:06:22,516
<c.magenta>当用户在你的集合视图上</c>

155
00:06:22,583 --> 00:06:25,319
<c.magenta>抬起手指释放拖动元素时</c>

156
00:06:27,654 --> 00:06:29,256
<c.magenta>这个方法可以让你有机会</c>

157
00:06:29,323 --> 00:06:33,460
<c.magenta>使用释放协调器处理释放行为</c>

158
00:06:33,827 --> 00:06:34,895
<c.magenta>释放协调器</c>

159
00:06:34,962 --> 00:06:37,231
<c.magenta>给你提供了许多便捷的方法</c>

160
00:06:37,564 --> 00:06:40,801
<c.magenta>比如获取被释放元素</c>

161
00:06:40,868 --> 00:06:43,136
<c.magenta>以便你可以实施数据迁移</c>

162
00:06:44,438 --> 00:06:47,140
<c.magenta>它为你提供了一些非常棒</c>

163
00:06:47,207 --> 00:06:49,610
<c.magenta>可以让你</c>

164
00:06:51,712 --> 00:06:55,315
<c.magenta>最后它还为你提供了一些</c>

165
00:06:55,382 --> 00:06:59,253
<c.magenta>为你的释放行为</c>

166
00:07:01,688 --> 00:07:04,358
<c.magenta>那么现在我们谈的是</c>

167
00:07:04,424 --> 00:07:05,692
<c.magenta>在你的集合和表视图中</c>

168
00:07:05,759 --> 00:07:06,960
<c.magenta>让我们在演示中看一下</c>

169
00:07:17,104 --> 00:07:18,172
<c.magenta>一开始让我们看一个</c>

170
00:07:18,238 --> 00:07:20,407
<c.magenta>基本的图库应用</c>

171
00:07:20,474 --> 00:07:21,775
<c.magenta>使用了集合视图</c>

172
00:07:21,842 --> 00:07:23,443
<c.magenta>来显示照片的网格</c>

173
00:07:23,744 --> 00:07:24,845
<c.magenta>我要添加</c>

174
00:07:24,912 --> 00:07:27,447
<c.magenta>将图片从集合视图中拖出来</c>

175
00:07:27,514 --> 00:07:29,082
<c.magenta>以及通过从其它应用中释放图片</c>

176
00:07:29,149 --> 00:07:30,651
<c.magenta>从而把图片导入回集合视图中的功能</c>

177
00:07:32,052 --> 00:07:32,920
<c.magenta>那么 你可以看到</c>

178
00:07:33,020 --> 00:07:35,722
<c.magenta>我已经在IndexPath</c>

179
00:07:35,789 --> 00:07:37,291
<c.magenta>开启了itemsForBeginning会话的</c>

180
00:07:37,357 --> 00:07:38,325
<c.magenta>存根实施</c>

181
00:07:38,659 --> 00:07:40,394
<c.magenta>并且我现在要添加一些…</c>

182
00:07:41,929 --> 00:07:43,463
<c.magenta>…基本代码…</c>

183
00:07:44,364 --> 00:07:49,403
<c.magenta>…从我们的数据源</c>

184
00:07:50,003 --> 00:07:51,672
<c.magenta>然后拉动一个UI图片</c>

185
00:07:51,738 --> 00:07:54,808
<c.magenta>从这个照片中</c>

186
00:07:55,542 --> 00:07:58,612
<c.magenta>因为UI图片已经遵循</c>

187
00:07:59,146 --> 00:08:01,815
<c.magenta>我们可以直接用它</c>

188
00:07:59,146 --> 00:08:01,815
<c.magenta>我们可以直接用它</c>

189
00:08:02,516 --> 00:08:03,784
<c.magenta>对于你自己的模型对象</c>

190
00:08:03,851 --> 00:08:05,485
<c.magenta>若你正拖动其它元素而不是图片</c>

191
00:08:05,652 --> 00:08:07,487
<c.magenta>你必须得确保那些对象</c>

192
00:08:07,554 --> 00:08:08,856
<c.magenta>遵循NSItemProvider写法</c>

193
00:08:09,056 --> 00:08:11,024
<c.magenta>在本场演讲之后刚好有另一场</c>

194
00:08:12,326 --> 00:08:13,794
<c.magenta>我们有了NSItemProvider之后</c>

195
00:08:13,861 --> 00:08:16,096
<c.magenta>我们可以用它创建</c>

196
00:08:16,163 --> 00:08:18,632
<c.magenta>这将会返回系统并开启拖动行为</c>

197
00:08:19,333 --> 00:08:20,801
<c.magenta>那么我现在可以开启拖动元素了</c>

198
00:08:20,868 --> 00:08:22,536
<c.magenta>但我还想添加一个功能</c>

199
00:08:22,603 --> 00:08:24,805
<c.magenta>就是将元素</c>

200
00:08:24,872 --> 00:08:28,175
<c.magenta>所以我要添加…一个元素的实施</c>

201
00:08:28,242 --> 00:08:30,978
<c.magenta>用于添加到IndexPath point的会话</c>

202
00:08:31,445 --> 00:08:35,249
<c.magenta>我要做的与itemsForBeginning会话</c>

203
00:08:35,349 --> 00:08:38,217
<c.magenta>只是返回一堆拖动元素</c>

204
00:08:38,284 --> 00:08:41,688
<c.magenta>让我们快速建好 然后看看是什么效果</c>

205
00:08:48,829 --> 00:08:50,597
<c.magenta>那么我要拉出照片应用</c>

206
00:08:50,998 --> 00:08:53,867
<c.magenta>并把它钉到我的图库应用旁边</c>

207
00:08:54,968 --> 00:08:56,637
<c.magenta>你可以看到我现可将元素拖动到</c>

208
00:08:56,703 --> 00:08:57,838
<c.magenta>我的集合视图外部了</c>

209
00:08:57,905 --> 00:09:00,807
<c.magenta>并且如果我轻触其它这些单元格</c>

210
00:08:57,905 --> 00:09:00,807
<c.magenta>并且如果我轻触其它这些单元格</c>

211
00:09:00,974 --> 00:09:02,910
<c.magenta>它们就会聚合到</c>

212
00:09:02,976 --> 00:09:06,880
<c.magenta>然后我可以将它们放在照片中</c>

213
00:09:09,650 --> 00:09:11,518
<c.magenta>那么现在我们实现了拖动元素</c>

214
00:09:11,585 --> 00:09:13,854
<c.magenta>让我们看看添加…接受释放行为</c>

215
00:09:15,522 --> 00:09:16,590
<c.magenta>正如我们之前讨论的</c>

216
00:09:16,657 --> 00:09:18,759
<c.magenta>我们必须实施那个必需的方法</c>

217
00:09:18,825 --> 00:09:22,462
<c.magenta>在集合视图dropDelegate上</c>

218
00:09:23,897 --> 00:09:25,599
<c.magenta>在这里我们要利用</c>

219
00:09:25,666 --> 00:09:27,668
<c.magenta>协调器的便捷方法</c>

220
00:09:27,734 --> 00:09:29,503
<c.magenta>来获得一些关于释放行为的信息</c>

221
00:09:29,570 --> 00:09:30,938
<c.magenta>然后就真正实施它</c>

222
00:09:31,238 --> 00:09:32,706
<c.magenta>我们要做的第一件事就是</c>

223
00:09:32,773 --> 00:09:36,210
<c.magenta>向协调器请求destinationIndexPath</c>

224
00:09:36,944 --> 00:09:39,813
<c.magenta>这个IndexPath来自</c>

225
00:09:39,880 --> 00:09:42,349
<c.magenta>用户释放拖动元素的那个点</c>

226
00:09:42,950 --> 00:09:45,619
<c.magenta>因为那个点可以跨越空的集合视图</c>

227
00:09:45,686 --> 00:09:48,689
<c.magenta>或表视图的范围 它的值可能是无</c>

228
00:09:49,056 --> 00:09:50,757
<c.magenta>所以我们在这里要处理那种情况</c>

229
00:09:50,991 --> 00:09:53,861
<c.magenta>通过返回一个零零 并将其插入…</c>

230
00:09:53,961 --> 00:09:56,430
<c.magenta>将其插入集合视图的最开始</c>

231
00:09:58,899 --> 00:10:02,736
<c.magenta>接下来我们要利用一个便捷方法</c>

232
00:09:58,899 --> 00:10:02,736
<c.magenta>接下来我们要利用一个便捷方法</c>

233
00:10:02,803 --> 00:10:04,104
<c.magenta>在释放会话上</c>

234
00:10:04,371 --> 00:10:07,841
<c.magenta>以在UI图片情境中</c>

235
00:10:07,908 --> 00:10:09,076
<c.magenta>这是我们感兴趣的地方</c>

236
00:10:09,676 --> 00:10:12,145
<c.magenta>然后在加载对象的完成闭包中</c>

237
00:10:12,412 --> 00:10:14,681
<c.magenta>我们要…更新我们的集合视图</c>

238
00:10:14,748 --> 00:10:17,451
<c.magenta>就像我们通常要做的那样</c>

239
00:10:17,718 --> 00:10:19,419
<c.magenta>并进行一些数据源更新</c>

240
00:10:19,486 --> 00:10:23,123
<c.magenta>使用我们之前写的一个便捷方法</c>

241
00:10:23,624 --> 00:10:27,194
<c.magenta>我们要请求集合视图</c>

242
00:10:27,628 --> 00:10:29,263
<c.magenta>那么让我们来试试吧</c>

243
00:10:38,238 --> 00:10:39,506
<c.magenta>那么现在我要</c>

244
00:10:40,340 --> 00:10:42,242
<c.magenta>从照片应用中拾取一些照片</c>

245
00:10:42,910 --> 00:10:46,213
<c.magenta>并将其释放到我的集合视图中</c>

246
00:10:46,713 --> 00:10:48,415
<c.magenta>以接受释放行为</c>

247
00:10:49,983 --> 00:10:52,819
<c.magenta>那么这次我可以拾取一些元素</c>

248
00:10:52,953 --> 00:10:54,855
<c.magenta>从照片中</c>

249
00:10:55,756 --> 00:10:59,526
<c.magenta>返回到我的应用 然后放手</c>

250
00:11:03,664 --> 00:11:04,498
<c.magenta>谢谢</c>

251
00:11:06,934 --> 00:11:09,136
<c.magenta>那么现在我们已经明白了它的效果</c>

252
00:11:10,938 --> 00:11:12,472
<c.magenta>仅仅通过添加一些方法</c>

253
00:11:12,539 --> 00:11:13,607
<c.magenta>非常简单就能实现</c>

254
00:11:13,674 --> 00:11:15,609
<c.magenta>现在泰勒要跟你们谈谈</c>

255
00:11:16,009 --> 00:11:18,612
<c.magenta>我们如何创建一些很棒的释放动画</c>

256
00:11:24,785 --> 00:11:26,486
<c.magenta>谢谢穆罕默德 好了</c>

257
00:11:26,687 --> 00:11:28,922
<c.magenta>现在让我们把中心转到</c>

258
00:11:28,989 --> 00:11:31,024
<c.magenta>完善这些释放行为</c>

259
00:11:31,592 --> 00:11:32,526
<c.magenta>一开始我想谈一下</c>

260
00:11:33,060 --> 00:11:35,162
<c.magenta>一个叫作释放提案的东西</c>

261
00:11:35,829 --> 00:11:37,497
<c.magenta>那么如果你参加了前几天</c>

262
00:11:37,564 --> 00:11:40,367
<c.magenta>关于UIKit中其它可用的API的演讲</c>

263
00:11:40,434 --> 00:11:44,004
<c.magenta>但释放提案是与系统通讯</c>

264
00:11:44,204 --> 00:11:46,006
<c.magenta>你希望如何处理释放会话的方式</c>

265
00:11:46,073 --> 00:11:48,208
<c.magenta>在用户实际释放他们的触摸</c>

266
00:11:48,308 --> 00:11:49,176
<c.magenta>以实施释放行为之前</c>

267
00:11:49,710 --> 00:11:50,978
<c.magenta>系统会请求多次你</c>

268
00:11:51,044 --> 00:11:53,247
<c.magenta>创建并返回一个释放提案</c>

269
00:11:53,680 --> 00:11:54,982
<c.magenta>当用户</c>

270
00:11:55,048 --> 00:11:56,984
<c.magenta>从集合或表视图中拖动时</c>

271
00:11:57,651 --> 00:11:58,986
<c.magenta>现在集合和表视图</c>

272
00:11:59,052 --> 00:12:01,855
<c.magenta>每个都有UIDropProposal的子类</c>

273
00:11:59,052 --> 00:12:01,855
<c.magenta>每个都有UIDropProposal的子类</c>

274
00:12:02,422 --> 00:12:03,357
<c.magenta>因此 这意味着</c>

275
00:12:03,423 --> 00:12:04,992
<c.magenta>每个都有那个同样的属性</c>

276
00:12:05,058 --> 00:12:06,460
<c.magenta>这个属性来自</c>

277
00:12:06,527 --> 00:12:07,594
<c.magenta>这是一个操作</c>

278
00:12:08,128 --> 00:12:10,163
<c.magenta>所以这是一个像复制</c>

279
00:12:10,430 --> 00:12:12,466
<c.magenta>移动、取消或禁止一样的值</c>

280
00:12:12,900 --> 00:12:14,701
<c.magenta>通常表明你是否</c>

281
00:12:14,768 --> 00:12:17,137
<c.magenta>对这个特定的释放会话感兴趣</c>

282
00:12:17,337 --> 00:12:19,740
<c.magenta>以及你打算如何处理</c>

283
00:12:19,806 --> 00:12:21,241
<c.magenta>那个释放会话内的实际数据</c>

284
00:12:22,242 --> 00:12:25,145
<c.magenta>但集合和表视图释放提案</c>

285
00:12:25,245 --> 00:12:27,014
<c.magenta>他们还有一个附加值</c>

286
00:12:27,114 --> 00:12:28,715
<c.magenta>即释放意向</c>

287
00:12:29,383 --> 00:12:30,217
<c.magenta>这是什么？</c>

288
00:12:30,884 --> 00:12:32,486
<c.magenta>这是一些附加信息</c>

289
00:12:32,553 --> 00:12:35,155
<c.magenta>你的应用可以向集合</c>

290
00:12:35,522 --> 00:12:37,191
<c.magenta>这将会使集合或表视图</c>

291
00:12:37,257 --> 00:12:38,792
<c.magenta>更新它们的外观</c>

292
00:12:38,859 --> 00:12:40,260
<c.magenta>在释放会话期间</c>

293
00:12:40,360 --> 00:12:42,462
<c.magenta>以反映你打算要做的操作</c>

294
00:12:43,931 --> 00:12:45,766
<c.magenta>那么让我们看一些真实的值</c>

295
00:12:45,832 --> 00:12:48,035
<c.magenta>关于这个释放意图 以更好地理解它</c>

296
00:12:48,402 --> 00:12:50,170
<c.magenta>我们将从默认值开始看</c>

297
00:12:50,337 --> 00:12:52,639
<c.magenta>也就是释放意图未指定</c>

298
00:12:54,041 --> 00:12:55,342
<c.magenta>通过这个释放意图</c>

299
00:12:55,409 --> 00:12:58,712
<c.magenta>集合或表视图</c>

300
00:12:58,779 --> 00:12:59,813
<c.magenta>在释放会话期间</c>

301
00:13:00,080 --> 00:13:02,449
<c.magenta>你可以从这里看到 当用户拖动时</c>

302
00:13:02,716 --> 00:13:04,184
<c.magenta>只有一个小标记</c>

303
00:13:04,251 --> 00:13:06,587
<c.magenta>在拖动预览旁边 只是这样</c>

304
00:13:06,954 --> 00:13:08,355
<c.magenta>你可能会选择这种释放意图</c>

305
00:13:08,422 --> 00:13:09,890
<c.magenta>如果你还不知道 比如</c>

306
00:13:09,957 --> 00:13:11,291
<c.magenta>元素会在哪里结束</c>

307
00:13:11,358 --> 00:13:13,026
<c.magenta>当用户实际释放他们的手指</c>

308
00:13:13,093 --> 00:13:13,927
<c.magenta>来实施释放行为时</c>

309
00:13:14,394 --> 00:13:17,297
<c.magenta>或者也许拖动会话包含好几个元素</c>

310
00:13:17,497 --> 00:13:19,766
<c.magenta>它们的终点是不同的位置</c>

311
00:13:19,833 --> 00:13:21,068
<c.magenta>当实际的释放行为发生时</c>

312
00:13:22,035 --> 00:13:24,004
<c.magenta>那么这是第一个释放意图 未指定</c>

313
00:13:24,471 --> 00:13:25,906
<c.magenta>第二个释放意图是</c>

314
00:13:25,973 --> 00:13:28,041
<c.magenta>insertAtDestinationIndexPath</c>

315
00:13:28,809 --> 00:13:29,843
<c.magenta>通过这个释放意图</c>

316
00:13:29,943 --> 00:13:32,279
<c.magenta>意味着你视图插入一个新元素</c>

317
00:13:32,346 --> 00:13:34,147
<c.magenta>或新行到集合或表视图中</c>

318
00:13:34,281 --> 00:13:35,949
<c.magenta>在目标索引路径</c>

319
00:13:36,149 --> 00:13:37,184
<c.magenta>你可以看到</c>

320
00:13:37,317 --> 00:13:38,585
<c.magenta>集合和表视图将</c>

321
00:13:38,652 --> 00:13:40,787
<c.magenta>在这个位置打开一个缺口</c>

322
00:13:40,954 --> 00:13:42,623
<c.magenta>让用户了解这就是那个</c>

323
00:13:42,689 --> 00:13:44,057
<c.magenta>要接受他们释放行为的位置</c>

324
00:13:45,726 --> 00:13:46,894
<c.magenta>第三种释放意图是</c>

325
00:13:46,960 --> 00:13:49,396
<c.magenta>insertIntoDestinationIndexPath</c>

326
00:13:50,364 --> 00:13:52,866
<c.magenta>这是你用来</c>

327
00:13:52,933 --> 00:13:55,335
<c.magenta>当用户在单元格上拖动时</c>

328
00:13:55,569 --> 00:13:58,172
<c.magenta>代表某种元素的容器</c>

329
00:13:58,372 --> 00:14:00,807
<c.magenta>比如 这里我们有照片相册</c>

330
00:13:58,372 --> 00:14:00,807
<c.magenta>比如 这里我们有照片相册</c>

331
00:14:01,074 --> 00:14:03,777
<c.magenta>照片容器</c>

332
00:14:03,844 --> 00:14:04,878
<c.magenta>或一个列表单元格</c>

333
00:14:05,646 --> 00:14:07,281
<c.magenta>在这种情况下</c>

334
00:14:07,347 --> 00:14:09,783
<c.magenta>到那个容器内部</c>

335
00:14:10,250 --> 00:14:11,718
<c.magenta>那么表视图 比如说</c>

336
00:14:11,785 --> 00:14:14,388
<c.magenta>要高亮目标索引路径的行</c>

337
00:14:14,454 --> 00:14:15,923
<c.magenta>因此用户就知道那个释放行为</c>

338
00:14:15,989 --> 00:14:17,624
<c.magenta>将会被那行所接受</c>

339
00:14:19,426 --> 00:14:21,261
<c.magenta>现在还有另一个释放意图值</c>

340
00:14:21,328 --> 00:14:23,263
<c.magenta>是UITableView专用的</c>

341
00:14:23,630 --> 00:14:25,732
<c.magenta>即自动释放意图</c>

342
00:14:26,800 --> 00:14:28,135
<c.magenta>你可以用于</c>

343
00:14:28,202 --> 00:14:31,138
<c.magenta>替换insertIntoDestinationIndexPath</c>

344
00:14:31,638 --> 00:14:33,073
<c.magenta>这个释放意图意味着</c>

345
00:14:33,140 --> 00:14:36,476
<c.magenta>你可以释放到那个</c>

346
00:14:36,677 --> 00:14:37,711
<c.magenta>索引路径的现有容器行</c>

347
00:14:38,011 --> 00:14:40,247
<c.magenta>或你可以在向下移动容器行</c>

348
00:14:40,314 --> 00:14:42,583
<c.magenta>并在同一索引路径的表视图中</c>

349
00:14:42,649 --> 00:14:43,717
<c.magenta>插入一个新行</c>

350
00:14:44,117 --> 00:14:46,620
<c.magenta>表视图会自动告诉你</c>

351
00:14:46,687 --> 00:14:48,455
<c.magenta>当释放发生时 释放了哪个</c>

352
00:14:48,522 --> 00:14:51,291
<c.magenta>它会从insertAtDestinationIndexPath</c>

353
00:14:51,425 --> 00:14:53,794
<c.magenta>和insertIntoDestinationIndexPath中</c>

354
00:14:55,028 --> 00:14:56,597
<c.magenta>那么让我们来看个例子</c>

355
00:14:56,663 --> 00:14:58,665
<c.magenta>关于如何在代码中实现释放提案</c>

356
00:14:59,299 --> 00:15:01,635
<c.magenta>它是从实施这个可选方法开始的</c>

357
00:14:59,299 --> 00:15:01,635
<c.magenta>它是从实施这个可选方法开始的</c>

358
00:15:01,835 --> 00:15:04,271
<c.magenta>dropSessionDidUpdate</c>

359
00:15:05,072 --> 00:15:06,440
<c.magenta>这里的这个将会被调用</c>

360
00:15:06,874 --> 00:15:08,876
<c.magenta>无论何时当表视图或集合视图</c>

361
00:15:08,942 --> 00:15:11,078
<c.magenta>检测到有释放会话在上层移动时</c>

362
00:15:11,812 --> 00:15:12,746
<c.magenta>现在这个方法是可选的</c>

363
00:15:12,813 --> 00:15:14,715
<c.magenta>但我们强烈建议你实施它</c>

364
00:15:14,781 --> 00:15:16,850
<c.magenta>因为这是你提供释放提案的方式</c>

365
00:15:17,751 --> 00:15:19,820
<c.magenta>现在因为这个会被同时调用</c>

366
00:15:19,887 --> 00:15:22,189
<c.magenta>当集合或表视图</c>

367
00:15:22,256 --> 00:15:23,824
<c.magenta>以及当释放会话在上层移动时</c>

368
00:15:24,024 --> 00:15:25,392
<c.magenta>它将会被非常频繁地调用</c>

369
00:15:25,526 --> 00:15:27,294
<c.magenta>因此你的实施必须</c>

370
00:15:27,361 --> 00:15:28,962
<c.magenta>非常高效并快速返回</c>

371
00:15:29,162 --> 00:15:32,032
<c.magenta>以避免挂住主线程</c>

372
00:15:32,366 --> 00:15:33,967
<c.magenta>现在我想让你们注意一下</c>

373
00:15:34,034 --> 00:15:36,203
<c.magenta>这个destinationIndexPath</c>

374
00:15:36,436 --> 00:15:37,838
<c.magenta>这是我们的提案</c>

375
00:15:37,905 --> 00:15:41,175
<c.magenta>关于我们认为你会把任意元素</c>

376
00:15:41,241 --> 00:15:42,442
<c.magenta>插入到集合或表视图中的地方</c>

377
00:15:43,210 --> 00:15:45,078
<c.magenta>现在这个destinationIndexPath</c>

378
00:15:45,145 --> 00:15:46,780
<c.magenta>在某些情况下为零</c>

379
00:15:46,847 --> 00:15:47,681
<c.magenta>特别是</c>

380
00:15:47,848 --> 00:15:49,783
<c.magenta>当用户在没有单元格的</c>

381
00:15:49,850 --> 00:15:50,884
<c.magenta>集合或表视图的</c>

382
00:15:50,951 --> 00:15:52,219
<c.magenta>区域内拖动时</c>

383
00:15:53,187 --> 00:15:55,289
<c.magenta>还有一个很重要的点</c>

384
00:15:55,355 --> 00:15:57,191
<c.magenta>可能会让你犯错 所以一定要注意</c>

385
00:15:57,691 --> 00:15:59,226
<c.magenta>当用户在集合或表视图中</c>

386
00:15:59,293 --> 00:16:01,929
<c.magenta>现有部分的终点拖动时</c>

387
00:15:59,293 --> 00:16:01,929
<c.magenta>现有部分的终点拖动时</c>

388
00:16:02,362 --> 00:16:03,997
<c.magenta>这个索引路径可能会等于</c>

389
00:16:04,064 --> 00:16:06,667
<c.magenta>该部分元素的数量</c>

390
00:16:06,867 --> 00:16:10,537
<c.magenta>意思是它可能不会</c>

391
00:16:10,971 --> 00:16:13,941
<c.magenta>所以要小心一点</c>

392
00:16:14,641 --> 00:16:16,276
<c.magenta>那么让我们快速看一个例子</c>

393
00:16:16,343 --> 00:16:17,411
<c.magenta>关于如何实施这个</c>

394
00:16:17,611 --> 00:16:20,781
<c.magenta>在本例中</c>

395
00:16:20,948 --> 00:16:22,249
<c.magenta>在释放会话上的</c>

396
00:16:22,316 --> 00:16:24,585
<c.magenta>看看拖动是否从我们的应用中发起</c>

397
00:16:24,985 --> 00:16:25,919
<c.magenta>如果是从我们的应用中发起</c>

398
00:16:25,986 --> 00:16:27,621
<c.magenta>我们可以用一个移动释放操作</c>

399
00:16:27,688 --> 00:16:30,457
<c.magenta>否则我们会用一个复制释放操作</c>

400
00:16:30,924 --> 00:16:32,893
<c.magenta>这两种情况都会插入一个新元素</c>

401
00:16:32,960 --> 00:16:34,094
<c.magenta>到集合视图中 那么我们要使用</c>

402
00:16:34,161 --> 00:16:35,896
<c.magenta>insertAtDestinationIndexPath</c>

403
00:16:35,963 --> 00:16:36,797
<c.magenta>作为我们的意图</c>

404
00:16:38,065 --> 00:16:40,968
<c.magenta>好的 那么这就是释放提案</c>

405
00:16:41,101 --> 00:16:43,670
<c.magenta>当用户仍然在集合</c>

406
00:16:44,338 --> 00:16:46,507
<c.magenta>让我们换个话题 谈谈释放</c>

407
00:16:46,573 --> 00:16:48,475
<c.magenta>当用户实际释放触摸</c>

408
00:16:48,642 --> 00:16:49,910
<c.magenta>而你需实施释放时的情况</c>

409
00:16:51,211 --> 00:16:52,846
<c.magenta>要设置一些很棒的动画</c>

410
00:16:53,080 --> 00:16:54,414
<c.magenta>你可以使用释放协调器</c>

411
00:16:54,481 --> 00:16:56,683
<c.magenta>就是那个传进来通过协调器</c>

412
00:16:57,818 --> 00:16:59,353
<c.magenta>集合和表视图将提供</c>

413
00:16:59,419 --> 00:17:00,888
<c.magenta>一些基本动画 在默认情况下</c>

414
00:16:59,419 --> 00:17:00,888
<c.magenta>一些基本动画 在默认情况下</c>

415
00:17:00,954 --> 00:17:03,290
<c.magenta>如果你什么也不做的话</c>

416
00:17:03,524 --> 00:17:04,790
<c.magenta>你可以使用释放协调器</c>

417
00:17:04,858 --> 00:17:06,593
<c.magenta>来设置具体的动画</c>

418
00:17:06,792 --> 00:17:09,563
<c.magenta>给释放会话中的每一个元素</c>

419
00:17:10,497 --> 00:17:11,598
<c.magenta>让我们看一些方法</c>

420
00:17:11,665 --> 00:17:13,233
<c.magenta>我们给你们提供这些方法</c>

421
00:17:14,734 --> 00:17:17,738
<c.magenta>第一个方法是释放到一个元素或行</c>

422
00:17:18,438 --> 00:17:20,307
<c.magenta>这是一个释放动画</c>

423
00:17:20,374 --> 00:17:21,842
<c.magenta>你可以使用</c>

424
00:17:21,942 --> 00:17:23,743
<c.magenta>当意图为insert</c>

425
00:17:24,545 --> 00:17:25,579
<c.magenta>并且你可以使用这个</c>

426
00:17:25,646 --> 00:17:27,714
<c.magenta>当你已经实施了更新</c>

427
00:17:27,915 --> 00:17:30,817
<c.magenta>以在集合或表视图中</c>

428
00:17:31,552 --> 00:17:33,120
<c.magenta>那么让我们在代码中看一个例子</c>

429
00:17:33,187 --> 00:17:34,721
<c.magenta>看看该如何实施</c>

430
00:17:38,025 --> 00:17:39,826
<c.magenta>在performDropWith协调器内部</c>

431
00:17:39,960 --> 00:17:41,328
<c.magenta>我们要从收集</c>

432
00:17:41,395 --> 00:17:42,796
<c.magenta>我们需要的一些本地变量开始</c>

433
00:17:42,863 --> 00:17:45,265
<c.magenta>尤其是我们需要destinationIndexPath</c>

434
00:17:45,699 --> 00:17:48,302
<c.magenta>我们还要使用localObject属性</c>

435
00:17:48,402 --> 00:17:50,404
<c.magenta>在拖动元素上 以实现</c>

436
00:17:50,571 --> 00:17:52,272
<c.magenta>潜在的数据同步</c>

437
00:17:52,339 --> 00:17:53,574
<c.magenta>当拖动会话从你自己的应用中发起时</c>

438
00:17:53,640 --> 00:17:55,809
<c.magenta>你可以使用</c>

439
00:17:57,044 --> 00:17:59,179
<c.magenta>接下来 因为我们会立即拥有那个数据</c>

440
00:17:59,246 --> 00:18:00,914
<c.magenta>我们可以实施一个即时插入</c>

441
00:17:59,246 --> 00:18:00,914
<c.magenta>我们可以实施一个即时插入</c>

442
00:18:00,981 --> 00:18:02,382
<c.magenta>插入到集合视图中</c>

443
00:18:02,449 --> 00:18:03,617
<c.magenta>performBatchUpdates</c>

444
00:18:03,750 --> 00:18:04,685
<c.magenta>在内部 当然</c>

445
00:18:04,751 --> 00:18:07,020
<c.magenta>我们将对数据源实施常规更新</c>

446
00:18:07,087 --> 00:18:08,322
<c.magenta>合并那个新图片</c>

447
00:18:08,622 --> 00:18:10,490
<c.magenta>我们要在集合视图中插入一个元素</c>

448
00:18:10,891 --> 00:18:13,861
<c.magenta>现在 因为我们已经插入了那个单元格</c>

449
00:18:14,027 --> 00:18:15,696
<c.magenta>可以告诉释放协调器</c>

450
00:18:15,796 --> 00:18:19,766
<c.magenta>将元素释放到那个</c>

451
00:18:20,067 --> 00:18:22,035
<c.magenta>这将会设置</c>

452
00:18:22,102 --> 00:18:23,403
<c.magenta>就是当拖动预览转变到</c>

453
00:18:23,470 --> 00:18:25,072
<c.magenta>我们所插入的最终单元格时</c>

454
00:18:26,940 --> 00:18:29,343
<c.magenta>好了 下一个释放动画是</c>

455
00:18:29,409 --> 00:18:31,311
<c.magenta>释放到一个元素或行</c>

456
00:18:32,112 --> 00:18:33,747
<c.magenta>你可能会想想这通常是</c>

457
00:18:33,814 --> 00:18:36,650
<c.magenta>当意图为insert</c>

458
00:18:37,317 --> 00:18:38,852
<c.magenta>在本例中 我们要插入元素</c>

459
00:18:38,919 --> 00:18:40,854
<c.magenta>在容器单元格内</c>

460
00:18:41,421 --> 00:18:43,156
<c.magenta>那么这个元素要…</c>

461
00:18:43,223 --> 00:18:45,325
<c.magenta>我们想要那个动画是一种按比例缩减</c>

462
00:18:45,526 --> 00:18:46,527
<c.magenta>通过这个很棒的动画</c>

463
00:18:46,593 --> 00:18:48,495
<c.magenta>就在那个单元格的某个区域内</c>

464
00:18:48,562 --> 00:18:50,831
<c.magenta>来向用户展示释放到了哪里</c>

465
00:18:51,732 --> 00:18:52,566
<c.magenta>那么让我们来看一个例子</c>

466
00:18:52,633 --> 00:18:54,501
<c.magenta>关于如何在代码中设置这个</c>

467
00:18:55,636 --> 00:18:58,472
<c.magenta>我们返回到</c>

468
00:18:59,139 --> 00:19:01,441
<c.magenta>这里的代码</c>

469
00:18:59,139 --> 00:19:01,441
<c.magenta>这里的代码</c>

470
00:19:01,508 --> 00:19:02,976
<c.magenta>与你在之前的例子中看到的代码</c>

471
00:19:03,243 --> 00:19:04,111
<c.magenta>那么只需要收集</c>

472
00:19:04,344 --> 00:19:05,646
<c.magenta>我们的destinationIndexPath</c>

473
00:19:05,712 --> 00:19:08,248
<c.magenta>然后拖动会话中就会包含图片</c>

474
00:19:09,349 --> 00:19:10,417
<c.magenta>现有一个附加的核对</c>

475
00:19:10,484 --> 00:19:11,985
<c.magenta>我们想在这种情况下实施</c>

476
00:19:12,052 --> 00:19:13,020
<c.magenta>目的是确保</c>

477
00:19:13,086 --> 00:19:14,588
<c.magenta>destinationIndexPath</c>

478
00:19:14,655 --> 00:19:17,224
<c.magenta>响应我们表视图中的一行</c>

479
00:19:17,491 --> 00:19:20,093
<c.magenta>否则 我们不能在那个相册中</c>

480
00:19:20,761 --> 00:19:22,763
<c.magenta>如果它响应某一行</c>

481
00:19:22,829 --> 00:19:25,832
<c.magenta>在那个照片相册潜在的数据结构中</c>

482
00:19:26,867 --> 00:19:28,635
<c.magenta>然后我们就准备好设置动画了</c>

483
00:19:28,902 --> 00:19:29,870
<c.magenta>那么在本例中</c>

484
00:19:29,937 --> 00:19:32,105
<c.magenta>我们将获得那个指定行的单元格</c>

485
00:19:32,372 --> 00:19:34,341
<c.magenta>且要给那单元格中的</c>

486
00:19:34,408 --> 00:19:35,475
<c.magenta>从而得到图片视图</c>

487
00:19:35,776 --> 00:19:37,077
<c.magenta>然后我们调用协调器</c>

488
00:19:37,144 --> 00:19:40,013
<c.magenta>释放元素intoRowAt indexPath rect</c>

489
00:19:40,480 --> 00:19:41,315
<c.magenta>我们正在传递一个rect</c>

490
00:19:41,381 --> 00:19:43,283
<c.magenta>这是在单元格的协调空间内</c>

491
00:19:43,450 --> 00:19:45,819
<c.magenta>所以我们将那个</c>

492
00:19:45,886 --> 00:19:47,554
<c.magenta>单元格的协调空间</c>

493
00:19:48,989 --> 00:19:51,425
<c.magenta>那么简单地说</c>

494
00:19:51,491 --> 00:19:53,560
<c.magenta>释放到新插入的单元格</c>

495
00:19:54,228 --> 00:19:57,064
<c.magenta>释放到容器单元格内的rect</c>

496
00:19:57,798 --> 00:19:59,967
<c.magenta>还有第三个释放动画方法</c>

497
00:20:00,234 --> 00:20:01,735
<c.magenta>即释放到目标</c>

498
00:20:02,402 --> 00:20:05,138
<c.magenta>这是如何实施完全自定义动画的方法</c>

499
00:20:05,239 --> 00:20:07,074
<c.magenta>比如通过可选转换到</c>

500
00:20:07,174 --> 00:20:09,409
<c.magenta>你应用中的任意位置的动画</c>

501
00:20:09,776 --> 00:20:11,845
<c.magenta>那么也许你想给标签栏</c>

502
00:20:11,912 --> 00:20:13,447
<c.magenta>或栏按钮元素或类似的东西</c>

503
00:20:14,515 --> 00:20:16,316
<c.magenta>这些是三个基本的释放动画</c>

504
00:20:16,450 --> 00:20:18,652
<c.magenta>但我想返回</c>

505
00:20:18,785 --> 00:20:20,220
<c.magenta>到我们所讲的第一个</c>

506
00:20:20,521 --> 00:20:21,855
<c.magenta>并回顾一下</c>

507
00:20:21,922 --> 00:20:24,124
<c.magenta>释放到新插入的元素或行</c>

508
00:20:24,892 --> 00:20:25,759
<c.magenta>正如我们所讨论的</c>

509
00:20:25,826 --> 00:20:28,295
<c.magenta>你需要已经实施更新</c>

510
00:20:28,362 --> 00:20:29,363
<c.magenta>在集合或表视图上</c>

511
00:20:29,429 --> 00:20:32,065
<c.magenta>以在你使用这个方法之前</c>

512
00:20:32,599 --> 00:20:34,134
<c.magenta>但若数据还没加载出来会如何？</c>

513
00:20:36,803 --> 00:20:39,339
<c.magenta>如果你正在iOS的应用之间拖动</c>

514
00:20:39,940 --> 00:20:42,075
<c.magenta>我们总是会进行异步数据加载</c>

515
00:20:42,776 --> 00:20:45,312
<c.magenta>但这些动画需要被立即指定</c>

516
00:20:45,379 --> 00:20:48,782
<c.magenta>当你从performDropWith</c>

517
00:20:49,583 --> 00:20:51,018
<c.magenta>要解决那个问题</c>

518
00:20:51,084 --> 00:20:52,186
<c.magenta>可能意味着你必须做</c>

519
00:20:52,252 --> 00:20:53,720
<c.magenta>一些很困难的记账</c>

520
00:20:53,820 --> 00:20:55,956
<c.magenta>因为你得实施暂时插入</c>

521
00:20:56,023 --> 00:20:57,224
<c.magenta>在集合或表视图中</c>

522
00:20:57,357 --> 00:20:58,959
<c.magenta>只是为了设置这些动画</c>

523
00:20:59,126 --> 00:21:00,894
<c.magenta>当然了 这意味着更新你的数据源</c>

524
00:20:59,126 --> 00:21:00,894
<c.magenta>当然了 这意味着更新你的数据源</c>

525
00:21:00,961 --> 00:21:02,529
<c.magenta>用暂时模型对象</c>

526
00:21:02,796 --> 00:21:03,931
<c.magenta>这并没有那么容易</c>

527
00:21:04,364 --> 00:21:05,799
<c.magenta>记住这些异步加载</c>

528
00:21:05,866 --> 00:21:07,267
<c.magenta>进来时甚至可能会次序颠倒</c>

529
00:21:08,735 --> 00:21:10,270
<c.magenta>我们知道这是一个巨大的挑战</c>

530
00:21:10,470 --> 00:21:12,806
<c.magenta>并且我们要非常激动地告诉你们</c>

531
00:21:12,873 --> 00:21:15,342
<c.magenta>在iOS 11中的一个全新的技术</c>

532
00:21:15,475 --> 00:21:16,643
<c.magenta>是关于集合和表视图的</c>

533
00:21:16,710 --> 00:21:18,545
<c.magenta>是特别为解决这个问题设计的</c>

534
00:21:18,812 --> 00:21:20,848
<c.magenta>我要引进占位符</c>

535
00:21:25,586 --> 00:21:27,054
<c.magenta>好的 什么是占位符？</c>

536
00:21:27,321 --> 00:21:29,823
<c.magenta>那么从名字中就能猜到 这些是</c>

537
00:21:29,890 --> 00:21:31,925
<c.magenta>你插入到集合或表视图中的</c>

538
00:21:32,326 --> 00:21:33,760
<c.magenta>关键点是</c>

539
00:21:33,827 --> 00:21:36,196
<c.magenta>你可以推迟更新数据源</c>

540
00:21:36,263 --> 00:21:37,865
<c.magenta>直到数据完成加载</c>

541
00:21:38,065 --> 00:21:39,466
<c.magenta>当你插入占位符时</c>

542
00:21:40,200 --> 00:21:41,301
<c.magenta>那么对于占位符</c>

543
00:21:41,368 --> 00:21:42,970
<c.magenta>你可以使用你想使用的任意单元格</c>

544
00:21:43,303 --> 00:21:44,304
<c.magenta>你可以提供给我们</c>

545
00:21:44,371 --> 00:21:47,307
<c.magenta>我们会在后台执行难度很大的记账</c>

546
00:21:47,374 --> 00:21:48,942
<c.magenta>直到你的数据完成加载</c>

547
00:21:49,943 --> 00:21:51,778
<c.magenta>这样集合和表视图</c>

548
00:21:51,845 --> 00:21:53,146
<c.magenta>将永不会</c>

549
00:21:53,213 --> 00:21:56,116
<c.magenta>向你的委托或数据源请求占位符</c>

550
00:21:56,450 --> 00:21:58,619
<c.magenta>所以你的委托</c>

551
00:21:58,685 --> 00:21:59,853
<c.magenta>它们还会存在</c>

552
00:22:00,787 --> 00:22:02,789
<c.magenta>你可以插入任意多个占位符</c>

553
00:22:02,956 --> 00:22:04,858
<c.magenta>可以插入到集合或表视图的任意位置</c>

554
00:22:04,925 --> 00:22:07,327
<c.magenta>并且你甚至可以实施增量更新</c>

555
00:22:07,594 --> 00:22:10,764
<c.magenta>当存在占位符以在集合视图和表视图中</c>

556
00:22:10,831 --> 00:22:11,932
<c.magenta>插入新行或新元素</c>

557
00:22:11,999 --> 00:22:13,166
<c.magenta>或移动当前行或元素时</c>

558
00:22:13,400 --> 00:22:14,234
<c.magenta>类似这样的</c>

559
00:22:14,635 --> 00:22:16,870
<c.magenta>所以这个为用户提供很棒的体验</c>

560
00:22:16,937 --> 00:22:19,306
<c.magenta>当他们的数据在应用之间加载时</c>

561
00:22:19,373 --> 00:22:21,508
<c.magenta>因为你可以保持用户界面生动性</c>

562
00:22:21,575 --> 00:22:23,810
<c.magenta>和响应性 在这些数据迁移时</c>

563
00:22:24,378 --> 00:22:25,812
<c.magenta>那么如何创建占位符呢？</c>

564
00:22:26,346 --> 00:22:29,016
<c.magenta>嗯 当然了 你可以用释放协调器创建</c>

565
00:22:29,550 --> 00:22:31,685
<c.magenta>从而将其插入到占位符中</c>

566
00:22:31,818 --> 00:22:33,720
<c.magenta>让我们深入看一些代码</c>

567
00:22:34,655 --> 00:22:37,157
<c.magenta>那么我们返回到了performDropWith</c>

568
00:22:37,624 --> 00:22:39,359
<c.magenta>我们需要一个</c>

569
00:22:39,426 --> 00:22:41,061
<c.magenta>是我们要释放的目的地</c>

570
00:22:41,895 --> 00:22:43,964
<c.magenta>现在我们要用一种不同的方法来实现</c>

571
00:22:44,331 --> 00:22:46,400
<c.magenta>现在我们要单独为释放会话中的</c>

572
00:22:46,466 --> 00:22:48,202
<c.magenta>每个元素的上层进行迭代</c>

573
00:22:48,602 --> 00:22:51,371
<c.magenta>对于每一个元素</c>

574
00:22:51,805 --> 00:22:53,707
<c.magenta>所以我们调用协调器释放元素</c>

575
00:22:53,774 --> 00:22:56,844
<c.magenta>toPlaceholderInsertedAt</c>

576
00:22:57,845 --> 00:22:59,313
<c.magenta>这将插入一个占位符</c>

577
00:22:59,379 --> 00:23:00,714
<c.magenta>在destinationIndexPath</c>

578
00:22:59,379 --> 00:23:00,714
<c.magenta>在destinationIndexPath</c>

579
00:23:00,848 --> 00:23:01,982
<c.magenta>为这个具体的元素</c>

580
00:23:02,382 --> 00:23:04,017
<c.magenta>你将注意到我们忽略了使用标识符</c>

581
00:23:04,084 --> 00:23:05,986
<c.magenta>这是你已经</c>

582
00:23:06,053 --> 00:23:07,487
<c.magenta>在集合或表视图中注册的东西</c>

583
00:23:07,554 --> 00:23:08,722
<c.magenta>我们要用来</c>

584
00:23:08,789 --> 00:23:10,724
<c.magenta>为这个占位符取出一个单元格</c>

585
00:23:11,692 --> 00:23:12,926
<c.magenta>你还将注意到 当然了</c>

586
00:23:12,993 --> 00:23:14,328
<c.magenta>在最后有一个闭包</c>

587
00:23:14,628 --> 00:23:16,964
<c.magenta>有一个注释说</c>

588
00:23:17,364 --> 00:23:18,498
<c.magenta>嗯 你可以回顾一下</c>

589
00:23:18,899 --> 00:23:21,435
<c.magenta>集合和表视图 它们不会</c>

590
00:23:21,502 --> 00:23:23,570
<c.magenta>向你的委托或数据源请求占位符</c>

591
00:23:23,904 --> 00:23:25,305
<c.magenta>意思是你要</c>

592
00:23:25,372 --> 00:23:27,674
<c.magenta>为占位符在索引路径中</c>

593
00:23:27,975 --> 00:23:29,843
<c.magenta>执行调用 因此这个闭包</c>

594
00:23:30,177 --> 00:23:32,646
<c.magenta>会取代你通常进行的配置</c>

595
00:23:32,713 --> 00:23:35,182
<c.magenta>在索引路径行单元格</c>

596
00:23:35,249 --> 00:23:36,550
<c.magenta>或在索引路径元素单元格</c>

597
00:23:37,551 --> 00:23:38,952
<c.magenta>好的 还有一点</c>

598
00:23:39,486 --> 00:23:40,921
<c.magenta>一旦你插入了占位符</c>

599
00:23:41,655 --> 00:23:43,624
<c.magenta>它会给你返回一些东西</c>

600
00:23:43,924 --> 00:23:45,526
<c.magenta>就是这个placeholderContext</c>

601
00:23:46,026 --> 00:23:48,295
<c.magenta>这是什么？</c>

602
00:23:48,362 --> 00:23:50,297
<c.magenta>分别会为每个占位符</c>

603
00:23:50,731 --> 00:23:53,000
<c.magenta>并且这是如何指派</c>

604
00:23:53,066 --> 00:23:54,601
<c.magenta>占位符的插入的方法</c>

605
00:23:54,701 --> 00:23:57,571
<c.magenta>以为最终的单元格交换它</c>

606
00:23:58,138 --> 00:24:00,274
<c.magenta>或者 如果数据迁移失败</c>

607
00:23:58,138 --> 00:24:00,274
<c.magenta>或者 如果数据迁移失败</c>

608
00:24:00,541 --> 00:24:02,142
<c.magenta>或也许用户取消了数据迁移</c>

609
00:24:02,376 --> 00:24:03,877
<c.magenta>你可以使用placeholderContext</c>

610
00:24:03,944 --> 00:24:05,245
<c.magenta>来删除占位符</c>

611
00:24:05,312 --> 00:24:07,014
<c.magenta>因为不再需要它了</c>

612
00:24:08,315 --> 00:24:09,383
<c.magenta>那么让我们跳回我们的代码</c>

613
00:24:09,449 --> 00:24:11,251
<c.magenta>看看如何使用这个placeholderContext</c>

614
00:24:11,552 --> 00:24:13,086
<c.magenta>我们从我们离开的那儿拾取</c>

615
00:24:13,153 --> 00:24:14,454
<c.magenta>我们插入了占位符</c>

616
00:24:14,588 --> 00:24:16,190
<c.magenta>我们又得到了placeholderContext</c>

617
00:24:16,590 --> 00:24:18,992
<c.magenta>现在我们需要加载数据</c>

618
00:24:19,593 --> 00:24:20,761
<c.magenta>这是异步的</c>

619
00:24:20,827 --> 00:24:23,497
<c.magenta>所以我们使用</c>

620
00:24:24,064 --> 00:24:26,233
<c.magenta>当闭包完成处理器运行时</c>

621
00:24:26,466 --> 00:24:27,868
<c.magenta>那将会被一个背景队列调用</c>

622
00:24:27,935 --> 00:24:29,403
<c.magenta>所以我们要确保转换回</c>

623
00:24:29,469 --> 00:24:31,605
<c.magenta>主队列 在我们更新UI之前</c>

624
00:24:32,673 --> 00:24:33,707
<c.magenta>现在我们可以查看</c>

625
00:24:33,774 --> 00:24:35,576
<c.magenta>我们是否加载了任何数据？</c>

626
00:24:36,109 --> 00:24:38,745
<c.magenta>如果是 这个本地变量中应该有图片</c>

627
00:24:38,979 --> 00:24:40,647
<c.magenta>现在我们调用commitInsertion</c>

628
00:24:40,714 --> 00:24:42,049
<c.magenta>在placeholderContext上</c>

629
00:24:42,382 --> 00:24:44,885
<c.magenta>再一次 我们置换出占位符单元格</c>

630
00:24:44,952 --> 00:24:47,955
<c.magenta>并插入实际的单元格 就在这个位置</c>

631
00:24:48,822 --> 00:24:50,824
<c.magenta>现在你向commitInsertion</c>

632
00:24:51,158 --> 00:24:52,092
<c.magenta>在那个闭包内部</c>

633
00:24:52,159 --> 00:24:54,561
<c.magenta>你有责任更新你的数据源</c>

634
00:24:54,628 --> 00:24:57,598
<c.magenta>为这里的真实行合并新数据</c>

635
00:24:58,165 --> 00:24:59,700
<c.magenta>或集合视图中的元素</c>

636
00:25:00,801 --> 00:25:02,336
<c.magenta>现在还有另外一个重要的事</c>

637
00:25:02,536 --> 00:25:03,937
<c.magenta>请看那个索引路径</c>

638
00:25:04,004 --> 00:25:05,606
<c.magenta>就是在那个闭包内传递的那个</c>

639
00:25:05,672 --> 00:25:06,907
<c.magenta>insertionIndexPath</c>

640
00:25:07,574 --> 00:25:09,910
<c.magenta>你要谨慎地使用它</c>

641
00:25:09,977 --> 00:25:12,546
<c.magenta>而不是原始的destinationIndexPath</c>

642
00:25:12,646 --> 00:25:14,448
<c.magenta>即你最开始插入占位符的索引路径</c>

643
00:25:14,681 --> 00:25:15,582
<c.magenta>这是因为</c>

644
00:25:15,883 --> 00:25:17,618
<c.magenta>你插入占位符</c>

645
00:25:17,684 --> 00:25:19,019
<c.magenta>与数据完成加载之间的时间</c>

646
00:25:19,186 --> 00:25:21,421
<c.magenta>如果在集合或表视图中</c>

647
00:25:21,488 --> 00:25:22,856
<c.magenta>占位符可能会被移除</c>

648
00:25:23,290 --> 00:25:24,825
<c.magenta>所以你要使用这个索引路径</c>

649
00:25:24,892 --> 00:25:26,126
<c.magenta>我们提供给你的这个索引路经</c>

650
00:25:26,193 --> 00:25:27,761
<c.magenta>来告诉你最终位置</c>

651
00:25:27,828 --> 00:25:29,930
<c.magenta>当提交占位符插入时</c>

652
00:25:30,898 --> 00:25:31,865
<c.magenta>好的 另外一件事</c>

653
00:25:31,932 --> 00:25:33,667
<c.magenta>当然了 如果我们的数据迁移</c>

654
00:25:33,734 --> 00:25:35,135
<c.magenta>由于某些原因不起作用</c>

655
00:25:35,202 --> 00:25:36,737
<c.magenta>或也许被取消了</c>

656
00:25:36,803 --> 00:25:39,473
<c.magenta>我们只需要删除占位符即可</c>

657
00:25:40,474 --> 00:25:42,743
<c.magenta>关于占位符的一点注意事项</c>

658
00:25:42,976 --> 00:25:45,445
<c.magenta>避免调用reloadData很重要</c>

659
00:25:45,512 --> 00:25:46,580
<c.magenta>在集合或表视图上</c>

660
00:25:46,647 --> 00:25:47,814
<c.magenta>当你有占位符时</c>

661
00:25:47,915 --> 00:25:50,784
<c.magenta>相反</c>

662
00:25:51,418 --> 00:25:53,387
<c.magenta>如此你可以实施增强更新</c>

663
00:25:53,453 --> 00:25:54,821
<c.magenta>在集合或表视图上</c>

664
00:25:55,422 --> 00:25:57,457
<c.magenta>你要避免reloadData的原因是</c>

665
00:25:57,524 --> 00:25:59,459
<c.magenta>因为它会重设一切</c>

666
00:25:59,526 --> 00:26:00,494
<c.magenta>在集合或表视图中</c>

667
00:25:59,526 --> 00:26:00,494
<c.magenta>在集合或表视图中</c>

668
00:26:00,561 --> 00:26:01,395
<c.magenta>结果是</c>

669
00:26:01,461 --> 00:26:03,697
<c.magenta>它会剔除任何现有占位符</c>

670
00:26:03,764 --> 00:26:04,731
<c.magenta>你仍然拥有的</c>

671
00:26:05,399 --> 00:26:06,934
<c.magenta>如果你使用performBatchUpdates</c>

672
00:26:07,067 --> 00:26:09,970
<c.magenta>你将实施增强插入和删除</c>

673
00:26:10,070 --> 00:26:12,139
<c.magenta>我们可以保持那些占位符留下来</c>

674
00:26:12,239 --> 00:26:14,341
<c.magenta>当你实时更新你的集合视图时</c>

675
00:26:15,442 --> 00:26:18,178
<c.magenta>你可以使用</c>

676
00:26:18,245 --> 00:26:19,513
<c.magenta>在集合和表视图上</c>

677
00:26:19,580 --> 00:26:22,316
<c.magenta>如果你想查看是否还有占位符</c>

678
00:26:23,050 --> 00:26:24,885
<c.magenta>我想把舞台再交给穆罕默德</c>

679
00:26:24,952 --> 00:26:26,787
<c.magenta>让他来给大家做一个演示</c>

680
00:26:26,854 --> 00:26:29,056
<c.magenta>在实际情况中看看占位符的相关技术</c>

681
00:26:32,192 --> 00:26:33,026
<c.magenta>是的 我来了</c>

682
00:26:35,028 --> 00:26:36,430
<c.magenta>谢谢 泰勒 哇哦</c>

683
00:26:36,496 --> 00:26:38,165
<c.magenta>占位符听起来很神奇 不是吗？</c>

684
00:26:38,498 --> 00:26:40,400
<c.magenta>实际上我迫不及待地要把它们</c>

685
00:26:40,467 --> 00:26:42,603
<c.magenta>创建到我们的应用中</c>

686
00:26:43,337 --> 00:26:44,171
<c.magenta>让我们开始吧</c>

687
00:26:47,608 --> 00:26:49,276
<c.magenta>我们要做的第一件事</c>

688
00:26:49,343 --> 00:26:52,746
<c.magenta>是在释放委托上实施另一个可选方法</c>

689
00:26:53,146 --> 00:26:56,216
<c.magenta>用来表明集合视图</c>

690
00:26:56,283 --> 00:27:00,654
<c.magenta>就是那个我们要添加把所释放的元素</c>

691
00:26:56,283 --> 00:27:00,654
<c.magenta>就是那个我们要添加把所释放的元素</c>

692
00:27:00,921 --> 00:27:03,790
<c.magenta>让我们添加一个实施</c>

693
00:27:03,857 --> 00:27:05,993
<c.magenta>给dropSessionDidUpdate</c>

694
00:27:06,059 --> 00:27:07,661
<c.magenta>withDestinationIndexPath</c>

695
00:27:08,428 --> 00:27:11,532
<c.magenta>并且我们要开始返回一个</c>

696
00:27:11,598 --> 00:27:14,368
<c.magenta>释放操作为复制</c>

697
00:27:14,434 --> 00:27:17,838
<c.magenta>意图为insertAtDestinationIndexPath</c>

698
00:27:18,939 --> 00:27:20,874
<c.magenta>接下来 我们要返回到</c>

699
00:27:21,875 --> 00:27:23,443
<c.magenta>performDropWith协调器方法</c>

700
00:27:23,510 --> 00:27:26,146
<c.magenta>我们要移除我们现有的协调器代码</c>

701
00:27:26,413 --> 00:27:27,915
<c.magenta>因为我们要用不同的方式来实现</c>

702
00:27:28,549 --> 00:27:29,917
<c.magenta>我们要做的第一件事</c>

703
00:27:29,983 --> 00:27:32,786
<c.magenta>就是迭代协调器的释放元素</c>

704
00:27:32,886 --> 00:27:36,423
<c.magenta>我们要查看每个释放元素</c>

705
00:27:36,490 --> 00:27:38,158
<c.magenta>拖动元素、元素供应者</c>

706
00:27:38,225 --> 00:27:40,961
<c.magenta>是否可用于加载类图的对象</c>

707
00:27:41,395 --> 00:27:43,497
<c.magenta>如果可以</c>

708
00:27:43,964 --> 00:27:47,067
<c.magenta>首先我们请求协调器</c>

709
00:27:47,134 --> 00:27:51,505
<c.magenta>在destinationIndexPath</c>

710
00:27:52,206 --> 00:27:54,508
<c.magenta>然后我们给它传递</c>

711
00:27:54,575 --> 00:27:55,609
<c.magenta>占位符单元格</c>

712
00:27:55,676 --> 00:27:58,111
<c.magenta>我们之前向集合视图注册过的</c>

713
00:27:58,745 --> 00:28:00,714
<c.magenta>我们要依附于placeholderContext</c>

714
00:27:58,745 --> 00:28:00,714
<c.magenta>我们要依附于placeholderContext</c>

715
00:28:00,781 --> 00:28:01,615
<c.magenta>因为我们稍后需要它</c>

716
00:28:01,682 --> 00:28:03,650
<c.magenta>来更新集合视图</c>

717
00:28:05,719 --> 00:28:08,522
<c.magenta>接下来我们要触发数据加载</c>

718
00:28:08,589 --> 00:28:10,924
<c.magenta>通过在itemProvider</c>

719
00:28:11,959 --> 00:28:13,827
<c.magenta>和loadObject的完成处理器上</c>

720
00:28:13,994 --> 00:28:16,296
<c.magenta>我们要继续并处理释放</c>

721
00:28:17,264 --> 00:28:18,565
<c.magenta>请注意 我正在分派回</c>

722
00:28:18,632 --> 00:28:20,100
<c.magenta>这里的主队列</c>

723
00:28:20,334 --> 00:28:22,336
<c.magenta>因为loadObject的完成处理器</c>

724
00:28:22,402 --> 00:28:24,071
<c.magenta>被后台队列调用了</c>

725
00:28:24,137 --> 00:28:25,939
<c.magenta>并且我要更新我们的UI</c>

726
00:28:27,541 --> 00:28:29,209
<c.magenta>如果数据迁移成功</c>

727
00:28:29,510 --> 00:28:31,411
<c.magenta>我们将完成释放</c>

728
00:28:31,578 --> 00:28:34,248
<c.magenta>通过在placeholderContext上</c>

729
00:28:34,715 --> 00:28:37,651
<c.magenta>我们要传递一组数据源更新</c>

730
00:28:37,885 --> 00:28:40,854
<c.magenta>使用insertionIndexPath</c>

731
00:28:41,154 --> 00:28:44,758
<c.magenta>在我们的[--返回商店]中插入新图片</c>

732
00:28:46,827 --> 00:28:50,631
<c.magenta>如果由于某些原因数据迁移失败</c>

733
00:28:50,697 --> 00:28:52,099
<c.magenta>我们一定要清理一下</c>

734
00:28:52,165 --> 00:28:54,334
<c.magenta>按情境调用deletePlaceholder</c>

735
00:28:55,102 --> 00:28:56,537
<c.magenta>我们还应该做一件事</c>

736
00:28:56,603 --> 00:29:00,040
<c.magenta>就是禁用默认系统进程UI的</c>

737
00:28:56,603 --> 00:29:00,040
<c.magenta>就是禁用默认系统进程UI的</c>

738
00:29:00,107 --> 00:29:01,542
<c.magenta>持久运行数据迁移</c>

739
00:29:01,808 --> 00:29:04,077
<c.magenta>因为我们现在</c>

740
00:29:04,778 --> 00:29:06,580
<c.magenta>所以我们要继续并实现这个</c>

741
00:29:06,647 --> 00:29:10,817
<c.magenta>通过将释放会话的</c>

742
00:29:11,885 --> 00:29:13,687
<c.magenta>就是这样 让我们看看是什么样的</c>

743
00:29:13,954 --> 00:29:14,988
<c.magenta>在我们的设备上</c>

744
00:29:18,959 --> 00:29:21,995
<c.magenta>要获得我们刚实现的整个效果</c>

745
00:29:22,095 --> 00:29:24,198
<c.magenta>我要…我不把图片拖出来</c>

746
00:29:24,264 --> 00:29:26,033
<c.magenta>而是切换到另一个不同的应用中</c>

747
00:29:26,900 --> 00:29:28,302
<c.magenta>我把它命名为Slow Photos</c>

748
00:29:28,836 --> 00:29:32,239
<c.magenta>故意减慢数据迁移的速度</c>

749
00:29:33,273 --> 00:29:36,510
<c.magenta>我要在这里拾取一些图片</c>

750
00:29:36,577 --> 00:29:38,345
<c.magenta>然后返回到我的集合视图</c>

751
00:29:39,079 --> 00:29:40,447
<c.magenta>请注意你将在这里</c>

752
00:29:40,514 --> 00:29:42,783
<c.magenta>当我在集合视图上层悬浮时</c>

753
00:29:42,883 --> 00:29:44,685
<c.magenta>单元格开始移动并分离</c>

754
00:29:44,751 --> 00:29:46,220
<c.magenta>我们得到了这种很酷的…</c>

755
00:29:46,753 --> 00:29:49,723
<c.magenta>…像跳板一样的重新排序效果</c>

756
00:29:50,557 --> 00:29:53,060
<c.magenta>这是因为我们已经开始返回</c>

757
00:29:53,126 --> 00:29:56,463
<c.magenta>insertAtDestinationIndexPath意图</c>

758
00:29:57,798 --> 00:29:59,700
<c.magenta>如果松手释放元素…</c>

759
00:30:00,267 --> 00:30:01,602
<c.magenta>哦 我喜欢这个动画</c>

760
00:30:02,903 --> 00:30:05,739
<c.magenta>请注意 我们得到的一个东西</c>

761
00:30:05,806 --> 00:30:06,907
<c.magenta>是占位符单元格</c>

762
00:30:06,974 --> 00:30:08,842
<c.magenta>带有这个内联进程UI</c>

763
00:30:09,042 --> 00:30:11,612
<c.magenta>几秒钟后 当数据迁移完成时</c>

764
00:30:11,879 --> 00:30:13,714
<c.magenta>我们的单元格</c>

765
00:30:13,780 --> 00:30:16,250
<c.magenta>真实的单元格 就加载了真实的图片</c>

766
00:30:22,289 --> 00:30:23,824
<c.magenta>现在我要把舞台交还给泰勒</c>

767
00:30:23,891 --> 00:30:26,059
<c.magenta>他要给大家谈谈最后几点</c>

768
00:30:26,460 --> 00:30:27,561
<c.magenta>可以帮助你们</c>

769
00:30:27,628 --> 00:30:30,230
<c.magenta>使你们应用中的拖放体验</c>

770
00:30:34,301 --> 00:30:35,502
<c.magenta>好的 谢谢穆罕默德</c>

771
00:30:36,136 --> 00:30:38,272
<c.magenta>那么让我们快速看一下</c>

772
00:30:38,338 --> 00:30:41,108
<c.magenta>你可以采用的最后润色</c>

773
00:30:41,175 --> 00:30:42,709
<c.magenta>通过我们很棒的API</c>

774
00:30:43,110 --> 00:30:44,912
<c.magenta>第一个对你来说可能很有意思</c>

775
00:30:44,978 --> 00:30:46,413
<c.magenta>是支持重新排序</c>

776
00:30:47,347 --> 00:30:48,582
<c.magenta>那么现在 我们有拖放</c>

777
00:30:48,849 --> 00:30:51,451
<c.magenta>可能很明显</c>

778
00:30:51,518 --> 00:30:54,254
<c.magenta>你可以 当然了 可以那么做</c>

779
00:30:54,788 --> 00:30:56,857
<c.magenta>你先是实施dropDelegate方法</c>

780
00:30:56,924 --> 00:30:57,891
<c.magenta>dropSessionDidUpdate</c>

781
00:30:57,958 --> 00:30:59,426
<c.magenta>withDestinationIndexPath</c>

782
00:30:59,793 --> 00:31:00,727
<c.magenta>原因是 当然了</c>

783
00:30:59,793 --> 00:31:00,727
<c.magenta>原因是 当然了</c>

784
00:31:00,794 --> 00:31:03,230
<c.magenta>这是你向系统提供释放提案的方式</c>

785
00:31:03,530 --> 00:31:04,598
<c.magenta>并且 尤其是</c>

786
00:31:04,665 --> 00:31:06,233
<c.magenta>你需要一个非常具体的释放提案</c>

787
00:31:06,300 --> 00:31:07,968
<c.magenta>如果你想要重新排序的话</c>

788
00:31:08,035 --> 00:31:10,270
<c.magenta>也就是一个操作为移动</c>

789
00:31:10,537 --> 00:31:13,440
<c.magenta>且意图为insert</c>

790
00:31:13,807 --> 00:31:16,276
<c.magenta>那是给集合或表视图的一个信号</c>

791
00:31:16,376 --> 00:31:18,545
<c.magenta>表明你有兴趣支持重新排序</c>

792
00:31:18,645 --> 00:31:20,547
<c.magenta>当元素被拖动时</c>

793
00:31:20,614 --> 00:31:21,815
<c.magenta>从同一个源视图中</c>

794
00:31:22,950 --> 00:31:24,518
<c.magenta>现在这里的情况有点不一样</c>

795
00:31:24,585 --> 00:31:25,619
<c.magenta>对于表视图和集合视图</c>

796
00:31:25,686 --> 00:31:26,520
<c.magenta>我们先说表视图</c>

797
00:31:27,154 --> 00:31:28,989
<c.magenta>对于表视图…表视图</c>

798
00:31:29,056 --> 00:31:30,424
<c.magenta>早已经支持重新排序</c>

799
00:31:30,490 --> 00:31:31,491
<c.magenta>很长一段时间了</c>

800
00:31:31,658 --> 00:31:33,293
<c.magenta>并且你很熟悉这个非常…</c>

801
00:31:33,594 --> 00:31:36,096
<c.magenta>…长期存在的数据源方法</c>

802
00:31:36,463 --> 00:31:39,199
<c.magenta>表视图moveRowAt</c>

803
00:31:39,700 --> 00:31:41,401
<c.magenta>你可以继续实施这个</c>

804
00:31:41,468 --> 00:31:43,604
<c.magenta>如果你喜欢的话 来支持重新排序</c>

805
00:31:43,837 --> 00:31:45,706
<c.magenta>因为表视图将会调用这个</c>

806
00:31:45,772 --> 00:31:48,275
<c.magenta>而不是通过用协调器执行释放来调用</c>

807
00:31:48,408 --> 00:31:50,310
<c.magenta>如果你已经返回了那个魔幻释放提案</c>

808
00:31:50,377 --> 00:31:52,412
<c.magenta>并且会重新排序单一行</c>

809
00:31:52,913 --> 00:31:53,780
<c.magenta>这就变得很简单了</c>

810
00:31:53,847 --> 00:31:56,817
<c.magenta>因为你可以在iPhone上</c>

811
00:31:56,884 --> 00:31:59,486
<c.magenta>比如也许是你没有实现拖放的地方</c>

812
00:31:59,553 --> 00:32:01,522
<c.magenta>使用现有重新排序方式</c>

813
00:31:59,553 --> 00:32:01,522
<c.magenta>使用现有重新排序方式</c>

814
00:32:01,622 --> 00:32:03,390
<c.magenta>如果你在iPad上</c>

815
00:32:03,457 --> 00:32:05,325
<c.magenta>你可以采用这里的这个</c>

816
00:32:06,727 --> 00:32:08,562
<c.magenta>那么这就是表视图 非常简单直接</c>

817
00:32:08,829 --> 00:32:10,697
<c.magenta>但集合视图同样也很简单</c>

818
00:32:11,231 --> 00:32:13,400
<c.magenta>你只需要确认你</c>

819
00:32:13,467 --> 00:32:15,169
<c.magenta>既实施了拖动委托也实施了释放委托</c>

820
00:32:15,235 --> 00:32:16,069
<c.magenta>两个都有</c>

821
00:32:17,004 --> 00:32:19,406
<c.magenta>在performDropWith协调器内部</c>

822
00:32:21,341 --> 00:32:23,844
<c.magenta>你可以看一下释放元素</c>

823
00:32:23,911 --> 00:32:25,846
<c.magenta>就是我们在那个协调器内</c>

824
00:32:26,113 --> 00:32:28,515
<c.magenta>我们实际是在提供一个</c>

825
00:32:28,582 --> 00:32:30,784
<c.magenta>给每一个元素 其值将为非零</c>

826
00:32:30,951 --> 00:32:32,653
<c.magenta>如果元素代表</c>

827
00:32:32,920 --> 00:32:34,721
<c.magenta>它所来自的那个集合视图中的</c>

828
00:32:34,788 --> 00:32:35,689
<c.magenta>一个特定元素</c>

829
00:32:36,356 --> 00:32:37,758
<c.magenta>那么你可以删除</c>

830
00:32:37,824 --> 00:32:39,026
<c.magenta>那个sourceIndexPath的元素</c>

831
00:32:39,092 --> 00:32:40,961
<c.magenta>并在destinationIndexPath</c>

832
00:32:41,028 --> 00:32:42,663
<c.magenta>插入一个新元素</c>

833
00:32:43,263 --> 00:32:45,332
<c.magenta>这将会影响实际的重新排序</c>

834
00:32:45,465 --> 00:32:47,501
<c.magenta>那么你可以流畅地移动那个单元格</c>

835
00:32:47,568 --> 00:32:48,869
<c.magenta>从起点到目的地</c>

836
00:32:49,903 --> 00:32:52,472
<c.magenta>现在集合视图有一些额外的功能</c>

837
00:32:52,539 --> 00:32:53,507
<c.magenta>关于重新排序</c>

838
00:32:53,907 --> 00:32:56,610
<c.magenta>这就是重新排序的新概念</c>

839
00:32:58,111 --> 00:32:59,880
<c.magenta>如你所知 集合视图总是</c>

840
00:32:59,947 --> 00:33:01,782
<c.magenta>会有这些二维网格一样的布局</c>

841
00:32:59,947 --> 00:33:01,782
<c.magenta>会有这些二维网格一样的布局</c>

842
00:33:01,849 --> 00:33:03,717
<c.magenta>比如 你在我身后看到的流布局</c>

843
00:33:04,251 --> 00:33:05,886
<c.magenta>当你重新排序时</c>

844
00:33:06,019 --> 00:33:08,822
<c.magenta>有时你可以得到那种行为</c>

845
00:33:08,889 --> 00:33:10,424
<c.magenta>就是元素又回流了</c>

846
00:33:10,490 --> 00:33:11,758
<c.magenta>当你移动手指时</c>

847
00:33:11,959 --> 00:33:12,893
<c.magenta>这很棒 当你在</c>

848
00:33:12,960 --> 00:33:13,827
<c.magenta>尝试重新排序时</c>

849
00:33:13,994 --> 00:33:15,796
<c.magenta>但你并不总是希望得到那种行为</c>

850
00:33:15,863 --> 00:33:18,031
<c.magenta>也许如果你正在尝试</c>

851
00:33:18,098 --> 00:33:19,366
<c.magenta>在集合视图外部</c>

852
00:33:19,566 --> 00:33:20,834
<c.magenta>并且它恰巧支持重新排序</c>

853
00:33:21,368 --> 00:33:22,269
<c.magenta>所以重新排序</c>

854
00:33:22,336 --> 00:33:23,270
<c.magenta>有三个不同的值</c>

855
00:33:23,337 --> 00:33:26,306
<c.magenta>帮助你调节集合视图的响应性</c>

856
00:33:26,540 --> 00:33:28,509
<c.magenta>当它打乱顺序并回流其布局时</c>

857
00:33:28,742 --> 00:33:29,810
<c.magenta>那么默认情况 当然了</c>

858
00:33:29,877 --> 00:33:32,546
<c.magenta>是立即</c>

859
00:33:32,613 --> 00:33:33,981
<c.magenta>一旦你开始移动</c>

860
00:33:34,047 --> 00:33:36,416
<c.magenta>它会立即回流集合视图布局</c>

861
00:33:36,650 --> 00:33:38,986
<c.magenta>你知道的</c>

862
00:33:39,386 --> 00:33:42,289
<c.magenta>如果你想在这里添加更多的释放</c>

863
00:33:42,356 --> 00:33:44,825
<c.magenta>你可以切换到快速模式</c>

864
00:33:45,492 --> 00:33:47,461
<c.magenta>如果你非常快地移动</c>

865
00:33:47,528 --> 00:33:49,396
<c.magenta>它将不会立即重新安排</c>

866
00:33:49,463 --> 00:33:50,597
<c.magenta>整个布局</c>

867
00:33:51,031 --> 00:33:52,332
<c.magenta>所以你可以看到 你得暂停</c>

868
00:33:52,399 --> 00:33:53,467
<c.magenta>时间长一点儿</c>

869
00:33:53,734 --> 00:33:55,502
<c.magenta>然后对于减慢</c>

870
00:33:55,736 --> 00:33:57,171
<c.magenta>它更加夸大了那个效果</c>

871
00:33:57,237 --> 00:33:58,238
<c.magenta>那么用户实际上得</c>

872
00:33:58,305 --> 00:33:59,706
<c.magenta>仔细考虑要停止</c>

873
00:33:59,773 --> 00:34:01,408
<c.magenta>和重新排序的具体位置</c>

874
00:33:59,773 --> 00:34:01,408
<c.magenta>和重新排序的具体位置</c>

875
00:34:01,575 --> 00:34:02,876
<c.magenta>这是如何获得</c>

876
00:34:02,943 --> 00:34:04,912
<c.magenta>与你在iOS主屏幕上看到的行为</c>

877
00:34:04,978 --> 00:34:06,046
<c.magenta>非常一致的行为方式</c>

878
00:34:06,113 --> 00:34:07,915
<c.magenta>当重新排序应用图标时 比如说</c>

879
00:34:09,016 --> 00:34:11,385
<c.magenta>那么这就是重新排序</c>

880
00:34:11,952 --> 00:34:13,853
<c.magenta>弹簧加载 你现在很可能了解这个了</c>

881
00:34:13,920 --> 00:34:16,723
<c.magenta>是一种导航和激活控件的方式</c>

882
00:34:16,790 --> 00:34:18,257
<c.magenta>在整个系统中 当你处于</c>

883
00:34:18,324 --> 00:34:19,159
<c.magenta>拖动会话中时</c>

884
00:34:19,226 --> 00:34:20,761
<c.magenta>你只要悬浮在控件上层</c>

885
00:34:20,827 --> 00:34:23,197
<c.magenta>它就开始高亮 然后就会激活</c>

886
00:34:23,630 --> 00:34:24,965
<c.magenta>那么在集合和表视图中</c>

887
00:34:25,032 --> 00:34:26,166
<c.magenta>很容易释放</c>

888
00:34:26,233 --> 00:34:29,069
<c.magenta>来采用弹簧加载</c>

889
00:34:29,870 --> 00:34:31,972
<c.magenta>遵从协议UISpringLoaded</c>

890
00:34:32,039 --> 00:34:33,139
<c.magenta>InteractionSupporting</c>

891
00:34:33,507 --> 00:34:34,440
<c.magenta>基本意思是</c>

892
00:34:34,507 --> 00:34:36,476
<c.magenta>它们每一个</c>

893
00:34:36,643 --> 00:34:39,079
<c.magenta>你将其设为真 然后弹性加载就能用了</c>

894
00:34:39,646 --> 00:34:41,949
<c.magenta>当用户在某个单元格弹性加载时</c>

895
00:34:42,014 --> 00:34:43,350
<c.magenta>我们要调用…我们要选择</c>

896
00:34:43,449 --> 00:34:45,518
<c.magenta>那个集合或表视图中的那个元素或行</c>

897
00:34:46,152 --> 00:34:47,554
<c.magenta>并且你可以自定义弹性加载</c>

898
00:34:47,621 --> 00:34:50,456
<c.magenta>根据情境使用一个</c>

899
00:34:50,524 --> 00:34:51,725
<c.magenta>IndexPath</c>

900
00:34:51,859 --> 00:34:53,126
<c.magenta>这是如何退出</c>

901
00:34:53,193 --> 00:34:54,728
<c.magenta>弹性加载具体行的方式</c>

902
00:34:54,962 --> 00:34:58,065
<c.magenta>或你甚至可以稍微</c>

903
00:34:58,232 --> 00:34:59,066
<c.magenta>通过那个情境</c>

904
00:34:59,132 --> 00:35:00,801
<c.magenta>比如 你可以变更视图</c>

905
00:34:59,132 --> 00:35:00,801
<c.magenta>比如 你可以变更视图</c>

906
00:35:00,868 --> 00:35:03,203
<c.magenta>在弹性加载交互中起作用的那个视图</c>

907
00:35:05,405 --> 00:35:08,542
<c.magenta>那么接下来</c>

908
00:35:09,343 --> 00:35:10,477
<c.magenta>我们有一些新方式</c>

909
00:35:10,544 --> 00:35:12,446
<c.magenta>你可以自定义单元格的外观</c>

910
00:35:12,513 --> 00:35:14,648
<c.magenta>参与到拖动会话中的</c>

911
00:35:15,315 --> 00:35:18,218
<c.magenta>那么单元格开始…</c>

912
00:35:18,285 --> 00:35:20,254
<c.magenta>并且它们都在无状态下开始</c>

913
00:35:20,554 --> 00:35:22,122
<c.magenta>也就是在发生任何事之前</c>

914
00:35:22,289 --> 00:35:24,157
<c.magenta>但当用户将手指放在屏幕上</c>

915
00:35:24,224 --> 00:35:25,826
<c.magenta>并开始拾取其中一个单元格时</c>

916
00:35:26,026 --> 00:35:28,161
<c.magenta>我们要将单元格转换到拾取状态</c>

917
00:35:28,395 --> 00:35:30,430
<c.magenta>并且你可以在这个示例中看到</c>

918
00:35:30,497 --> 00:35:32,599
<c.magenta>我们有一个小横幅</c>

919
00:35:32,666 --> 00:35:34,601
<c.magenta>我们实际上不想显示那个横幅</c>

920
00:35:34,668 --> 00:35:36,203
<c.magenta>当用户</c>

921
00:35:36,270 --> 00:35:37,671
<c.magenta>在整个系统中拖放单元格时</c>

922
00:35:37,871 --> 00:35:40,073
<c.magenta>所以我们将这种状态转换</c>

923
00:35:40,274 --> 00:35:41,275
<c.magenta>到拾取状态</c>

924
00:35:41,441 --> 00:35:43,210
<c.magenta>来隐藏那个横幅</c>

925
00:35:44,378 --> 00:35:46,180
<c.magenta>当用户移动手指</c>

926
00:35:46,246 --> 00:35:47,948
<c.magenta>开始拖动会话时</c>

927
00:35:48,115 --> 00:35:49,816
<c.magenta>一旦单元格完成拾取</c>

928
00:35:50,117 --> 00:35:51,318
<c.magenta>我们将把</c>

929
00:35:51,385 --> 00:35:53,620
<c.magenta>集合或表视图中处于后台的单元格</c>

930
00:35:53,687 --> 00:35:54,821
<c.magenta>转换为拖动状态</c>

931
00:35:55,189 --> 00:35:58,358
<c.magenta>默认情况为这将导致一种褪色的外观</c>

932
00:35:58,425 --> 00:36:00,627
<c.magenta>我们将缩小那个单元格的阿尔法</c>

933
00:35:58,425 --> 00:36:00,627
<c.magenta>我们将缩小那个单元格的阿尔法</c>

934
00:36:02,029 --> 00:36:04,298
<c.magenta>现在你可以响应这些状态转换了</c>

935
00:36:04,364 --> 00:36:06,900
<c.magenta>通过覆盖你单元格类上的方法</c>

936
00:36:07,034 --> 00:36:09,469
<c.magenta>子类 dragStateDidChange</c>

937
00:36:09,837 --> 00:36:11,538
<c.magenta>仅适用被传进来的新状态</c>

938
00:36:11,605 --> 00:36:13,140
<c.magenta>你可以选择调用super</c>

939
00:36:13,207 --> 00:36:15,075
<c.magenta>来获取默认外观和行为</c>

940
00:36:15,242 --> 00:36:17,377
<c.magenta>或者你只选择覆盖它并提供</c>

941
00:36:17,444 --> 00:36:18,912
<c.magenta>你自己的行为和实施</c>

942
00:36:19,246 --> 00:36:22,049
<c.magenta>我们甚至要确保调用这些状态转换</c>

943
00:36:22,115 --> 00:36:23,984
<c.magenta>在动画闭包内和旁边</c>

944
00:36:24,351 --> 00:36:26,220
<c.magenta>拥有实际拾取动画的动画闭包</c>

945
00:36:26,286 --> 00:36:28,822
<c.magenta>所以如果你在这里进行了修改</c>

946
00:36:28,889 --> 00:36:31,058
<c.magenta>前台和后台运行</c>

947
00:36:32,059 --> 00:36:33,994
<c.magenta>那么这是如何自定义单元格</c>

948
00:36:34,061 --> 00:36:36,463
<c.magenta>在集合或表视图中的</c>

949
00:36:36,730 --> 00:36:37,965
<c.magenta>但关于拖动预览</c>

950
00:36:38,031 --> 00:36:39,132
<c.magenta>怎么样呢？</c>

951
00:36:39,533 --> 00:36:40,634
<c.magenta>你可以从这里看到</c>

952
00:36:40,734 --> 00:36:43,303
<c.magenta>在本例中 我们有一个单元格</c>

953
00:36:43,370 --> 00:36:45,205
<c.magenta>基本上是一个方形的</c>

954
00:36:45,372 --> 00:36:47,074
<c.magenta>但如果可见的内容</c>

955
00:36:47,207 --> 00:36:48,742
<c.magenta>纵横比较宽</c>

956
00:36:49,109 --> 00:36:50,410
<c.magenta>它显示一个很不错的图片</c>

957
00:36:50,477 --> 00:36:51,945
<c.magenta>我们的结果会是</c>

958
00:36:52,579 --> 00:36:55,115
<c.magenta>…不是很白的栏</c>

959
00:36:55,215 --> 00:36:56,583
<c.magenta>很可能并不真想要这个外观</c>

960
00:36:56,650 --> 00:36:59,186
<c.magenta>当用户正在拖动这个时</c>

961
00:36:59,386 --> 00:37:00,420
<c.magenta>那么该如何修复呢？</c>

962
00:36:59,386 --> 00:37:00,420
<c.magenta>那么该如何修复呢？</c>

963
00:37:00,988 --> 00:37:03,290
<c.magenta>嗯 默认情况是会发生</c>

964
00:37:03,357 --> 00:37:04,858
<c.magenta>因为我们使用整个单元格</c>

965
00:37:04,925 --> 00:37:05,959
<c.magenta>作为拖动预览</c>

966
00:37:06,426 --> 00:37:07,794
<c.magenta>但是当然了 你可以变更</c>

967
00:37:08,228 --> 00:37:10,597
<c.magenta>这样你可以提供拖动预览参数</c>

968
00:37:10,664 --> 00:37:12,099
<c.magenta>通过实施可选方法</c>

969
00:37:12,165 --> 00:37:13,100
<c.magenta>在dragDelegate上</c>

970
00:37:13,500 --> 00:37:15,469
<c.magenta>dragPreviewParametersForItemAt</c>

971
00:37:15,936 --> 00:37:17,070
<c.magenta>并且如果你提供这些</c>

972
00:37:17,237 --> 00:37:20,073
<c.magenta>比如说你就有机会提供贝塞尔路径</c>

973
00:37:20,274 --> 00:37:22,809
<c.magenta>那将在单元格的一个具体区域进行剪裁</c>

974
00:37:23,043 --> 00:37:25,012
<c.magenta>所以如果我们回去看我们的例子</c>

975
00:37:25,179 --> 00:37:26,480
<c.magenta>若我们返回一个贝塞尔路径</c>

976
00:37:26,547 --> 00:37:28,115
<c.magenta>剪裁实际的rect</c>

977
00:37:28,215 --> 00:37:29,750
<c.magenta>那儿有一个可见的照片</c>

978
00:37:29,816 --> 00:37:32,252
<c.magenta>我们可以只把那个照片拾取到屏幕外</c>

979
00:37:32,319 --> 00:37:34,922
<c.magenta>在本例中即便单元格仍然是个方形</c>

980
00:37:38,692 --> 00:37:40,861
<c.magenta>好的 哇哦 我们今天讲了很多内容</c>

981
00:37:41,061 --> 00:37:42,563
<c.magenta>那么接下来你们要怎么做呢？</c>

982
00:37:43,630 --> 00:37:45,966
<c.magenta>嗯 首先我们希望当你们从这里离开时</c>

983
00:37:46,033 --> 00:37:47,234
<c.magenta>你们会添加拖放</c>

984
00:37:47,301 --> 00:37:49,636
<c.magenta>到你应用中的全部集合和表视图中</c>

985
00:37:49,703 --> 00:37:51,605
<c.magenta>你看到了设置基本效果</c>

986
00:37:51,672 --> 00:37:53,307
<c.magenta>并运行是非常迅速的</c>

987
00:37:53,740 --> 00:37:55,509
<c.magenta>并且用户会期待你的应用</c>

988
00:37:55,576 --> 00:37:57,377
<c.magenta>在iOS 11中支持拖放</c>

989
00:37:58,178 --> 00:38:00,948
<c.magenta>现在你应该明确地考虑</c>

990
00:37:58,178 --> 00:38:00,948
<c.magenta>现在你应该明确地考虑</c>

991
00:38:01,014 --> 00:38:03,050
<c.magenta>并设置那些很棒的动画</c>

992
00:38:03,116 --> 00:38:05,118
<c.magenta>因为我们把它变得非常容易实现</c>

993
00:38:05,385 --> 00:38:08,288
<c.magenta>并且它会为用户</c>

994
00:38:09,189 --> 00:38:11,925
<c.magenta>当然了 不要忘了占位符</c>

995
00:38:12,125 --> 00:38:13,861
<c.magenta>当你的数据异步加载时</c>

996
00:38:13,927 --> 00:38:16,129
<c.magenta>使用占位符来非常便利地管理</c>

997
00:38:16,763 --> 00:38:18,699
<c.magenta>那个异步数据加载</c>

998
00:38:18,765 --> 00:38:20,434
<c.magenta>并保持UI完全的完全响应性</c>

999
00:38:20,501 --> 00:38:22,936
<c.magenta>和交互性 在任何长期运行转换期间</c>

1000
00:38:23,403 --> 00:38:26,006
<c.magenta>最后 不要忘了修饰细节</c>

1001
00:38:26,440 --> 00:38:27,307
<c.magenta>我们迫不及待地想要看到</c>

1002
00:38:27,374 --> 00:38:30,244
<c.magenta>你们会用这些</c>

1003
00:38:30,511 --> 00:38:33,514
<c.magenta>并且我们会超级激动地</c>

1004
00:38:33,947 --> 00:38:36,250
<c.magenta>要获取更多信息和下载</c>

1005
00:38:36,316 --> 00:38:38,018
<c.magenta>我们今天给你们演示的示例应用</c>

1006
00:38:38,085 --> 00:38:39,586
<c.magenta>具体化了各种很棒的拖放示例</c>

1007
00:38:39,653 --> 00:38:42,756
<c.magenta>有集合视图和表视图代码</c>

1008
00:38:43,290 --> 00:38:45,459
<c.magenta>请访问这个URL 真的很棒</c>

1009
00:38:46,293 --> 00:38:48,996
<c.magenta>在本场演讲后</c>

1010
00:38:49,062 --> 00:38:51,231
<c.magenta>就在这个房间里 所以你可以留下来</c>

1011
00:38:51,365 --> 00:38:52,733
<c.magenta>用拖放实现数据传输</c>

1012
00:38:52,799 --> 00:38:54,501
<c.magenta>这将会详细讲解</c>

1013
00:38:54,568 --> 00:38:56,737
<c.magenta>加载和迁移实际数据</c>

1014
00:38:56,803 --> 00:38:57,804
<c.magenta>和元素提供者</c>

1015
00:38:58,272 --> 00:39:00,040
<c.magenta>很酷 留下来听听吧</c>

1016
00:38:58,272 --> 00:39:00,040
<c.magenta>很酷 留下来听听吧</c>

1017
00:39:00,107 --> 00:39:02,142
<c.magenta>当然 本周稍早些时候</c>

1018
00:39:02,209 --> 00:39:04,011
<c.magenta>关于拖放 拖放简介</c>

1019
00:39:04,077 --> 00:39:05,212
<c.magenta>以及精通拖放</c>

1020
00:39:05,312 --> 00:39:07,548
<c.magenta>请查看这些演讲的视频</c>

1021
00:39:08,215 --> 00:39:10,184
<c.magenta>最后我们希望你们喜欢本场演讲</c>

1022
00:39:10,250 --> 00:39:12,019
<c.magenta>希望你们度过一个美好的WWDC</c>
