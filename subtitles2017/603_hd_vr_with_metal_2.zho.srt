1
00:00:07,516 --> 00:00:16,500
[人声]

2
00:00:24,516 --> 00:00:26,736
[掌声]

3
00:00:27,236 --> 00:00:28,126
&gt;&gt; 大家早上好

4
00:00:28,746 --> 00:00:30,476
欢迎来到 VR with Metal 2

5
00:00:31,156 --> 00:00:32,646
我是 Rav Dhiraj

6
00:00:32,646 --> 00:00:34,466
是 Apple GPU 软件团队的一员

7
00:00:35,676 --> 00:00:37,446
大家都已经在

8
00:00:37,446 --> 00:00:39,006
Introducing Metal 2 讲座中了解到

9
00:00:39,416 --> 00:00:40,726
我们今年又推出了不少

10
00:00:40,726 --> 00:00:41,626
新特性

11
00:00:42,436 --> 00:00:43,546
在这场演讲中 我将会

12
00:00:43,606 --> 00:00:45,476
特别集中讲一下

13
00:00:45,476 --> 00:00:46,986
我们在 Metal 2 中添加的

14
00:00:46,986 --> 00:00:47,666
对 VR 的支持

15
00:00:48,226 --> 00:00:51,426
首先 我想简短总结一下

16
00:00:51,506 --> 00:00:53,396
我们在 macOS High Sierra 中

17
00:00:53,396 --> 00:00:54,626
推出的新功能

18
00:00:54,626 --> 00:00:57,106
然后再深入讲解

19
00:00:57,106 --> 00:00:58,386
构建 VR App 有哪些要求

20
00:00:59,186 --> 00:01:00,976
最后 再仔细讲一下

21
00:00:59,186 --> 00:01:00,976
最后 再仔细讲一下

22
00:01:00,976 --> 00:01:02,576
你们可以如何利用

23
00:01:02,576 --> 00:01:04,046
我们在 OS 中添加的

24
00:01:04,046 --> 00:01:05,906
最新的外接 GPU 支持

25
00:01:05,906 --> 00:01:06,436
这项功能

26
00:01:09,256 --> 00:01:09,516
好了

27
00:01:09,516 --> 00:01:11,166
我希望大家已经都知道

28
00:01:11,216 --> 00:01:12,276
虚拟现实是什么了

29
00:01:12,786 --> 00:01:14,706
但为防万一 我还是解释一下

30
00:01:14,706 --> 00:01:17,526
它是一种沉浸式的 360 度 3D

31
00:01:17,606 --> 00:01:20,246
体验 可以通过控制器

32
00:01:20,246 --> 00:01:21,726
直接操控物体

33
00:01:22,366 --> 00:01:24,476
还有一个房间大小的

34
00:01:24,476 --> 00:01:25,676
交互环境供人探索

35
00:01:25,676 --> 00:01:27,476
这要多亏了

36
00:01:27,476 --> 00:01:28,826
高度精确的动作追踪

37
00:01:30,036 --> 00:01:31,306
我们 Apple 认为

38
00:01:31,306 --> 00:01:32,716
VR 对于在座的开发者来说

39
00:01:32,716 --> 00:01:34,786
是一个为用户创造新体验的

40
00:01:34,786 --> 00:01:36,646
很棒的媒介

41
00:01:37,276 --> 00:01:40,956
Metal 2 以三种方式

42
00:01:40,956 --> 00:01:41,846
为此提供支持

43
00:01:42,516 --> 00:01:46,766
首先 提供一个快速 panel

44
00:01:46,846 --> 00:01:48,316
让画面帧直接显示

45
00:01:48,316 --> 00:01:49,776
在 VR 头戴显示器上 这用到了新的

46
00:01:50,296 --> 00:01:52,006
Direct to Display 功能

47
00:01:53,616 --> 00:01:56,136
其次 推出特别为 VR

48
00:01:56,136 --> 00:01:57,696
设计的新功能

49
00:01:57,756 --> 00:02:00,026
比如 Viewport Array

50
00:01:57,756 --> 00:02:00,026
比如 Viewport Array

51
00:02:01,506 --> 00:02:03,006
最后 为外接 GPU

52
00:02:03,076 --> 00:02:04,366
提供基础支持

53
00:02:04,366 --> 00:02:06,096
以便开发者能够

54
00:02:06,096 --> 00:02:07,796
使用更多样的

55
00:02:07,796 --> 00:02:08,705
Mac 硬件

56
00:02:08,946 --> 00:02:10,616
支持 VR 的 Mac 硬件

57
00:02:10,616 --> 00:02:11,066
进行工作

58
00:02:11,606 --> 00:02:13,566
好了 我们现在开始

59
00:02:13,566 --> 00:02:15,566
讲解 macOS High Sierra

60
00:02:15,696 --> 00:02:16,036
的新功能

61
00:02:17,056 --> 00:02:18,726
我们添加了对于 HTC ViveVR 头戴显示器

62
00:02:18,726 --> 00:02:20,186
的即插即玩功能

63
00:02:20,396 --> 00:02:21,616
这是内置的

64
00:02:21,616 --> 00:02:24,286
这个头戴显示器

65
00:02:24,286 --> 00:02:26,346
与 Valve SteamVR runtime

66
00:02:26,346 --> 00:02:28,436
一起工作 提供了一系列功能

67
00:02:28,436 --> 00:02:30,206
其中就包括 VR

68
00:02:30,206 --> 00:02:31,086
compositor （矫正器）

69
00:02:32,556 --> 00:02:33,946
Valve 还把他们的

70
00:02:34,006 --> 00:02:36,796
OpenVR API 添加进了 macOS

71
00:02:36,796 --> 00:02:39,136
这样你们就能创造与 SteamVR

72
00:02:39,136 --> 00:02:40,136
兼容的 VR App了

73
00:02:40,416 --> 00:02:41,466
我们在去年

74
00:02:41,466 --> 00:02:43,006
与 Valve 密切合作

75
00:02:43,106 --> 00:02:45,216
协调我们的发布

76
00:02:45,216 --> 00:02:47,256
现在 SteamVR 和 OpenVR 

77
00:02:47,726 --> 00:02:49,566
的 beta 版本都可以下载了

78
00:02:49,636 --> 00:02:50,746
就在这周

79
00:02:51,386 --> 00:02:55,376
在继续之前

80
00:02:55,406 --> 00:02:57,156
我想讲一下 VR compositor

81
00:02:57,156 --> 00:02:57,856
的具体功能

82
00:02:59,056 --> 00:03:00,616
一言以蔽之

83
00:02:59,056 --> 00:03:00,616
一言以蔽之

84
00:03:00,716 --> 00:03:02,766
它会让你的 App 渲染的画面失真

85
00:03:02,816 --> 00:03:05,106
以配合 VR 头戴显示器中的透镜

86
00:03:05,106 --> 00:03:06,156
从而显示出正常的画面

87
00:03:07,186 --> 00:03:08,526
在这个示例中 你们可以看到

88
00:03:08,686 --> 00:03:10,296
compositor 用桶形失真

89
00:03:10,296 --> 00:03:12,106
来抵消透镜

90
00:03:12,106 --> 00:03:13,516
的枕形畸变效果

91
00:03:15,676 --> 00:03:16,696
在实际应用中

92
00:03:16,696 --> 00:03:18,306
会比这个示例

93
00:03:18,306 --> 00:03:19,056
复杂得多

94
00:03:19,356 --> 00:03:20,746
compositor 需要去

95
00:03:20,746 --> 00:03:21,916
处理色差现象

96
00:03:21,916 --> 00:03:24,316
还要呈现一个

97
00:03:24,316 --> 00:03:26,176
Chaperone UI

98
00:03:26,206 --> 00:03:28,146
以便开发者们能够了解

99
00:03:28,286 --> 00:03:31,256
他们的 VR 空间的边界

100
00:03:31,466 --> 00:03:32,316
好了

101
00:03:32,316 --> 00:03:33,436
现在你有了对 VR 头戴显示器的

102
00:03:33,486 --> 00:03:36,386
内置支持 有了

103
00:03:36,896 --> 00:03:39,066
SteamVR 的 VR compositor

104
00:03:39,066 --> 00:03:41,296
还有了 API 框架

105
00:03:41,396 --> 00:03:42,976
下面我们就开始深入讲解如何创造

106
00:03:42,976 --> 00:03:43,286
VR App

107
00:03:44,756 --> 00:03:46,096
我们有两种选择

108
00:03:46,866 --> 00:03:49,156
第一是使用现有的

109
00:03:49,156 --> 00:03:50,996
支持 VR 的游戏引擎

110
00:03:51,786 --> 00:03:53,426
这是很多开发者喜欢的

111
00:03:53,426 --> 00:03:55,126
很好的选择 因为它

112
00:03:55,126 --> 00:03:56,566
把 VR compositor 的一些复杂性

113
00:03:56,566 --> 00:03:57,726
隐藏起来了

114
00:03:58,456 --> 00:04:00,356
同时它也提供了一个熟悉的

115
00:03:58,456 --> 00:04:00,356
同时它也提供了一个熟悉的

116
00:04:00,356 --> 00:04:01,786
内容创造工具链

117
00:04:03,156 --> 00:04:04,916
那么第二个选择

118
00:04:04,916 --> 00:04:06,906
是写一个原生的 VR App

119
00:04:06,906 --> 00:04:08,106
直接调用 openVR

120
00:04:08,926 --> 00:04:10,766
这会让你的 App 能够用

121
00:04:11,086 --> 00:04:12,716
VR compositor 全面控制

122
00:04:12,716 --> 00:04:13,756
渲染与同步

123
00:04:14,236 --> 00:04:15,236
但要以一些额外的复杂性

124
00:04:15,236 --> 00:04:16,366
作为这样做的代价

125
00:04:16,935 --> 00:04:19,906
选择哪一种方法取决于

126
00:04:19,906 --> 00:04:20,875
你的 App 的目标

127
00:04:21,486 --> 00:04:23,346
我们先来说一说

128
00:04:23,846 --> 00:04:24,946
游戏引擎吧

129
00:04:26,796 --> 00:04:29,306
你们在主旨演讲中已经见到

130
00:04:29,426 --> 00:04:31,316
Epic 公司的虚幻4引擎的实用

131
00:04:31,316 --> 00:04:32,976
这是个强有力的平台

132
00:04:32,976 --> 00:04:34,066
在上面可以构建你的 VR

133
00:04:34,066 --> 00:04:34,966
体验

134
00:04:36,246 --> 00:04:38,416
对于 VR 的支持会在今年晚些时候

135
00:04:38,416 --> 00:04:40,676
推出 你还可以在 Epic 的官网上找到

136
00:04:40,676 --> 00:04:42,646
教程以及其他

137
00:04:42,646 --> 00:04:43,586
相关信息

138
00:04:44,966 --> 00:04:46,656
我们还很高兴地看到

139
00:04:46,696 --> 00:04:48,936
Unity 也会在未来的引擎版本中

140
00:04:48,936 --> 00:04:50,596
在 macOS 中加入对 VR 的支持

141
00:04:51,896 --> 00:04:53,116
我们正与他们密切合作

142
00:04:53,116 --> 00:04:54,296
以确保引擎为

143
00:04:54,296 --> 00:04:56,266
VR 回放和使用 Metal 开发

144
00:04:56,266 --> 00:04:58,586
进行了优化

145
00:05:02,076 --> 00:05:03,396
说到这里 

146
00:05:03,396 --> 00:05:04,636
我想用一些时间谈谈

147
00:05:04,766 --> 00:05:06,936
一个特别的 Unity 游戏 那就是

148
00:05:06,936 --> 00:05:08,336
Space Pirate Trainer

149
00:05:08,806 --> 00:05:10,396
我们与 Unity 和 I-Illusions 合作

150
00:05:10,396 --> 00:05:12,556
把 Space Pirate Trainer

151
00:05:12,556 --> 00:05:14,596
的一个早期版本

152
00:05:14,666 --> 00:05:16,196
带入了 macOS

153
00:05:16,916 --> 00:05:19,836
I-Illusion 把他们的 App

154
00:05:20,066 --> 00:05:21,916
放到我们的平台上的速度

155
00:05:21,916 --> 00:05:23,176
真是非常惊人

156
00:05:23,716 --> 00:05:25,916
他们只用了几小时

157
00:05:25,916 --> 00:05:28,536
就完成了可运行的版本

158
00:05:28,536 --> 00:05:30,386
几天内就推出了完全可游玩的

159
00:05:30,386 --> 00:05:30,786
正式版本

160
00:05:31,926 --> 00:05:33,476
我们玩这个游戏

161
00:05:33,566 --> 00:05:35,166
玩得不亦乐乎

162
00:05:35,206 --> 00:05:36,336
而且我们认为

163
00:05:36,336 --> 00:05:38,516
这个游戏很好地

164
00:05:38,516 --> 00:05:39,886
代表了你们用 Unity 可以

165
00:05:40,146 --> 00:05:40,766
构建出的 VR 体验

166
00:05:42,176 --> 00:05:43,166
我们希望你们能够通过 WWDC

167
00:05:43,166 --> 00:05:44,136
来了解一下

168
00:05:44,136 --> 00:05:45,936
我们相信你们一定会也爱上它的

169
00:05:47,556 --> 00:05:50,636
Unity 和虚幻 4 引擎

170
00:05:50,636 --> 00:05:52,376
是 VR 开发的两大优秀平台

171
00:05:54,536 --> 00:05:56,536
但是你们当然也可以

172
00:05:56,536 --> 00:05:58,136
选择去写一个原生的 SteamVR App

173
00:05:58,496 --> 00:05:59,756
直接调用

174
00:05:59,846 --> 00:06:00,766
OpenVR 框架

175
00:05:59,846 --> 00:06:00,766
OpenVR 框架

176
00:06:01,566 --> 00:06:02,906
我们会详细讲到

177
00:06:02,906 --> 00:06:03,996
要如何把这个框架添加进

178
00:06:03,996 --> 00:06:05,756
你们的 App 这场演讲后面会讲到

179
00:06:06,006 --> 00:06:07,436
你们可以在 OpenVR GitHub 上

180
00:06:07,476 --> 00:06:09,386
下载到二进制代码和

181
00:06:09,386 --> 00:06:10,366
API 文档

182
00:06:12,776 --> 00:06:14,286
很快还会有一个

183
00:06:14,346 --> 00:06:16,416
针对 Metal 的范例 App

184
00:06:16,416 --> 00:06:17,786
可供下载

185
00:06:18,626 --> 00:06:19,676
现在 为了给大家一个基本概念

186
00:06:19,676 --> 00:06:21,556
我想先提供一个 VR App

187
00:06:21,556 --> 00:06:23,616
开发的基础讲解

188
00:06:23,616 --> 00:06:25,316
这个环节 我想把它叫做

189
00:06:25,316 --> 00:06:27,026
VR App 构建入门

190
00:06:28,666 --> 00:06:29,856
我们将会讲到

191
00:06:29,856 --> 00:06:30,356
以下几点

192
00:06:31,106 --> 00:06:32,706
首先是在 VR 开发

193
00:06:32,766 --> 00:06:34,176
过程中会遇到的

194
00:06:34,176 --> 00:06:35,246
一些挑战

195
00:06:36,496 --> 00:06:38,376
然后会讲一点

196
00:06:38,376 --> 00:06:40,206
我们的平台上的独有特点

197
00:06:40,916 --> 00:06:43,096
然后是深入剖析

198
00:06:43,096 --> 00:06:45,306
VR 框架

199
00:06:46,156 --> 00:06:47,136
最后 以一些针对

200
00:06:47,226 --> 00:06:48,826
VR App 的最佳范例作为结尾

201
00:06:50,326 --> 00:06:51,246
所以 我们要讲的很多

202
00:06:51,636 --> 00:06:53,066
就先从概况开始吧

203
00:06:54,106 --> 00:06:57,586
在 60 Hz 显示下

204
00:06:57,586 --> 00:07:00,166
传统的非 VR 动画

205
00:06:57,586 --> 00:07:00,166
传统的非 VR 动画

206
00:07:00,706 --> 00:07:03,696
每一帧大约有 16.7 毫秒的时间

207
00:07:03,696 --> 00:07:06,986
供你使用

208
00:07:07,166 --> 00:07:09,986
在很多情况下 App 可以

209
00:07:10,396 --> 00:07:12,856
把整个帧的时间预算用在

210
00:07:12,856 --> 00:07:14,016
GPU 运算上面

211
00:07:14,566 --> 00:07:17,266
但是 VR 工作

212
00:07:17,326 --> 00:07:19,656
必须要针对每秒 90 帧

213
00:07:19,656 --> 00:07:20,676
的显示方式

214
00:07:20,676 --> 00:07:22,766
这样才能

215
00:07:22,806 --> 00:07:24,686
在 Vive 这样的头戴显示器上

216
00:07:24,686 --> 00:07:26,446
达到流畅无卡顿的

217
00:07:26,446 --> 00:07:26,806
显示效果

218
00:07:27,756 --> 00:07:29,186
这就把每帧的时间

219
00:07:29,186 --> 00:07:31,116
压缩到了 11 毫秒左右

220
00:07:33,276 --> 00:07:35,186
此外 VR compositor

221
00:07:35,186 --> 00:07:37,296
还要用 GPU 为

222
00:07:37,296 --> 00:07:39,136
VR 头戴显示器的失真

223
00:07:39,136 --> 00:07:39,616
做调整

224
00:07:40,716 --> 00:07:42,136
这大约需要 1 毫秒

225
00:07:42,136 --> 00:07:44,266
这就让你的 App

226
00:07:44,266 --> 00:07:46,446
每帧可利用的时间

227
00:07:46,446 --> 00:07:48,026
缩短到了 10 毫秒

228
00:07:48,796 --> 00:07:51,726
相当于非 VR 工作的

229
00:07:51,726 --> 00:07:52,036
60%

230
00:07:52,776 --> 00:07:55,636
这还没完

231
00:07:55,636 --> 00:07:57,656
你的 App 在每一帧

232
00:07:57,656 --> 00:07:58,276
还有其它工作

233
00:07:59,306 --> 00:08:01,256
包括左右眼画面的

234
00:07:59,306 --> 00:08:01,256
包括左右眼画面的

235
00:08:01,556 --> 00:08:03,106
立体渲染

236
00:08:04,096 --> 00:08:05,786
很多情况下还包括

237
00:08:05,786 --> 00:08:07,416
高分辨率的渲染工作

238
00:08:08,476 --> 00:08:10,086
Vive 头显设备的分辨率是

239
00:08:10,086 --> 00:08:12,836
2160 x 1200

240
00:08:13,186 --> 00:08:15,476
这比1080的高清标准

241
00:08:15,476 --> 00:08:16,586
还多出 25% 的像素

242
00:08:17,576 --> 00:08:19,676
此外 很多 VR App

243
00:08:19,676 --> 00:08:22,696
还会以 1.2 到 1.4 倍的画面比例

244
00:08:22,746 --> 00:08:24,216
进行渲染 以保证高质量的画面

245
00:08:25,366 --> 00:08:28,316
也就是说 你的 App

246
00:08:28,316 --> 00:08:30,246
要在更少的时间内做更多工作

247
00:08:31,526 --> 00:08:32,645
欢迎来到 VR 开发的世界

248
00:08:34,596 --> 00:08:35,186
好了

249
00:08:35,186 --> 00:08:36,535
我们来说一说平台的具体特点吧

250
00:08:38,336 --> 00:08:40,535
Metal 2 推出了一项新的

251
00:08:40,535 --> 00:08:42,806
Direct to Display 功能

252
00:08:42,806 --> 00:08:44,166
用在其支持的头显设备上 比如

253
00:08:44,166 --> 00:08:44,596
Vive

254
00:08:45,476 --> 00:08:47,886
这是一个低延迟通道

255
00:08:47,926 --> 00:08:49,446
绕过了 OS window

256
00:08:49,446 --> 00:08:51,376
compositor 并给予 VR

257
00:08:51,376 --> 00:08:54,256
compositor 比如 SteamVR

258
00:08:54,256 --> 00:08:55,896
直接在头显设备上

259
00:08:55,896 --> 00:08:57,646
显示画面的能力

260
00:08:58,326 --> 00:09:00,146
这一功能避免了 OS 去做

261
00:08:58,326 --> 00:09:00,146
这一功能避免了 OS 去做

262
00:09:00,146 --> 00:09:03,546
像素处理或是额外拷贝

263
00:09:03,806 --> 00:09:05,276
如果为了保证这条快速通道

264
00:09:05,346 --> 00:09:06,926
让 macOS 不把 VR 头显设备

265
00:09:06,996 --> 00:09:09,846
当成显示设备

266
00:09:09,896 --> 00:09:11,366
那它将一文不值 毫无意义

267
00:09:11,956 --> 00:09:13,146
它们会被隐藏在系统里

268
00:09:13,286 --> 00:09:15,376
无法提供任何扩展的

269
00:09:15,376 --> 00:09:16,056
桌面功能

270
00:09:16,746 --> 00:09:20,676
总结一下 以前的模型

271
00:09:20,676 --> 00:09:22,976
是你可以 或者说一个 App

272
00:09:23,516 --> 00:09:25,276
可以通过操作系统的

273
00:09:25,366 --> 00:09:26,336
window compositor 来显示画面

274
00:09:28,316 --> 00:09:30,086
现在则是一个 VR App

275
00:09:30,136 --> 00:09:32,456
直接通过 VR compositor

276
00:09:32,496 --> 00:09:33,756
在头显设备上显示画面

277
00:09:34,566 --> 00:09:36,446
这就是 Metal 2 为了 VR

278
00:09:36,516 --> 00:09:39,716
推出的 Direct to Display 功能

279
00:09:41,416 --> 00:09:41,976
好了

280
00:09:42,206 --> 00:09:43,556
我们继续 macOS 平台特点的话题

281
00:09:43,616 --> 00:09:46,126
我们来说一说你们的 App

282
00:09:46,126 --> 00:09:48,026
如何选择 metal 设备

283
00:09:48,026 --> 00:09:49,296
进行工作

284
00:09:50,276 --> 00:09:52,266
在 macOS 里 VR compositor

285
00:09:52,316 --> 00:09:54,546
可以要求 OS

286
00:09:54,546 --> 00:09:57,006
为与头显设备相连的 GPU

287
00:09:57,006 --> 00:09:58,346
寻找设备

288
00:09:59,556 --> 00:10:00,786
出于性能方面的考虑

289
00:09:59,556 --> 00:10:00,786
出于性能方面的考虑

290
00:10:01,356 --> 00:10:02,776
你的 App 会选择与

291
00:10:02,776 --> 00:10:04,766
compositor 正在使用的设备

292
00:10:04,766 --> 00:10:04,976
相同的设备

293
00:10:06,266 --> 00:10:07,226
我们与 Valve 共同工作

294
00:10:07,226 --> 00:10:08,476
以确保有一个 API

295
00:10:08,476 --> 00:10:10,566
负责这一点 它就是

296
00:10:10,856 --> 00:10:13,186
GetOutputDevice 它能找到

297
00:10:13,186 --> 00:10:14,266
作为你渲染目标的 Metal 设备

298
00:10:14,876 --> 00:10:15,486
就这么简单

299
00:10:18,486 --> 00:10:20,416
接下来 我们说一下在 macOS 上

300
00:10:20,416 --> 00:10:22,236
管理 drawable 表面的问题

301
00:10:23,576 --> 00:10:25,376
VR compositor 和你的 App

302
00:10:25,376 --> 00:10:28,126
为 drawable 表面分别保留了

303
00:10:28,396 --> 00:10:29,576
不同的 pool

304
00:10:30,196 --> 00:10:32,276
在典型的一帧画面里 你的 App 会

305
00:10:32,556 --> 00:10:34,176
把它渲染成它所具有的纹理

306
00:10:34,176 --> 00:10:36,926
再提交给

307
00:10:36,926 --> 00:10:37,736
VR compositor

308
00:10:38,806 --> 00:10:40,666
然后这些会被合成到

309
00:10:40,666 --> 00:10:42,186
compositor 所具有的一个表面

310
00:10:42,186 --> 00:10:44,076
这个表面将会

311
00:10:44,076 --> 00:10:45,246
显示在头戴设备上

312
00:10:47,006 --> 00:10:49,716
在 macOS 中 把这些

313
00:10:49,716 --> 00:10:51,376
经过渲染的数据

314
00:10:51,556 --> 00:10:53,496
从你的 App 转移到 compositor 上

315
00:10:53,496 --> 00:10:54,286
IO surface 是理想的媒介

316
00:10:54,816 --> 00:10:56,346
所以请确保你们制作的

317
00:10:56,346 --> 00:10:58,066
Metal 纹理要得到

318
00:10:58,416 --> 00:10:59,566
IO surface 的支持

319
00:11:01,076 --> 00:11:02,596
我们来看看

320
00:11:02,656 --> 00:11:03,926
你要如何制造

321
00:11:03,926 --> 00:11:04,606
这些纹理

322
00:11:06,616 --> 00:11:08,046
你要建立一个

323
00:11:08,156 --> 00:11:09,766
纹理描述符

324
00:11:09,766 --> 00:11:11,436
指明渲染目标

325
00:11:11,476 --> 00:11:13,266
使用标志 因为你的 App

326
00:11:13,266 --> 00:11:14,406
会对它进行渲染

327
00:11:15,276 --> 00:11:17,416
但也要有着色器读取使用标志

328
00:11:18,146 --> 00:11:19,336
因为 compositor 会把它

329
00:11:19,426 --> 00:11:20,926
作为一个输入

330
00:11:21,406 --> 00:11:24,726
然后 要制作左右眼

331
00:11:24,946 --> 00:11:26,976
纹理 你只需要把之前分配的

332
00:11:27,066 --> 00:11:29,966
IO surface 和这个

333
00:11:29,966 --> 00:11:31,586
纹理描述符

334
00:11:31,626 --> 00:11:33,096
传送给

335
00:11:33,096 --> 00:11:34,696
newTextureWithDescriptor 就可以了

336
00:11:35,366 --> 00:11:35,596
好的

337
00:11:35,716 --> 00:11:36,786
现在我想花几分钟时间

338
00:11:36,786 --> 00:11:39,266
讲一下 或者说描述一下

339
00:11:39,266 --> 00:11:40,676
VR App 中的典型一帧

340
00:11:41,576 --> 00:11:43,076
这很重要 因为你的 App

341
00:11:43,076 --> 00:11:45,086
和 VR compositor 必须要

342
00:11:45,086 --> 00:11:46,376
同步工作

343
00:11:47,436 --> 00:11:49,186
我之前说过

344
00:11:49,186 --> 00:11:50,826
你的 App 渲染后的输出

345
00:11:50,826 --> 00:11:53,096
要被传送到 VR compositor 里

346
00:11:53,096 --> 00:11:54,336
用 GPU 进行额外的处理

347
00:11:55,726 --> 00:11:57,756
因为 GPU 属于共享资源

348
00:11:57,806 --> 00:12:00,596
因此保持同步与安排工作时间

349
00:11:57,806 --> 00:12:00,596
因此保持同步与安排工作时间

350
00:12:00,596 --> 00:12:02,486
就非常重要了

351
00:12:03,086 --> 00:12:05,436
我们就从一帧的开头

352
00:12:05,436 --> 00:12:06,026
说起吧

353
00:12:06,946 --> 00:12:08,706
你的 App 需要请求

354
00:12:08,706 --> 00:12:10,506
VR 系统 获取头显设备

355
00:12:10,506 --> 00:12:12,196
的动作 它需要这个来渲染

356
00:12:12,196 --> 00:12:12,746
这一帧

357
00:12:13,936 --> 00:12:15,766
对 SteamVR 来说 这是用

358
00:12:15,866 --> 00:12:17,316
WaitGetPoses 调用来完成的

359
00:12:18,366 --> 00:12:20,406
然后你的 App

360
00:12:20,406 --> 00:12:22,116
在获得这些输入后

361
00:12:22,246 --> 00:12:24,246
可以立即对这一帧渲染后的命令

362
00:12:24,246 --> 00:12:24,946
进行编码

363
00:12:25,536 --> 00:12:28,406
然后 在你在对命令缓冲

364
00:12:28,406 --> 00:12:30,136
进行编码后

365
00:12:30,176 --> 00:12:31,836
你可以将它提交给 Metal

366
00:12:31,836 --> 00:12:32,576
在 GPU 上排队

367
00:12:33,146 --> 00:12:35,296
然后 将你的左右眼纹理

368
00:12:35,296 --> 00:12:37,956
提交给 SteamVR

369
00:12:38,946 --> 00:12:40,666
这会唤起 compositor

370
00:12:40,666 --> 00:12:42,606
让它开始为这一帧的

371
00:12:42,606 --> 00:12:43,896
GPU 工作进行编码

372
00:12:44,476 --> 00:12:46,976
然后 因为执行顺序非常重要

373
00:12:46,976 --> 00:12:49,286
你的 App 还需要

374
00:12:49,286 --> 00:12:50,816
告诉 VR compositor

375
00:12:50,816 --> 00:12:53,526
交给 GPU 的工作

376
00:12:53,596 --> 00:12:54,896
被安排在何时开始

377
00:12:56,656 --> 00:12:58,566
所以 对 Metal SteamVR App 来说

378
00:12:58,646 --> 00:13:00,706
你只需要等待 直到你的

379
00:12:58,646 --> 00:13:00,706
你只需要等待 直到你的

380
00:13:00,706 --> 00:13:02,746
命令缓冲被安排好

381
00:13:02,746 --> 00:13:04,496
然后你就可以调用 SteamVR

382
00:13:04,496 --> 00:13:06,406
PostPresentHandoff 函数了

383
00:13:07,136 --> 00:13:08,886
这会告诉 VR compositor

384
00:13:09,136 --> 00:13:10,726
它可以把工作交给 GPU 了

385
00:13:10,726 --> 00:13:13,026
这一工作将按正确顺序

386
00:13:13,476 --> 00:13:14,366
进行排队

387
00:13:14,366 --> 00:13:16,886
我们看一下

388
00:13:16,886 --> 00:13:18,346
这在你的 draw loop 里是什么样子

389
00:13:18,706 --> 00:13:20,276
在 loop 的顶端

390
00:13:20,686 --> 00:13:22,006
有你的 WaitGetPoses call

391
00:13:22,006 --> 00:13:23,876
从头显设备里收集

392
00:13:23,876 --> 00:13:24,396
输入

393
00:13:25,656 --> 00:13:27,196
然后你要建立命令缓冲

394
00:13:27,196 --> 00:13:29,536
渲染你的场景

395
00:13:29,536 --> 00:13:30,706
然后把它提交给 GPU

396
00:13:31,826 --> 00:13:33,146
然后 在这里 你会

397
00:13:33,236 --> 00:13:35,086
把左右眼纹理提交给

398
00:13:35,186 --> 00:13:36,576
SteamVR

399
00:13:37,906 --> 00:13:39,876
然后 你等到

400
00:13:39,876 --> 00:13:40,796
命令缓冲被安排好

401
00:13:40,836 --> 00:13:43,466
你就可以调用

402
00:13:43,466 --> 00:13:45,086
PostPresentHandoff 告诉

403
00:13:45,086 --> 00:13:47,226
VR compositor 它现在可以

404
00:13:47,456 --> 00:13:49,966
把工作交给 GPU 了

405
00:13:51,926 --> 00:13:53,496
再强调一件事

406
00:13:55,056 --> 00:13:57,046
在我们

407
00:13:57,046 --> 00:13:58,486
把这个图表应用在

408
00:13:58,486 --> 00:14:00,676
下一帧的同时 需要注意是

409
00:13:58,486 --> 00:14:00,676
下一帧的同时 需要注意是

410
00:14:00,986 --> 00:14:04,086
WaitGetPoses 而不是

411
00:14:04,196 --> 00:14:06,556
垂直中断定义了

412
00:14:06,556 --> 00:14:08,046
你的 App 的一帧的开始

413
00:14:08,896 --> 00:14:09,956
这一点很重要

414
00:14:09,956 --> 00:14:11,026
我们很快就会

415
00:14:11,026 --> 00:14:12,116
回来再说到这里

416
00:14:13,136 --> 00:14:15,016
好了

417
00:14:15,986 --> 00:14:17,396
我们接下来看一些

418
00:14:17,396 --> 00:14:18,416
很棒的实践

419
00:14:19,026 --> 00:14:22,626
首先是要避免

420
00:14:22,626 --> 00:14:24,596
在 CPU 编码命令时

421
00:14:24,596 --> 00:14:26,146
在一帧的开始产生

422
00:14:26,146 --> 00:14:27,836
GPU 气泡

423
00:14:29,036 --> 00:14:31,646
SteamVR 提供了一个

424
00:14:31,646 --> 00:14:33,216
很有用的机制来

425
00:14:33,216 --> 00:14:35,206
让你很早开始这一帧的工作

426
00:14:35,626 --> 00:14:37,216
让你的 App 有

427
00:14:37,276 --> 00:14:38,856
2 到 3 毫秒的时间运行开始

428
00:14:40,286 --> 00:14:41,226
这应该看上去

429
00:14:41,276 --> 00:14:41,786
不陌生

430
00:14:42,456 --> 00:14:43,836
把一帧的开始

431
00:14:43,836 --> 00:14:46,126
与 WaitGetPoses 对齐

432
00:14:46,126 --> 00:14:47,416
就保证了你利用到了

433
00:14:47,416 --> 00:14:48,966
这一优化

434
00:14:49,226 --> 00:14:50,576
让运行开始

435
00:14:54,076 --> 00:14:54,636
好的

436
00:14:54,716 --> 00:14:57,076
接下来 保证你的 App

437
00:14:57,076 --> 00:14:59,146
不会在把它们发送给 GPU 前

438
00:14:59,196 --> 00:15:00,396
建立大型的单片命令缓冲

439
00:14:59,196 --> 00:15:00,396
建立大型的单片命令缓冲

440
00:15:00,396 --> 00:15:02,146
因为这也会

441
00:15:02,146 --> 00:15:03,936
造成 GPU 气泡

442
00:15:05,496 --> 00:15:07,966
你要做的是

443
00:15:07,966 --> 00:15:09,416
在可能的地方分割命令缓冲

444
00:15:09,656 --> 00:15:11,206
在进行过程中提交它们

445
00:15:11,206 --> 00:15:13,466
以保证 GPU 的应用在这一帧中达到

446
00:15:13,466 --> 00:15:13,866
最大化

447
00:15:14,406 --> 00:15:18,246
我们建议的下一个优化

448
00:15:18,246 --> 00:15:19,886
是尝试把你的左右眼

449
00:15:19,956 --> 00:15:22,046
绘制合并到一起

450
00:15:25,036 --> 00:15:26,836
Metal 2 Viewport Array

451
00:15:26,836 --> 00:15:28,296
特性为你提供了一个很好的机制

452
00:15:28,296 --> 00:15:30,296
帮你完成这一点

453
00:15:30,296 --> 00:15:32,036
它让你的 App 在

454
00:15:32,096 --> 00:15:34,176
vertex shader （顶点着色器）里

455
00:15:34,596 --> 00:15:35,546
选择逐个几何体目标视口

456
00:15:36,326 --> 00:15:37,796
这可以大幅度

457
00:15:37,796 --> 00:15:39,666
降低你的 draw call 资源消耗

458
00:15:39,666 --> 00:15:41,256
让你能够使用一个 draw call 来

459
00:15:41,916 --> 00:15:43,626
同时渲染左右眼场景

460
00:15:45,386 --> 00:15:46,726
我们来看一个示例

461
00:15:46,726 --> 00:15:48,296
展示如何用 instancing 来

462
00:15:48,676 --> 00:15:50,236
让你的 Metal App

463
00:15:50,236 --> 00:15:51,746
用上 Viewport Array

464
00:15:53,136 --> 00:15:54,016
我要先指出

465
00:15:54,016 --> 00:15:55,616
你需要制造一个

466
00:15:55,616 --> 00:15:57,446
两倍宽的纹理

467
00:15:57,446 --> 00:15:58,956
因为你现在要

468
00:15:58,956 --> 00:16:00,356
用同一个纹理

469
00:15:58,956 --> 00:16:00,356
用同一个纹理

470
00:16:00,356 --> 00:16:02,266
渲染左右眼场景

471
00:16:03,836 --> 00:16:05,766
然后你只需要建立你的

472
00:16:05,766 --> 00:16:07,386
Viewpoint array 它定义了

473
00:16:07,386 --> 00:16:10,026
你的左右眼视口的边界

474
00:16:12,786 --> 00:16:13,906
然后你可以把这个

475
00:16:13,946 --> 00:16:15,216
Viewport array 交给你的

476
00:16:15,216 --> 00:16:16,976
渲染命令编码 你可以用

477
00:16:17,416 --> 00:16:18,426
setViewports API 做到这一点

478
00:16:19,586 --> 00:16:20,586
然后 在这里 你需要

479
00:16:20,586 --> 00:16:21,826
制作一个实例到

480
00:16:21,976 --> 00:16:23,706
DrawPrimitives 调用

481
00:16:23,766 --> 00:16:26,286
实例数量是 2

482
00:16:26,286 --> 00:16:27,366
从而把 draw 分配到左右眼

483
00:16:27,416 --> 00:16:28,066
视口上

484
00:16:29,286 --> 00:16:31,046
我们会在顶点着色器里

485
00:16:31,366 --> 00:16:33,836
使用实例 ID 当作我们的 eye index

486
00:16:35,286 --> 00:16:36,136
我们来看一下这个

487
00:16:36,136 --> 00:16:36,786
顶点着色器

488
00:16:37,406 --> 00:16:39,536
我先要指出的是

489
00:16:39,536 --> 00:16:42,126
这个视口是

490
00:16:42,456 --> 00:16:44,096
由新的 viewpoint_array_index

491
00:16:44,316 --> 00:16:45,436
属性选择出来的

492
00:16:47,756 --> 00:16:49,276
我之前说过

493
00:16:49,406 --> 00:16:50,166
我们正在使用 instance_ID

494
00:16:50,166 --> 00:16:52,486
作为我们的 eye index

495
00:16:52,826 --> 00:16:54,186
我们将能够使用它

496
00:16:54,186 --> 00:16:56,416
访问我们的视口关联数据

497
00:16:56,416 --> 00:16:57,936
就好像这个示例里的

498
00:16:57,966 --> 00:16:59,646
这个模型投影矩阵

499
00:17:00,716 --> 00:17:03,166
最后 一定要记得

500
00:17:03,166 --> 00:17:05,006
让你的视口索引

501
00:17:05,476 --> 00:17:06,705
和 instance_ID 关联起来

502
00:17:06,746 --> 00:17:08,006
这样在栅格化你的图像时

503
00:17:08,066 --> 00:17:10,056
能够保证选择了正确的视口

504
00:17:11,465 --> 00:17:13,465
这就是使用新的

505
00:17:13,465 --> 00:17:15,286
Viewport Array 特性减少

506
00:17:15,346 --> 00:17:17,906
你的 VR App 的 draw call 开销

507
00:17:18,856 --> 00:17:18,976
的方法

508
00:17:20,296 --> 00:17:20,846
好了

509
00:17:21,006 --> 00:17:22,386
今天我想说的最后一个优化

510
00:17:22,386 --> 00:17:24,006
是一个公认的

511
00:17:24,066 --> 00:17:25,465
最佳方法

512
00:17:25,465 --> 00:17:27,406
你会想去尝试减少

513
00:17:27,406 --> 00:17:29,716
在每一帧着色的

514
00:17:29,716 --> 00:17:30,876
像素数量

515
00:17:31,406 --> 00:17:33,236
由于镜头扭曲的特性

516
00:17:33,236 --> 00:17:35,816
你渲染的场景中

517
00:17:35,816 --> 00:17:37,876
大约 15% 的部分

518
00:17:37,876 --> 00:17:39,386
在 VR 头显设备上是看不到的

519
00:17:40,136 --> 00:17:41,626
这幅图中的蓝色区域

520
00:17:41,626 --> 00:17:42,586
就代表了看不到的部分

521
00:17:43,536 --> 00:17:45,976
幸好 SteamVR 提供了一个

522
00:17:46,056 --> 00:17:47,786
基于网格的模板掩码

523
00:17:47,866 --> 00:17:49,466
专为 Vive 头显设备设计

524
00:17:49,626 --> 00:17:51,006
你可以用它来剔除这些

525
00:17:51,066 --> 00:17:51,576
像素

526
00:17:52,096 --> 00:17:54,296
非常易用 

527
00:17:54,326 --> 00:17:55,996
效果也非常之好

528
00:17:55,996 --> 00:17:56,866
好了

529
00:17:57,876 --> 00:18:00,586
这就是今天这个

530
00:17:57,876 --> 00:18:00,586
这就是今天这个

531
00:18:00,666 --> 00:18:01,976
构建 VR App 的简短介绍的全部内容

532
00:18:02,766 --> 00:18:03,716
背景介绍完毕

533
00:18:03,716 --> 00:18:05,256
我想请 Valve 软件公司的

534
00:18:05,256 --> 00:18:06,916
Nat Brown 上台

535
00:18:06,996 --> 00:18:08,836
为大家深入讲解

536
00:18:08,836 --> 00:18:10,886
macOS 系统上的 SteamVR

537
00:18:12,016 --> 00:18:13,726
[掌声]

538
00:18:13,726 --> 00:18:14,126
谢谢 Nat

539
00:18:14,356 --> 00:18:14,746
&gt;&gt; 谢谢 Rav

540
00:18:16,146 --> 00:18:17,516
嗨 大家好

541
00:18:17,566 --> 00:18:20,486
我是 Nat 在 Valve 负责 VR 工作

542
00:18:20,786 --> 00:18:22,546
如果你们还不知道 Valve

543
00:18:22,546 --> 00:18:24,076
我们是个游戏公司

544
00:18:24,076 --> 00:18:25,186
我们发行游戏

545
00:18:25,186 --> 00:18:28,636
我们在 Steam 上有

546
00:18:28,636 --> 00:18:29,276
许多玩家

547
00:18:29,636 --> 00:18:30,896
实践证明 游戏

548
00:18:30,896 --> 00:18:33,266
对于用户界面

549
00:18:33,266 --> 00:18:34,186
和人机交互来说

550
00:18:34,186 --> 00:18:35,226
是一个非常有趣的严峻考验

551
00:18:35,676 --> 00:18:36,766
在 Valve 我们围绕着

552
00:18:36,766 --> 00:18:39,006
游戏和输入 进行了很多

553
00:18:39,006 --> 00:18:39,306
实验

554
00:18:40,156 --> 00:18:42,356
但多年来的 VR 原形体

555
00:18:42,886 --> 00:18:44,186
却并没有真正适用在

556
00:18:44,186 --> 00:18:45,346
制作游戏或者其他任何内容上面

557
00:18:46,366 --> 00:18:47,866
知道我们发现了这个

558
00:18:47,866 --> 00:18:50,106
完美的结合体

559
00:18:50,106 --> 00:18:52,096
包括 90 赫兹低余辉显示 

560
00:18:52,096 --> 00:18:53,716
以及用这两个追踪控制器实现的

561
00:18:53,716 --> 00:18:54,536
房间范围内的准确追踪

562
00:18:55,276 --> 00:18:57,056
我们认为这就是 VR 领域的

563
00:18:57,056 --> 00:18:58,076
神奇突破

564
00:18:58,726 --> 00:19:00,826
我想它可以与

565
00:18:58,726 --> 00:19:00,826
我想它可以与

566
00:19:00,826 --> 00:19:02,776
你第一次使用

567
00:19:03,246 --> 00:19:04,546
低延迟精确触屏的

568
00:19:04,546 --> 00:19:06,216
智能手机的感受相比

569
00:19:06,216 --> 00:19:07,066
感觉非常神奇

570
00:19:07,396 --> 00:19:08,536
这就是 VR 领域的

571
00:19:08,536 --> 00:19:11,526
神奇突破

572
00:19:11,746 --> 00:19:12,916
一旦房间大小的 VR 环境

573
00:19:12,916 --> 00:19:14,216
成为了现实 我们就知道自己终于可以

574
00:19:14,216 --> 00:19:16,166
构建 VR 游戏和 VR

575
00:19:16,166 --> 00:19:16,496
内容了

576
00:19:17,516 --> 00:19:19,366
我们授权了各方面的 VR

577
00:19:19,366 --> 00:19:22,296
技术 比如基站

578
00:19:22,466 --> 00:19:24,686
头显设备镜片设计等等

579
00:19:24,686 --> 00:19:26,686
非独家地授权给了

580
00:19:26,686 --> 00:19:28,156
HTC 和 LG 等等合作伙伴

581
00:19:28,156 --> 00:19:30,016
我们还有一个大型项目

582
00:19:30,016 --> 00:19:31,486
把 Lighthouse 追踪技术

583
00:19:31,486 --> 00:19:32,816
授权给了很多不同的合作伙伴

584
00:19:33,756 --> 00:19:37,196
我们对于软件栈的办法

585
00:19:37,196 --> 00:19:38,336
你们也许已经听说了

586
00:19:38,336 --> 00:19:39,906
那就是

587
00:19:39,906 --> 00:19:42,186
SteamVr runtime

588
00:19:42,416 --> 00:19:43,936
SteamVr 有一个应用模型

589
00:19:43,936 --> 00:19:45,506
在上面 和一个硬件

590
00:19:45,506 --> 00:19:46,876
与驱动模型 在下面

591
00:19:47,016 --> 00:19:49,266
我们的目标是

592
00:19:49,266 --> 00:19:50,606
大力推广 VR 领域的实践

593
00:19:50,606 --> 00:19:52,096
因为我们现在还处于

594
00:19:52,096 --> 00:19:53,546
VR 初期 还不了解它

595
00:19:53,546 --> 00:19:55,006
能够发展成什么样子

596
00:19:55,546 --> 00:19:57,236
我们想制作这个模型

597
00:19:57,236 --> 00:19:58,746
让人们在里面实验

598
00:19:58,746 --> 00:19:59,576
VR 硬件和内容 同时

599
00:19:59,576 --> 00:19:59,976
减少风险

600
00:20:00,046 --> 00:20:03,036
你们可以去

601
00:20:03,036 --> 00:20:04,246
也许不是你们 但总有人可以去

602
00:20:04,536 --> 00:20:06,186
设计新的头显设备

603
00:20:06,186 --> 00:20:08,346
新的追踪系统 新的

604
00:20:08,346 --> 00:20:08,896
控制器

605
00:20:09,066 --> 00:20:10,526
然后 你们可以到

606
00:20:10,526 --> 00:20:12,146
Open VR 平台上

607
00:20:12,146 --> 00:20:13,526
写一个驱动程序然后直接插入设备

608
00:20:14,036 --> 00:20:15,116
然后你就可以访问

609
00:20:15,116 --> 00:20:16,606
正在运行的

610
00:20:16,606 --> 00:20:17,336
所有内容了

611
00:20:18,056 --> 00:20:19,596
这会给你真实世界的

612
00:20:19,596 --> 00:20:21,666
测试 能让你的硬件变得

613
00:20:21,666 --> 00:20:21,966
更好

614
00:20:21,966 --> 00:20:23,266
因为你和你的顾客

615
00:20:23,496 --> 00:20:25,426
可以直接将你的新创意

616
00:20:25,426 --> 00:20:26,566
和其他在这个平台上的

617
00:20:26,566 --> 00:20:27,326
硬件进行对比

618
00:20:27,826 --> 00:20:29,246
这样一来 硬件开发者就不必

619
00:20:29,246 --> 00:20:30,566
开发特定内容

620
00:20:30,916 --> 00:20:32,206
内容开发者也不必

621
00:20:32,206 --> 00:20:33,926
去赌哪一个硬件

622
00:20:33,926 --> 00:20:34,486
会胜出了

623
00:20:34,486 --> 00:20:36,476
他们只需要集中精力

624
00:20:37,236 --> 00:20:38,906
做好内容就可以了

625
00:20:38,906 --> 00:20:41,486
下面讲到关联到

626
00:20:41,486 --> 00:20:42,336
Open VR 框架的应用

627
00:20:42,336 --> 00:20:44,286
这是一个很小的库

628
00:20:44,286 --> 00:20:45,786
它只知道去定义

629
00:20:46,106 --> 00:20:47,166
当前被安装的 runtime

630
00:20:47,576 --> 00:20:49,336
它找到这个 VR 用户库

631
00:20:49,336 --> 00:20:50,546
这是一个共享库

632
00:20:50,546 --> 00:20:51,816
它要么能够关联到

633
00:20:51,816 --> 00:20:53,556
要么能够启动

634
00:20:53,556 --> 00:20:55,006
SteamVR 的其他 runtime

635
00:20:55,006 --> 00:20:55,596
进程

636
00:20:55,996 --> 00:20:57,156
这是 vrmonitor 进程

637
00:20:57,156 --> 00:20:58,516
你们会看到许多

638
00:20:58,516 --> 00:21:00,066
这样的小窗口

639
00:20:58,516 --> 00:21:00,066
这样的小窗口

640
00:21:00,066 --> 00:21:01,486
这是一个 UI 和设置

641
00:21:01,486 --> 00:21:02,066
应用

642
00:21:02,066 --> 00:21:03,586
它会显示连接

643
00:21:03,586 --> 00:21:04,536
头显设备和控制器

644
00:21:04,536 --> 00:21:05,886
以及追踪感应器的

645
00:21:05,886 --> 00:21:06,326
状态

646
00:21:06,836 --> 00:21:11,896
vrserver 负责

647
00:21:12,006 --> 00:21:13,656
追踪驱动

648
00:21:13,836 --> 00:21:14,976
加载交替驱动

649
00:21:14,976 --> 00:21:16,806
它还会把姿态和其他信息

650
00:21:16,806 --> 00:21:19,076
放入共享内存

651
00:21:19,076 --> 00:21:21,136
以便让你的应用

652
00:21:21,136 --> 00:21:22,656
和 SteaVR runtime 的其他部分

653
00:21:22,706 --> 00:21:24,836
能够访问它

654
00:21:25,106 --> 00:21:26,336
这是 vrcompositor 你们刚刚

655
00:21:26,336 --> 00:21:28,066
已经稍微了解过了

656
00:21:28,276 --> 00:21:30,696
这个进程有点像

657
00:21:30,696 --> 00:21:31,086
Windows Server

658
00:21:31,326 --> 00:21:33,026
它把场景和 overlay 绘制在

659
00:21:33,026 --> 00:21:33,636
头显设备上

660
00:21:33,636 --> 00:21:35,506
它还会根据镜片失真和颜色

661
00:21:35,536 --> 00:21:36,666
来矫正图像

662
00:21:36,886 --> 00:21:37,716
还有一件从某种程度来看

663
00:21:37,716 --> 00:21:39,526
是隐藏起来的 你们可能

664
00:21:39,526 --> 00:21:42,656
不太明白的事 那就是它还

665
00:21:42,656 --> 00:21:43,746
会矫正动态画面中的

666
00:21:43,746 --> 00:21:44,726
拖尾和重影

667
00:21:45,086 --> 00:21:48,506
它还会在应用无法

668
00:21:48,506 --> 00:21:50,216
达到帧率时 

669
00:21:50,216 --> 00:21:51,446
消失在稳定跟踪区域

670
00:21:51,716 --> 00:21:52,846
因为我们不想让人们

671
00:21:52,846 --> 00:21:53,846
碰到一些意外情况

672
00:21:54,526 --> 00:21:55,926
vrcompositor

673
00:21:55,926 --> 00:21:56,946
与 Metal 进行通讯

674
00:21:56,946 --> 00:21:57,386
你们已经了解过了

675
00:21:57,596 --> 00:21:59,066
它通过 Direct to Display

676
00:21:59,066 --> 00:22:00,026
Metal 2 API

677
00:21:59,066 --> 00:22:00,026
Metal 2 API

678
00:22:00,026 --> 00:22:01,546
把画面直接显示在头显设备上

679
00:22:03,146 --> 00:22:03,526
我们看一下

680
00:22:03,526 --> 00:22:05,216
最后要说的是

681
00:22:05,496 --> 00:22:06,266
vrdashboard

682
00:22:06,486 --> 00:22:09,216
这部分的 UI 让你

683
00:22:09,216 --> 00:22:10,606
能够选择应用

684
00:22:10,936 --> 00:22:12,176
让你控制音量

685
00:22:12,576 --> 00:22:13,636
等其他系统设置

686
00:22:14,486 --> 00:22:16,256
我们提供一个默认的

687
00:22:16,256 --> 00:22:17,586
向你展示你的 Steam 库

688
00:22:17,586 --> 00:22:18,606
除非你选择应用

689
00:22:18,956 --> 00:22:20,096
但实际上有一个 API

690
00:22:20,096 --> 00:22:21,206
你也可以写你自己的

691
00:22:21,446 --> 00:22:22,736
dashboard 应用

692
00:22:22,966 --> 00:22:24,646
Valve 和 Apple 我们已经

693
00:22:24,646 --> 00:22:25,886
更加密切地合作

694
00:22:26,086 --> 00:22:27,336
就在大约一年前开始

695
00:22:27,646 --> 00:22:28,776
我们把端口从 OpenGL 转换到 Metal

696
00:22:28,776 --> 00:22:30,286
并没有让我们花费太多代价

697
00:22:30,686 --> 00:22:31,856
Metal 是个非常酷的 API

698
00:22:31,856 --> 00:22:34,116
它对于我们实现 VR 的高性能运行

699
00:22:34,116 --> 00:22:35,716
起到了关键作用

700
00:22:35,876 --> 00:22:38,166
大约一年前 我们对 Apple 最大的要求

701
00:22:38,166 --> 00:22:39,836
就是这个 Direct to

702
00:22:39,836 --> 00:22:40,536
Display 的特性

703
00:22:40,986 --> 00:22:42,126
因为要确保

704
00:22:42,126 --> 00:22:43,476
VR compositor 有达到头显设备的

705
00:22:43,476 --> 00:22:45,846
最快的可预测通道

706
00:22:45,846 --> 00:22:46,966
这非常重要

707
00:22:47,906 --> 00:22:50,046
同时我们还非常需要

708
00:22:50,046 --> 00:22:52,166
非常准确的低方差 VBL

709
00:22:52,276 --> 00:22:53,606
也就是垂直中断事件

710
00:22:53,956 --> 00:22:54,726
这样我们就可以设置

711
00:22:54,726 --> 00:22:56,216
VR 显示帧的节拍

712
00:22:56,216 --> 00:22:57,856
并且可以

713
00:22:57,856 --> 00:22:58,936
精确预测

714
00:22:58,936 --> 00:23:00,086
这些动作

715
00:22:58,936 --> 00:23:00,086
这些动作

716
00:23:00,316 --> 00:23:01,736
精确预测动作

717
00:23:01,966 --> 00:23:04,156
实际上要比动作发生之间的时间

718
00:23:04,156 --> 00:23:06,016
和显示出现的时间

719
00:23:06,316 --> 00:23:07,366
更为重要

720
00:23:07,366 --> 00:23:08,496
如果我们知道什么时候会发生

721
00:23:08,496 --> 00:23:09,436
那是更加重要的

722
00:23:10,656 --> 00:23:12,816
最后 我们在进程

723
00:23:12,816 --> 00:23:13,836
和线程之间的同步方面

724
00:23:13,836 --> 00:23:15,456
遇到了一些阻碍

725
00:23:15,816 --> 00:23:17,196
其他一切都运行良好

726
00:23:17,196 --> 00:23:18,516
Metal 速度很快

727
00:23:18,516 --> 00:23:21,596
我们也有了超精确低方差 VBL

728
00:23:21,596 --> 00:23:22,816
但还是存在一些

729
00:23:22,816 --> 00:23:24,116
同步方面的问题

730
00:23:24,316 --> 00:23:25,906
不过 Apple 帮助我们找到了

731
00:23:25,906 --> 00:23:28,066
更好的方法去发送信号

732
00:23:28,066 --> 00:23:29,446
和在所有的进程与线程之间

733
00:23:29,446 --> 00:23:30,716
进行低调速差异的

734
00:23:30,716 --> 00:23:31,376
同步

735
00:23:33,286 --> 00:23:37,416
我这个 VR 帧的图表

736
00:23:37,496 --> 00:23:38,306
比较复杂

737
00:23:39,466 --> 00:23:40,686
你们中的大多数人

738
00:23:40,686 --> 00:23:41,776
永远不会看到这么深

739
00:23:41,776 --> 00:23:42,686
但我还是想给你们

740
00:23:42,686 --> 00:23:43,066
看一看

741
00:23:43,556 --> 00:23:46,746
HTC Vibe 的

742
00:23:46,746 --> 00:23:48,646
低余辉 OLED 显示屏使用了

743
00:23:48,646 --> 00:23:49,126
全局照明

744
00:23:49,996 --> 00:23:52,146
显示图像上的所有像素

745
00:23:52,146 --> 00:23:54,226
都会在同时在极短时间内闪烁

746
00:23:54,726 --> 00:23:56,276
这在 VR 中很常见

747
00:23:56,276 --> 00:23:57,556
因为头部动作

748
00:23:57,556 --> 00:23:57,936
很快

749
00:23:58,426 --> 00:24:00,676
我们要保证

750
00:23:58,426 --> 00:24:00,676
我们要保证

751
00:24:00,676 --> 00:24:02,506
画面不会在用户眼前

752
00:24:02,506 --> 00:24:03,526
产生拖尾或者撕裂

753
00:24:03,886 --> 00:24:05,566
panel 会照亮

754
00:24:05,566 --> 00:24:07,776
大约 2 毫秒每帧

755
00:24:07,776 --> 00:24:09,266
在它被 GPU 显示之后

756
00:24:09,266 --> 00:24:10,966
因为 panel 需要时间

757
00:24:11,036 --> 00:24:12,326
去充能 然后才可以

758
00:24:12,326 --> 00:24:14,096
发出全局照明脉冲

759
00:24:14,916 --> 00:24:16,266
这里 光子就从

760
00:24:16,266 --> 00:24:17,076
这里出来

761
00:24:17,076 --> 00:24:18,046
我们要在这个序列中

762
00:24:18,106 --> 00:24:19,246
跟踪这个红框

763
00:24:19,636 --> 00:24:23,436
光子在这里

764
00:24:23,436 --> 00:24:24,236
被释放出来

765
00:24:24,836 --> 00:24:25,916
因为这个时机

766
00:24:26,316 --> 00:24:27,706
应用通常会选择一个动作

767
00:24:27,756 --> 00:24:28,926
就像大家已经知道的一样

768
00:24:28,986 --> 00:24:30,986
应用从 IVR compositor 唤醒动作里

769
00:24:30,986 --> 00:24:31,406
选择一个动作

770
00:24:31,646 --> 00:24:33,946
唤醒动作会延迟

771
00:24:33,946 --> 00:24:36,096
并为那个未来的光子释放

772
00:24:36,096 --> 00:24:37,356
发回一个动作

773
00:24:37,616 --> 00:24:39,526
这里是渲染

774
00:24:39,526 --> 00:24:41,146
你把它显示在那里

775
00:24:41,366 --> 00:24:42,386
在中间这里

776
00:24:42,516 --> 00:24:43,796
但光子不会从那里

777
00:24:43,796 --> 00:24:44,056
出去

778
00:24:44,056 --> 00:24:46,916
所以我们必须要

779
00:24:46,916 --> 00:24:49,426
预测 25 毫秒之后的动作

780
00:24:50,076 --> 00:24:54,206
25 毫秒是

781
00:24:54,206 --> 00:24:56,206
两帧再加上运行开始时

782
00:24:56,366 --> 00:24:57,186
那一瞬间

783
00:24:57,236 --> 00:24:58,036
你们已经知道

784
00:24:58,036 --> 00:25:00,516
运行开始是非常重要的

785
00:24:58,036 --> 00:25:00,516
运行开始是非常重要的

786
00:25:00,516 --> 00:25:01,706
我们想要尽可能地

787
00:25:01,706 --> 00:25:04,146
给你们那 11 毫秒 GPU 时间

788
00:25:04,146 --> 00:25:05,826
去给用户展现

789
00:25:05,826 --> 00:25:07,376
最好的画面

790
00:25:08,396 --> 00:25:11,006
最后发生的事

791
00:25:11,006 --> 00:25:11,656
在这里

792
00:25:11,726 --> 00:25:12,736
你们可以看到这一帧

793
00:25:12,736 --> 00:25:14,156
会延伸到

794
00:25:14,156 --> 00:25:14,926
一开始的地方

795
00:25:15,416 --> 00:25:16,906
那是因为这个应用

796
00:25:16,906 --> 00:25:19,486
比较复杂

797
00:25:19,486 --> 00:25:20,526
你的游戏引擎

798
00:25:20,526 --> 00:25:22,566
可能会在暗中这样做

799
00:25:23,356 --> 00:25:24,726
它需要处理

800
00:25:24,726 --> 00:25:26,586
一些物理和输入事件

801
00:25:27,146 --> 00:25:28,386
在这里

802
00:25:28,386 --> 00:25:29,526
这个工作需要占用

803
00:25:29,526 --> 00:25:29,916
一些 CPU 时间

804
00:25:30,496 --> 00:25:32,046
那个代码实际上也需要

805
00:25:32,106 --> 00:25:33,286
动作信息

806
00:25:33,936 --> 00:25:35,346
它需要知道

807
00:25:35,346 --> 00:25:36,526
什么时候按键了

808
00:25:36,526 --> 00:25:37,366
控制器在哪里

809
00:25:37,366 --> 00:25:38,456
也许它正在插入

810
00:25:38,746 --> 00:25:39,576
一些关于动作的东西

811
00:25:39,576 --> 00:25:41,546
或者你在阻挡一些东西

812
00:25:41,796 --> 00:25:42,796
或者你在发射一些东西

813
00:25:43,556 --> 00:25:47,026
所以 实际上这个线程

814
00:25:47,026 --> 00:25:48,146
它会在差不多同时唤醒

815
00:25:48,146 --> 00:25:49,626
因为唤醒动作

816
00:25:49,626 --> 00:25:51,476
给了它这个重要的

817
00:25:51,586 --> 00:25:52,126
同步点

818
00:25:52,466 --> 00:25:53,866
但它会调用

819
00:25:53,866 --> 00:25:55,346
一个不同的 API

820
00:25:55,346 --> 00:25:56,756
因为它正试着获得

821
00:25:56,756 --> 00:25:57,346
一个更远的动作

822
00:25:57,536 --> 00:25:59,106
36 毫秒之后

823
00:25:59,106 --> 00:26:00,776
所以它需要

824
00:25:59,106 --> 00:26:00,776
所以它需要

825
00:26:00,776 --> 00:26:02,746
调用 getDevice

826
00:26:02,746 --> 00:26:04,026
来精确追踪动作

827
00:26:04,406 --> 00:26:06,946
我说这些是为了让你们知道

828
00:26:06,946 --> 00:26:09,636
OpenVR 有一些

829
00:26:09,636 --> 00:26:12,706
很深的 API 让你们用来

830
00:26:12,706 --> 00:26:13,746
调试你们的应用

831
00:26:13,746 --> 00:26:15,856
让你们能够精确预测

832
00:26:15,856 --> 00:26:16,806
头显设备和控制器

833
00:26:16,806 --> 00:26:18,806
将会在哪里

834
00:26:19,236 --> 00:26:21,696
基础就是你需要它们在哪里

835
00:26:21,696 --> 00:26:23,106
你的代码需要它们在哪里

836
00:26:23,106 --> 00:26:24,946
唤醒动作的意义就在于

837
00:26:24,946 --> 00:26:26,526
它在运行开始时就及时

838
00:26:26,526 --> 00:26:28,176
给你一个预测点

839
00:26:28,176 --> 00:26:29,376
你就会知道这些光子

840
00:26:29,376 --> 00:26:30,506
何时会释放出来

841
00:26:31,536 --> 00:26:35,316
最后让我们说一说

842
00:26:35,316 --> 00:26:36,276
你需要做什么

843
00:26:36,276 --> 00:26:37,426
来使用

844
00:26:37,426 --> 00:26:38,366
SteamVr 和 macOS

845
00:26:38,366 --> 00:26:39,656
首先 这是 Steam 上的一个工具

846
00:26:39,656 --> 00:26:41,816
开发者需要安装

847
00:26:41,816 --> 00:26:43,546
Steam 并注册免费账户

848
00:26:43,546 --> 00:26:44,906
才能开始

849
00:26:45,696 --> 00:26:47,626
如果你们还没有使用 Steam 

850
00:26:47,626 --> 00:26:47,996
快开始用吧

851
00:26:49,336 --> 00:26:51,086
接下来是安装 SteamVR 本身

852
00:26:51,166 --> 00:26:53,066
SteamVR 在工具中的

853
00:26:53,066 --> 00:26:53,946
Library 菜单里

854
00:26:54,296 --> 00:26:56,046
搜索 SteamVR 右键点击

855
00:26:56,046 --> 00:26:58,366
选择 Properties

856
00:26:58,366 --> 00:27:00,246
选择 Beta

857
00:26:58,366 --> 00:27:00,246
选择 Beta

858
00:27:00,246 --> 00:27:00,776
进入 Beta

859
00:27:01,246 --> 00:27:02,006
现在还是 beta 版本

860
00:27:02,316 --> 00:27:03,206
然后安装它

861
00:27:03,206 --> 00:27:04,566
我们会保持 SteamVR 的更新

862
00:27:04,566 --> 00:27:05,946
你们发现 bug 后我们就会去修复

863
00:27:07,166 --> 00:27:08,346
最后 你们要去 GitHub

864
00:27:08,346 --> 00:27:09,896
下载 OpenVR header 和

865
00:27:09,896 --> 00:27:11,686
框架

866
00:27:11,686 --> 00:27:12,796
我在这里放了一个链接

867
00:27:15,556 --> 00:27:17,096
这是最酷的部分

868
00:27:17,656 --> 00:27:18,886
你要把 OpenVR

869
00:27:18,886 --> 00:27:20,766
bootstrapping 框架

870
00:27:20,766 --> 00:27:21,526
放到你的应用里

871
00:27:22,106 --> 00:27:24,166
你链接到的 OpenVR 框架

872
00:27:24,166 --> 00:27:25,756
表达了你构建

873
00:27:25,756 --> 00:27:27,216
并测试的

874
00:27:27,216 --> 00:27:28,436
runtime 界面的版本

875
00:27:29,146 --> 00:27:30,866
这会让我们能

876
00:27:30,946 --> 00:27:32,736
升级 runtime 和进行

877
00:27:32,736 --> 00:27:33,616
版本更新

878
00:27:33,616 --> 00:27:35,306
我们会很积极地

879
00:27:35,536 --> 00:27:36,196
进行更新

880
00:27:36,386 --> 00:27:38,376
在 Xcode 里 不要去把框架

881
00:27:38,376 --> 00:27:39,146
添加到你的 link phase

882
00:27:39,146 --> 00:27:40,796
而应该到通用设置里

883
00:27:40,986 --> 00:27:42,216
把它设置成 embedded binary （嵌入式二进制文件）

884
00:27:42,216 --> 00:27:43,786
它会被安装到

885
00:27:43,786 --> 00:27:45,136
你的应用程序包里的

886
00:27:45,136 --> 00:27:46,086
内容框架部分

887
00:27:46,896 --> 00:27:50,506
好了 最后 我们真的需要

888
00:27:50,506 --> 00:27:51,296
你们的反馈

889
00:27:51,476 --> 00:27:53,016
因此 我们直接在

890
00:27:53,016 --> 00:27:54,426
vrmonitor 的 UI 里放了一些东西

891
00:27:54,426 --> 00:27:56,266
有个指针可以直接到 SteamVR 的

892
00:27:56,266 --> 00:27:57,756
支持网站和硬件

893
00:27:57,756 --> 00:27:58,756
讨论群

894
00:27:59,046 --> 00:28:00,646
你可以上报 bug

895
00:27:59,046 --> 00:28:00,646
你可以上报 bug

896
00:28:00,646 --> 00:28:01,976
制作系统报告并

897
00:28:01,976 --> 00:28:03,306
发送给我们 也可以直接发到我手上

898
00:28:03,306 --> 00:28:05,476
我的邮箱地址是

899
00:28:05,476 --> 00:28:07,736
natb@valvesoftware.com

900
00:28:07,736 --> 00:28:08,586
不过我更希望你们使用这个工具

901
00:28:09,196 --> 00:28:12,396
非常感谢大家

902
00:28:12,396 --> 00:28:13,826
我真的很期待看到

903
00:28:13,826 --> 00:28:15,306
你们使用 VR 的工作成果

904
00:28:15,376 --> 00:28:16,616
还要谢谢 Apple 的每个人

905
00:28:16,616 --> 00:28:18,246
让 VR 在 macOS 上发光

906
00:28:19,336 --> 00:28:19,716
谢谢大家

907
00:28:20,516 --> 00:28:22,636
[掌声]

908
00:28:23,136 --> 00:28:23,576
&gt;&gt; 谢谢 Nat

909
00:28:24,886 --> 00:28:25,926
与 Valve 合作非常愉快

910
00:28:25,926 --> 00:28:27,376
此时此刻 我仍然

911
00:28:27,376 --> 00:28:28,236
震惊于我们在过去一年

912
00:28:28,236 --> 00:28:29,636
所取得的成绩

913
00:28:31,206 --> 00:28:31,816
好了

914
00:28:31,816 --> 00:28:33,506
我们接着谈谈

915
00:28:33,506 --> 00:28:35,466
我们在 macOS High Sierra 里添加的

916
00:28:35,466 --> 00:28:37,296
外接 GPU 支持吧

917
00:28:37,986 --> 00:28:40,816
外接 GPU 是一个

918
00:28:40,816 --> 00:28:42,196
独立的底盘 上面

919
00:28:42,306 --> 00:28:44,436
有个桌面级别的 GPU

920
00:28:44,436 --> 00:28:47,146
可以通过 thunderbolt

921
00:28:47,146 --> 00:28:48,926
直接插到主系统上

922
00:28:49,856 --> 00:28:52,186
之前说过

923
00:28:52,466 --> 00:28:54,216
这样做的主要原因

924
00:28:54,216 --> 00:28:55,876
是让你们这样的开发者能够

925
00:28:55,876 --> 00:28:58,166
使用更多样的 Mac 硬件

926
00:28:58,256 --> 00:28:59,936
去制作更出色的 VR App

927
00:29:00,686 --> 00:29:02,196
这是个很棒的 workflow

928
00:29:02,196 --> 00:29:03,436
你可以用你的 MacBook Pro

929
00:29:03,436 --> 00:29:05,996
和外接 GPU

930
00:29:06,236 --> 00:29:07,946
来获得制作 VR 应用所需的

931
00:29:07,946 --> 00:29:08,696
渲染性能

932
00:29:08,696 --> 00:29:11,466
当然 这还能为

933
00:29:11,466 --> 00:29:12,896
其他 GPU 应用场景

934
00:29:12,936 --> 00:29:15,086
提供额外的性能支持

935
00:29:15,086 --> 00:29:17,506
比如游戏和专业 App

936
00:29:18,576 --> 00:29:22,706
大家在周一了解过了

937
00:29:22,706 --> 00:29:24,246
我们和 Sonnet 与 AMD 合作

938
00:29:24,246 --> 00:29:26,426
为你们提供了一个

939
00:29:26,426 --> 00:29:28,666
外部图像开发者套装

940
00:29:28,706 --> 00:29:32,226
里面有一块 AMD Radeon RX-580 GPU

941
00:29:32,556 --> 00:29:34,616
这个套装已经优化过

942
00:29:34,616 --> 00:29:36,106
适配所有的能兼容 Thunderbolt3

943
00:29:36,106 --> 00:29:37,966
的 Mac 设备

944
00:29:37,966 --> 00:29:38,906
今天就能通过开发者计划

945
00:29:38,906 --> 00:29:40,626
购买这个套装

946
00:29:41,236 --> 00:29:41,966
好了

947
00:29:42,246 --> 00:29:44,066
接下来讲要如何

948
00:29:44,066 --> 00:29:45,846
识别外接 GPU

949
00:29:46,556 --> 00:29:48,116
这个设备枚举代码

950
00:29:48,116 --> 00:29:49,196
看上去应该很不陌生

951
00:29:50,616 --> 00:29:52,646
CopyAllDevices 会显示出

952
00:29:52,646 --> 00:29:54,166
系统中所有支持 Metal 的设备

953
00:29:54,906 --> 00:29:56,336
然后你可以识别出

954
00:29:56,336 --> 00:29:58,626
外部 GPU 了 方法就是

955
00:29:58,626 --> 00:30:00,576
识别设备的

956
00:29:58,626 --> 00:30:00,576
识别设备的

957
00:30:00,576 --> 00:30:00,976
可删除属性就可以了

958
00:30:01,976 --> 00:30:03,466
这和你们之前

959
00:30:03,546 --> 00:30:04,936
识别我们平台上的

960
00:30:04,936 --> 00:30:06,646
低电量设备的方法很类似

961
00:30:06,646 --> 00:30:10,336
现在 我们来稍微讲一下

962
00:30:10,336 --> 00:30:11,246
Thunderbolt 带宽功能

963
00:30:12,816 --> 00:30:15,086
Thunderbolt 3 提供的

964
00:30:15,146 --> 00:30:16,386
理论带宽是

965
00:30:16,436 --> 00:30:18,326
Thunderbolt 2 的两倍 这很好

966
00:30:19,166 --> 00:30:20,406
但不要忘了

967
00:30:20,406 --> 00:30:21,806
这只不过是

968
00:30:21,806 --> 00:30:24,056
我们平台上

969
00:30:24,306 --> 00:30:25,956
内置 GPU 总线驱动带宽

970
00:30:25,956 --> 00:30:27,116
的四分之一而已

971
00:30:28,356 --> 00:30:29,286
这很重要

972
00:30:29,906 --> 00:30:31,586
你现在可以选择

973
00:30:31,586 --> 00:30:33,896
是使用带宽更高的

974
00:30:34,006 --> 00:30:36,426
内置 GPU

975
00:30:36,516 --> 00:30:38,656
还是使用大约

976
00:30:38,656 --> 00:30:39,926
四分之一带宽的

977
00:30:39,926 --> 00:30:40,466
高性能外接 GPU

978
00:30:41,126 --> 00:30:43,536
在决定使用哪个 GPU 的时候

979
00:30:43,536 --> 00:30:45,056
要把带宽的因素

980
00:30:45,056 --> 00:30:47,486
也考虑进去

981
00:30:48,816 --> 00:30:50,606
此外 用户现在可以

982
00:30:50,606 --> 00:30:52,706
在不同的 GPU 上接不同的显示设备了

983
00:30:52,896 --> 00:30:55,746
在这个环境下

984
00:30:55,746 --> 00:30:57,746
要使用一个 GPU 渲染

985
00:30:58,006 --> 00:30:59,576
另一个 GPU 显示的话 就会有个缺点

986
00:30:59,576 --> 00:31:00,516
因为数据需要

987
00:30:59,576 --> 00:31:00,516
因为数据需要

988
00:31:00,516 --> 00:31:02,226
通过链接传输

989
00:31:03,736 --> 00:31:05,046
所以 内容会在哪里显示

990
00:31:05,106 --> 00:31:08,946
这是你在决定使用哪个 GPU 时

991
00:31:08,946 --> 00:31:10,526
必须要考虑的

992
00:31:10,646 --> 00:31:12,176
一个重要因素

993
00:31:13,606 --> 00:31:14,206
这添加了一些

994
00:31:14,206 --> 00:31:15,106
复杂性

995
00:31:15,856 --> 00:31:16,806
但幸好

996
00:31:16,866 --> 00:31:18,566
你可以做一点

997
00:31:18,566 --> 00:31:20,156
简单的事情 让你的 App

998
00:31:20,216 --> 00:31:21,656
在多 GPU 环境下

999
00:31:21,656 --> 00:31:22,196
表现良好

1000
00:31:23,136 --> 00:31:24,116
我们先讲 GPU 的选择

1001
00:31:25,646 --> 00:31:27,066
我们强烈建议

1002
00:31:27,066 --> 00:31:29,836
你使用同一块 GPU

1003
00:31:29,836 --> 00:31:31,516
渲染和驱动你 App 的

1004
00:31:31,516 --> 00:31:31,916
显示设备

1005
00:31:32,506 --> 00:31:34,306
我把这称为 GPU 选择的

1006
00:31:34,306 --> 00:31:35,116
黄金法则

1007
00:31:36,216 --> 00:31:37,356
我们展开一下

1008
00:31:37,356 --> 00:31:38,306
制作一个决策树

1009
00:31:39,756 --> 00:31:41,186
如果你的 App 渲染的内容

1010
00:31:41,226 --> 00:31:43,226
会被显示出来

1011
00:31:43,226 --> 00:31:46,006
你就要去选择

1012
00:31:46,656 --> 00:31:48,436
驱动那个显示设备的 GPU

1013
00:31:48,656 --> 00:31:49,596
这是我们的黄金法则

1014
00:31:50,776 --> 00:31:51,936
但是如果你的 App

1015
00:31:51,976 --> 00:31:53,986
要进行计算或者其他

1016
00:31:53,986 --> 00:31:55,956
离线渲染操作

1017
00:31:55,956 --> 00:31:57,616
那你就要决定是否要

1018
00:31:57,616 --> 00:31:59,526
使用低能耗 GPU 了

1019
00:31:59,526 --> 00:32:00,116
如果可能的话

1020
00:31:59,526 --> 00:32:00,116
如果可能的话

1021
00:32:01,126 --> 00:32:02,646
这在移动设备上

1022
00:32:02,646 --> 00:32:04,006
尤其有用

1023
00:32:04,276 --> 00:32:05,596
因为选择这个设备

1024
00:32:05,666 --> 00:32:07,136
会极大地节省电量

1025
00:32:07,916 --> 00:32:09,066
但当然 如果你

1026
00:32:09,066 --> 00:32:11,186
需要把 GPU 性能用在 VR 上面

1027
00:32:11,186 --> 00:32:12,546
你就得选择

1028
00:32:12,546 --> 00:32:14,216
外接 GPU 了

1029
00:32:14,216 --> 00:32:17,126
我们回到黄金法则上

1030
00:32:17,126 --> 00:32:19,256
看看要如何

1031
00:32:19,256 --> 00:32:21,196
识别驱动特定显示的

1032
00:32:21,196 --> 00:32:22,556
Metal 设备吧

1033
00:32:23,866 --> 00:32:24,806
你们会发现

1034
00:32:24,876 --> 00:32:25,766
这是很容易的

1035
00:32:26,496 --> 00:32:27,576
有一个现有的

1036
00:32:27,576 --> 00:32:29,416
图像 API 会让你

1037
00:32:29,416 --> 00:32:30,176
识别这个设备

1038
00:32:30,996 --> 00:32:32,646
你只需要得到你的窗口

1039
00:32:33,216 --> 00:32:34,586
所在的显示设备的 ID

1040
00:32:34,586 --> 00:32:36,026
方法就是去询问

1041
00:32:36,026 --> 00:32:36,906
NSScreenNumber

1042
00:32:37,636 --> 00:32:39,516
然后调用

1043
00:32:39,576 --> 00:32:42,116
CGDirectDisplayCopyCurrentMetalDevice

1044
00:32:42,116 --> 00:32:44,076
来获取驱动这个显示的

1045
00:32:44,146 --> 00:32:45,346
Metal 设备

1046
00:32:46,036 --> 00:32:46,606
就这么简单

1047
00:32:46,606 --> 00:32:47,306
好了

1048
00:32:49,236 --> 00:32:51,586
我们已经知道

1049
00:32:51,586 --> 00:32:53,056
每个显示设备

1050
00:32:53,056 --> 00:32:55,346
都可以接到不同的 GPU 上

1051
00:32:55,346 --> 00:32:57,656
你的 App 就需要在显示移动时

1052
00:32:57,656 --> 00:32:58,706
操作 GPU 的迁移

1053
00:32:59,116 --> 00:33:00,566
不好意思 我是说在你的窗口

1054
00:32:59,116 --> 00:33:00,566
不好意思 我是说在你的窗口

1055
00:33:00,566 --> 00:33:01,706
在这些显示中移动的时候

1056
00:33:03,776 --> 00:33:05,586
你可以通过

1057
00:33:05,656 --> 00:33:07,646
注册新的

1058
00:33:07,646 --> 00:33:08,946
其实不是新的 是我们已有的

1059
00:33:09,376 --> 00:33:10,926
通知管理 叫做

1060
00:33:11,206 --> 00:33:12,896
WindowDidChangeScreen 来实现这一点

1061
00:33:12,896 --> 00:33:14,416
我们看一看你们要

1062
00:33:14,416 --> 00:33:15,826
如何处理这个通知管理

1063
00:33:16,406 --> 00:33:18,506
首先要找到

1064
00:33:18,596 --> 00:33:21,406
你的 App 现在所在的显示的

1065
00:33:21,406 --> 00:33:23,286
Metal 设备 方法就是

1066
00:33:23,286 --> 00:33:24,626
调用我们刚才说过的

1067
00:33:24,626 --> 00:33:26,196
核心图像 API

1068
00:33:27,476 --> 00:33:28,586
如果这就是你当前正在

1069
00:33:28,586 --> 00:33:29,646
渲染的同一个设备

1070
00:33:29,686 --> 00:33:31,106
那你就能提前完成了 

1071
00:33:31,106 --> 00:33:33,036
因为不需要 GPU 迁移

1072
00:33:33,036 --> 00:33:35,336
然后 你要进行

1073
00:33:35,566 --> 00:33:37,606
设备迁移

1074
00:33:37,606 --> 00:33:39,316
切换到使用新设备

1075
00:33:39,316 --> 00:33:39,966
进行所有渲染

1076
00:33:41,016 --> 00:33:43,236
这就是使用显示

1077
00:33:43,236 --> 00:33:45,246
更改通知来操作

1078
00:33:45,246 --> 00:33:46,376
GPU 迁移

1079
00:33:46,376 --> 00:33:48,166
但外接 GPU

1080
00:33:48,166 --> 00:33:50,076
插入系统

1081
00:33:50,366 --> 00:33:51,756
或者拔出系统时该怎样呢

1082
00:33:53,116 --> 00:33:54,786
Metal 2 推出了

1083
00:33:54,786 --> 00:33:56,526
3 个新通知 在这种情况下

1084
00:33:56,526 --> 00:33:57,146
帮助你

1085
00:33:58,316 --> 00:34:01,016
第一个是 DeviceWasAdded 

1086
00:33:58,316 --> 00:34:01,016
第一个是 DeviceWasAdded 

1087
00:34:01,016 --> 00:34:02,616
适用于外接 GPU 插入时

1088
00:34:03,726 --> 00:34:05,076
DeviceWasRemoved 适用于

1089
00:34:05,116 --> 00:34:06,336
拔出时

1090
00:34:06,336 --> 00:34:08,735
还有 DeviceRemovalRequested

1091
00:34:08,735 --> 00:34:10,896
适用于 OS 准备在未来某个时间点

1092
00:34:10,896 --> 00:34:12,795
移除外接 GPU 的情况

1093
00:34:14,235 --> 00:34:15,406
我们看看你要如何

1094
00:34:15,406 --> 00:34:16,716
注册并响应

1095
00:34:16,716 --> 00:34:18,706
这些通知

1096
00:34:19,815 --> 00:34:21,315
你要使用新的

1097
00:34:21,416 --> 00:34:24,016
CopyAllDevicesWithObserver API

1098
00:34:24,686 --> 00:34:25,786
这是我们在 Metal 2 中新推出的

1099
00:34:26,846 --> 00:34:27,936
这会让你为这些新的

1100
00:34:28,045 --> 00:34:30,416
设备变更通知注册

1101
00:34:30,416 --> 00:34:31,686
handler

1102
00:34:32,686 --> 00:34:34,136
在这个示例里 

1103
00:34:34,136 --> 00:34:35,536
我们只需要调用一个叫

1104
00:34:35,896 --> 00:34:37,266
handleGPUHotPlug 的函数

1105
00:34:37,976 --> 00:34:38,876
我们来看一看

1106
00:34:39,666 --> 00:34:41,126
这真的很简单直接

1107
00:34:41,616 --> 00:34:43,446
你只需要检查

1108
00:34:43,446 --> 00:34:45,216
并直接回应每一条通知

1109
00:34:46,686 --> 00:34:47,676
但我想在这里

1110
00:34:47,676 --> 00:34:48,275
指出几件事

1111
00:34:49,315 --> 00:34:50,966
首先 你的 App

1112
00:34:50,966 --> 00:34:51,896
应该把

1113
00:34:51,946 --> 00:34:53,436
DeviceRemovalRequested

1114
00:34:53,436 --> 00:34:55,696
通知 当成要迁移出

1115
00:34:55,795 --> 00:34:57,966
外接 GPU 的提示

1116
00:34:58,446 --> 00:35:02,216
第二 如果你的 App

1117
00:34:58,446 --> 00:35:02,216
第二 如果你的 App

1118
00:35:02,216 --> 00:35:02,796
没有接收到

1119
00:35:02,796 --> 00:35:04,116
DeviceRemovalRequested

1120
00:35:04,116 --> 00:35:06,016
通知 那它就应该

1121
00:35:06,016 --> 00:35:08,186
把 DeviceWasRemoved 当成

1122
00:35:08,286 --> 00:35:10,246
意外的 GPU 移除

1123
00:35:10,826 --> 00:35:13,646
意外的 GPU 移除是指

1124
00:35:13,646 --> 00:35:15,316
你的外接 GPU 在系统不知情的情况下

1125
00:35:15,436 --> 00:35:17,036
切断了连接

1126
00:35:17,156 --> 00:35:18,566
或者失去了电力

1127
00:35:19,926 --> 00:35:20,986
这就等于

1128
00:35:20,986 --> 00:35:22,196
有人进入了你的系统

1129
00:35:22,196 --> 00:35:24,116
拔掉了 GPU

1130
00:35:24,896 --> 00:35:26,126
既然硬件已经

1131
00:35:26,126 --> 00:35:28,286
不在了 一些 Metal API

1132
00:35:28,286 --> 00:35:30,086
调用就会开始出现错误

1133
00:35:30,646 --> 00:35:32,486
因此你需要在 App 中

1134
00:35:32,536 --> 00:35:33,986
添加防护代码

1135
00:35:33,986 --> 00:35:34,556
以防这种情况发生

1136
00:35:35,146 --> 00:35:36,516
让它能够坚持住

1137
00:35:36,616 --> 00:35:37,786
直到收到迁移通知

1138
00:35:37,786 --> 00:35:39,236
并从容地

1139
00:35:39,236 --> 00:35:41,076
切换到系统中的

1140
00:35:41,076 --> 00:35:41,696
另一块 GPU 上

1141
00:35:42,876 --> 00:35:44,116
还有一点需要指出

1142
00:35:44,296 --> 00:35:45,756
那就是如果你在外接 GPU 的

1143
00:35:45,756 --> 00:35:47,916
本地内存上有临时数据

1144
00:35:47,916 --> 00:35:49,646
你的 App 就可能需要

1145
00:35:49,646 --> 00:35:50,926
重新生成数据 因为它

1146
00:35:50,926 --> 00:35:51,386
已经没有了

1147
00:35:51,386 --> 00:35:52,066
好了

1148
00:35:53,346 --> 00:35:55,666
现在讲一些最佳实践

1149
00:35:56,456 --> 00:35:57,916
我们建议你们

1150
00:35:57,916 --> 00:35:59,716
不要在迁移后立即

1151
00:35:59,966 --> 00:36:02,466
释放设备

1152
00:35:59,966 --> 00:36:02,466
释放设备

1153
00:36:02,466 --> 00:36:04,106
因为用户喜欢在不同显示设备之间

1154
00:36:04,106 --> 00:36:05,066
移动窗口

1155
00:36:05,946 --> 00:36:08,356
所以请

1156
00:36:08,426 --> 00:36:10,126
采用延迟 teardown 策略 留出一些合理时间

1157
00:36:12,136 --> 00:36:14,566
此外 如果你的 App

1158
00:36:14,566 --> 00:36:16,936
有复杂的 UI 有很多窗口

1159
00:36:16,936 --> 00:36:19,366
你也许 也许需要

1160
00:36:19,366 --> 00:36:21,476
分别针对每个窗口

1161
00:36:21,526 --> 00:36:22,306
控制 GPU 迁移

1162
00:36:23,426 --> 00:36:25,526
最后 我们建议

1163
00:36:25,526 --> 00:36:27,086
你在多 GPU 场景下

1164
00:36:27,086 --> 00:36:29,516
存储 App 以保证

1165
00:36:29,516 --> 00:36:30,736
你不需要

1166
00:36:30,736 --> 00:36:32,356
在 GPU 之间来回传送数据

1167
00:36:32,426 --> 00:36:35,986
做无用功

1168
00:36:36,186 --> 00:36:36,446
好了

1169
00:36:36,696 --> 00:36:38,196
我们回到 VR 上来

1170
00:36:38,196 --> 00:36:39,816
看一看这种使用场景下的

1171
00:36:39,816 --> 00:36:40,676
最佳实践

1172
00:36:41,816 --> 00:36:44,156
首先 最明显的

1173
00:36:44,156 --> 00:36:45,616
保证你把 VR 头显设备

1174
00:36:45,736 --> 00:36:47,536
直接插到外接 GPU 上

1175
00:36:48,836 --> 00:36:50,076
不那么明显但同样重要的是

1176
00:36:50,076 --> 00:36:51,766
你要确保你的 App

1177
00:36:51,766 --> 00:36:53,256
把它的 UI 或是

1178
00:36:53,256 --> 00:36:56,256
镜像 VR 内容

1179
00:36:56,256 --> 00:36:57,746
显示到同样被

1180
00:36:57,746 --> 00:36:59,336
外接 GPU 驱动的显示器上

1181
00:37:00,036 --> 00:37:01,206
这会确保

1182
00:37:01,206 --> 00:37:03,626
VR compositor 和你的 App

1183
00:37:03,626 --> 00:37:05,316
都使用外接 GPU 进行渲染

1184
00:37:05,906 --> 00:37:08,396
最后 要保证你

1185
00:37:08,396 --> 00:37:10,846
在外接 GPU 的本地内存上

1186
00:37:10,846 --> 00:37:12,556
存储尽可能多的数据

1187
00:37:12,906 --> 00:37:14,226
这样你就不需要通过

1188
00:37:14,226 --> 00:37:15,416
Thunderbolt 链接传输数据了

1189
00:37:15,416 --> 00:37:17,016
除非这是绝对必要的

1190
00:37:18,216 --> 00:37:19,236
好了

1191
00:37:20,376 --> 00:37:22,096
这就是今天讲座的

1192
00:37:22,096 --> 00:37:22,826
全部内容

1193
00:37:23,046 --> 00:37:24,386
我们来快速回顾一下

1194
00:37:24,386 --> 00:37:25,196
今天谈到的东西

1195
00:37:25,476 --> 00:37:27,676
最重要的是你们现在

1196
00:37:27,676 --> 00:37:29,526
可以在 macOS 上开发 VR 内容了

1197
00:37:31,376 --> 00:37:32,886
我们添加了对 HTC Vibe 头显设备的

1198
00:37:33,126 --> 00:37:34,716
内置支持

1199
00:37:35,336 --> 00:37:37,366
我们与 Valve 合作

1200
00:37:37,366 --> 00:37:39,296
为在我们平台上的 SteamVR

1201
00:37:39,546 --> 00:37:41,046
runtime 推出了一个

1202
00:37:41,046 --> 00:37:43,106
优化版本的 Metal

1203
00:37:44,966 --> 00:37:46,216
此外 两个最流行的

1204
00:37:46,306 --> 00:37:48,486
游戏引擎 Unity

1205
00:37:48,486 --> 00:37:50,566
和虚幻 4 会在不久的将来

1206
00:37:50,636 --> 00:37:52,596
在 Mac 中加入 VR 支持

1207
00:37:53,766 --> 00:37:55,406
但当然 我们也鼓励

1208
00:37:55,406 --> 00:37:56,806
你们构建自己的原生 VR

1209
00:37:56,806 --> 00:37:57,296
App

1210
00:37:58,126 --> 00:37:59,726
最后 我们还添加了

1211
00:37:59,726 --> 00:38:00,626
对外接 GPU 的支持

1212
00:37:59,726 --> 00:38:00,626
对外接 GPU 的支持

1213
00:38:00,626 --> 00:38:02,846
我们希望这能

1214
00:38:02,846 --> 00:38:04,606
让你保证你的 App

1215
00:38:04,746 --> 00:38:06,946
在多 GPU 环境下

1216
00:38:06,946 --> 00:38:08,326
表现良好

1217
00:38:08,376 --> 00:38:09,376
让你们能利用上

1218
00:38:09,376 --> 00:38:10,706
外接 GPU 的强劲性能

1219
00:38:12,696 --> 00:38:14,746
我们非常期待看到

1220
00:38:14,746 --> 00:38:15,696
你们使用这个新技术

1221
00:38:15,696 --> 00:38:17,206
创造出的成果

1222
00:38:18,436 --> 00:38:19,396
一定要记得去

1223
00:38:19,396 --> 00:38:20,406
看 Metal Track 的

1224
00:38:20,406 --> 00:38:20,756
其他讲座

1225
00:38:21,086 --> 00:38:22,666
昨天有一场很棒的

1226
00:38:22,666 --> 00:38:23,706
Introducing Metal 2 讲座

1227
00:38:23,706 --> 00:38:24,826
如果你们没赶上

1228
00:38:24,926 --> 00:38:26,126
我建议你们去上网

1229
00:38:26,176 --> 00:38:27,186
看一看

1230
00:38:28,076 --> 00:38:29,466
我们明天下午

1231
00:38:29,466 --> 00:38:30,766
还有两场讲座

1232
00:38:31,336 --> 00:38:32,726
Metal 2 Optimization and

1233
00:38:32,726 --> 00:38:34,696
Debugging 和 Using Metal 2 for

1234
00:38:34,696 --> 00:38:35,136
Compute

1235
00:38:35,326 --> 00:38:36,636
我们希望在那里见到你们

1236
00:38:37,516 --> 00:38:38,196
我会去的

1237
00:38:38,196 --> 00:38:39,286
非常感谢大家

1238
00:38:39,336 --> 00:38:40,476
祝你们在 WWDC 大有收获

1239
00:38:41,016 --> 00:38:43,000
[掌声]
