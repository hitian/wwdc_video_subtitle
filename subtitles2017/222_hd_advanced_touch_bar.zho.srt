1
00:00:17,551 --> 00:00:22,055
<c.magenta>（高级触控条 演讲222）</c>

2
00:00:23,156 --> 00:00:23,991
<c.magenta>大家好</c>

3
00:00:27,394 --> 00:00:29,396
<c.magenta>我是唐娜·汤姆</c>

4
00:00:29,997 --> 00:00:32,499
<c.magenta>今天我的同事AppKit工程师</c>

5
00:00:33,100 --> 00:00:34,902
<c.magenta>杰夫·纳多和泰勒·凯利</c>

6
00:00:34,968 --> 00:00:36,770
<c.magenta>我们非常激动能跟大家谈谈</c>

7
00:00:36,837 --> 00:00:38,338
<c.magenta>触控条的高级概念</c>

8
00:00:39,473 --> 00:00:41,708
<c.magenta>但愿你们观看了</c>

9
00:00:41,775 --> 00:00:43,844
<c.magenta>或参加了今天早些时候的</c>

10
00:00:44,077 --> 00:00:46,847
<c.magenta>如果你没有在家关注那场演讲</c>

11
00:00:47,648 --> 00:00:48,815
<c.magenta>若你现已在此</c>

12
00:00:50,984 --> 00:00:52,619
<c.magenta>那是一场很棒的演讲</c>

13
00:00:52,686 --> 00:00:54,221
<c.magenta>如果有时间就看一下视频</c>

14
00:00:55,155 --> 00:00:57,958
<c.magenta>你可以了解如何</c>

15
00:00:58,025 --> 00:00:59,593
<c.magenta>以及如何使用它的输入功能</c>

16
00:00:59,660 --> 00:01:01,895
<c.magenta>来提升你应用的用户体验</c>

17
00:00:59,660 --> 00:01:01,895
<c.magenta>来提升你应用的用户体验</c>

18
00:01:02,963 --> 00:01:04,464
<c.magenta>而且你可以方便地利用触控条</c>

19
00:01:04,531 --> 00:01:07,000
<c.magenta>就通过你在那场Fundamental演讲中</c>

20
00:01:08,268 --> 00:01:10,370
<c.magenta>但你们参加这场演讲的原因</c>

21
00:01:10,437 --> 00:01:11,905
<c.magenta>来提升你的应用</c>

22
00:01:12,339 --> 00:01:14,241
<c.magenta>也许你想自定义</c>

23
00:01:14,308 --> 00:01:15,976
<c.magenta>如邮件应用的</c>

24
00:01:16,043 --> 00:01:17,611
<c.magenta>邮件自动完成项</c>

25
00:01:18,612 --> 00:01:20,681
<c.magenta>或者也许你想给你的应用</c>

26
00:01:20,981 --> 00:01:23,217
<c.magenta>以便用户可以快速滚动并选择内容</c>

27
00:01:23,617 --> 00:01:24,985
<c.magenta>比如日历的日期选择器</c>

28
00:01:26,019 --> 00:01:29,590
<c.magenta>或者也许你甚至希望添加</c>

29
00:01:29,957 --> 00:01:31,191
<c.magenta>比如系统颜色选择器</c>

30
00:01:31,925 --> 00:01:32,993
<c.magenta>那么在本场演讲中</c>

31
00:01:33,060 --> 00:01:35,329
<c.magenta>我们会向大家介绍如何创建这些东西</c>

32
00:01:35,395 --> 00:01:37,798
<c.magenta>我们会深入到技术点和最佳范例</c>

33
00:01:38,198 --> 00:01:40,033
<c.magenta>来自定义标准组件</c>

34
00:01:40,200 --> 00:01:42,002
<c.magenta>以及创建你自己的自定义控件</c>

35
00:01:42,069 --> 00:01:45,472
<c.magenta>让你有能力、灵活地来为用户</c>

36
00:01:47,207 --> 00:01:49,910
<c.magenta>那么首先是自定义TextBars</c>

37
00:01:51,845 --> 00:01:53,881
<c.magenta>我们要从标准项开始讲</c>

38
00:01:54,481 --> 00:01:56,149
<c.magenta>然后会讲</c>

39
00:01:56,216 --> 00:01:58,986
<c.magenta>如何禁用标准项</c>

40
00:01:59,920 --> 00:02:02,055
<c.magenta>最后我们要了解补充列表项</c>

41
00:01:59,920 --> 00:02:02,055
<c.magenta>最后我们要了解补充列表项</c>

42
00:02:02,389 --> 00:02:04,758
<c.magenta>而且我们会看一下</c>

43
00:02:04,825 --> 00:02:06,393
<c.magenta>类似于你在Mail应用中看到的那样</c>

44
00:02:10,964 --> 00:02:12,733
<c.magenta>那么让我们从标准项开始讲吧</c>

45
00:02:13,600 --> 00:02:16,503
<c.magenta>现在我们给标准TextBars</c>

46
00:02:16,737 --> 00:02:19,540
<c.magenta>如果你使用TextView或TextField</c>

47
00:02:19,940 --> 00:02:22,709
<c.magenta>这些组件在方框外也支持NSTouchBar</c>

48
00:02:22,776 --> 00:02:23,744
<c.magenta>（标准项）</c>

49
00:02:23,810 --> 00:02:25,546
<c.magenta>现在当TextView或TextField</c>

50
00:02:26,079 --> 00:02:29,216
<c.magenta>是你应用的第一响应器时</c>

51
00:02:29,283 --> 00:02:30,784
<c.magenta>填充由控件属性</c>

52
00:02:30,851 --> 00:02:32,686
<c.magenta>和内容驱动的触控项</c>

53
00:02:33,287 --> 00:02:34,888
<c.magenta>那么默认情况是这样的</c>

54
00:02:36,890 --> 00:02:39,459
<c.magenta>QuickType建议</c>

55
00:02:39,526 --> 00:02:41,195
<c.magenta>通过使用左侧的小尖括号</c>

56
00:02:41,962 --> 00:02:43,997
<c.magenta>上边的触控条显示的是折叠时的样子</c>

57
00:02:44,298 --> 00:02:46,733
<c.magenta>而下边的触控条显示的是展开时的样子</c>

58
00:02:48,135 --> 00:02:51,271
<c.magenta>你还会得到一个表情选择器</c>

59
00:02:51,338 --> 00:02:52,339
<c.magenta>（表情选择器）</c>

60
00:02:52,406 --> 00:02:55,943
<c.magenta>如果启用了富文本</c>

61
00:02:56,009 --> 00:02:57,678
<c.magenta>（颜色选择器）</c>

62
00:02:57,744 --> 00:02:58,745
<c.magenta>格式控件</c>

63
00:02:58,812 --> 00:02:59,980
<c.magenta>（格式）</c>

64
00:03:00,047 --> 00:03:02,149
<c.magenta>以及对齐和列表控件</c>

65
00:03:02,983 --> 00:03:06,620
<c.magenta>当你使用NSTextView或NSTextField时</c>

66
00:03:06,820 --> 00:03:08,789
<c.magenta>你不用写一行代码</c>

67
00:03:10,457 --> 00:03:12,492
<c.magenta>但是这些到底是如何工作的呢？</c>

68
00:03:13,160 --> 00:03:13,994
<c.magenta>嗯</c>

69
00:03:14,895 --> 00:03:17,564
<c.magenta>NSTextView和NSTouchBar的整合</c>

70
00:03:17,631 --> 00:03:19,633
<c.magenta>以便提供很棒的功能</c>

71
00:03:20,567 --> 00:03:23,203
<c.magenta>因为触控条中的触控项</c>

72
00:03:23,270 --> 00:03:25,038
<c.magenta>根据所输入文本的内容</c>

73
00:03:25,439 --> 00:03:27,641
<c.magenta>NSTextView实际上将自己作为了</c>

74
00:03:27,708 --> 00:03:30,244
<c.magenta>它自己的NSTouchBar实例委托</c>

75
00:03:31,211 --> 00:03:35,182
<c.magenta>如果你使用NSTextField</c>

76
00:03:35,249 --> 00:03:37,618
<c.magenta>的作用是当前激活的</c>

77
00:03:38,519 --> 00:03:40,821
<c.magenta>那么当你在TextField</c>

78
00:03:41,121 --> 00:03:44,491
<c.magenta>这与包含NSTouchBar</c>

79
00:03:46,059 --> 00:03:49,029
<c.magenta>字段编辑器的触控条</c>

80
00:03:50,230 --> 00:03:52,299
<c.magenta>就字段编辑器这个话题</c>

81
00:03:52,666 --> 00:03:55,869
<c.magenta>请记住字段编辑器是在窗口中的</c>

82
00:03:56,236 --> 00:03:58,639
<c.magenta>所以如果你修改字段编辑器的触控条</c>

83
00:03:58,972 --> 00:04:02,242
<c.magenta>这些修改同样也会影响</c>

84
00:03:58,972 --> 00:04:02,242
<c.magenta>这些修改同样也会影响</c>

85
00:04:02,476 --> 00:04:04,478
<c.magenta>这是一个需要时刻谨记的重要概念</c>

86
00:04:04,545 --> 00:04:05,779
<c.magenta>尤其当你处理文本字段时</c>

87
00:04:05,846 --> 00:04:07,381
<c.magenta>（标准触控项</c>

88
00:04:07,848 --> 00:04:11,285
<c.magenta>那么现在我们了解了更多关于</c>

89
00:04:11,351 --> 00:04:13,287
<c.magenta>让我们谈谈如何禁用标注触控项</c>

90
00:04:13,353 --> 00:04:14,354
<c.magenta>（禁用标准触控项）</c>

91
00:04:14,421 --> 00:04:15,656
<c.magenta>其实非常简单</c>

92
00:04:15,856 --> 00:04:18,024
<c.magenta>你所要做的就是设置相应的属性</c>

93
00:04:18,225 --> 00:04:19,860
<c.magenta>在textView或textField上</c>

94
00:04:20,861 --> 00:04:22,162
<c.magenta>当你设置这些属性时</c>

95
00:04:22,663 --> 00:04:24,531
<c.magenta>textView会自动得到一个通知</c>

96
00:04:24,831 --> 00:04:27,801
<c.magenta>说它的触控条项需要更新</c>

97
00:04:29,503 --> 00:04:32,773
<c.magenta>QuickType和表情选择器</c>

98
00:04:33,440 --> 00:04:36,543
<c.magenta>其余的标准触控项都是文本样式控件</c>

99
00:04:37,244 --> 00:04:41,648
<c.magenta>并且只有在文本字段</c>

100
00:04:41,715 --> 00:04:44,551
<c.magenta>如果没有启用富文本</c>

101
00:04:46,153 --> 00:04:49,256
<c.magenta>在你在全部文本控件中</c>

102
00:04:49,523 --> 00:04:51,024
<c.magenta>请考虑一下你的用户</c>

103
00:04:53,527 --> 00:04:55,863
<c.magenta>我知道你们中有一些人</c>

104
00:04:56,263 --> 00:04:59,766
<c.magenta>但我想强调的是你们的用户</c>

105
00:05:00,267 --> 00:05:04,371
<c.magenta>事实上 你的用户可以</c>

106
00:05:04,705 --> 00:05:07,307
<c.magenta>可以通过这里显示的系统偏好窗格</c>

107
00:05:07,374 --> 00:05:10,043
<c.magenta>或通过自定义他们的触控条实现</c>

108
00:05:10,444 --> 00:05:12,412
<c.magenta>所以请考虑</c>

109
00:05:12,479 --> 00:05:15,148
<c.magenta>并允许你的用户自己决定是否使用</c>

110
00:05:17,451 --> 00:05:19,520
<c.magenta>那么现在我们了解了</c>

111
00:05:19,586 --> 00:05:21,588
<c.magenta>让我们来谈谈如何</c>

112
00:05:22,823 --> 00:05:23,891
<c.magenta>（添加自定义触控项）</c>

113
00:05:23,957 --> 00:05:25,359
<c.magenta>那么这里是一些示例触控项</c>

114
00:05:25,425 --> 00:05:28,295
<c.magenta>在TextBar中添加到了</c>

115
00:05:29,429 --> 00:05:32,466
<c.magenta>若你观看了Fundamentals演讲视频</c>

116
00:05:32,533 --> 00:05:35,302
<c.magenta>左侧一直有一个发送邮件按钮</c>

117
00:05:36,003 --> 00:05:37,704
<c.magenta>下边的触控条有一个全选按钮</c>

118
00:05:37,771 --> 00:05:39,806
<c.magenta>就位于表情选择器右边</c>

119
00:05:40,040 --> 00:05:43,310
<c.magenta>那么我要如何在我的TextBar中</c>

120
00:05:45,479 --> 00:05:48,282
<c.magenta>嗯 你可能会很想</c>

121
00:05:49,349 --> 00:05:50,784
<c.magenta>抓住你textField的触控条</c>

122
00:05:51,785 --> 00:05:54,021
<c.magenta>给defaultItemIdentifiers附加新按钮</c>

123
00:05:54,688 --> 00:05:55,689
<c.magenta>就是这样 对吗？</c>

124
00:05:56,623 --> 00:05:59,226
<c.magenta>不 请不要这样做</c>

125
00:05:59,660 --> 00:06:01,195
<c.magenta>你一定会获得一种很糟糕的体验</c>

126
00:05:59,660 --> 00:06:01,195
<c.magenta>你一定会获得一种很糟糕的体验</c>

127
00:06:01,929 --> 00:06:03,864
<c.magenta>为什么？因为文本视图</c>

128
00:06:04,464 --> 00:06:08,235
<c.magenta>需要能基于当前配置</c>

129
00:06:09,803 --> 00:06:11,238
<c.magenta>你将会得到这样的东西</c>

130
00:06:11,705 --> 00:06:13,574
<c.magenta>你会得到一个这样的触控条</c>

131
00:06:13,640 --> 00:06:16,410
<c.magenta>当你添加新按钮之后</c>

132
00:06:17,077 --> 00:06:20,447
<c.magenta>但如果用户在你的应用运行时</c>

133
00:06:21,248 --> 00:06:22,850
<c.magenta>那么文本视图将收到通知</c>

134
00:06:22,916 --> 00:06:25,052
<c.magenta>说需要重设其触控项</c>

135
00:06:25,619 --> 00:06:28,121
<c.magenta>那么它会通过移除现有触控项来实现</c>

136
00:06:28,355 --> 00:06:31,525
<c.magenta>并基于当前配置</c>

137
00:06:32,893 --> 00:06:34,962
<c.magenta>但是请记住</c>

138
00:06:35,362 --> 00:06:36,864
<c.magenta>NSTouchBar实例委托</c>

139
00:06:37,064 --> 00:06:38,432
<c.magenta>所以它会重新创建这些触控项</c>

140
00:06:38,498 --> 00:06:41,401
<c.magenta>通过调用它自己的</c>

141
00:06:42,102 --> 00:06:43,937
<c.magenta>因此它会重新创建QuickType项</c>

142
00:06:46,139 --> 00:06:47,474
<c.magenta>它会重新创建表情选择器</c>

143
00:06:50,010 --> 00:06:53,080
<c.magenta>但它并不知道如何</c>

144
00:06:53,747 --> 00:06:55,516
<c.magenta>所以它就不会</c>

145
00:06:56,683 --> 00:06:57,751
<c.magenta>为了避免这个问题</c>

146
00:06:57,818 --> 00:06:59,553
<c.magenta>你需要一个能应对TextView的方法</c>

147
00:06:59,620 --> 00:07:01,288
<c.magenta>有许多不同的实现方式</c>

148
00:06:59,620 --> 00:07:01,288
<c.magenta>有许多不同的实现方式</c>

149
00:07:02,956 --> 00:07:05,526
<c.magenta>第一种方式是</c>

150
00:07:05,826 --> 00:07:06,994
<c.magenta>来提供自定义触控项</c>

151
00:07:07,594 --> 00:07:08,896
<c.magenta>这是一个好方法</c>

152
00:07:08,962 --> 00:07:11,698
<c.magenta>当你的触控项出现在</c>

153
00:07:11,765 --> 00:07:13,400
<c.magenta>（方法#1：</c>

154
00:07:13,800 --> 00:07:16,503
<c.magenta>而我们之前讲的那个发送邮件的</c>

155
00:07:17,070 --> 00:07:18,705
<c.magenta>那么在这里</c>

156
00:07:18,939 --> 00:07:22,009
<c.magenta>最理想的是把这个按钮放在触控条中</c>

157
00:07:22,209 --> 00:07:23,744
<c.magenta>当写邮件窗口打开时</c>

158
00:07:24,211 --> 00:07:26,713
<c.magenta>那个窗口内的</c>

159
00:07:27,114 --> 00:07:28,815
<c.magenta>是第一响应器并不重要</c>

160
00:07:28,882 --> 00:07:30,717
<c.magenta>无论是哪个</c>

161
00:07:31,385 --> 00:07:34,821
<c.magenta>那么这种情况下最好是</c>

162
00:07:35,022 --> 00:07:36,990
<c.magenta>比如ViewController来提供自定义项</c>

163
00:07:39,092 --> 00:07:40,260
<c.magenta>这是你可能会得到的结果</c>

164
00:07:40,694 --> 00:07:42,129
<c.magenta>在这里我们有ViewController</c>

165
00:07:43,597 --> 00:07:44,965
<c.magenta>我们要覆盖makeTouchBar</c>

166
00:07:47,968 --> 00:07:51,538
<c.magenta>我们要创建我们自己的自定义触控项</c>

167
00:07:54,141 --> 00:07:58,679
<c.magenta>然后我们要创建我们的触控条</c>

168
00:07:58,946 --> 00:07:59,947
<c.magenta>然后我们就返回它</c>

169
00:08:01,348 --> 00:08:03,417
<c.magenta>现在请注意这里使用的</c>

170
00:08:03,717 --> 00:08:05,953
<c.magenta>这将会嵌套字段编辑器中的触控项</c>

171
00:08:06,019 --> 00:08:08,121
<c.magenta>从而使它们出现在</c>

172
00:08:09,556 --> 00:08:12,426
<c.magenta>这就是如何使用较高等级响应器</c>

173
00:08:12,626 --> 00:08:15,062
<c.magenta>在标准触控项基础上</c>

174
00:08:16,830 --> 00:08:19,533
<c.magenta>现在让我们看第二种方式</c>

175
00:08:20,200 --> 00:08:22,970
<c.magenta>这是一个好方法 如果你有一个触控项</c>

176
00:08:23,036 --> 00:08:25,839
<c.magenta>你想让它出现在触控条中</c>

177
00:08:26,173 --> 00:08:28,141
<c.magenta>而当你的TextView</c>

178
00:08:28,509 --> 00:08:29,443
<c.magenta>（子类化NSTextView）</c>

179
00:08:30,010 --> 00:08:32,913
<c.magenta>要知道我是什么意思</c>

180
00:08:33,246 --> 00:08:34,515
<c.magenta>这里我们有一个全选按钮</c>

181
00:08:34,581 --> 00:08:36,549
<c.magenta>可以选中TextView中的</c>

182
00:08:37,451 --> 00:08:39,886
<c.magenta>那么在本例中</c>

183
00:08:40,153 --> 00:08:41,488
<c.magenta>是第一响应器时显示这个按钮</c>

184
00:08:41,554 --> 00:08:43,924
<c.magenta>因为全选按钮在那儿</c>

185
00:08:43,991 --> 00:08:46,927
<c.magenta>如果没有人编辑任何文本</c>

186
00:08:48,262 --> 00:08:51,598
<c.magenta>因此 这种情况</c>

187
00:08:51,865 --> 00:08:54,301
<c.magenta>将按钮放在与标准触控项相同的</c>

188
00:08:54,368 --> 00:08:55,569
<c.magenta>同一个NSTouchBar实例中</c>

189
00:08:58,038 --> 00:08:59,606
<c.magenta>并且要覆盖</c>

190
00:08:59,673 --> 00:09:00,974
<c.magenta>TextView子类中的两个方法</c>

191
00:08:59,673 --> 00:09:00,974
<c.magenta>TextView子类中的两个方法</c>

192
00:09:01,775 --> 00:09:04,278
<c.magenta>一个是updateTouchBar</c>

193
00:09:04,678 --> 00:09:06,046
<c.magenta>你要覆盖这个方法</c>

194
00:09:06,280 --> 00:09:09,616
<c.magenta>是因为每次当TextView的触控条的状态</c>

195
00:09:10,384 --> 00:09:13,387
<c.magenta>并且这个方法是你实际</c>

196
00:09:13,453 --> 00:09:14,788
<c.magenta>来显示你的自定义项</c>

197
00:09:16,156 --> 00:09:17,925
<c.magenta>添加到defaultItemIdentifiers数组</c>

198
00:09:18,692 --> 00:09:20,460
<c.magenta>第二个要覆盖的方法</c>

199
00:09:20,527 --> 00:09:23,130
<c.magenta>是委托方法makeItemForIdentifier</c>

200
00:09:23,630 --> 00:09:26,366
<c.magenta>你要覆盖这个方法</c>

201
00:09:26,433 --> 00:09:28,268
<c.magenta>创建其触控项的方法</c>

202
00:09:28,869 --> 00:09:32,372
<c.magenta>并且这个方法是你创建</c>

203
00:09:34,007 --> 00:09:36,376
<c.magenta>现在有了这两个方法你就可以确保</c>

204
00:09:36,677 --> 00:09:38,712
<c.magenta>调用超类实施</c>

205
00:09:38,779 --> 00:09:41,348
<c.magenta>在做与自定义触控项相关的工作之前</c>

206
00:09:41,748 --> 00:09:44,651
<c.magenta>通过这种方式</c>

207
00:09:44,718 --> 00:09:47,020
<c.magenta>将与标准触控项一起被重新创建</c>

208
00:09:47,521 --> 00:09:49,323
<c.magenta>无论何时TextView</c>

209
00:09:52,426 --> 00:09:54,728
<c.magenta>并且那也包含了</c>

210
00:09:55,095 --> 00:09:57,231
<c.magenta>让我们转过来看一下</c>

211
00:09:58,832 --> 00:10:00,901
<c.magenta>补充列表触控项是一个极好的控件</c>

212
00:09:58,832 --> 00:10:00,901
<c.magenta>补充列表触控项是一个极好的控件</c>

213
00:10:01,168 --> 00:10:04,171
<c.magenta>为你的用户</c>

214
00:10:04,238 --> 00:10:05,472
<c.magenta>（补充列表触控项）</c>

215
00:10:05,539 --> 00:10:07,841
<c.magenta>我们把这些推荐作为补充</c>

216
00:10:10,410 --> 00:10:13,280
<c.magenta>这个触控项也是</c>

217
00:10:13,814 --> 00:10:16,917
<c.magenta>因此在触控条中 每个TextView</c>

218
00:10:17,017 --> 00:10:19,953
<c.magenta>可以通过candidateListTouchBarItem</c>

219
00:10:20,954 --> 00:10:22,856
<c.magenta>请记住你看到的</c>

220
00:10:22,923 --> 00:10:24,091
<c.magenta>带有TextField的补充列表</c>

221
00:10:24,157 --> 00:10:27,127
<c.magenta>实际上是在触控条中与窗口的</c>

222
00:10:28,695 --> 00:10:29,696
<c.magenta>（补充来源）</c>

223
00:10:29,763 --> 00:10:32,432
<c.magenta>补充数据通常有这三种来源</c>

224
00:10:33,333 --> 00:10:35,402
<c.magenta>在QuickType例子中 补充数据</c>

225
00:10:35,469 --> 00:10:36,970
<c.magenta>是由NSSpellChecker提供的</c>

226
00:10:37,871 --> 00:10:40,874
<c.magenta>但你可以配置控件</c>

227
00:10:41,441 --> 00:10:42,609
<c.magenta>比如系统输入方法</c>

228
00:10:42,943 --> 00:10:46,413
<c.magenta>允许你键入中文、日语</c>

229
00:10:46,480 --> 00:10:47,681
<c.magenta>通过一个拉丁语系键盘</c>

230
00:10:48,549 --> 00:10:50,284
<c.magenta>但你们绝大部分人可能感兴趣的是</c>

231
00:10:50,350 --> 00:10:53,086
<c.magenta>可以提供你自己的完全自定义补充列表</c>

232
00:10:53,453 --> 00:10:55,956
<c.magenta>要实现这个目标有两种不同的方式</c>

233
00:10:58,091 --> 00:10:59,826
<c.magenta>第一种方式是使用委托方法</c>

234
00:11:00,561 --> 00:11:01,929
<c.magenta>这个方法的好处</c>

235
00:11:01,995 --> 00:11:04,464
<c.magenta>是它是最简单的 因为TextField</c>

236
00:11:06,834 --> 00:11:09,636
<c.magenta>那么要使用这种方式</c>

237
00:11:09,803 --> 00:11:13,006
<c.magenta>candidatesForSelectedRange</c>

238
00:11:13,674 --> 00:11:17,444
<c.magenta>并且你会获得原始文本控件</c>

239
00:11:18,045 --> 00:11:19,479
<c.magenta>以及文本范围</c>

240
00:11:19,680 --> 00:11:21,682
<c.magenta>你可以用来决定你的补充列表</c>

241
00:11:22,216 --> 00:11:24,885
<c.magenta>那么你可以简单地返回一个</c>

242
00:11:24,952 --> 00:11:26,987
<c.magenta>就会在标准的补充列表中</c>

243
00:11:27,654 --> 00:11:29,690
<c.magenta>现在因为这种方式使用了标准列表</c>

244
00:11:30,290 --> 00:11:32,926
<c.magenta>因此你不需要做什么操作</c>

245
00:11:35,362 --> 00:11:36,296
<c.magenta>第二种方式</c>

246
00:11:36,363 --> 00:11:37,664
<c.magenta>是使用较高等级的响应器</c>

247
00:11:38,632 --> 00:11:41,668
<c.magenta>这种方式的好处是</c>

248
00:11:41,735 --> 00:11:43,437
<c.magenta>而不是字符串</c>

249
00:11:45,372 --> 00:11:47,474
<c.magenta>那么这个类似于较高等级响应器方式</c>

250
00:11:47,541 --> 00:11:50,544
<c.magenta>我们稍早些时候在向触控条中</c>

251
00:11:50,911 --> 00:11:53,280
<c.magenta>在这里你需要使用一个</c>

252
00:11:53,514 --> 00:11:57,017
<c.magenta>来创建你自己的</c>

253
00:11:57,084 --> 00:11:58,986
<c.magenta>并用那个取代标准触控项</c>

254
00:11:59,052 --> 00:12:00,387
<c.magenta>（使用较高等级响应器）</c>

255
00:11:59,052 --> 00:12:00,387
<c.magenta>（使用较高等级响应器）</c>

256
00:12:00,454 --> 00:12:03,023
<c.magenta>现在这个方式比委托方法那个</c>

257
00:12:03,090 --> 00:12:04,758
<c.magenta>但这个方式是非常有帮助的</c>

258
00:12:04,825 --> 00:12:08,495
<c.magenta>若你想在补充中使用</c>

259
00:12:09,730 --> 00:12:12,099
<c.magenta>我们稍后再详细谈这个方式</c>

260
00:12:13,700 --> 00:12:16,069
<c.magenta>现在让我们看一个简单版本</c>

261
00:12:16,136 --> 00:12:17,437
<c.magenta>实施邮件自动完成触控项</c>

262
00:12:17,704 --> 00:12:19,640
<c.magenta>自这场演讲一开始</c>

263
00:12:20,707 --> 00:12:22,509
<c.magenta>我们要使用委托方式</c>

264
00:12:22,576 --> 00:12:23,844
<c.magenta>（示例：邮件自动完成）</c>

265
00:12:25,045 --> 00:12:26,346
<c.magenta>但我们在这里有一点问题</c>

266
00:12:26,713 --> 00:12:30,017
<c.magenta>现在 因为我们的文本字段</c>

267
00:12:30,083 --> 00:12:31,385
<c.magenta>在这里添加表情或富文本</c>

268
00:12:31,451 --> 00:12:33,854
<c.magenta>真的意义不大</c>

269
00:12:34,855 --> 00:12:36,623
<c.magenta>但如果我们关闭触控条上的那些属性</c>

270
00:12:36,690 --> 00:12:39,259
<c.magenta>请看当我们把补充列表</c>

271
00:12:39,793 --> 00:12:42,329
<c.magenta>你可能会得到这么一个</c>

272
00:12:42,763 --> 00:12:45,566
<c.magenta>看起来一点都不好</c>

273
00:12:47,000 --> 00:12:49,203
<c.magenta>我们要阻止这种情况的发生</c>

274
00:12:49,937 --> 00:12:52,172
<c.magenta>通过关闭折叠功能</c>

275
00:12:52,239 --> 00:12:54,842
<c.magenta>使用allowsCollapsing属性</c>

276
00:12:55,776 --> 00:12:56,910
<c.magenta>当我们设置这个属性时</c>

277
00:12:57,611 --> 00:12:59,346
<c.magenta>左边的那个小尖括号就不见了</c>

278
00:12:59,646 --> 00:13:01,949
<c.magenta>然后你就再也不能折叠列表了</c>

279
00:12:59,646 --> 00:13:01,949
<c.magenta>然后你就再也不能折叠列表了</c>

280
00:13:03,617 --> 00:13:04,585
<c.magenta>（不可折叠！）</c>

281
00:13:05,886 --> 00:13:07,321
<c.magenta>但现在我们面临着另一个问题</c>

282
00:13:09,089 --> 00:13:12,759
<c.magenta>我们在字段编辑器的补充列表项中</c>

283
00:13:13,727 --> 00:13:14,728
<c.magenta>设置了那个属性</c>

284
00:13:15,262 --> 00:13:18,098
<c.magenta>并且字段编辑器是与窗口中的全部</c>

285
00:13:18,565 --> 00:13:21,134
<c.magenta>如果我们设置allowsCollapsing属性</c>

286
00:13:21,468 --> 00:13:23,337
<c.magenta>在这个字段编辑器的补充列表中</c>

287
00:13:23,637 --> 00:13:25,572
<c.magenta>它会影响全部这些文本字段</c>

288
00:13:25,639 --> 00:13:26,840
<c.magenta>这并不是我们想看到的结果</c>

289
00:13:27,941 --> 00:13:30,978
<c.magenta>我们要解决这个问题</c>

290
00:13:31,378 --> 00:13:34,882
<c.magenta>TextField提供我们自己的字段编辑器</c>

291
00:13:35,215 --> 00:13:36,650
<c.magenta>它就不会影响共享编辑器</c>

292
00:13:38,352 --> 00:13:40,220
<c.magenta>那么要创建自定义字段编辑器</c>

293
00:13:40,287 --> 00:13:42,422
<c.magenta>我们要子类化NSTextFieldCell</c>

294
00:13:44,324 --> 00:13:47,394
<c.magenta>在我们的子类中</c>

295
00:13:50,130 --> 00:13:52,366
<c.magenta>然后我们要创建一个</c>

296
00:13:52,833 --> 00:13:55,669
<c.magenta>就是这样 完成了</c>

297
00:13:55,736 --> 00:13:58,505
<c.magenta>我们只是提供了自己的</c>

298
00:13:59,306 --> 00:14:00,574
<c.magenta>用作字段编辑器</c>

299
00:13:59,306 --> 00:14:00,574
<c.magenta>用作字段编辑器</c>

300
00:14:00,641 --> 00:14:03,210
<c.magenta>无论何时当某人想要编辑</c>

301
00:14:04,077 --> 00:14:07,381
<c.magenta>请不要忘记设置你的TextField</c>

302
00:14:07,447 --> 00:14:09,683
<c.magenta>可以通过界面创建器或编程实现</c>

303
00:14:11,451 --> 00:14:14,054
<c.magenta>那么现在 我们可以实施</c>

304
00:14:14,121 --> 00:14:16,957
<c.magenta>在这里 我们关闭了</c>

305
00:14:17,024 --> 00:14:18,892
<c.magenta>并返回到我们的自定义补充数组</c>

306
00:14:19,259 --> 00:14:21,628
<c.magenta>这是邮件自动完成的一个简单的实施</c>

307
00:14:21,695 --> 00:14:22,963
<c.magenta>通过补充列表项</c>

308
00:14:25,299 --> 00:14:27,434
<c.magenta>刚才我们提到了一个</c>

309
00:14:27,501 --> 00:14:28,969
<c.magenta>用于返回自定义补充</c>

310
00:14:29,036 --> 00:14:32,105
<c.magenta>通过提供你自己的拥有较高等级</c>

311
00:14:32,706 --> 00:14:35,342
<c.magenta>如果你需要获得补充列表触控项的</c>

312
00:14:35,409 --> 00:14:36,443
<c.magenta>你可以采用这种方式</c>

313
00:14:36,510 --> 00:14:39,213
<c.magenta>如果你想采用这种方式</c>

314
00:14:41,448 --> 00:14:44,318
<c.magenta>首先你要禁用文本字段</c>

315
00:14:44,885 --> 00:14:47,020
<c.magenta>因为你要提供你自己的补充列表</c>

316
00:14:47,087 --> 00:14:48,622
<c.magenta>就不再需要标准的补充列表了</c>

317
00:14:51,692 --> 00:14:54,995
<c.magenta>第二 要实施NSTouchBar委托方法</c>

318
00:14:55,062 --> 00:14:56,430
<c.magenta>makeItemForIdentifier</c>

319
00:14:56,997 --> 00:15:00,534
<c.magenta>这个方法是你要创建</c>

320
00:14:56,997 --> 00:15:00,534
<c.magenta>这个方法是你要创建</c>

321
00:15:01,702 --> 00:15:04,037
<c.magenta>如果你将模型对象用作补充</c>

322
00:15:04,104 --> 00:15:06,406
<c.magenta>这个方法还是你要把模型对象映射到</c>

323
00:15:06,473 --> 00:15:09,710
<c.magenta>能在补充列表触控项中显示的</c>

324
00:15:10,878 --> 00:15:13,680
<c.magenta>那么 要实现这个目的</c>

325
00:15:13,847 --> 00:15:15,315
<c.magenta>attributedStringForCandidate</c>

326
00:15:19,353 --> 00:15:22,055
<c.magenta>第三 如果你使用要在委托方法</c>

327
00:15:24,258 --> 00:15:29,162
<c.magenta>endSelectingCandidateAt索引中</c>

328
00:15:29,229 --> 00:15:30,964
<c.magenta>实施的模型对象补充</c>

329
00:15:31,031 --> 00:15:34,701
<c.magenta>这就是你要提供其它方向映射的方式</c>

330
00:15:35,035 --> 00:15:38,205
<c.magenta>从用户的补充选择</c>

331
00:15:40,674 --> 00:15:43,911
<c.magenta>最后你要更新补充</c>

332
00:15:43,977 --> 00:15:47,214
<c.magenta>当某人向你的文本字段</c>

333
00:15:47,614 --> 00:15:50,150
<c.magenta>实现方法是覆盖controlTextDidChange</c>

334
00:15:50,551 --> 00:15:53,587
<c.magenta>然后给所选范围和字符串</c>

335
00:15:53,654 --> 00:15:55,923
<c.magenta>在你的自定义补充列表触控项中</c>

336
00:15:58,158 --> 00:16:00,127
<c.magenta>这也包含了自定义文本栏</c>

337
00:15:58,158 --> 00:16:00,127
<c.magenta>这也包含了自定义文本栏</c>

338
00:16:00,594 --> 00:16:03,997
<c.magenta>那么让我们回顾一下</c>

339
00:16:04,064 --> 00:16:07,100
<c.magenta>添加自定义触控项的方式</c>

340
00:16:07,167 --> 00:16:08,202
<c.magenta>提供自定义补充的方式</c>

341
00:16:08,368 --> 00:16:11,138
<c.magenta>我鼓励你们大家尝试自定义文本栏</c>

342
00:16:11,205 --> 00:16:13,173
<c.magenta>通过我们今天推荐给大家的方式</c>

343
00:16:15,008 --> 00:16:18,011
<c.magenta>接下来我要邀请杰夫·纳多上台</c>

344
00:16:18,078 --> 00:16:20,347
<c.magenta>一个专门为NS触控条创建的控件</c>

345
00:16:20,414 --> 00:16:21,248
<c.magenta>杰夫？</c>

346
00:16:25,118 --> 00:16:26,220
<c.magenta>好的 谢谢</c>

347
00:16:26,653 --> 00:16:29,323
<c.magenta>那么正如唐娜刚才所说的</c>

348
00:16:29,389 --> 00:16:32,993
<c.magenta>是我们专为触控条环境设计的</c>

349
00:16:33,660 --> 00:16:37,164
<c.magenta>这个控件的中心主题是</c>

350
00:16:37,231 --> 00:16:40,400
<c.magenta>并便利地将其送到你的指尖下</c>

351
00:16:40,834 --> 00:16:41,869
<c.magenta>（NSScrubber）</c>

352
00:16:41,935 --> 00:16:45,372
<c.magenta>现在给大家看一些例子 现在展示的</c>

353
00:16:45,439 --> 00:16:48,075
<c.magenta>作为NSScrubber的一个例子</c>

354
00:16:48,141 --> 00:16:49,343
<c.magenta>许多地方都要用到它</c>

355
00:16:49,776 --> 00:16:52,813
<c.magenta>还有两个分别是</c>

356
00:16:53,514 --> 00:16:58,452
<c.magenta>以及Keynote的滑动导航器</c>

357
00:16:58,519 --> 00:16:59,520
<c.magenta>（触控条的通用控件）</c>

358
00:16:59,586 --> 00:17:01,622
<c.magenta>把这些摆在一起 你就可以说</c>

359
00:16:59,586 --> 00:17:01,622
<c.magenta>把这些摆在一起 你就可以说</c>

360
00:17:01,688 --> 00:17:03,323
<c.magenta>这个控件是非常通用的</c>

361
00:17:03,390 --> 00:17:07,594
<c.magenta>可以表达多种视觉和交互设计</c>

362
00:17:07,661 --> 00:17:09,730
<c.magenta>（Keynote幻灯片）</c>

363
00:17:09,796 --> 00:17:12,733
<c.magenta>但在我们深入讲解任意API之前</c>

364
00:17:12,799 --> 00:17:14,768
<c.magenta>回答这个问题：什么是NSScrubber？</c>

365
00:17:15,002 --> 00:17:16,336
<c.magenta>它是一个类似于集合的控件</c>

366
00:17:16,970 --> 00:17:19,640
<c.magenta>作用是安排你应用的内容列表</c>

367
00:17:19,705 --> 00:17:22,576
<c.magenta>然后提供基于触摸手势的</c>

368
00:17:22,643 --> 00:17:25,412
<c.magenta>通过轻触和拖拽手势</c>

369
00:17:26,413 --> 00:17:30,517
<c.magenta>如果你之前用过NSCollectionView</c>

370
00:17:30,584 --> 00:17:34,588
<c.magenta>然而它却进行了改进和调整</c>

371
00:17:37,224 --> 00:17:41,028
<c.magenta>与NSCollectionView一样</c>

372
00:17:41,094 --> 00:17:44,765
<c.magenta>意思是它将其许多功能</c>

373
00:17:44,998 --> 00:17:47,868
<c.magenta>最好的理解方式就是实际分解控件</c>

374
00:17:47,935 --> 00:17:49,937
<c.magenta>并挨个查看每一个部分</c>

375
00:17:51,171 --> 00:17:54,675
<c.magenta>首先 我们有控件视图自身</c>

376
00:17:54,741 --> 00:17:57,010
<c.magenta>它通过控件管理全部的用户交互</c>

377
00:17:57,344 --> 00:17:59,847
<c.magenta>它还提供一些很棒的外观属性</c>

378
00:17:59,913 --> 00:18:02,449
<c.magenta>比如背景和其它类似的东西</c>

379
00:17:59,913 --> 00:18:02,449
<c.magenta>比如背景和其它类似的东西</c>

380
00:18:03,884 --> 00:18:06,453
<c.magenta>接下来我们还有选择框</c>

381
00:18:06,520 --> 00:18:08,755
<c.magenta>这些是视图 用于表明</c>

382
00:18:08,822 --> 00:18:11,391
<c.magenta>已选择了一些内容</c>

383
00:18:12,960 --> 00:18:15,963
<c.magenta>我们有一个专用的布局对象</c>

384
00:18:16,029 --> 00:18:18,398
<c.magenta>如何安排控制器的内容</c>

385
00:18:19,132 --> 00:18:20,968
<c.magenta>然后当然了 我们就获取了你的内容</c>

386
00:18:21,034 --> 00:18:23,170
<c.magenta>是通过数据源模型提供的</c>

387
00:18:25,305 --> 00:18:27,374
<c.magenta>现在我们要逐个查看每一个部分</c>

388
00:18:27,875 --> 00:18:31,345
<c.magenta>然而我们应该先看一下我们可以在</c>

389
00:18:32,746 --> 00:18:35,115
<c.magenta>第一点也是最重要的一点</c>

390
00:18:35,182 --> 00:18:38,352
<c.magenta>是通过模式属性控制的</c>

391
00:18:38,752 --> 00:18:41,221
<c.magenta>NSScrubber</c>

392
00:18:41,788 --> 00:18:43,357
<c.magenta>第一个叫作“fixed”</c>

393
00:18:44,291 --> 00:18:47,794
<c.magenta>提供基于触摸的选择</c>

394
00:18:47,861 --> 00:18:49,463
<c.magenta>可以直接选择</c>

395
00:18:49,530 --> 00:18:51,431
<c.magenta>并高亮你触摸的项</c>

396
00:18:52,165 --> 00:18:54,902
<c.magenta>第二个叫作“free”</c>

397
00:18:54,968 --> 00:18:58,505
<c.magenta>你可以自由滚动 就像其它</c>

398
00:18:59,740 --> 00:19:03,911
<c.magenta>选择两个模式中的一种之后</c>

399
00:18:59,740 --> 00:19:03,911
<c.magenta>选择两个模式中的一种之后</c>

400
00:19:04,878 --> 00:19:07,347
<c.magenta>这个名字很熟悉</c>

401
00:19:07,414 --> 00:19:11,718
<c.magenta>我们用这个名字表示一个</c>

402
00:19:11,785 --> 00:19:15,289
<c.magenta>正在更新其值或发送其行动</c>

403
00:19:15,355 --> 00:19:17,858
<c.magenta>（连续性选择）</c>

404
00:19:17,925 --> 00:19:21,395
<c.magenta>现在如果连续性属性为假</c>

405
00:19:21,828 --> 00:19:25,632
<c.magenta>你可以看到轻触和拖拽</c>

406
00:19:25,699 --> 00:19:28,168
<c.magenta>但会一直保持选择状态</c>

407
00:19:28,235 --> 00:19:29,636
<c.magenta>并提交新选择</c>

408
00:19:30,671 --> 00:19:34,374
<c.magenta>但若我们将其设为真 我们可以看到</c>

409
00:19:34,875 --> 00:19:38,245
<c.magenta>我们在标签之间拖拽</c>

410
00:19:38,312 --> 00:19:40,214
<c.magenta>该触控项就会立即被选中</c>

411
00:19:41,882 --> 00:19:43,684
<c.magenta>还有自由式拖动器</c>

412
00:19:43,750 --> 00:19:46,086
<c.magenta>比如我们刚才看到过的</c>

413
00:19:46,420 --> 00:19:50,390
<c.magenta>我们可以在这里滑动 看什么呢</c>

414
00:19:50,457 --> 00:19:52,559
<c.magenta>然后我们可以轻触那个触控项选中它</c>

415
00:19:53,660 --> 00:19:58,165
<c.magenta>但如果我们将连续性属性设为真</c>

416
00:19:58,398 --> 00:20:03,203
<c.magenta>会在内容内部流动地</c>

417
00:19:58,398 --> 00:20:03,203
<c.magenta>会在内容内部流动地</c>

418
00:20:04,104 --> 00:20:06,707
<c.magenta>这就给了我们一个非常明显的区别</c>

419
00:20:06,773 --> 00:20:10,511
<c.magenta>连续性属性为假</c>

420
00:20:10,577 --> 00:20:13,113
<c.magenta>可能会很适合某种重量级动作</c>

421
00:20:13,313 --> 00:20:16,850
<c.magenta>连续属性为真</c>

422
00:20:16,917 --> 00:20:18,018
<c.magenta>会很快、很流畅</c>

423
00:20:18,085 --> 00:20:20,854
<c.magenta>可能适合高亮交互</c>

424
00:20:23,490 --> 00:20:26,460
<c.magenta>一旦我们确定想要哪种</c>

425
00:20:26,793 --> 00:20:29,396
<c.magenta>我们就需要决定</c>

426
00:20:29,463 --> 00:20:31,899
<c.magenta>这是由selectionBackgroundStyle</c>

427
00:20:31,965 --> 00:20:33,400
<c.magenta>和OverlayStyle属性控制的</c>

428
00:20:34,201 --> 00:20:38,005
<c.magenta>我们提供两种自带样式</c>

429
00:20:38,071 --> 00:20:41,842
<c.magenta>就是你曾在我们多个示例中</c>

430
00:20:42,176 --> 00:20:44,211
<c.magenta>然后我们还有一种</c>

431
00:20:44,278 --> 00:20:46,046
<c.magenta>作为文本触控项的背景看起来很不错</c>

432
00:20:47,548 --> 00:20:50,050
<c.magenta>现在如果你善于观察</c>

433
00:20:50,117 --> 00:20:52,419
<c.magenta>NSScrubber选择样式声明</c>

434
00:20:52,486 --> 00:20:55,088
<c.magenta>并不是一个闭合的枚举</c>

435
00:20:55,155 --> 00:20:58,759
<c.magenta>所以你可以子类化这个并定义</c>

436
00:21:01,061 --> 00:21:03,130
<c.magenta>关于选择的另一个有趣的外观选项</c>

437
00:21:03,197 --> 00:21:05,232
<c.magenta>就是这个floatSelectionViews属性</c>

438
00:21:05,299 --> 00:21:06,333
<c.magenta>（浮动选择）</c>

439
00:21:06,400 --> 00:21:09,870
<c.magenta>当它为假时 变更选择看起来</c>

440
00:21:09,937 --> 00:21:12,940
<c.magenta>老旧的选择样式不见了</c>

441
00:21:13,473 --> 00:21:15,042
<c.magenta>但如果我们将其设为真</c>

442
00:21:15,108 --> 00:21:19,513
<c.magenta>我们实际上会得到一个很棒</c>

443
00:21:19,580 --> 00:21:21,849
<c.magenta>这是一种很酷的效果</c>

444
00:21:24,484 --> 00:21:27,487
<c.magenta>在我们的例子中</c>

445
00:21:28,355 --> 00:21:31,525
<c.magenta>有些控件 当你滚动、滑动或拖拽时</c>

446
00:21:31,592 --> 00:21:35,762
<c.magenta>总是会很顺畅地滑动 因此有些触控项</c>

447
00:21:35,829 --> 00:21:36,964
<c.magenta>在本例中是中心位置</c>

448
00:21:37,297 --> 00:21:39,733
<c.magenta>这是通过itemAlignment属性控制的</c>

449
00:21:40,100 --> 00:21:42,503
<c.magenta>现在默认值是无 意思是我们不会</c>

450
00:21:42,569 --> 00:21:44,304
<c.magenta>对你的滚动做出任何调整</c>

451
00:21:44,371 --> 00:21:46,507
<c.magenta>但如果你将其设为居首、居尾或居中</c>

452
00:21:46,707 --> 00:21:50,177
<c.magenta>在滚动事件发生后</c>

453
00:21:50,577 --> 00:21:53,680
<c.magenta>将总是会调整它</c>

454
00:21:53,747 --> 00:21:56,650
<c.magenta>可以是居首、居尾或中心对齐</c>

455
00:21:58,452 --> 00:21:59,453
<c.magenta>（外观）</c>

456
00:21:59,620 --> 00:22:02,389
<c.magenta>最后 NSScrubber有一些</c>

457
00:21:59,620 --> 00:22:02,389
<c.magenta>最后 NSScrubber有一些</c>

458
00:22:02,456 --> 00:22:05,626
<c.magenta>适用于内容的背景区 包括背景颜色</c>

459
00:22:05,692 --> 00:22:08,228
<c.magenta>或者如果你想拉动你喜欢的 你可以</c>

460
00:22:08,295 --> 00:22:09,429
<c.magenta>在内容后面放一个视图</c>

461
00:22:10,631 --> 00:22:13,300
<c.magenta>而且我们也在NSColor中</c>

462
00:22:13,367 --> 00:22:15,335
<c.magenta>叫作scrubberTexturedBackground颜色</c>

463
00:22:16,170 --> 00:22:17,871
<c.magenta>在backgroundColor属性中效果不错</c>

464
00:22:17,938 --> 00:22:21,108
<c.magenta>用于提供这种很酷的垂直纹理外观</c>

465
00:22:21,175 --> 00:22:23,410
<c.magenta>你可能会在应用中见过</c>

466
00:22:25,112 --> 00:22:27,948
<c.magenta>现在看起来有很多属性</c>

467
00:22:28,015 --> 00:22:31,018
<c.magenta>我们只需要写几行代码</c>

468
00:22:32,386 --> 00:22:35,289
<c.magenta>那么我们创建了控件</c>

469
00:22:35,355 --> 00:22:36,757
<c.magenta>一个委托和一个dataSource</c>

470
00:22:36,823 --> 00:22:39,059
<c.magenta>我们并没有仔细研究这些</c>

471
00:22:39,126 --> 00:22:40,327
<c.magenta>稍后会逐个讲到每一个</c>

472
00:22:41,195 --> 00:22:43,463
<c.magenta>我们要决定如何与控件交互</c>

473
00:22:43,830 --> 00:22:46,567
<c.magenta>在本例中</c>

474
00:22:46,633 --> 00:22:48,268
<c.magenta>但在滚动时</c>

475
00:22:48,802 --> 00:22:51,104
<c.magenta>然后我们还想</c>

476
00:22:51,171 --> 00:22:54,675
<c.magenta>以便在滚动后某些触控项</c>

477
00:22:55,909 --> 00:22:58,011
<c.magenta>然后我们要选择选中效果</c>

478
00:22:58,078 --> 00:23:00,447
<c.magenta>在本例中我们要应用两种自带效果</c>

479
00:22:58,078 --> 00:23:00,447
<c.magenta>在本例中我们要应用两种自带效果</c>

480
00:23:00,614 --> 00:23:02,416
<c.magenta>我们要打开那个很不错的浮动选择</c>

481
00:23:02,482 --> 00:23:05,886
<c.magenta>因此当选择变更时 它会在视图间浮动</c>

482
00:23:06,954 --> 00:23:09,623
<c.magenta>最后我们要应用那个</c>

483
00:23:09,890 --> 00:23:12,826
<c.magenta>仅通过这几行代码</c>

484
00:23:12,893 --> 00:23:16,330
<c.magenta>日历拖动器的蓝图</c>

485
00:23:18,799 --> 00:23:21,802
<c.magenta>现在我们已按照我们的想法</c>

486
00:23:22,069 --> 00:23:23,637
<c.magenta>我们需要布局这些触控项</c>

487
00:23:24,137 --> 00:23:26,373
<c.magenta>这是通过NSScrubberLayout类实现的</c>

488
00:23:27,174 --> 00:23:30,277
<c.magenta>这个类定义了控件内部</c>

489
00:23:30,344 --> 00:23:31,178
<c.magenta>且它是</c>

490
00:23:31,245 --> 00:23:34,114
<c.magenta>通过NSScrubberLayoutAttributes</c>

491
00:23:34,181 --> 00:23:37,684
<c.magenta>这个对象实质上</c>

492
00:23:37,751 --> 00:23:42,256
<c.magenta>它应该在其内容的坐标控件内布局</c>

493
00:23:43,590 --> 00:23:47,027
<c.magenta>我们提供一些自带布局</c>

494
00:23:47,094 --> 00:23:50,130
<c.magenta>如果你喜欢的话 你知道的</c>

495
00:23:50,197 --> 00:23:52,199
<c.magenta>其中包括流式布局</c>

496
00:23:52,266 --> 00:23:55,169
<c.magenta>与NSCollectionView流式布局有可比性</c>

497
00:23:55,402 --> 00:23:58,372
<c.magenta>但如果你想定义你自己的布局</c>

498
00:23:58,438 --> 00:24:01,408
<c.magenta>其实你只需要实施三个关键方法</c>

499
00:23:58,438 --> 00:24:01,408
<c.magenta>其实你只需要实施三个关键方法</c>

500
00:24:01,875 --> 00:24:03,877
<c.magenta>第一个是scrubberContentSize</c>

501
00:24:03,944 --> 00:24:06,446
<c.magenta>定义了控件内一切组件的整体尺寸</c>

502
00:24:07,047 --> 00:24:10,217
<c.magenta>也定义了我们在全部内容内</c>

503
00:24:11,518 --> 00:24:14,221
<c.magenta>长方框里是layoutAttributesForItems</c>

504
00:24:14,288 --> 00:24:17,257
<c.magenta>为指定长方框内的每一触控项</c>

505
00:24:17,324 --> 00:24:19,159
<c.magenta>提供一组完整属性</c>

506
00:24:19,459 --> 00:24:21,495
<c.magenta>可能是当前这个可见的长方框</c>

507
00:24:21,562 --> 00:24:23,397
<c.magenta>或可能是用户要滚动到的一个长方框</c>

508
00:24:23,463 --> 00:24:25,399
<c.magenta>你想要准备好展示一切</c>

509
00:24:26,633 --> 00:24:28,869
<c.magenta>那么最后是索引中的</c>

510
00:24:28,936 --> 00:24:32,539
<c.magenta>如果需要的话</c>

511
00:24:35,442 --> 00:24:38,345
<c.magenta>布局生命周期的另一半是无效的</c>

512
00:24:38,412 --> 00:24:39,446
<c.magenta>（布局无效）</c>

513
00:24:39,513 --> 00:24:44,218
<c.magenta>InvalidateLayout控制的是</c>

514
00:24:44,284 --> 00:24:47,287
<c.magenta>以从NSScrubber布局中</c>

515
00:24:48,655 --> 00:24:51,024
<c.magenta>现在如果你的布局取决于指定信息</c>

516
00:24:51,091 --> 00:24:54,261
<c.magenta>或可见长方框 你想在选择时</c>

517
00:24:54,328 --> 00:24:56,597
<c.magenta>所选内容比其它项大一倍</c>

518
00:24:56,663 --> 00:24:57,965
<c.magenta>你可以按情况请求</c>

519
00:24:58,031 --> 00:25:01,301
<c.magenta>自动无效 当那些东西发生变更时</c>

520
00:24:58,031 --> 00:25:01,301
<c.magenta>自动无效 当那些东西发生变更时</c>

521
00:25:01,535 --> 00:25:04,338
<c.magenta>并且这会防止你自己追踪那个信息</c>

522
00:25:04,404 --> 00:25:06,340
<c.magenta>并手动调用无效布局</c>

523
00:25:07,975 --> 00:25:10,410
<c.magenta>最后在你的布局无效之后</c>

524
00:25:10,711 --> 00:25:13,947
<c.magenta>在我们做进一步的布局传递之前</c>

525
00:25:14,014 --> 00:25:15,215
<c.magenta>在你的布局对象中</c>

526
00:25:15,449 --> 00:25:17,251
<c.magenta>基础实施不会做任何事</c>

527
00:25:17,317 --> 00:25:21,421
<c.magenta>但这是一个很好的机会</c>

528
00:25:21,488 --> 00:25:23,257
<c.magenta>做一些测量并准备一些缓存</c>

529
00:25:23,323 --> 00:25:25,592
<c.magenta>从而使随后的外部调用变得非常迅速</c>

530
00:25:27,895 --> 00:25:29,863
<c.magenta>这就是你组织布局所需要做的一切</c>

531
00:25:30,998 --> 00:25:32,766
<c.magenta>现在我们已经配置了我们的控件</c>

532
00:25:32,833 --> 00:25:34,735
<c.magenta>我们知道想如何布局全部内容</c>

533
00:25:34,801 --> 00:25:38,005
<c.magenta>我们首先需要把内容放到控件中</c>

534
00:25:39,606 --> 00:25:42,309
<c.magenta>NSScrubber中的内容</c>

535
00:25:42,376 --> 00:25:44,912
<c.magenta>NSScrubberItemView类的子类呈现的</c>

536
00:25:45,245 --> 00:25:47,514
<c.magenta>这与NSTableCellView具有可比性</c>

537
00:25:48,916 --> 00:25:52,052
<c.magenta>就像NSTableCell</c>

538
00:25:52,486 --> 00:25:56,190
<c.magenta>NSScrubber提供一种重复使用的队列</c>

539
00:25:56,256 --> 00:25:57,758
<c.magenta>当它们在控件外循环时</c>

540
00:25:58,192 --> 00:26:01,061
<c.magenta>而不是每次请求时都分配一个新视图</c>

541
00:25:58,192 --> 00:26:01,061
<c.magenta>而不是每次请求时都分配一个新视图</c>

542
00:26:02,262 --> 00:26:05,332
<c.magenta>NSScrubber的dataSource协议</c>

543
00:26:05,399 --> 00:26:08,068
<c.magenta>你只需要实施两个方法</c>

544
00:26:08,135 --> 00:26:10,737
<c.magenta>整体控件中的numberOfItems</c>

545
00:26:10,804 --> 00:26:14,107
<c.magenta>准备一个代表指定触控项的视图即可</c>

546
00:26:15,709 --> 00:26:19,479
<c.magenta>为了帮助你完成这个任务 我们有两个</c>

547
00:26:19,546 --> 00:26:22,883
<c.magenta>有TextItem 你所需要做的就是提供</c>

548
00:26:22,950 --> 00:26:25,018
<c.magenta>并且我们会以一种</c>

549
00:26:25,085 --> 00:26:28,522
<c.magenta>其它控件一致的方式呈现它</c>

550
00:26:28,989 --> 00:26:33,861
<c.magenta>然后我们还有一个图片视图类</c>

551
00:26:33,927 --> 00:26:37,531
<c.magenta>除此之外 还允许你指定一种对齐方式</c>

552
00:26:38,565 --> 00:26:40,901
<c.magenta>现在如果这些都不是你想要的东西</c>

553
00:26:41,168 --> 00:26:45,239
<c.magenta>你还可以子类化NSScrubberItemView</c>

554
00:26:45,906 --> 00:26:48,408
<c.magenta>绘制自己的布局时</c>

555
00:26:48,475 --> 00:26:50,277
<c.magenta>比如isSelected和isHighlighted</c>

556
00:26:50,344 --> 00:26:52,613
<c.magenta>你可以用来修改那个状态下的拉动内容</c>

557
00:26:52,980 --> 00:26:55,048
<c.magenta>并且你拉动的内容将会自动无效</c>

558
00:26:55,115 --> 00:26:57,251
<c.magenta>当这些发生变更时</c>

559
00:26:57,951 --> 00:27:01,188
<c.magenta>并且你还可以</c>

560
00:26:57,951 --> 00:27:01,188
<c.magenta>并且你还可以</c>

561
00:27:01,522 --> 00:27:04,224
<c.magenta>这就允许你检验和诠释属性</c>

562
00:27:04,291 --> 00:27:06,360
<c.magenta>由布局对象生成的</c>

563
00:27:08,195 --> 00:27:09,663
<c.magenta>这就是如何提供内容方式</c>

564
00:27:10,297 --> 00:27:11,164
<c.magenta>最终</c>

565
00:27:11,231 --> 00:27:14,101
<c.magenta>我们假设用户要使用这个控件</c>

566
00:27:14,168 --> 00:27:15,903
<c.magenta>那么我们需要作出响应</c>

567
00:27:16,570 --> 00:27:18,672
<c.magenta>这是通过一个委托协议实现的</c>

568
00:27:19,139 --> 00:27:21,108
<c.magenta>你可以收到通知 当所选内容</c>

569
00:27:21,175 --> 00:27:22,276
<c.magenta>高亮内容</c>

570
00:27:22,342 --> 00:27:24,945
<c.magenta>以及控件中的可见触控项范围</c>

571
00:27:25,012 --> 00:27:26,780
<c.magenta>由于滚动或布局原因而发生变更时</c>

572
00:27:28,348 --> 00:27:31,752
<c.magenta>当交互开始、结束或被取消时</c>

573
00:27:32,019 --> 00:27:35,088
<c.magenta>这可能适用于 比如用控件</c>

574
00:27:35,155 --> 00:27:37,658
<c.magenta>在单一交互中创建一个取消分组</c>

575
00:27:37,724 --> 00:27:40,093
<c.magenta>那么因为用户会很迅速地拖动</c>

576
00:27:40,160 --> 00:27:43,897
<c.magenta>你可以将全部这些变更</c>

577
00:27:47,401 --> 00:27:50,170
<c.magenta>这就是你要做自己的NSScrubber</c>

578
00:27:50,237 --> 00:27:53,473
<c.magenta>我希望你已经</c>

579
00:27:53,540 --> 00:27:56,276
<c.magenta>关于你应用中的内容 你可以通过</c>

580
00:27:58,712 --> 00:27:59,546
<c.magenta>但是…</c>

581
00:28:00,113 --> 00:28:03,050
<c.magenta>我们…在Fundamentals演讲</c>

582
00:28:03,550 --> 00:28:06,553
<c.magenta>花了大量的时间解释</c>

583
00:28:06,620 --> 00:28:09,223
<c.magenta>和类来打造你的触控条体验</c>

584
00:28:10,057 --> 00:28:12,893
<c.magenta>但如果你想真正发挥你的创造力</c>

585
00:28:12,960 --> 00:28:14,461
<c.magenta>并创建一个真正自定义的控件</c>

586
00:28:14,862 --> 00:28:16,864
<c.magenta>你需要留下来听下一部分的内容</c>

587
00:28:16,930 --> 00:28:20,167
<c.magenta>泰勒会跟大家逐步分享…</c>

588
00:28:20,334 --> 00:28:22,703
<c.magenta>为触控条实现完全自定义控件</c>

589
00:28:23,770 --> 00:28:24,605
<c.magenta>谢谢</c>

590
00:28:27,374 --> 00:28:28,208
<c.magenta>来吧</c>

591
00:28:31,378 --> 00:28:32,212
<c.magenta>大家好</c>

592
00:28:34,448 --> 00:28:37,284
<c.magenta>那么提到为触控条创建自定义控件</c>

593
00:28:37,451 --> 00:28:39,953
<c.magenta>你需要记住四点</c>

594
00:28:40,120 --> 00:28:42,990
<c.magenta>第一点是处理进来的触摸事件</c>

595
00:28:43,624 --> 00:28:47,494
<c.magenta>第二点是调整视图的样式</c>

596
00:28:48,028 --> 00:28:50,697
<c.magenta>第三点是确保尺寸正确</c>

597
00:28:50,764 --> 00:28:52,132
<c.magenta>并将其放在其它控件之中</c>

598
00:28:52,566 --> 00:28:54,768
<c.magenta>最后一点是将一切捆绑在一起</c>

599
00:28:54,835 --> 00:28:56,537
<c.magenta>通过应用一些动画</c>

600
00:28:57,204 --> 00:28:59,106
<c.magenta>让我们从事件处理开始讲</c>

601
00:28:59,773 --> 00:29:03,477
<c.magenta>现在很明显的一件事是</c>

602
00:28:59,773 --> 00:29:03,477
<c.magenta>现在很明显的一件事是</c>

603
00:29:04,044 --> 00:29:05,412
<c.magenta>我真的很想阐述一下</c>

604
00:29:05,479 --> 00:29:07,681
<c.magenta>直接触摸与非直接触摸之间的区别</c>

605
00:29:08,448 --> 00:29:09,283
<c.magenta>你们</c>

606
00:29:09,349 --> 00:29:12,753
<c.magenta>可能是iList开发人员</c>

607
00:29:12,819 --> 00:29:15,389
<c.magenta>当你直接触摸时 你会直接操纵</c>

608
00:29:15,455 --> 00:29:17,257
<c.magenta>iPhone或iPad上的内容</c>

609
00:29:17,591 --> 00:29:21,361
<c.magenta>相反 非直接触摸</c>

610
00:29:21,562 --> 00:29:24,531
<c.magenta>你可以远程与电视上的内容进行交互</c>

611
00:29:25,299 --> 00:29:28,902
<c.magenta>在新MacBook Pro中</c>

612
00:29:29,536 --> 00:29:33,073
<c.magenta>触摸轨迹板上已经有了非直接触摸</c>

613
00:29:33,273 --> 00:29:36,476
<c.magenta>你可以在轨迹板上获取单一触摸</c>

614
00:29:37,611 --> 00:29:40,414
<c.magenta>现在通过触控条 我们支持直接触摸</c>

615
00:29:40,480 --> 00:29:43,383
<c.magenta>你可以直接操纵屏幕上的内容</c>

616
00:29:44,785 --> 00:29:47,754
<c.magenta>因此我们现在扩展了NSTouch类</c>

617
00:29:47,821 --> 00:29:51,491
<c.magenta>添加了一个TouchType来描述</c>

618
00:29:52,426 --> 00:29:53,427
<c.magenta>对于直接触摸</c>

619
00:29:53,493 --> 00:29:56,296
<c.magenta>你现在可以获取那个触摸的位置</c>

620
00:29:56,630 --> 00:29:58,932
<c.magenta>提供那个视图是非常重要的</c>

621
00:29:58,999 --> 00:30:02,236
<c.magenta>因为它提供了</c>

622
00:29:58,999 --> 00:30:02,236
<c.magenta>因为它提供了</c>

623
00:30:03,003 --> 00:30:06,073
<c.magenta>举个例子 当用户滚动滑块时</c>

624
00:30:06,340 --> 00:30:10,010
<c.magenta>我们想获取那个触摸的位置</c>

625
00:30:10,410 --> 00:30:13,113
<c.magenta>而且我们要获取那个位移</c>

626
00:30:13,447 --> 00:30:14,448
<c.magenta>以获取新值</c>

627
00:30:14,982 --> 00:30:16,183
<c.magenta>非常简单直接</c>

628
00:30:17,351 --> 00:30:18,185
<c.magenta>现在</c>

629
00:30:18,252 --> 00:30:21,121
<c.magenta>NSTouch和UITouch的一个</c>

630
00:30:21,388 --> 00:30:23,724
<c.magenta>是对于UITouch这个长期存在的对象</c>

631
00:30:23,790 --> 00:30:25,893
<c.magenta>它的位置会随着时间更新</c>

632
00:30:25,959 --> 00:30:29,062
<c.magenta>而NSTouch实质上是</c>

633
00:30:29,563 --> 00:30:32,599
<c.magenta>…那个手势中适时的某一点</c>

634
00:30:33,233 --> 00:30:34,902
<c.magenta>你可以用identify属性</c>

635
00:30:34,968 --> 00:30:37,838
<c.magenta>将一系列触摸捆绑到一起</c>

636
00:30:38,605 --> 00:30:41,008
<c.magenta>那么因为事件是通过触控条进入的</c>

637
00:30:41,074 --> 00:30:44,811
<c.magenta>每个事件都将包含一个或多个触摸</c>

638
00:30:45,612 --> 00:30:47,681
<c.magenta>并且每个触摸都是唯一实例</c>

639
00:30:47,748 --> 00:30:51,351
<c.magenta>因此再一次 你将它们捆绑在一起的</c>

640
00:30:52,152 --> 00:30:54,655
<c.magenta>那么甚至当用户用多个手指触摸时</c>

641
00:30:54,721 --> 00:30:57,457
<c.magenta>我们也可以区分</c>

642
00:30:57,658 --> 00:31:01,028
<c.magenta>通过与我们所追踪的触摸</c>

643
00:30:57,658 --> 00:31:01,028
<c.magenta>通过与我们所追踪的触摸</c>

644
00:31:02,062 --> 00:31:04,164
<c.magenta>我们可以通过一些代码</c>

645
00:31:04,431 --> 00:31:07,734
<c.magenta>那么我们想保留一个变量</c>

646
00:31:08,335 --> 00:31:10,304
<c.magenta>当我们第一次</c>

647
00:31:10,370 --> 00:31:12,973
<c.magenta>我们要检查这些触摸</c>

648
00:31:13,040 --> 00:31:15,342
<c.magenta>然后保存它的identity属性</c>

649
00:31:15,843 --> 00:31:19,546
<c.magenta>稍后 当越来越多的触摸进入之后</c>

650
00:31:20,180 --> 00:31:21,548
<c.magenta>并将每一个触摸的identity属性</c>

651
00:31:21,615 --> 00:31:24,184
<c.magenta>与我们要追踪的那个触摸的identity</c>

652
00:31:24,251 --> 00:31:27,788
<c.magenta>我们现在可以使用那个新位置</c>

653
00:31:29,122 --> 00:31:31,158
<c.magenta>现在 这些事件和触摸从哪儿来呢？</c>

654
00:31:31,792 --> 00:31:34,595
<c.magenta>嗯 其中一个来源是</c>

655
00:31:34,661 --> 00:31:37,431
<c.magenta>touchesBegan、Moved、Ended</c>

656
00:31:37,497 --> 00:31:39,967
<c.magenta>将会在视图的整个生命周期中</c>

657
00:31:40,634 --> 00:31:43,103
<c.magenta>我们可以选择接收它们</c>

658
00:31:43,170 --> 00:31:45,205
<c.magenta>包含直接或非直接触摸</c>

659
00:31:45,272 --> 00:31:47,174
<c.magenta>但一旦你链接Sierra SDK</c>

660
00:31:47,241 --> 00:31:50,177
<c.magenta>你将自动选择接收直接触摸</c>

661
00:31:51,345 --> 00:31:54,014
<c.magenta>这里的一个非常重要的方法是</c>

662
00:31:54,715 --> 00:31:57,885
<c.magenta>其实并没有取消鼠标追踪事件的概念</c>

663
00:31:57,951 --> 00:31:59,987
<c.magenta>这对于触控条来说非常重要</c>

664
00:32:00,053 --> 00:32:01,688
<c.magenta>因为它对情境非常敏感</c>

665
00:32:02,322 --> 00:32:05,259
<c.magenta>随着用户切换激活的应用或激活的窗口</c>

666
00:32:05,592 --> 00:32:08,161
<c.magenta>触控条中的内容将会随着更新</c>

667
00:32:08,228 --> 00:32:10,898
<c.magenta>并且如果用户在当时</c>

668
00:32:10,964 --> 00:32:14,234
<c.magenta>我们将发送touchesCancelled</c>

669
00:32:14,301 --> 00:32:16,703
<c.magenta>但是用户抬起手指就会把那个</c>

670
00:32:18,172 --> 00:32:20,674
<c.magenta>然而 在极大程度上</c>

671
00:32:20,741 --> 00:32:22,676
<c.magenta>你可以使用gestureRecognizers</c>

672
00:32:23,210 --> 00:32:25,312
<c.magenta>这些已经拥有全部这些相同的方法</c>

673
00:32:25,379 --> 00:32:27,881
<c.magenta>可供子类实施</c>

674
00:32:27,948 --> 00:32:29,416
<c.magenta>并拥有同样的选择方法</c>

675
00:32:29,483 --> 00:32:32,553
<c.magenta>唯一的不同点是你得明确选择加入</c>

676
00:32:32,619 --> 00:32:34,021
<c.magenta>因为没有自动链接检验</c>

677
00:32:35,189 --> 00:32:37,491
<c.magenta>你几乎可以使用</c>

678
00:32:37,558 --> 00:32:39,092
<c.magenta>现在在触控条中也能用了</c>

679
00:32:39,560 --> 00:32:43,564
<c.magenta>比如说颜色选择器使用了一个</c>

680
00:32:43,630 --> 00:32:45,399
<c.magenta>用来实施全部事件处理</c>

681
00:32:45,599 --> 00:32:47,067
<c.magenta>它不必做任何额外的工作</c>

682
00:32:48,135 --> 00:32:49,636
<c.magenta>但有一点很重要请谨记 即便是这些</c>

683
00:32:49,703 --> 00:32:52,840
<c.magenta>你仍然需要选择接收直接触摸</c>

684
00:32:52,906 --> 00:32:54,508
<c.magenta>当你在触控条中使用它们时</c>

685
00:32:56,109 --> 00:32:58,846
<c.magenta>现在提到事件处理</c>

686
00:32:58,912 --> 00:33:00,714
<c.magenta>在按住弹出框内</c>

687
00:32:58,912 --> 00:33:00,714
<c.magenta>在按住弹出框内</c>

688
00:33:01,281 --> 00:33:03,250
<c.magenta>在Fundamentals演讲中</c>

689
00:33:03,317 --> 00:33:05,485
<c.magenta>NSTouchBar的按住触控条</c>

690
00:33:06,153 --> 00:33:08,689
<c.magenta>从而当用户长按按钮时出现</c>

691
00:33:08,755 --> 00:33:11,925
<c.magenta>它会立即呈现一些很简单的列表</c>

692
00:33:12,593 --> 00:33:17,197
<c.magenta>你可以在那里放自己的自定义视图</c>

693
00:33:17,264 --> 00:33:21,668
<c.magenta>你将调用touchesBegan、Moved</c>

694
00:33:21,735 --> 00:33:24,671
<c.magenta>最后一旦用户抬起手指</c>

695
00:33:25,305 --> 00:33:27,808
<c.magenta>然而 因为这个非常独特的</c>

696
00:33:27,875 --> 00:33:30,177
<c.magenta>这个情境不支持GestureRecognizers</c>

697
00:33:30,244 --> 00:33:32,546
<c.magenta>所以你要使用那些NSResponder方法</c>

698
00:33:33,113 --> 00:33:35,482
<c.magenta>然而 在按住弹出框外部</c>

699
00:33:35,549 --> 00:33:38,118
<c.magenta>就变得简单多了</c>

700
00:33:39,453 --> 00:33:41,788
<c.magenta>关于触控条 有一个很有意思的方面</c>

701
00:33:41,855 --> 00:33:43,490
<c.magenta>就是关于事件形态</c>

702
00:33:44,258 --> 00:33:47,060
<c.magenta>因为触控条是这个输入设备</c>

703
00:33:47,127 --> 00:33:48,629
<c.magenta>它应该一直保持响应性</c>

704
00:33:48,795 --> 00:33:50,998
<c.magenta>正因为如此</c>

705
00:33:51,064 --> 00:33:52,833
<c.magenta>并不意味着你的键盘停止了工作</c>

706
00:33:53,534 --> 00:33:56,436
<c.magenta>那么即便你之前有一个</c>

707
00:33:56,837 --> 00:34:00,774
<c.magenta>触控条仍然要保持响应性</c>

708
00:33:56,837 --> 00:34:00,774
<c.magenta>触控条仍然要保持响应性</c>

709
00:34:01,341 --> 00:34:03,877
<c.magenta>那么你可能想返回去</c>

710
00:34:03,944 --> 00:34:06,480
<c.magenta>从而确保它们可以处理</c>

711
00:34:07,781 --> 00:34:10,617
<c.magenta>此外 触控条自身也能多点触控</c>

712
00:34:10,984 --> 00:34:13,820
<c.magenta>因此 当用户与其中一个控件交互时</c>

713
00:34:13,887 --> 00:34:16,123
<c.magenta>他们可以与另一个控件</c>

714
00:34:16,590 --> 00:34:19,259
<c.magenta>你要确保你可以处理</c>

715
00:34:20,694 --> 00:34:21,929
<c.magenta>然而一旦你那样做了</c>

716
00:34:21,995 --> 00:34:25,331
<c.magenta>你就提供了大量的</c>

717
00:34:25,399 --> 00:34:28,668
<c.magenta>通过结合存在于此台设备上的</c>

718
00:34:29,369 --> 00:34:32,438
<c.magenta>你可以为用户创建很高级的流程</c>

719
00:34:32,505 --> 00:34:34,208
<c.magenta>或这种令人愉悦的体验</c>

720
00:34:34,274 --> 00:34:36,510
<c.magenta>用户可能会在四处闲逛时发现</c>

721
00:34:37,377 --> 00:34:39,913
<c.magenta>比如在自定义UI中</c>

722
00:34:39,980 --> 00:34:43,317
<c.magenta>我们给每一个触控项添加了</c>

723
00:34:43,382 --> 00:34:45,719
<c.magenta>因此用户可以用多个手指轻触</c>

724
00:34:45,786 --> 00:34:47,621
<c.magenta>然后就会同时记录多个项</c>

725
00:34:49,056 --> 00:34:49,956
<c.magenta>类似地</c>

726
00:34:50,023 --> 00:34:53,927
<c.magenta>颜色选择器的每个单一滑块上</c>

727
00:34:53,994 --> 00:34:56,597
<c.magenta>因此你可以同时编辑多个组件</c>

728
00:34:56,663 --> 00:34:58,298
<c.magenta>或当你编辑那个颜色时</c>

729
00:34:58,365 --> 00:35:00,834
<c.magenta>你可以同时将其保存为你的偏爱颜色</c>

730
00:34:58,365 --> 00:35:00,834
<c.magenta>你可以同时将其保存为你的偏爱颜色</c>

731
00:35:01,668 --> 00:35:03,170
<c.magenta>这就是多点触控的使用</c>

732
00:35:03,370 --> 00:35:05,172
<c.magenta>一旦你将其与键盘或轨迹板相结合</c>

733
00:35:05,239 --> 00:35:07,174
<c.magenta>你就升了一级</c>

734
00:35:07,474 --> 00:35:11,078
<c.magenta>比如可以在键入文本时编辑文本颜色</c>

735
00:35:11,144 --> 00:35:14,414
<c.magenta>或当移动游标时编辑其属性</c>

736
00:35:15,482 --> 00:35:17,484
<c.magenta>因此 我鼓励你们考虑一下要如何</c>

737
00:35:17,551 --> 00:35:19,019
<c.magenta>利用gestureRecognizers</c>

738
00:35:19,086 --> 00:35:21,622
<c.magenta>为你的应用添加事件处理支持</c>

739
00:35:21,688 --> 00:35:24,525
<c.magenta>并同时处理这些同时发生的状态变更</c>

740
00:35:25,559 --> 00:35:27,928
<c.magenta>接下来让我们看看样式和外观</c>

741
00:35:28,562 --> 00:35:31,632
<c.magenta>那么很明显 触控条内的样式</c>

742
00:35:31,698 --> 00:35:34,601
<c.magenta>与Apple主显示屏上很不同</c>

743
00:35:35,202 --> 00:35:37,004
<c.magenta>我要提到其中几点</c>

744
00:35:37,070 --> 00:35:39,706
<c.magenta>但我想从你们可能甚至</c>

745
00:35:40,174 --> 00:35:42,910
<c.magenta>这是你能看到的唯一的东西</c>

746
00:35:42,976 --> 00:35:44,278
<c.magenta>带到不同的环境中时</c>

747
00:35:44,845 --> 00:35:46,647
<c.magenta>那么我们的标准存档照片</c>

748
00:35:46,713 --> 00:35:48,315
<c.magenta>就算是光线也非常棒</c>

749
00:35:48,382 --> 00:35:50,217
<c.magenta>如果你使用它</c>

750
00:35:50,284 --> 00:35:53,187
<c.magenta>或也许甚至是在室外</c>

751
00:35:53,754 --> 00:35:56,190
<c.magenta>如果你跟我一样</c>

752
00:35:56,256 --> 00:36:00,494
<c.magenta>OLED显示屏上的黑色消失后</c>

753
00:35:56,256 --> 00:36:00,494
<c.magenta>OLED显示屏上的黑色消失后</c>

754
00:36:01,195 --> 00:36:02,196
<c.magenta>最后</c>

755
00:36:02,262 --> 00:36:04,698
<c.magenta>如果你感到很累</c>

756
00:36:04,765 --> 00:36:07,334
<c.magenta>你可以打开键盘背光灯</c>

757
00:36:08,135 --> 00:36:11,171
<c.magenta>MacBook Pro外观看起来</c>

758
00:36:11,238 --> 00:36:14,308
<c.magenta>当处于这些不同的环境中时</c>

759
00:36:14,942 --> 00:36:19,213
<c.magenta>不同控件的边框颜色</c>

760
00:36:19,613 --> 00:36:21,782
<c.magenta>即便是控件内的符号</c>

761
00:36:21,849 --> 00:36:25,352
<c.magenta>也会对键盘背光灯的参照白点</c>

762
00:36:26,220 --> 00:36:28,822
<c.magenta>因此 如果你实施自己的自定义控件</c>

763
00:36:28,889 --> 00:36:30,390
<c.magenta>你需要确保你可以实现同样的功能</c>

764
00:36:31,091 --> 00:36:34,027
<c.magenta>幸亏这个实现非常简单</c>

765
00:36:34,561 --> 00:36:36,163
<c.magenta>这些是现有的命名颜色</c>

766
00:36:36,230 --> 00:36:38,765
<c.magenta>并且有如何使用它们的语义描述</c>

767
00:36:39,132 --> 00:36:40,901
<c.magenta>一旦你决定使用它们</c>

768
00:36:40,968 --> 00:36:43,971
<c.magenta>它们会动态地相互对抗当前情境</c>

769
00:36:44,037 --> 00:36:46,139
<c.magenta>以决定要拉动哪种颜色</c>

770
00:36:46,406 --> 00:36:49,743
<c.magenta>并考虑是否正在触控条</c>

771
00:36:49,810 --> 00:36:52,513
<c.magenta>以及参考白点</c>

772
00:36:53,981 --> 00:36:57,784
<c.magenta>此外 High Sierra新特性是</c>

773
00:36:57,851 --> 00:37:01,989
<c.magenta>你可以用来匹配系统UI</c>

774
00:36:57,851 --> 00:37:01,989
<c.magenta>你可以用来匹配系统UI</c>

775
00:37:02,055 --> 00:37:04,057
<c.magenta>进行了特别设计</c>

776
00:37:07,294 --> 00:37:10,230
<c.magenta>那么 你要记住的一个重点是</c>

777
00:37:10,297 --> 00:37:11,598
<c.magenta>以利用</c>

778
00:37:11,665 --> 00:37:13,033
<c.magenta>全部的情境敏感性</c>

779
00:37:14,468 --> 00:37:16,336
<c.magenta>那么如果你正在通过层来拉动视图</c>

780
00:37:16,403 --> 00:37:20,741
<c.magenta>你可能会尝试用框架进行初始化</c>

781
00:37:20,807 --> 00:37:23,844
<c.magenta>事件处理、立即更新层的属性</c>

782
00:37:24,411 --> 00:37:27,181
<c.magenta>但你不希望这样做</c>

783
00:37:27,247 --> 00:37:28,448
<c.magenta>并将其设置在层上时</c>

784
00:37:28,515 --> 00:37:30,651
<c.magenta>那会立即解决那些RGB值</c>

785
00:37:30,717 --> 00:37:32,953
<c.magenta>无论当前情境是什么</c>

786
00:37:33,720 --> 00:37:35,856
<c.magenta>那么随着参考白点或亮度的变更</c>

787
00:37:36,156 --> 00:37:39,059
<c.magenta>你的层将保持</c>

788
00:37:40,093 --> 00:37:41,261
<c.magenta>那么我们该怎么做呢？</c>

789
00:37:41,628 --> 00:37:43,730
<c.magenta>嗯 我们可以覆盖这个叫作</c>

790
00:37:43,797 --> 00:37:45,766
<c.magenta>然后从那儿升级我们的层</c>

791
00:37:46,366 --> 00:37:49,369
<c.magenta>这将会被自动调用</c>

792
00:37:49,436 --> 00:37:51,038
<c.magenta>就像它第一次显示在屏幕上</c>

793
00:37:51,104 --> 00:37:53,240
<c.magenta>或窗口中时</c>

794
00:37:54,041 --> 00:37:56,610
<c.magenta>如果你有一个想要设置的动态颜色</c>

795
00:37:56,810 --> 00:37:59,813
<c.magenta>你将那个颜色</c>

796
00:38:00,147 --> 00:38:02,916
<c.magenta>因为再一次 这会维持颜色的语义性质</c>

797
00:38:03,116 --> 00:38:04,852
<c.magenta>及其情境敏感性</c>

798
00:38:05,786 --> 00:38:08,622
<c.magenta>无论何时当颜色变更时</c>

799
00:38:08,689 --> 00:38:10,324
<c.magenta>然后我们就会替你回调这个方法</c>

800
00:38:12,025 --> 00:38:15,429
<c.magenta>同样的方法可以用于</c>

801
00:38:15,495 --> 00:38:17,998
<c.magenta>唯一的不同点是你按照当前情境</c>

802
00:38:18,065 --> 00:38:19,399
<c.magenta>设置颜色</c>

803
00:38:21,235 --> 00:38:24,137
<c.magenta>那么这就是如何利用自定义颜色</c>

804
00:38:24,905 --> 00:38:27,841
<c.magenta>然而 我们的许多控件支持颜色自定义</c>

805
00:38:27,908 --> 00:38:29,176
<c.magenta>在方框外</c>

806
00:38:29,843 --> 00:38:32,246
<c.magenta>你现在可以设置NS按钮的边框颜色</c>

807
00:38:32,312 --> 00:38:35,782
<c.magenta>选中部分的颜色</c>

808
00:38:36,416 --> 00:38:39,286
<c.magenta>你可以使用自带的系统颜色</c>

809
00:38:39,353 --> 00:38:40,954
<c.magenta>如果你有整体的应用主题的话</c>

810
00:38:41,688 --> 00:38:42,789
<c.magenta>这里有一点很酷</c>

811
00:38:42,856 --> 00:38:46,460
<c.magenta>就是这些控件内的文本和图片效果</c>

812
00:38:46,527 --> 00:38:48,295
<c.magenta>根据你所设置的颜色亮度进行调节的</c>

813
00:38:48,729 --> 00:38:50,731
<c.magenta>你其实不必做任何工作</c>

814
00:38:52,733 --> 00:38:54,468
<c.magenta>整个系统中 你可能注意到一件事</c>

815
00:38:54,535 --> 00:38:56,603
<c.magenta>就是这些默认按钮的蓝色</c>

816
00:38:57,304 --> 00:38:58,972
<c.magenta>一定要注意这并不是</c>

817
00:38:59,039 --> 00:39:01,742
<c.magenta>通过将systemBlue颜色</c>

818
00:38:59,039 --> 00:39:01,742
<c.magenta>通过将systemBlue颜色</c>

819
00:39:02,009 --> 00:39:04,611
<c.magenta>其实这些之间稍微有一些</c>

820
00:39:04,678 --> 00:39:07,814
<c.magenta>你可以通过将keyEquivalent</c>

821
00:39:08,048 --> 00:39:09,716
<c.magenta>就像你在主显示屏上做过的那样</c>

822
00:39:12,019 --> 00:39:14,955
<c.magenta>在我们之前看到的这些幻灯片中</c>

823
00:39:15,022 --> 00:39:17,291
<c.magenta>就是这个完成按钮替换了Esc键</c>

824
00:39:17,658 --> 00:39:19,026
<c.magenta>实现方式非常简单</c>

825
00:39:19,092 --> 00:39:21,662
<c.magenta>通过设置escapeKeyReplacement</c>

826
00:39:21,728 --> 00:39:23,697
<c.magenta>在你当前的NSTouchBar上</c>

827
00:39:23,931 --> 00:39:27,534
<c.magenta>无论是哪个控件</c>

828
00:39:28,535 --> 00:39:31,605
<c.magenta>然而考虑何时使用这个是非常重要的</c>

829
00:39:32,039 --> 00:39:33,140
<c.magenta>它其实只能用于</c>

830
00:39:33,207 --> 00:39:35,809
<c.magenta>当用户进入某些模态情境</c>

831
00:39:35,876 --> 00:39:38,846
<c.magenta>且他们可以使用那个控件</c>

832
00:39:39,580 --> 00:39:42,316
<c.magenta>他们在这个情境中所执行的任何行动</c>

833
00:39:42,382 --> 00:39:46,720
<c.magenta>因此如果我编辑这里的照片并轻触完成</c>

834
00:39:47,688 --> 00:39:50,591
<c.magenta>最后 你不需要给这个按钮</c>

835
00:39:50,657 --> 00:39:53,026
<c.magenta>来尝试使其符合Esc键的标准尺寸</c>

836
00:39:53,360 --> 00:39:56,463
<c.magenta>我们会自动应用度量</c>

837
00:39:56,797 --> 00:39:59,666
<c.magenta>甚至会调节文本四周的边距</c>

838
00:39:59,733 --> 00:40:01,368
<c.magenta>使其尽可能地适合大部分字符</c>

839
00:39:59,733 --> 00:40:01,368
<c.magenta>使其尽可能地适合大部分字符</c>

840
00:40:02,369 --> 00:40:05,038
<c.magenta>因此 比如说我们发现完成按钮的</c>

841
00:40:05,105 --> 00:40:06,206
<c.magenta>Gotowe</c>

842
00:40:06,273 --> 00:40:09,109
<c.magenta>即便是Gotowe也能适用</c>

843
00:40:10,010 --> 00:40:12,813
<c.magenta>然而还有最后一招</c>

844
00:40:12,880 --> 00:40:16,350
<c.magenta>尺寸变大</c>

845
00:40:18,051 --> 00:40:20,420
<c.magenta>现在关于触控条中的样式的</c>

846
00:40:20,487 --> 00:40:21,688
<c.magenta>字体</c>

847
00:40:22,556 --> 00:40:25,392
<c.magenta>现在你可能注意到Aqua</c>

848
00:40:25,459 --> 00:40:27,427
<c.magenta>触控条的字体发生了变化</c>

849
00:40:27,494 --> 00:40:30,831
<c.magenta>我们用了San Francisco UI的标准字体</c>

850
00:40:31,298 --> 00:40:34,101
<c.magenta>在触控条中</c>

851
00:40:34,168 --> 00:40:36,403
<c.magenta>San Francisco Condensed字体 字号15</c>

852
00:40:36,904 --> 00:40:38,839
<c.magenta>那么字体和字号都变了</c>

853
00:40:39,439 --> 00:40:41,909
<c.magenta>你们中跟随Mac字体过渡的人</c>

854
00:40:41,975 --> 00:40:45,445
<c.magenta>也许从Chicago</c>

855
00:40:45,512 --> 00:40:47,414
<c.magenta>Helvetica、San Francisco</c>

856
00:40:47,481 --> 00:40:50,250
<c.magenta>你们知道你们不应该在应用中</c>

857
00:40:50,751 --> 00:40:53,287
<c.magenta>相反 你可以使用systemFont</c>

858
00:40:53,353 --> 00:40:56,190
<c.magenta>这将会返回给你这个动态字体</c>

859
00:40:56,256 --> 00:40:58,692
<c.magenta>使用时会根据当前情境决定</c>

860
00:40:58,759 --> 00:41:02,296
<c.magenta>就像那些系统颜色一样</c>

861
00:40:58,759 --> 00:41:02,296
<c.magenta>就像那些系统颜色一样</c>

862
00:41:03,030 --> 00:41:06,400
<c.magenta>此外 还有一个权重变化</c>

863
00:41:07,367 --> 00:41:09,837
<c.magenta>关于字体还有另一个有意思的事</c>

864
00:41:09,903 --> 00:41:13,207
<c.magenta>就是这些在像AVKit Player</c>

865
00:41:13,273 --> 00:41:16,076
<c.magenta>甚至是滑块的组件值中使用的等宽数位</c>

866
00:41:16,610 --> 00:41:17,911
<c.magenta>即便是值改变了</c>

867
00:41:17,978 --> 00:41:20,547
<c.magenta>那些数字也不会像度量调节一样</c>

868
00:41:20,614 --> 00:41:21,682
<c.magenta>它们是等宽的</c>

869
00:41:22,249 --> 00:41:23,083
<c.magenta>那么你可以</c>

870
00:41:23,150 --> 00:41:26,053
<c.magenta>通过尺寸权重的</c>

871
00:41:26,687 --> 00:41:27,921
<c.magenta>来获得同样的效果</c>

872
00:41:28,822 --> 00:41:31,758
<c.magenta>现在 其实有许多有意思的排版功能</c>

873
00:41:31,825 --> 00:41:33,293
<c.magenta>提到San Francisco</c>

874
00:41:33,360 --> 00:41:35,729
<c.magenta>并且过去几年中也有一些相关演讲</c>

875
00:41:35,796 --> 00:41:38,599
<c.magenta>如果你有兴趣了解更多</c>

876
00:41:39,633 --> 00:41:41,435
<c.magenta>然而 触控条中符号的另一个重要类型</c>

877
00:41:41,502 --> 00:41:43,704
<c.magenta>当然是图片了</c>

878
00:41:45,005 --> 00:41:49,209
<c.magenta>而且因为触控条是</c>

879
00:41:49,276 --> 00:41:52,412
<c.magenta>你所要提供的就是为那里使用的图片</c>

880
00:41:53,013 --> 00:41:55,916
<c.magenta>然而 它们应该是专为触控条设计的</c>

881
00:41:56,216 --> 00:41:58,685
<c.magenta>你不应该仅仅是采用工具栏的图标</c>

882
00:41:59,586 --> 00:42:01,388
<c.magenta>此外 你应该使用模板渲染</c>

883
00:41:59,586 --> 00:42:01,388
<c.magenta>此外 你应该使用模板渲染</c>

884
00:42:01,455 --> 00:42:03,590
<c.magenta>来利用那些参考白点和亮度调节</c>

885
00:42:03,657 --> 00:42:04,758
<c.magenta>我之前提到过的</c>

886
00:42:05,826 --> 00:42:08,529
<c.magenta>举例说明 假如我们正在做一个</c>

887
00:42:09,096 --> 00:42:11,365
<c.magenta>我们已经专为触控条做了很好的设计</c>

888
00:42:11,431 --> 00:42:14,201
<c.magenta>并且我们会与其它标准图标一起使用</c>

889
00:42:14,601 --> 00:42:16,170
<c.magenta>总体上看起来很不错</c>

890
00:42:16,503 --> 00:42:19,873
<c.magenta>除了在夜晚 我们把它带回家</c>

891
00:42:19,940 --> 00:42:21,375
<c.magenta>它看起来是这样的</c>

892
00:42:21,942 --> 00:42:25,879
<c.magenta>其它图标都会自动调节</c>

893
00:42:26,580 --> 00:42:27,748
<c.magenta>那么我们不要这样做</c>

894
00:42:29,616 --> 00:42:30,884
<c.magenta>相反 我们可以使用的是</c>

895
00:42:30,951 --> 00:42:33,654
<c.magenta>提供一个通过阿尔法通道</c>

896
00:42:33,720 --> 00:42:36,757
<c.magenta>能与其形状通讯的图片</c>

897
00:42:36,823 --> 00:42:41,161
<c.magenta>以便AppKit可以获取</c>

898
00:42:41,228 --> 00:42:42,296
<c.magenta>比如白色</c>

899
00:42:42,362 --> 00:42:44,998
<c.magenta>甚至是蓝色样式</c>

900
00:42:46,433 --> 00:42:49,837
<c.magenta>现在 在你让设计师动身专为触控条</c>

901
00:42:49,903 --> 00:42:52,806
<c.magenta>以利用模板渲染之前</c>

902
00:42:53,140 --> 00:42:55,008
<c.magenta>请一定要确保查看</c>

903
00:42:55,075 --> 00:42:56,510
<c.magenta>系统已经提供了的全部标准图标</c>

904
00:42:56,910 --> 00:42:59,213
<c.magenta>真的有很多 你从人性化接口指南中</c>

905
00:42:59,279 --> 00:43:00,447
<c.magenta>可以看到全部标准图标</c>

906
00:42:59,279 --> 00:43:00,447
<c.magenta>可以看到全部标准图标</c>

907
00:43:00,781 --> 00:43:04,117
<c.magenta>非常酷的是这些全部都是</c>

908
00:43:04,184 --> 00:43:06,720
<c.magenta>因此你可以非常方便地</c>

909
00:43:06,787 --> 00:43:08,188
<c.magenta>工作量真的很小</c>

910
00:43:09,556 --> 00:43:10,390
<c.magenta>那么</c>

911
00:43:10,457 --> 00:43:12,359
<c.magenta>这些是设计外观的一些注意点</c>

912
00:43:12,426 --> 00:43:14,127
<c.magenta>很酷的是对于最主要的部分</c>

913
00:43:14,194 --> 00:43:15,963
<c.magenta>你可以仅采用系统标准技巧</c>

914
00:43:16,029 --> 00:43:17,731
<c.magenta>然后免费获得许多这样的行为</c>

915
00:43:19,032 --> 00:43:20,834
<c.magenta>接下来让我们谈谈布局</c>

916
00:43:21,502 --> 00:43:22,769
<c.magenta>在Fundamentals演讲中</c>

917
00:43:22,836 --> 00:43:25,973
<c.magenta>你了解了标准触控项布局的方式是</c>

918
00:43:26,039 --> 00:43:27,207
<c.magenta>逐个堆在一起</c>

919
00:43:27,674 --> 00:43:30,711
<c.magenta>你可以使用弹性空间为你的触控项</c>

920
00:43:31,078 --> 00:43:34,581
<c.magenta>或者你可以使用主要触控项</c>

921
00:43:35,516 --> 00:43:39,119
<c.magenta>现在 NSTouchBar中的布局</c>

922
00:43:39,653 --> 00:43:42,356
<c.magenta>触控项自身就提供自己的尺寸信息</c>

923
00:43:42,556 --> 00:43:45,459
<c.magenta>然后NSTouchBar基于那个尺寸</c>

924
00:43:46,360 --> 00:43:47,861
<c.magenta>提到描述那个尺寸</c>

925
00:43:47,928 --> 00:43:50,764
<c.magenta>与在触控条外时一模一样</c>

926
00:43:52,232 --> 00:43:55,068
<c.magenta>比如你覆盖了intrinsicContentSize</c>

927
00:43:55,135 --> 00:43:57,404
<c.magenta>你的控件尺寸</c>

928
00:43:58,305 --> 00:44:01,341
<c.magenta>如果发生任何状态变更</c>

929
00:43:58,305 --> 00:44:01,341
<c.magenta>如果发生任何状态变更</c>

930
00:44:01,608 --> 00:44:04,611
<c.magenta>并且当你需要记录</c>

931
00:44:04,945 --> 00:44:07,347
<c.magenta>你可以调用</c>

932
00:44:07,414 --> 00:44:09,449
<c.magenta>NSTouchBar将会输出一切</c>

933
00:44:10,751 --> 00:44:12,553
<c.magenta>你以前可能用过的另一个方法是</c>

934
00:44:12,786 --> 00:44:15,355
<c.magenta>向控件中添加一个明确的</c>

935
00:44:15,422 --> 00:44:17,124
<c.magenta>然后随时间更新那个常量</c>

936
00:44:17,624 --> 00:44:19,426
<c.magenta>这样也可以 同样地</c>

937
00:44:19,493 --> 00:44:22,162
<c.magenta>NSTouchBar也会输出一切</c>

938
00:44:24,932 --> 00:44:26,400
<c.magenta>当你创建自定义控件时</c>

939
00:44:26,466 --> 00:44:28,702
<c.magenta>你也可能拥有弹性尺寸的控件</c>

940
00:44:28,769 --> 00:44:30,904
<c.magenta>类似NSSlider或NSScrubber</c>

941
00:44:31,338 --> 00:44:34,608
<c.magenta>在这里</c>

942
00:44:34,675 --> 00:44:37,611
<c.magenta>或拥有noIntrinsicMetric的</c>

943
00:44:38,579 --> 00:44:41,815
<c.magenta>NSTouch Bar将利用触控条中的</c>

944
00:44:41,882 --> 00:44:44,251
<c.magenta>并将其划分给这些有弹性宽度的控件</c>

945
00:44:44,885 --> 00:44:45,886
<c.magenta>在本例中</c>

946
00:44:45,953 --> 00:44:47,487
<c.magenta>滑块是那里的唯一控件</c>

947
00:44:47,554 --> 00:44:49,523
<c.magenta>所以它占据了整个可用区域</c>

948
00:44:50,424 --> 00:44:53,160
<c.magenta>现在如果我们想给它限定一个</c>

949
00:44:53,493 --> 00:44:57,564
<c.magenta>我们只需要添加不等式约束即可</c>

950
00:44:58,332 --> 00:45:00,601
<c.magenta>NSTouchBar也会按那样做</c>

951
00:44:58,332 --> 00:45:00,601
<c.magenta>NSTouchBar也会按那样做</c>

952
00:45:01,502 --> 00:45:03,837
<c.magenta>拥有这种弹性的真正好处是</c>

953
00:45:03,937 --> 00:45:06,406
<c.magenta>当用户自定义一个附加触控项时</c>

954
00:45:06,707 --> 00:45:09,710
<c.magenta>它们仍会在控件能有多大方面</c>

955
00:45:09,776 --> 00:45:12,479
<c.magenta>而且用户可以真正最大限度地</c>

956
00:45:14,181 --> 00:45:17,484
<c.magenta>那么这就是如何自定义</c>

957
00:45:17,551 --> 00:45:20,454
<c.magenta>但你可能还想要协调一群项之间的布局</c>

958
00:45:21,755 --> 00:45:23,257
<c.magenta>High Sierra中新增的一个东西是</c>

959
00:45:23,323 --> 00:45:26,026
<c.magenta>prefersEqualWidths属性</c>

960
00:45:26,093 --> 00:45:28,161
<c.magenta>你可以在那个群中包含全部的触控项</c>

961
00:45:28,228 --> 00:45:29,396
<c.magenta>最好是等宽的</c>

962
00:45:30,130 --> 00:45:32,666
<c.magenta>很酷的是这也适用于用户自定义</c>

963
00:45:32,799 --> 00:45:34,134
<c.magenta>因此用户不仅可自定义触控项</c>

964
00:45:34,201 --> 00:45:36,470
<c.magenta>在这个同等尺寸的群内和群外</c>

965
00:45:36,537 --> 00:45:39,406
<c.magenta>而且同等尺寸只能影响</c>

966
00:45:39,473 --> 00:45:41,308
<c.magenta>那些在触控条中实际存在的触控项</c>

967
00:45:41,375 --> 00:45:44,244
<c.magenta>它与用户可能会添加的触控项无关</c>

968
00:45:45,379 --> 00:45:47,481
<c.magenta>这个对于本地化来说也非常好用</c>

969
00:45:47,915 --> 00:45:50,584
<c.magenta>假如其中一个按钮</c>

970
00:45:50,651 --> 00:45:54,288
<c.magenta>我们会选择打破那个等宽</c>

971
00:45:54,454 --> 00:45:56,456
<c.magenta>导致那个触控项被隐藏起来</c>

972
00:45:57,624 --> 00:46:00,194
<c.magenta>然而 有时候仍可能会发生溢出</c>

973
00:45:57,624 --> 00:46:00,194
<c.magenta>然而 有时候仍可能会发生溢出</c>

974
00:46:00,961 --> 00:46:03,397
<c.magenta>此时就要用到可见性优先级</c>

975
00:46:04,731 --> 00:46:08,168
<c.magenta>在这里你可以看到一些开始窗口的UI</c>

976
00:46:08,235 --> 00:46:11,471
<c.magenta>但是如果我们最初以德语版运行</c>

977
00:46:12,005 --> 00:46:15,075
<c.magenta>没有任何剪裁</c>

978
00:46:15,642 --> 00:46:17,644
<c.magenta>原因是触控条中的全部触控项</c>

979
00:46:17,711 --> 00:46:19,746
<c.magenta>不能嵌入我们所分配的空间</c>

980
00:46:19,813 --> 00:46:22,349
<c.magenta>所以NSTouchBar就溢出了</c>

981
00:46:22,416 --> 00:46:23,417
<c.magenta>然后将它隐藏起来</c>

982
00:46:23,984 --> 00:46:27,421
<c.magenta>在本例中</c>

983
00:46:27,487 --> 00:46:28,989
<c.magenta>而不是这个New Collection按钮</c>

984
00:46:29,156 --> 00:46:32,392
<c.magenta>我们可以通过将它</c>

985
00:46:32,459 --> 00:46:33,460
<c.magenta>设置得比其它项低实现</c>

986
00:46:33,927 --> 00:46:36,630
<c.magenta>NSTouchBar将首先分离较低的一个项</c>

987
00:46:37,364 --> 00:46:38,932
<c.magenta>这次 我们会得到这样的东西</c>

988
00:46:38,999 --> 00:46:43,203
<c.magenta>看起来好多了 但隐藏任何触控项</c>

989
00:46:43,937 --> 00:46:46,340
<c.magenta>因此在本例中 我们很可能会做得更好</c>

990
00:46:46,740 --> 00:46:50,377
<c.magenta>我们可以通过High Sierra中</c>

991
00:46:51,512 --> 00:46:54,481
<c.magenta>那么在本例中</c>

992
00:46:54,548 --> 00:46:56,884
<c.magenta>所拥有效果的不同按钮标题</c>

993
00:46:57,384 --> 00:47:01,688
<c.magenta>并且我们不会随意丢弃触控项</c>

994
00:46:57,384 --> 00:47:01,688
<c.magenta>并且我们不会随意丢弃触控项</c>

995
00:47:02,589 --> 00:47:04,992
<c.magenta>我们可以把这个群的优先压缩选项</c>

996
00:47:05,058 --> 00:47:07,728
<c.magenta>设定为hideImages</c>

997
00:47:07,794 --> 00:47:09,129
<c.magenta>看起来就是这样的</c>

998
00:47:09,663 --> 00:47:11,732
<c.magenta>很酷的是这是自动发生的</c>

999
00:47:12,199 --> 00:47:14,735
<c.magenta>我们再也不会让一半按钮有图</c>

1000
00:47:14,801 --> 00:47:16,370
<c.magenta>要么就都有 要么就都没有</c>

1001
00:47:16,837 --> 00:47:18,739
<c.magenta>这里真的有很多的弹性</c>

1002
00:47:19,039 --> 00:47:22,342
<c.magenta>我们可以思考一下我们的图标</c>

1003
00:47:22,609 --> 00:47:25,879
<c.magenta>并且如果出现本例中的情况</c>

1004
00:47:26,747 --> 00:47:29,383
<c.magenta>你甚至可以走得更远</c>

1005
00:47:29,449 --> 00:47:31,485
<c.magenta>你的自定义控件可以压缩的</c>

1006
00:47:31,885 --> 00:47:35,189
<c.magenta>你可以给这些优先选项添加附加选项</c>

1007
00:47:35,455 --> 00:47:38,325
<c.magenta>用于描述你的自定义控件应该</c>

1008
00:47:38,492 --> 00:47:39,693
<c.magenta>以不同的方式进行压缩</c>

1009
00:47:40,894 --> 00:47:44,264
<c.magenta>那么这些是你可以</c>

1010
00:47:44,331 --> 00:47:46,066
<c.magenta>来控制触控项群布局的几种方式</c>

1011
00:47:46,700 --> 00:47:50,037
<c.magenta>然而 你在触控条外使用的容器视图</c>

1012
00:47:50,103 --> 00:47:51,471
<c.magenta>也可以在触控条内使用</c>

1013
00:47:52,639 --> 00:47:54,308
<c.magenta>今天稍早些时候有一场很棒的演讲</c>

1014
00:47:54,374 --> 00:47:55,843
<c.magenta>“选择正确的Cocoa容器视图”</c>

1015
00:47:55,909 --> 00:47:58,145
<c.magenta>讨论了一些在触控条外部使用的</c>

1016
00:47:58,212 --> 00:47:59,746
<c.magenta>容器视图的不同点</c>

1017
00:47:59,947 --> 00:48:02,850
<c.magenta>但我想强调几种</c>

1018
00:47:59,947 --> 00:48:02,850
<c.magenta>但我想强调几种</c>

1019
00:48:03,917 --> 00:48:06,520
<c.magenta>你可以使用NSStackView</c>

1020
00:48:06,587 --> 00:48:10,224
<c.magenta>对触控项的空间或尺寸</c>

1021
00:48:10,290 --> 00:48:13,560
<c.magenta>它们完全去除了这两个按钮之间的空间</c>

1022
00:48:14,828 --> 00:48:17,064
<c.magenta>你还可以</c>

1023
00:48:17,130 --> 00:48:21,401
<c.magenta>用于启动触控条内右侧的</c>

1024
00:48:23,003 --> 00:48:25,706
<c.magenta>杰夫刚才说过如何使用NSScrubber</c>

1025
00:48:25,772 --> 00:48:27,908
<c.magenta>当你拥有这些不受控制的列表触控项时</c>

1026
00:48:27,975 --> 00:48:30,444
<c.magenta>你可以保持一个选择</c>

1027
00:48:30,511 --> 00:48:33,881
<c.magenta>并受益于那个拖动器</c>

1028
00:48:35,249 --> 00:48:37,985
<c.magenta>最后 你可以一直在触控条中</c>

1029
00:48:38,051 --> 00:48:41,722
<c.magenta>以真正地拥有对布局</c>

1030
00:48:42,089 --> 00:48:43,624
<c.magenta>或完全自定义交互的精确控制</c>

1031
00:48:43,924 --> 00:48:46,159
<c.magenta>正如颜色选择器中的偏好列表一样</c>

1032
00:48:49,329 --> 00:48:50,230
<c.magenta>那么这就是布局</c>

1033
00:48:50,864 --> 00:48:52,332
<c.magenta>很酷的是在极大程度上</c>

1034
00:48:52,399 --> 00:48:55,068
<c.magenta>布局跟在触控条外部一模一样</c>

1035
00:48:55,135 --> 00:48:58,338
<c.magenta>因此 你以前使用的任何概念</c>

1036
00:48:58,472 --> 00:48:59,439
<c.magenta>（动画）</c>

1037
00:48:59,506 --> 00:49:01,708
<c.magenta>最后 让我们谈谈如何使用布局</c>

1038
00:48:59,506 --> 00:49:01,708
<c.magenta>最后 让我们谈谈如何使用布局</c>

1039
00:49:01,775 --> 00:49:03,343
<c.magenta>将全部这些真正地捆绑在一起</c>

1040
00:49:04,178 --> 00:49:05,913
<c.magenta>在此之前 我很想重申一下</c>

1041
00:49:05,979 --> 00:49:09,216
<c.magenta>触控条是一个输入设备</c>

1042
00:49:09,650 --> 00:49:12,686
<c.magenta>这不是炫耀</c>

1043
00:49:12,753 --> 00:49:14,421
<c.magenta>动画可能会分散</c>

1044
00:49:14,521 --> 00:49:17,424
<c.magenta>正在试着专注于主显示屏的</c>

1045
00:49:18,091 --> 00:49:21,762
<c.magenta>你所添加的任何动画应该一直</c>

1046
00:49:22,296 --> 00:49:24,765
<c.magenta>因为用户的输入内容会随时变化</c>

1047
00:49:25,132 --> 00:49:27,467
<c.magenta>你的动画也应该是可中断的和可更新的</c>

1048
00:49:28,769 --> 00:49:30,470
<c.magenta>那么 要制作动画</c>

1049
00:49:30,537 --> 00:49:32,873
<c.magenta>就是触控项的尺寸</c>

1050
00:49:33,640 --> 00:49:36,743
<c.magenta>我们之前了解了</c>

1051
00:49:36,810 --> 00:49:37,978
<c.magenta>来控制那个尺寸</c>

1052
00:49:38,312 --> 00:49:41,348
<c.magenta>并且很棒的是要给那个尺寸变更</c>

1053
00:49:41,415 --> 00:49:44,318
<c.magenta>我们所需要做的就是</c>

1054
00:49:44,418 --> 00:49:46,119
<c.magenta>并更新其常量</c>

1055
00:49:46,420 --> 00:49:48,856
<c.magenta>并且我们拥有</c>

1056
00:49:49,356 --> 00:49:52,426
<c.magenta>比如同步动画 甚至还有可中断性</c>

1057
00:49:52,492 --> 00:49:53,827
<c.magenta>仅仅通过这个修改</c>

1058
00:49:55,429 --> 00:49:57,965
<c.magenta>如果我们选择使用</c>

1059
00:49:58,031 --> 00:49:59,566
<c.magenta>来表达触控项的尺寸</c>

1060
00:49:59,766 --> 00:50:02,503
<c.magenta>那么invalidateIntrinsicContentSize</c>

1061
00:49:59,766 --> 00:50:02,503
<c.magenta>那么invalidateIntrinsicContentSize</c>

1062
00:50:02,870 --> 00:50:05,639
<c.magenta>我们所要做的就是</c>

1063
00:50:06,006 --> 00:50:09,409
<c.magenta>将allowsImplicitAnimation设为真</c>

1064
00:50:09,910 --> 00:50:12,179
<c.magenta>我们再次得到了同样的动画效果</c>

1065
00:50:12,246 --> 00:50:13,914
<c.magenta>与我们之前</c>

1066
00:50:15,215 --> 00:50:17,050
<c.magenta>还有一些其它的东西</c>

1067
00:50:17,117 --> 00:50:19,119
<c.magenta>就是无论触控项是否为弹性尺寸</c>

1068
00:50:19,186 --> 00:50:22,890
<c.magenta>那么我们在这里看到因为触控项</c>

1069
00:50:23,490 --> 00:50:27,227
<c.magenta>我们可以在这里采用</c>

1070
00:50:27,561 --> 00:50:29,396
<c.magenta>唯一的不同点也跟以前一样</c>

1071
00:50:29,496 --> 00:50:31,832
<c.magenta>就是当触控项是弹性尺寸时</c>

1072
00:50:31,899 --> 00:50:35,903
<c.magenta>它的宽度为noIntrinsicMetric的</c>

1073
00:50:37,237 --> 00:50:40,874
<c.magenta>现在我们可以把这些捆绑在一起</c>

1074
00:50:41,175 --> 00:50:43,043
<c.magenta>你可以修改激活的触控项</c>

1075
00:50:43,143 --> 00:50:45,312
<c.magenta>它会增长并占据全部可用空间</c>

1076
00:50:45,379 --> 00:50:47,614
<c.magenta>而其它触控项就会缩水</c>

1077
00:50:48,882 --> 00:50:51,852
<c.magenta>那么我们</c>

1078
00:50:52,452 --> 00:50:55,489
<c.magenta>它有一个激活状态</c>

1079
00:50:56,456 --> 00:50:59,760
<c.magenta>当它处于非激活状态时</c>

1080
00:51:00,561 --> 00:51:02,196
<c.magenta>然而 一旦我们将其设为激活状态</c>

1081
00:51:02,462 --> 00:51:06,099
<c.magenta>我们希望它拥有那个可以占据</c>

1082
00:51:06,366 --> 00:51:09,002
<c.magenta>我们可以用noIntrinsicMetric来实现</c>

1083
00:51:10,170 --> 00:51:12,739
<c.magenta>现在我们在触控条中堆叠了一些触控项</c>

1084
00:51:12,906 --> 00:51:15,676
<c.magenta>并且我们给每一个</c>

1085
00:51:16,910 --> 00:51:19,513
<c.magenta>当用户轻触其中一个可折叠视图时</c>

1086
00:51:19,913 --> 00:51:24,084
<c.magenta>我们可以处理那个按压</c>

1087
00:51:24,618 --> 00:51:28,121
<c.magenta>并将其设为非激活状态</c>

1088
00:51:28,922 --> 00:51:31,758
<c.magenta>获取newActiveAccordionView并激活它</c>

1089
00:51:32,626 --> 00:51:34,895
<c.magenta>最后用那个allowsImplicitAnimations</c>

1090
00:51:34,962 --> 00:51:36,230
<c.magenta>列出那个修改的布局</c>

1091
00:51:37,164 --> 00:51:39,333
<c.magenta>我们完全得到了你们所期待的结果</c>

1092
00:51:39,499 --> 00:51:40,834
<c.magenta>非常简单易用</c>

1093
00:51:42,402 --> 00:51:44,338
<c.magenta>那么这就是如何给不同的</c>

1094
00:51:44,404 --> 00:51:47,040
<c.magenta>但你可能还想给触控项内的内容做动画</c>

1095
00:51:47,508 --> 00:51:49,843
<c.magenta>比如不同拖动器内的内容</c>

1096
00:51:50,577 --> 00:51:53,180
<c.magenta>现在如果你使用常量或高于一切的布局</c>

1097
00:51:53,247 --> 00:51:55,349
<c.magenta>并在那里设置框架或更新属性</c>

1098
00:51:55,415 --> 00:51:57,618
<c.magenta>最棒的是不需要额外工作</c>

1099
00:51:57,684 --> 00:51:58,685
<c.magenta>就能实现</c>

1100
00:51:59,152 --> 00:52:01,688
<c.magenta>随着我们用动画重新调整</c>

1101
00:51:59,152 --> 00:52:01,688
<c.magenta>随着我们用动画重新调整</c>

1102
00:52:01,922 --> 00:52:06,660
<c.magenta>你可以看到拖动器的触控项的尺寸</c>

1103
00:52:07,194 --> 00:52:09,663
<c.magenta>甚至其中的图片尺寸也很漂亮地变大了</c>

1104
00:52:10,864 --> 00:52:13,634
<c.magenta>很酷的是我不需要做任何额外工作</c>

1105
00:52:13,700 --> 00:52:15,903
<c.magenta>也可以通过NSScrubber</c>

1106
00:52:16,470 --> 00:52:19,806
<c.magenta>因为NSScrubber覆盖了布局</c>

1107
00:52:19,873 --> 00:52:21,508
<c.magenta>和视图属性</c>

1108
00:52:22,042 --> 00:52:23,877
<c.magenta>而且这些全都是完全免费的</c>

1109
00:52:26,113 --> 00:52:29,249
<c.magenta>你经常在触控条中使用的另一种</c>

1110
00:52:29,683 --> 00:52:30,851
<c.magenta>现在因为你的状态改变了</c>

1111
00:52:30,984 --> 00:52:33,487
<c.magenta>以前你可能升级了这些按钮的属性</c>

1112
00:52:33,687 --> 00:52:36,089
<c.magenta>但你可能需要实现一些</c>

1113
00:52:36,156 --> 00:52:38,425
<c.magenta>它实际上会给那些属性修改添加动画</c>

1114
00:52:39,059 --> 00:52:42,629
<c.magenta>在High Sierra中有一个新功能</c>

1115
00:52:42,696 --> 00:52:44,097
<c.magenta>并在那里升级你的属性</c>

1116
00:52:44,298 --> 00:52:46,967
<c.magenta>你会完全免费获得这些动画</c>

1117
00:52:48,602 --> 00:52:50,771
<c.magenta>如果你关注那个Remind Me Later按钮</c>

1118
00:52:50,838 --> 00:52:53,106
<c.magenta>你会注意到随着图片位置的改变</c>

1119
00:52:53,173 --> 00:52:55,242
<c.magenta>触控条的整体布局也会随之改变</c>

1120
00:52:55,442 --> 00:52:57,010
<c.magenta>我们可以结合这些</c>

1121
00:52:57,077 --> 00:52:59,379
<c.magenta>针对animator</c>

1122
00:52:59,479 --> 00:53:01,281
<c.magenta>然后使用allowsImplicitAnimations</c>

1123
00:52:59,479 --> 00:53:01,281
<c.magenta>然后使用allowsImplicitAnimations</c>

1124
00:53:01,448 --> 00:53:04,551
<c.magenta>来同时应用这两种动画</c>

1125
00:53:06,119 --> 00:53:08,555
<c.magenta>现在 提到创建你自己的自定义控件</c>

1126
00:53:08,622 --> 00:53:10,691
<c.magenta>你可能还想完全自定义动画</c>

1127
00:53:10,757 --> 00:53:13,827
<c.magenta>触控项尺寸或许甚至是独立的</c>

1128
00:53:14,194 --> 00:53:18,365
<c.magenta>比如当你激活这些滑块时发生的</c>

1129
00:53:19,466 --> 00:53:21,869
<c.magenta>现在你可以在这里</c>

1130
00:53:22,069 --> 00:53:25,038
<c.magenta>比如在你的自定义视图上</c>

1131
00:53:25,305 --> 00:53:28,542
<c.magenta>来给自带的视图属性</c>

1132
00:53:29,176 --> 00:53:31,411
<c.magenta>你还可以获取明确的CAAnimations</c>

1133
00:53:31,478 --> 00:53:34,114
<c.magenta>并将其添加到那个视图的内容中</c>

1134
00:53:34,515 --> 00:53:38,819
<c.magenta>或如果你可以在布局覆盖中</c>

1135
00:53:39,486 --> 00:53:41,288
<c.magenta>就是你更新视图属性的地方</c>

1136
00:53:41,355 --> 00:53:44,091
<c.magenta>你可以再一次利用那个</c>

1137
00:53:44,191 --> 00:53:47,628
<c.magenta>然后实际上你就不需要做其它额外操作</c>

1138
00:53:49,029 --> 00:53:50,397
<c.magenta>几年前有一场演讲</c>

1139
00:53:50,464 --> 00:53:53,200
<c.magenta>很具体地描述了这三种不同的方法</c>

1140
00:53:53,267 --> 00:53:56,436
<c.magenta>及其利弊：“Cocoa动画的最佳范例”</c>

1141
00:53:56,737 --> 00:53:59,072
<c.magenta>如果你们想了解更多信息</c>

1142
00:54:00,707 --> 00:54:03,677
<c.magenta>那么我们今天讲了各种各样的内容</c>

1143
00:54:04,011 --> 00:54:06,313
<c.magenta>我希望你们从中获得一些灵感</c>

1144
00:54:06,380 --> 00:54:08,882
<c.magenta>回去之后开始为你的应用</c>

1145
00:54:08,949 --> 00:54:12,152
<c.magenta>并真正打造一种非常了不起的用户体验</c>

1146
00:54:12,452 --> 00:54:14,955
<c.magenta>比如在补充列表项中自定义补充数据</c>

1147
00:54:15,322 --> 00:54:17,057
<c.magenta>创建你自己的拖动器布局</c>

1148
00:54:17,157 --> 00:54:20,027
<c.magenta>或结合gestureRecognizers</c>

1149
00:54:20,093 --> 00:54:22,596
<c.magenta>让你的UI变得非常有意思</c>

1150
00:54:23,130 --> 00:54:24,631
<c.magenta>要获取更多信息 请查看这个网站</c>

1151
00:54:24,698 --> 00:54:27,935
<c.magenta>那里有文档链接和</c>

1152
00:54:28,602 --> 00:54:31,438
<c.magenta>与之相关的大部分演讲</c>

1153
00:54:31,505 --> 00:54:34,041
<c.magenta>但明天同一时间还有一场</c>

1154
00:54:34,274 --> 00:54:36,143
<c.magenta>“创建可视化的丰富用户体验”</c>

1155
00:54:36,210 --> 00:54:39,279
<c.magenta>我会提出一些</c>

1156
00:54:39,346 --> 00:54:41,415
<c.magenta>实现其中一些很有意思的效果的</c>

1157
00:54:41,481 --> 00:54:43,750
<c.magenta>与在触控条中所应用的一样</c>

1158
00:54:45,185 --> 00:54:46,053
<c.magenta>好了 演讲到此结束</c>

1159
00:54:46,153 --> 00:54:48,455
<c.magenta>希望大家度过一个美好的WWDC</c>

1160
00:54:48,822 --> 00:54:49,656
<c.magenta>谢谢大家</c>
