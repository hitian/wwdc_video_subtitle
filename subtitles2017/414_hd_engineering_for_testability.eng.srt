1
00:00:07,516 --> 00:00:15,500
[ Cheering ]

2
00:00:21,516 --> 00:00:27,500
[ Applause ]

3
00:00:29,206 --> 00:00:29,956
&gt;&gt; Hello, everyone.

4
00:00:30,306 --> 00:00:31,546
Welcome to Engineering for

5
00:00:31,546 --> 00:00:32,246
Testability.

6
00:00:33,256 --> 00:00:34,546
My name is Brian Croom, and I

7
00:00:34,546 --> 00:00:36,306
work on the Xcode Team.

8
00:00:37,356 --> 00:00:38,846
My colleague Greg and I, want to

9
00:00:38,846 --> 00:00:39,786
share some things that we've

10
00:00:39,786 --> 00:00:41,896
been learning about testability

11
00:00:42,046 --> 00:00:42,946
and what it means for the

12
00:00:42,946 --> 00:00:45,486
process of developing great

13
00:00:48,826 --> 00:00:48,936
apps.

14
00:00:49,136 --> 00:00:50,776
I'll start by talking about what

15
00:00:50,776 --> 00:00:52,296
it means for an app's code to be

16
00:00:52,346 --> 00:00:52,766
testable.

17
00:00:53,686 --> 00:00:55,316
And we'll see some examples of

18
00:00:55,316 --> 00:00:56,476
techniques that can be applied

19
00:00:56,546 --> 00:00:58,376
to improving testability of an

20
00:00:58,376 --> 00:00:59,746
existing code.

21
00:01:01,276 --> 00:01:03,286
Then Gregg will come up, and

22
00:01:03,286 --> 00:01:04,616
talk about some ways of working

23
00:01:04,616 --> 00:01:06,196
with your test suite to help

24
00:01:06,196 --> 00:01:08,146
ensure that it helps support the

25
00:01:08,146 --> 00:01:09,986
development of your app, even as

26
00:01:09,986 --> 00:01:11,516
it grows in size and complexity.

27
00:01:14,256 --> 00:01:15,786
So, let's dive in, and talk

28
00:01:15,786 --> 00:01:16,896
about testability.

29
00:01:17,346 --> 00:01:20,616
I remember a while back, when I

30
00:01:20,616 --> 00:01:21,876
was first learning about writing

31
00:01:22,386 --> 00:01:22,666
tests.

32
00:01:23,746 --> 00:01:25,116
I'd been hearing a lot about how

33
00:01:25,116 --> 00:01:26,806
a test suite could help during

34
00:01:26,806 --> 00:01:27,766
the development of my app.

35
00:01:27,966 --> 00:01:30,816
How it could provide confidence,

36
00:01:31,176 --> 00:01:32,656
that the code I was writing was

37
00:01:32,656 --> 00:01:33,906
working the way it was supposed

38
00:01:34,646 --> 00:01:34,716
to.

39
00:01:35,636 --> 00:01:36,766
How it could help patch

40
00:01:36,826 --> 00:01:38,916
regressions in my code as my app

41
00:01:39,066 --> 00:01:40,266
grew and changed over time.

42
00:01:40,866 --> 00:01:43,626
And how it could serve as

43
00:01:43,626 --> 00:01:45,206
executable documentation for my

44
00:01:45,206 --> 00:01:45,506
code.

45
00:01:46,126 --> 00:01:49,066
But, I would start writing a

46
00:01:49,066 --> 00:01:51,636
test, and get stuck before I'd

47
00:01:51,636 --> 00:01:52,496
gotten very far.

48
00:01:53,136 --> 00:01:56,166
It felt as if my app's code were

49
00:01:56,166 --> 00:01:57,976
actively trying to prevent me

50
00:01:57,976 --> 00:01:58,876
from writing the test.

51
00:01:59,416 --> 00:02:02,946
It took a while, but eventually

52
00:01:59,416 --> 00:02:02,946
It took a while, but eventually

53
00:02:02,946 --> 00:02:04,256
I discovered that I was

54
00:02:04,256 --> 00:02:06,076
structuring my code in a way

55
00:02:06,076 --> 00:02:07,236
that interfered with effective

56
00:02:07,286 --> 00:02:07,500
testing.

57
00:02:10,895 --> 00:02:12,386
To explore what this means,

58
00:02:12,896 --> 00:02:14,056
let's first take a look at a

59
00:02:14,056 --> 00:02:15,936
unit test for some code that is

60
00:02:15,936 --> 00:02:18,486
readily testable, sorting an

61
00:02:18,876 --> 00:02:18,946
array.

62
00:02:21,456 --> 00:02:23,636
This is a test that exercises

63
00:02:23,636 --> 00:02:25,186
the Sorted Method from the Swift

64
00:02:25,186 --> 00:02:25,966
Standard Library.

65
00:02:26,676 --> 00:02:29,796
It begins by setting up an array

66
00:02:29,796 --> 00:02:30,876
of unsorted values.

67
00:02:31,556 --> 00:02:35,446
It calls the sorted method on

68
00:02:35,446 --> 00:02:35,926
that array.

69
00:02:36,646 --> 00:02:39,556
And then asserts that the

70
00:02:39,556 --> 00:02:41,606
returned array has the values in

71
00:02:41,686 --> 00:02:44,996
the expected order.

72
00:02:45,186 --> 00:02:47,366
Generalizing this, we can see

73
00:02:47,366 --> 00:02:49,056
that the test structure consists

74
00:02:49,056 --> 00:02:51,226
of first, setting up any

75
00:02:51,226 --> 00:02:53,386
required input state or values,

76
00:02:54,526 --> 00:02:56,136
then, calling the code being

77
00:02:56,136 --> 00:02:59,386
tested, and finally, asserting

78
00:02:59,386 --> 00:03:00,556
that the returned output is

79
00:02:59,386 --> 00:03:00,556
that the returned output is

80
00:03:00,556 --> 00:03:01,746
correct.

81
00:03:02,416 --> 00:03:04,356
This is sometimes referred to as

82
00:03:04,356 --> 00:03:05,956
the Arrange Act Assert Pattern.

83
00:03:06,586 --> 00:03:11,426
So, we've seen that sorted is a

84
00:03:11,426 --> 00:03:13,206
nicely testable piece of code.

85
00:03:14,266 --> 00:03:15,466
But I know what you're thinking,

86
00:03:16,176 --> 00:03:17,396
"My app's code doesn't have a

87
00:03:17,486 --> 00:03:19,426
single sorting algorithm in it."

88
00:03:20,496 --> 00:03:22,056
In my experience, most of the

89
00:03:22,056 --> 00:03:23,486
code in apps, looks pretty

90
00:03:23,486 --> 00:03:24,306
different than the sorting

91
00:03:24,306 --> 00:03:24,816
algorithm.

92
00:03:25,276 --> 00:03:27,616
Still, there are some

93
00:03:27,616 --> 00:03:29,326
characteristics of the sorted

94
00:03:29,326 --> 00:03:31,116
method that we can strive to

95
00:03:31,116 --> 00:03:32,426
achieve in our app's code, and

96
00:03:32,836 --> 00:03:34,016
to make them more testable.

97
00:03:35,286 --> 00:03:38,206
Specifically, testable code

98
00:03:38,206 --> 00:03:39,836
provides a way for its clients

99
00:03:39,836 --> 00:03:41,516
to have control over all of the

100
00:03:41,516 --> 00:03:42,836
inputs that it operates on.

101
00:03:43,416 --> 00:03:46,446
It provides a way for its

102
00:03:46,446 --> 00:03:48,276
clients to inspect any output

103
00:03:48,276 --> 00:03:49,026
being generated.

104
00:03:49,656 --> 00:03:52,436
And it avoids relying on

105
00:03:52,436 --> 00:03:54,166
internal state that could affect

106
00:03:54,166 --> 00:03:55,346
the code's behavior later on.

107
00:03:55,346 --> 00:04:02,106
I want to use code examples to

108
00:03:55,346 --> 00:04:02,106
I want to use code examples to

109
00:04:02,416 --> 00:04:03,306
demonstrate a couple of

110
00:04:03,306 --> 00:04:05,016
techniques that can be used to

111
00:04:05,016 --> 00:04:06,616
help application code take on

112
00:04:06,616 --> 00:04:08,636
these characteristics, and thus,

113
00:04:08,636 --> 00:04:09,876
improve its testability.

114
00:04:13,836 --> 00:04:15,656
The first technique is how to

115
00:04:15,656 --> 00:04:16,916
introduce protocols and

116
00:04:16,916 --> 00:04:18,336
parameterization into a piece of

117
00:04:18,336 --> 00:04:18,500
code.

118
00:04:21,406 --> 00:04:23,456
For this example, imagine a

119
00:04:23,456 --> 00:04:25,466
document browser app, that is

120
00:04:25,466 --> 00:04:27,056
capable of previewing documents

121
00:04:27,056 --> 00:04:29,046
of various types, and has the

122
00:04:29,046 --> 00:04:30,406
ability to switch to a different

123
00:04:30,406 --> 00:04:31,776
app for viewing it in more

124
00:04:31,776 --> 00:04:33,766
detail or editing it.

125
00:04:34,936 --> 00:04:36,676
The previous screen we see here,

126
00:04:36,676 --> 00:04:38,086
includes an open button for

127
00:04:38,086 --> 00:04:39,546
this, along with a segmented

128
00:04:39,546 --> 00:04:40,896
control for choosing [inaudible]

129
00:04:41,146 --> 00:04:42,546
open for viewing or editing.

130
00:04:42,546 --> 00:04:46,776
So, let's have a look at the

131
00:04:46,776 --> 00:04:48,506
first try at some code for this

132
00:04:48,856 --> 00:04:49,000
screen.

133
00:04:51,716 --> 00:04:52,796
So, the event handler in the

134
00:04:52,796 --> 00:04:54,216
view controller that gets

135
00:04:54,216 --> 00:04:55,626
invoked when that Open button is

136
00:04:56,636 --> 00:04:56,766
tapped.

137
00:04:58,996 --> 00:05:00,216
It starts with some business

138
00:04:58,996 --> 00:05:00,216
It starts with some business

139
00:05:00,216 --> 00:05:02,756
logic for constructing a URL to

140
00:05:02,756 --> 00:05:04,536
be used to request that iOS

141
00:05:04,536 --> 00:05:06,186
switch to the other app.

142
00:05:08,216 --> 00:05:10,586
Then, it uses the shared UI

143
00:05:10,586 --> 00:05:12,356
application instance, provided

144
00:05:12,356 --> 00:05:14,576
by UIKit, to determine whether

145
00:05:14,576 --> 00:05:15,806
the system is able to handle

146
00:05:15,806 --> 00:05:18,256
this Open request, and perform

147
00:05:18,256 --> 00:05:19,926
the open URL action if it is.

148
00:05:20,596 --> 00:05:23,386
And if not, it calls a helper

149
00:05:23,386 --> 00:05:25,386
method to show some UI to direct

150
00:05:25,386 --> 00:05:26,526
the user to install the other

151
00:05:26,526 --> 00:05:27,000
app.

152
00:05:30,086 --> 00:05:31,536
Now, I want to write some tests

153
00:05:31,696 --> 00:05:32,996
to make sure that this Open

154
00:05:32,996 --> 00:05:34,186
button is working the way it's

155
00:05:34,186 --> 00:05:35,436
supposed to.

156
00:05:36,916 --> 00:05:38,196
There are a couple of different

157
00:05:38,196 --> 00:05:39,896
ways to approach testing this.

158
00:05:41,446 --> 00:05:43,346
One option would be to write a

159
00:05:43,346 --> 00:05:43,916
UI test.

160
00:05:45,216 --> 00:05:46,566
We ask to launch the app,

161
00:05:46,566 --> 00:05:48,886
navigate to this screen, tap on

162
00:05:48,936 --> 00:05:50,316
the [inaudible] control, to peck

163
00:05:50,316 --> 00:05:52,256
and open mode, tap the Open

164
00:05:52,256 --> 00:05:55,196
button, and then verify that the

165
00:05:55,196 --> 00:05:56,506
phone switched to show the other

166
00:05:56,506 --> 00:05:57,186
app.

167
00:05:57,446 --> 00:06:00,196
While this would work, there are

168
00:05:57,446 --> 00:06:00,196
While this would work, there are

169
00:06:00,196 --> 00:06:01,446
some drawbacks to this approach.

170
00:06:01,886 --> 00:06:04,866
For one, the task would probably

171
00:06:04,866 --> 00:06:07,006
take a while to run, especially

172
00:06:07,006 --> 00:06:08,836
if I wanted to expand it to test

173
00:06:08,836 --> 00:06:09,976
with several different documents

174
00:06:09,976 --> 00:06:11,066
types for the different open

175
00:06:11,066 --> 00:06:11,466
modes.

176
00:06:11,996 --> 00:06:15,086
The bigger problem, however, is

177
00:06:15,086 --> 00:06:17,606
that a UI test would have no way

178
00:06:17,606 --> 00:06:19,206
to inspect that URL that was

179
00:06:19,206 --> 00:06:21,366
being generated, to request that

180
00:06:21,366 --> 00:06:22,236
iOS switch apps.

181
00:06:23,166 --> 00:06:24,526
And that URL is really something

182
00:06:24,526 --> 00:06:25,436
that I want to be able to

183
00:06:25,436 --> 00:06:26,576
inspect more precisely.

184
00:06:28,176 --> 00:06:29,626
So, it really feels like a unit

185
00:06:29,626 --> 00:06:30,876
test is more appropriate for the

186
00:06:30,876 --> 00:06:31,556
situation.

187
00:06:34,416 --> 00:06:35,586
So, let's see what it would take

188
00:06:35,586 --> 00:06:36,836
to write a unit test for this

189
00:06:36,836 --> 00:06:37,000
code.

190
00:06:40,016 --> 00:06:41,806
First, you need an instance of

191
00:06:41,806 --> 00:06:42,756
the view controller to work

192
00:06:42,756 --> 00:06:42,926
with.

193
00:06:44,346 --> 00:06:45,286
My view controller uses a

194
00:06:45,286 --> 00:06:47,406
storyboard for its UI, so I'll

195
00:06:47,406 --> 00:06:48,986
ask UI Storyboard to give me an

196
00:06:48,986 --> 00:06:50,126
instance of the view controller.

197
00:06:50,646 --> 00:06:54,616
Then we need to load the view to

198
00:06:55,976 --> 00:06:57,186
populate that [inaudible]

199
00:06:57,186 --> 00:06:59,856
control property, so that we --

200
00:06:59,856 --> 00:07:01,776
it's populated by the view data.

201
00:06:59,856 --> 00:07:01,776
it's populated by the view data.

202
00:07:01,776 --> 00:07:03,786
We can then configure that for

203
00:07:03,786 --> 00:07:05,096
our open mode.

204
00:07:05,756 --> 00:07:07,406
Provide a document to work with.

205
00:07:08,106 --> 00:07:12,136
And with the setup finally

206
00:07:12,136 --> 00:07:13,566
complete, we're now ready to

207
00:07:13,566 --> 00:07:15,546
call the method being tested.

208
00:07:18,116 --> 00:07:19,576
But what do we do now?

209
00:07:20,836 --> 00:07:22,046
It's not so clear what kind of

210
00:07:22,046 --> 00:07:23,000
assertion we could write here.

211
00:07:27,056 --> 00:07:29,176
Let's go back to the code, and

212
00:07:29,176 --> 00:07:30,346
look more closely at what makes

213
00:07:30,346 --> 00:07:32,146
this challenging to test.

214
00:07:34,386 --> 00:07:36,476
For one thing, just being in a

215
00:07:36,476 --> 00:07:37,806
view controller, made the

216
00:07:37,806 --> 00:07:39,346
methods test more complicated.

217
00:07:39,986 --> 00:07:40,806
You're going to jump through

218
00:07:40,806 --> 00:07:41,436
some hoops to get the view

219
00:07:41,436 --> 00:07:42,506
controller instance to work

220
00:07:42,506 --> 00:07:42,656
with.

221
00:07:43,236 --> 00:07:46,776
Then here, we're pulling input

222
00:07:46,776 --> 00:07:48,286
state directly from the view.

223
00:07:48,286 --> 00:07:50,646
[Inaudible] of the test had to

224
00:07:50,646 --> 00:07:52,536
force the view to load, and then

225
00:07:52,576 --> 00:07:54,636
indirectly provide the input by

226
00:07:54,636 --> 00:07:56,066
setting a property on some

227
00:07:56,776 --> 00:08:00,066
sub-view.

228
00:07:56,776 --> 00:08:00,066
sub-view.

229
00:08:00,266 --> 00:08:01,966
The biggest problem though was

230
00:08:01,966 --> 00:08:03,826
this usage of a UI application

231
00:08:03,826 --> 00:08:04,706
shared instance.

232
00:08:08,516 --> 00:08:10,286
The return value from this call

233
00:08:10,286 --> 00:08:12,816
to can open URL, is effectively

234
00:08:12,816 --> 00:08:14,126
another input for the method.

235
00:08:15,586 --> 00:08:16,966
But since this relies on global

236
00:08:16,966 --> 00:08:18,676
system state, there's no

237
00:08:18,676 --> 00:08:20,356
programmatic way for the test to

238
00:08:20,356 --> 00:08:21,506
control the result of this

239
00:08:21,506 --> 00:08:22,000
query.

240
00:08:25,396 --> 00:08:26,606
Nor is there a good way for a

241
00:08:26,606 --> 00:08:28,306
unit test to observe the side

242
00:08:28,306 --> 00:08:29,836
effects of opening a URL.

243
00:08:30,616 --> 00:08:33,806
In fact, after calling this, the

244
00:08:33,806 --> 00:08:35,155
test render app would actually

245
00:08:35,155 --> 00:08:36,635
be sent to the background, and

246
00:08:36,635 --> 00:08:37,546
there'd be no way to bring it

247
00:08:37,546 --> 00:08:38,206
back to the foreground

248
00:08:38,206 --> 00:08:38,765
afterwards.

249
00:08:38,765 --> 00:08:42,645
So, let's see what we can do to

250
00:08:42,645 --> 00:08:43,946
improve the testability of this

251
00:08:43,946 --> 00:08:44,206
code.

252
00:08:44,856 --> 00:08:48,846
We can start by getting it out

253
00:08:48,846 --> 00:08:49,586
of the view controller.

254
00:08:50,046 --> 00:08:53,076
Let's introduce a new document

255
00:08:53,076 --> 00:08:55,206
opener class, to encapsulate

256
00:08:55,206 --> 00:08:56,206
this logic and behavior.

257
00:08:58,756 --> 00:09:00,506
The open mode and document

258
00:08:58,756 --> 00:09:00,506
The open mode and document

259
00:09:00,506 --> 00:09:02,426
inputs, should now be provided a

260
00:09:02,426 --> 00:09:04,126
simple method arguments that the

261
00:09:04,126 --> 00:09:05,346
test can pass indirectly.

262
00:09:05,996 --> 00:09:09,306
But we still have to fix the

263
00:09:09,306 --> 00:09:11,026
problems caused by that shared

264
00:09:11,026 --> 00:09:12,496
UI application incidence.

265
00:09:13,026 --> 00:09:17,246
What can we do about that?

266
00:09:18,056 --> 00:09:20,086
Well, to start, we can stop

267
00:09:20,086 --> 00:09:21,336
using that [inaudible] accessor

268
00:09:21,336 --> 00:09:22,376
directly into method.

269
00:09:22,966 --> 00:09:25,696
Let's add an initializer to the

270
00:09:25,696 --> 00:09:27,786
class that lets us pass in a

271
00:09:27,786 --> 00:09:29,776
particular application instance.

272
00:09:30,316 --> 00:09:34,126
We can provide a default value

273
00:09:34,126 --> 00:09:35,986
for the argument, so the

274
00:09:35,986 --> 00:09:36,336
[inaudible] in the view

275
00:09:36,336 --> 00:09:37,436
controller, doesn't have to

276
00:09:37,436 --> 00:09:38,426
worry about this detail.

277
00:09:38,996 --> 00:09:44,546
Back in the open method, we then

278
00:09:44,546 --> 00:09:45,556
switch over to use the

279
00:09:45,556 --> 00:09:47,006
application instance that was

280
00:09:47,006 --> 00:09:49,416
passed in.

281
00:09:49,636 --> 00:09:50,366
Let's see how far this

282
00:09:50,366 --> 00:09:51,356
refactoring gets us.

283
00:09:55,016 --> 00:09:56,556
If we try to rewrite our test

284
00:09:56,556 --> 00:09:58,536
now, with the document open or

285
00:09:58,536 --> 00:10:00,116
in its current state, we'll

286
00:09:58,536 --> 00:10:00,116
in its current state, we'll

287
00:10:00,116 --> 00:10:01,006
still find ourselves getting

288
00:10:01,006 --> 00:10:01,606
stuck.

289
00:10:02,896 --> 00:10:03,786
You want to pass in an

290
00:10:03,786 --> 00:10:04,836
application instance that we

291
00:10:04,836 --> 00:10:05,966
have control over.

292
00:10:06,566 --> 00:10:07,886
So, you can imagine sub-classing

293
00:10:07,886 --> 00:10:10,156
UI application, overriding the

294
00:10:10,156 --> 00:10:12,236
can open URL and open methods,

295
00:10:12,456 --> 00:10:13,896
to get the control that we need.

296
00:10:14,166 --> 00:10:16,616
However, it turns out that UI

297
00:10:16,616 --> 00:10:18,486
application strictly enforces

298
00:10:18,486 --> 00:10:19,446
its singleton nature.

299
00:10:20,166 --> 00:10:21,476
And throws an exception to try

300
00:10:21,476 --> 00:10:23,086
to make a second instance, even

301
00:10:23,086 --> 00:10:24,000
if it's a subclass.

302
00:10:27,046 --> 00:10:28,006
So, instead of using

303
00:10:28,066 --> 00:10:29,876
sub-classing, to get the control

304
00:10:29,876 --> 00:10:32,176
that we need, let's instead add

305
00:10:32,176 --> 00:10:33,766
a protocol, URL Opening.

306
00:10:34,316 --> 00:10:38,136
We go to protocol, two methods,

307
00:10:38,786 --> 00:10:39,756
with precisely the same

308
00:10:39,756 --> 00:10:41,596
signatures as the application

309
00:10:41,596 --> 00:10:43,506
methods that we've been using up

310
00:10:44,166 --> 00:10:47,506
to this point.

311
00:10:47,506 --> 00:10:49,546
We still want UI application to

312
00:10:49,546 --> 00:10:50,966
be the primary implementation of

313
00:10:50,966 --> 00:10:51,596
this protocol.

314
00:10:52,876 --> 00:10:54,626
So, we'll throw an extension on

315
00:10:54,626 --> 00:10:56,466
UI application to give it the

316
00:10:56,466 --> 00:10:57,726
URL opening conformance.

317
00:10:58,226 --> 00:11:02,066
Since the method signatures line

318
00:10:58,226 --> 00:11:02,066
Since the method signatures line

319
00:11:02,066 --> 00:11:03,736
up exactly, you don't have to

320
00:11:03,736 --> 00:11:05,106
add any additional code in the

321
00:11:05,106 --> 00:11:05,896
extension to get the

322
00:11:05,896 --> 00:11:06,386
conformance.

323
00:11:06,426 --> 00:11:12,056
With a protocol in place, let's

324
00:11:12,056 --> 00:11:13,736
update the document opener to

325
00:11:13,736 --> 00:11:15,436
use the protocol instead of

326
00:11:15,436 --> 00:11:17,000
requiring UI application itself.

327
00:11:20,366 --> 00:11:21,946
First, we change the property

328
00:11:21,946 --> 00:11:24,306
and initialize a parameter to

329
00:11:24,306 --> 00:11:25,766
accept any implementation of the

330
00:11:25,766 --> 00:11:26,856
URL opening protocol.

331
00:11:27,446 --> 00:11:30,216
Note that we're still able to

332
00:11:30,216 --> 00:11:31,716
keep the shared UI application

333
00:11:31,716 --> 00:11:32,846
instance with the default

334
00:11:32,846 --> 00:11:34,816
argument as a convenience when

335
00:11:34,816 --> 00:11:35,506
we use it in the view

336
00:11:35,506 --> 00:11:35,986
controller.

337
00:11:39,316 --> 00:11:40,856
A final change requires the

338
00:11:40,856 --> 00:11:43,176
document opener simply to adopt

339
00:11:43,176 --> 00:11:45,416
the URL opener property name.

340
00:11:48,576 --> 00:11:49,826
With that, let's return to the

341
00:11:49,826 --> 00:11:51,546
test and see how the pieces fit

342
00:11:51,546 --> 00:11:52,000
together.

343
00:11:57,046 --> 00:11:58,796
Since UI Application doesn't

344
00:11:58,796 --> 00:12:00,196
give us the control that we need

345
00:11:58,796 --> 00:12:00,196
give us the control that we need

346
00:12:00,196 --> 00:12:02,146
in our test, we want to create a

347
00:12:02,146 --> 00:12:04,076
secondary mock implementation of

348
00:12:04,076 --> 00:12:06,566
the protocol, to use in its

349
00:12:08,436 --> 00:12:08,566
place.

350
00:12:08,746 --> 00:12:10,506
Here we add a sub-implementation

351
00:12:10,596 --> 00:12:13,866
of the two methods.

352
00:12:13,866 --> 00:12:16,246
The can open URL method acts as

353
00:12:16,246 --> 00:12:17,516
an input from the document

354
00:12:17,516 --> 00:12:17,896
opener.

355
00:12:18,726 --> 00:12:19,596
So, the test needs to have

356
00:12:19,596 --> 00:12:20,776
control over this input.

357
00:12:21,806 --> 00:12:22,816
We can get that by having the

358
00:12:22,816 --> 00:12:24,716
implementation return the value

359
00:12:24,716 --> 00:12:26,276
of a property that the test can

360
00:12:26,276 --> 00:12:27,096
set beforehand.

361
00:12:30,296 --> 00:12:32,106
The open method, act as an

362
00:12:32,106 --> 00:12:33,636
output from the document opener.

363
00:12:34,836 --> 00:12:35,776
The test wants to be able to

364
00:12:35,776 --> 00:12:37,996
access any URL that was passed

365
00:12:37,996 --> 00:12:38,696
into this method.

366
00:12:39,176 --> 00:12:41,916
We can achieve that by stashing

367
00:12:41,916 --> 00:12:43,916
the URL into a property for the

368
00:12:43,976 --> 00:12:45,346
test to -- to read afterwards.

369
00:12:48,956 --> 00:12:50,616
So, let's go ahead and write the

370
00:12:50,616 --> 00:12:51,000
test.

371
00:12:53,436 --> 00:12:54,726
First, we create an instance of

372
00:12:54,726 --> 00:12:56,146
our mock URL opener that we just

373
00:12:56,146 --> 00:12:58,306
wrote, and configure the input

374
00:12:58,546 --> 00:12:59,706
using the can open property.

375
00:13:02,296 --> 00:13:03,446
And create a document opener.

376
00:13:03,446 --> 00:13:06,046
And we pass in that mock URL

377
00:13:06,046 --> 00:13:07,106
opener as the argument.

378
00:13:07,666 --> 00:13:11,756
With that setup finished, we can

379
00:13:11,756 --> 00:13:14,216
call the open method, passing in

380
00:13:14,216 --> 00:13:15,696
document and open mode values,

381
00:13:16,066 --> 00:13:18,186
to act as the rest of the input.

382
00:13:20,316 --> 00:13:22,296
And we can then assert that the

383
00:13:22,296 --> 00:13:24,116
opened URL property of the mock

384
00:13:24,116 --> 00:13:26,216
URL opener, has been set to the

385
00:13:26,216 --> 00:13:27,036
expected URL.

386
00:13:27,666 --> 00:13:30,966
This one assertion, is testing

387
00:13:30,966 --> 00:13:32,446
both at the open method was

388
00:13:32,446 --> 00:13:34,756
called at all, as well as the

389
00:13:34,756 --> 00:13:36,436
URL passed in contains the

390
00:13:36,436 --> 00:13:37,006
correct data.

391
00:13:40,696 --> 00:13:42,186
With that test under our belt,

392
00:13:42,546 --> 00:13:43,606
you could continue to write

393
00:13:43,606 --> 00:13:45,046
tests for other variations of

394
00:13:45,046 --> 00:13:47,286
input data, such as when the can

395
00:13:47,286 --> 00:13:48,626
open property is set to false.

396
00:13:48,626 --> 00:13:50,436
But we have a lot more to cover,

397
00:13:50,436 --> 00:13:51,806
so let's just leave it there.

398
00:13:55,646 --> 00:13:57,776
So, in this example, you

399
00:13:57,776 --> 00:13:59,766
performed a few refactorings to

400
00:13:59,766 --> 00:14:01,406
allow us to write unit tests for

401
00:13:59,766 --> 00:14:01,406
allow us to write unit tests for

402
00:14:01,406 --> 00:14:02,000
our code.

403
00:14:04,436 --> 00:14:05,506
We pulled out explicit

404
00:14:05,506 --> 00:14:07,046
references to a shared singleton

405
00:14:07,046 --> 00:14:09,416
instance, and replaced them with

406
00:14:09,416 --> 00:14:11,516
parameterized input to offer

407
00:14:11,516 --> 00:14:12,246
substitution.

408
00:14:13,666 --> 00:14:15,566
This is sometimes referred to as

409
00:14:15,566 --> 00:14:17,976
a penancy injection.

410
00:14:18,196 --> 00:14:20,186
In this example, we use an

411
00:14:20,186 --> 00:14:22,356
initializer parameter to achieve

412
00:14:22,356 --> 00:14:22,916
this.

413
00:14:23,296 --> 00:14:24,466
We could also have used a

414
00:14:24,466 --> 00:14:26,636
property setter, or a parameter

415
00:14:26,636 --> 00:14:27,500
of the method being tested.

416
00:14:31,196 --> 00:14:33,236
We created a protocol to

417
00:14:33,236 --> 00:14:34,276
decouple the code from the

418
00:14:34,276 --> 00:14:35,396
concrete class that it

419
00:14:35,396 --> 00:14:37,000
previously depended on.

420
00:14:39,096 --> 00:14:40,396
And we created a test

421
00:14:40,396 --> 00:14:42,756
implementation to use in its

422
00:14:42,756 --> 00:14:43,176
place.

423
00:14:43,176 --> 00:14:45,506
And it gave us the control that

424
00:14:45,506 --> 00:14:46,826
we needed over the inputs, and

425
00:14:47,426 --> 00:14:49,346
the visibility into the outputs.

426
00:14:56,276 --> 00:14:58,656
Next, I want to look at how

427
00:14:58,656 --> 00:15:00,356
separating out logic from

428
00:14:58,656 --> 00:15:00,356
separating out logic from

429
00:15:00,356 --> 00:15:02,176
effects, can also be used to

430
00:15:02,176 --> 00:15:03,386
enhance testability.

431
00:15:07,636 --> 00:15:10,226
The example here is an on-disk

432
00:15:10,316 --> 00:15:12,466
cache class, which might be used

433
00:15:12,466 --> 00:15:14,526
by an app for faster retrieval

434
00:15:14,526 --> 00:15:15,806
of assets that have been

435
00:15:15,806 --> 00:15:17,346
previously downloaded from a

436
00:15:17,856 --> 00:15:18,000
server.

437
00:15:20,946 --> 00:15:22,866
This cache defines a script for

438
00:15:22,866 --> 00:15:24,066
representing the items that it

439
00:15:24,066 --> 00:15:24,416
stores.

440
00:15:24,896 --> 00:15:26,926
It defines the path to the item

441
00:15:26,926 --> 00:15:28,936
on the file system, how long

442
00:15:28,936 --> 00:15:30,436
it's been in the cache, and its

443
00:15:30,436 --> 00:15:31,146
size on disk.

444
00:15:31,656 --> 00:15:34,166
And it provides a way to get the

445
00:15:34,166 --> 00:15:35,706
set of all the items currently

446
00:15:35,706 --> 00:15:36,586
stored in the cache.

447
00:15:40,096 --> 00:15:41,176
The method that you want to look

448
00:15:41,176 --> 00:15:43,216
at now, though, is a cleanup

449
00:15:43,216 --> 00:15:43,586
method.

450
00:15:44,316 --> 00:15:45,096
It's meant to be called

451
00:15:45,096 --> 00:15:46,816
periodically, to ensure that the

452
00:15:46,816 --> 00:15:47,976
cache doesn't grow to take up

453
00:15:47,976 --> 00:15:49,146
too much space in the file

454
00:15:49,146 --> 00:15:49,486
system.

455
00:15:49,836 --> 00:15:53,136
So, let's have a look at the

456
00:15:53,136 --> 00:15:54,716
starting implementation for this

457
00:15:55,176 --> 00:15:55,326
method.

458
00:15:57,256 --> 00:15:59,716
First, it asks for the set of

459
00:15:59,716 --> 00:16:00,916
all the current items in the

460
00:15:59,716 --> 00:16:00,916
all the current items in the

461
00:16:00,916 --> 00:16:02,926
cache, sorts them from newest to

462
00:16:02,926 --> 00:16:03,456
oldest.

463
00:16:03,936 --> 00:16:07,646
But then it [inaudible] over all

464
00:16:07,646 --> 00:16:09,986
of these items, keeping track of

465
00:16:09,986 --> 00:16:11,406
the total size of the items

466
00:16:11,406 --> 00:16:12,000
already seen.

467
00:16:15,086 --> 00:16:16,086
Once you've seen enough items

468
00:16:16,156 --> 00:16:17,196
then we reached our maximum

469
00:16:17,196 --> 00:16:19,416
size, we begin removing the rest

470
00:16:19,416 --> 00:16:23,636
of them from the file system.

471
00:16:23,896 --> 00:16:24,986
So, let's think about how to

472
00:16:24,986 --> 00:16:25,646
test this method.

473
00:16:26,976 --> 00:16:27,846
What are the inputs?

474
00:16:28,186 --> 00:16:31,566
What are the outputs?

475
00:16:31,696 --> 00:16:33,896
Well, one input is the parameter

476
00:16:33,896 --> 00:16:35,116
specifying how large you want

477
00:16:35,116 --> 00:16:36,346
the cache to be able to grow.

478
00:16:36,346 --> 00:16:39,076
This is a simple integer, and a

479
00:16:39,076 --> 00:16:40,996
method parameter, so the test

480
00:16:40,996 --> 00:16:42,476
already has full control over

481
00:16:42,606 --> 00:16:42,660
it.

482
00:16:45,316 --> 00:16:47,506
The other input, is the list of

483
00:16:47,506 --> 00:16:48,816
items that are currently stored

484
00:16:48,816 --> 00:16:51,226
in the cache.

485
00:16:51,436 --> 00:16:52,636
We didn't take the time to look

486
00:16:52,636 --> 00:16:54,326
at how this is implemented, but

487
00:16:54,326 --> 00:16:56,236
the key point is that it uses a

488
00:16:56,236 --> 00:16:57,976
file manager to retrieve a list

489
00:16:57,976 --> 00:16:59,586
of files from the disc.

490
00:17:01,736 --> 00:17:03,326
This means that the input is

491
00:17:03,326 --> 00:17:04,626
actually derived from the file

492
00:17:04,626 --> 00:17:06,836
system, which is the dependency

493
00:17:06,836 --> 00:17:07,726
that the tests would need to

494
00:17:07,726 --> 00:17:08,976
deal with.

495
00:17:12,296 --> 00:17:14,276
The clean cache method has no

496
00:17:14,276 --> 00:17:14,965
return value.

497
00:17:15,576 --> 00:17:18,606
So, its output can't be data.

498
00:17:18,786 --> 00:17:20,566
Rather, it's the side effect of

499
00:17:20,566 --> 00:17:22,296
a certain set of files having

500
00:17:22,296 --> 00:17:23,606
been removed from the disc.

501
00:17:24,056 --> 00:17:27,195
Because of this dependency on

502
00:17:27,195 --> 00:17:29,146
the file system, tests for this

503
00:17:29,146 --> 00:17:31,436
method would need to deal with a

504
00:17:31,436 --> 00:17:33,126
file manager in the file system.

505
00:17:34,336 --> 00:17:35,966
For setup, they might need to

506
00:17:35,966 --> 00:17:37,876
create a temporary directory and

507
00:17:37,876 --> 00:17:39,716
populate it with a bunch of

508
00:17:39,716 --> 00:17:41,526
files of certain sizes and give

509
00:17:41,526 --> 00:17:43,196
them particular timestamps to

510
00:17:43,196 --> 00:17:43,936
provide the input.

511
00:17:45,856 --> 00:17:47,466
To validate the output, you

512
00:17:47,836 --> 00:17:48,876
would need to then return to the

513
00:17:48,876 --> 00:17:50,936
file system to see which files

514
00:17:50,936 --> 00:17:52,000
are still there.

515
00:17:56,176 --> 00:17:57,266
One way to approach this could

516
00:17:57,266 --> 00:17:59,816
be to use the protocols and

517
00:17:59,816 --> 00:18:01,116
parameterization techniques that

518
00:17:59,816 --> 00:18:01,116
parameterization techniques that

519
00:18:01,116 --> 00:18:01,926
we've already seen.

520
00:18:03,296 --> 00:18:04,636
You could introduce a file

521
00:18:04,636 --> 00:18:06,676
manager protocol that has the

522
00:18:06,676 --> 00:18:07,916
methods that we need for getting

523
00:18:07,916 --> 00:18:09,606
a list of files, and for

524
00:18:09,606 --> 00:18:10,306
removing a file.

525
00:18:11,786 --> 00:18:13,026
And then create a test

526
00:18:13,026 --> 00:18:15,206
implementation that would allow

527
00:18:15,206 --> 00:18:16,446
specifying the list of files

528
00:18:16,446 --> 00:18:17,986
that would be returned, and a

529
00:18:17,986 --> 00:18:19,246
query of which ones have been

530
00:18:19,746 --> 00:18:19,946
removed.

531
00:18:21,996 --> 00:18:23,396
If we do this though, we're

532
00:18:23,396 --> 00:18:25,136
still interacting indirectly

533
00:18:25,286 --> 00:18:26,276
with the code that we're trying

534
00:18:26,276 --> 00:18:28,386
to test mediated by the file

535
00:18:28,386 --> 00:18:28,756
manager.

536
00:18:32,306 --> 00:18:34,146
Instead, let's try something a

537
00:18:34,146 --> 00:18:35,156
little bit different.

538
00:18:35,826 --> 00:18:37,406
We could take our clean cache

539
00:18:37,406 --> 00:18:40,376
method and factor out the logic

540
00:18:40,656 --> 00:18:41,896
responsible for deciding while

541
00:18:41,896 --> 00:18:44,126
files should be removed, the

542
00:18:44,126 --> 00:18:46,606
clean-up policy, which you can

543
00:18:46,606 --> 00:18:47,576
then interact with more

544
00:18:47,576 --> 00:18:48,026
directly.

545
00:18:48,666 --> 00:18:51,606
Let's see how that might work.

546
00:18:54,776 --> 00:18:56,136
To clearly define the APIs we're

547
00:18:56,136 --> 00:18:57,316
going to work with, let's first

548
00:18:57,586 --> 00:18:59,206
define clean-up policy as a

549
00:18:59,206 --> 00:18:59,776
protocol.

550
00:19:00,406 --> 00:19:03,976
It just needs a single method --

551
00:19:04,326 --> 00:19:05,126
items to remove.

552
00:19:06,456 --> 00:19:07,876
Notice how the type signature

553
00:19:07,876 --> 00:19:09,696
that we've given it, looks a bit

554
00:19:09,696 --> 00:19:11,836
different than from the clean

555
00:19:11,836 --> 00:19:13,126
cache method that we started

556
00:19:13,416 --> 00:19:13,500
with.

557
00:19:16,066 --> 00:19:18,856
As input, the new method takes a

558
00:19:18,916 --> 00:19:20,276
set of cache item values.

559
00:19:21,616 --> 00:19:23,316
And for output, it returns

560
00:19:23,416 --> 00:19:25,506
another set of them, but that is

561
00:19:25,506 --> 00:19:27,206
the ones to be removed.

562
00:19:30,596 --> 00:19:32,046
So, let's see how we can

563
00:19:32,046 --> 00:19:33,696
implement this protocol using

564
00:19:33,696 --> 00:19:35,166
the algorithm that we previously

565
00:19:35,166 --> 00:19:37,326
saw from the cache class.

566
00:19:39,416 --> 00:19:40,546
Well, first define a property

567
00:19:40,756 --> 00:19:41,966
for that max size input.

568
00:19:42,896 --> 00:19:44,276
That'll let us specify this max

569
00:19:44,276 --> 00:19:45,496
size, and we construct the

570
00:19:45,496 --> 00:19:45,936
policy.

571
00:19:48,916 --> 00:19:50,646
Then we add the items to remove

572
00:19:50,646 --> 00:19:52,166
method that the protocol

573
00:19:52,166 --> 00:19:52,716
requires.

574
00:19:56,136 --> 00:19:57,686
We want to inspect each of the

575
00:19:57,686 --> 00:19:59,096
items passed into the method,

576
00:19:59,786 --> 00:20:01,246
and build up a set of items to

577
00:19:59,786 --> 00:20:01,246
and build up a set of items to

578
00:20:01,246 --> 00:20:02,906
remove, and return that to the

579
00:20:02,906 --> 00:20:04,000
method when we're done.

580
00:20:07,216 --> 00:20:09,166
To populate the set, we'll loop

581
00:20:09,166 --> 00:20:10,346
over all of the items from

582
00:20:10,346 --> 00:20:13,416
newest to oldest, summing up the

583
00:20:13,416 --> 00:20:14,826
size of all the items we've seen

584
00:20:14,826 --> 00:20:16,006
so far.

585
00:20:18,336 --> 00:20:19,776
Once we've reached the maximum

586
00:20:19,776 --> 00:20:22,346
size, we start adding the rest

587
00:20:22,346 --> 00:20:24,186
to the set of items to remove.

588
00:20:27,496 --> 00:20:29,826
Looking at this code, we can see

589
00:20:29,826 --> 00:20:31,086
that the side effects that were

590
00:20:31,086 --> 00:20:32,556
prone in the earlier version

591
00:20:32,806 --> 00:20:33,556
have been removed.

592
00:20:34,166 --> 00:20:36,666
What remains is the underlying

593
00:20:36,666 --> 00:20:40,096
algorithm, taking data as input,

594
00:20:40,806 --> 00:20:44,016
and returning some data as

595
00:20:44,016 --> 00:20:44,416
output.

596
00:20:45,566 --> 00:20:46,886
We can also visualize the data

597
00:20:46,886 --> 00:20:47,956
flow that we've achieved by

598
00:20:47,956 --> 00:20:48,496
doing this.

599
00:20:49,106 --> 00:20:51,826
Notice that the code has taken

600
00:20:51,826 --> 00:20:53,206
on a very functional style.

601
00:20:53,946 --> 00:20:55,376
Data in; data out.

602
00:20:59,736 --> 00:21:01,336
With the logic factored out in

603
00:20:59,736 --> 00:21:01,336
With the logic factored out in

604
00:21:01,336 --> 00:21:03,456
this way, we've enabled

605
00:21:03,456 --> 00:21:04,796
ourselves to write clear,

606
00:21:04,796 --> 00:21:06,536
concise tests that put the

607
00:21:06,536 --> 00:21:10,216
algorithm through its paces.

608
00:21:10,336 --> 00:21:12,046
All we have to do is define an

609
00:21:12,156 --> 00:21:16,536
input set with some cache items,

610
00:21:16,536 --> 00:21:17,826
create an instance of the type,

611
00:21:18,656 --> 00:21:20,296
calling the method, directly

612
00:21:20,296 --> 00:21:21,486
passing in the values that it

613
00:21:21,486 --> 00:21:25,246
needs, and then asserting that

614
00:21:25,246 --> 00:21:27,026
the returned items match the

615
00:21:27,026 --> 00:21:27,736
expected result.

616
00:21:28,266 --> 00:21:32,296
With a code in this form, we now

617
00:21:32,296 --> 00:21:33,326
have easy control over the

618
00:21:33,326 --> 00:21:35,446
inputs, visibility into the

619
00:21:35,446 --> 00:21:38,116
outputs, and there's no hidden

620
00:21:38,116 --> 00:21:39,486
state to contend with at all.

621
00:21:40,476 --> 00:21:41,656
It's very reminiscent of the

622
00:21:41,656 --> 00:21:43,606
test for the sorted method that

623
00:21:43,606 --> 00:21:44,576
we saw at the beginning.

624
00:21:46,496 --> 00:21:48,406
This allows the test to be easy

625
00:21:48,406 --> 00:21:50,136
to read, with minimal

626
00:21:50,136 --> 00:21:51,926
distraction from the essentials

627
00:21:51,926 --> 00:21:55,506
of what is being tested to run

628
00:21:55,506 --> 00:21:57,446
very quickly because it has no

629
00:21:57,446 --> 00:21:59,536
dependency on slow resources

630
00:21:59,536 --> 00:22:00,436
like the file system.

631
00:21:59,536 --> 00:22:00,436
like the file system.

632
00:22:00,966 --> 00:22:04,406
And to be deterministic because

633
00:22:04,576 --> 00:22:06,256
all of the data in use is fully

634
00:22:06,256 --> 00:22:06,936
self-contained.

635
00:22:11,756 --> 00:22:13,596
Taking a peek back at the

636
00:22:13,596 --> 00:22:15,136
original clean cache method,

637
00:22:15,476 --> 00:22:17,476
after the extraction, we see

638
00:22:17,476 --> 00:22:19,326
that there's very little left.

639
00:22:21,476 --> 00:22:22,826
All we're doing is asking the

640
00:22:22,826 --> 00:22:24,736
clean-up policy for the list of

641
00:22:24,736 --> 00:22:28,126
items to remove, and iterating

642
00:22:28,126 --> 00:22:30,076
over all of them, removing them

643
00:22:30,076 --> 00:22:30,906
from the file system.

644
00:22:33,236 --> 00:22:36,036
To test what remains, we could

645
00:22:36,036 --> 00:22:37,496
decide to introduce that file

646
00:22:37,496 --> 00:22:39,186
manager protocol and testable

647
00:22:39,186 --> 00:22:41,236
implementation to allow writing

648
00:22:41,236 --> 00:22:42,836
a very isolated unit tests for

649
00:22:43,446 --> 00:22:43,500
it.

650
00:22:44,496 --> 00:22:46,486
Or we might decide that a couple

651
00:22:46,486 --> 00:22:48,466
of integration tests are

652
00:22:48,466 --> 00:22:49,506
sufficient to give the

653
00:22:49,506 --> 00:22:51,496
confidence that we need that the

654
00:22:51,496 --> 00:22:52,646
code is doing the right thing.

655
00:22:53,916 --> 00:22:55,176
This thin layer of [inaudible]

656
00:22:55,296 --> 00:22:56,986
code that's left.

657
00:23:01,816 --> 00:23:04,186
So, in this example, we looked

658
00:23:04,736 --> 00:23:08,036
at how to extract business logic

659
00:23:08,036 --> 00:23:09,606
and algorithms into separate

660
00:23:09,606 --> 00:23:12,176
types, away from the code, using

661
00:23:12,206 --> 00:23:13,606
side effects.

662
00:23:15,636 --> 00:23:17,806
When doing this, the algorithms

663
00:23:17,806 --> 00:23:19,046
tend to take on a rather

664
00:23:19,046 --> 00:23:21,026
functional style, using value

665
00:23:21,026 --> 00:23:22,976
types to describe the inputs and

666
00:23:23,186 --> 00:23:23,976
the outputs.

667
00:23:24,466 --> 00:23:26,926
This allows for straightforward

668
00:23:26,926 --> 00:23:29,216
unit tests that exercise the

669
00:23:29,216 --> 00:23:30,806
algorithm in as much detail as

670
00:23:30,806 --> 00:23:31,326
you require.

671
00:23:34,676 --> 00:23:36,116
We're left with a small amount

672
00:23:36,116 --> 00:23:37,636
of code that perform side

673
00:23:37,636 --> 00:23:38,966
effects based on the computer

674
00:23:38,966 --> 00:23:39,406
data.

675
00:23:39,906 --> 00:23:42,336
This bit is often a good

676
00:23:42,336 --> 00:23:43,856
candidate for testing with

677
00:23:43,856 --> 00:23:46,316
integration tests in order to

678
00:23:46,316 --> 00:23:47,406
track that its interaction with

679
00:23:47,406 --> 00:23:48,526
the rest of the system is

680
00:23:48,526 --> 00:23:49,256
working properly.

681
00:23:54,176 --> 00:23:57,126
So, to wrap up, we saw examples

682
00:23:57,126 --> 00:23:59,186
that allowed us to explore two

683
00:23:59,186 --> 00:24:00,956
sets of techniques that allow us

684
00:23:59,186 --> 00:24:00,956
sets of techniques that allow us

685
00:24:00,956 --> 00:24:03,116
to structure or ask code, so

686
00:24:03,116 --> 00:24:04,956
that tests have control over the

687
00:24:04,956 --> 00:24:06,996
code's inputs, and visibility

688
00:24:06,996 --> 00:24:09,126
into its outputs, thereby

689
00:24:09,126 --> 00:24:10,456
allowing us to write effective

690
00:24:10,456 --> 00:24:12,026
unit tests for it.

691
00:24:14,776 --> 00:24:16,296
And now, I want to call up my

692
00:24:16,296 --> 00:24:18,146
colleague, Greg Tracy, to talk

693
00:24:18,146 --> 00:24:19,466
about how to create a test suite

694
00:24:19,816 --> 00:24:21,126
that scales with your app as it

695
00:24:21,126 --> 00:24:21,556
grows.

696
00:24:23,516 --> 00:24:27,500
[ Applause ]

697
00:24:31,636 --> 00:24:32,586
&gt;&gt; Hi, everyone.

698
00:24:32,796 --> 00:24:33,536
My name is Greg.

699
00:24:33,536 --> 00:24:35,996
And I also work on Xcode.

700
00:24:37,316 --> 00:24:38,866
Earlier, Brian showed you some

701
00:24:38,866 --> 00:24:40,176
techniques about how to make app

702
00:24:40,176 --> 00:24:41,216
code more testable.

703
00:24:41,826 --> 00:24:42,926
Now, I want to show you how to

704
00:24:42,926 --> 00:24:44,336
make the accompanying test code

705
00:24:44,336 --> 00:24:45,356
more scalable.

706
00:24:45,356 --> 00:24:47,316
To do this, we'll look at a few

707
00:24:47,316 --> 00:24:49,376
methods to make tests faster,

708
00:24:49,376 --> 00:24:51,166
more readable, and more

709
00:24:51,166 --> 00:24:52,006
modularized.

710
00:24:52,446 --> 00:24:54,306
I also want to mention that many

711
00:24:54,306 --> 00:24:55,606
of the techniques that Brian

712
00:24:55,606 --> 00:24:57,256
described earlier, can also be

713
00:24:57,256 --> 00:24:58,256
applied to test code.

714
00:24:58,926 --> 00:25:00,056
Here, we're going to go through

715
00:24:58,926 --> 00:25:00,056
Here, we're going to go through

716
00:25:00,056 --> 00:25:01,766
some additional tips.

717
00:25:03,196 --> 00:25:05,516
First, I'll talk about having a

718
00:25:05,606 --> 00:25:07,166
balance between UI and unit

719
00:25:08,106 --> 00:25:08,330
tests.

720
00:25:09,376 --> 00:25:11,496
Then, dive into code that helps

721
00:25:11,496 --> 00:25:13,816
test scale with the focus on UI

722
00:25:13,816 --> 00:25:14,376
test code.

723
00:25:15,086 --> 00:25:17,386
And then, I'll talk about the

724
00:25:17,386 --> 00:25:19,416
importance of having quality in

725
00:25:19,416 --> 00:25:20,000
test code.

726
00:25:22,736 --> 00:25:23,716
Striking the right balance

727
00:25:23,776 --> 00:25:27,436
between UI and unit tests.

728
00:25:27,436 --> 00:25:28,436
I sometimes like to view my

729
00:25:28,436 --> 00:25:30,006
distribution of tests as a

730
00:25:30,006 --> 00:25:30,536
pyramid.

731
00:25:31,816 --> 00:25:33,216
At the top, you have your UI

732
00:25:33,216 --> 00:25:36,036
tests, and at the bottom, you

733
00:25:36,036 --> 00:25:37,906
have your unit tests.

734
00:25:38,656 --> 00:25:40,026
These [inaudible] pyramid

735
00:25:40,026 --> 00:25:42,286
structure we usually have more

736
00:25:42,406 --> 00:25:44,336
unit tests than we will UI

737
00:25:44,336 --> 00:25:44,826
tests.

738
00:25:45,336 --> 00:25:46,526
This is usually because unit

739
00:25:46,526 --> 00:25:48,496
tests can run much more quickly

740
00:25:48,496 --> 00:25:49,566
than UI tests.

741
00:25:50,956 --> 00:25:53,296
Now between UI and unit tests,

742
00:25:53,456 --> 00:25:56,206
we also have integration tests.

743
00:25:56,986 --> 00:25:58,726
However, today, we're going to

744
00:25:58,726 --> 00:26:00,156
focus more on just UI and unit

745
00:25:58,726 --> 00:26:00,156
focus more on just UI and unit

746
00:26:00,156 --> 00:26:00,330
tests.

747
00:26:04,396 --> 00:26:06,216
Aside from the distribution, we

748
00:26:06,216 --> 00:26:07,516
might also look at the pyramid

749
00:26:07,516 --> 00:26:08,786
as a way to do maintenance

750
00:26:08,786 --> 00:26:09,246
costs.

751
00:26:09,986 --> 00:26:11,496
Generally, UI tests tend to have

752
00:26:11,496 --> 00:26:12,586
a higher maintenance cost

753
00:26:12,586 --> 00:26:14,036
because of the number of things

754
00:26:14,036 --> 00:26:14,716
that can happen.

755
00:26:15,896 --> 00:26:17,106
Unit tests on the other hand,

756
00:26:17,396 --> 00:26:19,206
have a lower maintenance cost.

757
00:26:19,476 --> 00:26:21,626
So, if a unit test fails, it's

758
00:26:21,626 --> 00:26:23,206
usually immediately obvious

759
00:26:23,346 --> 00:26:24,146
what's gone wrong.

760
00:26:25,336 --> 00:26:27,066
With UI tests, it's like casting

761
00:26:27,066 --> 00:26:28,916
a wide net where you can get

762
00:26:28,916 --> 00:26:30,006
failures that are difficult to

763
00:26:30,006 --> 00:26:31,996
understand, or might not be

764
00:26:31,996 --> 00:26:33,286
relevant to the test at hand.

765
00:26:33,336 --> 00:26:34,946
So, it can be a bit more tricky.

766
00:26:38,216 --> 00:26:39,556
While the testing pyramid is a

767
00:26:39,556 --> 00:26:41,216
great way to represent

768
00:26:41,506 --> 00:26:43,176
distributions of -- our

769
00:26:43,176 --> 00:26:45,096
distribution of tests, it

770
00:26:45,096 --> 00:26:46,486
doesn't represent every

771
00:26:46,536 --> 00:26:47,136
situation.

772
00:26:47,826 --> 00:26:48,996
In fact, you might think of

773
00:26:48,996 --> 00:26:50,816
testing as a spectrum, rather

774
00:26:50,816 --> 00:26:51,726
than a pyramid.

775
00:26:52,296 --> 00:26:53,886
It's often the case that some UI

776
00:26:54,376 --> 00:26:55,606
and unit tests, exist on

777
00:26:55,676 --> 00:26:56,946
opposite ends of the spectrum,

778
00:26:57,406 --> 00:26:58,726
or opposite ends of the pyramid.

779
00:26:59,306 --> 00:27:01,056
Some UI tests might be more like

780
00:26:59,306 --> 00:27:01,056
Some UI tests might be more like

781
00:27:01,056 --> 00:27:03,626
unit tests, and a unit test

782
00:27:03,696 --> 00:27:04,936
might interact with several

783
00:27:04,936 --> 00:27:07,136
different modules of code and

784
00:27:07,136 --> 00:27:08,886
not just single, isolated bits.

785
00:27:09,986 --> 00:27:10,916
The pyramid is just a good

786
00:27:10,916 --> 00:27:11,746
approximation.

787
00:27:11,746 --> 00:27:15,816
It's not written in stone.

788
00:27:15,906 --> 00:27:16,896
When thinking about these two

789
00:27:16,896 --> 00:27:18,146
kinds of tests, we need to

790
00:27:18,146 --> 00:27:19,036
consider each of their

791
00:27:19,036 --> 00:27:20,000
strengths.

792
00:27:21,386 --> 00:27:23,326
Unit tests are great at testing

793
00:27:23,326 --> 00:27:25,136
small bits of code that might be

794
00:27:25,136 --> 00:27:26,846
hard to reach without access to

795
00:27:26,846 --> 00:27:28,026
all of our app source code.

796
00:27:28,546 --> 00:27:30,896
UI tests on the other hand, are

797
00:27:30,896 --> 00:27:32,196
great when you need to test

798
00:27:32,196 --> 00:27:34,106
large chunks of code, working

799
00:27:34,106 --> 00:27:34,526
together.

800
00:27:35,686 --> 00:27:36,956
Of course, we need to keep in

801
00:27:36,956 --> 00:27:38,406
mind that unit tests do have

802
00:27:38,406 --> 00:27:39,716
access to all of our app's

803
00:27:39,716 --> 00:27:42,686
source, whereas UI tests do not.

804
00:27:45,036 --> 00:27:46,826
Focusing more on UI tests, let's

805
00:27:47,056 --> 00:27:48,096
look at a few things you could

806
00:27:48,096 --> 00:27:49,306
to do improve the quality of

807
00:27:49,306 --> 00:27:50,026
your test code.

808
00:27:51,066 --> 00:27:52,006
By making some of the changes

809
00:27:52,006 --> 00:27:54,236
I'm about to suggest, we can

810
00:27:54,236 --> 00:27:56,026
make it easier to create tests

811
00:27:56,246 --> 00:27:57,766
that scale alongside our app

812
00:27:57,876 --> 00:27:57,976
code.

813
00:28:01,046 --> 00:28:03,356
We'll look at abstracting UI

814
00:28:03,356 --> 00:28:06,196
element queries, creating

815
00:28:06,246 --> 00:28:07,686
objects in utility functions,

816
00:28:07,716 --> 00:28:08,736
which can then be placed in a

817
00:28:08,736 --> 00:28:11,916
library for later use, and

818
00:28:12,126 --> 00:28:13,586
utilizing keyboard shortcuts.

819
00:28:17,326 --> 00:28:18,116
So, first we'll look at

820
00:28:18,116 --> 00:28:19,606
abstracting UI element queries.

821
00:28:20,976 --> 00:28:22,116
Say I have an app that has

822
00:28:22,246 --> 00:28:23,186
several buttons in a view

823
00:28:23,186 --> 00:28:23,696
controller.

824
00:28:24,496 --> 00:28:25,926
And each button is at the same

825
00:28:25,926 --> 00:28:27,086
level in the view hierarchy.

826
00:28:27,086 --> 00:28:29,306
The only difference is the name

827
00:28:29,406 --> 00:28:31,736
of each button.

828
00:28:31,896 --> 00:28:32,836
Instead of writing out this

829
00:28:32,836 --> 00:28:34,706
query seven times, let's wrap

830
00:28:34,706 --> 00:28:35,416
this up in a method.

831
00:28:39,116 --> 00:28:40,746
We can now modify each of our

832
00:28:40,746 --> 00:28:42,416
queries to use the new method we

833
00:28:42,416 --> 00:28:43,066
just created.

834
00:28:43,676 --> 00:28:45,556
However, I might even go

835
00:28:45,556 --> 00:28:45,876
further.

836
00:28:49,366 --> 00:28:50,656
Since each method calls the

837
00:28:50,766 --> 00:28:53,026
same, except for the name, let's

838
00:28:53,026 --> 00:28:54,326
put all those names in array and

839
00:28:54,326 --> 00:28:56,486
just loop through them.

840
00:28:56,696 --> 00:28:57,646
This adds some benefit of

841
00:28:57,646 --> 00:28:59,116
maintainability for this code.

842
00:28:59,616 --> 00:29:00,756
If I add an extra button in the

843
00:28:59,616 --> 00:29:00,756
If I add an extra button in the

844
00:29:00,806 --> 00:29:02,926
future, I don't have to add a

845
00:29:02,926 --> 00:29:03,756
new line of code.

846
00:29:03,886 --> 00:29:04,996
I just have to add an extra

847
00:29:04,996 --> 00:29:09,206
button name to the array.

848
00:29:09,376 --> 00:29:11,086
By nature of what a UI test is,

849
00:29:11,726 --> 00:29:14,116
we're issuing a lot of these

850
00:29:14,116 --> 00:29:14,576
queries.

851
00:29:14,576 --> 00:29:16,926
So, if you're using the same

852
00:29:16,926 --> 00:29:18,946
query multiple times, store it

853
00:29:18,946 --> 00:29:19,776
as a variable.

854
00:29:20,076 --> 00:29:21,666
Even if it's only part of a

855
00:29:21,816 --> 00:29:26,126
query, store it somewhere.

856
00:29:26,236 --> 00:29:27,826
Also, if you have queries that

857
00:29:27,826 --> 00:29:29,386
are very similar, consider

858
00:29:29,386 --> 00:29:30,686
creating a helper method around

859
00:29:30,686 --> 00:29:31,316
that query.

860
00:29:32,526 --> 00:29:34,056
The code will look a lot cleaner

861
00:29:34,056 --> 00:29:35,566
and become much more readable.

862
00:29:36,416 --> 00:29:38,246
In terms of scaling our test

863
00:29:38,246 --> 00:29:39,866
suite, the use of shorter lines

864
00:29:39,966 --> 00:29:42,356
of code -- of shorter lines of

865
00:29:42,356 --> 00:29:43,476
test code and thoughtfully named

866
00:29:43,476 --> 00:29:44,996
helper methods, will make it

867
00:29:45,146 --> 00:29:46,576
faster and easier to implement

868
00:29:46,576 --> 00:29:51,046
new tests when the time comes.

869
00:29:51,236 --> 00:29:52,346
So, that was abstracting UI

870
00:29:52,346 --> 00:29:53,396
element queries.

871
00:29:54,166 --> 00:29:55,286
Now, let's move on to creating

872
00:29:55,286 --> 00:29:56,646
objects in utility functions.

873
00:29:56,996 --> 00:29:59,946
I have this game I've been

874
00:29:59,946 --> 00:30:01,916
working on, and for each test, I

875
00:29:59,946 --> 00:30:01,916
working on, and for each test, I

876
00:30:01,916 --> 00:30:02,976
want to change some settings.

877
00:30:04,326 --> 00:30:06,506
Now, this is not a great example

878
00:30:06,506 --> 00:30:07,176
of scalable code.

879
00:30:08,166 --> 00:30:09,296
Because I've been recently

880
00:30:09,296 --> 00:30:10,376
working with this app, I'm

881
00:30:10,376 --> 00:30:11,686
familiar with how everything is

882
00:30:11,686 --> 00:30:12,076
laid out.

883
00:30:13,006 --> 00:30:14,296
I understand exactly what's

884
00:30:14,296 --> 00:30:14,746
going on.

885
00:30:15,746 --> 00:30:17,866
However, later, if I was to come

886
00:30:17,866 --> 00:30:19,106
back to this code after a few

887
00:30:19,106 --> 00:30:21,546
weeks, or better yet, somebody

888
00:30:21,546 --> 00:30:23,126
not familiar with my code has to

889
00:30:23,126 --> 00:30:24,796
sit down and read what I wrote,

890
00:30:25,026 --> 00:30:26,406
it might not make all that much

891
00:30:26,486 --> 00:30:27,000
sense.

892
00:30:28,336 --> 00:30:30,146
I first have to realize that I

893
00:30:30,376 --> 00:30:32,886
have a Settings page that I need

894
00:30:32,886 --> 00:30:35,156
to get in and out of.

895
00:30:35,156 --> 00:30:36,636
And I then have to realize that

896
00:30:36,636 --> 00:30:38,446
between those two lines, I'm

897
00:30:38,446 --> 00:30:39,796
going through a difficulty page,

898
00:30:40,066 --> 00:30:42,796
setting the difficulty, then I'm

899
00:30:42,796 --> 00:30:43,666
going through a sound page, and

900
00:30:43,666 --> 00:30:44,726
setting the sound.

901
00:30:45,946 --> 00:30:47,176
Coming after an extended period

902
00:30:47,176 --> 00:30:49,066
of time, I might not understand

903
00:30:49,066 --> 00:30:50,486
why I have two back tabs at the

904
00:30:50,486 --> 00:30:50,876
bottom.

905
00:30:50,876 --> 00:30:53,326
I would have to run through this

906
00:30:53,366 --> 00:30:54,616
test to actually see this

907
00:30:54,616 --> 00:30:55,026
happen.

908
00:30:56,666 --> 00:30:58,366
And if the test were broken

909
00:30:58,366 --> 00:30:59,376
because of some change in the

910
00:30:59,376 --> 00:31:01,146
actual UI, I wouldn't be able to

911
00:30:59,376 --> 00:31:01,146
actual UI, I wouldn't be able to

912
00:31:01,146 --> 00:31:02,626
run my test, and I would be able

913
00:31:02,626 --> 00:31:03,686
to see what I wanted to see.

914
00:31:04,506 --> 00:31:05,876
I'd be clueless as to why the

915
00:31:05,876 --> 00:31:07,316
code was written the way it was.

916
00:31:08,516 --> 00:31:09,926
To fix this, let's try to

917
00:31:09,926 --> 00:31:11,306
abstract away some of this logic

918
00:31:11,306 --> 00:31:12,226
into helper methods.

919
00:31:12,916 --> 00:31:16,666
We can create a method to set

920
00:31:16,696 --> 00:31:17,396
the difficulty.

921
00:31:17,396 --> 00:31:19,676
And then similarly, we can

922
00:31:19,676 --> 00:31:20,586
create a method to set the

923
00:31:20,676 --> 00:31:21,066
sound.

924
00:31:21,636 --> 00:31:23,056
But can we do a little better?

925
00:31:24,046 --> 00:31:26,856
Sure. We can instead, of instead

926
00:31:26,856 --> 00:31:27,946
of passing stream typed

927
00:31:28,006 --> 00:31:29,826
arguments, let's utilize enums.

928
00:31:30,996 --> 00:31:32,406
That way, Xcode can -- helps

929
00:31:32,406 --> 00:31:34,036
determine if the arguments we're

930
00:31:34,036 --> 00:31:35,876
passing are even valid, before

931
00:31:35,876 --> 00:31:36,916
we even compile.

932
00:31:40,276 --> 00:31:41,456
Now, looking at the code from

933
00:31:41,456 --> 00:31:43,056
before, if we replace some of

934
00:31:43,056 --> 00:31:44,126
the code with our new helper

935
00:31:44,126 --> 00:31:47,386
methods, we reduce what we had

936
00:31:47,386 --> 00:31:47,826
before.

937
00:31:47,826 --> 00:31:48,966
And this is already starting to

938
00:31:48,966 --> 00:31:49,796
look a lot better.

939
00:31:49,796 --> 00:31:53,116
What about the initial jump in

940
00:31:53,116 --> 00:31:54,386
and out of the Settings page?

941
00:31:55,016 --> 00:31:56,726
Can we improve this as well?

942
00:31:57,086 --> 00:31:57,866
I think we can.

943
00:31:58,836 --> 00:32:00,556
Let's make a game app class.

944
00:31:58,836 --> 00:32:00,556
Let's make a game app class.

945
00:32:00,556 --> 00:32:03,566
And in this class, I'll include

946
00:32:03,566 --> 00:32:05,276
the enums I defined earlier for

947
00:32:05,276 --> 00:32:07,786
difficulty and sound.

948
00:32:07,826 --> 00:32:09,066
I'll also include the helper

949
00:32:09,066 --> 00:32:10,826
methods from before that set

950
00:32:10,826 --> 00:32:12,000
those settings.

951
00:32:13,396 --> 00:32:14,516
We'll create another method

952
00:32:14,516 --> 00:32:16,286
called Configure Settings, that

953
00:32:16,286 --> 00:32:17,326
takes the two settings as

954
00:32:17,326 --> 00:32:20,496
inputs, and we'll migrate the

955
00:32:20,546 --> 00:32:22,336
setup logic from before, into

956
00:32:22,336 --> 00:32:23,206
the configure method.

957
00:32:23,716 --> 00:32:26,966
Back to where we were before,

958
00:32:27,206 --> 00:32:28,286
now that we've created this game

959
00:32:28,286 --> 00:32:30,276
app class, we can take away all

960
00:32:30,276 --> 00:32:32,266
the code we wrote before, and

961
00:32:32,266 --> 00:32:33,866
just use a single call, the

962
00:32:33,866 --> 00:32:34,626
configure method.

963
00:32:35,476 --> 00:32:36,956
This looks a lot more readable

964
00:32:36,956 --> 00:32:38,286
to me than what we had before.

965
00:32:39,276 --> 00:32:41,416
Now, if I wrote more tests than

966
00:32:41,416 --> 00:32:42,856
needed to set the settings, I

967
00:32:43,206 --> 00:32:44,156
would just call our configure

968
00:32:44,156 --> 00:32:44,660
method.

969
00:32:46,166 --> 00:32:48,276
And if I needed to -- or if I

970
00:32:48,276 --> 00:32:49,386
decided that I wanted to add

971
00:32:49,386 --> 00:32:50,836
more settings to my app, I would

972
00:32:50,836 --> 00:32:51,826
just have to update our

973
00:32:51,826 --> 00:32:53,026
configure settings method to

974
00:32:53,026 --> 00:32:53,946
handle these additional

975
00:32:53,946 --> 00:32:54,306
settings.

976
00:32:54,996 --> 00:32:58,856
From the example, one of the

977
00:32:58,856 --> 00:33:00,516
most important things to do when

978
00:32:58,856 --> 00:33:00,516
most important things to do when

979
00:33:00,516 --> 00:33:02,096
trying to scale your tests, is

980
00:33:02,096 --> 00:33:03,926
to create abstraction that you

981
00:33:04,056 --> 00:33:05,726
can later put into a library

982
00:33:05,726 --> 00:33:06,006
suite.

983
00:33:06,606 --> 00:33:07,796
By doing this, we're

984
00:33:07,796 --> 00:33:09,476
encapsulating common workflows

985
00:33:09,806 --> 00:33:10,986
that can be applied to more than

986
00:33:10,986 --> 00:33:12,266
one test.

987
00:33:13,816 --> 00:33:15,296
This also means that we're able

988
00:33:15,296 --> 00:33:16,676
to share test code across

989
00:33:16,746 --> 00:33:17,716
different platforms.

990
00:33:18,256 --> 00:33:22,306
And, of course, by sharing code,

991
00:33:22,306 --> 00:33:23,906
we improve maintainability.

992
00:33:24,926 --> 00:33:26,006
If something related to an

993
00:33:26,006 --> 00:33:27,876
abstracted workflow changes, we

994
00:33:27,876 --> 00:33:29,146
only have to update our code in

995
00:33:29,146 --> 00:33:32,076
a single place, as opposed to

996
00:33:34,756 --> 00:33:35,196
several.

997
00:33:35,246 --> 00:33:36,176
One other improvement that I

998
00:33:36,176 --> 00:33:37,646
want to mention, in our

999
00:33:37,646 --> 00:33:39,756
configure method, and new in

1000
00:33:39,916 --> 00:33:42,566
Xcode this year, we can add an

1001
00:33:42,566 --> 00:33:45,036
XCTContent.runActivity block to

1002
00:33:45,666 --> 00:33:46,706
our code.

1003
00:33:46,906 --> 00:33:48,086
This makes it so that when we

1004
00:33:48,086 --> 00:33:49,636
run our test, instead of having

1005
00:33:49,636 --> 00:33:51,006
a log that contains all the

1006
00:33:51,006 --> 00:33:52,426
actions that we made at the top

1007
00:33:52,426 --> 00:33:55,056
level, we can nest our logging,

1008
00:33:55,056 --> 00:33:56,076
using runActivity.

1009
00:33:56,626 --> 00:33:59,406
This helps organize our logging

1010
00:33:59,406 --> 00:34:01,686
to make things look a little bit

1011
00:33:59,406 --> 00:34:01,686
to make things look a little bit

1012
00:34:02,556 --> 00:34:02,726
cleaner.

1013
00:34:02,856 --> 00:34:03,986
For more information regarding

1014
00:34:03,986 --> 00:34:05,926
the test activity feature, check

1015
00:34:05,926 --> 00:34:07,516
out the earlier talk about

1016
00:34:07,516 --> 00:34:11,005
What's New in Testing?

1017
00:34:11,545 --> 00:34:13,116
Now, let's move on to Utilizing

1018
00:34:13,116 --> 00:34:14,996
Keyboard Shortcuts for macOS UI

1019
00:34:14,996 --> 00:34:15,330
Tests.

1020
00:34:17,886 --> 00:34:19,166
Let's say I have an app where

1021
00:34:19,166 --> 00:34:20,606
the user can pick a color for

1022
00:34:20,606 --> 00:34:21,876
their text, using the standard

1023
00:34:21,876 --> 00:34:23,275
macOS color picker.

1024
00:34:23,886 --> 00:34:25,335
And I'm writing a test to verify

1025
00:34:25,335 --> 00:34:26,646
that the color is set correctly.

1026
00:34:27,196 --> 00:34:30,186
The typical way to bring up the

1027
00:34:30,186 --> 00:34:32,056
color picker in my app is by

1028
00:34:32,056 --> 00:34:34,056
opening the Format menu, and

1029
00:34:34,056 --> 00:34:35,716
navigating to the Font sub-menu,

1030
00:34:36,085 --> 00:34:37,315
and finally choosing Show

1031
00:34:37,315 --> 00:34:37,926
Colors.

1032
00:34:37,985 --> 00:34:40,795
I can write this in my UI test

1033
00:34:40,795 --> 00:34:41,500
like this.

1034
00:34:43,976 --> 00:34:45,616
But there's a faster way to do

1035
00:34:45,616 --> 00:34:47,016
this that'll scale better as my

1036
00:34:47,016 --> 00:34:47,846
test [inaudible] grows.

1037
00:34:49,166 --> 00:34:50,815
Notice that the Show Colors menu

1038
00:34:50,815 --> 00:34:52,576
item has an associated keyboard

1039
00:34:52,576 --> 00:34:53,235
shortcut.

1040
00:34:53,846 --> 00:34:57,456
Rather than using multiple lines

1041
00:34:57,456 --> 00:34:58,516
of code to bring up the color

1042
00:34:58,516 --> 00:35:01,166
picker, we can just use one line

1043
00:34:58,516 --> 00:35:01,166
picker, we can just use one line

1044
00:35:01,166 --> 00:35:02,666
of code using the shortcut.

1045
00:35:03,236 --> 00:35:06,436
And for the sake of readability,

1046
00:35:06,616 --> 00:35:07,806
I might use a wrapper to make

1047
00:35:07,806 --> 00:35:08,576
this call for me.

1048
00:35:09,646 --> 00:35:11,266
So, not only is this less code

1049
00:35:11,266 --> 00:35:13,056
to maintain in my tests, it's

1050
00:35:13,056 --> 00:35:14,306
less code that has to be run

1051
00:35:14,306 --> 00:35:15,846
that isn't directly relevant to

1052
00:35:15,846 --> 00:35:17,016
the actual test I'm trying to

1053
00:35:17,046 --> 00:35:18,000
perform.

1054
00:35:20,576 --> 00:35:22,326
So, in an example test method, I

1055
00:35:22,326 --> 00:35:23,446
was previously going through the

1056
00:35:23,446 --> 00:35:25,006
menu to get the color picker to

1057
00:35:25,006 --> 00:35:25,316
show.

1058
00:35:25,826 --> 00:35:29,136
Using the new wrapper method, we

1059
00:35:29,136 --> 00:35:30,406
remove all those extra lines and

1060
00:35:30,406 --> 00:35:31,856
reduce to a single method.

1061
00:35:32,586 --> 00:35:33,906
Not only does this make my test

1062
00:35:34,036 --> 00:35:35,426
faster, it makes my code look a

1063
00:35:35,426 --> 00:35:36,876
lot more readable.

1064
00:35:39,206 --> 00:35:40,886
Looking at what we just saw, if

1065
00:35:40,886 --> 00:35:42,066
you're writing a UI test for a

1066
00:35:42,066 --> 00:35:44,076
macOS application, you can offer

1067
00:35:44,076 --> 00:35:45,416
a keyboard shortcut instead of

1068
00:35:45,416 --> 00:35:46,416
going through the menu bar.

1069
00:35:47,056 --> 00:35:49,016
I'm still going to have at least

1070
00:35:49,016 --> 00:35:50,736
one test that ensures that

1071
00:35:50,736 --> 00:35:52,046
bringing up the color picker via

1072
00:35:52,046 --> 00:35:53,686
the menu bar, works properly,

1073
00:35:54,076 --> 00:35:56,246
but that doesn't need to be

1074
00:35:56,246 --> 00:35:57,826
repeated across every single

1075
00:35:57,826 --> 00:35:58,786
test that involves the color

1076
00:35:58,786 --> 00:35:59,126
picker.

1077
00:36:02,916 --> 00:36:04,956
In the process of using keyboard

1078
00:36:04,956 --> 00:36:06,876
shortcuts, we make our test code

1079
00:36:06,876 --> 00:36:09,196
more compact by skipping extra

1080
00:36:09,196 --> 00:36:10,496
steps needed to work through the

1081
00:36:10,496 --> 00:36:12,856
UI, sometimes reducing multiple

1082
00:36:12,856 --> 00:36:14,206
lines of code to a single line,

1083
00:36:14,546 --> 00:36:15,746
which can help for readability.

1084
00:36:18,636 --> 00:36:20,346
Finally, I want to stress to all

1085
00:36:20,346 --> 00:36:21,966
of you that writing good tests

1086
00:36:22,096 --> 00:36:23,496
is about writing good code.

1087
00:36:24,126 --> 00:36:25,886
It's easy to treat tests as an

1088
00:36:25,886 --> 00:36:26,436
afterthought.

1089
00:36:27,446 --> 00:36:29,366
Usually, we focus on trying to

1090
00:36:29,366 --> 00:36:30,466
make our app the best it can

1091
00:36:30,466 --> 00:36:32,346
possibly be, by investing all

1092
00:36:32,346 --> 00:36:33,506
this time in writing beautiful

1093
00:36:33,506 --> 00:36:35,216
app code that adheres to all

1094
00:36:35,216 --> 00:36:36,696
these principles of good design.

1095
00:36:36,966 --> 00:36:38,246
We might have this additional

1096
00:36:38,496 --> 00:36:40,336
requirement of writing test

1097
00:36:40,396 --> 00:36:40,686
code.

1098
00:36:40,686 --> 00:36:41,746
It might be something tacked on

1099
00:36:41,746 --> 00:36:43,196
at the end or done in a hurry

1100
00:36:43,196 --> 00:36:44,546
just to check off a checkbox.

1101
00:36:44,606 --> 00:36:46,896
But we can't allow this to

1102
00:36:47,186 --> 00:36:47,330
happen.

1103
00:36:48,926 --> 00:36:50,476
Without the same attention to

1104
00:36:50,476 --> 00:36:52,326
detail, test code isn't going to

1105
00:36:52,326 --> 00:36:53,896
scale the same way our app code

1106
00:36:53,896 --> 00:36:54,000
might.

1107
00:36:56,416 --> 00:36:58,546
So, to that end, test code is

1108
00:36:58,546 --> 00:37:00,266
important even though it isn't

1109
00:36:58,546 --> 00:37:00,266
important even though it isn't

1110
00:37:00,266 --> 00:37:00,736
shipping.

1111
00:37:02,156 --> 00:37:03,496
Also note that the test suite

1112
00:37:03,496 --> 00:37:04,936
should support the evolution of

1113
00:37:04,936 --> 00:37:06,686
your app, and not hinder change.

1114
00:37:07,156 --> 00:37:08,396
With low quality test code, it

1115
00:37:08,396 --> 00:37:10,006
becomes a burden to have to

1116
00:37:10,006 --> 00:37:11,056
update your test whenever you

1117
00:37:11,056 --> 00:37:12,276
make a change to your app.

1118
00:37:13,156 --> 00:37:14,626
But by consciously designing

1119
00:37:14,626 --> 00:37:16,416
test code with quality in mind,

1120
00:37:16,816 --> 00:37:18,736
our ability to scale won't be

1121
00:37:18,736 --> 00:37:19,856
inhibited by poorly designed

1122
00:37:19,856 --> 00:37:20,106
tests.

1123
00:37:20,836 --> 00:37:24,156
And of course, coding principles

1124
00:37:24,156 --> 00:37:26,056
that apply to app code, also

1125
00:37:26,056 --> 00:37:27,086
apply to test code.

1126
00:37:27,686 --> 00:37:28,826
Test code and app code should be

1127
00:37:28,826 --> 00:37:29,536
viewed equally.

1128
00:37:30,106 --> 00:37:33,246
And here's an idea for you.

1129
00:37:33,286 --> 00:37:34,706
We should have code reviews for

1130
00:37:34,706 --> 00:37:36,646
test code, not just code reviews

1131
00:37:36,886 --> 00:37:37,986
with test code.

1132
00:37:38,596 --> 00:37:39,446
Having code reviews that are

1133
00:37:39,446 --> 00:37:40,976
exclusively for test code,

1134
00:37:40,976 --> 00:37:42,006
ensures that somebody else is

1135
00:37:42,006 --> 00:37:42,656
checking your work, or

1136
00:37:43,016 --> 00:37:44,626
[inaudible] with a test cover,

1137
00:37:44,946 --> 00:37:46,256
and it's a chance to further

1138
00:37:46,256 --> 00:37:47,566
improve the tests themselves.

1139
00:37:47,566 --> 00:37:51,506
Now, I want to leave you with a

1140
00:37:51,506 --> 00:37:51,726
thought.

1141
00:37:52,316 --> 00:37:54,016
App code and the tests that

1142
00:37:54,016 --> 00:37:55,516
verify it, are really two halves

1143
00:37:55,516 --> 00:37:56,016
of a whole.

1144
00:37:56,726 --> 00:37:57,896
When you update your app code,

1145
00:37:57,966 --> 00:37:58,976
you'll need to update your test

1146
00:37:59,196 --> 00:37:59,716
code too.

1147
00:37:59,716 --> 00:38:04,026
We need to think of app code and

1148
00:37:59,716 --> 00:38:04,026
We need to think of app code and

1149
00:38:04,026 --> 00:38:05,966
the test code, as part of the

1150
00:38:05,966 --> 00:38:07,526
same thing, our code.

1151
00:38:08,476 --> 00:38:09,366
By making our code more

1152
00:38:09,366 --> 00:38:10,956
testable, as Brian discussed

1153
00:38:10,956 --> 00:38:12,546
earlier, and by treating test

1154
00:38:12,546 --> 00:38:13,816
code with the same care as your

1155
00:38:13,816 --> 00:38:15,286
app code, you improve the

1156
00:38:15,286 --> 00:38:16,306
quality of the whole app.

1157
00:38:17,196 --> 00:38:18,236
We ought to be proud of both

1158
00:38:18,236 --> 00:38:20,166
halves, and treat each with the

1159
00:38:20,166 --> 00:38:21,496
care and attention that they

1160
00:38:21,496 --> 00:38:21,926
deserve.

1161
00:38:25,826 --> 00:38:26,996
For more information and

1162
00:38:26,996 --> 00:38:27,976
resources regarding this

1163
00:38:27,976 --> 00:38:29,286
session, you can visit the link

1164
00:38:29,316 --> 00:38:30,226
listed on the screen.

1165
00:38:30,226 --> 00:38:33,296
Here are a few related sessions.

1166
00:38:33,356 --> 00:38:34,596
One that happened yesterday, and

1167
00:38:34,596 --> 00:38:35,826
a few that happened in previous

1168
00:38:35,826 --> 00:38:36,196
years.

1169
00:38:36,226 --> 00:38:37,616
You can check those out online,

1170
00:38:37,706 --> 00:38:40,156
or through the WWDC app.

1171
00:38:40,446 --> 00:38:41,476
And with that, I'd like to thank

1172
00:38:41,476 --> 00:38:42,506
you for your attention, and I

1173
00:38:42,506 --> 00:38:43,336
hope you enjoy the rest of the

1174
00:38:43,336 --> 00:38:43,676
conference.

1175
00:38:44,516 --> 00:38:50,500
[ Applause ]
