1
00:00:07,516 --> 00:00:21,516
[ Background Conversations ]

2
00:00:22,516 --> 00:00:27,556
[ Applause ]

3
00:00:28,056 --> 00:00:29,076
&gt;&gt; Good afternoon, everyone.

4
00:00:29,076 --> 00:00:30,446
And welcome to Metal 2

5
00:00:30,446 --> 00:00:31,796
Optimization and Debugging.

6
00:00:31,796 --> 00:00:34,716
As you know, we're talking a lot

7
00:00:34,716 --> 00:00:35,856
about Metal 2 this year, with

8
00:00:35,856 --> 00:00:37,116
some great new enhancements to

9
00:00:37,116 --> 00:00:39,106
the platform including GP driven

10
00:00:39,106 --> 00:00:40,966
rendering, machine learning

11
00:00:40,966 --> 00:00:43,936
acceleration, and a macOS VR,

12
00:00:43,936 --> 00:00:45,716
and external GPU support.

13
00:00:47,106 --> 00:00:48,466
And not forgetting Advanced

14
00:00:48,466 --> 00:00:49,636
Optimization Tools.

15
00:00:50,186 --> 00:00:52,886
So, this afternoon, we're going

16
00:00:52,886 --> 00:00:54,536
to talk about the current Metal

17
00:00:54,666 --> 00:00:56,076
tools, give you a recap of

18
00:00:56,376 --> 00:00:57,906
those, talk about some great new

19
00:00:57,906 --> 00:00:59,536
enhancements to the Metal frame

20
00:00:59,536 --> 00:01:01,356
debugger, and then finally cover

21
00:00:59,536 --> 00:01:01,356
debugger, and then finally cover

22
00:01:01,356 --> 00:01:03,136
some major enhancements in terms

23
00:01:03,136 --> 00:01:04,016
of GPU profiling.

24
00:01:04,676 --> 00:01:08,016
But first, the frame debugger.

25
00:01:10,226 --> 00:01:12,056
So hopefully you're all familiar

26
00:01:12,056 --> 00:01:12,776
with this tool.

27
00:01:14,076 --> 00:01:15,376
It is our fully-featured frame

28
00:01:15,376 --> 00:01:17,246
debugger integrated into Xcode,

29
00:01:17,246 --> 00:01:20,106
that lets you capture your Metal

30
00:01:20,106 --> 00:01:22,586
2 work, be it computer graphics,

31
00:01:22,966 --> 00:01:24,126
and then step through it into

32
00:01:24,126 --> 00:01:25,086
the debugger, to inspect state

33
00:01:25,086 --> 00:01:27,086
and resources, letting you debug

34
00:01:27,476 --> 00:01:28,186
and optimize.

35
00:01:29,076 --> 00:01:33,216
One of our focuses this year has

36
00:01:33,216 --> 00:01:34,006
been on improving the

37
00:01:34,006 --> 00:01:34,886
performance to the frame

38
00:01:34,886 --> 00:01:36,676
debugger, and in particular, we

39
00:01:36,676 --> 00:01:38,316
paid particular regard to

40
00:01:38,316 --> 00:01:39,386
improving the speed with which

41
00:01:39,676 --> 00:01:40,346
captures happen.

42
00:01:40,346 --> 00:01:43,096
And I'm happy to say that

43
00:01:43,096 --> 00:01:46,436
compared to Xcode 8, Xcode 9 now

44
00:01:46,436 --> 00:01:48,586
captures up to 10 times as fast,

45
00:01:49,106 --> 00:01:50,116
getting you from clicking the

46
00:01:50,116 --> 00:01:51,556
Capture button to into the

47
00:01:51,556 --> 00:01:52,946
debugger much, much more

48
00:01:52,946 --> 00:01:53,256
quickly.

49
00:01:56,036 --> 00:01:58,466
As you'd expect, we have full

50
00:01:58,466 --> 00:02:00,036
support for all the new Metal 2

51
00:01:58,466 --> 00:02:00,036
support for all the new Metal 2

52
00:02:00,036 --> 00:02:02,006
API, including Raster order

53
00:02:02,006 --> 00:02:04,346
groups, sampler arrays, viewport

54
00:02:04,346 --> 00:02:06,146
arrays, and the new pixel and

55
00:02:06,146 --> 00:02:07,356
vertex array formats.

56
00:02:07,876 --> 00:02:10,856
One particular part of Metal 2

57
00:02:10,856 --> 00:02:12,406
that we've paid a lot of

58
00:02:12,406 --> 00:02:14,116
attention to is the support for

59
00:02:14,116 --> 00:02:15,296
the new argument buffers.

60
00:02:15,936 --> 00:02:17,376
With this, in the buffer viewer,

61
00:02:17,626 --> 00:02:19,386
you can now see all the

62
00:02:19,386 --> 00:02:20,546
argument, buffer arguments,

63
00:02:20,646 --> 00:02:22,196
displayed in line, and you can

64
00:02:22,196 --> 00:02:23,856
click through whether it be to

65
00:02:23,856 --> 00:02:26,516
attach your sampler, buffer, or

66
00:02:26,516 --> 00:02:32,686
another argument buffer itself.

67
00:02:32,686 --> 00:02:33,956
We've also added support for VR

68
00:02:33,956 --> 00:02:35,196
captures this year, with

69
00:02:35,196 --> 00:02:36,456
automatic support for SteamVR.

70
00:02:36,456 --> 00:02:38,316
And we've added support for you

71
00:02:38,316 --> 00:02:40,216
to view your submitted surfaces

72
00:02:40,216 --> 00:02:40,966
in stereo.

73
00:02:41,446 --> 00:02:43,526
So when you get to the Submit

74
00:02:43,526 --> 00:02:44,576
call, you're sending your

75
00:02:44,576 --> 00:02:46,116
surfaces to the VR compositer,

76
00:02:46,406 --> 00:02:47,786
you will see left eye and right

77
00:02:47,786 --> 00:02:49,556
eye alongside each other, to

78
00:02:49,556 --> 00:02:51,106
quickly spot any discrepancies.

79
00:02:51,676 --> 00:02:56,496
Another area of focus this year

80
00:02:56,716 --> 00:02:58,006
has been on improving the

81
00:02:58,006 --> 00:02:59,456
workflow for capturing more

82
00:02:59,456 --> 00:03:00,416
complex workloads.

83
00:02:59,456 --> 00:03:00,416
complex workloads.

84
00:03:00,826 --> 00:03:01,836
So now if you're doing

85
00:03:01,896 --> 00:03:04,036
compute-only work in Metal, or

86
00:03:04,036 --> 00:03:05,396
perhaps you're using multiple

87
00:03:05,396 --> 00:03:07,516
Metal cues, it's much easier to

88
00:03:07,516 --> 00:03:08,846
capture exactly the work that

89
00:03:08,846 --> 00:03:09,396
you want.

90
00:03:10,446 --> 00:03:11,526
We've added the lightweight

91
00:03:11,526 --> 00:03:13,576
capture API, with some new Metal

92
00:03:13,576 --> 00:03:15,406
capture scope objects, that you

93
00:03:15,406 --> 00:03:17,416
create at startup and then reuse

94
00:03:17,416 --> 00:03:19,276
every frame to surround the work

95
00:03:19,276 --> 00:03:20,136
that you want to capture.

96
00:03:20,546 --> 00:03:21,656
You'll see a demo of this later,

97
00:03:21,656 --> 00:03:22,746
but it's great for being able to

98
00:03:22,746 --> 00:03:25,346
say, group all your regular

99
00:03:25,626 --> 00:03:28,006
rendering work in one scope, and

100
00:03:28,006 --> 00:03:29,666
some asynchronous work like

101
00:03:29,916 --> 00:03:31,126
regenerating your tessellation

102
00:03:31,126 --> 00:03:32,866
factor buffers, in another

103
00:03:32,866 --> 00:03:33,956
scope, and when you come to

104
00:03:33,956 --> 00:03:35,456
capture, you get exactly what

105
00:03:35,456 --> 00:03:35,866
you want.

106
00:03:37,416 --> 00:03:38,576
We also have support for

107
00:03:38,576 --> 00:03:39,266
triggering captures

108
00:03:39,266 --> 00:03:40,766
programmatically from your app.

109
00:03:41,316 --> 00:03:43,026
We use this a lot within our

110
00:03:43,026 --> 00:03:44,256
test apps ourselves, so that we

111
00:03:44,256 --> 00:03:45,436
can quickly do a gesture on the

112
00:03:45,436 --> 00:03:46,826
device, and trigger a frame

113
00:03:47,216 --> 00:03:48,476
capture, without having to

114
00:03:48,476 --> 00:03:53,046
switch our focus back to Xcode.

115
00:03:53,546 --> 00:03:55,076
Another new feature this year is

116
00:03:55,076 --> 00:03:56,676
support for Xcode's Quick Looks

117
00:03:57,046 --> 00:03:57,606
support.

118
00:03:58,826 --> 00:04:00,766
So now, you have lightweight

119
00:03:58,826 --> 00:04:00,766
So now, you have lightweight

120
00:04:00,766 --> 00:04:02,286
Metal debugging in the CPU

121
00:04:02,286 --> 00:04:02,856
debugger.

122
00:04:03,116 --> 00:04:05,276
So if you hit a breakpoint, and

123
00:04:05,276 --> 00:04:07,316
there is a Metal texture there,

124
00:04:07,796 --> 00:04:09,206
we'll pull back the data from

125
00:04:09,206 --> 00:04:11,426
the metal texture on the GPU and

126
00:04:11,426 --> 00:04:12,716
let you view it there and then.

127
00:04:12,916 --> 00:04:14,106
Similarly, with buffers and

128
00:04:14,106 --> 00:04:14,586
samplers.

129
00:04:15,486 --> 00:04:17,375
This is great for those cases

130
00:04:17,375 --> 00:04:19,796
where a full frame capture might

131
00:04:19,796 --> 00:04:21,736
be too invasive, for instance,

132
00:04:21,736 --> 00:04:22,786
if you're debugging your

133
00:04:22,786 --> 00:04:24,156
resource loading or some of the

134
00:04:24,156 --> 00:04:24,546
setup code.

135
00:04:24,546 --> 00:04:27,506
It is also great in cases where

136
00:04:27,506 --> 00:04:28,916
you're debugging some compute

137
00:04:28,916 --> 00:04:32,606
workloads as well.

138
00:04:33,026 --> 00:04:35,156
So last year we introduced

139
00:04:35,416 --> 00:04:37,056
support for rich filtering

140
00:04:37,266 --> 00:04:38,606
throughout the frame debugger,

141
00:04:38,686 --> 00:04:41,526
so that you could filter both on

142
00:04:41,526 --> 00:04:42,946
things like resource properties,

143
00:04:43,426 --> 00:04:44,356
but also within the frame

144
00:04:44,356 --> 00:04:47,156
navigator, you can filter based

145
00:04:47,156 --> 00:04:49,606
on contextual data, so what

146
00:04:49,936 --> 00:04:51,146
resources you're using at a

147
00:04:51,146 --> 00:04:52,506
given draw call will let that

148
00:04:52,506 --> 00:04:53,566
draw call show up.

149
00:04:53,756 --> 00:04:55,196
Well we've taken this to the

150
00:04:55,196 --> 00:04:56,626
next level this year, with

151
00:04:56,626 --> 00:04:58,136
support for data mining

152
00:04:58,136 --> 00:04:59,476
throughout your capture tray.

153
00:05:00,156 --> 00:05:01,716
So now, when you type, we'll

154
00:05:01,716 --> 00:05:03,626
give you context aware, or

155
00:05:03,626 --> 00:05:04,866
complete suggestions.

156
00:05:05,706 --> 00:05:07,886
And we now allow compound terms.

157
00:05:08,326 --> 00:05:10,236
So now if you search for a given

158
00:05:10,236 --> 00:05:12,506
encoder, and then you search for

159
00:05:12,506 --> 00:05:14,696
a texture, we'll only show you

160
00:05:14,696 --> 00:05:15,806
auto-complete suggestions for

161
00:05:15,806 --> 00:05:17,026
the textures that are actually

162
00:05:17,026 --> 00:05:22,346
used within that encoder.

163
00:05:22,946 --> 00:05:24,386
One of our most requested

164
00:05:24,386 --> 00:05:25,806
features over the years has been

165
00:05:25,806 --> 00:05:27,106
support for pixel inspection.

166
00:05:28,386 --> 00:05:29,496
And we've finally caught up with

167
00:05:29,496 --> 00:05:29,766
that.

168
00:05:30,386 --> 00:05:32,186
So now you can do detailed

169
00:05:32,186 --> 00:05:34,886
inspection of individual pixels

170
00:05:35,196 --> 00:05:36,706
within your textures and your

171
00:05:36,706 --> 00:05:37,486
render targets.

172
00:05:38,046 --> 00:05:39,366
And if you have multiple

173
00:05:39,366 --> 00:05:40,196
attachments to your render

174
00:05:40,196 --> 00:05:41,606
targets, we'll show you the

175
00:05:41,656 --> 00:05:43,366
pixel values for the same

176
00:05:43,366 --> 00:05:45,206
location in each attachment at

177
00:05:45,206 --> 00:05:45,866
the same time.

178
00:05:45,976 --> 00:05:47,146
So it's really good if you're

179
00:05:47,146 --> 00:05:48,836
trying to debug what the color

180
00:05:48,836 --> 00:05:50,136
value is alongside that and

181
00:05:50,136 --> 00:05:51,036
stencil and such like.

182
00:05:51,346 --> 00:05:52,916
It's also very valuable for

183
00:05:52,916 --> 00:05:54,516
debugging compute workloads if

184
00:05:54,516 --> 00:05:55,746
you're working with images there

185
00:05:55,746 --> 00:05:56,996
and you are, for instance,

186
00:05:56,996 --> 00:05:58,236
halfway through your CNN and you

187
00:05:58,236 --> 00:05:59,686
want to test watch to see what

188
00:05:59,686 --> 00:06:01,036
the exact values in the buffers

189
00:05:59,686 --> 00:06:01,036
the exact values in the buffers

190
00:06:01,036 --> 00:06:01,306
are.

191
00:06:03,516 --> 00:06:07,546
[ Applause ]

192
00:06:08,046 --> 00:06:09,026
&gt;&gt; Another new feature we

193
00:06:09,026 --> 00:06:10,556
introduced last year was our

194
00:06:10,556 --> 00:06:12,436
vertex attribute viewer, where

195
00:06:12,436 --> 00:06:14,336
you can see all the vertex data

196
00:06:14,486 --> 00:06:16,376
as it goes into your vertex

197
00:06:16,376 --> 00:06:18,246
shader, you know, shown on a per

198
00:06:18,246 --> 00:06:19,856
vertex basis.

199
00:06:20,496 --> 00:06:21,446
Well, this year, we've added

200
00:06:21,446 --> 00:06:23,626
support for viewing the outputs

201
00:06:23,626 --> 00:06:25,556
from your vertex shader as well,

202
00:06:25,696 --> 00:06:27,766
and we will display this inline

203
00:06:28,076 --> 00:06:29,776
with all the other input data,

204
00:06:30,146 --> 00:06:31,476
so in this case, you can see

205
00:06:31,476 --> 00:06:33,306
your position inputs, and your

206
00:06:33,306 --> 00:06:34,596
position outputs, at the same

207
00:06:34,596 --> 00:06:35,000
time.

208
00:06:38,046 --> 00:06:38,866
Well, to show you all these

209
00:06:38,866 --> 00:06:40,076
great new features in action,

210
00:06:40,076 --> 00:06:41,256
I'd like to invite my colleague,

211
00:06:41,486 --> 00:06:42,686
Max, to the stage, who is going

212
00:06:42,686 --> 00:06:44,106
to give you a demo of all this

213
00:06:44,106 --> 00:06:45,076
new stuff.

214
00:06:46,516 --> 00:06:49,556
[ Applause ]

215
00:06:50,056 --> 00:06:51,956
&gt;&gt; Hello. Great to see you here

216
00:06:51,956 --> 00:06:52,386
today.

217
00:06:52,526 --> 00:06:57,706
I hope you are doing fine and

218
00:06:57,706 --> 00:06:59,776
you are as hyped about Metal as

219
00:06:59,776 --> 00:07:00,236
we are.

220
00:06:59,776 --> 00:07:00,236
we are.

221
00:07:00,636 --> 00:07:02,616
Xcode GPU debugger helps you

222
00:07:02,616 --> 00:07:04,456
debugging your GPU and the Metal

223
00:07:04,456 --> 00:07:05,146
usage.

224
00:07:05,616 --> 00:07:07,356
I am Max, and I am going to

225
00:07:07,356 --> 00:07:08,496
maximize your debugging

226
00:07:08,496 --> 00:07:09,886
experience, showing our new

227
00:07:09,886 --> 00:07:10,246
features.

228
00:07:11,516 --> 00:07:14,696
[ Applause ]

229
00:07:15,196 --> 00:07:17,106
&gt;&gt; Yeah, let me run my demo app.

230
00:07:19,576 --> 00:07:21,676
It is rendering a beautiful

231
00:07:21,676 --> 00:07:24,056
scenery, reflects snowy

232
00:07:24,056 --> 00:07:26,266
mountains, grass that is waving

233
00:07:26,266 --> 00:07:27,936
in the wind, and to make it even

234
00:07:27,936 --> 00:07:29,986
look nicer, I added some

235
00:07:29,986 --> 00:07:31,846
particles that are glowing in

236
00:07:32,606 --> 00:07:33,176
the air.

237
00:07:33,216 --> 00:07:35,636
But as you can see, the

238
00:07:35,636 --> 00:07:37,826
particles of the grass, there is

239
00:07:37,826 --> 00:07:39,316
some kind of a problem.

240
00:07:39,546 --> 00:07:41,196
So let's figure this out.

241
00:07:41,756 --> 00:07:46,296
As a first step, let's check if

242
00:07:46,296 --> 00:07:47,336
the texture is correct.

243
00:07:47,906 --> 00:07:49,436
Let me set a breakpoint in the

244
00:07:49,436 --> 00:07:50,656
rendering loop, where this

245
00:07:50,716 --> 00:07:52,116
texture is being used.

246
00:07:53,216 --> 00:07:54,846
Hovering over a variable gives

247
00:07:54,846 --> 00:07:57,226
you access to Xcode's data tips,

248
00:07:57,566 --> 00:07:59,446
and you can quick look into the

249
00:07:59,446 --> 00:08:00,196
texture data.

250
00:07:59,446 --> 00:08:00,196
texture data.

251
00:08:00,726 --> 00:08:02,296
This data is fetched live from

252
00:08:02,296 --> 00:08:03,996
the GPU, and it helps you to

253
00:08:03,996 --> 00:08:05,576
verify the resources you are

254
00:08:05,576 --> 00:08:07,466
binding, and, of course, it

255
00:08:07,466 --> 00:08:09,136
works with all Metal resources.

256
00:08:09,856 --> 00:08:12,196
The texture in this case looks

257
00:08:12,196 --> 00:08:12,916
correct.

258
00:08:13,406 --> 00:08:20,006
So what else can we check?

259
00:08:20,276 --> 00:08:21,786
Our next step is to capture a

260
00:08:21,786 --> 00:08:22,226
frame.

261
00:08:22,686 --> 00:08:25,336
Using the little camera icon in

262
00:08:25,336 --> 00:08:27,366
the debug bar, let's you capture

263
00:08:27,366 --> 00:08:29,866
a frame, but using a long press

264
00:08:30,146 --> 00:08:31,556
gives you access to capture

265
00:08:31,556 --> 00:08:33,596
scopes and command cues.

266
00:08:33,876 --> 00:08:36,106
A capture scope is one path

267
00:08:36,306 --> 00:08:37,596
through your rendering pipeline.

268
00:08:37,846 --> 00:08:39,035
Like my environment map, I'm

269
00:08:39,035 --> 00:08:40,395
only updating every couple of

270
00:08:40,395 --> 00:08:41,066
frames.

271
00:08:41,826 --> 00:08:43,366
In this case, however, we want

272
00:08:43,366 --> 00:08:44,596
to capture rendering, this is

273
00:08:44,596 --> 00:08:45,636
where the particles are being

274
00:08:45,636 --> 00:08:45,936
drawn.

275
00:08:46,866 --> 00:08:49,836
So let's capture this.

276
00:08:50,046 --> 00:08:50,946
And already done.

277
00:08:51,476 --> 00:08:54,096
For those who are not familiar

278
00:08:54,096 --> 00:08:55,956
with our tool, I will give you a

279
00:08:55,956 --> 00:08:56,986
quick run through of all the

280
00:08:56,986 --> 00:08:58,186
views you are seeing here.

281
00:08:58,186 --> 00:09:01,726
On the left side, we have the

282
00:08:58,186 --> 00:09:01,726
On the left side, we have the

283
00:09:01,726 --> 00:09:02,716
debug navigator.

284
00:09:03,186 --> 00:09:04,276
It is in [inaudible]

285
00:09:04,276 --> 00:09:06,396
presentation of your frame, and

286
00:09:06,396 --> 00:09:08,016
to help you, we automatically

287
00:09:08,016 --> 00:09:10,316
group by command buffers and

288
00:09:10,316 --> 00:09:11,376
command encoders.

289
00:09:12,346 --> 00:09:13,926
But also your debugging groups

290
00:09:13,926 --> 00:09:15,936
are shown here, giving you fine

291
00:09:15,936 --> 00:09:17,566
grain control over the grouping.

292
00:09:17,906 --> 00:09:19,856
You can select the draw call or

293
00:09:19,856 --> 00:09:21,526
any other Metal call to inspect

294
00:09:21,526 --> 00:09:22,346
further details.

295
00:09:23,136 --> 00:09:27,406
The editor in the center is

296
00:09:27,406 --> 00:09:29,106
showing the bound resources.

297
00:09:29,496 --> 00:09:30,846
All the Metal objects you are

298
00:09:30,846 --> 00:09:32,986
using in the selected API call.

299
00:09:33,986 --> 00:09:35,976
Again, you can see labeling your

300
00:09:35,976 --> 00:09:37,726
objects will greatly increase

301
00:09:37,726 --> 00:09:38,536
readability.

302
00:09:38,926 --> 00:09:41,306
So I suggest to do that.

303
00:09:42,956 --> 00:09:45,026
The editor on the right side is

304
00:09:45,026 --> 00:09:46,556
showing the attachments, the

305
00:09:46,556 --> 00:09:48,556
output of the last issued draw

306
00:09:48,556 --> 00:09:48,936
call.

307
00:09:49,136 --> 00:09:50,066
So whenever you are, like,

308
00:09:50,066 --> 00:09:51,416
navigating through your frame,

309
00:09:51,606 --> 00:09:53,106
you instantly see where you are.

310
00:09:53,936 --> 00:09:56,346
On the bottom, we have our

311
00:09:56,346 --> 00:09:58,166
variables view, where you can

312
00:09:58,166 --> 00:10:00,156
access all the states of each

313
00:09:58,166 --> 00:10:00,156
access all the states of each

314
00:10:00,156 --> 00:10:01,026
Metal object.

315
00:10:01,506 --> 00:10:03,296
Back to our problem with the

316
00:10:03,296 --> 00:10:04,366
particles.

317
00:10:04,786 --> 00:10:06,216
Here, we can make use of our new

318
00:10:06,216 --> 00:10:07,756
super powerful filtering.

319
00:10:08,496 --> 00:10:11,226
So I know the particles are

320
00:10:11,226 --> 00:10:12,666
drawn somewhere in my forward

321
00:10:12,666 --> 00:10:12,976
rendering.

322
00:10:13,316 --> 00:10:15,556
So let me filter for this.

323
00:10:15,866 --> 00:10:17,576
Filtering for command encoder

324
00:10:17,976 --> 00:10:20,786
will only show API calls inside

325
00:10:20,786 --> 00:10:21,926
this command encoder.

326
00:10:21,926 --> 00:10:22,846
Like this.

327
00:10:23,446 --> 00:10:25,486
But it is still a lot.

328
00:10:26,646 --> 00:10:28,386
So let me add an additional

329
00:10:28,386 --> 00:10:28,736
filter.

330
00:10:29,086 --> 00:10:30,616
We know it is using our particle

331
00:10:30,616 --> 00:10:31,066
texture.

332
00:10:34,556 --> 00:10:37,186
Filtering for texture will only

333
00:10:37,186 --> 00:10:39,476
show draw calls using this

334
00:10:39,476 --> 00:10:39,896
texture.

335
00:10:40,576 --> 00:10:43,656
And boom, this combination of

336
00:10:43,656 --> 00:10:46,046
filters results in a single API

337
00:10:46,046 --> 00:10:47,986
call we want to inspect further.

338
00:10:48,726 --> 00:10:49,536
So let's go here.

339
00:10:50,016 --> 00:10:53,296
Let's take a look at the bound

340
00:10:53,296 --> 00:10:54,166
resources.

341
00:10:55,046 --> 00:10:57,026
The vertex attributes combines

342
00:10:57,026 --> 00:10:58,456
the data that is going into your

343
00:10:58,456 --> 00:11:01,026
vertex function and leaving it.

344
00:10:58,456 --> 00:11:01,026
vertex function and leaving it.

345
00:11:01,296 --> 00:11:02,616
Maybe we are doing something

346
00:11:02,616 --> 00:11:05,106
wrong with our geometry here, so

347
00:11:05,106 --> 00:11:06,196
let's open this by double

348
00:11:06,196 --> 00:11:06,616
clicking.

349
00:11:07,626 --> 00:11:09,696
Let me also hide the attachments

350
00:11:09,696 --> 00:11:10,406
for a moment.

351
00:11:11,626 --> 00:11:13,036
Last year, we started to show

352
00:11:13,036 --> 00:11:14,436
you a nice layout for all the

353
00:11:14,436 --> 00:11:14,976
buffers.

354
00:11:16,516 --> 00:11:17,836
And this year we added something

355
00:11:17,836 --> 00:11:18,186
more.

356
00:11:18,986 --> 00:11:20,316
In the header, you can see the

357
00:11:20,316 --> 00:11:21,746
direction where the data is

358
00:11:21,746 --> 00:11:22,306
flowing.

359
00:11:23,266 --> 00:11:28,336
And if we take a look, this is

360
00:11:28,336 --> 00:11:29,626
the output data, the data that

361
00:11:29,626 --> 00:11:31,106
is leaving the vertex function.

362
00:11:31,376 --> 00:11:32,966
This is the output position of

363
00:11:33,106 --> 00:11:35,776
every particle vertex, and as we

364
00:11:35,776 --> 00:11:37,336
can see here, there is no

365
00:11:37,376 --> 00:11:39,286
obvious error, like big numbers

366
00:11:39,286 --> 00:11:41,166
or something like this, so I

367
00:11:41,166 --> 00:11:42,706
assume this data is correct.

368
00:11:43,446 --> 00:11:45,336
So what else can we check?

369
00:11:46,036 --> 00:11:50,386
The debug navigator now gives

370
00:11:50,386 --> 00:11:51,836
you quick access to all the

371
00:11:51,836 --> 00:11:53,596
views related to this draw call.

372
00:11:53,926 --> 00:11:54,846
Let's switch back to the

373
00:11:54,846 --> 00:11:55,746
attachments again.

374
00:11:56,256 --> 00:12:01,306
We are using two render targets

375
00:11:56,256 --> 00:12:01,306
We are using two render targets

376
00:12:01,306 --> 00:12:01,506
here.

377
00:12:02,436 --> 00:12:04,566
Color, and depth.

378
00:12:05,076 --> 00:12:06,796
Let's inspect some more pixel

379
00:12:06,796 --> 00:12:07,376
values.

380
00:12:07,876 --> 00:12:11,586
Using the inspect pixels button

381
00:12:11,586 --> 00:12:13,156
in the lower right corner, we

382
00:12:13,226 --> 00:12:16,456
will present a new tool.

383
00:12:16,556 --> 00:12:20,386
A loop. This loop displays the

384
00:12:20,386 --> 00:12:22,106
value like they are outputted by

385
00:12:22,106 --> 00:12:23,296
the fragment function.

386
00:12:24,246 --> 00:12:26,256
And you can move the loop around

387
00:12:26,256 --> 00:12:27,506
all the render targets.

388
00:12:28,386 --> 00:12:29,796
But you can also use your arrow

389
00:12:29,796 --> 00:12:31,796
keys for pixel precise control,

390
00:12:31,796 --> 00:12:33,186
even if you are not zoomed in.

391
00:12:34,396 --> 00:12:36,566
Also, you notice, all the loops

392
00:12:36,566 --> 00:12:37,806
are being synchronized between

393
00:12:37,806 --> 00:12:38,956
all the render targets.

394
00:12:39,246 --> 00:12:40,976
That helps you to relate values.

395
00:12:41,256 --> 00:12:43,306
Let me find an interesting pixel

396
00:12:45,056 --> 00:12:45,136
now.

397
00:12:45,356 --> 00:12:46,426
Using a long press will

398
00:12:46,426 --> 00:12:47,666
instantly move the cursor.

399
00:12:48,286 --> 00:12:51,686
And here we can see something

400
00:12:51,686 --> 00:12:52,576
strange.

401
00:12:53,466 --> 00:12:55,676
The depth value inside and

402
00:12:55,676 --> 00:12:57,586
outside a particle is different,

403
00:12:58,076 --> 00:12:59,796
and let's opt, our particles

404
00:12:59,796 --> 00:13:00,946
shouldn't write into the depths

405
00:12:59,796 --> 00:13:00,946
shouldn't write into the depths

406
00:13:00,946 --> 00:13:01,896
buffer, of course.

407
00:13:02,526 --> 00:13:03,896
That will be an easy fix.

408
00:13:04,316 --> 00:13:05,976
And I'm also sure our new GPU

409
00:13:05,976 --> 00:13:07,536
debugger will help you fixing

410
00:13:07,536 --> 00:13:08,886
your issues with the GPU.

411
00:13:09,906 --> 00:13:11,346
I hope we see each other in the

412
00:13:11,346 --> 00:13:13,326
labs tomorrow morning, or at the

413
00:13:13,326 --> 00:13:14,226
[inaudible] later today.

414
00:13:14,936 --> 00:13:16,296
Back to my colleague, Seth.

415
00:13:17,516 --> 00:13:23,256
[ Applause ]

416
00:13:23,756 --> 00:13:26,276
&gt;&gt; So now, onto GPU profiling.

417
00:13:27,896 --> 00:13:29,796
As you know, performance is

418
00:13:29,796 --> 00:13:30,896
crucial to games and other

419
00:13:30,896 --> 00:13:32,596
graphical applications, and

420
00:13:32,596 --> 00:13:33,966
achieving a consistent, fast

421
00:13:33,966 --> 00:13:35,316
framework is always necessary.

422
00:13:36,106 --> 00:13:37,216
But on the flip side, you want

423
00:13:37,216 --> 00:13:38,616
to get the most of the GPU for

424
00:13:38,616 --> 00:13:40,066
the best looking game as well,

425
00:13:40,066 --> 00:13:41,756
and at the same time, increase

426
00:13:41,756 --> 00:13:43,106
efficiency for a longer game

427
00:13:43,106 --> 00:13:43,846
experience.

428
00:13:44,556 --> 00:13:45,726
Well, for all this, you need to

429
00:13:45,726 --> 00:13:47,206
use the GPU Profiling tools.

430
00:13:47,656 --> 00:13:53,046
The first tool I want to talk

431
00:13:53,046 --> 00:13:54,546
about is Metal System Trace.

432
00:13:55,396 --> 00:13:56,236
This is our tool for

433
00:13:56,236 --> 00:13:58,446
investigating timing issues, by

434
00:13:58,446 --> 00:14:00,136
which I mean investigating cases

435
00:13:58,446 --> 00:14:00,136
which I mean investigating cases

436
00:14:00,136 --> 00:14:02,446
where the CPU and the GPU might

437
00:14:02,446 --> 00:14:04,656
not be running in parallel,

438
00:14:04,656 --> 00:14:06,286
because you have some synching

439
00:14:06,286 --> 00:14:07,836
operations by mistake, and

440
00:14:07,836 --> 00:14:08,726
you're forcing them to work in

441
00:14:08,726 --> 00:14:09,116
serial.

442
00:14:09,796 --> 00:14:10,586
It's also great for

443
00:14:10,586 --> 00:14:12,166
investigating those cases where

444
00:14:12,396 --> 00:14:13,586
you're mostly achieving the

445
00:14:13,586 --> 00:14:14,676
framework you want, but

446
00:14:14,676 --> 00:14:15,976
occasionally you get a stutter,

447
00:14:16,246 --> 00:14:17,126
and you need to figure out,

448
00:14:17,126 --> 00:14:18,306
okay, what is going wrong in

449
00:14:18,306 --> 00:14:19,226
that particular frame?

450
00:14:20,106 --> 00:14:21,676
It lets you trace your Metal

451
00:14:21,676 --> 00:14:22,966
workloads through the system,

452
00:14:23,046 --> 00:14:25,436
from CPU to GPU to display.

453
00:14:27,436 --> 00:14:29,606
This year, we've added support

454
00:14:29,606 --> 00:14:31,296
for VR applications, with

455
00:14:31,296 --> 00:14:33,056
specific VR trace points for

456
00:14:33,056 --> 00:14:35,836
activities like when you query

457
00:14:35,836 --> 00:14:38,916
the head set for post-data, when

458
00:14:38,916 --> 00:14:40,516
you submit your surfaces to the

459
00:14:40,516 --> 00:14:43,086
VR compositor, when it does its

460
00:14:43,086 --> 00:14:45,196
work to do the compositing, and

461
00:14:45,196 --> 00:14:46,946
finally, when it hits the glass

462
00:14:47,106 --> 00:14:48,506
on the headset.

463
00:14:49,576 --> 00:14:51,406
In effect, it lets you trace

464
00:14:51,406 --> 00:14:53,366
from motion to photon.

465
00:14:55,976 --> 00:14:58,266
We've also added support this

466
00:14:58,266 --> 00:14:59,566
year for the new ProMotion

467
00:14:59,566 --> 00:15:02,076
displays, as you'll find in the

468
00:14:59,566 --> 00:15:02,076
displays, as you'll find in the

469
00:15:02,076 --> 00:15:04,096
new iPads, iPad Pros released

470
00:15:04,096 --> 00:15:06,066
early this week, and also

471
00:15:06,066 --> 00:15:08,046
support for external GPUs on

472
00:15:08,046 --> 00:15:08,666
macOS.

473
00:15:09,476 --> 00:15:10,776
It is also worth noting there

474
00:15:10,776 --> 00:15:11,906
are some great improvements in

475
00:15:11,906 --> 00:15:13,846
the instruments, to make it much

476
00:15:13,846 --> 00:15:15,616
easier to view other instruments

477
00:15:15,786 --> 00:15:17,646
alongside Metal System Trace in

478
00:15:17,646 --> 00:15:20,386
a more integrated fashion.

479
00:15:20,816 --> 00:15:22,776
Our next profiling tool is the

480
00:15:22,776 --> 00:15:23,806
GPU Shader Profiler.

481
00:15:24,306 --> 00:15:25,726
The tool for probing shader

482
00:15:25,726 --> 00:15:26,326
performance.

483
00:15:27,076 --> 00:15:28,316
It is integrated into the frame

484
00:15:28,316 --> 00:15:29,626
debugger, and lets you view

485
00:15:29,626 --> 00:15:31,466
shader time on a per draw call

486
00:15:31,466 --> 00:15:33,116
and per pipeline basis.

487
00:15:33,686 --> 00:15:37,416
And if you're on iOS or tvOS, it

488
00:15:37,416 --> 00:15:39,236
also lets you view it on a per

489
00:15:39,236 --> 00:15:39,956
line basis.

490
00:15:41,696 --> 00:15:43,136
Well, our first new tool this

491
00:15:43,136 --> 00:15:44,816
year is designed to work hand in

492
00:15:44,816 --> 00:15:46,006
hand with the GPU Shader

493
00:15:46,006 --> 00:15:46,496
Profiler.

494
00:15:48,636 --> 00:15:50,296
We call that Metal Pipeline

495
00:15:50,296 --> 00:15:51,046
Statistics.

496
00:15:53,036 --> 00:15:55,436
Metal Pipeline Statistics gives

497
00:15:55,436 --> 00:15:57,456
you a direct line to the GPU

498
00:15:57,456 --> 00:15:59,306
compiler to find out about the

499
00:15:59,306 --> 00:16:00,916
quality of the machine code the

500
00:15:59,306 --> 00:16:00,916
quality of the machine code the

501
00:16:00,916 --> 00:16:02,946
compiler is generating from your

502
00:16:03,016 --> 00:16:03,316
shader.

503
00:16:04,066 --> 00:16:05,176
It gives you a rich set of

504
00:16:05,176 --> 00:16:06,606
statistics with things such as

505
00:16:06,756 --> 00:16:08,366
instruction count, instruction

506
00:16:08,366 --> 00:16:10,236
mix, by which I mean the

507
00:16:10,236 --> 00:16:11,796
relative ratio of operations

508
00:16:11,796 --> 00:16:13,396
such as ALU or memory or control

509
00:16:13,396 --> 00:16:15,826
flow, and on GPUs where it is

510
00:16:15,826 --> 00:16:17,216
relevant, it will also show you

511
00:16:17,216 --> 00:16:18,866
register usage and occupancy.

512
00:16:19,306 --> 00:16:21,986
For GPUs such as that, these

513
00:16:22,016 --> 00:16:23,436
measures are crucial in

514
00:16:23,436 --> 00:16:25,306
understanding what is the

515
00:16:25,306 --> 00:16:27,766
limitations on how many shaders

516
00:16:27,766 --> 00:16:29,496
can be scheduled simultaneously,

517
00:16:30,176 --> 00:16:32,486
by which shader instances can be

518
00:16:32,646 --> 00:16:33,646
scheduled simultaneously.

519
00:16:34,876 --> 00:16:37,976
But even better are the new

520
00:16:37,976 --> 00:16:39,066
compiler remarks.

521
00:16:39,736 --> 00:16:41,636
With this, the GPU compiler will

522
00:16:41,636 --> 00:16:43,446
give you direct actual guidance

523
00:16:43,666 --> 00:16:44,786
on the performance of your

524
00:16:44,786 --> 00:16:46,506
shader, and things you can do to

525
00:16:46,506 --> 00:16:48,556
avoid performance hits, from

526
00:16:48,556 --> 00:16:49,956
things such as slow math usage,

527
00:16:50,256 --> 00:16:51,776
register spills, and stack

528
00:16:51,776 --> 00:16:52,216
usage.

529
00:16:52,796 --> 00:16:56,906
It's like having a GPU compiler

530
00:16:56,906 --> 00:16:59,636
engineer built into every Xcode.

531
00:17:00,736 --> 00:17:02,806
For each remark, it will explain

532
00:17:02,946 --> 00:17:06,246
what it means, what you can do

533
00:17:06,316 --> 00:17:08,796
to reduce it, and give you a

534
00:17:08,796 --> 00:17:11,006
link to where you need to go to

535
00:17:11,076 --> 00:17:11,536
fix it.

536
00:17:12,695 --> 00:17:13,955
Well, to demo this new feature,

537
00:17:13,955 --> 00:17:15,036
I'd like to invite my colleague

538
00:17:15,256 --> 00:17:16,935
Jose to the stage, to give you a

539
00:17:16,935 --> 00:17:18,465
tour of Metal Pipeline

540
00:17:18,465 --> 00:17:19,086
Statistics.

541
00:17:20,516 --> 00:17:22,546
[ Applause ]

542
00:17:23,046 --> 00:17:23,536
&gt;&gt; Hello everyone.

543
00:17:23,685 --> 00:17:24,526
My name is Jose Enrique

544
00:17:24,526 --> 00:17:24,606
[inaudible].

545
00:17:24,606 --> 00:17:26,006
I am going to present you a new

546
00:17:26,006 --> 00:17:27,556
feature of our GPU friendly

547
00:17:27,556 --> 00:17:28,946
debugger that will have you

548
00:17:29,296 --> 00:17:30,466
produce good quality.

549
00:17:30,836 --> 00:17:32,416
As you can see, we are replaying

550
00:17:32,526 --> 00:17:33,786
a capture of Metal [inaudible]

551
00:17:33,976 --> 00:17:35,166
demo for iOS.

552
00:17:35,996 --> 00:17:37,956
The first thing I'm going to do,

553
00:17:37,956 --> 00:17:39,286
I'm going to change my debug

554
00:17:39,286 --> 00:17:41,196
navigator view from view frame

555
00:17:41,196 --> 00:17:42,766
by call to view frame by

556
00:17:42,766 --> 00:17:43,496
performance.

557
00:17:44,026 --> 00:17:46,916
What this gives, what this view

558
00:17:46,916 --> 00:17:50,216
gives is all these pipelines you

559
00:17:50,216 --> 00:17:53,956
capture, sorted by time.

560
00:17:54,146 --> 00:17:56,066
Remember, in Metal, a shader is

561
00:17:56,066 --> 00:17:57,156
always linked to a pipeline,

562
00:17:57,556 --> 00:17:59,556
therefore, this is a list of all

563
00:17:59,556 --> 00:18:00,656
initiator combinations that are

564
00:17:59,556 --> 00:18:00,656
initiator combinations that are

565
00:18:00,656 --> 00:18:01,126
available in [inaudible]

566
00:18:01,126 --> 00:18:01,466
capture.

567
00:18:02,486 --> 00:18:04,506
I am going to go to a

568
00:18:04,506 --> 00:18:05,296
[inaudible] view of the most

569
00:18:05,296 --> 00:18:06,836
expensive pipeline, to see if we

570
00:18:06,836 --> 00:18:07,866
can improve the shaders.

571
00:18:08,436 --> 00:18:12,726
As you can see, this view has

572
00:18:12,726 --> 00:18:13,586
three sections.

573
00:18:13,956 --> 00:18:15,686
On top, we have remarks.

574
00:18:16,296 --> 00:18:17,626
Remarks are a unique approach to

575
00:18:17,626 --> 00:18:19,246
the compiler shader quality.

576
00:18:19,616 --> 00:18:21,576
As the report, final compiler

577
00:18:22,116 --> 00:18:23,486
co-generation issues.

578
00:18:24,646 --> 00:18:26,326
Remember, the GPU will execute

579
00:18:26,326 --> 00:18:28,206
your shader millions of times

580
00:18:28,206 --> 00:18:30,046
per frame, therefore, the

581
00:18:30,046 --> 00:18:31,446
[inaudible] you can get, the

582
00:18:31,446 --> 00:18:33,746
better the performance it will

583
00:18:33,746 --> 00:18:34,016
have.

584
00:18:35,096 --> 00:18:36,406
Remarks also are sorted by

585
00:18:36,406 --> 00:18:38,766
relevance, and if expanded, they

586
00:18:38,766 --> 00:18:41,106
offer you reason on why we're

587
00:18:41,106 --> 00:18:42,986
reporting it, and our

588
00:18:42,986 --> 00:18:44,556
recommendation on how to prevent

589
00:18:45,456 --> 00:18:45,523
it.

590
00:18:46,226 --> 00:18:47,836
Below remarks, we have an

591
00:18:47,836 --> 00:18:49,336
overview for each shader, where

592
00:18:49,336 --> 00:18:50,496
you can see how the compiler

593
00:18:50,576 --> 00:18:52,986
final assemblies compose

594
00:18:52,986 --> 00:18:54,096
[inaudible] of instruction

595
00:18:54,166 --> 00:18:54,876
ratios.

596
00:18:56,186 --> 00:18:58,046
And finally, we have a list of

597
00:18:58,106 --> 00:18:59,306
all the recalls using this

598
00:18:59,306 --> 00:18:59,756
pipeline.

599
00:19:00,396 --> 00:19:01,626
This will become very handy

600
00:19:01,626 --> 00:19:02,776
whenever we are iterating over

601
00:19:02,776 --> 00:19:03,396
our shaders.

602
00:19:04,426 --> 00:19:06,946
So let me showcase an example of

603
00:19:06,946 --> 00:19:08,506
workflow profiler statistics.

604
00:19:09,376 --> 00:19:10,976
We go to our top remark,

605
00:19:11,186 --> 00:19:13,036
Register Spill, we can see the

606
00:19:13,036 --> 00:19:14,846
compiler is reporting a big

607
00:19:14,846 --> 00:19:16,946
spill, 1,040 bytes.

608
00:19:17,786 --> 00:19:19,246
Spills will cause the GPU to

609
00:19:19,246 --> 00:19:21,546
access memory, which can stall

610
00:19:21,546 --> 00:19:22,486
your shade execution.

611
00:19:23,856 --> 00:19:24,806
Knowing that a compiler is

612
00:19:24,806 --> 00:19:26,326
spilling and fixing it can

613
00:19:26,326 --> 00:19:27,376
drastically improve your shader

614
00:19:27,376 --> 00:19:29,636
performance, yet finding where

615
00:19:29,636 --> 00:19:30,886
and why the compiler is spilling

616
00:19:31,296 --> 00:19:32,566
tends to be a time consuming

617
00:19:32,566 --> 00:19:32,876
manual [inaudible].

618
00:19:33,936 --> 00:19:36,596
But notice the second and fourth

619
00:19:36,596 --> 00:19:37,106
remarks.

620
00:19:37,586 --> 00:19:39,156
Dynamic Stack Store, and Dynamic

621
00:19:39,156 --> 00:19:39,766
Stack Load.

622
00:19:40,776 --> 00:19:43,056
If expanded, they offer a reason

623
00:19:43,226 --> 00:19:45,046
an expensive stack load is

624
00:19:45,046 --> 00:19:46,716
emitted to a dynamic offset in a

625
00:19:46,716 --> 00:19:47,416
local array.

626
00:19:48,256 --> 00:19:51,096
As well as a recommendation, to

627
00:19:51,096 --> 00:19:52,256
reduce the stack access,

628
00:19:52,336 --> 00:19:53,786
eliminate dynamic access to

629
00:19:53,786 --> 00:19:54,476
local arrays.

630
00:19:55,236 --> 00:19:57,026
This is basically saying that we

631
00:19:57,026 --> 00:19:58,586
have an array variable in our

632
00:19:58,586 --> 00:20:00,116
shader code that is storing the

633
00:19:58,586 --> 00:20:00,116
shader code that is storing the

634
00:20:00,116 --> 00:20:01,936
stack and where accessing it

635
00:20:01,936 --> 00:20:03,416
using some other index variable.

636
00:20:04,296 --> 00:20:05,996
This is a very common pattern

637
00:20:05,996 --> 00:20:07,816
when providing for the CPU, but

638
00:20:07,816 --> 00:20:09,286
GPUs are different, they suffer

639
00:20:09,286 --> 00:20:11,346
when we rely on stack usage.

640
00:20:11,966 --> 00:20:14,726
But note the languages below the

641
00:20:14,726 --> 00:20:15,376
recommendation.

642
00:20:15,426 --> 00:20:16,916
It has an exact line number.

643
00:20:17,436 --> 00:20:18,676
This means that we option click

644
00:20:18,776 --> 00:20:22,086
to it, we'll jump directly to

645
00:20:22,086 --> 00:20:23,426
the [inaudible] line where the

646
00:20:23,426 --> 00:20:25,146
compiler is actually loading

647
00:20:25,146 --> 00:20:26,286
data from the stack array.

648
00:20:26,776 --> 00:20:27,896
We just found the compiler

649
00:20:27,896 --> 00:20:28,296
spill.

650
00:20:29,366 --> 00:20:30,656
Also these align very well with

651
00:20:30,656 --> 00:20:31,676
our shared performing data,

652
00:20:31,676 --> 00:20:33,116
informing us of the high cost of

653
00:20:33,116 --> 00:20:34,986
this line, which now we know

654
00:20:34,986 --> 00:20:35,666
exactly why.

655
00:20:37,396 --> 00:20:40,326
The shader is doing two passes.

656
00:20:41,056 --> 00:20:42,836
The first pass, doing some light

657
00:20:42,836 --> 00:20:43,586
computation.

658
00:20:44,166 --> 00:20:46,956
And a second pass, doing the

659
00:20:46,956 --> 00:20:47,776
light accumulation.

660
00:20:48,766 --> 00:20:49,766
This speaks to the issue by

661
00:20:49,766 --> 00:20:51,076
working with the compiler but

662
00:20:51,076 --> 00:20:52,186
from a GPU perspective.

663
00:20:52,856 --> 00:20:55,056
The first thing I'm going to do,

664
00:20:55,176 --> 00:20:56,686
I'm going to remove the stack

665
00:20:56,686 --> 00:20:59,756
array, I am going to remove it

666
00:20:59,756 --> 00:21:02,366
in relation, and then I'm going

667
00:20:59,756 --> 00:21:02,366
in relation, and then I'm going

668
00:21:02,366 --> 00:21:03,536
to compute the light

669
00:21:03,536 --> 00:21:04,896
accommodation directly into the

670
00:21:04,896 --> 00:21:06,166
first loop.

671
00:21:09,116 --> 00:21:10,736
Then I am going to remove the

672
00:21:10,736 --> 00:21:12,976
second loop, and just not do

673
00:21:13,996 --> 00:21:14,316
that anymore.

674
00:21:14,316 --> 00:21:15,916
Now, I click my update shader

675
00:21:15,916 --> 00:21:17,396
button, and wait for the

676
00:21:17,396 --> 00:21:17,916
results.

677
00:21:18,516 --> 00:21:19,646
What this is going to do, it's

678
00:21:19,646 --> 00:21:20,966
going to have the compiler

679
00:21:20,966 --> 00:21:21,776
perform a whole loop

680
00:21:21,776 --> 00:21:24,376
optimization and reuse the same

681
00:21:24,376 --> 00:21:26,636
reducer over and over, instead

682
00:21:26,636 --> 00:21:27,596
of relying on the stack.

683
00:21:28,906 --> 00:21:30,356
Once the results are back, we

684
00:21:30,356 --> 00:21:31,786
can see the instruction ratio

685
00:21:31,786 --> 00:21:33,356
between the previous and current

686
00:21:33,356 --> 00:21:35,416
[inaudible] has been reduced, as

687
00:21:35,416 --> 00:21:36,486
well as the impact of this

688
00:21:36,486 --> 00:21:38,006
change on every single draw call

689
00:21:38,006 --> 00:21:39,726
used in the pipeline, giving us

690
00:21:39,726 --> 00:21:41,296
also whole space performance

691
00:21:41,296 --> 00:21:41,896
improvements.

692
00:21:43,046 --> 00:21:44,226
And with this, I conclude my

693
00:21:44,226 --> 00:21:44,986
example of [inaudible]

694
00:21:44,986 --> 00:21:46,246
statistics.

695
00:21:46,466 --> 00:21:47,656
I hand it back to my colleague,

696
00:21:47,656 --> 00:21:47,926
Seth.

697
00:21:49,516 --> 00:21:54,756
[ Applause ]

698
00:21:55,256 --> 00:21:56,866
&gt;&gt; Thank you, Jose.

699
00:21:56,966 --> 00:21:59,766
And finally, onto our last new

700
00:21:59,766 --> 00:22:00,296
tool today.

701
00:21:59,766 --> 00:22:00,296
tool today.

702
00:22:00,726 --> 00:22:02,286
GPU Counter Profiling.

703
00:22:02,806 --> 00:22:06,196
As you know, GPU architecture is

704
00:22:06,196 --> 00:22:08,056
complex, with a pipeline

705
00:22:08,056 --> 00:22:08,986
consisting of multiple

706
00:22:08,986 --> 00:22:10,366
programmable and fixed function

707
00:22:10,366 --> 00:22:12,196
blocks, bottlenecks can occur at

708
00:22:12,196 --> 00:22:13,396
any point within the pipeline,

709
00:22:14,216 --> 00:22:15,476
and often, at multiple

710
00:22:15,546 --> 00:22:16,936
simultaneous points.

711
00:22:18,386 --> 00:22:20,986
Your job as Metal programmers is

712
00:22:20,986 --> 00:22:23,026
to minimize fixed function

713
00:22:23,026 --> 00:22:24,366
bottlenecks while efficiently

714
00:22:24,366 --> 00:22:25,966
harnessing programmable blocks.

715
00:22:28,776 --> 00:22:30,586
Well, to do that, our new GPU

716
00:22:30,586 --> 00:22:33,166
Counter Profiling is the tool.

717
00:22:33,546 --> 00:22:36,106
Instead of going directly into

718
00:22:36,106 --> 00:22:38,236
the GPU Frame Debugger, it gives

719
00:22:38,236 --> 00:22:40,286
you detailed GPU hardware

720
00:22:40,286 --> 00:22:42,866
performance statistics on a per

721
00:22:42,866 --> 00:22:46,496
draw call, on macOS and per

722
00:22:46,496 --> 00:22:49,066
encoder on iOS and tvOS basis.

723
00:22:50,036 --> 00:22:51,986
And instead of giving you an

724
00:22:51,986 --> 00:22:54,336
arcane list of counters that

725
00:22:54,336 --> 00:22:55,906
change for every GPU and are

726
00:22:55,906 --> 00:22:57,676
hard to understand, and often

727
00:22:58,206 --> 00:22:59,216
don't tell you what you need to

728
00:22:59,216 --> 00:23:01,576
know, we've defined a high level

729
00:22:59,216 --> 00:23:01,576
know, we've defined a high level

730
00:23:01,576 --> 00:23:03,236
set of characters that mean the

731
00:23:03,236 --> 00:23:04,936
same across each GPU.

732
00:23:05,286 --> 00:23:07,296
So you don't have a per GPU

733
00:23:07,296 --> 00:23:08,666
learning curve.

734
00:23:10,156 --> 00:23:12,606
So here is the Counter

735
00:23:12,606 --> 00:23:13,146
Profiling.

736
00:23:13,146 --> 00:23:16,726
On the left, we have a graph

737
00:23:16,726 --> 00:23:19,506
view, showing you detailed GPU

738
00:23:19,546 --> 00:23:21,156
counter graphs, and on the

739
00:23:21,156 --> 00:23:22,886
right, the detail window.

740
00:23:23,606 --> 00:23:25,246
Let's talk about those in order.

741
00:23:26,036 --> 00:23:29,866
In the graph view, we show you

742
00:23:30,276 --> 00:23:33,306
counters across your frame,

743
00:23:33,936 --> 00:23:35,706
where the x axis represents draw

744
00:23:35,706 --> 00:23:37,836
calls, or encoders across time.

745
00:23:39,036 --> 00:23:40,506
At the top, we show you GPU

746
00:23:40,506 --> 00:23:40,826
time.

747
00:23:40,826 --> 00:23:43,206
As that is inherent to all GPU

748
00:23:43,206 --> 00:23:43,996
counter profiling.

749
00:23:44,746 --> 00:23:45,886
And then below that, a set of

750
00:23:45,886 --> 00:23:47,106
top level counters that

751
00:23:47,106 --> 00:23:48,706
correspond to the stages in the

752
00:23:48,706 --> 00:23:50,986
GPU pipeline, along with some

753
00:23:50,986 --> 00:23:52,386
other top level counters that

754
00:23:52,386 --> 00:23:53,996
correspond to shared execution

755
00:23:53,996 --> 00:23:55,816
units, such as the shader core

756
00:23:55,816 --> 00:23:56,836
and test units.

757
00:23:58,616 --> 00:24:00,796
For each group, you can drill

758
00:23:58,616 --> 00:24:00,796
For each group, you can drill

759
00:24:00,796 --> 00:24:02,686
down to more detailed counters,

760
00:24:02,686 --> 00:24:04,726
exploring a lot more data for

761
00:24:04,726 --> 00:24:06,966
each stage, and this is great

762
00:24:06,966 --> 00:24:08,926
for work flow where you identify

763
00:24:08,926 --> 00:24:10,616
it as your first cut, where you

764
00:24:10,616 --> 00:24:11,816
think the performance issue is,

765
00:24:11,976 --> 00:24:13,746
and then drill down to see why

766
00:24:13,746 --> 00:24:14,286
it's going on.

767
00:24:14,976 --> 00:24:19,586
In the detail view, we'll show

768
00:24:19,586 --> 00:24:20,976
you all the same counters from

769
00:24:20,976 --> 00:24:22,306
the counter graph view, but

770
00:24:22,306 --> 00:24:23,706
displayed in full detail

771
00:24:23,706 --> 00:24:24,226
numerically.

772
00:24:25,096 --> 00:24:26,546
And to give it context, we will

773
00:24:26,546 --> 00:24:28,656
show it alongside the median,

774
00:24:28,656 --> 00:24:29,996
max, and total values for the

775
00:24:29,996 --> 00:24:30,786
frame as well.

776
00:24:31,016 --> 00:24:34,546
Now, both the graph view and the

777
00:24:34,546 --> 00:24:35,856
detail views support the same

778
00:24:35,856 --> 00:24:38,136
full, rich filtering options

779
00:24:38,426 --> 00:24:40,036
that we support elsewhere in the

780
00:24:40,036 --> 00:24:42,226
frame debugger, so if you want

781
00:24:42,226 --> 00:24:44,086
to just view certain pixel stats

782
00:24:44,216 --> 00:24:45,426
and certain memory stats at the

783
00:24:45,426 --> 00:24:47,336
same time, you can put together

784
00:24:47,336 --> 00:24:48,776
the search term, and view

785
00:24:48,776 --> 00:24:49,876
everything you want alongside

786
00:24:49,876 --> 00:24:50,726
each other.

787
00:24:51,406 --> 00:24:54,696
But I'll highlight the GPU

788
00:24:54,696 --> 00:24:56,756
counter profiling is our advance

789
00:24:56,756 --> 00:24:58,026
to bottleneck analysis.

790
00:24:59,016 --> 00:25:00,516
With this, we take all the

791
00:24:59,016 --> 00:25:00,516
With this, we take all the

792
00:25:00,516 --> 00:25:01,896
counters that have been pulled

793
00:25:01,896 --> 00:25:03,706
for each draw call, or each

794
00:25:03,706 --> 00:25:05,536
encoder, and perform rich

795
00:25:05,536 --> 00:25:07,696
analysis on it, both on a cross

796
00:25:07,696 --> 00:25:10,446
platform basis, and on a per GPU

797
00:25:10,446 --> 00:25:12,716
specific basis to identify

798
00:25:12,716 --> 00:25:14,506
potential bottlenecks at each

799
00:25:14,506 --> 00:25:14,866
call.

800
00:25:16,446 --> 00:25:19,546
Alongside this, we will give you

801
00:25:19,546 --> 00:25:21,416
lots of data about, okay, what

802
00:25:21,416 --> 00:25:22,636
is going on here?

803
00:25:23,006 --> 00:25:24,306
What could cause it?

804
00:25:24,306 --> 00:25:26,266
And then intuitive workflow to

805
00:25:26,266 --> 00:25:28,716
navigate direct to the affected

806
00:25:28,716 --> 00:25:29,016
area.

807
00:25:30,346 --> 00:25:32,136
Now, both the, all the

808
00:25:32,136 --> 00:25:34,356
bottlenecks and all the counters

809
00:25:34,486 --> 00:25:36,606
will have rich detailed

810
00:25:36,866 --> 00:25:38,826
documentation within Xcode docs,

811
00:25:39,166 --> 00:25:40,716
explaining what each counter

812
00:25:40,716 --> 00:25:43,276
means in detail, why it might be

813
00:25:43,276 --> 00:25:44,636
particularly high or

814
00:25:44,636 --> 00:25:46,626
particularly low, and what you

815
00:25:46,626 --> 00:25:47,846
can do about it.

816
00:25:47,846 --> 00:25:49,306
To give a demo of this great new

817
00:25:49,516 --> 00:25:51,086
GPU Counter Profiling feature,

818
00:25:51,086 --> 00:25:52,556
I'd like to invite my colleague,

819
00:25:52,556 --> 00:25:54,476
Jose, back to the stage to give

820
00:25:54,476 --> 00:25:56,336
you a demo of it in action.

821
00:25:57,516 --> 00:25:59,676
[ Applause ]

822
00:26:00,176 --> 00:26:00,576
&gt;&gt; Thank you, Seth.

823
00:26:01,176 --> 00:26:02,116
And hello again everyone.

824
00:26:02,806 --> 00:26:06,066
This time, I will demonstrate

825
00:26:06,426 --> 00:26:10,266
GPU counters, a tool that will

826
00:26:10,266 --> 00:26:11,396
help you analyze your GPU

827
00:26:11,396 --> 00:26:11,996
performance.

828
00:26:13,036 --> 00:26:14,066
First, I'm going to replay the

829
00:26:14,066 --> 00:26:15,286
same demo that [inaudible] was

830
00:26:15,286 --> 00:26:17,496
on, but this time, we'll focus

831
00:26:17,496 --> 00:26:18,636
from a performance perspective.

832
00:26:19,766 --> 00:26:21,596
The first thing to note is, the

833
00:26:21,596 --> 00:26:23,656
new GPU gauge, just under the

834
00:26:23,656 --> 00:26:24,336
FPS gauge.

835
00:26:25,366 --> 00:26:26,356
By clicking on it, we'll

836
00:26:26,356 --> 00:26:28,796
navigate to our GP counter view.

837
00:26:29,436 --> 00:26:31,316
As you can see, there is a

838
00:26:31,316 --> 00:26:32,486
wealth of data here.

839
00:26:33,106 --> 00:26:34,306
Available for the first time.

840
00:26:34,476 --> 00:26:36,286
With this view, you can now

841
00:26:36,356 --> 00:26:38,216
deliver file any GPU performance

842
00:26:38,216 --> 00:26:39,316
issue that you have in any of

843
00:26:39,316 --> 00:26:40,296
your capture frames.

844
00:26:41,326 --> 00:26:42,796
So let me demonstrate how to

845
00:26:42,796 --> 00:26:43,776
find performance issues.

846
00:26:45,326 --> 00:26:46,696
First, let's focus on the graph

847
00:26:46,696 --> 00:26:47,016
view.

848
00:26:47,016 --> 00:26:47,083
'

849
00:26:50,206 --> 00:26:51,566
As you can see, there is a main

850
00:26:51,566 --> 00:26:53,076
spike in GPU time at the very

851
00:26:53,076 --> 00:26:54,016
beginning of a capture.

852
00:26:54,526 --> 00:26:56,356
The first thing you want to do

853
00:26:56,356 --> 00:26:58,746
is to zoom in to see a single

854
00:26:58,826 --> 00:26:59,876
recall, there are more

855
00:26:59,876 --> 00:27:00,436
offenders.

856
00:26:59,876 --> 00:27:00,436
offenders.

857
00:27:00,946 --> 00:27:01,926
In order to do that, I can

858
00:27:01,926 --> 00:27:04,596
simply pinch and zoom, just like

859
00:27:04,596 --> 00:27:04,846
that.

860
00:27:05,556 --> 00:27:07,216
Any default system behaviors

861
00:27:07,216 --> 00:27:08,356
will work just as you expect

862
00:27:08,356 --> 00:27:08,696
them to.

863
00:27:09,406 --> 00:27:11,546
Now I will see that there is a

864
00:27:11,546 --> 00:27:12,266
main spike.

865
00:27:12,456 --> 00:27:14,106
You can click on this draw call

866
00:27:14,106 --> 00:27:15,306
to highlight this impact across

867
00:27:15,436 --> 00:27:17,856
all the pipeline, and hovering

868
00:27:17,856 --> 00:27:19,856
over each row will give us

869
00:27:19,856 --> 00:27:21,396
detailed information on how

870
00:27:21,396 --> 00:27:23,016
relevant that stage is for this

871
00:27:23,016 --> 00:27:23,936
particular draw call.

872
00:27:24,856 --> 00:27:26,896
In this case, Vertex Omission,

873
00:27:27,026 --> 00:27:28,506
Vertex Shader, and Primitives

874
00:27:28,936 --> 00:27:30,546
did not seem to have relevant

875
00:27:30,676 --> 00:27:30,876
impact.

876
00:27:31,406 --> 00:27:33,096
On the contrary, Fragment Shader

877
00:27:33,716 --> 00:27:35,236
and Pixels [inaudible] seemed to

878
00:27:35,436 --> 00:27:36,316
be quite high.

879
00:27:37,106 --> 00:27:38,836
Let's focus on the Fragment

880
00:27:38,836 --> 00:27:39,436
Shader first.

881
00:27:40,396 --> 00:27:42,326
If we expand this group we now

882
00:27:42,326 --> 00:27:43,796
get access to a massive amount

883
00:27:43,796 --> 00:27:45,596
of counter data that gives us

884
00:27:45,656 --> 00:27:47,336
detailed information what is

885
00:27:47,336 --> 00:27:48,806
going on with the Shader stage.

886
00:27:49,636 --> 00:27:50,646
The last thing that this

887
00:27:50,646 --> 00:27:52,366
counted, we can quickly see that

888
00:27:52,616 --> 00:27:54,476
the stall time is unusually

889
00:27:54,476 --> 00:27:56,786
high, over 76%.

890
00:27:57,486 --> 00:27:58,936
This means that most of the time

891
00:27:58,936 --> 00:28:00,116
we are spending on the Fragment

892
00:27:58,936 --> 00:28:00,116
we are spending on the Fragment

893
00:28:00,116 --> 00:28:01,586
Shader is actually waiting for

894
00:28:01,586 --> 00:28:03,366
some memory or data to be

895
00:28:03,366 --> 00:28:03,816
available.

896
00:28:04,526 --> 00:28:06,776
This is caused because you are

897
00:28:06,776 --> 00:28:08,176
fetching from a buffer or from a

898
00:28:08,176 --> 00:28:10,596
texture, but texture captures

899
00:28:10,596 --> 00:28:11,806
should be here in this latency,

900
00:28:12,406 --> 00:28:14,556
so let's go down to our Texture

901
00:28:14,556 --> 00:28:16,736
Unit, to see what is the cache

902
00:28:16,736 --> 00:28:16,956
rate.

903
00:28:18,746 --> 00:28:20,526
And we can immediately see that

904
00:28:20,526 --> 00:28:22,256
the textures cache rate is also

905
00:28:22,256 --> 00:28:24,586
unusually high, almost at 60%.

906
00:28:25,326 --> 00:28:27,246
This means that more than half

907
00:28:27,246 --> 00:28:28,396
of the texture samples we are

908
00:28:28,396 --> 00:28:29,636
doing are coming from video

909
00:28:29,636 --> 00:28:30,766
memory and not from the texture

910
00:28:30,766 --> 00:28:31,236
caches.

911
00:28:31,966 --> 00:28:33,956
Now that we have a better

912
00:28:33,956 --> 00:28:34,946
understanding of the issue at

913
00:28:34,946 --> 00:28:36,966
hand, let's focus on the

914
00:28:36,966 --> 00:28:37,636
assistant editor.

915
00:28:38,196 --> 00:28:41,686
As you can see, the assistant

916
00:28:41,686 --> 00:28:43,406
editors offer the same graph

917
00:28:43,506 --> 00:28:45,006
inform-- counter information as

918
00:28:45,006 --> 00:28:46,156
the graph view was offering, but

919
00:28:46,356 --> 00:28:48,106
this time, displayed as a table

920
00:28:48,106 --> 00:28:48,516
view.

921
00:28:48,806 --> 00:28:51,376
But more important, look at the

922
00:28:51,376 --> 00:28:51,826
top.

923
00:28:51,826 --> 00:28:53,286
This is our bottleneck access

924
00:28:53,286 --> 00:28:53,566
tool.

925
00:28:53,566 --> 00:28:56,406
It will point out two relevant

926
00:28:56,406 --> 00:28:58,106
issues that we consider when we

927
00:28:58,106 --> 00:29:00,276
analyze all the counters within

928
00:28:58,106 --> 00:29:00,276
analyze all the counters within

929
00:29:00,276 --> 00:29:01,736
the selected draw call, and

930
00:29:01,736 --> 00:29:03,076
point out any relevant issues

931
00:29:03,076 --> 00:29:04,976
that we cconsider important for

932
00:29:04,976 --> 00:29:05,926
you to pay attention to.

933
00:29:06,266 --> 00:29:07,356
In this case, highlighting the

934
00:29:07,356 --> 00:29:09,446
same as we just found manually

935
00:29:09,446 --> 00:29:12,776
by checking the graph, that the

936
00:29:12,776 --> 00:29:15,646
texture cache miss rate is high.

937
00:29:15,876 --> 00:29:17,686
When expanded, it also offers

938
00:29:17,686 --> 00:29:18,586
recommendations on what to

939
00:29:18,586 --> 00:29:18,866
check.

940
00:29:19,636 --> 00:29:21,436
In this case, check if sampled

941
00:29:21,436 --> 00:29:23,446
textures have [inaudible], and a

942
00:29:23,486 --> 00:29:25,406
quick navigational name to

943
00:29:25,436 --> 00:29:26,786
relevant views for this issue.

944
00:29:28,066 --> 00:29:29,656
For example, boundary sources,

945
00:29:30,006 --> 00:29:31,266
where we can immediately see

946
00:29:31,266 --> 00:29:32,886
what's the issue at hand, we're

947
00:29:32,886 --> 00:29:35,866
fetching a 4K by 4K RGBA32

948
00:29:35,926 --> 00:29:37,126
Floating Point Texture with

949
00:29:37,126 --> 00:29:38,576
[inaudible] in both our vertex

950
00:29:39,226 --> 00:29:40,126
and our Fragment Shader.

951
00:29:40,476 --> 00:29:43,336
This is a 256-megabyte texture

952
00:29:43,336 --> 00:29:44,866
that is fetched all over the

953
00:29:44,866 --> 00:29:45,296
pipeline.

954
00:29:45,846 --> 00:29:47,816
No wonder we are trashing our

955
00:29:48,496 --> 00:29:48,786
cache.

956
00:29:48,826 --> 00:29:50,156
Just think for a moment what we

957
00:29:50,156 --> 00:29:50,826
just did.

958
00:29:51,426 --> 00:29:52,486
This was an incredibly detailed

959
00:29:52,486 --> 00:29:54,656
view of how GPU internals work.

960
00:29:55,616 --> 00:29:56,926
You finally have the data to

961
00:29:56,926 --> 00:29:58,216
prove what [inaudible] telling

962
00:29:58,216 --> 00:29:59,746
you, that fetching from the

963
00:29:59,746 --> 00:30:01,226
textures is expensive, but now

964
00:29:59,746 --> 00:30:01,226
textures is expensive, but now

965
00:30:01,226 --> 00:30:02,176
you know exactly why.

966
00:30:03,296 --> 00:30:05,076
Accessing this texture was a

967
00:30:05,076 --> 00:30:06,216
star on the Fragment Shader,

968
00:30:06,216 --> 00:30:08,136
because it had to fetch some

969
00:30:08,136 --> 00:30:09,196
data from [inaudible] memory

970
00:30:09,196 --> 00:30:11,426
that was not available in the

971
00:30:12,376 --> 00:30:12,576
caches.

972
00:30:12,706 --> 00:30:13,656
This level of detail is

973
00:30:13,656 --> 00:30:14,716
typically not seen outside

974
00:30:14,716 --> 00:30:15,606
consult tools.

975
00:30:16,706 --> 00:30:17,896
Solving this issue now is a

976
00:30:17,896 --> 00:30:20,566
matter of balancing performance,

977
00:30:21,006 --> 00:30:22,736
quality, and correctness, but

978
00:30:22,736 --> 00:30:23,926
you have demonstrated how you

979
00:30:23,926 --> 00:30:25,036
can use GPU counters [inaudible]

980
00:30:25,036 --> 00:30:27,376
the GPU Frame Debugger, to help

981
00:30:27,376 --> 00:30:30,196
you investigate, analyze, and

982
00:30:30,196 --> 00:30:32,016
verify any capture information

983
00:30:32,016 --> 00:30:34,246
-- any performance information

984
00:30:34,246 --> 00:30:35,256
that you have in your captures.

985
00:30:35,676 --> 00:30:37,056
And now, I hand it back to my

986
00:30:37,056 --> 00:30:37,586
colleague, Seth.

987
00:30:38,516 --> 00:30:43,500
[ Applause ]

988
00:30:48,386 --> 00:30:48,976
&gt;&gt; Thank you, Jose.

989
00:30:50,696 --> 00:30:52,756
So that is GPU Counter

990
00:30:52,756 --> 00:30:53,346
Profiling.

991
00:30:53,966 --> 00:30:54,926
Like all the new features we

992
00:30:54,926 --> 00:30:56,456
talked about today, it's the

993
00:30:56,456 --> 00:30:58,676
ultimate joy in Xcode Beta 9,

994
00:30:59,166 --> 00:31:00,716
and it's available for all Metal

995
00:30:59,166 --> 00:31:00,716
and it's available for all Metal

996
00:31:00,716 --> 00:31:01,906
capable GPUs.

997
00:31:02,656 --> 00:31:04,356
You will find that more recent

998
00:31:04,356 --> 00:31:05,586
GPUs have more counters

999
00:31:05,586 --> 00:31:07,676
available due to the more modern

1000
00:31:07,986 --> 00:31:10,086
nature of the GPU, but there's

1001
00:31:10,086 --> 00:31:11,976
still a rich and very usable set

1002
00:31:11,976 --> 00:31:13,616
available for all GPUs.

1003
00:31:14,026 --> 00:31:16,616
However, we would love to hear

1004
00:31:16,616 --> 00:31:17,936
feedback from you if you feel

1005
00:31:17,936 --> 00:31:18,946
there's particular counters that

1006
00:31:18,946 --> 00:31:19,696
were unexposed that would be

1007
00:31:19,696 --> 00:31:22,156
particularly valuable, you know,

1008
00:31:22,426 --> 00:31:24,606
please drop by the lab, or

1009
00:31:24,606 --> 00:31:26,046
[inaudible] and we'll be happy

1010
00:31:26,046 --> 00:31:26,956
to investigate.

1011
00:31:27,386 --> 00:31:28,986
So what have we talked about

1012
00:31:28,986 --> 00:31:29,226
today?

1013
00:31:29,486 --> 00:31:30,586
We've talked about some great

1014
00:31:30,586 --> 00:31:31,906
enhancements to the Metal Frame

1015
00:31:31,906 --> 00:31:33,676
Debugger, with support for pixel

1016
00:31:33,676 --> 00:31:35,846
inspection, inspecting Vertex

1017
00:31:36,246 --> 00:31:39,256
Shader outputs, rich filtering,

1018
00:31:39,776 --> 00:31:42,186
better capture support, better

1019
00:31:42,186 --> 00:31:44,196
capture performance, and Xcode

1020
00:31:44,196 --> 00:31:45,696
Metal Quick Looks.

1021
00:31:46,216 --> 00:31:49,206
We've talked about support for

1022
00:31:49,206 --> 00:31:50,586
debugging and profiling VR

1023
00:31:50,586 --> 00:31:53,506
applications in Metal Tray

1024
00:31:53,506 --> 00:31:54,876
Debugger, and Metal System

1025
00:31:54,876 --> 00:31:55,186
Trays.

1026
00:31:57,356 --> 00:31:59,986
We've talked about Metal

1027
00:32:00,056 --> 00:32:01,726
Pipeline Statistics, giving you

1028
00:32:01,726 --> 00:32:03,236
a direct line to the GPU

1029
00:32:03,236 --> 00:32:04,316
compiler for performance

1030
00:32:04,316 --> 00:32:04,916
information.

1031
00:32:06,696 --> 00:32:08,516
And we've introduced GPU Counter

1032
00:32:08,516 --> 00:32:11,586
Profiling, giving you unheralded

1033
00:32:11,586 --> 00:32:13,626
access to GPU Performance

1034
00:32:13,626 --> 00:32:17,346
Counter Data in Metal.

1035
00:32:17,626 --> 00:32:19,866
For more information, check out

1036
00:32:19,866 --> 00:32:20,486
the website.

1037
00:32:22,166 --> 00:32:23,846
Code is 607.

1038
00:32:23,846 --> 00:32:28,276
I did want to call out a couple

1039
00:32:28,276 --> 00:32:29,956
of other sessions.

1040
00:32:30,316 --> 00:32:31,756
If you didn't catch either the

1041
00:32:31,756 --> 00:32:33,946
Introducing Metal 2, or VR With

1042
00:32:33,946 --> 00:32:35,716
Metal 2 sessions earlier on this

1043
00:32:35,716 --> 00:32:38,186
week, it's highly worth going

1044
00:32:38,186 --> 00:32:39,896
and checking out the video, even

1045
00:32:39,896 --> 00:32:41,606
if you did see them, it's still

1046
00:32:41,606 --> 00:32:42,736
worth checking out the videos.

1047
00:32:43,066 --> 00:32:45,246
And coming up later this

1048
00:32:45,246 --> 00:32:46,446
afternoon, there is a great

1049
00:32:46,446 --> 00:32:47,706
session on using Metal 2 for

1050
00:32:47,706 --> 00:32:49,856
Compute, in Grand Ballroom A, at

1051
00:32:49,926 --> 00:32:50,866
10 past 4.

1052
00:32:51,386 --> 00:32:52,996
And that's it.

1053
00:32:52,996 --> 00:32:54,216
Thanks for coming.

1054
00:32:54,556 --> 00:32:56,086
Have a great remainder of your

1055
00:32:56,146 --> 00:32:58,436
WWDC 17 and enjoy the bash.

1056
00:32:58,436 --> 00:32:58,776
Thank you.

1057
00:32:59,016 --> 00:33:00,000
[ Applause ]
