1
00:00:18,046 --> 00:00:18,756
&gt;&gt;  大家下午好

2
00:00:19,516 --> 00:00:23,796
[掌声]

3
00:00:24,296 --> 00:00:24,606
谢谢大家

4
00:00:25,186 --> 00:00:26,516
欢迎来到 Swift 新品发布会

5
00:00:27,256 --> 00:00:28,206
我是 Doug Gregor

6
00:00:28,436 --> 00:00:29,296
在这里 我和 Swift 团队的

7
00:00:29,296 --> 00:00:30,446
同事将一起来聊聊

8
00:00:30,696 --> 00:00:32,286
我们在 Swift 4

9
00:00:32,286 --> 00:00:33,866
里带来的一些

10
00:00:33,866 --> 00:00:34,246
新改变

11
00:00:35,276 --> 00:00:38,866
现在 如果你关注了

12
00:00:38,866 --> 00:00:40,576
iOS Developer 或是

13
00:00:40,576 --> 00:00:41,486
Ole Begemann 其实你早就知道

14
00:00:41,486 --> 00:00:42,356
Swift 4 有什么新功能了

15
00:00:43,606 --> 00:00:45,046
这便是我如此热爱

16
00:00:45,046 --> 00:00:46,896
Swift 社区的理由

17
00:00:47,296 --> 00:00:49,726
Ole 把所有关于

18
00:00:49,726 --> 00:00:50,886
Swift 4 里应该有什么

19
00:00:50,886 --> 00:00:53,036
的提议都看了一遍

20
00:00:53,036 --> 00:00:53,366
接下来他做了什么

21
00:00:53,366 --> 00:00:54,996
他建了一个平台来演示

22
00:00:54,996 --> 00:00:56,346
这些功能是如何实现的

23
00:00:56,346 --> 00:00:57,926
并与世界分享

24
00:00:57,926 --> 00:00:58,996
这样我们就能从中

25
00:00:58,996 --> 00:00:59,386
得知都发生了什么

26
00:01:00,136 --> 00:01:00,996
这简直太棒了

27
00:01:01,896 --> 00:01:03,986
并且这是可行的

28
00:01:03,986 --> 00:01:05,426
因为在任何时间你都可以

29
00:01:05,426 --> 00:01:07,086
来到 Swift.org 我们的开源社区

30
00:01:07,086 --> 00:01:09,276
下载最新最强大的

31
00:01:09,276 --> 00:01:10,766
Swift 编译器

32
00:01:10,766 --> 00:01:11,336
的快照

33
00:01:12,046 --> 00:01:13,626
这个快照是一种工具链

34
00:01:13,626 --> 00:01:16,016
你可以把它安装到 Xcode 里

35
00:01:16,926 --> 00:01:18,576
它提供了新的编译器 调试器

36
00:01:18,576 --> 00:01:19,646
源码包等等

37
00:01:19,646 --> 00:01:20,696
所以你可以依靠最新的工具

38
00:01:20,696 --> 00:01:21,906
来编写你的 App

39
00:01:22,126 --> 00:01:23,026
试试一些新功能吧

40
00:01:23,026 --> 00:01:24,466
看看我们是否修复了

41
00:01:24,466 --> 00:01:25,226
你最喜欢的 Bug

42
00:01:25,336 --> 00:01:27,766
当然 这全都建立在

43
00:01:27,766 --> 00:01:29,286
Swift 开源的基础上

44
00:01:29,286 --> 00:01:30,426
我们在 GitHub 上

45
00:01:30,426 --> 00:01:32,406
公开了源码 

46
00:01:32,406 --> 00:01:33,116
以便你可以持续跟进

47
00:01:33,526 --> 00:01:34,746
如果你感兴趣

48
00:01:34,746 --> 00:01:35,346
当然可以加入我们

49
00:01:36,266 --> 00:01:38,706
另外 Swift 的发展

50
00:01:38,706 --> 00:01:40,226
比如标准函数库 编程语言

51
00:01:40,226 --> 00:01:42,206
都是通过这个开放的

52
00:01:42,206 --> 00:01:43,926
发展过程得来的 即通过

53
00:01:44,076 --> 00:01:46,036
评估个人提议来完善 Swift

54
00:01:46,396 --> 00:01:48,116
提高他们以改进 Swift

55
00:01:48,116 --> 00:01:49,846
让 Swift 对每个开发者

56
00:01:49,846 --> 00:01:51,156
都更加友好

57
00:01:52,346 --> 00:01:54,036
你没听错 接下来是

58
00:01:54,036 --> 00:01:56,256
Xcode 9 对 Swift

59
00:01:56,256 --> 00:01:57,846
重构支持的介绍

60
00:01:58,516 --> 00:02:01,736
[掌声]

61
00:01:58,516 --> 00:02:01,736
[掌声]

62
00:02:02,236 --> 00:02:05,256
好的 所有的为重构 Swift 工作的

63
00:02:05,256 --> 00:02:07,176
语言级位都是

64
00:02:07,176 --> 00:02:08,846
以 Swift 项目

65
00:02:08,846 --> 00:02:09,576
为基础的

66
00:02:09,576 --> 00:02:10,716
届时我们将

67
00:02:10,716 --> 00:02:11,226
完全开源

68
00:02:11,546 --> 00:02:12,746
最激动人心的事情是

69
00:02:12,746 --> 00:02:14,516
那时你可以查阅并编写

70
00:02:14,516 --> 00:02:16,286
Swift 源码

71
00:02:16,286 --> 00:02:17,826
通过我刚刚介绍的工具链

72
00:02:17,826 --> 00:02:19,226
进行你自己的重构

73
00:02:19,226 --> 00:02:20,626
试着在 Xcode 里

74
00:02:20,626 --> 00:02:21,626
编译他们

75
00:02:22,026 --> 00:02:22,866
总之 这是一种能让你真正的

76
00:02:22,866 --> 00:02:23,896
与开发工具

77
00:02:23,896 --> 00:02:24,356
融为一体的方法

78
00:02:26,186 --> 00:02:27,786
如今 作为开源生态系统

79
00:02:27,786 --> 00:02:29,266
一部分的还有

80
00:02:29,306 --> 00:02:30,126
Swift Package Manager

81
00:02:30,456 --> 00:02:31,626
在 GitHub 上 它为超过

82
00:02:31,626 --> 00:02:33,726
7000 个包提供支持

83
00:02:33,726 --> 00:02:34,866
并不断完善着生态系统

84
00:02:35,376 --> 00:02:36,996
这对于进程端的 Swift 而言

85
00:02:36,996 --> 00:02:38,936
十分受欢迎

86
00:02:38,936 --> 00:02:41,666
Swift PM 可以 在 Linux 上

87
00:02:41,666 --> 00:02:42,706
轻易地获取需要构建

88
00:02:42,706 --> 00:02:44,526
服务器端 Swift 应用程序

89
00:02:44,526 --> 00:02:45,536
所需的服务器组件

90
00:02:46,056 --> 00:02:47,416
今年 Swift Package Manager

91
00:02:47,416 --> 00:02:49,126
相较以往

92
00:02:49,156 --> 00:02:49,756
有了很大的提升

93
00:02:49,936 --> 00:02:51,366
为了更好的体现 API 的用途

94
00:02:51,786 --> 00:02:53,586
更好的用于开发 workflow 等等

95
00:02:53,586 --> 00:02:55,796
并且为了实现最终的目标

96
00:02:55,796 --> 00:02:57,586
我们已经取得了长足的进步

97
00:02:57,586 --> 00:02:59,316
这包括在 Xcode IDE 中

98
00:02:59,316 --> 00:03:01,446
为 Swift Package 提供了

99
00:02:59,316 --> 00:03:01,446
为 Swift Package 提供了

100
00:03:01,446 --> 00:03:01,516
一流的支持

101
00:03:01,516 --> 00:03:03,896
随着 Swift PM 作为

102
00:03:03,896 --> 00:03:05,396
函数库的使用

103
00:03:05,396 --> 00:03:07,256
我们也越来越接近这个目标

104
00:03:07,256 --> 00:03:08,926
当然 新的 Xcode 构建系统

105
00:03:08,926 --> 00:03:11,126
完全建立在 Swift 的基础上

106
00:03:12,276 --> 00:03:13,516
因此 我们今天要

107
00:03:13,516 --> 00:03:13,836
涉及到许多方面的内容

108
00:03:14,616 --> 00:03:16,306
在我们深入探讨

109
00:03:16,306 --> 00:03:17,916
源兼容性之前

110
00:03:17,916 --> 00:03:19,616
我将讨论一些

111
00:03:20,126 --> 00:03:21,376
对语言本身的小改进和补充

112
00:03:21,376 --> 00:03:22,736
我们将探讨

113
00:03:23,016 --> 00:03:23,866
如何在 Swift 4 和 Xcode 9 

114
00:03:23,866 --> 00:03:25,256
环境下充分利用你在

115
00:03:25,256 --> 00:03:27,266
Swift 中构建的

116
00:03:27,266 --> 00:03:28,736
所有代码

117
00:03:29,646 --> 00:03:31,056
在 Ben 深入到字符串 集合

118
00:03:31,056 --> 00:03:32,466
以及 Swift 的

119
00:03:32,466 --> 00:03:34,366
一些通用特性之前

120
00:03:34,366 --> 00:03:36,526
我的同事 Bob

121
00:03:36,526 --> 00:03:37,686
将讨论 Swift 工具

122
00:03:37,686 --> 00:03:38,046
和性能的提升

123
00:03:38,676 --> 00:03:40,316
最后 John 将谈到

124
00:03:40,316 --> 00:03:41,586
独占访问内存的问题

125
00:03:41,906 --> 00:03:43,306
这是一种语义限制

126
00:03:43,306 --> 00:03:44,576
我们将把它引入到

127
00:03:44,576 --> 00:03:46,316
未来 Swift 语言的

128
00:03:46,316 --> 00:03:46,716
构建之中

129
00:03:47,606 --> 00:03:50,356
那我们就从

130
00:03:50,356 --> 00:03:52,016
触手可及的未来开始吧

131
00:03:53,366 --> 00:03:54,646
访问控制

132
00:03:54,746 --> 00:03:56,206
这里我定义了一些

133
00:03:56,206 --> 00:03:57,216
简单的数据结构

134
00:03:57,906 --> 00:03:59,206
这与 Fundation

135
00:03:59,206 --> 00:03:59,876
中的十分类似

136
00:03:59,906 --> 00:04:00,666
它把 secondsSinceReferenceDate

137
00:03:59,906 --> 00:04:00,666
它把 secondsSinceReferenceDate

138
00:04:00,666 --> 00:04:02,436
作为一个内部引用

139
00:04:02,436 --> 00:04:03,896
但我把它私有化了

140
00:04:03,896 --> 00:04:05,146
因为我认为它

141
00:04:05,146 --> 00:04:07,276
并不是一个可以向

142
00:04:07,276 --> 00:04:07,996
我的用户们公开的 API

143
00:04:08,516 --> 00:04:09,656
我希望他成为一种

144
00:04:09,656 --> 00:04:11,706
优秀的值类型

145
00:04:11,706 --> 00:04:13,066
兼具公平性与可比性

146
00:04:13,506 --> 00:04:14,776
但是这段代码

147
00:04:14,776 --> 00:04:15,706
已经有一丝的

148
00:04:15,706 --> 00:04:16,125
混乱了

149
00:04:16,125 --> 00:04:17,776
我真的应该把它分解成

150
00:04:18,216 --> 00:04:20,086
单独的扩展

151
00:04:20,086 --> 00:04:21,305
每个任务对应一个 对吧

152
00:04:21,305 --> 00:04:23,316
这是 Swift 的一个很好的编码风格

153
00:04:23,716 --> 00:04:25,226
但是 Swift 3 并没有做到

154
00:04:25,226 --> 00:04:26,456
很好地支持它

155
00:04:26,456 --> 00:04:28,376
因为你会得到这样一个错误

156
00:04:28,376 --> 00:04:30,256
那就是无法跨越另一个词法范围

157
00:04:30,256 --> 00:04:31,296
来做出私有声明

158
00:04:32,206 --> 00:04:33,196
如今我们可以使用

159
00:04:33,196 --> 00:04:34,036
Fileprivate 来解决这个问题

160
00:04:34,446 --> 00:04:35,706
但这意味着此定义

161
00:04:35,706 --> 00:04:38,546
在整个文件中都可以

162
00:04:38,546 --> 00:04:39,356
被检索到 这并不好

163
00:04:39,356 --> 00:04:40,326
范围太广了

164
00:04:40,786 --> 00:04:43,416
因此 我们对 Swift 4

165
00:04:43,416 --> 00:04:45,706
进行了改进

166
00:04:45,706 --> 00:04:48,736
扩展了私有定义的范围

167
00:04:48,886 --> 00:04:51,246
覆盖同一源文件中

168
00:04:51,246 --> 00:04:52,706
特定类型的

169
00:04:52,706 --> 00:04:53,566
所有扩展的声明

170
00:04:53,936 --> 00:04:55,316
这与使用拓展

171
00:04:55,316 --> 00:04:57,316
来组建代码的概念

172
00:04:57,316 --> 00:04:57,976
更加吻合

173
00:04:58,516 --> 00:05:01,546
[掌声]

174
00:04:58,516 --> 00:05:01,546
[掌声]

175
00:05:02,046 --> 00:05:03,336
有了这种变化

176
00:05:03,336 --> 00:05:05,176
就让我们忘掉

177
00:05:05,176 --> 00:05:05,626
访问控制这种说法吧

178
00:05:06,516 --> 00:05:09,546
笑声

179
00:05:10,046 --> 00:05:11,016
其次 我想谈谈

180
00:05:11,016 --> 00:05:12,536
组合类和协议

181
00:05:13,006 --> 00:05:14,676
针对 UI 的部分

182
00:05:14,786 --> 00:05:16,186
这里我引入了一个

183
00:05:16,186 --> 00:05:17,656
可以调整的协议

184
00:05:17,656 --> 00:05:18,866
这足以带给我们惊喜

185
00:05:18,866 --> 00:05:19,486
并吸引我们的目光

186
00:05:20,106 --> 00:05:21,826
我已经扩展了来

187
00:05:21,826 --> 00:05:23,846
一些 UIKit 类

188
00:05:24,296 --> 00:05:25,526
从而提供这个

189
00:05:25,526 --> 00:05:26,306
调整功能

190
00:05:26,306 --> 00:05:27,466
现在我想写一些

191
00:05:27,466 --> 00:05:28,756
看起来很简单的东西

192
00:05:28,796 --> 00:05:30,336
我只是想写一个函数

193
00:05:30,506 --> 00:05:32,046
它需要一系列的控件

194
00:05:32,046 --> 00:05:33,556
这些控件是可调用的

195
00:05:33,556 --> 00:05:34,926
并且可以调用那些

196
00:05:34,926 --> 00:05:36,186
吸引他们注意力的控件

197
00:05:36,996 --> 00:05:38,486
在这个数组中

198
00:05:38,876 --> 00:05:39,546
我该如何定义类型

199
00:05:40,696 --> 00:05:41,866
这很不讨人喜欢

200
00:05:41,866 --> 00:05:42,196
非常棘手

201
00:05:42,616 --> 00:05:44,206
所以我试着用用

202
00:05:44,206 --> 00:05:44,746
UI 控件

203
00:05:44,746 --> 00:05:46,146
但并不是所有的

204
00:05:46,146 --> 00:05:47,156
UI 控件都是可调整的

205
00:05:48,006 --> 00:05:49,846
我可以试着调整 但不是所有

206
00:05:49,846 --> 00:05:51,536
可调整的部分都是 UI 控件

207
00:05:51,536 --> 00:05:52,496
在 Swift 3 中 我没有办法

208
00:05:52,496 --> 00:05:54,506
去很好的展示这些东西

209
00:05:54,916 --> 00:05:56,986
Swift 4 里引入了

210
00:05:57,386 --> 00:06:00,266
使用任意数量的协议

211
00:05:57,386 --> 00:06:00,266
使用任意数量的协议

212
00:06:00,266 --> 00:06:01,326
来编写类的概念

213
00:06:02,516 --> 00:06:07,696
[掌声]

214
00:06:08,196 --> 00:06:09,716
这是一个小功能

215
00:06:09,716 --> 00:06:11,046
但它与 Swift 的

216
00:06:11,046 --> 00:06:12,476
整体设置非常吻合

217
00:06:12,526 --> 00:06:13,826
如果你之前使用

218
00:06:13,826 --> 00:06:15,376
Objective-C 进行编程

219
00:06:15,376 --> 00:06:16,196
那么您应该对这些功能

220
00:06:16,196 --> 00:06:17,246
了如指掌

221
00:06:17,246 --> 00:06:18,456
因为很早之前

222
00:06:18,456 --> 00:06:19,746
Objective-C 就已经有了

223
00:06:19,746 --> 00:06:20,156
这项功能

224
00:06:20,616 --> 00:06:22,446
这里是一个 Touch Bar API

225
00:06:22,446 --> 00:06:24,836
客户端在 NSView 中

226
00:06:24,876 --> 00:06:26,906
它也符合 NSTextInputClient

227
00:06:27,426 --> 00:06:29,386
在 Swift 3 中 我们实际上不

228
00:06:29,386 --> 00:06:30,586
能表示那种类型 所以我们将它

229
00:06:30,586 --> 00:06:31,996
作为 NSView 来引入

230
00:06:32,166 --> 00:06:33,386
这真的不是个明智的做法

231
00:06:34,326 --> 00:06:36,716
因此 Swift 4 改进了这一点

232
00:06:36,716 --> 00:06:38,186
现在我们可以使用

233
00:06:38,186 --> 00:06:41,016
NSTextInputClient 的 NSView

234
00:06:41,046 --> 00:06:43,346
来导入类型 这可以完美匹配

235
00:06:43,346 --> 00:06:44,526
所有的 API

236
00:06:46,516 --> 00:06:49,546
[掌声]

237
00:06:50,046 --> 00:06:51,366
接下来我们还要

238
00:06:51,366 --> 00:06:52,216
谈到它很多

239
00:06:52,216 --> 00:06:53,046
过人之处

240
00:06:53,316 --> 00:06:54,366
我想让大家看看我们

241
00:06:54,366 --> 00:06:55,566
在改进 Cocoa idioms

242
00:06:55,566 --> 00:06:57,106
KeyPaths，Key-Value Coding

243
00:06:57,106 --> 00:06:58,156
Archival & Serialization 领域中

244
00:06:58,196 --> 00:07:00,096
引出的一些新特性

245
00:06:58,196 --> 00:07:00,096
引出的一些新特性

246
00:07:00,476 --> 00:07:02,736
这些都是 Swift 的重大新特性

247
00:07:02,736 --> 00:07:04,136
我们将在周三的

248
00:07:04,216 --> 00:07:05,916
《基础新特性》的讲座上

249
00:07:05,916 --> 00:07:06,896
对它进行

250
00:07:06,896 --> 00:07:08,576
详细的讨论

251
00:07:09,856 --> 00:07:12,656
这些新特性

252
00:07:12,756 --> 00:07:14,586
可以很好的与

253
00:07:14,586 --> 00:07:14,936
Swift 值类型兼容

254
00:07:14,936 --> 00:07:16,596
所以你可以在

255
00:07:16,596 --> 00:07:17,666
所有的 Swift 代码中

256
00:07:19,056 --> 00:07:20,136
使用他们 在这个部分

257
00:07:20,136 --> 00:07:21,706
他们还将回答一个古老的问题

258
00:07:22,096 --> 00:07:24,496
如何在 Swift 中解析 JSON

259
00:07:26,806 --> 00:07:28,346
好的 那我们就来谈谈

260
00:07:28,346 --> 00:07:29,176
源码兼容性

261
00:07:30,036 --> 00:07:32,916
从本质上来说

262
00:07:32,916 --> 00:07:34,306
Swift 4 在很大程度上

263
00:07:34,306 --> 00:07:35,126
与 Swift 3 兼容

264
00:07:35,676 --> 00:07:37,416
原因是语言本身没有

265
00:07:37,566 --> 00:07:39,806
太大的改变 我们只是

266
00:07:39,996 --> 00:07:41,426
做出了一些改进

267
00:07:41,426 --> 00:07:42,986
这就像对轴孔的改变一样（细微）

268
00:07:43,396 --> 00:07:44,626
我们做了一些补充

269
00:07:44,896 --> 00:07:46,486
就像对类和协议

270
00:07:46,486 --> 00:07:47,506
组合的更改一样

271
00:07:48,156 --> 00:07:49,436
此外 SDK 图中

272
00:07:49,436 --> 00:07:51,906
现有的 API 接入 Swift 的

273
00:07:51,936 --> 00:07:53,806
方式也有了一些改进

274
00:07:53,806 --> 00:07:55,566
现今我们提供了比以往更好的

275
00:07:55,566 --> 00:07:57,086
Swift API

276
00:07:57,426 --> 00:07:59,566
但这种改变的规模

277
00:07:59,566 --> 00:08:01,276
远小于从 Swift 2 到 3

278
00:07:59,566 --> 00:08:01,276
远小于从 Swift 2 到 3

279
00:08:01,276 --> 00:08:03,126
甚至是

280
00:08:03,126 --> 00:08:03,556
Swift 1 到 2

281
00:08:04,136 --> 00:08:06,956
因此 从 Swift 3 到 4

282
00:08:06,956 --> 00:08:08,626
并没有像之前那样

283
00:08:08,706 --> 00:08:10,026
对代码的基础有很大的影响

284
00:08:10,436 --> 00:08:11,316
我们谈到的很多特性

285
00:08:11,316 --> 00:08:12,386
都只是纯粹的

286
00:08:12,386 --> 00:08:12,866
补充条款

287
00:08:13,116 --> 00:08:14,536
所以他们在一些

288
00:08:14,536 --> 00:08:15,476
新的句法空间里

289
00:08:15,476 --> 00:08:17,166
我们不会以牺牲源码

290
00:08:17,166 --> 00:08:18,566
为代价来引入这些新特性

291
00:08:19,586 --> 00:08:21,426
这就是说

292
00:08:21,426 --> 00:08:22,176
我们要平稳的迁移

293
00:08:22,626 --> 00:08:24,166
所以我们还要引入

294
00:08:24,366 --> 00:08:25,106
Swift 3.2

295
00:08:26,146 --> 00:08:27,456
关于 Swift 3.2

296
00:08:27,456 --> 00:08:29,496
最重要的一点是它不是

297
00:08:29,496 --> 00:08:30,836
一个独立的编译器或是

298
00:08:30,836 --> 00:08:31,486
一个不同的工具链

299
00:08:32,246 --> 00:08:34,066
这是 Swift 4 编译器的

300
00:08:34,066 --> 00:08:36,166
编译模式

301
00:08:36,216 --> 00:08:37,316
它可以模拟 Swift 3 的做法

302
00:08:37,926 --> 00:08:39,285
因此 如果从

303
00:08:39,285 --> 00:08:41,256
Swift 3 到 4 的

304
00:08:41,256 --> 00:08:43,756
语法语义发生了变化

305
00:08:43,756 --> 00:08:44,275
它将提供 Swift 3 的做法

306
00:08:45,226 --> 00:08:47,016
此外 它还可以解释

307
00:08:47,016 --> 00:08:48,736
新 SDK 中

308
00:08:48,846 --> 00:08:50,006
所做的更改

309
00:08:50,006 --> 00:08:51,236
因此 如果一个 API 项目

310
00:08:51,236 --> 00:08:53,156
在 Swift 4 中和 Swift 3中

311
00:08:53,156 --> 00:08:55,406
不一样

312
00:08:55,556 --> 00:08:57,176
则它会将这些不同

313
00:08:57,176 --> 00:08:58,156
退回到 Swift 3 视图中呈现

314
00:08:59,446 --> 00:09:01,726
这最终的结果结果就是

315
00:08:59,446 --> 00:09:01,726
这最终的结果结果就是

316
00:09:01,726 --> 00:09:03,196
当你在 Xcode 9 中打开

317
00:09:03,606 --> 00:09:05,096
Swift 3 项目并使用

318
00:09:05,096 --> 00:09:07,406
Swift 3.2 构建它时

319
00:09:07,436 --> 00:09:09,176
几乎所有的东西

320
00:09:09,176 --> 00:09:10,586
都像以前那样构建和工作

321
00:09:11,306 --> 00:09:14,026
这为采用 Swift 4 的新特性

322
00:09:14,026 --> 00:09:15,906
提供了绝佳的途径

323
00:09:15,906 --> 00:09:17,886
因为它们中的大多数

324
00:09:17,886 --> 00:09:20,176
都可以在 Swift 3.2 中使用

325
00:09:20,596 --> 00:09:22,506
也可以在今年的

326
00:09:22,506 --> 00:09:25,696
SDK 中使用所有

327
00:09:25,736 --> 00:09:28,036
新的 API 和框架

328
00:09:28,266 --> 00:09:29,866
现在 你可以随时迁移到 Swift 4 平台

329
00:09:29,866 --> 00:09:31,826
在之前的几年里

330
00:09:31,826 --> 00:09:33,376
我们提供一个 migrator

331
00:09:33,376 --> 00:09:35,676
来把 Swift 3 中的代码

332
00:09:35,676 --> 00:09:39,186
迁移到

333
00:09:39,186 --> 00:09:39,766
Swift 4 里

334
00:09:40,526 --> 00:09:42,336
现在 与前些年不同的是

335
00:09:42,596 --> 00:09:45,226
这种迁移不会阻碍世界发展的脚步

336
00:09:45,226 --> 00:09:46,836
这项工作直至

337
00:09:46,836 --> 00:09:48,656
所有的一切都被迁移过去

338
00:09:48,656 --> 00:09:49,546
才算结束

339
00:09:50,656 --> 00:09:52,636
原因是 Swift3.2 和 Swift 4

340
00:09:52,636 --> 00:09:55,466
可以在同一个

341
00:09:55,466 --> 00:09:56,246
应用里共存

342
00:09:57,606 --> 00:09:58,726
因此你可以设置

343
00:09:58,726 --> 00:09:59,216
你需要的版本

344
00:10:00,516 --> 00:10:04,226
[掌声]

345
00:10:04,726 --> 00:10:06,506
你可以在每个目标的

346
00:10:06,506 --> 00:10:08,006
基础上设置要使用的

347
00:10:08,006 --> 00:10:09,426
语言版本

348
00:10:10,046 --> 00:10:10,846
因此 如果你想要迁移到

349
00:10:10,846 --> 00:10:12,096
Swift 4 你可以先迁移目标 App 

350
00:10:12,096 --> 00:10:13,866
但是框架和所有其他

351
00:10:13,866 --> 00:10:14,686
附属项依然保留

352
00:10:14,686 --> 00:10:16,226
Swift 3.2 的版本

353
00:10:16,466 --> 00:10:16,936
这是没有问题的

354
00:10:17,516 --> 00:10:18,766
当你的附属项

355
00:10:18,766 --> 00:10:20,006
更新并升级到 Swift 4 时

356
00:10:20,006 --> 00:10:21,516
那就太好了

357
00:10:21,666 --> 00:10:22,906
它们能很好的适应你的 App

358
00:10:22,906 --> 00:10:24,426
无论是 Swift 3.2 还是 Swift 4

359
00:10:25,196 --> 00:10:26,996
Swift Package Manager

360
00:10:26,996 --> 00:10:27,966
同样能做到这点

361
00:10:28,456 --> 00:10:29,756
并且它将使用用于

362
00:10:29,756 --> 00:10:31,246
开发包的工具版本

363
00:10:31,246 --> 00:10:33,536
来构建包

364
00:10:33,536 --> 00:10:34,946
如果一个包支持

365
00:10:34,946 --> 00:10:36,116
多个 Swift 语言版本

366
00:10:36,116 --> 00:10:37,076
它会被标注出来

367
00:10:37,076 --> 00:10:38,696
因此 Swift Package Manage

368
00:10:38,696 --> 00:10:39,696
总是会做出正确的选择

369
00:10:40,756 --> 00:10:42,466
现在 我们在认为

370
00:10:42,466 --> 00:10:44,316
Swift 3.2 和 Swift 4

371
00:10:44,376 --> 00:10:45,776
共存的情况下

372
00:10:46,046 --> 00:10:48,336
只需一点点的改变

373
00:10:48,396 --> 00:10:50,766
你就可以轻易地

374
00:10:50,766 --> 00:10:52,526
把代码从 Swift 3

375
00:10:52,526 --> 00:10:52,776
迁移到 Swift 4

376
00:10:54,086 --> 00:10:55,376
我们就先到这

377
00:10:55,376 --> 00:10:56,166
下面有请 BOB 来谈谈

378
00:10:56,166 --> 00:10:56,966
改进的构建

379
00:10:57,516 --> 00:11:03,046
[掌声]

380
00:10:57,516 --> 00:11:03,046
[掌声]

381
00:11:03,546 --> 00:11:05,256
&gt;&gt;  随着 Swift App 的

382
00:11:05,256 --> 00:11:07,016
规模和复杂度不断增加

383
00:11:07,016 --> 00:11:08,996
我们一直在投资于

384
00:11:08,996 --> 00:11:10,556
系统的改进

385
00:11:10,556 --> 00:11:12,036
以期跟上这种增长

386
00:11:13,826 --> 00:11:15,826
Xcode 9 有一个

387
00:11:15,826 --> 00:11:17,186
全新的

388
00:11:17,256 --> 00:11:17,636
构建系统

389
00:11:18,006 --> 00:11:19,686
当然 这是用 Swift 编写的

390
00:11:19,976 --> 00:11:21,246
它是在开源的 LLBuild

391
00:11:21,246 --> 00:11:23,606
引擎上构建的

392
00:11:24,326 --> 00:11:26,476
在计算构建的不同

393
00:11:26,476 --> 00:11:28,046
步骤之间的依赖关系时

394
00:11:28,046 --> 00:11:29,536
它的速度非常快

395
00:11:30,246 --> 00:11:31,396
你很可能会在进行

396
00:11:31,446 --> 00:11:32,896
进行大型项目的

397
00:11:32,896 --> 00:11:34,736
增量构建时注意到这一点

398
00:11:35,886 --> 00:11:37,866
这是 Xcode 9 中的

399
00:11:37,996 --> 00:11:38,616
一个技术预览

400
00:11:38,846 --> 00:11:40,206
我们诚挚的邀请你

401
00:11:40,206 --> 00:11:40,636
去尝试一下

402
00:11:40,876 --> 00:11:42,656
所以 找到文件菜单中的

403
00:11:42,656 --> 00:11:44,486
项目或工作空间设置

404
00:11:44,486 --> 00:11:46,796
并选择

405
00:11:47,506 --> 00:11:47,686
新建系统

406
00:11:48,936 --> 00:11:50,916
除了拥有一个更快的

407
00:11:50,976 --> 00:11:53,026
构建系统之外

408
00:11:53,026 --> 00:11:54,876
另外一个高效使用

409
00:11:54,876 --> 00:11:56,656
系统的方法是避免多余的工作

410
00:11:57,186 --> 00:11:58,896
Xcode 9 可以通过

411
00:11:58,896 --> 00:12:00,366
很多途径来实现这个目的

412
00:11:58,896 --> 00:12:00,366
很多途径来实现这个目的

413
00:12:01,296 --> 00:12:03,816
预编译的桥接头

414
00:12:04,156 --> 00:12:05,956
加速了大型混合源

415
00:12:06,066 --> 00:12:07,506
项目的构建

416
00:12:08,246 --> 00:12:10,056
桥接头描述了 Objective-C

417
00:12:10,056 --> 00:12:11,116
中的接口

418
00:12:11,116 --> 00:12:13,116
这样一来它们就可以

419
00:12:13,116 --> 00:12:14,676
在你的 Swift 代码中使用

420
00:12:15,516 --> 00:12:16,476
如果你有很多的 Objective-C

421
00:12:16,476 --> 00:12:18,556
那么桥接头会非常大

422
00:12:18,556 --> 00:12:20,496
编译速度

423
00:12:20,496 --> 00:12:21,446
也会很慢

424
00:12:21,996 --> 00:12:23,656
对于每个 Swift 文件来说

425
00:12:23,656 --> 00:12:25,706
反复解析头文件的内容

426
00:12:25,706 --> 00:12:27,786
是十分浪费的

427
00:12:29,326 --> 00:12:31,256
Apple LLVM 编译器

428
00:12:31,256 --> 00:12:32,506
有一个很好的解决方案

429
00:12:33,196 --> 00:12:34,426
就是预先编译好头文件

430
00:12:35,916 --> 00:12:38,046
Xcode 9 现在会使用

431
00:12:38,096 --> 00:12:39,886
一个预编译版本的

432
00:12:39,886 --> 00:12:41,846
桥接头 这样它只需

433
00:12:41,846 --> 00:12:43,256
解析一次就足够了

434
00:12:45,166 --> 00:12:47,416
Apple Music 是一个很好的例子

435
00:12:47,416 --> 00:12:49,666
Xcode 9 极大地优化了它

436
00:12:49,866 --> 00:12:51,676
音乐是一项非常大的工程

437
00:12:51,676 --> 00:12:53,126
就编程语言来说 Objective-C

438
00:12:53,186 --> 00:12:54,846
和 Swift 平分秋色

439
00:12:55,886 --> 00:12:57,446
Xcode 9 的默认设置是

440
00:12:57,446 --> 00:12:59,156
使用预编译的桥接头

441
00:12:59,236 --> 00:13:01,396
在调试音乐时 这大约

442
00:12:59,236 --> 00:13:01,396
在调试音乐时 这大约

443
00:13:01,396 --> 00:13:03,666
可以节省 40% 的时间

444
00:13:04,426 --> 00:13:09,326
另一个有力的工具是代码覆盖率测试

445
00:13:09,326 --> 00:13:11,846
但在 Xcode 8 里

446
00:13:11,846 --> 00:13:13,576
它很可能是

447
00:13:13,576 --> 00:13:14,586
多余工作量的来源

448
00:13:15,616 --> 00:13:16,996
设想一个常见的场景

449
00:13:16,996 --> 00:13:18,206
你对代码进行了一些更改

450
00:13:18,206 --> 00:13:20,276
把它用于构建

451
00:13:20,276 --> 00:13:21,126
并尝试使用

452
00:13:21,196 --> 00:13:22,226
覆盖测试

453
00:13:23,356 --> 00:13:24,586
这是 Xcode 

454
00:13:24,586 --> 00:13:25,986
报表显示器中的样子

455
00:13:27,166 --> 00:13:29,046
注意到那儿有一个额外的构建

456
00:13:29,686 --> 00:13:30,746
它为什么会在那儿

457
00:13:32,046 --> 00:13:33,796
覆盖测试是在编译器

458
00:13:33,796 --> 00:13:35,556
中来实现的

459
00:13:35,556 --> 00:13:37,746
它通过允许额外的插装代码

460
00:13:37,746 --> 00:13:39,086
来计算每段代码

461
00:13:39,086 --> 00:13:40,226
运行的次数

462
00:13:41,296 --> 00:13:43,106
在 Xcode 8 中

463
00:13:43,106 --> 00:13:44,356
普通的构建

464
00:13:44,356 --> 00:13:45,176
不包括那个工具

465
00:13:45,176 --> 00:13:46,336
因此 在进行

466
00:13:46,426 --> 00:13:48,396
覆盖测试之前

467
00:13:48,396 --> 00:13:49,986
整个项目需要进行重建

468
00:13:50,596 --> 00:13:54,896
在 Xcode 9 中

469
00:13:54,896 --> 00:13:55,596
我们整合了这些重建

470
00:13:56,016 --> 00:13:57,726
如果你启用了

471
00:13:57,726 --> 00:14:00,126
覆盖测试

472
00:13:57,726 --> 00:14:00,126
覆盖测试

473
00:14:00,126 --> 00:14:01,456
那么正常的构建

474
00:14:02,246 --> 00:14:03,736
将包含检测仪表

475
00:14:03,736 --> 00:14:03,946
这得稍微付出点成本

476
00:14:04,276 --> 00:14:06,246
我们所检测的项目

477
00:14:06,246 --> 00:14:06,926
的内容不到 3%

478
00:14:07,876 --> 00:14:10,076
但你会得到巨大的收益

479
00:14:10,146 --> 00:14:11,226
因为现在再

480
00:14:11,226 --> 00:14:12,866
构建项目只需

481
00:14:12,866 --> 00:14:13,406
一次即可

482
00:14:15,856 --> 00:14:18,426
这对你来说的改变不是

483
00:14:18,426 --> 00:14:19,776
能够让你更快的构建

484
00:14:20,646 --> 00:14:21,826
而是要让你

485
00:14:24,036 --> 00:14:24,306
彻底的杜绝它

486
00:14:25,516 --> 00:14:29,016
[掌声]

487
00:14:29,516 --> 00:14:30,676
索引是很棒的功能

488
00:14:30,816 --> 00:14:32,496
就像是在全局中重命名重构一样

489
00:14:32,496 --> 00:14:33,956
这是 Xcode 里一些最关键的

490
00:14:33,956 --> 00:14:35,746
强大功能

491
00:14:36,676 --> 00:14:38,236
但是后台索引

492
00:14:38,586 --> 00:14:39,446
则毫无意义

493
00:14:40,886 --> 00:14:42,476
无论何时构建项目

494
00:14:42,856 --> 00:14:44,226
编译器都需要查找

495
00:14:44,226 --> 00:14:45,956
符号索引所需要的

496
00:14:46,216 --> 00:14:47,476
所有相同的

497
00:14:47,476 --> 00:14:47,926
符号信息

498
00:14:48,306 --> 00:14:50,606
正基于此 现在在

499
00:14:50,606 --> 00:14:52,456
Xcode 9 中 需要构建项目时

500
00:14:52,506 --> 00:14:54,176
我们会自动更新索引

501
00:14:54,796 --> 00:14:56,486
在构建的时候

502
00:14:56,486 --> 00:14:58,566
会付出一点点成本

503
00:14:58,566 --> 00:15:00,016
但是没有必要

504
00:14:58,566 --> 00:15:00,016
但是没有必要

505
00:15:00,016 --> 00:15:01,686
在后台重复进行

506
00:15:01,686 --> 00:15:02,306
所有的工作

507
00:15:02,946 --> 00:15:05,776
所以 我们有了一个新的

508
00:15:05,866 --> 00:15:07,606
构建系统和几种不同的

509
00:15:07,606 --> 00:15:08,796
高效使用的方法

510
00:15:08,796 --> 00:15:10,806
我们觉得这对那些

511
00:15:10,806 --> 00:15:12,116
使用 Swift 构建

512
00:15:12,116 --> 00:15:13,906
大型项目的人

513
00:15:13,906 --> 00:15:14,836
尤为有用

514
00:15:16,256 --> 00:15:17,656
现在让我们来看看

515
00:15:17,656 --> 00:15:18,966
运行时间性能

516
00:15:20,276 --> 00:15:22,406
提供高质量的代码

517
00:15:22,406 --> 00:15:24,266
一直是 Swift 的

518
00:15:24,266 --> 00:15:25,356
主要目标之一

519
00:15:25,446 --> 00:15:26,786
每一个 Swift 新版本的发布

520
00:15:26,786 --> 00:15:28,266
都意味着性能的

521
00:15:28,266 --> 00:15:28,906
极大提升

522
00:15:29,776 --> 00:15:31,806
下一步是使性能

523
00:15:31,806 --> 00:15:33,306
变得更可预测

524
00:15:33,366 --> 00:15:34,066
更稳定

525
00:15:35,736 --> 00:15:37,146
让我们来看看一个

526
00:15:37,146 --> 00:15:37,746
使用 Swift 3 的例子

527
00:15:38,736 --> 00:15:40,956
我这里有一个简单的协议

528
00:15:40,956 --> 00:15:42,266
它用一个比较函数来排序

529
00:15:42,266 --> 00:15:44,366
另一个函数将通过对

530
00:15:44,706 --> 00:15:46,186
一个值数组的排序

531
00:15:46,306 --> 00:15:47,696
来进行测试

532
00:15:48,026 --> 00:15:49,146
整个代码

533
00:15:50,006 --> 00:15:51,696
非常的

534
00:15:51,696 --> 00:15:52,546
简单易懂

535
00:15:52,616 --> 00:15:54,256
它必须对所有

536
00:15:54,256 --> 00:15:55,806
符合有序协议的值

537
00:15:55,806 --> 00:15:56,606
都适用

538
00:15:57,236 --> 00:15:58,476
即使数组中的

539
00:15:58,476 --> 00:15:59,436
不同元素也可能

540
00:15:59,436 --> 00:16:00,366
是不同的类型

541
00:15:59,436 --> 00:16:00,366
是不同的类型

542
00:16:01,546 --> 00:16:02,766
让我们来看看

543
00:16:02,816 --> 00:16:02,976
它是如何工作的

544
00:16:04,756 --> 00:16:06,436
这个图表以秒位单位展示了

545
00:16:06,486 --> 00:16:09,236
对 100000 个 每个有 100 个元素

546
00:16:09,236 --> 00:16:10,506
的数组进行排序所花费的时间

547
00:16:10,936 --> 00:16:12,466
它测量的是不同

548
00:16:12,466 --> 00:16:13,966
大小的数组元素

549
00:16:14,166 --> 00:16:16,846
因此 对于一个单一结构体

550
00:16:16,846 --> 00:16:18,006
完成这些排序需要

551
00:16:18,006 --> 00:16:19,576
花费不到 2 秒的时间

552
00:16:20,576 --> 00:16:22,286
如果由于某种原因

553
00:16:22,286 --> 00:16:24,236
值的大小增加到双字

554
00:16:24,986 --> 00:16:26,656
时间也只会

555
00:16:26,746 --> 00:16:27,176
稍微增加一点点

556
00:16:27,176 --> 00:16:29,626
如何值的大小增加到 3 字

557
00:16:30,136 --> 00:16:31,456
跟刚才

558
00:16:31,456 --> 00:16:32,146
也没什么不同

559
00:16:33,506 --> 00:16:34,586
但一旦

560
00:16:34,586 --> 00:16:35,416
增加到 4 字

561
00:16:36,846 --> 00:16:38,156
那可就大事不妙了

562
00:16:38,566 --> 00:16:40,236
这会比之前慢上九倍

563
00:16:41,566 --> 00:16:43,326
怎么去解释刚刚发生的事情呢

564
00:16:44,756 --> 00:16:46,586
要弄清楚这一点

565
00:16:46,586 --> 00:16:48,326
我们需要深入了解 Swift

566
00:16:48,326 --> 00:16:49,736
的实现机制

567
00:16:50,106 --> 00:16:51,316
如果你对此感兴趣

568
00:16:51,316 --> 00:16:52,206
我建议你看看

569
00:16:52,306 --> 00:16:53,866
去年的

570
00:16:53,966 --> 00:16:54,726
Understanding Swift Performance

571
00:16:55,306 --> 00:16:57,606
现在 我来给你做一个

572
00:16:57,606 --> 00:16:57,976
简单的总结

573
00:16:58,756 --> 00:17:01,246
为了表示未知类型的值

574
00:16:58,756 --> 00:17:01,246
为了表示未知类型的值

575
00:17:01,246 --> 00:17:03,496
编译器使用了

576
00:17:03,496 --> 00:17:04,536
我们现在所说的

577
00:17:04,536 --> 00:17:05,756
存在容器的数据结构

578
00:17:06,695 --> 00:17:08,506
在存在容器内部

579
00:17:08,896 --> 00:17:10,306
有一个内嵌缓冲区

580
00:17:10,306 --> 00:17:11,566
来存放较小的值

581
00:17:13,215 --> 00:17:14,506
我们目前正在

582
00:17:14,576 --> 00:17:15,766
重新评估缓冲区的大小

583
00:17:15,766 --> 00:17:18,086
但是对于 Swift 4

584
00:17:18,086 --> 00:17:19,195
来说 仍向往常一样

585
00:17:19,195 --> 00:17:19,566
默认它是 3 个字长

586
00:17:21,386 --> 00:17:23,266
如果该值太大

587
00:17:23,266 --> 00:17:25,226
则无法与内联缓冲区匹配

588
00:17:25,226 --> 00:17:26,465
那么它就会在堆中分配

589
00:17:27,435 --> 00:17:29,556
而用堆存储的成本

590
00:17:29,556 --> 00:17:30,116
十分高昂

591
00:17:31,016 --> 00:17:32,136
这就是我们刚刚

592
00:17:32,136 --> 00:17:33,486
看到大事不妙的

593
00:17:33,536 --> 00:17:33,906
原因

594
00:17:35,216 --> 00:17:36,266
那我们能做些什么呢

595
00:17:37,696 --> 00:17:39,586
答案是 cow （牛）缓冲

596
00:17:40,076 --> 00:17:41,586
存在的 cow （牛）缓冲

597
00:17:41,821 --> 00:17:43,821
笑声

598
00:17:44,056 --> 00:17:45,276
不是你们想的那种牛

599
00:17:45,756 --> 00:17:47,736
COW 是 Copy On Right 的

600
00:17:47,736 --> 00:17:48,016
首字母缩写

601
00:17:48,446 --> 00:17:49,646
你可能听我们

602
00:17:49,646 --> 00:17:51,006
之前讨论过这个问题

603
00:17:51,006 --> 00:17:52,886
因为使用值语意

604
00:17:52,966 --> 00:17:53,446
是提高性能的关键

605
00:17:55,506 --> 00:17:57,796
在 Swift 4 里 如果一个值太大

606
00:17:57,796 --> 00:17:59,836
与內联缓冲区不匹配

607
00:18:00,286 --> 00:18:02,326
它就会和

608
00:18:02,326 --> 00:18:03,396
一个引用计数一起在堆中被分配

609
00:18:04,096 --> 00:18:05,976
只要保证是只读状态

610
00:18:06,026 --> 00:18:07,796
多个存在容器

611
00:18:07,796 --> 00:18:08,936
可以共享相同的

612
00:18:08,936 --> 00:18:09,246
缓冲区

613
00:18:09,636 --> 00:18:11,186
这样就避免了很多

614
00:18:11,186 --> 00:18:12,936
冗余的堆分配

615
00:18:13,926 --> 00:18:15,326
只有在有多个

616
00:18:15,326 --> 00:18:16,736
引用的情况下

617
00:18:16,736 --> 00:18:19,186
缓冲区才需要

618
00:18:19,406 --> 00:18:20,546
被单独的

619
00:18:20,546 --> 00:18:21,386
复制

620
00:18:22,076 --> 00:18:23,336
Swift 现在就能

621
00:18:23,336 --> 00:18:24,566
完全自动的为你

622
00:18:24,566 --> 00:18:25,856
管理这些复杂的东西

623
00:18:27,356 --> 00:18:28,246
这对性能

624
00:18:28,246 --> 00:18:28,866
有什么影响

625
00:18:30,166 --> 00:18:31,436
当然是变得更加稳定

626
00:18:32,246 --> 00:18:34,256
相较于之前用超过 18 秒

627
00:18:34,326 --> 00:18:35,946
的时间来对这些前结构

628
00:18:35,946 --> 00:18:37,726
进行排序 现在只需要

629
00:18:37,726 --> 00:18:38,926
4 秒多一点

630
00:18:39,536 --> 00:18:41,266
这是一个平缓的过程

631
00:18:41,266 --> 00:18:42,146
而不是一蹴而就

632
00:18:42,806 --> 00:18:45,846
这种改进适用于

633
00:18:45,846 --> 00:18:46,946
编译器处理

634
00:18:46,946 --> 00:18:48,216
那些根本不清楚

635
00:18:48,216 --> 00:18:49,536
类型的值的情况

636
00:18:50,246 --> 00:18:51,616
但是类似的问题

637
00:18:51,616 --> 00:18:53,156
出现在通用代码中

638
00:18:53,156 --> 00:18:54,586
他的类型是参数

639
00:18:55,266 --> 00:18:56,366
让我们来看看

640
00:18:58,316 --> 00:18:59,806
在许多情况下

641
00:18:59,806 --> 00:19:01,486
编译器能够通过

642
00:18:59,806 --> 00:19:01,486
编译器能够通过

643
00:19:01,976 --> 00:19:03,696
为特定类型使用

644
00:19:04,096 --> 00:19:05,206
专门的版本来快速地实现通用代码

645
00:19:05,896 --> 00:19:07,176
但是有时编译器不能

646
00:19:07,176 --> 00:19:09,026
识别特定的类型

647
00:19:09,106 --> 00:19:10,746
然后它需要使用

648
00:19:10,746 --> 00:19:12,336
非专用的通用代码

649
00:19:13,206 --> 00:19:14,896
这就慢的多了

650
00:19:15,306 --> 00:19:16,526
这是那种大事不妙的

651
00:19:16,526 --> 00:19:17,436
另一种表现形式

652
00:19:18,676 --> 00:19:20,656
到目前为止 Swift已经在

653
00:19:20,656 --> 00:19:22,546
非专用代码中使用了

654
00:19:22,546 --> 00:19:23,866
通用缓冲区的堆分配

655
00:19:24,156 --> 00:19:25,946
正如我们刚刚看到的

656
00:19:25,946 --> 00:19:27,866
堆分配的速度非常慢

657
00:19:28,776 --> 00:19:31,236
Swift 4 现在使用的是

658
00:19:31,236 --> 00:19:32,136
堆栈分配的通用缓冲区

659
00:19:32,486 --> 00:19:34,166
因此 对于非专用的

660
00:19:34,446 --> 00:19:37,906
通用代码 我们进行了

661
00:19:38,136 --> 00:19:39,886
类似的改进

662
00:19:39,976 --> 00:19:41,846
让 Swift 的性能得到持续优化

663
00:19:41,846 --> 00:19:42,226
需要我们共同的努力

664
00:19:42,756 --> 00:19:45,056
Swift 4 已经

665
00:19:45,346 --> 00:19:46,596
在处理棘手问题上

666
00:19:46,596 --> 00:19:49,576
取得了巨大的进步

667
00:19:50,176 --> 00:19:51,736
性能的另一个考核度

668
00:19:51,996 --> 00:19:52,576
是大小

669
00:19:54,196 --> 00:19:56,006
随着你的 App 越来越大

670
00:19:56,006 --> 00:19:58,446
代码大小也变得

671
00:19:58,516 --> 00:19:59,786
越来越重要

672
00:20:01,096 --> 00:20:02,656
使代码缩小的一个例子是

673
00:20:02,656 --> 00:20:05,376
避免未使用的代码

674
00:20:06,606 --> 00:20:08,166
让我们回到 Doug

675
00:20:08,166 --> 00:20:09,566
一个日期结构体的例子

676
00:20:10,126 --> 00:20:11,656
与任何值类型一样

677
00:20:11,656 --> 00:20:13,536
让它符合平等的

678
00:20:13,536 --> 00:20:14,956
可比较的协议

679
00:20:14,956 --> 00:20:15,516
是一个好主意

680
00:20:16,476 --> 00:20:17,766
但如果你的 App 中

681
00:20:17,766 --> 00:20:19,216
没有使用其中任何一个

682
00:20:19,216 --> 00:20:19,466
那该怎么办

683
00:20:20,196 --> 00:20:21,656
你不该为不用的代码

684
00:20:21,686 --> 00:20:25,366
浪费资源

685
00:20:25,556 --> 00:20:27,966
在 Swift 4 中

686
00:20:27,966 --> 00:20:30,536
编译器会自动优化

687
00:20:30,536 --> 00:20:32,146
所使用的内容

688
00:20:32,146 --> 00:20:33,336
这样你就不必

689
00:20:33,336 --> 00:20:33,616
再多费力气

690
00:20:34,296 --> 00:20:35,686
请注意 这与其他优化

691
00:20:35,686 --> 00:20:37,336
如反虚拟化

692
00:20:37,336 --> 00:20:39,186
和内连进行了交互

693
00:20:39,496 --> 00:20:41,616
这些优化将为编译器

694
00:20:41,616 --> 00:20:42,946
消除不需要的代码

695
00:20:42,946 --> 00:20:44,086
提供一些更多的方法

696
00:20:44,746 --> 00:20:47,326
这就是编译器

697
00:20:47,326 --> 00:20:48,876
可以完全自动

698
00:20:48,876 --> 00:20:49,596
完成的优化

699
00:20:50,436 --> 00:20:51,816
当然这并不总是可行的

700
00:20:52,646 --> 00:20:54,466
让我们来看看另一个例子

701
00:20:55,456 --> 00:20:57,956
这里我简单定义一个类

702
00:20:57,956 --> 00:20:58,776
它有两个函数

703
00:20:59,816 --> 00:21:01,156
编译器将生成这些函数

704
00:20:59,816 --> 00:21:01,156
编译器将生成这些函数

705
00:21:01,156 --> 00:21:05,126
因为在 Swift 3 中

706
00:21:05,126 --> 00:21:07,316
这是 NSObject 的一个子类

707
00:21:08,106 --> 00:21:10,536
语言会自行判断

708
00:21:10,536 --> 00:21:12,716
编译器也会推断

709
00:21:12,716 --> 00:21:14,036
Objc 的属性

710
00:21:15,416 --> 00:21:16,806
这意味着

711
00:21:16,806 --> 00:21:18,226
这些函数可以从

712
00:21:18,226 --> 00:21:19,366
Objective-C 中访问

713
00:21:20,376 --> 00:21:22,066
因此 

714
00:21:22,066 --> 00:21:24,506
编译器会生成

715
00:21:24,506 --> 00:21:25,566
与 Ojective-C

716
00:21:25,566 --> 00:21:27,146
函数兼容的换函数

717
00:21:27,196 --> 00:21:29,056
并把它推送至 Swift 函数

718
00:21:30,756 --> 00:21:32,756
现在 Swift 中的函数

719
00:21:32,756 --> 00:21:33,846
仍然可以被直接调用

720
00:21:34,176 --> 00:21:36,016
在我的示例中

721
00:21:36,766 --> 00:21:37,996
show 调用 print

722
00:21:37,996 --> 00:21:39,576
这就意味着

723
00:21:39,576 --> 00:21:40,426
这些换函数经常被闲置

724
00:21:41,026 --> 00:21:44,646
但是因为他们被计算在

725
00:21:44,646 --> 00:21:45,956
Objective-C 的运行时间里

726
00:21:45,956 --> 00:21:47,846
编译器无法告诉你

727
00:21:47,846 --> 00:21:48,416
他们是有没有被使用的

728
00:21:49,036 --> 00:21:51,196
解决这个问题需要

729
00:21:51,196 --> 00:21:52,126
改变语言模型

730
00:21:53,256 --> 00:21:55,806
因此 在 Swift 4 中

731
00:21:55,806 --> 00:21:57,846
Objc 属性只在

732
00:21:57,906 --> 00:21:59,306
有需要的情况下

733
00:21:59,306 --> 00:21:59,626
才会被推断出来

734
00:21:59,686 --> 00:22:00,936
比如当你重写

735
00:21:59,686 --> 00:22:00,936
比如当你重写

736
00:22:00,936 --> 00:22:02,426
Objective-C 的方法

737
00:22:02,426 --> 00:22:03,966
或者统一 Objective-C

738
00:22:04,016 --> 00:22:04,776
协议时

739
00:22:05,656 --> 00:22:08,036
这种改变避免了许多

740
00:22:08,036 --> 00:22:09,286
未使用的换函数

741
00:22:10,796 --> 00:22:12,536
当我们在 Apple Music 中

742
00:22:12,536 --> 00:22:14,026
采用这一功能时

743
00:22:14,076 --> 00:22:14,976
代码几乎减少了 6%

744
00:22:19,566 --> 00:22:21,266
当你有了一组

745
00:22:21,616 --> 00:22:23,106
想要访问的函数

746
00:22:23,106 --> 00:22:25,136
和 Objective-C 时

747
00:22:25,196 --> 00:22:26,126
我们建议你把它们放在一个

748
00:22:26,126 --> 00:22:28,336
放在一个扩展中

749
00:22:28,336 --> 00:22:29,546
然后用 Objc 属性标记扩展

750
00:22:30,026 --> 00:22:31,436
这保证了

751
00:22:31,436 --> 00:22:32,696
所有这些函数都可以

752
00:22:32,696 --> 00:22:33,866
用在 Objective-C 代码中

753
00:22:34,416 --> 00:22:35,846
如果因为某些原因

754
00:22:35,846 --> 00:22:38,436
导致不能成功运行

755
00:22:38,436 --> 00:22:38,976
编译器会向你报错

756
00:22:41,556 --> 00:22:43,316
那么采取这种改变

757
00:22:43,316 --> 00:22:43,976
需要些什么呢

758
00:22:44,476 --> 00:22:45,906
Doug 提到了迁移工具

759
00:22:45,906 --> 00:22:47,186
这可以帮你吧代码

760
00:22:47,186 --> 00:22:47,886
迁移到 Swift 4

761
00:22:48,506 --> 00:22:50,486
Objc 推理迁移工具

762
00:22:50,486 --> 00:22:51,416
提供了一个选择

763
00:22:52,046 --> 00:22:53,336
如果你不关心

764
00:22:53,336 --> 00:22:55,246
代码的大小

765
00:22:55,246 --> 00:22:57,056
那么迁移工具可以轻松地

766
00:22:57,056 --> 00:22:59,056
匹配 Swift 3 的行为

767
00:22:59,056 --> 00:23:00,816
只需将 Objc 属性插入到

768
00:22:59,056 --> 00:23:00,816
只需将 Objc 属性插入到

769
00:23:00,816 --> 00:23:02,276
先前推断的地方即可

770
00:23:03,156 --> 00:23:04,496
只需一点点改动

771
00:23:04,496 --> 00:23:06,206
利用最小的推断

772
00:23:06,206 --> 00:23:08,226
就可以享受

773
00:23:08,226 --> 00:23:09,766
代码改善的乐趣

774
00:23:10,316 --> 00:23:13,206
如果你使用该选项

775
00:23:13,206 --> 00:23:15,256
进行最小推断

776
00:23:15,256 --> 00:23:17,456
那么迁移工具将首先

777
00:23:17,456 --> 00:23:18,956
找到确定需要

778
00:23:18,956 --> 00:23:20,786
Objc 属性的

779
00:23:20,786 --> 00:23:21,216
所有位置

780
00:23:21,216 --> 00:23:22,646
它会这样做

781
00:23:22,646 --> 00:23:23,886
并且自动插入

782
00:23:24,966 --> 00:23:26,386
这可能还不够

783
00:23:26,816 --> 00:23:28,416
因为迁移工具

784
00:23:28,416 --> 00:23:30,626
无法单独的在 Swift 模块或

785
00:23:30,626 --> 00:23:32,226
Object-C 代码中

786
00:23:32,226 --> 00:23:33,246
检测到问题

787
00:23:34,106 --> 00:23:35,496
因此为了帮你

788
00:23:35,496 --> 00:23:38,736
找到这些位置

789
00:23:38,736 --> 00:23:39,776
迁移工具将标记那些

790
00:23:39,776 --> 00:23:42,046
被推断为过时的换函数

791
00:23:42,766 --> 00:23:44,166
然后你可以构建代码

792
00:23:44,166 --> 00:23:45,466
并运行代码

793
00:23:45,466 --> 00:23:46,516
查找弃用警告

794
00:23:47,806 --> 00:23:49,306
让我们更仔细的看一下

795
00:23:50,336 --> 00:23:51,936
下面是一个构建

796
00:23:51,936 --> 00:23:52,236
警告的例子

797
00:23:53,246 --> 00:23:55,266
我有一个 Swift 函数

798
00:23:55,266 --> 00:23:56,596
来显示我视图控制器

799
00:23:56,596 --> 00:23:57,116
的状态

800
00:23:57,576 --> 00:23:58,786
我正在从 Objective-C

801
00:23:58,786 --> 00:23:59,806
代码中调用这个

802
00:24:00,226 --> 00:24:01,706
但因为我仍然依赖于

803
00:24:01,706 --> 00:24:03,236
Objc 推论 所以我

804
00:24:03,236 --> 00:24:04,666
得到了被弃用的

805
00:24:04,666 --> 00:24:05,356
警告

806
00:24:05,906 --> 00:24:08,216
为了解决这个问题

807
00:24:08,306 --> 00:24:09,976
我需要在 Swift 代码中

808
00:24:09,976 --> 00:24:11,356
找到这个位置 在这个代码中

809
00:24:11,986 --> 00:24:13,756
定义了函数并添加 Objc 属性

810
00:24:14,256 --> 00:24:19,076
有些问题可能在

811
00:24:19,076 --> 00:24:20,326
构建初显现不出来

812
00:24:20,366 --> 00:24:22,026
在 Objective-C 中 我们

813
00:24:22,026 --> 00:24:24,156
可以用一种无法在运行前

814
00:24:24,156 --> 00:24:26,136
检测到的方式来引用函数

815
00:24:26,876 --> 00:24:28,466
因此 出于这个原因

816
00:24:28,466 --> 00:24:30,756
常跑代码 常做测试

817
00:24:30,956 --> 00:24:32,626
尽可能多地练习写代码

818
00:24:32,626 --> 00:24:34,176
多看 Xcode 调试区中的控制台

819
00:24:34,726 --> 00:24:36,336
所给出的提示信息

820
00:24:36,526 --> 00:24:38,486
这都是很

821
00:24:38,486 --> 00:24:39,246
重要的事情

822
00:24:39,336 --> 00:24:40,556
这告诉你需要

823
00:24:40,556 --> 00:24:41,626
添加 OBjc 属性

824
00:24:42,506 --> 00:24:45,586
注意 这里的消息

825
00:24:45,586 --> 00:24:46,886
向你显示了

826
00:24:46,886 --> 00:24:48,546
函数定义的

827
00:24:48,596 --> 00:24:49,056
确切源位置

828
00:24:49,056 --> 00:24:50,366
因此 你可以直接到

829
00:24:50,366 --> 00:24:53,826
那个位置并添加属性

830
00:24:53,926 --> 00:24:55,336
一旦你修复了所有的

831
00:24:55,336 --> 00:24:57,736
构建和运行警告

832
00:24:57,736 --> 00:24:59,226
就去为项目进行构建设置

833
00:24:59,566 --> 00:25:01,276
更改 Swift 3 Objc 设置

834
00:24:59,566 --> 00:25:01,276
更改 Swift 3 Objc 设置

835
00:25:01,276 --> 00:25:03,286
设置为默认设置

836
00:25:03,286 --> 00:25:05,146
这样就完成了

837
00:25:05,216 --> 00:25:05,516
迁移的过程

838
00:25:06,166 --> 00:25:07,486
这真的不是那么难

839
00:25:08,086 --> 00:25:09,486
我们为 Apple Music

840
00:25:09,686 --> 00:25:11,886
做了同样的事情

841
00:25:11,886 --> 00:25:13,706
在一个很大的项目中

842
00:25:13,706 --> 00:25:15,696
只有大约 40 处需要

843
00:25:15,696 --> 00:25:16,946
添加 Objc 属性的地方

844
00:25:17,476 --> 00:25:19,446
其中超过 30 个

845
00:25:19,446 --> 00:25:20,566
可以由迁移工具

846
00:25:20,566 --> 00:25:22,316
自动完成

847
00:25:22,806 --> 00:25:26,136
这种更改限制了 Objc

848
00:25:26,136 --> 00:25:27,796
推论 以及消除

849
00:25:27,796 --> 00:25:30,066
为使用协议的优化

850
00:25:30,066 --> 00:25:32,316
这两种方法都有助于

851
00:25:32,316 --> 00:25:33,436
减少代码的大小

852
00:25:33,436 --> 00:25:36,016
现在我来告诉你

853
00:25:36,016 --> 00:25:37,686
另外一个改变

854
00:25:37,686 --> 00:25:39,406
它对你 App 的整体

855
00:25:39,406 --> 00:25:41,106
大小有更大的影响

856
00:25:42,076 --> 00:25:44,486
除了组成一个编译

857
00:25:44,486 --> 00:25:45,846
Swift 应用的 指令和

858
00:25:45,936 --> 00:25:48,176
数据外 Swift框架中的

859
00:25:48,176 --> 00:25:50,816
符号表占据了

860
00:25:50,886 --> 00:25:51,266
大量的空间

861
00:25:52,366 --> 00:25:54,726
Swift 使用了很多的符号

862
00:25:54,726 --> 00:25:58,016
而且名字通常都很长

863
00:25:58,206 --> 00:26:01,376
比如 在 Swift 3.1 中

864
00:25:58,206 --> 00:26:01,376
比如 在 Swift 3.1 中

865
00:26:01,456 --> 00:26:03,476
几乎一半的标准库

866
00:26:03,516 --> 00:26:04,866
都是由符号组成的

867
00:26:05,186 --> 00:26:06,736
就像这里深蓝色

868
00:26:06,736 --> 00:26:06,966
柱状图显示的那样

869
00:26:08,016 --> 00:26:10,776
在 Swift 4 中

870
00:26:10,776 --> 00:26:11,676
符号所需的空间要小得多

871
00:26:11,676 --> 00:26:12,996
所以 尽管标准库

872
00:26:12,996 --> 00:26:14,306
中有了更多的

873
00:26:14,306 --> 00:26:14,836
内容

874
00:26:15,346 --> 00:26:17,166
总大小实际上

875
00:26:17,166 --> 00:26:17,626
是减小的

876
00:26:19,146 --> 00:26:20,496
我们通过使名字变短

877
00:26:20,496 --> 00:26:22,956
同时去掉符号来

878
00:26:22,956 --> 00:26:24,576
实现这个目标

879
00:26:25,286 --> 00:26:28,526
静态链接器和动态链接器

880
00:26:28,526 --> 00:26:30,316
都使用单独的

881
00:26:30,316 --> 00:26:32,096
Trie 数据结构

882
00:26:32,096 --> 00:26:32,946
来快速查找符号

883
00:26:33,956 --> 00:26:35,286
因此 这意味着

884
00:26:35,286 --> 00:26:37,156
在符号表中

885
00:26:37,156 --> 00:26:38,616
很少需要 Swift 符号

886
00:26:39,706 --> 00:26:41,596
Xcode 9 有一个新的构建设置

887
00:26:41,796 --> 00:26:44,156
即去掉默认启用的

888
00:26:44,156 --> 00:26:45,366
Swift 符号

889
00:26:46,646 --> 00:26:47,986
如果他对你的

890
00:26:47,986 --> 00:26:49,176
工作流程带来问题

891
00:26:49,176 --> 00:26:49,736
那么你可以选择关闭它

892
00:26:50,676 --> 00:26:52,926
但是 Xcode 通常把

893
00:26:52,926 --> 00:26:55,726
符号剥离作为

894
00:26:55,726 --> 00:26:57,266
归档项目的一部分

895
00:26:57,566 --> 00:26:59,336
因此 这个特性对

896
00:26:59,336 --> 00:27:00,746
开发的早期阶段

897
00:26:59,336 --> 00:27:00,746
开发的早期阶段

898
00:27:00,746 --> 00:27:01,306
没有影响

899
00:27:01,306 --> 00:27:02,896
特别是 它不应该

900
00:27:02,896 --> 00:27:04,516
干扰正常的

901
00:27:04,516 --> 00:27:05,266
调试或分析

902
00:27:05,856 --> 00:27:09,176
如果出于某种原因

903
00:27:09,176 --> 00:27:10,466
你想要检查二进制文件中

904
00:27:10,506 --> 00:27:12,196
被分离后

905
00:27:12,236 --> 00:27:12,796
依然存在的符号

906
00:27:13,296 --> 00:27:15,616
你可以使用带导出选项的

907
00:27:15,906 --> 00:27:17,836
DYLD 信息查看工具

908
00:27:17,836 --> 00:27:18,936
来查看导出的符号

909
00:27:19,586 --> 00:27:22,776
这个构建设置适用于

910
00:27:22,776 --> 00:27:24,486
你在项目中

911
00:27:24,486 --> 00:27:25,076
构建的代码

912
00:27:26,186 --> 00:27:27,786
Swift 标准库

913
00:27:27,786 --> 00:27:28,706
是被分开处理的

914
00:27:29,426 --> 00:27:31,086
他们作为 App Thinning

915
00:27:31,206 --> 00:27:31,486
的一部分被分离

916
00:27:32,716 --> 00:27:33,896
理解这一点很重要

917
00:27:33,896 --> 00:27:34,876
因为如果你想测量

918
00:27:34,876 --> 00:27:36,216
App 的大小

919
00:27:36,806 --> 00:27:37,926
你需要回顾 Xcode 的分布式

920
00:27:37,926 --> 00:27:39,956
工作流程

921
00:27:40,356 --> 00:27:41,586
并导出 App

922
00:27:42,086 --> 00:27:43,796
当你这样做时

923
00:27:43,796 --> 00:27:45,056
就会看到一个新的设置

924
00:27:45,056 --> 00:27:46,646
你可以用它来控制

925
00:27:46,646 --> 00:27:48,866
是否需要从标准库中

926
00:27:48,866 --> 00:27:49,836
去除符号

927
00:27:51,126 --> 00:27:52,966
你可以选择关闭这项功能

928
00:27:52,966 --> 00:27:54,816
但在大多数情况下

929
00:27:54,816 --> 00:27:55,976
我们建议保留

930
00:27:56,056 --> 00:27:57,726
因为他会大大

931
00:27:57,726 --> 00:27:59,276
减少你 App 的

932
00:28:00,026 --> 00:28:00,106
大小

933
00:28:00,716 --> 00:28:02,836
接下来 Ben 

934
00:28:02,956 --> 00:28:04,026
会讲到字符串

935
00:28:04,026 --> 00:28:05,126
集合和泛型

936
00:28:05,126 --> 00:28:05,676
的更新

937
00:28:06,516 --> 00:28:11,236
[掌声]

938
00:28:11,736 --> 00:28:12,106
&gt;&gt;  谢谢你 Bob

939
00:28:13,066 --> 00:28:14,356
在这个新版本中

940
00:28:14,356 --> 00:28:15,646
我们在标准库和泛型

941
00:28:15,646 --> 00:28:16,816
中有一些非常棒的特性

942
00:28:16,816 --> 00:28:18,316
我将从字符串

943
00:28:18,376 --> 00:28:18,746
说起

944
00:28:19,946 --> 00:28:21,506
Swift 4 中的字符串

945
00:28:21,546 --> 00:28:23,446
使处理字符的速度

946
00:28:23,446 --> 00:28:25,326
更快 更容易

947
00:28:25,326 --> 00:28:27,226
但他们的共同目标都是

948
00:28:27,226 --> 00:28:28,786
帮你编写 Unicode

949
00:28:28,786 --> 00:28:29,386
形式下正确的代码

950
00:28:29,386 --> 00:28:32,506
那什么叫做 Unicode

951
00:28:32,506 --> 00:28:32,826
形式下的正确呢

952
00:28:33,986 --> 00:28:34,896
这绝大部分是源于

953
00:28:34,896 --> 00:28:36,246
我们谈论的

954
00:28:36,246 --> 00:28:36,886
叫字符的东西

955
00:28:38,186 --> 00:28:39,476
在大多数的编程语言中

956
00:28:39,476 --> 00:28:42,276
字符只是一个数字

957
00:28:42,276 --> 00:28:42,916
或是一些编码

958
00:28:43,716 --> 00:28:44,866
在比较老的系统中

959
00:28:44,996 --> 00:28:45,236
可能是 ASCII 码

960
00:28:45,756 --> 00:28:46,746
现在 它可能是 Unicode

961
00:28:46,746 --> 00:28:47,856
编码中的一种

962
00:28:48,916 --> 00:28:50,816
可是为什么这很重要

963
00:28:50,816 --> 00:28:53,896
让我们来看一个例子

964
00:28:54,496 --> 00:28:58,456
在 Unicode 中

965
00:28:58,456 --> 00:29:01,286
有突出重音的单个字母 e

966
00:28:58,456 --> 00:29:01,286
有突出重音的单个字母 e

967
00:29:01,286 --> 00:29:02,426
可以使用两种不同的

968
00:29:02,426 --> 00:29:02,716
方式来进行编码

969
00:29:04,076 --> 00:29:06,766
一种方法是使用单一的

970
00:29:06,766 --> 00:29:08,356
Unicode 标量 E 9

971
00:29:09,576 --> 00:29:11,236
另一种方法是

972
00:29:11,236 --> 00:29:13,426
单纯使用字母 E

973
00:29:13,426 --> 00:29:15,106
和灵敏重音修饰符

974
00:29:16,346 --> 00:29:17,456
这两种对相同字母

975
00:29:17,456 --> 00:29:18,976
的不同编码方式

976
00:29:18,976 --> 00:29:20,366
正是 Unicode 所说的等同规范

977
00:29:21,196 --> 00:29:22,006
无需任何改变

978
00:29:22,126 --> 00:29:23,926
你就可以使用其中

979
00:29:23,926 --> 00:29:24,486
的任何一个

980
00:29:25,706 --> 00:29:27,746
所以 这在代码中意味着什么呢

981
00:29:28,656 --> 00:29:30,076
当一种语言

982
00:29:30,076 --> 00:29:31,736
默认查看代码的方式

983
00:29:32,026 --> 00:29:33,106
是查看各个字符串

984
00:29:33,106 --> 00:29:34,256
中的代码单元时

985
00:29:34,256 --> 00:29:35,386
你就会发现

986
00:29:35,446 --> 00:29:35,916
一些奇怪的行为

987
00:29:36,876 --> 00:29:38,216
这是一个在 Ruby 中的例子

988
00:29:38,216 --> 00:29:39,806
但是在其它语言中

989
00:29:39,806 --> 00:29:41,146
比如 Java 或 C 中 也通用

990
00:29:42,016 --> 00:29:43,676
我们可以用两种不同的

991
00:29:43,676 --> 00:29:45,306
方式创建两个字符串

992
00:29:45,346 --> 00:29:46,376
他们应当是完全相同的

993
00:29:46,866 --> 00:29:48,556
对用户来说他们看起来是一样的

994
00:29:50,026 --> 00:29:51,256
但当我们去计算

995
00:29:51,586 --> 00:29:53,646
字符的数量时

996
00:29:53,646 --> 00:29:54,276
就会得到不同的结果

997
00:29:55,026 --> 00:29:56,926
如果我们使用的是

998
00:29:56,926 --> 00:29:58,636
默认的比较运算

999
00:29:58,636 --> 00:29:59,236
他们就不是相等的

1000
00:30:00,416 --> 00:30:01,636
这可能会导致一些

1001
00:30:01,636 --> 00:30:02,806
难以理解和

1002
00:30:02,806 --> 00:30:03,256
诊断的问题

1003
00:30:03,986 --> 00:30:05,296
这就是为什么 Swift

1004
00:30:05,406 --> 00:30:06,426
采用的方法

1005
00:30:06,426 --> 00:30:06,866
略有不同

1006
00:30:08,136 --> 00:30:10,516
在 Swift 中

1007
00:30:10,516 --> 00:30:12,036
字符是为字形所冷却的

1008
00:30:13,046 --> 00:30:14,486
当用户在屏幕上

1009
00:30:14,486 --> 00:30:15,456
看到一个字形时

1010
00:30:15,456 --> 00:30:16,866
大多数用户

1011
00:30:16,866 --> 00:30:17,376
会认为那是一个字符

1012
00:30:18,576 --> 00:30:20,256
在 Swift 中 无论你

1013
00:30:20,256 --> 00:30:21,636
如何组合一个特定的

1014
00:30:22,096 --> 00:30:24,266
字形 它都是一个字符

1015
00:30:24,266 --> 00:30:25,556
两个不同组成却相对等的

1016
00:30:25,556 --> 00:30:26,986
字形相比较起来也是相等的

1017
00:30:27,586 --> 00:30:30,866
将字符串拆分

1018
00:30:30,866 --> 00:30:32,426
成字形的逻辑

1019
00:30:32,476 --> 00:30:33,366
可能相当复杂

1020
00:30:34,156 --> 00:30:36,146
例如 家庭表情符号

1021
00:30:36,146 --> 00:30:38,036
是由成人表情符号

1022
00:30:38,246 --> 00:30:39,026
和儿童表情符号组合而成的

1023
00:30:40,426 --> 00:30:41,846
在 Swift 4 中

1024
00:30:41,846 --> 00:30:43,256
因为我们使用的

1025
00:30:43,256 --> 00:30:44,296
是在操作系统中

1026
00:30:44,296 --> 00:30:45,906
构建的 Unicode 9

1027
00:30:45,906 --> 00:30:46,606
图形 所以把它记为一个字符

1028
00:30:47,226 --> 00:30:50,406
但这种复杂的逻辑

1029
00:30:50,406 --> 00:30:50,906
也来之不易

1030
00:30:51,206 --> 00:30:52,266
在之前版本的 Swift 中

1031
00:30:52,266 --> 00:30:53,526
你为每一个处理过的

1032
00:30:53,556 --> 00:30:55,346
字符都付出了

1033
00:30:55,346 --> 00:30:55,826
成本

1034
00:30:55,986 --> 00:30:56,886
即使是简单字符也是如此

1035
00:30:57,926 --> 00:30:59,296
在这个版本中

1036
00:30:59,296 --> 00:31:00,866
我们为许多

1037
00:30:59,296 --> 00:31:00,866
我们为许多

1038
00:31:00,866 --> 00:31:02,446
不同语言的简单字符

1039
00:31:02,446 --> 00:31:02,886
添加了快速通道

1040
00:31:04,216 --> 00:31:05,826
这意味着在字符串中

1041
00:31:05,826 --> 00:31:07,266
处理这些简单字符

1042
00:31:07,266 --> 00:31:08,656
所需要的时间

1043
00:31:08,656 --> 00:31:10,156
只有之前版本的

1044
00:31:10,216 --> 00:31:11,316
三分之一

1045
00:31:11,806 --> 00:31:14,206
这些快速通道

1046
00:31:14,206 --> 00:31:16,636
处理复杂字符串

1047
00:31:16,636 --> 00:31:17,146
十分得心应手

1048
00:31:17,506 --> 00:31:18,676
打个比方

1049
00:31:18,676 --> 00:31:19,866
如果你在社交媒体上

1050
00:31:19,866 --> 00:31:22,326
处理消息 那基本是

1051
00:31:22,326 --> 00:31:24,266
最简单的纯文本

1052
00:31:24,266 --> 00:31:25,776
还可能加上一些表情符号

1053
00:31:25,776 --> 00:31:26,996
我们在处理表情符号时

1054
00:31:26,996 --> 00:31:28,226
用的是更慢更复杂的方法

1055
00:31:28,226 --> 00:31:31,466
现在 让我们再来看看

1056
00:31:31,466 --> 00:31:33,476
这个 emoji 的例子

1057
00:31:33,776 --> 00:31:34,956
有两件事情

1058
00:31:34,956 --> 00:31:35,316
值得注意

1059
00:31:36,636 --> 00:31:38,996
第一件事是

1060
00:31:38,996 --> 00:31:39,826
字形宽度可调

1061
00:31:40,186 --> 00:31:41,616
所以我们显然不能

1062
00:31:41,616 --> 00:31:43,196
随机访问一个字符串中

1063
00:31:43,196 --> 00:31:43,696
特定的代码单元

1064
00:31:44,416 --> 00:31:45,716
我们可以对特定的

1065
00:31:45,716 --> 00:31:47,026
代码单元进行随机访问

1066
00:31:47,026 --> 00:31:48,306
当然你仍然可以使用

1067
00:31:48,306 --> 00:31:48,676
Swift 字符串进行访问

1068
00:31:50,336 --> 00:31:51,346
但这意味着什么

1069
00:31:51,346 --> 00:31:52,376
在这个例子中

1070
00:31:52,376 --> 00:31:54,096
它并不意味着

1071
00:31:54,096 --> 00:31:54,416
访问第五个代码单元

1072
00:31:54,766 --> 00:31:55,676
这肯定不是

1073
00:31:55,676 --> 00:31:56,096
第五个字符

1074
00:31:57,566 --> 00:31:58,826
另一件需要注意的事情

1075
00:31:58,826 --> 00:32:00,296
是这里有一些

1076
00:31:58,826 --> 00:32:00,296
是这里有一些

1077
00:32:00,296 --> 00:32:00,746
不寻常的行为

1078
00:32:00,746 --> 00:32:03,566
我们把六个项目

1079
00:32:03,566 --> 00:32:04,866
加到一个字符串里

1080
00:32:05,126 --> 00:32:06,206
但当我们结束时 计数并没有增加

1081
00:32:06,206 --> 00:32:07,926
这通常不是像数组

1082
00:32:07,926 --> 00:32:09,816
这样的其他集合

1083
00:32:09,816 --> 00:32:11,056
所期望的

1084
00:32:11,056 --> 00:32:13,696
正是因为存在这样的特殊情况

1085
00:32:13,696 --> 00:32:15,106
我们才发现

1086
00:32:15,106 --> 00:32:16,536
在之前的版本中

1087
00:32:16,536 --> 00:32:19,296
字符串不应该是集合

1088
00:32:19,456 --> 00:32:21,116
相反的 过去必须访问

1089
00:32:21,116 --> 00:32:24,366
作为字符串中

1090
00:32:24,366 --> 00:32:25,816
字符属性

1091
00:32:25,816 --> 00:32:26,886
的集合

1092
00:32:28,856 --> 00:32:30,676
但这实际上

1093
00:32:30,676 --> 00:32:32,046
没有帮助任何人

1094
00:32:32,046 --> 00:32:33,556
去理解这个问题

1095
00:32:33,906 --> 00:32:35,176
他所做的

1096
00:32:35,176 --> 00:32:35,576
一切都让代码变得混乱

1097
00:32:35,576 --> 00:32:37,366
它阻止人们从

1098
00:32:37,366 --> 00:32:38,786
字符的角度

1099
00:32:39,096 --> 00:32:40,306
思考和使用标准库

1100
00:32:40,306 --> 00:32:41,496
来进行

1101
00:32:41,496 --> 00:32:41,986
字符串处理

1102
00:32:42,986 --> 00:32:45,006
当然在 Swift 4 中

1103
00:32:45,006 --> 00:32:45,946
字符串是字符的集合

1104
00:32:45,946 --> 00:32:47,116
很大程度上可以帮助我们

1105
00:32:47,116 --> 00:32:48,346
清理代码 就像现在这样

1106
00:32:49,516 --> 00:32:54,696
[掌声]

1107
00:32:55,196 --> 00:32:56,076
还有一件事情我们

1108
00:32:56,076 --> 00:32:56,966
可以简化一下

1109
00:32:57,126 --> 00:32:58,166
在字符串处理中

1110
00:32:58,206 --> 00:32:59,806
想要按照索引分割

1111
00:32:59,806 --> 00:33:01,666
字符串是很常见的做法

1112
00:32:59,806 --> 00:33:01,666
字符串是很常见的做法

1113
00:33:03,026 --> 00:33:04,276
在 Swift 4 中

1114
00:33:04,276 --> 00:33:04,936
有一个简写

1115
00:33:05,036 --> 00:33:06,156
在你分割集合的

1116
00:33:06,156 --> 00:33:07,306
任何时间 你都可以

1117
00:33:07,306 --> 00:33:08,956
跳出这个集合

1118
00:33:08,956 --> 00:33:10,146
这意味着从索引

1119
00:33:10,146 --> 00:33:10,656
到集合的结束

1120
00:33:10,656 --> 00:33:12,526
从一开始

1121
00:33:12,526 --> 00:33:15,976
到索引结束

1122
00:33:16,336 --> 00:33:16,546
有着类似的语法

1123
00:33:16,546 --> 00:33:18,096
制作字符串集合

1124
00:33:18,096 --> 00:33:19,146
意味着你可以在

1125
00:33:19,146 --> 00:33:19,916
其它集合中

1126
00:33:19,916 --> 00:33:21,286
使用它们的全部功能

1127
00:33:21,286 --> 00:33:23,106
因此 你可以压缩 映射

1128
00:33:23,106 --> 00:33:23,256
搜索或过滤他们

1129
00:33:24,196 --> 00:33:25,396
这使得构建字符串

1130
00:33:25,396 --> 00:33:26,606
处理变得更为简单

1131
00:33:27,626 --> 00:33:28,496
我们来看一个例子

1132
00:33:30,016 --> 00:33:31,266
假设你想要检测你的

1133
00:33:31,506 --> 00:33:33,486
应用的信息中

1134
00:33:33,746 --> 00:33:34,976
是否有国旗

1135
00:33:34,976 --> 00:33:37,086
来触发一些逻辑

1136
00:33:38,436 --> 00:33:40,506
Unicode 里的国旗

1137
00:33:40,506 --> 00:33:41,926
是由一对对特殊的区域

1138
00:33:41,926 --> 00:33:43,296
指示器组成的 这些

1139
00:33:43,296 --> 00:33:44,656
区域指示器将显示出

1140
00:33:44,746 --> 00:33:45,066
国旗的 ISO 国家代码

1141
00:33:45,356 --> 00:33:46,376
举个例子 日本国旗的

1142
00:33:46,376 --> 00:33:47,316
ISO 代码是 JNP.

1143
00:33:47,316 --> 00:33:49,626
我们可以为 Unicode

1144
00:33:49,626 --> 00:33:51,066
定标器添加一个拓展

1145
00:33:51,066 --> 00:33:52,256
以便能够检测到它是否是

1146
00:33:52,256 --> 00:33:53,586
这些特殊区域指示器之一

1147
00:33:54,266 --> 00:33:58,276
接下来我们可以

1148
00:33:58,276 --> 00:34:00,116
拓展字符以检测

1149
00:33:58,276 --> 00:34:00,116
拓展字符以检测

1150
00:34:00,116 --> 00:34:01,306
字符是否为国旗

1151
00:34:02,276 --> 00:34:03,426
这是 Swift 4 中

1152
00:34:03,426 --> 00:34:04,746
可供使用的新特性

1153
00:34:04,746 --> 00:34:06,146
这允许你访问构成

1154
00:34:06,146 --> 00:34:07,736
图形底层的

1155
00:34:07,736 --> 00:34:08,156
Unicode 标量

1156
00:34:08,726 --> 00:34:10,686
如果你想了解

1157
00:34:10,686 --> 00:34:11,976
Unicode 是如何工作的

1158
00:34:11,976 --> 00:34:13,065
特别是在 Swift 平台上

1159
00:34:13,065 --> 00:34:14,606
他是如何运作的

1160
00:34:14,606 --> 00:34:15,406
这是一件十分有意思的事情

1161
00:34:18,295 --> 00:34:19,335
现在有了 Swift 4

1162
00:34:19,335 --> 00:34:20,545
我们可以用它来使用

1163
00:34:20,886 --> 00:34:21,795
所有熟悉的 API 集合

1164
00:34:21,996 --> 00:34:23,656
因此我们可以搜索一个字符串

1165
00:34:23,656 --> 00:34:24,516
是否含有特定标志

1166
00:34:25,376 --> 00:34:27,226
或者我们可以见这些标志

1167
00:34:27,226 --> 00:34:28,676
过滤后形成一个新字符串

1168
00:34:28,835 --> 00:34:32,726
现在这些字符串是集合了

1169
00:34:32,726 --> 00:34:34,136
你可能会注意到

1170
00:34:34,136 --> 00:34:35,295
他们有了一个新的方法

1171
00:34:35,536 --> 00:34:35,916
分割

1172
00:34:36,136 --> 00:34:37,275
这是一个现有的

1173
00:34:37,275 --> 00:34:37,735
收集方法

1174
00:34:38,976 --> 00:34:41,106
他将一个一个字符串

1175
00:34:41,106 --> 00:34:42,116
分割包含多段的数组

1176
00:34:42,966 --> 00:34:44,775
但如果你在 Swift 上运行它

1177
00:34:44,835 --> 00:34:46,166
你会注意到它

1178
00:34:46,166 --> 00:34:47,516
不会返回一个

1179
00:34:47,516 --> 00:34:47,956
字符串数组

1180
00:34:49,556 --> 00:34:50,996
用于 字符串的 Swift 4

1181
00:34:50,996 --> 00:34:52,726
段类型是子字符串

1182
00:34:53,946 --> 00:34:54,815
那么我们为什么

1183
00:34:54,815 --> 00:34:55,536
要给他一个不同的类型呢

1184
00:34:56,786 --> 00:34:58,346
在决定如何对集合进行

1185
00:34:58,346 --> 00:34:59,446
分段时 需要进行

1186
00:34:59,446 --> 00:35:01,526
一些基本的

1187
00:34:59,446 --> 00:35:01,526
一些基本的

1188
00:35:01,526 --> 00:35:02,726
工程权衡

1189
00:35:04,536 --> 00:35:05,306
当你对一个集合

1190
00:35:05,306 --> 00:35:06,586
进行分段时

1191
00:35:06,636 --> 00:35:08,126
它是否应该对正在

1192
00:35:08,126 --> 00:35:10,896
分段的内容创建一个副本

1193
00:35:11,136 --> 00:35:13,316
或者是否应该将

1194
00:35:13,426 --> 00:35:14,586
一个视图返回到

1195
00:35:14,586 --> 00:35:17,556
原始集合的内部存储中

1196
00:35:17,556 --> 00:35:19,616
从性能的角度来看

1197
00:35:19,616 --> 00:35:20,396
共享存储显然要快得多

1198
00:35:21,326 --> 00:35:22,366
正如 Bob 前面所提到的

1199
00:35:22,426 --> 00:35:24,686
分配和跟踪堆内容

1200
00:35:24,686 --> 00:35:26,196
可能会非常昂贵

1201
00:35:26,516 --> 00:35:27,926
你可能会至少花费

1202
00:35:27,926 --> 00:35:29,326
一半的时间在类似

1203
00:35:29,326 --> 00:35:31,116
分类 制作副本的操作中

1204
00:35:32,116 --> 00:35:34,456
而且 如果分段需要

1205
00:35:34,456 --> 00:35:35,866
线性时间 因为我们复制

1206
00:35:35,866 --> 00:35:37,166
内容的副本

1207
00:35:37,816 --> 00:35:39,786
执行分段操作

1208
00:35:39,786 --> 00:35:40,926
的循环可能意外

1209
00:35:40,926 --> 00:35:42,226
需要二次方时间

1210
00:35:42,496 --> 00:35:43,786
而不是在你期望的

1211
00:35:43,866 --> 00:35:44,986
线性时间

1212
00:35:46,526 --> 00:35:47,756
这就是在连续的时间里

1213
00:35:47,756 --> 00:35:49,426
对 Swift 中需要的

1214
00:35:49,426 --> 00:35:50,596
任何集合进行分段

1215
00:35:52,476 --> 00:35:53,906
但是我们所采用的

1216
00:35:53,906 --> 00:35:55,636
共享存储方法

1217
00:35:55,636 --> 00:35:56,116
同样也有缺点

1218
00:35:56,246 --> 00:35:57,516
为了弄明白这是什么

1219
00:35:58,056 --> 00:35:59,056
让我们来看看字符串

1220
00:35:59,056 --> 00:36:00,406
的内部实现

1221
00:35:59,056 --> 00:36:00,406
的内部实现

1222
00:36:01,876 --> 00:36:04,856
所以 当前 Swift

1223
00:36:04,856 --> 00:36:06,026
字符串内部

1224
00:36:06,026 --> 00:36:06,506
由三个属性组成

1225
00:36:07,646 --> 00:36:08,766
他们有一个指向

1226
00:36:08,766 --> 00:36:09,196
缓冲区开始处的指针

1227
00:36:10,076 --> 00:36:11,066
他们有缓冲区中

1228
00:36:11,066 --> 00:36:12,476
代码单元的数量

1229
00:36:12,606 --> 00:36:14,086
并且他们有一个

1230
00:36:14,086 --> 00:36:14,836
指向所有者对象的引用

1231
00:36:15,696 --> 00:36:17,196
所有者对象负责

1232
00:36:17,196 --> 00:36:18,526
跟踪和管理

1233
00:36:18,526 --> 00:36:18,846
缓冲区

1234
00:36:18,966 --> 00:36:20,216
在其他的集合上

1235
00:36:20,216 --> 00:36:21,316
作也采用

1236
00:36:21,316 --> 00:36:22,376
类似的模式

1237
00:36:24,306 --> 00:36:25,826
当原始的字符串

1238
00:36:25,826 --> 00:36:28,946
结构被破坏时

1239
00:36:28,946 --> 00:36:30,116
引用计数和所有者对象

1240
00:36:30,166 --> 00:36:31,896
会降为零 类中的

1241
00:36:31,896 --> 00:36:33,696
存储也会释放缓存区

1242
00:36:35,276 --> 00:36:36,626
现在让我们来看看

1243
00:36:36,626 --> 00:36:37,816
创建子字符串时

1244
00:36:37,926 --> 00:36:38,396
会发生什么

1245
00:36:39,066 --> 00:36:42,066
假设我们把 well 这个词

1246
00:36:42,066 --> 00:36:43,456
从原来的字符串

1247
00:36:43,456 --> 00:36:43,736
中切掉了

1248
00:36:45,176 --> 00:36:47,546
子字符串有一个

1249
00:36:47,546 --> 00:36:49,446
指向 W 的开始

1250
00:36:49,446 --> 00:36:51,656
他的计数范围是 5

1251
00:36:51,656 --> 00:36:53,136
并且所有者是对原始

1252
00:36:53,136 --> 00:36:54,146
字符串所有者的共享引用

1253
00:36:55,506 --> 00:36:56,486
现在来看看当原始

1254
00:36:56,486 --> 00:36:58,576
字符串溢出时

1255
00:36:59,496 --> 00:36:59,706
会发生什么

1256
00:37:00,526 --> 00:37:01,796
所有者的引用计数

1257
00:37:01,796 --> 00:37:03,636
会被减少 但不会遭到

1258
00:37:03,636 --> 00:37:04,546
破坏 因为它是由

1259
00:37:04,546 --> 00:37:05,526
子字符串共享的

1260
00:37:05,526 --> 00:37:06,806
因此 缓存区并没有被释放

1261
00:37:07,156 --> 00:37:08,496
这样就很棒 因为

1262
00:37:08,496 --> 00:37:09,556
子字符串依赖于

1263
00:37:09,556 --> 00:37:09,756
缓冲区

1264
00:37:09,756 --> 00:37:12,236
但是整个缓冲区

1265
00:37:12,236 --> 00:37:12,606
依然存在

1266
00:37:12,816 --> 00:37:14,296
不是只有这个部分

1267
00:37:14,296 --> 00:37:14,946
它所依赖的子字符串也是这样

1268
00:37:16,436 --> 00:37:17,496
现在这种情况

1269
00:37:17,496 --> 00:37:18,516
没什么大不了的

1270
00:37:18,516 --> 00:37:19,006
这只是几个字符

1271
00:37:19,696 --> 00:37:20,846
但这真的是个问题

1272
00:37:22,886 --> 00:37:24,626
假设你从网上下载了

1273
00:37:24,626 --> 00:37:25,816
一个巨大的文本

1274
00:37:26,596 --> 00:37:28,046
然后对其中的一小部分

1275
00:37:28,046 --> 00:37:29,636
分段 并将其分配

1276
00:37:29,636 --> 00:37:31,796
给一些长期的变量

1277
00:37:32,126 --> 00:37:33,116
比如 UI 标签

1278
00:37:34,216 --> 00:37:35,496
这看起来更像是

1279
00:37:35,496 --> 00:37:36,116
内存泄漏

1280
00:37:36,716 --> 00:37:38,046
因为原始文件

1281
00:37:38,046 --> 00:37:39,686
的缓冲区

1282
00:37:39,686 --> 00:37:40,066
永远不会被释放

1283
00:37:41,166 --> 00:37:42,206
这是 JAVA 中存在的

1284
00:37:42,206 --> 00:37:43,456
一个大问题 他们在几年前

1285
00:37:43,456 --> 00:37:45,036
改变了对字符串进行

1286
00:37:45,036 --> 00:37:47,346
分段的方法

1287
00:37:47,346 --> 00:37:48,236
以方便它进行复制

1288
00:37:49,566 --> 00:37:50,676
但正如我们看到的那样

1289
00:37:50,676 --> 00:37:51,806
这有一个性能上的缺点

1290
00:37:51,806 --> 00:37:52,916
我们并不一定要做出

1291
00:37:53,006 --> 00:37:53,706
这样的牺牲

1292
00:37:54,646 --> 00:37:55,896
在 Swift 中这样的

1293
00:37:55,896 --> 00:37:57,686
问题解决方案

1294
00:37:57,776 --> 00:37:58,446
是使用类型

1295
00:37:59,166 --> 00:38:00,746
这就是为什么子字符串

1296
00:37:59,166 --> 00:38:00,746
这就是为什么子字符串

1297
00:38:00,746 --> 00:38:01,856
是字符串的不同类型

1298
00:38:02,866 --> 00:38:04,486
现在 当你在原始的

1299
00:38:04,486 --> 00:38:06,086
大字符串上执行分段操作时

1300
00:38:06,086 --> 00:38:07,896
你最终会想

1301
00:38:07,896 --> 00:38:09,316
将一个子字符串

1302
00:38:09,356 --> 00:38:10,986
分配给一个字符串

1303
00:38:10,986 --> 00:38:12,186
编译器会告诉你它的情况

1304
00:38:13,456 --> 00:38:14,686
如果你是用修复程序

1305
00:38:14,686 --> 00:38:16,736
它会建议并新建一个

1306
00:38:16,736 --> 00:38:18,836
新的字符串

1307
00:38:18,836 --> 00:38:20,216
这只会复制你分段的

1308
00:38:20,216 --> 00:38:21,246
部分缓冲区

1309
00:38:22,286 --> 00:38:23,556
这允许原缓冲区

1310
00:38:23,556 --> 00:38:25,916
溢出并

1311
00:38:26,896 --> 00:38:27,666
释放

1312
00:38:28,516 --> 00:38:33,286
[掌声]

1313
00:38:33,786 --> 00:38:35,706
现在我们有两种

1314
00:38:35,706 --> 00:38:36,056
不同的类型

1315
00:38:36,056 --> 00:38:37,056
你可能会问我一个问题

1316
00:38:37,056 --> 00:38:38,606
那就是什么时候该在我的代码中

1317
00:38:38,606 --> 00:38:38,736
使用子字符串

1318
00:38:38,736 --> 00:38:40,856
回答是 我无法告诉你

1319
00:38:40,856 --> 00:38:42,756
具体的情况

1320
00:38:43,306 --> 00:38:45,596
在定义接口 比如

1321
00:38:45,596 --> 00:38:47,216
类型或属性的方式时

1322
00:38:47,686 --> 00:38:49,096
你应该偏向使用字符串

1323
00:38:49,856 --> 00:38:51,126
既避免了我们刚刚谈到的

1324
00:38:51,126 --> 00:38:52,696
内存泄漏的问题

1325
00:38:52,696 --> 00:38:54,336
同时也是因为字符串

1326
00:38:54,336 --> 00:38:55,796
是我们所谓的通用类型

1327
00:38:56,036 --> 00:38:56,916
这是每个人都希望

1328
00:38:56,916 --> 00:38:58,446
在 API 中看到的类型

1329
00:39:00,076 --> 00:39:01,386
大部分情况下

1330
00:39:01,386 --> 00:39:03,176
你遇到子字符串类型

1331
00:39:03,176 --> 00:39:04,676
的唯一可能性是

1332
00:39:04,676 --> 00:39:05,566
执行分段操作时

1333
00:39:06,076 --> 00:39:07,726
因为 Swift 使用

1334
00:39:07,786 --> 00:39:09,186
类型推断 你并不会为

1335
00:39:09,186 --> 00:39:10,596
所有的子类型命名

1336
00:39:12,196 --> 00:39:13,706
子字符串有许多

1337
00:39:13,706 --> 00:39:14,856
普通字符串相同的

1338
00:39:14,856 --> 00:39:15,586
方式和属性

1339
00:39:15,936 --> 00:39:17,666
所以即使你没有

1340
00:39:17,666 --> 00:39:19,606
命名类型为一个子字符串

1341
00:39:19,686 --> 00:39:20,806
大部分的代码在运行时

1342
00:39:20,896 --> 00:39:22,686
依然会把它当作

1343
00:39:22,686 --> 00:39:23,056
字符串来处理

1344
00:39:24,066 --> 00:39:25,196
如果你只进行

1345
00:39:25,196 --> 00:39:26,036
本地操作 那么你

1346
00:39:26,036 --> 00:39:26,836
实际上不需要创建字符串

1347
00:39:26,836 --> 00:39:28,336
那么这种情况

1348
00:39:28,336 --> 00:39:29,296
就可以被完全避免掉

1349
00:39:31,866 --> 00:39:32,656
好的 这差不多就是

1350
00:39:32,656 --> 00:39:33,026
我想讲的关于字符串的内容

1351
00:39:33,386 --> 00:39:34,526
我还想再谈谈

1352
00:39:34,526 --> 00:39:34,976
最后一个特性

1353
00:39:34,976 --> 00:39:36,266
那就是

1354
00:39:36,266 --> 00:39:36,656
多行字符串

1355
00:39:37,616 --> 00:39:38,916
之前 写这些东西

1356
00:39:38,916 --> 00:39:39,586
真的很痛苦

1357
00:39:39,726 --> 00:39:41,256
你必须去写一个

1358
00:39:41,256 --> 00:39:42,776
又大又长的字符串

1359
00:39:42,846 --> 00:39:43,516
在最后以斜线结尾

1360
00:39:44,606 --> 00:39:46,606
Swift 4 引入了

1361
00:39:46,606 --> 00:39:47,426
三引号语法

1362
00:39:48,676 --> 00:39:49,876
你可以使用三引号语法

1363
00:39:49,876 --> 00:39:50,556
来编写多行字符串

1364
00:39:51,516 --> 00:39:56,906
[掌声]

1365
00:39:57,406 --> 00:39:58,416
然后你用

1366
00:39:58,416 --> 00:39:58,946
三个引号结束它

1367
00:39:59,606 --> 00:40:01,316
结束三引号

1368
00:39:59,606 --> 00:40:01,316
结束三引号

1369
00:40:01,316 --> 00:40:02,966
的缩进决定了

1370
00:40:03,446 --> 00:40:04,936
多行字符串

1371
00:40:04,936 --> 00:40:05,976
每一行的缩进

1372
00:40:06,546 --> 00:40:08,856
在这里可以看到的是

1373
00:40:08,856 --> 00:40:09,996
因为我们把文字 

1374
00:40:09,996 --> 00:40:10,866
放入了一个函数中

1375
00:40:10,866 --> 00:40:12,086
我希望它能够很好的缩进

1376
00:40:12,086 --> 00:40:13,596
来匹配我们代码

1377
00:40:13,596 --> 00:40:13,716
其余部分的格式

1378
00:40:14,586 --> 00:40:15,706
这里的规则是

1379
00:40:15,706 --> 00:40:16,956
无论你在结束引号中

1380
00:40:16,996 --> 00:40:18,576
使用什么缩进

1381
00:40:18,576 --> 00:40:20,136
你必须在字符串的

1382
00:40:20,136 --> 00:40:21,936
每一行中都保持

1383
00:40:21,936 --> 00:40:22,266
同样的缩进

1384
00:40:23,076 --> 00:40:24,596
然后当代码

1385
00:40:25,546 --> 00:40:27,356
编译完成时

1386
00:40:28,236 --> 00:40:28,326
就会去掉缩进

1387
00:40:29,436 --> 00:40:30,806
这真是一个很棒的特征

1388
00:40:30,806 --> 00:40:31,636
其中一件很酷的事情

1389
00:40:31,636 --> 00:40:33,006
就是他是由 Swift

1390
00:40:33,006 --> 00:40:35,696
开源社区的

1391
00:40:35,696 --> 00:40:36,896
外部成员

1392
00:40:36,896 --> 00:40:38,036
提出和实施的

1393
00:40:39,516 --> 00:40:45,106
[掌声]

1394
00:40:45,606 --> 00:40:46,396
这就是对字符串的介绍

1395
00:40:46,396 --> 00:40:47,326
现在让我们来探讨一些

1396
00:40:47,326 --> 00:40:48,366
新的泛型特征

1397
00:40:49,516 --> 00:40:50,756
在 Swift 的每一个版本中

1398
00:40:50,756 --> 00:40:52,506
我你们都在改进

1399
00:40:52,576 --> 00:40:52,916
通用系统

1400
00:40:53,136 --> 00:40:54,406
它不仅仅变得更强大

1401
00:40:55,116 --> 00:40:56,766
而且用途更广

1402
00:40:56,936 --> 00:40:57,606
更易操作

1403
00:40:57,986 --> 00:40:59,396
例如在 Swift 2 中

1404
00:40:59,396 --> 00:41:00,356
推出的协议拓展

1405
00:40:59,396 --> 00:41:00,356
推出的协议拓展

1406
00:41:01,576 --> 00:41:03,616
在这个版本中

1407
00:41:03,616 --> 00:41:04,866
我们将介绍

1408
00:41:05,556 --> 00:41:06,846
两个特性

1409
00:41:06,846 --> 00:41:09,466
即关联类型和通用子脚本的子句

1410
00:41:10,016 --> 00:41:10,806
我将向你们展示

1411
00:41:10,806 --> 00:41:12,176
几个例子 有关

1412
00:41:12,176 --> 00:41:13,016
我们如何在标准库中

1413
00:41:13,016 --> 00:41:14,356
使用它们 以及

1414
00:41:14,356 --> 00:41:15,376
在你们的代码中

1415
00:41:15,406 --> 00:41:17,006
应当如何使用他们

1416
00:41:18,256 --> 00:41:20,386
所以 假设你想要

1417
00:41:20,386 --> 00:41:22,176
检测一个序列的

1418
00:41:22,176 --> 00:41:24,276
每一个元素是否

1419
00:41:24,276 --> 00:41:25,106
等于一个特定的值

1420
00:41:26,166 --> 00:41:27,806
你可以使用一个

1421
00:41:27,806 --> 00:41:28,946
已经包含在序列中的

1422
00:41:28,946 --> 00:41:29,366
方式来完成这个操作

1423
00:41:29,716 --> 00:41:31,486
但是这段代码有些笨拙

1424
00:41:31,876 --> 00:41:33,546
你写的这个序列

1425
00:41:33,726 --> 00:41:35,766
不可以包含任何

1426
00:41:35,766 --> 00:41:36,536
不等于这个值的元素

1427
00:41:37,656 --> 00:41:38,676
如果你一次又一次的

1428
00:41:38,676 --> 00:41:39,506
重写它 那这可能会

1429
00:41:39,506 --> 00:41:41,036
非常恼人 所以

1430
00:41:41,036 --> 00:41:42,526
协议拓展给你提供了

1431
00:41:42,526 --> 00:41:44,146
一种很好的方式

1432
00:41:44,146 --> 00:41:46,046
封装代码 就像现在这样

1433
00:41:46,046 --> 00:41:46,846
这会使你的代码变得整洁

1434
00:41:47,996 --> 00:41:49,786
因此 我们可以将这段代码

1435
00:41:49,786 --> 00:41:51,686
封装在一个序列的拓展中

1436
00:41:51,686 --> 00:41:52,706
这样我们就可以

1437
00:41:52,706 --> 00:41:53,566
更容易的调用它了

1438
00:41:55,026 --> 00:41:56,796
现在当你像这样

1439
00:41:56,796 --> 00:41:58,326
拓展序列时 有一件事情

1440
00:41:58,326 --> 00:41:59,536
有些不讨人喜欢

1441
00:41:59,536 --> 00:42:01,056
过去你需要

1442
00:41:59,536 --> 00:42:01,056
过去你需要

1443
00:42:01,086 --> 00:42:03,146
写一个迭代器元素

1444
00:42:03,146 --> 00:42:04,266
来说明

1445
00:42:04,266 --> 00:42:05,256
序列元素的类型

1446
00:42:06,306 --> 00:42:08,116
在 Swift 4 中

1447
00:42:08,116 --> 00:42:08,506
你可以不用迭代器了

1448
00:42:08,506 --> 00:42:10,796
因为序列有它

1449
00:42:10,856 --> 00:42:11,706
自己的元素类型

1450
00:42:13,006 --> 00:42:13,786
这似乎是我们

1451
00:42:13,786 --> 00:42:15,356
添加的一个非常

1452
00:42:15,356 --> 00:42:15,486
简单的特性

1453
00:42:15,486 --> 00:42:16,706
但是如果没有

1454
00:42:17,016 --> 00:42:18,506
约束相关类型的能力

1455
00:42:18,506 --> 00:42:19,466
我们实际上是我无法做到的

1456
00:42:19,516 --> 00:42:20,396
我将告诉你该怎么做

1457
00:42:22,026 --> 00:42:23,626
因此 在 Swift 3 中

1458
00:42:23,626 --> 00:42:25,576
我们有一个协议序列

1459
00:42:25,576 --> 00:42:26,916
它又有一个与之相关的类型迭代器

1460
00:42:27,526 --> 00:42:28,756
迭代器为元素提供了

1461
00:42:28,756 --> 00:42:30,136
一个相关的类型

1462
00:42:30,816 --> 00:42:33,856
在 Swift 4 中 我们添加了

1463
00:42:33,856 --> 00:42:36,736
相关联的类型元素

1464
00:42:37,246 --> 00:42:38,856
然后在迭代器关联类型中

1465
00:42:38,856 --> 00:42:40,916
添加 where 子句

1466
00:42:40,916 --> 00:42:43,026
以要求其元素

1467
00:42:43,106 --> 00:42:44,536
与序列元素相同

1468
00:42:45,366 --> 00:42:46,336
否则他们就会失去同步

1469
00:42:46,336 --> 00:42:47,426
并由此产生一些

1470
00:42:47,426 --> 00:42:47,976
问题

1471
00:42:49,276 --> 00:42:50,326
我们已经在标准库中的

1472
00:42:50,326 --> 00:42:51,656
几个地方使用过这个了

1473
00:42:52,396 --> 00:42:54,366
例如 以前没有保证

1474
00:42:54,366 --> 00:42:55,996
子序列的元素

1475
00:42:55,996 --> 00:42:58,006
与序列元素

1476
00:42:58,006 --> 00:42:59,266
的类型

1477
00:42:59,266 --> 00:42:59,736
是相同的

1478
00:43:00,646 --> 00:43:01,896
没有人想要写一个

1479
00:43:01,896 --> 00:43:03,006
不是案例的

1480
00:43:03,006 --> 00:43:03,336
序列

1481
00:43:03,666 --> 00:43:05,026
这根本不能用

1482
00:43:05,286 --> 00:43:06,746
但我们的编译器无法保证

1483
00:43:06,746 --> 00:43:08,356
这种事情不会发生

1484
00:43:08,356 --> 00:43:09,846
因为我们无法用

1485
00:43:09,846 --> 00:43:10,376
编程语言来表述它

1486
00:43:11,146 --> 00:43:12,806
现在 有了相关类型的

1487
00:43:12,806 --> 00:43:14,596
where 子句 我们就可以

1488
00:43:14,596 --> 00:43:15,276
做出这个保证了

1489
00:43:16,826 --> 00:43:18,016
那么这对你的代码

1490
00:43:18,016 --> 00:43:18,256
意味着什么呢

1491
00:43:19,866 --> 00:43:21,056
如果你已经拓展了

1492
00:43:21,086 --> 00:43:22,436
序列或者集合

1493
00:43:22,436 --> 00:43:23,936
你可能会发现

1494
00:43:23,936 --> 00:43:25,016
你不得不把这些看似

1495
00:43:25,016 --> 00:43:26,736
不必要的 where 子句

1496
00:43:26,736 --> 00:43:29,156
添加到你的扩展中去

1497
00:43:29,156 --> 00:43:30,196
这为了保证它能够被翻译

1498
00:43:30,196 --> 00:43:31,696
因为代码本身

1499
00:43:31,696 --> 00:43:33,736
依靠的是协议不能

1500
00:43:33,846 --> 00:43:34,606
保证的东西

1501
00:43:35,966 --> 00:43:37,966
现在 我们做了前几页

1502
00:43:37,966 --> 00:43:38,686
幻灯片中所做的事情

1503
00:43:38,686 --> 00:43:40,546
所以它现在可以

1504
00:43:40,546 --> 00:43:41,206
得到保证

1505
00:43:41,206 --> 00:43:43,496
因此 你会得到警告

1506
00:43:43,796 --> 00:43:44,816
告诉你现在存在

1507
00:43:44,876 --> 00:43:45,986
多余的约束

1508
00:43:47,096 --> 00:43:48,726
这些在 Swift 3

1509
00:43:48,726 --> 00:43:50,276
和 Swift 4 模式下都只是警告

1510
00:43:50,276 --> 00:43:51,616
他们只是告诉你这些

1511
00:43:51,616 --> 00:43:53,176
都是不必要的

1512
00:43:53,676 --> 00:43:55,126
你可以用自己的方式

1513
00:43:55,126 --> 00:43:56,926
来使你的代码变得更整洁

1514
00:43:58,056 --> 00:43:59,326
现在 关于我们添加的

1515
00:43:59,326 --> 00:44:00,666
这些新约束 还有几件事情

1516
00:43:59,326 --> 00:44:00,666
这些新约束 还有几件事情

1517
00:44:00,666 --> 00:44:01,186
需要我们来了解一下

1518
00:44:01,276 --> 00:44:02,746
在 Swift 3.2 模式中

1519
00:44:02,746 --> 00:44:04,476
这是少数几件

1520
00:44:04,476 --> 00:44:05,896
没有向后兼容的

1521
00:44:05,896 --> 00:44:06,796
事情

1522
00:44:07,436 --> 00:44:09,036
因为协议特性

1523
00:44:09,116 --> 00:44:10,186
必须在整个流程中

1524
00:44:10,186 --> 00:44:11,186
保持一致

1525
00:44:12,546 --> 00:44:13,566
因此 如果你编写了

1526
00:44:13,566 --> 00:44:15,216
自定义的集合类型

1527
00:44:15,546 --> 00:44:17,186
这可能会有悖

1528
00:44:17,186 --> 00:44:18,786
一些约束 那么在

1529
00:44:18,846 --> 00:44:20,266
使用新的编译器之前

1530
00:44:20,266 --> 00:44:21,236
你必须首先

1531
00:44:21,236 --> 00:44:21,746
解决这个问题

1532
00:44:22,686 --> 00:44:24,076
我们认为这种事情

1533
00:44:24,146 --> 00:44:24,846
发生的几率不高

1534
00:44:25,086 --> 00:44:26,666
这通常是由疏忽导致的

1535
00:44:26,666 --> 00:44:28,136
而且也很容易解决

1536
00:44:28,166 --> 00:44:29,346
但是如果不是因为疏忽

1537
00:44:29,346 --> 00:44:31,006
那就值得警惕了

1538
00:44:32,716 --> 00:44:34,296
最后 我们来谈一谈

1539
00:44:34,296 --> 00:44:35,166
一般的子脚本

1540
00:44:36,076 --> 00:44:37,516
在之前 我们看到了一个

1541
00:44:37,516 --> 00:44:38,876
单项范围语法的例子

1542
00:44:39,666 --> 00:44:40,536
那么我们是如何在

1543
00:44:40,536 --> 00:44:41,896
标准库内部

1544
00:44:41,896 --> 00:44:42,676
来实现这个的呢

1545
00:44:42,676 --> 00:44:47,376
首先 有一个新的

1546
00:44:47,566 --> 00:44:48,596
类型部分范围

1547
00:44:49,116 --> 00:44:50,106
它看起来像是

1548
00:44:50,106 --> 00:44:51,696
一个普通的范围

1549
00:44:51,696 --> 00:44:51,996
但它边界较低

1550
00:44:52,646 --> 00:44:55,956
接下来有一个

1551
00:44:55,956 --> 00:44:57,636
协议范围表达式

1552
00:44:57,636 --> 00:44:59,206
我们用它来统一所有

1553
00:44:59,206 --> 00:45:00,036
不同种类的范围类型

1554
00:44:59,206 --> 00:45:00,036
不同种类的范围类型

1555
00:45:00,776 --> 00:45:01,856
它有一种方式

1556
00:45:01,856 --> 00:45:03,996
那就是用一个集合

1557
00:45:03,996 --> 00:45:05,586
将任何范围内的表达式

1558
00:45:05,586 --> 00:45:07,176
转化为可供分段的

1559
00:45:07,176 --> 00:45:08,006
具体范围类型

1560
00:45:08,626 --> 00:45:11,936
例如 部分从

1561
00:45:12,096 --> 00:45:13,776
使用集合开始

1562
00:45:14,006 --> 00:45:15,376
一直到填充

1563
00:45:15,376 --> 00:45:15,716
缺失上界结束

1564
00:45:16,426 --> 00:45:19,586
现在有了这个协议之后

1565
00:45:19,776 --> 00:45:21,566
我们可以用一个

1566
00:45:21,566 --> 00:45:23,876
通用的子脚本扩展字符串

1567
00:45:23,956 --> 00:45:25,656
它将接受任何类型的

1568
00:45:25,656 --> 00:45:27,406
范围表达式 并用它

1569
00:45:27,406 --> 00:45:28,526
来对子字符串进行分段

1570
00:45:30,346 --> 00:45:31,316
现在字符串是集合了

1571
00:45:31,316 --> 00:45:33,176
实际上我们可以把

1572
00:45:33,176 --> 00:45:34,776
这个特性直接

1573
00:45:34,776 --> 00:45:35,276
放在集合上

1574
00:45:35,276 --> 00:45:37,026
这可能包含了

1575
00:45:37,026 --> 00:45:38,066
你编写的任意自定义集合

1576
00:45:38,066 --> 00:45:39,456
我们可以通过协议

1577
00:45:39,686 --> 00:45:41,386
来自动使用这个功能

1578
00:45:43,006 --> 00:45:44,016
事实上我们可以用

1579
00:45:44,016 --> 00:45:45,366
这种方式来清理

1580
00:45:45,366 --> 00:45:46,696
标准库中的许多代码

1581
00:45:46,696 --> 00:45:47,636
因为我们可以将所有

1582
00:45:47,636 --> 00:45:49,446
重复的分段操作移除

1583
00:45:49,446 --> 00:45:50,806
因为我们需要为

1584
00:45:50,806 --> 00:45:51,906
每个不同的范围类型硬编码

1585
00:45:51,906 --> 00:45:53,426
因为我们希望用一个

1586
00:45:53,426 --> 00:45:54,926
通用的子脚本替换它们

1587
00:45:55,496 --> 00:45:56,746
我们也希望你可以

1588
00:45:56,746 --> 00:45:58,356
找到类似的方法

1589
00:45:58,356 --> 00:46:01,176
来清理你的代码

1590
00:45:58,356 --> 00:46:01,176
来清理你的代码

1591
00:46:01,676 --> 00:46:02,396
其实还有一些

1592
00:46:02,396 --> 00:46:03,506
我今天来不及介绍的

1593
00:46:03,506 --> 00:46:04,866
新功能 比如一些

1594
00:46:04,866 --> 00:46:05,796
新的数字协议

1595
00:46:06,156 --> 00:46:06,956
还有一些对

1596
00:46:06,956 --> 00:46:08,116
字典类型

1597
00:46:08,186 --> 00:46:08,386
非常棒的改进

1598
00:46:09,506 --> 00:46:11,086
我们添加到东西之一

1599
00:46:11,086 --> 00:46:12,866
是一个集合的新形式

1600
00:46:12,866 --> 00:46:14,206
允许你在集合中

1601
00:46:14,386 --> 00:46:16,006
交换两个元素

1602
00:46:16,006 --> 00:46:17,296
给定两个索引

1603
00:46:17,296 --> 00:46:18,966
而不是使用全局函数

1604
00:46:18,966 --> 00:46:19,736
将两个参数输出

1605
00:46:21,046 --> 00:46:22,376
这是为了支持一个

1606
00:46:22,376 --> 00:46:24,206
新的独占访问内存

1607
00:46:24,206 --> 00:46:25,526
的功能

1608
00:46:25,526 --> 00:46:26,276
John 下面会详细介绍

1609
00:46:27,516 --> 00:46:34,266
[掌声]

1610
00:46:34,766 --> 00:46:35,486
&gt;&gt; 谢谢你 Ben

1611
00:46:36,026 --> 00:46:37,316
谢谢

1612
00:46:38,616 --> 00:46:40,556
对内存的独占访问是

1613
00:46:40,556 --> 00:46:42,126
我们在 Swift 4 中

1614
00:46:42,126 --> 00:46:42,966
添加的一条新规则

1615
00:46:43,636 --> 00:46:46,896
这实际上是我们

1616
00:46:46,896 --> 00:46:48,556
称之为所有权的

1617
00:46:48,716 --> 00:46:49,236
更大特征的一部分

1618
00:46:49,946 --> 00:46:51,666
所有权的目的是

1619
00:46:51,666 --> 00:46:53,196
为了让你更容易

1620
00:46:53,196 --> 00:46:54,986
理解程序的性能

1621
00:46:55,826 --> 00:46:57,296
这将使你更容易

1622
00:46:57,296 --> 00:46:59,106
优化程序

1623
00:46:59,106 --> 00:47:01,206
消除不必要的副本

1624
00:46:59,106 --> 00:47:01,206
消除不必要的副本

1625
00:47:01,206 --> 00:47:03,066
并在你需要时保留它

1626
00:47:03,216 --> 00:47:04,966
但是在一些情况下

1627
00:47:05,126 --> 00:47:07,336
这能让我们在默认设置下

1628
00:47:07,636 --> 00:47:08,836
更迅速地使用 Swift

1629
00:47:09,726 --> 00:47:11,426
最终 它将启用一些

1630
00:47:11,426 --> 00:47:13,936
非常强大的新语言

1631
00:47:13,936 --> 00:47:15,986
特性来创建

1632
00:47:16,126 --> 00:47:18,156
安全和有效的

1633
00:47:18,156 --> 00:47:20,356
抽象 但在我们做事前

1634
00:47:20,356 --> 00:47:22,396
我们必须让理解内存

1635
00:47:22,476 --> 00:47:23,976
更容易

1636
00:47:24,326 --> 00:47:26,116
这意味着

1637
00:47:26,146 --> 00:47:27,916
独占访问内存

1638
00:47:28,976 --> 00:47:30,186
所以我的意思是

1639
00:47:31,486 --> 00:47:32,576
让我们来看看一个例子

1640
00:47:33,606 --> 00:47:35,086
通常情况下 我像这样

1641
00:47:35,246 --> 00:47:37,046
集合上进行迭代

1642
00:47:37,126 --> 00:47:38,766
我想修改我看到

1643
00:47:38,766 --> 00:47:39,776
的每一个元素

1644
00:47:40,616 --> 00:47:42,166
这是一个常见的模式

1645
00:47:42,166 --> 00:47:43,856
那么我将把它

1646
00:47:43,856 --> 00:47:45,746
变成一个方法

1647
00:47:46,486 --> 00:47:49,096
现在我有了这个方法

1648
00:47:49,666 --> 00:47:51,376
我得到了一个

1649
00:47:51,546 --> 00:47:53,346
通用的操作 这可以

1650
00:47:53,346 --> 00:47:54,466
用来修改任何可变的元素

1651
00:47:54,976 --> 00:47:58,956
每次一个元素

1652
00:47:59,156 --> 00:48:01,966
这个操作是在迭代

1653
00:47:59,156 --> 00:48:01,966
这个操作是在迭代

1654
00:48:01,966 --> 00:48:03,676
开始时捕获的

1655
00:48:03,726 --> 00:48:07,386
一组索引上

1656
00:48:07,386 --> 00:48:08,176
进行迭代

1657
00:48:09,226 --> 00:48:11,256
这只会在下面

1658
00:48:11,256 --> 00:48:13,286
这种情况下起作用

1659
00:48:13,636 --> 00:48:15,186
那就是该操作实际上

1660
00:48:15,186 --> 00:48:16,976
不通过添加或删除

1661
00:48:16,976 --> 00:48:18,186
集合中的元素来修改索引

1662
00:48:19,356 --> 00:48:21,456
但我实际上看得很清楚

1663
00:48:21,556 --> 00:48:22,816
这个方法中没有任何

1664
00:48:22,816 --> 00:48:23,786
一种操作实际上

1665
00:48:23,786 --> 00:48:24,286
修改了集合

1666
00:48:24,416 --> 00:48:28,186
是不是这样呢 

1667
00:48:28,186 --> 00:48:30,056
我调用这个被传入的闭包

1668
00:48:30,056 --> 00:48:31,726
闭包是任意的代码

1669
00:48:32,386 --> 00:48:34,406
但是 我再看一下这个方式

1670
00:48:34,406 --> 00:48:37,726
我想没问题啊

1671
00:48:37,856 --> 00:48:39,646
我只是让这个闭包

1672
00:48:39,646 --> 00:48:41,816
访问一个集合的

1673
00:48:41,816 --> 00:48:43,196
特定元素 而不是

1674
00:48:43,196 --> 00:48:44,216
整个集合

1675
00:48:44,616 --> 00:48:47,126
因此我应该知道的是

1676
00:48:47,126 --> 00:48:48,406
在这个操作正在进行时

1677
00:48:48,406 --> 00:48:50,336
没有任何东西

1678
00:48:50,336 --> 00:48:50,986
可以修改集合

1679
00:48:52,376 --> 00:48:54,526
不幸的是 在 Swift 3 中

1680
00:48:54,626 --> 00:48:55,586
这不是语言的

1681
00:48:55,586 --> 00:48:56,196
工作方式

1682
00:48:57,546 --> 00:48:59,086
让我们回到我

1683
00:48:59,086 --> 00:49:01,026
调用方式的那个

1684
00:48:59,086 --> 00:49:01,026
调用方式的那个

1685
00:49:01,026 --> 00:49:01,486
代码那里

1686
00:49:02,236 --> 00:49:03,106
我们试试

1687
00:49:03,106 --> 00:49:06,026
把元素乘二

1688
00:49:06,476 --> 00:49:08,296
并试试去访问

1689
00:49:08,296 --> 00:49:08,976
数字变量

1690
00:49:09,976 --> 00:49:11,276
没有什么会

1691
00:49:11,276 --> 00:49:11,766
阻止我这么做

1692
00:49:12,076 --> 00:49:14,756
当我在另一个

1693
00:49:14,756 --> 00:49:17,336
方式中迭代它的时候

1694
00:49:17,336 --> 00:49:20,106
我可以在这个

1695
00:49:20,106 --> 00:49:21,756
闭包的任意点上

1696
00:49:21,756 --> 00:49:23,176
给变量移除或添加一些东西

1697
00:49:23,796 --> 00:49:26,466
当我这么做的时候

1698
00:49:26,466 --> 00:49:27,866
我突然想起了一件事

1699
00:49:28,326 --> 00:49:30,216
想推理出这个

1700
00:49:30,256 --> 00:49:32,376
数组中发生了什么

1701
00:49:32,376 --> 00:49:33,106
真的太难了

1702
00:49:33,106 --> 00:49:36,456
以前的情况是

1703
00:49:36,826 --> 00:49:38,456
这样的 我可以在

1704
00:49:38,456 --> 00:49:39,996
我的程序中查看

1705
00:49:39,996 --> 00:49:41,786
每个单独的函数

1706
00:49:41,986 --> 00:49:44,186
然后考虑它对每个

1707
00:49:44,306 --> 00:49:46,106
变量做了什么

1708
00:49:46,736 --> 00:49:47,596
这非常棒

1709
00:49:47,896 --> 00:49:49,086
这是我们所说的

1710
00:49:49,156 --> 00:49:50,976
值语义的

1711
00:49:50,976 --> 00:49:51,416
最好属性之一

1712
00:49:51,416 --> 00:49:52,836
你在你的程序 程序中的

1713
00:49:52,896 --> 00:49:55,226
每个部分都存在

1714
00:49:55,266 --> 00:49:56,286
这种隔离

1715
00:49:56,786 --> 00:49:58,706
所有的东西都组合在了一起

1716
00:49:58,866 --> 00:50:00,206
你也不必立马解释

1717
00:49:58,866 --> 00:50:00,206
你也不必立马解释

1718
00:50:00,256 --> 00:50:01,836
清楚所有的事情

1719
00:50:03,136 --> 00:50:05,586
但不幸的是

1720
00:50:05,586 --> 00:50:07,476
正因为我们可以

1721
00:50:07,556 --> 00:50:09,966
做这样的事情 我们得到了

1722
00:50:09,966 --> 00:50:11,936
一种参考语义

1723
00:50:11,936 --> 00:50:13,556
为了理解现在在发生了什么

1724
00:50:13,636 --> 00:50:15,336
你不得不理解你的

1725
00:50:15,336 --> 00:50:16,676
整个程序

1726
00:50:17,646 --> 00:50:19,076
这里当我做这些

1727
00:50:19,176 --> 00:50:21,056
事情的时候 我将会

1728
00:50:21,116 --> 00:50:21,876
查阅整个数组

1729
00:50:22,686 --> 00:50:24,836
对我来说尝试修复

1730
00:50:24,836 --> 00:50:26,876
我的代码并不困难

1731
00:50:26,876 --> 00:50:29,566
通过在集合开始时

1732
00:50:29,856 --> 00:50:31,006
迭代一组索引

1733
00:50:31,006 --> 00:50:32,356
我将每次重新

1734
00:50:32,416 --> 00:50:34,636
加载索引

1735
00:50:34,636 --> 00:50:37,066
然后比较

1736
00:50:37,066 --> 00:50:38,986
这两种方法

1737
00:50:38,986 --> 00:50:40,486
如果我从最后移过来一点东西

1738
00:50:40,486 --> 00:50:41,416
一切又都运行的非常正常

1739
00:50:41,936 --> 00:50:46,266
哦对了 其实

1740
00:50:46,296 --> 00:50:46,456
还有另一种方法

1741
00:50:46,656 --> 00:50:47,336
一种更好的方法

1742
00:50:47,966 --> 00:50:50,076
因为我的代码

1743
00:50:50,076 --> 00:50:51,946
有些丑

1744
00:50:51,946 --> 00:50:52,556
还运行得很慢

1745
00:50:52,856 --> 00:50:54,376
然而如果它足够好

1746
00:50:54,376 --> 00:50:55,896
那确实是个不错的

1747
00:50:55,956 --> 00:50:57,226
权衡之道 对吗

1748
00:50:57,846 --> 00:50:59,486
你知道吗 如果能让

1749
00:50:59,486 --> 00:51:00,886
你的性能

1750
00:50:59,486 --> 00:51:00,886
你的性能

1751
00:51:00,886 --> 00:51:03,826
变得更加优秀

1752
00:51:04,036 --> 00:51:06,376
牺牲一点美观度

1753
00:51:06,376 --> 00:51:06,806
也无可厚非

1754
00:51:08,336 --> 00:51:09,466
但在这里还

1755
00:51:09,466 --> 00:51:09,986
不够好

1756
00:51:10,686 --> 00:51:11,986
那让我们再回到

1757
00:51:11,986 --> 00:51:12,306
这个闭包上去

1758
00:51:12,856 --> 00:51:14,966
如果不是在循环

1759
00:51:15,016 --> 00:51:19,126
结束时移除一个东西

1760
00:51:19,126 --> 00:51:20,796
如果在我

1761
00:51:20,846 --> 00:51:22,576
访问元素之前

1762
00:51:22,666 --> 00:51:23,216
就擦除整个数组

1763
00:51:23,826 --> 00:51:26,436
现在它现在访问的

1764
00:51:26,496 --> 00:51:27,036
是什么

1765
00:51:27,466 --> 00:51:28,686
它要去哪里

1766
00:51:29,516 --> 00:51:31,276
我其实正在分配

1767
00:51:31,276 --> 00:51:32,856
一些根本不存在的东西

1768
00:51:33,076 --> 00:51:34,246
因为数组中没有

1769
00:51:34,246 --> 00:51:35,706
任何元素

1770
00:51:37,016 --> 00:51:38,806
这是一个非常好的

1771
00:51:38,836 --> 00:51:40,116
问题 为了回答这个问题

1772
00:51:40,116 --> 00:51:41,076
我们需要深入

1773
00:51:41,076 --> 00:51:42,756
研究数组的

1774
00:51:43,336 --> 00:51:43,576
实现方式

1775
00:51:43,576 --> 00:51:45,846
数组是一个写值类型的拷贝

1776
00:51:45,846 --> 00:51:47,156
它用一个引用计数

1777
00:51:47,266 --> 00:51:49,166
缓存区来实现

1778
00:51:49,916 --> 00:51:52,626
在循环开始时

1779
00:51:53,956 --> 00:51:57,026
数字正指向

1780
00:51:57,076 --> 00:51:58,846
该缓存区

1781
00:51:59,036 --> 00:52:00,866
为了保证性能 Swift

1782
00:51:59,036 --> 00:52:00,866
为了保证性能 Swift

1783
00:52:00,866 --> 00:52:02,836
希望将直接传递到

1784
00:52:03,066 --> 00:52:05,816
闭包中的元素变量

1785
00:52:05,816 --> 00:52:08,316
绑定到该缓存区

1786
00:52:08,316 --> 00:52:09,296
的内存之中

1787
00:52:10,106 --> 00:52:11,706
这就产生了一个问题

1788
00:52:11,966 --> 00:52:12,886
因为当我们分配时

1789
00:52:12,886 --> 00:52:16,056
数字不再

1790
00:52:16,056 --> 00:52:17,746
指向那个缓冲区

1791
00:52:17,746 --> 00:52:19,026
这意味着不再

1792
00:52:19,026 --> 00:52:19,536
维持它的活动

1793
00:52:20,736 --> 00:52:23,026
Swift 是一种安全的语言

1794
00:52:23,266 --> 00:52:24,826
我们并不想让它

1795
00:52:24,826 --> 00:52:26,236
成为一个危险因素

1796
00:52:26,646 --> 00:52:28,256
所以 我们必须做些事情

1797
00:52:28,256 --> 00:52:30,226
来保证这个缓存区是活动的

1798
00:52:30,226 --> 00:52:31,646
这样才不会导致

1799
00:52:31,646 --> 00:52:32,216
程序崩溃

1800
00:52:32,986 --> 00:52:33,786
这是如何工作的呢

1801
00:52:34,616 --> 00:52:37,006
在子脚本操作的时候

1802
00:52:37,096 --> 00:52:39,556
Swift 实际上

1803
00:52:39,556 --> 00:52:41,986
悄悄地创建了

1804
00:52:41,986 --> 00:52:43,976
一个模糊的对缓存区的引用

1805
00:52:43,976 --> 00:52:45,206
这就是它的工作方式

1806
00:52:46,226 --> 00:52:48,886
这使程序免于崩溃

1807
00:52:49,386 --> 00:52:50,926
但这会浪费额外的

1808
00:52:50,926 --> 00:52:53,266
性能 我们希望优化器

1809
00:52:53,266 --> 00:52:55,096
在每次将

1810
00:52:55,146 --> 00:52:57,486
脚本放入

1811
00:52:57,706 --> 00:52:59,136
数组时都可以

1812
00:52:59,136 --> 00:52:59,346
清理掉它们

1813
00:52:59,946 --> 00:53:03,906
这种对内存的

1814
00:52:59,946 --> 00:53:03,906
这种对内存的

1815
00:53:03,906 --> 00:53:05,456
非独占访问内存

1816
00:53:05,456 --> 00:53:07,446
会在多个层面产生问题

1817
00:53:07,676 --> 00:53:09,166
比如程序中的

1818
00:53:09,206 --> 00:53:09,716
级联问题

1819
00:53:10,166 --> 00:53:11,766
这让整件事情变得

1820
00:53:11,766 --> 00:53:12,136
更难理解

1821
00:53:12,516 --> 00:53:14,356
这是你的代码并不那么通用

1822
00:53:14,676 --> 00:53:16,236
证明正确性时也更复杂

1823
00:53:17,206 --> 00:53:18,566
当你试图去优化这些

1824
00:53:18,566 --> 00:53:20,486
一般的数据结构时

1825
00:53:20,486 --> 00:53:22,946
他会在你的程序

1826
00:53:22,946 --> 00:53:24,756
和 Swift 中产生

1827
00:53:24,756 --> 00:53:26,086
性能问题

1828
00:53:27,156 --> 00:53:28,826
解决方案是我们必须

1829
00:53:28,826 --> 00:53:31,276
拥有对内存的独占访问权

1830
00:53:31,806 --> 00:53:35,336
我所谓的独占性是什么意思

1831
00:53:35,496 --> 00:53:39,016
程序中有两个不用的

1832
00:53:39,016 --> 00:53:40,086
部分在同一时间从

1833
00:53:40,086 --> 00:53:41,356
同一个变量中读取

1834
00:53:41,356 --> 00:53:42,656
这是没问题的

1835
00:53:44,286 --> 00:53:45,326
但是 当我在为变量

1836
00:53:45,326 --> 00:53:46,926
写入一些东西的时候

1837
00:53:47,266 --> 00:53:48,946
很重要的一点就是

1838
00:53:48,946 --> 00:53:50,476
什么都不能访问

1839
00:53:50,946 --> 00:53:52,166
写入变量的东西

1840
00:53:52,166 --> 00:53:53,866
应该是独占的

1841
00:53:54,736 --> 00:53:55,246
就是这样

1842
00:53:55,726 --> 00:53:56,616
这就是规则

1843
00:53:56,616 --> 00:53:58,006
这既是我们在

1844
00:53:58,066 --> 00:53:59,526
Swift 4 中添加的新规则

1845
00:54:00,186 --> 00:54:04,166
那么我们该如何实施呢

1846
00:54:04,796 --> 00:54:08,896
在大多数情况下 就像我们

1847
00:54:08,896 --> 00:54:10,896
最初执行的例子一样

1848
00:54:10,896 --> 00:54:12,676
Swift 其实能在编译时

1849
00:54:12,676 --> 00:54:15,846
执行这一过程

1850
00:54:16,056 --> 00:54:18,136
这里我调用了一个

1851
00:54:18,136 --> 00:54:19,736
关于数字的突变方法

1852
00:54:19,986 --> 00:54:22,046
在调用期间

1853
00:54:22,046 --> 00:54:23,166
赋予了它权限

1854
00:54:23,166 --> 00:54:27,306
当我在这个调用后面

1855
00:54:27,306 --> 00:54:29,576
入手并调用另一个

1856
00:54:29,576 --> 00:54:30,876
正在运行的方法时

1857
00:54:31,496 --> 00:54:33,226
我就得到了一个

1858
00:54:33,636 --> 00:54:34,856
有违规则的权限冲突

1859
00:54:35,346 --> 00:54:36,596
在编译时发生

1860
00:54:36,596 --> 00:54:38,486
这种事情

1861
00:54:38,796 --> 00:54:39,806
Swift 会立刻

1862
00:54:39,856 --> 00:54:40,576
告诉你

1863
00:54:41,166 --> 00:54:44,036
一般来说 在大多数

1864
00:54:44,036 --> 00:54:46,726
值语义情况下

1865
00:54:46,796 --> 00:54:48,336
这都是正确的

1866
00:54:49,346 --> 00:54:50,906
但在某些情况下

1867
00:54:51,966 --> 00:54:54,236
这是不可能的

1868
00:54:54,816 --> 00:54:56,176
通常是由于

1869
00:54:56,176 --> 00:54:57,276
某种参考语义

1870
00:54:57,446 --> 00:54:59,106
要么是全局变量

1871
00:54:59,106 --> 00:55:01,116
要么是像类属型

1872
00:54:59,106 --> 00:55:01,116
要么是像类属型

1873
00:55:01,116 --> 00:55:02,126
这样的共享内存

1874
00:55:03,486 --> 00:55:04,526
那么 让我们回到

1875
00:55:04,526 --> 00:55:05,446
之前的例子

1876
00:55:05,976 --> 00:55:08,206
这里 数字

1877
00:55:08,206 --> 00:55:08,776
代表一个局部变量

1878
00:55:09,266 --> 00:55:12,396
但如果它是一个

1879
00:55:13,616 --> 00:55:15,726
类属性呢

1880
00:55:15,816 --> 00:55:17,486
嗯 情况基本上

1881
00:55:17,486 --> 00:55:20,186
还是一样的

1882
00:55:20,386 --> 00:55:22,106
这里 我调用了一个

1883
00:55:22,106 --> 00:55:23,936
类属性的变异方法

1884
00:55:25,076 --> 00:55:27,326
在闭包中

1885
00:55:27,326 --> 00:55:29,616
我在同一个类属性中

1886
00:55:30,166 --> 00:55:31,366
调用了同一个变异方法

1887
00:55:32,266 --> 00:55:34,336
但是他们是在对象上的

1888
00:55:34,336 --> 00:55:36,816
编译器无法判断

1889
00:55:36,816 --> 00:55:38,446
他们是否在同一个对象上

1890
00:55:39,596 --> 00:55:42,036
一般来说 类类型

1891
00:55:42,286 --> 00:55:44,486
的特点是你可以移动

1892
00:55:44,486 --> 00:55:46,496
复制 并在整个程序

1893
00:55:46,496 --> 00:55:47,666
中共享它们

1894
00:55:48,306 --> 00:55:51,186
在你喜欢的地方使用它们

1895
00:55:51,736 --> 00:55:54,116
但是 这意味着编译器

1896
00:55:54,116 --> 00:55:55,746
不能确切地告诉你

1897
00:55:55,856 --> 00:55:58,136
是否每个特定的函数

1898
00:55:58,136 --> 00:56:00,456
或者像这样的访问

1899
00:55:58,136 --> 00:56:00,456
或者像这样的访问

1900
00:56:00,456 --> 00:56:02,936
实际上是在

1901
00:56:02,936 --> 00:56:04,396
访问同一个对象

1902
00:56:05,116 --> 00:56:06,226
因此 编译器必须是

1903
00:56:06,226 --> 00:56:06,976
保守的

1904
00:56:07,536 --> 00:56:09,556
现在 如果我们一直

1905
00:56:09,556 --> 00:56:11,606
禁止这样的事情

1906
00:56:11,676 --> 00:56:12,816
是不太可能的

1907
00:56:12,816 --> 00:56:14,486
所以我们要做

1908
00:56:14,586 --> 00:56:15,486
动态检查

1909
00:56:16,256 --> 00:56:17,366
这意味着在运行时

1910
00:56:17,366 --> 00:56:20,286
我们会得到这样的错误

1911
00:56:20,896 --> 00:56:22,986
但前提是他们实际上

1912
00:56:22,986 --> 00:56:23,696
是同一对象

1913
00:56:23,846 --> 00:56:24,806
当然 如果它们是

1914
00:56:24,806 --> 00:56:27,116
不同的对象

1915
00:56:27,256 --> 00:56:29,076
那么它们会被认为是

1916
00:56:29,076 --> 00:56:30,776
两个类属性及不同的内存

1917
00:56:31,346 --> 00:56:32,316
这里并没有冲突

1918
00:56:32,846 --> 00:56:37,726
出于性能因素考虑

1919
00:56:38,776 --> 00:56:40,936
我们在做的这个强制执行

1920
00:56:40,936 --> 00:56:42,486
只在一个线程内完成

1921
00:56:43,116 --> 00:56:45,476
然而 我们在 Xcode 中

1922
00:56:45,476 --> 00:56:47,406
提供的线程杀毒工具

1923
00:56:47,486 --> 00:56:49,226
即使在不同的线程中

1924
00:56:49,266 --> 00:56:50,906
也可以捕捉到这些问题

1925
00:56:51,716 --> 00:56:53,016
本周晚些时候

1926
00:56:53,016 --> 00:56:53,546
会有个很棒的会议

1927
00:56:53,866 --> 00:56:55,486
我强烈建议你们

1928
00:56:55,486 --> 00:56:57,706
每个人都在 Xcode 中

1929
00:56:57,776 --> 00:56:59,326
找找像这样的 bug

1930
00:57:03,216 --> 00:57:05,226
这就是 Swift 4 的规则

1931
00:57:06,636 --> 00:57:08,066
就像我们昨天在发布会上

1932
00:57:08,306 --> 00:57:12,596
说的那样 Swift 3.2 是允许

1933
00:57:12,596 --> 00:57:15,466
你现有的代码

1934
00:57:15,466 --> 00:57:16,896
继续工作的

1935
00:57:17,606 --> 00:57:19,526
因此 在 Swift 3.2 中

1936
00:57:19,586 --> 00:57:19,886
这仅仅会作为警告存在

1937
00:57:20,716 --> 00:57:23,436
但是 因为 Swift 4 和

1938
00:57:23,436 --> 00:57:27,356
Swift 3 需要在 Xcode 

1939
00:57:27,356 --> 00:57:30,066
的未来版本中进行交互操作

1940
00:57:30,066 --> 00:57:31,676
所以即使在 Swift 3 模式下

1941
00:57:31,726 --> 00:57:33,496
我们也会以错误这一形式显示

1942
00:57:34,236 --> 00:57:36,066
所以我们强烈建议

1943
00:57:36,216 --> 00:57:37,846
你能注意到这些警告

1944
00:57:38,316 --> 00:57:39,086
并修复它们

1945
00:57:39,456 --> 00:57:40,496
因为他们只是警告

1946
00:57:40,536 --> 00:57:41,776
所以你可以在

1947
00:57:41,856 --> 00:57:42,226
任意时间去修复它们

1948
00:57:42,226 --> 00:57:44,116
你可以按照你自己的节奏来

1949
00:57:44,116 --> 00:57:45,486
但是你需要认真的对待它们了

1950
00:57:52,076 --> 00:57:53,966
我们非常期待

1951
00:57:54,006 --> 00:57:55,196
它所能够带来

1952
00:57:55,196 --> 00:57:55,576
的影响

1953
00:57:55,866 --> 00:57:57,066
这使得代码

1954
00:57:57,136 --> 00:58:00,126
更易理解

1955
00:57:57,136 --> 00:58:00,126
更易理解

1956
00:58:00,126 --> 00:58:03,716
在库和编译器中

1957
00:58:03,716 --> 00:58:05,376
它都启用了

1958
00:58:05,616 --> 00:58:07,416
许多非常棒

1959
00:58:07,416 --> 00:58:08,106
的优化

1960
00:58:08,416 --> 00:58:09,776
而且他也提供一些

1961
00:58:10,386 --> 00:58:12,076
很易上手的工具

1962
00:58:12,076 --> 00:58:14,666
使用这些工具

1963
00:58:15,016 --> 00:58:18,496
你可以以你自己的方式

1964
00:58:18,496 --> 00:58:20,256
去优化代码

1965
00:58:20,256 --> 00:58:21,236
这是非常棒的

1966
00:58:22,386 --> 00:58:23,626
如果你对我们

1967
00:58:23,626 --> 00:58:25,116
准备用它来做什么

1968
00:58:25,116 --> 00:58:26,796
感兴趣 在 Swift 官网上

1969
00:58:26,946 --> 00:58:28,736
有一个开发者宣言

1970
00:58:28,736 --> 00:58:30,476
你可以去

1971
00:58:30,476 --> 00:58:32,946
看一下

1972
00:58:33,216 --> 00:58:34,546
现在 有一个警告你需要知道

1973
00:58:34,706 --> 00:58:36,276
这周我们已经给出了

1974
00:58:36,276 --> 00:58:38,186
开发者预览版

1975
00:58:38,186 --> 00:58:39,826
有些功能还在实现中

1976
00:58:40,226 --> 00:58:41,396
在发布说明中

1977
00:58:41,396 --> 00:58:42,296
有很多信息

1978
00:58:42,556 --> 00:58:43,766
我真的希望你们能自己

1979
00:58:43,816 --> 00:58:44,256
去阅读一下

1980
00:58:44,846 --> 00:58:46,406
我希望你们自己去探索

1981
00:58:46,406 --> 00:58:48,496
所有的这些东西

1982
00:58:48,496 --> 00:58:49,426
确保每一项功能都能得到实现

1983
00:58:49,486 --> 00:58:50,646
如果你遇到了任何困难

1984
00:58:50,646 --> 00:58:50,976
请与我们沟通

1985
00:58:54,086 --> 00:58:55,676
这就是今天

1986
00:58:55,746 --> 00:58:56,076
Swift 的新版本发布会

1987
00:58:56,836 --> 00:58:58,306
除了库和语言之外

1988
00:58:58,306 --> 00:59:00,506
我们还做了

1989
00:58:58,306 --> 00:59:00,506
我们还做了

1990
00:59:00,506 --> 00:59:03,416
许多的改进

1991
00:59:04,036 --> 00:59:05,676
我们已经有了一个

1992
00:59:06,146 --> 00:59:07,436
很棒的 Swift 

1993
00:59:07,436 --> 00:59:07,896
并对很多东西进行了优化

1994
00:59:08,606 --> 00:59:10,186
我们真的在工作上

1995
00:59:10,186 --> 00:59:12,306
投入了许多精力和时间

1996
00:59:12,306 --> 00:59:13,526
这足以使你提高代码性能

1997
00:59:13,526 --> 00:59:14,276
并压缩代码大小

1998
00:59:14,366 --> 00:59:17,496
希望你们享受 WWDC

1999
00:59:17,586 --> 00:59:18,626
再此感谢大家能够

2000
00:59:18,626 --> 00:59:18,816
亲临现场

2001
00:59:19,516 --> 00:59:23,500
[掌声]
