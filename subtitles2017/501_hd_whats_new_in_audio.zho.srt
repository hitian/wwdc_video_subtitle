1
00:00:17,751 --> 00:00:22,556
<c.magenta>（音频中的新功能）</c>

2
00:00:29,763 --> 00:00:31,798
<c.magenta>谢谢大家 大家下午好</c>

3
00:00:32,499 --> 00:00:35,169
<c.magenta>欢迎参加“音频中的新功能”演讲</c>

4
00:00:36,136 --> 00:00:38,038
<c.magenta>我是Akshatha Nagesh</c>

5
00:00:38,405 --> 00:00:41,108
<c.magenta>今天我要跟你们大家分享</c>

6
00:00:41,441 --> 00:00:46,113
<c.magenta>在今年的OS发布中</c>

7
00:00:48,081 --> 00:00:50,984
<c.magenta>我要从音频堆栈的快速概览开始讲</c>

8
00:00:52,152 --> 00:00:55,656
<c.magenta>音频框架提供了多种多样的API</c>

9
00:00:55,722 --> 00:00:58,125
<c.magenta>我们的主要目标是帮助你</c>

10
00:00:58,292 --> 00:01:02,129
<c.magenta>通过你的应用给你的终端用户</c>

11
00:00:58,292 --> 00:01:02,129
<c.magenta>通过你的应用给你的终端用户</c>

12
00:01:03,330 --> 00:01:06,166
<c.magenta>在顶层我们有AV基础框架</c>

13
00:01:06,333 --> 00:01:11,939
<c.magenta>API有AVAudioSession、Engine、</c>

14
00:01:12,706 --> 00:01:16,243
<c.magenta>这些API迎合了绝大部分应用的需求</c>

15
00:01:17,177 --> 00:01:19,847
<c.magenta>但如果你想进一步自定义体验</c>

16
00:01:20,180 --> 00:01:24,618
<c.magenta>你可以使用我们的其他框架</c>

17
00:01:24,685 --> 00:01:28,989
<c.magenta>音频工具箱框架中的音频编解码器、</c>

18
00:01:29,356 --> 00:01:31,425
<c.magenta>AudioHAL框架等等</c>

19
00:01:32,759 --> 00:01:35,162
<c.magenta>在我们去年WWDC的演讲中</c>

20
00:01:35,362 --> 00:01:39,633
<c.magenta>我们通过堆栈逐个谈了全部API</c>

21
00:01:40,133 --> 00:01:42,569
<c.magenta>我强烈推荐你们参考一下去年的资料</c>

22
00:01:44,071 --> 00:01:46,540
<c.magenta>现在让我们看看今天的议事日程</c>

23
00:01:48,008 --> 00:01:51,645
<c.magenta>我们要了解我们给某些API中</c>

24
00:01:51,879 --> 00:01:53,547
<c.magenta>从AVFoundation框架</c>

25
00:01:53,614 --> 00:01:56,416
<c.magenta>中的API开始讲 其中包括</c>

26
00:01:56,483 --> 00:01:58,819
<c.magenta>AVAudioEngine、AVAudioSession</c>

27
00:01:59,152 --> 00:02:02,890
<c.magenta>以及在watchOS 4上</c>

28
00:01:59,152 --> 00:02:02,890
<c.magenta>以及在watchOS 4上</c>

29
00:02:04,191 --> 00:02:07,361
<c.magenta>稍后我们将了解音频工具箱的世界</c>

30
00:02:07,661 --> 00:02:11,632
<c.magenta>查看AUAudioUnit</c>

31
00:02:12,332 --> 00:02:14,801
<c.magenta>最后我们会讲设备间音频模式的更新</c>

32
00:02:15,035 --> 00:02:17,371
<c.magenta>圆满结束今天的演讲</c>

33
00:02:18,739 --> 00:02:21,275
<c.magenta>其间还有几个演示</c>

34
00:02:21,341 --> 00:02:24,478
<c.magenta>用于在实际操作中展示今天的新功能</c>

35
00:02:26,280 --> 00:02:28,549
<c.magenta>那么让我们从AVAudioEngine开始吧</c>

36
00:02:29,783 --> 00:02:32,085
<c.magenta>这是这个API的一个快速回顾</c>

37
00:02:33,187 --> 00:02:38,325
<c.magenta>AVAudioEngine是一个强大的基于</c>

38
00:02:38,892 --> 00:02:40,827
<c.magenta>这个API的主要目标</c>

39
00:02:40,994 --> 00:02:43,697
<c.magenta>是简化对实时音频的处理</c>

40
00:02:44,097 --> 00:02:47,234
<c.magenta>并让你写代码</c>

41
00:02:47,568 --> 00:02:52,306
<c.magenta>以实施各种音频任务的过程</c>

42
00:02:52,606 --> 00:02:56,076
<c.magenta>到更复杂的任务 比如音频处理、混音</c>

43
00:02:56,143 --> 00:02:58,011
<c.magenta>甚至是3D音频特化</c>

44
00:02:59,079 --> 00:03:03,350
<c.magenta>在我们去年的WWDC演讲中</c>

45
00:02:59,079 --> 00:03:03,350
<c.magenta>在我们去年的WWDC演讲中</c>

46
00:03:03,617 --> 00:03:05,919
<c.magenta>我们详细介绍了这个API</c>

47
00:03:06,253 --> 00:03:09,823
<c.magenta>那么请参看去年的资料</c>

48
00:03:11,625 --> 00:03:14,127
<c.magenta>Engine管理一系列的节点</c>

49
00:03:14,361 --> 00:03:17,130
<c.magenta>而一个节点</c>

50
00:03:18,031 --> 00:03:22,135
<c.magenta>那么这里是一个Engine组合示例</c>

51
00:03:23,337 --> 00:03:26,240
<c.magenta>正如你所看到的</c>

52
00:03:26,406 --> 00:03:27,908
<c.magenta>形成了完整的处理图</c>

53
00:03:28,942 --> 00:03:32,446
<c.magenta>我们有InputNode</c>

54
00:03:32,513 --> 00:03:35,849
<c.magenta>到输入硬件并捕捉用户的声音</c>

55
00:03:36,683 --> 00:03:39,019
<c.magenta>这是通过EffectNode处理的</c>

56
00:03:39,086 --> 00:03:40,888
<c.magenta>可能是 比如说EQ</c>

57
00:03:42,256 --> 00:03:45,292
<c.magenta>我们在InputNode上还有一个东西</c>

58
00:03:45,626 --> 00:03:48,462
<c.magenta>用于分析用户的声音</c>

59
00:03:48,529 --> 00:03:50,998
<c.magenta>了解他表现怎么样 基于此</c>

60
00:03:51,198 --> 00:03:54,468
<c.magenta>我们可以通过PlayerNode</c>

61
00:03:55,702 --> 00:03:57,237
<c.magenta>我们还有另一个PlayerNode</c>

62
00:03:57,304 --> 00:04:00,407
<c.magenta>当用户正在唱歌时会播放背景音乐</c>

63
00:03:57,304 --> 00:04:00,407
<c.magenta>当用户正在唱歌时会播放背景音乐</c>

64
00:04:01,842 --> 00:04:04,044
<c.magenta>全部信号都被混在一起</c>

65
00:04:04,278 --> 00:04:07,414
<c.magenta>在MixerNode中</c>

66
00:04:07,614 --> 00:04:09,883
<c.magenta>通过输出硬件播放出来</c>

67
00:04:11,518 --> 00:04:14,221
<c.magenta>这是一个引擎集合的简单示例</c>

68
00:04:14,555 --> 00:04:18,024
<c.magenta>但通过全部节点</c>

69
00:04:18,225 --> 00:04:21,195
<c.magenta>我们可以创建更复杂的处理图</c>

70
00:04:21,261 --> 00:04:22,896
<c.magenta>基于你应用的需要</c>

71
00:04:24,464 --> 00:04:26,233
<c.magenta>那么这是关于Engine的回顾</c>

72
00:04:26,300 --> 00:04:29,102
<c.magenta>现在让我们来看看</c>

73
00:04:30,304 --> 00:04:34,241
<c.magenta>我们有一些新节点</c>

74
00:04:34,408 --> 00:04:35,642
<c.magenta>和自动关闭模式</c>

75
00:04:36,343 --> 00:04:39,479
<c.magenta>同时在AVAudioPlayerNode中</c>

76
00:04:39,680 --> 00:04:42,216
<c.magenta>与文件和缓冲区结束回调有关</c>

77
00:04:43,250 --> 00:04:47,821
<c.magenta>我们将逐个来看这些</c>

78
00:04:50,924 --> 00:04:53,594
<c.magenta>那么这是我们刚才看到的</c>

79
00:04:54,561 --> 00:04:57,998
<c.magenta>正如你所看到的</c>

80
00:04:58,165 --> 00:05:00,300
<c.magenta>连接到了音频硬件</c>

81
00:04:58,165 --> 00:05:00,300
<c.magenta>连接到了音频硬件</c>

82
00:05:00,634 --> 00:05:04,204
<c.magenta>因此 Engine就会实时自动渲染</c>

83
00:05:05,539 --> 00:05:08,041
<c.magenta>这里的IO是由硬件驱动的</c>

84
00:05:09,309 --> 00:05:12,112
<c.magenta>但如果你想让Engine进行渲染</c>

85
00:05:12,179 --> 00:05:14,214
<c.magenta>不是对设备 而是对应用</c>

86
00:05:14,581 --> 00:05:17,084
<c.magenta>比如说速度要比实时的快一些？</c>

87
00:05:18,385 --> 00:05:21,922
<c.magenta>那么这里有手动渲染模式</c>

88
00:05:23,190 --> 00:05:24,157
<c.magenta>正如你所看到的</c>

89
00:05:24,224 --> 00:05:25,392
<c.magenta>在这种模式下</c>

90
00:05:25,459 --> 00:05:29,696
<c.magenta>InputNode和OutputNode</c>

91
00:05:30,397 --> 00:05:34,501
<c.magenta>而应用将拉动Engine用于输出</c>

92
00:05:34,801 --> 00:05:37,337
<c.magenta>并向Engine提供输入</c>

93
00:05:37,571 --> 00:05:39,940
<c.magenta>可以通过InputNode</c>

94
00:05:40,240 --> 00:05:41,842
<c.magenta>或PlayerNode等等</c>

95
00:05:42,843 --> 00:05:46,547
<c.magenta>那么应用在手动渲染模式中驱动IO</c>

96
00:05:48,682 --> 00:05:51,285
<c.magenta>在手动渲染模式下有两个变体</c>

97
00:05:51,752 --> 00:05:55,622
<c.magenta>即脱机和实时手动渲染模式</c>

98
00:05:56,089 --> 00:05:58,258
<c.magenta>我们会具体了解每一个变体</c>

99
00:05:58,525 --> 00:06:01,962
<c.magenta>同时 稍后我会展示一个演示</c>

100
00:05:58,525 --> 00:06:01,962
<c.magenta>同时 稍后我会展示一个演示</c>

101
00:06:02,029 --> 00:06:04,031
<c.magenta>是脱机手动渲染模式的演示</c>

102
00:06:07,668 --> 00:06:10,037
<c.magenta>在脱机手动渲染模式下</c>

103
00:06:10,337 --> 00:06:13,874
<c.magenta>Engine和你处理图中的全部节点</c>

104
00:06:13,941 --> 00:06:17,110
<c.magenta>在没有截止日期</c>

105
00:06:18,078 --> 00:06:21,982
<c.magenta>因为这种灵活性</c>

106
00:06:22,049 --> 00:06:25,919
<c.magenta>使用更昂贵的信号处理机制</c>

107
00:06:26,486 --> 00:06:31,491
<c.magenta>或者节点 比如说播放器节点</c>

108
00:06:31,825 --> 00:06:35,395
<c.magenta>直到准备好全部输入数据</c>

109
00:06:36,530 --> 00:06:38,999
<c.magenta>但这些事可能不会 将不会发生</c>

110
00:06:39,066 --> 00:06:41,702
<c.magenta>当节点在进行实时渲染时</c>

111
00:06:42,069 --> 00:06:43,036
<c.magenta>我们稍后再看</c>

112
00:06:44,938 --> 00:06:49,109
<c.magenta>让我们思考一个简单的例子</c>

113
00:06:51,478 --> 00:06:52,846
<c.magenta>这里有个例子</c>

114
00:06:53,146 --> 00:06:57,317
<c.magenta>应用想要在源文件中处理音频数据</c>

115
00:06:57,718 --> 00:07:00,020
<c.magenta>我会给那个数据添加一些效果</c>

116
00:06:57,718 --> 00:07:00,020
<c.magenta>我会给那个数据添加一些效果</c>

117
00:07:00,187 --> 00:07:03,190
<c.magenta>并把处理输出数据转储到目标文件中</c>

118
00:07:04,258 --> 00:07:07,961
<c.magenta>正如你所看到的</c>

119
00:07:08,195 --> 00:07:12,699
<c.magenta>由此 应用现在可以</c>

120
00:07:13,467 --> 00:07:17,437
<c.magenta>它会在Engine中设置一个</c>

121
00:07:18,005 --> 00:07:21,675
<c.magenta>它会使用PlayerNode</c>

122
00:07:22,442 --> 00:07:25,779
<c.magenta>通过EffectNode处理它</c>

123
00:07:26,380 --> 00:07:29,016
<c.magenta>然后把数据从OutputNode中拉出来</c>

124
00:07:29,082 --> 00:07:31,785
<c.magenta>并把处理数据驱动到目标文件中</c>

125
00:07:32,753 --> 00:07:38,325
<c.magenta>我们很快就会在接下来的几张幻灯片中</c>

126
00:07:40,327 --> 00:07:43,797
<c.magenta>还有许多应用可以使用脱机模式</c>

127
00:07:44,364 --> 00:07:45,799
<c.magenta>这里列出了其中一些</c>

128
00:07:46,533 --> 00:07:50,204
<c.magenta>除了我刚提到过的音频文件的后处理</c>

129
00:07:50,404 --> 00:07:54,575
<c.magenta>你还可以使用脱机模式</c>

130
00:07:55,509 --> 00:07:58,178
<c.magenta>你可以用于脱机处理</c>

131
00:07:58,245 --> 00:08:02,049
<c.magenta>通过一个CPU密集型或高质量算法</c>

132
00:07:58,245 --> 00:08:02,049
<c.magenta>通过一个CPU密集型或高质量算法</c>

133
00:08:02,115 --> 00:08:04,284
<c.magenta>可能不适合在实时条件下使用</c>

134
00:08:05,352 --> 00:08:07,654
<c.magenta>或者简单地说 你可以使用脱机模式</c>

135
00:08:07,988 --> 00:08:11,892
<c.magenta>进行测试、调试或调整</c>

136
00:08:14,228 --> 00:08:17,030
<c.magenta>那么正如我所承诺过的总结了脱机模式</c>

137
00:08:17,097 --> 00:08:19,333
<c.magenta>我会实际展示一个演示</c>

138
00:08:23,103 --> 00:08:28,242
<c.magenta>好了 那么这是一个</c>

139
00:08:29,176 --> 00:08:30,010
<c.magenta>并且</c>

140
00:08:30,210 --> 00:08:32,712
<c.magenta>这也是我们要在源文件中后处理</c>

141
00:08:32,779 --> 00:08:34,548
<c.magenta>音频数据的例子</c>

142
00:08:34,847 --> 00:08:37,351
<c.magenta>在数据上应用一个混响效果</c>

143
00:08:37,618 --> 00:08:40,187
<c.magenta>把输出转储到目标文件中</c>

144
00:08:41,121 --> 00:08:44,491
<c.magenta>这里有一些代码片段</c>

145
00:08:45,859 --> 00:08:51,798
<c.magenta>那么我要做的第一件事就是</c>

146
00:08:51,865 --> 00:08:56,570
<c.magenta>在实时模式下针对设备进行渲染</c>

147
00:08:56,637 --> 00:08:59,173
<c.magenta>当不添加任何效果时</c>

148
00:09:01,775 --> 00:09:06,580
<c.magenta>那么我首先打开我要读取的源文件</c>

149
00:09:08,215 --> 00:09:11,785
<c.magenta>然后创建并配置我的Engine</c>

150
00:09:12,486 --> 00:09:15,589
<c.magenta>那么我有一个Engine</c>

151
00:09:16,490 --> 00:09:19,993
<c.magenta>我要把播放器</c>

152
00:09:20,294 --> 00:09:23,564
<c.magenta>它隐含地连接到了</c>

153
00:09:25,632 --> 00:09:28,802
<c.magenta>然后我要为播放器上的</c>

154
00:09:28,869 --> 00:09:31,071
<c.magenta>以便播放器可以从源文件中读取数据</c>

155
00:09:32,239 --> 00:09:35,008
<c.magenta>然后我就开启Engine</c>

156
00:09:35,776 --> 00:09:38,512
<c.magenta>正如我所提到过的</c>

157
00:09:38,579 --> 00:09:41,315
<c.magenta>这将会针渲染到设备中</c>

158
00:09:41,515 --> 00:09:45,385
<c.magenta>那么让我们听听没有任何效果的</c>

159
00:09:55,128 --> 00:09:56,196
<c.magenta>好的 这是</c>

160
00:09:56,263 --> 00:10:01,101
<c.magenta>源文件的声音 那么现在我要做的是</c>

161
00:09:56,263 --> 00:10:01,101
<c.magenta>源文件的声音 那么现在我要做的是</c>

162
00:10:01,168 --> 00:10:04,438
<c.magenta>添加一个混响来处理数据</c>

163
00:10:05,472 --> 00:10:08,375
<c.magenta>那么我要把播放器</c>

164
00:10:09,109 --> 00:10:10,711
<c.magenta>我要插入混响</c>

165
00:10:11,745 --> 00:10:13,580
<c.magenta>那么在这里 我创建了一个混响</c>

166
00:10:14,147 --> 00:10:16,583
<c.magenta>并且设置了混响的参数</c>

167
00:10:16,750 --> 00:10:19,920
<c.magenta>在本例中</c>

168
00:10:20,587 --> 00:10:23,257
<c.magenta>而wetDryMix为70%</c>

169
00:10:24,057 --> 00:10:27,027
<c.magenta>然后我要在播放部分插入混响</c>

170
00:10:27,227 --> 00:10:29,196
<c.magenta>在播放器和主混音器之间</c>

171
00:10:30,330 --> 00:10:35,802
<c.magenta>那么现在如果我运行这个示例</c>

172
00:10:46,213 --> 00:10:49,850
<c.magenta>好的 那么现在这点上</c>

173
00:10:49,917 --> 00:10:53,387
<c.magenta>并调节我的混响参数</c>

174
00:10:53,720 --> 00:10:55,622
<c.magenta>那么假如我对全部参数都很满意</c>

175
00:10:55,689 --> 00:10:59,927
<c.magenta>那么现在我要把我的源文件</c>

176
00:11:00,260 --> 00:11:02,529
<c.magenta>并且这就是脱机模式起作用的地方</c>

177
00:11:03,830 --> 00:11:05,566
<c.magenta>那么我首先要做的是</c>

178
00:11:06,900 --> 00:11:10,671
<c.magenta>我会启动…我会把Engine</c>

179
00:11:18,045 --> 00:11:19,513
<c.magenta>那么我所要做的就是</c>

180
00:11:20,714 --> 00:11:24,952
<c.magenta>调用启用手动渲染模式API</c>

181
00:11:25,118 --> 00:11:27,254
<c.magenta>“它需要成为脱机变体”</c>

182
00:11:28,222 --> 00:11:32,726
<c.magenta>我要指定我希望Engine</c>

183
00:11:33,193 --> 00:11:36,263
<c.magenta>那么在本例中输出格式</c>

184
00:11:37,764 --> 00:11:40,834
<c.magenta>然后我会指定最大帧数</c>

185
00:11:41,068 --> 00:11:43,203
<c.magenta>也就是你请求Engine</c>

186
00:11:43,270 --> 00:11:45,472
<c.magenta>在单一渲染调用中</c>

187
00:11:45,539 --> 00:11:47,174
<c.magenta>进行渲染的最大帧数</c>

188
00:11:47,641 --> 00:11:50,444
<c.magenta>那么在本例中 这个值是4096</c>

189
00:11:50,711 --> 00:11:53,080
<c.magenta>但你可以随你自己的意愿进行配置</c>

190
00:11:54,715 --> 00:11:57,618
<c.magenta>那么现在如果我继续并运行这个示例</c>

191
00:11:59,286 --> 00:12:02,589
<c.magenta>什么也不会发生</c>

192
00:11:59,286 --> 00:12:02,589
<c.magenta>什么也不会发生</c>

193
00:12:02,823 --> 00:12:03,991
<c.magenta>它已准备好进行渲染了</c>

194
00:12:04,324 --> 00:12:08,495
<c.magenta>但当然了 它正在等待应用</c>

195
00:12:09,496 --> 00:12:13,767
<c.magenta>那么我们接下来要做的其实是</c>

196
00:12:16,937 --> 00:12:22,576
<c.magenta>那么在这里我创建了一个输出文件</c>

197
00:12:25,112 --> 00:12:29,483
<c.magenta>我还创建了一个输出缓冲区</c>

198
00:12:29,550 --> 00:12:31,885
<c.magenta>在每个渲染调用中循序地渲染到</c>

199
00:12:32,619 --> 00:12:35,088
<c.magenta>缓冲区的格式与我之前</c>

200
00:12:35,155 --> 00:12:38,625
<c.magenta>启用脱机模式时提到过的格式一样</c>

201
00:12:40,761 --> 00:12:42,296
<c.magenta>然后就是渲染循环</c>

202
00:12:42,362 --> 00:12:45,532
<c.magenta>我会持续从渲染循环中</c>

203
00:12:46,200 --> 00:12:49,870
<c.magenta>现在 在本例中 我有一个源文件</c>

204
00:12:50,504 --> 00:12:52,439
<c.magenta>那么我其实不想分配</c>

205
00:12:52,506 --> 00:12:55,809
<c.magenta>一个巨大的输出缓冲区</c>

206
00:12:55,876 --> 00:12:58,478
<c.magenta>在单一渲染调用中</c>

207
00:12:58,946 --> 00:13:00,280
<c.magenta>这也是为什么我要</c>

208
00:12:58,946 --> 00:13:00,280
<c.magenta>这也是为什么我要</c>

209
00:13:00,347 --> 00:13:03,917
<c.magenta>分配一个大小合理的输出缓冲区的原因</c>

210
00:13:04,251 --> 00:13:07,888
<c.magenta>但会持续地拉动Engine</c>

211
00:13:07,955 --> 00:13:10,224
<c.magenta>然后把输出数据转储到目标文件中</c>

212
00:13:12,292 --> 00:13:15,963
<c.magenta>那么在每个迭代中 我都要确定</c>

213
00:13:16,029 --> 00:13:18,065
<c.magenta>在这个渲染调用中要渲染的帧数</c>

214
00:13:18,532 --> 00:13:21,201
<c.magenta>并且我会在Engine上</c>

215
00:13:21,268 --> 00:13:23,837
<c.magenta>要求它渲染那么多数量的帧</c>

216
00:13:24,071 --> 00:13:26,974
<c.magenta>并给它提供我们刚才分配的输出缓冲区</c>

217
00:13:27,875 --> 00:13:30,544
<c.magenta>根据状态 如果它渲染成功</c>

218
00:13:30,944 --> 00:13:34,448
<c.magenta>成功渲染了数据 那么我就继续</c>

219
00:13:34,648 --> 00:13:36,850
<c.magenta>并把数据拖拽到我的输出文件中</c>

220
00:13:37,351 --> 00:13:39,987
<c.magenta>万一它渲染失败</c>

221
00:13:40,053 --> 00:13:43,557
<c.magenta>那么你可以查看错误代码</c>

222
00:13:44,591 --> 00:13:46,593
<c.magenta>那么最终 当渲染完成后</c>

223
00:13:46,660 --> 00:13:49,263
<c.magenta>我会停止播放器并停止Engine</c>

224
00:13:50,097 --> 00:13:53,166
<c.magenta>那么现在如果我继续</c>

225
00:13:53,233 --> 00:13:57,237
<c.magenta>整个源文件都将被输出</c>

226
00:13:57,804 --> 00:13:58,805
<c.magenta>那么让我们来试试</c>

227
00:14:02,809 --> 00:14:06,547
<c.magenta>好的 那么你可能观察到了</c>

228
00:14:06,980 --> 00:14:11,485
<c.magenta>源文件被渲染到了一个输出文件中</c>

229
00:14:11,552 --> 00:14:13,187
<c.magenta>比实时模式下更快</c>

230
00:14:13,453 --> 00:14:16,423
<c.magenta>这是脱机渲染模式的主要应用之一</c>

231
00:14:17,357 --> 00:14:21,795
<c.magenta>那么我们接下来要做的就是</c>

232
00:14:22,996 --> 00:14:29,570
<c.magenta>和目标文件 确保数据确实经过了处理</c>

233
00:14:30,037 --> 00:14:31,705
<c.magenta>那么这是我的源文件</c>

234
00:14:33,106 --> 00:14:35,275
<c.magenta>这是我的目标文件</c>

235
00:14:39,012 --> 00:14:41,248
<c.magenta>那么首先让我们先听听源文件</c>

236
00:14:50,057 --> 00:14:52,259
<c.magenta>那么正如你所听到的 它很干燥</c>

237
00:14:53,093 --> 00:14:53,927
<c.magenta>而现在</c>

238
00:14:54,361 --> 00:14:55,429
<c.magenta>这是处理过的文件</c>

239
00:15:04,204 --> 00:15:05,973
<c.magenta>好的 那么正如我们所期待的</c>

240
00:15:06,039 --> 00:15:08,475
<c.magenta>处理过的数据中添加了混响效果</c>

241
00:15:09,676 --> 00:15:13,480
<c.magenta>那么这就对脱机渲染</c>

242
00:15:13,547 --> 00:15:15,616
<c.magenta>我要切换回幻灯片</c>

243
00:15:19,119 --> 00:15:23,657
<c.magenta>（演示</c>

244
00:15:25,025 --> 00:15:27,194
<c.magenta>那么正如我所提到过的 脱机渲染模式</c>

245
00:15:27,261 --> 00:15:28,529
<c.magenta>有许多种应用方式</c>

246
00:15:28,929 --> 00:15:34,401
<c.magenta>那么我很高兴地告诉大家</c>

247
00:15:34,468 --> 00:15:36,803
<c.magenta>可以从我们演讲的主页上看到</c>

248
00:15:36,970 --> 00:15:40,440
<c.magenta>在演讲的最后</c>

249
00:15:42,709 --> 00:15:45,679
<c.magenta>现在让我们进入</c>

250
00:15:46,380 --> 00:15:48,015
<c.magenta>实时手动进入模式</c>

251
00:15:48,849 --> 00:15:51,451
<c.magenta>正如它的名字所暗指的 在这种模式下</c>

252
00:15:51,518 --> 00:15:54,388
<c.magenta>你处理图中的Engine和全部节点</c>

253
00:15:54,588 --> 00:15:57,925
<c.magenta>将会假设它们正在实时情境下进行渲染</c>

254
00:15:58,325 --> 00:16:01,028
<c.magenta>由此 它们会遵从实时约束</c>

255
00:15:58,325 --> 00:16:01,028
<c.magenta>由此 它们会遵从实时约束</c>

256
00:16:01,728 --> 00:16:06,466
<c.magenta>也就是说它们不会在渲染线程上</c>

257
00:16:06,967 --> 00:16:09,603
<c.magenta>比如它们将不会调用任何</c>

258
00:16:10,170 --> 00:16:13,407
<c.magenta>它们将不会分配内存</c>

259
00:16:14,308 --> 00:16:15,876
<c.magenta>因为这个约束</c>

260
00:16:16,043 --> 00:16:19,446
<c.magenta>假如节点的输入数据不能及时准备好</c>

261
00:16:19,980 --> 00:16:22,516
<c.magenta>节点就别无其它选择 但会表明</c>

262
00:16:22,583 --> 00:16:25,118
<c.magenta>“给那个渲染循环删除数据</c>

263
00:16:25,185 --> 00:16:27,454
<c.magenta>或假定为零并继续 ”</c>

264
00:16:29,957 --> 00:16:31,959
<c.magenta>现在让我们看看在实时手动渲染模式下</c>

265
00:16:32,025 --> 00:16:33,961
<c.magenta>要在哪里使用Engine</c>

266
00:16:35,495 --> 00:16:38,131
<c.magenta>假如你有一个自定义AU音频单元</c>

267
00:16:38,966 --> 00:16:41,735
<c.magenta>位于实时播放部分</c>

268
00:16:42,102 --> 00:16:45,105
<c.magenta>并且在音频单元的内部渲染组块内</c>

269
00:16:45,372 --> 00:16:48,642
<c.magenta>你想处理所接收的数据</c>

270
00:16:48,709 --> 00:16:52,079
<c.magenta>通过一台或几台其它音频单元</c>

271
00:16:52,846 --> 00:16:57,718
<c.magenta>在那种情况下 你可以设置Engine</c>

272
00:16:57,784 --> 00:17:01,288
<c.magenta>并在实时手动渲染模式下处理数据</c>

273
00:16:57,784 --> 00:17:01,288
<c.magenta>并在实时手动渲染模式下处理数据</c>

274
00:17:02,856 --> 00:17:05,659
<c.magenta>第二个例子是假如你想处理</c>

275
00:17:05,726 --> 00:17:08,462
<c.magenta>电影或视频中的音频数据</c>

276
00:17:08,694 --> 00:17:10,696
<c.magenta>当它正在播放或回放时</c>

277
00:17:11,498 --> 00:17:14,367
<c.magenta>因为这是实时发生的</c>

278
00:17:14,434 --> 00:17:17,871
<c.magenta>在实时手动渲染模式下</c>

279
00:17:18,704 --> 00:17:21,008
<c.magenta>那么现在让我们思考第二种用例</c>

280
00:17:21,241 --> 00:17:24,111
<c.magenta>看如何设置和使用Engine</c>

281
00:17:24,444 --> 00:17:26,613
<c.magenta>作为代码示例</c>

282
00:17:28,749 --> 00:17:33,420
<c.magenta>那么这是接收输入电影数据流的应用</c>

283
00:17:33,854 --> 00:17:37,090
<c.magenta>并实时显示 假如说在电视上实时显示</c>

284
00:17:37,658 --> 00:17:40,761
<c.magenta>但它想要做的是在输入中处理音频数据</c>

285
00:17:40,827 --> 00:17:44,498
<c.magenta>在它进入输出之前</c>

286
00:17:45,732 --> 00:17:49,870
<c.magenta>那么现在它可以使用</c>

287
00:17:50,704 --> 00:17:53,874
<c.magenta>那么它可以设置一个这样的处理图</c>

288
00:17:53,941 --> 00:17:56,777
<c.magenta>它可以通过输入节点提供输入</c>

289
00:17:57,377 --> 00:17:59,179
<c.magenta>通过效果节点处理它</c>

290
00:17:59,479 --> 00:18:01,648
<c.magenta>然后从输出节点中拉动数据</c>

291
00:17:59,479 --> 00:18:01,648
<c.magenta>然后从输出节点中拉动数据</c>

292
00:18:01,715 --> 00:18:04,785
<c.magenta>并在设备上播放</c>

293
00:18:07,187 --> 00:18:08,889
<c.magenta>现在让我们看一个代码示例</c>

294
00:18:08,956 --> 00:18:11,992
<c.magenta>关于如何设置</c>

295
00:18:16,630 --> 00:18:17,631
<c.magenta>那么这是代码</c>

296
00:18:17,998 --> 00:18:21,134
<c.magenta>请注意设置Engine自身</c>

297
00:18:21,201 --> 00:18:25,873
<c.magenta>是从非实时情境中发生的</c>

298
00:18:25,939 --> 00:18:28,275
<c.magenta>才实际发生在实时情境中</c>

299
00:18:28,742 --> 00:18:32,713
<c.magenta>那么这是设置代码</c>

300
00:18:34,248 --> 00:18:38,919
<c.magenta>默认为Engine一经创建</c>

301
00:18:38,986 --> 00:18:41,822
<c.magenta>除非你把它切换到手动渲染模式</c>

302
00:18:42,756 --> 00:18:45,492
<c.magenta>那么你清除了Engine</c>

303
00:18:45,659 --> 00:18:48,862
<c.magenta>然后把它切换回手动渲染模式</c>

304
00:18:49,563 --> 00:18:51,999
<c.magenta>这个是与我们在演示中</c>

305
00:18:52,165 --> 00:18:55,969
<c.magenta>除了我们现在要表达的内容</c>

306
00:18:56,203 --> 00:18:58,639
<c.magenta>在实时手动渲染模式下运作</c>

307
00:18:59,273 --> 00:19:03,544
<c.magenta>指定输出格式和最大帧数</c>

308
00:18:59,273 --> 00:19:03,544
<c.magenta>指定输出格式和最大帧数</c>

309
00:19:05,279 --> 00:19:08,048
<c.magenta>接下来你要做的就是搜索和缓存</c>

310
00:19:08,115 --> 00:19:10,450
<c.magenta>这被称为放弃组块</c>

311
00:19:10,918 --> 00:19:15,122
<c.magenta>现在因为Engine的渲染</c>

312
00:19:15,355 --> 00:19:18,825
<c.magenta>你将不能使用我们在刚才的演示中</c>

313
00:19:18,892 --> 00:19:20,928
<c.magenta>或Swift元数据</c>

314
00:19:21,295 --> 00:19:22,329
<c.magenta>这是因为</c>

315
00:19:22,529 --> 00:19:26,934
<c.magenta>在实时情境中使用Objective-C</c>

316
00:19:27,367 --> 00:19:30,404
<c.magenta>那么相反</c>

317
00:19:30,604 --> 00:19:34,141
<c.magenta>你可以用于搜索和缓存</c>

318
00:19:34,208 --> 00:19:36,710
<c.magenta>在实时情境中渲染Engine</c>

319
00:19:38,545 --> 00:19:41,849
<c.magenta>接下来…要做的是设置你的输入节点</c>

320
00:19:41,915 --> 00:19:44,618
<c.magenta>从而给Engine提供输入数据</c>

321
00:19:45,352 --> 00:19:50,390
<c.magenta>在这里你要指定你将提供的输入格式</c>

322
00:19:50,457 --> 00:19:53,060
<c.magenta>输入格式可以和输出格式不一样</c>

323
00:19:54,094 --> 00:19:57,431
<c.magenta>并且你还要提供Engine</c>

324
00:19:57,497 --> 00:19:59,600
<c.magenta>无论何时当它需要输入数据时</c>

325
00:20:01,969 --> 00:20:05,239
<c.magenta>当调用这个组块后</c>

326
00:20:05,305 --> 00:20:07,941
<c.magenta>它实际需要多少输入帧数</c>

327
00:20:08,542 --> 00:20:14,181
<c.magenta>在那点上 如果你有数据</c>

328
00:20:14,414 --> 00:20:15,983
<c.magenta>并将其返回给Engine</c>

329
00:20:16,817 --> 00:20:20,053
<c.magenta>但如果你没有数据</c>

330
00:20:21,455 --> 00:20:24,725
<c.magenta>现在请注意 输入节点既可用于脱机</c>

331
00:20:24,791 --> 00:20:26,693
<c.magenta>又可用于实时手动渲染模式</c>

332
00:20:27,227 --> 00:20:30,330
<c.magenta>但是当你在实时手动渲染模式中使用时</c>

333
00:20:30,697 --> 00:20:34,401
<c.magenta>就会在实时情境中</c>

334
00:20:34,668 --> 00:20:38,105
<c.magenta>意思就是你需要注意</c>

335
00:20:38,172 --> 00:20:41,575
<c.magenta>不要在这个输入组块内截断任何调用</c>

336
00:20:43,644 --> 00:20:46,647
<c.magenta>接下来的设置是要清除你的输出缓冲区</c>

337
00:20:47,314 --> 00:20:51,418
<c.magenta>这里的不同之处在于：</c>

338
00:20:51,685 --> 00:20:55,389
<c.magenta>并获取它的音频缓冲区列表 这将用在</c>

339
00:20:55,455 --> 00:20:57,391
<c.magenta>实时渲染逻辑中</c>

340
00:20:58,692 --> 00:21:00,961
<c.magenta>最后你要继续并启动Engine</c>

341
00:20:58,692 --> 00:21:00,961
<c.magenta>最后你要继续并启动Engine</c>

342
00:21:01,562 --> 00:21:04,298
<c.magenta>那么现在Engine已经设置好了</c>

343
00:21:04,364 --> 00:21:08,068
<c.magenta>它正在等待应用拉动输出数据</c>

344
00:21:10,737 --> 00:21:13,340
<c.magenta>现在这是实际的渲染逻辑</c>

345
00:21:14,007 --> 00:21:17,344
<c.magenta>请注意这部分代码使用C++写的</c>

346
00:21:17,611 --> 00:21:22,182
<c.magenta>这是因为正如我所提到过的</c>

347
00:21:22,249 --> 00:21:25,452
<c.magenta>或Swift运行时间不安全</c>

348
00:21:26,520 --> 00:21:31,191
<c.magenta>那么我们首先要做的就是：</c>

349
00:21:31,758 --> 00:21:34,528
<c.magenta>并请求Engine渲染指定数量的帧</c>

350
00:21:34,595 --> 00:21:37,064
<c.magenta>并将其提供给</c>

351
00:21:38,098 --> 00:21:41,635
<c.magenta>最终根据状态 如果成功</c>

352
00:21:41,702 --> 00:21:45,539
<c.magenta>意味着一切都没问题</c>

353
00:21:46,206 --> 00:21:51,645
<c.magenta>但你还会从输入备注中获取不完整数据</c>

354
00:21:51,712 --> 00:21:56,984
<c.magenta>当Engine调用你的输入组块</c>

355
00:21:57,184 --> 00:22:01,054
<c.magenta>那个输入组块中的空对象中</c>

356
00:21:57,184 --> 00:22:01,054
<c.magenta>那个输入组块中的空对象中</c>

357
00:22:01,922 --> 00:22:02,956
<c.magenta>请注意</c>

358
00:22:03,023 --> 00:22:05,425
<c.magenta>在这种情况下</c>

359
00:22:05,492 --> 00:22:08,962
<c.magenta>比如说你有一些播放器备注</c>

360
00:22:09,363 --> 00:22:12,065
<c.magenta>这些备注将仍然会渲染输入数据</c>

361
00:22:12,132 --> 00:22:16,036
<c.magenta>那么你可能仍然会在输出缓冲区中</c>

362
00:22:16,103 --> 00:22:18,338
<c.magenta>查看输出缓冲区的大小</c>

363
00:22:18,405 --> 00:22:20,874
<c.magenta>从而判断是否有数据</c>

364
00:22:22,309 --> 00:22:26,747
<c.magenta>当然了 你要处理包含错误的其它状态</c>

365
00:22:27,047 --> 00:22:31,318
<c.magenta>在实时手动渲染模式下的渲染逻辑中</c>

366
00:22:34,188 --> 00:22:37,558
<c.magenta>现在最后是渲染原因上的备注</c>

367
00:22:38,292 --> 00:22:41,461
<c.magenta>在脱机模式下</c>

368
00:22:41,528 --> 00:22:45,599
<c.magenta>你可以使用Objective-C</c>

369
00:22:45,966 --> 00:22:48,802
<c.magenta>或可以基于渲染调用使用渲染组块</c>

370
00:22:48,869 --> 00:22:50,270
<c.magenta>以渲染Engine</c>

371
00:22:50,804 --> 00:22:55,309
<c.magenta>但在实时手动渲染模式下</c>

372
00:22:57,144 --> 00:22:59,880
<c.magenta>那么这就是手动渲染模式</c>

373
00:23:00,180 --> 00:23:05,285
<c.magenta>现在让我们看看</c>

374
00:23:05,352 --> 00:23:07,020
<c.magenta>即自动关闭模式</c>

375
00:23:09,356 --> 00:23:12,125
<c.magenta>现在通常是应用要</c>

376
00:23:12,392 --> 00:23:15,629
<c.magenta>暂停或停止Engine 当不使用时</c>

377
00:23:15,863 --> 00:23:17,130
<c.magenta>以便节约电量</c>

378
00:23:17,998 --> 00:23:22,035
<c.magenta>比如假如说我们有一个音乐应用</c>

379
00:23:22,236 --> 00:23:24,638
<c.magenta>来播放某个文件</c>

380
00:23:25,138 --> 00:23:27,474
<c.magenta>那么比如说 用户停止了播放</c>

381
00:23:28,141 --> 00:23:32,312
<c.magenta>现在应用不应该仅仅暂停</c>

382
00:23:32,546 --> 00:23:34,915
<c.magenta>还应该暂停或停止Engine</c>

383
00:23:35,315 --> 00:23:37,451
<c.magenta>以防止它空转</c>

384
00:23:38,418 --> 00:23:42,222
<c.magenta>但在过去 我们看到并不是</c>

385
00:23:42,289 --> 00:23:44,925
<c.magenta>尤其是在watchOS上</c>

386
00:23:45,359 --> 00:23:48,262
<c.magenta>由此 我们现在添加了安全网</c>

387
00:23:48,328 --> 00:23:51,732
<c.magenta>以通过这个自动关闭模式节约电量</c>

388
00:23:52,866 --> 00:23:55,235
<c.magenta>当Engine在这个模式下运作时</c>

389
00:23:56,136 --> 00:23:59,907
<c.magenta>它将持续监控</c>

390
00:23:59,973 --> 00:24:02,643
<c.magenta>空转了一段指定的时间</c>

391
00:23:59,973 --> 00:24:02,643
<c.magenta>空转了一段指定的时间</c>

392
00:24:02,709 --> 00:24:05,746
<c.magenta>它将停止音频硬件并删除</c>

393
00:24:06,280 --> 00:24:09,483
<c.magenta>那么稍后 假如任意资源再次被激活</c>

394
00:24:09,550 --> 00:24:11,785
<c.magenta>它将动态地开启音频硬件</c>

395
00:24:12,352 --> 00:24:14,087
<c.magenta>全部这些都是在底层发生的</c>

396
00:24:15,155 --> 00:24:17,724
<c.magenta>这是在watchOS上的强制性行为</c>

397
00:24:17,891 --> 00:24:21,094
<c.magenta>但它还可以在其它平台上选择启动</c>

398
00:24:23,564 --> 00:24:27,467
<c.magenta>现在下一个增强功能</c>

399
00:24:29,736 --> 00:24:32,739
<c.magenta>AV音频播放器节点</c>

400
00:24:33,073 --> 00:24:36,476
<c.magenta>通过这个你可以</c>

401
00:24:37,911 --> 00:24:41,882
<c.magenta>现有的安排方法是通过一个结束处理器</c>

402
00:24:42,216 --> 00:24:44,718
<c.magenta>它们调用结束处理器</c>

403
00:24:44,785 --> 00:24:47,554
<c.magenta>被播放器消耗完之后</c>

404
00:24:48,989 --> 00:24:53,093
<c.magenta>我们现在添加了新的结束处理器</c>

405
00:24:53,360 --> 00:24:57,231
<c.magenta>以便让你了解结束的各种不同阶段</c>

406
00:24:58,999 --> 00:25:03,370
<c.magenta>第一个新回调类型是数据消耗类型</c>

407
00:24:58,999 --> 00:25:03,370
<c.magenta>第一个新回调类型是数据消耗类型</c>

408
00:25:03,604 --> 00:25:06,773
<c.magenta>这与现有的结束处理器一模一样</c>

409
00:25:07,207 --> 00:25:10,644
<c.magenta>也就是说 当调用结束处理器时</c>

410
00:25:10,711 --> 00:25:13,247
<c.magenta>意味着数据已经被播放器消耗完了</c>

411
00:25:13,714 --> 00:25:17,618
<c.magenta>那么在那点上 如果你想</c>

412
00:25:17,885 --> 00:25:21,922
<c.magenta>或者如果你在播放器上安排了更多数据</c>

413
00:25:23,223 --> 00:25:26,059
<c.magenta>第二种回调类型是数据渲染回调</c>

414
00:25:26,393 --> 00:25:29,162
<c.magenta>意思就是你所提供的数据</c>

415
00:25:29,229 --> 00:25:32,199
<c.magenta>已经被渲染完成了</c>

416
00:25:33,033 --> 00:25:37,271
<c.magenta>并且这不会导致信号处理延迟后移</c>

417
00:25:37,337 --> 00:25:39,273
<c.magenta>在你的处理图中</c>

418
00:25:40,541 --> 00:25:43,110
<c.magenta>最后一种类型是数据播放类型</c>

419
00:25:43,177 --> 00:25:44,878
<c.magenta>也是最有意思的一个</c>

420
00:25:45,179 --> 00:25:48,215
<c.magenta>它的意思是当你调用结束处理器时</c>

421
00:25:48,515 --> 00:25:50,851
<c.magenta>缓冲区或你所安排的文件</c>

422
00:25:50,918 --> 00:25:54,188
<c.magenta>实际已经完成了播放</c>

423
00:25:54,988 --> 00:25:56,890
<c.magenta>只有当Engine</c>

424
00:25:56,957 --> 00:25:58,392
<c.magenta>渲染到设备时才可适用</c>

425
00:25:59,059 --> 00:26:02,029
<c.magenta>这会导致全部信号处理延迟</c>

426
00:25:59,059 --> 00:26:02,029
<c.magenta>这会导致全部信号处理延迟</c>

427
00:26:02,229 --> 00:26:04,965
<c.magenta>你处理图中的播放器后移</c>

428
00:26:05,032 --> 00:26:08,335
<c.magenta>以及音频播放设备的延迟</c>

429
00:26:09,837 --> 00:26:14,007
<c.magenta>那么作为一个代码示例</c>

430
00:26:14,074 --> 00:26:16,543
<c.magenta>通过这个你可以为播放安排文件</c>

431
00:26:17,277 --> 00:26:19,746
<c.magenta>那么在这里 我正在给播放安排文件</c>

432
00:26:19,813 --> 00:26:23,917
<c.magenta>我指明我有兴趣了解何时播放数据</c>

433
00:26:25,152 --> 00:26:27,521
<c.magenta>那个空对象 我要提供一个结束处理器</c>

434
00:26:28,021 --> 00:26:31,258
<c.magenta>然后当调用结束处理器时</c>

435
00:26:31,325 --> 00:26:34,127
<c.magenta>已经完成播放 那么在这点上</c>

436
00:26:34,194 --> 00:26:36,530
<c.magenta>“通知我的UI线程更新UI”</c>

437
00:26:36,597 --> 00:26:38,699
<c.magenta>或者我可以通知我的主线程</c>

438
00:26:38,765 --> 00:26:41,168
<c.magenta>停止Engine 如果适用的话</c>

439
00:26:43,170 --> 00:26:44,905
<c.magenta>那么这就是</c>

440
00:26:44,972 --> 00:26:47,774
<c.magenta>AVAudio Engine中的</c>

441
00:26:48,475 --> 00:26:50,477
<c.magenta>在这点上 我还想提一下</c>

442
00:26:50,544 --> 00:26:54,448
<c.magenta>我们很快就会在2018年弃用</c>

443
00:26:54,515 --> 00:26:58,051
<c.magenta>音频工具箱框架中的</c>

444
00:26:58,118 --> 00:27:01,989
<c.magenta>所以请着手使用AVAudio Engine</c>

445
00:26:58,118 --> 00:27:01,989
<c.magenta>所以请着手使用AVAudio Engine</c>

446
00:27:02,055 --> 00:27:03,557
<c.magenta>如果你还没有这样做的话</c>

447
00:27:06,727 --> 00:27:10,564
<c.magenta>现在让我们谈谈</c>

448
00:27:10,631 --> 00:27:11,698
<c.magenta>AV音频会话</c>

449
00:27:13,967 --> 00:27:17,838
<c.magenta>在今年发布的iOS、tvOS</c>

450
00:27:17,905 --> 00:27:19,806
<c.magenta>AirPlay 2是一个全新的技术</c>

451
00:27:20,641 --> 00:27:25,112
<c.magenta>通过装有AirPlay 2的设备</c>

452
00:27:25,345 --> 00:27:26,980
<c.magenta>比如说Homepod</c>

453
00:27:29,116 --> 00:27:32,953
<c.magenta>那么有一个单独的专题演讲</c>

454
00:27:33,020 --> 00:27:35,088
<c.magenta>时间为本周四下午4:10</c>

455
00:27:35,589 --> 00:27:39,259
<c.magenta>那场演讲将具体分析</c>

456
00:27:39,326 --> 00:27:42,529
<c.magenta>那么你可以考虑参加那场演讲</c>

457
00:27:44,331 --> 00:27:47,935
<c.magenta>同时与AirPlay 2共同发布的</c>

458
00:27:48,435 --> 00:27:53,273
<c.magenta>这是一系列的内容 比如音乐或播客</c>

459
00:27:53,540 --> 00:27:56,710
<c.magenta>一般只有几分钟的长度</c>

460
00:27:57,077 --> 00:27:59,980
<c.magenta>可以与其它人共享播放</c>

461
00:28:00,914 --> 00:28:03,217
<c.magenta>比如 假如说你在家办聚会</c>

462
00:28:03,450 --> 00:28:06,086
<c.magenta>你通过AirPlay设备播放一个</c>

463
00:28:06,153 --> 00:28:09,590
<c.magenta>现在这将被分类为…</c>

464
00:28:09,656 --> 00:28:10,924
<c.magenta>那将被分类</c>

465
00:28:10,991 --> 00:28:12,426
<c.magenta>为长格式音频内容</c>

466
00:28:13,861 --> 00:28:16,430
<c.magenta>现在通过AirPlay 2</c>

467
00:28:16,663 --> 00:28:21,668
<c.magenta>我们现在获得了一个独立的共享路径</c>

468
00:28:21,902 --> 00:28:23,303
<c.magenta>到AirPlay 2设备</c>

469
00:28:23,871 --> 00:28:27,708
<c.magenta>我稍后再详细解释更多</c>

470
00:28:28,909 --> 00:28:32,946
<c.magenta>好的…现在我们在AV音频会话中</c>

471
00:28:33,013 --> 00:28:36,416
<c.magenta>应用可以将自己识别为长格式</c>

472
00:28:36,583 --> 00:28:40,654
<c.magenta>并利用这个独立的共享音频路径</c>

473
00:28:42,689 --> 00:28:45,692
<c.magenta>那么让我们思考一下我刚提到的例子</c>

474
00:28:45,759 --> 00:28:49,530
<c.magenta>那么假如我们在家里办聚会</c>

475
00:28:49,596 --> 00:28:50,764
<c.magenta>AirPlay设备上播放音乐</c>

476
00:28:51,431 --> 00:28:55,502
<c.magenta>我们将对比当前行为</c>

477
00:28:55,569 --> 00:28:57,271
<c.magenta>与长格式音频路径行为</c>

478
00:28:57,638 --> 00:28:59,239
<c.magenta>那么这是当前行为</c>

479
00:28:59,840 --> 00:29:03,911
<c.magenta>那么你…现在正在通过</c>

480
00:28:59,840 --> 00:29:03,911
<c.magenta>那么你…现在正在通过</c>

481
00:29:04,311 --> 00:29:06,480
<c.magenta>假如现在有人打电话给你</c>

482
00:29:08,048 --> 00:29:09,383
<c.magenta>那么</c>

483
00:29:09,783 --> 00:29:13,787
<c.magenta>在这点上 你的音乐播放就会被中断</c>

484
00:29:14,354 --> 00:29:17,424
<c.magenta>而电话会占用系统音频</c>

485
00:29:17,491 --> 00:29:19,226
<c.magenta>可能是接收器或比如说扬声器</c>

486
00:29:20,227 --> 00:29:24,364
<c.magenta>那么只有电话结束后</c>

487
00:29:24,431 --> 00:29:27,034
<c.magenta>它才会恢复播放</c>

488
00:29:28,135 --> 00:29:31,672
<c.magenta>那么正如你所看到的</c>

489
00:29:31,738 --> 00:29:34,408
<c.magenta>这并不是一个很理想的情景</c>

490
00:29:35,075 --> 00:29:39,713
<c.magenta>那么我们现在要看通过长格式音频路径</c>

491
00:29:41,548 --> 00:29:43,550
<c.magenta>那么让我们来看同一个例子</c>

492
00:29:43,617 --> 00:29:48,555
<c.magenta>那么现在我们正在通过</c>

493
00:29:49,790 --> 00:29:51,959
<c.magenta>然后有电话进来了</c>

494
00:29:52,693 --> 00:29:55,963
<c.magenta>现在因为电话不是长格式音频</c>

495
00:29:56,296 --> 00:29:58,866
<c.magenta>它不会中断你的音乐播放</c>

496
00:29:59,233 --> 00:30:02,569
<c.magenta>它获得了一个单独的路径进入系统音频</c>

497
00:29:59,233 --> 00:30:02,569
<c.magenta>它获得了一个单独的路径进入系统音频</c>

498
00:30:03,036 --> 00:30:03,971
<c.magenta>没有导致任何问题</c>

499
00:30:04,538 --> 00:30:06,940
<c.magenta>那么通过长格式音频路径</c>

500
00:30:07,241 --> 00:30:11,578
<c.magenta>两个会话可以共存 而不会相互中断</c>

501
00:30:11,912 --> 00:30:15,749
<c.magenta>并且正如你所看到的</c>

502
00:30:18,118 --> 00:30:19,019
<c.magenta>那么…</c>

503
00:30:23,190 --> 00:30:26,026
<c.magenta>那么总的来说 通过长格式音频路径</c>

504
00:30:26,393 --> 00:30:30,030
<c.magenta>将自己识别为长格式的所有应用</c>

505
00:30:30,097 --> 00:30:35,169
<c.magenta>比如说音乐、播客</c>

506
00:30:35,769 --> 00:30:39,306
<c.magenta>都会获得专用…都会获得独立共享路径</c>

507
00:30:39,373 --> 00:30:41,275
<c.magenta>在支持AirPlay 2的设备上</c>

508
00:30:42,009 --> 00:30:44,745
<c.magenta>现在请注意这两者之间有一个调停会话</c>

509
00:30:45,112 --> 00:30:47,381
<c.magenta>那会确保</c>

510
00:30:47,447 --> 00:30:51,385
<c.magenta>同一时间只有一个这样的应用</c>

511
00:30:51,652 --> 00:30:54,221
<c.magenta>那么这些应用不能相互穿插</c>

512
00:30:55,022 --> 00:30:59,960
<c.magenta>而其它使用系统路径的非长格式应用</c>

513
00:31:00,027 --> 00:31:01,562
<c.magenta>则可以相互中断</c>

514
00:31:01,628 --> 00:31:05,699
<c.magenta>或相互穿插 它们会获得进入</c>

515
00:31:05,866 --> 00:31:08,735
<c.magenta>并不会中断你的长格式音频播放</c>

516
00:31:11,438 --> 00:31:15,976
<c.magenta>现在让我们看看应用是如何</c>

517
00:31:16,043 --> 00:31:17,811
<c.magenta>以及是如何利用这个路径的</c>

518
00:31:19,446 --> 00:31:22,649
<c.magenta>在iOS和tvOS上 代码非常简单</c>

519
00:31:22,950 --> 00:31:26,119
<c.magenta>你获得AVAudio会话的共享实例</c>

520
00:31:26,353 --> 00:31:29,323
<c.magenta>且你使用这个新API把你的类别设置</c>

521
00:31:29,389 --> 00:31:33,393
<c.magenta>为播放</c>

522
00:31:36,230 --> 00:31:38,498
<c.magenta>现在再看看macOS</c>

523
00:31:39,333 --> 00:31:43,036
<c.magenta>路径与iOS和tvOS上非常相似</c>

524
00:31:43,370 --> 00:31:45,272
<c.magenta>全部长格式音频应用</c>

525
00:31:45,339 --> 00:31:49,009
<c.magenta>比如 你的iTunes和</c>

526
00:31:49,076 --> 00:31:52,813
<c.magenta>会获得进入支持AirPlay 2的</c>

527
00:31:53,747 --> 00:31:55,983
<c.magenta>当然了 这之间有一个调停会话</c>

528
00:31:57,017 --> 00:32:02,256
<c.magenta>而其它系统应用 比如GarageBand、</c>

529
00:31:57,017 --> 00:32:02,256
<c.magenta>而其它系统应用 比如GarageBand、</c>

530
00:32:02,523 --> 00:32:05,192
<c.magenta>将不会中断你的长格式音频应用</c>

531
00:32:05,259 --> 00:32:09,696
<c.magenta>它们总是会相互穿插</c>

532
00:32:10,831 --> 00:32:14,601
<c.magenta>要在macOS上启用</c>

533
00:32:14,668 --> 00:32:19,072
<c.magenta>我们现在向macOS引入了</c>

534
00:32:19,640 --> 00:32:22,409
<c.magenta>那么作为应用 为了将自己识别为</c>

535
00:32:22,476 --> 00:32:25,112
<c.magenta>长格式 你要再次获取</c>

536
00:32:25,179 --> 00:32:27,748
<c.magenta>共享和感觉</c>

537
00:32:27,814 --> 00:32:30,817
<c.magenta>将路径共享政策设置为长格式</c>

538
00:32:33,086 --> 00:32:34,054
<c.magenta>那么这就是</c>

539
00:32:34,121 --> 00:32:35,722
<c.magenta>AVAudio会话的改进</c>

540
00:32:35,789 --> 00:32:39,326
<c.magenta>让我们现在看看AV基础框架中</c>

541
00:32:39,393 --> 00:32:41,195
<c.magenta>即watchOS上的改进</c>

542
00:32:43,897 --> 00:32:48,468
<c.magenta>那么我们引入了AV…</c>

543
00:32:48,535 --> 00:32:50,337
<c.magenta>也可以用AVAudio Player API了</c>

544
00:32:50,904 --> 00:32:53,607
<c.magenta>那么这是我们第一次</c>

545
00:32:54,141 --> 00:32:57,244
<c.magenta>使用AVAudio Player</c>

546
00:32:57,477 --> 00:33:00,614
<c.magenta>它与其AVAudio会话相关联</c>

547
00:32:57,477 --> 00:33:00,614
<c.magenta>它与其AVAudio会话相关联</c>

548
00:33:00,681 --> 00:33:03,317
<c.magenta>因此你可以使用会话类别选项</c>

549
00:33:03,383 --> 00:33:07,654
<c.magenta>比如解码器或与其它穿插</c>

550
00:33:08,789 --> 00:33:12,893
<c.magenta>现在从watchOS 4开始</c>

551
00:33:12,960 --> 00:33:17,898
<c.magenta>以帮助你录制音频 即我们正在开发</c>

552
00:33:18,198 --> 00:33:21,502
<c.magenta>以及AVAudio Input Note</c>

553
00:33:22,769 --> 00:33:25,639
<c.magenta>有了这些</c>

554
00:33:25,806 --> 00:33:29,276
<c.magenta>通过这个许可 应用就可以请求</c>

555
00:33:30,444 --> 00:33:34,248
<c.magenta>现在[听不清]这个</c>

556
00:33:34,314 --> 00:33:35,482
<c.magenta>来进行录音</c>

557
00:33:35,549 --> 00:33:36,917
<c.magenta>使用Apple UI</c>

558
00:33:37,217 --> 00:33:41,989
<c.magenta>但现在通过这些API</c>

559
00:33:42,055 --> 00:33:43,223
<c.magenta>用你自己的UI</c>

560
00:33:44,424 --> 00:33:46,927
<c.magenta>通过AVAudio Recorder</c>

561
00:33:47,227 --> 00:33:50,297
<c.magenta>或如果你想直接获取麦克风数据</c>

562
00:33:50,364 --> 00:33:53,467
<c.magenta>你可以使用AVAudio输入节点</c>

563
00:33:53,634 --> 00:33:54,635
<c.magenta>把它写入到文件中</c>

564
00:33:55,536 --> 00:33:58,539
<c.magenta>这是watchOS上支持的格式</c>

565
00:33:58,605 --> 00:34:00,541
<c.magenta>无论是播放还是录音</c>

566
00:33:58,605 --> 00:34:00,541
<c.magenta>无论是播放还是录音</c>

567
00:34:02,276 --> 00:34:04,578
<c.magenta>关于录音政策的最后一个提醒</c>

568
00:34:05,245 --> 00:34:08,248
<c.magenta>录音只能当应用处于前台时开始</c>

569
00:34:08,849 --> 00:34:11,818
<c.magenta>但它允许在后台继续录音</c>

570
00:34:11,885 --> 00:34:15,322
<c.magenta>但是…将会在顶部显示麦克风图标</c>

571
00:34:15,489 --> 00:34:17,157
<c.magenta>以便用户知道他们正在录音</c>

572
00:34:18,292 --> 00:34:21,428
<c.magenta>在后台录音是CPU受限的</c>

573
00:34:21,495 --> 00:34:23,429
<c.magenta>类似于锻炼会话</c>

574
00:34:23,496 --> 00:34:26,266
<c.magenta>你可以参考这个URL获取更多信息</c>

575
00:34:28,268 --> 00:34:30,704
<c.magenta>现在让我们进入音频工具箱的世界</c>

576
00:34:30,771 --> 00:34:34,842
<c.magenta>看看AUAudio单元和音频格式</c>

577
00:34:36,376 --> 00:34:39,346
<c.magenta>在AUAudio单元中有两个主要改进</c>

578
00:34:39,947 --> 00:34:40,848
<c.magenta>在本场演讲的最后</c>

579
00:34:40,914 --> 00:34:43,116
<c.magenta>我们将进行一次演示</c>

580
00:34:43,183 --> 00:34:45,219
<c.magenta>在实际操作中了解这两个新功能</c>

581
00:34:48,222 --> 00:34:52,326
<c.magenta>现在音频单元托管</c>

582
00:34:52,592 --> 00:34:55,896
<c.magenta>以便推荐如何为AU显示UI</c>

583
00:34:56,429 --> 00:35:00,834
<c.magenta>它们可以决定</c>

584
00:34:56,429 --> 00:35:00,834
<c.magenta>它们可以决定</c>

585
00:35:01,168 --> 00:35:05,138
<c.magenta>或它们可以为AU呈现一个全屏、</c>

586
00:35:06,139 --> 00:35:09,376
<c.magenta>现在这主要呈现为iOS设备上的挑战</c>

587
00:35:09,443 --> 00:35:12,379
<c.magenta>因为目前没有定义视图尺寸</c>

588
00:35:12,713 --> 00:35:16,650
<c.magenta>而音频单元要采用</c>

589
00:35:16,717 --> 00:35:18,652
<c.magenta>托管实际所选择的任意UI尺寸</c>

590
00:35:19,853 --> 00:35:23,524
<c.magenta>为了克服这种限制</c>

591
00:35:23,590 --> 00:35:25,158
<c.magenta>托管和AU</c>

592
00:35:25,225 --> 00:35:29,730
<c.magenta>可以相互协商</c>

593
00:35:29,796 --> 00:35:32,833
<c.magenta>关于它实际所支持的全部视图配置</c>

594
00:35:33,634 --> 00:35:36,770
<c.magenta>现在让我们看这种协商是如何发生的</c>

595
00:35:38,338 --> 00:35:43,977
<c.magenta>托管首先为AU编译一个</c>

596
00:35:44,411 --> 00:35:49,283
<c.magenta>然后把音频传递给AU</c>

597
00:35:50,017 --> 00:35:53,587
<c.magenta>然后AU可以通过全部这些</c>

598
00:35:53,654 --> 00:35:56,924
<c.magenta>然后告诉托管</c>

599
00:35:56,990 --> 00:35:59,059
<c.magenta>它实际所支持的配置</c>

600
00:35:59,660 --> 00:36:03,430
<c.magenta>然后托管可以选择其中一个</c>

601
00:35:59,660 --> 00:36:03,430
<c.magenta>然后托管可以选择其中一个</c>

602
00:36:03,497 --> 00:36:07,267
<c.magenta>然后它会告诉AU它最终选择的配置</c>

603
00:36:08,335 --> 00:36:09,203
<c.magenta>现在让我们来看看</c>

604
00:36:09,269 --> 00:36:12,539
<c.magenta>代码示例 关于这种协商是如何发生的</c>

605
00:36:12,906 --> 00:36:16,009
<c.magenta>我们首先要看音频单元扩展</c>

606
00:36:17,878 --> 00:36:19,713
<c.magenta>AU要做的第一件事</c>

607
00:36:20,347 --> 00:36:21,281
<c.magenta>就是覆盖</c>

608
00:36:21,448 --> 00:36:25,018
<c.magenta>基类中的所支持的视频配置方法</c>

609
00:36:25,519 --> 00:36:27,921
<c.magenta>这是由托管通过</c>

610
00:36:27,988 --> 00:36:31,158
<c.magenta>全部可用配置进行调用的</c>

611
00:36:32,292 --> 00:36:36,163
<c.magenta>然后AU会在每个配置中进行迭代</c>

612
00:36:36,230 --> 00:36:38,966
<c.magenta>并决定它实际支持哪个</c>

613
00:36:40,000 --> 00:36:43,804
<c.magenta>现在配置自身包含一个宽和一个高</c>

614
00:36:44,071 --> 00:36:46,840
<c.magenta>也就是推荐视图尺寸</c>

615
00:36:47,040 --> 00:36:49,743
<c.magenta>同时它还有一个托管测试控制器旗标</c>

616
00:36:50,611 --> 00:36:54,848
<c.magenta>并且那个旗标指明了托管是否代表</c>

617
00:36:54,915 --> 00:36:58,519
<c.magenta>它自己的控制器 在这个视图配置中</c>

618
00:36:59,586 --> 00:37:01,622
<c.magenta>那么根据全部这些因素</c>

619
00:36:59,586 --> 00:37:01,622
<c.magenta>那么根据全部这些因素</c>

620
00:37:01,688 --> 00:37:05,526
<c.magenta>AU可以选择它是否支持那个配置</c>

621
00:37:06,860 --> 00:37:10,998
<c.magenta>请注意有一个通配符配置是0x0</c>

622
00:37:11,265 --> 00:37:15,068
<c.magenta>意思是…那代表AU可以</c>

623
00:37:15,302 --> 00:37:17,070
<c.magenta>支持默认全屏尺寸</c>

624
00:37:17,804 --> 00:37:23,243
<c.magenta>在macOS上 这其实是转化到一个</c>

625
00:37:23,310 --> 00:37:27,447
<c.magenta>全尺寸、可调整大小的窗口</c>

626
00:37:29,216 --> 00:37:33,453
<c.magenta>那么AU有自己的逻辑</c>

627
00:37:33,520 --> 00:37:36,590
<c.magenta>那么最终它对比列有各种指标的列表</c>

628
00:37:38,225 --> 00:37:40,127
<c.magenta>和它所支持的配置</c>

629
00:37:40,194 --> 00:37:43,864
<c.magenta>并将这个指标组合写入到托管中</c>

630
00:37:45,399 --> 00:37:49,937
<c.magenta>AU要做的最后一件事就是</c>

631
00:37:50,170 --> 00:37:52,873
<c.magenta>由托管通过</c>

632
00:37:52,940 --> 00:37:54,775
<c.magenta>它最终所选择的配置进行调用</c>

633
00:37:54,942 --> 00:37:56,310
<c.magenta>然后AU</c>

634
00:37:56,376 --> 00:37:58,178
<c.magenta>可以让其视图控制器</c>

635
00:37:58,245 --> 00:38:00,414
<c.magenta>了解最终所选择的配置</c>

636
00:37:58,245 --> 00:38:00,414
<c.magenta>了解最终所选择的配置</c>

637
00:38:02,316 --> 00:38:06,086
<c.magenta>现在让我们进入托管看一下代码</c>

638
00:38:07,621 --> 00:38:11,859
<c.magenta>托管必须编译可用配置的列表</c>

639
00:38:11,925 --> 00:38:13,694
<c.magenta>在本例中 它指明</c>

640
00:38:13,861 --> 00:38:17,097
<c.magenta>它拥有一个大配置和一个小配置</c>

641
00:38:18,031 --> 00:38:20,801
<c.magenta>在最后一个配置中 托管表明</c>

642
00:38:20,868 --> 00:38:25,672
<c.magenta>它没有呈现其控制器</c>

643
00:38:25,973 --> 00:38:29,910
<c.magenta>在小配置中 托管呈现了它的控制器</c>

644
00:38:29,977 --> 00:38:31,111
<c.magenta>那么旗标就为真</c>

645
00:38:32,913 --> 00:38:37,918
<c.magenta>然后托管调用AU上</c>

646
00:38:37,985 --> 00:38:40,521
<c.magenta>并提供这份配置列表</c>

647
00:38:40,888 --> 00:38:44,224
<c.magenta>根据所返回的指标组合</c>

648
00:38:44,291 --> 00:38:46,426
<c.magenta>它会选择其中一项配置</c>

649
00:38:46,627 --> 00:38:49,596
<c.magenta>在本例中 托管只是</c>

650
00:38:49,663 --> 00:38:52,099
<c.magenta>在大配置和小配置之间切换</c>

651
00:38:53,700 --> 00:38:54,868
<c.magenta>那么这就是</c>

652
00:38:54,935 --> 00:38:57,271
<c.magenta>优选视图配置协商</c>

653
00:38:57,704 --> 00:39:00,874
<c.magenta>现在让我们看看第二个主要的新功能</c>

654
00:38:57,704 --> 00:39:00,874
<c.magenta>现在让我们看看第二个主要的新功能</c>

655
00:39:01,208 --> 00:39:04,611
<c.magenta>即在音频单元扩展中支持MIDI输出</c>

656
00:39:05,913 --> 00:39:09,416
<c.magenta>我们现在支持AU进行</c>

657
00:39:09,483 --> 00:39:11,385
<c.magenta>通过其音频输出同步后的MIDI输出</c>

658
00:39:12,019 --> 00:39:16,223
<c.magenta>主要用处是如果托管想记录和编辑</c>

659
00:39:16,290 --> 00:39:19,193
<c.magenta>AU中的MIDI性能</c>

660
00:39:19,259 --> 00:39:20,327
<c.magenta>以及音频输出</c>

661
00:39:20,961 --> 00:39:24,398
<c.magenta>那么托管安装了MIDI输出事件组块</c>

662
00:39:24,464 --> 00:39:25,332
<c.magenta>在AU上</c>

663
00:39:25,399 --> 00:39:28,902
<c.magenta>AU应该在每个渲染循环中</c>

664
00:39:29,069 --> 00:39:32,472
<c.magenta>并为该渲染循坏提供MIDI输出</c>

665
00:39:34,842 --> 00:39:37,344
<c.magenta>我们还有一些其它改进</c>

666
00:39:37,411 --> 00:39:39,046
<c.magenta>在音频工具箱框架中</c>

667
00:39:39,112 --> 00:39:42,382
<c.magenta>第一个是与隐私权有关</c>

668
00:39:43,083 --> 00:39:48,589
<c.magenta>那么从iOS 11 SDK开始</c>

669
00:39:48,655 --> 00:39:52,459
<c.magenta>都需要应用间音频权利来与</c>

670
00:39:52,526 --> 00:39:54,328
<c.magenta>音频单元扩展进行通讯</c>

671
00:39:55,162 --> 00:39:59,933
<c.magenta>我们还有一个新API</c>

672
00:40:00,000 --> 00:40:04,204
<c.magenta>一个非常有意义的短名称</c>

673
00:40:04,271 --> 00:40:07,708
<c.magenta>可以使用这个短名称 如果它要显示</c>

674
00:40:08,308 --> 00:40:13,547
<c.magenta>AU名称列表的话 在空间约束列表中</c>

675
00:40:15,182 --> 00:40:19,720
<c.magenta>那么这就是音频工具箱框架中的</c>

676
00:40:19,786 --> 00:40:24,424
<c.magenta>正如我所承诺的</c>

677
00:40:24,491 --> 00:40:26,560
<c.magenta>让我们邀请Bela上台</c>

678
00:40:37,004 --> 00:40:40,507
<c.magenta>谢谢Akshatha 大家下午好</c>

679
00:40:40,574 --> 00:40:42,609
<c.magenta>我是Core Audio团队的一名工程师</c>

680
00:40:43,177 --> 00:40:46,880
<c.magenta>今天我要给大家展示</c>

681
00:40:46,947 --> 00:40:50,651
<c.magenta>一个应用</c>

682
00:40:51,118 --> 00:40:54,221
<c.magenta>为此 我们开发了一个示例音频单元</c>

683
00:40:54,288 --> 00:40:56,123
<c.magenta>有如下功能</c>

684
00:40:57,157 --> 00:40:59,860
<c.magenta>它支持其优选视图配置</c>

685
00:40:59,927 --> 00:41:01,695
<c.magenta>通过音频单元托管应用</c>

686
00:40:59,927 --> 00:41:01,695
<c.magenta>通过音频单元托管应用</c>

687
00:41:02,563 --> 00:41:04,798
<c.magenta>它支持多视图配置</c>

688
00:41:04,865 --> 00:41:09,036
<c.magenta>并使用新桥接的MIDI输出API</c>

689
00:41:09,102 --> 00:41:10,938
<c.magenta>来传递MIDI数据</c>

690
00:41:11,405 --> 00:41:14,808
<c.magenta>到音频单元托管应用 用于录制音频</c>

691
00:41:15,742 --> 00:41:18,612
<c.magenta>那么在这里我有一个</c>

692
00:41:19,346 --> 00:41:22,249
<c.magenta>我已经把我的示例音频单元</c>

693
00:41:23,350 --> 00:41:26,486
<c.magenta>在这里你可以看到我的</c>

694
00:41:26,553 --> 00:41:28,355
<c.magenta>和GarageBand键盘</c>

695
00:41:28,655 --> 00:41:30,524
<c.magenta>在这个重配置中</c>

696
00:41:30,591 --> 00:41:33,594
<c.magenta>我依赖GarageBand键盘</c>

697
00:41:34,228 --> 00:41:37,030
<c.magenta>我在键盘上制定了三种鼓声示例</c>

698
00:41:37,097 --> 00:41:40,868
<c.magenta>有底鼓、军鼓和踩镲</c>

699
00:41:41,502 --> 00:41:44,571
<c.magenta>除了这些 在我的音频单元视图上</c>

700
00:41:44,638 --> 00:41:48,542
<c.magenta>我还有一个音量滑块</c>

701
00:41:51,478 --> 00:41:55,482
<c.magenta>然而 我的音频单元</c>

702
00:41:55,549 --> 00:41:59,353
<c.magenta>我可以通过右边这个新添加的按钮</c>

703
00:41:59,419 --> 00:42:01,588
<c.magenta>在屏幕的右下方</c>

704
00:41:59,419 --> 00:42:01,588
<c.magenta>在屏幕的右下方</c>

705
00:42:02,122 --> 00:42:06,560
<c.magenta>当我激活那个按钮后</c>

706
00:42:06,627 --> 00:42:08,662
<c.magenta>而GarageBand键盘就消失了</c>

707
00:42:09,329 --> 00:42:13,534
<c.magenta>当我再次激活它时</c>

708
00:42:14,101 --> 00:42:16,770
<c.magenta>这是通过GarageBand</c>

709
00:42:17,571 --> 00:42:21,175
<c.magenta>把全部可用视图配置</c>

710
00:42:21,675 --> 00:42:24,711
<c.magenta>并且我的音频单元查看那份列表</c>

711
00:42:24,778 --> 00:42:26,980
<c.magenta>支持或不支持</c>

712
00:42:27,047 --> 00:42:30,417
<c.magenta>在这个过程的最后</c>

713
00:42:30,484 --> 00:42:34,354
<c.magenta>支持两种视图配置</c>

714
00:42:35,189 --> 00:42:38,692
<c.magenta>如果我的音频单元只支持一种视图配置</c>

715
00:42:38,759 --> 00:42:41,495
<c.magenta>GarageBand就会</c>

716
00:42:41,562 --> 00:42:45,599
<c.magenta>但我的音频组件仍然会利用协商过程</c>

717
00:42:45,666 --> 00:42:49,536
<c.magenta>来协商该视图的优选视图配置</c>

718
00:42:50,804 --> 00:42:55,275
<c.magenta>在这个小视图中</c>

719
00:42:56,009 --> 00:42:58,345
<c.magenta>这也是GarageBand键盘</c>

720
00:42:58,579 --> 00:43:00,614
<c.magenta>在较大的视图配置中</c>

721
00:42:58,579 --> 00:43:00,614
<c.magenta>在较大的视图配置中</c>

722
00:43:00,681 --> 00:43:04,718
<c.magenta>GarageBand键盘是隐藏的</c>

723
00:43:05,252 --> 00:43:09,590
<c.magenta>在这个视图配置中</c>

724
00:43:09,990 --> 00:43:11,825
<c.magenta>我可以用于播放我的伴奏</c>

725
00:43:12,059 --> 00:43:15,162
<c.magenta>有底鼓、军鼓和踩镲</c>

726
00:43:15,996 --> 00:43:19,433
<c.magenta>除了这三个按钮 我还有</c>

727
00:43:20,767 --> 00:43:23,837
<c.magenta>一个新按钮 位于右手边</c>

728
00:43:24,071 --> 00:43:25,138
<c.magenta>这个按钮可以让我</c>

729
00:43:25,205 --> 00:43:28,208
<c.magenta>以指定速率重复每个示例</c>

730
00:43:28,709 --> 00:43:32,713
<c.magenta>我可以通过滑块分别设置每一个的速率</c>

731
00:43:36,617 --> 00:43:39,553
<c.magenta>我还可以把每个示例从鼓声循环中</c>

732
00:43:51,265 --> 00:43:53,767
<c.magenta>这就允许我很简便地构建鼓声循环</c>

733
00:43:53,834 --> 00:43:56,670
<c.magenta>使其遵从我的音轨的速度</c>

734
00:43:57,738 --> 00:44:01,275
<c.magenta>让我们使用MIDI输出API来录制</c>

735
00:43:57,738 --> 00:44:01,275
<c.magenta>让我们使用MIDI输出API来录制</c>

736
00:44:01,341 --> 00:44:03,410
<c.magenta>这个音频单元扩展的输出</c>

737
00:44:04,044 --> 00:44:09,049
<c.magenta>这里有一个同步速率按钮</c>

738
00:44:09,750 --> 00:44:13,287
<c.magenta>首先我将录制一个底鼓</c>

739
00:44:13,387 --> 00:44:16,790
<c.magenta>然后当循环录制完成后 我再添加踩镲</c>

740
00:44:17,224 --> 00:44:20,928
<c.magenta>这是通过GarageBand的</c>

741
00:44:21,662 --> 00:44:23,130
<c.magenta>那么让我们来试试</c>

742
00:44:27,000 --> 00:44:30,003
<c.magenta>对于前两个 我只录制四条</c>

743
00:44:35,175 --> 00:44:36,510
<c.magenta>然后添加踩镲</c>

744
00:44:45,152 --> 00:44:47,321
<c.magenta>踩镲已经被添加到了录音中</c>

745
00:44:49,456 --> 00:44:53,193
<c.magenta>现在我们可以进入音轨视图</c>

746
00:44:57,264 --> 00:44:59,233
<c.magenta>我可以量化音轨</c>

747
00:45:02,803 --> 00:45:04,438
<c.magenta>然后我可以播放它</c>

748
00:45:06,640 --> 00:45:10,277
<c.magenta>我们拥有GarageBand的全部</c>

749
00:45:10,344 --> 00:45:13,614
<c.magenta>可任由我们用来构建我们的鼓声音轨</c>

750
00:45:14,381 --> 00:45:16,984
<c.magenta>这就是我的演示 谢谢大家的关注</c>

751
00:45:17,050 --> 00:45:19,453
<c.magenta>我要把舞台交还给我的同事Akshatha</c>

752
00:45:19,853 --> 00:45:20,687
<c.magenta>谢谢</c>

753
00:45:26,026 --> 00:45:27,027
<c.magenta>谢谢Bela</c>

754
00:45:29,897 --> 00:45:33,634
<c.magenta>现在让我们讲音频工具箱框架中的</c>

755
00:45:33,700 --> 00:45:35,269
<c.magenta>与音频格式有关</c>

756
00:45:36,637 --> 00:45:39,740
<c.magenta>我们目前支持两种流行格式</c>

757
00:45:39,806 --> 00:45:42,409
<c.magenta>分别是FLAC和Opus格式</c>

758
00:45:43,110 --> 00:45:47,147
<c.magenta>关于FLAC 我们有编解码器、</c>

759
00:45:47,214 --> 00:45:50,450
<c.magenta>关于Opus</c>

760
00:45:50,517 --> 00:45:52,419
<c.magenta>通过编码音频格式容器</c>

761
00:45:54,621 --> 00:45:57,157
<c.magenta>从音频格式到空间音频格式</c>

762
00:45:57,658 --> 00:46:00,260
<c.magenta>你们中对[听不清]音频、</c>

763
00:45:57,658 --> 00:46:00,260
<c.magenta>你们中对[听不清]音频、</c>

764
00:46:00,327 --> 00:46:05,566
<c.magenta>AR和VR应用感兴趣的人 可能很高兴</c>

765
00:46:06,099 --> 00:46:10,204
<c.magenta>对于不熟悉环绕声的人 就像我一样</c>

766
00:46:10,737 --> 00:46:12,773
<c.magenta>环绕声还是一种</c>

767
00:46:12,840 --> 00:46:15,909
<c.magenta>多波段格式 但不同点是</c>

768
00:46:15,976 --> 00:46:21,548
<c.magenta>我们所了解的传统环绕立体声格式</c>

769
00:46:21,915 --> 00:46:25,118
<c.magenta>其信号实际上代表着扬声器布局</c>

770
00:46:25,586 --> 00:46:27,087
<c.magenta>而环绕声</c>

771
00:46:27,421 --> 00:46:31,658
<c.magenta>提供一个独立于扬声器之外的</c>

772
00:46:32,259 --> 00:46:35,495
<c.magenta>它们实质上[听不清]来自播放系统</c>

773
00:46:36,163 --> 00:46:37,898
<c.magenta>渲染时</c>

774
00:46:37,965 --> 00:46:41,835
<c.magenta>就是它们被解码到</c>

775
00:46:42,336 --> 00:46:45,439
<c.magenta>这就为内容创建者提供了更多的灵活性</c>

776
00:46:46,440 --> 00:46:48,041
<c.magenta>我们现在支持第一级</c>

777
00:46:48,108 --> 00:46:53,647
<c.magenta>环绕声叫作B-格式</c>

778
00:46:53,714 --> 00:46:57,885
<c.magenta>为序号N 范围可以从1到254</c>

779
00:46:58,318 --> 00:47:02,422
<c.magenta>根据顺序 波段自身可以从零…</c>

780
00:46:58,318 --> 00:47:02,422
<c.magenta>根据顺序 波段自身可以从零…</c>

781
00:47:02,489 --> 00:47:07,127
<c.magenta>环绕声波段编号可以从零</c>

782
00:47:07,828 --> 00:47:11,965
<c.magenta>我们支持两种流行的标准化数据流</c>

783
00:47:12,032 --> 00:47:14,768
<c.magenta>分别是SN3D和N3D数据流</c>

784
00:47:14,835 --> 00:47:20,707
<c.magenta>并且我们支持把环绕声</c>

785
00:47:20,774 --> 00:47:24,278
<c.magenta>并在B-格式和这些标准化数据流</c>

786
00:47:26,280 --> 00:47:27,481
<c.magenta>最后一个改进</c>

787
00:47:27,548 --> 00:47:30,317
<c.magenta>是关于AU空间混音器</c>

788
00:47:30,517 --> 00:47:33,687
<c.magenta>那么这是Apple内置空间混音器</c>

789
00:47:33,754 --> 00:47:36,423
<c.magenta>用于3D音频空间化</c>

790
00:47:37,057 --> 00:47:39,526
<c.magenta>并且AVAudio环境节点</c>

791
00:47:39,593 --> 00:47:44,464
<c.magenta>即AVAudio Engine中的</c>

792
00:47:44,865 --> 00:47:48,969
<c.magenta>并且我们现在有一个新的渲染算法</c>

793
00:47:49,036 --> 00:47:52,239
<c.magenta>叫作HRTFHQ 高品质</c>

794
00:47:52,573 --> 00:47:57,077
<c.magenta>这与当前现有的HRTF算法不同</c>

795
00:47:57,144 --> 00:47:59,713
<c.magenta>它拥有更好的频率响应</c>

796
00:47:59,780 --> 00:48:02,583
<c.magenta>和更好的资源本地化 在3D空间中</c>

797
00:47:59,780 --> 00:48:02,583
<c.magenta>和更好的资源本地化 在3D空间中</c>

798
00:48:03,817 --> 00:48:07,588
<c.magenta>那么这就是</c>

799
00:48:07,654 --> 00:48:10,958
<c.magenta>现在我要把舞台交给Torrey</c>

800
00:48:11,024 --> 00:48:14,361
<c.magenta>让他给大家讲讲</c>

801
00:48:20,567 --> 00:48:21,535
<c.magenta>谢谢Akshatha</c>

802
00:48:21,835 --> 00:48:24,338
<c.magenta>我是Torrey Holbrook Walker</c>

803
00:48:24,404 --> 00:48:25,973
<c.magenta>设备间音频模式</c>

804
00:48:26,039 --> 00:48:28,909
<c.magenta>或者如果你想酷点儿</c>

805
00:48:29,276 --> 00:48:30,511
<c.magenta>你要记住这个词IDAM</c>

806
00:48:30,611 --> 00:48:34,748
<c.magenta>你拿着你的iOS设备 把它查到Mac上</c>

807
00:48:34,815 --> 00:48:37,584
<c.magenta>然后它会在音频设备窗口中显示</c>

808
00:48:37,651 --> 00:48:41,088
<c.magenta>你可以 它旁边有一个启动按钮</c>

809
00:48:41,255 --> 00:48:44,224
<c.magenta>你会立即获得录制数字音频的功能</c>

810
00:48:44,291 --> 00:48:47,628
<c.magenta>通过设备自带的USB闪电数据线</c>

811
00:48:47,694 --> 00:48:51,498
<c.magenta>它看起来就像是对Mac托管的一个</c>

812
00:48:51,565 --> 00:48:53,166
<c.magenta>那么它使用了同样的驱动器</c>

813
00:48:53,233 --> 00:48:55,769
<c.magenta>同样的低延迟驱动器</c>

814
00:48:55,836 --> 00:48:57,337
<c.magenta>class-compliant音频设备</c>

815
00:48:57,571 --> 00:48:59,239
<c.magenta>你自El Capitan和iOS 9</c>

816
00:48:59,306 --> 00:49:01,642
<c.magenta>起就可以实现了</c>

817
00:48:59,306 --> 00:49:01,642
<c.magenta>起就可以实现了</c>

818
00:49:02,276 --> 00:49:03,410
<c.magenta>嗯 今天我们要</c>

819
00:49:03,477 --> 00:49:06,046
<c.magenta>向IDAM依依惜别了</c>

820
00:49:06,113 --> 00:49:08,982
<c.magenta>那么再见了IDAM 拜拜了IDAM</c>

821
00:49:09,449 --> 00:49:12,252
<c.magenta>当你挥手告别时</c>

822
00:49:12,319 --> 00:49:13,720
<c.magenta>设备间音频和MIDI</c>

823
00:49:14,388 --> 00:49:18,125
<c.magenta>今年我们给IDAM配置</c>

824
00:49:18,192 --> 00:49:22,496
<c.magenta>那会允许你发送或接收音乐伴奏数据</c>

825
00:49:22,563 --> 00:49:25,966
<c.magenta>到你的iOS设备</c>

826
00:49:26,200 --> 00:49:31,638
<c.magenta>又是class-compliant</c>

827
00:49:31,705 --> 00:49:33,874
<c.magenta>MIDI源和目标代表Mac</c>

828
00:49:33,941 --> 00:49:37,845
<c.magenta>在Mac上 你会看到源</c>

829
00:49:38,445 --> 00:49:43,050
<c.magenta>现在这需要iOS 11才行</c>

830
00:49:43,116 --> 00:49:46,453
<c.magenta>在老MacOS El Capitan或更新版本上</c>

831
00:49:46,854 --> 00:49:48,789
<c.magenta>并且你不需要做什么就能获取MIDI</c>

832
00:49:48,856 --> 00:49:50,357
<c.magenta>你会自动获取它</c>

833
00:49:50,424 --> 00:49:53,193
<c.magenta>无论何时你通过点击启用进入项配置时</c>

834
00:49:53,360 --> 00:49:55,863
<c.magenta>你需要做什么来让你的应用支持它吗？</c>

835
00:49:55,929 --> 00:49:58,131
<c.magenta>不 如果它支持MIDI</c>

836
00:49:58,999 --> 00:50:01,768
<c.magenta>当你在IDAM配置中时 你的设备</c>

837
00:49:58,999 --> 00:50:01,768
<c.magenta>当你在IDAM配置中时 你的设备</c>

838
00:50:01,835 --> 00:50:03,303
<c.magenta>将可以充电和同步</c>

839
00:50:03,370 --> 00:50:06,907
<c.magenta>但你将暂时失去图片导入和渲染的功能</c>

840
00:50:07,074 --> 00:50:09,076
<c.magenta>你可以通过点击禁用按钮</c>

841
00:50:09,142 --> 00:50:10,911
<c.magenta>或在Mac上带电插拔设备</c>

842
00:50:11,545 --> 00:50:14,715
<c.magenta>那个输入 它的音频输入可能是聚合的</c>

843
00:50:14,781 --> 00:50:18,085
<c.magenta>所以如果你拥有多台iOS设备</c>

844
00:50:18,151 --> 00:50:22,155
<c.magenta>你的iPhone和iPad以及你孩子的iPad</c>

845
00:50:22,222 --> 00:50:25,659
<c.magenta>在全部三台设备上</c>

846
00:50:25,726 --> 00:50:29,496
<c.magenta>你的数字音频工作站可以查找到的</c>

847
00:50:30,197 --> 00:50:32,533
<c.magenta>因为MIDI通讯是双向的</c>

848
00:50:32,599 --> 00:50:35,102
<c.magenta>你可以把它用作…你可以指明比如说</c>

849
00:50:35,169 --> 00:50:41,208
<c.magenta>“发送MIDI到合成器应用”</c>

850
00:50:41,441 --> 00:50:44,611
<c.magenta>或者你可以为iPad设计一个</c>

851
00:50:44,678 --> 00:50:48,048
<c.magenta>那块神奇的玻璃</c>

852
00:50:48,382 --> 00:50:50,617
<c.magenta>但演讲总是说得简单</c>

853
00:50:50,851 --> 00:50:52,352
<c.magenta>那么让我们实际操作一下</c>

854
00:50:54,788 --> 00:50:57,224
<c.magenta>那么在我实际打开我的演示机器之前</c>

855
00:50:57,291 --> 00:51:01,061
<c.magenta>我想给你们展示一个</c>

856
00:50:57,291 --> 00:51:01,061
<c.magenta>我想给你们展示一个</c>

857
00:51:02,296 --> 00:51:04,565
<c.magenta>它叫作Feud Machine</c>

858
00:51:05,065 --> 00:51:07,501
<c.magenta>我已打开了Feud Machine</c>

859
00:51:07,668 --> 00:51:12,039
<c.magenta>在Feud Machine上</c>

860
00:51:12,372 --> 00:51:14,508
<c.magenta>那意味着你可以使用</c>

861
00:51:14,575 --> 00:51:16,710
<c.magenta>一个MIDI音序和不同的播放头</c>

862
00:51:16,777 --> 00:51:20,948
<c.magenta>也许在不同的时间移动</c>

863
00:51:21,014 --> 00:51:26,887
<c.magenta>并使用它来创建复杂的和音</c>

864
00:51:27,287 --> 00:51:29,590
<c.magenta>那么我要播放这里的这个模型</c>

865
00:51:32,993 --> 00:51:36,230
<c.magenta>并且有大量播放头 我要停止其中一些</c>

866
00:51:36,964 --> 00:51:38,165
<c.magenta>那么只有一个了</c>

867
00:51:40,133 --> 00:51:41,068
<c.magenta>我要再添加一个</c>

868
00:51:42,536 --> 00:51:43,403
<c.magenta>再添加一个</c>

869
00:51:44,605 --> 00:51:47,941
<c.magenta>再添加一个 正如你所看到的</c>

870
00:51:48,642 --> 00:51:51,678
<c.magenta>那么还有其它模型可以使用 比如</c>

871
00:51:51,745 --> 00:51:52,880
<c.magenta>这个叫作“Dotted”</c>

872
00:51:55,415 --> 00:51:56,450
<c.magenta>这个叫“Triplet”</c>

873
00:51:57,985 --> 00:52:01,555
<c.magenta>但我们仍然采用这个 我们要用这个</c>

874
00:51:57,985 --> 00:52:01,555
<c.magenta>但我们仍然采用这个 我们要用这个</c>

875
00:52:01,622 --> 00:52:04,091
<c.magenta>实际控制一个</c>

876
00:52:04,358 --> 00:52:06,126
<c.magenta>那么现在我要返回我的演示机器</c>

877
00:52:06,793 --> 00:52:08,128
<c.magenta>我要点击这里的启用</c>

878
00:52:09,496 --> 00:52:11,765
<c.magenta>我将看到它作为USB音频输入出现</c>

879
00:52:11,832 --> 00:52:15,802
<c.magenta>如果我查看MIDI工作室窗口</c>

880
00:52:15,869 --> 00:52:18,572
<c.magenta>为MIDI源和目标</c>

881
00:52:18,939 --> 00:52:21,375
<c.magenta>那么如果我启动一个</c>

882
00:52:26,747 --> 00:52:28,682
<c.magenta>现在这是一个很短的四条循环</c>

883
00:52:28,749 --> 00:52:33,120
<c.magenta>是用于游戏得分屏幕上的</c>

884
00:52:33,187 --> 00:52:36,623
<c.magenta>玩家可以查看他们的得分</c>

885
00:52:37,758 --> 00:52:41,195
<c.magenta>而这个循环现在 在我向里边添加</c>

886
00:52:52,873 --> 00:52:55,375
<c.magenta>现在我想在其中一部分中添加和音</c>

887
00:52:55,576 --> 00:52:58,679
<c.magenta>那么我所要做的就是</c>

888
00:52:58,946 --> 00:53:03,417
<c.magenta>我要选择一个和音</c>

889
00:52:58,946 --> 00:53:03,417
<c.magenta>我要选择一个和音</c>

890
00:53:06,653 --> 00:53:09,289
<c.magenta>好了 我要在这里执行打击乐方波</c>

891
00:53:09,389 --> 00:53:11,825
<c.magenta>在声波条上 你实际可以看到一个和音</c>

892
00:53:11,892 --> 00:53:14,561
<c.magenta>我不需要那个</c>

893
00:53:14,928 --> 00:53:19,533
<c.magenta>那么如果我启用这个</c>

894
00:53:19,933 --> 00:53:25,439
<c.magenta>我就能听到Feud Machine</c>

895
00:53:26,039 --> 00:53:27,140
<c.magenta>那么我要独奏</c>

896
00:53:30,244 --> 00:53:32,779
<c.magenta>这个是四个播放头同时移动</c>

897
00:53:32,946 --> 00:53:36,517
<c.magenta>我要把它们关掉 我只留下一个播放头</c>

898
00:53:37,618 --> 00:53:39,152
<c.magenta>或最多可以有四个</c>

899
00:53:39,620 --> 00:53:42,456
<c.magenta>那么我要把这个录到我的音轨中</c>

900
00:53:42,523 --> 00:53:44,925
<c.magenta>我们要看看在情境中听起来如何</c>

901
00:53:51,565 --> 00:53:56,303
<c.magenta>哎呦 抱歉 我要先记录配置并播放</c>

902
00:54:07,581 --> 00:54:08,949
<c.magenta>好的那么</c>

903
00:54:10,083 --> 00:54:13,086
<c.magenta>我已经记录了这里的自动操作</c>

904
00:54:13,620 --> 00:54:16,790
<c.magenta>并且我可以使用这个自动操作 并能</c>

905
00:54:18,325 --> 00:54:21,328
<c.magenta>从这里的iPad中播放 那么如果</c>

906
00:54:24,498 --> 00:54:26,300
<c.magenta>那么现在我已经搞好了MIDI…</c>

907
00:54:26,366 --> 00:54:28,435
<c.magenta>一个MIDI开始命令</c>

908
00:54:28,502 --> 00:54:30,571
<c.magenta>Feud Machine</c>

909
00:54:30,904 --> 00:54:33,607
<c.magenta>在这里对于录音 我有一些自动操作</c>

910
00:54:34,741 --> 00:54:39,546
<c.magenta>这就是IDAM之上的</c>

911
00:54:40,714 --> 00:54:42,015
<c.magenta>让我们返回看幻灯片</c>

912
00:54:46,720 --> 00:54:48,288
<c.magenta>好的 我们今天讲了很多内容</c>

913
00:54:48,355 --> 00:54:50,290
<c.magenta>我们讲了AVAudio Engine的改进</c>

914
00:54:50,357 --> 00:54:53,160
<c.magenta>包括手动渲染 你现在可以脱机进行了</c>

915
00:54:53,227 --> 00:54:54,394
<c.magenta>或者也可以实时进行</c>

916
00:54:54,728 --> 00:54:58,332
<c.magenta>有了AirPlay 2支持 关于AirPlay 2</c>

917
00:54:58,398 --> 00:55:00,167
<c.magenta>即将举办</c>

918
00:54:58,398 --> 00:55:00,167
<c.magenta>即将举办</c>

919
00:55:00,234 --> 00:55:02,169
<c.magenta>请确保参看那场演讲</c>

920
00:55:02,369 --> 00:55:05,906
<c.magenta>Watch OS 4 你现在可以录音了</c>

921
00:55:05,973 --> 00:55:08,342
<c.magenta>和限制还有政策</c>

922
00:55:08,742 --> 00:55:11,411
<c.magenta>对于AUAudio单元</c>

923
00:55:11,478 --> 00:55:15,249
<c.magenta>并且你可以与你的音频</c>

924
00:55:15,716 --> 00:55:18,585
<c.magenta>我们谈了一些其它的音频改进 包括</c>

925
00:55:18,652 --> 00:55:22,723
<c.magenta>支持的新格式、环绕声、</c>

926
00:55:22,789 --> 00:55:24,825
<c.magenta>并且我们还谈了IDAM</c>

927
00:55:24,892 --> 00:55:27,160
<c.magenta>IDAM代表设备间音频和MIDI</c>

928
00:55:27,761 --> 00:55:30,664
<c.magenta>关于本场演讲的主要信息URL</c>

929
00:55:30,731 --> 00:55:32,132
<c.magenta>在这里</c>

930
00:55:33,934 --> 00:55:37,938
<c.magenta>如果你对音频有兴趣</c>

931
00:55:38,005 --> 00:55:41,708
<c.magenta>本周稍后举办的这些相关演讲</c>

932
00:55:43,443 --> 00:55:45,345
<c.magenta>谢谢大家花时间</c>

933
00:55:45,412 --> 00:55:47,080
<c.magenta>祝你们在大会期间有一段美妙时光</c>
