1
00:00:07,516 --> 00:00:15,500
[欢呼声]

2
00:00:21,516 --> 00:00:27,500
[掌声]

3
00:00:29,206 --> 00:00:29,956
&gt;&gt; 大家好

4
00:00:30,306 --> 00:00:31,546
欢迎大家 

5
00:00:31,546 --> 00:00:32,246
来到可测试性工程学讲座

6
00:00:33,256 --> 00:00:34,546
我是 Brian Croom

7
00:00:34,546 --> 00:00:36,306
现在在 Xcode 团队工作

8
00:00:37,356 --> 00:00:38,846
我和我的同事 Greg

9
00:00:38,846 --> 00:00:39,786
想要和大家分享一下

10
00:00:39,786 --> 00:00:41,896
我们对于可测试性的学习成果

11
00:00:42,046 --> 00:00:42,946
以及可测试性在

12
00:00:42,946 --> 00:00:45,486
开发出色 app 进程中

13
00:00:48,826 --> 00:00:48,936
起到的重要作用

14
00:00:49,136 --> 00:00:50,776
首先 我想要讲一讲

15
00:00:50,776 --> 00:00:52,296
一个 app 的代码具有可测试性

16
00:00:52,346 --> 00:00:52,766
究竟是什么意思

17
00:00:53,686 --> 00:00:55,316
我们会看到一些实例

18
00:00:55,316 --> 00:00:56,476
看看如何应用技术

19
00:00:56,546 --> 00:00:58,376
来提高现有代码

20
00:00:58,376 --> 00:00:59,746
的可测试性

21
00:01:01,276 --> 00:01:03,286
然后 Gregg 会和大家探讨

22
00:01:03,286 --> 00:01:04,616
如何使用测试套件

23
00:01:04,616 --> 00:01:06,196
来确保

24
00:01:06,196 --> 00:01:08,146
它能够对你的 app 开发

25
00:01:08,146 --> 00:01:09,986
起到协助作用 即使是在

26
00:01:09,986 --> 00:01:11,516
开发规模和复杂性不断提高的情况下

27
00:01:14,256 --> 00:01:15,786
好的 我们这就开始

28
00:01:15,786 --> 00:01:16,896
首先来谈谈可测试性

29
00:01:17,346 --> 00:01:20,616
我记得在不久之前

30
00:01:20,616 --> 00:01:21,876
我最初开始学习写

31
00:01:22,386 --> 00:01:22,666
测试

32
00:01:23,746 --> 00:01:25,116
我已经听说过很多有关

33
00:01:25,116 --> 00:01:26,806
测试套件如何能够

34
00:01:26,806 --> 00:01:27,766
帮助我开发 app 的信息

35
00:01:27,966 --> 00:01:30,816
测试套件如何能够使我

36
00:01:31,176 --> 00:01:32,656
对正在编写的代码更有把握

37
00:01:32,656 --> 00:01:33,906
能够让其按照期望的方式

38
00:01:34,646 --> 00:01:34,716
运行

39
00:01:35,636 --> 00:01:36,766
测试套件如何能够帮我

40
00:01:36,826 --> 00:01:38,916
在 app 不断升级变化的情况下

41
00:01:39,066 --> 00:01:40,266
为代码中的regression打补丁

42
00:01:40,866 --> 00:01:43,626
以及如何充当

43
00:01:43,626 --> 00:01:45,206
我的代码的

44
00:01:45,206 --> 00:01:45,506
可执行文件

45
00:01:46,126 --> 00:01:49,066
但是 我一开始写测试时

46
00:01:49,066 --> 00:01:51,636
还没有达到这些讨论的范畴

47
00:01:51,636 --> 00:01:52,496
就陷入停滞无法继续编写下去了

48
00:01:53,136 --> 00:01:56,166
感觉好像我的 app 代码

49
00:01:56,166 --> 00:01:57,976
主动地抗拒我

50
00:01:57,976 --> 00:01:58,876
写测试

51
00:01:59,416 --> 00:02:02,946
这个情况持续了一段时间

52
00:01:59,416 --> 00:02:02,946
这个情况持续了一段时间

53
00:02:02,946 --> 00:02:04,256
不过最后我发现

54
00:02:04,256 --> 00:02:06,076
我构建代码的方式

55
00:02:06,076 --> 00:02:07,236
阻碍了

56
00:02:07,286 --> 00:02:07,500
我进行有效的测试

57
00:02:10,895 --> 00:02:12,386
为了搞清楚这是什么意思

58
00:02:12,896 --> 00:02:14,056
首先请大家看这个单元测试

59
00:02:14,056 --> 00:02:15,936
这个单元测试的对象是

60
00:02:15,936 --> 00:02:18,486
已经具有可测试性的代码

61
00:02:18,876 --> 00:02:18,946
该代码是用来进行数组排序的

62
00:02:21,456 --> 00:02:23,636
这个测试使用的是

63
00:02:23,636 --> 00:02:25,186
Swift Standard Library 中的

64
00:02:25,186 --> 00:02:25,966
Sorted Method

65
00:02:26,676 --> 00:02:29,796
首先它创建一组

66
00:02:29,796 --> 00:02:30,876
未经排序的数值

67
00:02:31,556 --> 00:02:35,446
然后它为这组数值

68
00:02:35,446 --> 00:02:35,926
调用 Sorted Method

69
00:02:36,646 --> 00:02:39,556
然后再判断 

70
00:02:39,556 --> 00:02:41,606
返回的数组中数值按照预期的

71
00:02:41,686 --> 00:02:44,996
顺序排列

72
00:02:45,186 --> 00:02:47,366
概括说来 我们能够看到

73
00:02:47,366 --> 00:02:49,056
该测试的结构由三部分组成

74
00:02:49,056 --> 00:02:51,226
第一 创建任何

75
00:02:51,226 --> 00:02:53,386
所需的输入状态或数值

76
00:02:54,526 --> 00:02:56,136
然后 调用被测试的代码

77
00:02:56,136 --> 00:02:59,386
最后 判断

78
00:02:59,386 --> 00:03:00,556
返回的输出信息

79
00:02:59,386 --> 00:03:00,556
返回的输出信息

80
00:03:00,556 --> 00:03:01,746
是正确的

81
00:03:02,416 --> 00:03:04,356
有些情况下 这个模式被称作

82
00:03:04,356 --> 00:03:05,956
3A 模式（Arrange Act Assert）

83
00:03:06,586 --> 00:03:11,426
我们已经看过了

84
00:03:11,426 --> 00:03:13,206
这个具有不错可测试性的排序代码

85
00:03:14,266 --> 00:03:15,466
不过 我知道你们现在在想

86
00:03:16,176 --> 00:03:17,396
我的 app 代码里

87
00:03:17,486 --> 00:03:19,426
没有一点排序算法啊

88
00:03:20,496 --> 00:03:22,056
就我的经验而言 app 里面的

89
00:03:22,056 --> 00:03:23,486
大多数代码

90
00:03:23,486 --> 00:03:24,306
确实都和排序算法有

91
00:03:24,306 --> 00:03:24,816
天差地别

92
00:03:25,276 --> 00:03:27,616
不过 我们还是可以

93
00:03:27,616 --> 00:03:29,326
在我们的 app 中努力

94
00:03:29,326 --> 00:03:31,116
实现一些 Sorted Method 的

95
00:03:31,116 --> 00:03:32,426
特性

96
00:03:32,836 --> 00:03:34,016
以使其更加具有可测试性

97
00:03:35,286 --> 00:03:38,206
更确切地说 具有可测试性的代码

98
00:03:38,206 --> 00:03:39,836
能够帮助其客户端

99
00:03:39,836 --> 00:03:41,516
对代码处理的所有 inputs

100
00:03:41,516 --> 00:03:42,836
进行完全控制

101
00:03:43,416 --> 00:03:46,446
它能够帮助用户端

102
00:03:46,446 --> 00:03:48,276
检查所有

103
00:03:48,276 --> 00:03:49,026
正在生成的 output

104
00:03:49,656 --> 00:03:52,436
它避免了完全依赖于

105
00:03:52,436 --> 00:03:54,166
内部状态的情况 而这种情况

106
00:03:54,166 --> 00:03:55,346
有可能在日后影响到代码的行为

107
00:03:55,346 --> 00:04:02,106
我想要举一些关于代码的例子

108
00:03:55,346 --> 00:04:02,106
我想要举一些关于代码的例子

109
00:04:02,416 --> 00:04:03,306
来向大家展示几种技术

110
00:04:03,306 --> 00:04:05,016
这些技术可以用来把

111
00:04:05,016 --> 00:04:06,616
这些特性赋予给应用程序的代码

112
00:04:06,616 --> 00:04:08,636
并借此

113
00:04:08,636 --> 00:04:09,876
提高其可测试性

114
00:04:13,836 --> 00:04:15,656
第一个技术是

115
00:04:15,656 --> 00:04:16,916
如何将 protocols 及

116
00:04:16,916 --> 00:04:18,336
parameterization 引进到

117
00:04:18,336 --> 00:04:18,500
一个代码中

118
00:04:21,406 --> 00:04:23,456
比如 想象这是一个文档浏览的 app

119
00:04:23,456 --> 00:04:25,466
能够对

120
00:04:25,466 --> 00:04:27,056
各种不同类型的文档

121
00:04:27,056 --> 00:04:29,046
进行预览

122
00:04:29,046 --> 00:04:30,406
也可以切换到另一个不同的 app 里

123
00:04:30,406 --> 00:04:31,776
进行更加细致的查看

124
00:04:31,776 --> 00:04:33,766
或者编辑

125
00:04:34,936 --> 00:04:36,676
我们看到的前一个画面

126
00:04:36,676 --> 00:04:38,086
包括一个打开按钮

127
00:04:38,086 --> 00:04:39,546
还有一个分段控制

128
00:04:39,546 --> 00:04:40,896
用来选择

129
00:04:41,146 --> 00:04:42,546
是进行查看还是进行编辑

130
00:04:42,546 --> 00:04:46,776
好的 我们先来看看

131
00:04:46,776 --> 00:04:48,506
这一界面

132
00:04:48,856 --> 00:04:49,000
背后的代码

133
00:04:51,716 --> 00:04:52,796
当打开按钮被按下时

134
00:04:52,796 --> 00:04:54,216
view controller 中的

135
00:04:54,216 --> 00:04:55,626
event handler

136
00:04:56,636 --> 00:04:56,766
被调用

137
00:04:58,996 --> 00:05:00,216
首先是一些 business logic

138
00:04:58,996 --> 00:05:00,216
首先是一些 business logic

139
00:05:00,216 --> 00:05:02,756
用来构建一个 URL

140
00:05:02,756 --> 00:05:04,536
这个 URL 被用来请求 iOS

141
00:05:04,536 --> 00:05:06,186
切换到其它 app

142
00:05:08,216 --> 00:05:10,586
然后 它使用由

143
00:05:10,586 --> 00:05:12,356
UIKit 提供的 

144
00:05:12,356 --> 00:05:14,576
shared UI application instance

145
00:05:14,576 --> 00:05:15,806
来确定系统是否能够处理

146
00:05:15,806 --> 00:05:18,256
这个打开的请求 如果可以的话

147
00:05:18,256 --> 00:05:19,926
则执行这个打开 URL 的动作

148
00:05:20,596 --> 00:05:23,386
如果不可以的话 则调用辅助方式

149
00:05:23,386 --> 00:05:25,386
显示一些 UI 来引导

150
00:05:25,386 --> 00:05:26,526
用户去安装另一个

151
00:05:26,526 --> 00:05:27,000
app

152
00:05:30,086 --> 00:05:31,536
现在 我想要写一些测试

153
00:05:31,696 --> 00:05:32,996
来确保这个打开按钮

154
00:05:32,996 --> 00:05:34,186
能够以我们期望的方式

155
00:05:34,186 --> 00:05:35,436
运行

156
00:05:36,916 --> 00:05:38,196
测试这一点

157
00:05:38,196 --> 00:05:39,896
有许多种不同的途径

158
00:05:41,446 --> 00:05:43,346
一种方式就是写一个

159
00:05:43,346 --> 00:05:43,916
UI 测试

160
00:05:45,216 --> 00:05:46,566
我们要求启动 app

161
00:05:46,566 --> 00:05:48,886
导航到这一屏

162
00:05:48,936 --> 00:05:50,316
点击控制键

163
00:05:50,316 --> 00:05:52,256
轻击 open mode

164
00:05:52,256 --> 00:05:55,196
点击打开按钮

165
00:05:55,196 --> 00:05:56,506
然后验证手机切换显示

166
00:05:56,506 --> 00:05:57,186
另一个 app

167
00:05:57,446 --> 00:06:00,196
虽然这个办法行得通

168
00:05:57,446 --> 00:06:00,196
虽然这个办法行得通

169
00:06:00,196 --> 00:06:01,446
但是也有些缺点

170
00:06:01,886 --> 00:06:04,866
比如 它运行时间

171
00:06:04,866 --> 00:06:07,006
可能会比较长

172
00:06:07,006 --> 00:06:08,836
特别是当我想要对测试内容进行拓展时

173
00:06:08,836 --> 00:06:09,976
比如测试不同种类文档

174
00:06:09,976 --> 00:06:11,066
在不同打开模式下

175
00:06:11,066 --> 00:06:11,466
的运行效果

176
00:06:11,996 --> 00:06:15,086
更严重的缺点是

177
00:06:15,086 --> 00:06:17,606
一个 UI 测试无论如何都无法

178
00:06:17,606 --> 00:06:19,206
检查刚刚被生成的

179
00:06:19,206 --> 00:06:21,366
用来请求 iOS 切换 app

180
00:06:21,366 --> 00:06:22,236
的 URL

181
00:06:23,166 --> 00:06:24,526
而那个 URL 则是

182
00:06:24,526 --> 00:06:25,436
我真正想要

183
00:06:25,436 --> 00:06:26,576
进行更加精准检查的对象

184
00:06:28,176 --> 00:06:29,626
所以 似乎

185
00:06:29,626 --> 00:06:30,876
单元测试是更加

186
00:06:30,876 --> 00:06:31,556
适合这种情况的

187
00:06:34,416 --> 00:06:35,586
我们就来看看

188
00:06:35,586 --> 00:06:36,836
要为这个代码写一个

189
00:06:36,836 --> 00:06:37,000
单元测试需要些什么

190
00:06:40,016 --> 00:06:41,806
首先 你需要一个 view controller

191
00:06:41,806 --> 00:06:42,756
的 instance

192
00:06:42,756 --> 00:06:42,926
来进行操作

193
00:06:44,346 --> 00:06:45,286
我的 view controller 为其 UI

194
00:06:45,286 --> 00:06:47,406
使用了一个 storyboard

195
00:06:47,406 --> 00:06:48,986
所以我会让 UI Storyboard 来

196
00:06:48,986 --> 00:06:50,126
提供给我一个 view controller 的 instance

197
00:06:50,646 --> 00:06:54,616
然后我们需要加载这个视图

198
00:06:55,976 --> 00:06:57,186
来填入控制属性

199
00:06:57,186 --> 00:06:59,856
这样

200
00:06:59,856 --> 00:07:01,776
它就被视图数据填充了

201
00:06:59,856 --> 00:07:01,776
它就被视图数据填充了

202
00:07:01,776 --> 00:07:03,786
然后可以依据我们的 open mode

203
00:07:03,786 --> 00:07:05,096
对其进行配置

204
00:07:05,756 --> 00:07:07,406
提供一个可供处理的文档

205
00:07:08,106 --> 00:07:12,136
设定最终完成之后

206
00:07:12,136 --> 00:07:13,566
我们现在就可以

207
00:07:13,566 --> 00:07:15,546
调用要被测试的 method 了

208
00:07:18,116 --> 00:07:19,576
但是我们现在该怎么做呢

209
00:07:20,836 --> 00:07:22,046
我们能够在这里写哪一种

210
00:07:22,046 --> 00:07:23,000
assertion 似乎不太明了

211
00:07:27,056 --> 00:07:29,176
我们先回到代码那里

212
00:07:29,176 --> 00:07:30,346
再仔细看看究竟是什么

213
00:07:30,346 --> 00:07:32,146
导致了我们在进行测试时遇到这样的挑战

214
00:07:34,386 --> 00:07:36,476
首先 单单是因为在 view controller 内

215
00:07:36,476 --> 00:07:37,806
的这个情况

216
00:07:37,806 --> 00:07:39,346
就使得 methods 测试更加复杂了

217
00:07:39,986 --> 00:07:40,806
为了得到可以进行操作的

218
00:07:40,806 --> 00:07:41,436
view controller instance

219
00:07:41,436 --> 00:07:42,506
你就必须要

220
00:07:42,506 --> 00:07:42,656
越过重重关卡

221
00:07:43,236 --> 00:07:46,776
在这里 我们是从视图中直接

222
00:07:46,776 --> 00:07:48,286
取出 input 状态

223
00:07:48,286 --> 00:07:50,646
测试不得不强制

224
00:07:50,646 --> 00:07:52,536
加载该视图

225
00:07:52,576 --> 00:07:54,636
然后再间接地通过在

226
00:07:54,636 --> 00:07:56,066
一些 sub-view 上设置一个属性来

227
00:07:56,776 --> 00:08:00,066
提供 input

228
00:07:56,776 --> 00:08:00,066
提供 input

229
00:08:00,266 --> 00:08:01,966
不过 最严重的问题

230
00:08:01,966 --> 00:08:03,826
是这个 UI application shared instance

231
00:08:03,826 --> 00:08:04,706
的使用

232
00:08:08,516 --> 00:08:10,286
这个 canOpenURL 的回传值

233
00:08:10,286 --> 00:08:12,816
实际上

234
00:08:12,816 --> 00:08:14,126
是该 method 的另一个 input

235
00:08:15,586 --> 00:08:16,966
但是因为这个是依赖于

236
00:08:16,966 --> 00:08:18,676
全局系统状态的

237
00:08:18,676 --> 00:08:20,356
我们并无法给测试提供程序化的方法 

238
00:08:20,356 --> 00:08:21,506
来控制这个 query

239
00:08:21,506 --> 00:08:22,000
的结果

240
00:08:25,396 --> 00:08:26,606
对于一个单元测试而言

241
00:08:26,606 --> 00:08:28,306
也没有一个好的方式能够观察

242
00:08:28,306 --> 00:08:29,836
打开一个 URL 的副效应

243
00:08:30,616 --> 00:08:33,806
实际上 在调用这个之后

244
00:08:33,806 --> 00:08:35,155
测试渲染的 app 

245
00:08:35,155 --> 00:08:36,635
会被送至后台

246
00:08:36,635 --> 00:08:37,546
之后就再也没有办法

247
00:08:37,546 --> 00:08:38,206
把它带回到

248
00:08:38,206 --> 00:08:38,765
前台了

249
00:08:38,765 --> 00:08:42,645
那么 我们就来看看

250
00:08:42,645 --> 00:08:43,946
我们能够做些什么来提升

251
00:08:43,946 --> 00:08:44,206
这个代码的可测试性

252
00:08:44,856 --> 00:08:48,846
首先我们可以将其从

253
00:08:48,846 --> 00:08:49,586
view controller 中取出来

254
00:08:50,046 --> 00:08:53,076
然后引入一个新的

255
00:08:53,076 --> 00:08:55,206
document opener 类 将

256
00:08:55,206 --> 00:08:56,206
这个 logic 和 behavior 封装起来

257
00:08:58,756 --> 00:09:00,506
现在应该为 Open mode

258
00:08:58,756 --> 00:09:00,506
现在应该为 Open mode

259
00:09:00,506 --> 00:09:02,426
和 document inputs

260
00:09:02,426 --> 00:09:04,126
提供一个简单的 method arguments

261
00:09:04,126 --> 00:09:05,346
这样测试就可以间接地通过

262
00:09:05,996 --> 00:09:09,306
但是 我们仍然需要解决

263
00:09:09,306 --> 00:09:11,026
由 shared UI application incidence

264
00:09:11,026 --> 00:09:12,496
引起的问题

265
00:09:13,026 --> 00:09:17,246
我们能够怎么做呢

266
00:09:18,056 --> 00:09:20,086
首先 我们可以停止

267
00:09:20,086 --> 00:09:21,336
在这里直接

268
00:09:21,336 --> 00:09:22,376
使用 accessor

269
00:09:22,966 --> 00:09:25,696
让我们向类中加入

270
00:09:25,696 --> 00:09:27,786
一个 initializer 这样我们就能够

271
00:09:27,786 --> 00:09:29,776
得到一个特别的 application instance

272
00:09:30,316 --> 00:09:34,126
我们可以为此 argument 

273
00:09:34,126 --> 00:09:35,986
提供一个初始数值

274
00:09:35,986 --> 00:09:36,336
这样 在 view controller 中

275
00:09:36,336 --> 00:09:37,436
就不必要

276
00:09:37,436 --> 00:09:38,426
担心这个细节了

277
00:09:38,996 --> 00:09:44,546
回到 open method 这里

278
00:09:44,546 --> 00:09:45,556
我们随后切换使用

279
00:09:45,556 --> 00:09:47,006
刚才得到的

280
00:09:47,006 --> 00:09:49,416
application instance

281
00:09:49,636 --> 00:09:50,366
一起来看看

282
00:09:50,366 --> 00:09:51,356
这个代码重构给我们带来什么效果吧

283
00:09:55,016 --> 00:09:56,556
如果我们现在尝试

284
00:09:56,556 --> 00:09:58,536
在文档打开或者保持其当前状态的情况下

285
00:09:58,536 --> 00:10:00,116
重写测试

286
00:09:58,536 --> 00:10:00,116
重写测试

287
00:10:00,116 --> 00:10:01,006
我们会发现自己

288
00:10:01,006 --> 00:10:01,606
又被卡住了

289
00:10:02,896 --> 00:10:03,786
你想要得到一个

290
00:10:03,786 --> 00:10:04,836
我们能够控制的

291
00:10:04,836 --> 00:10:05,966
application instance

292
00:10:06,566 --> 00:10:07,886
自然 你可以想象将 UI 应用

293
00:10:07,886 --> 00:10:10,156
加入子类别

294
00:10:10,156 --> 00:10:12,236
覆写这个 canOpenURL 和 open methods

295
00:10:12,456 --> 00:10:13,896
来得到我们想要的控制

296
00:10:14,166 --> 00:10:16,616
但是 最后的结果是

297
00:10:16,616 --> 00:10:18,486
UI 应用严格地遵守其

298
00:10:18,486 --> 00:10:19,446
单例本质

299
00:10:20,166 --> 00:10:21,476
引发异常产生例外情况来试图

300
00:10:21,476 --> 00:10:23,086
创造第二个 instance

301
00:10:23,086 --> 00:10:24,000
即使它是一个子类

302
00:10:27,046 --> 00:10:28,006
所以 为了得到我们想要的控制

303
00:10:28,066 --> 00:10:29,876
我们不用加入子类别这个方式

304
00:10:29,876 --> 00:10:32,176
而是加入一个 protocol

305
00:10:32,176 --> 00:10:33,766
URL Opening

306
00:10:34,316 --> 00:10:38,136
我们看这个 protocol

307
00:10:38,786 --> 00:10:39,756
和这两个 methods

308
00:10:39,756 --> 00:10:41,596
它们所用的 signatures

309
00:10:41,596 --> 00:10:43,506
和我们到目前为止的应用 methods 所使用的

310
00:10:44,166 --> 00:10:47,506
signatures 一模一样

311
00:10:47,506 --> 00:10:49,546
我们仍然想让 UI 应用

312
00:10:49,546 --> 00:10:50,966
成为这个 protocol 的

313
00:10:50,966 --> 00:10:51,596
最主要的实现

314
00:10:52,876 --> 00:10:54,626
然后 我们会给 UI 应用

315
00:10:54,626 --> 00:10:56,466
添加一个 extension 来

316
00:10:56,466 --> 00:10:57,726
赋予其 URLOpening 一致性

317
00:10:58,226 --> 00:11:02,066
因为这些方法的 signatures 都

318
00:10:58,226 --> 00:11:02,066
因为这些方法的 signatures 都

319
00:11:02,066 --> 00:11:03,736
正好对应

320
00:11:03,736 --> 00:11:05,106
你就不需要再在这个 extension 上

321
00:11:05,106 --> 00:11:05,896
添加额外的代码

322
00:11:05,896 --> 00:11:06,386
来达到一致了

323
00:11:06,426 --> 00:11:12,056
现在有一个 protocol 已经就绪

324
00:11:12,056 --> 00:11:13,736
我们就更新 DocumentOpener

325
00:11:13,736 --> 00:11:15,436
来使用这个 protocol

326
00:11:15,436 --> 00:11:17,000
而不用 UI 应用本身了

327
00:11:20,366 --> 00:11:21,946
首先 我们来更改其属性

328
00:11:21,946 --> 00:11:24,306
并初始化参数来接受

329
00:11:24,306 --> 00:11:25,766
这个 URLOpening protocol 的

330
00:11:25,766 --> 00:11:26,856
任何的实现

331
00:11:27,446 --> 00:11:30,216
要注意 我们仍然能够

332
00:11:30,216 --> 00:11:31,716
保持 shard UI application instance 的

333
00:11:31,716 --> 00:11:32,846
默认参数

334
00:11:32,846 --> 00:11:34,816
这样我们之后

335
00:11:34,816 --> 00:11:35,506
在 view controller 使用它时

336
00:11:35,506 --> 00:11:35,986
就会方便很多

337
00:11:39,316 --> 00:11:40,856
最后一个变更需要

338
00:11:40,856 --> 00:11:43,176
document opener 采用

339
00:11:43,176 --> 00:11:45,416
URL opener 的属性名称

340
00:11:48,576 --> 00:11:49,826
一切都做好了 我们现在回到测试去

341
00:11:49,826 --> 00:11:51,546
来一起看看这样操作之后的

342
00:11:51,546 --> 00:11:52,000
效果如何

343
00:11:57,046 --> 00:11:58,796
因为 UI 应用不能

344
00:11:58,796 --> 00:12:00,196
使我们得到在测试中需要的控制

345
00:11:58,796 --> 00:12:00,196
使我们得到在测试中需要的控制

346
00:12:00,196 --> 00:12:02,146
我们就想建构

347
00:12:02,146 --> 00:12:04,076
protocol 的一个

348
00:12:04,076 --> 00:12:06,566
次级的mock implementation虚拟实现

349
00:12:08,436 --> 00:12:08,566
来在其位置使用

350
00:12:08,746 --> 00:12:10,506
我们在这里已经加上了

351
00:12:10,596 --> 00:12:13,866
两个 methods 的 sub-implementation

352
00:12:13,866 --> 00:12:16,246
canOpen URL method 充当

353
00:12:16,246 --> 00:12:17,516
来自 document opener 的

354
00:12:17,516 --> 00:12:17,896
一个 input

355
00:12:18,726 --> 00:12:19,596
所以 测试需要控制

356
00:12:19,596 --> 00:12:20,776
此 input

357
00:12:21,806 --> 00:12:22,816
通过使 implementation 返回

358
00:12:22,816 --> 00:12:24,716
测试事先设置好的 

359
00:12:24,716 --> 00:12:26,276
属性的数值

360
00:12:26,276 --> 00:12:27,096
我们就能够做到这一点

361
00:12:30,296 --> 00:12:32,106
而 open method 则充当了

362
00:12:32,106 --> 00:12:33,636
来自 document opener 的 output

363
00:12:34,836 --> 00:12:35,776
测试希望能够

364
00:12:35,776 --> 00:12:37,996
接入任何传进这个 method

365
00:12:37,996 --> 00:12:38,696
的 URL

366
00:12:39,176 --> 00:12:41,916
为了达到这一点 我们可以将

367
00:12:41,916 --> 00:12:43,916
URL 藏到一个属性之中

368
00:12:43,976 --> 00:12:45,346
然后可以让测试在随后读取

369
00:12:48,956 --> 00:12:50,616
好的 我们继续

370
00:12:50,616 --> 00:12:51,000
编写这个测试

371
00:12:53,436 --> 00:12:54,726
首先 我们为刚刚写好的

372
00:12:54,726 --> 00:12:56,146
mockURLOpener 创建一个 instance,

373
00:12:56,146 --> 00:12:58,306
然后用 canOpen 属性

374
00:12:58,546 --> 00:12:59,706
设置 input

375
00:13:02,296 --> 00:13:03,446
创建一个 documentOpener

376
00:13:03,446 --> 00:13:06,046
然后将 mock urlOpener 加入

377
00:13:06,046 --> 00:13:07,106
作为 argument

378
00:13:07,666 --> 00:13:11,756
设置好了这个

379
00:13:11,756 --> 00:13:14,216
我们就可以调用 open method

380
00:13:14,216 --> 00:13:15,696
加入 document 和 open mode 的数值

381
00:13:16,066 --> 00:13:18,186
作为余下的 input

382
00:13:20,316 --> 00:13:22,296
然后 我们可以判断

383
00:13:22,296 --> 00:13:24,116
mock URLOpener 的 

384
00:13:24,116 --> 00:13:26,216
openedURL 属性已经设置为

385
00:13:26,216 --> 00:13:27,036
期望的 URL

386
00:13:27,666 --> 00:13:30,966
这个 assertion 在 

387
00:13:30,966 --> 00:13:32,446
被调用的 open method 和

388
00:13:32,446 --> 00:13:34,756
包含有正确数据的

389
00:13:34,756 --> 00:13:36,436
传入的 URL 上

390
00:13:36,436 --> 00:13:37,006
都进行测试

391
00:13:40,696 --> 00:13:42,186
已经学习过这个测试后

392
00:13:42,546 --> 00:13:43,606
大家就可以继续

393
00:13:43,606 --> 00:13:45,046
为其它 input 数据的变体

394
00:13:45,046 --> 00:13:47,286
编写测试了

395
00:13:47,286 --> 00:13:48,626
比如 canOpen 属性设置为 false 的变体

396
00:13:48,626 --> 00:13:50,436
我们接下来还有很多内容要讲

397
00:13:50,436 --> 00:13:51,806
这部分就先讲到这里

398
00:13:55,646 --> 00:13:57,776
在这个例子中

399
00:13:57,776 --> 00:13:59,766
我们进行了一些代码重构

400
00:13:59,766 --> 00:14:01,406
以使得我们能够为自己的代码

401
00:13:59,766 --> 00:14:01,406
以使得我们能够为自己的代码

402
00:14:01,406 --> 00:14:02,000
编写单元测试

403
00:14:04,436 --> 00:14:05,506
我们抽离掉对一个

404
00:14:05,506 --> 00:14:07,046
shared singleton instance 的

405
00:14:07,046 --> 00:14:09,416
显示引用

406
00:14:09,416 --> 00:14:11,516
然后用 parameterized input 取代显示引用

407
00:14:11,516 --> 00:14:12,246
来作置换

408
00:14:13,666 --> 00:14:15,566
一些情况下

409
00:14:15,566 --> 00:14:17,976
这个被称作 penancy injection

410
00:14:18,196 --> 00:14:20,186
在这个例子中

411
00:14:20,186 --> 00:14:22,356
我们使用了一个 initialized parameter

412
00:14:22,356 --> 00:14:22,916
来达到这个目的

413
00:14:23,296 --> 00:14:24,466
我们也可以使用一个

414
00:14:24,466 --> 00:14:26,636
属性 setter 或者是

415
00:14:26,636 --> 00:14:27,500
接受测试的 method 的一个 parameter

416
00:14:31,196 --> 00:14:33,236
我们创建了一个 protocol 来

417
00:14:33,236 --> 00:14:34,276
将代码从其先前依赖的

418
00:14:34,276 --> 00:14:35,396
具体类中

419
00:14:35,396 --> 00:14:37,000
解耦出来

420
00:14:39,096 --> 00:14:40,396
然后我们又创建了一个

421
00:14:40,396 --> 00:14:42,756
测试 implementation 来

422
00:14:42,756 --> 00:14:43,176
在其位置运行

423
00:14:43,176 --> 00:14:45,506
这给予了我们所需的

424
00:14:45,506 --> 00:14:46,826
对于 inputs 的控制

425
00:14:47,426 --> 00:14:49,346
以及 outputs 的可视性

426
00:14:56,276 --> 00:14:58,656
接下来 我希望带大家看看

427
00:14:58,656 --> 00:15:00,356
如何将 logic 从 effects 中分离出来

428
00:14:58,656 --> 00:15:00,356
如何将 logic 从 effects 中分离出来

429
00:15:00,356 --> 00:15:02,176
以及如何用此种操作

430
00:15:02,176 --> 00:15:03,386
提升可测试性

431
00:15:07,636 --> 00:15:10,226
这里的例子是一个

432
00:15:10,316 --> 00:15:12,466
OnDiskCache 类

433
00:15:12,466 --> 00:15:14,526
可能是被 app 用来

434
00:15:14,526 --> 00:15:15,806
对先前已经从服务器下载下来的 assets

435
00:15:15,806 --> 00:15:17,346
进行更快速的

436
00:15:17,856 --> 00:15:18,000
取回

437
00:15:20,946 --> 00:15:22,866
该 Cache 界定了

438
00:15:22,866 --> 00:15:24,066
一个脚本

439
00:15:24,066 --> 00:15:24,416
此脚本代表了其所储存的条目

440
00:15:24,896 --> 00:15:26,926
它界定了在文件系统中

441
00:15:26,926 --> 00:15:28,936
获取该条目的路径

442
00:15:28,936 --> 00:15:30,436
以及它在 cache 上存在的时间

443
00:15:30,436 --> 00:15:31,146
和在磁盘上的大小

444
00:15:31,656 --> 00:15:34,166
并提供了获取

445
00:15:34,166 --> 00:15:35,706
目前所有储存在 cache 上条目集合

446
00:15:35,706 --> 00:15:36,586
的方法

447
00:15:40,096 --> 00:15:41,176
现在需要注意的 method

448
00:15:41,176 --> 00:15:43,216
是一个

449
00:15:43,216 --> 00:15:43,586
cleanup method

450
00:15:44,316 --> 00:15:45,096
这个 method 应该是被

451
00:15:45,096 --> 00:15:46,816
周期性地调用

452
00:15:46,816 --> 00:15:47,976
以保证 cache 不会增加得过多

453
00:15:47,976 --> 00:15:49,146
占据文件系统

454
00:15:49,146 --> 00:15:49,486
太多的空间

455
00:15:49,836 --> 00:15:53,136
好的 我们来看一看

456
00:15:53,136 --> 00:15:54,716
这个 method 对应的

457
00:15:55,176 --> 00:15:55,326
起始实现

458
00:15:57,256 --> 00:15:59,716
首先 它请求

459
00:15:59,716 --> 00:16:00,916
当前所有处在 cache 上的

460
00:15:59,716 --> 00:16:00,916
当前所有处在 cache 上的

461
00:16:00,916 --> 00:16:02,926
条目集合

462
00:16:02,926 --> 00:16:03,456
按照从最新到最老的顺序排列

463
00:16:03,936 --> 00:16:07,646
然后

464
00:16:07,646 --> 00:16:09,986
这些条目

465
00:16:09,986 --> 00:16:11,406
记录下所有已见到条目

466
00:16:11,406 --> 00:16:12,000
的总大小

467
00:16:15,086 --> 00:16:16,086
一旦你看到了

468
00:16:16,156 --> 00:16:17,196
达到了我们的最大容量

469
00:16:17,196 --> 00:16:19,416
的足够多的条目 我们就可以开始

470
00:16:19,416 --> 00:16:23,636
将其余的从文件系统中移除出去了

471
00:16:23,896 --> 00:16:24,986
好的 让我们想想应该

472
00:16:24,986 --> 00:16:25,646
如何测试这个 method

473
00:16:26,976 --> 00:16:27,846
什么是其 inputs

474
00:16:28,186 --> 00:16:31,566
什么是其 outputs

475
00:16:31,696 --> 00:16:33,896
一个 input 是指定了

476
00:16:33,896 --> 00:16:35,116
你想要 cache 最大能增大到多少的

477
00:16:35,116 --> 00:16:36,346
parameter

478
00:16:36,346 --> 00:16:39,076
这是一个简单的整数

479
00:16:39,076 --> 00:16:40,996
一个 method parameter

480
00:16:40,996 --> 00:16:42,476
所以测试对其已经拥有

481
00:16:42,606 --> 00:16:42,660
完全的控制

482
00:16:45,316 --> 00:16:47,506
另外一个 input

483
00:16:47,506 --> 00:16:48,816
是现在储存在 cache 上的

484
00:16:48,816 --> 00:16:51,226
条目列表

485
00:16:51,436 --> 00:16:52,636
我们就不去花时间看

486
00:16:52,636 --> 00:16:54,326
这个到底是怎么实现的了

487
00:16:54,326 --> 00:16:56,236
但是这里的关键是

488
00:16:56,236 --> 00:16:57,976
它使用了一个 file manage r来

489
00:16:57,976 --> 00:16:59,586
从磁盘上取回一个文件列表

490
00:17:01,736 --> 00:17:03,326
这就意味着

491
00:17:03,326 --> 00:17:04,626
input 实际是来源于

492
00:17:04,626 --> 00:17:06,836
文件系统的

493
00:17:06,836 --> 00:17:07,726
测试则需要

494
00:17:07,726 --> 00:17:08,976
处理好这种依赖性

495
00:17:12,296 --> 00:17:14,276
clean cache method 没有

496
00:17:14,276 --> 00:17:14,965
返回数值

497
00:17:15,576 --> 00:17:18,606
所以 它的 output 不可能是数据

498
00:17:18,786 --> 00:17:20,566
换句话说 它是 

499
00:17:20,566 --> 00:17:22,296
在一系列特定的文件被从磁盘移除后

500
00:17:22,296 --> 00:17:23,606
产生的副效应

501
00:17:24,056 --> 00:17:27,195
因为它依赖于文件系统

502
00:17:27,195 --> 00:17:29,146
对于这个 method 的测试

503
00:17:29,146 --> 00:17:31,436
就需要和在文件系统中的

504
00:17:31,436 --> 00:17:33,126
一个文件管理器打交道

505
00:17:34,336 --> 00:17:35,966
设置这些测试时

506
00:17:35,966 --> 00:17:37,876
可能需要它们创建一个临时文件夹

507
00:17:37,876 --> 00:17:39,716
然后向其中填入一些

508
00:17:39,716 --> 00:17:41,526
特定大小的文件

509
00:17:41,526 --> 00:17:43,196
并给它们加上特定的 timestamps

510
00:17:43,196 --> 00:17:43,936
来提供 input

511
00:17:45,856 --> 00:17:47,466
为了验证 output

512
00:17:47,836 --> 00:17:48,876
你则需要随后返回到

513
00:17:48,876 --> 00:17:50,936
文件系统去看看哪些文件

514
00:17:50,936 --> 00:17:52,000
还在那里

515
00:17:56,176 --> 00:17:57,266
一种实现该目的的方式

516
00:17:57,266 --> 00:17:59,816
就是使用

517
00:17:59,816 --> 00:18:01,116
我们之前看过的

518
00:17:59,816 --> 00:18:01,116
我们之前看过的

519
00:18:01,116 --> 00:18:01,926
protocols 和 parameterization 技术

520
00:18:03,296 --> 00:18:04,636
你可以引进一个

521
00:18:04,636 --> 00:18:06,676
文件管理器 protocol

522
00:18:06,676 --> 00:18:07,916
它具有我们需要的 methods

523
00:18:07,916 --> 00:18:09,606
能够帮助我们得到一个文件列表

524
00:18:09,606 --> 00:18:10,306
并移除一个文件

525
00:18:11,786 --> 00:18:13,026
然后创建一个测试实现

526
00:18:13,026 --> 00:18:15,206
能够详细列举

527
00:18:15,206 --> 00:18:16,446
会被返回的

528
00:18:16,446 --> 00:18:17,986
文件列表

529
00:18:17,986 --> 00:18:19,246
并针对哪些文件被移除

530
00:18:19,746 --> 00:18:19,946
发出一个 query

531
00:18:21,996 --> 00:18:23,396
如果我们这么做

532
00:18:23,396 --> 00:18:25,136
我们还是在间接地

533
00:18:25,286 --> 00:18:26,276
同想要测试的代码互动

534
00:18:26,276 --> 00:18:28,386
文件管理器

535
00:18:28,386 --> 00:18:28,756
负责居中进行协调

536
00:18:32,306 --> 00:18:34,146
我们不这样做

537
00:18:34,146 --> 00:18:35,156
来试试不同的方式

538
00:18:35,826 --> 00:18:37,406
我们可以使用

539
00:18:37,406 --> 00:18:40,376
clean cache method 并

540
00:18:40,656 --> 00:18:41,896
从负责确定哪些文件需要被移除的 logic 中

541
00:18:41,896 --> 00:18:44,126
提出撰因子

542
00:18:44,126 --> 00:18:46,606
就是 clean-up policy

543
00:18:46,606 --> 00:18:47,576
然后你就能够

544
00:18:47,576 --> 00:18:48,026
进行更直接的互动了

545
00:18:48,666 --> 00:18:51,606
我们来看看这个是如何运转的

546
00:18:54,776 --> 00:18:56,136
为了清楚地界定我们

547
00:18:56,136 --> 00:18:57,316
要使用的 APIs

548
00:18:57,586 --> 00:18:59,206
首先我们将 clean-up policy 定义为

549
00:18:59,206 --> 00:18:59,776
一个 protocol

550
00:19:00,406 --> 00:19:03,976
这只需要一个 method 即

551
00:19:04,326 --> 00:19:05,126
itemsToRemove

552
00:19:06,456 --> 00:19:07,876
注意下我们给它加上的

553
00:19:07,876 --> 00:19:09,696
type signature

554
00:19:09,696 --> 00:19:11,836
和之前我们开始时的

555
00:19:11,836 --> 00:19:13,126
clean cache method 的

556
00:19:13,416 --> 00:19:13,500
看起来有些不一样

557
00:19:16,066 --> 00:19:18,856
作为 input

558
00:19:18,916 --> 00:19:20,276
这个新的 method 使用一组 cache 条目数值

559
00:19:21,616 --> 00:19:23,316
而对于 output

560
00:19:23,416 --> 00:19:25,506
它能够返回另一组数值

561
00:19:25,506 --> 00:19:27,206
但是这是那些将被移除的条目数值

562
00:19:30,596 --> 00:19:32,046
好的 我们就看看

563
00:19:32,046 --> 00:19:33,696
如何用我们先前在

564
00:19:33,696 --> 00:19:35,166
cache 类里面看到的算法

565
00:19:35,166 --> 00:19:37,326
来实现这个 protocol

566
00:19:39,416 --> 00:19:40,546
好的 首先为 input 的最大值

567
00:19:40,756 --> 00:19:41,966
界定一个属性

568
00:19:42,896 --> 00:19:44,276
这可以让我们明确这个最大的大小

569
00:19:44,276 --> 00:19:45,496
然后我们可以构建

570
00:19:45,496 --> 00:19:45,936
policy

571
00:19:48,916 --> 00:19:50,646
然后我们添加

572
00:19:50,646 --> 00:19:52,166
protocol 要求的

573
00:19:52,166 --> 00:19:52,716
itemsToRemove method

574
00:19:56,136 --> 00:19:57,686
我们想要检查

575
00:19:57,686 --> 00:19:59,096
每一个传递进 method 的条目

576
00:19:59,786 --> 00:20:01,246
然后构建一组将被移除的条目

577
00:19:59,786 --> 00:20:01,246
然后构建一组将被移除的条目

578
00:20:01,246 --> 00:20:02,906
在完成之后

579
00:20:02,906 --> 00:20:04,000
再将其返回给 method

580
00:20:07,216 --> 00:20:09,166
为了填充该组

581
00:20:09,166 --> 00:20:10,346
我们将这些条目按照从新至老的顺序

582
00:20:10,346 --> 00:20:13,416
进行循环

583
00:20:13,416 --> 00:20:14,826
计算已见所有条目大小

584
00:20:14,826 --> 00:20:16,006
的总数

585
00:20:18,336 --> 00:20:19,776
一旦我们达到了最大值

586
00:20:19,776 --> 00:20:22,346
就开始向这组 itemsToRemove

587
00:20:22,346 --> 00:20:24,186
添加剩余的

588
00:20:27,496 --> 00:20:29,826
请看这条代码

589
00:20:29,826 --> 00:20:31,086
我们能够发现在先前版本中

590
00:20:31,086 --> 00:20:32,556
容易出现的副效应

591
00:20:32,806 --> 00:20:33,556
在此处已经被移除

592
00:20:34,166 --> 00:20:36,666
保留下来的是底层算法

593
00:20:36,666 --> 00:20:40,096
将数据取作 input

594
00:20:40,806 --> 00:20:44,016
然后返回一些数据

595
00:20:44,016 --> 00:20:44,416
作为 output

596
00:20:45,566 --> 00:20:46,886
我们也可以将由此而

597
00:20:46,886 --> 00:20:47,956
实现的数据流

598
00:20:47,956 --> 00:20:48,496
可视化

599
00:20:49,106 --> 00:20:51,826
注意下 这个代码采用了

600
00:20:51,826 --> 00:20:53,206
功能样式

601
00:20:53,946 --> 00:20:55,376
数据进入 数据输出

602
00:20:59,736 --> 00:21:01,336
通过这种方式将 logic

603
00:20:59,736 --> 00:21:01,336
通过这种方式将 logic

604
00:21:01,336 --> 00:21:03,456
进行提出撰因子操作

605
00:21:03,456 --> 00:21:04,796
我们能够写出清晰

606
00:21:04,796 --> 00:21:06,536
简明的测试

607
00:21:06,536 --> 00:21:10,216
然后对算法进行全面的测试

608
00:21:10,336 --> 00:21:12,046
我们需要做的就是界定

609
00:21:12,156 --> 00:21:16,536
包含有一些 cache 条目的输入集

610
00:21:16,536 --> 00:21:17,826
创建一个该类型的 instance

611
00:21:18,656 --> 00:21:20,296
调用 method

612
00:21:20,296 --> 00:21:21,486
直接将其需要的数值传递进入

613
00:21:21,486 --> 00:21:25,246
然后判断

614
00:21:25,246 --> 00:21:27,026
返回的条目

615
00:21:27,026 --> 00:21:27,736
匹配预期的结果

616
00:21:28,266 --> 00:21:32,296
有了这种形式的代码

617
00:21:32,296 --> 00:21:33,326
我们现在就能够轻易获得

618
00:21:33,326 --> 00:21:35,446
对 inputs 的控制

619
00:21:35,446 --> 00:21:38,116
及 outputs 的可视化显示

620
00:21:38,116 --> 00:21:39,486
没有任何需要进行处理的隐藏状态了

621
00:21:40,476 --> 00:21:41,656
这个特别能让我们

622
00:21:41,656 --> 00:21:43,606
联想到一开始看到的

623
00:21:43,606 --> 00:21:44,576
为 sorted method 所写的测试

624
00:21:46,496 --> 00:21:48,406
测试因此变得

625
00:21:48,406 --> 00:21:50,136
极易读取

626
00:21:50,136 --> 00:21:51,926
测试要针对的要素

627
00:21:51,926 --> 00:21:55,506
也运行飞快

628
00:21:55,506 --> 00:21:57,446
受到的干扰也最小

629
00:21:57,446 --> 00:21:59,536
因为它不再需要依赖于运行速度慢的资源了

630
00:21:59,536 --> 00:22:00,436
比如文件系统

631
00:21:59,536 --> 00:22:00,436
比如文件系统

632
00:22:00,966 --> 00:22:04,406
而且极具确定性

633
00:22:04,576 --> 00:22:06,256
因为所有使用的数据

634
00:22:06,256 --> 00:22:06,936
都是独立的

635
00:22:11,756 --> 00:22:13,596
再回来看一眼

636
00:22:13,596 --> 00:22:15,136
最初的 clean cache method

637
00:22:15,476 --> 00:22:17,476
我们发现在进行取出操作后

638
00:22:17,476 --> 00:22:19,326
剩下的东西就不多了

639
00:22:21,476 --> 00:22:22,826
我们现在只要请求

640
00:22:22,826 --> 00:22:24,736
clean-up policy 来

641
00:22:24,736 --> 00:22:28,126
将条目移除

642
00:22:28,126 --> 00:22:30,076
然后迭代直到

643
00:22:30,076 --> 00:22:30,906
将其全部移除出文件系统

644
00:22:33,236 --> 00:22:36,036
为了测试剩余的代码

645
00:22:36,036 --> 00:22:37,496
我们可以引进

646
00:22:37,496 --> 00:22:39,186
文件管理器 protocol 以及

647
00:22:39,186 --> 00:22:41,236
具备可测试性的实现

648
00:22:41,236 --> 00:22:42,836
来使得我们能够为其写一个

649
00:22:43,446 --> 00:22:43,500
十分独立的单元测试

650
00:22:44,496 --> 00:22:46,486
当然 我们也许也会觉得

651
00:22:46,486 --> 00:22:48,466
几个综合测试

652
00:22:48,466 --> 00:22:49,506
就已经足够了

653
00:22:49,506 --> 00:22:51,496
就能够让我们对代码可以正确运行

654
00:22:51,496 --> 00:22:52,646
有足够的把握

655
00:22:53,916 --> 00:22:55,176
这一薄薄的[听不清]

656
00:22:55,296 --> 00:22:56,986
代码层就是剩下的

657
00:23:01,816 --> 00:23:04,186
好的 在这个例子中

658
00:23:04,736 --> 00:23:08,036
我们看到了如何利用副效应

659
00:23:08,036 --> 00:23:09,606
将 business logic 和算法

660
00:23:09,606 --> 00:23:12,176
从代码中抽取出到

661
00:23:12,206 --> 00:23:13,606
单独的类型中

662
00:23:15,636 --> 00:23:17,806
在进行这种操作时

663
00:23:17,806 --> 00:23:19,046
算法通常会倾向于呈现功能样式

664
00:23:19,046 --> 00:23:21,026
使用数值类型

665
00:23:21,026 --> 00:23:22,976
来描述 inputs

666
00:23:23,186 --> 00:23:23,976
和 outputs

667
00:23:24,466 --> 00:23:26,926
这个使我们能够利用

668
00:23:26,926 --> 00:23:29,216
简单直接的单元测试

669
00:23:29,216 --> 00:23:30,806
对算法进行测试

670
00:23:30,806 --> 00:23:31,326
可以达到任何你所需的细致程度

671
00:23:34,676 --> 00:23:36,116
我们还剩下一小部分

672
00:23:36,116 --> 00:23:37,636
代码用来运行

673
00:23:37,636 --> 00:23:38,966
基于电脑数据的

674
00:23:38,966 --> 00:23:39,406
副效应

675
00:23:39,906 --> 00:23:42,336
这个部分经常

676
00:23:42,336 --> 00:23:43,856
可以用综合测试

677
00:23:43,856 --> 00:23:46,316
来进行很好的测试

678
00:23:46,316 --> 00:23:47,406
这样就能够跟踪

679
00:23:47,406 --> 00:23:48,526
它和余下的系统间的互动

680
00:23:48,526 --> 00:23:49,256
正在正常进行

681
00:23:54,176 --> 00:23:57,126
总结一下

682
00:23:57,126 --> 00:23:59,186
我们看过了一些例子

683
00:23:59,186 --> 00:24:00,956
这些例子能够帮助我们探索一些

684
00:23:59,186 --> 00:24:00,956
这些例子能够帮助我们探索一些

685
00:24:00,956 --> 00:24:03,116
允许我们构建或者请求代码的技术

686
00:24:03,116 --> 00:24:04,956
这样测试就能够拥有对代码 inputs 的控制

687
00:24:04,956 --> 00:24:06,996
以及其 outputs 的可视性

688
00:24:06,996 --> 00:24:09,126
因此 这就能够使我们

689
00:24:09,126 --> 00:24:10,456
为其写出

690
00:24:10,456 --> 00:24:12,026
有效的单元测试

691
00:24:14,776 --> 00:24:16,296
好的 现在我想要请我的同事上来

692
00:24:16,296 --> 00:24:18,146
Greg Tracy 来给大家讲一讲

693
00:24:18,146 --> 00:24:19,466
如何创建能够随着你的 app

694
00:24:19,816 --> 00:24:21,126
成长也进行扩展的

695
00:24:21,126 --> 00:24:21,556
测试套件

696
00:24:23,516 --> 00:24:27,500
[掌声]

697
00:24:31,636 --> 00:24:32,586
&gt;&gt; 大家好

698
00:24:32,796 --> 00:24:33,536
我叫 Greg

699
00:24:33,536 --> 00:24:35,996
现在也在 Xcode 工作

700
00:24:37,316 --> 00:24:38,866
刚才 Brian 给大家展示了

701
00:24:38,866 --> 00:24:40,176
如何使得 app 代码更具可测试性

702
00:24:40,176 --> 00:24:41,216
的一些技术

703
00:24:41,826 --> 00:24:42,926
现在我想要给大家展示

704
00:24:42,926 --> 00:24:44,336
如何使得伴随着的测试代码

705
00:24:44,336 --> 00:24:45,356
更加具有可扩展性

706
00:24:45,356 --> 00:24:47,316
为了达到这一点

707
00:24:47,316 --> 00:24:49,376
我们会来一起看看几种能够让

708
00:24:49,376 --> 00:24:51,166
测试运行更快 更加易读 更模块化

709
00:24:51,166 --> 00:24:52,006
的方法

710
00:24:52,446 --> 00:24:54,306
我也想要提一下

711
00:24:54,306 --> 00:24:55,606
刚才 Brian 所介绍的技术

712
00:24:55,606 --> 00:24:57,256
大多对测试代码

713
00:24:57,256 --> 00:24:58,256
也是适用的

714
00:24:58,926 --> 00:25:00,056
不过在这里 我们会看看

715
00:24:58,926 --> 00:25:00,056
不过在这里 我们会看看

716
00:25:00,056 --> 00:25:01,766
更多的小窍门

717
00:25:03,196 --> 00:25:05,516
首先 我会讲讲

718
00:25:05,606 --> 00:25:07,166
在 UI 和单元测试间达到一个平衡

719
00:25:08,106 --> 00:25:08,330
这个话题

720
00:25:09,376 --> 00:25:11,496
然后 我会讲讲如何能够帮助测试

721
00:25:11,496 --> 00:25:13,816
具备可扩展性的代码

722
00:25:13,816 --> 00:25:14,376
重点放在 UI 测试代码上

723
00:25:15,086 --> 00:25:17,386
随后 我会给大家说明

724
00:25:17,386 --> 00:25:19,416
测试代码质量

725
00:25:19,416 --> 00:25:20,000
的重要性

726
00:25:22,736 --> 00:25:23,716
在 UI 测试和单元测试间

727
00:25:23,776 --> 00:25:27,436
达到正确的平衡

728
00:25:27,436 --> 00:25:28,436
有些时候 我喜欢

729
00:25:28,436 --> 00:25:30,006
将测试的分布视作

730
00:25:30,006 --> 00:25:30,536
一个金字塔

731
00:25:31,816 --> 00:25:33,216
最顶端的是 UI 测试

732
00:25:33,216 --> 00:25:36,036
底部呢

733
00:25:36,036 --> 00:25:37,906
则是单元测试

734
00:25:38,656 --> 00:25:40,026
这个[听不清]

735
00:25:40,026 --> 00:25:42,286
金字塔的结构也正好体现了现实情况

736
00:25:42,406 --> 00:25:44,336
相较于 UI 测试而言

737
00:25:44,336 --> 00:25:44,826
我们进行的单元测试数量会更多一些

738
00:25:45,336 --> 00:25:46,526
这个通常是因为

739
00:25:46,526 --> 00:25:48,496
单元测试的运行速度

740
00:25:48,496 --> 00:25:49,566
要比 UI 测试快很多

741
00:25:50,956 --> 00:25:53,296
在 UI 测试和单元测试之间

742
00:25:53,456 --> 00:25:56,206
我们还有综合测试

743
00:25:56,986 --> 00:25:58,726
不过 今天我们会把重点

744
00:25:58,726 --> 00:26:00,156
放在 UI 测试

745
00:25:58,726 --> 00:26:00,156
放在 UI 测试

746
00:26:00,156 --> 00:26:00,330
和单元测试上

747
00:26:04,396 --> 00:26:06,216
除了能够体现分布状态

748
00:26:06,216 --> 00:26:07,516
这个金字塔结构

749
00:26:07,516 --> 00:26:08,786
也能够体现不同测试的

750
00:26:08,786 --> 00:26:09,246
维护成本

751
00:26:09,986 --> 00:26:11,496
一般情况下

752
00:26:11,496 --> 00:26:12,586
UI 测试的维护成本会比较高

753
00:26:12,586 --> 00:26:14,036
因为会有各种各样的

754
00:26:14,036 --> 00:26:14,716
情况发生

755
00:26:15,896 --> 00:26:17,106
另一方面 单元测试

756
00:26:17,396 --> 00:26:19,206
的维护成本则比较低

757
00:26:19,476 --> 00:26:21,626
所以 当一个单元测试失败后

758
00:26:21,626 --> 00:26:23,206
哪里出现了问题

759
00:26:23,346 --> 00:26:24,146
一般都是瞬间就一目了然的

760
00:26:25,336 --> 00:26:27,066
而 UI 测试

761
00:26:27,066 --> 00:26:28,916
则像是撒下了一张大网

762
00:26:28,916 --> 00:26:30,006
可能能够捕捉到

763
00:26:30,006 --> 00:26:31,996
难以理解的测试失败结果

764
00:26:31,996 --> 00:26:33,286
或者得到和手头测试相关性并不高的结果

765
00:26:33,336 --> 00:26:34,946
所以 UI 测试可能会有些难以捉摸

766
00:26:38,216 --> 00:26:39,556
虽然这个金字塔结构

767
00:26:39,556 --> 00:26:41,216
能够很好地展示

768
00:26:41,506 --> 00:26:43,176
我们各种测试的分布状况

769
00:26:43,176 --> 00:26:45,096
但是并不能够

770
00:26:45,096 --> 00:26:46,486
体现

771
00:26:46,536 --> 00:26:47,136
每一种可能出现的情况

772
00:26:47,826 --> 00:26:48,996
事实上 你可以将测试

773
00:26:48,996 --> 00:26:50,816
想象成为一个频谱

774
00:26:50,816 --> 00:26:51,726
而非一个金字塔

775
00:26:52,296 --> 00:26:53,886
一些 UI 测试和

776
00:26:54,376 --> 00:26:55,606
单元测试 经常会存在于

777
00:26:55,676 --> 00:26:56,946
这个频谱的两端

778
00:26:57,406 --> 00:26:58,726
或者是这个金字塔结构的两端

779
00:26:59,306 --> 00:27:01,056
一些 UI 测试可能会

780
00:26:59,306 --> 00:27:01,056
一些 UI 测试可能会

781
00:27:01,056 --> 00:27:03,626
更像单元测试

782
00:27:03,696 --> 00:27:04,936
而一个单元测试也可以

783
00:27:04,936 --> 00:27:07,136
和不同代码模块进行互动

784
00:27:07,136 --> 00:27:08,886
并不总是和单一独立的模块互动

785
00:27:09,986 --> 00:27:10,916
只能说这个金字塔结构

786
00:27:10,916 --> 00:27:11,746
是最相近与真实情况的

787
00:27:11,746 --> 00:27:15,816
当然 它不可能是一成不变完全准确的

788
00:27:15,906 --> 00:27:16,896
审视这两种

789
00:27:16,896 --> 00:27:18,146
不同测试的时候

790
00:27:18,146 --> 00:27:19,036
我们需要考虑

791
00:27:19,036 --> 00:27:20,000
它们各自的优势

792
00:27:21,386 --> 00:27:23,326
单元测试很适合被用于测试

793
00:27:23,326 --> 00:27:25,136
一小部分代码

794
00:27:25,136 --> 00:27:26,846
而这部分代码可能在

795
00:27:26,846 --> 00:27:28,026
无法访问我们 app 全部源码的情况下很难接触到

796
00:27:28,546 --> 00:27:30,896
另一方面 UI 测试

797
00:27:30,896 --> 00:27:32,196
则在测试一大块代码

798
00:27:32,196 --> 00:27:34,106
同时运行的状况时

799
00:27:34,106 --> 00:27:34,526
表现出众

800
00:27:35,686 --> 00:27:36,956
当然了 我们还是要

801
00:27:36,956 --> 00:27:38,406
时刻记住

802
00:27:38,406 --> 00:27:39,716
单元测试能够访问到我们 app 的所有资源

803
00:27:39,716 --> 00:27:42,686
而 UI 测试则不可以

804
00:27:45,036 --> 00:27:46,826
现在把重点放在 UI 测试上

805
00:27:47,056 --> 00:27:48,096
我们来看看

806
00:27:48,096 --> 00:27:49,306
大家能够为提升自己测试代码质量

807
00:27:49,306 --> 00:27:50,026
采取哪些操作

808
00:27:51,066 --> 00:27:52,006
采用我接下来建议的

809
00:27:52,006 --> 00:27:54,236
一些变更

810
00:27:54,236 --> 00:27:56,026
我们能够轻松地创建

811
00:27:56,246 --> 00:27:57,766
可以随着我们 app 代码扩展的

812
00:27:57,876 --> 00:27:57,976
测试

813
00:28:01,046 --> 00:28:03,356
我们讲如下几个方面

814
00:28:03,356 --> 00:28:06,196
抽象出 UI element queries

815
00:28:06,246 --> 00:28:07,686
在 utility functions 中创建 objects

816
00:28:07,716 --> 00:28:08,736
这个可以放在函数库中

817
00:28:08,736 --> 00:28:11,916
以后经常使用

818
00:28:12,126 --> 00:28:13,586
以及启用快捷键

819
00:28:17,326 --> 00:28:18,116
首先 我们来看看

820
00:28:18,116 --> 00:28:19,606
抽象出 UI element queries 这个方面

821
00:28:20,976 --> 00:28:22,116
比如说我有一个 app

822
00:28:22,246 --> 00:28:23,186
在它的 view controller 中

823
00:28:23,186 --> 00:28:23,696
有一些按钮

824
00:28:24,496 --> 00:28:25,926
每一个按钮

825
00:28:25,926 --> 00:28:27,086
都处在相同的视图层级

826
00:28:27,086 --> 00:28:29,306
唯一的区别

827
00:28:29,406 --> 00:28:31,736
就是每个按钮的名称不同

828
00:28:31,896 --> 00:28:32,836
与其把这个 query 写 7 次

829
00:28:32,836 --> 00:28:34,706
不如把它们一起放在

830
00:28:34,706 --> 00:28:35,416
一个 method 中

831
00:28:39,116 --> 00:28:40,746
现在我们就能够用

832
00:28:40,746 --> 00:28:42,416
刚刚创建好的新 method 来

833
00:28:42,416 --> 00:28:43,066
修改每一个 query 了

834
00:28:43,676 --> 00:28:45,556
但是

835
00:28:45,556 --> 00:28:45,876
我还想要更进一步

836
00:28:49,366 --> 00:28:50,656
既然每个 method 调用的对象

837
00:28:50,766 --> 00:28:53,026
除去名字不同外 其它都一样

838
00:28:53,026 --> 00:28:54,326
我们就把那些名字放在一个数组中

839
00:28:54,326 --> 00:28:56,486
然后对其进行循环即可

840
00:28:56,696 --> 00:28:57,646
这个方法有利于

841
00:28:57,646 --> 00:28:59,116
提高该代码的可维护性

842
00:28:59,616 --> 00:29:00,756
如果我今后要添加

843
00:28:59,616 --> 00:29:00,756
如果我今后要添加

844
00:29:00,806 --> 00:29:02,926
一个新按钮的话

845
00:29:02,926 --> 00:29:03,756
我就不需要再添加一行新代码了

846
00:29:03,886 --> 00:29:04,996
我只需要向数组中

847
00:29:04,996 --> 00:29:09,206
多添加一个按钮的名字就可以了

848
00:29:09,376 --> 00:29:11,086
由 UI 测试的性质决定

849
00:29:11,726 --> 00:29:14,116
我们会使用很多这样的

850
00:29:14,116 --> 00:29:14,576
queries

851
00:29:14,576 --> 00:29:16,926
如果你要多次

852
00:29:16,926 --> 00:29:18,946
使用同一个 query

853
00:29:18,946 --> 00:29:19,776
就最好将其储存起来作为一个 variable

854
00:29:20,076 --> 00:29:21,666
即使只是一个 query 的一部分

855
00:29:21,816 --> 00:29:26,126
也把它储存起来

856
00:29:26,236 --> 00:29:27,826
同样的 如果你的 queries

857
00:29:27,826 --> 00:29:29,386
都比较相似

858
00:29:29,386 --> 00:29:30,686
则可以考虑围绕着 query

859
00:29:30,686 --> 00:29:31,316
创建一个辅助方法(helper method)

860
00:29:32,526 --> 00:29:34,056
代码就看起来整洁很多了

861
00:29:34,056 --> 00:29:35,566
也会变得更加易读

862
00:29:36,416 --> 00:29:38,246
就拓展我们的测试套件的角度说

863
00:29:38,246 --> 00:29:39,866
使用更短的代码行

864
00:29:39,966 --> 00:29:42,356
更短的测试代码行

865
00:29:42,356 --> 00:29:43,476
及细心命名的辅助方法

866
00:29:43,476 --> 00:29:44,996
可以在需要的时候

867
00:29:45,146 --> 00:29:46,576
更快速更简便地

868
00:29:46,576 --> 00:29:51,046
施行新的测试

869
00:29:51,236 --> 00:29:52,346
这就是如何抽象出 UI element queries

870
00:29:52,346 --> 00:29:53,396
这一部分的内容

871
00:29:54,166 --> 00:29:55,286
现在我们继续下一个话题

872
00:29:55,286 --> 00:29:56,646
在utility functions 中创建 objects

873
00:29:56,996 --> 00:29:59,946
我手头在做一款游戏

874
00:29:59,946 --> 00:30:01,916
对于每一个测试

875
00:29:59,946 --> 00:30:01,916
对于每一个测试

876
00:30:01,916 --> 00:30:02,976
我都想要变更一些设置

877
00:30:04,326 --> 00:30:06,506
我们现在看到的这个例子

878
00:30:06,506 --> 00:30:07,176
就不是一个很好的具有扩展性的代码

879
00:30:08,166 --> 00:30:09,296
因为我最近

880
00:30:09,296 --> 00:30:10,376
一直都在和这个 app 打交道

881
00:30:10,376 --> 00:30:11,686
我自然很熟悉

882
00:30:11,686 --> 00:30:12,076
这个代码的里里外外

883
00:30:13,006 --> 00:30:14,296
我清楚的知道

884
00:30:14,296 --> 00:30:14,746
所有正在发生的事情

885
00:30:15,746 --> 00:30:17,866
但是 如果在一段时间后

886
00:30:17,866 --> 00:30:19,106
比如几个星期后

887
00:30:19,106 --> 00:30:21,546
我再回头来看这个代码

888
00:30:21,546 --> 00:30:23,126
或者另一个不熟悉我的代码的人

889
00:30:23,126 --> 00:30:24,796
不得不坐下来读我写的这些代码的话

890
00:30:25,026 --> 00:30:26,406
这些代码

891
00:30:26,486 --> 00:30:27,000
就不一定能被很简单地读懂了

892
00:30:28,336 --> 00:30:30,146
首先我需要看出

893
00:30:30,376 --> 00:30:32,886
我有一个 Settings 页面

894
00:30:32,886 --> 00:30:35,156
我需要能够进入并离开这个页面

895
00:30:35,156 --> 00:30:36,636
然后我需要看出

896
00:30:36,636 --> 00:30:38,446
在这两行之间

897
00:30:38,446 --> 00:30:39,796
我有一个 difficulty 页

898
00:30:40,066 --> 00:30:42,796
设置 difficulty

899
00:30:42,796 --> 00:30:43,666
然后还有 sound 页

900
00:30:43,666 --> 00:30:44,726
设置 sound

901
00:30:45,946 --> 00:30:47,176
时间一旦过长

902
00:30:47,176 --> 00:30:49,066
我就可能会忘掉

903
00:30:49,066 --> 00:30:50,486
自己为什么会在底部

904
00:30:50,486 --> 00:30:50,876
有两个 back tabs

905
00:30:50,876 --> 00:30:53,326
我必须使用测试

906
00:30:53,366 --> 00:30:54,616
来看看这个

907
00:30:54,616 --> 00:30:55,026
代码到底会如何运行

908
00:30:56,666 --> 00:30:58,366
如果因为实际 UI

909
00:30:58,366 --> 00:30:59,376
发生的变更

910
00:30:59,376 --> 00:31:01,146
而导致测试不成功

911
00:30:59,376 --> 00:31:01,146
而导致测试不成功

912
00:31:01,146 --> 00:31:02,626
我就无法进行测试

913
00:31:02,626 --> 00:31:03,686
也就无法看到我想要的结果

914
00:31:04,506 --> 00:31:05,876
这样 我基本上对当初

915
00:31:05,876 --> 00:31:07,316
为什么这样写这些代码这个问题无能为力了

916
00:31:08,516 --> 00:31:09,926
为了解决这个问题

917
00:31:09,926 --> 00:31:11,306
我们试一试将一些 logic 抽象到

918
00:31:11,306 --> 00:31:12,226
辅助方法里面

919
00:31:12,916 --> 00:31:16,666
我们可以创建一个 method

920
00:31:16,696 --> 00:31:17,396
来设置 difficulty

921
00:31:17,396 --> 00:31:19,676
同样的

922
00:31:19,676 --> 00:31:20,586
我们也可以创建一个 method

923
00:31:20,676 --> 00:31:21,066
来设置 sound

924
00:31:21,636 --> 00:31:23,056
不过 我们能够做的更好吗

925
00:31:24,046 --> 00:31:26,856
当然了

926
00:31:26,856 --> 00:31:27,946
我们可以不传入 stream typed arguments

927
00:31:28,006 --> 00:31:29,826
转而使用 enums

928
00:31:30,996 --> 00:31:32,406
这样 Xcode 就能够

929
00:31:32,406 --> 00:31:34,036
帮助我们在进行编译前确认

930
00:31:34,036 --> 00:31:35,876
正在传入的 arguments

931
00:31:35,876 --> 00:31:36,916
是否是有效的

932
00:31:40,276 --> 00:31:41,456
现在看一下我们先前的代码

933
00:31:41,456 --> 00:31:43,056
如果我们用新的辅助方法

934
00:31:43,056 --> 00:31:44,126
代替一些代码

935
00:31:44,126 --> 00:31:47,386
我们就能够减少

936
00:31:47,386 --> 00:31:47,826
原来写的一些东西

937
00:31:47,826 --> 00:31:48,966
这样已经看起来

938
00:31:48,966 --> 00:31:49,796
好多了

939
00:31:49,796 --> 00:31:53,116
那我们可以对最初的跳入跳出的

940
00:31:53,116 --> 00:31:54,386
Settings 页面做些什么呢

941
00:31:55,016 --> 00:31:56,726
我们能够对它进行改善吗

942
00:31:57,086 --> 00:31:57,866
我觉得是可以的

943
00:31:58,836 --> 00:32:00,556
让我们创建一个 GameApp 类

944
00:31:58,836 --> 00:32:00,556
让我们创建一个 GameApp 类

945
00:32:00,556 --> 00:32:03,566
在这个类中

946
00:32:03,566 --> 00:32:05,276
我会加入之前为设定 difficulty 和sound

947
00:32:05,276 --> 00:32:07,786
界定好的 enums

948
00:32:07,826 --> 00:32:09,066
我也会加入

949
00:32:09,066 --> 00:32:10,826
之前用来配置那些设置的

950
00:32:10,826 --> 00:32:12,000
辅助方法

951
00:32:13,396 --> 00:32:14,516
我们创建另一个 method

952
00:32:14,516 --> 00:32:16,286
叫做 configureSettings

953
00:32:16,286 --> 00:32:17,326
它将之前的两个设置作为 inputs

954
00:32:17,326 --> 00:32:20,496
然后我们将之前的

955
00:32:20,546 --> 00:32:22,336
setup logic 移植进

956
00:32:22,336 --> 00:32:23,206
configure method 里面

957
00:32:23,716 --> 00:32:26,966
回到我们先前的位置

958
00:32:27,206 --> 00:32:28,286
因为我们已经创建了

959
00:32:28,286 --> 00:32:30,276
这 个GameApp 类

960
00:32:30,276 --> 00:32:32,266
我们就可以拿走原来所写的全部代码了

961
00:32:32,266 --> 00:32:33,866
然后只需要用一个调用即可

962
00:32:33,866 --> 00:32:34,626
也就是 configure method

963
00:32:35,476 --> 00:32:36,956
相较于之前的版本

964
00:32:36,956 --> 00:32:38,286
这个对于我来说可读性要大多了

965
00:32:39,276 --> 00:32:41,416
现在 如果我需要写更多的测试

966
00:32:41,416 --> 00:32:42,856
来配置设置

967
00:32:43,206 --> 00:32:44,156
我只需要调用

968
00:32:44,156 --> 00:32:44,660
configure method 就可以了

969
00:32:46,166 --> 00:32:48,276
如果我需要

970
00:32:48,276 --> 00:32:49,386
或者决定在 app 中

971
00:32:49,386 --> 00:32:50,836
加入更多的设置

972
00:32:50,836 --> 00:32:51,826
我只需要更新我们的

973
00:32:51,826 --> 00:32:53,026
configure settings method

974
00:32:53,026 --> 00:32:53,946
就能够处理这些新添加的

975
00:32:53,946 --> 00:32:54,306
设置了

976
00:32:54,996 --> 00:32:58,856
从这个例子我们可以看出

977
00:32:58,856 --> 00:33:00,516
要扩展你的测试

978
00:32:58,856 --> 00:33:00,516
要扩展你的测试

979
00:33:00,516 --> 00:33:02,096
最重要的一点就是

980
00:33:02,096 --> 00:33:03,926
创建你能够随后放入

981
00:33:04,056 --> 00:33:05,726
library suite

982
00:33:05,726 --> 00:33:06,006
的 abstraction

983
00:33:06,606 --> 00:33:07,796
这样做

984
00:33:07,796 --> 00:33:09,476
我们其实是在封装通用工作流程

985
00:33:09,806 --> 00:33:10,986
以将其适用在

986
00:33:10,986 --> 00:33:12,266
多个测试上

987
00:33:13,816 --> 00:33:15,296
这也意味着

988
00:33:15,296 --> 00:33:16,676
我们能够将测试代码

989
00:33:16,746 --> 00:33:17,716
分享到不同的平台上

990
00:33:18,256 --> 00:33:22,306
当然了 分享代码

991
00:33:22,306 --> 00:33:23,906
能够便于我们的维护

992
00:33:24,926 --> 00:33:26,006
如果出现了和抽象出的工作流程

993
00:33:26,006 --> 00:33:27,876
相关的改动

994
00:33:27,876 --> 00:33:29,146
我们只需要在一个地方更新代码即可

995
00:33:29,146 --> 00:33:32,076
而不需要在

996
00:33:34,756 --> 00:33:35,196
多处都进行操作

997
00:33:35,246 --> 00:33:36,176
我想要提一下另外一个改进

998
00:33:36,176 --> 00:33:37,646
在我们的 configure method 中

999
00:33:37,646 --> 00:33:39,756
因为今年 Xcode 进行了改进

1000
00:33:39,916 --> 00:33:42,566
我们可以 

1001
00:33:42,566 --> 00:33:45,036
在自己的代码中加入一个

1002
00:33:45,666 --> 00:33:46,706
XCTContent.runActivity

1003
00:33:46,906 --> 00:33:48,086
当我们运行测试时

1004
00:33:48,086 --> 00:33:49,636
我们可以用 runActivity 来

1005
00:33:49,636 --> 00:33:51,006
嵌套我们的 logging

1006
00:33:51,006 --> 00:33:52,426
而不是得到一个

1007
00:33:52,426 --> 00:33:55,056
包含所有顶层行为

1008
00:33:55,056 --> 00:33:56,076
的 log

1009
00:33:56,626 --> 00:33:59,406
这个能够帮助我们整理 logging

1010
00:33:59,406 --> 00:34:01,686
可以让内容

1011
00:33:59,406 --> 00:34:01,686
可以让内容

1012
00:34:02,556 --> 00:34:02,726
看起来更加整洁一些

1013
00:34:02,856 --> 00:34:03,986
有关测试 activity 特性的

1014
00:34:03,986 --> 00:34:05,926
更多信息

1015
00:34:05,926 --> 00:34:07,516
请查看我们先前的演讲

1016
00:34:07,516 --> 00:34:11,005
What’s New in Testing

1017
00:34:11,545 --> 00:34:13,116
好的 现在我们继续下一个话题

1018
00:34:13,116 --> 00:34:14,996
如何对 macOS UI 测试

1019
00:34:14,996 --> 00:34:15,330
使用快捷键

1020
00:34:17,886 --> 00:34:19,166
比如说我这里有一个 app

1021
00:34:19,166 --> 00:34:20,606
用户能够为他们的 text

1022
00:34:20,606 --> 00:34:21,876
挑选颜色

1023
00:34:21,876 --> 00:34:23,275
使用的是标准 macOS color picker

1024
00:34:23,886 --> 00:34:25,335
我现在要写一个测试

1025
00:34:25,335 --> 00:34:26,646
来验证颜色都设置正确了

1026
00:34:27,196 --> 00:34:30,186
最典型的方式是在 app 中

1027
00:34:30,186 --> 00:34:32,056
通过打开 Format menu

1028
00:34:32,056 --> 00:34:34,056
然后导航到 Font sub-menu

1029
00:34:34,056 --> 00:34:35,716
最后选择

1030
00:34:36,085 --> 00:34:37,315
Show Colors

1031
00:34:37,315 --> 00:34:37,926
来打开 color picker

1032
00:34:37,985 --> 00:34:40,795
我可以在 UI 测试中这样写

1033
00:34:40,795 --> 00:34:41,500
就像这样

1034
00:34:43,976 --> 00:34:45,616
但是有一种更快捷的方式

1035
00:34:45,616 --> 00:34:47,016
这个方式也能在我的测试[听不清]增多时

1036
00:34:47,016 --> 00:34:47,846
更好地扩展

1037
00:34:49,166 --> 00:34:50,815
注意这个 Show Colors menu 条目

1038
00:34:50,815 --> 00:34:52,576
有一个与其相关联的

1039
00:34:52,576 --> 00:34:53,235
键盘快捷方式了吧

1040
00:34:53,846 --> 00:34:57,456
与其使用多行代码

1041
00:34:57,456 --> 00:34:58,516
来启用 color picker

1042
00:34:58,516 --> 00:35:01,166
我们实际可以借助这个快捷键

1043
00:34:58,516 --> 00:35:01,166
我们实际可以借助这个快捷键

1044
00:35:01,166 --> 00:35:02,666
只用一行代码就达到目的

1045
00:35:03,236 --> 00:35:06,436
出于可读性的考虑

1046
00:35:06,616 --> 00:35:07,806
我也可能会使用一个 wrapper

1047
00:35:07,806 --> 00:35:08,576
来帮我调用

1048
00:35:09,646 --> 00:35:11,266
这样 在我的测试中

1049
00:35:11,266 --> 00:35:13,056
不仅能够减少需要维护的代码数量

1050
00:35:13,056 --> 00:35:14,306
而且实际运行的代码也变少了

1051
00:35:14,306 --> 00:35:15,846
那些和我想要进行的测试

1052
00:35:15,846 --> 00:35:17,016
并不直接相关的代码

1053
00:35:17,046 --> 00:35:18,000
都被削减掉了

1054
00:35:20,576 --> 00:35:22,326
在之前测试 method 例子中

1055
00:35:22,326 --> 00:35:23,446
我需要通过 menu

1056
00:35:23,446 --> 00:35:25,006
来最后显示出

1057
00:35:25,006 --> 00:35:25,316
color picker

1058
00:35:25,826 --> 00:35:29,136
用这个新的 wrapper method

1059
00:35:29,136 --> 00:35:30,406
我们就去掉了这些多余的代码行

1060
00:35:30,406 --> 00:35:31,856
将它精简到了一个 method

1061
00:35:32,586 --> 00:35:33,906
这样不仅使我的测试

1062
00:35:34,036 --> 00:35:35,426
运行得更快

1063
00:35:35,426 --> 00:35:36,876
而且也提高了我的代码的可读性

1064
00:35:39,206 --> 00:35:40,886
我们刚才已经看到了

1065
00:35:40,886 --> 00:35:42,066
如果你正在为一个 macOS 应用

1066
00:35:42,066 --> 00:35:44,076
写 UI 测试

1067
00:35:44,076 --> 00:35:45,416
你可以直接提供一个键盘快捷键

1068
00:35:45,416 --> 00:35:46,416
而不再需要通过 menu bar 来实现

1069
00:35:47,056 --> 00:35:49,016
我还需要

1070
00:35:49,016 --> 00:35:50,736
至少一个测试

1071
00:35:50,736 --> 00:35:52,046
来保证通过 menu bar 启用的 color picker

1072
00:35:52,046 --> 00:35:53,686
能够正常运行

1073
00:35:54,076 --> 00:35:56,246
但是这不需要

1074
00:35:56,246 --> 00:35:57,826
在每次包含 color picker

1075
00:35:57,826 --> 00:35:58,786
的测试上

1076
00:35:58,786 --> 00:35:59,126
都重复运行

1077
00:36:02,916 --> 00:36:04,956
使用键盘快捷方式

1078
00:36:04,956 --> 00:36:06,876
我们可以通过

1079
00:36:06,876 --> 00:36:09,196
跳过一些 UI 中的步骤

1080
00:36:09,196 --> 00:36:10,496
来使得测试代码

1081
00:36:10,496 --> 00:36:12,856
变得更加紧凑

1082
00:36:12,856 --> 00:36:14,206
有时可以将多行代码缩减到一行

1083
00:36:14,546 --> 00:36:15,746
这样也有助于提高代码可读性

1084
00:36:18,636 --> 00:36:20,346
最后 我想要对各位强调一点

1085
00:36:20,346 --> 00:36:21,966
想要写出好的测试

1086
00:36:22,096 --> 00:36:23,496
其实就是要写出好的代码

1087
00:36:24,126 --> 00:36:25,886
大家很容易把测试

1088
00:36:25,886 --> 00:36:26,436
看成是马后炮 有些无关紧要

1089
00:36:27,446 --> 00:36:29,366
一般情况下

1090
00:36:29,366 --> 00:36:30,466
我们都十分看重 app 的制作 想将其做到最好

1091
00:36:30,466 --> 00:36:32,346
将所有的时间都投入到

1092
00:36:32,346 --> 00:36:33,506
写出优美的

1093
00:36:33,506 --> 00:36:35,216
符合好的设计准则的

1094
00:36:35,216 --> 00:36:36,696
app 代码中去

1095
00:36:36,966 --> 00:36:38,246
对于编写测试代码

1096
00:36:38,496 --> 00:36:40,336
我们也需要

1097
00:36:40,396 --> 00:36:40,686
提高一点标准

1098
00:36:40,686 --> 00:36:41,746
有可能你在最后一刻

1099
00:36:41,746 --> 00:36:43,196
才匆忙挤出时间来写测试代码

1100
00:36:43,196 --> 00:36:44,546
只是为了完成一项任务

1101
00:36:44,606 --> 00:36:46,896
但是我们不应该

1102
00:36:47,186 --> 00:36:47,330
让这样的情况出现

1103
00:36:48,926 --> 00:36:50,476
如果不注意

1104
00:36:50,476 --> 00:36:52,326
测试代码的细节

1105
00:36:52,326 --> 00:36:53,896
它就无法像我们的 app 代码一样

1106
00:36:53,896 --> 00:36:54,000
扩展下去

1107
00:36:56,416 --> 00:36:58,546
最后

1108
00:36:58,546 --> 00:37:00,266
测试代码虽然不是 shipping

1109
00:36:58,546 --> 00:37:00,266
测试代码虽然不是 shipping

1110
00:37:00,266 --> 00:37:00,736
但仍然至关重要

1111
00:37:02,156 --> 00:37:03,496
也请注意

1112
00:37:03,496 --> 00:37:04,936
测试套件理应能够帮助你的 app

1113
00:37:04,936 --> 00:37:06,686
不断改进 而不是阻碍改变

1114
00:37:07,156 --> 00:37:08,396
如果测试代码质量不高

1115
00:37:08,396 --> 00:37:10,006
每次你要对 app 做改动时

1116
00:37:10,006 --> 00:37:11,056
都需要更新测试

1117
00:37:11,056 --> 00:37:12,276
它就变成了你的负担

1118
00:37:13,156 --> 00:37:14,626
要有意识地

1119
00:37:14,626 --> 00:37:16,416
提高测试代码的质量

1120
00:37:16,816 --> 00:37:18,736
这样我们扩展的能力

1121
00:37:18,736 --> 00:37:19,856
就不会因为设计不良的测试

1122
00:37:19,856 --> 00:37:20,106
而受到阻碍

1123
00:37:20,836 --> 00:37:24,156
当然了

1124
00:37:24,156 --> 00:37:26,056
编写 app 代码的原则

1125
00:37:26,056 --> 00:37:27,086
也同样适用于编写测试代码

1126
00:37:27,686 --> 00:37:28,826
测试代码和 app 代码

1127
00:37:28,826 --> 00:37:29,536
应该被平等看待

1128
00:37:30,106 --> 00:37:33,246
这里我可以给大家出个主意

1129
00:37:33,286 --> 00:37:34,706
我们需要对测试代码

1130
00:37:34,706 --> 00:37:36,646
进行代码审查

1131
00:37:36,886 --> 00:37:37,986
而不仅仅是将测试代码用于代码审查

1132
00:37:38,596 --> 00:37:39,446
要给测试代码

1133
00:37:39,446 --> 00:37:40,976
进行单独的代码审查

1134
00:37:40,976 --> 00:37:42,006
保证是由别人来检查

1135
00:37:42,006 --> 00:37:42,656
你的工作

1136
00:37:44,946 --> 00:37:46,256
这也是改进测试本身

1137
00:37:46,256 --> 00:37:47,566
的一个机会

1138
00:37:47,566 --> 00:37:51,506
好的 现在我给大家留下

1139
00:37:51,506 --> 00:37:51,726
一个思路

1140
00:37:52,316 --> 00:37:54,016
app 代码以及

1141
00:37:54,016 --> 00:37:55,516
验证它的测试

1142
00:37:55,516 --> 00:37:56,016
其实是不可分割的两部分

1143
00:37:56,726 --> 00:37:57,896
当你更新 app 代码时

1144
00:37:57,966 --> 00:37:58,976
你也需要

1145
00:37:59,196 --> 00:37:59,716
更新测试代码

1146
00:37:59,716 --> 00:38:04,026
我们需要将 app 代码

1147
00:37:59,716 --> 00:38:04,026
我们需要将 app 代码

1148
00:38:04,026 --> 00:38:05,966
和测试代码视为同一件事的两部分

1149
00:38:05,966 --> 00:38:07,526
这个事情就是我们的代码

1150
00:38:08,476 --> 00:38:09,366
将我们的代码变得更

1151
00:38:09,366 --> 00:38:10,956
具有可测试性 正如 Brian 先前和大家讨论的

1152
00:38:10,956 --> 00:38:12,546
用对待 app 代码同样认真的态度

1153
00:38:12,546 --> 00:38:13,816
对待测试代码

1154
00:38:13,816 --> 00:38:15,286
你就能够提升

1155
00:38:15,286 --> 00:38:16,306
整个 app 的质量了

1156
00:38:17,196 --> 00:38:18,236
我们理应对

1157
00:38:18,236 --> 00:38:20,166
两部分都感到自豪

1158
00:38:20,166 --> 00:38:21,496
并给予它们应得的

1159
00:38:21,496 --> 00:38:21,926
关注

1160
00:38:25,826 --> 00:38:26,996
有关这次讲座

1161
00:38:26,996 --> 00:38:27,976
更多的信息和资源

1162
00:38:27,976 --> 00:38:29,286
大家可以通过屏幕上的链接

1163
00:38:29,316 --> 00:38:30,226
获得

1164
00:38:30,226 --> 00:38:33,296
这里有几个相关的讲座

1165
00:38:33,356 --> 00:38:34,596
有一个是昨天的

1166
00:38:34,596 --> 00:38:35,826
还有一些是前几年

1167
00:38:35,826 --> 00:38:36,196
的讲座

1168
00:38:36,226 --> 00:38:37,616
大家可以上网查询

1169
00:38:37,706 --> 00:38:40,156
或者通过 WWDC app 查看

1170
00:38:40,446 --> 00:38:41,476
好了 谢谢大家的

1171
00:38:41,476 --> 00:38:42,506
认真聆听

1172
00:38:42,506 --> 00:38:43,336
我祝愿各位在剩下的时间里 

1173
00:38:43,336 --> 00:38:43,676
与会愉快
