1
00:00:07,516 --> 00:00:16,500
[欢呼声]

2
00:00:23,516 --> 00:00:27,136
[掌声]

3
00:00:27,636 --> 00:00:28,966
&gt;&gt; 大家下午好

4
00:00:28,966 --> 00:00:30,486
欢迎来到

5
00:00:30,486 --> 00:00:31,826
iOS 现代用户交互的展示

6
00:00:32,276 --> 00:00:33,536
我叫 Dominik Wagner

7
00:00:33,536 --> 00:00:35,156
我是名工程师

8
00:00:35,156 --> 00:00:37,646
来自 UIkit 框架团队

9
00:00:37,646 --> 00:00:39,616
我今天想跟大家说说

10
00:00:39,616 --> 00:00:41,136
如何熟练操作

11
00:00:41,226 --> 00:00:41,696
手势识别系统

12
00:00:41,696 --> 00:00:42,796
稍后我的同事

13
00:00:42,796 --> 00:00:44,316
Glen 和 Michael

14
00:00:44,316 --> 00:00:44,916
也会上台进行展示

15
00:00:45,286 --> 00:00:46,806
我们要讲的

16
00:00:46,806 --> 00:00:47,126
到底是什么呢

17
00:00:47,126 --> 00:00:48,406
我们讲的是

18
00:00:48,596 --> 00:00:49,366
Multi-Touch

19
00:00:49,366 --> 00:00:51,116
这次只讲

20
00:00:51,116 --> 00:00:51,586
触摸界面

21
00:00:51,586 --> 00:00:52,616
我们有许多很棒的

22
00:00:52,616 --> 00:00:54,366
其他交互方式

23
00:00:54,516 --> 00:00:56,136
但 Multi-Touch

24
00:00:56,166 --> 00:00:56,806
是今天展示的主题

25
00:00:57,336 --> 00:00:59,056
我会详细地和你们分享

26
00:00:59,056 --> 00:01:01,246
UI 手势识别系统的方方面面

27
00:00:59,056 --> 00:01:01,246
UI 手势识别系统的方方面面

28
00:01:01,246 --> 00:01:02,966
告诉你们

29
00:01:02,966 --> 00:01:04,806
如何使用

30
00:01:04,806 --> 00:01:06,286
如何根据喜好进行自定义

31
00:01:07,206 --> 00:01:08,626
之后 Glen 会上台和你们分享

32
00:01:08,626 --> 00:01:10,346
iOS 11 中

33
00:01:10,346 --> 00:01:11,916
为系统手势交互而产生的

34
00:01:11,986 --> 00:01:12,796
New API 的使用

35
00:01:13,266 --> 00:01:14,816
最后 Mike 会上台

36
00:01:15,256 --> 00:01:17,016
和你们分享

37
00:01:17,016 --> 00:01:18,526
如何玩转

38
00:01:18,526 --> 00:01:19,296
拖放新功能

39
00:01:19,996 --> 00:01:22,856
这次的展示更适合

40
00:01:22,856 --> 00:01:26,076
已经对 UITouch

41
00:01:26,076 --> 00:01:27,256
有所了解的观众

42
00:01:27,696 --> 00:01:29,366
但如果你是新手

43
00:01:29,446 --> 00:01:31,376
我们就先一起

44
00:01:31,376 --> 00:01:33,056
过一遍基础部分

45
00:01:33,466 --> 00:01:34,756
我们有 UITouch

46
00:01:35,136 --> 00:01:37,276
UITouch 代表

47
00:01:37,596 --> 00:01:39,896
手指触摸屏幕

48
00:01:40,176 --> 00:01:43,176
用户交互的状态会从 Begin 开始

49
00:01:43,176 --> 00:01:45,256
以 Cancel 或 Ended 的状态结束

50
00:01:45,256 --> 00:01:47,016
它代表一次

51
00:01:47,076 --> 00:01:47,626
与屏幕的交互行为

52
00:01:48,046 --> 00:01:49,356
另外我们有

53
00:01:49,446 --> 00:01:50,966
UIGestureRecognizer

54
00:01:50,966 --> 00:01:52,116
这是个更强大的抽象类

55
00:01:52,726 --> 00:01:54,266
UIGestureRecognizer

56
00:01:54,266 --> 00:01:56,086
能配置对象和动作

57
00:01:56,086 --> 00:01:57,826
放上 UI 视图

58
00:01:59,006 --> 00:02:00,326
我们有可以识别各种交互手势的

59
00:01:59,006 --> 00:02:00,326
我们有可以识别各种交互手势的

60
00:02:00,326 --> 00:02:01,996
手势识别器

61
00:02:01,996 --> 00:02:04,246
轻点 拖移

62
00:02:04,246 --> 00:02:04,706
双指开合

63
00:02:05,616 --> 00:02:06,846
我们还有

64
00:02:06,846 --> 00:02:08,286
协调这些功能的

65
00:02:08,286 --> 00:02:09,806
手势识别系统

66
00:02:10,126 --> 00:02:11,596
我接下来

67
00:02:11,646 --> 00:02:12,506
会重点讨论它

68
00:02:13,226 --> 00:02:14,776
我会通过这个简单的例子

69
00:02:14,866 --> 00:02:15,856
进行说明

70
00:02:16,606 --> 00:02:18,366
跟 AssistiveTouch 一样

71
00:02:18,776 --> 00:02:20,506
这个窗口部件

72
00:02:20,506 --> 00:02:23,406
你可以点

73
00:02:23,406 --> 00:02:23,976
也可以拖动

74
00:02:24,656 --> 00:02:26,396
甚至你可以在上面进行

75
00:02:26,396 --> 00:02:27,696
常规的基于响应器的触摸处理

76
00:02:27,696 --> 00:02:29,586
来处理一些

77
00:02:29,586 --> 00:02:30,196
触摸

78
00:02:30,566 --> 00:02:32,206
这个例子很简单

79
00:02:32,206 --> 00:02:33,176
容易实现

80
00:02:33,176 --> 00:02:34,996
你们不用只想着

81
00:02:34,996 --> 00:02:36,986
这个例子

82
00:02:36,986 --> 00:02:38,376
你们可以想想

83
00:02:38,376 --> 00:02:39,156
你们的手势设置

84
00:02:39,596 --> 00:02:41,446
我想说

85
00:02:41,446 --> 00:02:43,326
开发触摸事件的秘诀

86
00:02:43,326 --> 00:02:44,806
在于要适用于你的设置

87
00:02:44,806 --> 00:02:46,166
然后再想如何优化你的设置

88
00:02:46,536 --> 00:02:47,916
那我们来看看

89
00:02:47,916 --> 00:02:48,296
这个例子

90
00:02:48,296 --> 00:02:50,196
这里有一个视图

91
00:02:50,426 --> 00:02:51,826
然后还有能在视图上

92
00:02:51,826 --> 00:02:53,026
进行的基于响应器的触摸处理

93
00:02:53,386 --> 00:02:55,706
然后我们从这个

94
00:02:55,706 --> 00:02:56,656
轻点手势识别器开始

95
00:02:57,686 --> 00:03:00,826
当视图上受到触摸时

96
00:02:57,686 --> 00:03:00,826
当视图上受到触摸时

97
00:03:00,826 --> 00:03:02,746
它会即刻随其状态开始

98
00:03:02,746 --> 00:03:03,616
而开始

99
00:03:04,016 --> 00:03:05,686
首先

100
00:03:05,686 --> 00:03:07,536
手势识别系统

101
00:03:07,796 --> 00:03:09,366
会将其分发给

102
00:03:09,366 --> 00:03:10,926
所有与这个触摸相关的

103
00:03:10,986 --> 00:03:11,366
手势识别器

104
00:03:11,756 --> 00:03:13,106
在这里就是

105
00:03:13,106 --> 00:03:14,466
轻点手势识别器

106
00:03:14,966 --> 00:03:16,206
然后轻点手势识别器

107
00:03:16,306 --> 00:03:18,536
会接管这个触摸

108
00:03:18,536 --> 00:03:19,986
并尽量让它保持在

109
00:03:20,016 --> 00:03:20,746
初始状态

110
00:03:21,406 --> 00:03:23,576
触摸被接收后

111
00:03:23,576 --> 00:03:25,086
会被标记为

112
00:03:25,306 --> 00:03:26,886
属于此交互

113
00:03:27,586 --> 00:03:29,056
手势识别器开始运行后

114
00:03:29,376 --> 00:03:31,656
我们继续

115
00:03:31,656 --> 00:03:33,126
将触摸的状态

116
00:03:33,126 --> 00:03:34,376
分发给

117
00:03:34,376 --> 00:03:34,636
触摸事件处理方法

118
00:03:35,586 --> 00:03:37,836
触摸的手指抬起来后

119
00:03:38,046 --> 00:03:39,616
触摸状态结束

120
00:03:39,616 --> 00:03:40,856
依然会在第一时间

121
00:03:40,856 --> 00:03:42,356
分发给

122
00:03:42,446 --> 00:03:42,866
手势识别系统

123
00:03:43,066 --> 00:03:45,736
这里的轻点手势识别器

124
00:03:45,736 --> 00:03:47,136
会通过设置状态结束

125
00:03:47,206 --> 00:03:48,766
进行识别

126
00:03:48,766 --> 00:03:49,866
手势识别器

127
00:03:49,866 --> 00:03:52,546
会用这种方式

128
00:03:52,546 --> 00:03:53,106
示意识别

129
00:03:53,196 --> 00:03:54,186
它们会改变它们的状态

130
00:03:54,556 --> 00:03:55,596
接着手势识别系统

131
00:03:55,656 --> 00:03:58,756
会接收到标记的状态

132
00:03:58,756 --> 00:04:00,636
然后给轻点手势识别器

133
00:03:58,756 --> 00:04:00,636
然后给轻点手势识别器

134
00:04:00,736 --> 00:04:02,196
发送

135
00:04:02,196 --> 00:04:02,776
动作指令

136
00:04:05,066 --> 00:04:07,346
在这之后

137
00:04:07,346 --> 00:04:10,066
我们继续向触摸事件处理方法

138
00:04:10,336 --> 00:04:11,706
发送这个触摸事件

139
00:04:11,886 --> 00:04:12,966
Responder 类的这个

140
00:04:13,406 --> 00:04:14,906
你们会发现我们发送的状态

141
00:04:14,906 --> 00:04:16,526
是取消

142
00:04:16,526 --> 00:04:16,956
而不是终止

143
00:04:17,516 --> 00:04:18,766
为什么要这么做呢

144
00:04:19,466 --> 00:04:20,755
这是因为

145
00:04:20,755 --> 00:04:23,136
手势识别器

146
00:04:23,286 --> 00:04:25,336
不喜欢常规的触摸处理方法

147
00:04:25,336 --> 00:04:26,766
这会限制它的功能

148
00:04:26,766 --> 00:04:28,056
在手势识别器上

149
00:04:28,056 --> 00:04:29,306
你可以对三个属性控件

150
00:04:29,306 --> 00:04:31,996
进行设置

151
00:04:31,996 --> 00:04:33,226
前两个分别是 delaysTouchesEnded

152
00:04:33,226 --> 00:04:34,556
和 cancelsTouchesInView

153
00:04:35,076 --> 00:04:36,796
这两个都设置

154
00:04:36,796 --> 00:04:38,286
默认为 true

155
00:04:38,286 --> 00:04:39,176
从而发生了我们刚看到的动作

156
00:04:39,176 --> 00:04:40,866
手势识别器识别之后

157
00:04:40,966 --> 00:04:42,636
触摸分发

158
00:04:42,636 --> 00:04:43,856
要取消

159
00:04:44,446 --> 00:04:45,676
第三个控件是

160
00:04:45,736 --> 00:04:47,016
delaysTouchesBegan

161
00:04:47,016 --> 00:04:48,526
如果对这个控件选了 yes

162
00:04:48,596 --> 00:04:50,186
那么即便手势识别了

163
00:04:50,186 --> 00:04:52,086
常规的基于响应器的触摸处理

164
00:04:52,116 --> 00:04:53,066
都不会看到

165
00:04:53,066 --> 00:04:53,816
触摸事件

166
00:04:54,326 --> 00:04:56,556
所以记住

167
00:04:56,556 --> 00:04:58,116
触摸分发过程中最先反应的

168
00:04:58,116 --> 00:04:59,456
是手势识别系统

169
00:05:00,036 --> 00:05:01,976
这也是为什么

170
00:05:01,976 --> 00:05:03,496
当在执行触摸事件处理方法时

171
00:05:03,496 --> 00:05:05,496
你要继续执行

172
00:05:05,496 --> 00:05:06,986
手势识别器

173
00:05:06,986 --> 00:05:08,176
或是

174
00:05:08,216 --> 00:05:09,496
使用我们的

175
00:05:09,496 --> 00:05:09,886
手势识别系统

176
00:05:10,216 --> 00:05:11,586
只有在有必要的时候

177
00:05:11,586 --> 00:05:12,436
你才执行它们

178
00:05:12,916 --> 00:05:14,946
我们拓展一下我们的例子

179
00:05:15,536 --> 00:05:17,876
再加一个识别器

180
00:05:17,876 --> 00:05:18,856
给我们

181
00:05:18,856 --> 00:05:19,326
增添点趣味

182
00:05:19,596 --> 00:05:21,396
我们增加一个

183
00:05:21,396 --> 00:05:22,956
拖移手势识别器吧

184
00:05:23,116 --> 00:05:24,656
同样触摸发生后

185
00:05:24,656 --> 00:05:26,446
我们会遵从一个触摸顺序

186
00:05:27,276 --> 00:05:29,196
一开始

187
00:05:29,196 --> 00:05:30,476
它会被分发给

188
00:05:30,476 --> 00:05:32,056
所有相关的手势识别器

189
00:05:32,466 --> 00:05:34,216
然后相应的手势识别器

190
00:05:34,216 --> 00:05:36,596
会立即开始运行并被标记

191
00:05:36,726 --> 00:05:38,196
因为系统接收了

192
00:05:38,196 --> 00:05:39,416
属于此交互

193
00:05:39,416 --> 00:05:40,726
触摸事件

194
00:05:41,546 --> 00:05:43,106
然后我们会将这个触摸事件

195
00:05:43,596 --> 00:05:44,636
分发给触摸事件处理方法

196
00:05:44,636 --> 00:05:45,776
它会开始运行

197
00:05:46,606 --> 00:05:48,046
现在我们移动手指

198
00:05:48,046 --> 00:05:51,246
手指移动后

199
00:05:51,246 --> 00:05:53,386
它会被分发给手势识别系统

200
00:05:53,386 --> 00:05:54,856
然后拖移手势识别器

201
00:05:55,466 --> 00:05:57,186
会因为我们移动了手指

202
00:05:57,186 --> 00:05:59,706
对此进行

203
00:05:59,706 --> 00:06:00,216
识别

204
00:05:59,706 --> 00:06:00,216
识别

205
00:06:00,656 --> 00:06:02,216
它会通过将状态改为开启状态

206
00:06:02,246 --> 00:06:03,116
来完成识别

207
00:06:03,946 --> 00:06:05,246
但我们的移动的幅度

208
00:06:05,296 --> 00:06:06,536
不足以让轻点手势识别器

209
00:06:06,536 --> 00:06:07,446
失效

210
00:06:07,446 --> 00:06:08,616
我们没有超过

211
00:06:08,616 --> 00:06:09,486
最大移动范围

212
00:06:09,556 --> 00:06:11,306
所以轻点手势识别器

213
00:06:11,306 --> 00:06:13,706
会保持原本的

214
00:06:13,786 --> 00:06:14,366
状态

215
00:06:15,486 --> 00:06:18,166
然而在这个例子中

216
00:06:18,356 --> 00:06:18,916
它依然会失效

217
00:06:19,146 --> 00:06:20,136
这跟手势识别系统

218
00:06:20,136 --> 00:06:21,876
另一个方面

219
00:06:21,946 --> 00:06:22,336
有关

220
00:06:22,686 --> 00:06:24,106
系统的默认设置中

221
00:06:24,106 --> 00:06:26,066
只有手势识别器

222
00:06:26,066 --> 00:06:27,426
能够识别和成功运行

223
00:06:27,426 --> 00:06:28,976
而且是唯一的

224
00:06:29,426 --> 00:06:30,786
这就是现在的情况

225
00:06:31,356 --> 00:06:34,406
注意开启状态

226
00:06:34,406 --> 00:06:35,386
会被手势识别系统发出

227
00:06:35,386 --> 00:06:38,286
触摸事件处理

228
00:06:38,286 --> 00:06:39,456
会以已经取消的状态

229
00:06:39,556 --> 00:06:41,276
发出

230
00:06:41,276 --> 00:06:42,436
因为拖移手势识别器

231
00:06:42,736 --> 00:06:44,846
取消了视图中的触摸

232
00:06:45,096 --> 00:06:46,916
所以系统会开启

233
00:06:46,916 --> 00:06:48,156
触摸事件处理会取消

234
00:06:48,156 --> 00:06:49,786
这挺有趣的

235
00:06:49,786 --> 00:06:51,736
因为你的手指

236
00:06:51,736 --> 00:06:53,706
还在屏幕上

237
00:06:53,706 --> 00:06:55,706
手势识别器看见了

238
00:06:55,846 --> 00:06:57,156
但基于响应器的触摸处理

239
00:06:57,156 --> 00:06:57,506
看不见

240
00:06:57,806 --> 00:06:59,246
你们可以

241
00:06:59,246 --> 00:06:59,576
再想想

242
00:07:00,166 --> 00:07:03,146
如果你移开手指

243
00:07:03,896 --> 00:07:05,386
它就会变成终止状态

244
00:07:05,386 --> 00:07:06,826
终止状态同样也会

245
00:07:07,186 --> 00:07:08,486
最先分发给

246
00:07:08,486 --> 00:07:09,196
手势识别系统

247
00:07:09,976 --> 00:07:11,246
拖移手势识别器

248
00:07:11,246 --> 00:07:14,566
会变成终止状态

249
00:07:14,566 --> 00:07:16,766
并标记为

250
00:07:16,766 --> 00:07:17,326
动作已发出

251
00:07:18,076 --> 00:07:19,256
你可能会认为

252
00:07:19,256 --> 00:07:20,456
轻点手势识别器

253
00:07:20,456 --> 00:07:21,876
也会看到这个终止状态

254
00:07:21,876 --> 00:07:23,266
因为通常

255
00:07:23,266 --> 00:07:25,536
你可以在你的处理方法上

256
00:07:25,736 --> 00:07:26,326
看到全部的触摸顺序

257
00:07:26,656 --> 00:07:27,956
但是

258
00:07:27,956 --> 00:07:28,426
是看不到的

259
00:07:28,966 --> 00:07:30,356
这点对于

260
00:07:30,356 --> 00:07:31,136
自定义手势识别器来说

261
00:07:31,136 --> 00:07:31,666
很重要

262
00:07:31,776 --> 00:07:32,736
一旦你的手势识别器无法运作了

263
00:07:32,736 --> 00:07:34,686
你需要

264
00:07:34,686 --> 00:07:36,066
重置所有状态

265
00:07:36,066 --> 00:07:37,846
以确保你没有

266
00:07:37,846 --> 00:07:39,986
在你还没接收到

267
00:07:39,986 --> 00:07:41,226
终止或取消的触摸事件上

268
00:07:41,226 --> 00:07:41,856
遗留以前的设置

269
00:07:41,986 --> 00:07:44,166
要操作的位置

270
00:07:44,166 --> 00:07:46,206
在你自定义的重置中

271
00:07:46,206 --> 00:07:48,046
手势识别器子任务

272
00:07:49,126 --> 00:07:50,376
最后手势识别系统

273
00:07:50,376 --> 00:07:51,746
会向

274
00:07:51,856 --> 00:07:53,276
拖移手势识别器

275
00:07:53,366 --> 00:07:54,226
发出终止信号

276
00:07:55,806 --> 00:07:57,156
你们刚刚看见的就是

277
00:07:57,226 --> 00:07:57,956
Exclusion

278
00:07:58,136 --> 00:07:59,246
状态变更时

279
00:07:59,246 --> 00:08:00,396
会产生这种情况

280
00:07:59,246 --> 00:08:00,396
会产生这种情况

281
00:08:00,396 --> 00:08:01,676
但有种方法

282
00:08:01,736 --> 00:08:02,036
能让你解决

283
00:08:02,036 --> 00:08:03,926
UIGestureRecognizer 委托中

284
00:08:03,926 --> 00:08:05,596
有办法让你解决

285
00:08:05,936 --> 00:08:07,026
手势识别器

286
00:08:07,026 --> 00:08:08,686
应该同步识别

287
00:08:09,266 --> 00:08:11,156
你可以选择

288
00:08:11,156 --> 00:08:11,736
not be excluded 这一选项

289
00:08:12,326 --> 00:08:13,576
注意你也只能

290
00:08:13,576 --> 00:08:14,126
做这件事

291
00:08:14,126 --> 00:08:16,816
所有想要同步识别的参与者

292
00:08:16,856 --> 00:08:18,316
都能进行

293
00:08:18,546 --> 00:08:19,026
同步识别

294
00:08:19,026 --> 00:08:20,786
这你无法阻止

295
00:08:21,846 --> 00:08:23,566
UIGestureRecognizer 本身

296
00:08:24,856 --> 00:08:26,666
有 inverse logic

297
00:08:26,666 --> 00:08:28,046
可以用来阻止

298
00:08:28,046 --> 00:08:29,736
还可以通过子类

299
00:08:29,736 --> 00:08:30,046
来阻止

300
00:08:30,366 --> 00:08:33,116
所以你可以把这个

301
00:08:33,116 --> 00:08:34,726
用在你想要

302
00:08:34,726 --> 00:08:36,506
进行同步识别的

303
00:08:36,506 --> 00:08:36,696
手势识别器上

304
00:08:37,616 --> 00:08:38,976
我们看看是怎么回事

305
00:08:42,576 --> 00:08:44,376
同样先是设置

306
00:08:45,096 --> 00:08:47,016
触摸屏幕然后进入开启状态

307
00:08:47,636 --> 00:08:48,826
一开始

308
00:08:48,826 --> 00:08:49,396
什么都没发生改变

309
00:08:50,766 --> 00:08:53,356
移动手指

310
00:08:53,356 --> 00:08:54,736
拖移识别器进行识别

311
00:08:54,736 --> 00:08:56,056
轻点识别器

312
00:08:56,056 --> 00:08:59,406
无法进行识别

313
00:08:59,996 --> 00:09:01,096
这个时候

314
00:08:59,996 --> 00:09:01,096
这个时候

315
00:09:01,096 --> 00:09:02,546
手势识别系统

316
00:09:02,546 --> 00:09:04,136
会因为状态改变

317
00:09:04,286 --> 00:09:04,726
而产生 Exclusion

318
00:09:04,726 --> 00:09:06,946
属于此交互的手势识别器

319
00:09:06,946 --> 00:09:08,966
改变了

320
00:09:08,966 --> 00:09:09,436
状态

321
00:09:09,486 --> 00:09:12,016
然后询问问题

322
00:09:12,016 --> 00:09:13,526
得到委托回调

323
00:09:13,836 --> 00:09:15,156
回复 true

324
00:09:15,606 --> 00:09:17,326
回复 true 之后

325
00:09:17,326 --> 00:09:18,306
轻点手势识别器

326
00:09:18,306 --> 00:09:19,236
会被允许继续运行

327
00:09:19,686 --> 00:09:22,226
拖移手势识别器的动作

328
00:09:22,226 --> 00:09:25,976
会被发送

329
00:09:26,146 --> 00:09:27,766
如果现在移开手指

330
00:09:27,766 --> 00:09:30,686
状态开启

331
00:09:30,686 --> 00:09:32,216
拖移手势识别器

332
00:09:32,556 --> 00:09:33,226
会进入终止状态完成工作

333
00:09:33,566 --> 00:09:34,756
轻点手势识别器

334
00:09:34,756 --> 00:09:36,146
也会进入终止状态

335
00:09:36,146 --> 00:09:36,656
完成工作

336
00:09:37,096 --> 00:09:39,006
我们需要知道

337
00:09:39,066 --> 00:09:40,326
手势识别器

338
00:09:40,326 --> 00:09:42,226
会在系统调解前

339
00:09:42,226 --> 00:09:43,946
改变状态

340
00:09:44,276 --> 00:09:46,116
这意味着在这个时候

341
00:09:46,116 --> 00:09:46,976
系统会再次询问

342
00:09:46,976 --> 00:09:48,456
手势识别器是否要同步识别

343
00:09:48,456 --> 00:09:50,096
这是因为我们发生了一个状态变更

344
00:09:50,096 --> 00:09:51,476
如果你想要两个识别器都运行的话

345
00:09:51,476 --> 00:09:53,256
你需要再次在委托方法中

346
00:09:53,256 --> 00:09:54,886
回复 true

347
00:09:56,206 --> 00:09:57,116
既然两个识别器

348
00:09:57,156 --> 00:09:58,396
都进行了识别

349
00:09:58,396 --> 00:09:59,626
这就出现了一个有意思的情况

350
00:09:59,976 --> 00:10:01,356
如果你用

351
00:09:59,976 --> 00:10:01,356
如果你用

352
00:10:01,356 --> 00:10:02,456
手势识别器

353
00:10:02,456 --> 00:10:04,676
进行了同步识别

354
00:10:04,916 --> 00:10:07,236
动作一旦发出

355
00:10:07,236 --> 00:10:08,696
你就决定不了顺序了

356
00:10:09,136 --> 00:10:10,476
于是拖移和轻点手势识别器

357
00:10:10,476 --> 00:10:11,726
会不断反馈问题

358
00:10:11,726 --> 00:10:12,236
因为它们同步识别的过程中

359
00:10:12,236 --> 00:10:14,986
你无法确定

360
00:10:14,986 --> 00:10:16,416
它们会依照

361
00:10:17,306 --> 00:10:18,636
什么样的顺序进行

362
00:10:18,746 --> 00:10:21,886
大体来说是好的

363
00:10:21,886 --> 00:10:23,736
但现在可能会识别一些

364
00:10:23,736 --> 00:10:24,936
我们并不想要的

365
00:10:24,936 --> 00:10:25,506
拖移和轻点动作

366
00:10:25,866 --> 00:10:28,706
如果我们想要拖移识别器

367
00:10:28,706 --> 00:10:30,116
等到轻点识别器

368
00:10:30,116 --> 00:10:32,206
超过最大移动范围后

369
00:10:32,206 --> 00:10:34,526
再进行识别的话

370
00:10:34,526 --> 00:10:36,516
我们另有办法

371
00:10:36,516 --> 00:10:37,546
这个方法叫做

372
00:10:37,546 --> 00:10:38,436
failure requirements

373
00:10:39,056 --> 00:10:41,416
在 failure requirements 中

374
00:10:41,416 --> 00:10:43,236
你可以对两个手势识别器

375
00:10:43,236 --> 00:10:43,986
进行设置

376
00:10:44,846 --> 00:10:46,286
举个例子

377
00:10:46,286 --> 00:10:47,966
当要求静态失效

378
00:10:47,966 --> 00:10:48,686
并且优先时

379
00:10:48,686 --> 00:10:50,186
这意味着

380
00:10:50,186 --> 00:10:52,286
一个识别器要求另一个识别器

381
00:10:52,286 --> 00:10:53,876
在它发送动作前

382
00:10:53,876 --> 00:10:54,306
失效

383
00:10:54,696 --> 00:10:56,586
另一个识别器依然会改变状态

384
00:10:56,586 --> 00:10:58,716
但它会等到前一个识别器发送动作后

385
00:10:59,626 --> 00:10:59,776
再改变

386
00:11:00,486 --> 00:11:02,476
如果你想要更快捷的操作

387
00:11:02,476 --> 00:11:04,276
告诉你个方法

388
00:11:04,356 --> 00:11:05,576
你也可以在

389
00:11:05,576 --> 00:11:07,116
UIGestureRecognizer 委托中输入

390
00:11:07,656 --> 00:11:08,836
两个手势识别器方法

391
00:11:08,836 --> 00:11:09,816
应该要求为

392
00:11:09,816 --> 00:11:11,506
failure of

393
00:11:11,506 --> 00:11:13,086
手势识别器应该要求为

394
00:11:13,086 --> 00:11:13,846
fail by

395
00:11:14,526 --> 00:11:15,666
注意这里

396
00:11:15,736 --> 00:11:16,136
有两种写法

397
00:11:16,266 --> 00:11:17,906
你需要确保

398
00:11:17,906 --> 00:11:20,036
执行时

399
00:11:20,036 --> 00:11:21,486
你的写法是匹配的

400
00:11:21,486 --> 00:11:23,616
因为在更复杂的

401
00:11:23,706 --> 00:11:25,166
UI 手势设置中

402
00:11:25,166 --> 00:11:26,766
这个可能叫 one way

403
00:11:26,766 --> 00:11:27,776
和 the other way first

404
00:11:28,086 --> 00:11:30,396
所以必须要统一

405
00:11:30,726 --> 00:11:32,106
否则可能会

406
00:11:32,106 --> 00:11:33,556
出现 bug

407
00:11:35,156 --> 00:11:36,376
UIGestureRecognizer 子类中

408
00:11:36,376 --> 00:11:38,256
也是一样的

409
00:11:38,456 --> 00:11:39,636
执行

410
00:11:39,636 --> 00:11:40,846
failure of

411
00:11:40,846 --> 00:11:42,286
再执行 fail by

412
00:11:42,756 --> 00:11:44,406
同样这些指令

413
00:11:44,406 --> 00:11:46,736
也有其他表述方法

414
00:11:47,446 --> 00:11:49,436
我们再来看看

415
00:11:49,436 --> 00:11:50,056
其中的工作原理

416
00:11:50,326 --> 00:11:52,016
我们在

417
00:11:52,016 --> 00:11:53,526
拖移手势识别器

418
00:11:53,576 --> 00:11:55,086
和轻点手势识别器中间

419
00:11:55,086 --> 00:11:55,956
设置了一个静态 failure requirement

420
00:11:56,686 --> 00:11:59,946
再次触摸屏幕

421
00:11:59,946 --> 00:12:02,086
初始状态显示 possible

422
00:11:59,946 --> 00:12:02,086
初始状态显示 possible

423
00:12:02,876 --> 00:12:04,226
然后我们移动手指

424
00:12:04,986 --> 00:12:07,666
移动状态会分发给

425
00:12:07,836 --> 00:12:09,296
两个手势识别器

426
00:12:09,296 --> 00:12:10,776
拖移识别器的状态显示 began

427
00:12:11,026 --> 00:12:12,306
而轻点手势识别器的状态仍然为

428
00:12:12,306 --> 00:12:12,836
possible

429
00:12:13,666 --> 00:12:15,076
但由于

430
00:12:15,126 --> 00:12:16,816
failure requirement 的存在

431
00:12:16,816 --> 00:12:18,286
拖移识别器

432
00:12:18,286 --> 00:12:19,646
此时不会发送动作

433
00:12:22,026 --> 00:12:23,396
接着再往外移一点点

434
00:12:23,446 --> 00:12:24,866
但又不至于

435
00:12:24,866 --> 00:12:26,316
远到轻点手势识别器无法识别的地步

436
00:12:26,316 --> 00:12:28,586
我们移的时候

437
00:12:28,586 --> 00:12:30,106
拖移识别器会将状态改为

438
00:12:30,176 --> 00:12:31,546
changed

439
00:12:33,386 --> 00:12:34,796
轻点识别器的状态

440
00:12:34,796 --> 00:12:36,506
仍然保持为 possible

441
00:12:36,506 --> 00:12:38,036
但 failure requirement 还没完成

442
00:12:38,256 --> 00:12:40,386
也就是说仍然无动作

443
00:12:40,956 --> 00:12:42,966
此时此刻

444
00:12:42,966 --> 00:12:45,116
如果你在往外移一点

445
00:12:45,436 --> 00:12:47,116
轻点识别器就会失效

446
00:12:47,116 --> 00:12:49,006
它失效之后

447
00:12:49,006 --> 00:12:50,426
就允许了拖移识别器

448
00:12:50,426 --> 00:12:50,896
发送动作

449
00:12:51,716 --> 00:12:54,006
这里有个很重要的

450
00:12:54,006 --> 00:12:54,336
信息

451
00:12:54,336 --> 00:12:56,006
如果此时拖移识别器

452
00:12:56,006 --> 00:12:57,366
发送了动作

453
00:12:57,656 --> 00:12:58,896
它会以 began 的状态

454
00:12:58,896 --> 00:12:59,706
发送动作

455
00:13:00,186 --> 00:13:01,836
虽然它现在的状态是 change

456
00:13:01,836 --> 00:13:03,406
但我们要确保

457
00:13:03,406 --> 00:13:04,836
用户看到的是连续的图像

458
00:13:05,106 --> 00:13:07,766
重要的是

459
00:13:08,126 --> 00:13:09,486
你不能看了

460
00:13:09,486 --> 00:13:11,326
手势识别器发送动作时

461
00:13:11,326 --> 00:13:13,186
显示出的状态后

462
00:13:13,186 --> 00:13:14,516
就误以为是当前的状态

463
00:13:14,516 --> 00:13:16,376
因为这个状态只针对

464
00:13:16,376 --> 00:13:17,606
这个动作方法有效

465
00:13:18,896 --> 00:13:20,786
现在我们再进一步

466
00:13:20,786 --> 00:13:23,076
移开手指

467
00:13:23,076 --> 00:13:24,406
触摸状态显示为 ended

468
00:13:24,406 --> 00:13:26,026
且即将被

469
00:13:26,026 --> 00:13:26,426
分发处理

470
00:13:26,426 --> 00:13:27,766
拖移识别器的状态更改为 ended

471
00:13:27,766 --> 00:13:29,246
并进行识别

472
00:13:29,556 --> 00:13:30,976
轻点手势识别器的状态

473
00:13:30,976 --> 00:13:31,996
更改为 ended

474
00:13:31,996 --> 00:13:32,686
并进行识别

475
00:13:35,296 --> 00:13:37,076
但现在仍然无动作

476
00:13:37,076 --> 00:13:38,496
我们看到拖移手势识别器

477
00:13:38,496 --> 00:13:40,236
已经完成了全套的状态变更

478
00:13:40,236 --> 00:13:41,676
但它还没有发送动作

479
00:13:41,676 --> 00:13:43,406
这是因为

480
00:13:43,406 --> 00:13:45,496
轻点识别器进行了识别

481
00:13:45,496 --> 00:13:47,166
于是 failure requirement

482
00:13:47,336 --> 00:13:48,076
还没结束

483
00:13:48,576 --> 00:13:50,146
轻点手势识别器

484
00:13:50,146 --> 00:13:51,666
最后会发送动作

485
00:13:52,136 --> 00:13:53,926
这就是 failure requirements

486
00:13:54,116 --> 00:13:55,596
Failure requirements 的用处就在于

487
00:13:55,646 --> 00:13:57,206
阻止一个手势识别器

488
00:13:57,206 --> 00:13:58,156
发送多余动作

489
00:13:58,526 --> 00:14:01,866
这点你们得知道

490
00:13:58,526 --> 00:14:01,866
这点你们得知道

491
00:14:02,076 --> 00:14:03,326
我们来看看

492
00:14:03,326 --> 00:14:03,756
这幅图

493
00:14:03,756 --> 00:14:06,106
这是个普通的设定界面

494
00:14:06,746 --> 00:14:08,656
想象一下这个屏幕上

495
00:14:08,656 --> 00:14:10,106
有多少手势识别器

496
00:14:10,496 --> 00:14:11,736
蓄势待发

497
00:14:11,796 --> 00:14:14,776
想个数字

498
00:14:14,946 --> 00:14:17,916
是的  有 163 个

499
00:14:19,616 --> 00:14:21,126
确实是有很多

500
00:14:21,126 --> 00:14:23,276
但我们的手势识别系统

501
00:14:23,276 --> 00:14:25,236
就是为此而存在的

502
00:14:25,236 --> 00:14:26,506
我们在做的

503
00:14:26,506 --> 00:14:27,586
是缩小范围

504
00:14:27,916 --> 00:14:29,596
举个例子

505
00:14:29,736 --> 00:14:31,696
如果点这里  滑动开关

506
00:14:31,696 --> 00:14:33,846
我们为你

507
00:14:33,846 --> 00:14:35,586
缩小了相关手势识别器的

508
00:14:35,656 --> 00:14:35,876
范围

509
00:14:36,706 --> 00:14:38,856
在这个例子中我们减少到了

510
00:14:38,856 --> 00:14:39,716
七个

511
00:14:40,036 --> 00:14:41,436
只有七个

512
00:14:41,766 --> 00:14:42,636
就很好处理了

513
00:14:43,126 --> 00:14:44,406
这是怎么做到的呢

514
00:14:44,706 --> 00:14:46,466
在 channel 中   我们会在触摸发生时

515
00:14:46,466 --> 00:14:48,166
做命中测试

516
00:14:48,166 --> 00:14:50,036
命中测试

517
00:14:50,036 --> 00:14:51,346
会步步深入视图层级

518
00:14:51,346 --> 00:14:52,966
从窗口开始

519
00:14:52,966 --> 00:14:55,236
询问命中测试工具

520
00:14:55,236 --> 00:14:56,986
触摸是否在某个视图中

521
00:14:56,986 --> 00:14:58,196
我们找到最深层的视图后

522
00:14:58,296 --> 00:15:00,406
我们保存并指定它

523
00:14:58,296 --> 00:15:00,406
我们保存并指定它

524
00:15:00,406 --> 00:15:01,206
分配给这次触摸事件

525
00:15:05,476 --> 00:15:07,386
这是一个

526
00:15:07,386 --> 00:15:07,986
简要概览

527
00:15:07,986 --> 00:15:10,366
包括了命中测试

528
00:15:10,366 --> 00:15:10,886
和触摸点

529
00:15:11,716 --> 00:15:15,216
这是你重载的

530
00:15:15,216 --> 00:15:15,626
触摸点

531
00:15:15,886 --> 00:15:17,986
注意如果你重载了触摸点

532
00:15:17,986 --> 00:15:19,906
来放大或缩小了

533
00:15:19,906 --> 00:15:21,026
你的命中测试区域

534
00:15:21,026 --> 00:15:22,926
你应该两者都

535
00:15:23,416 --> 00:15:23,966
再进行一次重载

536
00:15:24,496 --> 00:15:26,806
还要注意这里的事件

537
00:15:26,836 --> 00:15:28,206
是没有完全形成的

538
00:15:28,206 --> 00:15:29,396
因为命中测试是我们做的

539
00:15:29,396 --> 00:15:29,916
第一件事

540
00:15:30,346 --> 00:15:32,026
这意味着如果你去检查

541
00:15:32,026 --> 00:15:33,936
事件中的触摸点

542
00:15:33,936 --> 00:15:35,426
可能会找不到

543
00:15:35,426 --> 00:15:36,646
我们需要经过一层一层的测试

544
00:15:36,646 --> 00:15:38,066
最后才会把触摸点

545
00:15:38,066 --> 00:15:38,626
添加到事件上

546
00:15:39,006 --> 00:15:40,226
也许你会觉得奇怪

547
00:15:40,226 --> 00:15:42,156
但在命中测试中

548
00:15:42,186 --> 00:15:42,576
就是这样的

549
00:15:42,576 --> 00:15:43,816
对于这个事件

550
00:15:43,886 --> 00:15:45,306
你能询问的只有

551
00:15:45,306 --> 00:15:48,146
它是否在回调中存在

552
00:15:48,276 --> 00:15:49,826
和它的种类

553
00:15:50,296 --> 00:15:52,216
还有很多属性控件

554
00:15:52,286 --> 00:15:53,396
会对命中测试进行影响

555
00:15:53,436 --> 00:15:55,276
比如 UIView 中的

556
00:15:55,276 --> 00:15:56,496
isUserInteractionEnabled

557
00:15:56,496 --> 00:15:57,846
这个是

558
00:15:57,846 --> 00:15:58,496
最重要的控件之一

559
00:15:58,846 --> 00:16:01,376
如果未作更改

560
00:15:58,846 --> 00:16:01,376
如果未作更改

561
00:16:01,376 --> 00:16:03,236
它一般默认为 true

562
00:16:03,236 --> 00:16:05,216
但有例外  对于图片视图

563
00:16:05,216 --> 00:16:07,586
默认为 false

564
00:16:07,866 --> 00:16:09,086
对于这种你需要改为 yes

565
00:16:09,116 --> 00:16:10,686
不然你就无法对此

566
00:16:10,716 --> 00:16:11,666
进行命中测试

567
00:16:12,056 --> 00:16:13,386
这有个 alpha 和 isHidden

568
00:16:13,386 --> 00:16:14,926
这是用来防护命中测试的

569
00:16:14,976 --> 00:16:16,596
所以对于不可见的东西

570
00:16:16,596 --> 00:16:18,846
我们不对它进行命中测试

571
00:16:19,196 --> 00:16:21,516
但在你的自定义子类中

572
00:16:21,516 --> 00:16:23,226
你还是需要进行

573
00:16:23,226 --> 00:16:23,576
命中测试

574
00:16:23,916 --> 00:16:24,786
再就是

575
00:16:24,786 --> 00:16:26,866
isMultipleTouchEnabled

576
00:16:26,866 --> 00:16:28,746
出于历史原因默认为 No

577
00:16:28,746 --> 00:16:30,436
但并不影响

578
00:16:30,436 --> 00:16:31,716
手势识别系统

579
00:16:31,716 --> 00:16:34,226
所以如果你

580
00:16:34,226 --> 00:16:35,656
明明做了双指开合的

581
00:16:35,656 --> 00:16:37,096
相关手势设定

582
00:16:37,156 --> 00:16:38,946
但你的

583
00:16:38,946 --> 00:16:40,136
基于响应器的触摸处理

584
00:16:40,136 --> 00:16:41,706
只看到了一个触摸

585
00:16:41,706 --> 00:16:43,906
很有可能你层级中的一个视图

586
00:16:43,906 --> 00:16:45,986
设置成 No

587
00:16:45,986 --> 00:16:46,676
忘改了

588
00:16:46,716 --> 00:16:47,776
你只需要把它

589
00:16:47,886 --> 00:16:48,146
设置为 True

590
00:16:48,596 --> 00:16:49,846
在接下来是

591
00:16:49,846 --> 00:16:51,566
UIViewAnimationOptions

592
00:16:51,566 --> 00:16:53,646
如果你进行了终端用户交互

593
00:16:53,646 --> 00:16:54,256
就停止测试

594
00:16:54,676 --> 00:16:57,646
这并不是因为我们不希望

595
00:16:57,646 --> 00:16:59,106
你在用户交互期间

596
00:16:59,106 --> 00:17:01,176
进行命中测试

597
00:16:59,106 --> 00:17:01,176
进行命中测试

598
00:17:01,176 --> 00:17:02,546
而是如果你授权了

599
00:17:02,546 --> 00:17:03,726
你需要再做点额外的工作

600
00:17:04,036 --> 00:17:05,205
你需要重载

601
00:17:05,205 --> 00:17:06,366
内部相关的命中测试

602
00:17:06,366 --> 00:17:07,016
从而让它

603
00:17:07,066 --> 00:17:07,336
顺畅运行

604
00:17:08,296 --> 00:17:09,465
我们之前说过

605
00:17:09,465 --> 00:17:10,836
表现层和模型层

606
00:17:10,836 --> 00:17:11,976
你应该

607
00:17:11,976 --> 00:17:13,205
对此

608
00:17:13,976 --> 00:17:14,205
有所收获

609
00:17:14,465 --> 00:17:16,195
如果没有

610
00:17:16,195 --> 00:17:16,566
请去看看那次展示

611
00:17:17,036 --> 00:17:19,356
去年我们新增了

612
00:17:19,356 --> 00:17:21,705
UIViewPropertyAnimator

613
00:17:21,705 --> 00:17:23,046
它可以帮助你

614
00:17:23,046 --> 00:17:24,296
对动画进行命中测试

615
00:17:24,746 --> 00:17:26,386
然而对于这个

616
00:17:26,386 --> 00:17:27,766
isManualHitTestingEnabled 的属性控件

617
00:17:27,766 --> 00:17:29,156
你必须设置为 true

618
00:17:29,636 --> 00:17:32,076
从而才能进行自定义命中测试

619
00:17:32,076 --> 00:17:33,296
和其他更复杂的

620
00:17:33,296 --> 00:17:33,936
场景

621
00:17:34,456 --> 00:17:37,006
再回来看

622
00:17:37,006 --> 00:17:38,206
视图层级中的命中测试

623
00:17:38,566 --> 00:17:39,916
我们进行了命中测试后

624
00:17:40,206 --> 00:17:41,476
我们回来视图层级

625
00:17:41,476 --> 00:17:42,796
收集各个视图中

626
00:17:42,796 --> 00:17:44,296
所有的

627
00:17:44,336 --> 00:17:44,826
手势识别器

628
00:17:45,056 --> 00:17:46,586
这是我们对这个交互的

629
00:17:46,586 --> 00:17:49,666
手势识别器基集

630
00:17:49,666 --> 00:17:53,206
但还有更多

631
00:17:53,206 --> 00:17:54,516
可供你自定义的部分

632
00:17:54,516 --> 00:17:55,726
你有个回调函数

633
00:17:55,786 --> 00:17:56,906
UIGestureRecognizer

634
00:17:56,906 --> 00:17:57,666
shouldReceive touch

635
00:17:58,076 --> 00:18:00,496
如果你对它返回 false

636
00:17:58,076 --> 00:18:00,496
如果你对它返回 false

637
00:18:00,496 --> 00:18:03,196
你就会完全

638
00:18:03,196 --> 00:18:04,446
将一个手势识别器

639
00:18:04,446 --> 00:18:05,696
隔离在外

640
00:18:05,696 --> 00:18:07,346
它会永远看不见这次触摸

641
00:18:07,576 --> 00:18:09,056
这也是个让你

642
00:18:09,056 --> 00:18:10,826
来看看你的手势识别器

643
00:18:11,556 --> 00:18:13,246
是否真正

644
00:18:13,246 --> 00:18:15,246
参与交互

645
00:18:15,246 --> 00:18:15,886
的机会

646
00:18:16,276 --> 00:18:17,746
在后面的 gestureRecognizerShouldBegin 上

647
00:18:17,746 --> 00:18:18,986
也有一个触摸点

648
00:18:18,986 --> 00:18:20,386
可能会给调试

649
00:18:20,386 --> 00:18:21,466
带来问题

650
00:18:21,756 --> 00:18:23,296
当手势识别器准备开启时

651
00:18:23,356 --> 00:18:24,826
会进行询问

652
00:18:24,866 --> 00:18:26,806
你可以对此说不

653
00:18:26,936 --> 00:18:28,756
也就是返回 False

654
00:18:29,056 --> 00:18:31,106
如果你这样做了  它就会失效

655
00:18:31,106 --> 00:18:33,356
它因为失效

656
00:18:33,356 --> 00:18:34,936
会完成 failure requirements

657
00:18:34,936 --> 00:18:36,916
这点可以

658
00:18:37,196 --> 00:18:39,386
看看

659
00:18:39,556 --> 00:18:41,056
这有个 UIGestureRecognizer 上的

660
00:18:41,056 --> 00:18:42,656
静态属性控件 isEnabled

661
00:18:42,656 --> 00:18:45,136
如果你知道你的状态

662
00:18:45,136 --> 00:18:47,026
并且想在静态下进行

663
00:18:47,026 --> 00:18:48,396
你可以把它设置为 False

664
00:18:48,736 --> 00:18:49,956
这对你

665
00:18:49,956 --> 00:18:50,486
很有帮助

666
00:18:50,716 --> 00:18:52,536
这有个技巧

667
00:18:52,536 --> 00:18:54,686
我们说过很多次了

668
00:18:54,986 --> 00:18:57,056
当你设置成 False 时

669
00:18:57,056 --> 00:18:58,576
它在识别时会失效

670
00:18:58,856 --> 00:19:00,156
如果你立即又设置回 True

671
00:18:58,856 --> 00:19:00,156
如果你立即又设置回 True

672
00:19:00,246 --> 00:19:01,766
你的手势识别器

673
00:19:01,766 --> 00:19:04,226
就会直接

674
00:19:04,226 --> 00:19:05,356
对下一个触摸顺序

675
00:19:05,386 --> 00:19:05,866
进行回应

676
00:19:06,776 --> 00:19:07,926
接下来是 allowedTouchTypes

677
00:19:07,976 --> 00:19:09,526
默认为所有触摸种类

678
00:19:09,526 --> 00:19:11,686
包括直接

679
00:19:11,686 --> 00:19:13,086
间接和触控笔

680
00:19:13,656 --> 00:19:15,996
但你也可以

681
00:19:15,996 --> 00:19:17,656
只选触控笔或直接触摸

682
00:19:17,656 --> 00:19:20,996
但如果你想要

683
00:19:21,276 --> 00:19:23,006
识别不同触摸种类的手势

684
00:19:23,006 --> 00:19:24,176
你必须把

685
00:19:24,176 --> 00:19:25,856
requiresExclusiveTouchType

686
00:19:25,856 --> 00:19:27,546
设置为 True

687
00:19:27,936 --> 00:19:29,696
这样你才能做到

688
00:19:29,696 --> 00:19:31,166
用一支铅笔和一根手指

689
00:19:31,166 --> 00:19:31,796
来实现双指开合

690
00:19:32,206 --> 00:19:33,126
否则是做不到的

691
00:19:33,826 --> 00:19:34,856
说到属性控件

692
00:19:34,856 --> 00:19:36,206
我们在 iOS 11 中给你们带来了

693
00:19:36,386 --> 00:19:37,886
New Property

694
00:19:37,886 --> 00:19:39,086
就叫这个名字

695
00:19:39,656 --> 00:19:40,846
听起来简单

696
00:19:40,846 --> 00:19:42,256
但很有帮助

697
00:19:42,256 --> 00:19:43,356
因为我们可以让你用

698
00:19:43,356 --> 00:19:44,436
我们所有的手势识别器

699
00:19:44,436 --> 00:19:45,256
并且还能进行配置

700
00:19:45,576 --> 00:19:47,036
于是你能添加

701
00:19:47,036 --> 00:19:47,246
附加名称

702
00:19:47,246 --> 00:19:48,396
调试时你不需要

703
00:19:48,466 --> 00:19:49,706
去看动作方法

704
00:19:50,146 --> 00:19:52,206
你只需要用它来

705
00:19:52,206 --> 00:19:53,996
进行调试就好了

706
00:19:53,996 --> 00:19:56,176
我们不保证

707
00:19:56,176 --> 00:19:58,046
系统不会对它

708
00:19:58,046 --> 00:19:58,486
进行干涉

709
00:19:59,676 --> 00:20:01,836
说到调试

710
00:19:59,676 --> 00:20:01,836
说到调试

711
00:20:01,836 --> 00:20:03,966
我们现在

712
00:20:03,966 --> 00:20:05,076
取得了一个破发点机会

713
00:20:05,076 --> 00:20:06,406
可以用手势识别器的 shouldReceive touch

714
00:20:06,976 --> 00:20:08,636
清楚地看到

715
00:20:08,676 --> 00:20:09,146
你的设置是否生效

716
00:20:09,496 --> 00:20:11,116
还有这个 touchesBegin

717
00:20:11,116 --> 00:20:12,226
这种 responder base touch handling method

718
00:20:12,226 --> 00:20:14,366
可以帮助你

719
00:20:14,816 --> 00:20:16,206
在已知状态下

720
00:20:16,206 --> 00:20:17,736
检查手势识别器系统的状态

721
00:20:17,776 --> 00:20:19,106
你也看到了

722
00:20:19,156 --> 00:20:20,946
我们操作的步骤

723
00:20:21,246 --> 00:20:22,606
现在你可以对它进行检查

724
00:20:22,606 --> 00:20:25,866
并且知道各个值的

725
00:20:25,866 --> 00:20:26,336
意思

726
00:20:26,736 --> 00:20:28,106
再比如  你还可以看

727
00:20:28,106 --> 00:20:29,766
一次触摸的手势识别器

728
00:20:29,766 --> 00:20:31,886
或者你也可以

729
00:20:31,886 --> 00:20:33,016
通过询问事件

730
00:20:33,016 --> 00:20:34,986
来查看触摸的手势识别器

731
00:20:35,346 --> 00:20:38,076
你还可以收集

732
00:20:38,076 --> 00:20:39,726
调试期间

733
00:20:39,726 --> 00:20:41,086
所有视图层级的

734
00:20:41,086 --> 00:20:41,426
手势识别器

735
00:20:43,356 --> 00:20:45,126
再说说

736
00:20:45,126 --> 00:20:46,176
自定义 UIGestureRecognizers.

737
00:20:46,656 --> 00:20:47,946
你必须慢开始

738
00:20:47,996 --> 00:20:48,786
快结束

739
00:20:49,186 --> 00:20:50,896
就是说如果你过早开始

740
00:20:50,896 --> 00:20:52,086
比如对于触摸事件而言

741
00:20:52,126 --> 00:20:53,896
一旦开始早了

742
00:20:53,896 --> 00:20:55,736
其他手势识别器就没有机会

743
00:20:55,736 --> 00:20:56,826
设置成 not be excluded 了

744
00:20:57,276 --> 00:20:57,886
这很不好

745
00:20:57,886 --> 00:20:59,136
所以你应该

746
00:20:59,166 --> 00:21:00,786
尽量晚一点开始

747
00:20:59,166 --> 00:21:00,786
尽量晚一点开始

748
00:21:00,786 --> 00:21:01,756
保证你的手势识别器的

749
00:21:01,756 --> 00:21:02,326
功能

750
00:21:02,756 --> 00:21:05,146
同时你也要快速结束

751
00:21:05,146 --> 00:21:06,696
免得去影响

752
00:21:06,696 --> 00:21:08,006
其他手势识别器的

753
00:21:08,006 --> 00:21:10,066
failure requirements

754
00:21:10,066 --> 00:21:11,926
这点很重要

755
00:21:11,926 --> 00:21:13,556
你每看到一次触摸事件

756
00:21:13,556 --> 00:21:16,036
一定要把状态变为fail

757
00:21:16,086 --> 00:21:17,396
即使是之前的状态一直都是 possible

758
00:21:17,396 --> 00:21:18,456
也要这么做

759
00:21:18,456 --> 00:21:19,806
因为你必须被标记为

760
00:21:19,806 --> 00:21:21,166
属于此交互

761
00:21:21,166 --> 00:21:23,026
否则会使系统中止

762
00:21:23,026 --> 00:21:24,526
慎重对待

763
00:21:24,526 --> 00:21:25,016
屏蔽触摸

764
00:21:25,076 --> 00:21:27,116
要正确地去屏蔽

765
00:21:27,116 --> 00:21:28,226
不能只是放在一边不处理

766
00:21:28,606 --> 00:21:30,016
你还应该调用 Ignore

767
00:21:30,346 --> 00:21:31,856
这一步是给

768
00:21:31,856 --> 00:21:33,676
自定义手势识别器子集上的事件做的

769
00:21:33,676 --> 00:21:34,886
否则你的触摸事件会被延迟

770
00:21:34,886 --> 00:21:36,856
虽然你对它们

771
00:21:36,856 --> 00:21:37,856
甚至都不感兴趣

772
00:21:38,416 --> 00:21:39,656
永远别忘了

773
00:21:39,696 --> 00:21:41,696
设置 touchesCancelled

774
00:21:41,996 --> 00:21:43,656
今年这一步变得尤为重要

775
00:21:43,656 --> 00:21:44,866
因为我们的拖放功能

776
00:21:44,866 --> 00:21:46,176
会需要更频繁地取消

777
00:21:46,176 --> 00:21:46,446
触摸事件

778
00:21:47,746 --> 00:21:50,116
在这里你得记住

779
00:21:50,116 --> 00:21:51,846
要重新访问你的设置

780
00:21:51,846 --> 00:21:52,896
好好检查

781
00:21:52,896 --> 00:21:55,006
手势识别器设置

782
00:21:55,886 --> 00:21:57,346
好好理顺一下

783
00:21:57,346 --> 00:21:58,576
刚刚听到的知识

784
00:21:58,636 --> 00:21:58,976
归纳好

785
00:21:59,856 --> 00:22:01,016
重新访问你的

786
00:21:59,856 --> 00:22:01,016
重新访问你的

787
00:22:01,016 --> 00:22:02,146
exclusion 和 failure requirements

788
00:22:02,146 --> 00:22:03,606
当你在用一个手势识别器时

789
00:22:03,826 --> 00:22:05,156
你想要多少个

790
00:22:05,156 --> 00:22:06,356
手势识别器

791
00:22:06,356 --> 00:22:07,546
同步发挥作用

792
00:22:09,246 --> 00:22:10,746
你的手势识别器

793
00:22:10,746 --> 00:22:12,336
是否在正确的视图中

794
00:22:12,336 --> 00:22:13,556
是否够深层

795
00:22:13,666 --> 00:22:14,956
你放置得越深

796
00:22:14,956 --> 00:22:16,526
它跟其他手势识别器

797
00:22:16,526 --> 00:22:17,306
产生的干扰越小

798
00:22:17,356 --> 00:22:18,436
越是在上层

799
00:22:18,436 --> 00:22:20,706
越通用

800
00:22:21,126 --> 00:22:22,266
所以你得

801
00:22:22,336 --> 00:22:22,896
好好权衡

802
00:22:23,856 --> 00:22:26,276
现在

803
00:22:26,276 --> 00:22:27,706
我想请 Glen 上台

804
00:22:27,706 --> 00:22:28,206
讲讲系统手势交互

805
00:22:28,596 --> 00:22:28,876
谢谢

806
00:22:29,516 --> 00:22:35,546
[掌声]

807
00:22:36,046 --> 00:22:36,686
&gt;&gt; 谢谢 Dom

808
00:22:36,686 --> 00:22:39,446
我叫 Glen Low

809
00:22:39,446 --> 00:22:41,506
我是 UIkit

810
00:22:41,506 --> 00:22:42,006
软件工程师

811
00:22:42,396 --> 00:22:43,666
我来为大家介绍

812
00:22:43,666 --> 00:22:45,706
一些全新的

813
00:22:45,706 --> 00:22:46,936
能优化系统手势交互体验的

814
00:22:47,346 --> 00:22:48,526
API

815
00:22:49,236 --> 00:22:50,436
先来玩个

816
00:22:50,436 --> 00:22:51,056
小游戏

817
00:22:52,226 --> 00:22:53,976
辛辛苦苦码一天代码的

818
00:22:54,016 --> 00:22:55,406
软件工程师想玩玩游戏

819
00:22:55,766 --> 00:22:58,376
所以我打开了 Demobots

820
00:22:58,376 --> 00:22:59,596
在虚拟控件上

821
00:22:59,596 --> 00:23:00,546
上上下下滑动

822
00:22:59,596 --> 00:23:00,546
上上下下滑动

823
00:23:00,546 --> 00:23:01,506
操作机器人

824
00:23:01,506 --> 00:23:03,126
就是屏幕右上角的

825
00:23:03,126 --> 00:23:03,716
这个

826
00:23:03,936 --> 00:23:04,996
灰色圆圈

827
00:23:05,956 --> 00:23:06,976
就像这样

828
00:23:08,466 --> 00:23:11,176
我的机器人必须

829
00:23:11,176 --> 00:23:13,276
把坏机器人变成好机器人

830
00:23:14,606 --> 00:23:16,326
你们看我玩得还不错

831
00:23:17,796 --> 00:23:19,036
好像错过了一个

832
00:23:19,036 --> 00:23:20,466
我得往下走

833
00:23:20,466 --> 00:23:22,586
找到那个机器人

834
00:23:23,766 --> 00:23:25,966
欸  这是怎么了

835
00:23:26,186 --> 00:23:27,356
为什么我退回到了

836
00:23:27,356 --> 00:23:27,806
桌面

837
00:23:28,386 --> 00:23:30,976
这不是我们

838
00:23:30,976 --> 00:23:32,026
想要营造的

839
00:23:32,026 --> 00:23:32,906
用户体验吧

840
00:23:33,946 --> 00:23:35,426
那哪里错了呢

841
00:23:36,716 --> 00:23:38,166
我们现在有几个

842
00:23:38,316 --> 00:23:40,816
特殊的手势

843
00:23:40,816 --> 00:23:41,386
我们称作系统手势

844
00:23:41,846 --> 00:23:44,666
从底部向上滑

845
00:23:44,666 --> 00:23:46,146
可以拉出多任务处理栏

846
00:23:46,146 --> 00:23:46,466
和 Dock 栏

847
00:23:47,456 --> 00:23:49,796
从侧面滑

848
00:23:50,006 --> 00:23:52,006
可以实现 SlideOver 功能

849
00:23:52,646 --> 00:23:54,996
从顶部向下滑

850
00:23:55,046 --> 00:23:56,496
会拉出桌面

851
00:23:57,666 --> 00:23:59,856
现在这些特殊的系统手势识别器

852
00:23:59,856 --> 00:24:02,146
会阻碍你 App 中的

853
00:23:59,856 --> 00:24:02,146
会阻碍你 App 中的

854
00:24:02,146 --> 00:24:03,196
手势识别器

855
00:24:03,426 --> 00:24:06,106
和响应器

856
00:24:06,106 --> 00:24:07,086
意图率先

857
00:24:07,086 --> 00:24:07,206
识别触摸

858
00:24:07,206 --> 00:24:09,176
那么我们能做些什么呢

859
00:24:10,496 --> 00:24:12,036
有一些手势识别器

860
00:24:12,096 --> 00:24:13,036
例外

861
00:24:13,626 --> 00:24:15,386
轻点  双指开合  旋转

862
00:24:15,386 --> 00:24:17,646
和长按手势识别器

863
00:24:17,646 --> 00:24:18,966
能够在系统手势识别器

864
00:24:19,016 --> 00:24:21,016
识别的同时

865
00:24:21,046 --> 00:24:21,946
识别触摸

866
00:24:22,676 --> 00:24:23,976
但是有些时候

867
00:24:23,976 --> 00:24:26,306
如果发现明显是系统手势

868
00:24:26,306 --> 00:24:27,866
它们也会被

869
00:24:27,866 --> 00:24:28,206
取消

870
00:24:28,836 --> 00:24:31,016
这就是为什么

871
00:24:31,576 --> 00:24:32,736
当你在底部点一个按钮

872
00:24:32,736 --> 00:24:34,276
并不会拉出

873
00:24:34,276 --> 00:24:36,106
Dock 栏的原因

874
00:24:36,106 --> 00:24:37,706
因为它是基于

875
00:24:37,736 --> 00:24:39,016
轻点手势识别器的

876
00:24:40,026 --> 00:24:42,246
另一方面

877
00:24:42,956 --> 00:24:44,286
我们有拖移和轻扫识别器

878
00:24:44,286 --> 00:24:46,286
以及早就有的响应器

879
00:24:46,586 --> 00:24:47,866
而这些会在

880
00:24:47,916 --> 00:24:49,646
系统手势识别器识别之后

881
00:24:49,646 --> 00:24:51,136
对触摸进行处理

882
00:24:51,726 --> 00:24:53,056
那么当我们的用户

883
00:24:53,056 --> 00:24:54,616
轻轻滑动了底部的时候

884
00:24:54,616 --> 00:24:56,626
他是想打开 Dock 栏呢

885
00:24:56,816 --> 00:24:59,296
还是拖动视野呢

886
00:24:59,516 --> 00:25:03,276
我们得去猜

887
00:24:59,516 --> 00:25:03,276
我们得去猜

888
00:25:03,396 --> 00:25:04,586
是否需要延迟系统手势

889
00:25:05,506 --> 00:25:06,986
举个例子

890
00:25:06,986 --> 00:25:09,116
如果这个 App 隐藏了状态栏

891
00:25:09,446 --> 00:25:10,586
我们就会延迟

892
00:25:10,586 --> 00:25:13,066
上拉 Dock 栏

893
00:25:13,066 --> 00:25:14,266
但要一直猜对是很难的

894
00:25:14,466 --> 00:25:16,536
到底谁最清楚

895
00:25:16,536 --> 00:25:17,386
用户想要什么

896
00:25:18,616 --> 00:25:21,076
对于 iOS 11  你现在可以告诉我们

897
00:25:21,456 --> 00:25:22,976
什么时候延迟

898
00:25:23,056 --> 00:25:23,356
在哪进行延迟

899
00:25:24,776 --> 00:25:25,586
不需要再猜

900
00:25:25,906 --> 00:25:27,626
你不用再去判断

901
00:25:28,066 --> 00:25:30,036
是否需要延迟

902
00:25:30,036 --> 00:25:31,066
系统手势

903
00:25:32,266 --> 00:25:33,866
也就是说

904
00:25:33,866 --> 00:25:35,566
如果你的 App 隐藏了状态栏

905
00:25:35,566 --> 00:25:37,016
不会再自动

906
00:25:37,126 --> 00:25:37,556
延迟 Dock 栏

907
00:25:38,716 --> 00:25:41,736
看起来是什么样呢

908
00:25:42,196 --> 00:25:43,836
你要用到一个新的

909
00:25:43,836 --> 00:25:46,506
叫做 ScreenEdgesDeferringSystemGestures

910
00:25:46,606 --> 00:25:47,896
的 API

911
00:25:48,626 --> 00:25:50,926
这个 API 能让你

912
00:25:50,926 --> 00:25:52,546
界定一个范围

913
00:25:52,806 --> 00:25:54,666
范围内会延迟系统识别器

914
00:25:54,666 --> 00:25:56,786
从而保护你自己的手势识别器

915
00:25:57,476 --> 00:25:58,656
在你的试图控制器中

916
00:25:58,796 --> 00:26:01,426
重载

917
00:25:58,796 --> 00:26:01,426
重载

918
00:26:01,946 --> 00:26:03,706
preferredScreenEdgesDeferringSystemGesutres

919
00:26:03,706 --> 00:26:05,046
以返回要延迟的

920
00:26:05,046 --> 00:26:05,606
屏幕边界

921
00:26:06,356 --> 00:26:10,216
如果你想返回其他

922
00:26:10,216 --> 00:26:12,466
调用

923
00:26:12,676 --> 00:26:14,766
setNeedsUpdateOfScreenEdges

924
00:26:14,806 --> 00:26:16,736
DeferringSystemGestures

925
00:26:17,386 --> 00:26:18,936
我们看看

926
00:26:19,296 --> 00:26:21,486
这个调用是干嘛的

927
00:26:24,346 --> 00:26:26,146
当用户触摸界面底部时

928
00:26:26,956 --> 00:26:28,346
你的手势识别器

929
00:26:28,346 --> 00:26:29,856
和响应器

930
00:26:29,856 --> 00:26:30,996
同时得到触摸

931
00:26:31,666 --> 00:26:33,806
这时

932
00:26:35,036 --> 00:26:36,116
我们显示一个拉出箭头

933
00:26:36,556 --> 00:26:38,466
让用户看到

934
00:26:38,466 --> 00:26:39,646
他们有更多选择

935
00:26:40,326 --> 00:26:41,876
再一次在底部向上滑

936
00:26:41,936 --> 00:26:43,646
就能上拉

937
00:26:43,646 --> 00:26:43,966
Dock 栏

938
00:26:51,306 --> 00:26:53,356
如果你都是在

939
00:26:53,356 --> 00:26:54,966
容器视图下进行编写的话

940
00:26:54,966 --> 00:26:55,476
再教你一招

941
00:26:56,246 --> 00:26:57,236
一般而言

942
00:26:57,236 --> 00:26:58,456
这个 MyContainerViewController

943
00:26:58,456 --> 00:26:59,656
实际上就是

944
00:26:59,656 --> 00:27:00,536
ChildViewController

945
00:26:59,656 --> 00:27:00,536
ChildViewController

946
00:27:00,626 --> 00:27:02,726
所以你返回的

947
00:27:02,726 --> 00:27:04,486
重载得写对

948
00:27:04,806 --> 00:27:06,746
应该是

949
00:27:06,746 --> 00:27:08,296
childViewControllerForScreenEdgesDeferringSystemGestures

950
00:27:08,896 --> 00:27:10,686
它应该有希望拿下

951
00:27:10,686 --> 00:27:12,016
iOS 最长的方法名

952
00:27:12,016 --> 00:27:12,846
的称号

953
00:27:13,526 --> 00:27:16,066
现在万事俱备

954
00:27:16,066 --> 00:27:18,376
都在你指之下

955
00:27:18,376 --> 00:27:19,666
你该什么时候用呢

956
00:27:20,276 --> 00:27:23,966
简而言之  别用

957
00:27:24,676 --> 00:27:26,476
那我来这干嘛  是吧

958
00:27:26,866 --> 00:27:28,626
不那么简而言之就是

959
00:27:28,626 --> 00:27:30,946
好好思考什么时候用

960
00:27:30,946 --> 00:27:32,686
为什么

961
00:27:33,276 --> 00:27:35,016
第一

962
00:27:35,016 --> 00:27:36,326
你的用户对上拉 Dock 栏的操作

963
00:27:36,326 --> 00:27:37,886
和其他的系统手势

964
00:27:37,886 --> 00:27:38,426
都非常熟悉

965
00:27:38,426 --> 00:27:40,516
这时用这个 API

966
00:27:40,516 --> 00:27:41,496
会违背他们的习惯

967
00:27:41,646 --> 00:27:43,476
会跟他们的期望

968
00:27:43,476 --> 00:27:44,316
相矛盾

969
00:27:45,316 --> 00:27:47,466
再者  如果你用的是

970
00:27:47,506 --> 00:27:49,626
我们之前说过的

971
00:27:49,626 --> 00:27:51,356
轻点  双指开合  旋转和长按手势的话

972
00:27:51,356 --> 00:27:52,816
你即便不用 API

973
00:27:52,816 --> 00:27:54,146
这些触摸也会被

974
00:27:54,146 --> 00:27:55,826
率先识别

975
00:27:56,676 --> 00:28:00,476
第三

976
00:27:56,676 --> 00:28:00,476
第三

977
00:28:00,476 --> 00:28:02,466
我们保留屏蔽或修改

978
00:28:02,466 --> 00:28:03,566
延迟边界的权利

979
00:28:04,566 --> 00:28:05,776
所以不要总想着

980
00:28:05,776 --> 00:28:07,616
系统会完全按照

981
00:28:08,146 --> 00:28:08,996
你说的去做

982
00:28:09,226 --> 00:28:12,666
如果你是需要

983
00:28:12,666 --> 00:28:14,056
用户长时间

984
00:28:14,116 --> 00:28:16,166
与全屏幕交互

985
00:28:16,166 --> 00:28:18,046
才用这个API

986
00:28:18,346 --> 00:28:20,316
假如你在编写一款游戏

987
00:28:20,316 --> 00:28:22,716
或者绘图 App 的时候

988
00:28:22,716 --> 00:28:24,876
你问问自己

989
00:28:24,946 --> 00:28:26,306
你的这款 App 是否真正

990
00:28:26,306 --> 00:28:26,806
需要用到这个 API

991
00:28:28,296 --> 00:28:29,746
说到这里

992
00:28:29,746 --> 00:28:31,936
有请我的同事

993
00:28:32,026 --> 00:28:34,526
Mike Turner 上台

994
00:28:34,526 --> 00:28:36,326
他会告诉你们如何使用

995
00:28:37,076 --> 00:28:37,566
拖放功能

996
00:28:37,666 --> 00:28:37,976
Mikey

997
00:28:38,516 --> 00:28:43,500
[掌声]

998
00:28:46,416 --> 00:28:47,406
谢谢 Glow

999
00:28:50,676 --> 00:28:53,306
大家也看到了  在 iOS 11 中

1000
00:28:53,306 --> 00:28:54,206
我们做了许多更新

1001
00:28:54,206 --> 00:28:55,626
首屈一指的

1002
00:28:55,626 --> 00:28:57,066
就是拖放功能

1003
00:28:57,476 --> 00:28:59,126
有了拖放功能

1004
00:28:59,326 --> 00:29:01,696
用户可以以一种新鲜有趣的方式

1005
00:28:59,326 --> 00:29:01,696
用户可以以一种新鲜有趣的方式

1006
00:29:01,696 --> 00:29:03,006
与各位的 App

1007
00:29:03,006 --> 00:29:04,266
互动

1008
00:29:04,846 --> 00:29:06,596
但你们得了解

1009
00:29:06,596 --> 00:29:09,016
如何运用你们 App 中现有的

1010
00:29:09,016 --> 00:29:10,686
一些手势识别器

1011
00:29:10,686 --> 00:29:11,646
来让拖放功能的效果

1012
00:29:11,646 --> 00:29:12,856
最大化

1013
00:29:13,186 --> 00:29:14,086
所以我先做个简单的示例

1014
00:29:14,086 --> 00:29:15,486
告诉你们

1015
00:29:15,486 --> 00:29:18,276
如何在视图中加入拖动功能

1016
00:29:18,276 --> 00:29:19,876
以及这么做了之后

1017
00:29:19,876 --> 00:29:20,586
对你现有手势识别器

1018
00:29:20,586 --> 00:29:21,686
会有什么影响

1019
00:29:22,356 --> 00:29:24,106
在 iOS 11 中  我们新增了一个类

1020
00:29:24,106 --> 00:29:25,876
叫做 UIDragInteraction

1021
00:29:26,496 --> 00:29:28,136
UIDragInteraction用起来

1022
00:29:28,236 --> 00:29:29,296
超级简单

1023
00:29:29,296 --> 00:29:30,216
非常符合习惯

1024
00:29:30,486 --> 00:29:31,386
跟手势识别器的操作

1025
00:29:31,386 --> 00:29:33,006
和添加子视图的操作一样

1026
00:29:33,006 --> 00:29:34,766
你只要

1027
00:29:34,766 --> 00:29:35,896
选择一个委托

1028
00:29:35,896 --> 00:29:37,316
设定初始值

1029
00:29:37,316 --> 00:29:38,666
然后在视图中调用 addInteraction

1030
00:29:38,666 --> 00:29:39,966
做完这些

1031
00:29:39,966 --> 00:29:40,416
就差不多了

1032
00:29:40,416 --> 00:29:41,136
你设置好了一个委托 API

1033
00:29:41,136 --> 00:29:42,696
你就有拖动功能了

1034
00:29:43,236 --> 00:29:43,756
非常简单

1035
00:29:44,056 --> 00:29:46,236
我们来看一个简短的展示

1036
00:29:46,236 --> 00:29:47,546
看看你添加了一个拖动交互后

1037
00:29:47,546 --> 00:29:49,316
你的视图

1038
00:29:49,316 --> 00:29:50,066
是什么样

1039
00:29:50,326 --> 00:29:51,496
我们长按视图这里

1040
00:29:51,496 --> 00:29:52,826
然后移动

1041
00:29:52,826 --> 00:29:53,506
一点点

1042
00:29:54,656 --> 00:29:56,046
长按

1043
00:29:56,046 --> 00:29:57,356
视图会悬浮在屏幕上

1044
00:29:57,356 --> 00:29:58,616
移动的时候

1045
00:29:58,616 --> 00:29:59,656
就像撕掉了一样

1046
00:30:00,656 --> 00:30:01,916
我们再来看看

1047
00:30:01,916 --> 00:30:03,076
在你 App 里是如何实现

1048
00:30:03,136 --> 00:30:03,976
拖动交互的

1049
00:30:05,146 --> 00:30:05,986
我们新增拖动交互后

1050
00:30:05,986 --> 00:30:07,116
UIView 上

1051
00:30:07,116 --> 00:30:08,676
出现了新的

1052
00:30:08,676 --> 00:30:09,126
交互组

1053
00:30:09,686 --> 00:30:10,996
于是拖动交互

1054
00:30:10,996 --> 00:30:12,136
给自己生成了一些

1055
00:30:12,136 --> 00:30:13,536
手势识别器

1056
00:30:13,946 --> 00:30:15,176
依附在视图上

1057
00:30:15,176 --> 00:30:16,216
并且成为了这些手势识别器的

1058
00:30:16,216 --> 00:30:17,066
委托

1059
00:30:17,206 --> 00:30:18,326
生成的手势识别器

1060
00:30:18,326 --> 00:30:19,766
可以初始化拖动

1061
00:30:19,766 --> 00:30:21,446
处理与其他手势识别器的

1062
00:30:21,446 --> 00:30:23,526
关系

1063
00:30:23,526 --> 00:30:25,196
并给 App 已有的拖动

1064
00:30:25,196 --> 00:30:26,276
添加其他

1065
00:30:26,276 --> 00:30:26,816
东西

1066
00:30:27,426 --> 00:30:30,416
更具体一点

1067
00:30:30,416 --> 00:30:32,806
我们在视图新增

1068
00:30:32,806 --> 00:30:34,526
UILongPressGestureRecognizer

1069
00:30:34,526 --> 00:30:35,866
有了这个

1070
00:30:35,866 --> 00:30:38,346
会跳出这幅图的

1071
00:30:38,526 --> 00:30:40,016
一个

1072
00:30:40,016 --> 00:30:40,726
活动视图控制器

1073
00:30:41,296 --> 00:30:43,056
在这里当手势识别器的状态

1074
00:30:43,056 --> 00:30:44,286
为 Began 时

1075
00:30:44,286 --> 00:30:45,406
我们打开这个

1076
00:30:45,406 --> 00:30:47,046
活动视图控制器

1077
00:30:47,046 --> 00:30:48,276
手势识别器的状态为 Cancel 时

1078
00:30:48,276 --> 00:30:49,346
我们关上

1079
00:30:49,346 --> 00:30:50,316
活动视图控制器

1080
00:30:51,686 --> 00:30:52,506
我们再回到

1081
00:30:52,506 --> 00:30:53,916
这个长按后移动的

1082
00:30:53,916 --> 00:30:55,716
例子

1083
00:30:56,146 --> 00:30:57,306
现在我们有了自己的

1084
00:30:57,306 --> 00:30:58,736
UILongPressGestureRecognizer

1085
00:30:58,736 --> 00:30:59,246
在里面

1086
00:31:00,626 --> 00:31:02,946
长按  移动

1087
00:31:03,956 --> 00:31:05,176
没有出现什么

1088
00:31:05,176 --> 00:31:05,886
活动视图控制器

1089
00:31:07,146 --> 00:31:08,256
这是因为

1090
00:31:08,256 --> 00:31:09,446
当有拖动交互时

1091
00:31:09,446 --> 00:31:11,006
长按手势识别器

1092
00:31:11,006 --> 00:31:12,866
会被延迟

1093
00:31:14,106 --> 00:31:15,356
那我们稍微调整一下

1094
00:31:15,356 --> 00:31:16,426
我们的操作

1095
00:31:16,496 --> 00:31:17,516
看看能不能把活动视图控制器

1096
00:31:17,516 --> 00:31:18,526
给弄出来

1097
00:31:19,006 --> 00:31:20,326
这一次我们长按后

1098
00:31:20,326 --> 00:31:22,086
保持一下

1099
00:31:22,186 --> 00:31:23,606
再移动

1100
00:31:24,516 --> 00:31:26,986
长按  保持

1101
00:31:26,986 --> 00:31:27,366
再移动

1102
00:31:27,806 --> 00:31:29,076
我们看到活动视图控制器

1103
00:31:29,076 --> 00:31:30,866
出来了一下

1104
00:31:30,866 --> 00:31:31,666
马上又没了

1105
00:31:32,286 --> 00:31:34,696
这是因为一个开始了的拖动

1106
00:31:34,696 --> 00:31:36,366
会取消

1107
00:31:36,366 --> 00:31:37,696
你 App 里上一个拖动的

1108
00:31:37,696 --> 00:31:38,246
触摸

1109
00:31:38,706 --> 00:31:39,966
我们会为这次触摸

1110
00:31:40,026 --> 00:31:41,136
向 App 发送取消其他触摸

1111
00:31:41,456 --> 00:31:42,576
然后 App 会把它发送给

1112
00:31:42,606 --> 00:31:43,466
手势识别器

1113
00:31:43,466 --> 00:31:44,146
和响应器

1114
00:31:44,466 --> 00:31:45,476
于是手势识别器

1115
00:31:45,476 --> 00:31:47,306
会给这个动作

1116
00:31:47,306 --> 00:31:49,366
发送取消的状态

1117
00:31:49,366 --> 00:31:50,326
于是就关闭了这个活动视图控制器

1118
00:31:52,016 --> 00:31:53,776
在紧凑的界面中

1119
00:31:53,776 --> 00:31:56,036
活动视图控制器

1120
00:31:56,356 --> 00:31:57,466
会适应屏幕大小

1121
00:31:57,466 --> 00:31:58,606
变成

1122
00:31:58,606 --> 00:32:00,006
一张上拉菜单

1123
00:31:58,606 --> 00:32:00,006
一张上拉菜单

1124
00:32:00,576 --> 00:32:01,786
我们看看这会是

1125
00:32:01,786 --> 00:32:02,446
什么样

1126
00:32:03,136 --> 00:32:03,986
所以我们要在

1127
00:32:04,306 --> 00:32:06,636
紧凑的界面中

1128
00:32:06,636 --> 00:32:07,706
长按并保持一会儿再移动

1129
00:32:08,956 --> 00:32:09,996
长按

1130
00:32:10,596 --> 00:32:11,216
保持  移动

1131
00:32:11,996 --> 00:32:13,366
又没有活动视图

1132
00:32:13,366 --> 00:32:13,616
控制器

1133
00:32:14,466 --> 00:32:16,296
来看看是什么情况

1134
00:32:16,566 --> 00:32:17,646
在这里

1135
00:32:17,646 --> 00:32:19,426
长按会被一直延迟到触摸结束

1136
00:32:19,426 --> 00:32:20,866
这是因为

1137
00:32:20,866 --> 00:32:22,686
在紧凑的界面中

1138
00:32:22,746 --> 00:32:24,306
弹框

1139
00:32:24,306 --> 00:32:26,096
和上拉菜单

1140
00:32:26,096 --> 00:32:27,756
大多都会妨碍

1141
00:32:27,756 --> 00:32:29,056
用户继续拖动

1142
00:32:29,056 --> 00:32:30,196
影响用户体验

1143
00:32:31,236 --> 00:32:32,486
我们看看

1144
00:32:32,486 --> 00:32:33,956
我们怎么调整一下操作

1145
00:32:34,306 --> 00:32:35,376
让活动视图控制器

1146
00:32:35,376 --> 00:32:35,786
出现

1147
00:32:35,986 --> 00:32:37,936
我们长按再松开

1148
00:32:39,326 --> 00:32:41,596
长按后

1149
00:32:41,596 --> 00:32:42,046
松开手指

1150
00:32:42,046 --> 00:32:43,086
有了

1151
00:32:43,346 --> 00:32:44,986
上拉菜单出现了

1152
00:32:44,986 --> 00:32:45,956
活动视图控制器

1153
00:32:47,556 --> 00:32:49,626
所以 UIDragInteraction

1154
00:32:49,746 --> 00:32:51,486
还有能往拖动上添加其他物件的

1155
00:32:51,756 --> 00:32:53,386
内置功能

1156
00:32:53,386 --> 00:32:55,416
也就是我之前说的

1157
00:32:55,416 --> 00:32:57,736
通过生成另一个手势识别器

1158
00:32:57,736 --> 00:32:58,306
来完成

1159
00:32:59,276 --> 00:33:00,546
这里很快地

1160
00:32:59,276 --> 00:33:00,546
这里很快地

1161
00:33:00,546 --> 00:33:01,096
展示一下

1162
00:33:01,096 --> 00:33:02,766
我们长按  移动

1163
00:33:02,766 --> 00:33:04,736
再轻点视图

1164
00:33:04,736 --> 00:33:06,326
添加其他物件

1165
00:33:07,246 --> 00:33:09,216
它会帮你处理这次轻点

1166
00:33:09,466 --> 00:33:10,386
但你也可以

1167
00:33:10,386 --> 00:33:11,376
进行更改

1168
00:33:11,936 --> 00:33:13,336
首先这个动作是

1169
00:33:13,336 --> 00:33:13,776
非强制的

1170
00:33:13,776 --> 00:33:15,686
所以这个添加物件的

1171
00:33:15,686 --> 00:33:17,126
委托方法

1172
00:33:17,126 --> 00:33:18,726
UIDragInteraction 是非强制的

1173
00:33:18,796 --> 00:33:20,176
你不执行

1174
00:33:20,176 --> 00:33:21,636
你就不会有这个添加的行为

1175
00:33:21,636 --> 00:33:22,816
但即便你执行了

1176
00:33:22,816 --> 00:33:24,636
你也可以返回"return zero items

1177
00:33:24,636 --> 00:33:26,146
in this API to continue"

1178
00:33:26,386 --> 00:33:27,786
以平常的方式

1179
00:33:27,786 --> 00:33:29,586
对这个触摸进行处理

1180
00:33:31,256 --> 00:33:33,036
所以使用 UIDragInteraction 时

1181
00:33:33,036 --> 00:33:34,406
适用于你的 App

1182
00:33:34,406 --> 00:33:35,786
并不难

1183
00:33:36,046 --> 00:33:37,586
基本无需手动操作

1184
00:33:37,586 --> 00:33:39,996
你只要知道一些

1185
00:33:40,256 --> 00:33:41,246
基本概念就行了

1186
00:33:41,246 --> 00:33:42,916
你要做的第一件事

1187
00:33:42,916 --> 00:33:44,276
就只是检验你现有的

1188
00:33:44,276 --> 00:33:44,906
动作

1189
00:33:45,176 --> 00:33:46,526
是否能配合

1190
00:33:46,526 --> 00:33:47,526
UIDragInteraction

1191
00:33:47,866 --> 00:33:49,586
有些情况  UIDragInteraction

1192
00:33:49,586 --> 00:33:50,666
可能可以取代

1193
00:33:50,666 --> 00:33:52,216
UILongPress 的

1194
00:33:52,216 --> 00:33:53,466
一些现有功能

1195
00:33:54,486 --> 00:33:55,886
你在用

1196
00:33:55,886 --> 00:33:57,396
UIDragInteraction

1197
00:33:57,396 --> 00:33:59,276
呈现模式用户界面的时候

1198
00:33:59,276 --> 00:33:59,606
得要

1199
00:33:59,606 --> 00:34:00,526
非常注意

1200
00:33:59,606 --> 00:34:00,526
非常注意

1201
00:34:00,856 --> 00:34:03,376
这是因为在标准界面下

1202
00:34:03,376 --> 00:34:05,396
它会被延迟

1203
00:34:05,396 --> 00:34:06,826
而且可能

1204
00:34:06,826 --> 00:34:08,235
在拖动之前展示

1205
00:34:08,516 --> 00:34:09,286
在此你需要

1206
00:34:09,286 --> 00:34:10,275
注意一下

1207
00:34:11,286 --> 00:34:12,646
之后你得处理

1208
00:34:12,646 --> 00:34:14,085
你 UIGestureRecognizers 中的

1209
00:34:14,085 --> 00:34:14,996
Cancel 状态

1210
00:34:15,416 --> 00:34:16,815
你们之前也看到了  拖动一开始

1211
00:34:16,815 --> 00:34:17,916
我们发送了触摸已取消

1212
00:34:18,016 --> 00:34:19,246
所以如果你不处理

1213
00:34:19,246 --> 00:34:20,466
你手势识别器的 Cancel 状态的话

1214
00:34:20,466 --> 00:34:21,926
你就无法

1215
00:34:21,926 --> 00:34:23,005
像我们的示例中那样

1216
00:34:23,005 --> 00:34:24,485
关闭

1217
00:34:24,485 --> 00:34:25,956
活动视图

1218
00:34:25,956 --> 00:34:26,966
控制器了

1219
00:34:27,626 --> 00:34:29,085
注意关于 UIDragInteraction

1220
00:34:29,085 --> 00:34:31,525
有一点非常重要

1221
00:34:31,525 --> 00:34:33,315
也特别酷

1222
00:34:33,315 --> 00:34:34,706
就是你的 App 在拖动期间

1223
00:34:34,706 --> 00:34:35,906
是完全交互的

1224
00:34:36,606 --> 00:34:38,166
所以可能会产生

1225
00:34:38,206 --> 00:34:39,545
一些预想不到的

1226
00:34:39,545 --> 00:34:39,946
交互行为

1227
00:34:39,946 --> 00:34:41,846
你们得警惕

1228
00:34:43,856 --> 00:34:45,985
Dom 之前上台告诉我们

1229
00:34:45,985 --> 00:34:48,025
如何最有好地使用

1230
00:34:48,076 --> 00:34:50,786
手势识别系统

1231
00:34:50,786 --> 00:34:52,386
来进行你想要的设定

1232
00:34:52,386 --> 00:34:53,456
以及如何通过 failure requirements

1233
00:34:53,456 --> 00:34:55,946
和 exclusion

1234
00:34:55,946 --> 00:34:57,065
来处理

1235
00:34:57,065 --> 00:34:58,336
若干手势识别器之间的

1236
00:34:58,336 --> 00:34:58,526
关系

1237
00:34:59,436 --> 00:35:01,276
他告诉了我们很重要的一点

1238
00:34:59,436 --> 00:35:01,276
他告诉了我们很重要的一点

1239
00:35:01,276 --> 00:35:02,706
手势识别器是

1240
00:35:02,776 --> 00:35:03,126
第一位出现的

1241
00:35:03,936 --> 00:35:05,816
所以当我们通过

1242
00:35:05,816 --> 00:35:06,836
发送触摸时

1243
00:35:06,836 --> 00:35:08,766
手势识别器会

1244
00:35:08,766 --> 00:35:10,156
阻止基于响应器的触摸处理

1245
00:35:10,366 --> 00:35:11,516
所以你应该

1246
00:35:11,516 --> 00:35:12,806
尽一切可能

1247
00:35:12,806 --> 00:35:14,276
使用手势识别器

1248
00:35:14,276 --> 00:35:14,786
来达到目的

1249
00:35:15,436 --> 00:35:19,006
然后 Glen 告诉我们

1250
00:35:19,006 --> 00:35:20,786
当我们需要滑动屏幕边缘时

1251
00:35:20,786 --> 00:35:24,116
如何运用New系统手势延迟 API

1252
00:35:24,116 --> 00:35:25,466
优先我们 App 中的

1253
00:35:25,466 --> 00:35:27,366
手势

1254
00:35:27,366 --> 00:35:27,936
识别器

1255
00:35:28,346 --> 00:35:29,486
在全屏的情况下

1256
00:35:29,486 --> 00:35:30,806
你要非常保守地

1257
00:35:30,806 --> 00:35:31,876
使用这个方法

1258
00:35:32,186 --> 00:35:33,126
只有在用户

1259
00:35:33,126 --> 00:35:34,846
使用 App 时明确期望发生的交互

1260
00:35:34,846 --> 00:35:36,216
不是系统手势的时候

1261
00:35:36,216 --> 00:35:36,696
才使用

1262
00:35:37,066 --> 00:35:37,986
所以用得很少

1263
00:35:38,806 --> 00:35:40,646
最后我们简要地说了一下

1264
00:35:40,646 --> 00:35:42,436
如何在你的 App 中

1265
00:35:42,916 --> 00:35:44,686
使用 UIDragInteraction

1266
00:35:44,686 --> 00:35:45,526
特别简单

1267
00:35:46,456 --> 00:35:47,496
所以我希望你们可以

1268
00:35:47,496 --> 00:35:49,056
多多在你们的视图中

1269
00:35:49,056 --> 00:35:49,576
使用 UIDragInteraction

1270
00:35:50,986 --> 00:35:52,656
想了解更多资讯的话

1271
00:35:52,986 --> 00:35:54,776
你们可以在这个网站

1272
00:35:54,776 --> 00:35:55,676
看视频回放

1273
00:35:56,086 --> 00:35:57,856
我们做了一些很棒的展示

1274
00:35:57,856 --> 00:35:59,126
深入探讨了 UIkit 中的

1275
00:35:59,126 --> 00:36:00,296
事件处理方法

1276
00:35:59,126 --> 00:36:00,296
事件处理方法

1277
00:36:00,426 --> 00:36:01,296
如果你还没看过

1278
00:36:01,336 --> 00:36:02,396
我强烈推荐

1279
00:36:03,276 --> 00:36:05,416
我们还会有一些关于

1280
00:36:05,416 --> 00:36:06,736
拖放和动画的展示

1281
00:36:06,736 --> 00:36:08,466
你们可以关注一下

1282
00:36:08,466 --> 00:36:09,976
好好享受 WWDC 吧

1283
00:36:10,516 --> 00:36:15,500
[掌声]
