1
00:00:17,718 --> 00:00:21,221
<c.green>（编写省电的应用）</c>

2
00:00:22,489 --> 00:00:25,526
<c.green>电池使用时间对用户来说</c>

3
00:00:25,826 --> 00:00:28,128
<c.green>应用与电池使用时间</c>

4
00:00:28,629 --> 00:00:30,497
<c.green>作为开发者</c>

5
00:00:30,697 --> 00:00:32,633
<c.green>我们在编写代码时</c>

6
00:00:33,367 --> 00:00:34,635
<c.green>原因很简单</c>

7
00:00:35,369 --> 00:00:37,771
<c.green>如果我是用户</c>

8
00:00:38,238 --> 00:00:39,473
<c.green>那么我做的第一件事情</c>

9
00:00:39,740 --> 00:00:41,842
<c.green>是转到</c>

10
00:00:42,209 --> 00:00:45,479
<c.green>我会弄清楚</c>

11
00:00:46,313 --> 00:00:50,050
<c.green>如果我发现你的应用</c>

12
00:00:50,517 --> 00:00:53,954
<c.green>而且我会很高兴</c>

13
00:00:55,455 --> 00:01:00,060
<c.green>今天 我要讨论</c>

14
00:00:55,455 --> 00:01:00,060
<c.green>今天 我要讨论</c>

15
00:01:00,594 --> 00:01:02,029
<c.green>然后 我们将会讨论</c>

16
00:01:02,095 --> 00:01:03,697
<c.green>节能编码规范</c>

17
00:01:04,096 --> 00:01:05,232
<c.green>此后 我的同事将上台</c>

18
00:01:05,532 --> 00:01:07,301
<c.green>为大家介绍</c>

19
00:01:07,534 --> 00:01:09,670
<c.green>这些工具可供你们使用</c>

20
00:01:10,404 --> 00:01:11,939
<c.green>最后我们进行总结</c>

21
00:01:13,273 --> 00:01:14,308
<c.green>让我们开始</c>

22
00:01:15,409 --> 00:01:16,777
<c.green>什么是电量？</c>

23
00:01:17,244 --> 00:01:19,880
<c.green>电量是电力和时间的双重结合</c>

24
00:01:20,147 --> 00:01:21,782
<c.green>我想用一个例子来进行描述</c>

25
00:01:21,849 --> 00:01:23,684
<c.green>（什么是电量？）</c>

26
00:01:23,750 --> 00:01:26,086
<c.green>在这里可以看到</c>

27
00:01:26,386 --> 00:01:27,487
<c.green>电量耗用很低</c>

28
00:01:28,188 --> 00:01:30,757
<c.green>当设备工作时</c>

29
00:01:31,758 --> 00:01:33,894
<c.green>你还会注意到</c>

30
00:01:33,961 --> 00:01:35,529
<c.green>这取决于你的工作负荷</c>

31
00:01:35,596 --> 00:01:36,897
<c.green>以及你的工作类型</c>

32
00:01:37,698 --> 00:01:39,766
<c.green>你会注意到存在开销</c>

33
00:01:41,034 --> 00:01:45,005
<c.green>需要电量来启动硬件</c>

34
00:01:45,706 --> 00:01:47,875
<c.green>以处理你的工作</c>

35
00:01:49,643 --> 00:01:52,779
<c.green>前面我说过</c>

36
00:01:53,413 --> 00:01:54,882
<c.green>这是曲线下方的区域</c>

37
00:01:55,649 --> 00:01:57,284
<c.green>让我们进行更深层的研究</c>

38
00:01:59,720 --> 00:02:02,956
<c.green>我们将电量分布</c>

39
00:01:59,720 --> 00:02:02,956
<c.green>我们将电量分布</c>

40
00:02:03,156 --> 00:02:05,626
<c.green>固定成本和动态成本</c>

41
00:02:06,360 --> 00:02:08,729
<c.green>动态成本是</c>

42
00:02:09,562 --> 00:02:13,433
<c.green>固定成本是开销</c>

43
00:02:13,967 --> 00:02:15,569
<c.green>也就是启动硬件</c>

44
00:02:15,636 --> 00:02:18,205
<c.green>来完成你的工作所需要的电量</c>

45
00:02:18,539 --> 00:02:20,507
<c.green>因此 即使你处理</c>

46
00:02:20,974 --> 00:02:22,843
<c.green>你仍然需要付出</c>

47
00:02:23,710 --> 00:02:25,145
<c.green>在这方面</c>

48
00:02:27,080 --> 00:02:28,916
<c.green>我们的设备功耗很高</c>

49
00:02:29,616 --> 00:02:32,352
<c.green>因此 作为开发者</c>

50
00:02:33,420 --> 00:02:34,755
<c.green>应该非常小心</c>

51
00:02:35,622 --> 00:02:36,657
<c.green>我们应该认真思考</c>

52
00:02:37,057 --> 00:02:40,661
<c.green>以合理地利用电量</c>

53
00:02:40,727 --> 00:02:43,063
<c.green>当我们处理工作时</c>

54
00:02:43,230 --> 00:02:45,332
<c.green>但是在其它时候</c>

55
00:02:47,301 --> 00:02:49,603
<c.green>这时 你可能在想</c>

56
00:02:50,204 --> 00:02:53,373
<c.green>事实上 设备中的所有项目</c>

57
00:02:53,674 --> 00:02:56,643
<c.green>但是今天 我想要重点讨论四个要点</c>

58
00:02:57,578 --> 00:03:00,147
<c.green>它们包括处理</c>

59
00:02:57,578 --> 00:03:00,147
<c.green>它们包括处理</c>

60
00:03:01,081 --> 00:03:04,952
<c.green>网络 位置</c>

61
00:03:05,319 --> 00:03:07,287
<c.green>这四点 我希望你们</c>

62
00:03:07,354 --> 00:03:08,388
<c.green>在编写应用时给予重视</c>

63
00:03:12,326 --> 00:03:15,696
<c.green>那么 我如何降低</c>

64
00:03:16,797 --> 00:03:19,900
<c.green>首先 需要分析</c>

65
00:03:20,167 --> 00:03:23,437
<c.green>认真思考这些工作</c>

66
00:03:23,504 --> 00:03:24,505
<c.green>（如何减少电量耗用）</c>

67
00:03:24,571 --> 00:03:28,609
<c.green>如果不能帮助用户 就应该放弃</c>

68
00:03:29,276 --> 00:03:30,677
<c.green>接下来 你需优化你的工作</c>

69
00:03:31,078 --> 00:03:33,146
<c.green>在确定需要做的工作之后</c>

70
00:03:33,814 --> 00:03:35,883
<c.green>应该想办法快速</c>

71
00:03:36,850 --> 00:03:40,053
<c.green>你需要进行合并</c>

72
00:03:40,287 --> 00:03:41,655
<c.green>不要离散地完成这些处理</c>

73
00:03:42,356 --> 00:03:44,758
<c.green>最后 应该想办法</c>

74
00:03:46,894 --> 00:03:50,063
<c.green>让我们来看</c>

75
00:03:50,130 --> 00:03:51,331
<c.green>（节能编码）</c>

76
00:03:51,632 --> 00:03:53,100
<c.green>首先 我想从网络开始</c>

77
00:03:53,567 --> 00:03:55,736
<c.green>如果你要开发使用网络功能的应用</c>

78
00:03:55,936 --> 00:03:58,672
<c.green>或者你的应用提供网络功能</c>

79
00:04:00,774 --> 00:04:03,010
<c.green>让我们来看一个例子</c>

80
00:04:03,644 --> 00:04:05,412
<c.green>我在开发一个社交网络应用</c>

81
00:04:06,013 --> 00:04:08,048
<c.green>分为三部分：</c>

82
00:04:08,549 --> 00:04:11,718
<c.green>主界面</c>

83
00:04:12,519 --> 00:04:15,722
<c.green>而且最终能够发送一些分析数据</c>

84
00:04:18,425 --> 00:04:19,660
<c.green>让我们先来看主界面</c>

85
00:04:20,494 --> 00:04:21,862
<c.green>在当前实现中</c>

86
00:04:21,928 --> 00:04:25,599
<c.green>我反复不断地</c>

87
00:04:26,400 --> 00:04:29,002
<c.green>让我们来看</c>

88
00:04:29,937 --> 00:04:34,474
<c.green>乍看上去</c>

89
00:04:35,309 --> 00:04:39,713
<c.green>但是前面我们说过</c>

90
00:04:40,647 --> 00:04:44,918
<c.green>然后使其进入睡眠状态</c>

91
00:04:46,820 --> 00:04:48,722
<c.green>因此 虽然你仅进行少量的工作</c>

92
00:04:48,889 --> 00:04:50,357
<c.green>也会产生这些开销</c>

93
00:04:50,557 --> 00:04:53,327
<c.green>这会对电量使用情况</c>

94
00:04:54,061 --> 00:04:55,662
<c.green>那么 我们应该如何优化呢？</c>

95
00:04:57,531 --> 00:05:01,068
<c.green>首先 应该仅在</c>

96
00:04:57,531 --> 00:05:01,068
<c.green>首先 应该仅在</c>

97
00:05:01,568 --> 00:05:04,204
<c.green>或者在收到通知时这样做</c>

98
00:05:05,539 --> 00:05:08,342
<c.green>接下来 你需要使用</c>

99
00:05:08,609 --> 00:05:11,778
<c.green>有一个新属性</c>

100
00:05:12,646 --> 00:05:14,214
<c.green>它让你能够知道</c>

101
00:05:14,281 --> 00:05:17,251
<c.green>何时连接到你选择的服务器</c>

102
00:05:17,985 --> 00:05:21,255
<c.green>另外 还需要使用</c>

103
00:05:22,356 --> 00:05:27,160
<c.green>这让你不必反复不断地</c>

104
00:05:27,628 --> 00:05:30,531
<c.green>加载主界面</c>

105
00:05:32,699 --> 00:05:36,036
<c.green>让我们来看这些优化</c>

106
00:05:37,337 --> 00:05:41,108
<c.green>这里 可以看到</c>

107
00:05:41,542 --> 00:05:45,012
<c.green>现在 只会在用户交互</c>

108
00:05:45,546 --> 00:05:48,015
<c.green>而且消除了</c>

109
00:05:48,882 --> 00:05:50,083
<c.green>这可以延长电量使用时间</c>

110
00:05:51,985 --> 00:05:53,620
<c.green>让我们来看如何进行编码</c>

111
00:05:54,188 --> 00:05:57,891
<c.green>首先 我们需要</c>

112
00:05:59,293 --> 00:06:03,864
<c.green>然后我们将这个</c>

113
00:05:59,293 --> 00:06:03,864
<c.green>然后我们将这个</c>

114
00:06:05,232 --> 00:06:06,800
<c.green>最后</c>

115
00:06:09,336 --> 00:06:10,470
<c.green>这就是主要设置工作</c>

116
00:06:10,938 --> 00:06:13,407
<c.green>接下来 让我们讨论</c>

117
00:06:14,107 --> 00:06:15,475
<c.green>在当前的实现中</c>

118
00:06:16,176 --> 00:06:18,478
<c.green>我想要立即发送这张照片</c>

119
00:06:18,779 --> 00:06:20,681
<c.green>每次失败后</c>

120
00:06:21,381 --> 00:06:23,483
<c.green>我必须将这张照片</c>

121
00:06:24,251 --> 00:06:26,386
<c.green>让我们来看这对电量的影响</c>

122
00:06:27,521 --> 00:06:29,890
<c.green>这里可以看到电量影响非常高</c>

123
00:06:30,190 --> 00:06:32,793
<c.green>我们花费大量的时间</c>

124
00:06:32,860 --> 00:06:33,961
<c.green>最终产生超时</c>

125
00:06:34,027 --> 00:06:35,929
<c.green>也许是因为网络状况不佳</c>

126
00:06:38,131 --> 00:06:41,301
<c.green>我们再次尝试</c>

127
00:06:41,568 --> 00:06:42,903
<c.green>我们再次耗用很多的电量</c>

128
00:06:43,770 --> 00:06:46,006
<c.green>我们并没有为用户提供解决方法</c>

129
00:06:46,073 --> 00:06:47,841
<c.green>这张照片仍然没有</c>

130
00:06:48,375 --> 00:06:50,377
<c.green>这种情况不断地反复出现</c>

131
00:06:51,545 --> 00:06:52,846
<c.green>如何进行优化呢？</c>

132
00:06:53,881 --> 00:06:56,683
<c.green>首先 应该尽量减少重试次数</c>

133
00:06:57,451 --> 00:06:59,052
<c.green>仅尝试两次或三次</c>

134
00:06:59,887 --> 00:07:03,457
<c.green>接下来 设置合适的超时</c>

135
00:06:59,887 --> 00:07:03,457
<c.green>接下来 设置合适的超时</c>

136
00:07:03,524 --> 00:07:04,892
<c.green>当网络状态不佳时</c>

137
00:07:04,958 --> 00:07:06,827
<c.green>不要花费太多时间进行尝试</c>

138
00:07:08,262 --> 00:07:10,430
<c.green>最后</c>

139
00:07:10,497 --> 00:07:12,566
<c.green>如果还需要同时发布其它照片</c>

140
00:07:12,933 --> 00:07:14,334
<c.green>应该一起发送它们</c>

141
00:07:15,469 --> 00:07:18,939
<c.green>最后 如果达到重试次数限制</c>

142
00:07:19,306 --> 00:07:20,607
<c.green>可以创建一个后台会话</c>

143
00:07:21,275 --> 00:07:24,144
<c.green>这样 就能让系统</c>

144
00:07:24,211 --> 00:07:25,879
<c.green>找到良好的时机来完成你的工作</c>

145
00:07:27,381 --> 00:07:30,551
<c.green>让我们来看这些优化</c>

146
00:07:31,718 --> 00:07:32,853
<c.green>这里可以看到</c>

147
00:07:33,053 --> 00:07:35,389
<c.green>我们显著降低</c>

148
00:07:35,455 --> 00:07:39,226
<c.green>电量使用量和资源开销</c>

149
00:07:40,260 --> 00:07:42,196
<c.green>另外 可以看到仍然发生超时</c>

150
00:07:42,262 --> 00:07:44,164
<c.green>也许是因为网络状态依旧不佳</c>

151
00:07:44,932 --> 00:07:46,633
<c.green>但是仍然进行第二次尝试</c>

152
00:07:46,934 --> 00:07:48,168
<c.green>我们创建一个后台会话</c>

153
00:07:48,235 --> 00:07:51,605
<c.green>现在 我们让系统</c>

154
00:07:52,406 --> 00:07:54,308
<c.green>通过这种方法</c>

155
00:07:54,808 --> 00:07:57,945
<c.green>现在我们来看</c>

156
00:07:58,011 --> 00:08:00,447
<c.green>作为开发者</c>

157
00:07:58,011 --> 00:08:00,447
<c.green>作为开发者</c>

158
00:08:00,514 --> 00:08:01,915
<c.green>用户如何使用我们的应用</c>

159
00:08:02,216 --> 00:08:04,017
<c.green>我们想要确保</c>

160
00:08:04,418 --> 00:08:06,086
<c.green>而不造成电量耗用过多</c>

161
00:08:06,854 --> 00:08:09,389
<c.green>为此 我们可以使用后台会话</c>

162
00:08:10,057 --> 00:08:12,025
<c.green>这样可以把上传或</c>

163
00:08:12,292 --> 00:08:14,862
<c.green>下载工作交给系统</c>

164
00:08:15,362 --> 00:08:17,231
<c.green>此外</c>

165
00:08:17,297 --> 00:08:22,069
<c.green>因此不必自己设置重试规则</c>

166
00:08:23,871 --> 00:08:25,939
<c.green>接下来 它提供吞吐量监测</c>

167
00:08:26,006 --> 00:08:28,809
<c.green>这意味着</c>

168
00:08:28,876 --> 00:08:31,245
<c.green>例如 如果网络状况不佳</c>

169
00:08:31,945 --> 00:08:34,914
<c.green>任务将会停止</c>

170
00:08:35,115 --> 00:08:36,149
<c.green>进行重试</c>

171
00:08:37,751 --> 00:08:39,052
<c.green>最后</c>

172
00:08:39,586 --> 00:08:41,388
<c.green>名称为start time</c>

173
00:08:41,755 --> 00:08:44,691
<c.green>可以使用它们</c>

174
00:08:46,627 --> 00:08:49,396
<c.green>最后 需要设置</c>

175
00:08:49,463 --> 00:08:52,499
<c.green>如果你要做的工作</c>

176
00:08:53,333 --> 00:08:55,769
<c.green>这让系统能够找到</c>

177
00:08:56,103 --> 00:08:57,104
<c.green>来完成你的工作</c>

178
00:08:59,773 --> 00:09:01,175
<c.green>让我们来看一个例子</c>

179
00:08:59,773 --> 00:09:01,175
<c.green>让我们来看一个例子</c>

180
00:09:01,909 --> 00:09:05,145
<c.green>在这里看到</c>

181
00:09:05,212 --> 00:09:07,414
<c.green>我将会在需要发送数据</c>

182
00:09:07,481 --> 00:09:09,650
<c.green>到服务器时</c>

183
00:09:10,384 --> 00:09:13,487
<c.green>另外 后面还有一些</c>

184
00:09:14,588 --> 00:09:16,790
<c.green>这里 将会产生两种开销成本</c>

185
00:09:17,324 --> 00:09:19,626
<c.green>假设我们使用后台会话</c>

186
00:09:21,395 --> 00:09:24,565
<c.green>现在可以看到后台会话允许</c>

187
00:09:24,631 --> 00:09:27,401
<c.green>合并这些事件</c>

188
00:09:28,135 --> 00:09:29,536
<c.green>帮助我们节省时间</c>

189
00:09:29,603 --> 00:09:31,205
<c.green>这些其它网络操作将在稍后发生</c>

190
00:09:32,172 --> 00:09:34,741
<c.green>这可以帮助用户</c>

191
00:09:34,808 --> 00:09:36,443
<c.green>（社交网络应用的电量影响）</c>

192
00:09:37,978 --> 00:09:39,580
<c.green>让我们来看如何进行设置</c>

193
00:09:40,113 --> 00:09:42,916
<c.green>首先 我们将创建</c>

194
00:09:43,350 --> 00:09:46,253
<c.green>然后 将discretionary属性</c>

195
00:09:48,088 --> 00:09:50,858
<c.green>接下来</c>

196
00:09:50,924 --> 00:09:54,061
<c.green>比如开始时间和预期工作量</c>

197
00:09:55,362 --> 00:09:56,697
<c.green>最后</c>

198
00:09:57,631 --> 00:10:01,101
<c.green>这就是高效率的</c>

199
00:09:57,631 --> 00:10:01,101
<c.green>这就是高效率的</c>

200
00:10:01,502 --> 00:10:03,504
<c.green>接下来 我想讨论watchOS</c>

201
00:10:04,538 --> 00:10:07,441
<c.green>手表上的网络应用</c>

202
00:10:07,608 --> 00:10:09,643
<c.green>对于想要在屏幕熄灭时</c>

203
00:10:09,910 --> 00:10:12,446
<c.green>你应该使用后台会话</c>

204
00:10:13,547 --> 00:10:15,782
<c.green>也应该使用它进行复杂的更新</c>

205
00:10:15,849 --> 00:10:17,684
<c.green>或后台应用刷新</c>

206
00:10:17,985 --> 00:10:21,188
<c.green>这是因为这样做</c>

207
00:10:21,355 --> 00:10:24,691
<c.green>从而执行你的网络操作</c>

208
00:10:26,994 --> 00:10:28,695
<c.green>让我们进行回顾</c>

209
00:10:29,096 --> 00:10:31,465
<c.green>首先 应该确定你要做的工作</c>

210
00:10:31,865 --> 00:10:35,068
<c.green>这保证你不会</c>

211
00:10:35,402 --> 00:10:36,737
<c.green>然后</c>

212
00:10:36,803 --> 00:10:39,706
<c.green>使用后台会话</c>

213
00:10:40,340 --> 00:10:41,808
<c.green>接下来</c>

214
00:10:41,875 --> 00:10:45,279
<c.green>批处理这些事务</c>

215
00:10:45,746 --> 00:10:48,949
<c.green>最后 减少你的工作</c>

216
00:10:49,149 --> 00:10:50,584
<c.green>和设置合适的超时来实现</c>

217
00:10:52,419 --> 00:10:54,054
<c.green>关于网络部分就是这些</c>

218
00:10:54,354 --> 00:10:57,057
<c.green>接下来 我想和你们讨论位置</c>

219
00:10:58,492 --> 00:11:02,262
<c.green>作为开发者 你们有许多位置API</c>

220
00:10:58,492 --> 00:11:02,262
<c.green>作为开发者 你们有许多位置API</c>

221
00:11:02,563 --> 00:11:05,732
<c.green>但是今天我想重点讨论</c>

222
00:11:05,799 --> 00:11:08,202
<c.green>（位置最佳实践</c>

223
00:11:08,268 --> 00:11:10,537
<c.green>假设我想要</c>

224
00:11:10,604 --> 00:11:14,208
<c.green>为我的应用添加导航功能</c>

225
00:11:15,108 --> 00:11:17,711
<c.green>为此 需要使用持续性位置更新</c>

226
00:11:18,078 --> 00:11:19,680
<c.green>其原因是我需要知道</c>

227
00:11:19,746 --> 00:11:21,548
<c.green>用户是否偏离我的路线</c>

228
00:11:22,249 --> 00:11:24,251
<c.green>让我能够为他们提供新的指令</c>

229
00:11:24,318 --> 00:11:25,786
<c.green>帮助他们到达目的地</c>

230
00:11:27,487 --> 00:11:28,922
<c.green>但需要注意的是</c>

231
00:11:29,423 --> 00:11:31,458
<c.green>这会阻止进入睡眠状态</c>

232
00:11:31,525 --> 00:11:34,228
<c.green>因此这会极大地影响电量</c>

233
00:11:35,696 --> 00:11:38,665
<c.green>因此 在用户到达目的地之后</c>

234
00:11:39,032 --> 00:11:41,835
<c.green>必须确保</c>

235
00:11:42,536 --> 00:11:44,171
<c.green>确保设备</c>

236
00:11:45,072 --> 00:11:46,874
<c.green>让我们看看应该如何做</c>

237
00:11:47,307 --> 00:11:48,775
<c.green>首先 我们创建</c>

238
00:11:49,676 --> 00:11:51,545
<c.green>然后 设置一些属性</c>

239
00:11:51,612 --> 00:11:53,580
<c.green>我想要重点讨论的属性</c>

240
00:11:53,647 --> 00:11:55,015
<c.green>是目标精度</c>

241
00:11:55,282 --> 00:11:56,917
<c.green>请认真思考你想要的精度</c>

242
00:11:56,984 --> 00:12:00,354
<c.green>因为精度越高</c>

243
00:11:56,984 --> 00:12:00,354
<c.green>因为精度越高</c>

244
00:12:01,288 --> 00:12:03,190
<c.green>因此 必须确保</c>

245
00:12:03,257 --> 00:12:04,324
<c.green>然后才进行这样的设置</c>

246
00:12:05,659 --> 00:12:09,229
<c.green>接下来</c>

247
00:12:11,398 --> 00:12:14,701
<c.green>完成之后 比如用户到达目的地时</c>

248
00:12:15,035 --> 00:12:16,570
<c.green>停止更新位置</c>

249
00:12:17,070 --> 00:12:19,540
<c.green>设备重新进入睡眠状态</c>

250
00:12:22,676 --> 00:12:24,211
<c.green>这就是连续性位置更新</c>

251
00:12:24,778 --> 00:12:26,647
<c.green>我们继续来看</c>

252
00:12:26,713 --> 00:12:28,815
<c.green>它们允许设备更频繁地睡眠</c>

253
00:12:30,017 --> 00:12:31,785
<c.green>第一个是requestLocation</c>

254
00:12:32,419 --> 00:12:35,222
<c.green>它获取用户的当前位置</c>

255
00:12:35,289 --> 00:12:39,560
<c.green>也许 你想要</c>

256
00:12:40,327 --> 00:12:43,230
<c.green>而不必担心</c>

257
00:12:43,297 --> 00:12:45,632
<c.green>和管理这些调用</c>

258
00:12:47,534 --> 00:12:49,336
<c.green>接下来 是区域监测</c>

259
00:12:49,870 --> 00:12:52,005
<c.green>区域监测让你能够</c>

260
00:12:52,072 --> 00:12:55,309
<c.green>比如说 你想要</c>

261
00:12:55,609 --> 00:12:57,244
<c.green>你不必始终跟踪他们的位置</c>

262
00:12:57,311 --> 00:13:00,214
<c.green>你可以创建一个区域</c>

263
00:12:57,311 --> 00:13:00,214
<c.green>你可以创建一个区域</c>

264
00:13:00,280 --> 00:13:02,282
<c.green>你可以让运行时</c>

265
00:13:02,349 --> 00:13:04,451
<c.green>（位置最佳实践）</c>

266
00:13:04,518 --> 00:13:06,253
<c.green>访问监测也是如此</c>

267
00:13:06,820 --> 00:13:08,088
<c.green>访问监测让你知道</c>

268
00:13:08,155 --> 00:13:10,324
<c.green>用户何时去经常前往的位置</c>

269
00:13:10,858 --> 00:13:12,693
<c.green>在那个时间</c>

270
00:13:12,759 --> 00:13:15,162
<c.green>而不必持续地</c>

271
00:13:17,064 --> 00:13:18,665
<c.green>可以进行下面的设置</c>

272
00:13:20,767 --> 00:13:22,569
<c.green>最后 还有显著位置变化</c>

273
00:13:23,136 --> 00:13:26,139
<c.green>可以使用显著位置变化功能</c>

274
00:13:26,406 --> 00:13:28,575
<c.green>用户的物理位置</c>

275
00:13:28,942 --> 00:13:30,711
<c.green>而不想使用持续性位置功能</c>

276
00:13:30,777 --> 00:13:33,514
<c.green>因为持续性位置更新</c>

277
00:13:35,182 --> 00:13:38,151
<c.green>显著位置变化功能</c>

278
00:13:38,318 --> 00:13:40,220
<c.green>设备可以在更新间隙睡眠</c>

279
00:13:40,888 --> 00:13:42,456
<c.green>你可以进行一些很好的优化</c>

280
00:13:42,756 --> 00:13:44,291
<c.green>如果你想要从持续性位置转变为</c>

281
00:13:44,358 --> 00:13:45,592
<c.green>显著位置变化</c>

282
00:13:45,893 --> 00:13:47,528
<c.green>来看一个例子</c>

283
00:13:47,761 --> 00:13:49,429
<c.green>需要知道</c>

284
00:13:49,496 --> 00:13:51,198
<c.green>然后在这些时间更新天气信息</c>

285
00:13:52,499 --> 00:13:53,867
<c.green>你可以进行这样的设置</c>

286
00:13:56,436 --> 00:13:59,072
<c.green>总的来说</c>

287
00:13:59,139 --> 00:14:00,474
<c.green>想要的精度水平</c>

288
00:13:59,139 --> 00:14:00,474
<c.green>想要的精度水平</c>

289
00:14:00,707 --> 00:14:02,843
<c.green>认真思考是否确实需要高精度</c>

290
00:14:02,910 --> 00:14:04,611
<c.green>如果不需要 则可以使用较低精度</c>

291
00:14:05,379 --> 00:14:07,214
<c.green>接下来 应该优化你的工作</c>

292
00:14:07,281 --> 00:14:09,316
<c.green>尽可能使用不同于</c>

293
00:14:09,550 --> 00:14:11,285
<c.green>持续性位置更新的其它方案</c>

294
00:14:12,286 --> 00:14:14,388
<c.green>然后 需要减少工作量</c>

295
00:14:14,621 --> 00:14:16,857
<c.green>在完成工作之后</c>

296
00:14:17,291 --> 00:14:19,893
<c.green>同样地 如果保持位置更新</c>

297
00:14:19,960 --> 00:14:21,261
<c.green>设备就不能进入睡眠状态</c>

298
00:14:22,129 --> 00:14:26,066
<c.green>最后 需要合并</c>

299
00:14:26,133 --> 00:14:27,968
<c.green>也许以后你需要这些位置</c>

300
00:14:28,368 --> 00:14:30,037
<c.green>虽然你现在可能不需要</c>

301
00:14:31,538 --> 00:14:32,673
<c.green>关于位置就是这些</c>

302
00:14:33,574 --> 00:14:35,175
<c.green>接下来 我们讨论图形</c>

303
00:14:35,742 --> 00:14:37,845
<c.green>图形可能会消耗很多的电量</c>

304
00:14:39,546 --> 00:14:41,481
<c.green>下面介绍一些良好的指导原则</c>

305
00:14:42,149 --> 00:14:44,585
<c.green>首先 需要最大限度减少屏幕更新</c>

306
00:14:45,319 --> 00:14:47,821
<c.green>确保为用户提供</c>

307
00:14:49,256 --> 00:14:50,958
<c.green>接下来</c>

308
00:14:51,291 --> 00:14:53,260
<c.green>不要在经常更新的元素上</c>

309
00:14:53,327 --> 00:14:55,963
<c.green>因为这会耗用大量的电池电量</c>

310
00:14:57,130 --> 00:14:58,432
<c.green>因此应该引起注意</c>

311
00:15:00,033 --> 00:15:01,535
<c.green>这是一般性指导原则</c>

312
00:15:01,602 --> 00:15:03,570
<c.green>让我们重点讨论Mac上的应用</c>

313
00:15:04,238 --> 00:15:07,074
<c.green>如果在Mac上开发应用</c>

314
00:15:07,140 --> 00:15:10,844
<c.green>一些MacBook配备独立GPU</c>

315
00:15:11,078 --> 00:15:14,882
<c.green>能够为用户呈现精美的图形</c>

316
00:15:15,048 --> 00:15:18,418
<c.green>但是相比集成GPU</c>

317
00:15:19,386 --> 00:15:22,923
<c.green>因此 你必须确保只有集成GPU无法</c>

318
00:15:22,990 --> 00:15:26,894
<c.green>满足你的动画图形性能要求时</c>

319
00:15:27,327 --> 00:15:29,563
<c.green>你需要的功能时</c>

320
00:15:31,865 --> 00:15:34,401
<c.green>另外 如果在Mac上进行开发</c>

321
00:15:34,635 --> 00:15:37,337
<c.green>可能需要使用</c>

322
00:15:38,005 --> 00:15:40,507
<c.green>如果使用Metal</c>

323
00:15:40,574 --> 00:15:42,609
<c.green>调用Create</c>

324
00:15:42,676 --> 00:15:45,579
<c.green>将会自动触发独立GPU</c>

325
00:15:46,413 --> 00:15:48,182
<c.green>因此 如果不需要独立GPU</c>

326
00:15:48,248 --> 00:15:51,151
<c.green>可以调用</c>

327
00:15:51,552 --> 00:15:53,220
<c.green>功耗水平较低的设备</c>

328
00:15:53,787 --> 00:15:57,191
<c.green>这将确保在必要时</c>

329
00:15:59,426 --> 00:16:01,662
<c.green>对于使用OpenGL的开发人员</c>

330
00:15:59,426 --> 00:16:01,662
<c.green>对于使用OpenGL的开发人员</c>

331
00:16:02,196 --> 00:16:04,698
<c.green>需要确保你的应用支持多路转换</c>

332
00:16:05,332 --> 00:16:08,202
<c.green>因此应设置Automatic</c>

333
00:16:08,268 --> 00:16:12,306
<c.green>可在Info.plist中设置</c>

334
00:16:12,372 --> 00:16:13,240
<c.green>（图形）</c>

335
00:16:13,674 --> 00:16:14,975
<c.green>原因是</c>

336
00:16:15,209 --> 00:16:19,179
<c.green>如果不需要独立GPU</c>

337
00:16:19,880 --> 00:16:23,317
<c.green>在设置这个属性之后</c>

338
00:16:25,886 --> 00:16:29,122
<c.green>总结</c>

339
00:16:29,189 --> 00:16:31,892
<c.green>所要完成的工作</c>

340
00:16:32,192 --> 00:16:34,761
<c.green>应确保不在经常更新的元素上使用虚化</c>

341
00:16:35,329 --> 00:16:36,830
<c.green>接下来 应该优化你的工作</c>

342
00:16:37,464 --> 00:16:38,699
<c.green>如果在Mac上开发</c>

343
00:16:38,765 --> 00:16:41,201
<c.green>应确保仅在需要提供</c>

344
00:16:41,268 --> 00:16:43,971
<c.green>优异图形性能时</c>

345
00:16:44,505 --> 00:16:45,506
<c.green>最后</c>

346
00:16:45,572 --> 00:16:48,675
<c.green>应尽可能减少屏幕更新</c>

347
00:16:49,977 --> 00:16:51,044
<c.green>关于图形就是这些</c>

348
00:16:51,278 --> 00:16:53,380
<c.green>接下来 我们讨论处理</c>

349
00:16:53,447 --> 00:16:56,216
<c.green>同样地 处理也会耗用很多电量</c>

350
00:16:58,619 --> 00:17:00,721
<c.green>下面是一些指导原则</c>

351
00:16:58,619 --> 00:17:00,721
<c.green>下面是一些指导原则</c>

352
00:17:01,021 --> 00:17:04,156
<c.green>首先 你需要确定必须完成哪些任务</c>

353
00:17:05,125 --> 00:17:07,895
<c.green>接下来 应该快速且高效率地完成任务</c>

354
00:17:07,961 --> 00:17:09,530
<c.green>在确定这些任务之后</c>

355
00:17:10,396 --> 00:17:12,566
<c.green>还应该尽可能地避免使用计时器</c>

356
00:17:12,633 --> 00:17:14,867
<c.green>应该在用户交互的基础上执行工作</c>

357
00:17:15,102 --> 00:17:17,771
<c.green>而不是反复地使用固定的计时器</c>

358
00:17:18,672 --> 00:17:20,840
<c.green>如果确实需要使用计时器</c>

359
00:17:20,907 --> 00:17:24,044
<c.green>让尝试设置较长的间隙让系统</c>

360
00:17:24,111 --> 00:17:25,878
<c.green>将计时器与其它工作合并</c>

361
00:17:27,513 --> 00:17:29,750
<c.green>这是一些基本的处理指导原则</c>

362
00:17:29,816 --> 00:17:32,586
<c.green>今天 我想重点讨论后台处理</c>

363
00:17:33,387 --> 00:17:36,857
<c.green>对于用户来说 后台处理</c>

364
00:17:37,090 --> 00:17:39,960
<c.green>必须思考应该在后台做什么</c>

365
00:17:40,027 --> 00:17:44,097
<c.green>主要原因是</c>

366
00:17:44,765 --> 00:17:46,166
<c.green>他们看到的只是应用的前台</c>

367
00:17:46,233 --> 00:17:49,603
<c.green>因此 如果后台占用一些资源</c>

368
00:17:49,670 --> 00:17:51,839
<c.green>但是 如果后台占用大量的资源</c>

369
00:17:52,272 --> 00:17:54,374
<c.green>将会降低用户体验</c>

370
00:17:54,441 --> 00:17:55,742
<c.green>（后台处理）</c>

371
00:17:55,809 --> 00:17:58,512
<c.green>这里是一些一般性指导原则</c>

372
00:17:59,112 --> 00:18:02,049
<c.green>首先 我们需要尽可能快地完成工作</c>

373
00:17:59,112 --> 00:18:02,049
<c.green>首先 我们需要尽可能快地完成工作</c>

374
00:18:02,349 --> 00:18:05,185
<c.green>首先思考 “我真的</c>

375
00:18:05,252 --> 00:18:07,621
<c.green>如果是 应该找到</c>

376
00:18:08,088 --> 00:18:10,224
<c.green>接下来 如果想要更新内容</c>

377
00:18:10,524 --> 00:18:12,993
<c.green>应尝试使用后台程序刷新API</c>

378
00:18:13,660 --> 00:18:16,864
<c.green>这将帮助你找到</c>

379
00:18:17,931 --> 00:18:21,435
<c.green>最后 应该确保</c>

380
00:18:21,602 --> 00:18:23,337
<c.green>无论你使用哪个API</c>

381
00:18:23,570 --> 00:18:26,840
<c.green>这将确保设备</c>

382
00:18:26,907 --> 00:18:29,276
<c.green>而不会继续占用资源不放</c>

383
00:18:32,079 --> 00:18:34,348
<c.green>iOS 11中的新功能：</c>

384
00:18:34,414 --> 00:18:37,451
<c.green>这是PushKit API中</c>

385
00:18:37,885 --> 00:18:41,221
<c.green>它允许设备</c>

386
00:18:41,288 --> 00:18:43,824
<c.green>在处理你的</c>

387
00:18:44,791 --> 00:18:47,828
<c.green>如果使用PushKit</c>

388
00:18:48,962 --> 00:18:50,797
<c.green>让我们来看一个例子</c>

389
00:18:51,498 --> 00:18:55,035
<c.green>在这里看到 我没有调用</c>

390
00:18:55,102 --> 00:18:56,837
<c.green>在这个例子中 当我接收</c>

391
00:18:56,904 --> 00:18:59,873
<c.green>仅进行一些处理</c>

392
00:18:59,940 --> 00:19:02,176
<c.green>让设备进入睡眠状态</c>

393
00:18:59,940 --> 00:19:02,176
<c.green>让设备进入睡眠状态</c>

394
00:19:03,844 --> 00:19:08,015
<c.green>现在 让我们来看看</c>

395
00:19:08,482 --> 00:19:11,518
<c.green>通过调用completion处理程序</c>

396
00:19:11,585 --> 00:19:14,621
<c.green>更快地进入睡眠状态</c>

397
00:19:14,688 --> 00:19:17,724
<c.green>后台工作耗用的电量而且节省开销</c>

398
00:19:18,392 --> 00:19:22,429
<c.green>如果使用PushKit</c>

399
00:19:22,496 --> 00:19:23,797
<c.green>（使用COMPLETION处理程序）</c>

400
00:19:24,965 --> 00:19:28,068
<c.green>让我们来看看</c>

401
00:19:28,135 --> 00:19:31,672
<c.green>后台导航模式是一种新技术</c>

402
00:19:32,206 --> 00:19:35,776
<c.green>与Watch的其它后台模式一样</c>

403
00:19:36,743 --> 00:19:39,379
<c.green>此外 如果确实想要保证尽量减少</c>

404
00:19:39,446 --> 00:19:42,482
<c.green>这种后台模式下的网络操作</c>

405
00:19:42,683 --> 00:19:48,488
<c.green>请认真地思考 我真的需要这样做吗</c>

406
00:19:48,555 --> 00:19:50,457
<c.green>我做的这些网络更新吗</c>

407
00:19:51,625 --> 00:19:53,961
<c.green>也许 这适用于流量重路由</c>

408
00:19:54,628 --> 00:19:56,563
<c.green>或重要的流量信息</c>

409
00:19:57,631 --> 00:20:01,168
<c.green>最后 应使用后台应用刷新</c>

410
00:19:57,631 --> 00:20:01,168
<c.green>最后 应使用后台应用刷新</c>

411
00:20:01,235 --> 00:20:02,402
<c.green>来更新你的数据</c>

412
00:20:02,703 --> 00:20:06,373
<c.green>当你使用这些API时</c>

413
00:20:06,440 --> 00:20:08,308
<c.green>以获取数据</c>

414
00:20:08,375 --> 00:20:11,378
<c.green>这样就不必等待数据进来</c>

415
00:20:13,313 --> 00:20:14,581
<c.green>总结</c>

416
00:20:14,848 --> 00:20:17,584
<c.green>首先 你应该确定</c>

417
00:20:17,651 --> 00:20:22,656
<c.green>必须确保后台进程</c>

418
00:20:23,557 --> 00:20:26,393
<c.green>因此需要使用后台程序刷新来</c>

419
00:20:26,460 --> 00:20:27,628
<c.green>应该尽可能这样做</c>

420
00:20:28,795 --> 00:20:31,098
<c.green>接下来 通过限制事务数量来减少</c>

421
00:20:31,164 --> 00:20:32,199
<c.green>后台处理工作量</c>

422
00:20:33,166 --> 00:20:36,170
<c.green>最后 应尽可能使用后台会话</c>

423
00:20:38,805 --> 00:20:41,508
<c.green>接下来 我的同事</c>

424
00:20:41,575 --> 00:20:44,745
<c.green>一些可用的节能工具</c>

425
00:20:48,081 --> 00:20:49,249
<c.green>谢谢 丹尼尔</c>

426
00:20:52,186 --> 00:20:55,022
<c.green>大家早上好</c>

427
00:20:55,322 --> 00:20:56,890
<c.green>是电量管理团队的工程师</c>

428
00:20:58,492 --> 00:21:02,396
<c.green>你们已经了解编写</c>

429
00:20:58,492 --> 00:21:02,396
<c.green>你们已经了解编写</c>

430
00:21:03,330 --> 00:21:06,533
<c.green>现在我将介绍一些电量调试工具</c>

431
00:21:06,600 --> 00:21:07,801
<c.green>它们是我们自己开发的</c>

432
00:21:08,569 --> 00:21:10,771
<c.green>我们将了解如何使用这些工具</c>

433
00:21:11,071 --> 00:21:15,175
<c.green>来评估应用的节能效率或电量影响</c>

434
00:21:16,210 --> 00:21:19,413
<c.green>这些工具将帮助你们找到</c>

435
00:21:19,479 --> 00:21:21,748
<c.green>与电量相关的高层次问题</c>

436
00:21:22,482 --> 00:21:25,886
<c.green>或主要的问题方面</c>

437
00:21:26,920 --> 00:21:28,789
<c.green>最后</c>

438
00:21:29,122 --> 00:21:33,327
<c.green>我会使用一些示例应用</c>

439
00:21:33,560 --> 00:21:38,065
<c.green>进行调试以发现电量问题</c>

440
00:21:38,131 --> 00:21:40,267
<c.green>以便于你调试自己的应用</c>

441
00:21:41,768 --> 00:21:45,639
<c.green>首先 让我们来看</c>

442
00:21:46,673 --> 00:21:50,277
<c.green>假设你开发了一个很不错的应用</c>

443
00:21:50,344 --> 00:21:52,179
<c.green>但并没有评估</c>

444
00:21:52,913 --> 00:21:56,583
<c.green>结果发现 这个应用的电量影响非常高</c>

445
00:21:56,984 --> 00:21:59,586
<c.green>即使只使用了很短的时间</c>

446
00:22:00,654 --> 00:22:04,525
<c.green>自然地 电量管理界面会将这个应用</c>

447
00:22:04,591 --> 00:22:06,527
<c.green>标注为最耗电的程序</c>

448
00:22:07,027 --> 00:22:11,164
<c.green>使用这个应用的用户发现</c>

449
00:22:11,231 --> 00:22:14,434
<c.green>你的应用耗用了很多的电量</c>

450
00:22:15,202 --> 00:22:18,605
<c.green>用户很可能会删除你的应用</c>

451
00:22:18,805 --> 00:22:21,308
<c.green>这绝对是你不愿意看到的</c>

452
00:22:21,375 --> 00:22:22,276
<c.green>（设置：电量）</c>

453
00:22:22,342 --> 00:22:24,845
<c.green>作为应用开发者很重要的一点是</c>

454
00:22:24,912 --> 00:22:28,115
<c.green>评估应用的电量使用效率</c>

455
00:22:28,282 --> 00:22:29,550
<c.green>或电量影响</c>

456
00:22:30,651 --> 00:22:32,619
<c.green>为了帮助你们进行评估</c>

457
00:22:32,920 --> 00:22:35,556
<c.green>我们推出经过改进的</c>

458
00:22:36,323 --> 00:22:40,093
<c.green>这些工具是Xcode的组成部分</c>

459
00:22:41,428 --> 00:22:45,032
<c.green>Energy Gauges设计用于</c>

460
00:22:45,332 --> 00:22:48,368
<c.green>显示应用的所有电量相关问题</c>

461
00:22:49,036 --> 00:22:52,339
<c.green>它们将会告诉你</c>

462
00:22:53,373 --> 00:22:56,577
<c.green>还指导你使用正确的方法</c>

463
00:22:56,743 --> 00:23:01,248
<c.green>深入研究这些问题区域解决这些问题</c>

464
00:22:56,743 --> 00:23:01,248
<c.green>深入研究这些问题区域解决这些问题</c>

465
00:23:02,983 --> 00:23:06,220
<c.green>那么 可以在Xcode内哪个位置</c>

466
00:23:07,120 --> 00:23:09,356
<c.green>使用XCode</c>

467
00:23:10,090 --> 00:23:11,792
<c.green>点击排除故障导航栏</c>

468
00:23:12,726 --> 00:23:16,864
<c.green>一系列的性能计量表</c>

469
00:23:17,898 --> 00:23:22,503
<c.green>这些是系统基本指标</c>

470
00:23:22,836 --> 00:23:24,671
<c.green>网络和磁盘等</c>

471
00:23:25,472 --> 00:23:29,943
<c.green>在iOS和macOS中</c>

472
00:23:31,178 --> 00:23:33,680
<c.green>点击这个电量影响计量表时</c>

473
00:23:34,081 --> 00:23:37,317
<c.green>电量报告将在屏幕右侧打开</c>

474
00:23:38,452 --> 00:23:41,188
<c.green>让我们来看这个报告的各个部分</c>

475
00:23:41,588 --> 00:23:42,990
<c.green>（平均电量影响）</c>

476
00:23:43,223 --> 00:23:45,425
<c.green>在报告的左上角</c>

477
00:23:45,859 --> 00:23:50,364
<c.green>你会看到一个值</c>

478
00:23:50,597 --> 00:23:53,133
<c.green>或总体耗电评分</c>

479
00:23:54,468 --> 00:23:55,536
<c.green>旁边有一个</c>

480
00:23:56,236 --> 00:23:58,639
<c.green>计量表</c>

481
00:23:58,805 --> 00:24:02,576
<c.green>绿色、黄色和红色区域</c>

482
00:23:58,805 --> 00:24:02,576
<c.green>绿色、黄色和红色区域</c>

483
00:24:02,643 --> 00:24:05,245
<c.green>高和极高电量影响</c>

484
00:24:06,146 --> 00:24:09,082
<c.green>这个报告的坏消息是</c>

485
00:24:09,283 --> 00:24:12,586
<c.green>正在调试的这个应用</c>

486
00:24:12,653 --> 00:24:14,788
<c.green>具有高平均电量影响</c>

487
00:24:15,956 --> 00:24:19,193
<c.green>好消息是对你的应用</c>

488
00:24:19,259 --> 00:24:21,929
<c.green>进行改进或优化时</c>

489
00:24:21,995 --> 00:24:24,298
<c.green>这个计量表让你知道</c>

490
00:24:24,364 --> 00:24:25,465
<c.green>是否朝正确方向发展</c>

491
00:24:25,632 --> 00:24:28,535
<c.green>也就是说 指针应该位于绿色区域</c>

492
00:24:28,836 --> 00:24:31,238
<c.green>也会指示是否在朝错误方向发展</c>

493
00:24:31,305 --> 00:24:33,307
<c.green>即极高</c>

494
00:24:34,308 --> 00:24:37,978
<c.green>如果你的应用位于</c>

495
00:24:38,045 --> 00:24:39,379
<c.green>或高影响区域</c>

496
00:24:39,880 --> 00:24:42,616
<c.green>你应该查看</c>

497
00:24:42,816 --> 00:24:45,052
<c.green>报告右上角的饼图</c>

498
00:24:45,118 --> 00:24:46,119
<c.green>（各组件平均耗电量）</c>

499
00:24:46,186 --> 00:24:50,424
<c.green>这个屏图告诉你</c>

500
00:24:50,858 --> 00:24:54,561
<c.green>在iOS上的平均耗电量</c>

501
00:24:54,895 --> 00:24:56,763
<c.green>前面丹尼尔已经讲过</c>

502
00:24:57,998 --> 00:24:59,132
<c.green>你应该问自己</c>

503
00:24:59,466 --> 00:25:06,206
<c.green>你的应用真需占用这么多</c>

504
00:24:59,466 --> 00:25:06,206
<c.green>你的应用真需占用这么多</c>

505
00:25:07,274 --> 00:25:09,209
<c.green>你可以消除</c>

506
00:25:09,276 --> 00:25:12,312
<c.green>应用不必要处理的工作</c>

507
00:25:13,080 --> 00:25:15,649
<c.green>你的应用可能存在某些漏洞</c>

508
00:25:15,916 --> 00:25:18,352
<c.green>让一些硬件始终保持运行</c>

509
00:25:18,519 --> 00:25:21,054
<c.green>从而产生严重的电量影响</c>

510
00:25:22,189 --> 00:25:23,323
<c.green>举例来说</c>

511
00:25:23,657 --> 00:25:26,059
<c.green>假设你开发一个游戏应用</c>

512
00:25:26,360 --> 00:25:28,762
<c.green>它仅使用CPU和GPU</c>

513
00:25:29,263 --> 00:25:33,734
<c.green>而且仅需要极少的位置服务</c>

514
00:25:33,800 --> 00:25:35,569
<c.green>应用访问用户的位置</c>

515
00:25:36,336 --> 00:25:39,907
<c.green>但是 如果在电量报告中</c>

516
00:25:39,973 --> 00:25:42,576
<c.green>位置服务的使用频率非常高</c>

517
00:25:42,776 --> 00:25:45,612
<c.green>这可能表明应用存在漏洞</c>

518
00:25:45,812 --> 00:25:48,248
<c.green>而持续性地访问位置</c>

519
00:25:48,649 --> 00:25:52,152
<c.green>造成过多的电量流失</c>

520
00:25:53,720 --> 00:25:56,823
<c.green>在消除应用中</c>

521
00:25:56,890 --> 00:26:00,894
<c.green>接下来你应该针对饼图中</c>

522
00:25:56,890 --> 00:26:00,894
<c.green>接下来你应该针对饼图中</c>

523
00:26:00,961 --> 00:26:04,631
<c.green>耗电量明显过高或</c>

524
00:26:05,499 --> 00:26:07,201
<c.green>在这个例子中</c>

525
00:26:07,835 --> 00:26:11,038
<c.green>我们看到红色区域表示开销</c>

526
00:26:11,104 --> 00:26:12,873
<c.green>是饼图中耗电量最大的部分</c>

527
00:26:13,774 --> 00:26:17,878
<c.green>我们知道 开销是无线电和</c>

528
00:26:17,945 --> 00:26:22,049
<c.green>应用需要的所有其它系统硬件</c>

529
00:26:22,115 --> 00:26:23,951
<c.green>所耗用的电量</c>

530
00:26:24,852 --> 00:26:27,955
<c.green>这似乎是正确的</c>

531
00:26:28,021 --> 00:26:30,357
<c.green>还使用网络组件</c>

532
00:26:31,024 --> 00:26:33,360
<c.green>网络将会启动无线电</c>

533
00:26:33,527 --> 00:26:36,230
<c.green>这将长时间耗用电量</c>

534
00:26:37,297 --> 00:26:41,235
<c.green>因此 在本例中</c>

535
00:26:41,869 --> 00:26:44,071
<c.green>请尝试尽可能地批处理应用中的</c>

536
00:26:44,137 --> 00:26:48,175
<c.green>所有网络活动从而降低网络</c>

537
00:26:48,242 --> 00:26:51,178
<c.green>的耗电量以及因此产生的</c>

538
00:26:51,245 --> 00:26:52,679
<c.green>相关开销</c>

539
00:26:54,481 --> 00:26:56,717
<c.green>知道应该优化哪个主要组件</c>

540
00:26:56,783 --> 00:27:00,320
<c.green>或者改进应用的哪个部分之后</c>

541
00:26:56,783 --> 00:27:00,320
<c.green>或者改进应用的哪个部分之后</c>

542
00:27:01,321 --> 00:27:03,457
<c.green>应该查看分区条形图</c>

543
00:27:03,524 --> 00:27:05,626
<c.green>或报告的即时区域</c>

544
00:27:05,692 --> 00:27:06,593
<c.green>（电量影响）</c>

545
00:27:06,760 --> 00:27:08,729
<c.green>此区域每秒更新一次</c>

546
00:27:09,830 --> 00:27:11,231
<c.green>因此很容易发现</c>

547
00:27:11,298 --> 00:27:15,836
<c.green>你的应用的耗电量是否一直正常</c>

548
00:27:16,737 --> 00:27:19,573
<c.green>因此 在使用Energy Gauge</c>

549
00:27:19,640 --> 00:27:22,876
<c.green>当你执行某些操作或方案时</c>

550
00:27:23,377 --> 00:27:28,749
<c.green>在这里可以看到</c>

551
00:27:29,149 --> 00:27:32,753
<c.green>哪些不同的组件在产生工作负荷</c>

552
00:27:34,087 --> 00:27:37,891
<c.green>这个区域告诉你</c>

553
00:27:37,958 --> 00:27:41,628
<c.green>或后台运行时</c>

554
00:27:41,862 --> 00:27:43,130
<c.green>是否产生工作负荷</c>

555
00:27:43,997 --> 00:27:47,501
<c.green>在这里 你可以核实</c>

556
00:27:47,734 --> 00:27:51,805
<c.green>尽可能少在后台处理工作</c>

557
00:27:51,872 --> 00:27:53,073
<c.green>或者不处理工作</c>

558
00:27:53,140 --> 00:27:55,576
<c.green>而且当应用在后台运行时</c>

559
00:27:55,776 --> 00:27:57,678
<c.green>挂起状态</c>

560
00:27:59,446 --> 00:28:03,383
<c.green>如果点击这些条图中的任何一个</c>

561
00:27:59,446 --> 00:28:03,383
<c.green>如果点击这些条图中的任何一个</c>

562
00:28:03,617 --> 00:28:07,921
<c.green>将会细详地描述</c>

563
00:28:07,988 --> 00:28:08,856
<c.green>（后台）</c>

564
00:28:09,089 --> 00:28:12,993
<c.green>参考这个区域很容易发现</c>

565
00:28:13,060 --> 00:28:17,030
<c.green>在你的应用中</c>

566
00:28:18,065 --> 00:28:21,502
<c.green>在这个例子中</c>

567
00:28:21,568 --> 00:28:25,005
<c.green>进行网络活动</c>

568
00:28:25,072 --> 00:28:27,941
<c.green>导致网络影响</c>

569
00:28:28,008 --> 00:28:29,309
<c.green>开销影响</c>

570
00:28:29,710 --> 00:28:33,380
<c.green>这个例子很好地告诉你</c>

571
00:28:33,580 --> 00:28:36,917
<c.green>这将会降低应用的电量影响</c>

572
00:28:39,920 --> 00:28:43,223
<c.green>在报告底部显示在iOS上</c>

573
00:28:43,290 --> 00:28:47,027
<c.green>耗用电量的不同组件的信息</c>

574
00:28:47,294 --> 00:28:50,230
<c.green>并提供一些有用的提示</c>

575
00:28:50,297 --> 00:28:53,867
<c.green>各个组件的电量影响</c>

576
00:28:55,402 --> 00:28:59,473
<c.green>这些提示的右边有一些按钮</c>

577
00:29:00,340 --> 00:29:02,709
<c.green>比如 在Energy Gauge报告中</c>

578
00:29:02,776 --> 00:29:07,548
<c.green>你应用的CPU占用率是最高的</c>

579
00:29:07,948 --> 00:29:10,684
<c.green>你想对此进行优化</c>

580
00:29:11,218 --> 00:29:13,954
<c.green>你可以点击Time Profiler仪表</c>

581
00:29:14,354 --> 00:29:18,492
<c.green>调试会话将会</c>

582
00:29:18,559 --> 00:29:19,860
<c.green>（仪表）</c>

583
00:29:19,927 --> 00:29:24,131
<c.green>Time Profiler观察进程中的</c>

584
00:29:24,398 --> 00:29:28,202
<c.green>以固定的间隔生成样本</c>

585
00:29:28,769 --> 00:29:32,239
<c.green>可以完成向后追溯所有这些样本</c>

586
00:29:32,306 --> 00:29:36,176
<c.green>可以在Extended View区域中</c>

587
00:29:37,110 --> 00:29:40,280
<c.green>这可以帮助你弄清楚应用中的</c>

588
00:29:40,347 --> 00:29:44,618
<c.green>哪些代码行大量地占用CPU时间</c>

589
00:29:44,885 --> 00:29:47,788
<c.green>应用中的哪些部分占用最多CPU时间</c>

590
00:29:48,222 --> 00:29:52,159
<c.green>应用中的哪些函数</c>

591
00:29:52,392 --> 00:29:55,128
<c.green>这样你可以优化这部分代码</c>

592
00:29:55,562 --> 00:29:58,899
<c.green>然后使用Energy Gauges</c>

593
00:30:00,934 --> 00:30:05,772
<c.green>同样地 如果Energy Gauges报告</c>

594
00:30:05,839 --> 00:30:10,077
<c.green>那么应该针对这个问题进行优化</c>

595
00:30:10,410 --> 00:30:12,946
<c.green>你可以点击Location Profiler</c>

596
00:30:13,847 --> 00:30:16,817
<c.green>它将告诉你哪些代码块</c>

597
00:30:16,884 --> 00:30:19,987
<c.green>访问了核心位置管理器</c>

598
00:30:21,054 --> 00:30:24,358
<c.green>你还可以看到</c>

599
00:30:24,424 --> 00:30:29,296
<c.green>以及这些调用</c>

600
00:30:30,030 --> 00:30:31,832
<c.green>在这个例子中</c>

601
00:30:31,899 --> 00:30:36,203
<c.green>应用中的代码不断地</c>

602
00:30:36,470 --> 00:30:40,440
<c.green>而且使用最高的精度要求</c>

603
00:30:40,507 --> 00:30:43,410
<c.green>会产生极高的电量影响</c>

604
00:30:44,411 --> 00:30:46,647
<c.green>而且也很容易发现你是否</c>

605
00:30:46,713 --> 00:30:49,116
<c.green>在系统中留下任何漏洞</c>

606
00:30:49,483 --> 00:30:53,620
<c.green>也就是说 所有这些</c>

607
00:30:54,888 --> 00:30:57,925
<c.green>还可以尝试采用最佳实践方法</c>

608
00:30:58,192 --> 00:31:02,262
<c.green>在应用中尽可能地使用较低的精度</c>

609
00:30:58,192 --> 00:31:02,262
<c.green>在应用中尽可能地使用较低的精度</c>

610
00:31:02,329 --> 00:31:05,432
<c.green>从而降低由此产生的电量影响</c>

611
00:31:08,635 --> 00:31:10,771
<c.green>现在我们已经熟悉</c>

612
00:31:10,838 --> 00:31:14,141
<c.green>多个不同的电量管理调试工具</c>

613
00:31:14,608 --> 00:31:19,046
<c.green>让我们来看一些方案</c>

614
00:31:19,112 --> 00:31:21,481
<c.green>电量问题时</c>

615
00:31:22,583 --> 00:31:26,286
<c.green>有一些方案可能适用于所有的程序</c>

616
00:31:26,653 --> 00:31:29,857
<c.green>例如 这是一个启动和空闲方案</c>

617
00:31:29,923 --> 00:31:33,560
<c.green>无论用户是否启动应用而不进行交互</c>

618
00:31:34,261 --> 00:31:36,363
<c.green>第二个是后台运行方案</c>

619
00:31:37,130 --> 00:31:40,400
<c.green>应该尝试使用Energy Gauges</c>

620
00:31:40,467 --> 00:31:42,903
<c.green>并且查看在你的应用上</c>

621
00:31:42,970 --> 00:31:46,607
<c.green>执行这些操作</c>

622
00:31:48,008 --> 00:31:52,379
<c.green>接下来 根据你开发的应用的类型</c>

623
00:31:52,446 --> 00:31:55,349
<c.green>还有一些应用专用的特定方案</c>

624
00:31:56,016 --> 00:31:59,386
<c.green>例如 如果开发导航应用</c>

625
00:31:59,853 --> 00:32:03,023
<c.green>一些专门用于你的应用的方案</c>

626
00:31:59,853 --> 00:32:03,023
<c.green>一些专门用于你的应用的方案</c>

627
00:32:03,423 --> 00:32:06,693
<c.green>将会查找特定位置或地址</c>

628
00:32:07,160 --> 00:32:09,663
<c.green>然后获取该地址的方向</c>

629
00:32:09,730 --> 00:32:12,566
<c.green>导航到那个特定的位置</c>

630
00:32:13,667 --> 00:32:18,906
<c.green>因此应该在Energy Gauges上</c>

631
00:32:18,972 --> 00:32:21,275
<c.green>了解相应的电量影响</c>

632
00:32:21,909 --> 00:32:25,045
<c.green>在发现主要的电量相关问题之后</c>

633
00:32:25,112 --> 00:32:27,514
<c.green>进行改进或优化</c>

634
00:32:27,781 --> 00:32:31,018
<c.green>然后返回这些方案</c>

635
00:32:31,084 --> 00:32:34,955
<c.green>告诉你电量影响</c>

636
00:32:36,223 --> 00:32:40,093
<c.green>关于这一点</c>

637
00:32:40,160 --> 00:32:42,663
<c.green>在相同的示例应用上</c>

638
00:32:42,863 --> 00:32:45,332
<c.green>从而确立一个调试流程</c>

639
00:32:45,399 --> 00:32:47,668
<c.green>你可以用它调试自己的应用</c>

640
00:32:53,841 --> 00:32:58,212
<c.green>我要调试的</c>

641
00:32:59,146 --> 00:33:02,783
<c.green>我在设备上使用Xcode</c>

642
00:32:59,146 --> 00:33:02,783
<c.green>我在设备上使用Xcode</c>

643
00:33:03,984 --> 00:33:06,386
<c.green>这是我们开发的一个简单游戏</c>

644
00:33:06,987 --> 00:33:10,858
<c.green>我们希望游戏仅使用CPU和GPU</c>

645
00:33:12,125 --> 00:33:17,231
<c.green>我点击Debug Navigator</c>

646
00:33:18,432 --> 00:33:20,968
<c.green>这是我们将要执行的第一个方案</c>

647
00:33:21,034 --> 00:33:22,903
<c.green>它是启动与空闲方案</c>

648
00:33:23,604 --> 00:33:26,273
<c.green>你希望看到在应用上执行这个操作</c>

649
00:33:26,340 --> 00:33:29,276
<c.green>将会产生什么样的电量影响</c>

650
00:33:30,377 --> 00:33:35,182
<c.green>在这里 我们看到</c>

651
00:33:35,415 --> 00:33:37,684
<c.green>因为它具有较高的平均电量影响</c>

652
00:33:38,552 --> 00:33:42,289
<c.green>接下来 我们想要查看</c>

653
00:33:42,789 --> 00:33:45,993
<c.green>不出所料</c>

654
00:33:46,059 --> 00:33:49,062
<c.green>没有使用其它不必要的组件 这很不错</c>

655
00:33:49,963 --> 00:33:53,667
<c.green>接下来 我们来看</c>

656
00:33:53,734 --> 00:33:55,869
<c.green>我们首先</c>

657
00:33:56,770 --> 00:34:02,209
<c.green>我们看到GPU占用率</c>

658
00:33:56,770 --> 00:34:02,209
<c.green>我们看到GPU占用率</c>

659
00:34:02,543 --> 00:34:06,346
<c.green>因此 如果你在应用中</c>

660
00:34:06,413 --> 00:34:09,917
<c.green>对GPU占用率进行优化</c>

661
00:34:09,983 --> 00:34:12,252
<c.green>将会获得最好的结果</c>

662
00:34:13,253 --> 00:34:16,123
<c.green>在这里 你可以使用的一些</c>

663
00:34:16,690 --> 00:34:19,159
<c.green>最佳实践方法</c>

664
00:34:19,226 --> 00:34:25,699
<c.green>或检查虚化效果使用情况</c>

665
00:34:26,400 --> 00:34:29,203
<c.green>这能够降低GPU占用率</c>

666
00:34:29,268 --> 00:34:32,572
<c.green>和相应的电能影响</c>

667
00:34:33,907 --> 00:34:37,344
<c.green>现在我们执行另一个方案</c>

668
00:34:37,878 --> 00:34:40,013
<c.green>让我们尝试后台运行这个应用</c>

669
00:34:41,215 --> 00:34:44,083
<c.green>我们想要查看</c>

670
00:34:44,150 --> 00:34:46,320
<c.green>或者立即进入挂起状态</c>

671
00:34:47,154 --> 00:34:48,422
<c.green>在这个例子中</c>

672
00:34:48,487 --> 00:34:51,692
<c.green>应用立即进入挂起状态</c>

673
00:34:51,757 --> 00:34:55,562
<c.green>这样很好 因为实际上</c>

674
00:34:56,230 --> 00:34:59,366
<c.green>应用不会耗用设备的电量</c>

675
00:35:00,934 --> 00:35:04,071
<c.green>让我们继续来看另一个应用</c>

676
00:35:05,372 --> 00:35:08,375
<c.green>我们要调试的第二个应用</c>

677
00:35:09,409 --> 00:35:10,444
<c.green>是EnergyBuddy</c>

678
00:35:12,713 --> 00:35:16,049
<c.green>我在设备上使用Xcode</c>

679
00:35:17,117 --> 00:35:19,553
<c.green>这是我们开发的一个简单应用</c>

680
00:35:19,620 --> 00:35:22,422
<c.green>用于获取电量表的图表</c>

681
00:35:23,023 --> 00:35:26,860
<c.green>它获取电量表图片中的读数</c>

682
00:35:27,594 --> 00:35:29,696
<c.green>然后获取你的核心位置</c>

683
00:35:29,763 --> 00:35:33,400
<c.green>然后使用你的位置</c>

684
00:35:33,901 --> 00:35:37,971
<c.green>所有这些信息都</c>

685
00:35:39,273 --> 00:35:44,311
<c.green>我点击Debug Navigator</c>

686
00:35:45,279 --> 00:35:47,181
<c.green>对不起 是Energy Impact计量表</c>

687
00:35:47,814 --> 00:35:50,551
<c.green>在这里 我们将执行第一个方案</c>

688
00:35:51,051 --> 00:35:52,219
<c.green>也就是启动与空闲方案</c>

689
00:35:53,020 --> 00:35:53,921
<c.green>因此</c>

690
00:35:54,321 --> 00:35:57,891
<c.green>在这里 我们看到</c>

691
00:35:58,559 --> 00:36:01,461
<c.green>唯一使用的组件是CPU</c>

692
00:35:58,559 --> 00:36:01,461
<c.green>唯一使用的组件是CPU</c>

693
00:36:01,528 --> 00:36:03,163
<c.green>启动应用时需要使用它</c>

694
00:36:04,264 --> 00:36:07,201
<c.green>现在让我们执行</c>

695
00:36:08,268 --> 00:36:10,170
<c.green>让我们尝试导入一张照片</c>

696
00:36:10,237 --> 00:36:14,308
<c.green>并查看在我的应用上</c>

697
00:36:14,374 --> 00:36:16,810
<c.green>造成的电量影响</c>

698
00:36:18,412 --> 00:36:19,813
<c.green>当我导入照片时</c>

699
00:36:19,880 --> 00:36:25,385
<c.green>我将接受一张照片</c>

700
00:36:26,854 --> 00:36:30,090
<c.green>这将生成一张图片</c>

701
00:36:31,291 --> 00:36:34,061
<c.green>在即时区域</c>

702
00:36:34,361 --> 00:36:36,630
<c.green>在执行这个特定操作时</c>

703
00:36:37,497 --> 00:36:41,034
<c.green>我的应用使用CPU进行处理</c>

704
00:36:41,401 --> 00:36:44,605
<c.green>而且它还使用位置组件</c>

705
00:36:45,906 --> 00:36:48,442
<c.green>这符合我们的预期</c>

706
00:36:48,675 --> 00:36:51,011
<c.green>在导入这张照片之后</c>

707
00:36:51,078 --> 00:36:54,114
<c.green>应用立即获取位置</c>

708
00:36:54,181 --> 00:36:55,649
<c.green>获取天气信息</c>

709
00:36:56,583 --> 00:37:01,054
<c.green>但是我们看到</c>

710
00:36:56,583 --> 00:37:01,054
<c.green>但是我们看到</c>

711
00:37:01,688 --> 00:37:04,191
<c.green>这可能是代码中的一个漏洞</c>

712
00:37:04,258 --> 00:37:07,561
<c.green>持续不断地访问核心位置</c>

713
00:37:08,061 --> 00:37:11,098
<c.green>你可以在应用中修复这个问题</c>

714
00:37:11,598 --> 00:37:15,102
<c.green>然后返回这个特定的照片导入方案</c>

715
00:37:15,169 --> 00:37:18,338
<c.green>确保电量影响已经降低</c>

716
00:37:20,207 --> 00:37:22,843
<c.green>让我们尝试后台运行这个应用</c>

717
00:37:24,411 --> 00:37:27,247
<c.green>当我后台运行这个应用时</c>

718
00:37:27,314 --> 00:37:29,616
<c.green>尽快进入挂起状态</c>

719
00:37:30,984 --> 00:37:35,822
<c.green>但是我们看到应用进入后台运行状态</c>

720
00:37:35,889 --> 00:37:39,526
<c.green>而且在后台运行状态下</c>

721
00:37:40,294 --> 00:37:42,963
<c.green>这对用户来说并没有任何用处</c>

722
00:37:43,030 --> 00:37:46,099
<c.green>可以在应用中进行优化</c>

723
00:37:47,334 --> 00:37:51,972
<c.green>我们访问核心位置</c>

724
00:37:52,039 --> 00:37:54,842
<c.green>因此会持续不断地使用核心位置</c>

725
00:37:54,908 --> 00:37:59,613
<c.green>从而导致非常高的位置服务使用频率</c>

726
00:38:00,714 --> 00:38:04,251
<c.green>在后台运行区域</c>

727
00:38:04,318 --> 00:38:08,589
<c.green>这是保持设备唤醒状态</c>

728
00:38:08,989 --> 00:38:12,726
<c.green>只要你的应用导致设备处于后台状态</c>

729
00:38:12,793 --> 00:38:14,328
<c.green>就始终会</c>

730
00:38:14,394 --> 00:38:15,829
<c.green>耗用一定的电量</c>

731
00:38:15,896 --> 00:38:18,599
<c.green>这是你的应用所固有的电量耗用</c>

732
00:38:20,100 --> 00:38:23,203
<c.green>当你尝试进行调试以发现电量问题时</c>

733
00:38:23,570 --> 00:38:27,841
<c.green>希望你在设备上运行这些方案</c>

734
00:38:30,577 --> 00:38:35,315
<c.green>确定哪些方案</c>

735
00:38:36,083 --> 00:38:38,919
<c.green>使用Energy Gauges</c>

736
00:38:39,119 --> 00:38:41,955
<c.green>通过报告查看执行这些方案</c>

737
00:38:42,022 --> 00:38:43,557
<c.green>带来哪些电量影响变化</c>

738
00:38:44,324 --> 00:38:48,395
<c.green>确保在应用中进行必要的改进或优化</c>

739
00:38:48,762 --> 00:38:50,797
<c.green>使用仪表进行更深入的分析</c>

740
00:38:51,231 --> 00:38:53,333
<c.green>解决相关的电量问题</c>

741
00:38:54,201 --> 00:38:58,505
<c.green>之后应该返回方案</c>

742
00:38:58,572 --> 00:39:01,008
<c.green>并且核实Energy Gauges已经表明</c>

743
00:38:58,572 --> 00:39:01,008
<c.green>并且核实Energy Gauges已经表明</c>

744
00:39:01,074 --> 00:39:04,845
<c.green>电量影响已经降低或者进入绿色区域</c>

745
00:39:06,046 --> 00:39:09,116
<c.green>现在 我想把舞台交回给丹尼尔</c>

746
00:39:09,183 --> 00:39:11,952
<c.green>进行最后的归纳和总结</c>

747
00:39:15,923 --> 00:39:17,491
<c.green>（最后归纳）</c>

748
00:39:17,558 --> 00:39:19,493
<c.green>你们已经看到</c>

749
00:39:19,560 --> 00:39:22,129
<c.green>它帮助你发现应用中的</c>

750
00:39:22,896 --> 00:39:24,565
<c.green>让我们进行最后的归纳和总结</c>

751
00:39:25,766 --> 00:39:29,770
<c.green>首先 希望你们尽可能地</c>

752
00:39:30,204 --> 00:39:33,240
<c.green>这将帮助系统发现</c>

753
00:39:34,141 --> 00:39:36,810
<c.green>接下来 应确保</c>

754
00:39:37,110 --> 00:39:39,479
<c.green>请记住 这将使设备保持唤醒状态</c>

755
00:39:40,514 --> 00:39:41,615
<c.green>然后 应避免使用计时器</c>

756
00:39:42,282 --> 00:39:45,052
<c.green>如果需要计时器</c>

757
00:39:45,586 --> 00:39:47,454
<c.green>最后 应使用Energy Gauges</c>

758
00:39:47,754 --> 00:39:49,823
<c.green>这将帮助你发现良好的优化机会</c>

759
00:39:50,691 --> 00:39:52,025
<c.green>这里是一些相关的演讲</c>

760
00:39:52,092 --> 00:39:54,061
<c.green>这些演讲视频很有价值</c>

761
00:39:54,294 --> 00:39:55,362
<c.green>非常感谢</c>
