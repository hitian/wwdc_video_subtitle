1
00:00:17,551 --> 00:00:21,688
<c.magenta>（Foundation新特性）</c>

2
00:00:21,755 --> 00:00:22,589
<c.magenta>大家好</c>

3
00:00:27,561 --> 00:00:28,428
<c.magenta>欢迎到来</c>

4
00:00:28,562 --> 00:00:31,632
<c.magenta>我的名字叫托尼·帕克</c>

5
00:00:31,698 --> 00:00:34,368
<c.magenta>我今天和我的同事迈克尔·乐修</c>

6
00:00:34,434 --> 00:00:36,370
<c.magenta>告诉你们有关Foundation的新特性</c>

7
00:00:37,404 --> 00:00:38,705
<c.magenta>我们今天有三个主题</c>

8
00:00:38,906 --> 00:00:42,276
<c.magenta>首先我们要快速浏览一遍</c>

9
00:00:42,342 --> 00:00:44,144
<c.magenta>来自于今年Foundation</c>

10
00:00:44,978 --> 00:00:48,081
<c.magenta>在那之后 我们要进入</c>

11
00:00:48,248 --> 00:00:51,185
<c.magenta>键路径和键值观察API</c>

12
00:00:52,386 --> 00:00:56,056
<c.magenta>在那之后 我们将讨论</c>

13
00:00:56,924 --> 00:00:59,660
<c.magenta>让我们从那些新的API重点开始吧</c>

14
00:01:02,563 --> 00:01:05,299
<c.magenta>首先今年我们强化了</c>

15
00:01:05,364 --> 00:01:07,467
<c.magenta>去年我们作为iOS 10</c>

16
00:01:08,302 --> 00:01:10,370
<c.magenta>这增强了你交互的能力</c>

17
00:01:10,437 --> 00:01:14,074
<c.magenta>在FileProvider扩展</c>

18
00:01:15,676 --> 00:01:18,545
<c.magenta>我们已经改进了可用存储空间API</c>

19
00:01:18,712 --> 00:01:22,416
<c.magenta>这是一个在MSURL上的新API</c>

20
00:01:22,482 --> 00:01:25,452
<c.magenta>你用户的设备上有多少剩余空间可用</c>

21
00:01:25,519 --> 00:01:27,287
<c.magenta>而且可以了解</c>

22
00:01:27,354 --> 00:01:31,592
<c.magenta>如果我们清除像是缓存或者旧数据</c>

23
00:01:33,594 --> 00:01:37,464
<c.magenta>我们在NS range和Swift range中</c>

24
00:01:37,531 --> 00:01:40,367
<c.magenta>NS range中NSString的使用</c>

25
00:01:40,434 --> 00:01:42,636
<c.magenta>以及Swift range中</c>

26
00:01:43,036 --> 00:01:47,374
<c.magenta>这对于像是AttributedString和</c>

27
00:01:49,243 --> 00:01:53,680
<c.magenta>在NSXPCConnection中 我们加入了</c>

28
00:01:54,081 --> 00:01:56,250
<c.magenta>实际上第一个东西真的很有趣</c>

29
00:01:56,316 --> 00:02:01,121
<c.magenta>因为在扩展</c>

30
00:01:56,316 --> 00:02:01,121
<c.magenta>因为在扩展</c>

31
00:02:01,188 --> 00:02:05,392
<c.magenta>实际上是NSXPCConnection</c>

32
00:02:06,059 --> 00:02:08,929
<c.magenta>NSURLSession也获得了对于</c>

33
00:02:09,062 --> 00:02:10,931
<c.magenta>因为我们希望你们可以使用</c>

34
00:02:10,997 --> 00:02:15,736
<c.magenta>所有这些进程功能来使得从下载</c>

35
00:02:15,802 --> 00:02:19,339
<c.magenta>到扩展 到应用</c>

36
00:02:21,175 --> 00:02:23,110
<c.magenta>最后我们还引入了热通知</c>

37
00:02:23,177 --> 00:02:25,012
<c.magenta>今年从Mac到iOS上</c>

38
00:02:26,246 --> 00:02:28,582
<c.magenta>对于这些主题的更多内容</c>

39
00:02:28,649 --> 00:02:30,150
<c.magenta>它是在今天早上</c>

40
00:02:30,217 --> 00:02:33,554
<c.magenta>在那场演讲上 我们有相当多</c>

41
00:02:35,656 --> 00:02:38,625
<c.magenta>性能也是我们今年在Foundation上的</c>

42
00:02:38,692 --> 00:02:40,027
<c.magenta>一个关键考虑因素</c>

43
00:02:40,260 --> 00:02:43,564
<c.magenta>从一个有关NSArray的</c>

44
00:02:43,630 --> 00:02:46,767
<c.magenta>以及它的词典 NSSet</c>

45
00:02:47,568 --> 00:02:50,771
<c.magenta>对于它一个很大的刺激因素是</c>

46
00:02:51,104 --> 00:02:55,209
<c.magenta>因此当Objective-C API</c>

47
00:02:55,275 --> 00:02:57,911
<c.magenta>也许是在一个框架里</c>

48
00:02:57,978 --> 00:03:01,048
<c.magenta>你接收到了Swift的值类型：</c>

49
00:02:57,978 --> 00:03:01,048
<c.magenta>你接收到了Swift的值类型：</c>

50
00:03:01,448 --> 00:03:03,317
<c.magenta>为了保留这些值语义</c>

51
00:03:03,383 --> 00:03:06,486
<c.magenta>那些结构在引入类型上调用复制</c>

52
00:03:06,553 --> 00:03:07,821
<c.magenta>当它们在做桥接的时候</c>

53
00:03:08,222 --> 00:03:10,858
<c.magenta>如果结果恰好是共有子类的一个</c>

54
00:03:10,924 --> 00:03:12,793
<c.magenta>那么复制会开销很大</c>

55
00:03:13,227 --> 00:03:17,030
<c.magenta>现在我们可以延迟复制的花销</c>

56
00:03:17,097 --> 00:03:18,365
<c.magenta>如果真发生的话</c>

57
00:03:18,432 --> 00:03:20,868
<c.magenta>这会导致相当大的改进</c>

58
00:03:20,934 --> 00:03:22,269
<c.magenta>对于桥接时的性能来说</c>

59
00:03:23,904 --> 00:03:27,174
<c.magenta>结构体数据作为</c>

60
00:03:27,241 --> 00:03:29,576
<c.magenta>也获得很多性能增强</c>

61
00:03:29,743 --> 00:03:33,046
<c.magenta>特别酷的是 我们可以直列</c>

62
00:03:33,113 --> 00:03:36,450
<c.magenta>数据行为的关键部分到你的应用里</c>

63
00:03:36,850 --> 00:03:40,754
<c.magenta>这包括像是在数据里挨个字节编序号</c>

64
00:03:40,821 --> 00:03:44,892
<c.magenta>这同样获得相当大的性能改进</c>

65
00:03:46,093 --> 00:03:48,095
<c.magenta>NSCalendar获得了</c>

66
00:03:48,161 --> 00:03:50,797
<c.magenta>在CPU时间以及</c>

67
00:03:50,864 --> 00:03:52,900
<c.magenta>除此之外 我们还改进了结果</c>

68
00:03:52,966 --> 00:03:55,202
<c.magenta>它所给你的 特别是在边界情况上</c>

69
00:03:56,670 --> 00:04:00,374
<c.magenta>最后我们改进了桥接NSNumber</c>

70
00:03:56,670 --> 00:04:00,374
<c.magenta>最后我们改进了桥接NSNumber</c>

71
00:04:00,440 --> 00:04:03,944
<c.magenta>我们同样也改进了</c>

72
00:04:04,011 --> 00:04:07,347
<c.magenta>来提供更好的安全性</c>

73
00:04:07,414 --> 00:04:10,517
<c.magenta>从NSNumber到Swift数据类型时</c>

74
00:04:11,351 --> 00:04:14,755
<c.magenta>这种更快的桥接对于像是属性表解析</c>

75
00:04:15,522 --> 00:04:16,957
<c.magenta>有关这些主题的更多内容</c>

76
00:04:17,024 --> 00:04:18,858
<c.magenta>请观看“与框架高效互动”</c>

77
00:04:18,926 --> 00:04:20,427
<c.magenta>那是在周五下午1：50</c>

78
00:04:21,228 --> 00:04:23,430
<c.magenta>现在我将舞台交给我的同事迈克尔</c>

79
00:04:23,497 --> 00:04:25,699
<c.magenta>来谈谈键路径和键值观察</c>

80
00:04:34,942 --> 00:04:35,876
<c.magenta>谢谢 托尼</c>

81
00:04:36,376 --> 00:04:40,447
<c.magenta>嗨 我是来自Foundation团队的迈克尔</c>

82
00:04:40,514 --> 00:04:43,584
<c.magenta>有关我们今年对于键路径</c>

83
00:04:43,650 --> 00:04:47,487
<c.magenta>我想要从Foundation团队中</c>

84
00:04:47,855 --> 00:04:48,956
<c.magenta>就是键路径</c>

85
00:04:49,022 --> 00:04:51,291
<c.magenta>在Cocoa开发中非常重要</c>

86
00:04:51,892 --> 00:04:54,628
<c.magenta>因为它让我们推论出类型的结构</c>

87
00:04:54,695 --> 00:04:56,830
<c.magenta>除了任何特定情况</c>

88
00:04:56,897 --> 00:04:59,266
<c.magenta>以一种比起终结更具限制性的方式</c>

89
00:05:00,234 --> 00:05:02,836
<c.magenta>我们觉得这非常重要</c>

90
00:05:02,903 --> 00:05:04,805
<c.magenta>对于语言本身的特别处理</c>

91
00:05:08,108 --> 00:05:12,713
<c.magenta>我们从去年将字符串键路径添加</c>

92
00:05:13,547 --> 00:05:18,051
<c.magenta>其使得Swift获得了能力</c>

93
00:05:18,118 --> 00:05:20,521
<c.magenta>保证了一个Objective-C</c>

94
00:05:21,154 --> 00:05:22,155
<c.magenta>也就是我现在要说的</c>

95
00:05:22,556 --> 00:05:24,024
<c.magenta>假设我们有个Kid类</c>

96
00:05:24,091 --> 00:05:25,926
<c.magenta>它有一些键值可观察的属性</c>

97
00:05:25,993 --> 00:05:27,761
<c.magenta>像是他们的昵称 年龄</c>

98
00:05:27,828 --> 00:05:30,130
<c.magenta>当然了 还有他们现在最好的朋友</c>

99
00:05:30,197 --> 00:05:32,065
<c.magenta>我们可以继续构造一个实例</c>

100
00:05:32,132 --> 00:05:34,168
<c.magenta>在这里例子中 一个叫本基的小男孩</c>

101
00:05:35,235 --> 00:05:38,272
<c.magenta>然后形成了一个到孩子昵称属性</c>

102
00:05:38,505 --> 00:05:40,707
<c.magenta>接着 Swift编译器会确认</c>

103
00:05:40,774 --> 00:05:42,910
<c.magenta>这对我们来说是合理的</c>

104
00:05:43,810 --> 00:05:46,813
<c.magenta>接着我们可以用键值或者键值编码</c>

105
00:05:46,880 --> 00:05:49,783
<c.magenta>来读取或者将该变量写回到实例中</c>

106
00:05:51,518 --> 00:05:53,220
<c.magenta>现在 我们通过字符串键径</c>

107
00:05:53,287 --> 00:05:56,456
<c.magenta>而获得的当前编译时间检查</c>

108
00:05:56,823 --> 00:05:59,193
<c.magenta>最终它还是会编译到一个字符串</c>

109
00:06:00,093 --> 00:06:03,630
<c.magenta>为了让该字符串有用</c>

110
00:06:03,697 --> 00:06:07,201
<c.magenta>之前我看的时候</c>

111
00:06:07,267 --> 00:06:09,703
<c.magenta>而且大概短时间内不可能变得可用</c>

112
00:06:10,771 --> 00:06:15,142
<c.magenta>最后 字符串键径不携带类型信息</c>

113
00:06:15,209 --> 00:06:16,376
<c.magenta>它就是一个字符串</c>

114
00:06:17,678 --> 00:06:20,414
<c.magenta>因此所有使用字符串键径</c>

115
00:06:20,480 --> 00:06:23,217
<c.magenta>无论如何都需要被定义</c>

116
00:06:25,052 --> 00:06:27,821
<c.magenta>但这是Swift</c>

117
00:06:28,355 --> 00:06:30,257
<c.magenta>因为我们考虑 什么可以</c>

118
00:06:30,324 --> 00:06:32,593
<c.magenta>键径 它们在Swift中</c>

119
00:06:33,427 --> 00:06:35,195
<c.magenta>首先我们想要能描述属性</c>

120
00:06:35,262 --> 00:06:36,597
<c.magenta>这很必要</c>

121
00:06:36,663 --> 00:06:38,398
<c.magenta>它们应该是静态类型安全的</c>

122
00:06:39,766 --> 00:06:40,934
<c.magenta>它们同样也要很快</c>

123
00:06:41,301 --> 00:06:44,705
<c.magenta>并且它们应该可以处理</c>

124
00:06:46,340 --> 00:06:49,376
<c.magenta>它们应该可以在</c>

125
00:06:49,977 --> 00:06:51,211
<c.magenta>因此我们考虑了很长时间</c>

126
00:06:51,278 --> 00:06:54,014
<c.magenta>如何使得所有这些键径梦想成真</c>

127
00:06:54,348 --> 00:06:56,283
<c.magenta>最终跟世界分享我们的点子</c>

128
00:06:56,350 --> 00:06:58,418
<c.magenta>通过开源Swift进化过程</c>

129
00:06:58,485 --> 00:07:02,322
<c.magenta>还有一份名为</c>

130
00:06:58,485 --> 00:07:02,322
<c.magenta>还有一份名为</c>

131
00:07:02,856 --> 00:07:05,692
<c.magenta>这就是Swift 4中</c>

132
00:07:07,227 --> 00:07:09,029
<c.magenta>从反斜线符号开始</c>

133
00:07:10,597 --> 00:07:12,666
<c.magenta>跟着基类型的名字</c>

134
00:07:13,166 --> 00:07:16,603
<c.magenta>一个点表明我们是在该基类型里</c>

135
00:07:16,670 --> 00:07:18,172
<c.magenta>然后就是属性的名字</c>

136
00:07:19,540 --> 00:07:21,508
<c.magenta>这里的反斜线符号很重要</c>

137
00:07:21,575 --> 00:07:24,611
<c.magenta>因为它帮助我们消除了</c>

138
00:07:24,678 --> 00:07:27,247
<c.magenta>还有属性的提及或者引用</c>

139
00:07:28,148 --> 00:07:33,487
<c.magenta>当然了这是Swift</c>

140
00:07:33,554 --> 00:07:35,389
<c.magenta>仅通过反斜线符号和点的部分</c>

141
00:07:37,257 --> 00:07:39,059
<c.magenta>键径可以依次形成</c>

142
00:07:39,126 --> 00:07:41,862
<c.magenta>就像是属性接着属性地调用</c>

143
00:07:42,663 --> 00:07:46,066
<c.magenta>很快地 任选链接会像它</c>

144
00:07:49,469 --> 00:07:52,105
<c.magenta>我们很快会允许通过下标的间接使用</c>

145
00:07:55,409 --> 00:07:56,877
<c.magenta>就像是这样 我也喜欢</c>

146
00:08:00,214 --> 00:08:02,249
<c.magenta>键径也可以从一个下标直接开始</c>

147
00:08:02,316 --> 00:08:05,652
<c.magenta>这里我们从数据的字节下标开始</c>

148
00:08:05,719 --> 00:08:08,222
<c.magenta>这里我们用startIndex表示</c>

149
00:08:09,223 --> 00:08:11,692
<c.magenta>当然了 这也可以被推断</c>

150
00:08:11,758 --> 00:08:14,828
<c.magenta>通过反斜线符号与点剩余部分</c>

151
00:08:15,896 --> 00:08:19,967
<c.magenta>这些新键径表达式给所有</c>

152
00:08:20,033 --> 00:08:23,070
<c.magenta>对于支持属性</c>

153
00:08:24,271 --> 00:08:27,808
<c.magenta>当然了 生成键径是一回事</c>

154
00:08:28,342 --> 00:08:30,143
<c.magenta>假设我们有一个键径</c>

155
00:08:32,246 --> 00:08:33,780
<c.magenta>这里是一个孩子的年龄</c>

156
00:08:34,280 --> 00:08:37,851
<c.magenta>使用键径来读取一个属性</c>

157
00:08:40,053 --> 00:08:41,154
<c.magenta>这开始像是代码</c>

158
00:08:41,221 --> 00:08:43,423
<c.magenta>我现在会高亮句法</c>

159
00:08:44,558 --> 00:08:45,592
<c.magenta>好了</c>

160
00:08:46,426 --> 00:08:47,895
<c.magenta>这里发生了些什么 我想要谈谈</c>

161
00:08:47,961 --> 00:08:51,598
<c.magenta>一些背景动机</c>

162
00:08:51,798 --> 00:08:55,669
<c.magenta>首先我们给键径下标参数一个标签</c>

163
00:08:55,936 --> 00:08:58,438
<c.magenta>我们这样做是因为我们想让它</c>

164
00:08:58,505 --> 00:09:00,007
<c.magenta>对于其他类型可以存在的下标</c>

165
00:08:58,505 --> 00:09:00,007
<c.magenta>对于其他类型可以存在的下标</c>

166
00:09:00,307 --> 00:09:02,376
<c.magenta>接着 你正在使用的值类型</c>

167
00:09:02,442 --> 00:09:05,979
<c.magenta>它在调用下标</c>

168
00:09:06,580 --> 00:09:08,549
<c.magenta>如果它们匹配 这是合理的事</c>

169
00:09:08,615 --> 00:09:10,484
<c.magenta>你的代码就会编译</c>

170
00:09:12,419 --> 00:09:16,623
<c.magenta>你也可以用下标来变动一个特定的值</c>

171
00:09:17,257 --> 00:09:20,694
<c.magenta>下标非常好 因为它们提供了</c>

172
00:09:20,761 --> 00:09:21,828
<c.magenta>来读取和写入一个值</c>

173
00:09:21,895 --> 00:09:24,064
<c.magenta>无论它们是一个值类型还是引用类型</c>

174
00:09:25,065 --> 00:09:27,501
<c.magenta>我已经展示了引用类型的情况</c>

175
00:09:27,568 --> 00:09:30,404
<c.magenta>现在我想要换成展示</c>

176
00:09:30,637 --> 00:09:32,406
<c.magenta>为了这个目的 我们会扩展例子</c>

177
00:09:32,472 --> 00:09:33,974
<c.magenta>到我真正想谈的地方</c>

178
00:09:34,041 --> 00:09:35,709
<c.magenta>也就是生日派对计划</c>

179
00:09:37,244 --> 00:09:38,879
<c.magenta>让我们创建一个派对</c>

180
00:09:39,513 --> 00:09:42,850
<c.magenta>看起来本基要举办一个</c>

181
00:09:42,916 --> 00:09:45,018
<c.magenta>通过一个键径来读取值类型</c>

182
00:09:45,085 --> 00:09:48,522
<c.magenta>使用了和我们之前看到的</c>

183
00:09:49,122 --> 00:09:53,393
<c.magenta>类似地 改动一个派对</c>

184
00:09:53,460 --> 00:09:56,230
<c.magenta>这是个常见的主题</c>

185
00:09:56,897 --> 00:10:01,201
<c.magenta>然而既然这是Swift</c>

186
00:09:56,897 --> 00:10:01,201
<c.magenta>然而既然这是Swift</c>

187
00:10:01,268 --> 00:10:03,403
<c.magenta>因此语言可以为我们推断这一点</c>

188
00:10:04,771 --> 00:10:07,875
<c.magenta>我刚听说本</c>

189
00:10:07,941 --> 00:10:09,510
<c.magenta>那么我们就在这里改过来吧</c>

190
00:10:10,744 --> 00:10:12,713
<c.magenta>这里我高亮了一下句法</c>

191
00:10:12,846 --> 00:10:15,249
<c.magenta>像是这样的代码</c>

192
00:10:15,315 --> 00:10:19,086
<c.magenta>所以让我们看看当你使用这些键径</c>

193
00:10:21,755 --> 00:10:24,558
<c.magenta>键径表达式</c>

194
00:10:24,625 --> 00:10:26,527
<c.magenta>像是所有的值 它们能被保存</c>

195
00:10:28,095 --> 00:10:29,963
<c.magenta>那么 这个变量的类型是什么呢？</c>

196
00:10:30,030 --> 00:10:33,834
<c.magenta>让我们假设使用Option加X键</c>

197
00:10:33,901 --> 00:10:37,004
<c.magenta>不出意外 我们得到了</c>

198
00:10:37,571 --> 00:10:40,874
<c.magenta>其基类型是Kid</c>

199
00:10:40,941 --> 00:10:42,476
<c.magenta>因为昵称是字符串</c>

200
00:10:44,077 --> 00:10:46,880
<c.magenta>强类型键径也可以适用于复合键径</c>

201
00:10:46,947 --> 00:10:48,849
<c.magenta>这里我们从生日派对开始</c>

202
00:10:48,916 --> 00:10:51,118
<c.magenta>一直遍历到庆祝者的年龄</c>

203
00:10:51,418 --> 00:10:54,354
<c.magenta>当然了年龄是double类型</c>

204
00:10:54,421 --> 00:10:57,057
<c.magenta>小数点后的数字是非常重要的</c>

205
00:10:58,992 --> 00:11:01,929
<c.magenta>变量所保存的键径</c>

206
00:10:58,992 --> 00:11:01,929
<c.magenta>变量所保存的键径</c>

207
00:11:06,066 --> 00:11:07,434
<c.magenta>因为它们是强类型的</c>

208
00:11:07,501 --> 00:11:09,369
<c.magenta>它们是静态被认知拥有正确类型的</c>

209
00:11:09,436 --> 00:11:11,171
<c.magenta>这里是如我们所期望的double</c>

210
00:11:12,206 --> 00:11:14,675
<c.magenta>假设我们要计划另一个生日派对</c>

211
00:11:14,741 --> 00:11:17,678
<c.magenta>这次是米亚的</c>

212
00:11:18,612 --> 00:11:20,047
<c.magenta>我们可以使用相同的键径变量</c>

213
00:11:20,113 --> 00:11:22,616
<c.magenta>来找出她要庆祝的是哪个生日</c>

214
00:11:22,683 --> 00:11:26,653
<c.magenta>通过这种方式 键径某种程度上</c>

215
00:11:27,754 --> 00:11:30,390
<c.magenta>在这个例子中</c>

216
00:11:30,457 --> 00:11:32,492
<c.magenta>但是让我们更进一步泛化一点</c>

217
00:11:33,126 --> 00:11:35,762
<c.magenta>如果我想知道</c>

218
00:11:36,530 --> 00:11:38,532
<c.magenta>我们要定义一个函数</c>

219
00:11:38,632 --> 00:11:41,168
<c.magenta>把它叫做</c>

220
00:11:41,235 --> 00:11:45,405
<c.magenta>它们被给了一个派对和</c>

221
00:11:45,672 --> 00:11:47,574
<c.magenta>为了达成这个目的</c>

222
00:11:47,641 --> 00:11:49,810
<c.magenta>这些类型安全的键径</c>

223
00:11:49,877 --> 00:11:53,547
<c.magenta>可以动态地从其他键径生成新的键径</c>

224
00:11:53,881 --> 00:11:56,283
<c.magenta>这里我会把两个键径连到一起</c>

225
00:11:56,350 --> 00:11:59,720
<c.magenta>participantPath到孩子的年龄</c>

226
00:11:59,786 --> 00:12:03,290
<c.magenta>这就是为什么除了变量名</c>

227
00:11:59,786 --> 00:12:03,290
<c.magenta>这就是为什么除了变量名</c>

228
00:12:03,824 --> 00:12:06,326
<c.magenta>如你所料</c>

229
00:12:06,393 --> 00:12:08,662
<c.magenta>从BirthdayParty开始</c>

230
00:12:09,463 --> 00:12:13,367
<c.magenta>用这个键径和存在变量中的</c>

231
00:12:13,700 --> 00:12:15,369
<c.magenta>我们可以在庆祝者中</c>

232
00:12:15,435 --> 00:12:18,172
<c.magenta>我们可以得到和之前所见</c>

233
00:12:19,106 --> 00:12:22,209
<c.magenta>当支持下标的时候</c>

234
00:12:22,276 --> 00:12:25,012
<c.magenta>来找到派对的第一个到场者的年龄</c>

235
00:12:27,080 --> 00:12:30,050
<c.magenta>现在我想要谈一些</c>

236
00:12:30,617 --> 00:12:34,288
<c.magenta>当我们把两个键径连到一起时</c>

237
00:12:35,556 --> 00:12:37,524
<c.magenta>为了让这个相加能讲得通</c>

238
00:12:37,591 --> 00:12:40,327
<c.magenta>我们需要看看</c>

239
00:12:41,028 --> 00:12:44,231
<c.magenta>我们需要看每个基类型</c>

240
00:12:45,966 --> 00:12:48,202
<c.magenta>内部类型需要匹配</c>

241
00:12:48,302 --> 00:12:51,004
<c.magenta>如果是这种情况的话</c>

242
00:12:51,071 --> 00:12:54,341
<c.magenta>从初始基类型到最终属性类型</c>

243
00:12:56,476 --> 00:13:00,080
<c.magenta>这样 键径不在乎它们是如何获得</c>

244
00:12:56,476 --> 00:13:00,080
<c.magenta>这样 键径不在乎它们是如何获得</c>

245
00:13:00,147 --> 00:13:01,882
<c.magenta>从它们的基类型到属性类型</c>

246
00:13:01,949 --> 00:13:04,618
<c.magenta>它们能办到</c>

247
00:13:06,019 --> 00:13:07,955
<c.magenta>现在我想看看另一个例子</c>

248
00:13:08,021 --> 00:13:11,225
<c.magenta>或者说Swift键径</c>

249
00:13:13,627 --> 00:13:14,995
<c.magenta>以防你们还不是很清楚</c>

250
00:13:16,129 --> 00:13:18,398
<c.magenta>假设我们想输出一个我们派对的概要</c>

251
00:13:18,532 --> 00:13:21,068
<c.magenta>我们可以在键径中</c>

252
00:13:22,402 --> 00:13:25,539
<c.magenta>但是我们会期望这个数组</c>

253
00:13:25,606 --> 00:13:27,441
<c.magenta>我们期望它的类型是什么呢？</c>

254
00:13:27,508 --> 00:13:29,109
<c.magenta>毕竟主题是一个字符串</c>

255
00:13:29,476 --> 00:13:31,211
<c.magenta>Attending是一个孩子的数组</c>

256
00:13:31,778 --> 00:13:34,081
<c.magenta>celebrant</c>

257
00:13:35,215 --> 00:13:36,717
<c.magenta>这种情况下</c>

258
00:13:36,783 --> 00:13:39,686
<c.magenta>它是一个关于BirthdayParty的</c>

259
00:13:40,220 --> 00:13:43,190
<c.magenta>PartialKeyPath部分</c>

260
00:13:43,557 --> 00:13:44,825
<c.magenta>它们知道它们的基类型</c>

261
00:13:44,892 --> 00:13:50,597
<c.magenta>但是它们可以指向任何对于</c>

262
00:13:50,664 --> 00:13:53,734
<c.magenta>这样我们打印出报告</c>

263
00:13:54,368 --> 00:14:00,874
<c.magenta>我们把titles和paths压缩到一起</c>

264
00:13:54,368 --> 00:14:00,874
<c.magenta>我们把titles和paths压缩到一起</c>

265
00:14:00,941 --> 00:14:02,176
<c.magenta>然后打印我们的报告</c>

266
00:14:02,576 --> 00:14:04,578
<c.magenta>你可以看到米亚要举办</c>

267
00:14:04,645 --> 00:14:06,480
<c.magenta>看起来是个家庭生日派对</c>

268
00:14:06,547 --> 00:14:08,682
<c.magenta>不过它是太空主题的</c>

269
00:14:11,218 --> 00:14:13,487
<c.magenta>现在我想往BirthdayParty中</c>

270
00:14:13,687 --> 00:14:14,755
<c.magenta>我们要添加一个函数</c>

271
00:14:14,821 --> 00:14:16,590
<c.magenta>来让孩子们吹灭他们的生日蜡烛</c>

272
00:14:16,657 --> 00:14:17,724
<c.magenta>这会和我们之前所做的</c>

273
00:14:17,791 --> 00:14:19,326
<c.magenta>有点不一样</c>

274
00:14:19,393 --> 00:14:21,161
<c.magenta>因为到目前为止</c>

275
00:14:21,228 --> 00:14:23,997
<c.magenta>现在我想要写入到一个键径</c>

276
00:14:25,265 --> 00:14:26,567
<c.magenta>我们要加入我们的函数</c>

277
00:14:27,000 --> 00:14:29,236
<c.magenta>我想要指出的是</c>

278
00:14:29,303 --> 00:14:32,940
<c.magenta>它是一个可写的键径</c>

279
00:14:34,374 --> 00:14:37,544
<c.magenta>我们可以像是一般键径</c>

280
00:14:37,611 --> 00:14:39,913
<c.magenta>从我们的值中得到想要的值</c>

281
00:14:40,480 --> 00:14:42,549
<c.magenta>我们也可以使用它们来变动我们的值</c>

282
00:14:43,183 --> 00:14:45,352
<c.magenta>我们终于要吹灭蜡烛了</c>

283
00:14:45,619 --> 00:14:48,155
<c.magenta>除了一个问题</c>

284
00:14:48,789 --> 00:14:49,723
<c.magenta>它不编译</c>

285
00:14:50,290 --> 00:14:51,859
<c.magenta>这是个生日灾难</c>

286
00:14:53,861 --> 00:14:56,296
<c.magenta>让我们尝试一下</c>

287
00:14:56,964 --> 00:14:57,798
<c.magenta>排除障碍</c>

288
00:14:58,832 --> 00:15:00,467
<c.magenta>编译器告诉我们</c>

289
00:14:58,832 --> 00:15:00,467
<c.magenta>编译器告诉我们</c>

290
00:15:00,534 --> 00:15:03,237
<c.magenta>“无法分配到不可改变的</c>

291
00:15:03,437 --> 00:15:05,372
<c.magenta>这是非常Swift的风格</c>

292
00:15:06,173 --> 00:15:07,941
<c.magenta>让我们看看能否知道到底是怎么回事</c>

293
00:15:08,041 --> 00:15:11,044
<c.magenta>它说不可变的</c>

294
00:15:12,045 --> 00:15:13,981
<c.magenta>我们确实传的是一个键径</c>

295
00:15:14,047 --> 00:15:17,050
<c.magenta>让我们确定这个键径</c>

296
00:15:17,117 --> 00:15:19,586
<c.magenta>有时候你应该用的是</c>

297
00:15:19,653 --> 00:15:21,255
<c.magenta>让我们回到kid的声明</c>

298
00:15:21,321 --> 00:15:24,124
<c.magenta>但我们看到的是var</c>

299
00:15:24,391 --> 00:15:26,693
<c.magenta>是var 所以没有问题</c>

300
00:15:27,528 --> 00:15:30,097
<c.magenta>也许问题是写入本身</c>

301
00:15:30,163 --> 00:15:31,665
<c.magenta>也就是我们用了subscript</c>

302
00:15:31,732 --> 00:15:33,667
<c.magenta>我现在告诉你们</c>

303
00:15:33,734 --> 00:15:35,135
<c.magenta>所以不是这个问题</c>

304
00:15:35,402 --> 00:15:37,504
<c.magenta>肯定是self有什么问题</c>

305
00:15:38,472 --> 00:15:41,375
<c.magenta>self是什么？</c>

306
00:15:41,441 --> 00:15:43,477
<c.magenta>因此现在我们需要回到</c>

307
00:15:43,544 --> 00:15:44,711
<c.magenta>幸运的是 我们还有余地</c>

308
00:15:46,580 --> 00:15:48,949
<c.magenta>我们会发现BirthdayParty</c>

309
00:15:49,016 --> 00:15:50,417
<c.magenta>而结构体是值类型的</c>

310
00:15:50,484 --> 00:15:52,452
<c.magenta>因此这里编译器所做的是正确的</c>

311
00:15:52,519 --> 00:15:54,321
<c.magenta>它不让我们变动BirthdayParty</c>

312
00:15:54,388 --> 00:15:57,724
<c.magenta>因为我们的键径是</c>

313
00:15:58,292 --> 00:15:59,526
<c.magenta>我们能用的一个技巧就是</c>

314
00:15:59,593 --> 00:16:03,130
<c.magenta>我们看看所知道的Swift的技巧</c>

315
00:15:59,593 --> 00:16:03,130
<c.magenta>我们看看所知道的Swift的技巧</c>

316
00:16:03,197 --> 00:16:05,999
<c.magenta>我们加上mutating就行了</c>

317
00:16:07,401 --> 00:16:09,203
<c.magenta>但是当你这么做的时候</c>

318
00:16:09,269 --> 00:16:11,004
<c.magenta>这真的是正确的选择吗？</c>

319
00:16:11,238 --> 00:16:16,343
<c.magenta>因为我们不想改动键</c>

320
00:16:17,044 --> 00:16:18,111
<c.magenta>我们要改动的是庆祝者</c>

321
00:16:18,178 --> 00:16:20,681
<c.magenta>我刚检查过</c>

322
00:16:21,081 --> 00:16:24,218
<c.magenta>而庆祝者实际上是一个类</c>

323
00:16:24,985 --> 00:16:27,321
<c.magenta>对于这点 我们实际上有另一类键径</c>

324
00:16:27,387 --> 00:16:31,325
<c.magenta>添加引入可变语义到变动中</c>

325
00:16:31,391 --> 00:16:33,527
<c.magenta>它叫作引用可写键径</c>

326
00:16:34,695 --> 00:16:36,063
<c.magenta>那么让我们使用它</c>

327
00:16:36,129 --> 00:16:37,431
<c.magenta>这次编译通过了</c>

328
00:16:37,497 --> 00:16:39,466
<c.magenta>我们可以最终声明我们的小男孩本基</c>

329
00:16:39,533 --> 00:16:42,236
<c.magenta>大了一岁</c>

330
00:16:43,270 --> 00:16:44,338
<c.magenta>我们可以看看区别</c>

331
00:16:44,404 --> 00:16:46,874
<c.magenta>在这两种变动键径的方法之间</c>

332
00:16:48,208 --> 00:16:49,977
<c.magenta>我们有个</c>

333
00:16:50,043 --> 00:16:53,547
<c.magenta>WritableKeyPath</c>

334
00:16:53,881 --> 00:16:57,017
<c.magenta>因此base或者链式的base</c>

335
00:16:58,719 --> 00:17:03,156
<c.magenta>然而一个ReferenceWritableKeyPath</c>

336
00:16:58,719 --> 00:17:03,156
<c.magenta>然而一个ReferenceWritableKeyPath</c>

337
00:17:03,557 --> 00:17:06,326
<c.magenta>所有这些键径类型</c>

338
00:17:07,794 --> 00:17:09,730
<c.magenta>每个都比上一个更详细</c>

339
00:17:10,063 --> 00:17:11,565
<c.magenta>这棵树最上面的根</c>

340
00:17:11,632 --> 00:17:13,666
<c.magenta>是另一种我没有提到过的键径</c>

341
00:17:13,733 --> 00:17:16,837
<c.magenta>叫作AnyKeyPath</c>

342
00:17:17,003 --> 00:17:18,771
<c.magenta>这对于你有键径时很有用</c>

343
00:17:18,839 --> 00:17:21,575
<c.magenta>该键径是由多个base到</c>

344
00:17:21,642 --> 00:17:22,809
<c.magenta>通常是一个集</c>

345
00:17:24,144 --> 00:17:26,380
<c.magenta>如果这一切似乎有一点复杂</c>

346
00:17:26,445 --> 00:17:28,815
<c.magenta>我向你保证</c>

347
00:17:28,882 --> 00:17:32,286
<c.magenta>使用 还有获得</c>

348
00:17:32,352 --> 00:17:34,421
<c.magenta>还符合你已经熟悉的规则</c>

349
00:17:34,488 --> 00:17:37,524
<c.magenta>关于Swift值类型和引用类型的</c>

350
00:17:38,725 --> 00:17:41,128
<c.magenta>我们先解决一半问题</c>

351
00:17:41,328 --> 00:17:44,665
<c.magenta>只读属性总会产生一个键径</c>

352
00:17:44,731 --> 00:17:46,466
<c.magenta>（键径）</c>

353
00:17:46,767 --> 00:17:49,603
<c.magenta>而可读写属性</c>

354
00:17:50,938 --> 00:17:54,041
<c.magenta>可变值类型base或者</c>

355
00:17:54,107 --> 00:17:56,310
<c.magenta>会生成一个</c>

356
00:17:57,010 --> 00:18:01,515
<c.magenta>WritableKeyPath</c>

357
00:17:57,010 --> 00:18:01,515
<c.magenta>WritableKeyPath</c>

358
00:18:02,382 --> 00:18:04,418
<c.magenta>然而如果其中一个值类型</c>

359
00:18:05,519 --> 00:18:07,754
<c.magenta>是不可变的 就像是一个let语句</c>

360
00:18:08,655 --> 00:18:10,190
<c.magenta>该属性的可变性就消失了</c>

361
00:18:10,257 --> 00:18:13,026
<c.magenta>就好像你使用一般属性的时候</c>

362
00:18:13,227 --> 00:18:14,828
<c.magenta>你就剩下了KeyPath</c>

363
00:18:15,796 --> 00:18:17,564
<c.magenta>最后讲个最简单的例子</c>

364
00:18:17,631 --> 00:18:19,733
<c.magenta>在引入类型base上的可读写属性</c>

365
00:18:19,800 --> 00:18:22,102
<c.magenta>总是生成</c>

366
00:18:23,704 --> 00:18:27,074
<c.magenta>现在我想分享下关于</c>

367
00:18:28,108 --> 00:18:30,210
<c.magenta>当我们和subscript一起</c>

368
00:18:30,277 --> 00:18:33,547
<c.magenta>知道它们的行为和终结</c>

369
00:18:34,648 --> 00:18:36,183
<c.magenta>思考下面的例子</c>

370
00:18:36,550 --> 00:18:37,684
<c.magenta>这里我要生成一个键径</c>

371
00:18:37,751 --> 00:18:39,686
<c.magenta>来自于生日派对的第一个到场者</c>

372
00:18:40,153 --> 00:18:41,622
<c.magenta>并且使用它来识别他们的年龄</c>

373
00:18:41,688 --> 00:18:45,692
<c.magenta>使用我们前面的partyPersonAge方法</c>

374
00:18:46,226 --> 00:18:49,029
<c.magenta>不出所料 这里我们得到的键径</c>

375
00:18:49,096 --> 00:18:51,732
<c.magenta>是我们attendees数组</c>

376
00:18:53,133 --> 00:18:54,835
<c.magenta>假设我把序号变成了1</c>

377
00:18:54,902 --> 00:18:58,205
<c.magenta>出于某种原因</c>

378
00:18:59,506 --> 00:19:01,175
<c.magenta>你可能会感到惊讶</c>

379
00:18:59,506 --> 00:19:01,175
<c.magenta>你可能会感到惊讶</c>

380
00:19:02,342 --> 00:19:04,978
<c.magenta>结果键径没有变化</c>

381
00:19:05,045 --> 00:19:06,980
<c.magenta>尽管我把序号改变了</c>

382
00:19:07,481 --> 00:19:10,450
<c.magenta>通过这种方式</c>

383
00:19:10,851 --> 00:19:12,286
<c.magenta>它们由值所捕获</c>

384
00:19:12,452 --> 00:19:14,421
<c.magenta>当这个功能变得可用时</c>

385
00:19:14,488 --> 00:19:16,957
<c.magenta>我想要今天说以便你不会感到惊讶</c>

386
00:19:17,858 --> 00:19:18,825
<c.magenta>我现在说了</c>

387
00:19:20,060 --> 00:19:24,698
<c.magenta>到目前为止 我们已看了许多</c>

388
00:19:24,765 --> 00:19:29,670
<c.magenta>满足了我们快速、类型安全以及</c>

389
00:19:31,104 --> 00:19:32,906
<c.magenta>我想要换个主题了</c>

390
00:19:32,973 --> 00:19:34,341
<c.magenta>因为我想谈谈</c>

391
00:19:34,408 --> 00:19:37,010
<c.magenta>被用来改进</c>

392
00:19:37,744 --> 00:19:39,446
<c.magenta>特别是我想谈谈我们如何应用它们</c>

393
00:19:39,513 --> 00:19:40,781
<c.magenta>到键值观察上</c>

394
00:19:42,349 --> 00:19:45,619
<c.magenta>你们大概知道</c>

395
00:19:45,686 --> 00:19:49,022
<c.magenta>建立状态变化通知关系的方式</c>

396
00:19:49,590 --> 00:19:52,292
<c.magenta>如果你已经试着</c>

397
00:19:52,359 --> 00:19:56,063
<c.magenta>你大概知道它有点偏离预期了</c>

398
00:19:58,799 --> 00:20:00,868
<c.magenta>假设我们有个引用</c>

399
00:19:58,799 --> 00:20:00,868
<c.magenta>假设我们有个引用</c>

400
00:20:02,536 --> 00:20:04,004
<c.magenta>先别鼓掌 过会儿再鼓</c>

401
00:20:05,572 --> 00:20:08,175
<c.magenta>假设我们有个对于</c>

402
00:20:08,242 --> 00:20:10,410
<c.magenta>从前面例子里的小孩米亚</c>

403
00:20:10,477 --> 00:20:13,180
<c.magenta>我们关心这个孩子的年龄变化</c>

404
00:20:14,348 --> 00:20:18,185
<c.magenta>我们认为形成一个观察</c>

405
00:20:18,252 --> 00:20:19,119
<c.magenta>现在鼓掌吧</c>

406
00:20:25,092 --> 00:20:27,361
<c.magenta>我想要说明这个形成过程的一些细节</c>

407
00:20:27,861 --> 00:20:31,164
<c.magenta>我们要在值类型上</c>

408
00:20:31,431 --> 00:20:33,333
<c.magenta>使用我们新的类型安全键径</c>

409
00:20:34,067 --> 00:20:35,302
<c.magenta>我们得到的是一个类似于</c>

410
00:20:35,369 --> 00:20:38,505
<c.magenta>我们Notification Center API的</c>

411
00:20:38,572 --> 00:20:40,941
<c.magenta>这个observation token</c>

412
00:20:41,008 --> 00:20:44,778
<c.magenta>第一 它省去了我们</c>

413
00:20:44,845 --> 00:20:47,648
<c.magenta>有着独一无二识别我们</c>

414
00:20:47,881 --> 00:20:51,785
<c.magenta>我们的observation直接联系着</c>

415
00:20:51,985 --> 00:20:54,721
<c.magenta>第二 它管理了我们observation</c>

416
00:20:55,022 --> 00:20:57,558
<c.magenta>如果我…我不能将它设成nil…</c>

417
00:20:57,624 --> 00:21:00,561
<c.magenta>但是如果我把它设成nil</c>

418
00:20:57,624 --> 00:21:00,561
<c.magenta>但是如果我把它设成nil</c>

419
00:21:01,094 --> 00:21:03,430
<c.magenta>这是个巨大的改进 而不是获得异常</c>

420
00:21:03,497 --> 00:21:06,700
<c.magenta>当你忘了去除注册observation时</c>

421
00:21:07,968 --> 00:21:10,237
<c.magenta>最后 这可能是最棒的部分</c>

422
00:21:10,304 --> 00:21:14,808
<c.magenta>现在你可以利用终结来掌握</c>

423
00:21:15,108 --> 00:21:18,612
<c.magenta>而不是嵌套if语句</c>

424
00:21:19,112 --> 00:21:22,149
<c.magenta>让我们看看这个终结里面的参数</c>

425
00:21:23,050 --> 00:21:25,986
<c.magenta>它有两个参数</c>

426
00:21:26,153 --> 00:21:29,590
<c.magenta>这个是相同的引用 米亚</c>

427
00:21:30,357 --> 00:21:33,694
<c.magenta>来帮助你避免意外创建了保持循环</c>

428
00:21:34,862 --> 00:21:37,631
<c.magenta>第二个参数是一个change对象</c>

429
00:21:37,698 --> 00:21:40,868
<c.magenta>这和现存的KVO API很类似</c>

430
00:21:40,934 --> 00:21:42,703
<c.magenta>如果你用过 如果你熟悉那个API</c>

431
00:21:42,769 --> 00:21:44,571
<c.magenta>你就会知道那是个松类型词典</c>

432
00:21:44,638 --> 00:21:46,773
<c.magenta>而这里我们提供的是强类型结构体</c>

433
00:21:46,840 --> 00:21:49,109
<c.magenta>因为键径 我们知道</c>

434
00:21:49,176 --> 00:21:52,212
<c.magenta>因为键径 我们知道</c>

435
00:21:52,479 --> 00:21:54,448
<c.magenta>现在我想让这变得真实一点</c>

436
00:21:54,515 --> 00:21:55,582
<c.magenta>我们会举个例子</c>

437
00:21:55,816 --> 00:21:58,552
<c.magenta>假设我们有个控制器</c>

438
00:21:58,619 --> 00:22:00,287
<c.magenta>叫做KindergartenController</c>

439
00:21:58,619 --> 00:22:00,287
<c.magenta>叫做KindergartenController</c>

440
00:22:00,354 --> 00:22:03,223
<c.magenta>它有一个键值 可观察属性</c>

441
00:22:03,390 --> 00:22:06,059
<c.magenta>叫做representedKid</c>

442
00:22:06,126 --> 00:22:09,329
<c.magenta>让我们添加一个var i</c>

443
00:22:10,230 --> 00:22:12,099
<c.magenta>接着我们现在就要生成</c>

444
00:22:12,165 --> 00:22:14,434
<c.magenta>给我们的控制器</c>

445
00:22:14,501 --> 00:22:16,103
<c.magenta>我们将其存在var i上</c>

446
00:22:17,037 --> 00:22:19,139
<c.magenta>我们加入我们超秘密业务逻辑</c>

447
00:22:19,206 --> 00:22:21,441
<c.magenta>如果你看着觉得是错误的</c>

448
00:22:21,508 --> 00:22:23,277
<c.magenta>我向你们保证</c>

449
00:22:23,343 --> 00:22:26,280
<c.magenta>你总是准备好去幼儿园</c>

450
00:22:27,214 --> 00:22:28,182
<c.magenta>就是这样了</c>

451
00:22:28,448 --> 00:22:30,817
<c.magenta>这就是我们控制器的整个声明过程</c>

452
00:22:31,818 --> 00:22:33,187
<c.magenta>没有必要给一个dnit</c>

453
00:22:33,253 --> 00:22:35,656
<c.magenta>我抛弃或者毁坏了我的</c>

454
00:22:35,722 --> 00:22:38,091
<c.magenta>因为它联系着observation token</c>

455
00:22:38,158 --> 00:22:39,626
<c.magenta>当控制器消失的时候</c>

456
00:22:39,693 --> 00:22:43,330
<c.magenta>observation token也会消失</c>

457
00:22:43,830 --> 00:22:44,765
<c.magenta>接下来让我们</c>

458
00:22:45,732 --> 00:22:47,601
<c.magenta>接下来让我们创建控制器</c>

459
00:22:48,702 --> 00:22:50,404
<c.magenta>这里我们指向米亚</c>

460
00:22:50,470 --> 00:22:53,674
<c.magenta>通过我们之前定义的函数</c>

461
00:22:53,740 --> 00:22:56,276
<c.magenta>最终我们见识到了这些</c>

462
00:22:56,343 --> 00:22:58,145
<c.magenta>我们的小女孩长大了一岁</c>

463
00:23:00,480 --> 00:23:03,183
<c.magenta>目前为止</c>

464
00:23:03,250 --> 00:23:06,486
<c.magenta>但我想绕回来再讲一次</c>

465
00:23:07,621 --> 00:23:09,489
<c.magenta>这些会一直存在</c>

466
00:23:09,556 --> 00:23:12,192
<c.magenta>而且它们对于过期API来说</c>

467
00:23:13,093 --> 00:23:14,895
<c.magenta>坚持使用字符串</c>

468
00:23:15,963 --> 00:23:17,698
<c.magenta>然而 从Swift 4开始</c>

469
00:23:18,999 --> 00:23:22,436
<c.magenta>你可以使用这些新的高性能</c>

470
00:23:22,970 --> 00:23:24,137
<c.magenta>我们将其引入到语言中</c>

471
00:23:24,204 --> 00:23:26,707
<c.magenta>因为我们觉得它非常重要</c>

472
00:23:27,541 --> 00:23:30,344
<c.magenta>随着时间发展</c>

473
00:23:31,478 --> 00:23:33,847
<c.magenta>我想请托尼回到台上来讨论下</c>

474
00:23:33,914 --> 00:23:36,416
<c.magenta>我们今年引入到</c>

475
00:23:36,483 --> 00:23:37,351
<c.magenta>谢谢</c>

476
00:23:43,156 --> 00:23:44,491
<c.magenta>谢谢 迈克尔</c>

477
00:23:44,825 --> 00:23:47,528
<c.magenta>接下来 我们要谈谈编码和解码</c>

478
00:23:48,762 --> 00:23:51,198
<c.magenta>总的来说 编码和解码</c>

479
00:23:51,265 --> 00:23:55,836
<c.magenta>是关于你本地和定制</c>

480
00:23:55,903 --> 00:23:58,772
<c.magenta>还有压缩的格式 特别是JSON</c>

481
00:23:59,606 --> 00:24:02,676
<c.magenta>你们很多人都告诉我们</c>

482
00:23:59,606 --> 00:24:02,676
<c.magenta>你们很多人都告诉我们</c>

483
00:24:02,743 --> 00:24:05,979
<c.magenta>在强类型语言Swift</c>

484
00:24:06,046 --> 00:24:09,516
<c.magenta>和弱类型压缩数据类型</c>

485
00:24:10,517 --> 00:24:12,352
<c.magenta>我们相信这个挑战的答案</c>

486
00:24:12,419 --> 00:24:15,255
<c.magenta>是由语言本身开始</c>

487
00:24:15,556 --> 00:24:17,724
<c.magenta>还利用了编译器</c>

488
00:24:17,791 --> 00:24:22,763
<c.magenta>标准库 还有Foundation</c>

489
00:24:22,829 --> 00:24:26,266
<c.magenta>而且给你提供了强大定制化的机会</c>

490
00:24:27,167 --> 00:24:29,436
<c.magenta>让我们从一个例子开始</c>

491
00:24:30,904 --> 00:24:33,407
<c.magenta>这里有一些来自我们最喜欢的网站之一</c>

492
00:24:33,941 --> 00:24:35,576
<c.magenta>这是请求信息的结果</c>

493
00:24:35,642 --> 00:24:37,945
<c.magenta>关于一个档案的提交</c>

494
00:24:38,312 --> 00:24:39,680
<c.magenta>这是相当标准的JSON</c>

495
00:24:40,080 --> 00:24:43,116
<c.magenta>这是个JSON对象或者</c>

496
00:24:43,350 --> 00:24:45,752
<c.magenta>它支持一个任意数字的键值对</c>

497
00:24:45,819 --> 00:24:48,589
<c.magenta>在这里 名称 也就是一个字符串</c>

498
00:24:48,655 --> 00:24:52,326
<c.magenta>邮件 也是个字符串</c>

499
00:24:52,693 --> 00:24:55,863
<c.magenta>原因当然是</c>

500
00:24:56,263 --> 00:25:01,268
<c.magenta>但有很多种将日期编码成</c>

501
00:24:56,263 --> 00:25:01,268
<c.magenta>但有很多种将日期编码成</c>

502
00:25:01,335 --> 00:25:03,804
<c.magenta>这个显然是ISO8601</c>

503
00:25:04,738 --> 00:25:07,741
<c.magenta>如果我们要在Swift中</c>

504
00:25:08,008 --> 00:25:09,443
<c.magenta>它会看起来非常不一样</c>

505
00:25:10,444 --> 00:25:14,982
<c.magenta>例如 我们为它创建一个强类型</c>

506
00:25:15,849 --> 00:25:18,218
<c.magenta>这个结构体有三个属性</c>

507
00:25:18,285 --> 00:25:20,787
<c.magenta>名称和邮件还是字符串</c>

508
00:25:20,854 --> 00:25:24,591
<c.magenta>但日期如你所见</c>

509
00:25:25,425 --> 00:25:26,927
<c.magenta>这个原因很重要是因为</c>

510
00:25:26,994 --> 00:25:30,631
<c.magenta>随着你与其他Cocoa SDK</c>

511
00:25:30,697 --> 00:25:35,469
<c.magenta>你会发现日期是一种用来</c>

512
00:25:36,236 --> 00:25:38,839
<c.magenta>这就是我们遇到的挑战 对吧</c>

513
00:25:39,306 --> 00:25:43,110
<c.magenta>我们如何转换顶层弱类型JSON</c>

514
00:25:43,343 --> 00:25:45,679
<c.magenta>到底层的强类型Swift类型？</c>

515
00:25:46,480 --> 00:25:49,049
<c.magenta>我们认为应该像这样简单</c>

516
00:25:49,149 --> 00:25:51,852
<c.magenta>在你的结构体上采用一个协议</c>

517
00:25:51,919 --> 00:25:55,088
<c.magenta>让编译器 标准库</c>

518
00:25:55,155 --> 00:25:57,257
<c.magenta>来为你做大部分的工作</c>

519
00:25:59,459 --> 00:26:00,327
<c.magenta>谢谢</c>

520
00:25:59,459 --> 00:26:00,327
<c.magenta>谢谢</c>

521
00:26:04,097 --> 00:26:06,200
<c.magenta>让我们把幻灯片转到实际代码</c>

522
00:26:06,767 --> 00:26:08,602
<c.magenta>首先我要将</c>

523
00:26:08,669 --> 00:26:12,206
<c.magenta>用Swift 4中很酷的新文本句法</c>

524
00:26:12,439 --> 00:26:15,042
<c.magenta>接着利用UTF-8编码</c>

525
00:26:15,108 --> 00:26:16,743
<c.magenta>这对于JSON来说很常见</c>

526
00:26:16,844 --> 00:26:18,779
<c.magenta>当然了 结构体编写者保持不变</c>

527
00:26:19,279 --> 00:26:22,249
<c.magenta>接下来 我们创建一个解码器</c>

528
00:26:22,316 --> 00:26:25,719
<c.magenta>JSON和Swift结构间的转换</c>

529
00:26:27,287 --> 00:26:31,191
<c.magenta>我们告诉解码器这个转换</c>

530
00:26:31,425 --> 00:26:33,060
<c.magenta>我们后面再说</c>

531
00:26:33,493 --> 00:26:36,663
<c.magenta>最后我们请求解码器</c>

532
00:26:36,997 --> 00:26:39,399
<c.magenta>结果不是任意的</c>

533
00:26:39,466 --> 00:26:42,236
<c.magenta>你不需要检查字符串或者键值</c>

534
00:26:42,436 --> 00:26:45,405
<c.magenta>它已经是这种情况下</c>

535
00:26:46,773 --> 00:26:47,908
<c.magenta>这很简单</c>

536
00:26:48,175 --> 00:26:50,344
<c.magenta>让我们把难度提升一点</c>

537
00:26:50,644 --> 00:26:53,013
<c.magenta>这个JSON实际上</c>

538
00:26:53,080 --> 00:26:57,384
<c.magenta>伴随着这个请求的结果</c>

539
00:26:57,451 --> 00:26:59,720
<c.magenta>额外的字符串和整型值</c>

540
00:27:00,387 --> 00:27:03,190
<c.magenta>Swift中 我们照着做就可以</c>

541
00:27:03,357 --> 00:27:06,793
<c.magenta>我要将我的结构体编写者嵌套到</c>

542
00:27:06,860 --> 00:27:08,028
<c.magenta>也是可编码性</c>

543
00:27:08,595 --> 00:27:11,331
<c.magenta>你会发现我可以用</c>

544
00:27:11,732 --> 00:27:13,066
<c.magenta>还有我们的结构体编写者</c>

545
00:27:13,133 --> 00:27:15,402
<c.magenta>你会发现我们能递归地向下降类型</c>

546
00:27:15,469 --> 00:27:17,804
<c.magenta>如果它们也遵从可编码的规则</c>

547
00:27:18,539 --> 00:27:21,108
<c.magenta>信息这个字符串</c>

548
00:27:21,175 --> 00:27:22,643
<c.magenta>还有我们的</c>

549
00:27:23,310 --> 00:27:26,146
<c.magenta>要解码这个 只需要一行代码</c>

550
00:27:26,213 --> 00:27:27,881
<c.magenta>这次我们要解码一个提交</c>

551
00:27:28,215 --> 00:27:31,351
<c.magenta>结果是：我们的强Swift类型</c>

552
00:27:31,418 --> 00:27:33,787
<c.magenta>我们知道并且喜欢的</c>

553
00:27:33,854 --> 00:27:36,356
<c.magenta>来从压缩数据中得到我们想要的值</c>

554
00:27:36,423 --> 00:27:38,358
<c.magenta>在这里 就是属性访问</c>

555
00:27:39,893 --> 00:27:41,161
<c.magenta>让我们看看发生了什么</c>

556
00:27:41,595 --> 00:27:45,132
<c.magenta>首先 可编码协议</c>

557
00:27:45,599 --> 00:27:49,903
<c.magenta>第一个叫作Encodable</c>

558
00:27:50,637 --> 00:27:54,942
<c.magenta>这个函数的目的是</c>

559
00:27:55,008 --> 00:27:56,510
<c.magenta>它需要的所有信息</c>

560
00:27:56,577 --> 00:27:58,645
<c.magenta>以便接下来可以重建自己</c>

561
00:27:59,546 --> 00:28:03,050
<c.magenta>相应的协议 可解码性</c>

562
00:27:59,546 --> 00:28:03,050
<c.magenta>相应的协议 可解码性</c>

563
00:28:03,684 --> 00:28:07,187
<c.magenta>初始化的目的是</c>

564
00:28:07,254 --> 00:28:09,756
<c.magenta>从解码器中 接着使用这些值</c>

565
00:28:09,823 --> 00:28:14,228
<c.magenta>来创建一个可供随时使用的</c>

566
00:28:16,496 --> 00:28:18,599
<c.magenta>这些API的主要设计点</c>

567
00:28:18,665 --> 00:28:22,336
<c.magenta>是使用你可能已经熟悉的</c>

568
00:28:22,402 --> 00:28:24,538
<c.magenta>这叫作协议扩展</c>

569
00:28:24,771 --> 00:28:31,144
<c.magenta>Swift中 协议不仅可定义接口</c>

570
00:28:31,211 --> 00:28:34,882
<c.magenta>它们可以为该接口</c>

571
00:28:35,983 --> 00:28:38,886
<c.magenta>它们让你给两者之一写你自己的实现</c>

572
00:28:38,952 --> 00:28:41,955
<c.magenta>或者给整个协议来定制行为</c>

573
00:28:42,656 --> 00:28:45,225
<c.magenta>让我们回到提交看看这是如何运作的</c>

574
00:28:46,126 --> 00:28:47,861
<c.magenta>当我采用可编码的协议时</c>

575
00:28:47,928 --> 00:28:51,665
<c.magenta>编译器会生成encode to encoder</c>

576
00:28:51,732 --> 00:28:54,368
<c.magenta>还有init from decoder完全免费</c>

577
00:28:55,202 --> 00:28:57,571
<c.magenta>在这种情况下</c>

578
00:28:57,638 --> 00:29:00,574
<c.magenta>因此我可以从类型中完全移除它们</c>

579
00:28:57,638 --> 00:29:00,574
<c.magenta>因此我可以从类型中完全移除它们</c>

580
00:29:01,775 --> 00:29:04,178
<c.magenta>不过有一个是我想要定制的</c>

581
00:29:04,244 --> 00:29:06,480
<c.magenta>就是这个属性的名字</c>

582
00:29:06,813 --> 00:29:09,149
<c.magenta>你可以注意到它使用了蛇型连字符</c>

583
00:29:09,216 --> 00:29:10,717
<c.magenta>这在JSON中很常见</c>

584
00:29:10,784 --> 00:29:13,153
<c.magenta>但是这不符合Swift的命名规范</c>

585
00:29:13,587 --> 00:29:15,622
<c.magenta>让我给你们展示下如何修复这个问题</c>

586
00:29:15,822 --> 00:29:18,725
<c.magenta>首先 编译器还为我们</c>

587
00:29:18,792 --> 00:29:21,662
<c.magenta>就是这个叫CodingKeys</c>

588
00:29:23,363 --> 00:29:27,100
<c.magenta>这个枚举由字符串组成</c>

589
00:29:27,167 --> 00:29:29,102
<c.magenta>同样我们稍后再讲</c>

590
00:29:29,236 --> 00:29:33,040
<c.magenta>有趣的是这个枚举</c>

591
00:29:33,106 --> 00:29:35,709
<c.magenta>匹配我的四个属性的名字</c>

592
00:29:36,243 --> 00:29:39,146
<c.magenta>为了定制我的属性的名字</c>

593
00:29:39,213 --> 00:29:41,615
<c.magenta>我只需要定制case语句的名字</c>

594
00:29:42,015 --> 00:29:43,083
<c.magenta>为了实现这个</c>

595
00:29:43,150 --> 00:29:47,387
<c.magenta>我要将这个comment_count</c>

596
00:29:47,888 --> 00:29:52,492
<c.magenta>但是如你所见</c>

597
00:29:52,559 --> 00:29:54,494
<c.magenta>通过将该case的字符串值设置成</c>

598
00:29:54,561 --> 00:29:57,631
<c.magenta>我们预期在压缩数据中找到的值</c>

599
00:29:58,232 --> 00:30:03,003
<c.magenta>如果这就是我们需要做的所有定制</c>

600
00:29:58,232 --> 00:30:03,003
<c.magenta>如果这就是我们需要做的所有定制</c>

601
00:30:04,037 --> 00:30:08,408
<c.magenta>你可以不再看了并且离开</c>

602
00:30:08,475 --> 00:30:10,210
<c.magenta>我想给你们展示下我们能如何完成</c>

603
00:30:10,277 --> 00:30:12,779
<c.magenta>对于这个提交的更多定制</c>

604
00:30:13,380 --> 00:30:15,682
<c.magenta>现在我想把舞台交给同事毅太</c>

605
00:30:15,749 --> 00:30:17,784
<c.magenta>来给我们实际演示一下这个东西</c>

606
00:30:28,028 --> 00:30:28,862
<c.magenta>谢谢 托尼</c>

607
00:30:29,630 --> 00:30:33,567
<c.magenta>托尼给你们展示了在你的类型中</c>

608
00:30:33,634 --> 00:30:35,669
<c.magenta>不过让我们看看这会是什么样子</c>

609
00:30:35,736 --> 00:30:37,271
<c.magenta>在许多你们的实践应用中</c>

610
00:30:38,438 --> 00:30:41,074
<c.magenta>我这里有最近一直在做原型的小应用</c>

611
00:30:41,175 --> 00:30:42,776
<c.magenta>因为我是Swift的大粉丝</c>

612
00:30:42,843 --> 00:30:44,745
<c.magenta>我想要看有趣的git提交</c>

613
00:30:44,811 --> 00:30:46,780
<c.magenta>出现在Swift的GitHub repo</c>

614
00:30:47,648 --> 00:30:51,518
<c.magenta>这里我写了个小应用</c>

615
00:30:51,585 --> 00:30:54,254
<c.magenta>来解析这些提交</c>

616
00:30:54,855 --> 00:30:57,758
<c.magenta>让我们快看看把这个应用写完</c>

617
00:30:57,824 --> 00:30:59,326
<c.magenta>使用新的可编码性API</c>

618
00:31:01,228 --> 00:31:03,463
<c.magenta>如果我们切换到Xcode</c>

619
00:31:03,530 --> 00:31:06,567
<c.magenta>托尼在幻灯片上扩展了一点</c>

620
00:31:07,134 --> 00:31:10,337
<c.magenta>我们有相同的提交信息 编写者信息</c>

621
00:31:10,871 --> 00:31:13,006
<c.magenta>我们也做了同样的重命名</c>

622
00:31:13,774 --> 00:31:16,243
<c.magenta>右侧是GitHub所提供的</c>

623
00:31:16,310 --> 00:31:18,545
<c.magenta>不过有些不相关的部分被剪切掉了</c>

624
00:31:18,612 --> 00:31:20,314
<c.magenta>如果你注意看右下角</c>

625
00:31:20,380 --> 00:31:23,884
<c.magenta>在JSON代码中</c>

626
00:31:24,451 --> 00:31:26,553
<c.magenta>这没问题的 因为它会默认被忽略掉</c>

627
00:31:26,620 --> 00:31:28,222
<c.magenta>我们接下来再处理它</c>

628
00:31:28,689 --> 00:31:31,959
<c.magenta>让我们隐藏掉这个JSON代码</c>

629
00:31:32,025 --> 00:31:34,127
<c.magenta>来看看我们如何实际使用这些模型</c>

630
00:31:34,661 --> 00:31:37,197
<c.magenta>这里我们有</c>

631
00:31:37,264 --> 00:31:41,001
<c.magenta>这个是实际显示这些提交的</c>

632
00:31:41,335 --> 00:31:43,871
<c.magenta>这个视图控制器有我们的表格视图</c>

633
00:31:43,937 --> 00:31:45,572
<c.magenta>还有这些提交的数组</c>

634
00:31:45,873 --> 00:31:49,176
<c.magenta>注意这里是我们类型的一个数组</c>

635
00:31:49,409 --> 00:31:51,545
<c.magenta>不是任何其他或者类似的数组</c>

636
00:31:53,013 --> 00:31:55,482
<c.magenta>当我们要显示这个数据时</c>

637
00:31:55,549 --> 00:31:58,852
<c.magenta>我们可以从GitHub获取数据</c>

638
00:31:58,919 --> 00:32:00,320
<c.magenta>就像托尼向你们演示的那样</c>

639
00:31:58,919 --> 00:32:00,320
<c.magenta>就像托尼向你们演示的那样</c>

640
00:32:00,420 --> 00:32:03,924
<c.magenta>我们可以请求将这些提交的数组</c>

641
00:32:05,158 --> 00:32:08,462
<c.magenta>一旦完成 我们可以重新加载</c>

642
00:32:09,663 --> 00:32:12,566
<c.magenta>如果出问题了 我们可以捕捉错误</c>

643
00:32:12,633 --> 00:32:14,735
<c.magenta>并且显示一些本地信息给用户</c>

644
00:32:14,801 --> 00:32:16,870
<c.magenta>高层面地告诉他们哪里出错了</c>

645
00:32:17,838 --> 00:32:19,706
<c.magenta>这就是你如何将数据载入你的应用</c>

646
00:32:19,773 --> 00:32:21,942
<c.magenta>让我们看看</c>

647
00:32:22,176 --> 00:32:24,144
<c.magenta>往下一点看文件</c>

648
00:32:24,211 --> 00:32:26,847
<c.magenta>我有一个辅助函数</c>

649
00:32:26,914 --> 00:32:29,049
<c.magenta>在它们显示给用户之前</c>

650
00:32:29,116 --> 00:32:31,718
<c.magenta>这里要设置我的定制表格视图单元格</c>

651
00:32:31,785 --> 00:32:34,454
<c.magenta>我要从提交数组中抓取出一条提交</c>

652
00:32:34,688 --> 00:32:38,025
<c.magenta>接着使用该条提交的强类型属性</c>

653
00:32:38,091 --> 00:32:39,560
<c.magenta>我们就可以将其连接到UI</c>

654
00:32:39,660 --> 00:32:41,895
<c.magenta>再次注意我们没有向下转换任何</c>

655
00:32:41,962 --> 00:32:44,131
<c.magenta>而且没有通过数组或者词典配对</c>

656
00:32:44,198 --> 00:32:47,134
<c.magenta>这就是我们写类型的方式</c>

657
00:32:48,669 --> 00:32:50,737
<c.magenta>这都挺不错的</c>

658
00:32:50,804 --> 00:32:53,607
<c.magenta>你看这里就会发现</c>

659
00:32:53,674 --> 00:32:57,144
<c.magenta>我留下来连接给</c>

660
00:32:57,211 --> 00:32:59,880
<c.magenta>但它还没被连接上</c>

661
00:33:02,049 --> 00:33:05,452
<c.magenta>如果我们回到模型</c>

662
00:33:05,552 --> 00:33:10,023
<c.magenta>我们会发现在JSON代码中</c>

663
00:33:10,090 --> 00:33:11,592
<c.magenta>我们一直没有请求</c>

664
00:33:11,758 --> 00:33:13,660
<c.magenta>让我们把它加到我们的类型里</c>

665
00:33:13,927 --> 00:33:17,497
<c.magenta>接着 如果我构建项目来使用它</c>

666
00:33:17,564 --> 00:33:20,000
<c.magenta>你会发现我得到一个构建失败</c>

667
00:33:20,234 --> 00:33:22,002
<c.magenta>让我们看看为什么会这样</c>

668
00:33:23,203 --> 00:33:26,607
<c.magenta>作为这个类型的一部分</c>

669
00:33:26,807 --> 00:33:29,209
<c.magenta>这个你放进类型里的</c>

670
00:33:29,276 --> 00:33:32,646
<c.magenta>是用来控制编译器生成的强大工具</c>

671
00:33:32,713 --> 00:33:35,516
<c.magenta>作为NNCode 2初始的一部分</c>

672
00:33:35,949 --> 00:33:38,118
<c.magenta>在这个例子中</c>

673
00:33:38,185 --> 00:33:42,623
<c.magenta>来将我的提交信息属性重命名</c>

674
00:33:43,023 --> 00:33:45,659
<c.magenta>但这里 我刚添加的哈希属性</c>

675
00:33:45,726 --> 00:33:47,194
<c.magenta>在CodingKeys中找不到</c>

676
00:33:47,794 --> 00:33:49,596
<c.magenta>编译器会试着做的是</c>

677
00:33:49,663 --> 00:33:52,966
<c.magenta>如果你故意落下一个属性</c>

678
00:33:53,033 --> 00:33:57,037
<c.magenta>它就会从编码和解码显示中移除出去</c>

679
00:33:57,237 --> 00:33:58,238
<c.magenta>这里发生的是</c>

680
00:33:58,305 --> 00:34:01,842
<c.magenta>因为这个哈希属性没有一个默认值</c>

681
00:33:58,305 --> 00:34:01,842
<c.magenta>因为这个哈希属性没有一个默认值</c>

682
00:34:01,909 --> 00:34:05,279
<c.magenta>如果编译器试图给我们生成</c>

683
00:34:05,345 --> 00:34:08,348
<c.magenta>就不会有合理的值初始化给这个属性</c>

684
00:34:08,415 --> 00:34:11,051
<c.magenta>因此编译器拒绝这么做</c>

685
00:34:11,118 --> 00:34:14,021
<c.magenta>因为我们的类型实际上</c>

686
00:34:14,721 --> 00:34:16,590
<c.magenta>在这个例子中 我们实际上不想让</c>

687
00:34:16,657 --> 00:34:18,992
<c.magenta>这个哈希属性</c>

688
00:34:19,059 --> 00:34:20,127
<c.magenta>我们想要解码它</c>

689
00:34:20,226 --> 00:34:22,496
<c.magenta>让我们镜像这个相同的属性</c>

690
00:34:22,629 --> 00:34:23,931
<c.magenta>在我们的CodingKeys枚举中</c>

691
00:34:24,931 --> 00:34:27,801
<c.magenta>让我们再次隐藏JSON代码</c>

692
00:34:27,868 --> 00:34:29,101
<c.magenta>直接到我们的UI上</c>

693
00:34:29,436 --> 00:34:31,938
<c.magenta>在这个单元格设置方法中</c>

694
00:34:32,005 --> 00:34:35,175
<c.magenta>我们要加入另一行代码来抓取哈希值</c>

695
00:34:35,242 --> 00:34:38,212
<c.magenta>我们将要把它变短一点</c>

696
00:34:38,277 --> 00:34:40,746
<c.magenta>就像使用任何东西一样</c>

697
00:34:40,813 --> 00:34:42,616
<c.magenta>我们可以将其直接连接到我们的UI</c>

698
00:34:43,016 --> 00:34:44,518
<c.magenta>让我们回到我们的应用</c>

699
00:34:44,585 --> 00:34:47,387
<c.magenta>看一下确保所有东西都连接正确了</c>

700
00:34:49,723 --> 00:34:51,757
<c.magenta>这里我们已经重新运行了</c>

701
00:34:51,824 --> 00:34:54,161
<c.magenta>我们可以看到所有东西</c>

702
00:34:54,228 --> 00:34:57,130
<c.magenta>我很高兴 因为这只用了四行代码</c>

703
00:34:57,197 --> 00:34:58,131
<c.magenta>加到我们的应用中</c>

704
00:35:02,069 --> 00:35:02,903
<c.magenta>谢谢</c>

705
00:35:06,473 --> 00:35:08,208
<c.magenta>现在暂时回到代码中</c>

706
00:35:08,275 --> 00:35:11,912
<c.magenta>让我们看看当应用出错时</c>

707
00:35:13,013 --> 00:35:15,382
<c.magenta>如果我们再一次打开JSON代码</c>

708
00:35:15,449 --> 00:35:16,917
<c.magenta>你可能会注意到在右下角</c>

709
00:35:16,984 --> 00:35:19,386
<c.magenta>我们还有最后一个</c>

710
00:35:19,453 --> 00:35:21,221
<c.magenta>让我们现在完成它</c>

711
00:35:22,055 --> 00:35:24,658
<c.magenta>我们要把URL属性加入到</c>

712
00:35:24,725 --> 00:35:27,227
<c.magenta>并且在CodingKeys枚举中</c>

713
00:35:28,161 --> 00:35:31,231
<c.magenta>这次让我们给CodingKey</c>

714
00:35:31,298 --> 00:35:34,368
<c.magenta>明显在我们的JSON中是找不到的</c>

715
00:35:35,202 --> 00:35:37,738
<c.magenta>当我们试图解码这个值的时候</c>

716
00:35:37,804 --> 00:35:41,341
<c.magenta>它不会被找到</c>

717
00:35:42,109 --> 00:35:45,179
<c.magenta>看看我们如何解决这个错误</c>

718
00:35:45,245 --> 00:35:47,314
<c.magenta>往下找到我们实现解码的地方</c>

719
00:35:48,615 --> 00:35:50,083
<c.magenta>为了解决这个错误</c>

720
00:35:50,217 --> 00:35:53,620
<c.magenta>我们可以捕捉一个解码错误</c>

721
00:35:53,687 --> 00:35:56,823
<c.magenta>这表明了我们试图访问</c>

722
00:35:56,890 --> 00:35:58,926
<c.magenta>但它不能在加载内容的</c>

723
00:35:59,459 --> 00:36:01,595
<c.magenta>除了这个</c>

724
00:35:59,459 --> 00:36:01,595
<c.magenta>除了这个</c>

725
00:36:01,662 --> 00:36:03,163
<c.magenta>关于什么以及哪里出了错</c>

726
00:36:03,697 --> 00:36:07,134
<c.magenta>让我们在这设置一个断点</c>

727
00:36:07,201 --> 00:36:09,336
<c.magenta>看一下以确保我们可以捕捉到</c>

728
00:36:09,403 --> 00:36:10,571
<c.magenta>并且我们到达了断点</c>

729
00:36:11,805 --> 00:36:13,340
<c.magenta>现在我们运行了这个应用</c>

730
00:36:13,407 --> 00:36:15,409
<c.magenta>你会注意到我们确实到达了那个断点</c>

731
00:36:15,475 --> 00:36:18,278
<c.magenta>如果我们打印这个键</c>

732
00:36:18,345 --> 00:36:20,681
<c.magenta>我们给了一个有错误数值的URL键</c>

733
00:36:20,747 --> 00:36:22,716
<c.magenta>事实上 它在加载内容里找不到</c>

734
00:36:22,783 --> 00:36:24,051
<c.magenta>因此我们得到了这个错误</c>

735
00:36:25,052 --> 00:36:26,820
<c.magenta>这里我们如果看上下文环境信息</c>

736
00:36:26,887 --> 00:36:30,390
<c.magenta>你可以看到两个有用的功能</c>

737
00:36:31,091 --> 00:36:33,493
<c.magenta>首先是一条排除故障描述</c>

738
00:36:33,560 --> 00:36:36,930
<c.magenta>来看看哪里出了问题 还有代码路径</c>

739
00:36:36,997 --> 00:36:40,367
<c.magenta>其描述了在加载内容时哪里出了问题</c>

740
00:36:41,602 --> 00:36:43,604
<c.magenta>这些都很棒 不过事实上</c>

741
00:36:43,670 --> 00:36:47,040
<c.magenta>如果我不是很关心URL</c>

742
00:36:47,107 --> 00:36:48,242
<c.magenta>而且我可能不需要它</c>

743
00:36:48,308 --> 00:36:51,044
<c.magenta>那么解决这个错误的一个方法</c>

744
00:36:52,312 --> 00:36:54,414
<c.magenta>当你默认将这个属性设为可选时</c>

745
00:36:54,481 --> 00:36:56,583
<c.magenta>如果键或值没有被找到</c>

746
00:36:56,650 --> 00:36:59,386
<c.magenta>它会被初始化设为nil</c>

747
00:36:59,753 --> 00:37:01,788
<c.magenta>让我们隐藏我们的UI</c>

748
00:36:59,753 --> 00:37:01,788
<c.magenta>让我们隐藏我们的UI</c>

749
00:37:01,855 --> 00:37:03,857
<c.magenta>来看看我们是不是还会达到断点</c>

750
00:37:05,058 --> 00:37:07,594
<c.magenta>当我们重新运行时</c>

751
00:37:07,661 --> 00:37:10,864
<c.magenta>因为该值被默认设成了nil</c>

752
00:37:11,865 --> 00:37:13,600
<c.magenta>让我们回到代码并看一下</c>

753
00:37:13,667 --> 00:37:16,303
<c.magenta>我们还可以捕捉哪些有用的错误</c>

754
00:37:17,137 --> 00:37:20,807
<c.magenta>另一个错误像是</c>

755
00:37:20,874 --> 00:37:23,844
<c.magenta>其表明了我们试图解码</c>

756
00:37:23,911 --> 00:37:25,145
<c.magenta>但是实际上找到了nil</c>

757
00:37:25,979 --> 00:37:28,715
<c.magenta>你还得到了相同的上下文环境信息</c>

758
00:37:28,782 --> 00:37:30,651
<c.magenta>来告诉你什么以及哪里出了错</c>

759
00:37:32,386 --> 00:37:35,022
<c.magenta>同时 你或许想捕捉类型不匹配</c>

760
00:37:35,255 --> 00:37:38,125
<c.magenta>表明了你试图解码该类型的某些东西</c>

761
00:37:38,192 --> 00:37:40,160
<c.magenta>但是在加载内容里找到的是别的类型</c>

762
00:37:40,227 --> 00:37:43,797
<c.magenta>比如说 你试图解码一个字符串</c>

763
00:37:44,031 --> 00:37:47,100
<c.magenta>同样 你会跟前面一样</c>

764
00:37:48,101 --> 00:37:50,737
<c.magenta>当你想排除故障时 这些错误很有用</c>

765
00:37:50,804 --> 00:37:53,073
<c.magenta>当某些东西出错时 不过通常情况下</c>

766
00:37:53,140 --> 00:37:56,043
<c.magenta>你不会想要在最高级别</c>

767
00:37:56,109 --> 00:37:57,744
<c.magenta>取而代之 你只想要捕捉通用错误</c>

768
00:37:57,811 --> 00:38:00,247
<c.magenta>并显示一些本地的信息</c>

769
00:37:57,811 --> 00:38:00,247
<c.magenta>并显示一些本地的信息</c>

770
00:38:00,314 --> 00:38:02,316
<c.magenta>什么出错了或者报告这个漏洞</c>

771
00:38:03,450 --> 00:38:05,552
<c.magenta>这些实际上是非常强大的工具</c>

772
00:38:05,619 --> 00:38:07,187
<c.magenta>来实现一些更高级的事情</c>

773
00:38:07,487 --> 00:38:10,057
<c.magenta>如果你定制你的init from</c>

774
00:38:10,123 --> 00:38:13,160
<c.magenta>你可以捕捉类型里的这些错误</c>

775
00:38:13,227 --> 00:38:17,064
<c.magenta>像是数据迁移 重命名属性等等</c>

776
00:38:17,331 --> 00:38:19,099
<c.magenta>但在我们的应用中</c>

777
00:38:19,166 --> 00:38:21,568
<c.magenta>因为我已经通过少量代码</c>

778
00:38:22,002 --> 00:38:24,438
<c.magenta>我要将舞台交还给托尼</c>

779
00:38:24,505 --> 00:38:27,975
<c.magenta>一些更高级的编码和解码主题 谢谢</c>

780
00:38:33,313 --> 00:38:34,147
<c.magenta>谢谢 毅太</c>

781
00:38:35,682 --> 00:38:40,254
<c.magenta>让我们继续谈谈一些更高级的主题吧</c>

782
00:38:40,320 --> 00:38:41,788
<c.magenta>关于编码和解码的</c>

783
00:38:41,855 --> 00:38:44,324
<c.magenta>我们要谈谈我称之为三个支柱的</c>

784
00:38:44,391 --> 00:38:46,493
<c.magenta>可编码性API设计哲学</c>

785
00:38:46,827 --> 00:38:50,230
<c.magenta>首先是我们真的想要内置错误解决</c>

786
00:38:50,297 --> 00:38:51,598
<c.magenta>像是你在演示中所看到的</c>

787
00:38:52,566 --> 00:38:54,501
<c.magenta>当你在处理压缩数据的时候</c>

788
00:38:54,568 --> 00:38:59,039
<c.magenta>处理未预见的输入不是如果的问题</c>

789
00:38:59,773 --> 00:39:02,976
<c.magenta>这可能是数据侵蚀</c>

790
00:38:59,773 --> 00:39:02,976
<c.magenta>这可能是数据侵蚀</c>

791
00:39:03,043 --> 00:39:06,914
<c.magenta>来自你接收数据的地方</c>

792
00:39:06,980 --> 00:39:09,650
<c.magenta>有些人试图探查到你应用的弱点</c>

793
00:39:09,750 --> 00:39:11,952
<c.magenta>我们决定不应该有致命性的错误</c>

794
00:39:12,019 --> 00:39:13,987
<c.magenta>作为解析不受信任数据的结果</c>

795
00:39:14,454 --> 00:39:17,658
<c.magenta>然而我们确实在Swift中</c>

796
00:39:17,724 --> 00:39:20,194
<c.magenta>若我们检测到这可能是开发者的错误</c>

797
00:39:20,394 --> 00:39:22,229
<c.magenta>就会有一个含致命性错误的字符串</c>

798
00:39:22,296 --> 00:39:24,398
<c.magenta>在告诉你哪里可能出错了</c>

799
00:39:24,998 --> 00:39:28,535
<c.magenta>对于其他情况 我们使用</c>

800
00:39:28,602 --> 00:39:32,072
<c.magenta>这类错误在编码和解码时候</c>

801
00:39:32,973 --> 00:39:34,374
<c.magenta>让我们看看它们是什么样的</c>

802
00:39:35,108 --> 00:39:37,177
<c.magenta>首先 编码</c>

803
00:39:37,411 --> 00:39:40,747
<c.magenta>只有一种编码的错误 就是非法的值</c>

804
00:39:41,114 --> 00:39:43,650
<c.magenta>对于某些像JSON这样的格式</c>

805
00:39:43,717 --> 00:39:47,921
<c.magenta>我们想要给予它们灵活性来</c>

806
00:39:47,988 --> 00:39:51,258
<c.magenta>而不是报告一个致命性的错误</c>

807
00:39:51,592 --> 00:39:55,829
<c.magenta>例如在JSON中</c>

808
00:39:56,063 --> 00:39:58,165
<c.magenta>因此在这些情况下 它们能抛出错误</c>

809
00:39:58,232 --> 00:40:01,068
<c.magenta>你可能从类型层面上做不了太多</c>

810
00:39:58,232 --> 00:40:01,068
<c.magenta>你可能从类型层面上做不了太多</c>

811
00:40:01,134 --> 00:40:02,703
<c.magenta>不过你仍然可以在上层捕捉它</c>

812
00:40:02,769 --> 00:40:05,439
<c.magenta>并且呈献给你的用户一个错误</c>

813
00:40:05,506 --> 00:40:07,808
<c.magenta>或是呈现某种其他类型的恢复机制</c>

814
00:40:08,675 --> 00:40:12,279
<c.magenta>对于解码方面 有四种错误</c>

815
00:40:12,346 --> 00:40:14,348
<c.magenta>类型不匹配 找不到的键</c>

816
00:40:14,414 --> 00:40:17,417
<c.magenta>你可以通过空中处理机制解决</c>

817
00:40:17,484 --> 00:40:19,887
<c.magenta>如果它们确实是你类型所必需的部分</c>

818
00:40:19,953 --> 00:40:21,922
<c.magenta>或是将这些属性设为可选的</c>

819
00:40:22,656 --> 00:40:24,458
<c.magenta>最后我们有数据侵蚀</c>

820
00:40:24,658 --> 00:40:26,360
<c.magenta>数据侵蚀就是我们的捕捉所有错误</c>

821
00:40:26,426 --> 00:40:29,263
<c.magenta>对于解码过程所能发生的</c>

822
00:40:29,630 --> 00:40:31,164
<c.magenta>为了看看它何处可能会有用</c>

823
00:40:31,231 --> 00:40:34,168
<c.magenta>让我们深入看看解码时发生了什么</c>

824
00:40:34,635 --> 00:40:37,171
<c.magenta>首先开始的时候</c>

825
00:40:37,571 --> 00:40:39,072
<c.magenta>它可能来自于网络</c>

826
00:40:39,139 --> 00:40:42,176
<c.magenta>可能来自于磁盘上的某个文件</c>

827
00:40:42,242 --> 00:40:45,512
<c.magenta>无论从哪来的 在此时</c>

828
00:40:45,579 --> 00:40:49,283
<c.magenta>因此第一步就是</c>

829
00:40:50,450 --> 00:40:52,186
<c.magenta>例如 这个JSON解码器</c>

830
00:40:52,252 --> 00:40:55,389
<c.magenta>要验证JSON代码的</c>

831
00:40:55,722 --> 00:40:58,091
<c.magenta>在压缩数据的开始 个别的字节码</c>

832
00:40:58,158 --> 00:40:59,626
<c.magenta>表明了字符串编码</c>

833
00:40:59,893 --> 00:41:05,465
<c.magenta>特定的用于字符串分隔符的</c>

834
00:40:59,893 --> 00:41:05,465
<c.magenta>特定的用于字符串分隔符的</c>

835
00:41:05,866 --> 00:41:07,267
<c.magenta>若其中任何东西看上去有错</c>

836
00:41:07,334 --> 00:41:11,104
<c.magenta>JSON解码器就能抛出一个错误</c>

837
00:41:12,506 --> 00:41:16,176
<c.magenta>在那之后 我们想要从</c>

838
00:41:16,243 --> 00:41:19,179
<c.magenta>以及字符串转换到你的类型</c>

839
00:41:19,246 --> 00:41:21,849
<c.magenta>毕竟这个API就是为此而生的</c>

840
00:41:22,716 --> 00:41:24,685
<c.magenta>不过我们还可以做到更多</c>

841
00:41:25,385 --> 00:41:27,588
<c.magenta>我们称之为域相关合法性验证</c>

842
00:41:27,988 --> 00:41:31,158
<c.magenta>例如 你有个包含整型属性的类型</c>

843
00:41:31,225 --> 00:41:34,628
<c.magenta>但是合法的整数只有0到100之间</c>

844
00:41:35,195 --> 00:41:38,131
<c.magenta>或者你的类型有两种布尔属性</c>

845
00:41:38,198 --> 00:41:41,268
<c.magenta>但是它们有着互斥的关系</c>

846
00:41:41,635 --> 00:41:45,138
<c.magenta>这类事情很难通过Swift</c>

847
00:41:45,205 --> 00:41:48,208
<c.magenta>但是我们认为</c>

848
00:41:48,275 --> 00:41:50,277
<c.magenta>而这仅需多写点Swift代码</c>

849
00:41:50,344 --> 00:41:53,347
<c.magenta>我们想要确保提供给你机会来实现</c>

850
00:41:53,413 --> 00:41:55,315
<c.magenta>如果你有这类需求的话</c>

851
00:41:56,149 --> 00:41:58,385
<c.magenta>最后你还有图形级别合法性验证</c>

852
00:41:58,619 --> 00:41:59,720
<c.magenta>这是有关</c>

853
00:41:59,786 --> 00:42:03,056
<c.magenta>图中的对象彼此间的关系</c>

854
00:41:59,786 --> 00:42:03,056
<c.magenta>图中的对象彼此间的关系</c>

855
00:42:04,424 --> 00:42:05,993
<c.magenta>让我们将其应用到我们的提交中</c>

856
00:42:06,159 --> 00:42:09,296
<c.magenta>此前我们看到了如何定制</c>

857
00:42:09,363 --> 00:42:11,698
<c.magenta>通过定制叫作</c>

858
00:42:11,965 --> 00:42:14,067
<c.magenta>现在我们将要定制可解码性</c>

859
00:42:14,134 --> 00:42:16,069
<c.magenta>通过实现init from decoder</c>

860
00:42:16,870 --> 00:42:19,706
<c.magenta>首先 我为解码器请求一个容器</c>

861
00:42:20,207 --> 00:42:22,876
<c.magenta>容器就是用来匹配你的键</c>

862
00:42:22,943 --> 00:42:25,712
<c.magenta>到你期望在压缩数据中所找到的值</c>

863
00:42:26,813 --> 00:42:30,517
<c.magenta>一旦我们有了一个容器</c>

864
00:42:30,617 --> 00:42:34,087
<c.magenta>在这里 是一个URL</c>

865
00:42:34,154 --> 00:42:38,625
<c.magenta>还有我们的递归降序</c>

866
00:42:39,626 --> 00:42:41,428
<c.magenta>比如说现在我有一个额外需求</c>

867
00:42:41,495 --> 00:42:43,764
<c.magenta>就是我需要作为技术规格</c>

868
00:42:43,830 --> 00:42:47,067
<c.magenta>所有的URL都必须是HTTPS</c>

869
00:42:47,467 --> 00:42:49,636
<c.magenta>如果它们不是的话 就会有错误</c>

870
00:42:50,003 --> 00:42:53,574
<c.magenta>让我们看看如果实现吧</c>

871
00:42:54,208 --> 00:42:57,711
<c.magenta>然后 我会使用我们</c>

872
00:42:57,778 --> 00:42:59,713
<c.magenta>那就是scheme属性</c>

873
00:43:00,614 --> 00:43:03,817
<c.magenta>这里我只检查是否等于HTTPS</c>

874
00:43:03,951 --> 00:43:05,886
<c.magenta>我就可以抛出一个解码错误</c>

875
00:43:05,953 --> 00:43:08,689
<c.magenta>提供一个排除故障描述</c>

876
00:43:08,755 --> 00:43:10,357
<c.magenta>就如同毅太在演示中所展示的那样</c>

877
00:43:10,657 --> 00:43:14,995
<c.magenta>你没注意到的是 这个类型 提交</c>

878
00:43:15,062 --> 00:43:17,064
<c.magenta>检查了URL的字符串值</c>

879
00:43:17,698 --> 00:43:19,633
<c.magenta>我们可以允许URL解码自己</c>

880
00:43:20,167 --> 00:43:23,036
<c.magenta>这也是这个设计如此之棒的部分原因</c>

881
00:43:23,337 --> 00:43:26,006
<c.magenta>URL知道某个字符串是不是URL</c>

882
00:43:26,073 --> 00:43:29,109
<c.magenta>如果不是的话 它就会抛出一个错误</c>

883
00:43:29,409 --> 00:43:31,612
<c.magenta>由于Swift错误处理的设计</c>

884
00:43:31,678 --> 00:43:35,082
<c.magenta>可以延迟这个类型到解码提交</c>

885
00:43:35,148 --> 00:43:36,416
<c.magenta>或者甚至更高层级</c>

886
00:43:38,719 --> 00:43:40,521
<c.magenta>让我们接着看第二个支柱</c>

887
00:43:40,587 --> 00:43:43,257
<c.magenta>那就是编码细节的封装</c>

888
00:43:44,358 --> 00:43:48,128
<c.magenta>我们觉得保证键和值非常重要</c>

889
00:43:48,195 --> 00:43:51,665
<c.magenta>它们是一个类型选择私密的东西</c>

890
00:43:52,366 --> 00:43:53,734
<c.magenta>原因很重要</c>

891
00:43:53,800 --> 00:43:56,470
<c.magenta>因为这减少了我们的工作量</c>

892
00:43:56,537 --> 00:43:58,839
<c.magenta>设计某些带有全局知识的</c>

893
00:43:58,906 --> 00:44:01,475
<c.magenta>在压缩数据里可能会出现的东西</c>

894
00:43:58,906 --> 00:44:01,475
<c.magenta>在压缩数据里可能会出现的东西</c>

895
00:44:02,109 --> 00:44:04,878
<c.magenta>我们实现这种封装的主要机制</c>

896
00:44:04,945 --> 00:44:07,581
<c.magenta>叫作容器 我们有三种</c>

897
00:44:08,115 --> 00:44:10,017
<c.magenta>第一种叫作加密容器</c>

898
00:44:10,684 --> 00:44:14,021
<c.magenta>加密容器是大多数情况下的优先选择</c>

899
00:44:14,188 --> 00:44:18,358
<c.magenta>原因是因为</c>

900
00:44:18,759 --> 00:44:22,196
<c.magenta>如果你新版本的应用里</c>

901
00:44:22,429 --> 00:44:23,897
<c.magenta>你只需要用一个新的密钥</c>

902
00:44:24,498 --> 00:44:26,667
<c.magenta>这使得应用的绝大多数版本</c>

903
00:44:26,733 --> 00:44:28,769
<c.magenta>与你数据的绝大多数版本相兼容</c>

904
00:44:28,836 --> 00:44:31,104
<c.magenta>这对于每个人都是最好的可能结果</c>

905
00:44:32,039 --> 00:44:34,041
<c.magenta>让我们看看这些密钥实际上是什么</c>

906
00:44:34,107 --> 00:44:36,076
<c.magenta>早些时候</c>

907
00:44:36,143 --> 00:44:37,144
<c.magenta>就是这个</c>

908
00:44:37,444 --> 00:44:41,248
<c.magenta>它有两个协议</c>

909
00:44:41,748 --> 00:44:43,517
<c.magenta>属性就是stringValue</c>

910
00:44:43,584 --> 00:44:45,986
<c.magenta>例如 你在用JSON时候就很方便</c>

911
00:44:46,053 --> 00:44:48,956
<c.magenta>不过你也可以提供一个整型数值</c>

912
00:44:49,022 --> 00:44:51,992
<c.magenta>这或许提供了一个</c>

913
00:44:53,060 --> 00:44:56,396
<c.magenta>而初始化</c>

914
00:44:56,463 --> 00:44:57,798
<c.magenta>这就意味着解码器</c>

915
00:44:57,865 --> 00:45:01,235
<c.magenta>拥有执行额外一层安全性检查的能力</c>

916
00:44:57,865 --> 00:45:01,235
<c.magenta>拥有执行额外一层安全性检查的能力</c>

917
00:45:01,368 --> 00:45:03,871
<c.magenta>它可以验证你的代码密钥</c>

918
00:45:03,937 --> 00:45:07,808
<c.magenta>你在压缩数据中所找到的值</c>

919
00:45:08,275 --> 00:45:11,345
<c.magenta>通常你要在枚举上采用这个协议</c>

920
00:45:11,411 --> 00:45:12,946
<c.magenta>就如同我们目前看到的这个</c>

921
00:45:13,280 --> 00:45:15,048
<c.magenta>这里所发生的就是</c>

922
00:45:15,115 --> 00:45:16,583
<c.magenta>标准库的编译器</c>

923
00:45:16,650 --> 00:45:19,086
<c.magenta>提供一个所有这四种需求的实现</c>

924
00:45:19,152 --> 00:45:20,420
<c.magenta>完全免费给我们</c>

925
00:45:20,888 --> 00:45:23,957
<c.magenta>在这里 因为枚举是由字符串组成的</c>

926
00:45:24,458 --> 00:45:27,027
<c.magenta>编译器使用case名</c>

927
00:45:27,094 --> 00:45:29,329
<c.magenta>同时为了属性还有初始化</c>

928
00:45:29,696 --> 00:45:31,231
<c.magenta>不过intValue还是nil</c>

929
00:45:31,298 --> 00:45:33,033
<c.magenta>因为在这个枚举中没有足够的信息</c>

930
00:45:33,100 --> 00:45:35,102
<c.magenta>来给它分配一个特定值</c>

931
00:45:36,003 --> 00:45:39,406
<c.magenta>早前当我们定制case名的时候</c>

932
00:45:39,473 --> 00:45:42,509
<c.magenta>我们改变了case的名字</c>

933
00:45:42,576 --> 00:45:45,812
<c.magenta>因此stringValue仍和</c>

934
00:45:47,147 --> 00:45:48,582
<c.magenta>如果你在写库的代码</c>

935
00:45:48,649 --> 00:45:52,119
<c.magenta>我会鼓励你考虑用整型</c>

936
00:45:52,186 --> 00:45:56,323
<c.magenta>如果你这么做</c>

937
00:45:56,390 --> 00:46:00,060
<c.magenta>在这个例子中</c>

938
00:45:56,390 --> 00:46:00,060
<c.magenta>在这个例子中</c>

939
00:46:00,127 --> 00:46:01,728
<c.magenta>其可能支持整型密钥</c>

940
00:46:03,697 --> 00:46:08,569
<c.magenta>我们也支持未加密容器</c>

941
00:46:09,236 --> 00:46:12,806
<c.magenta>对于有序或无边界的数据</c>

942
00:46:12,873 --> 00:46:14,541
<c.magenta>你不需要生成假的密钥</c>

943
00:46:14,608 --> 00:46:16,543
<c.magenta>让你的数据进入压缩数据</c>

944
00:46:16,977 --> 00:46:19,213
<c.magenta>我们也支持单一值容器</c>

945
00:46:19,279 --> 00:46:22,349
<c.magenta>就如这个名字所指的</c>

946
00:46:22,883 --> 00:46:24,251
<c.magenta>对于主类型使用这些容器</c>

947
00:46:24,318 --> 00:46:26,253
<c.magenta>例如 以秒数保存的日期</c>

948
00:46:26,553 --> 00:46:28,155
<c.magenta>由于是时间内的一个引用点</c>

949
00:46:28,889 --> 00:46:30,691
<c.magenta>当你在其中选择的时候 你应该注意</c>

950
00:46:30,757 --> 00:46:34,728
<c.magenta>这些是最不兼容的选择 一定要记住</c>

951
00:46:35,796 --> 00:46:37,898
<c.magenta>让我们再一次回到我们的提交</c>

952
00:46:39,066 --> 00:46:41,335
<c.magenta>我们可以看到</c>

953
00:46:41,401 --> 00:46:43,237
<c.magenta>还有它的CodingKeys</c>

954
00:46:43,303 --> 00:46:45,539
<c.magenta>通过改变init</c>

955
00:46:45,806 --> 00:46:49,476
<c.magenta>现在让我们看看</c>

956
00:46:49,776 --> 00:46:52,145
<c.magenta>实际上 我在这不需要定制任何东西</c>

957
00:46:52,212 --> 00:46:53,814
<c.magenta>不过我仍然想给你们展示看看</c>

958
00:46:53,881 --> 00:46:55,582
<c.magenta>以便你们能理解它是如何运作的</c>

959
00:46:55,649 --> 00:46:59,586
<c.magenta>首先 我们有一个容器</c>

960
00:46:59,653 --> 00:47:02,756
<c.magenta>藉由我们自己的私密</c>

961
00:46:59,653 --> 00:47:02,756
<c.magenta>藉由我们自己的私密</c>

962
00:47:03,290 --> 00:47:06,193
<c.magenta>这个容器就是我如何编码</c>

963
00:47:06,260 --> 00:47:08,562
<c.magenta>我想要放入压缩数据的值</c>

964
00:47:08,629 --> 00:47:11,498
<c.magenta>我们的URL信息 编写者</c>

965
00:47:11,565 --> 00:47:12,666
<c.magenta>还有commentCount</c>

966
00:47:13,500 --> 00:47:16,436
<c.magenta>我想给你们展示一个如何选择的例子</c>

967
00:47:16,503 --> 00:47:18,805
<c.magenta>比如说我们正在处理</c>

968
00:47:18,872 --> 00:47:20,874
<c.magenta>其有一个点的概念</c>

969
00:47:21,275 --> 00:47:24,945
<c.magenta>点有两个值 它应该在JSON中</c>

970
00:47:25,012 --> 00:47:28,315
<c.magenta>为了使其能正常运作</c>

971
00:47:28,382 --> 00:47:32,186
<c.magenta>并且使用一个未加密容器</c>

972
00:47:32,252 --> 00:47:35,622
<c.magenta>你会注意到这个容器中没有密钥</c>

973
00:47:35,689 --> 00:47:37,591
<c.magenta>当我编码的时候 我没有用密钥</c>

974
00:47:37,658 --> 00:47:40,494
<c.magenta>JSON中的结果就像是这样</c>

975
00:47:41,728 --> 00:47:43,630
<c.magenta>我们也支持嵌套式的容器</c>

976
00:47:44,398 --> 00:47:46,900
<c.magenta>比如说我的词典中的第二个项目</c>

977
00:47:46,967 --> 00:47:48,936
<c.magenta>需要包含三个值的一个数组</c>

978
00:47:49,002 --> 00:47:53,207
<c.magenta>因此 如你所见 我们支持嵌套</c>

979
00:47:53,273 --> 00:47:56,276
<c.magenta>或者其他任何加密</c>

980
00:47:56,977 --> 00:48:00,080
<c.magenta>嵌套式容器的主要用例就是类</c>

981
00:47:56,977 --> 00:48:00,080
<c.magenta>嵌套式容器的主要用例就是类</c>

982
00:48:00,414 --> 00:48:03,250
<c.magenta>到目前为止</c>

983
00:48:03,317 --> 00:48:06,220
<c.magenta>但嵌套式容器给了我们一个自然机制</c>

984
00:48:06,286 --> 00:48:09,890
<c.magenta>从我们作为子类的自己数据</c>

985
00:48:09,957 --> 00:48:11,592
<c.magenta>也就是一个来自于NSCoding的变化</c>

986
00:48:12,092 --> 00:48:13,126
<c.magenta>我们来看一个例子</c>

987
00:48:13,360 --> 00:48:16,263
<c.magenta>就是每个人都喜欢的</c>

988
00:48:16,330 --> 00:48:18,799
<c.magenta>很自然 动物有个legCount</c>

989
00:48:19,566 --> 00:48:21,235
<c.magenta>还有它自己的CodingKeys</c>

990
00:48:21,301 --> 00:48:25,005
<c.magenta>并且你看到在这个类中</c>

991
00:48:25,072 --> 00:48:26,473
<c.magenta>它是一个必需的初始化</c>

992
00:48:27,674 --> 00:48:29,176
<c.magenta>这里我创建了一个加密容器</c>

993
00:48:29,243 --> 00:48:31,812
<c.magenta>使用动物的CodingKeys</c>

994
00:48:31,979 --> 00:48:33,780
<c.magenta>跟我们目前为止所见过的很类似</c>

995
00:48:34,481 --> 00:48:35,782
<c.magenta>让我们创建一个它的子类</c>

996
00:48:36,450 --> 00:48:38,585
<c.magenta>狗是有最好朋友的一种动物</c>

997
00:48:38,652 --> 00:48:40,888
<c.magenta>也就是我们早前生日派对里的小孩</c>

998
00:48:41,154 --> 00:48:45,192
<c.magenta>你会注意到dog也有个叫作</c>

999
00:48:45,259 --> 00:48:48,529
<c.magenta>即使它有着与超类中相同的名字</c>

1000
00:48:48,595 --> 00:48:52,900
<c.magenta>因为它是私有的</c>

1001
00:48:53,333 --> 00:48:55,836
<c.magenta>因此 当我实现dog的</c>

1002
00:48:55,903 --> 00:48:58,672
<c.magenta>并且使用它自己的CodingKeys</c>

1003
00:48:58,739 --> 00:49:02,643
<c.magenta>我可以利用对于它来说重要的密钥</c>

1004
00:48:58,739 --> 00:49:02,643
<c.magenta>我可以利用对于它来说重要的密钥</c>

1005
00:49:02,709 --> 00:49:03,777
<c.magenta>而不是对它的超类重要</c>

1006
00:49:04,444 --> 00:49:06,213
<c.magenta>现在 我们需要完成那个嵌套</c>

1007
00:49:06,446 --> 00:49:08,248
<c.magenta>我们可以调用超类</c>

1008
00:49:08,315 --> 00:49:11,552
<c.magenta>利用我们接收到的解码器</c>

1009
00:49:11,919 --> 00:49:17,157
<c.magenta>然而 这不会给容器机会</c>

1010
00:49:17,624 --> 00:49:20,894
<c.magenta>因此 最简单的实现方法</c>

1011
00:49:20,961 --> 00:49:22,095
<c.magenta>叫作superDecoder</c>

1012
00:49:22,162 --> 00:49:25,098
<c.magenta>它会获得一个新的</c>

1013
00:49:25,332 --> 00:49:30,537
<c.magenta>通过调用super 我们满足了</c>

1014
00:49:30,604 --> 00:49:33,874
<c.magenta>其实现了一个随时可用的</c>

1015
00:49:36,910 --> 00:49:38,445
<c.magenta>最后是我们的第三个支柱</c>

1016
00:49:38,512 --> 00:49:42,382
<c.magenta>那就是从这些类型中抽象出编码格式</c>

1017
00:49:43,483 --> 00:49:45,452
<c.magenta>我们觉得能够重用很重要</c>

1018
00:49:45,519 --> 00:49:48,288
<c.magenta>就是重用这些协议的实现</c>

1019
00:49:49,022 --> 00:49:50,724
<c.magenta>我们不想以这种局面结束</c>

1020
00:49:50,791 --> 00:49:53,694
<c.magenta>就是我们有很多几乎相同的实现</c>

1021
00:49:53,760 --> 00:49:57,231
<c.magenta>对于可编码性和可解码性</c>

1022
00:49:57,865 --> 00:50:00,334
<c.magenta>因此通过抽象格式</c>

1023
00:49:57,865 --> 00:50:00,334
<c.magenta>因此通过抽象格式</c>

1024
00:50:00,400 --> 00:50:03,403
<c.magenta>我们可以不改变任何库</c>

1025
00:50:03,537 --> 00:50:07,508
<c.magenta>这些格式可以来自于我们或你们</c>

1026
00:50:07,574 --> 00:50:10,010
<c.magenta>这些格式可以与这些类型一起运作</c>

1027
00:50:10,077 --> 00:50:12,880
<c.magenta>来自于我们的 来自于你们的</c>

1028
00:50:13,714 --> 00:50:16,083
<c.magenta>不过我们也理解 不同的格式</c>

1029
00:50:16,149 --> 00:50:19,286
<c.magenta>有着不同的基础类型和不同的规范</c>

1030
00:50:19,820 --> 00:50:21,588
<c.magenta>因为我们保证运作正常的机制</c>

1031
00:50:21,655 --> 00:50:23,123
<c.magenta>叫作编码战略</c>

1032
00:50:23,624 --> 00:50:27,761
<c.magenta>这是针对特定类型的</c>

1033
00:50:28,061 --> 00:50:30,564
<c.magenta>例如 在JSON中</c>

1034
00:50:30,931 --> 00:50:34,935
<c.magenta>在我们的GitHub例子中</c>

1035
00:50:35,402 --> 00:50:38,105
<c.magenta>不过还有其他可能的规范</c>

1036
00:50:38,172 --> 00:50:40,841
<c.magenta>例如 作为引用日期的秒数</c>

1037
00:50:40,908 --> 00:50:43,076
<c.magenta>作为引用日期的毫秒数</c>

1038
00:50:43,143 --> 00:50:45,746
<c.magenta>或者你甚至可以声明</c>

1039
00:50:45,812 --> 00:50:48,015
<c.magenta>如果你脑子里有些很专注的东西</c>

1040
00:50:48,916 --> 00:50:51,785
<c.magenta>JSON编码器和解码器</c>

1041
00:50:51,852 --> 00:50:53,654
<c.magenta>例如 对于数据</c>

1042
00:50:53,854 --> 00:50:56,990
<c.magenta>在JSON中 用Base64</c>

1043
00:50:57,824 --> 00:51:01,061
<c.magenta>不过我们也允许你通过选择战略</c>

1044
00:50:57,824 --> 00:51:01,061
<c.magenta>不过我们也允许你通过选择战略</c>

1045
00:51:01,128 --> 00:51:03,564
<c.magenta>也就是作为字节码的数组来编码它</c>

1046
00:51:03,630 --> 00:51:06,200
<c.magenta>或者你可以声明某些完全定制的东西</c>

1047
00:51:06,266 --> 00:51:09,136
<c.magenta>把所有的零变成绵羊</c>

1048
00:51:09,403 --> 00:51:13,373
<c.magenta>我不知道你为什么要这么做</c>

1049
00:51:13,907 --> 00:51:17,377
<c.magenta>抽象也可以帮助我们利用不同的格式</c>

1050
00:51:17,444 --> 00:51:19,479
<c.magenta>如我们所见 今天谈论了</c>

1051
00:51:19,546 --> 00:51:23,016
<c.magenta>但实际上 我们也引入了</c>

1052
00:51:23,283 --> 00:51:27,721
<c.magenta>而属性表 不像是JSON</c>

1053
00:51:27,821 --> 00:51:29,756
<c.magenta>因此当这些编码器和解码器</c>

1054
00:51:30,090 --> 00:51:32,860
<c.magenta>遇到这些对象</c>

1055
00:51:32,926 --> 00:51:34,995
<c.magenta>还是在解压缩的数据里</c>

1056
00:51:35,329 --> 00:51:38,565
<c.magenta>我们都可以将它们转换成</c>

1057
00:51:39,733 --> 00:51:42,503
<c.magenta>由于这些抽象</c>

1058
00:51:42,569 --> 00:51:45,939
<c.magenta>在许多Foundation类型中</c>

1059
00:51:47,708 --> 00:51:49,543
<c.magenta>我们已经谈论了许多关于</c>

1060
00:51:49,610 --> 00:51:51,845
<c.magenta>我想要给你们一个清晰的概括</c>

1061
00:51:51,912 --> 00:51:54,047
<c.magenta>来帮助你们理解全局</c>

1062
00:51:54,114 --> 00:51:56,450
<c.magenta>当然了 我们从你的类型开始</c>

1063
00:51:56,517 --> 00:52:00,754
<c.magenta>你的类型采用两种协议</c>

1064
00:51:56,517 --> 00:52:00,754
<c.magenta>你的类型采用两种协议</c>

1065
00:52:01,822 --> 00:52:03,924
<c.magenta>它们有一个函数和一个初始化</c>

1066
00:52:03,991 --> 00:52:07,160
<c.magenta>其让你访问编码器和解码器</c>

1067
00:52:08,161 --> 00:52:10,163
<c.magenta>这些可供你访问容器</c>

1068
00:52:10,230 --> 00:52:13,133
<c.magenta>那也是在压缩数据中</c>

1069
00:52:13,200 --> 00:52:14,868
<c.magenta>在加密容器的情况下</c>

1070
00:52:14,935 --> 00:52:18,005
<c.magenta>我们使用由你的类型</c>

1071
00:52:19,106 --> 00:52:21,475
<c.magenta>最后 就是编码器和容器</c>

1072
00:52:21,542 --> 00:52:26,079
<c.magenta>提供了对于编码格式的抽象</c>

1073
00:52:28,148 --> 00:52:31,351
<c.magenta>我们今天开始时候</c>

1074
00:52:31,418 --> 00:52:34,321
<c.magenta>还有今年新发布的</c>

1075
00:52:34,388 --> 00:52:37,691
<c.magenta>在那之后</c>

1076
00:52:37,758 --> 00:52:42,596
<c.magenta>包括一个非常酷的用例 就是全新的</c>

1077
00:52:43,063 --> 00:52:45,766
<c.magenta>最后 我们介绍新的可编码性协议</c>

1078
00:52:45,832 --> 00:52:48,836
<c.magenta>其使得与其他格式的集成非常简单</c>

1079
00:52:48,902 --> 00:52:52,306
<c.magenta>而且也允许你进行强大的定制</c>

1080
00:52:53,607 --> 00:52:55,542
<c.magenta>有关更多信息 请查阅这个链接</c>

1081
00:52:56,009 --> 00:52:58,879
<c.magenta>我们有一些与所谈内容相关的演讲</c>

1082
00:53:00,514 --> 00:53:01,448
<c.magenta>非常感谢</c>
