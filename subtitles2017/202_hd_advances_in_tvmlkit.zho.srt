1
00:00:20,516 --> 00:00:22,916
[掌声]

2
00:00:23,416 --> 00:00:23,596
&gt;&gt; 早上好

3
00:00:25,956 --> 00:00:28,146
欢迎来听“TVMLKit  的新改进”

4
00:00:28,526 --> 00:00:29,146
我叫 Trevor

5
00:00:29,146 --> 00:00:30,486
是本地化部门的员工

6
00:00:30,486 --> 00:00:31,526
我的同事  来自 tvOS 部门的

7
00:00:31,526 --> 00:00:32,936
Parry 和 Jeremy 会在我

8
00:00:32,936 --> 00:00:33,866
之后发言

9
00:00:34,366 --> 00:00:35,656
今天   我们很高兴

10
00:00:35,656 --> 00:00:37,146
能和大家分享我们对 TVMLKit

11
00:00:37,146 --> 00:00:39,586
做出的三大新改进

12
00:00:39,586 --> 00:00:41,226
TVMLKit 是一个开发者框架

13
00:00:41,226 --> 00:00:42,586
用于为 Apple TV 开发

14
00:00:42,586 --> 00:00:45,246
原生应用程序  该框架

15
00:00:45,466 --> 00:00:47,356
可整合 JavaScript 和苹果自定义

16
00:00:47,356 --> 00:00:48,646
标记语言 TVML

17
00:00:51,376 --> 00:00:52,716
首先  演讲内容会谈到

18
00:00:52,716 --> 00:00:54,146
对从右往左书写文字的支持

19
00:00:55,166 --> 00:00:56,866
第二位演讲者 Parry 会给大家

20
00:00:56,866 --> 00:00:57,876
展示如何应用模版中

21
00:00:57,876 --> 00:00:59,426
一些新增的优化功能

22
00:00:59,696 --> 00:01:01,066
来提升程序性能

23
00:00:59,696 --> 00:01:01,066
来提升程序性能

24
00:01:02,016 --> 00:01:03,456
最后  Jeremy 会

25
00:01:03,456 --> 00:01:04,995
给大家展示 Web 审查器中

26
00:01:04,995 --> 00:01:06,376
新增了哪些很棒的新功能

27
00:01:06,436 --> 00:01:07,286
可帮你更便捷地

28
00:01:07,286 --> 00:01:08,826
给你的程序调试排错

29
00:01:09,316 --> 00:01:10,636
下面我们就开始  我先讲

30
00:01:10,636 --> 00:01:11,896
对从右往左书写文字的支持

31
00:01:14,836 --> 00:01:16,456
tvOS 11 中新增了

32
00:01:16,456 --> 00:01:17,996
两个可选语言  分别是阿拉伯语

33
00:01:17,996 --> 00:01:18,946
和希伯来语

34
00:01:20,206 --> 00:01:22,386
两门语言全球有超过4亿人使用

35
00:01:22,386 --> 00:01:23,806
如果你的 App

36
00:01:23,806 --> 00:01:25,436
能够在这两门语言环境下运行

37
00:01:25,666 --> 00:01:27,106
就可让各位开发的应用触及到更多的用户

38
00:01:28,416 --> 00:01:29,626
要支持阿拉伯语和希伯来语

39
00:01:29,626 --> 00:01:30,846
对比大家的应用程序目前

40
00:01:30,846 --> 00:01:31,986
已经支持的其他语言

41
00:01:31,986 --> 00:01:33,556
区别在于阿拉伯语和希伯来语

42
00:01:33,556 --> 00:01:35,156
都是从右往左书写的

43
00:01:35,196 --> 00:01:35,646
文字

44
00:01:36,686 --> 00:01:37,646
我先给大家看几个例子  展示一下

45
00:01:37,646 --> 00:01:38,786
支持从右往左书写语言后

46
00:01:38,786 --> 00:01:40,066
大家的应用程序  看起来

47
00:01:40,066 --> 00:01:41,036
大概什么样

48
00:01:45,056 --> 00:01:46,846
现在显示的是一个

49
00:01:46,846 --> 00:01:47,926
从左往右书写语言模式下

50
00:01:47,926 --> 00:01:50,126
的产品模版  大部分人

51
00:01:50,126 --> 00:01:51,256
可能已经很熟悉这个

52
00:01:51,256 --> 00:01:51,826
界面了

53
00:01:51,916 --> 00:01:53,446
文字左对齐

54
00:01:53,796 --> 00:01:55,226
内容排布顺序

55
00:01:55,226 --> 00:01:56,376
是从屏幕左边

56
00:01:56,376 --> 00:01:57,426
排向屏幕右边

57
00:01:58,006 --> 00:01:59,126
优先选中的第一个按钮

58
00:01:59,126 --> 00:02:00,186
也是在屏幕的

59
00:01:59,126 --> 00:02:00,186
也是在屏幕的

60
00:02:00,186 --> 00:02:00,966
最左边

61
00:02:02,096 --> 00:02:03,446
现在  如果我们选用这个模版

62
00:02:03,896 --> 00:02:04,846
然后在从右往左

63
00:02:04,846 --> 00:02:06,376
书写文字模式下加载

64
00:02:06,376 --> 00:02:08,406
比如选择希伯来语  就可以看到

65
00:02:08,406 --> 00:02:09,466
页面布局被左右翻转了

66
00:02:09,466 --> 00:02:11,606
内容排布顺序会变成

67
00:02:11,606 --> 00:02:12,786
从屏幕右边

68
00:02:12,786 --> 00:02:13,526
排向屏幕左边

69
00:02:13,826 --> 00:02:15,146
文字右对齐

70
00:02:15,646 --> 00:02:17,106
优先选中的  还是第一个按钮

71
00:02:17,106 --> 00:02:18,326
但现在这一项位于

72
00:02:18,326 --> 00:02:19,016
屏幕右边了

73
00:02:19,506 --> 00:02:21,386
我们再看一个例子

74
00:02:23,296 --> 00:02:24,976
这是目录模版

75
00:02:24,976 --> 00:02:27,146
和刚才一样  如果你常用的语言

76
00:02:27,146 --> 00:02:28,646
是从左往右书写的

77
00:02:28,646 --> 00:02:29,986
你可能会很熟悉这个界面

78
00:02:29,986 --> 00:02:30,536
很自然

79
00:02:30,976 --> 00:02:32,026
但如果我们把同一个模版

80
00:02:32,026 --> 00:02:33,396
放到从右往左书写文字的

81
00:02:33,396 --> 00:02:35,126
模式下  我们会发现

82
00:02:35,126 --> 00:02:36,676
页面布局同样被翻转了

83
00:02:36,866 --> 00:02:38,196
内容变成从右往左

84
00:02:38,196 --> 00:02:38,626
排布

85
00:02:38,836 --> 00:02:40,016
第一张图片依然是沙漠

86
00:02:40,016 --> 00:02:41,106
但现在这张图片显示在

87
00:02:41,106 --> 00:02:41,876
屏幕的另一边

88
00:02:42,876 --> 00:02:44,136
从右往左书写文字的模式下

89
00:02:44,136 --> 00:02:46,056
应用程序的界面看起来差不多就是这样

90
00:02:46,346 --> 00:02:47,276
从刚刚的演示中也可看到

91
00:02:47,276 --> 00:02:48,416
我们把对相应语言的支持

92
00:02:48,416 --> 00:02:49,896
都整合到了 TVMLKit 内部了

93
00:02:50,416 --> 00:02:52,036
所以  只要你使用的是默认模版

94
00:02:52,036 --> 00:02:53,306
你们的应用程序就可免费获得

95
00:02:53,306 --> 00:02:55,836
对从右往左书写文字的优化支持

96
00:02:56,006 --> 00:02:57,946
而要让应用程序支持

97
00:02:57,946 --> 00:02:59,756
从右往左书写文字的显示模式

98
00:02:59,756 --> 00:03:01,026
设置方法  和配置其他支持语言

99
00:02:59,756 --> 00:03:01,026
设置方法  和配置其他支持语言

100
00:03:01,026 --> 00:03:01,486
方法一样

101
00:03:02,176 --> 00:03:03,816
只需在 Xcode 中

102
00:03:03,816 --> 00:03:05,646
进入 Project Setting 页面

103
00:03:05,646 --> 00:03:07,996
可看到  在 localizations 下

104
00:03:07,996 --> 00:03:09,336
目前新增了阿语和希语

105
00:03:09,336 --> 00:03:10,366
我们按需添加即可

106
00:03:12,076 --> 00:03:13,946
把两种语言整合到 TVMLKit 中很重要

107
00:03:13,946 --> 00:03:15,696
这样可确保 TVMLKit 在运行时

108
00:03:15,696 --> 00:03:16,616
能判断何时加载成

109
00:03:16,616 --> 00:03:17,786
从右往左显示的界面

110
00:03:18,496 --> 00:03:19,846
关于如何更好地

111
00:03:19,846 --> 00:03:20,866
把应用程序本地化

112
00:03:20,866 --> 00:03:22,146
和更多相关详细信息

113
00:03:22,146 --> 00:03:23,396
包括内容本地化

114
00:03:23,396 --> 00:03:24,516
和如何设置本地化的

115
00:03:24,516 --> 00:03:25,946
时间日期格式  等等

116
00:03:26,306 --> 00:03:27,606
我推荐大家去听一个

117
00:03:27,606 --> 00:03:29,266
今年的演讲  叫“Localizing With X

118
00:03:29,266 --> 00:03:30,646
Code 9” 那里会讲得

119
00:03:30,646 --> 00:03:33,086
更详细一些

120
00:03:33,226 --> 00:03:35,036
好了  刚说了使用默认模版自带的

121
00:03:35,036 --> 00:03:36,856
设置一键配置本地化  但如果程序里

122
00:03:36,856 --> 00:03:38,526
有自定义界面呢  如果你想

123
00:03:38,526 --> 00:03:39,946
实现一些模版中没有提供的

124
00:03:39,946 --> 00:03:40,696
显示效果呢

125
00:03:41,306 --> 00:03:42,666
在 tvOS 11 里

126
00:03:42,666 --> 00:03:44,456
我们新引入了三处可以

127
00:03:44,456 --> 00:03:46,956
自定义的领域  分别是页面布局

128
00:03:47,536 --> 00:03:49,316
文字对齐方式和图片显示

129
00:03:49,706 --> 00:03:51,356
我们首先说页面布局

130
00:03:52,556 --> 00:03:54,296
目前我们自定义页面布局

131
00:03:54,296 --> 00:03:56,456
可能是靠分别设置

132
00:03:56,456 --> 00:03:57,476
tv-align 为 left(左)

133
00:03:57,476 --> 00:03:59,446
和设置 tv-position

134
00:03:59,446 --> 00:03:59,846
为 right(右)

135
00:04:01,046 --> 00:04:01,946
而对于从右往左书写

136
00:04:01,946 --> 00:04:03,836
的文字  左是右

137
00:04:03,836 --> 00:04:05,516
右是左  是颠倒的

138
00:04:05,516 --> 00:04:07,366
这样我们再使用 left 和 right 就得格外小心

139
00:04:07,366 --> 00:04:10,076
很容易设置错方向

140
00:04:10,266 --> 00:04:11,436
为此  我们引入了两个新的属性

141
00:04:11,436 --> 00:04:12,446
叫 leading 和 trailing

142
00:04:13,496 --> 00:04:14,496
Leading 和 trailing

143
00:04:14,496 --> 00:04:15,796
会在程序运行时

144
00:04:15,796 --> 00:04:17,336
根据运行时的语言环境

145
00:04:17,336 --> 00:04:18,676
自动解析出与之适应的 left

146
00:04:18,676 --> 00:04:19,486
或者 right

147
00:04:19,486 --> 00:04:20,055
值

148
00:04:20,886 --> 00:04:22,096
比方说  如果我们

149
00:04:22,096 --> 00:04:23,156
本来定义的样式里是

150
00:04:23,156 --> 00:04:24,806
把 tv-position 设为 right

151
00:04:25,116 --> 00:04:26,946
或者 tv-align 设为 left

152
00:04:26,946 --> 00:04:28,216
现在  我们需要把后面的值

153
00:04:28,216 --> 00:04:29,246
改为 leading 和 trailing

154
00:04:29,876 --> 00:04:31,336
这样就可以确保

155
00:04:31,336 --> 00:04:32,506
在从左往右语言模式下

156
00:04:32,506 --> 00:04:33,716
页面显示效果还和原来一样

157
00:04:33,716 --> 00:04:35,596
但用从右往左语言模式加载后

158
00:04:35,596 --> 00:04:37,016
内容依然能正确排布

159
00:04:40,116 --> 00:04:41,726
对于 margin 和 padding 的赋值

160
00:04:41,726 --> 00:04:43,166
tvOS 11 引入了

161
00:04:43,166 --> 00:04:45,386
一个全新的媒体查询属性

162
00:04:45,836 --> 00:04:47,336
叫作 Layout Direction (布局方向)

163
00:04:48,056 --> 00:04:49,366
大家可能已经

164
00:04:49,366 --> 00:04:51,166
在通过使用媒体查询

165
00:04:51,166 --> 00:04:52,336
来自定义调整页面明暗

166
00:04:52,976 --> 00:04:54,166
这里也是一样的道理

167
00:04:54,606 --> 00:04:56,016
在媒体查询内部

168
00:04:56,016 --> 00:04:57,906
定义的样式  只在当前

169
00:04:57,906 --> 00:04:59,706
媒体查询中有效

170
00:05:00,306 --> 00:05:02,336
如何应用  我来举一个例子

171
00:05:02,506 --> 00:05:04,786
这个媒体查询定义了两个样式

172
00:05:04,786 --> 00:05:06,406
一个适用于从左往右(LTR)方向

173
00:05:06,406 --> 00:05:08,256
另一个适用于从右往左(RTL)方向

174
00:05:09,356 --> 00:05:11,396
这里设置 margin 时需要特意留心

175
00:05:11,396 --> 00:05:13,466
依据语言书写方向

176
00:05:13,466 --> 00:05:15,106
把水平向的左右外边距值

177
00:05:15,106 --> 00:05:16,016
作相应对调

178
00:05:16,376 --> 00:05:17,556
在这个例子中

179
00:05:17,556 --> 00:05:19,136
我们给 margin 设置的值  12

180
00:05:19,186 --> 00:05:20,756
就要写在正确的位置

181
00:05:21,216 --> 00:05:23,556
页面布局就说到这里

182
00:05:23,556 --> 00:05:25,356
那么文字对齐方向呢

183
00:05:26,216 --> 00:05:28,446
我们通常习惯的是  统一设置

184
00:05:28,446 --> 00:05:30,436
左对齐  居中  或者

185
00:05:30,436 --> 00:05:30,856
右对齐

186
00:05:31,316 --> 00:05:32,526
而我们看这个屏幕上的文字

187
00:05:32,526 --> 00:05:34,536
其中分别有两种显示方式

188
00:05:34,536 --> 00:05:35,826
看起来比其他的更自然

189
00:05:35,826 --> 00:05:37,676
对于从左往右书写的文字

190
00:05:37,676 --> 00:05:39,086
左对齐看起来自然

191
00:05:39,086 --> 00:05:40,776
对于从右往左书写的文字

192
00:05:40,776 --> 00:05:42,066
右对齐看起来自然

193
00:05:43,166 --> 00:05:45,216
为此  我们专门

194
00:05:45,216 --> 00:05:46,436
与市场团队碰头协商

195
00:05:46,436 --> 00:05:48,666
思考了一下  究竟该如何

196
00:05:48,736 --> 00:05:50,256
命名这种对齐方式

197
00:05:50,256 --> 00:05:51,596
最终决定  采用一个新的值

198
00:05:51,596 --> 00:05:52,826
叫作  自然对齐

199
00:05:53,716 --> 00:05:55,096
自然对齐  效果和大家想象的

200
00:05:55,096 --> 00:05:55,936
差不多

201
00:05:55,936 --> 00:05:57,616
会根据大家应用程序的 UI 语言

202
00:05:57,616 --> 00:05:59,006
对文字进行自然对齐

203
00:05:59,506 --> 00:05:59,956
很简单

204
00:06:02,496 --> 00:06:04,156
下面再说应用程序中的图片显示

205
00:06:04,156 --> 00:06:06,126
大部分应用程序内采用的图片

206
00:06:06,126 --> 00:06:07,296
都有一定普适性

207
00:06:07,386 --> 00:06:08,586
不管页面如何布局  都可以

208
00:06:08,586 --> 00:06:09,566
正常显示

209
00:06:10,146 --> 00:06:12,076
但在个别情况下

210
00:06:12,076 --> 00:06:13,906
某些图片会自带方向属性

211
00:06:13,906 --> 00:06:15,336
比如这个表单项后面的

212
00:06:15,336 --> 00:06:15,956
V 形标记

213
00:06:16,506 --> 00:06:17,636
这种情况下

214
00:06:17,636 --> 00:06:18,706
就需要确保 V 形箭头

215
00:06:18,706 --> 00:06:19,626
指向正确的方向

216
00:06:19,626 --> 00:06:21,436
不然整个列表页面就会

217
00:06:21,436 --> 00:06:22,896
令人困惑  看起来也

218
00:06:22,896 --> 00:06:23,366
很奇怪

219
00:06:24,226 --> 00:06:26,086
要在应用程序中做到这种效果

220
00:06:26,086 --> 00:06:27,316
有两种方法

221
00:06:27,626 --> 00:06:29,006
一种是针对资源

222
00:06:29,006 --> 00:06:29,576
图片

223
00:06:30,006 --> 00:06:31,186
对于来自应用程序

224
00:06:31,186 --> 00:06:32,626
捆绑包内部的图片

225
00:06:33,216 --> 00:06:35,916
可通过图片资源目录 (Asset Catalogs)

226
00:06:35,916 --> 00:06:37,576
来便捷地自定义

227
00:06:37,576 --> 00:06:39,706
图片显示方向

228
00:06:39,706 --> 00:06:41,946
可设置在所有布局下

229
00:06:41,946 --> 00:06:43,446
图片显示固定不变

230
00:06:43,446 --> 00:06:45,066
可像刚刚的 V 形标记

231
00:06:45,256 --> 00:06:46,946
在运行时左右翻转显示

232
00:06:46,946 --> 00:06:48,486
或是给每门语言都指定一张

233
00:06:48,486 --> 00:06:49,546
单独的图片

234
00:06:51,526 --> 00:06:53,896
对于来自于服务器上的图片

235
00:06:53,896 --> 00:06:56,916
我们引入了一个全新的属性

236
00:06:56,916 --> 00:06:58,246
可以用来定义图片元素

237
00:06:58,246 --> 00:06:59,396
这个属性就叫作

238
00:06:59,396 --> 00:06:59,906
Source Set

239
00:07:01,226 --> 00:07:02,376
Source Set 可针对

240
00:07:02,376 --> 00:07:04,906
某给定的布局方向设置一个

241
00:07:04,906 --> 00:07:05,706
既定的图片 URL

242
00:07:06,596 --> 00:07:07,826
Source Set 还有一个好处

243
00:07:07,826 --> 00:07:09,116
就是  我们也可以通过

244
00:07:09,116 --> 00:07:10,706
设置 Source Set 属性来调整

245
00:07:10,706 --> 00:07:11,336
明暗度

246
00:07:12,006 --> 00:07:15,346
在这个例子中  当布局方向是 LTR 时

247
00:07:15,486 --> 00:07:17,126
就会载入 URL1 链接中的图片

248
00:07:17,896 --> 00:07:20,046
而当布局方向是 RTL 时

249
00:07:20,046 --> 00:07:21,296
就会载入 URL2 图片

250
00:07:21,296 --> 00:07:23,306
通过这种方法

251
00:07:23,306 --> 00:07:24,856
可以指定显示某张图片

252
00:07:24,856 --> 00:07:26,406
运行时就会产出

253
00:07:26,406 --> 00:07:29,006
正确的结果

254
00:07:29,096 --> 00:07:30,476
好了  现在看我们

255
00:07:30,476 --> 00:07:31,846
能不能综合以上谈到的所有点

256
00:07:31,846 --> 00:07:33,026
糅合在一个小程序里

257
00:07:33,026 --> 00:07:33,706
我做了一个样本给大家

258
00:07:33,706 --> 00:07:33,936
看看

259
00:07:44,386 --> 00:07:45,876
我之前一直在做一个应用程序

260
00:07:45,876 --> 00:07:48,186
来展示去年 WWDC

261
00:07:48,186 --> 00:07:49,516
会上的演讲

262
00:07:49,516 --> 00:07:51,096
我现在跟大家分享一下

263
00:07:51,096 --> 00:07:51,506
这个程序

264
00:08:02,316 --> 00:08:03,436
这个页面里  我们可以看到

265
00:08:03,436 --> 00:08:05,346
呈网格 (grid) 排列的往期演讲

266
00:08:05,346 --> 00:08:06,656
顶端我设置了一个横幅

267
00:08:06,656 --> 00:08:07,976
来进行置顶推荐

268
00:08:09,036 --> 00:08:11,026
在正式让我的应用支持

269
00:08:11,026 --> 00:08:12,106
从右往左书写语言之前

270
00:08:12,106 --> 00:08:14,116
不去设置里添加本地化语言

271
00:08:14,116 --> 00:08:15,026
也可以做一些此方面的

272
00:08:15,026 --> 00:08:15,786
其他尝试

273
00:08:16,926 --> 00:08:21,056
我们可以去 edit scheme 下

274
00:08:21,136 --> 00:08:22,966
在 run option 的下拉菜单中

275
00:08:22,966 --> 00:08:24,826
可以把应用程序

276
00:08:24,826 --> 00:08:25,966
的系统语言

277
00:08:25,966 --> 00:08:27,286
改为从右往左的伪码

278
00:08:27,836 --> 00:08:29,476
设置后就可以模拟

279
00:08:29,476 --> 00:08:30,366
程序在从右往左

280
00:08:30,366 --> 00:08:31,796
语言环境中的效果

281
00:08:31,796 --> 00:08:32,996
而项目本身不用做

282
00:08:32,996 --> 00:08:33,645
任何改动

283
00:08:34,856 --> 00:08:36,466
现在再编译并运行的话

284
00:08:36,946 --> 00:08:38,466
就能看到  网格布局变成了

285
00:08:38,466 --> 00:08:39,395
从右往左排布

286
00:08:39,816 --> 00:08:41,635
又因为我们使用了网格布局

287
00:08:41,635 --> 00:08:42,976
这些效果支持都是模版

288
00:08:42,976 --> 00:08:43,696
免费自带的

289
00:08:44,126 --> 00:08:45,616
但是因为我的横幅

290
00:08:45,616 --> 00:08:47,146
是我自己自定义的样式

291
00:08:47,146 --> 00:08:48,816
所以看起来这一部分还需要

292
00:08:48,816 --> 00:08:49,426
我再去调试一下

293
00:08:49,936 --> 00:08:51,436
现在就让我们尝试使用

294
00:08:51,436 --> 00:08:53,746
tvOS 11 中的新 API 来调整

295
00:08:53,746 --> 00:08:54,196
一下

296
00:08:55,836 --> 00:08:57,056
首先我要做的一件事  就是

297
00:08:57,056 --> 00:08:59,126
检查我 TVML 里定义的样式

298
00:08:59,126 --> 00:09:01,126
然后把所有规定死的

299
00:08:59,126 --> 00:09:01,126
然后把所有规定死的

300
00:09:01,226 --> 00:09:03,936
left  都替换成 leading

301
00:09:03,936 --> 00:09:05,656
在我所用的开发语言环境下

302
00:09:05,656 --> 00:09:07,036
leading 也就是屏幕左侧 (left)

303
00:09:08,386 --> 00:09:09,836
同样的  也把所有的

304
00:09:09,836 --> 00:09:11,776
right 都替换成 trailing

305
00:09:14,156 --> 00:09:15,636
现在我们再编译并运行应用程序

306
00:09:15,686 --> 00:09:17,176
应该会看到改进后有什么

307
00:09:17,176 --> 00:09:17,816
不同

308
00:09:19,696 --> 00:09:21,736
很好  看起来文字布局

309
00:09:21,736 --> 00:09:22,676
都翻到了屏幕另一边

310
00:09:22,676 --> 00:09:24,366
页面上的播放按钮

311
00:09:24,366 --> 00:09:25,366
也在正确的位置

312
00:09:25,676 --> 00:09:27,356
但播放按钮看起来

313
00:09:27,356 --> 00:09:29,896
离边框有点太近了

314
00:09:30,116 --> 00:09:31,996
查看一下代码样式就发现

315
00:09:31,996 --> 00:09:33,626
我为 bannerPlayButtonLockup 单独

316
00:09:33,626 --> 00:09:34,766
设置了 margin  但定义的

317
00:09:34,766 --> 00:09:35,706
是元素的右边距

318
00:09:36,016 --> 00:09:37,426
我们需要对此进行调整

319
00:09:37,426 --> 00:09:38,656
使得我们切换为从右往左语言模式后

320
00:09:38,656 --> 00:09:39,626
margin 赋值也相应对调

321
00:09:41,096 --> 00:09:43,116
为了节省时间  我这里插入

322
00:09:43,116 --> 00:09:44,686
我预先写好的一个片段

323
00:09:44,686 --> 00:09:46,496
这里为 bannerPlayButtonLockup 定义了

324
00:09:46,496 --> 00:09:48,686
LTR 和 RTL  两个情况下的媒体查询

325
00:09:48,816 --> 00:09:51,576
我只需把原先定义好的 margin

326
00:09:51,576 --> 00:09:54,646
移动到 LTR 媒体查询下

327
00:09:55,436 --> 00:09:57,326
然后在 RTL 的媒体查询里

328
00:09:57,326 --> 00:09:59,036
把右边距60调换成左边距

329
00:09:59,416 --> 00:10:00,276
就行了

330
00:09:59,416 --> 00:10:00,276
就行了

331
00:10:02,916 --> 00:10:05,896
现在我们再编译并运行一下

332
00:10:05,896 --> 00:10:07,076
这下播放按钮的 padding 就看起来

333
00:10:07,076 --> 00:10:07,636
正常多了

334
00:10:08,146 --> 00:10:09,876
现在页面布局完成得差不多了

335
00:10:09,876 --> 00:10:11,356
但再看一下这个界面

336
00:10:11,356 --> 00:10:12,766
我们发现  当横幅文字被移到

337
00:10:12,766 --> 00:10:13,406
右边后

338
00:10:13,406 --> 00:10:14,826
背后正好和图片内容重合

339
00:10:14,826 --> 00:10:16,126
这样文字就不太容易阅读

340
00:10:17,166 --> 00:10:18,426
这时网页设计师给了我

341
00:10:18,426 --> 00:10:19,826
一张左右翻转的图片

342
00:10:19,826 --> 00:10:21,176
可以用在从右往左布局的页面里

343
00:10:21,486 --> 00:10:23,006
我就可以用图片资源目录 (Asset Catalogs)

344
00:10:23,006 --> 00:10:24,756
把这张图片加到项目里

345
00:10:25,556 --> 00:10:26,966
在我的这个图片资源目录里

346
00:10:26,966 --> 00:10:28,436
当前只为横幅指定了

347
00:10:28,436 --> 00:10:29,906
一张图片

348
00:10:29,906 --> 00:10:31,796
我可以在 Attribute Inspector 里

349
00:10:31,796 --> 00:10:33,416
把布局方向从 fixed (固定) 改为

350
00:10:33,626 --> 00:10:34,106
both (双向)

351
00:10:34,846 --> 00:10:36,346
这样设置后  就会出现预留空位

352
00:10:36,346 --> 00:10:37,576
把需要在从右往左布局中使用的

353
00:10:37,576 --> 00:10:38,696
左右翻转的图片  拖拽到空位上

354
00:10:38,696 --> 00:10:39,146
就可以了

355
00:10:40,656 --> 00:10:44,366
现在我就拖拽过来

356
00:10:44,596 --> 00:10:46,036
最后再编译并运行一下我的应用程序

357
00:10:50,436 --> 00:10:51,306
这就是调试结果了

358
00:10:51,586 --> 00:10:52,996
只需进行一些很小的改动

359
00:10:52,996 --> 00:10:54,536
我们的应用程序就可以完美支持

360
00:10:54,536 --> 00:10:55,516
从右往左布局了

361
00:10:55,516 --> 00:11:01,396
[掌声]

362
00:10:55,516 --> 00:11:01,396
[掌声]

363
00:11:01,896 --> 00:11:04,076
总结一下  就像大家所见

364
00:11:04,076 --> 00:11:05,276
只需对程序进行一些很小的改动

365
00:11:05,586 --> 00:11:06,866
大部分工作都可以由默认模版中

366
00:11:06,866 --> 00:11:08,536
自带的免费技术支持来完成

367
00:11:08,536 --> 00:11:09,956
很轻松  就能让我们的程序

368
00:11:09,956 --> 00:11:10,916
支持从右往左书写文字

369
00:11:10,916 --> 00:11:12,606
我们需要做的编程改动

370
00:11:12,606 --> 00:11:13,386
非常少

371
00:11:13,926 --> 00:11:15,356
同时  从右往左的伪码也是一个

372
00:11:15,356 --> 00:11:16,366
非常强大的工具

373
00:11:16,366 --> 00:11:17,626
我们可以在不懂任何

374
00:11:17,626 --> 00:11:19,036
从右往左书写语言的情况下

375
00:11:19,036 --> 00:11:20,566
通过伪码模拟  查看程序

376
00:11:20,566 --> 00:11:21,806
在从右往左布局下的

377
00:11:21,806 --> 00:11:22,286
显示效果

378
00:11:23,196 --> 00:11:25,116
还有再多说一点  如果你的应用

379
00:11:25,116 --> 00:11:26,356
要使用自定义试图

380
00:11:26,356 --> 00:11:28,746
我们的 AutoLayout Engine 里

381
00:11:28,746 --> 00:11:30,336
还有一系列约束 (constraint)

382
00:11:30,336 --> 00:11:32,076
这些约束  功能非常强大

383
00:11:32,076 --> 00:11:34,496
可以帮助你们优化从右往左书写

384
00:11:34,496 --> 00:11:35,606
语言模式下的布局

385
00:11:36,366 --> 00:11:38,066
我们还有一个基于 API 的

386
00:11:38,066 --> 00:11:39,346
布局方向属性  返回的结果

387
00:11:39,346 --> 00:11:40,686
可以显示运行时

388
00:11:40,686 --> 00:11:42,186
你是在一个从左往右

389
00:11:42,186 --> 00:11:43,446
还是从右往左的布局

390
00:11:43,856 --> 00:11:45,396
在做动画帧的屏幕

391
00:11:45,456 --> 00:11:46,986
自适应运算时  这个功能

392
00:11:46,986 --> 00:11:47,486
会很有用

393
00:11:48,486 --> 00:11:50,086
了解从右往左书写语言的布局的

394
00:11:50,086 --> 00:11:52,016
更多细节  或是

395
00:11:52,016 --> 00:11:52,926
想要深入了解相关信息

396
00:11:52,926 --> 00:11:54,316
我推荐大家去听去年的

397
00:11:54,316 --> 00:11:55,436
两场相关演讲

398
00:11:55,656 --> 00:11:56,826
Internationalization Best

399
00:11:56,826 --> 00:11:58,396
Practices 和 What's New In

400
00:11:58,396 --> 00:11:59,846
International User Interfaces

401
00:12:01,756 --> 00:12:03,756
我迫不及待在今年秋天的时候

402
00:12:03,756 --> 00:12:04,706
能看到你们的应用程序

403
00:12:04,706 --> 00:12:06,186
开始支持从右往左的语言布局

404
00:12:06,696 --> 00:12:07,746
下面有请 Parry

405
00:12:07,746 --> 00:12:08,826
为大家介绍模版优化项目

406
00:12:09,026 --> 00:12:09,386
谢谢大家

407
00:12:10,516 --> 00:12:12,546
[掌声]

408
00:12:13,046 --> 00:12:14,896
&gt;&gt; 谢谢 Trevor

409
00:12:14,896 --> 00:12:16,406
大家好  我是 Parry

410
00:12:16,676 --> 00:12:17,676
下面我将给大家介绍

411
00:12:17,676 --> 00:12:18,996
我们对模版进行的一些改进

412
00:12:18,996 --> 00:12:20,496
这些改进将会提高你们

413
00:12:20,496 --> 00:12:21,656
应用程序的运行性能

414
00:12:21,696 --> 00:12:23,346
既可以优化响应时间

415
00:12:23,466 --> 00:12:23,936
又可以减少内存占用

416
00:12:24,836 --> 00:12:26,426
如果你用 TVMLKit 做过应用程序

417
00:12:26,426 --> 00:12:28,166
那么也许已经注意到

418
00:12:28,166 --> 00:12:29,656
当我们试图往模版里

419
00:12:29,656 --> 00:12:31,676
添加更多内容的时候

420
00:12:31,676 --> 00:12:33,406
模版性能会逐渐降低

421
00:12:33,546 --> 00:12:34,396
让我用一个例子给大家演示

422
00:12:34,396 --> 00:12:34,816
一下

423
00:12:36,076 --> 00:12:37,756
我和 Trevor 一起

424
00:12:37,756 --> 00:12:40,246
在开发这个 WWDC 的样本程序

425
00:12:40,246 --> 00:12:43,066
我希望这个应用程序能搭载

426
00:12:43,066 --> 00:12:44,156
所有的往期演讲

427
00:12:44,156 --> 00:12:45,236
而不是只有去年的

428
00:12:45,236 --> 00:12:45,586
演讲

429
00:12:46,016 --> 00:12:47,506
我们依然维持简洁的页面设计

430
00:12:48,236 --> 00:12:50,036
用网格 (grid) 来展示所有

431
00:12:50,036 --> 00:12:50,606
演讲

432
00:12:51,096 --> 00:12:52,606
每个演讲都由一个 lockup 元素来代表

433
00:12:52,606 --> 00:12:55,686
其中包括一张图片

434
00:12:55,906 --> 00:12:56,426
和一个文字标题

435
00:12:56,426 --> 00:12:58,716
大家可以想象  要展示的全部内容

436
00:12:58,716 --> 00:12:59,806
会包括上千个像这样的

437
00:12:59,806 --> 00:13:00,506
视频

438
00:12:59,806 --> 00:13:00,506
视频

439
00:13:01,126 --> 00:13:02,426
所以一般针对这种典型情况

440
00:13:02,426 --> 00:13:03,986
我们不希望这个页面  一上来

441
00:13:03,986 --> 00:13:05,596
就显示出所有内容

442
00:13:05,596 --> 00:13:07,026
因为首先  一下全部显示出来

443
00:13:07,026 --> 00:13:09,196
加载时间太长  而第二

444
00:13:09,196 --> 00:13:10,606
很有可能根本无法一下全部显示

445
00:13:10,606 --> 00:13:11,876
那还要看你的服务器是否能够

446
00:13:11,876 --> 00:13:12,316
支持

447
00:13:13,066 --> 00:13:14,846
所以我们就需要给数据进行分页 (paginate)

448
00:13:14,846 --> 00:13:15,396
处理

449
00:13:15,856 --> 00:13:17,036
可以先显示一小部分

450
00:13:17,036 --> 00:13:18,856
比方说 500 个项目

451
00:13:18,856 --> 00:13:20,626
然后等用户滚动到

452
00:13:20,626 --> 00:13:22,516
接近内容末尾时

453
00:13:22,516 --> 00:13:23,826
再不断加载下一部分内容

454
00:13:25,056 --> 00:13:26,916
我们针对这种情形做了

455
00:13:26,916 --> 00:13:28,586
一个性能分析

456
00:13:28,946 --> 00:13:30,076
结果差不多如图

457
00:13:31,636 --> 00:13:33,766
这张图上显示的是

458
00:13:33,766 --> 00:13:35,866
编译一个含有一定数量

459
00:13:35,866 --> 00:13:36,996
项目的模版  需要多长时间

460
00:13:36,996 --> 00:13:40,786
我们可以看到  这张图里

461
00:13:40,786 --> 00:13:42,056
位于 X 轴上的数值

462
00:13:42,056 --> 00:13:43,736
代表着模版中项目的数量

463
00:13:43,736 --> 00:13:45,126
而 Y 轴数值  代表显示出这么多项目

464
00:13:45,126 --> 00:13:45,796
所需要的时间

465
00:13:46,506 --> 00:13:48,346
我们从图中可以看出

466
00:13:48,346 --> 00:13:49,426
花费时间呈指数增长

467
00:13:50,596 --> 00:13:51,926
也就是说  随着模版

468
00:13:51,926 --> 00:13:53,586
体量增大  要加载同样多

469
00:13:53,586 --> 00:13:55,526
数量的项目  就需要花费

470
00:13:55,526 --> 00:13:56,306
更多的时间

471
00:13:56,306 --> 00:13:58,726
这又是为什么呢

472
00:13:59,476 --> 00:14:01,236
一个很重要的影响因素

473
00:13:59,476 --> 00:14:01,236
一个很重要的影响因素

474
00:14:01,496 --> 00:14:02,876
就是这些模版里

475
00:14:02,876 --> 00:14:04,426
文档对象模型 (DOM) 的

476
00:14:04,456 --> 00:14:04,936
大小

477
00:14:05,416 --> 00:14:06,786
这个问题有两方面

478
00:14:07,686 --> 00:14:08,946
一方面是

479
00:14:08,946 --> 00:14:09,786
存在多余的模板语法解析

480
00:14:10,086 --> 00:14:11,816
首先  是在你的 JavaScript 里

481
00:14:11,816 --> 00:14:13,076
要把数据解析到 DOM 树里

482
00:14:13,076 --> 00:14:15,016
这样  当 DOM 树越来越大

483
00:14:15,016 --> 00:14:16,376
要添加新的东西进去

484
00:14:16,376 --> 00:14:18,356
就需要花更多的时间

485
00:14:18,356 --> 00:14:20,486
然后  TVMLKit 还得解析 DOM

486
00:14:20,486 --> 00:14:21,616
来计算出显示布局

487
00:14:21,616 --> 00:14:24,156
所需信息  比如内容格大小

488
00:14:24,266 --> 00:14:26,156
行距  甚至滚动

489
00:14:26,156 --> 00:14:26,616
偏移量

490
00:14:27,106 --> 00:14:28,316
上述这些参数   会让你们的

491
00:14:28,316 --> 00:14:29,976
TVMLKit 程序界面看起来非常漂亮

492
00:14:30,966 --> 00:14:32,096
但可以想象的是

493
00:14:32,096 --> 00:14:33,966
DOM 树越大  完成这些

494
00:14:33,966 --> 00:14:35,346
计算所需的时间

495
00:14:35,346 --> 00:14:35,826
就越长

496
00:14:37,226 --> 00:14:39,886
而另一方面  DOM 树越来越大

497
00:14:39,886 --> 00:14:41,626
对内存的压力也会越来越大

498
00:14:41,626 --> 00:14:42,926
这就会整体拖慢

499
00:14:42,926 --> 00:14:44,656
你应用程序的响应

500
00:14:44,656 --> 00:14:44,976
时间

501
00:14:47,186 --> 00:14:49,506
为了解决响应时间和内存占用问题

502
00:14:49,506 --> 00:14:52,386
在 tvOS 11 中  我们引入了一个全新的

503
00:14:52,386 --> 00:14:54,296
模版定义范式

504
00:14:54,296 --> 00:14:56,446
新方法采用原型 (Prototype)

505
00:14:56,626 --> 00:14:59,396
加数据绑定 (Data Binding) 来构建模版

506
00:14:59,396 --> 00:15:00,976
此方法可以显著降低 DOM 树大小

507
00:14:59,396 --> 00:15:00,976
此方法可以显著降低 DOM 树大小

508
00:15:01,016 --> 00:15:02,786
从而提高大家

509
00:15:02,786 --> 00:15:05,526
应用程序的性能  除此之外

510
00:15:05,526 --> 00:15:07,386
我们还增加了一些 API

511
00:15:07,386 --> 00:15:08,336
来支持数据分页

512
00:15:09,286 --> 00:15:10,246
下面我们详细讨论

513
00:15:10,246 --> 00:15:10,586
一下

514
00:15:12,036 --> 00:15:13,996
为了方便大家理解原型

515
00:15:13,996 --> 00:15:15,786
到底是什么  我先给大家

516
00:15:15,786 --> 00:15:17,486
讲一下  一个典型的模版

517
00:15:17,486 --> 00:15:18,336
构建过程

518
00:15:18,916 --> 00:15:20,296
最开始  在我们手上的

519
00:15:20,296 --> 00:15:22,776
是你服务器上的数据  和一个模版

520
00:15:22,776 --> 00:15:23,336
的空壳

521
00:15:23,336 --> 00:15:24,456
针对我们这个程序  是个网格模版

522
00:15:24,456 --> 00:15:27,086
然后根据 JavaScript

523
00:15:27,086 --> 00:15:27,886
我们需要把

524
00:15:27,886 --> 00:15:30,936
JavaScript 里的对象都逐一

525
00:15:30,936 --> 00:15:32,446
翻译成相对应的 TVML

526
00:15:32,446 --> 00:15:33,096
语言

527
00:15:33,496 --> 00:15:35,056
在我们这个应用里  翻成 lockup

528
00:15:36,086 --> 00:15:37,866
做完这一步之后

529
00:15:37,866 --> 00:15:40,736
再把这些都转化成 DOM 树

530
00:15:40,736 --> 00:15:42,296
然后 TVMLKit 就可以开始

531
00:15:42,296 --> 00:15:43,386
生成 UI 了

532
00:15:44,056 --> 00:15:46,286
但如果我们仔细研究一下代码

533
00:15:46,286 --> 00:15:47,826
就会发现  这些 lockup 之间

534
00:15:47,826 --> 00:15:49,016
相似度非常高

535
00:15:49,016 --> 00:15:51,736
实际上这些 lockup 之间  唯一不同的

536
00:15:51,826 --> 00:15:52,856
地方  就是它们各自

537
00:15:52,856 --> 00:15:53,846
从数据中解析来的值

538
00:15:56,796 --> 00:15:58,606
如果我们去除这些值

539
00:15:59,076 --> 00:16:00,806
剩下的就是一些

540
00:15:59,076 --> 00:16:00,806
剩下的就是一些

541
00:16:00,876 --> 00:16:03,756
完全一样的 lockup

542
00:16:03,756 --> 00:16:05,326
其中任何一个  所包含的信息

543
00:16:05,326 --> 00:16:07,386
就已经足够 TVMLKit 预先计算出

544
00:16:07,386 --> 00:16:08,306
如何布局页面了

545
00:16:09,216 --> 00:16:10,856
所以  其实我们并不需要

546
00:16:10,856 --> 00:16:12,706
写这么多个 lockup

547
00:16:12,706 --> 00:16:14,146
写一个就够了

548
00:16:14,466 --> 00:16:15,896
而提炼出的这个骨架  就是一个

549
00:16:15,896 --> 00:16:16,586
原型了

550
00:16:17,596 --> 00:16:20,306
所以简单说  原型就是个针对

551
00:16:20,306 --> 00:16:22,386
数据对象的 TVML 语言纲要

552
00:16:22,386 --> 00:16:24,196
TVMLKit 可利用这一纲要

553
00:16:24,196 --> 00:16:26,636
预先计算布局  然后在

554
00:16:26,636 --> 00:16:28,116
运行时  再和数据

555
00:16:28,116 --> 00:16:30,786
进行结合  自动帮你创建 DOM 树

556
00:16:30,786 --> 00:16:32,266
但只解析它所需要的那一部分

557
00:16:32,266 --> 00:16:34,056
且只在需要的时候才解析

558
00:16:34,876 --> 00:16:36,616
这样就可以控制 DOM 树较小

559
00:16:36,926 --> 00:16:38,476
且大小独立  不随数据变多而增长

560
00:16:40,386 --> 00:16:42,836
当然  如果一个模版里

561
00:16:42,836 --> 00:16:44,166
只有原型  还不完整

562
00:16:44,166 --> 00:16:45,776
我们还需要给模版

563
00:16:45,776 --> 00:16:46,546
提供数据

564
00:16:47,696 --> 00:16:49,036
但除了提供数据

565
00:16:49,036 --> 00:16:51,146
我们还需要把模版

566
00:16:51,146 --> 00:16:52,936
和数据关联起来

567
00:16:53,226 --> 00:16:54,826
这样 TVMLKit 才能

568
00:16:54,936 --> 00:16:56,756
解析你的数据

569
00:16:56,756 --> 00:16:58,016
并且帮你完成模版构建

570
00:16:58,746 --> 00:17:01,736
这一关联过程就要靠数据绑定

571
00:16:58,746 --> 00:17:01,736
这一关联过程就要靠数据绑定

572
00:17:01,736 --> 00:17:02,176
来完成

573
00:17:03,696 --> 00:17:05,976
要在 tvOS 11 里

574
00:17:05,976 --> 00:17:07,746
给模版绑定数据  一共有

575
00:17:08,056 --> 00:17:09,116
三种方法

576
00:17:09,705 --> 00:17:12,546
首先  可以给一个元素的来源

577
00:17:12,665 --> 00:17:13,806
绑定属性

578
00:17:14,086 --> 00:17:15,425
这个例子里  就给

579
00:17:15,425 --> 00:17:17,286
图像元素的来源属性

580
00:17:17,665 --> 00:17:18,776
绑定了数据中的

581
00:17:18,776 --> 00:17:19,646
URL 属性

582
00:17:20,896 --> 00:17:22,665
我们还可以对一个元素的文字内容

583
00:17:22,665 --> 00:17:23,955
进行绑定

584
00:17:23,955 --> 00:17:25,856
这个例子里  就给 title 元素的

585
00:17:26,146 --> 00:17:28,046
文字内容 (textContent) 绑定了

586
00:17:28,046 --> 00:17:29,526
数据中的 title 属性

587
00:17:30,646 --> 00:17:33,106
最后  我们还可以把一个组件

588
00:17:33,106 --> 00:17:35,966
中的某些项目绑定

589
00:17:35,966 --> 00:17:36,346
对象

590
00:17:37,416 --> 00:17:38,906
我们可以将组件中的

591
00:17:38,906 --> 00:17:40,156
试验 DOM 元素

592
00:17:40,156 --> 00:17:41,356
和一系列对象进行

593
00:17:41,356 --> 00:17:41,986
绑定

594
00:17:44,546 --> 00:17:46,786
所以简单说  数据绑定

595
00:17:46,786 --> 00:17:47,886
就是一种链接  用来关联

596
00:17:47,936 --> 00:17:48,656
TVML 属性和数据属性

597
00:17:48,926 --> 00:17:49,796
这种关联  可以在 TVML 里

598
00:17:49,826 --> 00:17:50,606
利用一个绑定属性

599
00:17:50,636 --> 00:17:51,086
来直接指定

600
00:17:51,116 --> 00:17:51,896
说到为 TVMLKit 提供数据

601
00:17:51,926 --> 00:17:52,796
我们还可以在 JavaScript 里

602
00:17:52,826 --> 00:17:53,666
用 DataItem 来实现这一点

603
00:17:53,696 --> 00:17:54,476
这是我们对 DOM 元素

604
00:17:54,506 --> 00:17:55,286
引入的一个新属性

605
00:17:55,316 --> 00:17:55,856
我来举个例子

606
00:17:55,886 --> 00:17:56,516
我们读取 JSON

607
00:17:56,546 --> 00:17:57,296
将数据转换为 JavaScript 对象

608
00:17:57,326 --> 00:17:58,166
然后再用 DataItem 属性

609
00:17:58,196 --> 00:17:58,976
把该对象关联到组件元素上

610
00:18:01,456 --> 00:18:02,996
好了  我们接下来说

611
00:18:02,996 --> 00:18:03,656
分页

612
00:18:03,656 --> 00:18:06,046
在 tvOS 11 里  我们引入了

613
00:18:06,686 --> 00:18:08,386
一个新事件叫作 Needs More

614
00:18:08,386 --> 00:18:09,986
用这个事件  我们可以很方便地

615
00:18:09,986 --> 00:18:10,986
对数据进行分页

616
00:18:11,026 --> 00:18:13,666
当用户滚动到

617
00:18:13,816 --> 00:18:15,586
接近页面内容末尾时

618
00:18:15,586 --> 00:18:18,886
就会触发这一事件  可应用范围

619
00:18:18,886 --> 00:18:20,676
包括 list  shelf  grid

620
00:18:26,756 --> 00:18:28,416
甚至 stackTemplate

621
00:18:29,246 --> 00:18:32,266
用途广泛  且几乎可以应用到

622
00:18:32,266 --> 00:18:33,086
任何模版上

623
00:18:33,356 --> 00:18:35,416
但要注意的是

624
00:18:35,416 --> 00:18:37,696
如果要在数据绑定模板中

625
00:18:37,696 --> 00:18:40,676
进行分页  还需要给数据

626
00:18:40,676 --> 00:18:41,946
创建可观察对象

627
00:18:42,766 --> 00:18:45,436
这样 TVMLKit 才能观察监听到

628
00:18:45,616 --> 00:18:47,176
你对数据做出的改动

629
00:18:47,176 --> 00:18:49,556
并在发生变动后  主动更新

630
00:18:50,406 --> 00:18:51,916
UI 界面

631
00:18:52,196 --> 00:18:54,286
让我们看一个   如何创建

632
00:18:54,706 --> 00:18:57,976
这些可观察对象的例子

633
00:18:57,976 --> 00:19:00,006
开头的地方都一样

634
00:18:57,976 --> 00:19:00,006
开头的地方都一样

635
00:19:00,146 --> 00:19:04,216
解析 JSON 成为一个

636
00:19:04,216 --> 00:19:08,756
JavaScript 对象  但接下来

637
00:19:08,756 --> 00:19:11,176
要遍历每一个对象

638
00:19:11,176 --> 00:19:17,486
把它们映射为一个

639
00:19:17,486 --> 00:19:19,176
DataItem 类

640
00:19:19,316 --> 00:19:22,406
这一项也是 tvOS 11

641
00:19:22,406 --> 00:19:25,416
里介绍过的  本身

642
00:19:25,416 --> 00:19:27,046
自带观察者模式

643
00:19:28,656 --> 00:19:30,096
我们创建 dataItem 时

644
00:19:30,096 --> 00:19:31,686
把它设置为可选类型

645
00:19:31,686 --> 00:19:32,876
这样万一你希望模版中

646
00:19:32,876 --> 00:19:35,166
有多个原型  也可以

647
00:19:35,166 --> 00:19:38,326
还要规定识别码

648
00:19:38,326 --> 00:19:39,936
TVMLKit 可以利用这个识别码

649
00:19:39,936 --> 00:19:41,906
更高效地把更新推到

650
00:19:41,906 --> 00:19:42,516
UI 上

651
00:19:43,846 --> 00:19:45,566
映射完成后

652
00:19:45,566 --> 00:19:47,156
还要把这个 DataItem 类

653
00:19:47,156 --> 00:19:48,596
包在另一个 sectionDataItem 里

654
00:19:49,426 --> 00:19:51,946
最终才是  把这个 sectionDataItem 关联到

655
00:19:52,736 --> 00:19:53,366
元素上

656
00:19:53,806 --> 00:19:57,546
我们举个例子来看看如何

657
00:19:57,546 --> 00:19:58,516
处理 Needs More

658
00:19:59,636 --> 00:20:01,226
Needs More 和其他事件

659
00:19:59,636 --> 00:20:01,226
Needs More 和其他事件

660
00:20:01,226 --> 00:20:01,976
一样

661
00:20:02,046 --> 00:20:03,806
我们可以用

662
00:20:03,806 --> 00:20:05,776
Add Event Listener 方法

663
00:20:05,776 --> 00:20:07,846
来监听一个 DOM 元素

664
00:20:07,846 --> 00:20:10,516
再提供一个函数

665
00:20:10,516 --> 00:20:11,976
这个函数执行起来

666
00:20:11,976 --> 00:20:13,576
和新构建一个模板

667
00:20:13,576 --> 00:20:13,986
差不多

668
00:20:14,176 --> 00:20:16,216
从数据库提取数据

669
00:20:16,216 --> 00:20:18,296
映射为 DataItem 类

670
00:20:18,296 --> 00:20:21,376
但最后一步

671
00:20:21,376 --> 00:20:23,066
不是把这些 DataItem

672
00:20:23,066 --> 00:20:24,156
直接关联到元素上

673
00:20:24,156 --> 00:20:26,006
而是插入到已有元素的末尾

674
00:20:26,746 --> 00:20:28,266
完成以上这些操作之后

675
00:20:28,266 --> 00:20:30,196
再对 DataItem 类调用

676
00:20:30,246 --> 00:20:32,216
Touch Property Path Method

677
00:20:32,216 --> 00:20:33,466
把你数据更新推到

678
00:20:33,466 --> 00:20:33,956
UI 上

679
00:20:35,496 --> 00:20:37,036
现在我们综合以上讲到的

680
00:20:37,036 --> 00:20:42,096
用程序给大家示范一下

681
00:20:42,256 --> 00:20:44,166
刚刚 Trevor 给大家演示的时候

682
00:20:44,166 --> 00:20:45,366
我在他样本程序

683
00:20:45,366 --> 00:20:47,376
的脚本里添加了代码  进行了

684
00:20:47,376 --> 00:20:47,966
数据分页

685
00:20:48,556 --> 00:20:49,896
不如就从这里开始讲吧

686
00:20:51,646 --> 00:20:53,836
我们直接在代码中

687
00:20:53,836 --> 00:20:55,076
找到相应的

688
00:20:55,076 --> 00:20:56,846
构建 stackDocument 的部分

689
00:20:57,786 --> 00:20:59,816
我要处理的事件  就关联

690
00:20:59,866 --> 00:21:01,536
在 stackElement 元素

691
00:20:59,866 --> 00:21:01,536
在 stackElement 元素

692
00:21:01,536 --> 00:21:01,986
上

693
00:21:02,856 --> 00:21:04,266
大家可以看到

694
00:21:04,266 --> 00:21:05,736
这里我先抓取了下一批

695
00:21:05,736 --> 00:21:06,996
想要推到模版上的数据

696
00:21:06,996 --> 00:21:08,906
读取返回的 JSON

697
00:21:08,906 --> 00:21:10,696
将数据转换为

698
00:21:10,696 --> 00:21:12,156
JavaScript 对象

699
00:21:12,156 --> 00:21:15,226
再调用 populateGrid 函数  把对象

700
00:21:15,256 --> 00:21:15,966
加到模版里

701
00:21:16,426 --> 00:21:17,666
populateGrid 这个函数是做什么的呢

702
00:21:18,276 --> 00:21:21,746
目前我创建的模版

703
00:21:21,746 --> 00:21:23,356
还没有使用新的原型

704
00:21:23,416 --> 00:21:24,666
加数据绑定方法

705
00:21:24,666 --> 00:21:25,836
所以可能大家看着代码觉得很

706
00:21:25,836 --> 00:21:26,386
熟悉

707
00:21:26,816 --> 00:21:28,246
大家看一眼  也许就知道这个函数

708
00:21:28,246 --> 00:21:29,116
是要做什么

709
00:21:29,946 --> 00:21:34,586
首先这里  我添加了一个空网格

710
00:21:34,766 --> 00:21:37,056
然后遍历此批数据中的对象

711
00:21:37,056 --> 00:21:38,976
把它们都用 TVML 标记语言表述

712
00:21:39,456 --> 00:21:40,666
这个例子里用的是 lockup

713
00:21:41,456 --> 00:21:43,486
最后把所有这些 lockup

714
00:21:43,486 --> 00:21:44,926
都直接解析到 DOM 里

715
00:21:46,176 --> 00:21:47,386
我稍后会用新方法

716
00:21:47,386 --> 00:21:49,796
把这些转换成数据绑定模板

717
00:21:49,796 --> 00:21:51,506
但在那之前  我们先运行一次

718
00:21:51,686 --> 00:21:52,696
体验一下  在 TVMLKit 里

719
00:21:52,696 --> 00:21:53,746
执行分页加载

720
00:21:53,746 --> 00:21:54,336
是什么样

721
00:22:02,046 --> 00:22:03,066
我们可以看到  刚打开时

722
00:22:03,096 --> 00:22:03,796
没什么区别

723
00:22:04,266 --> 00:22:05,856
但注意看  当我滚动到

724
00:22:05,896 --> 00:22:08,826
接近这个网格末尾的时候

725
00:22:08,826 --> 00:22:10,086
右侧的索引条

726
00:22:10,086 --> 00:22:12,506
会向上跳回  这是因为

727
00:22:12,506 --> 00:22:14,146
滚动接近末尾时  程序会自动

728
00:22:14,146 --> 00:22:15,276
在网格末尾插入新的项目

729
00:22:16,016 --> 00:22:17,706
好  现在分页实现了

730
00:22:18,646 --> 00:22:20,596
让我们回过头  做完这个例子

731
00:22:20,596 --> 00:22:22,866
再用新引入的原型加

732
00:22:22,866 --> 00:22:24,646
数据绑定的方法  改写优化一下

733
00:22:24,646 --> 00:22:25,256
这个模版

734
00:22:29,456 --> 00:22:30,946
跟大家想的差不多

735
00:22:31,066 --> 00:22:32,346
要把现有模版

736
00:22:32,346 --> 00:22:34,706
转换成数据绑定模板

737
00:22:34,706 --> 00:22:36,346
我所需要做的全部改动

738
00:22:36,346 --> 00:22:38,486
都在 populateGrid 这一个函数里

739
00:22:39,156 --> 00:22:40,626
我首先要做的就是

740
00:22:40,626 --> 00:22:44,566
对比原来单纯地添加空网格

741
00:22:44,566 --> 00:22:47,336
我需要添加一些原型

742
00:22:48,076 --> 00:22:49,936
和一个绑定网格  就像这样

743
00:22:54,196 --> 00:22:56,076
接下来的一步

744
00:22:56,076 --> 00:22:57,926
我不需要逐一把这些对象

745
00:22:57,926 --> 00:23:00,436
都映射到标记语言

746
00:22:57,926 --> 00:23:00,436
都映射到标记语言

747
00:23:02,206 --> 00:23:04,216
而是需要用 DataItem 类把它们

748
00:23:04,216 --> 00:23:05,746
映射为可观察对象

749
00:23:06,326 --> 00:23:12,056
像这样

750
00:23:12,056 --> 00:23:15,796
最后一步  我也不需要

751
00:23:15,796 --> 00:23:19,136
把这些标记语言都直接

752
00:23:19,136 --> 00:23:21,636
读到 DOM 里  我只需把

753
00:23:21,636 --> 00:23:23,606
新创建的 DataItem 插入到

754
00:23:23,606 --> 00:23:26,726
已有 DataItem 的末尾

755
00:23:26,816 --> 00:23:32,486
像这样  现在我们已经完成了

756
00:23:32,486 --> 00:23:34,166
所有的优化改写  再运行一下

757
00:23:34,226 --> 00:23:34,976
看看效果

758
00:23:43,556 --> 00:23:45,426
应用程序一启动

759
00:23:45,426 --> 00:23:46,416
我们就可以注意到

760
00:23:46,416 --> 00:23:47,936
加载速度更快了  尽管

761
00:23:47,936 --> 00:23:49,746
启动时只加载了

762
00:23:49,746 --> 00:23:51,506
很少一部分内容

763
00:23:51,536 --> 00:23:52,696
也能体会到速度增快

764
00:23:53,086 --> 00:23:54,446
而当我向下滚动时

765
00:23:54,446 --> 00:23:57,316
可看到程序性能

766
00:23:57,316 --> 00:24:00,056
表现完美  滚动效果流畅

767
00:23:57,316 --> 00:24:00,056
表现完美  滚动效果流畅

768
00:24:00,056 --> 00:24:00,496
顺滑

769
00:24:01,296 --> 00:24:03,006
滚起来还挺上瘾的

770
00:24:03,006 --> 00:24:04,106
我能玩一天

771
00:24:06,516 --> 00:24:12,016
[掌声]

772
00:24:12,516 --> 00:24:14,766
让我们回顾一下

773
00:24:14,796 --> 00:24:15,356
讲过的内容

774
00:24:18,656 --> 00:24:20,446
我们刚刚讲了  如何运用原型

775
00:24:20,446 --> 00:24:22,456
和数据绑定这一更优化的

776
00:24:22,716 --> 00:24:25,046
模版定义范式来构建你的

777
00:24:25,046 --> 00:24:25,486
模版

778
00:24:26,496 --> 00:24:27,926
优化后可以降低 DOM 树

779
00:24:27,926 --> 00:24:29,076
大小  提高应用程序

780
00:24:29,776 --> 00:24:32,106
性能  我们还讲了如何利用

781
00:24:32,106 --> 00:24:33,766
Needs More 事件  便捷地

782
00:24:33,766 --> 00:24:34,506
对数据进行分页

783
00:24:35,826 --> 00:24:37,166
在我结束前  还想给大家

784
00:24:37,166 --> 00:24:38,986
重现一个测试结果

785
00:24:40,386 --> 00:24:41,516
还记得我之前给大家

786
00:24:41,516 --> 00:24:43,086
展示的这张图吗  显示了

787
00:24:43,086 --> 00:24:44,276
构建一个含有一定数量

788
00:24:44,276 --> 00:24:45,536
项目的模版  需要多长时间

789
00:24:46,946 --> 00:24:48,606
我们如例子中演示的  用原型

790
00:24:48,606 --> 00:24:50,626
加数据绑定的新方法  重新构建了模版

791
00:24:50,626 --> 00:24:52,676
之后重做了一次性能分析

792
00:24:53,536 --> 00:24:55,956
结果显示  采用新方法后

793
00:24:55,956 --> 00:24:58,406
编译同样的模版所需的时间

794
00:24:58,406 --> 00:24:59,426
比起原先  缩短了

795
00:24:59,486 --> 00:25:00,036
超过50%

796
00:24:59,486 --> 00:25:00,036
超过50%

797
00:25:00,486 --> 00:25:01,816
这个结果让我们很满意

798
00:25:02,716 --> 00:25:04,706
所以我鼓励大家都去看一下

799
00:25:04,706 --> 00:25:06,446
这些 API  并且在你们的应用程序中

800
00:25:06,446 --> 00:25:08,596
试验一下  看看你能从中

801
00:25:08,596 --> 00:25:09,296
收获什么

802
00:25:09,356 --> 00:25:10,986
我就说到这里  下面由

803
00:25:10,986 --> 00:25:12,396
Jeremy 来给大家讲

804
00:25:12,666 --> 00:25:13,316
Web 审查器 (Web Inspector)

805
00:25:13,436 --> 00:25:13,806
谢谢大家

806
00:25:14,516 --> 00:25:20,546
[掌声]

807
00:25:21,046 --> 00:25:21,666
&gt;&gt; 谢谢 Parry

808
00:25:21,666 --> 00:25:23,366
大家好  我的名字是 Jeremy

809
00:25:23,366 --> 00:25:24,866
今天我想和大家讲讲

810
00:25:24,866 --> 00:25:26,276
在 Web 审查器 (Web Inspector) 帮助下

811
00:25:26,406 --> 00:25:28,336
进行 TVMLKit 开发时

812
00:25:28,336 --> 00:25:30,676
如何在开发中获得幸福

813
00:25:31,976 --> 00:25:34,306
我们已经看过 Parry 和 Trevor

814
00:25:34,306 --> 00:25:36,126
尝试开发 WWDC 样本程序

815
00:25:36,126 --> 00:25:38,066
的精彩示范

816
00:25:38,066 --> 00:25:39,986
程序开发到这一步  已经

817
00:25:39,986 --> 00:25:40,786
比较能干了

818
00:25:41,526 --> 00:25:43,236
目前的程序可以支持 RTL  因此

819
00:25:43,236 --> 00:25:44,466
可以一键本地化  设置成

820
00:25:44,466 --> 00:25:46,396
从右往左书写语言模式

821
00:25:46,396 --> 00:25:48,176
构建模版时还使用了数据绑定

822
00:25:48,176 --> 00:25:49,266
加原型方法  所以可以流畅地

823
00:25:49,266 --> 00:25:50,976
滚动  不会卡住等待加载

824
00:25:52,656 --> 00:25:56,406
但好巧不巧  就在

825
00:25:56,406 --> 00:25:57,456
我们准备上线的前几天

826
00:25:57,456 --> 00:25:59,406
设计师突然跑过来

827
00:25:59,406 --> 00:26:00,926
给了我们这么一个版面设计

828
00:25:59,406 --> 00:26:00,926
给了我们这么一个版面设计

829
00:26:01,296 --> 00:26:02,466
他竖起大拇指  跟你说

830
00:26:02,466 --> 00:26:03,916
这个调整一下  应该很简单

831
00:26:05,096 --> 00:26:06,716
我们都知道实际调整起来  没那么

832
00:26:06,716 --> 00:26:07,206
简单

833
00:26:07,616 --> 00:26:08,946
对此我可以说非常感同身受

834
00:26:08,946 --> 00:26:10,516
你们心里的那些抱怨声

835
00:26:10,516 --> 00:26:12,056
我也都能听见

836
00:26:13,016 --> 00:26:14,516
让我们一起看一下开发周期

837
00:26:14,516 --> 00:26:16,336
看看尤其针对这种 UI 调整

838
00:26:16,336 --> 00:26:17,346
要做哪些具体步骤

839
00:26:17,346 --> 00:26:18,576
借此试图细数一下

840
00:26:18,576 --> 00:26:19,786
到底这哪些点非常恼人

841
00:26:20,216 --> 00:26:21,916
这个 UI 调整  首先要做的

842
00:26:21,916 --> 00:26:24,066
就是预估出来所有需要调整的

843
00:26:24,066 --> 00:26:26,176
部分  还要猜测  为实现目标 UI

844
00:26:26,176 --> 00:26:27,996
具体需要做哪些

845
00:26:27,996 --> 00:26:28,236
改动

846
00:26:28,826 --> 00:26:30,016
margin 是往右还是往左

847
00:26:30,016 --> 00:26:31,036
移动一像素

848
00:26:31,036 --> 00:26:33,346
等你预估完所有需要

849
00:26:33,346 --> 00:26:35,106
调整的部位  还要

850
00:26:35,106 --> 00:26:36,436
再反复编译并运行

851
00:26:36,436 --> 00:26:37,156
来调试

852
00:26:37,326 --> 00:26:38,626
我们需要在 Xcode 里编译并运行

853
00:26:38,786 --> 00:26:40,656
等着应用启动  看一眼

854
00:26:40,656 --> 00:26:42,036
改动后的效果  对不对

855
00:26:42,326 --> 00:26:43,576
如果不对  还得

856
00:26:43,576 --> 00:26:45,136
再一遍遍地重复这个过程

857
00:26:45,136 --> 00:26:45,926
直到结果正确

858
00:26:47,166 --> 00:26:48,956
然后因为这个冗长的过程

859
00:26:48,956 --> 00:26:51,076
中间会丢失大量上下文

860
00:26:51,346 --> 00:26:52,866
开发者很容易就会沉浸在细微末节里

861
00:26:52,866 --> 00:26:53,626
而忘记最终想要的目标效果

862
00:26:53,626 --> 00:26:55,016
因为在调试过程中

863
00:26:55,016 --> 00:26:56,506
从你对代码做出改动

864
00:26:56,506 --> 00:26:57,906
到看到屏幕上的运行效果

865
00:26:57,906 --> 00:26:58,546
间隔时间实在太久

866
00:26:59,886 --> 00:27:02,006
所以  如果有一样东西

867
00:26:59,886 --> 00:27:02,006
所以  如果有一样东西

868
00:27:02,006 --> 00:27:02,966
能帮我们解决这些问题

869
00:27:02,966 --> 00:27:04,806
那该有多好

870
00:27:05,856 --> 00:27:07,056
一些经验丰富的 Web 开发者

871
00:27:07,056 --> 00:27:08,686
已经在使用 Web 审查器的

872
00:27:08,686 --> 00:27:10,206
这些强大的功能了

873
00:27:10,416 --> 00:27:11,986
包括可视化调试排错

874
00:27:12,486 --> 00:27:13,546
对 LocalStorage

875
00:27:13,546 --> 00:27:15,056
和 SessionStorage 的内省  甚至

876
00:27:15,056 --> 00:27:16,306
对 JavaScript 进行性能分析

877
00:27:17,396 --> 00:27:20,156
当前的 tvOS 在 TVMLKit 里

878
00:27:20,156 --> 00:27:22,596
只支持这一小部分针对

879
00:27:22,596 --> 00:27:24,126
Web 审查器的功能

880
00:27:25,186 --> 00:27:26,746
今天  我很高兴能宣布

881
00:27:26,746 --> 00:27:29,186
在 tvOS 11 中  我们会增加

882
00:27:29,186 --> 00:27:30,646
对 Web 审查器其余

883
00:27:30,646 --> 00:27:32,116
几项功能的支持

884
00:27:33,516 --> 00:27:36,556
[掌声]

885
00:27:37,056 --> 00:27:38,356
&gt;&gt; 我们首先讲一下

886
00:27:38,356 --> 00:27:39,396
可视化调试排错 (Visual Debugging)

887
00:27:40,646 --> 00:27:42,656
你的 TVML 应用  是一个

888
00:27:42,656 --> 00:27:44,816
以 DOM 来代表的文件  为了

889
00:27:44,816 --> 00:27:46,156
可视化这些 Web 审查器

890
00:27:46,156 --> 00:27:47,466
设有 Elements 标签页

891
00:27:47,716 --> 00:27:49,616
这里树状显示了全部节点

892
00:27:49,616 --> 00:27:51,936
TVML 就用这些节点

893
00:27:51,936 --> 00:27:52,846
来渲染 UI

894
00:27:53,536 --> 00:27:54,786
我们首先做的一项工作

895
00:27:54,786 --> 00:27:56,906
就是我们希望能完全避免

896
00:27:57,006 --> 00:27:58,256
猜测  而直接定位到需要

897
00:27:58,256 --> 00:27:59,756
调整的部分  要实现

898
00:27:59,756 --> 00:28:00,936
这一点  就应用了

899
00:27:59,756 --> 00:28:00,936
这一点  就应用了

900
00:28:00,936 --> 00:28:01,756
可视化

901
00:28:01,806 --> 00:28:03,536
如果将鼠标缓慢

902
00:28:03,536 --> 00:28:05,576
移动到树中节点上方

903
00:28:05,726 --> 00:28:06,456
Web 审查器会自动

904
00:28:06,456 --> 00:28:07,586
在屏幕上高亮与节点对应的

905
00:28:07,586 --> 00:28:08,286
UI 图形区域

906
00:28:08,736 --> 00:28:09,756
甚至会提供

907
00:28:09,756 --> 00:28:11,756
尺寸信息  和相关联

908
00:28:11,756 --> 00:28:13,116
的都有哪些元素

909
00:28:14,956 --> 00:28:16,966
现在我们准确定位了需要改动的

910
00:28:16,966 --> 00:28:18,326
那个节点  就可以

911
00:28:18,326 --> 00:28:19,966
针对这个节点

912
00:28:19,966 --> 00:28:21,836
编辑它的 XML

913
00:28:22,506 --> 00:28:23,646
期间你做出的任何改动

914
00:28:23,646 --> 00:28:25,616
都会在渲染 UI 前生效

915
00:28:26,876 --> 00:28:27,926
如果你不想改动

916
00:28:27,926 --> 00:28:29,126
XML  而只是想

917
00:28:29,126 --> 00:28:30,886
重新排列屏幕上的节点  这点

918
00:28:30,886 --> 00:28:31,886
也可以做到

919
00:28:32,196 --> 00:28:33,826
很简单  只需拖拽节点

920
00:28:33,826 --> 00:28:35,206
拖动到你期望的目标位置

921
00:28:35,206 --> 00:28:36,756
屏幕界面上会自动

922
00:28:36,756 --> 00:28:37,756
显示出相应的更新

923
00:28:39,386 --> 00:28:40,916
也有一些开发者  想在不同

924
00:28:40,916 --> 00:28:42,036
明暗度下

925
00:28:42,036 --> 00:28:43,746
查看 UI 效果  亮或者暗

926
00:28:44,026 --> 00:28:45,376
这点可以在模版上直接

927
00:28:45,376 --> 00:28:46,076
改动属性

928
00:28:46,076 --> 00:28:47,336
实际上  全部节点的

929
00:28:47,336 --> 00:28:49,106
所有属性  都可以修改

930
00:28:49,956 --> 00:28:51,626
最后一点  我们做出的

931
00:28:51,626 --> 00:28:53,246
所有这些改动  都可以

932
00:28:53,246 --> 00:28:55,116
复制出来  然后随意粘贴进

933
00:28:55,116 --> 00:28:56,056
任何文件

934
00:28:57,386 --> 00:28:58,646
现在我们看过了如何

935
00:28:58,646 --> 00:29:00,136
改变页面布局  我们再

936
00:28:58,646 --> 00:29:00,136
改变页面布局  我们再

937
00:29:00,136 --> 00:29:01,696
看一下屏幕上渲染 UI

938
00:29:01,696 --> 00:29:02,906
所需要用到的属性

939
00:29:04,046 --> 00:29:06,026
现在 Web 审查器可让我们

940
00:29:06,026 --> 00:29:07,266
查看每一个节点

941
00:29:07,266 --> 00:29:08,446
所关联的对应规则

942
00:29:08,446 --> 00:29:09,856
所以现在我们可以查看

943
00:29:09,856 --> 00:29:11,586
渲染全部节点所用的

944
00:29:11,586 --> 00:29:12,826
每一条规则

945
00:29:14,156 --> 00:29:15,986
这些都按照层叠顺序

946
00:29:15,986 --> 00:29:17,326
来排序  权重最大的

947
00:29:17,326 --> 00:29:18,916
那些规则  显示在最上面

948
00:29:18,916 --> 00:29:20,136
它们覆盖的那些规则

949
00:29:20,136 --> 00:29:22,586
被排在最底端

950
00:29:22,726 --> 00:29:24,446
媒体查询也可以

951
00:29:24,446 --> 00:29:25,736
被可视化  所以我们也可以

952
00:29:25,736 --> 00:29:27,466
查看特定媒体查询

953
00:29:27,536 --> 00:29:28,926
所对应的

954
00:29:28,926 --> 00:29:30,596
特定规则  举个例子

955
00:29:30,596 --> 00:29:32,906
若有针对 LTR 的规则  也可以

956
00:29:32,906 --> 00:29:35,246
看到相应规则被归类显示

957
00:29:35,246 --> 00:29:35,446
了

958
00:29:35,446 --> 00:29:37,696
最后  Web 审查器

959
00:29:37,696 --> 00:29:38,866
还可以让我们查看

960
00:29:38,866 --> 00:29:40,336
框架本身自带的

961
00:29:40,336 --> 00:29:41,376
默认规则

962
00:29:41,376 --> 00:29:43,106
这样一来  要知道做出

963
00:29:43,106 --> 00:29:44,286
一个完美漂亮的 UI 成品

964
00:29:44,286 --> 00:29:46,126
还需要改动哪些默认规则

965
00:29:46,126 --> 00:29:47,566
也完全不需要靠开发者自己

966
00:29:47,656 --> 00:29:50,216
来猜测了

967
00:29:50,216 --> 00:29:51,576
当然  显示出来

968
00:29:51,616 --> 00:29:53,576
这么多的规则  我们

969
00:29:53,956 --> 00:29:55,476
也会提供一个合并

970
00:29:55,476 --> 00:29:56,506
的版本

971
00:29:56,506 --> 00:29:57,886
屏幕上渲染 UI 时

972
00:29:57,886 --> 00:29:59,246
用的就是这些

973
00:29:59,246 --> 00:29:59,886
样式了

974
00:29:59,886 --> 00:30:04,106
在 Web 审查器里  还有

975
00:29:59,886 --> 00:30:04,106
在 Web 审查器里  还有

976
00:30:04,106 --> 00:30:05,686
一个重新加载 (Reload) 按钮  现在

977
00:30:05,686 --> 00:30:06,666
只要点击这个按钮

978
00:30:06,666 --> 00:30:08,326
就可以重启整个

979
00:30:08,326 --> 00:30:10,036
JavaScript 执行上下文  不需要

980
00:30:10,036 --> 00:30:11,336
再通过反复编译并运行来调试

981
00:30:11,336 --> 00:30:11,916
程序

982
00:30:12,536 --> 00:30:13,696
讲完这些  我想用一个

983
00:30:13,696 --> 00:30:15,776
演示实例  给大家展示一下

984
00:30:15,776 --> 00:30:16,526
刚刚所说的功能

985
00:30:21,046 --> 00:30:23,496
现在我已经事先准备

986
00:30:23,726 --> 00:30:25,316
好了项目  也更新了 UI

987
00:30:25,316 --> 00:30:27,016
最后要做的就是

988
00:30:27,016 --> 00:30:28,326
检查程序是否可以

989
00:30:28,326 --> 00:30:28,856
完美支持 RTL

990
00:30:28,856 --> 00:30:29,236
好了

991
00:30:29,236 --> 00:30:35,126
我们现在要再次应用

992
00:30:35,126 --> 00:30:36,496
前面 Trevor 教给我们的方法

993
00:30:36,496 --> 00:30:37,966
去 scheme 下

994
00:30:38,186 --> 00:30:39,566
把应用程序的系统语言

995
00:30:39,566 --> 00:30:40,876
改为从右往左的伪码

996
00:30:41,296 --> 00:30:42,976
编译并运行一下

997
00:30:55,046 --> 00:30:55,216
好了

998
00:30:55,216 --> 00:30:57,006
如大家所见  整体看起来

999
00:30:57,076 --> 00:30:58,396
还不错  除了页面上方的横幅

1000
00:30:58,396 --> 00:30:59,826
我们还没来得及为 RTL

1001
00:30:59,826 --> 00:31:01,106
做优化

1002
00:30:59,826 --> 00:31:01,106
做优化

1003
00:31:01,726 --> 00:31:02,896
那么接下来的调试  我们就不需要

1004
00:31:02,896 --> 00:31:04,276
像 Trevor 那样  反复编译并运行

1005
00:31:04,276 --> 00:31:05,866
而是试图通过

1006
00:31:05,866 --> 00:31:06,536
Web 审查器来做

1007
00:31:06,916 --> 00:31:08,136
讲下具体操作方法  我们先

1008
00:31:08,136 --> 00:31:11,666
打开 Safari   可以看到我已经

1009
00:31:11,666 --> 00:31:13,016
启用了开发者工具菜单

1010
00:31:13,016 --> 00:31:14,576
点进去  找到 Simulator

1011
00:31:14,576 --> 00:31:16,756
然后审查你想要调试的应用

1012
00:31:16,756 --> 00:31:17,796
程序

1013
00:31:20,266 --> 00:31:23,026
这就打开了 Web 审查器

1014
00:31:23,026 --> 00:31:23,916
可以开始调试了

1015
00:31:24,566 --> 00:31:26,946
现在我们想要改动

1016
00:31:26,946 --> 00:31:28,116
屏幕上的几个 UI 元素

1017
00:31:28,116 --> 00:31:29,506
我们可以看到  这里的

1018
00:31:29,506 --> 00:31:30,646
标题  副标题  和

1019
00:31:30,646 --> 00:31:31,676
按钮  都需要调整

1020
00:31:31,676 --> 00:31:33,636
用 Web 审查器  我们可以

1021
00:31:33,636 --> 00:31:35,236
轻松定位到这些元素

1022
00:31:35,236 --> 00:31:37,006
所对应的节点

1023
00:31:37,006 --> 00:31:37,976
只要移动鼠标  就可以看到

1024
00:31:37,976 --> 00:31:39,076
节点对应的元素被

1025
00:31:39,076 --> 00:31:39,646
高亮了

1026
00:31:40,276 --> 00:31:41,626
我们现在快速地找到标题

1027
00:31:41,626 --> 00:31:41,976
来进行调整

1028
00:31:44,916 --> 00:31:46,706
找到后  Web 审查器会显示出

1029
00:31:46,706 --> 00:31:47,876
这个节点所对应的

1030
00:31:47,876 --> 00:31:49,506
所有规则  我们现在只需

1031
00:31:49,506 --> 00:31:51,396
在规则中找到这个恼人的

1032
00:31:51,396 --> 00:31:52,436
bottom-left   把它改为

1033
00:31:52,436 --> 00:31:53,186
bottom-leading

1034
00:31:53,516 --> 00:31:55,656
大家注意看  我边打字

1035
00:31:55,656 --> 00:31:57,126
模拟屏幕上会产生什么

1036
00:31:57,126 --> 00:31:57,526
变化

1037
00:31:59,316 --> 00:32:01,206
你看  屏幕显示自动更新了

1038
00:31:59,316 --> 00:32:01,206
你看  屏幕显示自动更新了

1039
00:32:01,206 --> 00:32:03,336
不需要我们再去编译并运行

1040
00:32:03,556 --> 00:32:05,946
响应非常快  如果有人

1041
00:32:05,946 --> 00:32:07,376
没看到  我们再来

1042
00:32:07,376 --> 00:32:08,406
对副标题进行一下

1043
00:32:08,406 --> 00:32:10,256
改动  一样的步骤

1044
00:32:10,546 --> 00:32:12,426
定位到你想改动的元素

1045
00:32:12,426 --> 00:32:14,066
改动相关联的样式

1046
00:32:16,186 --> 00:32:16,896
好了

1047
00:32:17,876 --> 00:32:19,466
我们也把播放按钮

1048
00:32:19,466 --> 00:32:20,536
快速地修改一下  让它

1049
00:32:20,536 --> 00:32:21,676
显示在正确的位置

1050
00:32:23,496 --> 00:32:24,916
我们需要把所有的 right

1051
00:32:24,916 --> 00:32:26,166
都改为 trailing

1052
00:32:27,866 --> 00:32:34,026
拼一下 trailing  当然

1053
00:32:34,026 --> 00:32:35,526
就像 Trevor 之前做的  为了设置

1054
00:32:35,526 --> 00:32:36,636
正确的 margin  还需单独

1055
00:32:36,636 --> 00:32:38,676
创建媒体查询  因为 RTL 语言模式下

1056
00:32:38,676 --> 00:32:40,106
数据要写在不同位置

1057
00:32:40,106 --> 00:32:41,666
所以我来复制一下 margin

1058
00:32:43,096 --> 00:32:43,846
粘贴过去

1059
00:32:45,106 --> 00:32:46,246
这里再改一下

1060
00:32:46,786 --> 00:32:47,806
然后就好了

1061
00:32:48,566 --> 00:32:49,786
我们做的这些改动

1062
00:32:49,786 --> 00:32:51,176
都是在作者样式表上

1063
00:32:51,176 --> 00:32:52,596
而作者样式表是包含在

1064
00:32:52,596 --> 00:32:54,876
样式属性

1065
00:32:54,876 --> 00:32:56,376
样式标签下  我们把这些都复制

1066
00:32:56,376 --> 00:32:57,016
下来

1067
00:32:58,216 --> 00:32:59,456
为了核对  我们把这些

1068
00:32:59,456 --> 00:33:00,786
都粘贴到我们的 TVML

1069
00:32:59,456 --> 00:33:00,786
都粘贴到我们的 TVML

1070
00:33:00,786 --> 00:33:01,286
文档里

1071
00:33:01,796 --> 00:33:05,046
好了

1072
00:33:05,126 --> 00:33:08,626
然后这次不用编译并运行

1073
00:33:08,626 --> 00:33:10,966
我们可以直接点击

1074
00:33:10,966 --> 00:33:11,396
重新加载

1075
00:33:12,246 --> 00:33:12,896
就好了

1076
00:33:12,896 --> 00:33:14,416
一切运行正常

1077
00:33:14,416 --> 00:33:14,886
[掌声]

1078
00:33:14,886 --> 00:33:16,296
我们回到幻灯片

1079
00:33:17,516 --> 00:33:19,776
[掌声]

1080
00:33:20,276 --> 00:33:21,496
大家刚刚看到了  这种方法

1081
00:33:21,496 --> 00:33:22,926
可以快速定位 UI 中的问题

1082
00:33:22,926 --> 00:33:24,286
并对其进行调整

1083
00:33:24,286 --> 00:33:26,266
应用起来的具体步骤

1084
00:33:26,266 --> 00:33:27,776
是先找到具体

1085
00:33:27,776 --> 00:33:29,916
受影响的节点  对它们

1086
00:33:29,916 --> 00:33:31,486
进行实时编辑  最后

1087
00:33:31,486 --> 00:33:32,936
只需把 TVML 属性

1088
00:33:33,246 --> 00:33:35,276
复制出来并粘贴

1089
00:33:35,446 --> 00:33:36,706
然后直接重启整个 JavaScript

1090
00:33:36,706 --> 00:33:38,706
执行上下文即可  不再需要

1091
00:33:38,706 --> 00:33:39,896
一遍遍地编译并运行

1092
00:33:40,946 --> 00:33:42,406
以上这就是可视化调试排错

1093
00:33:42,406 --> 00:33:43,916
我下面开始介绍

1094
00:33:43,916 --> 00:33:44,936
网络分析 (Network Analysis)

1095
00:33:46,036 --> 00:33:47,526
Web 审查器现在支持

1096
00:33:47,526 --> 00:33:49,336
查看从 TVMLKit

1097
00:33:49,336 --> 00:33:50,686
应用发出的所有

1098
00:33:50,686 --> 00:33:51,306
网络请求

1099
00:33:52,166 --> 00:33:53,846
我们可以查看

1100
00:33:53,846 --> 00:33:55,026
单项请求的耗时信息

1101
00:33:55,026 --> 00:33:56,996
比如 DNS 查询花了多长时间

1102
00:33:56,996 --> 00:33:58,396
比如响应传输需要花费

1103
00:33:58,396 --> 00:33:59,436
多长时间

1104
00:34:00,206 --> 00:34:01,846
我们还可以审查

1105
00:34:01,846 --> 00:34:03,246
你给某一个请求单独

1106
00:34:03,246 --> 00:34:04,626
设置的审查属性

1107
00:34:04,626 --> 00:34:06,336
可用来确认发出去的信息

1108
00:34:06,336 --> 00:34:07,326
符合预期

1109
00:34:07,326 --> 00:34:09,556
最后  如果需要

1110
00:34:09,556 --> 00:34:11,206
我们还可以查看响应头

1111
00:34:11,206 --> 00:34:13,996
和请求头

1112
00:34:14,056 --> 00:34:15,275
可能你目前还写了脚本

1113
00:34:15,275 --> 00:34:17,505
来内省 LocalStorage

1114
00:34:17,505 --> 00:34:18,806
和 SessionStorage

1115
00:34:19,206 --> 00:34:20,286
以后这个工作也不需要做了

1116
00:34:20,286 --> 00:34:21,426
因为 Web 审查器也会

1117
00:34:21,426 --> 00:34:23,126
提供一个很好的 UI

1118
00:34:23,406 --> 00:34:24,696
让我们看到我们 LocalStorage

1119
00:34:24,696 --> 00:34:26,815
和 SessionStorage 里每一个

1120
00:34:26,815 --> 00:34:28,936
关键值路径

1121
00:34:28,936 --> 00:34:30,456
而能查看这些数据  也就意味着

1122
00:34:30,456 --> 00:34:31,766
我们可以进行修改

1123
00:34:32,016 --> 00:34:33,775
可以进行复制  删除

1124
00:34:33,775 --> 00:34:34,766
也可以随意移动

1125
00:34:35,326 --> 00:34:38,516
就这些  这就是 TVMLKit

1126
00:34:38,516 --> 00:34:39,985
如何支持 Web 审查器

1127
00:34:39,985 --> 00:34:40,966
这就是如何在开发中获得

1128
00:34:40,966 --> 00:34:41,606
幸福

1129
00:34:42,516 --> 00:34:45,545
[掌声]

1130
00:34:46,045 --> 00:34:47,045
总结下  我们今天讲了什么

1131
00:34:47,775 --> 00:34:49,666
首先 TVMLKit 自身  对于所有默认模版

1132
00:34:49,666 --> 00:34:50,806
都提供对从右往左书写语言

1133
00:34:50,806 --> 00:34:51,356
的支持

1134
00:34:51,476 --> 00:34:52,616
如果你的应用程序中有自定义样式

1135
00:34:52,616 --> 00:34:54,436
可能配置起来会复杂一点

1136
00:34:54,436 --> 00:34:55,295
但都很简单

1137
00:34:56,005 --> 00:34:57,326
像 Parry 讲的  如果你想要流畅

1138
00:34:57,326 --> 00:34:58,286
顺滑的滚动用户体验

1139
00:34:58,286 --> 00:35:00,606
请使用数据绑定和原型

1140
00:34:58,286 --> 00:35:00,606
请使用数据绑定和原型

1141
00:35:00,736 --> 00:35:02,906
最后  如果你希望在

1142
00:35:02,906 --> 00:35:04,426
开发应用程序时

1143
00:35:04,426 --> 00:35:05,876
减少调试排错的时间  请使用

1144
00:35:05,876 --> 00:35:06,456
Web 审查器

1145
00:35:06,646 --> 00:35:08,386
更多信息  请访问

1146
00:35:08,386 --> 00:35:09,456
屏幕上显示的网址

1147
00:35:09,756 --> 00:35:10,656
网站上有样本代码和

1148
00:35:10,656 --> 00:35:11,646
支持文件  都非常有用

1149
00:35:11,646 --> 00:35:12,606
值得一看

1150
00:35:13,286 --> 00:35:15,026
另外还有一些 其他很棒的演讲可以参加

1151
00:35:15,026 --> 00:35:16,686
尤其 What's New in

1152
00:35:16,686 --> 00:35:18,116
tvOS tomorrow

1153
00:35:18,956 --> 00:35:21,486
感谢大家参加 WWDC 2017

1154
00:35:21,556 --> 00:35:22,456
希望大家在大会剩下的时光

1155
00:35:22,456 --> 00:35:22,946
都过得愉快
