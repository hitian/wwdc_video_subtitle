1
00:00:17,551 --> 00:00:24,558
<c.magenta>（加速和稀疏求解器）</c>

2
00:00:26,059 --> 00:00:27,995
<c.magenta>谢谢 欢迎参加加速演讲</c>

3
00:00:28,061 --> 00:00:31,865
<c.magenta>我叫Eric Bainville</c>

4
00:00:33,033 --> 00:00:35,969
<c.magenta>我们工作组的任务是</c>

5
00:00:36,470 --> 00:00:40,174
<c.magenta>这是我们今天要讲的内容</c>

6
00:00:40,274 --> 00:00:43,010
<c.magenta>它包含什么 如何使用它</c>

7
00:00:43,076 --> 00:00:45,012
<c.magenta>我会给大家演示你为什么要用它</c>

8
00:00:45,479 --> 00:00:49,650
<c.magenta>我们主要关注</c>

9
00:00:49,716 --> 00:00:53,120
<c.magenta>首先讲Compression</c>

10
00:00:53,187 --> 00:00:56,390
<c.magenta>然后是BNNS 基本神经网络子程序</c>

11
00:00:57,024 --> 00:00:59,960
<c.magenta>之后我的同事Steve</c>

12
00:01:00,027 --> 00:01:01,395
<c.magenta>simd中的新功能</c>

13
00:01:01,461 --> 00:01:05,199
<c.magenta>最后我们非常亲爱的</c>

14
00:01:05,265 --> 00:01:07,367
<c.magenta>跟大家介绍稀疏矩阵</c>

15
00:01:07,501 --> 00:01:09,770
<c.magenta>稀疏矩阵求解器</c>

16
00:01:09,837 --> 00:01:12,673
<c.magenta>被首次商业化了</c>

17
00:01:12,739 --> 00:01:14,208
<c.magenta>但让我们先从</c>

18
00:01:15,509 --> 00:01:20,447
<c.magenta>Accelerate是一个</c>

19
00:01:20,514 --> 00:01:21,682
<c.magenta>用于CPU上的高性能基元</c>

20
00:01:22,916 --> 00:01:25,352
<c.magenta>实际上它无所不在</c>

21
00:01:25,419 --> 00:01:27,855
<c.magenta>当你占用了太多CPU时</c>

22
00:01:28,455 --> 00:01:31,158
<c.magenta>在Accelerate内部有许多库</c>

23
00:01:31,225 --> 00:01:35,462
<c.magenta>比如vImage用于图像处理</c>

24
00:01:35,762 --> 00:01:40,567
<c.magenta>我们还包括vDSP</c>

25
00:01:40,634 --> 00:01:42,636
<c.magenta>还有vForce用于向量函数</c>

26
00:01:43,136 --> 00:01:46,240
<c.magenta>然后我们有许多线性代数库</c>

27
00:01:46,306 --> 00:01:48,542
<c.magenta>用于密集和稀疏矩阵</c>

28
00:01:48,609 --> 00:01:51,745
<c.magenta>那么这是用于密集向量</c>

29
00:01:51,812 --> 00:01:55,816
<c.magenta>还有Sparse BLAS</c>

30
00:01:56,416 --> 00:01:59,887
<c.magenta>去年我们还引入了</c>

31
00:01:59,953 --> 00:02:02,155
<c.magenta>这是对我们更新的网络的支持</c>

32
00:01:59,953 --> 00:02:02,155
<c.magenta>这是对我们更新的网络的支持</c>

33
00:02:02,256 --> 00:02:07,561
<c.magenta>这用在 比如说 Core ML</c>

34
00:02:08,095 --> 00:02:11,765
<c.magenta>稍微偏离了Accelerate</c>

35
00:02:11,832 --> 00:02:14,001
<c.magenta>就是一个标头和函数的集合</c>

36
00:02:14,067 --> 00:02:17,171
<c.magenta>允许你直接与CPU向量单元通讯</c>

37
00:02:17,905 --> 00:02:21,441
<c.magenta>最后是Compression</c>

38
00:02:22,276 --> 00:02:23,977
<c.magenta>如何使用Accelerate？</c>

39
00:02:24,578 --> 00:02:27,881
<c.magenta>你导入Accelerate</c>

40
00:02:27,948 --> 00:02:30,984
<c.magenta>然后在你自己的集合中</c>

41
00:02:31,051 --> 00:02:34,988
<c.magenta>现在我要给你们展示几个例子</c>

42
00:02:35,389 --> 00:02:36,823
<c.magenta>让我们从那个开始谈吧</c>

43
00:02:37,057 --> 00:02:39,459
<c.magenta>那么让我们假设</c>

44
00:02:39,526 --> 00:02:41,428
<c.magenta>你想调整这些值</c>

45
00:02:42,095 --> 00:02:44,831
<c.magenta>那么你有这个调整</c>

46
00:02:44,898 --> 00:02:48,202
<c.magenta>并将其存储在Y向量中</c>

47
00:02:48,602 --> 00:02:49,803
<c.magenta>非常完美</c>

48
00:02:50,070 --> 00:02:53,607
<c.magenta>但其实在Accelerate中</c>

49
00:02:53,674 --> 00:02:54,775
<c.magenta>它叫作vsmul</c>

50
00:02:55,676 --> 00:02:58,645
<c.magenta>那么只需要用一行代码来替换你的代码</c>

51
00:02:58,879 --> 00:03:03,851
<c.magenta>好处是我们为你进行了优化</c>

52
00:02:58,879 --> 00:03:03,851
<c.magenta>好处是我们为你进行了优化</c>

53
00:03:04,117 --> 00:03:05,452
<c.magenta>当然 我们也会替你们维护</c>

54
00:03:05,519 --> 00:03:07,688
<c.magenta>所以你就不再需要维护你的循环了</c>

55
00:03:07,921 --> 00:03:10,858
<c.magenta>当然了 它更快</c>

56
00:03:11,258 --> 00:03:14,261
<c.magenta>那么这对于循环来说是一个基准速度</c>

57
00:03:14,328 --> 00:03:18,165
<c.magenta>这是你通过Accelerate</c>

58
00:03:21,768 --> 00:03:25,606
<c.magenta>并且能量消耗少了六倍 这非常重要</c>

59
00:03:25,672 --> 00:03:26,874
<c.magenta>让我给你看另一个例子</c>

60
00:03:27,140 --> 00:03:30,844
<c.magenta>那么这次我们仍然有这个数组X</c>

61
00:03:30,911 --> 00:03:33,881
<c.magenta>下限和上限之间的值并将其保存到Y中</c>

62
00:03:34,081 --> 00:03:37,217
<c.magenta>再一次 你可以通过写这段代码来实现</c>

63
00:03:37,284 --> 00:03:41,922
<c.magenta>但我们在vDSP中有一个函数</c>

64
00:03:41,989 --> 00:03:44,958
<c.magenta>我们替你维护它</c>

65
00:03:45,526 --> 00:03:48,262
<c.magenta>当然了 它速度更快</c>

66
00:03:48,595 --> 00:03:50,531
<c.magenta>这是你通过Accelerate</c>

67
00:03:51,231 --> 00:03:54,601
<c.magenta>速度快了八倍 并且能量消耗少了八倍</c>

68
00:03:55,202 --> 00:03:56,270
<c.magenta>另一个例子</c>

69
00:03:57,571 --> 00:04:00,207
<c.magenta>矩阵 那么假如我们有两个矩阵A和B</c>

70
00:03:57,571 --> 00:04:00,207
<c.magenta>矩阵 那么假如我们有两个矩阵A和B</c>

71
00:04:00,274 --> 00:04:02,242
<c.magenta>你想要计算A和B的结果</c>

72
00:04:02,309 --> 00:04:04,678
<c.magenta>并把结果添加到C矩阵中</c>

73
00:04:06,180 --> 00:04:08,148
<c.magenta>听起来没那么简单 但实际上非常简单</c>

74
00:04:08,215 --> 00:04:10,551
<c.magenta>你只需要三行代码就可以实现</c>

75
00:04:11,351 --> 00:04:14,288
<c.magenta>当然在Accelerate中</c>

76
00:04:14,354 --> 00:04:16,757
<c.magenta>叫作sgemm 用于Cblas</c>

77
00:04:18,692 --> 00:04:21,461
<c.magenta>真的 真的 你永远不希望通过写代码</c>

78
00:04:21,528 --> 00:04:22,930
<c.magenta>来计算矩阵向量结果</c>

79
00:04:22,996 --> 00:04:25,465
<c.magenta>或矩阵度量或任何与矩阵相关的东西</c>

80
00:04:25,532 --> 00:04:27,401
<c.magenta>你再也不想写那样的代码了</c>

81
00:04:28,202 --> 00:04:31,205
<c.magenta>你想调用Accelerate中的</c>

82
00:04:31,538 --> 00:04:34,908
<c.magenta>为什么？嗯 首先是因为</c>

83
00:04:34,975 --> 00:04:38,545
<c.magenta>和多线程化</c>

84
00:04:39,713 --> 00:04:42,416
<c.magenta>这一次 这是对循环的一个参考</c>

85
00:04:42,482 --> 00:04:46,019
<c.magenta>这是你通过Accelerate</c>

86
00:04:47,588 --> 00:04:49,623
<c.magenta>是的 速度快了100倍</c>

87
00:04:51,925 --> 00:04:54,528
<c.magenta>并且能量比原来节约了26倍</c>

88
00:04:54,928 --> 00:04:56,396
<c.magenta>这是你的电池</c>

89
00:04:56,897 --> 00:04:59,333
<c.magenta>好的 再讲一个例子</c>

90
00:04:59,399 --> 00:05:01,802
<c.magenta>那么假如你有一个32位/像素的图像</c>

91
00:04:59,399 --> 00:05:01,802
<c.magenta>那么假如你有一个32位/像素的图像</c>

92
00:05:01,869 --> 00:05:05,606
<c.magenta>每个像素有四个组成成分</c>

93
00:05:05,906 --> 00:05:08,609
<c.magenta>并且你想给图像中的每个像素</c>

94
00:05:08,675 --> 00:05:10,110
<c.magenta>都应用一个4x4的转换矩阵</c>

95
00:05:10,777 --> 00:05:13,380
<c.magenta>但你可通过写代码来实现</c>

96
00:05:13,447 --> 00:05:15,182
<c.magenta>但实际上 你不需要写代码</c>

97
00:05:15,249 --> 00:05:17,651
<c.magenta>我们在vImage中有一个函数</c>

98
00:05:17,718 --> 00:05:19,887
<c.magenta>它是vImage中最常用的函数之一</c>

99
00:05:19,953 --> 00:05:23,957
<c.magenta>完全可以实现那个功能</c>

100
00:05:24,024 --> 00:05:26,026
<c.magenta>在我们所支持的全部架构中</c>

101
00:05:26,727 --> 00:05:30,264
<c.magenta>最后一个例子 这是个卷积层</c>

102
00:05:30,330 --> 00:05:33,834
<c.magenta>这是神经网络中的主力</c>

103
00:05:33,901 --> 00:05:35,602
<c.magenta>卷积神经网络</c>

104
00:05:35,869 --> 00:05:38,572
<c.magenta>那么这个层获取输入堆栈</c>

105
00:05:38,639 --> 00:05:42,809
<c.magenta>就是左边显示的这个东西 是一堆图像</c>

106
00:05:42,943 --> 00:05:46,113
<c.magenta>它将生产输入图像堆栈</c>

107
00:05:46,180 --> 00:05:50,117
<c.magenta>输出中的每个像素都是协定卷积的结果</c>

108
00:05:50,184 --> 00:05:52,019
<c.magenta>在整个输入堆栈上</c>

109
00:05:52,085 --> 00:05:55,656
<c.magenta>我们给这三个中的每一个都执行一遍</c>

110
00:05:55,989 --> 00:05:58,458
<c.magenta>那么最后 那是一个六维循环</c>

111
00:05:59,026 --> 00:06:00,994
<c.magenta>你真的不想写这个循环了</c>

112
00:05:59,026 --> 00:06:00,994
<c.magenta>你真的不想写这个循环了</c>

113
00:06:01,228 --> 00:06:04,831
<c.magenta>就算维数小 你也要把它们乘在一起</c>

114
00:06:04,898 --> 00:06:09,203
<c.magenta>那么这是数百万</c>

115
00:06:10,070 --> 00:06:13,106
<c.magenta>当然 我们为你准备了一个函数</c>

116
00:06:13,273 --> 00:06:15,108
<c.magenta>当你运行Core ML模型时</c>

117
00:06:15,175 --> 00:06:17,878
<c.magenta>我们将在这个函数中</c>

118
00:06:19,012 --> 00:06:20,981
<c.magenta>好的 那么这是几个简单的例子</c>

119
00:06:21,048 --> 00:06:22,816
<c.magenta>我几乎可以一直举例</c>

120
00:06:22,883 --> 00:06:26,520
<c.magenta>因为我们在Accelerate中</c>

121
00:06:27,054 --> 00:06:29,389
<c.magenta>那么通常这些API中</c>

122
00:06:29,556 --> 00:06:31,825
<c.magenta>每次你使用</c>

123
00:06:32,326 --> 00:06:35,195
<c.magenta>好处似乎你不再需要写那么多代码了</c>

124
00:06:35,729 --> 00:06:37,030
<c.magenta>并且我们也会替你维护</c>

125
00:06:37,097 --> 00:06:39,933
<c.magenta>当然了 它的速度更快 更节能</c>

126
00:06:40,000 --> 00:06:41,468
<c.magenta>并且它是最优化的</c>

127
00:06:42,369 --> 00:06:45,405
<c.magenta>在我们所支持的全部架构中</c>

128
00:06:45,472 --> 00:06:48,542
<c.magenta>包括一些新架构</c>

129
00:06:48,609 --> 00:06:51,712
<c.magenta>你的代码将从第一天开始</c>

130
00:06:52,646 --> 00:06:56,717
<c.magenta>好的 这是Accelerate</c>

131
00:06:58,952 --> 00:07:01,688
<c.magenta>Compression是一个</c>

132
00:06:58,952 --> 00:07:01,688
<c.magenta>Compression是一个</c>

133
00:07:01,755 --> 00:07:06,059
<c.magenta>它是一个非常简单的API</c>

134
00:07:06,393 --> 00:07:09,062
<c.magenta>那么这个小图表显示出了</c>

135
00:07:09,363 --> 00:07:12,633
<c.magenta>在x轴上你可以看到相对压缩率</c>

136
00:07:12,699 --> 00:07:15,002
<c.magenta>相对于ZLIB ZLIB在中心</c>

137
00:07:15,169 --> 00:07:18,972
<c.magenta>y轴是压缩速度</c>

138
00:07:19,239 --> 00:07:20,541
<c.magenta>并不是呈指数</c>

139
00:07:21,241 --> 00:07:25,479
<c.magenta>那么在压缩库内部 我们有一些压缩器</c>

140
00:07:25,913 --> 00:07:28,982
<c.magenta>LZMA的压缩性能较好</c>

141
00:07:29,049 --> 00:07:32,352
<c.magenta>LZ4的优化版压缩速度快</c>

142
00:07:33,120 --> 00:07:36,356
<c.magenta>当然了 我们有ZLIB</c>

143
00:07:36,423 --> 00:07:42,296
<c.magenta>还有我们自己的LZFSE 它比ZLIB</c>

144
00:07:42,729 --> 00:07:46,233
<c.magenta>去年我们开源了LZFSE</c>

145
00:07:47,668 --> 00:07:49,369
<c.magenta>好的 现在讲API</c>

146
00:07:50,037 --> 00:07:52,472
<c.magenta>在压缩中有两个API</c>

147
00:07:52,573 --> 00:07:54,007
<c.magenta>第一个是缓冲器API</c>

148
00:07:54,074 --> 00:07:56,643
<c.magenta>那么就是当你压缩全部数据时使用</c>

149
00:07:57,477 --> 00:08:01,315
<c.magenta>你在要压缩的数据中引用一个缓冲器</c>

150
00:07:57,477 --> 00:08:01,315
<c.magenta>你在要压缩的数据中引用一个缓冲器</c>

151
00:08:01,982 --> 00:08:04,985
<c.magenta>提供输出缓冲器 然后就会在一个</c>

152
00:08:05,052 --> 00:08:07,054
<c.magenta>这对于编码和解码很有帮助</c>

153
00:08:07,120 --> 00:08:11,592
<c.magenta>如果数据很大或数据是一小块一小块的</c>

154
00:08:11,658 --> 00:08:13,427
<c.magenta>你就要使用一个数据流API</c>

155
00:08:14,094 --> 00:08:18,065
<c.magenta>在那种情况下你要创建一个数据流对象</c>

156
00:08:18,131 --> 00:08:19,733
<c.magenta>然后在外部获得一个较小的数据</c>

157
00:08:19,800 --> 00:08:23,604
<c.magenta>你要重复调用它</c>

158
00:08:25,339 --> 00:08:30,143
<c.magenta>这是我们提供给你的 我们改进了它</c>

159
00:08:31,378 --> 00:08:34,847
<c.magenta>那么你可以从命令行中</c>

160
00:08:35,549 --> 00:08:38,784
<c.magenta>好的 这是Compression</c>

161
00:08:38,852 --> 00:08:40,654
<c.magenta>（基本神经网络子程序 BNNS）</c>

162
00:08:40,721 --> 00:08:43,756
<c.magenta>正如我所说过的 这是CPU的引擎</c>

163
00:08:44,057 --> 00:08:49,663
<c.magenta>它支持着全部神经网络和机器学习库</c>

164
00:08:49,830 --> 00:08:54,735
<c.magenta>那么你几乎可以随时使用BNNS</c>

165
00:08:54,801 --> 00:09:00,741
<c.magenta>或当你运行面部识别时</c>

166
00:08:54,801 --> 00:09:00,741
<c.magenta>或当你运行面部识别时</c>

167
00:09:01,742 --> 00:09:04,845
<c.magenta>BNNS为此提供了低等级的函数</c>

168
00:09:04,912 --> 00:09:08,415
<c.magenta>那么是卷积层、池化层</c>

169
00:09:09,049 --> 00:09:10,517
<c.magenta>我们还有完全连接的层</c>

170
00:09:10,584 --> 00:09:14,621
<c.magenta>我们还添加了独立激活层</c>

171
00:09:14,688 --> 00:09:16,523
<c.magenta>正是用于执行激活函数</c>

172
00:09:16,723 --> 00:09:19,526
<c.magenta>这些层还可以执行高效转换、</c>

173
00:09:19,593 --> 00:09:21,195
<c.magenta>数据类型转换</c>

174
00:09:21,562 --> 00:09:24,565
<c.magenta>提到了数据类型</c>

175
00:09:24,698 --> 00:09:27,901
<c.magenta>那么当你训练机器学习模型时</c>

176
00:09:27,968 --> 00:09:32,472
<c.magenta>你会得到数百万字节或上亿字节的数据</c>

177
00:09:32,539 --> 00:09:35,342
<c.magenta>通常是32位的浮点型数据</c>

178
00:09:35,576 --> 00:09:37,845
<c.magenta>这些是卷积比重等等</c>

179
00:09:38,345 --> 00:09:42,282
<c.magenta>你可以把这些家伙转换成较小的类型</c>

180
00:09:42,349 --> 00:09:47,020
<c.magenta>比如16位浮点 或甚至是8位整数</c>

181
00:09:47,087 --> 00:09:49,890
<c.magenta>并仍得到同样的精确度</c>

182
00:09:49,957 --> 00:09:53,493
<c.magenta>但是当然了</c>

183
00:09:53,560 --> 00:09:55,495
<c.magenta>你的模型就缩小了4倍</c>

184
00:09:55,562 --> 00:09:57,164
<c.magenta>对此你要与你的应用进行协商</c>

185
00:09:57,231 --> 00:09:59,066
<c.magenta>那么你要考虑到这一点</c>

186
00:09:59,833 --> 00:10:03,470
<c.magenta>今年 我们优化了BNNS</c>

187
00:09:59,833 --> 00:10:03,470
<c.magenta>今年 我们优化了BNNS</c>

188
00:10:03,770 --> 00:10:08,575
<c.magenta>那么这是我们现在所支持的</c>

189
00:10:09,142 --> 00:10:10,210
<c.magenta>绿色部分是新添加的</c>

190
00:10:11,044 --> 00:10:15,315
<c.magenta>看 我们为输入和比重</c>

191
00:10:16,750 --> 00:10:20,420
<c.magenta>这是我们对完全连接的层中</c>

192
00:10:20,487 --> 00:10:22,789
<c.magenta>那么我们仍然支持32位</c>

193
00:10:22,856 --> 00:10:26,260
<c.magenta>但我们也可以采用16位</c>

194
00:10:27,027 --> 00:10:30,864
<c.magenta>现在 对于激活函数 这是去年的</c>

195
00:10:30,931 --> 00:10:34,501
<c.magenta>今年我们又增加了一些</c>

196
00:10:34,568 --> 00:10:37,070
<c.magenta>现在我们在BNNS中</c>

197
00:10:38,038 --> 00:10:42,075
<c.magenta>如果你把激活函数设为身份</c>

198
00:10:42,142 --> 00:10:45,479
<c.magenta>把输入和输出类型修改为不同组合</c>

199
00:10:45,612 --> 00:10:47,481
<c.magenta>这是我们现在所支持的</c>

200
00:10:47,548 --> 00:10:50,551
<c.magenta>你将从BNNS中</c>

201
00:10:51,552 --> 00:10:53,587
<c.magenta>最后一个也同样重要 性能</c>

202
00:10:54,821 --> 00:10:58,892
<c.magenta>我们与Core ML团队以及</c>

203
00:10:58,959 --> 00:11:01,728
<c.magenta>优化他们平时使用最频繁的东西</c>

204
00:10:58,959 --> 00:11:01,728
<c.magenta>优化他们平时使用最频繁的东西</c>

205
00:11:02,596 --> 00:11:06,366
<c.magenta>那么包括带填充的卷积</c>

206
00:11:06,433 --> 00:11:09,970
<c.magenta>Stride 1和2卷积以及</c>

207
00:11:10,037 --> 00:11:14,308
<c.magenta>较小的内核 因为新神经网络有许多层</c>

208
00:11:14,374 --> 00:11:17,911
<c.magenta>有较小的卷积 是3x3和1x1</c>

209
00:11:17,978 --> 00:11:19,446
<c.magenta>那么我们优化了这些情况</c>

210
00:11:19,746 --> 00:11:23,383
<c.magenta>尤其是针对3x3</c>

211
00:11:23,450 --> 00:11:27,087
<c.magenta>要比基准实施的速度快四倍</c>

212
00:11:27,821 --> 00:11:31,458
<c.magenta>这就是BNNS 那么让我邀请</c>

213
00:11:31,525 --> 00:11:33,493
<c.magenta>simd相关的内容 谢谢</c>

214
00:11:37,664 --> 00:11:39,733
<c.magenta>非常感谢Eric 谢谢大家</c>

215
00:11:39,900 --> 00:11:41,301
<c.magenta>Eric刚说过了 我叫Steve</c>

216
00:11:41,368 --> 00:11:43,670
<c.magenta>今天我要讲一下simd模块</c>

217
00:11:43,737 --> 00:11:46,640
<c.magenta>我不认为我能讲到全部东西</c>

218
00:11:47,908 --> 00:11:50,911
<c.magenta>simd模块位于</c>

219
00:11:50,978 --> 00:11:53,580
<c.magenta>它是标头和用户应用的一个小集合</c>

220
00:11:53,747 --> 00:11:55,816
<c.magenta>它是一个你可在Swift中</c>

221
00:11:55,883 --> 00:11:59,620
<c.magenta>大约主要有三种用例</c>

222
00:12:00,220 --> 00:12:05,626
<c.magenta>第一个 如果你正在执行2x2、</c>

223
00:12:05,692 --> 00:12:07,761
<c.magenta>就是当进行图形或集合运算时</c>

224
00:12:07,828 --> 00:12:09,329
<c.magenta>总能看到的那种东西</c>

225
00:12:10,464 --> 00:12:12,966
<c.magenta>它还提供了较大的向量类型集合</c>

226
00:12:13,033 --> 00:12:14,968
<c.magenta>其中有整型向量和浮点型向量</c>

227
00:12:15,335 --> 00:12:19,206
<c.magenta>长度最大可达64位</c>

228
00:12:19,273 --> 00:12:24,278
<c.magenta>你可以在我们所支持的全部平台上的</c>

229
00:12:24,344 --> 00:12:28,081
<c.magenta>非常简单 你只需要写一段代码</c>

230
00:12:28,148 --> 00:12:29,616
<c.magenta>就可在全部这些架构上</c>

231
00:12:30,484 --> 00:12:32,486
<c.magenta>你要使用simd的最后一个原因是</c>

232
00:12:32,553 --> 00:12:36,056
<c.magenta>它是一个类型和运算的大集合</c>

233
00:12:36,123 --> 00:12:41,261
<c.magenta>运算是指在平台上进行3x3、</c>

234
00:12:41,328 --> 00:12:46,166
<c.magenta>比如SceneKit、SpriteKit、</c>

235
00:12:46,233 --> 00:12:49,236
<c.magenta>你可以有许多矩阵和向量</c>

236
00:12:49,503 --> 00:12:52,139
<c.magenta>并且有许多simd类型可以配合使用</c>

237
00:12:52,439 --> 00:12:54,441
<c.magenta>我应该说尤其是SpriteKit</c>

238
00:12:54,508 --> 00:12:56,844
<c.magenta>或者尤其是SceneKit</c>

239
00:12:56,910 --> 00:12:58,045
<c.magenta>那么请参看相关的演讲</c>

240
00:12:58,111 --> 00:13:00,447
<c.magenta>通过simd可以实现很多很棒的东西</c>

241
00:12:58,111 --> 00:13:00,447
<c.magenta>通过simd可以实现很多很棒的东西</c>

242
00:13:00,514 --> 00:13:03,050
<c.magenta>我要给你展示几个关于</c>

243
00:13:04,184 --> 00:13:07,721
<c.magenta>那么假如说你想用三维矩阵</c>

244
00:13:07,921 --> 00:13:10,991
<c.magenta>你可以通过BLAS实现</c>

245
00:13:11,058 --> 00:13:12,025
<c.magenta>看起来是这样的</c>

246
00:13:12,926 --> 00:13:17,497
<c.magenta>这没问题 但BLAS将全部参数</c>

247
00:13:17,564 --> 00:13:19,933
<c.magenta>那么我们必须得告诉它</c>

248
00:13:20,000 --> 00:13:22,870
<c.magenta>这些是向量的维数 这就是内存的分配</c>

249
00:13:22,936 --> 00:13:25,339
<c.magenta>还有许多其它信息需要传递</c>

250
00:13:25,706 --> 00:13:28,108
<c.magenta>这会增加写代码的困难系数</c>

251
00:13:28,175 --> 00:13:29,676
<c.magenta>并且也很难读懂</c>

252
00:13:29,877 --> 00:13:33,046
<c.magenta>如果你还不熟悉BLAS</c>

253
00:13:33,113 --> 00:13:35,916
<c.magenta>很难看出它正在生产一个矩阵向量</c>

254
00:13:35,983 --> 00:13:38,218
<c.magenta>那么我们想要一种更简单的方式</c>

255
00:13:39,253 --> 00:13:43,357
<c.magenta>我们还可以用GLKit来写这个</c>

256
00:13:43,423 --> 00:13:46,026
<c.magenta>我们有三维矩阵</c>

257
00:13:46,093 --> 00:13:47,694
<c.magenta>和三维向量的专用类型</c>

258
00:13:47,761 --> 00:13:51,398
<c.magenta>我们把它叫作</c>

259
00:13:51,465 --> 00:13:53,433
<c.magenta>很显然它是一个乘法</c>

260
00:13:53,500 --> 00:13:56,603
<c.magenta>但我们可以通过simd</c>

261
00:13:57,337 --> 00:13:58,839
<c.magenta>这是在simd中的样子</c>

262
00:13:58,906 --> 00:14:01,775
<c.magenta>好的？非常明确它是一个对角矩阵</c>

263
00:13:58,906 --> 00:14:01,775
<c.magenta>好的？非常明确它是一个对角矩阵</c>

264
00:14:02,075 --> 00:14:05,913
<c.magenta>矩阵乘以向量只需要</c>

265
00:14:05,979 --> 00:14:10,150
<c.magenta>非常好 非常简单 速度也非常快</c>

266
00:14:10,417 --> 00:14:13,487
<c.magenta>关于simd最重要的部分</c>

267
00:14:13,554 --> 00:14:17,457
<c.magenta>那么这会在我的CPU上</c>

268
00:14:17,558 --> 00:14:19,626
<c.magenta>速度很快 不需要调用</c>

269
00:14:19,693 --> 00:14:21,562
<c.magenta>不需要检查参数 什么也不用做</c>

270
00:14:21,628 --> 00:14:23,997
<c.magenta>我就是能从这个中</c>

271
00:14:24,531 --> 00:14:25,899
<c.magenta>这是一个Swift示例</c>

272
00:14:25,966 --> 00:14:29,203
<c.magenta>我要演示的下一个示例是在C中</c>

273
00:14:30,237 --> 00:14:31,972
<c.magenta>在这里 我要给你展示一个例子</c>

274
00:14:32,039 --> 00:14:34,274
<c.magenta>看如何用simd来写向量代码</c>

275
00:14:34,708 --> 00:14:38,579
<c.magenta>那么假如说我们想用指定中点</c>

276
00:14:38,645 --> 00:14:39,813
<c.magenta>和最大斜率计算对数曲线</c>

277
00:14:40,080 --> 00:14:42,816
<c.magenta>这个函数总是会出现在</c>

278
00:14:42,883 --> 00:14:44,685
<c.magenta>数学运算中 尤其是机器学习</c>

279
00:14:44,751 --> 00:14:46,820
<c.magenta>那么这是一个可以进行优化的有用函数</c>

280
00:14:46,887 --> 00:14:48,188
<c.magenta>我们非常关心这个</c>

281
00:14:48,789 --> 00:14:51,725
<c.magenta>我放在注释中的东西 在函数的主体中</c>

282
00:14:52,092 --> 00:14:54,828
<c.magenta>是一个典型的变量实施</c>

283
00:14:54,895 --> 00:14:56,830
<c.magenta>看起来非常像是一个数学运算</c>

284
00:14:57,364 --> 00:15:01,902
<c.magenta>但我们想同时在16浮点值上计算这个</c>

285
00:14:57,364 --> 00:15:01,902
<c.magenta>但我们想同时在16浮点值上计算这个</c>

286
00:15:01,969 --> 00:15:04,071
<c.magenta>因为那样我们的效率更高</c>

287
00:15:04,137 --> 00:15:06,807
<c.magenta>这就是该simd float16</c>

288
00:15:06,874 --> 00:15:09,076
<c.magenta>它就是个16位浮点的向量</c>

289
00:15:09,343 --> 00:15:12,346
<c.magenta>我们要看我们是否可以实施</c>

290
00:15:12,579 --> 00:15:14,615
<c.magenta>那么向量代码很复杂</c>

291
00:15:14,681 --> 00:15:17,384
<c.magenta>所以我把这部分分成了三段</c>

292
00:15:17,451 --> 00:15:20,220
<c.magenta>那么我们可以单独写每一段</c>

293
00:15:20,354 --> 00:15:22,890
<c.magenta>让我们从第一部分开始 线性部分</c>

294
00:15:23,290 --> 00:15:26,627
<c.magenta>那么我们刚从向量中减去了一个标量</c>

295
00:15:26,693 --> 00:15:28,395
<c.magenta>我们从那个向量的每一个路径中减去它</c>

296
00:15:28,462 --> 00:15:30,497
<c.magenta>然后我们要用它乘以一个标量</c>

297
00:15:30,564 --> 00:15:32,099
<c.magenta>在simd中是什么样的？</c>

298
00:15:33,734 --> 00:15:36,837
<c.magenta>我们就是先做减法 在做乘法</c>

299
00:15:37,571 --> 00:15:41,441
<c.magenta>可在C中用 可在Swift中用</c>

300
00:15:41,508 --> 00:15:43,777
<c.magenta>非常棒 看起来非常像是着色器编程</c>

301
00:15:43,844 --> 00:15:45,045
<c.magenta>若你曾做过着色器编程</c>

302
00:15:45,646 --> 00:15:49,383
<c.magenta>那么这里的这最后一段</c>

303
00:15:49,449 --> 00:15:52,920
<c.magenta>再一次 同样的 我们写出了一段</c>

304
00:15:52,986 --> 00:15:56,356
<c.magenta>它看起来就像是调整器代码</c>

305
00:15:56,757 --> 00:15:58,258
<c.magenta>那么这中间这部分怎么样呢？</c>

306
00:15:58,325 --> 00:15:59,860
<c.magenta>这个稍微有点复杂</c>

307
00:15:59,927 --> 00:16:02,262
<c.magenta>我们在这里要做的是</c>

308
00:15:59,927 --> 00:16:02,262
<c.magenta>我们在这里要做的是</c>

309
00:16:02,329 --> 00:16:04,731
<c.magenta>我们都想计算它的指数函数</c>

310
00:16:04,798 --> 00:16:07,768
<c.magenta>并把它放在结果因素的响应元素中</c>

311
00:16:08,902 --> 00:16:12,806
<c.magenta>我们可以用for循环来实现</c>

312
00:16:13,574 --> 00:16:17,744
<c.magenta>但我们今年有了一个很棒的新功能</c>

313
00:16:17,811 --> 00:16:20,948
<c.magenta>全部的数学函数都能在浮点向量</c>

314
00:16:21,014 --> 00:16:23,550
<c.magenta>所以是任意长度的向量</c>

315
00:16:23,617 --> 00:16:26,987
<c.magenta>你可调用XPath 你可调用正弦</c>

316
00:16:27,054 --> 00:16:28,755
<c.magenta>数学函数就是能在它们上边用了</c>

317
00:16:28,822 --> 00:16:32,326
<c.magenta>这是一个非常棒、非常方便的功能</c>

318
00:16:32,626 --> 00:16:38,398
<c.magenta>当我在ARM上写的时候</c>

319
00:16:38,465 --> 00:16:41,935
<c.magenta>当我编译Intel时</c>

320
00:16:42,002 --> 00:16:45,272
<c.magenta>那么我会在所有平台上得到</c>

321
00:16:45,672 --> 00:16:47,407
<c.magenta>今年我们还有另一个很大的新功能</c>

322
00:16:47,474 --> 00:16:50,677
<c.magenta>是许多人要求添加的一个新功能</c>

323
00:16:51,011 --> 00:16:53,514
<c.magenta>我要非常快速地介绍一下</c>

324
00:16:53,714 --> 00:16:57,484
<c.magenta>就是那个四元素扩展了复数</c>

325
00:16:57,551 --> 00:16:59,319
<c.magenta>与复数扩展实数的方式一样</c>

326
00:17:00,621 --> 00:17:03,156
<c.magenta>那么复数 你可能还记得在学校学过吧</c>

327
00:17:03,223 --> 00:17:05,925
<c.magenta>有实数和虚数</c>

328
00:17:07,160 --> 00:17:11,999
<c.magenta>四元数有实数 并且有三个虚数</c>

329
00:17:12,065 --> 00:17:13,634
<c.magenta>有时候你需要调用四元数的向量</c>

330
00:17:13,700 --> 00:17:17,104
<c.magenta>我妈妈总是说 如果有一个</c>

331
00:17:17,171 --> 00:17:19,772
<c.magenta>但有三个负一的平方根那一定很棒</c>

332
00:17:20,641 --> 00:17:22,742
<c.magenta>她是位聪慧的女人 你应该听她的</c>

333
00:17:25,179 --> 00:17:28,315
<c.magenta>有许多关于四元数的迷人的数学结构</c>

334
00:17:28,382 --> 00:17:31,318
<c.magenta>我们真正关心的并不是那个</c>

335
00:17:32,019 --> 00:17:34,721
<c.magenta>四元数有长度的概念 跟复数一样</c>

336
00:17:34,788 --> 00:17:37,691
<c.magenta>你把各部分的平方数加起来</c>

337
00:17:37,758 --> 00:17:39,359
<c.magenta>就是四元数的长度</c>

338
00:17:39,793 --> 00:17:43,597
<c.magenta>长度为1的四元数</c>

339
00:17:43,664 --> 00:17:48,602
<c.magenta>它们有这个非常棒的属性 可以用于</c>

340
00:17:48,669 --> 00:17:52,005
<c.magenta>在三维空间中表示旋转</c>

341
00:17:52,706 --> 00:17:56,577
<c.magenta>这就是我们所关心的东西</c>

342
00:17:57,811 --> 00:18:00,214
<c.magenta>那么我要给你看一下迅捷代码示例</c>

343
00:17:57,811 --> 00:18:00,214
<c.magenta>那么我要给你看一下迅捷代码示例</c>

344
00:18:00,480 --> 00:18:02,950
<c.magenta>比如说我们有一个向量</c>

345
00:18:03,917 --> 00:18:05,319
<c.magenta>让我们创建一个四元数</c>

346
00:18:05,385 --> 00:18:08,989
<c.magenta>这是一个代表y轴旋转的四元数</c>

347
00:18:10,457 --> 00:18:14,228
<c.magenta>四元数作用于向量</c>

348
00:18:14,828 --> 00:18:18,398
<c.magenta>它并不是乘法 当向量乘以矩阵时</c>

349
00:18:18,465 --> 00:18:22,803
<c.magenta>当通过矩阵旋转向量时</c>

350
00:18:22,870 --> 00:18:24,538
<c.magenta>对于四元数来说 这叫作一个作用</c>

351
00:18:24,605 --> 00:18:27,174
<c.magenta>那么不要太关心细节</c>

352
00:18:27,241 --> 00:18:29,142
<c.magenta>这就是这个act函数产生的原因</c>

353
00:18:30,110 --> 00:18:32,246
<c.magenta>那么这是一个表示旋转的很棒的方式</c>

354
00:18:32,679 --> 00:18:35,115
<c.magenta>还有许多其它方式来表示旋转</c>

355
00:18:35,182 --> 00:18:37,985
<c.magenta>你为什么要用这个呢？</c>

356
00:18:38,785 --> 00:18:41,622
<c.magenta>你知道的 你可能会使用矩阵</c>

357
00:18:41,688 --> 00:18:44,358
<c.magenta>或偏航角/俯仰角/翻滚角</c>

358
00:18:44,424 --> 00:18:45,659
<c.magenta>有很多选择</c>

359
00:18:45,859 --> 00:18:48,028
<c.magenta>四元数是一个特别好的选择</c>

360
00:18:48,095 --> 00:18:51,031
<c.magenta>对于我将要讲的某些操作来说</c>

361
00:18:52,566 --> 00:18:55,836
<c.magenta>关于四元数的第一个好处就是</c>

362
00:18:55,903 --> 00:18:59,039
<c.magenta>这很好 非常棒</c>

363
00:18:59,106 --> 00:19:01,175
<c.magenta>但这并不是</c>

364
00:18:59,106 --> 00:19:01,175
<c.magenta>但这并不是</c>

365
00:19:01,975 --> 00:19:06,380
<c.magenta>关于四元数更大的好处是</c>

366
00:19:06,446 --> 00:19:09,316
<c.magenta>你可以在这里看到只有</c>

367
00:19:09,383 --> 00:19:12,119
<c.magenta>使用矩阵计算旋转时的速度的三分之一</c>

368
00:19:13,320 --> 00:19:15,656
<c.magenta>当你想执行一系列操作时</c>

369
00:19:15,722 --> 00:19:18,425
<c.magenta>当你想联合旋转或想插入旋转时</c>

370
00:19:18,492 --> 00:19:19,693
<c.magenta>你想做那样类似的操作</c>

371
00:19:19,760 --> 00:19:23,030
<c.magenta>那么它们是执行</c>

372
00:19:23,463 --> 00:19:25,566
<c.magenta>那么当我们想把两个旋转结合在一起时</c>

373
00:19:25,632 --> 00:19:29,203
<c.magenta>你可看到四元数比向量和矩阵快30%</c>

374
00:19:29,469 --> 00:19:33,207
<c.magenta>但它们还允许我们执行一些</c>

375
00:19:34,474 --> 00:19:36,143
<c.magenta>那么假如说我们想插入</c>

376
00:19:36,210 --> 00:19:38,946
<c.magenta>在两个不同的旋转的坐标系中执行插入</c>

377
00:19:39,246 --> 00:19:43,116
<c.magenta>如果用矩阵 感觉有点儿微妙</c>

378
00:19:43,417 --> 00:19:45,219
<c.magenta>感到很自然的原因是与</c>

379
00:19:45,285 --> 00:19:48,255
<c.magenta>我在屏幕右边画的这个球体有关</c>

380
00:19:48,322 --> 00:19:51,658
<c.magenta>你可能会说“嗯</c>

381
00:19:51,792 --> 00:19:53,193
<c.magenta>有一个很好的理由</c>

382
00:19:53,594 --> 00:19:57,898
<c.magenta>你可以把四元数看做是</c>

383
00:19:58,765 --> 00:20:02,536
<c.magenta>听起来有点复杂 需要数学专业知识</c>

384
00:19:58,765 --> 00:20:02,536
<c.magenta>听起来有点复杂 需要数学专业知识</c>

385
00:20:02,603 --> 00:20:06,773
<c.magenta>但在三维空间中是旋转的自然空间</c>

386
00:20:06,840 --> 00:20:09,610
<c.magenta>那么 当我执行操作时</c>

387
00:20:09,676 --> 00:20:12,446
<c.magenta>那会与你的天生直觉完全匹配</c>

388
00:20:12,513 --> 00:20:14,515
<c.magenta>关于旋转会发生什么</c>

389
00:20:15,616 --> 00:20:17,417
<c.magenta>比如说</c>

390
00:20:17,484 --> 00:20:20,420
<c.magenta>我只需要在球体上沿着大圆弧插入</c>

391
00:20:20,487 --> 00:20:21,955
<c.magenta>这就是该simd slerp函数</c>

392
00:20:22,022 --> 00:20:24,491
<c.magenta>它代表了球面线性差值</c>

393
00:20:25,125 --> 00:20:28,562
<c.magenta>非常简单易用</c>

394
00:20:29,062 --> 00:20:32,766
<c.magenta>如果我们有一系列的点</c>

395
00:20:33,233 --> 00:20:36,904
<c.magenta>我们可以重复调用slerp</c>

396
00:20:36,970 --> 00:20:39,473
<c.magenta>但那会有一个很明显的跳跃</c>

397
00:20:39,540 --> 00:20:41,842
<c.magenta>在旋转中 当你转角时</c>

398
00:20:42,809 --> 00:20:46,213
<c.magenta>相反 我们可以使用</c>

399
00:20:46,280 --> 00:20:48,348
<c.magenta>得到一个完全流畅的插入</c>

400
00:20:48,415 --> 00:20:50,951
<c.magenta>通过一系列旋转的坐标系</c>

401
00:20:51,518 --> 00:20:55,656
<c.magenta>在simd标头中</c>

402
00:20:55,722 --> 00:20:58,625
<c.magenta>你可以用于执行这种类型的操作</c>

403
00:20:58,926 --> 00:21:02,229
<c.magenta>如果你想处理旋转</c>

404
00:20:58,926 --> 00:21:02,229
<c.magenta>如果你想处理旋转</c>

405
00:21:02,296 --> 00:21:03,664
<c.magenta>我鼓励你们自己去了解</c>

406
00:21:04,064 --> 00:21:06,767
<c.magenta>正如我所说的</c>

407
00:21:06,834 --> 00:21:08,902
<c.magenta>所以我鼓励你们发现漏洞并告诉我们说</c>

408
00:21:08,969 --> 00:21:10,871
<c.magenta>“嘿 你们还能添加这个东西吗？”</c>

409
00:21:10,938 --> 00:21:14,107
<c.magenta>我们一定会给你们一个满意的答案</c>

410
00:21:14,575 --> 00:21:18,045
<c.magenta>那么 我要把你们交给</c>

411
00:21:18,111 --> 00:21:21,381
<c.magenta>他要跟大家谈一些非常非常大的矩阵</c>

412
00:21:27,688 --> 00:21:31,124
<c.magenta>嗨 你们从Steve那儿</c>

413
00:21:31,191 --> 00:21:34,261
<c.magenta>这对于非常非常小的矩阵来说很棒</c>

414
00:21:34,561 --> 00:21:38,232
<c.magenta>我要讲一下非常大的矩阵</c>

415
00:21:38,765 --> 00:21:41,235
<c.magenta>但首先我要谈谈</c>

416
00:21:41,301 --> 00:21:44,204
<c.magenta>这些是处理密集矩阵的库</c>

417
00:21:44,271 --> 00:21:49,610
<c.magenta>那么你可以在MacBook上</c>

418
00:21:50,744 --> 00:21:51,812
<c.magenta>我们有什么？</c>

419
00:21:52,746 --> 00:21:56,383
<c.magenta>那么BLAS代表基础线性代数子程序</c>

420
00:21:56,450 --> 00:21:59,887
<c.magenta>在矩阵和向量上执行基本运算</c>

421
00:22:00,621 --> 00:22:04,057
<c.magenta>我们有BLAS 1 执行向量运算</c>

422
00:22:04,124 --> 00:22:07,194
<c.magenta>BLAS 2执行矩阵向量</c>

423
00:22:07,261 --> 00:22:09,363
<c.magenta>BLAS 2执行矩阵运算</c>

424
00:22:09,663 --> 00:22:13,567
<c.magenta>你已经从Eric那儿了解到了</c>

425
00:22:13,634 --> 00:22:16,403
<c.magenta>我们在矩阵相乘上的速度</c>

426
00:22:17,204 --> 00:22:19,506
<c.magenta>如果你想执行更复杂的运算</c>

427
00:22:19,773 --> 00:22:21,375
<c.magenta>那么我们有LAPACK</c>

428
00:22:21,909 --> 00:22:26,513
<c.magenta>这些会执行矩阵因式分解、</c>

429
00:22:26,580 --> 00:22:31,051
<c.magenta>特征向量、奇异值分解等等</c>

430
00:22:32,819 --> 00:22:35,756
<c.magenta>这就是我要告诉你的关于</c>

431
00:22:35,822 --> 00:22:37,791
<c.magenta>因为我们实际上想要谈谈稀疏矩阵</c>

432
00:22:39,293 --> 00:22:41,562
<c.magenta>什么是稀疏矩阵？</c>

433
00:22:44,398 --> 00:22:47,401
<c.magenta>那么James Wilkinson</c>

434
00:22:47,467 --> 00:22:49,136
<c.magenta>是计算数学线性代数的先驱之一</c>

435
00:22:49,203 --> 00:22:50,337
<c.magenta>这是他的定义</c>

436
00:22:51,271 --> 00:22:55,609
<c.magenta>“稀疏矩阵是</c>

437
00:22:57,511 --> 00:23:00,180
<c.magenta>让我们看看稀疏矩阵实际上是什么样子</c>

438
00:22:57,511 --> 00:23:00,180
<c.magenta>让我们看看稀疏矩阵实际上是什么样子</c>

439
00:23:01,648 --> 00:23:03,817
<c.magenta>那么这里有两个稀疏矩阵</c>

440
00:23:03,884 --> 00:23:06,787
<c.magenta>一个实际上是另一个的乔里斯基分解</c>

441
00:23:07,354 --> 00:23:10,390
<c.magenta>这里的每个像素都代表多个非零</c>

442
00:23:11,291 --> 00:23:17,464
<c.magenta>它们是白色的</c>

443
00:23:17,831 --> 00:23:20,934
<c.magenta>而蓝色的代表至少存在一个非零</c>

444
00:23:21,001 --> 00:23:24,171
<c.magenta>那么你可以看到</c>

445
00:23:25,138 --> 00:23:28,575
<c.magenta>事实上 如果你要把它存储为密集矩阵</c>

446
00:23:28,642 --> 00:23:32,679
<c.magenta>它大约是30,000x30,000</c>

447
00:23:33,380 --> 00:23:39,386
<c.magenta>如果我们把它存储为稀疏矩阵</c>

448
00:23:39,453 --> 00:23:41,188
<c.magenta>只有26MB</c>

449
00:23:41,288 --> 00:23:44,424
<c.magenta>如果我们想用这个矩阵</c>

450
00:23:44,491 --> 00:23:49,730
<c.magenta>乘以一个向量 我们所需要的浮点运算</c>

451
00:23:50,564 --> 00:23:52,432
<c.magenta>但如果我们想执行一个更复杂的运算</c>

452
00:23:52,499 --> 00:23:54,868
<c.magenta>比如因式分解这个矩阵</c>

453
00:23:56,503 --> 00:24:00,607
<c.magenta>那更棒了 至少是在浮点运算中更棒了</c>

454
00:23:56,503 --> 00:24:00,607
<c.magenta>那更棒了 至少是在浮点运算中更棒了</c>

455
00:24:00,841 --> 00:24:05,078
<c.magenta>要因式分解这个矩阵</c>

456
00:24:05,145 --> 00:24:06,513
<c.magenta>我们所需要的浮点运算减少了2000倍</c>

457
00:24:07,447 --> 00:24:09,683
<c.magenta>而密集矩阵仍然是一样的大小</c>

458
00:24:09,750 --> 00:24:11,418
<c.magenta>因子也替代了一点儿</c>

459
00:24:11,685 --> 00:24:13,687
<c.magenta>它比原来稍微密集一点儿</c>

460
00:24:13,754 --> 00:24:16,790
<c.magenta>那马我们减少了30倍的内存</c>

461
00:24:17,758 --> 00:24:20,794
<c.magenta>现在 要把那个点指回去</c>

462
00:24:21,361 --> 00:24:26,200
<c.magenta>我们决定在Watch上运行</c>

463
00:24:26,266 --> 00:24:30,938
<c.magenta>Macbook Air上LAPACK中的</c>

464
00:24:31,505 --> 00:24:32,973
<c.magenta>情况就是这样的</c>

465
00:24:35,008 --> 00:24:38,812
<c.magenta>现在 这个的实际运行速度快5倍</c>

466
00:24:39,012 --> 00:24:43,684
<c.magenta>你可以看到Watch</c>

467
00:24:44,084 --> 00:24:45,953
<c.magenta>你要记住 在看这个时</c>

468
00:24:46,019 --> 00:24:50,090
<c.magenta>MacBook Air上的浮点</c>

469
00:24:50,157 --> 00:24:51,892
<c.magenta>比Watch上可用的浮点要多50倍</c>

470
00:24:56,797 --> 00:25:00,868
<c.magenta>现在对于稀疏矩阵来说</c>

471
00:24:56,797 --> 00:25:00,868
<c.magenta>现在对于稀疏矩阵来说</c>

472
00:25:00,934 --> 00:25:04,671
<c.magenta>第一 我们发现非零项的位置</c>

473
00:25:04,738 --> 00:25:05,939
<c.magenta>这是象征阶段</c>

474
00:25:06,006 --> 00:25:09,877
<c.magenta>然后我们有一个数值阶段</c>

475
00:25:10,544 --> 00:25:12,946
<c.magenta>这些时间只是数值阶段的时间</c>

476
00:25:13,714 --> 00:25:16,917
<c.magenta>但象征阶段在Watch上</c>

477
00:25:17,217 --> 00:25:21,488
<c.magenta>那么与其说是16秒</c>

478
00:25:21,555 --> 00:25:25,425
<c.magenta>但如果你在同样的模式上</c>

479
00:25:26,460 --> 00:25:30,531
<c.magenta>你可以在第二个和第三个因式分解上</c>

480
00:25:31,231 --> 00:25:33,867
<c.magenta>即便你执行象征阶段</c>

481
00:25:33,934 --> 00:25:36,103
<c.magenta>因为MacBook执行的是密集计算</c>

482
00:25:37,571 --> 00:25:41,441
<c.magenta>我希望我说服了你们</c>

483
00:25:41,508 --> 00:25:44,611
<c.magenta>那么让我来谈谈如何定义稀疏矩阵</c>

484
00:25:45,412 --> 00:25:48,415
<c.magenta>那么这是一个非常非常小的稀疏矩阵</c>

485
00:25:48,682 --> 00:25:52,252
<c.magenta>你会注意到它的项有缺失</c>

486
00:25:52,953 --> 00:25:55,789
<c.magenta>我们要使用一种标准格式把它存起来</c>

487
00:25:55,856 --> 00:26:00,160
<c.magenta>叫作压缩稀疏列 使用这三个数组</c>

488
00:25:55,856 --> 00:26:00,160
<c.magenta>叫作压缩稀疏列 使用这三个数组</c>

489
00:26:01,295 --> 00:26:04,064
<c.magenta>我们要从rowIndices率开始</c>

490
00:26:04,131 --> 00:26:08,168
<c.magenta>那么让我们把行数添加到矩阵中</c>

491
00:26:09,169 --> 00:26:11,805
<c.magenta>我们只需把那些复制到</c>

492
00:26:12,940 --> 00:26:15,242
<c.magenta>那么值的处理也类似</c>

493
00:26:16,376 --> 00:26:18,745
<c.magenta>你可以看到我们这里是一一对应的</c>

494
00:26:19,213 --> 00:26:22,382
<c.magenta>第一个项是第零行 值为二</c>

495
00:26:23,750 --> 00:26:27,888
<c.magenta>那么让我们把这些项的位置放到</c>

496
00:26:27,955 --> 00:26:30,090
<c.magenta>那个rowIndices和值数组中</c>

497
00:26:30,591 --> 00:26:33,060
<c.magenta>压缩稀疏列的一个技巧是</c>

498
00:26:33,126 --> 00:26:37,097
<c.magenta>全部这些值必须按照</c>

499
00:26:37,598 --> 00:26:41,702
<c.magenta>第零列的全部项实际上</c>

500
00:26:42,769 --> 00:26:44,738
<c.magenta>那么我们还有一个关于这种格式的技巧</c>

501
00:26:44,805 --> 00:26:46,707
<c.magenta>即我们只需要存储</c>

502
00:26:46,773 --> 00:26:50,844
<c.magenta>每列中第一项的位置</c>

503
00:26:51,745 --> 00:26:57,251
<c.magenta>和一条额外的信息</c>

504
00:26:57,317 --> 00:27:00,020
<c.magenta>意思就是我们知道最后一列是多长</c>

505
00:26:57,317 --> 00:27:00,020
<c.magenta>意思就是我们知道最后一列是多长</c>

506
00:27:01,288 --> 00:27:05,259
<c.magenta>如果你曾经使用过稀疏求解器</c>

507
00:27:05,325 --> 00:27:07,628
<c.magenta>这种格式或坐标格式的数据</c>

508
00:27:07,694 --> 00:27:09,029
<c.magenta>并且我们提供转换器</c>

509
00:27:11,164 --> 00:27:14,902
<c.magenta>要在Accelerate中使用</c>

510
00:27:14,968 --> 00:27:17,404
<c.magenta>只是告诉它有多少行 有多少列</c>

511
00:27:17,671 --> 00:27:20,440
<c.magenta>我们要表明这是一个普通的稀疏矩阵</c>

512
00:27:20,507 --> 00:27:25,379
<c.magenta>稍后我要展示一个异常稀疏矩阵的例子</c>

513
00:27:26,513 --> 00:27:29,249
<c.magenta>现在我有了我的稀疏矩阵</c>

514
00:27:31,351 --> 00:27:34,087
<c.magenta>那么你可以做很多你所期待的任何运算</c>

515
00:27:34,154 --> 00:27:37,858
<c.magenta>你可以乘以一个密集向量或密集矩阵</c>

516
00:27:37,925 --> 00:27:40,928
<c.magenta>你可以同时增加两个</c>

517
00:27:40,994 --> 00:27:43,197
<c.magenta>你可以变换行或列</c>

518
00:27:43,263 --> 00:27:46,033
<c.magenta>或你可以寻找各种有用的矩阵范数</c>

519
00:27:46,700 --> 00:27:49,603
<c.magenta>这些功能都是</c>

520
00:27:49,670 --> 00:27:53,540
<c.magenta>是我们几年前引入的</c>

521
00:27:53,607 --> 00:27:54,908
<c.magenta>（求解）</c>

522
00:27:54,975 --> 00:27:57,544
<c.magenta>求解稀疏系统的能力</c>

523
00:27:58,679 --> 00:28:05,185
<c.magenta>就是假设矩阵方程A乘以X等于B</c>

524
00:27:58,679 --> 00:28:05,185
<c.magenta>就是假设矩阵方程A乘以X等于B</c>

525
00:28:05,252 --> 00:28:09,456
<c.magenta>和右边的B已知</c>

526
00:28:10,591 --> 00:28:13,493
<c.magenta>那么我们为你们提供了两种方法</c>

527
00:28:14,027 --> 00:28:18,532
<c.magenta>第一种方式是矩阵因式分解</c>

528
00:28:18,966 --> 00:28:21,702
<c.magenta>非常简单 非常精确 很容易上手</c>

529
00:28:22,336 --> 00:28:24,805
<c.magenta>但数学家就是数学家</c>

530
00:28:24,872 --> 00:28:27,474
<c.magenta>他们提出了更复杂的方式</c>

531
00:28:28,675 --> 00:28:29,877
<c.magenta>就是迭代法</c>

532
00:28:29,943 --> 00:28:31,979
<c.magenta>稍后我会详细讲一下迭代法</c>

533
00:28:33,313 --> 00:28:35,883
<c.magenta>那么我们的矩阵因式分解</c>

534
00:28:35,949 --> 00:28:38,385
<c.magenta>对于你们从来没听说过</c>

535
00:28:38,452 --> 00:28:42,556
<c.magenta>我们要对左边的这个绿色矩阵</c>

536
00:28:42,623 --> 00:28:45,425
<c.magenta>把它分解到右边的两个三角矩阵中</c>

537
00:28:46,126 --> 00:28:47,628
<c.magenta>这是因为我们非常了解</c>

538
00:28:47,694 --> 00:28:49,630
<c.magenta>如何求解一个有三角矩阵的系统</c>

539
00:28:50,564 --> 00:28:53,433
<c.magenta>若我们不是正方形</c>

540
00:28:54,034 --> 00:28:58,005
<c.magenta>我们得从这里选择一个矩形和正交因子</c>

541
00:28:58,071 --> 00:29:01,575
<c.magenta>这是你的QR因式分解</c>

542
00:28:58,071 --> 00:29:01,575
<c.magenta>这是你的QR因式分解</c>

543
00:29:02,476 --> 00:29:04,778
<c.magenta>那么让我们看看到底该怎么做</c>

544
00:29:06,213 --> 00:29:09,049
<c.magenta>这是一个系数矩阵等式</c>

545
00:29:09,783 --> 00:29:12,186
<c.magenta>一开始让我们先定义那个矩阵</c>

546
00:29:13,554 --> 00:29:15,923
<c.magenta>那么这与我刚展示给你们的非常相似</c>

547
00:29:15,989 --> 00:29:19,459
<c.magenta>除了这个矩阵有点特殊外 它是对称的</c>

548
00:29:19,860 --> 00:29:23,864
<c.magenta>意思就是靠下的三角形就是</c>

549
00:29:23,931 --> 00:29:26,967
<c.magenta>另一个三角形的镜反射</c>

550
00:29:27,034 --> 00:29:29,369
<c.magenta>让我们只存储靠下的三角形的项</c>

551
00:29:30,404 --> 00:29:34,575
<c.magenta>把它包在元数据中</c>

552
00:29:34,641 --> 00:29:37,077
<c.magenta>它不是普通矩阵 它是一个对称矩阵</c>

553
00:29:37,377 --> 00:29:40,781
<c.magenta>我们要告诉它我们要传递靠下的三角形</c>

554
00:29:40,848 --> 00:29:42,683
<c.magenta>如果我们想</c>

555
00:29:42,749 --> 00:29:44,518
<c.magenta>但在这里我们选择靠下的三角形</c>

556
00:29:45,152 --> 00:29:49,456
<c.magenta>那么我们得到了我们的矩阵</c>

557
00:29:49,990 --> 00:29:54,461
<c.magenta>那么这是一个密集向量</c>

558
00:29:55,028 --> 00:29:57,898
<c.magenta>用一些元数据把它包起来</c>

559
00:29:57,965 --> 00:30:00,367
<c.magenta>以及它是如何简单</c>

560
00:29:57,965 --> 00:30:00,367
<c.magenta>以及它是如何简单</c>

561
00:30:01,768 --> 00:30:06,006
<c.magenta>这就把我们带到了最有意思的部分</c>

562
00:30:08,976 --> 00:30:12,179
<c.magenta>那么让我们定义一些存储</c>

563
00:30:12,246 --> 00:30:15,282
<c.magenta>这与我们刚看到的那个</c>

564
00:30:15,349 --> 00:30:17,818
<c.magenta>除了我们不需要提供任何值以外</c>

565
00:30:19,353 --> 00:30:21,388
<c.magenta>然后我们要调用</c>

566
00:30:21,688 --> 00:30:23,957
<c.magenta>我知道这个矩阵是正定的；</c>

567
00:30:24,024 --> 00:30:26,593
<c.magenta>因此 我可以告诉它使用乔里斯基分解</c>

568
00:30:26,994 --> 00:30:29,563
<c.magenta>稍后我会给你们看一个流程图 告诉你</c>

569
00:30:29,630 --> 00:30:33,734
<c.magenta>如何选择一种因式分解</c>

570
00:30:33,800 --> 00:30:36,637
<c.magenta>那就为我们提供了</c>

571
00:30:36,703 --> 00:30:38,906
<c.magenta>然后我们进入</c>

572
00:30:38,972 --> 00:30:41,575
<c.magenta>传入右手边的那个</c>

573
00:30:41,642 --> 00:30:45,312
<c.magenta>然后我们就得到了答案</c>

574
00:30:45,379 --> 00:30:47,414
<c.magenta>我们可以看到这是正确的</c>

575
00:30:48,916 --> 00:30:51,218
<c.magenta>那么如果A不是正方形会怎么样呢？</c>

576
00:30:53,554 --> 00:30:56,757
<c.magenta>嗯 这时候我们就不得不使用</c>

577
00:30:56,823 --> 00:30:59,426
<c.magenta>我之前提到过</c>

578
00:30:59,493 --> 00:31:00,894
<c.magenta>并不完全是那么简单</c>

579
00:30:59,493 --> 00:31:00,894
<c.magenta>并不完全是那么简单</c>

580
00:31:01,161 --> 00:31:05,666
<c.magenta>我们可以多因素决定</c>

581
00:31:06,567 --> 00:31:08,335
<c.magenta>除非你选择了一个非常特殊的系统</c>

582
00:31:08,402 --> 00:31:11,538
<c.magenta>那很可能意味着没有完全正确的答案</c>

583
00:31:12,105 --> 00:31:14,074
<c.magenta>事实上你就处于这种情况下</c>

584
00:31:15,209 --> 00:31:18,212
<c.magenta>用一条直线把这四个点连起来</c>

585
00:31:20,314 --> 00:31:21,748
<c.magenta>很明显这是不可能的</c>

586
00:31:21,815 --> 00:31:23,584
<c.magenta>但若你还记得上学时</c>

587
00:31:23,650 --> 00:31:26,119
<c.magenta>你很可能会执行一些最小二乘方拟合</c>

588
00:31:27,888 --> 00:31:31,558
<c.magenta>我们选择了一条箭头平方总和最小的线</c>

589
00:31:31,625 --> 00:31:33,360
<c.magenta>这即我们在该情况下</c>

590
00:31:33,961 --> 00:31:37,965
<c.magenta>还记得吧 我们要求解Ax等于B</c>

591
00:31:38,398 --> 00:31:41,168
<c.magenta>让我们把两个常量拿出来</c>

592
00:31:41,235 --> 00:31:44,805
<c.magenta>并求它的最小值</c>

593
00:31:46,907 --> 00:31:50,711
<c.magenta>如果我们还不确定</c>

594
00:31:50,777 --> 00:31:52,713
<c.magenta>我们的情况就稍微不一样了</c>

595
00:31:53,714 --> 00:31:57,451
<c.magenta>那等同于画一条线穿过这个点</c>

596
00:31:58,252 --> 00:32:02,222
<c.magenta>很明显 有无限多条线可以穿过那个点</c>

597
00:31:58,252 --> 00:32:02,222
<c.magenta>很明显 有无限多条线可以穿过那个点</c>

598
00:32:02,422 --> 00:32:05,726
<c.magenta>那么我们要如何选择一条线</c>

599
00:32:06,360 --> 00:32:09,663
<c.magenta>我们给你提供一个最小范数</c>

600
00:32:12,099 --> 00:32:14,268
<c.magenta>让我们看看代码</c>

601
00:32:15,502 --> 00:32:19,439
<c.magenta>它非常非常类似于</c>

602
00:32:19,640 --> 00:32:22,843
<c.magenta>事实上唯一的不同点是</c>

603
00:32:22,910 --> 00:32:25,712
<c.magenta>一个QR分解 而不是乔里斯基分解</c>

604
00:32:25,779 --> 00:32:28,649
<c.magenta>这将自动选择是否执行最小平方</c>

605
00:32:28,715 --> 00:32:32,352
<c.magenta>或最小范数 根据你矩阵的维数</c>

606
00:32:33,320 --> 00:32:35,222
<c.magenta>并且我告诉过你我们有一个流程图</c>

607
00:32:35,289 --> 00:32:38,458
<c.magenta>可以让你了解如何决定</c>

608
00:32:38,525 --> 00:32:41,695
<c.magenta>那么你要提出的第一个问题是：</c>

609
00:32:44,498 --> 00:32:46,266
<c.magenta>“你的矩阵对称吗？”</c>

610
00:32:47,434 --> 00:32:50,971
<c.magenta>如果不对称 你就要使用QR分解</c>

611
00:32:51,438 --> 00:32:54,308
<c.magenta>如果对称 那么还有另一个问题：</c>

612
00:32:54,741 --> 00:32:56,543
<c.magenta>“你的矩阵是正定的吗？”</c>

613
00:32:56,610 --> 00:33:01,882
<c.magenta>现在如果你不知道答案</c>

614
00:32:56,610 --> 00:33:01,882
<c.magenta>现在如果你不知道答案</c>

615
00:33:01,949 --> 00:33:06,620
<c.magenta>对称不定分解 LDL转置</c>

616
00:33:07,154 --> 00:33:09,223
<c.magenta>但如果你稍微知道一点其它信息</c>

617
00:33:09,289 --> 00:33:11,225
<c.magenta>比如你有一个正定矩阵</c>

618
00:33:11,291 --> 00:33:15,229
<c.magenta>你可以使用乔里斯基分解</c>

619
00:33:15,829 --> 00:33:18,765
<c.magenta>这就是我们要谈的关于</c>

620
00:33:18,832 --> 00:33:23,270
<c.magenta>现在 我说过还有另一种技术 迭代法</c>

621
00:33:25,305 --> 00:33:27,107
<c.magenta>那么什么是迭代法？</c>

622
00:33:27,875 --> 00:33:29,510
<c.magenta>我们选择一个起点</c>

623
00:33:29,576 --> 00:33:32,546
<c.magenta>是我们猜测的最佳答案</c>

624
00:33:33,146 --> 00:33:35,282
<c.magenta>这可以是零 如果你没有任何想法的话</c>

625
00:33:35,349 --> 00:33:37,684
<c.magenta>对于[听不清]答案会是什么的想法</c>

626
00:33:38,018 --> 00:33:43,156
<c.magenta>我们想把这个点放在</c>

627
00:33:43,690 --> 00:33:47,261
<c.magenta>我们的实现方式是通过</c>

628
00:33:47,327 --> 00:33:49,496
<c.magenta>这就会收敛到那个答案</c>

629
00:33:50,063 --> 00:33:52,699
<c.magenta>现在对于使用这些方法</c>

630
00:33:53,734 --> 00:33:58,672
<c.magenta>一般来说 如果你有一个</c>

631
00:33:58,739 --> 00:34:02,409
<c.magenta>这种方法的速度</c>

632
00:33:58,739 --> 00:34:02,409
<c.magenta>这种方法的速度</c>

633
00:34:02,976 --> 00:34:05,779
<c.magenta>此外 要实际获取那种性能</c>

634
00:34:05,846 --> 00:34:08,148
<c.magenta>你需要了解关于</c>

635
00:34:08,215 --> 00:34:10,050
<c.magenta>你需要一个叫作预处理器的东西</c>

636
00:34:10,117 --> 00:34:12,119
<c.magenta>它是一个非常近似的答案</c>

637
00:34:13,152 --> 00:34:15,621
<c.magenta>如果你查看你所在领域的文献</c>

638
00:34:15,688 --> 00:34:20,027
<c.magenta>你很可能会发现有许多</c>

639
00:34:21,128 --> 00:34:23,096
<c.magenta>这到底要怎么用呢？</c>

640
00:34:23,597 --> 00:34:26,300
<c.magenta>那么这是我们之前看的那个矩阵方程</c>

641
00:34:26,366 --> 00:34:29,002
<c.magenta>这一次 我要使用迭代法来求解它</c>

642
00:34:29,436 --> 00:34:32,105
<c.magenta>事实上 我要使用共轭梯度</c>

643
00:34:33,139 --> 00:34:34,641
<c.magenta>这是正定的</c>

644
00:34:35,242 --> 00:34:39,612
<c.magenta>我们只需要指定</c>

645
00:34:39,679 --> 00:34:42,049
<c.magenta>你会注意到那儿有一个括号</c>

646
00:34:42,549 --> 00:34:44,818
<c.magenta>那其实是因为这是一个工厂函数</c>

647
00:34:44,885 --> 00:34:47,821
<c.magenta>它生产方法 你可以在这些括号中指定</c>

648
00:34:47,888 --> 00:34:50,724
<c.magenta>方法专用的参数</c>

649
00:34:51,123 --> 00:34:51,992
<c.magenta>我要做的另一件事就是</c>

650
00:34:52,059 --> 00:34:54,293
<c.magenta>使用一个对角线预处理器</c>

651
00:34:54,360 --> 00:34:55,996
<c.magenta>这个矩阵是个对角优势矩阵</c>

652
00:34:56,063 --> 00:34:58,565
<c.magenta>意思是对角线上的项远远大于</c>

653
00:34:58,632 --> 00:35:00,534
<c.magenta>那些不在对角线上的项；</c>

654
00:34:58,632 --> 00:35:00,534
<c.magenta>那些不在对角线上的项；</c>

655
00:35:00,601 --> 00:35:02,769
<c.magenta>因此 我就知道这个对角线预处理器</c>

656
00:35:02,836 --> 00:35:04,338
<c.magenta>应该会很好用</c>

657
00:35:04,638 --> 00:35:08,141
<c.magenta>确实 如果我们看一下算法的输出</c>

658
00:35:08,208 --> 00:35:10,143
<c.magenta>你可以看到这个箭头AX减去B</c>

659
00:35:10,210 --> 00:35:14,781
<c.magenta>是递减的[听不清] 并且我们在</c>

660
00:35:15,082 --> 00:35:18,752
<c.magenta>这是因为它是个4x4矩阵</c>

661
00:35:18,819 --> 00:35:22,656
<c.magenta>最多收敛N次迭代</c>

662
00:35:23,423 --> 00:35:26,093
<c.magenta>那么这跟我们预期的一样</c>

663
00:35:26,159 --> 00:35:28,896
<c.magenta>你和可能不想执行那么多次迭代</c>

664
00:35:29,229 --> 00:35:31,465
<c.magenta>这也是为什么你会获得</c>

665
00:35:32,266 --> 00:35:34,401
<c.magenta>且你可以看到我们</c>

666
00:35:35,135 --> 00:35:38,872
<c.magenta>现在假设我们想求解那个</c>

667
00:35:39,373 --> 00:35:42,309
<c.magenta>我们提供了一个最小平方求解器</c>

668
00:35:42,376 --> 00:35:46,013
<c.magenta>然而 我们没有提供不定系统求解器</c>

669
00:35:46,079 --> 00:35:48,916
<c.magenta>在那种情况下</c>

670
00:35:48,982 --> 00:35:50,918
<c.magenta>在求解器正方系统中</c>

671
00:35:51,385 --> 00:35:57,424
<c.magenta>要使用这个 我们需使用LSMR方法</c>

672
00:35:57,491 --> 00:36:00,027
<c.magenta>这个预处理器</c>

673
00:35:57,491 --> 00:36:00,027
<c.magenta>这个预处理器</c>

674
00:36:00,093 --> 00:36:01,995
<c.magenta>你可以看到</c>

675
00:36:02,062 --> 00:36:05,165
<c.magenta>这次我们进行了三次迭代</c>

676
00:36:05,699 --> 00:36:12,272
<c.magenta>但关于这种实现方式</c>

677
00:36:13,340 --> 00:36:17,845
<c.magenta>首先是很明显</c>

678
00:36:18,912 --> 00:36:23,383
<c.magenta>只要我有一个</c>

679
00:36:23,450 --> 00:36:27,855
<c.magenta>A乘以X或A转置乘以X</c>

680
00:36:28,422 --> 00:36:32,726
<c.magenta>我可以替换一个</c>

681
00:36:33,460 --> 00:36:37,965
<c.magenta>第二个是你可以使用无限个预处理器</c>

682
00:36:38,699 --> 00:36:42,202
<c.magenta>你可以写自己的预处理器</c>

683
00:36:44,838 --> 00:36:46,173
<c.magenta>现在你很可能会说</c>

684
00:36:46,240 --> 00:36:48,342
<c.magenta>“该如何了解要使用哪种迭代方法？”</c>

685
00:36:48,408 --> 00:36:50,711
<c.magenta>我这里有另外一个流程图</c>

686
00:36:50,878 --> 00:36:53,881
<c.magenta>这一次我们的第一个问题不是</c>

687
00:36:53,947 --> 00:36:56,884
<c.magenta>而是是否为正方形 如果不是正方形</c>

688
00:36:56,950 --> 00:36:59,152
<c.magenta>你就要执行最小二乘方求解</c>

689
00:36:59,820 --> 00:37:02,723
<c.magenta>然而 如果是</c>

690
00:36:59,820 --> 00:37:02,723
<c.magenta>然而 如果是</c>

691
00:37:02,789 --> 00:37:04,358
<c.magenta>“你是正定的吗？”</c>

692
00:37:05,192 --> 00:37:07,227
<c.magenta>如果不是 我们就用GMRES</c>

693
00:37:07,294 --> 00:37:09,863
<c.magenta>它会处理很多任意正方形矩阵</c>

694
00:37:10,797 --> 00:37:13,967
<c.magenta>但如果你了解更多一点儿信息</c>

695
00:37:14,034 --> 00:37:16,136
<c.magenta>使用著名的共轭梯度法</c>

696
00:37:17,471 --> 00:37:21,408
<c.magenta>现在这就是我今天要跟大家</c>

697
00:37:21,975 --> 00:37:24,745
<c.magenta>那么我们有一点要指出来</c>

698
00:37:26,313 --> 00:37:30,284
<c.magenta>就是你现在可以在Watch上</c>

699
00:37:30,350 --> 00:37:35,455
<c.magenta>我们提供了那个SDK</c>

700
00:37:35,789 --> 00:37:40,394
<c.magenta>甚至会更棒 使用今天谈到的SDK</c>

701
00:37:40,460 --> 00:37:45,599
<c.magenta>之前的Watch OS上的东西</c>

702
00:37:45,666 --> 00:37:48,302
<c.magenta>在Watch上应用我们今天</c>

703
00:37:49,503 --> 00:37:51,772
<c.magenta>那么让我们总结一下</c>

704
00:37:51,839 --> 00:37:54,942
<c.magenta>通过使用Accelerate</c>

705
00:37:55,209 --> 00:37:59,279
<c.magenta>它会更节能</c>

706
00:37:59,479 --> 00:38:02,316
<c.magenta>到头来你也不需要维护那么多的代码了</c>

707
00:37:59,479 --> 00:38:02,316
<c.magenta>到头来你也不需要维护那么多的代码了</c>

708
00:38:02,382 --> 00:38:04,318
<c.magenta>这是我们今天跟大家分享的全部内容：</c>

709
00:38:04,384 --> 00:38:07,387
<c.magenta>稀疏求解器库、新压缩工具、</c>

710
00:38:07,988 --> 00:38:10,991
<c.magenta>BNNS的变更、simd的改进</c>

711
00:38:11,058 --> 00:38:13,293
<c.magenta>以及更多 还有针对框架</c>

712
00:38:13,360 --> 00:38:14,695
<c.magenta>增强的性能</c>

713
00:38:16,063 --> 00:38:18,232
<c.magenta>如果你想了解更多信息</c>

714
00:38:18,298 --> 00:38:21,835
<c.magenta>引用我们针对稀疏求解器</c>

715
00:38:21,902 --> 00:38:23,337
<c.magenta>你可以从这里找到</c>

716
00:38:25,239 --> 00:38:28,275
<c.magenta>你可能对这些演讲感兴趣</c>

717
00:38:28,342 --> 00:38:32,312
<c.magenta>有些已经结束了或即将开始</c>

718
00:38:33,313 --> 00:38:34,548
<c.magenta>谢谢大家的参与</c>
