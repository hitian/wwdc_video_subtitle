1
00:00:17,084 --> 0:00:21,221
（Metal光线追踪加速技术

2
00:00:23,590 --> 0:00:24,625
嗨 各位

3
00:00:25,092 --> 0:00:28,128
我是Sean James

4
00:00:28,695 --> 0:00:30,964
今天 我们将会讨论光线追踪技术

5
00:00:31,465 --> 0:00:33,333
你们可能已经在“国情咨文”中

6
00:00:33,400 --> 0:00:36,036
看过我们的光线追踪演示

7
00:00:36,770 --> 0:00:39,473
也许你们想要在自己的app中

8
00:00:40,007 --> 0:00:44,011
今天 我将会介绍

9
00:00:44,144 --> 0:00:47,514
以及如何使用Metal

10
00:00:48,549 --> 0:00:51,285
特别会介绍如何

11
00:00:52,586 --> 0:00:56,323
Metal性能着色器

12
00:00:56,456 --> 0:00:59,760
已经针对所有iOS

13
00:01:00,961 --> 0:01:03,463
MPS内置图像处理

14
00:01:03,664 --> 0:01:05,866
线性代数和机器学习支持功能

15
00:01:06,800 --> 0:01:10,337
在前面的演讲里

16
00:01:11,305 --> 0:01:14,241
今年 我们还增加了训练支持功能

17
00:01:14,908 --> 0:01:17,444
关于这个主题 明天会有一个演讲

18
00:01:18,345 --> 0:01:19,213
今天…

19
00:01:19,279 --> 0:01:22,916
我将会介绍今年我们

20
00:01:23,750 --> 0:01:25,953
那么我们首先要问

21
00:01:27,788 --> 0:01:30,891
光线追踪app的基本原理是

22
00:01:30,958 --> 0:01:33,594
追踪光线的路径

23
00:01:34,561 --> 0:01:37,931
光线可以建模光照、声音

24
00:01:38,498 --> 0:01:42,503
光线追踪在渲染、音频

25
00:01:42,569 --> 0:01:43,837
和物理仿真方面均有应用

26
00:01:44,872 --> 0:01:47,875
但是光线也可以表示更抽象的概念

27
00:01:47,941 --> 0:01:50,377
比如是否可以从一个点

28
00:01:51,278 --> 0:01:54,181
因此光线追踪还可以应用于冲撞检测

29
00:01:54,248 --> 0:01:56,817
人工智能和路径寻找

30
00:01:57,951 --> 0:02:00,654
但是今天我将会以渲染为例

31
00:01:57,951 --> 0:02:00,654
但是今天我将会以渲染为例

32
00:02:00,721 --> 0:02:03,190
讲述如何在app中使用光线追踪

33
00:02:05,125 --> 0:02:07,694
你们可以已经熟悉光栅化管道程序

34
00:02:08,328 --> 0:02:09,696
光栅化工作原理是

35
00:02:09,763 --> 0:02:12,900
一次将一个三角形投影到屏幕上

36
00:02:13,133 --> 0:02:15,035
并且投射相应像素点的阴影

37
00:02:15,669 --> 0:02:18,639
在GPU硬件中

38
00:02:18,839 --> 0:02:20,274
因此很多游戏和其他实时app

39
00:02:20,340 --> 0:02:22,643
都选择使用此方法

40
00:02:24,244 --> 0:02:25,412
但是光栅化模型

41
00:02:25,946 --> 0:02:29,049
难以模拟光线的特定物理行为

42
00:02:30,784 --> 0:02:32,386
其中一个例子是反射

43
00:02:33,053 --> 0:02:34,188
在光栅化方法中

44
00:02:34,254 --> 0:02:37,124
反射通常是使用近似方法实现的

45
00:02:37,191 --> 0:02:39,693
例如立方体贴图

46
00:02:40,627 --> 0:02:41,628
但使用光线追踪器

47
00:02:41,695 --> 0:02:44,464
我们可以直接计算

48
00:02:45,866 --> 0:02:47,401
另一个例子是阴影

49
00:02:48,168 --> 0:02:49,269
在光栅化方法中

50
00:02:49,336 --> 0:02:51,972
通常使用阴影贴图

51
00:02:52,472 --> 0:02:54,007
但是在实施会遇到一些问题

52
00:02:54,074 --> 0:02:56,944
比如偏差和分辨率问题

53
00:02:57,744 --> 0:02:58,612
此外

54
00:02:58,779 --> 0:03:02,549
软阴影贴图技术

55
00:02:58,779 --> 0:03:02,549
软阴影贴图技术

56
00:03:03,717 --> 0:03:04,818
利用光线追踪技术

57
00:03:04,985 --> 0:03:08,388
我们可以直接计算

58
00:03:08,822 --> 0:03:10,490
因此可以生成清晰的阴影

59
00:03:10,757 --> 0:03:13,994
包括在物体之间的距离增大时

60
00:03:14,061 --> 0:03:16,163
生成从硬到软的真实阴影过渡效果

61
00:03:18,532 --> 0:03:20,834
最后一个例子是球形淡出

62
00:03:22,202 --> 0:03:24,838
它模拟光线在场景表面上的

63
00:03:25,706 --> 0:03:29,476
使用光栅化方法

64
00:03:29,743 --> 0:03:32,613
但是使用光线追踪器

65
00:03:33,013 --> 0:03:35,516
事实上 许多游戏和实时app

66
00:03:35,582 --> 0:03:37,718
都包含球形淡出效果组件

67
00:03:37,985 --> 0:03:40,454
这些组件使用光线追踪器

68
00:03:40,621 --> 0:03:42,422
然后将结果存储到材质之中

69
00:03:42,556 --> 0:03:45,192
在运行时映射到几何形状上

70
00:03:47,327 --> 0:03:50,797
当然 我们还可以使用

71
00:03:50,864 --> 0:03:54,801
例如环境光遮蔽

72
00:03:55,169 --> 0:03:58,238
以及摄像机效果

73
00:03:59,573 --> 0:04:01,375
因此 光线追踪技术被用于

74
00:03:59,573 --> 0:04:01,375
因此 光线追踪技术被用于

75
00:04:01,441 --> 0:04:04,511
许多高真实性离线渲染app

76
00:04:05,879 --> 0:04:07,381
光线追踪技术的不足之处是

77
00:04:07,447 --> 0:04:09,583
相比于光栅化方法

78
00:04:09,650 --> 0:04:10,751
它需要明显更多的计算资源

79
00:04:10,984 --> 0:04:12,386
因为需要进行更多的计算

80
00:04:12,452 --> 0:04:13,787
来模拟这些效果

81
00:04:15,088 --> 0:04:16,356
让我们来详细了解

82
00:04:16,423 --> 0:04:18,492
光线追踪器的渲染原理

83
00:04:18,559 --> 0:04:21,060
然后了解如何

84
00:04:23,597 --> 0:04:25,532
我们使用名为路径追踪的算法

85
00:04:26,500 --> 0:04:29,403
在现实世界中

86
00:04:29,570 --> 0:04:32,873
它们在周围反射

87
00:04:33,907 --> 0:04:37,077
但是大多数光子

88
00:04:37,377 --> 0:04:39,580
因此模拟效率非常低

89
00:04:40,547 --> 0:04:41,515
幸运的是…

90
00:04:41,782 --> 0:04:44,718
根据光线的属性

91
00:04:44,785 --> 0:04:46,153
从摄像机开始

92
00:04:47,187 --> 0:04:51,892
我们将光线从摄像机

93
00:04:53,460 --> 0:04:55,863
然后计算交叉点的阴影

94
00:04:56,797 --> 0:04:58,198
在生成阴影时 需要明白

95
00:04:58,265 --> 0:05:00,767
多少光线到达阴影点

96
00:04:58,265 --> 0:05:00,767
多少光线到达阴影点

97
00:05:01,235 --> 0:05:04,705
以及哪一部分的光线

98
00:05:05,572 --> 0:05:08,809
实际上有两个光源

99
00:05:10,777 --> 0:05:12,679
第一个光源是直射光线

100
00:05:13,213 --> 0:05:14,982
此光线从光源

101
00:05:15,048 --> 0:05:17,017
直接到达阴影点

102
00:05:18,218 --> 0:05:21,388
我们可以轻松地计算出

103
00:05:21,455 --> 0:05:24,525
以及哪一部分光线

104
00:05:25,158 --> 0:05:26,159
我们需要做的是

105
00:05:26,226 --> 0:05:29,096
在将光线添加到图像之前

106
00:05:29,162 --> 0:05:31,164
检查阴影点是否位于阴影之中

107
00:05:32,566 --> 0:05:35,569
为此 我们可以从阴影点位置

108
00:05:35,636 --> 0:05:37,738
投射更多阴影光线

109
00:05:39,006 --> 0:05:41,775
如果阴影光线不能到达光源

110
00:05:41,842 --> 0:05:44,044
那么原始阴影点

111
00:05:44,278 --> 0:05:46,446
我们不应该为图像添加光照效果

112
00:05:48,916 --> 0:05:51,218
另一个光源是非直射光线

113
00:05:52,085 --> 0:05:54,288
这是场景中

114
00:05:54,354 --> 0:05:56,857
从其他表面反射的光线

115
00:05:57,991 --> 0:05:59,493
为了收集非直射光线

116
00:05:59,560 --> 0:06:02,329
我们可以从阴影点

117
00:05:59,560 --> 0:06:02,329
我们可以从阴影点

118
00:06:02,396 --> 0:06:03,597
投射二次光线

119
00:06:04,631 --> 0:06:08,402
然后我们在第二个交叉点

120
00:06:09,903 --> 0:06:12,940
首先计算多少光线

121
00:06:13,006 --> 0:06:14,708
直接到达第二个交叉点

122
00:06:15,042 --> 0:06:17,477
以及哪一部分光线

123
00:06:17,544 --> 0:06:19,446
朝向前一个交叉点

124
00:06:19,746 --> 0:06:21,849
最终进入摄像机

125
00:06:22,916 --> 0:06:24,918
我们需要从二次交叉点

126
00:06:24,985 --> 0:06:26,820
投射另一束阴影光线

127
00:06:28,989 --> 0:06:31,658
我们可以多次重复这个过程

128
00:06:31,892 --> 0:06:33,861
以模拟场景中的光线反射

129
00:06:36,964 --> 0:06:39,099
现在 为了获得

130
00:06:39,166 --> 0:06:40,601
和反射光线效果…

131
00:06:41,134 --> 0:06:43,937
对于路径上的每个点

132
00:06:44,004 --> 0:06:45,372
我们都需要投射许多阴影光线

133
00:06:46,507 --> 0:06:49,576
反射光线数量

134
00:06:49,643 --> 0:06:50,911
将会呈指数增长

135
00:06:51,912 --> 0:06:53,647
为了避免这种指数增长

136
00:06:54,414 --> 0:06:56,316
我们只会选一条阴影光线

137
00:06:56,383 --> 0:06:58,919
和每次反射时的

138
00:07:00,087 --> 0:07:02,122
这时图像中有很多噪讯

139
00:07:02,589 --> 0:07:05,526
但是我们可以通过多帧叠加

140
00:07:06,260 --> 0:07:09,129
每个帧将会生成

141
00:07:09,196 --> 0:07:12,499
因此我们能够实施摄像机效果

142
00:07:12,566 --> 0:07:14,401
例如景深和运动模糊

143
00:07:16,570 --> 0:07:18,572
让我们将这些过程

144
00:07:20,007 --> 0:07:21,909
首先 我们生成一次光线

145
00:07:22,910 --> 0:07:24,811
然后找到场景中的交叉点

146
00:07:26,313 --> 0:07:28,849
计算交叉点位置的阴影

147
00:07:28,982 --> 0:07:31,218
请记住 这是一个迭代过程

148
00:07:31,285 --> 0:07:34,188
将会产生更多的阴影和二次光线

149
00:07:34,254 --> 0:07:36,290
将会在场景中

150
00:07:36,890 --> 0:07:38,525
最后 将阴影颜色

151
00:07:38,592 --> 0:07:39,660
写入图像

152
00:07:40,961 --> 0:07:43,297
这是渲染app的流程

153
00:07:43,630 --> 0:07:45,399
但是 大量的时间

154
00:07:45,465 --> 0:07:48,268
实际上被花费在

155
00:07:49,403 --> 0:07:51,705
这意味着 交叉区的渲染性能

156
00:07:51,772 --> 0:07:54,608
对总体渲染性能有很大的影响

157
00:07:54,675 --> 0:07:57,411
即使它与实际光照和阴影无关

158
00:07:58,478 --> 0:08:00,280
这个核心交叉问题

159
00:07:58,478 --> 0:08:00,280
这个核心交叉问题

160
00:08:00,347 --> 0:08:02,916
是所有光线追踪app

161
00:08:04,785 --> 0:08:07,821
因此我们决定

162
00:08:08,088 --> 0:08:10,924
以实现高水平的交叉区性能

163
00:08:11,091 --> 0:08:13,193
并且专注于app的细节

164
00:08:14,728 --> 0:08:15,562
为此 今年

165
00:08:15,629 --> 0:08:18,398
我们引入了

166
00:08:19,633 --> 0:08:22,970
这个API加速

167
00:08:23,136 --> 0:08:24,238
和iOs设备的

168
00:08:24,571 --> 0:08:27,107
GPU上的光线三角线交叉测试

169
00:08:28,542 --> 0:08:31,345
我们希望这个API能够

170
00:08:31,478 --> 0:08:33,746
因此我们通过Metal缓冲区

171
00:08:34,648 --> 0:08:37,351
MPS将会沿每条光线

172
00:08:37,885 --> 0:08:39,953
然后在另一个Metal缓冲区中

173
00:08:40,754 --> 0:08:41,889
你只需要

174
00:08:42,389 --> 0:08:45,392
在app中提供

175
00:08:45,459 --> 0:08:47,561
在这个缓冲区中

176
00:08:47,928 --> 0:08:49,763
我们会将所有交叉测试工作

177
00:08:49,830 --> 0:08:51,298
编码到指令缓冲区中

178
00:08:52,766 --> 0:08:55,335
让我们来更深入地分析

179
00:08:59,706 --> 0:09:00,541
好的

180
00:08:59,706 --> 0:09:00,541
好的

181
00:09:01,742 --> 0:09:05,179
3D模型通常表示为

182
00:09:06,079 --> 0:09:08,949
我们需要做的事情是

183
00:09:09,149 --> 0:09:11,652
找出哪些三角形

184
00:09:12,920 --> 0:09:14,555
此外 我们需要分析

185
00:09:14,688 --> 0:09:17,591
哪些交叉点最接近

186
00:09:19,126 --> 0:09:20,761
最简单的方法是

187
00:09:20,961 --> 0:09:22,896
循环遍历所有三角形

188
00:09:22,963 --> 0:09:24,698
检查光线的交叉点

189
00:09:25,332 --> 0:09:28,735
但是 即使是最小的场景

190
00:09:29,903 --> 0:09:33,740
因此 我们创建了一个数据结构

191
00:09:34,675 --> 0:09:35,742
加速结构的工作原理

192
00:09:35,809 --> 0:09:39,146
是递归地将场景划分为

193
00:09:39,213 --> 0:09:41,148
组中的三角形

194
00:09:42,482 --> 0:09:44,618
当需要将一条光线与场景交叉时

195
00:09:45,118 --> 0:09:47,654
将光线与树中的边界方框进行交叉

196
00:09:48,355 --> 0:09:51,992
如果光线未与边界方框交叉

197
00:09:53,093 --> 0:09:54,661
最后 我们只需要

198
00:09:54,728 --> 0:09:56,396
检查一小部分的三角形

199
00:09:56,463 --> 0:09:57,931
以确定光线交叉

200
00:09:59,066 --> 0:10:00,100
我们主要使用这方法

201
00:09:59,066 --> 0:10:00,100
我们主要使用这方法

202
00:10:00,167 --> 0:10:02,035
加速光线三角形交叉检查

203
00:10:03,303 --> 0:10:05,539
当然 这是一个简单的例子

204
00:10:06,106 --> 0:10:07,107
在实际场景中

205
00:10:07,174 --> 0:10:09,843
加速结构可能会更加复杂

206
00:10:11,378 --> 0:10:14,581
从这个图示中 我们可以看出

207
00:10:14,648 --> 0:10:16,984
加速结构正在适应

208
00:10:17,851 --> 0:10:19,786
这意味着 我们的大多数时间

209
00:10:19,853 --> 0:10:23,824
仅用于搜索高复杂性

210
00:10:24,024 --> 0:10:25,025
这正是我们想要的

211
00:10:26,460 --> 0:10:28,795
我描述了加速结构是什么

212
00:10:29,029 --> 0:10:31,965
让你们有直观的感受

213
00:10:32,466 --> 0:10:34,668
但实际上你们并不需要

214
00:10:35,002 --> 0:10:37,070
因为MPS将会为你们

215
00:10:39,039 --> 0:10:41,241
请记住 我们使用三角形

216
00:10:41,808 --> 0:10:43,844
这些三角形本身

217
00:10:43,911 --> 0:10:45,779
顶点进行表示

218
00:10:46,813 --> 0:10:50,784
你只需要 调用MPS

219
00:10:50,851 --> 0:10:52,052
创建一个加速结构

220
00:10:53,387 --> 0:10:55,122
当准备搜索交叉时

221
00:10:55,289 --> 0:10:57,157
只需要将这个加速结构

222
00:10:57,224 --> 0:10:58,525
提供给交叉区域

223
00:10:59,693 --> 0:11:02,262
让我们来看如何使用此方法

224
00:10:59,693 --> 0:11:02,262
让我们来看如何使用此方法

225
00:11:03,463 --> 0:11:05,465
我们将这个app划分为三个阶段

226
00:11:05,899 --> 0:11:10,003
首先 我们生成一次光线

227
00:11:10,070 --> 0:11:11,338
然后计算阴影

228
00:11:11,972 --> 0:11:13,574
这类似于我们使用

229
00:11:13,640 --> 0:11:14,775
实现的效果

230
00:11:15,108 --> 0:11:16,910
但在接下来的步骤中

231
00:11:18,245 --> 0:11:19,680
接下来 我们将会添加阴影

232
00:11:20,013 --> 0:11:22,316
MPS提供特殊的阴影光线支持

233
00:11:22,516 --> 0:11:24,518
可以加快app速度

234
00:11:26,119 --> 0:11:26,987
最后

235
00:11:27,054 --> 0:11:29,189
我们使用二次光线

236
00:11:29,256 --> 0:11:30,624
模拟场景中的光线反射

237
00:11:31,391 --> 0:11:33,694
使用光栅化方法很难

238
00:11:33,760 --> 0:11:35,729
但是 我们看到

239
00:11:35,796 --> 0:11:36,930
很容易做到这一点

240
00:11:38,665 --> 0:11:40,133
让我们从一次光线开始

241
00:11:41,401 --> 0:11:43,537
我们需要做五件事

242
00:11:44,404 --> 0:11:46,974
首先 我们创建一个

243
00:11:48,542 --> 0:11:50,043
然后 在我们的顶点缓冲区中

244
00:11:50,110 --> 0:11:51,345
创建一个加速结构

245
00:11:53,480 --> 0:11:56,884
接下来 我们生成一次光线

246
00:11:58,719 --> 0:12:01,822
然后 我们使用

247
00:11:58,719 --> 0:12:01,822
然后 我们使用

248
00:12:01,889 --> 0:12:03,257
寻找光线与场景间的交叉区

249
00:12:04,024 --> 0:12:04,958
最后

250
00:12:05,025 --> 0:12:07,694
最后我们使用交叉区结果

251
00:12:09,263 --> 0:12:10,731
我们先来看Intersector

252
00:12:12,566 --> 0:12:14,468
MPSRayIntersector类

253
00:12:14,768 --> 0:12:17,304
协调所有光线三角交叉区测试结果

254
00:12:18,305 --> 0:12:21,041
我们只需要提供

255
00:12:21,108 --> 0:12:23,043
Metal设备

256
00:12:25,312 --> 0:12:27,314
接下来 我们将创建加速结构

257
00:12:28,982 --> 0:12:29,917
此加速结构用

258
00:12:29,983 --> 0:12:32,686
MPSTriangle

259
00:12:33,120 --> 0:12:36,456
同样地 要创建加速结构

260
00:12:36,523 --> 0:12:38,158
相同Metal设备

261
00:12:40,027 --> 0:12:43,230
然后 加入我们的vertexBuffer

262
00:12:44,298 --> 0:12:46,967
最后 我们创建加速结构

263
00:12:47,534 --> 0:12:48,869
只需要创建一次

264
00:12:48,936 --> 0:12:51,338
然后 就可以重复地

265
00:12:51,405 --> 0:12:52,739
多次使用这个加速结构

266
00:12:56,677 --> 0:12:59,947
接下来 将生成一次光线

267
00:13:01,148 --> 0:13:03,951
为此 将启动

268
00:13:04,117 --> 0:13:05,652
每个像素一个线程

269
00:13:06,486 --> 0:13:09,823
每个线程将这个光线结构

270
00:13:11,458 --> 0:13:13,126
可以设想 输出图像

271
00:13:13,193 --> 0:13:15,629
在摄像机正方的平面上飘浮

272
00:13:17,397 --> 0:13:19,366
一次光线从摄像机中发出

273
00:13:19,433 --> 0:13:21,768
因此我以将原点

274
00:13:22,703 --> 0:13:24,004
为了计算方向

275
00:13:24,471 --> 0:13:26,840
将从摄像机位置寻找方向

276
00:13:27,007 --> 0:13:29,343
穿过图像平面上的相应像素点

277
00:13:32,546 --> 0:13:34,047
现在 已经生成一次光线

278
00:13:34,114 --> 0:13:36,583
将用Intersector

279
00:13:38,285 --> 0:13:40,087
encodeIntersection调用

280
00:13:40,153 --> 0:13:42,456
将我们创建的所有项目

281
00:13:43,457 --> 0:13:46,793
首先请记住 我们将会编码到

282
00:13:47,928 --> 0:13:49,162
实际上 我们有多个选项

283
00:13:49,229 --> 0:13:51,498
来选择进行哪种类型的交叉区搜索

284
00:13:51,999 --> 0:13:53,634
本例中 我们使用最近的交叉区

285
00:13:53,700 --> 0:13:56,336
将沿每条光线寻找最近的交叉区

286
00:13:58,172 --> 0:13:59,640
然后 提供光线缓冲区

287
00:13:59,706 --> 0:14:02,776
此缓冲区包含我们刚创建的一次光线

288
00:13:59,706 --> 0:14:02,776
此缓冲区包含我们刚创建的一次光线

289
00:14:03,410 --> 0:14:04,778
另外还提供交叉区缓冲区

290
00:14:04,845 --> 0:14:06,613
此缓冲区包含交叉区结果

291
00:14:07,848 --> 0:14:09,583
还需要提供rayCount

292
00:14:09,816 --> 0:14:11,485
在本例中 它是图像宽度

293
00:14:11,552 --> 0:14:12,619
乘以图像高度

294
00:14:13,787 --> 0:14:16,290
最后 提供我们的加速结构

295
00:14:17,724 --> 0:14:20,494
MPS将会沿每条光线

296
00:14:20,561 --> 0:14:22,829
并在交叉区缓冲中返回结果

297
00:14:23,230 --> 0:14:25,632
最后剩下的工作是

298
00:14:25,699 --> 0:14:26,700
计算阴影

299
00:14:28,669 --> 0:14:30,771
为此 我们启动

300
00:14:31,705 --> 0:14:33,440
可以像在片段着色器中那样

301
00:14:33,507 --> 0:14:35,742
app光照和材质

302
00:14:36,043 --> 0:14:38,612
在片段着色器中可以使用的

303
00:14:38,679 --> 0:14:40,547
大多数标准材质和数学函数

304
00:14:40,714 --> 0:14:42,616
都可以在计算内核中使用

305
00:14:43,784 --> 0:14:46,753
但是一般来说

306
00:14:46,820 --> 0:14:49,489
和顶点属性

307
00:14:50,023 --> 0:14:53,594
在片段着色器中

308
00:14:53,927 --> 0:14:55,729
但我们需要它们在交叉数据的基础上

309
00:14:55,796 --> 0:14:57,297
自己进行插值

310
00:14:58,866 --> 0:15:01,368
因此 让我们来看如何计算交叉点

311
00:14:58,866 --> 0:15:01,368
因此 让我们来看如何计算交叉点

312
00:15:03,237 --> 0:15:06,373
请记住

313
00:15:09,510 --> 0:15:12,779
这是Intersector

314
00:15:13,547 --> 0:15:15,249
距离字段告诉我们

315
00:15:15,315 --> 0:15:17,618
需要在光线方向行进多远的距离

316
00:15:17,951 --> 0:15:20,454
才能从光线起点到达交叉点

317
00:15:21,088 --> 0:15:24,324
如果光线不会与任何物体交叉

318
00:15:26,527 --> 0:15:29,296
primitiveIndex

319
00:15:30,330 --> 0:15:33,767
我们使用最后一个字段

320
00:15:35,169 --> 0:15:37,771
这个字段包含前两个质心坐标

321
00:15:37,838 --> 0:15:39,039
即U和V

322
00:15:39,473 --> 0:15:42,242
第三个坐标对应于交叉点相对于

323
00:15:42,309 --> 0:15:44,211
三角形顶点的

324
00:15:45,579 --> 0:15:47,714
实际上有三个质心坐标

325
00:15:47,781 --> 0:15:48,982
组成一个坐标集合

326
00:15:49,216 --> 0:15:51,652
因此我们可以用1减去前两个坐标

327
00:15:51,818 --> 0:15:53,954
计算出第三个坐标W

328
00:15:55,589 --> 0:15:59,092
如果仅定义三角形的

329
00:15:59,459 --> 0:16:01,395
插入的顶点属性

330
00:15:59,459 --> 0:16:01,395
插入的顶点属性

331
00:16:02,329 --> 0:16:05,566
仅仅是每个顶点的属性相加

332
00:16:05,632 --> 0:16:07,534
并使用质心坐标加权

333
00:16:08,302 --> 0:16:11,205
例如 如果设定每个顶点的颜色

334
00:16:11,271 --> 0:16:12,673
那么插值颜色

335
00:16:12,739 --> 0:16:15,442
就是每个顶点的颜色加权和

336
00:16:18,178 --> 0:16:20,480
到此为止 我们创建了

337
00:16:20,981 --> 0:16:22,583
一个加速结构

338
00:16:23,584 --> 0:16:25,452
然后生成一次光线

339
00:16:25,686 --> 0:16:27,521
找到光线与场景的交叉区

340
00:16:28,288 --> 0:16:30,324
在交叉点计算阴影

341
00:16:30,390 --> 0:16:32,793
然后 我们将阴影颜色

342
00:16:32,993 --> 0:16:34,361
让我们来看图像

343
00:16:36,063 --> 0:16:39,199
我们可以看到加速结构

344
00:16:39,399 --> 0:16:42,736
以及插值顶点颜色

345
00:16:43,904 --> 0:16:45,372
图像已经显示在屏幕上

346
00:16:45,439 --> 0:16:47,241
我们添加一些其他效果

347
00:16:48,742 --> 0:16:51,011
首先 为图像增加阴影

348
00:16:53,447 --> 0:16:55,315
为此 在添加阴影之前

349
00:16:55,883 --> 0:16:58,252
需要检查

350
00:16:58,318 --> 0:16:59,953
光线是否可以到达阴影点

351
00:17:00,888 --> 0:17:03,557
为此 可以添加

352
00:17:03,690 --> 0:17:06,026
从交叉点投射到光源

353
00:17:07,594 --> 0:17:10,130
如果阴影光线不能到达光源

354
00:17:10,196 --> 0:17:12,532
那么初始阴影点就不是阴影

355
00:17:12,633 --> 0:17:14,667
因此不应该添加其颜色到图像

356
00:17:17,704 --> 0:17:19,339
我们将修改阴影内核

357
00:17:19,806 --> 0:17:22,910
将附加阴影光线

358
00:17:24,444 --> 0:17:27,114
然后 我们再次寻找

359
00:17:28,115 --> 0:17:30,017
然后启动最后一个内核

360
00:17:30,083 --> 0:17:33,220
此内核根据阴影光线

361
00:17:33,287 --> 0:17:35,889
有条件地

362
00:17:36,990 --> 0:17:39,092
因此 让我们开始修改阴影内核

363
00:17:40,894 --> 0:17:43,597
现在 阴影光线略微

364
00:17:44,198 --> 0:17:45,032
首先…

365
00:17:45,098 --> 0:17:47,768
我们需要提供

366
00:17:47,901 --> 0:17:50,571
这样 阴影光线

367
00:17:52,539 --> 0:17:54,908
我们不需要知道

368
00:17:54,975 --> 0:17:56,910
或质心坐标是多少

369
00:17:56,977 --> 0:17:58,912
因此我们可以进行一些优化

370
00:18:00,314 --> 0:18:01,215
最后…

371
00:18:01,281 --> 0:18:04,117
记住 我们不能

372
00:18:04,184 --> 0:18:07,254
除非我们知道原始阴影点

373
00:18:07,821 --> 0:18:11,058
因此我们需要一种方法

374
00:18:11,124 --> 0:18:14,127
从阴影内核

375
00:18:14,194 --> 0:18:15,596
这将会更新图像

376
00:18:16,296 --> 0:18:18,632
为此 可以自定义

377
00:18:22,302 --> 0:18:23,904
我们有多个选项

378
00:18:23,971 --> 0:18:26,507
选择为Intersector

379
00:18:27,140 --> 0:18:28,742
本例中

380
00:18:28,809 --> 0:18:31,445
它包含最小和最大距离字段

381
00:18:32,379 --> 0:18:35,449
MPS将会忽略

382
00:18:35,649 --> 0:18:38,552
从而防止阴影射线

383
00:18:40,187 --> 0:18:41,054
其次…

384
00:18:41,288 --> 0:18:44,758
如果应用特定的光线相关数据

385
00:18:45,125 --> 0:18:47,261
可以将这些数据追加到

386
00:18:47,327 --> 0:18:48,996
并且提供一个rayStride

387
00:18:49,730 --> 0:18:52,866
MPS从你的光线缓冲区读取数据时

388
00:18:53,867 --> 0:18:54,701
在本例中

389
00:18:54,768 --> 0:18:57,004
我们将阴影颜色添加到

390
00:18:57,070 --> 0:18:59,339
这样 可以将它从阴影内核

391
00:18:59,406 --> 0:19:00,607
传递到最后内核

392
00:18:59,406 --> 0:19:00,607
传递到最后内核

393
00:19:02,242 --> 0:19:04,611
我们可以在光线Intersector上

394
00:19:05,312 --> 0:19:06,146
首先…

395
00:19:06,346 --> 0:19:08,649
设置rayDataType

396
00:19:10,651 --> 0:19:11,885
然后 设置rayStride

397
00:19:11,952 --> 0:19:14,188
以跳过结构末尾的颜色

398
00:19:16,590 --> 0:19:18,859
接下来 通过Intersector

399
00:19:20,894 --> 0:19:22,996
这是Intersector

400
00:19:23,564 --> 0:19:26,200
记住 阴影光线仅检查

401
00:19:26,266 --> 0:19:28,836
原始阴影点与光源之间的可见性

402
00:19:28,902 --> 0:19:30,704
我们可以进行两项优化

403
00:19:31,538 --> 0:19:34,908
与自定义

404
00:19:34,975 --> 0:19:37,377
我们可以自定义

405
00:19:37,711 --> 0:19:40,380
或Intersector的

406
00:19:41,982 --> 0:19:45,152
在本例中只需要知道

407
00:19:45,219 --> 0:19:46,820
表示是否存在交叉

408
00:19:47,454 --> 0:19:50,324
因此可以将intersection数据类型

409
00:19:50,724 --> 0:19:52,326
这会节省一些内存带宽

410
00:19:52,392 --> 0:19:55,162
加快Intersection

411
00:19:57,497 --> 0:19:58,332
其次

412
00:19:58,398 --> 0:20:00,968
由于并不需要知道

413
00:19:58,398 --> 0:20:00,968
由于并不需要知道

414
00:20:01,034 --> 0:20:04,404
因此可以在遇到任意三角形时

415
00:20:04,705 --> 0:20:05,672
通常情况下

416
00:20:05,739 --> 0:20:08,375
这比搜索最近交叉点的速度更快

417
00:20:09,142 --> 0:20:12,112
对此 MPS有一个专用模式

418
00:20:12,312 --> 0:20:15,349
方法是传递任意intersectionType

419
00:20:18,385 --> 0:20:22,222
最后 可以启动最后内核

420
00:20:24,191 --> 0:20:28,929
每个线程将读入一阴影光线和相应的

421
00:20:30,297 --> 0:20:32,332
如果交叉间距为正值

422
00:20:32,533 --> 0:20:34,902
那么原始交叉点位于阴影之中

423
00:20:35,269 --> 0:20:36,703
不需要做其他工作

424
00:20:37,504 --> 0:20:39,907
否则 交叉点不在阴影之中

425
00:20:41,275 --> 0:20:44,745
因此 应读入光线颜色

426
00:20:45,979 --> 0:20:48,282
这样就可以将阴影

427
00:20:50,817 --> 0:20:53,587
我们可以看到

428
00:20:53,654 --> 0:20:56,757
每个阴影点检查

429
00:20:57,591 --> 0:20:59,193
由于我们使用光线追踪器

430
00:20:59,660 --> 0:21:02,429
因此可以随机采样

431
00:20:59,660 --> 0:21:02,429
因此可以随机采样

432
00:21:02,496 --> 0:21:04,398
为我们提供这些美观的软阴影

433
00:21:07,301 --> 0:21:09,403
最后 让我们来看二次光源

434
00:21:11,205 --> 0:21:14,608
记住 二次光线模拟

435
00:21:15,709 --> 0:21:19,947
为了添加二次光源

436
00:21:20,480 --> 0:21:23,383
在每次迭代中

437
00:21:23,450 --> 0:21:24,918
以沿续光线路径

438
00:21:29,790 --> 0:21:31,358
然后 修改阴影内核

439
00:21:31,592 --> 0:21:34,194
为下次迭代生成光线

440
00:21:35,162 --> 0:21:36,964
完成图像更新之后

441
00:21:37,364 --> 0:21:40,200
循环回到第一次交叉测试

442
00:21:40,734 --> 0:21:44,171
可以根据需要的反射次数

443
00:21:47,274 --> 0:21:49,409
我们来看阴影内核修改

444
00:21:51,945 --> 0:21:53,080
在每次迭代中

445
00:21:53,480 --> 0:21:55,816
我们将光线起点移至交叉点

446
00:21:57,651 --> 0:22:00,087
然后选择一个随机方向

447
00:21:57,651 --> 0:22:00,087
然后选择一个随机方向

448
00:22:01,388 --> 0:22:02,289
最后

449
00:22:02,923 --> 0:22:05,893
将光线颜色与插值顶点颜色相乘

450
00:22:06,894 --> 0:22:08,996
这样光线就会使用

451
00:22:09,062 --> 0:22:11,031
表面反射的颜色

452
00:22:11,832 --> 0:22:13,400
在更高级的app中

453
00:22:13,467 --> 0:22:16,036
计算将会更加复杂

454
00:22:16,436 --> 0:22:18,872
但是 通过认真选择随机光线方向

455
00:22:18,939 --> 0:22:21,475
可以取消其余的数学计算

456
00:22:22,543 --> 0:22:25,245
即使从摄像机反向投射光线

457
00:22:25,479 --> 0:22:27,981
只要在每个交叉点

458
00:22:28,048 --> 0:22:30,117
严格地为直射光线着色

459
00:22:31,785 --> 0:22:33,687
对于二次光线

460
00:22:35,155 --> 0:22:38,125
光线可以从墙面反射到

461
00:22:38,192 --> 0:22:40,594
箱子侧面和天花板上

462
00:22:42,129 --> 0:22:43,564
这是我们的示例app

463
00:22:44,865 --> 0:22:48,802
最初 屏幕上显示一幅图像

464
00:22:49,670 --> 0:22:51,071
然后我们添加阴影

465
00:22:51,438 --> 0:22:52,306
最后

466
00:22:52,372 --> 0:22:55,309
使用二次光线模拟

467
00:22:56,176 --> 0:22:59,847
让我们切换到演示

468
00:23:03,951 --> 0:23:08,755
这是我们编写的app运行在

469
00:23:09,656 --> 0:23:11,558
我们可以扩展此app

470
00:23:11,892 --> 0:23:15,629
以支持更高级的光照

471
00:23:16,096 --> 0:23:18,565
让我们切换到更复杂的场景

472
00:23:18,732 --> 0:23:20,501
这个场景使用了许多这样的特性

473
00:23:25,973 --> 0:23:28,108
这是Amazon Lumberyard Bistro场景

474
00:23:28,175 --> 0:23:31,912
在“国情咨文”中运行

475
00:23:32,713 --> 0:23:35,148
这个场景有将近一百万个三角形

476
00:23:35,482 --> 0:23:37,985
但是 使用这些先进的

477
00:23:38,051 --> 0:23:39,286
我们仍能在iPad Pro上

478
00:23:39,353 --> 0:23:42,022
实现将近两千万条光线/秒的

479
00:23:42,456 --> 0:23:45,192
这是一个综合指标

480
00:23:45,259 --> 0:23:46,827
阴影和二次光线

481
00:23:48,362 --> 0:23:51,498
我们创建了便于使用的API

482
00:23:51,698 --> 0:23:54,835
你们现在就可以使用它们

483
00:23:56,069 --> 0:23:57,571
这是我们的演示例子

484
00:23:59,239 --> 0:24:00,140
谢谢

485
00:23:59,239 --> 0:24:00,140
谢谢

486
00:24:03,477 --> 0:24:05,312
如果你们没有完全理解

487
00:24:05,479 --> 0:24:08,482
这个app作为例子

488
00:24:09,116 --> 0:24:12,085
这个例子演示了

489
00:24:12,686 --> 0:24:15,389
强烈建议你们下载这个示例

490
00:24:15,556 --> 0:24:18,792
添加你们自己的几何

491
00:24:19,560 --> 0:24:21,495
关于API 还有很多的内容

492
00:24:21,562 --> 0:24:23,297
今天没有时间逐一讲解

493
00:24:23,797 --> 0:24:25,165
因此 建议你们查看

494
00:24:25,232 --> 0:24:27,000
文件和头文件

495
00:24:27,868 --> 0:24:30,304
接下来 把舞台交给同事Wayne

496
00:24:30,737 --> 0:24:33,373
他将会介绍我们如何

497
00:24:35,542 --> 0:24:36,376
谢谢

498
00:24:42,149 --> 0:24:42,983
谢谢Sean

499
00:24:43,550 --> 0:24:44,384
大家好

500
00:24:47,988 --> 0:24:49,590
你们很多人使用Mac计算机

501
00:24:50,424 --> 0:24:52,226
它有一个内置GPU

502
00:24:52,559 --> 0:24:56,363
但是你们可能添加了

503
00:24:57,464 --> 0:25:01,301
我们希望能够使用所有这些GPU

504
00:24:57,464 --> 0:25:01,301
我们希望能够使用所有这些GPU

505
00:25:01,368 --> 0:25:04,104
以尽量提高光线追踪速度

506
00:25:05,272 --> 0:25:06,473
我们应该怎么做？

507
00:25:06,840 --> 0:25:07,708
我们需要

508
00:25:07,774 --> 0:25:09,309
考虑三件事情

509
00:25:10,277 --> 0:25:11,178
首先

510
00:25:11,512 --> 0:25:14,281
我们如何在GPU之间

511
00:25:15,749 --> 0:25:16,583
其次

512
00:25:17,284 --> 0:25:20,387
有时候 GPU需要

513
00:25:20,721 --> 0:25:22,623
我们如何处理这个问题？

514
00:25:23,824 --> 0:25:24,658
最后

515
00:25:24,725 --> 0:25:26,760
还需要一个同步方法

516
00:25:27,594 --> 0:25:30,163
对此 我将介绍如何使用

517
00:25:30,230 --> 0:25:31,798
本周我们进行了相关的介绍

518
00:25:32,666 --> 0:25:33,767
让我们开始

519
00:25:35,335 --> 0:25:36,537
对于如何划分处理工作量

520
00:25:36,603 --> 0:25:39,006
我们将会使用名称为

521
00:25:39,806 --> 0:25:42,976
其原理是将帧分为多个区域

522
00:25:43,043 --> 0:25:46,346
然后将这些区域

523
00:25:46,880 --> 0:25:48,448
从而可以并行地进行渲染

524
00:25:49,883 --> 0:25:50,851
现在 每个GPU

525
00:25:50,918 --> 0:25:53,820
都将运行完整渲染管道

526
00:25:54,121 --> 0:25:56,590
这包括所有的处理

527
00:25:56,924 --> 0:25:59,026
到阴影光线和着色

528
00:26:00,360 --> 0:26:02,196
所有GPU完成处理之后

529
00:26:02,262 --> 0:26:04,965
我们选择连接到显示的GPU

530
00:26:05,732 --> 0:26:07,968
将会复制所有已经完成的区域

531
00:26:08,035 --> 0:26:08,902
以进行合成

532
00:26:10,537 --> 0:26:11,471
合成是将各个区域

533
00:26:11,538 --> 0:26:13,307
拼接在一起

534
00:26:13,373 --> 0:26:15,309
然后放入帧缓冲区

535
00:26:16,043 --> 0:26:19,179
你可能想要将它们

536
00:26:19,246 --> 0:26:21,448
以增强图像质量和消除噪讯

537
00:26:23,550 --> 0:26:25,485
在开始进行渲染之前

538
00:26:25,619 --> 0:26:28,822
需要确保每个GPU

539
00:26:30,123 --> 0:26:33,227
需要在所有GPU上复制资产

540
00:26:33,293 --> 0:26:35,462
例如顶点缓冲区和材质

541
00:26:36,563 --> 0:26:38,432
然后 创建Sean前面说过的

542
00:26:38,498 --> 0:26:39,867
三角形加速结构

543
00:26:42,436 --> 0:26:44,705
现在… 对于加速结构

544
00:26:44,771 --> 0:26:47,808
不需要为每个GPU

545
00:26:47,875 --> 0:26:48,976
重头进行创建

546
00:26:49,510 --> 0:26:54,147
我们添加一个API

547
00:26:54,214 --> 0:26:56,850
为每个想要使用的GPU

548
00:26:58,118 --> 0:27:00,587
这个副本是非递归性的

549
00:26:58,118 --> 0:27:00,587
这个副本是非递归性的

550
00:27:01,088 --> 0:27:04,091
因此 添加到加速结构的任何缓冲区

551
00:27:04,224 --> 0:27:06,693
例如顶点和索引缓冲区

552
00:27:07,628 --> 0:27:09,096
都需要单独复制它们

553
00:27:09,162 --> 0:27:11,431
然后 将它们添加到

554
00:27:11,498 --> 0:27:12,766
刚才创建的加速结构

555
00:27:16,203 --> 0:27:19,039
现在 已经在所有GPU上

556
00:27:19,106 --> 0:27:20,340
准备开始渲染

557
00:27:21,975 --> 0:27:24,845
从多GPU角度来的

558
00:27:24,912 --> 0:27:28,048
这部分的管道

559
00:27:28,115 --> 0:27:29,383
没有什么差别

560
00:27:30,250 --> 0:27:32,619
唯一的差别在于对于多GPU

561
00:27:32,819 --> 0:27:35,989
需要设定各个GPU所负责的

562
00:27:36,056 --> 0:27:37,891
屏幕区域的光线生成工作

563
00:27:38,458 --> 0:27:39,893
其他部分都是相同的

564
00:27:40,894 --> 0:27:41,929
因此

565
00:27:41,995 --> 0:27:46,099
让我们直接来看

566
00:27:46,500 --> 0:27:48,769
也就是合成阶段

567
00:27:51,371 --> 0:27:54,007
为了在macOS上获得最佳性能

568
00:27:54,074 --> 0:27:57,077
每个GPU都将渲染结果

569
00:27:58,078 --> 0:28:01,081
渲染完成后

570
00:27:58,078 --> 0:28:01,081
渲染完成后

571
00:28:01,148 --> 0:28:03,817
用于进行合成的GPU

572
00:28:04,985 --> 0:28:07,187
不能直接在缓冲区之间进行复制

573
00:28:07,254 --> 0:28:09,723
因为Metal资源只能

574
00:28:09,790 --> 0:28:10,791
在创建这些资源的设备上使用

575
00:28:11,425 --> 0:28:13,427
因此 不能在一个GPU上

576
00:28:13,493 --> 0:28:16,230
然后尝试将它添加到

577
00:28:16,296 --> 0:28:17,598
这样是不行的

578
00:28:18,832 --> 0:28:21,568
这意味着 我们的副本

579
00:28:23,370 --> 0:28:25,472
为了提高效率

580
00:28:25,539 --> 0:28:27,741
我们使用缓冲区管理

581
00:28:29,343 --> 0:28:31,111
我们创建两个Metal缓冲区

582
00:28:31,378 --> 0:28:34,882
每台设备一个包装通用CPU分配

583
00:28:36,016 --> 0:28:38,652
由于缓冲区包装相同的底层内存

584
00:28:39,052 --> 0:28:42,022
在设备A上写入

585
00:28:42,489 --> 0:28:45,192
对于设备B上的Metal缓冲区

586
00:28:46,927 --> 0:28:48,128
如前所述

587
00:28:48,795 --> 0:28:50,731
为了确保macOS上的处理性能

588
00:28:51,131 --> 0:28:54,368
所有这些实际渲染工作

589
00:28:55,169 --> 0:28:58,205
然后 当需复制区域到不同GPU时

590
00:28:58,272 --> 0:29:00,307
我们通过系统内存

591
00:28:58,272 --> 0:29:00,307
我们通过系统内存

592
00:29:02,142 --> 0:29:03,944
来看如何进行设置

593
00:29:05,012 --> 0:29:08,815
首先 使用Metal共享存储模式

594
00:29:09,783 --> 0:29:12,152
这将会在内部分配系统内存

595
00:29:12,553 --> 0:29:15,522
使用.contents方法

596
00:29:18,625 --> 0:29:20,460
然后在设备B上创建缓冲区时

597
00:29:20,761 --> 0:29:25,032
使用NoCopy API包装

598
00:29:27,000 --> 0:29:29,136
对于此API 需要知道的是

599
00:29:29,203 --> 0:29:32,406
缓冲区必须是多页面大小

600
00:29:32,472 --> 0:29:35,442
因此在创建原始缓冲区时

601
00:29:38,745 --> 0:29:41,381
现在 我们可以在设备之间共享内存

602
00:29:41,448 --> 0:29:43,150
我们需要思考同步化问题

603
00:29:43,917 --> 0:29:46,420
为了描述这个问题

604
00:29:46,486 --> 0:29:48,989
来描述两个并行运行的GPU

605
00:29:49,489 --> 0:29:51,792
黑框表示指令缓冲区

606
00:29:51,859 --> 0:29:53,026
绿框表示我们编码进入

607
00:29:53,093 --> 0:29:55,996
这些指令缓冲区中的工作内容

608
00:29:56,296 --> 0:29:58,632
例如 使用计算指令编码器

609
00:30:00,033 --> 0:30:03,036
因此 上方GPU将进行渲染

610
00:30:03,470 --> 0:30:06,273
渲染完成之后

611
00:30:06,340 --> 0:30:08,408
Blit进入前面所述的共享缓冲区

612
00:30:09,910 --> 0:30:11,078
在此过程中

613
00:30:11,678 --> 0:30:13,714
GPU B也在进行渲染

614
00:30:15,082 --> 0:30:17,584
我们将使用这个GPU进行合成

615
00:30:18,118 --> 0:30:19,019
因此在某一时间点

616
00:30:19,086 --> 0:30:22,356
它将需要GPU A生成的缓冲区

617
00:30:23,357 --> 0:30:24,992
这里可看到 有一个问题

618
00:30:25,893 --> 0:30:28,228
这个区域没有同步化

619
00:30:28,996 --> 0:30:32,099
因此 在GPU完成写入缓冲区之前

620
00:30:32,165 --> 0:30:34,368
不能阻止GPU B读取缓冲区

621
00:30:35,669 --> 0:30:38,105
要处理该问题

622
00:30:39,106 --> 0:30:41,008
利用Metal Events

623
00:30:41,074 --> 0:30:42,276
我们在指令缓冲区中

624
00:30:43,043 --> 0:30:45,712
当GPU执行时

625
00:30:45,879 --> 0:30:47,447
然后就会停止

626
00:30:48,782 --> 0:30:51,818
它等待的是

627
00:30:53,620 --> 0:30:55,022
收到信号之后

628
00:30:55,389 --> 0:30:58,058
我们就知道GPU A

629
00:30:58,125 --> 0:31:00,494
现在GPU B可以访问缓冲区

630
00:30:58,125 --> 0:31:00,494
现在GPU B可以访问缓冲区

631
00:31:02,596 --> 0:31:05,699
这种方法可以巧妙地

632
00:31:06,800 --> 0:31:08,802
但是很显然 使性能强劲的GPU

633
00:31:08,869 --> 0:31:13,106
保持等待状态并不是一个良策

634
00:31:13,841 --> 0:31:16,210
因此需要尽快缩短等待

635
00:31:16,276 --> 0:31:19,279
理想的情况下 我们希望GPU

636
00:31:20,848 --> 0:31:23,183
在这里 我们讨论的是

637
00:31:24,585 --> 0:31:26,587
因此 我们在GPU之间

638
00:31:26,653 --> 0:31:27,988
均等地分配屏幕区域

639
00:31:28,055 --> 0:31:29,723
这有一个问题

640
00:31:30,357 --> 0:31:32,159
首先 这没有考虑

641
00:31:32,226 --> 0:31:34,661
所使用的GPU性能可能存在差异

642
00:31:35,662 --> 0:31:37,464
如果一个GPU速度更快

643
00:31:37,531 --> 0:31:40,067
那么它会首先完成任务

644
00:31:41,535 --> 0:31:44,538
另一个问题是

645
00:31:44,605 --> 0:31:46,139
比其他区域更加复杂

646
00:31:46,206 --> 0:31:47,107
它们需要更长的时间

647
00:31:47,541 --> 0:31:50,777
它们可能有更复杂的几何形状

648
00:31:52,246 --> 0:31:53,380
为了解决这个问题

649
00:31:53,614 --> 0:31:56,049
我们需要自适应地

650
00:31:56,850 --> 0:31:59,152
这时的目标是确保每个GPU

651
00:31:59,219 --> 0:32:02,656
使用大约相等的时间

652
00:31:59,219 --> 0:32:02,656
使用大约相等的时间

653
00:32:04,291 --> 0:32:05,259
为此 我们使用的方法是

654
00:32:05,325 --> 0:32:07,995
从固定分区着手

655
00:32:08,362 --> 0:32:09,663
然后我们渲染一个帧

656
00:32:10,597 --> 0:32:13,066
测量每个GPU需要

657
00:32:13,500 --> 0:32:14,801
然后我们根据此结果确定

658
00:32:14,868 --> 0:32:17,471
为每个GPU分配多大的区域

659
00:32:19,940 --> 0:32:22,442
将会在app运行时

660
00:32:23,377 --> 0:32:25,846
因此 它不断地适应

661
00:32:25,913 --> 0:32:26,847
你的GPU的性能

662
00:32:27,181 --> 0:32:30,083
无论使用哪个场景区域

663
00:32:32,953 --> 0:32:37,591
都会使用指令缓冲区完成处理程序

664
00:32:38,725 --> 0:32:41,662
完成处理程序是一个CPU代码块

665
00:32:41,728 --> 0:32:43,497
可在GPU完成执行

666
00:32:43,564 --> 0:32:45,432
运行此代码块

667
00:32:46,800 --> 0:32:48,535
现在iOS上

668
00:32:49,102 --> 0:32:50,904
指令缓冲区有多个有用的属性

669
00:32:50,971 --> 0:32:52,072
可以读取这些属性

670
00:32:52,139 --> 0:32:54,408
以发现在GPU上运行缓冲区的时间

671
00:32:55,609 --> 0:32:57,444
但是它们在macOS上不可用

672
00:32:57,511 --> 0:32:59,446
我们需要确保处理时间大致相当

673
00:33:00,747 --> 0:33:03,417
我们使用的方法是

674
00:33:03,483 --> 0:33:05,619
存储主机时间

675
00:33:06,386 --> 0:33:08,188
如果对每个指令缓冲区执行此操作

676
00:33:08,689 --> 0:33:10,591
就可以根据这些时间差异

677
00:33:10,724 --> 0:33:12,593
确定GPU运行时间

678
00:33:13,393 --> 0:33:14,294
举例来说

679
00:33:15,195 --> 0:33:17,030
为了估算这里显示的

680
00:33:17,097 --> 0:33:18,498
三个指令缓冲区的执行时间

681
00:33:18,932 --> 0:33:21,301
我们测量完成处理程序调用的

682
00:33:21,368 --> 0:33:24,004
对于指令缓冲区3

683
00:33:26,640 --> 0:33:28,175
这是理论性的

684
00:33:28,242 --> 0:33:29,743
让我们来看实际运行情况

685
00:33:42,122 --> 0:33:44,591
这是Sean前面展示过的

686
00:33:44,658 --> 0:33:46,760
Amazon Lumberyard Bistro场景

687
00:33:47,561 --> 0:33:49,830
这次它在MacBook Pro上

688
00:33:50,797 --> 0:33:52,766
在屏幕上方

689
00:33:52,833 --> 0:33:54,568
有一个每秒光线数量指标

690
00:33:54,835 --> 0:33:56,870
可以知道运行速度

691
00:33:57,471 --> 0:34:01,642
这包括一次光线

692
00:33:57,471 --> 0:34:01,642
这包括一次光线

693
00:34:01,708 --> 0:34:03,310
都包含在这个指标中

694
00:34:04,444 --> 0:34:07,381
可以看到

695
00:34:07,447 --> 0:34:08,282
而且

696
00:34:08,415 --> 0:34:10,350
如果速度加快 效果会更好

697
00:34:10,484 --> 0:34:11,685
我想要启用

698
00:34:11,752 --> 0:34:13,987
我连接的一个eGPU

699
00:34:17,024 --> 0:34:18,358
这里的文字显示

700
00:34:18,425 --> 0:34:22,094
我们运行RX 580

701
00:34:22,629 --> 0:34:25,899
性能提高了一倍

702
00:34:26,900 --> 0:34:28,268
可以看到这里的绿线

703
00:34:28,335 --> 0:34:31,705
它更好地显示

704
00:34:32,039 --> 0:34:35,074
一个GPU渲染绿线上方的场景

705
00:34:35,141 --> 0:34:37,344
一个GPU渲染绿线下方的场景

706
00:34:38,745 --> 0:34:41,281
因此 通过使用eGPU

707
00:34:41,348 --> 0:34:42,349
能够将速度提高两倍

708
00:34:43,150 --> 0:34:45,452
但是我还有更高的期望

709
00:34:45,786 --> 0:34:49,623
问题是 eGPU

710
00:34:50,123 --> 0:34:52,192
这是因为我们使用固定分区方法

711
00:34:52,926 --> 0:34:55,429
如果我们切换为自适应负载均衡方法

712
00:34:56,196 --> 0:34:59,233
可以看到RX 580

713
00:34:59,299 --> 0:35:01,702
相比以前速度明显更快

714
00:34:59,299 --> 0:35:01,702
相比以前速度明显更快

715
00:35:04,638 --> 0:35:07,207
这个场景大约有一百万个三角形

716
00:35:07,274 --> 0:35:09,877
现在我们切换到室外场景

717
00:35:09,943 --> 0:35:13,213
这也是Amazon Lumberyard场景

718
00:35:13,313 --> 0:35:16,483
这个场景大约有三百万个三角形

719
00:35:17,518 --> 0:35:20,921
另外一个GPU处于等待状态

720
00:35:20,988 --> 0:35:21,822
现在

721
00:35:22,656 --> 0:35:24,124
这个GPU是Vega 64

722
00:35:24,858 --> 0:35:27,361
可以看到Vega

723
00:35:28,762 --> 0:35:30,831
这个配置比较有趣

724
00:35:30,898 --> 0:35:33,634
因为有三个不同的GPU

725
00:35:33,700 --> 0:35:35,235
它们的架构不同

726
00:35:35,569 --> 0:35:37,037
而且性能差异很大

727
00:35:37,104 --> 0:35:39,640
但是它们协同工作

728
00:35:51,018 --> 0:35:53,954
今天 我们介绍了

729
00:35:54,021 --> 0:35:55,389
它是一个新的API

730
00:35:55,455 --> 0:35:58,325
可用于在GPU上

731
00:35:59,793 --> 0:36:01,028
从前面的演示中可以看出

732
00:35:59,793 --> 0:36:01,028
从前面的演示中可以看出

733
00:36:01,094 --> 0:36:04,364
已经可以在所有的iOS

734
00:36:04,698 --> 0:36:08,001
当你在macOS上添加GPU时

735
00:36:09,770 --> 0:36:11,004
我们希望看到

736
00:36:11,071 --> 0:36:13,540
你们在app中

737
00:36:14,107 --> 0:36:16,977
今天 我们在示例中

738
00:36:17,311 --> 0:36:18,745
以及混合渲染技术

739
00:36:18,812 --> 0:36:20,881
你们可能希望使用光线追踪技术

740
00:36:20,948 --> 0:36:24,351
生成美观的阴影

741
00:36:25,319 --> 0:36:27,254
另外还有一些非渲染app

742
00:36:27,454 --> 0:36:31,225
例如 自动模拟、物理

743
00:36:31,291 --> 0:36:32,926
应用非常广泛

744
00:36:34,862 --> 0:36:35,963
为了帮助你们上手

745
00:36:38,899 --> 0:36:41,535
可以在developer.apple.com

746
00:36:41,602 --> 0:36:43,003
因此请务必查阅

747
00:36:43,470 --> 0:36:46,406
另外还有头文件大量的文档

748
00:36:46,473 --> 0:36:48,742
以及其他特性的相关信息

749
00:36:48,809 --> 0:36:50,344
今天无法逐一讲解

750
00:36:51,411 --> 0:36:52,246
最后

751
00:36:52,312 --> 0:36:54,014
明天12:00还有实验室

752
00:36:54,515 --> 0:36:57,284
Sean和我将会

753
00:36:57,351 --> 0:37:00,120
帮助你们在app中

754
00:36:57,351 --> 0:37:00,120
帮助你们在app中

755
00:37:00,187 --> 0:37:01,755
希望你们能参加

756
00:37:02,623 --> 0:37:03,490
最后

757
00:37:03,557 --> 0:37:04,858
感谢你们参加本演讲

758
00:37:04,925 --> 0:37:07,027
希望你们在剩下的WWDC中
