1
00:00:17,150 --> 0:00:22,055
（Metal游戏性能优化）

2
00:00:22,122 --> 0:00:24,491
（演讲612）

3
00:00:29,329 --> 0:00:31,231
早上好 欢迎来到本次演讲

4
00:00:31,832 --> 0:00:34,368
我叫Guillem Vinals Gangolells

5
00:00:34,434 --> 0:00:37,604
在Apple的

6
00:00:38,839 --> 0:00:42,709
你们这样的游戏开发者

7
00:00:43,243 --> 0:00:45,546
在Apple

8
00:00:46,380 --> 0:00:49,216
所以今年

9
00:00:49,583 --> 0:00:51,552
并发现了一些常见的性能问题

10
00:00:52,386 --> 0:00:53,921
我们分析了很多数据

11
00:00:54,188 --> 0:00:56,023
作为调查的结果

12
00:00:56,423 --> 0:00:58,225
我们决定做这个谈话

13
00:00:59,860 --> 0:01:01,862
所以这将是今天的主题

14
00:00:59,860 --> 0:01:01,862
所以这将是今天的主题

15
00:01:02,296 --> 0:01:03,730
开发出色的游戏

16
00:01:04,965 --> 0:01:07,868
但是 我只能在这里提供技术指导

17
00:01:07,935 --> 0:01:09,303
所以我们只能满足于此

18
00:01:09,369 --> 0:01:11,238
（开发技术出色的游戏）

19
00:01:11,305 --> 0:01:12,272
在开始之前

20
00:01:12,940 --> 0:01:14,908
我想借机感谢Croteam的朋友

21
00:01:15,309 --> 0:01:17,711
他们是《塔洛斯法则》背后的开发者

22
00:01:18,011 --> 0:01:19,546
这是一款非常棒的游戏

23
00:01:19,847 --> 0:01:22,716
你将在这些幻灯片

24
00:01:23,917 --> 0:01:26,787
请注意 它具有令人惊叹的视觉效果

25
00:01:27,221 --> 0:01:29,623
但它确实在性能上没变差

26
00:01:29,990 --> 0:01:31,458
这就是我们今天的目标

27
00:01:32,059 --> 0:01:34,027
让我们快速过一下今天的议题

28
00:01:36,396 --> 0:01:38,398
我将首先介绍这些工具

29
00:01:38,832 --> 0:01:40,367
这是一个非常好的起步

30
00:01:40,868 --> 0:01:43,804
然后我们将讨论实际的性能问题

31
00:01:44,371 --> 0:01:48,141
有关帧速 线程优先级 热状态

32
00:01:48,509 --> 0:01:50,043
和不必要的GPU工作

33
00:01:51,078 --> 0:01:53,780
尽管所有这些问题似乎互不相关

34
00:01:54,281 --> 0:01:56,283
它们会互相复合和影响

35
00:01:56,483 --> 0:01:58,118
所以解决所有这些问题很重要

36
00:01:59,820 --> 0:02:01,021
让我们从工具开始

37
00:01:59,820 --> 0:02:01,021
让我们从工具开始

38
00:02:01,788 --> 0:02:03,690
（分析工具）

39
00:02:03,757 --> 0:02:04,625
（及早分析及经常分析）

40
00:02:04,691 --> 0:02:06,493
这是最重要的建议

41
00:02:06,760 --> 0:02:09,429
你应该尽早建档分析并经常更新

42
00:02:10,564 --> 0:02:13,233
除非你已经对游戏进行了分析

43
00:02:13,967 --> 0:02:16,570
为此 你需要了解这些工具

44
00:02:17,471 --> 0:02:19,940
今天 我将关注其中两个

45
00:02:20,941 --> 0:02:22,709
首先

46
00:02:23,043 --> 0:02:24,678
这是我们的主要分析工具

47
00:02:25,345 --> 0:02:27,581
你会想用它来理解性能

48
00:02:28,148 --> 0:02:30,284
延迟和总体时间

49
00:02:31,151 --> 0:02:33,687
其次 我们有Metal框架调试器

50
00:02:34,021 --> 0:02:35,689
这也是一个非常强大的工具

51
00:02:36,323 --> 0:02:38,892
你希望用它来调试GPU工作负载

52
00:02:40,627 --> 0:02:41,828
我们从哪里开始呢？

53
00:02:42,763 --> 0:02:44,164
这是我们经常遇到的问题

54
00:02:45,132 --> 0:02:47,701
嗯 今年我们让你们更轻松

55
00:02:48,135 --> 0:02:50,237
我们正在推出一种新的仪器模板

56
00:02:50,671 --> 0:02:52,673
这将是一个很好的起点

57
00:02:53,073 --> 0:02:54,508
游戏性能模板

58
00:02:55,275 --> 0:02:57,744
这是现有工具的组合

59
00:02:58,245 --> 0:02:59,713
例如系统跟踪

60
00:03:00,581 --> 0:03:01,548
时间分析仪

61
00:03:02,082 --> 0:03:03,317
和Metal系统跟踪

62
00:03:03,951 --> 0:03:05,319
我们为你配置好了

63
00:03:05,619 --> 0:03:09,223
它会记录与你的游戏相关的

64
00:03:09,656 --> 0:03:10,757
所以你可以用它调试

65
00:03:12,259 --> 0:03:14,261
那么我们如何推出呢？

66
00:03:14,695 --> 0:03:15,529
嗯…

67
00:03:15,696 --> 0:03:18,899
只需打开Instruments

68
00:03:19,967 --> 0:03:20,934
选择后

69
00:03:21,001 --> 0:03:23,704
你将像设任何其它模板一样设置

70
00:03:24,838 --> 0:03:27,407
开始记录后

71
00:03:27,808 --> 0:03:30,644
允许你任意地玩游戏

72
00:03:30,978 --> 0:03:33,714
只有最后几秒的数据会被记录下来

73
00:03:34,114 --> 0:03:37,317
这就是最后几秒数据的样子

74
00:03:38,785 --> 0:03:42,422
有很多信息 所以我们简单概述一下

75
00:03:43,457 --> 0:03:45,092
（系统跟踪和时间分析仪）

76
00:03:45,158 --> 0:03:47,928
首先 我们有系统跟踪和时间分析仪

77
00:03:47,995 --> 0:03:50,264
它将为你提供系统负载的概述

78
00:03:50,330 --> 0:03:52,399
以及你的app CPU使用情况

79
00:03:53,300 --> 0:03:55,636
例如 用户交互式加载

80
00:03:55,702 --> 0:03:58,705
将记录给定时间内的所有活动线程

81
00:03:59,273 --> 0:04:00,107
在这种情况下

82
00:03:59,273 --> 0:04:00,107
在这种情况下

83
00:04:00,807 --> 0:04:02,176
你看到的橙色

84
00:04:02,643 --> 0:04:05,279
表示可运行的线程数量

85
00:04:05,445 --> 0:04:06,547
大于CPU核心数

86
00:04:06,813 --> 0:04:08,148
所以有一些意外情况

87
00:04:09,016 --> 0:04:11,318
这将提供系统的绝佳视图

88
00:04:12,753 --> 0:04:14,188
有几个很棒的谈话

89
00:04:14,388 --> 0:04:16,456
更深入地探讨这个工具

90
00:04:16,990 --> 0:04:18,225
请进一步关注这些

91
00:04:20,327 --> 0:04:22,863
下一个是Metal系统跟踪

92
00:04:23,096 --> 0:04:24,398
我们的GPU分析工具

93
00:04:24,932 --> 0:04:27,534
它提供了图形堆栈的绝佳视图

94
00:04:28,135 --> 0:04:29,870
从Metal框架

95
00:04:30,270 --> 0:04:31,338
一直到到显示

96
00:04:32,539 --> 0:04:33,740
特别注意

97
00:04:33,974 --> 0:04:36,844
我们要密切关注GPU硬件时间

98
00:04:37,344 --> 0:04:39,713
分为顶点 片段

99
00:04:40,113 --> 0:04:41,582
及计算 如果你的游戏用到

100
00:04:42,749 --> 0:04:44,384
还要注意显示监视器

101
00:04:44,451 --> 0:04:46,987
将是我们许多调查的起点

102
00:04:47,621 --> 0:04:49,756
我们将识别长框架或启动器

103
00:04:49,823 --> 0:04:51,725
我们将从那里开始一直调查下去

104
00:04:52,125 --> 0:04:53,861
所以这是一个非常自然的起点

105
00:04:56,530 --> 0:04:58,432
关于这个工具有很多信息

106
00:04:58,498 --> 0:05:00,367
因为它确实是一个非常强大的工具

107
00:04:58,498 --> 0:05:00,367
因为它确实是一个非常强大的工具

108
00:05:00,434 --> 0:05:02,302
我鼓励大家去熟悉它

109
00:05:03,303 --> 0:05:04,638
这几个演讲

110
00:05:04,705 --> 0:05:06,707
将为你提供一个很好的起点

111
00:05:08,141 --> 0:05:08,976
好

112
00:05:09,042 --> 0:05:10,077
接下来要谈的是

113
00:05:10,577 --> 0:05:13,347
我们今年推出了一个线程状态视图

114
00:05:14,314 --> 0:05:17,017
此视图显示游戏中每个线程的状态

115
00:05:17,484 --> 0:05:20,587
在这种情况下

116
00:05:21,321 --> 0:05:24,124
例如被抢占以橙色表示

117
00:05:24,458 --> 0:05:26,360
已屏蔽以灰色表示

118
00:05:27,561 --> 0:05:29,930
我们专门为你 游戏开发者

119
00:05:29,997 --> 0:05:31,231
设计了此视图

120
00:05:31,698 --> 0:05:36,036
因为我们知道

121
00:05:36,270 --> 0:05:38,138
我们希望这对你有所帮助

122
00:05:40,240 --> 0:05:43,443
我们还为每个CPU核心

123
00:05:44,278 --> 0:05:46,313
它将显示在该核心上运行的线程

124
00:05:46,680 --> 0:05:50,184
以及以颜色编码的该线程的优先级

125
00:05:51,552 --> 0:05:52,486
用这个工具

126
00:05:52,553 --> 0:05:55,622
你将能够一目了然地看到系统的状态

127
00:05:56,924 --> 0:05:57,758
还有…

128
00:05:58,225 --> 0:06:02,262
这是一个简短但相当宽泛的工具介绍

129
00:05:58,225 --> 0:06:02,262
这是一个简短但相当宽泛的工具介绍

130
00:06:02,329 --> 0:06:05,432
现在我们该转向实际的性能问题了

131
00:06:05,999 --> 0:06:08,569
第一个是关于帧速度

132
00:06:10,237 --> 0:06:12,005
让我们先看一下它

133
00:06:12,773 --> 0:06:16,476
为此 我们用了Fox II

134
00:06:16,677 --> 0:06:18,745
这将有助于我们更好地说明问题

135
00:06:20,647 --> 0:06:24,084
你能猜出哪个游戏生成得更快吗？

136
00:06:27,287 --> 0:06:28,121
嗯…

137
00:06:28,956 --> 0:06:30,657
你们中的一些人可能没有猜到

138
00:06:31,458 --> 0:06:35,429
左边的游戏试图以

139
00:06:35,963 --> 0:06:37,564
但它只达到40

140
00:06:38,198 --> 0:06:40,467
所以它不流畅而有抖动

141
00:06:40,901 --> 0:06:42,636
另一方面 右边的游戏

142
00:06:43,003 --> 0:06:45,105
它的目标是每秒30帧

143
00:06:45,372 --> 0:06:47,241
可以一贯地实现

144
00:06:47,841 --> 0:06:49,176
这就是为何它看起来更顺畅

145
00:06:50,944 --> 0:06:53,814
但这有点违反直觉

146
00:06:54,047 --> 0:06:57,417
为什么生成速度更快的游戏

147
00:06:58,218 --> 0:06:59,353
反倒看起来不太顺畅？

148
00:07:00,287 --> 0:07:02,856
嗯 这个问题被称为微型口吃

149
00:07:03,223 --> 0:07:04,758
或不一致帧速

150
00:07:06,059 --> 0:07:07,995
它出现于帧时间

151
00:07:08,529 --> 0:07:10,597
高于显示刷新间隔

152
00:07:11,265 --> 0:07:12,099
例如

153
00:07:13,033 --> 0:07:15,969
我们的游戏可能要25毫秒生成一帧

154
00:07:16,170 --> 0:07:17,538
或每秒40帧

155
00:07:17,938 --> 0:07:21,275
而显示屏可能会每16.6毫秒刷新

156
00:07:21,675 --> 0:07:23,143
或每秒60帧

157
00:07:23,577 --> 0:07:25,045
与我们刚看到的视频相同

158
00:07:25,345 --> 0:07:27,781
这会产生一些视觉上的不一致

159
00:07:29,650 --> 0:07:31,151
这种情况是怎么造成的？

160
00:07:31,718 --> 0:07:34,988
我们在这种情况下做了什么？

161
00:07:35,789 --> 0:07:36,623
嗯…

162
00:07:37,491 --> 0:07:38,592
我们没有做什么

163
00:07:38,659 --> 0:07:40,527
这就是问题所在

164
00:07:41,728 --> 0:07:43,163
生成帧后

165
00:07:43,597 --> 0:07:46,033
我们从显示链请求下一个可绘图

166
00:07:46,233 --> 0:07:47,701
一旦我们得到了可绘图

167
00:07:48,101 --> 0:07:50,871
我们完成了最后一步并立即展示

168
00:07:51,438 --> 0:07:53,473
我们明确地告诉了系统

169
00:07:54,041 --> 0:07:56,410
在下一个刷新间隔

170
00:07:56,643 --> 0:07:58,111
尽快呈现可绘图

171
00:07:58,412 --> 0:07:59,246
毕竟

172
00:07:59,413 --> 0:08:01,548
我们的目标是每秒60帧 对吗？

173
00:07:59,413 --> 0:08:01,548
我们的目标是每秒60帧 对吗？

174
00:08:03,350 --> 0:08:06,620
还有另一类问题会导致微型口吃

175
00:08:06,687 --> 0:08:11,425
有些游戏已经设定较低的帧率

176
00:08:12,392 --> 0:08:14,995
但我们也发现了很多这样的游戏

177
00:08:15,495 --> 0:08:18,298
在主线程或

178
00:08:18,365 --> 0:08:19,333
（勿用usleep()

179
00:08:19,399 --> 0:08:21,168
这在iOS中是一种很糟糕的做法

180
00:08:21,235 --> 0:08:22,936
所以请不要那样做

181
00:08:23,737 --> 0:08:25,706
耐心等我几分钟

182
00:08:25,772 --> 0:08:28,442
我会告诉你在iOS中的正确方法

183
00:08:30,577 --> 0:08:31,411
现在…

184
00:08:32,145 --> 0:08:36,350
让我们深入了解系统中发生了什么

185
00:08:36,416 --> 0:08:38,118
微型口吃是可见的

186
00:08:39,119 --> 0:08:40,888
在这种情况下 我们在这里看到

187
00:08:40,953 --> 0:08:42,956
生成中涉及的所有组件的时间表

188
00:08:43,924 --> 0:08:47,160
我们开始正常生成我们的游戏

189
00:08:47,761 --> 0:08:51,298
注意 这是一个三重缓冲区

190
00:08:51,532 --> 0:08:52,366
在这种情况下

191
00:08:52,699 --> 0:08:55,769
每个可绘图都用字母和颜色表示

192
00:08:56,670 --> 0:08:58,372
注意这里的前提

193
00:08:58,972 --> 0:09:00,474
生成可绘图B

194
00:08:58,972 --> 0:09:00,474
生成可绘图B

195
00:09:01,108 --> 0:09:03,911
历时超过一个显示刷新间隔

196
00:09:04,244 --> 0:09:05,913
即Vsyncs之间的时间

197
00:09:07,281 --> 0:09:10,651
在这种情况下

198
00:09:10,817 --> 0:09:14,121
显示刷新间隔之间为16.6毫秒

199
00:09:16,223 --> 0:09:18,525
所以 既然这是前提

200
00:09:18,592 --> 0:09:21,728
这意味着我们需要在显示屏上保持A

201
00:09:22,162 --> 0:09:25,532
为下一个间隔给出时间以便完成

202
00:09:26,633 --> 0:09:27,835
我们会这样做

203
00:09:27,901 --> 0:09:29,503
在那个时间段内

204
00:09:29,770 --> 0:09:32,739
B实际上会完成

205
00:09:33,574 --> 0:09:35,275
并准备好呈现

206
00:09:36,343 --> 0:09:38,979
但注意我们刚在这里隐藏了一个问题

207
00:09:39,646 --> 0:09:43,050
在此间隔期间

208
00:09:43,617 --> 0:09:45,419
我们已准备好立即呈现它

209
00:09:46,653 --> 0:09:49,723
所以从这个时间段开始

210
00:09:49,790 --> 0:09:51,091
我们会遇到不一致的帧速

211
00:09:51,592 --> 0:09:52,960
我们陷入了这种模式

212
00:09:53,460 --> 0:09:55,596
每隔一帧都不一致

213
00:09:56,330 --> 0:09:58,398
用户将看到微型口吃

214
00:10:00,601 --> 0:10:01,435
现在…

215
00:10:01,602 --> 0:10:05,472
现实世界中

216
00:10:06,006 --> 0:10:08,108
所以我们现在做的就是快速演示

217
00:10:08,442 --> 0:10:10,210
我将向你展示《塔洛斯法则》

218
00:10:10,277 --> 0:10:11,912
的仪器跟踪

219
00:10:12,412 --> 0:10:13,413
我们会用它来观察

220
00:10:13,480 --> 0:10:16,083
看能否识别现实世界中的微型口吃情况

221
00:10:25,225 --> 0:10:26,126
好

222
00:10:26,193 --> 0:10:27,194
我们在这里看到的

223
00:10:27,261 --> 0:10:29,963
与我之前展示的信息相同

224
00:10:30,330 --> 0:10:31,331
我们的游戏性能模板

225
00:10:31,398 --> 0:10:33,500
已在默认状态下将此信息捕获

226
00:10:34,134 --> 0:10:36,203
注意我谈到的所有相同的工具

227
00:10:36,270 --> 0:10:37,504
显示在左侧

228
00:10:39,473 --> 0:10:41,875
所有游戏线程都在中间

229
00:10:42,676 --> 0:10:46,480
尤其我们现在正在寻找微型口吃

230
00:10:47,314 --> 0:10:50,484
所以这很直观地会让我们看显示轨道

231
00:10:50,551 --> 0:10:54,488
因为微型口吃的定义

232
00:10:55,189 --> 0:10:57,157
在这种情况下

233
00:10:58,492 --> 0:11:01,428
注意 该显示轨道中有一些提示

234
00:10:58,492 --> 0:11:01,428
注意 该显示轨道中有一些提示

235
00:11:02,029 --> 0:11:05,165
我们添加了它们

236
00:11:05,933 --> 0:11:06,867
它们会告诉你

237
00:11:06,934 --> 0:11:08,569
当表面显示

238
00:11:08,635 --> 0:11:12,306
比正常生成时预期更长

239
00:11:13,040 --> 0:11:15,175
也许这是一个开始观察的好地方

240
00:11:15,242 --> 0:11:16,844
有一些堆砌

241
00:11:17,144 --> 0:11:18,278
让我们放大一个

242
00:11:19,112 --> 0:11:21,014
要放大 我们将长按选项键

243
00:11:21,281 --> 0:11:24,151
并将指针拖动到感兴趣的区域

244
00:11:25,719 --> 0:11:28,355
这种情况下

245
00:11:29,189 --> 0:11:31,959
已经很明显存在微型口吃

246
00:11:32,025 --> 0:11:35,729
我们可以看到

247
00:11:36,363 --> 0:11:37,664
所以在这种情况下 例如

248
00:11:37,731 --> 0:11:39,566
我们有50、33

249
00:11:40,133 --> 0:11:42,302
16 回到50

250
00:11:42,903 --> 0:11:43,937
再回到33

251
00:11:44,438 --> 0:11:45,973
所以当我们在仪器捕获中

252
00:11:46,640 --> 0:11:47,841
看到这种模式时

253
00:11:47,908 --> 0:11:51,011
这意味着存在微型口吃

254
00:11:51,778 --> 0:11:52,746
我们看看做法

255
00:11:53,146 --> 0:11:54,081
回到幻灯片

256
00:11:58,051 --> 0:11:58,886
好了…

257
00:11:59,453 --> 0:12:02,122
我们刚刚看到了这个问题

258
00:11:59,453 --> 0:12:02,122
我们刚刚看到了这个问题

259
00:12:02,389 --> 0:12:04,258
模式基本相同

260
00:12:04,691 --> 0:12:06,393
那我们该怎么做呢？

261
00:12:07,928 --> 0:12:11,498
最佳做实践

262
00:12:12,165 --> 0:12:13,800
所以在最小帧持续时间

263
00:12:14,401 --> 0:12:16,703
长于帧生成时间

264
00:12:17,938 --> 0:12:20,674
为此 有很多API可以帮助你

265
00:12:21,241 --> 0:12:24,111
例如 MTLDrawable

266
00:12:24,578 --> 0:12:27,781
一旦可绘图出现 会给你一个回调

267
00:12:27,848 --> 0:12:30,851
这样一旦微型口吃发生

268
00:12:31,919 --> 0:12:35,355
其它两个API会帮你解决这个问题

269
00:12:35,822 --> 0:12:39,793
它们将允许你明确控制帧速

270
00:12:40,394 --> 0:12:42,863
在这种情况下

271
00:12:43,163 --> 0:12:44,231
和atTime

272
00:12:45,165 --> 0:12:46,333
我们这里的目的

273
00:12:46,867 --> 0:12:50,704
是把帧的最小持续时间

274
00:12:51,839 --> 0:12:54,208
这正是我们要做的

275
00:12:55,943 --> 0:12:57,778
注意 当我们开始生成时

276
00:12:58,712 --> 0:13:00,714
我们从一开始就保持一致

277
00:12:58,712 --> 0:13:00,714
我们从一开始就保持一致

278
00:13:01,081 --> 0:13:04,952
我们的帧显示时间长于生成时间

279
00:13:05,686 --> 0:13:07,254
每一帧都是一致的

280
00:13:08,655 --> 0:13:11,358
用户的观感也会一致

281
00:13:12,159 --> 0:13:12,993
太好了

282
00:13:13,060 --> 0:13:15,462
另外 注意有副作用

283
00:13:15,729 --> 0:13:16,964
帧速率将降低

284
00:13:17,030 --> 0:13:20,367
我们从每秒40帧降到30帧

285
00:13:20,968 --> 0:13:23,570
所以这也给了我们额外的帧时间

286
00:13:25,138 --> 0:13:26,206
我们是怎么做到的？

287
00:13:27,307 --> 0:13:31,678
我们是如何修复帧速的？

288
00:13:31,745 --> 0:13:32,579
嗯…

289
00:13:33,180 --> 0:13:35,415
真的 只需几行代码

290
00:13:36,016 --> 0:13:37,818
我们的模式与以前相同

291
00:13:38,118 --> 0:13:39,152
我们生成场景

292
00:13:39,586 --> 0:13:40,687
得到了下一个可绘图

293
00:13:41,188 --> 0:13:42,289
我们做最后一步生成

294
00:13:43,090 --> 0:13:44,358
唯一的区别

295
00:13:44,691 --> 0:13:47,995
是我们指定帧的最小持续时间

296
00:13:48,428 --> 0:13:50,864
并以最短持续时间呈现

297
00:13:51,598 --> 0:13:52,599
就是这样

298
00:13:53,400 --> 0:13:56,470
这将允许我们设置帧的最小持续时间

299
00:13:56,537 --> 0:13:58,005
它们将保持一致

300
00:13:59,306 --> 0:14:01,408
这样做之后 你可能会想

301
00:13:59,306 --> 0:14:01,408
这样做之后 你可能会想

302
00:14:01,475 --> 0:14:04,778
那么 最长持续时间呢？

303
00:14:05,646 --> 0:14:08,582
我们的工作优先级概念如何体现？

304
00:14:08,649 --> 0:14:10,350
或一帧可以花多长时间？

305
00:14:11,185 --> 0:14:13,754
嗯 这是我们要谈的下一个问题

306
00:14:13,954 --> 0:14:14,855
线程优先级

307
00:14:16,390 --> 0:14:18,859
像之前一样 让我们先看一下它

308
00:14:19,593 --> 0:14:22,029
还是用Fox II演示的修改版本

309
00:14:23,497 --> 0:14:25,232
你可能在想 而你会是对的

310
00:14:25,299 --> 0:14:27,668
有很多事情可能导致这类的口吃

311
00:14:27,734 --> 0:14:31,205
也许你正在作资源加载或着色器编译

312
00:14:32,072 --> 0:14:34,675
今天我们将重点关注更为根本

313
00:14:35,209 --> 0:14:37,411
但也是非常常见的类型的口吃

314
00:14:38,912 --> 0:14:40,447
即由线程停滞引起的口吃

315
00:14:42,316 --> 0:14:46,653
如果工作优先级未很好地传达给系统

316
00:14:47,054 --> 0:14:48,989
你的游戏可能有意想不到的停滞

317
00:14:50,123 --> 0:14:53,427
除了生成游戏之外

318
00:14:54,928 --> 0:14:57,164
线程优先级用于保证

319
00:14:57,364 --> 0:14:59,533
整个系统的服务质量

320
00:15:00,667 --> 0:15:02,503
所以如果一个线程做了很多工作

321
00:15:02,970 --> 0:15:05,339
其优先级将随时间的推移而降低

322
00:15:05,772 --> 0:15:07,441
以让其它线程有机会运行

323
00:15:08,242 --> 0:15:10,511
这就是优先级衰减的概念

324
00:15:11,979 --> 0:15:13,847
另外 在我身后的幻灯片上可看到

325
00:15:14,615 --> 0:15:15,682
优先级倒置

326
00:15:16,116 --> 0:15:19,887
这是另一类

327
00:15:20,521 --> 0:15:23,257
当生成线程依赖于来自同一引擎的

328
00:15:23,323 --> 0:15:27,194
较低优先级的工作线程以完成工作时

329
00:15:28,028 --> 0:15:30,564
在这种情况下 发生优先级倒置

330
00:15:31,298 --> 0:15:32,466
我们看看它是怎么样的

331
00:15:32,533 --> 0:15:34,401
与我们之前看到的时间表相同

332
00:15:35,802 --> 0:15:36,770
在这种情况下

333
00:15:36,837 --> 0:15:38,906
我们开始以每秒30帧的速度生成

334
00:15:39,273 --> 0:15:40,107
很轻松

335
00:15:41,041 --> 0:15:43,844
但是 有一些背景工作

336
00:15:44,678 --> 0:15:47,347
iOS做很多东西

337
00:15:48,715 --> 0:15:49,950
若我们的线程配置不正确

338
00:15:50,017 --> 0:15:52,286
那问题就来了

339
00:15:53,487 --> 0:15:55,556
你可能会被该后台工作抢占

340
00:15:55,989 --> 0:15:59,760
你可能无法完成GPU上

341
00:16:01,128 --> 0:16:04,498
并且没有帧的最大持续时间的概念

342
00:16:05,165 --> 0:16:08,068
所以帧生成可能会持续数百毫秒

343
00:16:08,735 --> 0:16:10,537
用户会看到口吃

344
00:16:12,673 --> 0:16:14,675
这就是它背后的理论

345
00:16:14,741 --> 0:16:19,213
在实践中 它的发生遵循相同的模式

346
00:16:19,847 --> 0:16:20,981
我们再作一个演示

347
00:16:21,048 --> 0:16:24,284
我将向你展示另一个仪器捕捉的

348
00:16:24,351 --> 0:16:27,087
来看看如何识别此问题

349
00:16:37,998 --> 0:16:41,101
在这种情况下 你看到的是

350
00:16:41,168 --> 0:16:43,604
使用游戏性能模板作的信息捕捉

351
00:16:44,271 --> 0:16:46,073
但这一次 我们已经放大了

352
00:16:46,373 --> 0:16:48,041
进入我们感兴趣的帧

353
00:16:48,509 --> 0:16:50,110
这是一个很长的帧

354
00:16:51,378 --> 0:16:54,081
它的持续时间为233毫秒

355
00:16:54,147 --> 0:16:57,017
所以我们应该调查这个很典型的口吃

356
00:16:58,619 --> 0:17:00,454
一眼看去

357
00:16:58,619 --> 0:17:00,454
一眼看去

358
00:17:00,521 --> 0:17:04,458
我们已经知道GPU似乎未做什么

359
00:17:04,958 --> 0:17:06,425
在此期间它处于闲置状态

360
00:17:07,094 --> 0:17:09,329
这意味着我们没有喂饱它

361
00:17:10,130 --> 0:17:14,134
现在 我们可以看一下CPU

362
00:17:14,800 --> 0:17:17,137
CPU似乎相当忙

363
00:17:17,704 --> 0:17:18,771
就像它们真的……

364
00:17:19,540 --> 0:17:20,874
所有这些看起来都很稳固

365
00:17:22,476 --> 0:17:28,048
注意 你在此处看到的是我们的

366
00:17:28,315 --> 0:17:30,284
看上去没有在运行

367
00:17:31,318 --> 0:17:32,753
为什么我们的游戏没有运行

368
00:17:33,587 --> 0:17:36,190
这怎么会导致口吃？为什么？

369
00:17:36,924 --> 0:17:37,758
嗯…

370
00:17:38,659 --> 0:17:41,094
我们可以切换到我提到的新视图

371
00:17:41,161 --> 0:17:42,496
新的线程状态视图

372
00:17:43,363 --> 0:17:47,034
要做到这个 你进入app的图标

373
00:17:47,768 --> 0:17:49,837
并点击此处的按钮

374
00:17:50,604 --> 0:17:52,406
这将拉出轨道显示

375
00:17:53,640 --> 0:17:55,809
在这种情况下

376
00:17:57,711 --> 0:18:01,481
这有望帮助你看到这里有问题

377
00:17:57,711 --> 0:18:01,481
这有望帮助你看到这里有问题

378
00:18:02,349 --> 0:18:05,953
它以橙色突出显示 这已经告诉我们

379
00:18:06,019 --> 0:18:09,756
该线程已被抢占192毫秒

380
00:18:10,490 --> 0:18:13,493
这就是问题所在 生成线程未运行

381
00:18:13,894 --> 0:18:15,062
有些东西先占用了

382
00:18:16,263 --> 0:18:17,331
如果你想了解更多

383
00:18:18,232 --> 0:18:20,167
你可以在底部展开信息

384
00:18:20,234 --> 0:18:22,302
也将包含线程叙述

385
00:18:23,804 --> 0:18:26,907
并且通过单击被抢先的线程

386
00:18:27,741 --> 0:18:28,909
你会看到这里

387
00:18:29,676 --> 0:18:31,278
对正在发生的事情的解释

388
00:18:31,612 --> 0:18:32,446
在这里

389
00:18:33,046 --> 0:18:35,749
你的生成线程优先级为26

390
00:18:36,016 --> 0:18:36,917
非常低

391
00:18:36,984 --> 0:18:38,552
低于后台线程优先级

392
00:18:39,486 --> 0:18:41,088
因为App Store正更新

393
00:18:42,122 --> 0:18:43,657
这是不应该的

394
00:18:44,024 --> 0:18:47,060
我们想告诉系统

395
00:18:47,494 --> 0:18:49,730
在那个特定的时刻 我们的游戏

396
00:18:49,796 --> 0:18:51,131
比App Store更新更重要

397
00:18:51,765 --> 0:18:54,134
让我们回到幻灯片

398
00:19:02,276 --> 0:19:05,345
最好的做法是配置你的生成线程

399
00:19:06,213 --> 0:19:10,017
建议将生成线程优先级固定为45

400
00:19:11,118 --> 0:19:15,889
注意 在iOS和macOS中

401
00:19:16,823 --> 0:19:21,395
因此优先级31高于优先级4

402
00:19:22,162 --> 0:19:25,999
此外 我们需要选择退出

403
00:19:26,333 --> 0:19:30,337
以防止优先级衰减

404
00:19:31,738 --> 0:19:34,341
我们看看配置良好的

405
00:19:36,043 --> 0:19:39,046
现在我们按照刚才所说的来配置

406
00:19:39,847 --> 0:19:41,181
我们开始正常生成

407
00:19:42,649 --> 0:19:44,751
我们还有一些背景工作在运行

408
00:19:44,818 --> 0:19:46,186
否则这不公平

409
00:19:46,787 --> 0:19:49,389
而且 这个后台工作

410
00:19:49,456 --> 0:19:50,791
正如我们在演示中看到的

411
00:19:51,692 --> 0:19:56,563
但请注意一个又一个Vsync后

412
00:19:57,197 --> 0:20:01,401
我们正在抢占CPU的

413
00:19:57,197 --> 0:20:01,401
我们正在抢占CPU的

414
00:20:02,603 --> 0:20:04,872
用户看不到口吃

415
00:20:05,339 --> 0:20:08,642
你的游戏可以每秒30个固帧运行

416
00:20:09,243 --> 0:20:11,211
即使系统负载很重

417
00:20:12,012 --> 0:20:14,815
这在技术上很棒 这就是我们要做的

418
00:20:15,182 --> 0:20:18,418
让我们看看如何通过

419
00:20:19,953 --> 0:20:22,322
确实是一点代码

420
00:20:22,556 --> 0:20:23,991
只有几行

421
00:20:24,791 --> 0:20:25,726
在这种情况下

422
00:20:26,593 --> 0:20:28,929
它只是配置pthread属性

423
00:20:29,229 --> 0:20:31,031
在创建pthread之前

424
00:20:32,165 --> 0:20:36,904
我们需要选择退出服务质量

425
00:20:37,938 --> 0:20:40,741
就是这样 现在我们

426
00:20:41,074 --> 0:20:42,409
它会正常工作

427
00:20:43,110 --> 0:20:45,012
这很简单同时技术上很了不起

428
00:20:47,181 --> 0:20:48,649
不是那么简单的

429
00:20:49,650 --> 0:20:51,285
是我们要讲的下一个问题

430
00:20:52,586 --> 0:20:54,922
处理多个热状态的问题

431
00:20:56,256 --> 0:20:57,724
目的是明确的

432
00:20:59,092 --> 0:21:00,827
为持续性能设计

433
00:20:59,092 --> 0:21:00,827
为持续性能设计

434
00:21:02,930 --> 0:21:04,932
并处理偶尔出现的热问题

435
00:21:05,666 --> 0:21:07,100
我们看看我们如何来做

436
00:21:08,602 --> 0:21:12,639
iOS设备可提供前所未有的电量

437
00:21:12,806 --> 0:21:15,075
但是在一个非常小的外形中

438
00:21:15,609 --> 0:21:18,378
因此 随着更多的app

439
00:21:18,946 --> 0:21:21,582
系统可能会开始采取措施

440
00:21:21,648 --> 0:21:24,084
以保持低温和反应速度

441
00:21:25,118 --> 0:21:29,423
此外 用户可能已启用低功耗模式

442
00:21:29,756 --> 0:21:32,192
会产生相似的效果

443
00:21:34,561 --> 0:21:36,763
好 所以最好的做法

444
00:21:37,130 --> 0:21:41,034
是将工作负载调整为系统状态

445
00:21:42,269 --> 0:21:45,305
你应该监控系统并相应调整工作负载

446
00:21:45,873 --> 0:21:48,308
iOS有许多API可以有帮助

447
00:21:48,909 --> 0:21:52,379
例如

448
00:21:52,746 --> 0:21:55,215
来查询或注册通知

449
00:21:55,516 --> 0:21:57,251
设备热状态变化

450
00:21:57,851 --> 0:22:02,155
检查低功耗模式的方式类似

451
00:21:57,851 --> 0:22:02,155
检查低功耗模式的方式类似

452
00:22:02,923 --> 0:22:06,426
另外 请考虑查询

453
00:22:06,493 --> 0:22:07,928
GPU启动/GPU结束时间

454
00:22:08,395 --> 0:22:12,432
以了解系统负载如何影响GPU时间

455
00:22:14,434 --> 0:22:17,070
我们看看如何用一个简单的

456
00:22:18,372 --> 0:22:20,407
这直接来自我们的最佳实践

457
00:22:21,175 --> 0:22:24,478
它的核心是一个

458
00:22:24,878 --> 0:22:27,281
每个case对应一个热状态

459
00:22:27,681 --> 0:22:28,649
这里有名义上的

460
00:22:30,083 --> 0:22:30,918
一般

461
00:22:32,186 --> 0:22:33,020
重要

462
00:22:33,754 --> 0:22:34,588
和关键

463
00:22:37,424 --> 0:22:39,359
这一切都很好

464
00:22:39,426 --> 0:22:41,862
现在我们知道我们处于热状态

465
00:22:42,629 --> 0:22:45,165
并且这些指令告诉我们要做些什么

466
00:22:45,999 --> 0:22:49,903
我们怎样才能真正帮助

467
00:22:50,971 --> 0:22:51,805
嗯…

468
00:22:52,940 --> 0:22:56,310
我可以给一些建议

469
00:22:56,376 --> 0:22:58,478
来决定要做出什么样的妥协

470
00:22:58,979 --> 0:23:00,547
以帮助系统

471
00:22:58,979 --> 0:23:00,547
以帮助系统

472
00:23:01,215 --> 0:23:05,252
你知道什么行动最适合你的游戏

473
00:23:06,520 --> 0:23:10,390
我的一些建议是针对帧速率

474
00:23:10,457 --> 0:23:12,960
以在整个游戏会话保持

475
00:23:13,627 --> 0:23:16,697
例如

476
00:23:16,930 --> 0:23:20,067
维持10分钟或更长

477
00:23:21,435 --> 0:23:24,972
调整GPU工作也非常有用

478
00:23:25,939 --> 0:23:28,041
例如 考虑降低

479
00:23:28,108 --> 0:23:29,810
中间生成目标的分辨率

480
00:23:30,777 --> 0:23:32,813
或者简化阴影图

481
00:23:33,380 --> 0:23:34,648
加载更简单的资产

482
00:23:34,982 --> 0:23:37,951
甚至完全删除一些后期处理

483
00:23:38,585 --> 0:23:40,921
什么办法最适合你的游戏

484
00:23:41,722 --> 0:23:43,056
你就应该采取什么

485
00:23:44,892 --> 0:23:48,028
而且这把我们带到我们的下一个议题

486
00:23:49,129 --> 0:23:51,698
关于处理不必要的GPU工作

487
00:23:51,899 --> 0:23:54,835
为此 请欢迎我的同事Ohad上台

488
00:23:54,902 --> 0:23:56,336
他会都告诉你

489
00:23:56,403 --> 0:23:59,773
（不必要的GPU工作）

490
00:24:00,574 --> 0:24:01,508
谢谢 Guillem

491
00:24:04,845 --> 0:24:05,679
大家好

492
00:24:06,213 --> 0:24:07,814
我叫Ohad

493
00:24:07,881 --> 0:24:09,883
Apple的游戏技术团队成员

494
00:24:10,751 --> 0:24:11,985
在之前的幻灯片中

495
00:24:12,519 --> 0:24:16,089
Guillem展示了

496
00:24:17,157 --> 0:24:21,728
响应低功耗模式或不同的热状态等

497
00:24:22,229 --> 0:24:24,631
将要求你调整GPU工作负载

498
00:24:24,698 --> 0:24:26,667
以保持整个游戏阶段

499
00:24:26,733 --> 0:24:28,335
一致的帧速

500
00:24:29,303 --> 0:24:33,373
然而 对于许多开发人员来说

501
00:24:33,540 --> 0:24:35,709
藏在游戏引擎的窗帘后面

502
00:24:36,343 --> 0:24:38,545
今天 我们来拉开这个窗帘

503
00:24:40,480 --> 0:24:43,283
浪费GPU时间是一个很常见的问题

504
00:24:43,584 --> 0:24:45,719
也经常被忽视

505
00:24:46,119 --> 0:24:47,487
但我希望你记住这一点

506
00:24:47,688 --> 0:24:51,258
技术上出色的游戏

507
00:24:52,259 --> 0:24:57,331
它们也是系统的好公民

508
00:24:57,898 --> 0:24:59,299
所有流行的游戏引擎

509
00:24:59,366 --> 0:25:01,702
都提供了一系列最佳实践

510
00:24:59,366 --> 0:25:01,702
都提供了一系列最佳实践

511
00:25:02,102 --> 0:25:03,136
我们不会介绍这些

512
00:25:03,370 --> 0:25:07,107
相反 我们将专注于

513
00:25:08,041 --> 0:25:11,078
正如我们今天已经对CPU多次做的

514
00:25:11,712 --> 0:25:15,449
这最佳实践是对GPU进行分析

515
00:25:17,217 --> 0:25:19,753
我们GPU的强大功能可以隐藏许多

516
00:25:19,820 --> 0:25:22,089
内容或算法上的效率

517
00:25:22,689 --> 0:25:26,527
你需要对工作量计时

518
00:25:26,593 --> 0:25:28,495
你启用的每种生成技术

519
00:25:29,096 --> 0:25:33,100
并只保留那些

520
00:25:34,268 --> 0:25:36,403
但是你怎么发现效率问题？

521
00:25:37,070 --> 0:25:40,474
你如何确定过程的

522
00:25:40,707 --> 0:25:43,544
这当然让我们回到了工具

523
00:25:44,878 --> 0:25:47,414
与往常一样 你的第一站

524
00:25:48,015 --> 0:25:49,983
我们在这里看看Metal系统跟踪

525
00:25:50,517 --> 0:25:54,154
它将为你提供精确的时间：

526
00:25:54,354 --> 0:25:56,023
顶点、片段及计算工作

527
00:25:57,224 --> 0:26:00,394
但是测量GPU时间

528
00:25:57,224 --> 0:26:00,394
但是测量GPU时间

529
00:26:00,894 --> 0:26:05,599
接下来 你想要真正了解

530
00:26:07,000 --> 0:26:11,071
为此我们今年为Metal系统跟踪

531
00:26:11,371 --> 0:26:12,806
这是依赖关系图

532
00:26:15,175 --> 0:26:18,912
依赖关系图是一个单帧的故事

533
00:26:20,080 --> 0:26:21,815
它由节点和边组成

534
00:26:21,882 --> 0:26:24,651
每一个都讲述了故事的不同部分

535
00:26:25,719 --> 0:26:29,590
边表示步与步之间的依赖关系

536
00:26:29,857 --> 0:26:31,525
当你从上到下跟踪它们时

537
00:26:31,758 --> 0:26:34,528
你将看到每一步

538
00:26:34,761 --> 0:26:37,598
以及它们如何协同工作来创建框架

539
00:26:39,032 --> 0:26:42,703
另一方面 节点是单个步的故事

540
00:26:44,271 --> 0:26:46,139
它们由三个主要组成部分组成

541
00:26:46,440 --> 0:26:50,310
首先 title元素将给出步名称

542
00:26:50,711 --> 0:26:52,346
我想确实强调这一点

543
00:26:52,613 --> 0:26:53,714
命名标记一切

544
00:26:54,114 --> 0:26:56,316
这不仅有助于

545
00:26:56,383 --> 0:26:58,485
也有助于我们的整个工具套件

546
00:26:59,586 --> 0:27:00,420
其次

547
00:26:59,586 --> 0:27:00,420
其次

548
00:27:00,487 --> 0:27:04,124
它可以让你快速了解

549
00:27:04,958 --> 0:27:07,127
生成、位块传输还是计算

550
00:27:07,461 --> 0:27:09,997
这里 从图标中

551
00:27:11,465 --> 0:27:13,567
接下来 这里有一个统计列表

552
00:27:13,634 --> 0:27:15,736
描述了此步中正在完成的工作

553
00:27:16,837 --> 0:27:20,407
最后 在底部 在此步中写入的

554
00:27:20,474 --> 0:27:22,743
所有资源的列表

555
00:27:22,943 --> 0:27:24,778
并且每个资源都带标签

556
00:27:25,212 --> 0:27:27,281
允许预览的缩略图

557
00:27:27,681 --> 0:27:31,885
以及具体描述每个资源的信息列表

558
00:27:33,086 --> 0:27:34,188
所有这些一起

559
00:27:34,454 --> 0:27:37,191
可让你真正了解每一步

560
00:27:37,791 --> 0:27:40,227
好的 现在我们知道如何读图表了

561
00:27:40,294 --> 0:27:43,463
让我们跳转到一个演示

562
00:27:52,940 --> 0:27:56,743
我在我的机器上运行了

563
00:27:57,077 --> 0:27:58,345
它是在SceneKit中构建的

564
00:27:58,612 --> 0:28:01,148
允许我添加各种很棒的效果

565
00:27:58,612 --> 0:28:01,148
允许我添加各种很棒的效果

566
00:28:02,349 --> 0:28:05,352
如你所见 我有瀑落式阴影图

567
00:28:06,420 --> 0:28:09,823
高光 景深 所有这些合在一起

568
00:28:09,990 --> 0:28:11,792
创建一个精美生成的场景

569
00:28:12,526 --> 0:28:15,329
我们用依赖关系查看器

570
00:28:15,929 --> 0:28:18,765
首先 我们将转到Xcode

571
00:28:18,832 --> 0:28:21,001
用底部的

572
00:28:21,535 --> 0:28:23,403
我们选择左边的主要步

573
00:28:25,906 --> 0:28:27,641
并切换到自动模式

574
00:28:27,708 --> 0:28:30,043
我们右边出现助手

575
00:28:30,344 --> 0:28:34,248
现在 注意我在调试导航器中

576
00:28:34,314 --> 0:28:38,185
也是被选的 并且在主视图中心

577
00:28:38,519 --> 0:28:39,987
这是一条双向的街

578
00:28:40,888 --> 0:28:43,624
当我们与图表进行交互时

579
00:28:43,690 --> 0:28:48,929
选择不同的步或纹理甚至缓冲区

580
00:28:49,730 --> 0:28:52,499
左侧的导航器和右侧的助手

581
00:28:52,733 --> 0:28:54,601
都会更新以显示你的选择

582
00:28:55,302 --> 0:28:58,238
这是帧导航的一种非常棒的方式

583
00:29:01,108 --> 0:29:03,710
现在当我缩小时

584
00:29:03,777 --> 0:29:06,280
是统计隐藏了 焦点消失了

585
00:29:06,346 --> 0:29:09,550
视图从单独步转到了整个帧

586
00:29:10,217 --> 0:29:11,785
我可以缩小更多

587
00:29:12,186 --> 0:29:15,656
可以看到我整个帧的鸟瞰图

588
00:29:17,357 --> 0:29:19,359
现在注意真正酷的是

589
00:29:19,560 --> 0:29:22,963
由于依赖关系驱动图的互联

590
00:29:24,364 --> 0:29:27,668
每个逻辑工作在空间中组合在一起

591
00:29:28,335 --> 0:29:29,870
让我们放大

592
00:29:30,437 --> 0:29:33,540
这里我有一个工作分支

593
00:29:35,642 --> 0:29:38,045
在左边 我可以看到三步

594
00:29:39,112 --> 0:29:40,547
生成阴影

595
00:29:41,114 --> 0:29:42,516
这太好了

596
00:29:42,749 --> 0:29:46,086
因为我不只是了解整个帧的状态

597
00:29:46,153 --> 0:29:49,122
还有这两层之间的联系

598
00:29:49,756 --> 0:29:52,593
每个生成技术是怎么构建起来的

599
00:29:53,293 --> 0:29:56,196
而当你使用游戏引擎打开它们时

600
00:29:56,263 --> 0:29:58,365
这并非总是显而易见的

601
00:29:58,432 --> 0:30:01,301
例如 用我的阴影图 我可能不知道

602
00:29:58,432 --> 0:30:01,301
例如 用我的阴影图 我可能不知道

603
00:30:01,602 --> 0:30:04,771
每个级联都需要自己的步

604
00:30:05,572 --> 0:30:07,674
如果我单独考虑这些中的每一个

605
00:30:08,108 --> 0:30:09,543
这不会很明显

606
00:30:09,710 --> 0:30:12,212
但现在我看到

607
00:30:13,447 --> 0:30:17,317
我在调整GPU工作负载作妥协时

608
00:30:17,551 --> 0:30:21,188
这个认识帮我做出明智决策

609
00:30:22,890 --> 0:30:24,358
这就是依赖关系查看器

610
00:30:24,758 --> 0:30:26,193
我切换回幻灯片

611
00:30:26,260 --> 0:30:29,563
欢迎Guillem回到台上

612
00:30:29,630 --> 0:30:30,464
谢谢

613
00:30:36,270 --> 0:30:37,938
谢谢 这是一个出色的演示

614
00:30:38,372 --> 0:30:39,206
谢谢

615
00:30:43,911 --> 0:30:44,745
酷

616
00:30:44,811 --> 0:30:46,313
Ohad刚刚向我们展示过

617
00:30:46,547 --> 0:30:48,782
通过依赖关系查看器查看图帧的方式

618
00:30:50,117 --> 0:30:54,054
而且 你可以检查GPU工作负载

619
00:30:54,721 --> 0:30:59,493
例如 我们通常可能

620
00:30:59,560 --> 0:31:00,594
像这个

621
00:30:59,560 --> 0:31:00,594
像这个

622
00:31:01,728 --> 0:31:03,263
演变到一个非常复杂的过程

623
00:31:03,897 --> 0:31:05,866
经过后期处理

624
00:31:06,166 --> 0:31:08,368
HDR中的多个阴影图

625
00:31:09,703 --> 0:31:12,372
所有这些的实现方法可以是

626
00:31:12,539 --> 0:31:15,976
在你的游戏引擎的相机对象中

627
00:31:17,244 --> 0:31:20,614
你会发现这些更改的代码复杂性很小

628
00:31:21,215 --> 0:31:25,485
但生成复杂性可能增加了十倍

629
00:31:26,820 --> 0:31:29,923
这就把我们带回到开头

630
00:31:29,990 --> 0:31:31,391
就在我们开篇的地方

631
00:31:32,793 --> 0:31:33,627
分析资料

632
00:31:34,361 --> 0:31:38,065
了解游戏的功能非常重要

633
00:31:39,399 --> 0:31:42,970
你花了数万小时开发游戏

634
00:31:43,437 --> 0:31:46,573
你应该考虑花一些时间进行分析

635
00:31:47,608 --> 0:31:49,309
我们今天看到的一切

636
00:31:50,043 --> 0:31:51,612
可以在几分钟内找到

637
00:31:52,646 --> 0:31:53,514
最好的部分是什么？

638
00:31:53,847 --> 0:31:55,916
你无需知道自己在寻找什么

639
00:31:56,083 --> 0:31:58,719
仅仅记录口吃 查到长帧

640
00:31:59,152 --> 0:32:01,188
并从那里开始一直继续

641
00:31:59,152 --> 0:32:01,188
并从那里开始一直继续

642
00:32:01,588 --> 0:32:02,623
就这么简单

643
00:32:03,090 --> 0:32:05,325
这个工具将为你提供所需的所有信息

644
00:32:05,592 --> 0:32:06,760
来识别问题

645
00:32:07,594 --> 0:32:09,029
但你需要使用该工具

646
00:32:10,564 --> 0:32:14,067
这就是关键

647
00:32:14,535 --> 0:32:16,803
我们看到了一堆常见的陷阱

648
00:32:17,171 --> 0:32:18,772
和一些最佳的解决办法

649
00:32:19,806 --> 0:32:20,707
所有这些问题

650
00:32:21,508 --> 0:32:22,943
可以通过分析找到

651
00:32:23,177 --> 0:32:24,311
我们就是这样找到问题

652
00:32:24,378 --> 0:32:27,214
我们分析了大量游戏

653
00:32:27,281 --> 0:32:28,849
并决定把它们放在一起

654
00:32:29,917 --> 0:32:32,920
如果你有权访问引擎源代码

655
00:32:33,687 --> 0:32:37,324
确保帧速度和线程优先级都配置好

656
00:32:37,824 --> 0:32:39,726
这只是几行代码

657
00:32:40,694 --> 0:32:41,562
但无论如何

658
00:32:41,895 --> 0:32:44,364
你的游戏应该始终适应热量需求

659
00:32:44,765 --> 0:32:47,601
并且不要提交不必要的GPU工作

660
00:32:48,435 --> 0:32:51,338
确保遵循所有这些最佳实践

661
00:32:51,972 --> 0:32:54,408
你也将开发技术上令人敬畏的游戏

662
00:32:54,741 --> 0:32:56,210
这就是我们这个谈话的宗旨

663
00:32:57,344 --> 0:32:58,478
更多信息

664
00:32:58,979 --> 0:33:01,515
中午12点会设一个实验室

665
00:32:58,979 --> 0:33:01,515
中午12点会设一个实验室

666
00:33:01,682 --> 0:33:03,083
我们会在那儿 我会在那儿

667
00:33:03,150 --> 0:33:05,719
如果你在这次会议之后有任何问题

668
00:33:05,786 --> 0:33:07,321
我们非常乐意回答

669
00:33:07,955 --> 0:33:11,825
或者也许你只是想坐下来

670
00:33:12,659 --> 0:33:15,996
此次WWDC还有两场精彩的演讲

671
00:33:16,063 --> 0:33:18,966
关于游戏开发者的Metal

672
00:33:21,068 --> 0:33:23,270
非常感谢 祝你们今天愉快

673
00:33:23,770 --> 0:33:24,671
度过愉快的一天
