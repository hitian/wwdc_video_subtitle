1
00:00:16,917 --> 00:00:21,922
（订阅工程实现最佳实践）

2
00:00:21,989 --> 00:00:22,990
（演讲705）

3
00:00:23,056 --> 00:00:24,191
大家下午好

4
00:00:30,364 --> 00:00:32,332
我叫Pete Hare

5
00:00:32,399 --> 00:00:34,168
一名工程经理

6
00:00:34,234 --> 00:00:36,870
我们在这里讨论构建你的app

7
00:00:36,937 --> 00:00:39,806
和服务器基础设施的最佳方式

8
00:00:40,541 --> 00:00:42,509
今天我将在这里讨论几个主题

9
00:00:42,709 --> 00:00:44,111
首先 我们将讨论构建

10
00:00:44,178 --> 00:00:46,180
你的app和服务器体系结构

11
00:00:47,080 --> 00:00:49,249
我们还会介绍一些有助于提升

12
00:00:49,316 --> 00:00:51,118
用户app内体验的窍门和技巧

13
00:00:52,152 --> 00:00:53,854
我的同事Michael会谈下

14
00:00:53,921 --> 00:00:55,923
如何减少订户流失

15
00:00:56,590 --> 00:00:58,492
最后我们将会宣布一些

16
00:00:58,559 --> 00:01:01,094
你可以使用的分析和报告工具

17
00:00:58,559 --> 00:01:01,094
你可以使用的分析和报告工具

18
00:01:02,162 --> 00:01:03,530
但首先让我们谈一谈

19
00:01:03,597 --> 00:01:05,732
如何构建你的app

20
00:01:05,799 --> 00:01:07,000
（设备和服务器架构）

21
00:01:07,334 --> 00:01:09,503
我们从一个简单的问题开始

22
00:01:10,270 --> 00:01:11,505
什么是订阅？

23
00:01:12,639 --> 00:01:15,175
订阅就是让用户

24
00:01:15,242 --> 00:01:18,512
通过周期性的向你付费

25
00:01:19,146 --> 00:01:20,914
当你从工程层面看它时

26
00:01:20,981 --> 00:01:23,951
订阅实际上只是一组重复交易

27
00:01:24,284 --> 00:01:27,254
其中每个将解锁某个订阅周期

28
00:01:28,555 --> 00:01:30,324
若想在你的app中使用订阅功能

29
00:01:30,624 --> 00:01:32,492
作为一名开发人员

30
00:01:32,559 --> 00:01:34,962
来处理这些交易

31
00:01:35,395 --> 00:01:36,496
我们看看其中每一步

32
00:01:36,563 --> 00:01:40,734
首先 它始于你的app

33
00:01:42,002 --> 00:01:44,037
你的app收到交易后 你需要继续

34
00:01:44,104 --> 00:01:46,440
验证它是一笔真实的交易

35
00:01:46,507 --> 00:01:48,308
即资金已经转移了

36
00:01:49,443 --> 00:01:53,614
然后你就可以更新和维护

37
00:01:53,680 --> 00:01:55,782
以便他们能够持续访问你的服务

38
00:01:56,683 --> 00:01:58,585
让我们更详细地介绍其中每一个步骤

39
00:01:58,652 --> 00:02:02,256
首先 我们谈谈在你的app中

40
00:01:58,652 --> 00:02:02,256
首先 我们谈谈在你的app中

41
00:02:04,024 --> 00:02:06,426
现在无论是首次购买订阅

42
00:02:06,493 --> 00:02:08,862
还是续订交易

43
00:02:09,395 --> 00:02:11,932
你的app均已被设为

44
00:02:11,999 --> 00:02:14,101
来处理订阅和交易

45
00:02:14,735 --> 00:02:17,237
当你用StoreKit处理交易时

46
00:02:17,304 --> 00:02:21,208
App Store将在后台

47
00:02:21,642 --> 00:02:25,345
无论何时只要有交易发生

48
00:02:25,412 --> 00:02:27,214
SKPaymentTransactionsObserver

49
00:02:27,281 --> 00:02:28,515
来通知你的app

50
00:02:30,083 --> 00:02:33,720
这个交易观察者对象

51
00:02:33,921 --> 00:02:35,689
app内购买的核心部分

52
00:02:35,756 --> 00:02:38,392
它只是StoreKit中

53
00:02:38,458 --> 00:02:39,860
你可将其设置在任何对象上

54
00:02:40,260 --> 00:02:42,963
这例子中 我们将它

55
00:02:43,797 --> 00:02:46,433
但最重要的是你需要

56
00:02:46,500 --> 00:02:50,404
尽可能早的添加一个交易观察者

57
00:02:51,471 --> 00:02:54,875
一旦你在默认支付队列中

58
00:02:54,942 --> 00:02:56,743
你就准备好开始接收

59
00:02:56,810 --> 00:02:58,245
后台所发生的交易了

60
00:02:59,880 --> 00:03:01,682
你在交易观察者中的

61
00:02:59,880 --> 00:03:01,682
你在交易观察者中的

62
00:03:01,748 --> 00:03:04,551
一个名为updatedTransactions的

63
00:03:04,952 --> 00:03:07,487
StoreKit会通知你的app

64
00:03:07,554 --> 00:03:09,690
你要处理的一组交易

65
00:03:09,957 --> 00:03:11,558
它们可以各种不同的状态出现

66
00:03:11,625 --> 00:03:13,794
我们不打算在这次演讲中

67
00:03:13,861 --> 00:03:16,563
但请注意已购买状态的交易

68
00:03:17,231 --> 00:03:19,733
这是StoreKit

69
00:03:19,800 --> 00:03:22,035
这笔交易已准备好进行验证和解锁

70
00:03:24,638 --> 00:03:26,206
一旦你有一笔处于已购买状态的交易

71
00:03:26,273 --> 00:03:28,442
你已准备好进行下一步

72
00:03:28,509 --> 00:03:30,310
即验证它是一个真实的交易

73
00:03:32,412 --> 00:03:34,248
所以当涉及到检查真实性的时候

74
00:03:34,314 --> 00:03:36,783
你怎么知道钱真的已经转手了呢？

75
00:03:37,985 --> 00:03:39,686
你可用一种称为

76
00:03:40,487 --> 00:03:43,323
App Store收据

77
00:03:43,390 --> 00:03:45,759
它是用户说他们购买了某东西的

78
00:03:45,826 --> 00:03:47,094
购买证明

79
00:03:47,728 --> 00:03:50,497
在这种情况下 它是app首次下载

80
00:03:50,564 --> 00:03:53,133
以及该app中发生的

81
00:03:54,568 --> 00:03:57,137
这是一个数字文件

82
00:03:57,204 --> 00:03:58,906
我们为你提供一个API来访问它

83
00:03:59,439 --> 00:04:01,141
并且它由App Store生成

84
00:03:59,439 --> 00:04:01,141
并且它由App Store生成

85
00:04:02,342 --> 00:04:04,845
我们还使用数字证书

86
00:04:04,912 --> 00:04:07,581
以便你可以检查以确保它

87
00:04:07,648 --> 00:04:09,349
是由Apple发布的真实文档

88
00:04:10,551 --> 00:04:13,954
最后 该文档仅适用于

89
00:04:14,188 --> 00:04:16,156
如果你之前使用过订阅服务

90
00:04:16,223 --> 00:04:18,959
你会注意到拥有多台设备的用户

91
00:04:19,493 --> 00:04:22,095
他们的收据在每台设备上

92
00:04:23,964 --> 00:04:26,033
当涉及到验证你的app

93
00:04:26,099 --> 00:04:27,467
所获悉的交易时

94
00:04:27,534 --> 00:04:29,269
你需要做的第一步是验证该文档

95
00:04:29,336 --> 00:04:32,339
也就是App Store收据

96
00:04:32,406 --> 00:04:33,407
你怎么做到呢？

97
00:04:35,142 --> 00:04:36,143
通过两种方式完成此操作

98
00:04:36,210 --> 00:04:38,345
首先 你可以使用设备上验证

99
00:04:38,412 --> 00:04:40,681
它直接发生在用户的设备上

100
00:04:40,747 --> 00:04:43,483
你可以通过一系列检查

101
00:04:43,550 --> 00:04:45,752
并验证其是否可信

102
00:04:46,220 --> 00:04:49,056
或你可使用被称为

103
00:04:49,690 --> 00:04:52,960
第二种技术是将

104
00:04:53,427 --> 00:04:54,761
发送到你自己的服务器

105
00:04:55,095 --> 00:04:57,831
再从你的服务器发送到

106
00:04:58,031 --> 00:05:00,367
App Store

107
00:04:58,031 --> 00:05:00,367
App Store

108
00:05:00,834 --> 00:05:02,302
（收据验证

109
00:05:02,369 --> 00:05:04,938
你可以使用这其中任何一种技术

110
00:05:05,005 --> 00:05:06,773
最重要的是不要在用户的设备上

111
00:05:06,840 --> 00:05:09,543
使用在线验证

112
00:05:09,610 --> 00:05:12,412
来验证此文件是真实的

113
00:05:13,080 --> 00:05:14,715
但让我们在细节上

114
00:05:14,781 --> 00:05:17,451
比较一下这两种方法

115
00:05:17,518 --> 00:05:19,286
和可更新订单订阅

116
00:05:20,287 --> 00:05:22,523
这两种技术都可以用来

117
00:05:22,589 --> 00:05:24,358
验证文件的真实性

118
00:05:25,592 --> 00:05:27,461
它们还可以让你访问收据的内容

119
00:05:27,528 --> 00:05:30,430
比如该特定用户发生的任何交易

120
00:05:31,398 --> 00:05:33,133
但当涉及到可更新订单订阅时

121
00:05:33,200 --> 00:05:36,203
服务器到服务器收据验证

122
00:05:36,270 --> 00:05:38,839
要优于使用设备上收据验证

123
00:05:39,506 --> 00:05:42,075
首先 我们在验证的响应中

124
00:05:42,142 --> 00:05:44,945
会包含一些额外的订阅信息

125
00:05:45,279 --> 00:05:47,848
你可使用这些信息

126
00:05:47,915 --> 00:05:49,216
（比较验证方法）

127
00:05:49,283 --> 00:05:50,918
你的服务器始终处于开启状态

128
00:05:50,984 --> 00:05:53,020
以便于在后台处理这些续订交易

129
00:05:53,086 --> 00:05:56,690
如果你拥有多个平台的服务

130
00:05:58,458 --> 00:06:01,061
你的服务器不易受

131
00:05:58,458 --> 00:06:01,061
你的服务器不易受

132
00:06:01,728 --> 00:06:03,764
如果你使用设备上收据验证

133
00:06:03,830 --> 00:06:05,699
来在用户设备上进行订阅管理

134
00:06:05,766 --> 00:06:08,435
实际上没有任何东西能够

135
00:06:08,502 --> 00:06:10,904
以使自己仍处于有效的订阅期

136
00:06:10,971 --> 00:06:14,408
比如他们已经失效的免费试用期

137
00:06:15,776 --> 00:06:17,778
最后 它更简单

138
00:06:18,579 --> 00:06:21,348
在服务器到服务器验证中

139
00:06:21,415 --> 00:06:24,952
不必使用OpenSSL

140
00:06:25,018 --> 00:06:27,254
考虑到所有这些因素

141
00:06:27,321 --> 00:06:30,023
越来越多的人

142
00:06:30,090 --> 00:06:33,260
采用服务器到服务器验证

143
00:06:34,461 --> 00:06:37,931
如果你有一个简单的不需联网的

144
00:06:37,998 --> 00:06:41,301
你仍然可以使用设备上验证

145
00:06:41,635 --> 00:06:43,136
若你有兴趣了解更多相关信息

146
00:06:43,203 --> 00:06:44,404
我想邀请你观看

147
00:06:44,471 --> 00:06:46,440
去年StoreKit进阶

148
00:06:46,507 --> 00:06:49,543
我们在该视频中更详细地介绍了

149
00:06:50,110 --> 00:06:52,579
但这次演讲的目的是

150
00:06:52,646 --> 00:06:55,249
这里列出的服务器到服务器技术

151
00:06:56,183 --> 00:06:57,317
让我们回到刚才的例子

152
00:06:57,384 --> 00:06:59,386
并了解我们如何使用

153
00:06:59,453 --> 00:07:01,154
来处理当前这笔交易

154
00:06:59,453 --> 00:07:01,154
来处理当前这笔交易

155
00:07:01,722 --> 00:07:03,490
回到我们的交易观察者

156
00:07:03,824 --> 00:07:05,726
你可以使用主包中的

157
00:07:05,792 --> 00:07:09,062
来访问该二进制收据数据

158
00:07:09,897 --> 00:07:13,100
一旦你获取该URL

159
00:07:13,166 --> 00:07:16,737
二进制数据 接着你可以使用

160
00:07:16,803 --> 00:07:19,339
取出那个receiptData

161
00:07:19,406 --> 00:07:21,675
你可以将其发送到

162
00:07:21,742 --> 00:07:24,311
你可能会调用

163
00:07:24,378 --> 00:07:25,579
一些app内的网络API

164
00:07:27,114 --> 00:07:29,383
当你将数据发送到服务器进行处理时

165
00:07:29,449 --> 00:07:31,552
显然你首先需要安全地做到这一点

166
00:07:31,618 --> 00:07:33,854
你可以将它发送到你的服务器上的

167
00:07:33,921 --> 00:07:34,922
/processTransaction端点

168
00:07:35,422 --> 00:07:37,758
在此端点中

169
00:07:37,824 --> 00:07:40,794
其与系统中当前用户的账户相关联

170
00:07:41,795 --> 00:07:43,764
你可以将此收据数据

171
00:07:43,830 --> 00:07:47,134
然后一旦你的服务器收到它

172
00:07:47,201 --> 00:07:49,570
到App Store的

173
00:07:50,070 --> 00:07:53,006
然后你就可以将收据数据

174
00:07:53,707 --> 00:07:55,676
在这里你可以包含一个密码字段

175
00:07:55,742 --> 00:07:58,879
这是你的app

176
00:07:58,946 --> 00:08:01,815
你可在App Store Connect中

177
00:07:58,946 --> 00:08:01,815
你可在App Store Connect中

178
00:08:01,882 --> 00:08:03,050
（验证一笔交易）

179
00:08:03,116 --> 00:08:06,053
当你将此收据数据发送到

180
00:08:06,119 --> 00:08:07,654
/verifyReceipt端点

181
00:08:07,721 --> 00:08:09,990
一个类似这样的JSON载荷

182
00:08:11,792 --> 00:08:13,994
当你验证交易的真实性时

183
00:08:14,061 --> 00:08:16,864
首先检查的是这个status字段

184
00:08:17,164 --> 00:08:18,665
它能够表明Apple

185
00:08:18,732 --> 00:08:21,201
的确签发了这个文档

186
00:08:21,635 --> 00:08:24,171
一旦你确认了

187
00:08:24,238 --> 00:08:27,708
你就可以检查此载荷的

188
00:08:27,941 --> 00:08:29,943
这是你发送给

189
00:08:30,010 --> 00:08:32,346
二进制数据的解码版本

190
00:08:32,412 --> 00:08:35,582
因此你可在此做些事

191
00:08:35,649 --> 00:08:38,251
是否与你的app的包ID相匹配

192
00:08:39,019 --> 00:08:41,522
然后你可以检查in_app数组

193
00:08:41,722 --> 00:08:45,092
它包含此app中该用户的交易列表

194
00:08:45,726 --> 00:08:48,495
你还可以验证该收据的

195
00:08:48,996 --> 00:08:51,632
是否与你app中的该字段相匹配

196
00:08:52,499 --> 00:08:54,067
假设这些都匹配

197
00:08:54,434 --> 00:08:56,670
你就可以决定此收据能够

198
00:08:56,737 --> 00:08:59,072
赋予这个特定的用户

199
00:08:59,139 --> 00:09:01,375
现在你已准备好继续进行第三步

200
00:08:59,139 --> 00:09:01,375
现在你已准备好继续进行第三步

201
00:09:01,842 --> 00:09:03,777
更新用户的订阅状态

202
00:09:07,481 --> 00:09:09,950
与每个订阅周期始于某笔交易类似

203
00:09:10,017 --> 00:09:13,253
它也会以到期日期结束

204
00:09:14,454 --> 00:09:16,757
/verifyReceipt的

205
00:09:16,823 --> 00:09:19,459
每个交易的到期日期

206
00:09:19,526 --> 00:09:22,296
回头看一下

207
00:09:22,596 --> 00:09:24,865
你会注意到交易中的

208
00:09:24,932 --> 00:09:26,433
这个expires_date字段

209
00:09:26,500 --> 00:09:27,634
（更新订阅状态）

210
00:09:27,701 --> 00:09:29,136
现在让我们看看用户表

211
00:09:29,203 --> 00:09:31,438
你可能会将这些数据

212
00:09:33,006 --> 00:09:35,375
你可以从此交易中获取此过期日期

213
00:09:35,442 --> 00:09:37,911
并将其填充到你的服务器上的

214
00:09:37,978 --> 00:09:40,814
比如该用户的

215
00:09:40,881 --> 00:09:44,117
这个字段将作为你的服务器

216
00:09:44,184 --> 00:09:47,154
判断该用户是否为订阅用户的依据

217
00:09:48,355 --> 00:09:50,791
你也应该记录这个字段

218
00:09:50,858 --> 00:09:53,460
你可以将其

219
00:09:53,527 --> 00:09:55,262
保存到该用户的

220
00:09:55,329 --> 00:09:56,930
originalTransactionId字段中

221
00:09:56,997 --> 00:09:58,465
我们稍后还会谈到

222
00:09:58,532 --> 00:09:59,867
为什么这很重要

223
00:10:01,468 --> 00:10:03,403
一旦你在服务器上保存了

224
00:10:03,470 --> 00:10:05,339
该用户的这两样信息

225
00:10:05,405 --> 00:10:07,007
你就可以进行最后一步

226
00:10:07,074 --> 00:10:09,877
也就是通知设备该交易通过了

227
00:10:09,943 --> 00:10:11,278
你的验证

228
00:10:11,945 --> 00:10:14,047
然后当你的设备得到这个回调

229
00:10:14,114 --> 00:10:17,551
它就会在你的交易观察者中

230
00:10:18,252 --> 00:10:20,554
这是一个非常重要的步骤

231
00:10:20,621 --> 00:10:22,756
实际上会将其清除出你的支付队列

232
00:10:22,823 --> 00:10:26,126
如果你不调用finishTransaction

233
00:10:26,193 --> 00:10:27,861
再次出现以进行处理

234
00:10:27,928 --> 00:10:30,898
因此请确保你完成每个

235
00:10:32,833 --> 00:10:34,701
当你完成交易后

236
00:10:34,768 --> 00:10:36,637
你的服务器中将有更新后的订阅状态

237
00:10:36,703 --> 00:10:40,073
用户现在可以在订阅期内

238
00:10:43,143 --> 00:10:45,279
现在让我们再看看我提到的那个

239
00:10:45,345 --> 00:10:46,947
保存在你的服务器上的用户表

240
00:10:47,781 --> 00:10:50,284
使用此设置购买订阅的每个用户

241
00:10:50,350 --> 00:10:52,986
都将被分配一个唯一的

242
00:10:53,053 --> 00:10:56,089
即你从交易响应中保存的字段

243
00:10:56,924 --> 00:11:00,093
这个标识符实质上

244
00:10:56,924 --> 00:11:00,093
这个标识符实质上

245
00:11:01,261 --> 00:11:04,798
它很重要 因为它将显示在

246
00:11:05,098 --> 00:11:06,800
让我们来看看这是如何工作的

247
00:11:07,167 --> 00:11:09,570
假设你正在验证一笔续订交易

248
00:11:09,636 --> 00:11:11,038
这与你在你的服务器上使用

249
00:11:11,104 --> 00:11:13,707
/processTransaction端点

250
00:11:14,708 --> 00:11:17,578
当你验证这笔交易时

251
00:11:18,111 --> 00:11:21,849
你到了更新该用户的

252
00:11:22,583 --> 00:11:24,751
你会发现这里现在有多笔交易

253
00:11:24,818 --> 00:11:26,620
因为这是一笔续订交易

254
00:11:26,687 --> 00:11:27,888
（更新订阅状态）

255
00:11:27,955 --> 00:11:30,591
现在根据你现有的服务器端逻辑

256
00:11:31,091 --> 00:11:33,260
这个最新的到期日期已经过了

257
00:11:33,327 --> 00:11:36,330
所以此用户目前不是订阅用户

258
00:11:36,396 --> 00:11:39,199
他们是否还是订阅用户

259
00:11:40,100 --> 00:11:43,770
那么你如何使用此收据数据

260
00:11:43,837 --> 00:11:47,608
为了判断用户是否处于订阅有效期

261
00:11:47,674 --> 00:11:50,244
你可以找出与

262
00:11:50,310 --> 00:11:52,079
那笔交易

263
00:11:52,145 --> 00:11:53,247
（用户是否处于订阅有效期？）

264
00:11:53,313 --> 00:11:56,617
然后你可以找到具有最新

265
00:11:57,184 --> 00:11:59,853
如果你发现该日期是过去的某天

266
00:12:00,087 --> 00:12:02,122
则表明该用户

267
00:12:02,189 --> 00:12:04,091
但是如果该日期是将来某天

268
00:12:04,291 --> 00:12:07,761
则表示此用户仍处于有效订阅期

269
00:12:08,328 --> 00:12:11,398
我们通过刚才这个例子

270
00:12:13,333 --> 00:12:16,103
获取与该用户关联的

271
00:12:16,837 --> 00:12:20,307
并提取与此订阅相关的所有交易

272
00:12:20,741 --> 00:12:23,377
然后使用其expires_date字段

273
00:12:23,777 --> 00:12:26,046
并找到具有最新过期日期的那个

274
00:12:26,113 --> 00:12:30,217
现在你可以使用该expires_date

275
00:12:30,284 --> 00:12:31,485
latestExpiresDate字段

276
00:12:32,519 --> 00:12:34,221
当你这样做时 你正在有效地

277
00:12:34,288 --> 00:12:37,191
将该用户的订阅期延长一段时间

278
00:12:37,357 --> 00:12:38,792
你的服务器端逻辑现在知道

279
00:12:38,859 --> 00:12:40,894
该用户位于有效的订阅时间窗口中

280
00:12:41,828 --> 00:12:44,198
当然 当你正在处理通过

281
00:12:44,264 --> 00:12:46,967
你仍然需要告知设备

282
00:12:47,034 --> 00:12:48,869
它通过了这些验证检查

283
00:12:49,403 --> 00:12:51,371
并让你的app

284
00:12:51,438 --> 00:12:53,407
再次调用finishTransaction函数

285
00:12:53,473 --> 00:12:55,542
（在设备上完成所有交易）

286
00:12:57,411 --> 00:12:59,847
假设你已经设置并能正常工作

287
00:13:00,547 --> 00:13:02,115
App Store正在后台

288
00:13:02,182 --> 00:13:05,519
并且你正使用StoreKit处理

289
00:13:05,586 --> 00:13:07,387
这些来自你的app的交易

290
00:13:07,721 --> 00:13:09,857
然后你的服务器将更新和维护

291
00:13:09,923 --> 00:13:12,359
这个latestExpiresDate字段

292
00:13:12,426 --> 00:13:14,528
现在你已经能够通过服务端逻辑推断

293
00:13:14,595 --> 00:13:16,530
用户是否为合法订阅用户了

294
00:13:16,597 --> 00:13:17,631
（续订交易）

295
00:13:17,698 --> 00:13:20,300
现在让我们来介绍一个

296
00:13:20,367 --> 00:13:23,704
也许你通过网站提供服务

297
00:13:24,238 --> 00:13:25,472
现在当用户访问一个网站

298
00:13:25,772 --> 00:13:28,709
来使用你的订阅服务

299
00:13:28,775 --> 00:13:31,211
知道该用户是一个合法订阅用户

300
00:13:31,278 --> 00:13:32,513
（多平台）

301
00:13:32,579 --> 00:13:35,916
但尽管我们希望

302
00:13:36,517 --> 00:13:39,386
假设用户有几天没有使用过

303
00:13:39,453 --> 00:13:42,189
在这段时间内

304
00:13:42,256 --> 00:13:44,191
成功更新了该用户的订阅

305
00:13:45,192 --> 00:13:47,995
当用户尝试通过你的网站

306
00:13:48,595 --> 00:13:50,297
latestExpiresDate

307
00:13:50,364 --> 00:13:52,733
因为你的服务器尚未知晓该笔新交易

308
00:13:52,799 --> 00:13:55,802
那么你的服务器怎么知道

309
00:13:55,869 --> 00:13:57,504
发生在App Store上的

310
00:13:59,206 --> 00:14:00,040
（状态轮询）

311
00:13:59,206 --> 00:14:00,040
（状态轮询）

312
00:14:00,107 --> 00:14:02,242
你可以使用这种称为状态轮询的技术

313
00:14:02,309 --> 00:14:04,378
这可以让你在你的服务器中

314
00:14:04,444 --> 00:14:05,679
直接发现这些交易

315
00:14:06,446 --> 00:14:09,416
为了设置为能够从你的服务器

316
00:14:09,716 --> 00:14:12,920
你只需保存编码收据数据的最新版本

317
00:14:12,986 --> 00:14:15,489
即你发送的

318
00:14:16,190 --> 00:14:19,826
你可以将该编码数据视为一个令牌

319
00:14:20,594 --> 00:14:23,764
你能够像对待令牌一样对待它

320
00:14:23,830 --> 00:14:26,934
发给/verifyReceipt端点时

321
00:14:27,167 --> 00:14:29,369
/verifyReceipt端点

322
00:14:29,436 --> 00:14:32,139
该收据数据的解码版本

323
00:14:32,206 --> 00:14:34,942
它还包含与该用户订阅相关的

324
00:14:35,309 --> 00:14:37,477
所有发生过的新交易

325
00:14:37,544 --> 00:14:40,514
它位于那个JSON响应中称为

326
00:14:40,781 --> 00:14:41,915
latestReceiptInfo的字段中

327
00:14:42,850 --> 00:14:45,786
你可以使用该信息为用户

328
00:14:46,019 --> 00:14:49,189
而无需启动该app

329
00:14:50,023 --> 00:14:52,759
让我们看看它是如何工作的

330
00:14:52,826 --> 00:14:55,395
就像我们之前看到的

331
00:14:55,462 --> 00:14:56,563
（验证续订交易）

332
00:14:56,630 --> 00:14:59,700
现在 一旦你确定这个交易

333
00:14:59,766 --> 00:15:02,102
通过了与你以前一样的检查过程后

334
00:14:59,766 --> 00:15:02,102
通过了与你以前一样的检查过程后

335
00:15:02,402 --> 00:15:04,905
你就可以将

336
00:15:04,972 --> 00:15:08,141
该用户的latestReceiptData字段中

337
00:15:09,510 --> 00:15:11,879
你现已存储了用户的

338
00:15:12,246 --> 00:15:14,781
这是一个

339
00:15:15,282 --> 00:15:17,284
当需要回答以下这个问题时

340
00:15:17,351 --> 00:15:18,852
即我的用户是否处于订阅有效期

341
00:15:18,919 --> 00:15:22,055
你可以直接从服务器获取

342
00:15:22,122 --> 00:15:24,358
并将其发送到

343
00:15:25,225 --> 00:15:29,329
你还可包含一可选标志

344
00:15:29,796 --> 00:15:31,932
这会告诉/verifyReceipt

345
00:15:31,999 --> 00:15:33,600
收据的解码版本

346
00:15:33,667 --> 00:15:36,069
你只想了解是否有任何新的交易

347
00:15:36,136 --> 00:15:37,271
（状态轮询）

348
00:15:37,337 --> 00:15:41,175
/verifyReceipt

349
00:15:41,241 --> 00:15:42,676
即latest_receipt_info对象

350
00:15:42,910 --> 00:15:45,445
这个对象中包含那些

351
00:15:45,512 --> 00:15:48,815
发生的新的交易

352
00:15:48,882 --> 00:15:52,119
你可以直接从响应中的

353
00:15:52,753 --> 00:15:54,254
获取expires_date

354
00:15:55,222 --> 00:15:57,090
并针对当前用户进行更新

355
00:15:57,391 --> 00:16:00,360
从而再次延长他们的访问有效期

356
00:15:57,391 --> 00:16:00,360
从而再次延长他们的访问有效期

357
00:16:00,761 --> 00:16:04,064
因此 试图访问你的网站内容的用户

358
00:16:04,131 --> 00:16:06,366
现在可以进入到下一个订阅期

359
00:16:06,433 --> 00:16:09,636
而无需使用新的交易来启动app

360
00:16:11,305 --> 00:16:13,240
如果你使用状态轮询技术

361
00:16:13,307 --> 00:16:14,508
你必须要记住一件事

362
00:16:14,575 --> 00:16:17,144
那就是当你的app再次联网时

363
00:16:17,211 --> 00:16:19,880
交易仍会通过StoreKit

364
00:16:19,947 --> 00:16:21,715
在更新后的交易回调中出现

365
00:16:21,782 --> 00:16:24,985
你仍然应该处理这些交易

366
00:16:25,052 --> 00:16:27,521
你的服务器以进行验证

367
00:16:27,588 --> 00:16:28,822
再次关闭它们

368
00:16:28,989 --> 00:16:30,991
即使你的服务器已经通过状态轮询

369
00:16:31,058 --> 00:16:32,092
知道它们的存在

370
00:16:33,560 --> 00:16:35,963
我们鼓励你将其作为

371
00:16:36,029 --> 00:16:39,933
并将其存储到服务器上的机会

372
00:16:44,271 --> 00:16:45,639
状态轮询在用户的信用卡

373
00:16:46,006 --> 00:16:48,408
可以收费时工作很好

374
00:16:48,642 --> 00:16:52,312
但是如果在某个订阅期内

375
00:16:52,379 --> 00:16:55,649
以至App Store无法

376
00:16:55,716 --> 00:16:57,451
这时该怎么办

377
00:16:57,985 --> 00:17:00,821
这个用户是否注定会

378
00:16:57,985 --> 00:17:00,821
这个用户是否注定会

379
00:17:01,455 --> 00:17:02,289
并不会

380
00:17:03,156 --> 00:17:06,393
当遇到这样的结算问题时

381
00:17:06,460 --> 00:17:10,063
首先 你观察到这个用户

382
00:17:10,130 --> 00:17:13,133
他们的订阅现在已经失效

383
00:17:13,733 --> 00:17:16,537
其次 你可以引导该用户

384
00:17:16,603 --> 00:17:18,571
更新他的账单信息

385
00:17:19,806 --> 00:17:23,577
然后是第三步 当发生续订交易时

386
00:17:23,810 --> 00:17:26,680
立即解除对该用户的屏蔽

387
00:17:27,146 --> 00:17:29,449
第一步和第二步非常简单

388
00:17:29,516 --> 00:17:31,552
如果使用了我们刚刚谈到的

389
00:17:31,618 --> 00:17:33,820
但这里的第三步使用了一个

390
00:17:33,887 --> 00:17:37,357
我们去年推出的特性

391
00:17:38,392 --> 00:17:39,426
我们来看看这个例子

392
00:17:39,493 --> 00:17:42,629
假设在一个订阅期内

393
00:17:42,696 --> 00:17:44,731
此用户的信用卡收费时发生错误

394
00:17:44,798 --> 00:17:46,233
（服务器到服务器通知）

395
00:17:46,300 --> 00:17:49,570
然后你会通过状态轮训发现这个用户

396
00:17:49,636 --> 00:17:51,371
没有新的续订交易

397
00:17:52,072 --> 00:17:54,708
你的服务器通过正确的计算

398
00:17:54,775 --> 00:17:56,476
确定该用户不再是合法订阅用户

399
00:17:56,543 --> 00:17:59,680
所以当用户通过网站访问你的服务时

400
00:17:59,746 --> 00:18:01,548
你给他们一些适当的错误信息

401
00:17:59,746 --> 00:18:01,548
你给他们一些适当的错误信息

402
00:18:01,615 --> 00:18:04,284
告诉他们其订阅服务无法续订

403
00:18:04,685 --> 00:18:07,454
你可以引导该用户

404
00:18:07,521 --> 00:18:08,555
更新他们的账单信息

405
00:18:09,423 --> 00:18:11,258
现在当用户更新他们的账单信息时

406
00:18:11,325 --> 00:18:13,727
也许他们只需更新过期日期

407
00:18:14,261 --> 00:18:15,262
这时发生了两件事

408
00:18:15,896 --> 00:18:18,432
首先 App Store

409
00:18:18,632 --> 00:18:21,368
会立即向用户的信用卡收费

410
00:18:21,768 --> 00:18:23,403
当App Store这样做了

411
00:18:23,570 --> 00:18:25,839
它所做的第二步是

412
00:18:25,906 --> 00:18:29,843
发出一个关于该续订交易的

413
00:18:30,043 --> 00:18:34,715
该POST请求的载荷中

414
00:18:34,781 --> 00:18:36,617
包括刚发生的交易的新信息

415
00:18:36,984 --> 00:18:38,952
你可以使用载荷中的

416
00:18:39,019 --> 00:18:42,489
来确定这个通知是针对哪个用户的

417
00:18:43,290 --> 00:18:45,292
一旦你找出该用户

418
00:18:45,359 --> 00:18:47,528
你可以使用最新的

419
00:18:47,728 --> 00:18:50,998
来为此用户进行更新

420
00:18:51,064 --> 00:18:52,766
下一个订阅期的访问权限

421
00:18:53,166 --> 00:18:55,002
接着这位可能还在盯着你的网页

422
00:18:55,068 --> 00:18:57,538
试图访问其中内容的用户

423
00:18:58,505 --> 00:19:00,574
将能够立即被解锁

424
00:18:58,505 --> 00:19:00,574
将能够立即被解锁

425
00:19:00,807 --> 00:19:04,111
因为你的服务器直接从

426
00:19:05,846 --> 00:19:08,815
当这种事情发生时

427
00:19:08,882 --> 00:19:11,151
尤其是当他们付出巨大努力

428
00:19:11,218 --> 00:19:13,487
去手动更新他们的信用卡信息

429
00:19:13,554 --> 00:19:15,289
并等待访问服务器时

430
00:19:15,589 --> 00:19:18,559
但是这里有一点需要注意

431
00:19:18,625 --> 00:19:21,161
如我们刚刚看到的那样失效时

432
00:19:22,029 --> 00:19:24,198
为了发现成功的续订交易

433
00:19:24,364 --> 00:19:26,300
你仍然需要依赖

434
00:19:26,366 --> 00:19:27,668
状态轮询技术

435
00:19:28,569 --> 00:19:31,772
但设置并使用

436
00:19:31,839 --> 00:19:34,608
你所要做的只是在

437
00:19:35,275 --> 00:19:37,311
这只是你自己服务器上的一个端点

438
00:19:37,377 --> 00:19:39,179
如果你将其输入到

439
00:19:39,513 --> 00:19:42,349
App Store将开始向

440
00:19:42,583 --> 00:19:44,117
HTTPS POST请求

441
00:19:44,384 --> 00:19:47,754
正如我们在POST请求中

442
00:19:48,021 --> 00:19:49,957
触发该请求的交易的

443
00:19:50,624 --> 00:19:53,894
你需要确保你的服务器

444
00:19:54,061 --> 00:19:56,196
但这是一个非常简单的步骤

445
00:19:56,263 --> 00:19:58,131
它却可以给很多用户带来更好的体验

446
00:20:02,402 --> 00:20:04,705
以上是一些关于

447
00:20:04,771 --> 00:20:06,907
和服务器体系结构的技巧和窍门

448
00:20:06,974 --> 00:20:10,310
让我们来谈谈你可以

449
00:20:10,377 --> 00:20:12,513
来大幅提升用户体验

450
00:20:13,480 --> 00:20:16,783
首先 我们假设用户已登录到

451
00:20:16,850 --> 00:20:18,585
你提供的服务的账户中

452
00:20:19,720 --> 00:20:22,356
为了跟踪每个订阅ID

453
00:20:22,422 --> 00:20:25,225
你需要使用位于服务器上的

454
00:20:25,692 --> 00:20:27,661
现在我们谈到实际创建账户

455
00:20:27,728 --> 00:20:29,763
我们认为

456
00:20:29,830 --> 00:20:31,598
就可以进行app内购买

457
00:20:31,665 --> 00:20:32,566
（创建用户帐户）

458
00:20:32,633 --> 00:20:35,135
为什么呢？

459
00:20:35,202 --> 00:20:36,904
你第一次打开某app

460
00:20:36,970 --> 00:20:38,172
就可以购买订阅

461
00:20:38,238 --> 00:20:40,574
并立即访问你想要的内容

462
00:20:40,641 --> 00:20:43,177
对你而言 这样更好

463
00:20:43,243 --> 00:20:45,479
用户不必输入邮件地址

464
00:20:45,546 --> 00:20:48,081
和密码就能够向你支付

465
00:20:49,216 --> 00:20:51,585
现在你可以通过在这些实例中

466
00:20:51,652 --> 00:20:54,254
来使用我们刚刚谈到的技术

467
00:20:55,622 --> 00:20:58,992
你可以使用

468
00:20:59,059 --> 00:21:01,195
来关联多个设备

469
00:20:59,059 --> 00:21:01,195
来关联多个设备

470
00:21:02,396 --> 00:21:04,464
如果你使用这样的匿名账户

471
00:21:04,531 --> 00:21:07,768
当用户需要真正创建一个账户时

472
00:21:07,835 --> 00:21:10,437
你可以简单地通过一个去匿名过程

473
00:21:10,504 --> 00:21:13,640
即更新邮件地址字段

474
00:21:13,707 --> 00:21:15,943
和其他个人信息相关的字段

475
00:21:17,945 --> 00:21:19,213
这是第一个窍门

476
00:21:19,279 --> 00:21:21,949
第二个窍门是关于

477
00:21:22,216 --> 00:21:23,917
在销售你的订阅时

478
00:21:23,984 --> 00:21:27,221
你可以使用我们去年推出的功能

479
00:21:27,821 --> 00:21:30,224
推介定价有一个重要的步骤

480
00:21:30,424 --> 00:21:34,127
即你在运行时需要知道用户是否真的

481
00:21:34,361 --> 00:21:35,629
具有推介定价资格

482
00:21:35,696 --> 00:21:37,764
你需要知道它的原因是

483
00:21:37,831 --> 00:21:39,700
你要呈现给用户的价格

484
00:21:40,033 --> 00:21:41,902
无论是显示正常的

485
00:21:41,969 --> 00:21:44,271
还是你想给用户提供的推介价格

486
00:21:44,338 --> 00:21:45,339
来让他们进门

487
00:21:46,340 --> 00:21:48,742
现在你可以通过监视

488
00:21:48,809 --> 00:21:51,211
后台正在发生的交易

489
00:21:51,278 --> 00:21:52,846
来提前知道这一点

490
00:21:53,480 --> 00:21:56,416
让我们看看它是如何工作的

491
00:21:56,483 --> 00:21:59,186
就像我们刚才看到的一样

492
00:21:59,686 --> 00:22:04,057
is_trial_period字段

493
00:21:59,686 --> 00:22:04,057
is_trial_period字段

494
00:22:04,525 --> 00:22:06,226
如果这些字段中的任何一个为真

495
00:22:06,560 --> 00:22:08,829
这就表明这笔交易

496
00:22:09,096 --> 00:22:11,732
是一个推介价位或免费试用的交易

497
00:22:12,533 --> 00:22:16,103
如果是这样

498
00:22:16,403 --> 00:22:17,504
针对当前用户的

499
00:22:17,571 --> 00:22:20,541
你可以将它们存储在名为

500
00:22:21,642 --> 00:22:24,278
现在 如果你正在跟踪

501
00:22:24,578 --> 00:22:27,781
哪些产品被用来提供推介优惠

502
00:22:27,848 --> 00:22:31,151
新的订阅产品的价格时

503
00:22:31,852 --> 00:22:33,020
你可以这样做

504
00:22:33,086 --> 00:22:35,155
你可以获取

505
00:22:35,222 --> 00:22:36,823
consumedProductDiscounts

506
00:22:37,357 --> 00:22:39,393
在它们上面执行

507
00:22:39,927 --> 00:22:43,730
现在iOS 12中

508
00:22:43,964 --> 00:22:46,099
包含subscriptionGroupIdentifier

509
00:22:46,366 --> 00:22:49,403
以便于你知道这个特定产品

510
00:22:49,937 --> 00:22:52,472
现在有了这个

511
00:22:52,539 --> 00:22:56,577
你就可以在该用户的一组

512
00:22:56,643 --> 00:22:57,678
跟踪该消息

513
00:22:57,744 --> 00:23:01,348
你知道这个用户使用过哪个订阅组

514
00:22:57,744 --> 00:23:01,348
你知道这个用户使用过哪个订阅组

515
00:23:02,850 --> 00:23:05,786
现在 当你要呈现

516
00:23:06,086 --> 00:23:07,487
它只需进行一个简单的检查

517
00:23:07,554 --> 00:23:11,592
你可以检查此用户的

518
00:23:11,859 --> 00:23:15,262
你想要卖给他们的产品的组标识符

519
00:23:15,329 --> 00:23:18,866
如果确实如此

520
00:23:18,932 --> 00:23:20,300
之前的推介报价

521
00:23:20,367 --> 00:23:23,704
因此你可以将正常价格字符串

522
00:23:24,238 --> 00:23:27,274
但如果不是

523
00:23:27,341 --> 00:23:31,111
因此你可以使用位于

524
00:23:32,479 --> 00:23:35,549
在呈现价格字符串时

525
00:23:35,616 --> 00:23:39,286
它与你用于呈现

526
00:23:39,353 --> 00:23:41,455
我不打算在这里深入讨论

527
00:23:41,522 --> 00:23:44,191
但我建议你观看上一个演讲的视频

528
00:23:44,258 --> 00:23:46,360
其中讨论了如何更加动态的

529
00:23:46,426 --> 00:23:47,661
呈现这些价格字符串

530
00:23:48,095 --> 00:23:50,330
有关设置推介优惠的更多信息

531
00:23:50,397 --> 00:23:53,166
我也建议你看看

532
00:23:53,233 --> 00:23:55,102
“App Store Connect新特性”演讲

533
00:23:57,104 --> 00:23:59,072
所以这是关于推介定价的第二个窍门

534
00:23:59,139 --> 00:24:01,909
这里的第三个窍门是关于订阅管理的

535
00:23:59,139 --> 00:24:01,909
这里的第三个窍门是关于订阅管理的

536
00:24:03,010 --> 00:24:05,112
你可以直接在你的app的

537
00:24:05,179 --> 00:24:07,881
让用户可以在不同订阅层级之间

538
00:24:08,448 --> 00:24:09,349
为了做到这一点

539
00:24:09,416 --> 00:24:12,052
你实际上可以像

540
00:24:13,320 --> 00:24:15,489
现在如果你正在销售给用户的订阅

541
00:24:15,556 --> 00:24:17,224
是同一个订阅组的一部分

542
00:24:17,291 --> 00:24:20,394
它将与用户已订阅的层不同

543
00:24:20,761 --> 00:24:23,163
你可以创建一个SKPayment

544
00:24:23,230 --> 00:24:24,831
就像你向用户出售

545
00:24:24,898 --> 00:24:25,966
首次订阅服务一样

546
00:24:26,033 --> 00:24:28,268
当你这样做时

547
00:24:28,335 --> 00:24:30,304
这是一次升级或降级的事实

548
00:24:30,637 --> 00:24:33,540
所以你不必担心该用户会订阅两次

549
00:24:34,308 --> 00:24:36,276
如果你不想在app中提供你自己的

550
00:24:36,343 --> 00:24:38,345
升级和降级用户界面

551
00:24:38,412 --> 00:24:39,913
你也可以只提供一个

552
00:24:39,980 --> 00:24:42,149
到App Store

553
00:24:42,216 --> 00:24:44,318
我们为你提供一个链接

554
00:24:44,384 --> 00:24:45,886
从你的app访问此界面

555
00:24:45,953 --> 00:24:49,289
在这里用户可以升级

556
00:24:50,190 --> 00:24:52,593
你的app通常是

557
00:24:52,659 --> 00:24:53,727
首选地方

558
00:24:53,794 --> 00:24:55,162
以便升级、降级或取消订阅

559
00:24:55,229 --> 00:24:57,664
因此提供某种让用户

560
00:24:57,731 --> 00:25:00,801
是一个非常好的主意

561
00:24:57,731 --> 00:25:00,801
是一个非常好的主意

562
00:25:01,435 --> 00:25:02,336
为了进入这个页面

563
00:25:02,402 --> 00:25:05,305
在我们的app内购买项目指南中

564
00:25:05,706 --> 00:25:07,975
链接在这里 如果你想要记一下的话

565
00:25:09,009 --> 00:25:11,945
以上是一些可以在app中

566
00:25:12,012 --> 00:25:14,648
从而为用户提供

567
00:25:14,715 --> 00:25:16,483
接下来

568
00:25:16,550 --> 00:25:19,152
他会谈一些能够防止订户流失的

569
00:25:19,219 --> 00:25:20,287
实用技术

570
00:25:20,354 --> 00:25:21,188
谢谢大家

571
00:25:29,263 --> 00:25:31,865
下午好

572
00:25:31,932 --> 00:25:35,068
我是App Store运营团队的

573
00:25:35,469 --> 00:25:39,706
今天我想谈谈如何通过

574
00:25:39,773 --> 00:25:41,575
一些策略和方法

575
00:25:41,642 --> 00:25:43,076
来减少app内的订户流失

576
00:25:44,811 --> 00:25:47,814
今天我们将覆盖

577
00:25:47,881 --> 00:25:50,817
这是两种在订阅app中

578
00:25:51,285 --> 00:25:53,720
以及一些方法来赢回这些

579
00:25:53,787 --> 00:25:56,156
你可能已经失去或即将失去的用户

580
00:25:57,724 --> 00:26:00,327
首先我们来谈谈非自愿流失

581
00:25:57,724 --> 00:26:00,327
首先我们来谈谈非自愿流失

582
00:26:01,461 --> 00:26:03,997
非自愿流失是

583
00:26:04,064 --> 00:26:06,967
由于平台上付款或结算失败

584
00:26:08,502 --> 00:26:10,204
去年的WWDC中

585
00:26:10,404 --> 00:26:12,206
我们向你介绍了我们做的一些工作

586
00:26:12,272 --> 00:26:15,576
来最小化app内的

587
00:26:16,276 --> 00:26:18,545
我们宣布了我们升级后的

588
00:26:18,879 --> 00:26:22,983
其中我们将重试时间

589
00:26:24,051 --> 00:26:26,320
我们还实施了新的重试策略

590
00:26:26,553 --> 00:26:30,591
并随时调整它们

591
00:26:32,025 --> 00:26:35,596
2017年7月13日是

592
00:26:35,996 --> 00:26:38,098
因为这一天Apple

593
00:26:38,165 --> 00:26:41,034
积极开始为你恢复订阅

594
00:26:43,704 --> 00:26:47,040
如果我们查看自启动以来的

595
00:26:47,107 --> 00:26:49,877
我们可以看到

596
00:26:51,178 --> 00:26:53,113
而对于非自愿流失

597
00:26:53,347 --> 00:26:55,949
我们已经在平台范围内

598
00:27:02,856 --> 00:27:06,693
现在 如果看看我们的调整

599
00:27:06,760 --> 00:27:09,096
我们可以看到

600
00:27:09,263 --> 00:27:13,133
我们已经能够持续恢复

601
00:27:15,469 --> 00:27:20,807
现在最终的结果是

602
00:27:20,874 --> 00:27:22,609
我们已经恢复了1200万次订阅

603
00:27:27,014 --> 00:27:30,317
这就是Apple为尽量减少

604
00:27:30,751 --> 00:27:33,687
作为开发人员你也可以采取一些策略

605
00:27:33,754 --> 00:27:37,191
来最大程度地减少

606
00:27:38,325 --> 00:27:41,562
你可以利用到Pete在前面提到的

607
00:27:41,628 --> 00:27:43,096
一些订阅相关的收据字段

608
00:27:43,397 --> 00:27:45,032
你还可以使用宽限期

609
00:27:45,465 --> 00:27:49,803
在此期间 你可以部署一些

610
00:27:51,104 --> 00:27:53,473
我们来看一个示例订阅

611
00:27:54,341 --> 00:27:58,579
在这里我们可以看到

612
00:27:58,745 --> 00:28:01,281
然而他们遇到了一个结算问题

613
00:27:58,745 --> 00:28:01,281
然而他们遇到了一个结算问题

614
00:28:02,516 --> 00:28:06,687
所以为了让你知道

615
00:28:06,753 --> 00:28:09,289
积极尝试向该用户收费

616
00:28:09,656 --> 00:28:12,459
我们将在JSON响应中显示一个

617
00:28:12,526 --> 00:28:15,462
is_in_billing_retry_period

618
00:28:15,963 --> 00:28:18,031
其值为1代表

619
00:28:18,098 --> 00:28:21,001
我们正尝试向该订户收取资金

620
00:28:23,437 --> 00:28:25,172
如果我们回到刚才的订阅示例

621
00:28:25,239 --> 00:28:27,975
你可以看到

622
00:28:28,575 --> 00:28:31,478
当你看到它与过期日期同时出现

623
00:28:31,645 --> 00:28:35,816
这就是你作为开发人员

624
00:28:37,317 --> 00:28:39,453
你可能会问自己什么是宽限期

625
00:28:42,689 --> 00:28:47,227
宽限期是在结算重试状态下的

626
00:28:47,294 --> 00:28:49,563
然而 这发生在你失去该用户之前

627
00:28:49,630 --> 00:28:51,398
在他们彻底流失之前

628
00:28:52,065 --> 00:28:54,835
宽限期的目标是改善订阅恢复

629
00:28:55,669 --> 00:28:57,437
我们来看看如何利用收据响应中的

630
00:28:57,504 --> 00:28:59,840
部分信息做到这一点

631
00:29:00,874 --> 00:29:03,043
我们回到刚才的示例订阅

632
00:29:03,277 --> 00:29:05,879
你可以看到我们的订户处于

633
00:29:05,946 --> 00:29:08,015
并将于4月26日到期续订

634
00:29:09,249 --> 00:29:13,153
我们想添加一些服务器端逻辑以使用

635
00:29:13,554 --> 00:29:17,524
和is_in_billing_retry_period字段

636
00:29:17,691 --> 00:29:19,459
在这个例子中为三天

637
00:29:19,893 --> 00:29:22,796
用户在这期间将能够继续访问该服务

638
00:29:22,863 --> 00:29:24,498
并在技术上仍然保持订阅状态

639
00:29:27,034 --> 00:29:28,368
你为什么要这样做呢？

640
00:29:28,435 --> 00:29:32,773
因为这是部署有效客户消息的好时机

641
00:29:33,173 --> 00:29:35,642
来在该情景下与你的订阅者进行沟通

642
00:29:35,809 --> 00:29:39,246
让他们知道他们的订阅可能存在问题

643
00:29:39,847 --> 00:29:43,383
你可能想要执行某些操作

644
00:29:43,617 --> 00:29:47,154
或让他们重申所订阅产品的

645
00:29:47,221 --> 00:29:48,622
价值定位

646
00:29:49,323 --> 00:29:52,593
在此期间 你也可以提供受限服务

647
00:29:52,659 --> 00:29:55,963
比如在娱乐app中可以浏览

648
00:29:58,232 --> 00:30:01,368
这里我们可以看到Peak

649
00:29:58,232 --> 00:30:01,368
这里我们可以看到Peak

650
00:30:02,503 --> 00:30:05,105
Peak正在利用结算重试状态字段

651
00:30:05,372 --> 00:30:08,442
来向其订阅者呈现一条情景消息

652
00:30:08,775 --> 00:30:12,179
让他们知道他们的订阅存在问题

653
00:30:12,479 --> 00:30:15,582
当用户与其交互时

654
00:30:15,749 --> 00:30:19,186
其中明确指出问题所在

655
00:30:21,388 --> 00:30:24,091
如果能将用户从这个界面

656
00:30:24,157 --> 00:30:27,661
直接引导到我们的系统中

657
00:30:27,728 --> 00:30:29,363
这将非常有效

658
00:30:30,597 --> 00:30:33,433
因此今天我很兴奋地宣布

659
00:30:33,500 --> 00:30:35,669
我们将有两个新的URL

660
00:30:36,203 --> 00:30:39,439
一个用来直接驱动用户

661
00:30:39,506 --> 00:30:41,909
另一个用来让用户管理自己的订阅

662
00:30:41,975 --> 00:30:45,379
比如Pete早些时候提到的

663
00:30:51,051 --> 00:30:53,453
这时很多开发者会问

664
00:30:53,520 --> 00:30:55,822
我们何时能看到我们的用户被恢复

665
00:30:56,890 --> 00:30:59,793
平均而言

666
00:30:59,860 --> 00:31:03,764
在平台上进入结算重试状态的

667
00:30:59,860 --> 00:31:03,764
在平台上进入结算重试状态的

668
00:31:06,166 --> 00:31:08,902
这应该是提供

669
00:31:09,203 --> 00:31:12,406
因为我们看到很多用户

670
00:31:13,941 --> 00:31:15,008
你最好在该期间末尾

671
00:31:15,075 --> 00:31:17,444
部署客户消息

672
00:31:17,511 --> 00:31:20,514
来引导一些可能需要更长时间

673
00:31:20,581 --> 00:31:21,815
你的app的订阅者

674
00:31:24,418 --> 00:31:26,920
让我们回到刚才的示例订阅

675
00:31:27,321 --> 00:31:31,091
如果我们成功恢复了这些用户的订阅

676
00:31:33,060 --> 00:31:37,431
当重试尝试成功时

677
00:31:37,497 --> 00:31:40,434
将成为新的订阅周期的起始日期

678
00:31:40,767 --> 00:31:42,936
这将在交易验证成功并完成时

679
00:31:43,003 --> 00:31:46,073
反映在JSON响应中

680
00:31:47,975 --> 00:31:49,409
但我们不会止步于此

681
00:31:49,710 --> 00:31:52,613
我们也将部署服务器到服务器通知

682
00:31:52,679 --> 00:31:54,715
以便你可以在所有平台上立即解锁

683
00:31:54,781 --> 00:31:58,151
用户的访问权限

684
00:31:58,218 --> 00:32:00,120
让他们知道

685
00:31:58,218 --> 00:32:00,120
让他们知道

686
00:32:02,489 --> 00:32:03,891
这是非自愿流失

687
00:32:04,057 --> 00:32:06,293
客户没有从技术上做出选择

688
00:32:06,360 --> 00:32:08,328
退订你的app

689
00:32:09,696 --> 00:32:11,098
什么是自愿流失呢？

690
00:32:12,366 --> 00:32:16,837
自愿流失是由于客户做出选择

691
00:32:17,337 --> 00:32:19,940
其可能是取消订阅或请求退款

692
00:32:20,774 --> 00:32:23,777
明确来说 该用户主动做出选择

693
00:32:23,844 --> 00:32:25,512
来离开你的订阅产品

694
00:32:26,847 --> 00:32:29,049
那么作为一名开发人员你能做什么

695
00:32:29,116 --> 00:32:32,119
来最大限度地减少

696
00:32:33,320 --> 00:32:36,657
Pete刚介绍了如何进行状态轮询

697
00:32:36,723 --> 00:32:39,726
以获取有关用户的一些

698
00:32:40,527 --> 00:32:41,828
当你获得该信息后

699
00:32:41,895 --> 00:32:45,766
你可以使用它来提供

700
00:32:45,832 --> 00:32:47,801
以尽可能保住该用户

701
00:32:51,104 --> 00:32:53,707
所以让我们再多谈一下状态轮询

702
00:32:55,108 --> 00:32:57,611
随着服务器到服务器通知的发布

703
00:32:57,811 --> 00:32:59,680
你仍然需要进行状态轮询

704
00:32:59,746 --> 00:33:01,515
实际上只有两个关键原因

705
00:32:59,746 --> 00:33:01,515
实际上只有两个关键原因

706
00:33:03,183 --> 00:33:05,018
首先是想知道

707
00:33:05,085 --> 00:33:08,555
我的订阅用户是否会在

708
00:33:09,556 --> 00:33:12,025
第二个是 我的用户续订了吗

709
00:33:14,228 --> 00:33:17,464
我们经常被问到 作为开发人员

710
00:33:17,531 --> 00:33:21,535
我什么时候应该尝试找到这些用户

711
00:33:23,537 --> 00:33:27,007
我们认为进行状态轮训

712
00:33:27,074 --> 00:33:29,543
在订阅期的开始或结束时

713
00:33:30,143 --> 00:33:31,645
通过响应式的部署

714
00:33:32,346 --> 00:33:34,681
你很可能会找到订阅产品中

715
00:33:35,015 --> 00:33:38,352
自愿流失的大多数用户

716
00:33:40,854 --> 00:33:42,055
但当你进行状态轮询时

717
00:33:42,122 --> 00:33:45,526
你还可以访问一些其他订户状态字段

718
00:33:46,860 --> 00:33:50,397
你可能想要获取这些字段并将对

719
00:33:50,464 --> 00:33:51,999
所返回的解码JSON响应

720
00:33:52,466 --> 00:33:54,468
保存到数据库的用户表中

721
00:33:55,435 --> 00:33:58,472
或者 你可以解析出特定的字段

722
00:33:59,072 --> 00:34:02,442
例如结算重试状态

723
00:33:59,072 --> 00:34:02,442
例如结算重试状态

724
00:34:02,509 --> 00:34:05,112
并且了解哪些人处于重试状态

725
00:34:05,179 --> 00:34:06,180
而哪些不是

726
00:34:07,915 --> 00:34:11,150
客户是否会自愿流失的标志

727
00:34:11,217 --> 00:34:14,721
通过称为auto_renew_status的字段显示

728
00:34:17,224 --> 00:34:19,993
auto_renew_status会让你知道

729
00:34:20,194 --> 00:34:23,664
如果其值为1 则该用户将

730
00:34:24,331 --> 00:34:27,835
若值为0则代表他们会在

731
00:34:27,900 --> 00:34:29,870
下一个续订日期自愿流失

732
00:34:31,804 --> 00:34:34,208
让我们看看这在我们的示例订阅中

733
00:34:35,708 --> 00:34:38,745
我们有一个3月26日购买的用户

734
00:34:41,114 --> 00:34:43,250
他已经通过管理订阅设置界面

735
00:34:43,317 --> 00:34:45,485
禁用了自动续订功能

736
00:34:47,020 --> 00:34:50,456
碰巧的是 我们在该事件发生后不久

737
00:34:51,123 --> 00:34:53,960
我们可以通过收据响应看到

738
00:34:54,261 --> 00:34:56,563
auto_renew_status已变为0了

739
00:34:58,031 --> 00:35:01,134
这时你可以更新你服务器上的

740
00:34:58,031 --> 00:35:01,134
这时你可以更新你服务器上的

741
00:35:01,201 --> 00:35:04,538
数据库中的用户表

742
00:35:04,605 --> 00:35:07,140
潜在自愿流失客户

743
00:35:10,010 --> 00:35:13,313
如果回到我们刚才的示例订阅

744
00:35:13,380 --> 00:35:16,550
我们了解到这位顾客可能会离开

745
00:35:16,617 --> 00:35:17,784
那我们该怎么办？

746
00:35:18,652 --> 00:35:21,088
作为开发者

747
00:35:21,154 --> 00:35:24,758
更具吸引力的降级优惠的机会

748
00:35:25,526 --> 00:35:28,328
在这里 我们可以看到

749
00:35:28,395 --> 00:35:30,697
通过向他们提供更短的使用期

750
00:35:30,764 --> 00:35:33,700
或更低价的订阅期

751
00:35:33,767 --> 00:35:35,335
或是另一个不同的产品

752
00:35:37,771 --> 00:35:40,841
如果该用户决定接受这些

753
00:35:40,908 --> 00:35:42,509
就像Pete向你展示的

754
00:35:42,576 --> 00:35:45,612
通过在你的app中

755
00:35:46,346 --> 00:35:49,416
我们想让你知道他们在接下来

756
00:35:49,483 --> 00:35:50,751
将续订的产品

757
00:35:52,920 --> 00:35:56,356
我们通过JSON响应中的

758
00:35:57,224 --> 00:35:59,026
这与产品ID不同

759
00:35:59,092 --> 00:36:03,263
因为这将是订阅者续订后的

760
00:35:59,092 --> 00:36:03,263
因为这将是订阅者续订后的

761
00:36:06,266 --> 00:36:08,402
我们可以在该示例订阅中看到

762
00:36:09,203 --> 00:36:12,206
我们的用户选择降级而不是流失

763
00:36:12,873 --> 00:36:15,008
我们已将auto_renew_status更改为1

764
00:36:15,876 --> 00:36:17,945
并且添加了auto_renew_product_id字段

765
00:36:19,680 --> 00:36:21,014
立即获悉此更改

766
00:36:21,181 --> 00:36:23,283
也是非常有益的

767
00:36:23,517 --> 00:36:26,987
为此 我们将发送一个

768
00:36:27,254 --> 00:36:31,425
让你知道你的订阅者

769
00:36:33,160 --> 00:36:37,064
如果你这时向用户说明

770
00:36:37,130 --> 00:36:39,399
与他们将在下一个订阅期

771
00:36:39,633 --> 00:36:42,169
有何不同 这将是非常有益的

772
00:36:44,271 --> 00:36:48,342
开展一个能100%留住用户的

773
00:36:48,842 --> 00:36:52,145
所以重要的是要了解

774
00:36:52,312 --> 00:36:54,815
流失的部分订阅用户

775
00:36:56,683 --> 00:37:00,087
赢回是指已流失用户的再次回归

776
00:36:56,683 --> 00:37:00,087
赢回是指已流失用户的再次回归

777
00:37:00,621 --> 00:37:02,556
这可能是通过向他们显示

778
00:37:03,056 --> 00:37:06,226
或调查他们离开的原因来达到的

779
00:37:08,028 --> 00:37:10,030
现在看看我们的示例订阅

780
00:37:10,097 --> 00:37:12,633
让我们看看自愿取消是什么样子的

781
00:37:12,699 --> 00:37:15,102
以及我们如何在app内部利用它

782
00:37:16,069 --> 00:37:19,740
在这里 我们的用户已选择

783
00:37:20,941 --> 00:37:23,343
为了让你知道这个事件

784
00:37:23,410 --> 00:37:25,746
我们将在JSON响应中

785
00:37:26,580 --> 00:37:30,684
这是你知道

786
00:37:30,751 --> 00:37:32,853
并取消或要求退款的标志

787
00:37:33,654 --> 00:37:37,758
但作为开发人员

788
00:37:38,992 --> 00:37:41,728
为此我们将部署一个

789
00:37:42,829 --> 00:37:46,200
这很重要

790
00:37:46,266 --> 00:37:47,935
这些用户的访问权限

791
00:37:48,569 --> 00:37:52,105
并可能向他们显示其他订阅优惠

792
00:37:54,208 --> 00:37:56,410
现在当这个用户流失后

793
00:37:56,476 --> 00:37:58,011
能够分辨他是自愿取消订阅

794
00:37:58,078 --> 00:38:01,348
还是由于某些支付或结算问题

795
00:37:58,078 --> 00:38:01,348
还是由于某些支付或结算问题

796
00:38:02,216 --> 00:38:04,484
而非自愿取消订阅

797
00:38:04,551 --> 00:38:06,186
非常重要

798
00:38:07,054 --> 00:38:11,859
为此我们在JSON响应中

799
00:38:12,626 --> 00:38:17,097
为了清晰起见

800
00:38:18,031 --> 00:38:20,267
我们真正关心的是两个关键值

801
00:38:20,767 --> 00:38:24,905
第一个值是1

802
00:38:25,639 --> 00:38:30,744
第二个值是2

803
00:38:33,046 --> 00:38:35,315
回到我们的示例订阅

804
00:38:35,382 --> 00:38:37,518
我们的客户

805
00:38:37,584 --> 00:38:40,320
可以看到我们已在收据响应中

806
00:38:40,387 --> 00:38:42,789
且其值为1

807
00:38:45,425 --> 00:38:47,060
那么你作为一名开发人员

808
00:38:47,127 --> 00:38:49,062
当看到用户处于这种状态

809
00:38:49,129 --> 00:38:51,732
并且你能分辨他们属于

810
00:38:51,798 --> 00:38:54,868
你该怎么做？

811
00:38:56,537 --> 00:39:00,007
对于自愿的情况

812
00:38:56,537 --> 00:39:00,007
对于自愿的情况

813
00:39:00,073 --> 00:39:02,176
建立过账户的订户进行调查

814
00:39:02,476 --> 00:39:05,846
你可以问他们为什么服务不适合他们

815
00:39:06,180 --> 00:39:07,748
以及你可以如何改善它

816
00:39:07,814 --> 00:39:11,318
从而为他们或其他用户

817
00:39:12,553 --> 00:39:16,089
此外 你还可以显示

818
00:39:16,323 --> 00:39:19,459
因为如果他们重新订阅这些产品

819
00:39:19,526 --> 00:39:23,163
你希望继续为85/15的

820
00:39:25,265 --> 00:39:28,735
当用户自愿流失时

821
00:39:29,403 --> 00:39:33,240
显示了重新订阅优惠

822
00:39:36,743 --> 00:39:40,080
对于非自愿流失

823
00:39:40,147 --> 00:39:41,215
要退订的决定

824
00:39:41,281 --> 00:39:44,651
只需显示相同或替代的订阅产品即可

825
00:39:45,252 --> 00:39:47,554
你可能想要在用户登录到

826
00:39:47,621 --> 00:39:50,123
显示一些持久的消息

827
00:39:50,190 --> 00:39:53,594
让他们知道他们已经失效

828
00:39:54,494 --> 00:39:57,865
你也可能想要部署受限订阅体验

829
00:39:58,298 --> 00:40:01,602
比如在娱乐app中只能浏览

830
00:39:58,298 --> 00:40:01,602
比如在娱乐app中只能浏览

831
00:40:02,936 --> 00:40:04,304
这是Tinder的界面

832
00:40:04,771 --> 00:40:08,742
当用户与专业级或订阅级功能

833
00:40:08,809 --> 00:40:11,245
他们不断被提示订阅

834
00:40:12,913 --> 00:40:15,782
总而言之 如果说你能

835
00:40:15,849 --> 00:40:17,384
任何关于减少用户流失的方法

836
00:40:17,584 --> 00:40:18,986
那就是你应该好好利用

837
00:40:19,052 --> 00:40:21,788
这些订阅收据字段

838
00:40:23,657 --> 00:40:26,260
然后你可以通过状态轮询来了解

839
00:40:26,326 --> 00:40:28,729
何时你的用户可能会自愿流失

840
00:40:32,466 --> 00:40:33,934
然后你可以使用该状态轮询

841
00:40:34,001 --> 00:40:36,837
来部署一些有针对性

842
00:40:38,672 --> 00:40:40,841
最后

843
00:40:40,908 --> 00:40:43,977
向这些用户展示相应的订阅优惠

844
00:40:44,044 --> 00:40:46,747
以此希望赢回他们

845
00:40:49,349 --> 00:40:51,818
现在我想将话筒交回同事Pete

846
00:40:51,885 --> 00:40:53,253
来讨论分析和报告的话题

847
00:40:53,320 --> 00:40:54,388
谢谢

848
00:41:02,829 --> 00:41:03,830
谢谢Michael

849
00:41:04,565 --> 00:41:07,234
如果你还没处理过这些JSON字段

850
00:41:07,301 --> 00:41:09,503
我们强烈建议你尝试一下

851
00:41:09,570 --> 00:41:11,405
并感受它对客户保有率的巨大作用

852
00:41:11,471 --> 00:41:13,307
作为工程师

853
00:41:13,373 --> 00:41:14,942
通过如此简单的架构调整

854
00:41:15,008 --> 00:41:18,478
就可以对业务收入产生

855
00:41:18,545 --> 00:41:19,913
所以我们一起来看看

856
00:41:19,980 --> 00:41:21,815
今天我们在分析和报告领域

857
00:41:21,882 --> 00:41:24,351
带来的一些很棒的新升级

858
00:41:24,751 --> 00:41:26,386
在App Store Connect中

859
00:41:26,453 --> 00:41:30,090
销售和趋势部分包含大量有用的信息

860
00:41:30,157 --> 00:41:32,993
现在你甚至可以更深入的了解

861
00:41:33,427 --> 00:41:35,963
当前的这个订阅摘要仪表板

862
00:41:36,029 --> 00:41:38,065
现在还可以监控

863
00:41:38,131 --> 00:41:40,601
处于结算重试状态的订阅

864
00:41:41,268 --> 00:41:44,004
这对了解用户行为

865
00:41:44,071 --> 00:41:46,039
以及确定最有效的宽限期长短

866
00:41:46,106 --> 00:41:47,341
非常有用

867
00:41:47,407 --> 00:41:49,076
就像刚才Michael谈到的

868
00:41:50,978 --> 00:41:53,447
今年我们还为订阅保有情况

869
00:41:53,514 --> 00:41:55,182
推出了一个全新的仪表板

870
00:41:55,883 --> 00:41:58,852
这个页面显示了推介价格的表现

871
00:41:59,219 --> 00:42:01,221
以及多少用户属于

872
00:41:59,219 --> 00:42:01,221
以及多少用户属于

873
00:42:01,288 --> 00:42:02,422
高提成客户

874
00:42:02,489 --> 00:42:04,691
也就是当用户订阅超过一年时

875
00:42:04,758 --> 00:42:06,660
85/15提成

876
00:42:08,095 --> 00:42:09,763
仪表板包含新的图表

877
00:42:10,464 --> 00:42:12,866
来帮助你快速识别哪些订阅群组

878
00:42:12,933 --> 00:42:14,234
是表现最好的

879
00:42:14,301 --> 00:42:17,571
而且你可以随时监控你的订阅效果

880
00:42:17,638 --> 00:42:21,141
并比较你的app在不同时期的表现

881
00:42:22,276 --> 00:42:25,179
现在 所有这些新信息不仅可以

882
00:42:25,245 --> 00:42:27,014
在App Store Connect报告中显示

883
00:42:27,080 --> 00:42:29,983
还可以通过新的

884
00:42:30,784 --> 00:42:33,120
这里的报告数据每天都会提供给你

885
00:42:33,187 --> 00:42:36,190
你可以编写自己的程序

886
00:42:36,256 --> 00:42:39,226
来将其存入你自己的数据仓库

887
00:42:39,893 --> 00:42:41,628
我们不会讨论更多关于

888
00:42:41,695 --> 00:42:42,863
App Store Connect API的细节

889
00:42:42,930 --> 00:42:44,264
但我强烈建议你观看

890
00:42:44,331 --> 00:42:47,201
周四下午3点在三号厅举办的

891
00:42:47,267 --> 00:42:48,635
“自动化App Store Connect”演讲

892
00:42:48,702 --> 00:42:52,005
其在自动化领域有一些

893
00:42:53,006 --> 00:42:55,375
我们讨论了你可以从收据中得到什么

894
00:42:55,442 --> 00:42:57,878
以及你可以从这些

895
00:42:57,945 --> 00:42:59,580
现在总结一下

896
00:42:59,646 --> 00:43:01,448
App Store收据可以用来

897
00:42:59,646 --> 00:43:01,448
App Store收据可以用来

898
00:43:01,515 --> 00:43:04,251
验证那些StoreKit交易

899
00:43:04,318 --> 00:43:07,120
并更新用户的订阅状态

900
00:43:07,387 --> 00:43:10,524
你也能像Michael演示的那样

901
00:43:10,591 --> 00:43:12,159
使用它们来了解个人用户的行为

902
00:43:13,327 --> 00:43:15,963
对于App Store Connect报告而言

903
00:43:16,029 --> 00:43:18,298
它们更适合宏观层面的分析

904
00:43:18,365 --> 00:43:21,902
比如了解用户的订阅路径

905
00:43:21,969 --> 00:43:25,172
或者最重要的是

906
00:43:25,239 --> 00:43:27,374
获得多少收入

907
00:43:29,543 --> 00:43:32,779
今天我们谈论了很多主题

908
00:43:33,213 --> 00:43:37,050
请记住 当涉及到订阅管理时

909
00:43:37,117 --> 00:43:39,453
服务器端状态管理

910
00:43:40,687 --> 00:43:42,890
如果你尚未这样做

911
00:43:42,956 --> 00:43:45,158
接收来自App Store的通知

912
00:43:46,293 --> 00:43:48,262
考虑在你的app中设置推介价格

913
00:43:48,328 --> 00:43:50,130
这是让用户开始

914
00:43:50,197 --> 00:43:51,498
订阅你的app的好方法

915
00:43:52,633 --> 00:43:55,435
使用Michael向我们介绍的

916
00:43:55,502 --> 00:43:57,804
来添加一些简单的消息

917
00:43:57,871 --> 00:43:59,706
对于实际已失效的用户

918
00:44:00,741 --> 00:44:02,442
提供一些替代的的订阅选项

919
00:44:02,509 --> 00:44:03,844
也许这样可以赢回他们

920
00:44:04,745 --> 00:44:06,813
最后 别忘了试试这些新的报告工具

921
00:44:06,880 --> 00:44:08,649
它们可在App Store Connect中找到

922
00:44:10,384 --> 00:44:12,519
有关本次演讲和视频的更多信息

923
00:44:12,586 --> 00:44:14,154
本次演讲编号为705

924
00:44:14,521 --> 00:44:17,324
我们稍后和星期四上午9:00

925
00:44:17,391 --> 00:44:18,926
都会有实验室

926
00:44:18,992 --> 00:44:20,794
我们将有来自StoreKit

927
00:44:20,861 --> 00:44:22,095
和App Store Connect团队的工程师

928
00:44:22,162 --> 00:44:23,730
随时准备回答你可能遇到的

929
00:44:23,797 --> 00:44:25,499
任何关于订阅工程的问题

930
00:44:25,566 --> 00:44:26,400
非常感谢
