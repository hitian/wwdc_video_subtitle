1
00:00:17,284 --> 0:00:21,421
（测试提示和技巧 演讲417）

2
00:00:32,432 --> 0:00:33,300
大家好

3
00:00:33,367 --> 0:00:35,169
欢迎来到“测试提示和技巧”

4
00:00:36,069 --> 0:00:37,571
我叫Brian Croom

5
00:00:38,305 --> 0:00:39,806
我的同事Stuart和我

6
00:00:39,873 --> 0:00:42,943
真的很高兴与你们分享

7
00:00:43,010 --> 0:00:44,578
我们最近一直在学习这些技术

8
00:00:47,848 --> 0:00:50,717
随着会议的临近

9
00:00:50,784 --> 0:00:52,486
用它能够在会议中心周围

10
00:00:52,553 --> 0:00:56,423
找一些我们能够去看和做的东西

11
00:00:57,791 --> 0:00:59,026
我们一直在创建这app

12
00:00:59,393 --> 0:01:03,497
为它在圣何塞周围寻找

13
00:00:59,393 --> 0:01:03,497
为它在圣何塞周围寻找

14
00:01:03,864 --> 0:01:05,699
并列出了它们离你有多远

15
00:01:07,568 --> 0:01:09,503
现在当然我们想要确保

16
00:01:09,570 --> 0:01:11,738
我们有一个非常棒的测试套件

17
00:01:12,372 --> 0:01:16,143
我们可以运行这个app

18
00:01:16,443 --> 0:01:18,812
并且随着开发的继续

19
00:01:21,882 --> 0:01:25,419
今天我们想与你们分享四套

20
00:01:25,485 --> 0:01:28,622
我们在为app编写测试时

21
00:01:30,290 --> 0:01:33,627
一些在app中测试网络代码的策略

22
00:01:34,895 --> 0:01:38,732
一些用于处理基础通知对象的

23
00:01:40,300 --> 0:01:44,671
在测试中使用模拟对象时

24
00:01:45,639 --> 0:01:48,775
以及一些使测试运行速度

25
00:01:52,446 --> 0:01:54,248
现在让我们开始讨论网络吧

26
00:01:55,883 --> 0:01:59,253
为了允许动态内容更新

27
00:01:59,319 --> 0:02:01,421
以便从远程网络服务器加载数据

28
00:01:59,319 --> 0:02:01,421
以便从远程网络服务器加载数据

29
00:02:02,856 --> 0:02:04,491
这里我们发现一些

30
00:02:04,558 --> 0:02:06,460
网络代码编写测试时有用的东西

31
00:02:08,794 --> 0:02:11,565
首先快速回顾一下去年的情况

32
00:02:12,332 --> 0:02:16,637
在2017年WWDC

33
00:02:17,070 --> 0:02:18,939
我们讨论了金字塔模型

34
00:02:19,306 --> 0:02:21,508
它是如何构造测试套件

35
00:02:21,909 --> 0:02:26,480
平衡彻底性

36
00:02:28,615 --> 0:02:31,818
总之 理想的测试套件往往是

37
00:02:31,885 --> 0:02:34,488
由大量集中的单元测试组成

38
00:02:34,555 --> 0:02:38,025
能够在你的app中

39
00:02:39,693 --> 0:02:42,262
它们的特点是阅读简单

40
00:02:42,963 --> 0:02:46,099
在检测到问题时

41
00:02:47,000 --> 0:02:48,569
并且运行速度非常快

42
00:02:48,802 --> 0:02:51,939
通常是每分钟数百或数千次测试

43
00:02:54,741 --> 0:02:59,379
这些测试由较小数量的

44
00:03:00,214 --> 0:03:03,951
这些测试以app中的

45
00:03:04,918 --> 0:03:06,787
检查它们是否一起正常工作

46
00:03:07,087 --> 0:03:09,089
每个测试只需几秒钟即可运行

47
00:03:11,792 --> 0:03:15,095
这个套件是一些端到端的系统测试

48
00:03:15,562 --> 0:03:17,898
最常见的形式是UI测试

49
00:03:18,432 --> 0:03:20,734
它非常类似于终端用户

50
00:03:20,801 --> 0:03:23,203
在他们的设备上的操作方式

51
00:03:24,538 --> 0:03:26,807
检查所有的部分

52
00:03:27,107 --> 0:03:31,678
以及检查与底层操作系统

53
00:03:33,680 --> 0:03:35,782
遵循该模型的测试套件

54
00:03:36,116 --> 0:03:39,520
可以全面描述app代码的基本功能

55
00:03:43,790 --> 0:03:45,826
为了测试这个app中的网络堆栈

56
00:03:46,193 --> 0:03:48,362
我们真的很想

57
00:03:48,929 --> 0:03:51,565
将它作为如何构建测试套件的指南

58
00:03:53,333 --> 0:03:55,202
在这里我们看到了

59
00:03:55,269 --> 0:03:57,504
在app中发出网络请求并将数据

60
00:03:57,804 --> 0:03:59,573
输入UI所涉及的高级数据流

61
00:04:02,342 --> 0:04:03,911
在这个app的早期原型中

62
00:04:04,444 --> 0:04:05,846
我们在视图控制器中有个方法

63
00:04:05,913 --> 0:04:08,382
它可以在一个地方完成所有这些工作

64
00:04:09,116 --> 0:04:10,284
它看起来和这个很相似

65
00:04:12,486 --> 0:04:15,455
该方法接受一个带有用户位置的参数

66
00:04:17,357 --> 0:04:20,928
并使用该参数为我们的

67
00:04:21,161 --> 0:04:23,230
并将该位置作为查询参数

68
00:04:26,133 --> 0:04:29,069
然后它使用Foundation的

69
00:04:29,336 --> 0:04:32,606
为向那个URL得到一个请求

70
00:04:34,908 --> 0:04:37,978
当服务器响应时它将打开数据

71
00:04:39,479 --> 0:04:42,349
使用foundation的

72
00:04:42,950 --> 0:04:45,519
将其解码为一个有关值的数组

73
00:04:45,586 --> 0:04:47,521
这是我在其他地方声明过的一个结构

74
00:04:47,855 --> 0:04:49,823
并符合可解码协议

75
00:04:51,825 --> 0:04:53,360
然后将其存储到属性中

76
00:04:53,427 --> 0:04:55,829
以驱实现动表视图数据源

77
00:04:56,029 --> 0:04:57,264
并将其放到屏幕上

78
00:05:00,567 --> 0:05:03,303
现在非常值得注意的是

79
00:05:03,370 --> 0:05:05,305
利用Swift

80
00:05:05,739 --> 0:05:08,075
能够在大约15行代码中

81
00:05:09,443 --> 0:05:11,778
但是通过一个方法来做所有这些

82
00:05:12,179 --> 0:05:13,947
那么我就损害了代码的可维护性

83
00:05:14,014 --> 0:05:16,383
特别是代码的可测试性

84
00:05:20,921 --> 0:05:23,257
来看看我们的测试金字塔的基础

85
00:05:23,457 --> 0:05:26,860
我们真正想要做的是为每个流的

86
00:05:26,927 --> 0:05:28,662
每个部分编写焦点单元测试

87
00:05:30,864 --> 0:05:34,935
让我们首先考虑请求准备

88
00:05:38,772 --> 0:05:41,141
为了使这段代码更具可测试性

89
00:05:41,842 --> 0:05:44,111
我们首先从视图控制器中取出它

90
00:05:45,546 --> 0:05:49,316
PointsOfInterestRequest

91
00:05:50,584 --> 0:05:53,287
这给出了两个很好的解耦方法

92
00:05:53,353 --> 0:05:55,822
每个都取一些值作为输入

93
00:05:56,223 --> 0:06:00,160
并将它们转换为一些输出值

94
00:05:56,223 --> 0:06:00,160
并将它们转换为一些输出值

95
00:06:03,330 --> 0:06:05,232
这使得我们很容易

96
00:06:05,599 --> 0:06:07,901
为代码编写一个集中的单元测试

97
00:06:09,503 --> 0:06:11,371
在这里我们测试

98
00:06:12,039 --> 0:06:14,208
只要做一个样本并放置位置

99
00:06:14,274 --> 0:06:15,742
将其传递到这个方法中

100
00:06:16,210 --> 0:06:18,846
并对其返回值做出一些认定

101
00:06:22,082 --> 0:06:26,253
类似地 我们可以通过传入

102
00:06:26,386 --> 0:06:28,522
并对解析的结果进行断言

103
00:06:31,491 --> 0:06:34,027
关于这个测试的另一点需要注意的是

104
00:06:34,428 --> 0:06:36,864
我正在使用XCTest支持

105
00:06:36,930 --> 0:06:38,999
来用于标记为抛出的测试方法

106
00:06:39,399 --> 0:06:42,169
这允许我在测试代码中使用try

107
00:06:42,336 --> 0:06:44,705
而不需在测试代码周围使用

108
00:06:49,042 --> 0:06:52,112
现在让我们看看

109
00:06:54,581 --> 0:06:56,884
这里我们再次将其拉出视图控制器

110
00:06:57,985 --> 0:07:00,220
并使用与我们刚才看到的

111
00:06:57,985 --> 0:07:00,220
并使用与我们刚才看到的

112
00:07:00,287 --> 0:07:02,055
请求类型匹配方法签名的方法

113
00:07:02,122 --> 0:07:04,291
创建了APIRequest协议

114
00:07:05,526 --> 0:07:08,362
这是被请求类型初始化的

115
00:07:09,530 --> 0:07:13,901
和urlSession实例类

116
00:07:17,504 --> 0:07:20,174
这个类有一个

117
00:07:20,674 --> 0:07:24,478
它使用该apiRequest值

118
00:07:25,412 --> 0:07:27,314
将其输入到urlSession中

119
00:07:28,415 --> 0:07:31,151
然后再用apiRequest

120
00:07:34,721 --> 0:07:37,491
现在我们可以继续为这个方法

121
00:07:37,925 --> 0:07:40,194
但是现在我实际上想要向上

122
00:07:40,527 --> 0:07:42,629
并查看一个中级集成测试

123
00:07:42,696 --> 0:07:44,898
它涵盖了这个数据流的几个部分

124
00:07:47,000 --> 0:07:49,903
在套件的这一层我还能够进行的

125
00:07:49,970 --> 0:07:53,106
我与URLSession API

126
00:07:53,173 --> 0:07:55,375
的交互是正确的

127
00:07:57,010 --> 0:07:59,847
事实证明

128
00:07:59,913 --> 0:08:01,682
系统为实现这点提供了很大的帮助

129
00:07:59,913 --> 0:08:01,682
系统为实现这点提供了很大的帮助

130
00:08:04,184 --> 0:08:07,588
URLSession为用于

131
00:08:07,654 --> 0:08:09,089
提供了一个高级API

132
00:08:10,424 --> 0:08:12,459
弯曲对象 如表示飞行请求的

133
00:08:12,526 --> 0:08:14,561
URLSession数据任务

134
00:08:15,896 --> 0:08:17,264
然而在幕后还有另一个较低级别的

135
00:08:17,497 --> 0:08:20,701
API URLProtocol

136
00:08:21,368 --> 0:08:24,571
它来执行打开网络连接 编写请求

137
00:08:24,738 --> 0:08:27,674
和读取响应的底层工作

138
00:08:29,810 --> 0:08:32,145
URLProtocol

139
00:08:32,546 --> 0:08:35,849
为URL加载系统提供了一个扩展点

140
00:08:39,253 --> 0:08:42,589
Foundation为诸如

141
00:08:42,789 --> 0:08:44,725
提供内置协议子类

142
00:08:45,592 --> 0:08:49,229
但是我们可以在测试中覆盖这些内容

143
00:08:50,063 --> 0:08:51,932
方法是提供一个模拟协议

144
00:08:51,999 --> 0:08:55,636
允许我们对即将发出的请求进行断言

145
00:08:59,673 --> 0:09:02,509
URLProtocol通过

146
00:08:59,673 --> 0:09:02,509
URLProtocol通过

147
00:09:02,676 --> 0:09:05,279
将进程通信回系统

148
00:09:08,015 --> 0:09:09,850
我们可以用这个方法

149
00:09:10,984 --> 0:09:13,987
我们在测试包中创建一个

150
00:09:14,821 --> 0:09:18,458
重写canInit请求

151
00:09:18,525 --> 0:09:21,295
以向系统表明

152
00:09:23,864 --> 0:09:26,099
实现canonicalRequest

153
00:09:26,567 --> 0:09:29,970
但startLoading和StopLoading

154
00:09:34,808 --> 0:09:37,611
为了给我们的测试提供一种连接到

155
00:09:38,078 --> 0:09:41,949
我们将提供一个闭包属性

156
00:09:44,885 --> 0:09:47,120
当一个URLSession

157
00:09:47,187 --> 0:09:50,224
系统将实例化我们的

158
00:09:50,591 --> 0:09:55,395
为它提供URLRequest值和

159
00:09:57,264 --> 0:09:59,132
然后它将调用

160
00:09:59,733 --> 0:10:02,703
在该方法中我们将使用测试设置的

161
00:09:59,733 --> 0:10:02,703
在该方法中我们将使用测试设置的

162
00:10:03,437 --> 0:10:05,906
并在参数处使用

163
00:10:07,574 --> 0:10:10,344
我们将获取它返回的内容

164
00:10:10,978 --> 0:10:13,547
和数据传递回系统

165
00:10:14,748 --> 0:10:15,782
或作为一个错误传递回系统

166
00:10:18,619 --> 0:10:20,787
如果你想要取消测试请求

167
00:10:20,854 --> 0:10:24,591
我们可以在停止加载方法实现中

168
00:10:28,862 --> 0:10:31,832
有了存根协议我们就可以编写测试了

169
00:10:33,400 --> 0:10:36,336
我们创建一个

170
00:10:36,637 --> 0:10:40,340
用一个请求类型和一个配置为使用

171
00:10:40,407 --> 0:10:42,776
我们的URLProtocol的

172
00:10:46,313 --> 0:10:50,851
在测试体中我们在MockURLProtocol上

173
00:10:51,752 --> 0:10:54,621
对将要发出的请求作出断言

174
00:10:55,889 --> 0:10:57,524
然后提供一个存根响应

175
00:10:59,826 --> 0:11:01,862
然后我们可以调用

176
00:10:59,826 --> 0:11:01,862
然后我们可以调用

177
00:11:03,030 --> 0:11:04,898
等待调用完成块

178
00:11:06,166 --> 0:11:08,368
并对解析响应作出断言

179
00:11:11,038 --> 0:11:14,575
在这一层上的几个测试可以给

180
00:11:14,641 --> 0:11:16,410
使我们相信我们的代码

181
00:11:16,476 --> 0:11:19,179
而且我们正在与系统进行适当的集成

182
00:11:19,780 --> 0:11:23,083
例如如果我忘记在我的数据任务中

183
00:11:23,150 --> 0:11:25,953
那么我们刚才看到的测试就会失败

184
00:11:26,553 --> 0:11:28,655
我相信我不是唯一犯过这个错误的人

185
00:11:33,360 --> 0:11:35,529
最后包含一些系统级的

186
00:11:35,596 --> 0:11:38,699
端到端测试也是非常有价值的

187
00:11:39,766 --> 0:11:42,769
实际上测试

188
00:11:44,471 --> 0:11:46,173
要了解更多关于UI测试的信息

189
00:11:46,240 --> 0:11:50,711
请参考2015年WWDC的

190
00:11:53,981 --> 0:11:56,917
现在当你开始编写真正的

191
00:11:56,984 --> 0:11:59,620
你遇到的一个重大挑战是

192
00:12:00,120 --> 0:12:02,456
当你遇到测试失败时

193
00:12:02,523 --> 0:12:04,925
很难知道从哪里开始

194
00:12:04,992 --> 0:12:06,193
寻找问题的根源

195
00:12:07,928 --> 0:12:10,731
我们最近在测试中

196
00:12:11,298 --> 0:12:13,867
设置一个模拟服务器的本地实例

197
00:12:14,301 --> 0:12:18,639
中断我们的UI测试来对其发出请求

198
00:12:19,706 --> 0:12:22,309
这使得我们的UI测试更加可靠

199
00:12:22,376 --> 0:12:25,512
因为我们可以控制

200
00:12:28,649 --> 0:12:31,785
虽然在这个上下文中

201
00:12:32,186 --> 0:12:35,989
但是让一些测试针对真正的

202
00:12:38,926 --> 0:12:40,561
其一种很酷的技术就是

203
00:12:40,627 --> 0:12:43,230
可以在单元测试包中进行一些测试

204
00:12:43,497 --> 0:12:46,233
直接调用

205
00:12:47,000 --> 0:12:49,770
并使用这些测试

206
00:12:51,071 --> 0:12:54,908
这提供了一种验证服务器

207
00:12:54,975 --> 0:12:56,643
是否与app的方式相同的方法

208
00:12:57,544 --> 0:12:59,847
并且你可以解析服务器的响应

209
00:13:00,347 --> 0:13:02,516
而不必同时处理

210
00:13:02,583 --> 0:13:04,618
测试UI的复杂问题

211
00:13:10,357 --> 0:13:13,327
因此最后我们看到了一个

212
00:13:13,393 --> 0:13:16,230
将代码分解成更小独立的部分

213
00:13:16,296 --> 0:13:17,831
以便单元测试的例子

214
00:13:19,566 --> 0:13:24,571
我们已看到了如何使用URLProtocol

215
00:13:26,340 --> 0:13:29,209
我们还讨论了如何使用

216
00:13:29,276 --> 0:13:31,745
来帮助我们构建

217
00:13:31,812 --> 0:13:33,714
这将使我们对我们的代码充满信心

218
00:13:35,449 --> 0:13:39,253
现在我想把Stuart叫到台上

219
00:13:43,190 --> 0:13:44,124
谢谢

220
00:13:46,560 --> 0:13:47,494
谢谢 Brian

221
00:13:48,195 --> 0:13:50,430
那么我想要讨论的第一个领域是

222
00:13:50,497 --> 0:13:53,000
测试通知的一些最佳实践方法

223
00:13:54,735 --> 0:13:57,471
澄清一下 这里的通知

224
00:13:57,538 --> 0:14:00,107
我说的是基础级别的通知

225
00:13:57,538 --> 0:14:00,107
我说的是基础级别的通知

226
00:14:00,174 --> 0:14:02,576
和Objective-C

227
00:14:03,377 --> 0:14:07,114
是的 有时我们需要测试

228
00:14:07,281 --> 0:14:10,617
而另一些时候我们需要测试

229
00:14:11,451 --> 0:14:14,588
通知是一种一对多的通信机制

230
00:14:14,788 --> 0:14:17,824
这意味着在发布单个通知时

231
00:14:17,891 --> 0:14:20,694
它可能会通过

232
00:14:20,928 --> 0:14:24,131
甚至是你的app进程运行的

233
00:14:24,198 --> 0:14:28,001
因此正因为这一点 我们必须始终

234
00:14:28,068 --> 0:14:33,540
以独立的方式测试通知

235
00:14:33,607 --> 0:14:37,044
因为这可能导致不稳定不可靠的测试

236
00:14:37,578 --> 0:14:40,280
让我们看一个

237
00:14:41,348 --> 0:14:43,750
在这里有 Brian和我

238
00:14:43,817 --> 0:14:45,552
的PointsOfInterest

239
00:14:46,119 --> 0:14:49,590
表视图中显示了附近有趣地点的列表

240
00:14:49,723 --> 0:14:52,526
每当app的位置授权发生变化时

241
00:14:52,593 --> 0:14:54,228
它可能需要重新加载数据

242
00:14:54,695 --> 0:14:57,464
因此它从app的

243
00:14:57,531 --> 0:15:00,167
观察到一个名为

244
00:14:57,531 --> 0:15:00,167
观察到一个名为

245
00:15:00,767 --> 0:15:04,338
当它观察到这个通知时

246
00:15:04,404 --> 0:15:07,608
它会在必要时重新加载它的数据

247
00:15:08,275 --> 0:15:11,478
这样我们的测试代码就可以检查标志

248
00:15:11,545 --> 0:15:13,614
看看是否实际收到了通知

249
00:15:14,548 --> 0:15:17,451
这里我们可以看到它正在使用

250
00:15:17,518 --> 0:15:18,752
默认的通知中心来添加观察者

251
00:15:19,853 --> 0:15:22,623
让我们来看看

252
00:15:23,857 --> 0:15:25,759
在这个类的测试中

253
00:15:25,826 --> 0:15:29,229
我们发布了AuthChanged

254
00:15:29,296 --> 0:15:31,532
并将它发布到默认的

255
00:15:31,598 --> 0:15:33,367
与我们的视图控制器使用相同

256
00:15:34,034 --> 0:15:37,437
现在这个测试起作用了

257
00:15:37,504 --> 0:15:38,906
但它可能在app代码的

258
00:15:39,439 --> 0:15:41,608
一些系统通知很常见

259
00:15:41,675 --> 0:15:45,345
appDidFinish

260
00:15:45,412 --> 0:15:48,549
被许多层观察到并且有未知的副作用

261
00:15:48,849 --> 0:15:51,218
或者它只会减慢我们的测试速度

262
00:15:51,585 --> 0:15:54,788
因此我们想

263
00:15:56,790 --> 0:15:59,760
我们可以使用一种技术

264
00:16:00,294 --> 0:16:01,962
要使用它我们首先必须认识到

265
00:16:02,029 --> 0:16:04,831
NotificationCenter

266
00:16:05,465 --> 0:16:10,137
你可能会注意到

267
00:16:10,204 --> 0:16:13,340
但它支持在必要时创建其他实例

268
00:16:13,407 --> 0:16:15,709
这将是隔离我们测试的关键

269
00:16:16,443 --> 0:16:20,647
因此要应用这种技术我们首先

270
00:16:20,848 --> 0:16:24,618
将它传递给我们的主题并使用它

271
00:16:25,519 --> 0:16:27,754
这通常被称为依赖注入

272
00:16:28,488 --> 0:16:30,824
我们来看看

273
00:16:31,892 --> 0:16:35,662
在这里我有使用默认

274
00:16:35,863 --> 0:16:38,198
我将它修改为使用一个单独的实例

275
00:16:39,433 --> 0:16:41,768
我添加了一个新的

276
00:16:41,969 --> 0:16:44,104
并在设置它的初始化器中

277
00:16:44,738 --> 0:16:47,708
它使用这个新属性

278
00:16:48,108 --> 0:16:49,643
而不是向默认中心添加一个观察者

279
00:16:51,879 --> 0:16:56,183
我还将向初始化器添加默认的

280
00:16:56,250 --> 0:16:59,253
这样可以避免在我的app中

281
00:16:59,319 --> 0:17:02,189
因为现有的客户端不需要通过

282
00:16:59,319 --> 0:17:02,189
因为现有的客户端不需要通过

283
00:17:02,256 --> 0:17:03,757
只有我们的单元测试会需要

284
00:17:05,925 --> 0:17:07,828
现在让我们回去并更新我们的测试

285
00:17:08,862 --> 0:17:10,396
这是最初的测试代码

286
00:17:11,031 --> 0:17:14,434
我已修改它以使用单独的

287
00:17:18,105 --> 0:17:21,608
这显示了如何测试

288
00:17:21,675 --> 0:17:24,578
但是如何测试

289
00:17:25,479 --> 0:17:29,116
我们将再次使用相同的

290
00:17:29,183 --> 0:17:32,252
但我还将展示如何使用

291
00:17:32,319 --> 0:17:34,087
来添加通知观察者

292
00:17:35,489 --> 0:17:37,691
这是我们app的另一部分代码

293
00:17:37,958 --> 0:17:39,893
CurrentLocationProvider类

294
00:17:40,527 --> 0:17:44,431
稍后我将详细讨论这个类

295
00:17:44,498 --> 0:17:46,700
它有向我app中其他类

296
00:17:46,767 --> 0:17:50,771
即该app的位置授权

297
00:17:51,939 --> 0:17:53,273
和我们的视图控制器一样

298
00:17:53,340 --> 0:17:56,276
它目前正硬编码默认的

299
00:17:58,545 --> 0:18:00,881
这是我为这个类写的单元测试

300
00:17:58,545 --> 0:18:00,881
这是我为这个类写的单元测试

301
00:18:01,014 --> 0:18:03,050
它用来验证

302
00:18:03,116 --> 0:18:05,652
在调用NotifyAuthChanged

303
00:18:06,887 --> 0:18:10,824
我们可以在这里的中间部分看到

304
00:18:10,891 --> 0:18:12,726
创建一个基于块的观察者

305
00:18:12,926 --> 0:18:15,095
然后它移除块内的观察者

306
00:18:16,063 --> 0:18:18,031
现在我可以对这个测试做一个改进

307
00:18:18,098 --> 0:18:19,399
就是使用内置的

308
00:18:19,466 --> 0:18:22,402
XCTNSNotificationExpectation

309
00:18:22,469 --> 0:18:26,373
来为我们创建这个

310
00:18:27,574 --> 0:18:28,876
这是一个很好的改进

311
00:18:29,142 --> 0:18:31,612
它允许我们删除几行代码

312
00:18:32,713 --> 0:18:34,515
但它仍然有我们之前看到的问题

313
00:18:34,581 --> 0:18:37,417
即隐式使用默认

314
00:18:37,484 --> 0:18:38,652
我们来解决这个问题

315
00:18:40,120 --> 0:18:41,388
这是我们的原始代码

316
00:18:42,556 --> 0:18:44,525
我将应用前面看到的相同的技术

317
00:18:44,591 --> 0:18:47,728
在初始化器中使用一个单独的

318
00:18:47,928 --> 0:18:50,664
存储它并使用它而不是默认值

319
00:18:53,734 --> 0:18:55,369
现在回到我们的测试代码

320
00:18:56,203 --> 0:18:59,339
将一个新的NotificationCenter

321
00:19:00,240 --> 0:19:02,342
但是现在我们来看一下期望

322
00:19:03,310 --> 0:19:07,381
当我们的测试期望接收到

323
00:19:07,614 --> 0:19:10,083
我们可以将

324
00:19:10,150 --> 0:19:11,852
传递给预期的初始化器

325
00:19:13,720 --> 0:19:18,759
我还想指出这个期望的超时值是0

326
00:19:18,926 --> 0:19:21,628
这是因为我们实际上期望

327
00:19:21,695 --> 0:19:22,996
它在我们等待它时已实现

328
00:19:23,830 --> 0:19:26,466
这是因为在

329
00:19:26,533 --> 0:19:29,369
方法返回时通知应该已经发布了

330
00:19:30,571 --> 0:19:33,740
因此使用这对技术来测试通知

331
00:19:34,107 --> 0:19:36,443
我们可以确保我们的测试

332
00:19:36,977 --> 0:19:40,814
并且我们在不需要修改app中的

333
00:19:40,948 --> 0:19:43,383
因为我们指定了默认的参数值

334
00:19:47,921 --> 0:19:50,190
接下来我想谈谈在编写单元

335
00:19:50,257 --> 0:19:53,827
测试时经常遇到的一个挑战

336
00:19:55,896 --> 0:19:59,166
在开发app时

337
00:19:59,233 --> 0:20:01,869
你的类正在与其他类对话

338
00:19:59,233 --> 0:20:01,869
你的类正在与其他类对话

339
00:20:01,935 --> 0:20:05,239
无论是在app的其他地方

340
00:20:05,639 --> 0:20:07,941
你发现编写测试很困难

341
00:20:08,008 --> 0:20:12,179
因为创建外部类很难甚至是不可能的

342
00:20:12,846 --> 0:20:15,249
这种情况经常发生 特别是

343
00:20:15,315 --> 0:20:17,417
对于那些没有被直接创建的API中

344
00:20:17,751 --> 0:20:21,822
而且当这些API具有需要测试的

345
00:20:22,890 --> 0:20:25,826
我想展示如何通过模拟

346
00:20:25,959 --> 0:20:28,762
与外部类的交互来使用协议

347
00:20:28,929 --> 0:20:31,899
而且这样做并不会降低测试的可靠性

348
00:20:34,134 --> 0:20:37,437
在我们的app中

349
00:20:37,504 --> 0:20:38,939
CurrentLocationProvider类

350
00:20:39,806 --> 0:20:41,708
它创建一个

351
00:20:41,842 --> 0:20:43,610
并在它的初始化器中配置它

352
00:20:43,944 --> 0:20:47,614
设置它想要的精度属性

353
00:20:50,017 --> 0:20:51,351
这是这门类的重点

354
00:20:51,518 --> 0:20:53,654
它是一个名为

355
00:20:54,154 --> 0:20:56,857
它请求当前位置并获取一个完成块

356
00:20:56,924 --> 0:20:59,693
该块返回该位置是否为感兴趣的点

357
00:21:00,894 --> 0:21:03,197
请注意我们在这里调用

358
00:21:03,263 --> 0:21:05,032
CLLocationManager

359
00:21:05,899 --> 0:21:09,069
当我们调用它时

360
00:21:09,303 --> 0:21:11,738
并最终调用类上的委托方法

361
00:21:12,172 --> 0:21:13,841
那么 让我们来看看委托方法

362
00:21:15,309 --> 0:21:19,680
我们使用一个扩展来遵循这里的

363
00:21:19,813 --> 0:21:21,682
我们并且调用一个存储完成块

364
00:21:22,449 --> 0:21:25,285
好的

365
00:21:26,753 --> 0:21:29,289
这里是我尝试编写的一个

366
00:21:29,489 --> 0:21:33,093
我们可以看到它首先创建一个

367
00:21:33,594 --> 0:21:37,197
然后检查所需的精度

368
00:21:37,497 --> 0:21:38,532
到现在为止还好

369
00:21:39,166 --> 0:21:40,734
但事情就变得棘手了

370
00:21:41,301 --> 0:21:43,871
我们想测试

371
00:21:44,137 --> 0:21:47,674
因为这是我们的主要逻辑所在

372
00:21:48,175 --> 0:21:51,745
我们无法知道何时调用请求位置方法

373
00:21:52,012 --> 0:21:55,983
因为这是CLLocationManager上的

374
00:21:57,551 --> 0:22:00,053
我们在这个测试中

375
00:21:57,551 --> 0:22:00,053
我们在这个测试中

376
00:22:00,287 --> 0:22:03,190
CoreLocation

377
00:22:03,724 --> 0:22:05,893
如果之前没有授权

378
00:22:05,959 --> 0:22:07,494
它会在设备上显示权限对话框

379
00:22:08,362 --> 0:22:10,931
这导致我们的测试依赖于设备状态

380
00:22:10,998 --> 0:22:14,368
并且使它们更难维护

381
00:22:16,336 --> 0:22:18,572
因此如果你在过去遇到过这个问题

382
00:22:18,639 --> 0:22:21,575
你可能会考虑对外部类进行子类化

383
00:22:21,642 --> 0:22:24,444
并重写你调用它的任何方法

384
00:22:24,845 --> 0:22:29,016
例如我们可以在这里尝试子类

385
00:22:29,082 --> 0:22:31,385
并重写RequestLocation方法

386
00:22:31,952 --> 0:22:34,688
这在一开始可能行得通 但有风险

387
00:22:35,622 --> 0:22:38,525
SDK中的一些类

388
00:22:38,592 --> 0:22:39,826
它们的行为可能不同

389
00:22:40,694 --> 0:22:43,797
另外我们仍然需要调用

390
00:22:43,864 --> 0:22:45,465
这不是我们可以重写的代码

391
00:22:46,266 --> 0:22:47,701
但是主要的问题是

392
00:22:47,768 --> 0:22:51,905
如果我修改代码来调用

393
00:22:52,139 --> 0:22:54,174
我也要必须记住

394
00:22:54,241 --> 0:22:56,243
在我的测试子类上重写该方法

395
00:22:57,044 --> 0:23:00,013
如果我依赖子类 编译器不会通知我

396
00:22:57,044 --> 0:23:00,013
如果我依赖子类 编译器不会通知我

397
00:23:00,080 --> 0:23:02,482
我已经开始调用另一个方法

398
00:23:02,549 --> 0:23:04,685
这很容易忘记和破坏我的测试

399
00:23:05,552 --> 0:23:07,321
因此我不推荐这种方法

400
00:23:07,387 --> 0:23:11,225
而我推荐使用协议模拟外部类型

401
00:23:11,291 --> 0:23:12,960
我们来看看怎么做

402
00:23:14,494 --> 0:23:16,129
这是原始代码

403
00:23:16,330 --> 0:23:19,032
第一步是定义一个新协议

404
00:23:20,300 --> 0:23:22,703
我已经命名了新协议

405
00:23:22,936 --> 0:23:25,405
它包含了我的代码

406
00:23:25,472 --> 0:23:28,075
使用的方法和属性的确切集合

407
00:23:28,976 --> 0:23:32,012
成员名称和类型完全匹配

408
00:23:32,079 --> 0:23:35,883
这允许我在

409
00:23:35,949 --> 0:23:37,384
创建一个符合协议的空扩展

410
00:23:37,451 --> 0:23:39,286
因为它已经满足了所有要求

411
00:23:41,321 --> 0:23:44,858
然后我将LocationManager属性

412
00:23:45,092 --> 0:23:47,794
并将其类型更改为

413
00:23:49,663 --> 0:23:52,599
我还将向初始化器添加一个

414
00:23:52,666 --> 0:23:56,170
就像我之前所做的那样

415
00:23:58,438 --> 0:24:01,708
我需要对checkCurrentLocation

416
00:23:58,438 --> 0:24:01,708
我需要对checkCurrentLocation

417
00:24:02,009 --> 0:24:03,544
以使用重命名的属性

418
00:24:05,445 --> 0:24:07,548
最后让我们看一下委托方法

419
00:24:08,182 --> 0:24:09,850
这个部分处理起来有点棘手

420
00:24:09,917 --> 0:24:12,786
因为委托期望Manager参数

421
00:24:12,853 --> 0:24:16,623
是真正的CLLocationManager

422
00:24:17,558 --> 0:24:20,627
因此当委托参与时

423
00:24:20,694 --> 0:24:22,930
但是我们仍然可以在这里应用协议

424
00:24:23,130 --> 0:24:24,431
让我们来看看

425
00:24:26,400 --> 0:24:29,770
我将回到前面定义的

426
00:24:30,337 --> 0:24:34,141
并将该委托属性重命名为

427
00:24:34,641 --> 0:24:36,677
我将其类型更改为一个新协议

428
00:24:36,743 --> 0:24:40,514
该协议的接口与

429
00:24:40,848 --> 0:24:42,516
但是我调整了方法名

430
00:24:42,583 --> 0:24:45,719
我将第一个参数的类型改为

431
00:24:49,356 --> 0:24:52,125
现在我需要在扩展中实现

432
00:24:52,192 --> 0:24:56,063
LocationFetcherDelegate属性

433
00:24:56,997 --> 0:24:59,867
我将实现getter

434
00:24:59,933 --> 0:25:03,070
来回转换到

435
00:24:59,933 --> 0:25:03,070
来回转换到

436
00:25:03,570 --> 0:25:06,240
稍后我会解释为什么

437
00:25:08,242 --> 0:25:09,810
然后在我的类的初始化器中

438
00:25:09,877 --> 0:25:12,913
我需要用locationFetcher

439
00:25:14,915 --> 0:25:17,818
最后一步是修改原来的扩展

440
00:25:17,885 --> 0:25:21,655
以符合新的模拟委托协议

441
00:25:21,722 --> 0:25:25,726
我需要做的就是替换协议和方法签名

442
00:25:26,560 --> 0:25:28,629
但是 我实际上仍然需要遵守旧的

443
00:25:28,695 --> 0:25:31,965
CLLocationManagerDelegate

444
00:25:32,499 --> 0:25:34,601
这是因为真正的

445
00:25:34,668 --> 0:25:37,004
不知道我的模拟委托协议

446
00:25:38,272 --> 0:25:40,841
因此这里的诀窍是

447
00:25:40,908 --> 0:25:43,076
扩展添加回来

448
00:25:43,143 --> 0:25:46,580
但让它调用上面等效的

449
00:25:47,981 --> 0:25:50,284
前面我提到我在委托

450
00:25:50,350 --> 0:25:51,885
getter和setter中

451
00:25:52,419 --> 0:25:55,455
这是为了确保我的类符合这两种协议

452
00:25:55,522 --> 0:25:57,824
我没有忘记其中的一种或另一种

453
00:26:01,562 --> 0:26:03,130
因此在我的单元测试中

454
00:26:03,197 --> 0:26:06,733
我将为模拟定义一个嵌套在

455
00:26:06,800 --> 0:26:08,969
它符合

456
00:26:09,036 --> 0:26:10,537
并满足其要求

457
00:26:11,505 --> 0:26:13,407
注意在它的requestLocation方法中

458
00:26:13,473 --> 0:26:17,611
它调用一个块来获取一个假的位置

459
00:26:18,245 --> 0:26:21,682
然它后调用委托方法

460
00:26:24,585 --> 0:26:27,254
现在我有了我所需要的一切

461
00:26:27,988 --> 0:26:30,057
我创建一个

462
00:26:30,123 --> 0:26:32,593
并配置它的

463
00:26:32,659 --> 0:26:34,161
以提供假位置

464
00:26:35,262 --> 0:26:39,600
然后我创建CurrentLocationProvider

465
00:26:40,167 --> 0:26:43,637
最后我用一个完成块调用

466
00:26:44,238 --> 0:26:45,606
在完成块中有一个断言

467
00:26:45,672 --> 0:26:47,441
用于检查位置

468
00:26:47,508 --> 0:26:49,076
是一个感兴趣的点

469
00:26:51,178 --> 0:26:52,012
所以它很管用

470
00:26:52,079 --> 0:26:54,948
我现在可以模拟我的类使用

471
00:26:55,015 --> 0:26:56,850
而不需要创建一个真正的

472
00:26:58,185 --> 0:27:00,120
因此在这里我展示了如何使用

473
00:26:58,185 --> 0:27:00,120
因此在这里我展示了如何使用

474
00:27:00,187 --> 0:27:03,690
协议来模拟与外部类及其委托的交互

475
00:27:04,224 --> 0:27:06,760
这是很多步骤

476
00:27:08,862 --> 0:27:10,764
首先我们定义了一个新的协议

477
00:27:10,831 --> 0:27:13,600
表示外部类的接口

478
00:27:14,301 --> 0:27:17,171
该协议需要包含

479
00:27:17,237 --> 0:27:19,339
所有方法和属性

480
00:27:19,540 --> 0:27:22,409
并且通常它们的声明可以完全匹配

481
00:27:23,777 --> 0:27:27,147
接下来我们在原始的

482
00:27:27,214 --> 0:27:29,082
它声明符合协议

483
00:27:30,450 --> 0:27:32,953
然后我们用我们的新协议替换了

484
00:27:33,020 --> 0:27:34,321
外部类的所有用法

485
00:27:34,755 --> 0:27:36,523
并添加了一个初始化器参数

486
00:27:36,590 --> 0:27:38,959
以便在测试中设置该类型

487
00:27:41,028 --> 0:27:43,830
我们还讨论了如何模拟委托协议

488
00:27:43,897 --> 0:27:45,933
这是SDK中常见的模式

489
00:27:46,934 --> 0:27:48,669
这里还有一些步骤

490
00:27:48,735 --> 0:27:49,837
但这里是我们所做的

491
00:27:51,004 --> 0:27:55,008
首先我们定义了一个模拟委托协议

492
00:27:55,075 --> 0:27:56,643
其方法签名

493
00:27:57,077 --> 0:28:00,747
但是我们用模拟协议类型

494
00:27:57,077 --> 0:28:00,747
但是我们用模拟协议类型

495
00:28:02,015 --> 0:28:05,719
然后在我们最初的模拟协议中

496
00:28:05,953 --> 0:28:08,488
并在扩展中实现了该重命名属性

497
00:28:09,857 --> 0:28:12,960
因此虽然这种方法

498
00:28:13,026 --> 0:28:15,062
而不是子类之类的替代方法

499
00:28:15,596 --> 0:28:17,731
,它会更可靠 更不可能打破

500
00:28:17,798 --> 0:28:19,600
我扩大我的代码

501
00:28:20,200 --> 0:28:22,069
因为这样编译器将强制执行

502
00:28:22,135 --> 0:28:27,207
必须包括在这些新协议中

503
00:28:31,778 --> 0:28:35,716
最后我想谈谈测试执行速度

504
00:28:38,118 --> 0:28:40,120
当你的测试需要很长时间运行时

505
00:28:40,387 --> 0:28:42,422
你就不太可能在开发期间运行它们

506
00:28:42,689 --> 0:28:45,292
或者你可能会尝试跳过

507
00:28:46,159 --> 0:28:48,595
我们的测试套件

508
00:28:48,662 --> 0:28:50,497
而修复回归是最容易的

509
00:28:50,731 --> 0:28:53,767
因此我们希望确保我们的测试

510
00:28:54,935 --> 0:28:56,770
现在你可能在过去遇到过一些

511
00:28:56,837 --> 0:28:59,806
需要在测试中人工等待或休眠的情况

512
00:28:59,873 --> 0:29:03,443
因为你的测试是异步的

513
00:28:59,873 --> 0:29:03,443
因为你的测试是异步的

514
00:29:04,378 --> 0:29:05,812
延迟操作是很棘手的

515
00:29:05,879 --> 0:29:07,948
我们希望确保

516
00:29:08,182 --> 0:29:11,118
但是如果我们不小心的话

517
00:29:11,818 --> 0:29:13,220
因此我想谈谈一些

518
00:29:13,287 --> 0:29:15,722
我们可以避免

519
00:29:15,789 --> 0:29:17,357
因为它们永远都是不必要的

520
00:29:19,059 --> 0:29:20,194
下面是一个例子

521
00:29:20,594 --> 0:29:22,930
在Brian和我正在构建的

522
00:29:23,297 --> 0:29:25,432
在主UI上 我们在底部有一个条带

523
00:29:25,499 --> 0:29:27,134
它显示了特色的地方

524
00:29:27,534 --> 0:29:29,903
它基本上是绕着附近的顶部旋转

525
00:29:30,237 --> 0:29:32,873
每隔十秒钟就会显示一个新的位置

526
00:29:33,507 --> 0:29:36,343
现在有几种方法可以实现这个功能

527
00:29:36,410 --> 0:29:38,812
但是这里我使用的是

528
00:29:40,948 --> 0:29:43,317
让我们看一下我可能

529
00:29:44,051 --> 0:29:46,119
它创建一个

530
00:29:46,520 --> 0:29:50,858
并在调用scheduleNextPlace方法之前

531
00:29:51,491 --> 0:29:54,127
然后运行循环11秒

532
00:29:54,361 --> 0:29:56,496
我加了一秒钟作为宽限期

533
00:29:57,397 --> 0:30:00,234
最后它检查当前位置

534
00:29:57,397 --> 0:30:00,234
最后它检查当前位置

535
00:30:01,001 --> 0:30:04,137
现在这不是很好

536
00:30:04,972 --> 0:30:08,208
为了缓解这一问题

537
00:30:08,275 --> 0:30:12,246
以允许我们将超时定制为更短的时间

538
00:30:12,946 --> 0:30:16,216
这就是代码改变的样子

539
00:30:20,754 --> 0:30:24,691
现在使用这种方法

540
00:30:25,359 --> 0:30:27,794
这个方法比以前的好

541
00:30:27,861 --> 0:30:31,932
我们的测试肯定会运行得更快

542
00:30:32,366 --> 0:30:35,002
我们的代码还有延迟只是时间更短

543
00:30:35,669 --> 0:30:39,506
真正的问题是

544
00:30:39,773 --> 0:30:43,110
这意味着

545
00:30:43,177 --> 0:30:45,212
我们的测试可能变得不那么可靠

546
00:30:45,345 --> 0:30:48,582
因为它们将更依赖于CPU

547
00:30:48,715 --> 0:30:51,919
这并不总是正确的

548
00:30:52,786 --> 0:30:54,755
那么让我们来看看一个更好的方法

549
00:30:56,557 --> 0:30:59,793
我建议首先确定延迟机制

550
00:31:00,127 --> 0:31:01,962
在我的示例中它是一个定时器

551
00:31:02,029 --> 0:31:05,832
但你也可以使用DispatchQueue

552
00:31:06,867 --> 0:31:09,136
我们想要模拟这个机制

553
00:31:09,203 --> 0:31:12,806
以便我们能够

554
00:31:16,043 --> 0:31:17,544
这里是我们的原始代码

555
00:31:17,845 --> 0:31:21,481
让我们从这个scheduledTimer方法的

556
00:31:22,516 --> 0:31:25,786
ScheduledTimer

557
00:31:26,253 --> 0:31:30,224
它创建一个计时器 然后将

558
00:31:31,158 --> 0:31:34,394
现在这个API

559
00:31:34,628 --> 0:31:36,530
但是如果我将这两个步骤分开

560
00:31:36,597 --> 0:31:38,699
它将帮助我们使代码更可测试

561
00:31:40,601 --> 0:31:44,137
在这里 我将前面的代码从使用

562
00:31:44,238 --> 0:31:48,442
scheduledTimer转换为先创建计时器

563
00:31:48,509 --> 0:31:50,210
我已经将其存储在一个新属性中

564
00:31:51,545 --> 0:31:54,014
现在这段代码相当于我们以前的代码

565
00:31:54,214 --> 0:31:56,183
但是一旦我们将这两个步骤分开

566
00:31:56,650 --> 0:31:59,520
我们就可以看到runLoop

567
00:31:59,586 --> 0:32:00,854
只是这个类与之交互的另一个外部类

568
00:31:59,586 --> 0:32:00,854
只是这个类与之交互的另一个外部类

569
00:32:01,355 --> 0:32:02,589
因此我们可以应用

570
00:32:02,656 --> 0:32:05,292
我们前面讨论过的

571
00:32:06,126 --> 0:32:10,464
为此我们将创建一个小协议

572
00:32:12,099 --> 0:32:14,401
我调用了该新协议

573
00:32:14,601 --> 0:32:17,104
它只有一个addTimer方法

574
00:32:17,271 --> 0:32:20,040
它与runLoop API

575
00:32:22,242 --> 0:32:25,012
现在回到我的代码中

576
00:32:25,078 --> 0:32:27,014
我需用刚刚创建的协议

577
00:32:29,683 --> 0:32:33,520
在我的测试中我不想使用真正的

578
00:32:33,820 --> 0:32:38,125
相反我想创建一个模拟调度器

579
00:32:39,660 --> 0:32:43,096
为此 我将创建一个嵌套在

580
00:32:43,163 --> 0:32:46,967
我的单元测试类MockTimerScheduler中的新结构

581
00:32:47,935 --> 0:32:51,471
它存储一个块 每当被告知要

582
00:32:53,907 --> 0:32:56,977
有了所有的片段

583
00:32:57,811 --> 0:33:02,683
首先我创建一个MockTimerScheduler

584
00:32:57,811 --> 0:33:02,683
首先我创建一个MockTimerScheduler

585
00:33:03,450 --> 0:33:04,785
这个块接收计时器

586
00:33:04,852 --> 0:33:08,589
一旦它被添加到调度程序中

587
00:33:08,789 --> 0:33:13,627
然后通过触发计时器来绕过延迟

588
00:33:14,995 --> 0:33:18,832
然后我们创建一个FeaturedPlaceManager

589
00:33:19,933 --> 0:33:22,936
最后 我们调用scheduleNextPlace

590
00:33:23,837 --> 0:33:26,540
好啊 我们的测试不再有任何延迟

591
00:33:27,040 --> 0:33:29,810
它们执行得非常快而且不依赖于时间

592
00:33:29,877 --> 0:33:31,345
所以它会更可靠

593
00:33:32,179 --> 0:33:36,016
作为奖励

594
00:33:36,083 --> 0:33:37,751
来验证计时器延迟的数量

595
00:33:38,051 --> 0:33:40,587
这不是我在之前的测试中所能做

596
00:33:42,890 --> 0:33:47,194
所以就像我说的

597
00:33:48,028 --> 0:33:51,331
我们认为这是测试涉及

598
00:33:51,765 --> 0:33:54,735
但是对于测试中最快的总体执行速度

599
00:33:54,935 --> 0:33:57,571
最好是直接构建大部分测试

600
00:33:57,638 --> 0:34:00,741
而根本不需要模拟延迟操作

601
00:33:57,638 --> 0:34:00,741
而根本不需要模拟延迟操作

602
00:34:01,975 --> 0:34:03,510
例如 在我们的app中

603
00:34:03,677 --> 0:34:07,347
被延迟的动作

604
00:34:07,781 --> 0:34:12,886
我可能只需要一两次测试

605
00:34:13,219 --> 0:34:14,388
对于其余的类

606
00:34:14,454 --> 0:34:17,056
我可以直接调用

607
00:34:17,123 --> 0:34:19,560
根本不需要模拟一个计时器调度程序

608
00:34:22,563 --> 0:34:24,864
在我们讨论测试执行速度这一主题时

609
00:34:24,931 --> 0:34:26,632
我们还有一些其他的技巧要分享

610
00:34:27,701 --> 0:34:31,271
我们已经看到的一个领域是

611
00:34:31,839 --> 0:34:34,341
我们指出的是这些类

612
00:34:34,408 --> 0:34:36,143
几乎不像其他预期类那样具有性能

613
00:34:36,342 --> 0:34:39,880
因为它们依赖于轮询机制

614
00:34:40,547 --> 0:34:42,449
它们主要用于UI测试

615
00:34:42,516 --> 0:34:46,053
其中评估的条件发生在另一个进程中

616
00:34:46,386 --> 0:34:49,556
因此在单元测试中

617
00:34:49,623 --> 0:34:55,495
例如常规的XCTestExec

618
00:34:58,031 --> 0:34:59,600
另一个测试速度提示是

619
00:34:59,666 --> 0:35:02,469
确保你的app尽快启动

620
00:34:59,666 --> 0:35:02,469
确保你的app尽快启动

621
00:35:03,337 --> 0:35:06,540
现在大多数app都必须

622
00:35:06,840 --> 0:35:09,877
尽管这种工作

623
00:35:10,310 --> 0:35:12,913
但当你的app作为

624
00:35:12,980 --> 0:35:14,648
很多工作可能是不必要的

625
00:35:15,249 --> 0:35:19,152
例如加载视图控制器 启动网络请求

626
00:35:19,219 --> 0:35:21,588
或配置分析包

627
00:35:21,655 --> 0:35:24,091
这些都是单元测试场景中

628
00:35:24,157 --> 0:35:25,692
通常不必要的东西

629
00:35:27,094 --> 0:35:30,898
XCTest在开始运行测试之前

630
00:35:30,964 --> 0:35:32,699
等待app委托完成启动方法返回

631
00:35:33,133 --> 0:35:35,302
因此若你分析并注意到

632
00:35:35,369 --> 0:35:37,371
花费了很长时间

633
00:35:38,071 --> 0:35:41,008
一个技巧就是检测你的app

634
00:35:41,074 --> 0:35:42,176
并避免这项工作

635
00:35:44,111 --> 0:35:49,016
一种方法是指定自定义环境变量

636
00:35:49,850 --> 0:35:53,353
打开方案编辑器

637
00:35:53,620 --> 0:35:55,155
然后到参数选项卡

638
00:35:55,355 --> 0:35:58,559
然后添加一个环境变量

639
00:35:59,259 --> 0:36:01,862
在这个屏幕截图中

640
00:35:59,259 --> 0:36:01,862
在这个屏幕截图中

641
00:36:01,929 --> 0:36:04,264
名为IS-UNIT-TESTING

642
00:36:06,400 --> 0:36:09,770
然后 修改app委托的

643
00:36:09,837 --> 0:36:12,639
使用类似于此的代码检查此条件

644
00:36:13,540 --> 0:36:16,343
现在 如果你这样做

645
00:36:16,410 --> 0:36:19,213
请确保你跳过的代码

646
00:36:22,916 --> 0:36:28,989
最后总结一下Brian开始时候

647
00:36:29,423 --> 0:36:31,792
以及如何在app中

648
00:36:32,292 --> 0:36:35,896
展示几种测试网络操作的实用技术

649
00:36:36,897 --> 0:36:40,167
然后我讨论了隔离基础通知

650
00:36:40,734 --> 0:36:42,269
并使用依赖项注入

651
00:36:43,437 --> 0:36:46,039
我们为编写测试时最常见的挑战之一

652
00:36:46,106 --> 0:36:49,343
即与外部类交互

653
00:36:49,877 --> 0:36:51,245
即使它们有一个委托

654
00:36:52,312 --> 0:36:54,982
我们还分享了一些保持测试快速运行

655
00:36:55,048 --> 0:36:56,850
和避免人为延迟的技巧

656
00:36:57,784 --> 0:36:59,486
我们真的希望你觉得这些测试有用

657
00:36:59,553 --> 0:37:02,089
并在下次编写测试时

658
00:36:59,553 --> 0:37:02,089
并在下次编写测试时

659
00:37:04,625 --> 0:37:07,628
要了解更多信息

660
00:37:07,895 --> 0:37:08,962
如果你错过了

661
00:37:09,029 --> 0:37:12,733
我们希望你能看看

662
00:37:13,700 --> 0:37:16,003
非常感谢
