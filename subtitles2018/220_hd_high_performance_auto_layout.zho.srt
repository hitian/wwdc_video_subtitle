1
00:00:07,516 --> 0:00:15,500
[ 音乐 ]

2
00:00:19,516 --> 0:00:25,176
[ 掌声 ]

3
00:00:25,676 --> 0:00:26,186
&gt;&gt; 下午好

4
00:00:27,166 --> 0:00:28,956
欢迎大家 我叫 Ken Ferry

5
00:00:29,246 --> 0:00:31,536
今天我与 Kasia Wawer 将会给大家介绍

6
00:00:31,536 --> 0:00:32,686
Auto Layout 的性能

7
00:00:33,666 --> 0:00:35,466
上一次我站在这里谈论

8
00:00:35,466 --> 0:00:37,446
Auto Layout 是 2011 年

9
00:00:38,056 --> 0:00:39,356
当时我们刚刚推出这个功能

10
00:00:39,726 --> 0:00:42,216
所以我很高兴可以回到这里

11
00:00:42,316 --> 0:00:43,446
与你们一起探讨这个功能

12
00:00:44,956 --> 0:00:48,896
好的 下面说 Auto Layout

13
00:00:49,796 --> 0:00:51,366
我们像这样把内容

14
00:00:51,576 --> 0:00:52,916
放置在 Mac 的 iOS 系统中

15
00:00:53,486 --> 0:00:55,096
其中主要涉及的是

16
00:00:55,096 --> 0:00:57,456
我们熟知的视图和约束

17
00:00:58,246 --> 0:00:59,096
其中约束定义

18
00:00:59,096 --> 0:01:00,406
视图之间的关系

19
00:00:59,096 --> 0:01:00,406
视图之间的关系

20
00:01:01,206 --> 0:01:02,826
那么关于性能

21
00:01:03,126 --> 0:01:04,756
我想其中的挑战在于

22
00:01:04,756 --> 0:01:07,276
如果只说这两个按钮的

23
00:01:07,416 --> 0:01:09,286
间距为 20

24
00:01:09,286 --> 0:01:10,446
就很难去理解机器

25
00:01:10,446 --> 0:01:12,606
如何一步一步

26
00:01:12,606 --> 0:01:13,936
完成这个过程

27
00:01:14,226 --> 0:01:15,466
也就是说 很难去

28
00:01:15,466 --> 0:01:17,726
正确理解对

29
00:01:17,726 --> 0:01:18,736
其性能的期望

30
00:01:18,736 --> 0:01:19,826
并了解什么运行得快

31
00:01:19,826 --> 0:01:21,296
什么运行的慢 以及一般情况下

32
00:01:21,296 --> 0:01:22,006
整个过程是如何工作的

33
00:01:22,986 --> 0:01:25,156
这就是我们今天的目的

34
00:01:25,456 --> 0:01:29,556
今天的目标是 真正理解并掌握整个过程如何运作

35
00:01:29,896 --> 0:01:31,146
那么我们就

36
00:01:31,146 --> 0:01:32,696
首先展示一些

37
00:01:32,696 --> 0:01:33,826
我们在过去为了

38
00:01:33,826 --> 0:01:35,556
iOS 12 发布而做的

39
00:01:35,556 --> 0:01:36,096
性能方面的工作

40
00:01:36,436 --> 0:01:37,256
我们有很多成果

41
00:01:37,706 --> 0:01:40,286
在演讲中会进行介绍

42
00:01:41,206 --> 0:01:44,646
这之后我们将会

43
00:01:44,646 --> 0:01:46,166
讨论如何建立起

44
00:01:46,166 --> 0:01:48,376
我刚才说的那种一步一步的理解

45
00:01:48,686 --> 0:01:50,506
这样我们对于性能有

46
00:01:50,506 --> 0:01:52,006
较好的判断和较好的期望

47
00:01:52,456 --> 0:01:53,626
为此我们将会做

48
00:01:53,626 --> 0:01:55,496
一些不寻常的事情

49
00:01:55,786 --> 0:01:57,076
我们会谈到一些内在问题

50
00:01:57,746 --> 0:01:58,756
请尽情享受

51
00:02:02,546 --> 0:02:04,756
最后 如果你只依赖于

52
00:02:04,756 --> 0:02:06,316
对性能的直观判断

53
00:02:06,546 --> 0:02:07,896
这远远不够

54
00:02:08,286 --> 0:02:10,776
那么我们将有请 Kasia

55
00:02:10,776 --> 0:02:12,376
上台来分析代码

56
00:02:12,506 --> 0:02:14,686
我们将会展示如何

57
00:02:14,686 --> 0:02:16,696
将你的直观判断与

58
00:02:16,916 --> 0:02:17,736
实践结合起来

59
00:02:18,846 --> 0:02:20,126
现在开始吧

60
00:02:20,436 --> 0:02:22,226
首先 作为一个

61
00:02:22,226 --> 0:02:23,326
Apple 展示的传统

62
00:02:23,326 --> 0:02:24,676
我们先来看到一些数据和自夸

63
00:02:25,516 --> 0:02:28,796
[ 笑声 ]

64
00:02:29,296 --> 0:02:31,116
我们目前看到的是

65
00:02:31,116 --> 0:02:32,806
一个基准测试

66
00:02:33,416 --> 0:02:35,456
我们进行工作的方法是

67
00:02:35,456 --> 0:02:37,536
去寻找并查看

68
00:02:37,536 --> 0:02:38,816
一些第三方 App

69
00:02:38,816 --> 0:02:40,406
也包括我们自己的 App

70
00:02:40,406 --> 0:02:41,906
并试图将看到的内容提取

71
00:02:41,906 --> 0:02:44,646
为测试案例

72
00:02:44,646 --> 0:02:45,476
因此我们可以进行基准测试

73
00:02:45,996 --> 0:02:47,056
那么我们看到的

74
00:02:47,056 --> 0:02:49,006
就是 UICollectionView

75
00:02:49,006 --> 0:02:51,486
它具有自动调节大小的单元格

76
00:02:51,706 --> 0:02:53,236
看起来糟糕的那一边

77
00:02:53,436 --> 0:03:00,086
就是 iOS 11 它看起来很差劲

78
00:02:53,436 --> 0:03:00,086
就是 iOS 11 它看起来很差劲

79
00:03:00,266 --> 0:03:02,946
而在 iOS 12 中它表现完美

80
00:03:03,216 --> 0:03:04,116
达到了全帧速率

81
00:03:05,096 --> 0:03:07,586
这就是我们所关注的案例之一

82
00:03:07,896 --> 0:03:10,846
这里还有一些其他的样本

83
00:03:10,846 --> 0:03:11,806
这样的样本我们有很多

84
00:03:12,526 --> 0:03:14,186
这些都是关于时间的

85
00:03:14,766 --> 0:03:16,446
你们所看到的

86
00:03:16,446 --> 0:03:18,176
灰色的条形代表 iOS 11

87
00:03:18,346 --> 0:03:19,666
即在 iOS 11 上所需的时间

88
00:03:20,016 --> 0:03:21,506
蓝色的代表 iOS 12

89
00:03:22,936 --> 0:03:24,236
你们可以看到的是

90
00:03:24,236 --> 0:03:25,516
我们发现很多地方

91
00:03:25,516 --> 0:03:27,476
都有很大的改进空间

92
00:03:28,076 --> 0:03:31,546
而这些会对你们的 App 有帮助

93
00:03:31,676 --> 0:03:32,646
这会让产品

94
00:03:32,856 --> 0:03:35,616
变得更好 希望如此

95
00:03:35,616 --> 0:03:36,896
改进存在于整个

96
00:03:36,896 --> 0:03:37,466
堆栈的过程

97
00:03:37,766 --> 0:03:39,336
其中有的位于

98
00:03:39,336 --> 0:03:41,676
核心中 可以影响到方方面面

99
00:03:42,166 --> 0:03:44,366
有的存在于 UI Kit 中

100
00:03:44,366 --> 0:03:45,486
有的则是存在于客户

101
00:03:45,486 --> 0:03:48,326
层面 关于如何使用 Auto Layout

102
00:03:48,716 --> 0:03:51,246
比如说 UICollectionView 基准测试

103
00:03:51,606 --> 0:03:52,776
也就是刚刚展示的

104
00:03:52,776 --> 0:03:53,536
就包括所有改进

105
00:03:54,016 --> 0:03:55,846
它包括了

106
00:03:55,846 --> 0:03:57,386
核心部分的 也包括了

107
00:03:57,446 --> 0:03:58,856
一些非常

108
00:03:58,856 --> 0:04:00,236
重要的改进

109
00:03:58,856 --> 0:04:00,236
重要的改进

110
00:04:00,236 --> 0:04:01,876
是关于 UICollectionView 如何

111
00:04:01,876 --> 0:04:03,576
使用 Auto Layout 如何展现

112
00:04:04,296 --> 0:04:04,866
更高的性能的

113
00:04:05,376 --> 0:04:07,186
这对于接下来的演讲

114
00:04:07,186 --> 0:04:09,186
是一个不错的例子

115
00:04:09,256 --> 0:04:10,116
你们也可以做到

116
00:04:10,676 --> 0:04:11,786
那应该如何正确使用它呢

117
00:04:12,606 --> 0:04:14,286
当我们完成这些工作后

118
00:04:15,026 --> 0:04:16,505
我常常会想到

119
00:04:16,505 --> 0:04:17,956
我们之所以能够完成

120
00:04:17,956 --> 0:04:19,375
这些改进是因为

121
00:04:19,375 --> 0:04:21,786
我们有一个很好的心智模型

122
00:04:21,786 --> 0:04:24,336
关于事物如何组建以及

123
00:04:24,366 --> 0:04:26,226
如何执行 如何工作

124
00:04:27,366 --> 0:04:29,756
我们希望帮助你们也构建起这一模型

125
00:04:30,286 --> 0:04:31,876
为此我们会先

126
00:04:31,876 --> 0:04:34,126
探讨一个示例

127
00:04:34,126 --> 0:04:36,726
一些客户端代码

128
00:04:36,726 --> 0:04:38,676
它们有一些问题 我们将会讨论问题的原因

129
00:04:39,266 --> 0:04:40,796
你的代码或许不一定有

130
00:04:40,796 --> 0:04:42,166
一模一样的问题 但我们

131
00:04:42,166 --> 0:04:43,226
选择的是

132
00:04:43,226 --> 0:04:44,636
我们认为

133
00:04:44,636 --> 0:04:45,816
在看到的这些

134
00:04:46,056 --> 0:04:47,496
客户端 App 中最为常见的问题

135
00:04:48,096 --> 0:04:49,146
就算你没有这个

136
00:04:49,146 --> 0:04:50,876
问题 我们所做的

137
00:04:50,876 --> 0:04:52,476
对问题的探讨

138
00:04:52,706 --> 0:04:53,596
将会对每个人都有所帮助

139
00:04:53,596 --> 0:04:56,026
而且可能对所有人来说 都是新的内容

140
00:04:56,876 --> 0:04:58,426
那么我们开始吧

141
00:04:59,656 --> 0:05:01,436
这个示例是我们即将探讨的

142
00:04:59,656 --> 0:05:01,436
这个示例是我们即将探讨的

143
00:05:01,436 --> 0:05:04,516
要产生这个布局 显然非常简单

144
00:05:05,106 --> 0:05:06,976
我想你们应该经常

145
00:05:06,976 --> 0:05:08,046
在 Interface Builder 中创建它

146
00:05:08,806 --> 0:05:09,756
这个做法很聪明

147
00:05:09,876 --> 0:05:11,716
因为这样就能够

148
00:05:11,716 --> 0:05:12,786
完全避免

149
00:05:12,786 --> 0:05:13,896
我们可能遇到的

150
00:05:13,896 --> 0:05:15,796
性能问题

151
00:05:16,076 --> 0:05:18,976
那么假设我们没有这么做

152
00:05:19,406 --> 0:05:21,886
假设我们像这样创建布局

153
00:05:24,066 --> 0:05:25,216
让我们先大致看一看

154
00:05:25,216 --> 0:05:26,406
再进行分析

155
00:05:26,406 --> 0:05:27,796
首先看一看 这些代码是做什么的

156
00:05:28,826 --> 0:05:31,316
首先我们覆写

157
00:05:31,316 --> 0:05:33,226
UIView 中的 updateConstraints 方法

158
00:05:33,866 --> 0:05:34,976
不管它是做什么的

159
00:05:35,366 --> 0:05:37,426
后面会谈到它

160
00:05:37,916 --> 0:05:42,476
接着 我们有一个成员变量叫 myConstraints

161
00:05:42,716 --> 0:05:45,446
我们提取这个

162
00:05:45,446 --> 0:05:46,436
变量中的所有内容

163
00:05:46,436 --> 0:05:47,836
并停用所有的约束

164
00:05:48,586 --> 0:05:49,516
我们然后创建

165
00:05:49,516 --> 0:05:51,176
约束 这些约束 

166
00:05:51,176 --> 0:05:52,416
实现我们刚刚看到的布局

167
00:05:53,006 --> 0:05:54,106
这非常直白

168
00:05:54,106 --> 0:05:55,546
使用的是视觉格式语言

169
00:05:56,276 --> 0:05:57,276
然后我们执行这些 

170
00:05:57,276 --> 0:05:58,776
约束 安装它们

171
00:05:59,236 --> 0:06:00,296
最后我们调用

172
00:05:59,236 --> 0:06:00,296
最后我们调用

173
00:06:00,296 --> 0:06:02,356
super.updateConstraints 

174
00:06:02,356 --> 0:06:04,256
这很重要 因为这个方法

175
00:06:04,586 --> 0:06:08,976
对 UIView 层面的执行很有用

176
00:06:09,166 --> 0:06:10,966
好的 这就是基本的结构 

177
00:06:11,436 --> 0:06:15,306
表明了它的目的 并且确实可用有效果

178
00:06:15,906 --> 0:06:18,676
但是我们接下来

179
00:06:18,676 --> 0:06:20,136
进一步探讨它的运行过程 

180
00:06:20,136 --> 0:06:21,276
让我们更好地了解其性能

181
00:06:22,016 --> 0:06:23,116
那么首先要了解的

182
00:06:23,116 --> 0:06:24,736
就是到底什么是

183
00:06:24,856 --> 0:06:26,906
updateConstraints 即我们正在覆写的方法

184
00:06:28,316 --> 0:06:30,646
它属于渲染循环

185
00:06:31,636 --> 0:06:33,266
渲染循环是一个过程

186
00:06:33,506 --> 0:06:36,476
它每秒钟可用运行高达 120 次

187
00:06:37,216 --> 0:06:38,976
从而确保所有内容

188
00:06:38,976 --> 0:06:40,656
出现在每一帧上

189
00:06:41,656 --> 0:06:43,786
好的 它包含 3 个阶段

190
00:06:43,786 --> 0:06:45,066
分别是更新约束

191
00:06:45,066 --> 0:06:46,386
布局与显示

192
00:06:47,096 --> 0:06:49,246
首先所有需要的视图都会

193
00:06:49,246 --> 0:06:50,916
收到 updateConstraints

194
00:06:51,306 --> 0:06:53,306
然后从最末端的

195
00:06:53,306 --> 0:06:55,096
视图开始 沿着视图层级向上运行

196
00:06:55,096 --> 0:06:55,786
最终到达窗口

197
00:06:56,656 --> 0:06:59,086
接着 每个视图会收到 layoutSubView

198
00:06:59,366 --> 0:07:00,616
它沿着相反方向运行

199
00:06:59,366 --> 0:07:00,616
它沿着相反方向运行

200
00:07:00,616 --> 0:07:02,516
从窗口向下直到末端

201
00:07:03,176 --> 0:07:05,886
最后 所有视图按需求提取 

202
00:07:05,886 --> 0:07:07,856
差不多就是这样

203
00:07:08,636 --> 0:07:11,166
好的 那么这是为什么呢

204
00:07:11,166 --> 0:07:12,156
它们为什么存在

205
00:07:13,306 --> 0:07:14,736
它们全部具有完全

206
00:07:14,736 --> 0:07:17,016
相同的目的以及完全

207
00:07:17,056 --> 0:07:18,226
平行的方法

208
00:07:18,646 --> 0:07:20,586
这个目的就是防止

209
00:07:20,846 --> 0:07:23,966
工作的浪费 我后面会举例子解释

210
00:07:24,856 --> 0:07:28,516
一个 UI 标签需要

211
00:07:28,516 --> 0:07:30,346
约束来表述

212
00:07:30,576 --> 0:07:33,466
其文本的尺寸 对吗

213
00:07:34,056 --> 0:07:34,986
但是 有很多属性

214
00:07:34,986 --> 0:07:36,126
都与文本尺寸相关

215
00:07:36,406 --> 0:07:37,426
比如有文本本身属性

216
00:07:37,426 --> 0:07:39,936
还有字体 以及

217
00:07:39,936 --> 0:07:41,356
文本尺寸 等等

218
00:07:41,936 --> 0:07:44,946
一种方法是每次这些

219
00:07:44,946 --> 0:07:47,576
属性出现变化时 去重新测量你的文本

220
00:07:48,556 --> 0:07:52,096
但是 那往往效率极低 因为

221
00:07:52,096 --> 0:07:53,766
一般会连续改变多个属性

222
00:07:54,206 --> 0:07:55,076
当你首次设置一个标签时

223
00:07:55,076 --> 0:07:56,176
你可能会

224
00:07:56,176 --> 0:07:57,306
调用一批此类属性设置

225
00:07:57,306 --> 0:07:58,506
那么如果你

226
00:07:58,506 --> 0:07:59,976
每次都重新测量文本

227
00:08:00,506 --> 0:08:01,536
所有的中间环节就被

228
00:08:01,536 --> 0:08:02,856
浪费了 你事实上只想

229
00:08:02,856 --> 0:08:03,516
在完成后进行测量

230
00:08:03,816 --> 0:08:05,316
那么这就是渲染循环为你做的

231
00:08:05,876 --> 0:08:07,656
这样你只需选择

232
00:08:08,086 --> 0:08:10,646
对于设置的字体调用

233
00:08:10,646 --> 0:08:13,206
setNeedsUpdateConstraints

234
00:08:13,336 --> 0:08:14,986
然后你就可以确保

235
00:08:15,176 --> 0:08:17,366
在设置后更新约束

236
00:08:17,436 --> 0:08:18,826
且在这一帧出现在屏幕上之前完成

237
00:08:19,816 --> 0:08:20,456
这就是它的作用

238
00:08:21,486 --> 0:08:22,876
那么有一些事情

239
00:08:22,876 --> 0:08:24,386
需要了解

240
00:08:24,386 --> 0:08:26,176
第一 它运行次数多

241
00:08:26,176 --> 0:08:27,626
每秒钟 120 帧

242
00:08:28,406 --> 0:08:30,346
第二 它们是平行的

243
00:08:30,686 --> 0:08:32,696
因此你也可以用作直觉判断

244
00:08:32,726 --> 0:08:33,866
如果你觉得你理解了

245
00:08:33,866 --> 0:08:35,035
布局部分的运行

246
00:08:35,035 --> 0:08:37,506
或是有了一些感觉 那么你在思考

247
00:08:37,506 --> 0:08:39,256
更新约束或显示时也是一样

248
00:08:40,155 --> 0:08:41,746
最后一件事就是

249
00:08:41,746 --> 0:08:43,756
它存在的原因是

250
00:08:43,756 --> 0:08:45,886
避免工作浪费

251
00:08:45,886 --> 0:08:48,036
延迟工作 甚至有可能跳过工作 完全跳过

252
00:08:49,006 --> 0:08:53,316
好了 看完这些之后

253
00:08:53,316 --> 0:08:54,876
我们现在可以

254
00:08:54,876 --> 0:08:56,156
分析这一方法的其他部分

255
00:08:56,896 --> 0:08:59,476
可以看到 每一次

256
00:08:59,476 --> 0:09:01,076
调用时 我们都停用

257
00:08:59,476 --> 0:09:01,076
调用时 我们都停用

258
00:09:01,276 --> 0:09:03,996
一些约束 然后执行一些新的约束

259
00:09:05,406 --> 0:09:07,326
这与 layoutSubViews 类似

260
00:09:07,706 --> 0:09:09,616
假设我们在

261
00:09:09,616 --> 0:09:11,966
layoutSubViews 中写了相同的代码

262
00:09:11,966 --> 0:09:14,076
像是这样

263
00:09:14,476 --> 0:09:16,996
每一次 layoutSubViews

264
00:09:16,996 --> 0:09:18,436
被调用时 你就销毁了之前所有的

265
00:09:18,436 --> 0:09:20,236
子视图 然后从头开始

266
00:09:20,236 --> 0:09:22,346
创建 再添加它们

267
00:09:23,436 --> 0:09:25,596
我相信很多人都会有

268
00:09:25,596 --> 0:09:26,836
非常准确的

269
00:09:26,836 --> 0:09:27,946
直觉判断 认为这可能不会

270
00:09:27,946 --> 0:09:28,726
很好的执行

271
00:09:29,306 --> 0:09:31,916
所以只需要记住的是

272
00:09:31,916 --> 0:09:33,266
它们一样的

273
00:09:33,586 --> 0:09:34,976
不管你对此有什么直觉判断

274
00:09:34,976 --> 0:09:36,436
都可以用在

275
00:09:36,436 --> 0:09:37,756
updateConstraints 上

276
00:09:38,046 --> 0:09:39,216
当你这样停用

277
00:09:39,216 --> 0:09:40,336
各种约束时

278
00:09:40,336 --> 0:09:43,156
其实做了很多无用功 那么如何解决这个问题呢

279
00:09:43,766 --> 0:09:46,076
你需要做的是

280
00:09:46,076 --> 0:09:47,116
正如我们说的 你需要确定 

281
00:09:47,116 --> 0:09:49,286
你不会重复工作

282
00:09:49,506 --> 0:09:50,606
这就是延迟工作

283
00:09:51,566 --> 0:09:53,076
情况应该是这样的

284
00:09:53,076 --> 0:09:55,056
我们询问是否已经做过这个工作了呢

285
00:09:55,636 --> 0:09:57,856
如果做过了 那么就不要再做任何事

286
00:09:57,856 --> 0:09:58,886
如果还没有做过

287
00:09:58,886 --> 0:09:59,976
那么当然要设置这些约束 只做一次

288
00:10:00,046 --> 0:10:03,816
这样就能很好地执行了 对吧

289
00:10:04,176 --> 0:10:05,956
那么 就像之前说的

290
00:10:05,956 --> 0:10:07,916
这实际上是

291
00:10:07,916 --> 0:10:09,636
客户端代码中最常见的错误

292
00:10:09,866 --> 0:10:12,146
我们称之为约束流失

293
00:10:12,846 --> 0:10:14,116
即不必要的删除约束

294
00:10:14,116 --> 0:10:16,036
然后再次添加它们

295
00:10:16,036 --> 0:10:17,326
好的

296
00:10:17,886 --> 0:10:19,396
我们还有很多要做

297
00:10:19,766 --> 0:10:21,196
但是现在先等一下

298
00:10:21,386 --> 0:10:22,676
回顾一下渲染循环

299
00:10:22,676 --> 0:10:23,626
仔细思考

300
00:10:24,296 --> 0:10:26,576
如果你确实需要渲染循环

301
00:10:26,576 --> 0:10:27,696
那它非常好用

302
00:10:27,926 --> 0:10:29,066
它的目的是

303
00:10:29,066 --> 0:10:31,236
有助于避免那些冗余的工作

304
00:10:32,106 --> 0:10:34,386
但它也比较危险 因为

305
00:10:34,616 --> 0:10:35,506
运行次数过多

306
00:10:35,826 --> 0:10:38,036
这个代码非常敏感

307
00:10:38,356 --> 0:10:41,236
所以像这种情况 一般来说你使用

308
00:10:41,236 --> 0:10:43,486
这样敏感的代码时

309
00:10:43,486 --> 0:10:44,336
你应该在写代码时

310
00:10:44,336 --> 0:10:45,196
小心谨慎 同时也应该

311
00:10:45,196 --> 0:10:46,956
试图减少

312
00:10:46,956 --> 0:10:48,216
写此类敏感代码的次数

313
00:10:48,616 --> 0:10:50,636
因为你有可能会

314
00:10:50,636 --> 0:10:51,846
把事情搞砸

315
00:10:52,166 --> 0:10:53,426
我们都有搞砸的时候

316
00:10:53,426 --> 0:10:55,096
所以在这种情况下

317
00:10:55,096 --> 0:10:55,986
你真的应该考虑

318
00:10:55,986 --> 0:10:57,716
我是否可以只做一次

319
00:10:57,716 --> 0:10:59,956
而非把它放入

320
00:11:00,346 --> 0:11:01,256
updateConstraints 中 完成这个工作的好办法

321
00:11:01,326 --> 0:11:03,936
就是使用 Interface Builder

322
00:11:04,286 --> 0:11:05,796
如果你可以使用 Interface Builder

323
00:11:06,026 --> 0:11:06,506
你就应该使用它

324
00:11:07,496 --> 0:11:08,946
它的好处体现在方方面面

325
00:11:08,946 --> 0:11:11,276
可以让你走上正确的路径

326
00:11:11,466 --> 0:11:13,206
好的 很好

327
00:11:13,346 --> 0:11:14,876
既然我们现在已经讨论过了

328
00:11:14,876 --> 0:11:15,856
我认为 我们已经更好地理解了

329
00:11:15,856 --> 0:11:17,286
为什么这是有问题的

330
00:11:17,286 --> 0:11:20,266
至少是通过类比

331
00:11:21,336 --> 0:11:22,486
但是这个演讲的目的

332
00:11:22,486 --> 0:11:23,846
要求我们做的比这更好

333
00:11:23,846 --> 0:11:26,336
我们并不只想说这样不好

334
00:11:26,536 --> 0:11:28,376
我们希望真正的理解它

335
00:11:28,376 --> 0:11:29,666
真正地理解这个过程

336
00:11:30,366 --> 0:11:32,956
为此我们需要

337
00:11:33,016 --> 0:11:34,816
拨开表面

338
00:11:34,816 --> 0:11:36,976
看到真正发生了什么事情

339
00:11:37,546 --> 0:11:43,096
那么当我们启用约束 添加约束时

340
00:11:43,096 --> 0:11:45,626
这个过程是什么样的呢

341
00:11:46,916 --> 0:11:48,276
我们以图表的形式进行直观阐述

342
00:11:48,626 --> 0:11:50,856
假设这是一个视图

343
00:11:50,856 --> 0:11:51,946
我们想在其中添加约束

344
00:11:53,056 --> 0:11:55,596
这个视图在一个窗口中

345
00:11:55,726 --> 0:11:57,406
窗口挂着

346
00:11:57,406 --> 0:12:00,086
一个内部对象叫做引擎

347
00:11:57,406 --> 0:12:00,086
一个内部对象叫做引擎

348
00:12:00,516 --> 0:12:03,296
引擎是 Auto Layout 的计算内核

349
00:12:03,816 --> 0:12:06,246
在添加约束后

350
00:12:06,576 --> 0:12:10,336
我们要创建

351
00:12:10,336 --> 0:12:12,146
一个与约束对应的等式

352
00:12:12,146 --> 0:12:13,616
然后我们将

353
00:12:13,616 --> 0:12:15,846
该等式添加到引擎中

354
00:12:16,516 --> 0:12:18,306
这个图表中最后一个

355
00:12:18,306 --> 0:12:19,906
需要理解的问题是该等式

356
00:12:20,186 --> 0:12:22,996
是关于变量的

357
00:12:22,996 --> 0:12:24,526
而变量 举个例子

358
00:12:24,526 --> 0:12:25,936
假设我给你一个等式 然后我说

359
00:12:25,936 --> 0:12:28,336
解出 X 那么 X 就是变量

360
00:12:29,396 --> 0:12:30,666
在这个情况下我们

361
00:12:30,666 --> 0:12:33,326
需要解决的就是

362
00:12:33,326 --> 0:12:34,746
视图的帧数据

363
00:12:35,166 --> 0:12:36,356
对于每一个视图

364
00:12:36,356 --> 0:12:37,916
将会有 4 个变量 分别是

365
00:12:37,916 --> 0:12:40,906
X 轴坐标 Y轴坐标 宽度和高度

366
00:12:41,126 --> 0:12:43,956
好的 那么让我们进入这一过程

367
00:12:44,276 --> 0:12:45,906
这是我们将要创建的布局

368
00:12:45,906 --> 0:12:46,976
简单起见我们仅关注

369
00:12:46,976 --> 0:12:48,166
横向约束

370
00:12:48,166 --> 0:12:49,386
但是我们会

371
00:12:49,386 --> 0:12:50,486
考虑整个过程

372
00:12:51,356 --> 0:12:52,496
那么第一件事

373
00:12:52,636 --> 0:12:53,996
如我们刚才所说 就是我们

374
00:12:53,996 --> 0:12:55,536
创建等式 看起来是这样子的

375
00:12:57,156 --> 0:12:58,366
这些看起来非常直观

376
00:12:58,676 --> 0:13:00,656
我认为最有趣的是

377
00:12:58,676 --> 0:13:00,656
我认为最有趣的是

378
00:13:00,656 --> 0:13:01,936
两个文本框之间的空间

379
00:13:01,936 --> 0:13:03,896
它看起来像是

380
00:13:03,896 --> 0:13:05,366
看起来非常

381
00:13:05,366 --> 0:13:07,656
近似于你写的

382
00:13:07,656 --> 0:13:08,896
约束 但它相对是

383
00:13:08,896 --> 0:13:10,416
更低层级的 因为它是

384
00:13:10,416 --> 0:13:11,756
关于这些变量的

385
00:13:13,376 --> 0:13:16,806
好的 然后每个等式

386
00:13:16,806 --> 0:13:18,336
都需要被添加到引擎

387
00:13:18,336 --> 0:13:20,546
事实上我们将会

388
00:13:20,546 --> 0:13:22,596
再次研究这一过程

389
00:13:22,596 --> 0:13:24,006
目标是对于

390
00:13:24,006 --> 0:13:27,386
性能特点有一个更好的把握

391
00:13:27,746 --> 0:13:28,846
那么 当我们这么写时发生了什么?

392
00:13:29,856 --> 0:13:31,856
引擎试图解出

393
00:13:31,856 --> 0:13:33,806
这些变量

394
00:13:33,806 --> 0:13:36,086
这跟你在代数中学到的很像

395
00:13:36,086 --> 0:13:38,936
看起来也完全相同

396
00:13:38,936 --> 0:13:40,106
那么我们一起来看

397
00:13:40,386 --> 0:13:42,166
首先是第一个等式

398
00:13:42,166 --> 0:13:44,146
表明第一个区域的 X 轴坐标是 8

399
00:13:44,486 --> 0:13:47,846
好的 它的宽度为 100 好

400
00:13:48,436 --> 0:13:50,696
好的 这个等式中我们定义

401
00:13:50,696 --> 0:13:52,106
定义第二个区域的 X 轴坐标

402
00:13:52,106 --> 0:13:53,556
等于第一个 X 坐标加上

403
00:13:53,556 --> 0:13:54,406
该宽度再加 20

404
00:13:54,406 --> 0:13:57,096
在代数中你会怎么做

405
00:13:57,096 --> 0:13:59,666
如果有人要求你解出这些变量

406
00:14:00,956 --> 0:14:02,836
你会用已知的

407
00:14:02,836 --> 0:14:03,996
数据来进行替换

408
00:14:04,146 --> 0:14:05,646
这就是接下来即将发生的事情

409
00:14:06,636 --> 0:14:08,486
如果你进行程序剖析

410
00:14:08,486 --> 0:14:10,356
会看到 引擎中确实有一个方法

411
00:14:10,356 --> 0:14:12,186
包含替换这个词

412
00:14:12,186 --> 0:14:13,986
同时还包含了其他的

413
00:14:13,986 --> 0:14:16,956
140 个字符 因为我们是

414
00:14:16,956 --> 0:14:18,776
Cocoa 编程开发者

415
00:14:18,776 --> 0:14:21,716
这就是引擎将要做的

416
00:14:22,266 --> 0:14:23,726
然后 你知道 最后一个

417
00:14:23,726 --> 0:14:26,726
等式进入后 看起来就完成了

418
00:14:27,126 --> 0:14:29,106
看上去这就是全部的

419
00:14:29,106 --> 0:14:30,636
工作 至少针对

420
00:14:30,636 --> 0:14:32,656
这个案例 就可以解出

421
00:14:32,656 --> 0:14:34,466
全部变量 确实如此

422
00:14:35,006 --> 0:14:36,646
这就是我此时要了解的

423
00:14:36,646 --> 0:14:39,856
那就是这些工作

424
00:14:39,856 --> 0:14:40,546
并不复杂

425
00:14:41,046 --> 0:14:42,856
它的过程

426
00:14:42,856 --> 0:14:43,956
和手工计算

427
00:14:43,956 --> 0:14:46,566
非常非常近似

428
00:14:46,566 --> 0:14:47,916
同时 它也并不是高消耗

429
00:14:48,266 --> 0:14:50,296
它只不过是完成替换 就像这样

430
00:14:50,536 --> 0:14:51,626
这就是它所做的工作

431
00:14:52,626 --> 0:14:54,976
好的 那么现在我们已经

432
00:14:55,326 --> 0:14:56,686
在引擎中解出了这些变量

433
00:14:56,686 --> 0:14:57,936
但是这并不是一个布局

434
00:14:58,386 --> 0:15:00,716
下面让我们完成这个过程

435
00:14:58,386 --> 0:15:00,716
下面让我们完成这个过程

436
00:15:02,036 --> 0:15:03,106
接下来的过程中

437
00:15:03,106 --> 0:15:06,506
每当引擎将一个值赋给

438
00:15:06,506 --> 0:15:07,816
其中一个变量

439
00:15:07,816 --> 0:15:09,746
它都会告知视图

440
00:15:09,746 --> 0:15:11,246
变量从何而来 并告知

441
00:15:11,246 --> 0:15:12,036
它已发生变化

442
00:15:12,496 --> 0:15:15,406
那么视图会做什么作为回应呢

443
00:15:16,526 --> 0:15:17,556
如果你想一想

444
00:15:17,556 --> 0:15:20,956
它会调用上级视图

445
00:15:20,956 --> 0:15:23,816
并使用 setNeedsLayout 因为需要发生变动

446
00:15:25,226 --> 0:15:27,196
好的 这就是

447
00:15:27,226 --> 0:15:30,216
更新约束阶段的全部内容

448
00:15:31,136 --> 0:15:32,106
现在我们已经收到了

449
00:15:32,106 --> 0:15:33,716
setNeedsLayout 在某个时间点

450
00:15:33,716 --> 0:15:35,536
就会进入布局阶段

451
00:15:36,696 --> 0:15:39,846
好的 最后一块拼图

452
00:15:39,846 --> 0:15:40,846
就是我们将会收到

453
00:15:40,846 --> 0:15:42,236
UIView 将会收到

454
00:15:42,236 --> 0:15:45,776
layoutSubViews 而它要做的就是

455
00:15:45,776 --> 0:15:47,816
把这部分数据

456
00:15:47,816 --> 0:15:49,096
从引擎中复制到帧

457
00:15:50,336 --> 0:15:52,356
那么它会询问引擎

458
00:15:52,356 --> 0:15:53,956
那些变量的值是多少

459
00:15:54,446 --> 0:15:56,676
引擎将会告知它 该上级视图

460
00:15:56,676 --> 0:15:58,746
就会在下级视图中

461
00:15:58,746 --> 0:16:02,076
调用 setCenter 和 setBounds

462
00:15:58,746 --> 0:16:02,076
调用 setCenter 和 setBounds

463
00:16:03,306 --> 0:16:04,606
这就是全部过程

464
00:16:06,146 --> 0:16:07,686
那么 我们回顾一下

465
00:16:07,686 --> 0:16:09,976
想一想这就是逐步创建布局的过程

466
00:16:10,206 --> 0:16:12,716
如果你能够尝试吸收它

467
00:16:12,716 --> 0:16:13,906
并找到感觉

468
00:16:14,166 --> 0:16:17,066
你将会对性能期望

469
00:16:17,066 --> 0:16:19,586
有更好地理解

470
00:16:20,486 --> 0:16:21,896
事实上 让我们看看

471
00:16:21,896 --> 0:16:23,676
现在是什么情况 因为现在

472
00:16:24,196 --> 0:16:26,886
当我们看到这里 看着这个方法

473
00:16:26,886 --> 0:16:29,506
也就是我们停用约束

474
00:16:29,506 --> 0:16:30,736
以及重新启用约束的地方

475
00:16:31,106 --> 0:16:32,346
回想一下我们刚才所做的

476
00:16:32,346 --> 0:16:33,656
想一想引擎

477
00:16:33,656 --> 0:16:34,206
将会怎么做

478
00:16:35,596 --> 0:16:36,626
它看起来将是这样

479
00:16:40,426 --> 0:16:42,136
我们称之为流失

480
00:16:42,556 --> 0:16:45,226
它的每一次运行

481
00:16:45,226 --> 0:16:47,246
并不是特别的高消耗 但是它

482
00:16:47,246 --> 0:16:49,576
运行的次数很多

483
00:16:49,576 --> 0:16:51,086
而这是完全不必要的

484
00:16:51,086 --> 0:16:52,196
这部分工作被浪费了

485
00:16:52,726 --> 0:16:54,456
那么如果你可以在心里感觉到

486
00:16:54,456 --> 0:16:56,336
如果你可以真正感觉到

487
00:16:56,406 --> 0:16:57,636
当你这么做时 发生的事情

488
00:16:58,046 --> 0:17:00,046
那么你就能够处于一个很好的状态

489
00:16:58,046 --> 0:17:00,046
那么你就能够处于一个很好的状态

490
00:17:00,356 --> 0:17:02,046
那么你就会

491
00:17:02,046 --> 0:17:03,036
与接下来我们

492
00:17:03,036 --> 0:17:05,056
要做的处于同一水准

493
00:17:05,056 --> 0:17:05,715
并对此具备一个良好的把握

494
00:17:06,636 --> 0:17:08,935
好的 我希望目前一切都好

495
00:17:08,935 --> 0:17:14,246
我们还有另外一个大话题

496
00:17:14,246 --> 0:17:15,236
希望探讨

497
00:17:15,236 --> 0:17:16,256
如果想要获得一个

498
00:17:16,256 --> 0:17:18,356
较好的性能模型 我们的想法是

499
00:17:18,356 --> 0:17:20,766
你只为你使用的内容消耗性能

500
00:17:20,766 --> 0:17:21,965
这在 Auto Layout 中可以做到

501
00:17:22,086 --> 0:17:23,056
当看过这些以后我认为

502
00:17:23,056 --> 0:17:26,665
我们已经能够理解其中的含义 对吗

503
00:17:26,665 --> 0:17:28,346
为此 我们假设

504
00:17:28,346 --> 0:17:29,476
目前的情况是之前的两倍

505
00:17:29,476 --> 0:17:31,346
那么我们有四个文本框

506
00:17:31,346 --> 0:17:33,076
分别在两个互相独立的层级中

507
00:17:34,496 --> 0:17:36,886
现在你可以做的是

508
00:17:36,886 --> 0:17:38,426
创建一个约束

509
00:17:38,426 --> 0:17:40,606
令其像这样跨越层级

510
00:17:40,976 --> 0:17:42,866
那么你可以说

511
00:17:42,866 --> 0:17:44,286
1 号文本框应该与

512
00:17:44,286 --> 0:17:45,316
3 号文本框对齐

513
00:17:45,316 --> 0:17:46,656
尽管它们的上级视图并不相同

514
00:17:48,186 --> 0:17:50,956
我认为 有时候人们会有

515
00:17:50,956 --> 0:17:52,486
一个印象 就是因为这是

516
00:17:52,516 --> 0:17:54,526
可能完成的 就意味着它会

517
00:17:54,526 --> 0:17:56,606
运行的较为缓慢

518
00:17:56,606 --> 0:17:58,226
因为各个部分可能

519
00:17:58,226 --> 0:17:59,646
随时相互影响

520
00:17:59,646 --> 0:18:00,746
就像一团浆糊

521
00:17:59,646 --> 0:18:00,746
就像一团浆糊

522
00:18:00,746 --> 0:18:04,296
而性能可能很糟糕

523
00:18:05,056 --> 0:18:07,306
好的 但我们了解过

524
00:18:07,306 --> 0:18:08,936
刚才的内容后 再一起来看看

525
00:18:08,936 --> 0:18:11,086
在普通情况下

526
00:18:11,086 --> 0:18:13,136
不会进行这种操作 因为大部分时间

527
00:18:13,136 --> 0:18:14,006
都没有必要

528
00:18:14,506 --> 0:18:16,476
大多数情况下

529
00:18:16,476 --> 0:18:17,906
视图仅受到上级视图或

530
00:18:17,906 --> 0:18:18,916
同级视图的约束

531
00:18:19,736 --> 0:18:23,026
你看到由于我们有两个

532
00:18:23,026 --> 0:18:25,586
互相独立的区块

533
00:18:25,586 --> 0:18:27,036
引擎内部

534
00:18:27,036 --> 0:18:28,366
将会有两个

535
00:18:28,366 --> 0:18:29,926
互相独立的等式块

536
00:18:29,926 --> 0:18:31,206
它们完全不与

537
00:18:31,206 --> 0:18:32,366
对方互动 也不具有任何

538
00:18:32,366 --> 0:18:33,636
互相重合的变量

539
00:18:34,146 --> 0:18:36,776
这样一来

540
00:18:36,776 --> 0:18:38,186
由于它们完全不会

541
00:18:38,186 --> 0:18:39,596
重合 就不会发生互动

542
00:18:39,996 --> 0:18:41,296
如果我们只有一个等式快

543
00:18:41,296 --> 0:18:43,966
就需要花一些时间来进行处理

544
00:18:44,246 --> 0:18:45,536
如果我们有两个这样的等式块

545
00:18:45,536 --> 0:18:47,256
就需要花费两倍的时间

546
00:18:47,556 --> 0:18:48,486
因为它们之间并没有任何关系

547
00:18:49,246 --> 0:18:50,316
如果有三个 就是三倍时间

548
00:18:50,546 --> 0:18:52,566
以此类推 问题在于你

549
00:18:52,626 --> 0:18:54,366
将会看到线性关系

550
00:18:54,366 --> 0:18:56,836
你将会看到线性的

551
00:18:56,836 --> 0:18:58,026
性能 这已经是你可以

552
00:18:58,026 --> 0:18:59,016
得到的最优结果

553
00:18:59,276 --> 0:19:01,106
已经是最好的情况了

554
00:18:59,276 --> 0:19:01,106
已经是最好的情况了

555
00:19:01,246 --> 0:19:03,816
我想要再次强调一下

556
00:19:03,816 --> 0:19:05,496
之所以它是线性的

557
00:19:05,496 --> 0:19:06,306
是因为它们之间

558
00:19:06,306 --> 0:19:07,886
不存在任何互相依赖性

559
00:19:08,516 --> 0:19:09,596
如果它们之间存在互相依赖性

560
00:19:10,066 --> 0:19:11,846
那么这些等式块

561
00:19:11,846 --> 0:19:14,106
将会被连在一起

562
00:19:14,106 --> 0:19:15,996
将会有更多的

563
00:19:15,996 --> 0:19:18,096
计算需要处理

564
00:19:18,566 --> 0:19:19,876
但也只是使用的时候

565
00:19:20,396 --> 0:19:22,236
当然如果你确实有这样的情况 你知道

566
00:19:22,236 --> 0:19:23,446
如果你手动处理

567
00:19:23,446 --> 0:19:24,246
当然它会比较

568
00:19:24,246 --> 0:19:25,396
消耗性能

569
00:19:25,396 --> 0:19:27,446
你也能想到 因为这件事情更为复杂

570
00:19:27,546 --> 0:19:29,626
这样常见的情况

571
00:19:29,626 --> 0:19:31,456
是我们在 Cocoa 中的目标

572
00:19:31,456 --> 0:19:32,626
即让简单的事情

573
00:19:32,626 --> 0:19:34,976
保持简单 让复杂的事情成为可能

574
00:19:35,306 --> 0:19:36,476
在这一情况下 它们可能

575
00:19:36,476 --> 0:19:37,176
性能消耗会高一点

576
00:19:37,596 --> 0:19:38,986
但是你不必为此消耗性能

577
00:19:38,986 --> 0:19:41,296
如果你不使用的话

578
00:19:41,296 --> 0:19:44,716
事实上 用直觉理解整个引擎的

579
00:19:44,716 --> 0:19:46,726
正确方法就是 你可以把它

580
00:19:46,726 --> 0:19:49,206
想作一个布局的缓存

581
00:19:49,206 --> 0:19:50,446
和一个依赖关系追踪器

582
00:19:51,296 --> 0:19:52,736
它非常有针对性

583
00:19:52,776 --> 0:19:54,396
它了解哪些约束

584
00:19:54,396 --> 0:19:55,896
会影响哪些视图 而当你

585
00:19:55,896 --> 0:19:58,346
做出改变时 它只会更新

586
00:19:58,346 --> 0:19:59,866
需要改变的内容

587
00:20:00,396 --> 0:20:02,976
这对于你写代码也有启发

588
00:20:04,696 --> 0:20:07,306
有时候我们看到的一个问题是

589
00:20:07,306 --> 0:20:08,886
有一些人会

590
00:20:08,886 --> 0:20:11,236
费很大劲去避免创建

591
00:20:11,236 --> 0:20:13,686
约束 因为他们

592
00:20:13,686 --> 0:20:15,546
认为这样性能消耗太高

593
00:20:16,476 --> 0:20:18,296
然而 事实上约束很有针对性

594
00:20:18,526 --> 0:20:19,736
只要你创建的

595
00:20:19,736 --> 0:20:21,866
约束能够有效对应

596
00:20:21,866 --> 0:20:22,746
你正在解决的问题

597
00:20:22,746 --> 0:20:24,456
那么 就不太可能发生

598
00:20:24,456 --> 0:20:25,556
更好的情况

599
00:20:25,556 --> 0:20:26,646
如果你试图去回避问题

600
00:20:26,646 --> 0:20:27,636
也不会有更好的性能情况

601
00:20:28,126 --> 0:20:29,796
我们经常看到有些人

602
00:20:29,796 --> 0:20:31,036
进行非常复杂的测量

603
00:20:31,036 --> 0:20:33,006
把问题复杂化

604
00:20:33,006 --> 0:20:34,406
然后试图

605
00:20:34,406 --> 0:20:35,756
获取信息 然后再

606
00:20:35,756 --> 0:20:37,496
返回信息 这样往往

607
00:20:37,496 --> 0:20:38,986
消耗更多 相对

608
00:20:38,986 --> 0:20:40,126
直接表达一个

609
00:20:40,126 --> 0:20:41,296
你所需要的约束而言

610
00:20:42,606 --> 0:20:45,456
这个问题的反面是

611
00:20:45,456 --> 0:20:47,286
有时候我们会看到

612
00:20:47,716 --> 0:20:49,366
像这样的层级

613
00:20:49,526 --> 0:20:51,006
在这样的层级中我们看到

614
00:20:51,006 --> 0:20:52,356
非常多的约束

615
00:20:52,356 --> 0:20:54,456
以及非常多的优先级 以至于

616
00:20:54,456 --> 0:20:56,176
过程很不清晰

617
00:20:56,176 --> 0:20:58,146
通常这种情况

618
00:20:58,146 --> 0:21:00,466
表示事实上

619
00:20:58,146 --> 0:21:00,466
表示事实上

620
00:21:00,466 --> 0:21:01,816
情况可能是

621
00:21:01,816 --> 0:21:03,426
这个人心里有两个完全

622
00:21:03,426 --> 0:21:04,896
独立的布局

623
00:21:05,346 --> 0:21:07,406
而试图把它们

624
00:21:07,406 --> 0:21:09,196
打包到一套

625
00:21:09,196 --> 0:21:11,286
约束中 然后一次性解决问题

626
00:21:11,836 --> 0:21:13,906
这也不是一个好主意

627
00:21:14,276 --> 0:21:17,056
那将会产生

628
00:21:17,056 --> 0:21:18,316
许多虚假的依赖关系

629
00:21:18,616 --> 0:21:19,776
它们看起来是

630
00:21:19,776 --> 0:21:20,846
互动的 但事实上

631
00:21:20,846 --> 0:21:21,196
并非如此

632
00:21:21,586 --> 0:21:22,786
而且几乎没办法

633
00:21:22,786 --> 0:21:25,506
进行调试 如果你不注意的话

634
00:21:26,186 --> 0:21:30,406
那么我的总体建议是

635
00:21:30,406 --> 0:21:32,516
试图以最直接的方式对问题建模

636
00:21:32,766 --> 0:21:33,826
Kasia 将会带大家

637
00:21:33,826 --> 0:21:34,786
探讨这类在

638
00:21:34,786 --> 0:21:35,736
不同的布局间切换的例子

639
00:21:35,736 --> 0:21:37,396
并且展示的更为明确

640
00:21:38,186 --> 0:21:40,106
但是这只是一般性建议

641
00:21:40,346 --> 0:21:41,886
你需要自然地使用它

642
00:21:42,036 --> 0:21:43,276
这对于性能

643
00:21:43,606 --> 0:21:45,176
和理解都有好处

644
00:21:45,736 --> 0:21:50,926
好的 这就是我们今天要说的大部分内容

645
00:21:51,186 --> 0:21:52,526
但是由于我们想要建立

646
00:21:52,526 --> 0:21:54,276
一个总体的关于

647
00:21:54,276 --> 0:21:55,336
布局性能特点的心理模型

648
00:21:55,336 --> 0:21:57,146
我希望至少确保

649
00:21:57,146 --> 0:21:59,636
我们谈到了全部主要特征

650
00:21:59,856 --> 0:22:01,546
你还有很多其他的事情可以做

651
00:21:59,856 --> 0:22:01,546
你还有很多其他的事情可以做

652
00:22:02,676 --> 0:22:04,046
我们讨论一下

653
00:22:04,626 --> 0:22:05,946
那么你可以定义一些

654
00:22:05,946 --> 0:22:07,186
特定的视图

655
00:22:07,186 --> 0:22:08,346
宽度至少为 100

656
00:22:08,466 --> 0:22:09,366
你可以使用不等式

657
00:22:10,106 --> 0:22:10,806
这样做的消耗如何

658
00:22:11,736 --> 0:22:12,816
非常非常低

659
00:22:13,006 --> 0:22:13,876
与仅仅定义

660
00:22:13,876 --> 0:22:15,736
宽度等于 100 相比

661
00:22:15,736 --> 0:22:17,346
由于我们已经对内部问题略有探讨

662
00:22:17,656 --> 0:22:20,636
它的消耗仅仅是多一个变量 仅此而已

663
00:22:21,156 --> 0:22:23,936
你也可以调用设置常量功能

664
00:22:24,436 --> 0:22:26,066
对这个问题的用例

665
00:22:26,066 --> 0:22:27,926
就如同我有一个

666
00:22:27,926 --> 0:22:29,206
手势辨认器 而我

667
00:22:29,266 --> 0:22:31,396
试图将一个视图四处拖拽

668
00:22:31,396 --> 0:22:32,676
要做的是

669
00:22:32,676 --> 0:22:34,976
每一次我从手势辨识器

670
00:22:34,976 --> 0:22:36,196
获得信号时

671
00:22:36,196 --> 0:22:38,416
我会使用它的翻译结果

672
00:22:38,416 --> 0:22:39,296
并将其输入一个

673
00:22:39,296 --> 0:22:41,006
约束 通过为

674
00:22:41,006 --> 0:22:43,866
该约束设置常量的方式

675
00:22:44,626 --> 0:22:45,896
输入翻译值

676
00:22:46,616 --> 0:22:48,966
好的 它接下来要做的是

677
00:22:48,966 --> 0:22:50,616
我们刚才讨论过的引擎如何充当

678
00:22:50,616 --> 0:22:51,786
一个依赖关系追踪器

679
00:22:52,346 --> 0:22:53,976
它将这一点发挥到了

680
00:22:53,976 --> 0:22:55,016
最大水平

681
00:22:55,656 --> 0:22:58,016
这是一个

682
00:22:58,016 --> 0:23:00,266
非常快速的一步更新

683
00:22:58,016 --> 0:23:00,266
非常快速的一步更新

684
00:23:00,266 --> 0:23:02,426
由于约束的改变

685
00:23:02,696 --> 0:23:04,106
而改变需要更改的内容

686
00:23:04,916 --> 0:23:06,606
这是一种性能优化

687
00:23:06,606 --> 0:23:07,936
这就是为什么我们要用这么一个

688
00:23:07,936 --> 0:23:08,936
设置常量的方法

689
00:23:09,476 --> 0:23:11,526
最后要讨论的是它的优先级

690
00:23:12,436 --> 0:23:14,536
因此这里你可以定义

691
00:23:14,536 --> 0:23:16,266
你可以定义这个视图

692
00:23:16,266 --> 0:23:18,676
最好宽度为 100 但是

693
00:23:18,876 --> 0:23:20,046
如果达不到

694
00:23:20,046 --> 0:23:22,236
就尽量靠近这个数值

695
00:23:22,956 --> 0:23:24,636
这确实会导致更多的工作

696
00:23:25,326 --> 0:23:26,196
一定量的工作发生

697
00:23:26,196 --> 0:23:28,306
那么让我们进一步讨论一下

698
00:23:28,576 --> 0:23:29,866
另一个考虑的角度

699
00:23:30,206 --> 0:23:31,626
是定义该文本框的宽度

700
00:23:31,626 --> 0:23:35,666
等于 100 加一些误差 并且

701
00:23:35,666 --> 0:23:36,716
最小化该误差

702
00:23:37,436 --> 0:23:38,496
这就是你们想要的部分

703
00:23:39,776 --> 0:23:41,266
因此这里有一个误差

704
00:23:41,266 --> 0:23:42,536
最小化的阶段 我之前

705
00:23:42,536 --> 0:23:43,156
没有讨论过

706
00:23:43,366 --> 0:23:46,816
当视图询问引擎

707
00:23:46,816 --> 0:23:48,086
作为布局子视图的一部分

708
00:23:48,086 --> 0:23:50,446
“这些变量的值是多少?”

709
00:23:50,686 --> 0:23:51,866
引擎需要确保

710
00:23:51,866 --> 0:23:53,366
所有误差值

711
00:23:53,366 --> 0:23:54,626
已经完成最小化

712
00:23:55,386 --> 0:23:58,546
实际上我不会探讨具体

713
00:23:58,546 --> 0:24:00,726
是如何工作的 但我会稍微讨论一下

714
00:23:58,546 --> 0:24:00,726
是如何工作的 但我会稍微讨论一下

715
00:24:00,726 --> 0:24:02,006
性能特点

716
00:24:02,056 --> 0:24:03,586
我会说的简洁明了

717
00:24:04,536 --> 0:24:06,746
因此你或许想要

718
00:24:06,746 --> 0:24:07,196
看看这个

719
00:24:07,196 --> 0:24:08,476
这是简单的 X 算法

720
00:24:08,476 --> 0:24:09,526
这是实际的事

721
00:24:09,866 --> 0:24:11,206
非常古老

722
00:24:11,676 --> 0:24:13,186
是第二次世界大战期间开发的

723
00:24:13,576 --> 0:24:17,246
甚至早于电脑的出现

724
00:24:17,416 --> 0:24:19,026
事实上 过去有一些人

725
00:24:19,026 --> 0:24:20,356
被称为电脑

726
00:24:20,356 --> 0:24:21,156
就在机器被称为电脑之前

727
00:24:21,156 --> 0:24:23,016
这就是他们所做的事情

728
00:24:23,486 --> 0:24:25,706
他们手动完成计算

729
00:24:25,856 --> 0:24:27,146
这会给你一些关于

730
00:24:27,146 --> 0:24:28,076
性能特点的感觉

731
00:24:28,316 --> 0:24:29,566
如果你手动计算

732
00:24:29,566 --> 0:24:30,816
应该非常快 而且它确实是

733
00:24:31,126 --> 0:24:33,336
这与我们刚才做的事情

734
00:24:33,336 --> 0:24:34,106
几乎是相同的

735
00:24:34,166 --> 0:24:35,326
更多的是替换过程

736
00:24:35,726 --> 0:24:37,066
这就是你进行思考的方式

737
00:24:38,266 --> 0:24:39,676
不管怎么说 你知道

738
00:24:39,676 --> 0:24:40,986
当你使用优先级时

739
00:24:40,986 --> 0:24:42,116
它确实会产生这么多性能消耗

740
00:24:42,256 --> 0:24:43,146
这一点需要注意

741
00:24:44,226 --> 0:24:46,216
好的 除此之外 它与之前相同

742
00:24:46,616 --> 0:24:50,546
这就是我想说的内容

743
00:24:50,756 --> 0:24:52,556
这就是我们试图建立

744
00:24:52,556 --> 0:24:54,836
这种直观的

745
00:24:54,836 --> 0:24:56,086
对于 Auto Layout 的

746
00:24:56,086 --> 0:24:58,046
性能特点的理解

747
00:24:58,176 --> 0:24:59,746
快速地回顾一下我们刚才讨论的内容

748
00:25:00,226 --> 0:25:01,766
不要使你的约束流失

749
00:25:02,316 --> 0:25:03,036
这在你完成

750
00:25:03,036 --> 0:25:04,826
无意义工作时会发生

751
00:25:05,116 --> 0:25:05,686
因此不要这么做

752
00:25:06,326 --> 0:25:09,876
当你处理约束时 它实际上是基础代数

753
00:25:10,176 --> 0:25:11,566
而这种代数也发生在

754
00:25:11,566 --> 0:25:12,706
你添加约束

755
00:25:12,706 --> 0:25:14,586
移除约束

756
00:25:14,586 --> 0:25:16,706
以及调用设置常量功能时

757
00:25:16,706 --> 0:25:17,466
以上是主要情况

758
00:25:17,956 --> 0:25:20,956
还有 你知道 当我们

759
00:25:20,956 --> 0:25:22,866
处于误差最小化阶段时 也是代数问题

760
00:25:23,436 --> 0:25:26,916
理解 Auto Layout 的工作原理的方法是

761
00:25:26,916 --> 0:25:28,546
把它想做是一个

762
00:25:28,546 --> 0:25:29,806
布局缓存

763
00:25:29,806 --> 0:25:31,226
可以看到引擎包含所有

764
00:25:31,226 --> 0:25:33,016
已解出的值 并且它是一个

765
00:25:33,016 --> 0:25:34,766
依赖关系追踪器 因此当

766
00:25:34,766 --> 0:25:36,916
数据发生改变时我们可以

767
00:25:37,066 --> 0:25:39,296
以一个非常有针对性的方法 更新那些值

768
00:25:39,896 --> 0:25:41,016
这引出了我们最后一个点

769
00:25:41,186 --> 0:25:43,236
那就是你只为

770
00:25:43,236 --> 0:25:44,216
你在使用的功能消耗性能

771
00:25:45,266 --> 0:25:46,916
这就是我们所谈到的内容

772
00:25:47,276 --> 0:25:48,566
你知道 这就是你的直觉判断

773
00:25:48,956 --> 0:25:53,376
接下来的部分我将会交给 Kasia

774
00:25:53,376 --> 0:25:54,556
因为 再次强调 如果你

775
00:25:54,556 --> 0:25:56,586
只是依赖于直觉判断 是无法完成布局的

776
00:25:56,866 --> 0:25:58,336
所以她将会进行

777
00:25:58,336 --> 0:25:59,946
一些分析

778
00:25:59,946 --> 0:26:01,286
避免我们刚才讨论的问题 并把直觉判断

779
00:25:59,946 --> 0:26:01,286
避免我们刚才讨论的问题 并把直觉判断

780
00:26:01,286 --> 0:26:02,006
用于实践中

781
00:26:02,336 --> 0:26:03,926
欢迎她

782
00:26:04,516 --> 0:26:11,546
[ 掌声 ]

783
00:26:12,046 --> 0:26:13,096
&gt;&gt; 好的 请让我开始我的部分

784
00:26:14,056 --> 0:26:15,696
谢谢 Ken 大家好

785
00:26:15,956 --> 0:26:17,246
我的名字是 Kasia Wawer

786
00:26:17,796 --> 0:26:20,886
我是 iOS 键盘组的成员 我们使用

787
00:26:20,886 --> 0:26:22,106
Auto Layout 也很喜欢它

788
00:26:22,646 --> 0:26:24,006
所以接下来我想与大家讨论

789
00:26:24,006 --> 0:26:25,206
如何创建有效的布局

790
00:26:26,286 --> 0:26:27,056
好的 让我们快速

791
00:26:27,056 --> 0:26:28,586
回顾一下约束流失问题

792
00:26:29,116 --> 0:26:30,396
正如刚才听到的 约束流失

793
00:26:30,396 --> 0:26:31,876
发生在你改变你的

794
00:26:31,876 --> 0:26:33,726
约束 但是实际视图

795
00:26:33,726 --> 0:26:35,396
并不需要变动时 因此你

796
00:26:35,396 --> 0:26:36,816
向引擎发送了过多工作

797
00:26:37,276 --> 0:26:38,456
而且可能会影响到

798
00:26:38,456 --> 0:26:39,106
你的性能表现

799
00:26:39,106 --> 0:26:40,776
所以你希望避免这种情况

800
00:26:41,636 --> 0:26:43,646
那么让我们探讨一下你什么时候

801
00:26:43,646 --> 0:26:45,746
可能遇到这一问题

802
00:26:45,746 --> 0:26:46,556
以及如何解决它

803
00:26:46,556 --> 0:26:49,056
因此我们将以一个规格说明为例

804
00:26:49,286 --> 0:26:50,866
这是一个社交网络 App 使用的规格说明

805
00:26:51,586 --> 0:26:52,526
有一个头像视图

806
00:26:52,526 --> 0:26:53,566
可以显示谁在分享

807
00:26:53,566 --> 0:26:56,336
有一个标题 一个日期

808
00:26:56,336 --> 0:26:59,206
以及一个日志输入界面

809
00:26:59,206 --> 0:27:00,186
你需要设置一些间隔

810
00:26:59,206 --> 0:27:00,186
你需要设置一些间隔

811
00:27:00,186 --> 0:27:01,606
可能需要

812
00:27:01,606 --> 0:27:04,516
规定一些尺寸 你也有可能会用到对齐

813
00:27:05,566 --> 0:27:08,036
而事实上这并非一个完全的

814
00:27:08,036 --> 0:27:08,946
社交媒体 App

815
00:27:09,266 --> 0:27:11,036
这是一个半社交媒体 App

816
00:27:11,476 --> 0:27:13,276
你可以选择是否愿意分享内容

817
00:27:14,176 --> 0:27:15,986
因此还有一个可选的

818
00:27:15,986 --> 0:27:16,756
视图 显示你已经

819
00:27:16,756 --> 0:27:18,016
分享的内容 以及分享的用户

820
00:27:18,946 --> 0:27:20,376
而且一个社交媒体 App

821
00:27:20,376 --> 0:27:22,166
如果不能分享猫的图片

822
00:27:22,166 --> 0:27:23,036
就是不完整的

823
00:27:23,936 --> 0:27:24,896
因此你可能会需要

824
00:27:24,896 --> 0:27:25,846
添加另一个布局

825
00:27:26,836 --> 0:27:28,326
也许你根本并不想

826
00:27:28,326 --> 0:27:29,236
分享这个猫的图片 因为

827
00:27:29,236 --> 0:27:30,346
它实在太好了 你想要

828
00:27:30,346 --> 0:27:31,066
自己保留它

829
00:27:32,056 --> 0:27:33,976
那么我们有四个非常相似的布局

830
00:27:34,626 --> 0:27:35,996
它们并不是相同的

831
00:27:35,996 --> 0:27:36,776
需要做一些调整

832
00:27:36,776 --> 0:27:38,196
当这些表格视图

833
00:27:38,196 --> 0:27:39,306
单元格出现在屏幕上时

834
00:27:39,396 --> 0:27:40,396
当做我刚刚没有提到它们

835
00:27:40,396 --> 0:27:41,156
存在于表格视图单元格中

836
00:27:42,026 --> 0:27:43,406
让我们假设你正在

837
00:27:43,406 --> 0:27:45,236
处理这个 App 的性能问题

838
00:27:45,236 --> 0:27:47,026
你第一次运行它

839
00:27:47,026 --> 0:27:49,036
这就是你获得的滑动性能

840
00:27:49,386 --> 0:27:51,316
其中有很多卡顿现象

841
00:27:51,316 --> 0:27:52,976
尤其是当向上滑动 返回顶部时

842
00:27:53,086 --> 0:27:55,666
那么你会想 好的 我要怎样来

843
00:27:55,666 --> 0:27:57,026
提升这个 App 呢

844
00:27:57,026 --> 0:27:57,716
发生什么问题了呢

845
00:27:58,636 --> 0:28:00,986
因此我想介绍

846
00:27:58,636 --> 0:28:00,986
因此我想介绍

847
00:28:01,096 --> 0:28:02,406
一个新的功能 它可以让你

848
00:28:02,406 --> 0:28:03,416
对我们正在开发的内容先睹为快

849
00:28:03,886 --> 0:28:05,096
目前它在

850
00:28:05,096 --> 0:28:07,486
测试版中尚不可用 但是敬请期待

851
00:28:07,946 --> 0:28:08,886
因为我们很快会

852
00:28:08,886 --> 0:28:10,386
推出一个布局设计的工具

853
00:28:12,076 --> 0:28:12,796
好的

854
00:28:13,516 --> 0:28:18,716
[ 掌声 ]

855
00:28:19,216 --> 0:28:20,086
我很高兴你们对此感到兴奋

856
00:28:20,606 --> 0:28:21,866
让我们很有动力

857
00:28:22,576 --> 0:28:24,526
不管怎么说 我们一起来看看 发生了什么

858
00:28:25,466 --> 0:28:27,186
最顶部的轨迹显示的是

859
00:28:27,226 --> 0:28:28,856
正在使用的 CPU 容量

860
00:28:29,496 --> 0:28:30,646
某种程度上说

861
00:28:30,646 --> 0:28:31,556
这是一个危险信号

862
00:28:31,756 --> 0:28:33,116
如果存在许多峰值

863
00:28:33,446 --> 0:28:34,486
这意味着你

864
00:28:34,486 --> 0:28:35,436
你的布局

865
00:28:35,436 --> 0:28:36,846
可能有一些问题

866
00:28:37,576 --> 0:28:38,686
而如果它较为平滑

867
00:28:39,166 --> 0:28:40,106
可能其它地方

868
00:28:40,106 --> 0:28:41,526
会有别的问题

869
00:28:42,466 --> 0:28:43,906
下面的轨迹则

870
00:28:43,906 --> 0:28:45,756
具体地追踪约束流失

871
00:28:46,446 --> 0:28:47,616
这些柱状图的高度

872
00:28:47,616 --> 0:28:49,846
在这个例子中 反映的是

873
00:28:49,846 --> 0:28:51,196
发生约束流失的

874
00:28:51,196 --> 0:28:52,596
视图数量

875
00:28:53,506 --> 0:28:54,506
因此当你看到很高的柱状图时

876
00:28:54,506 --> 0:28:56,226
你就知道有许多视图受到了影响

877
00:28:57,446 --> 0:28:59,456
我们也会展示如何

878
00:28:59,456 --> 0:29:00,746
移除和改变约束

879
00:28:59,456 --> 0:29:00,746
移除和改变约束

880
00:29:01,776 --> 0:29:05,326
并最终设定

881
00:29:05,326 --> 0:29:06,716
UILabel 和其他文本视图的尺寸

882
00:29:06,906 --> 0:29:08,286
这里是 UILabel 是因为

883
00:29:08,286 --> 0:29:09,156
这是 App 中的内容

884
00:29:09,956 --> 0:29:11,026
它也可以追踪其他

885
00:29:11,026 --> 0:29:12,186
类型的文本视图

886
00:29:13,786 --> 0:29:16,286
那么这是 App

887
00:29:16,366 --> 0:29:18,816
滑动时的情况 我们需要查看什么呢

888
00:29:19,206 --> 0:29:21,136
有一些峰值发生在

889
00:29:21,136 --> 0:29:24,236
CPU 视图中 但是让我们放大

890
00:29:24,236 --> 0:29:25,776
这一个 因为在它下面

891
00:29:25,776 --> 0:29:27,106
我看到了一个约束流失的

892
00:29:27,106 --> 0:29:28,926
突然上升 这有些令人担忧

893
00:29:29,906 --> 0:29:31,396
那么 如果你选中这个视图

894
00:29:31,526 --> 0:29:32,966
然后进入 Instruments 中的

895
00:29:33,666 --> 0:29:35,486
详细视图 你会看到的是

896
00:29:35,726 --> 0:29:36,846
一个列表 根据视图描述列明

897
00:29:36,846 --> 0:29:38,896
受到约束流失影响的视图

898
00:29:39,586 --> 0:29:40,556
我们依据

899
00:29:40,556 --> 0:29:42,326
上级视图将它们分类 那么

900
00:29:42,326 --> 0:29:44,576
比如说在表格视图单元格中

901
00:29:44,576 --> 0:29:46,486
很容易看出这个问题

902
00:29:46,486 --> 0:29:48,286
一次又一次地发生在

903
00:29:48,286 --> 0:29:50,116
某个特定的情况下 而非不同情况下

904
00:29:51,016 --> 0:29:52,536
那么在这一实例中我们看到

905
00:29:52,536 --> 0:29:54,586
头像视图和三个不同标签

906
00:29:54,966 --> 0:29:55,956
都出现了流失问题

907
00:29:57,316 --> 0:29:59,646
由于是我

908
00:29:59,646 --> 0:30:01,696
负责在 Instruments 中运行的

909
00:29:59,646 --> 0:30:01,696
负责在 Instruments 中运行的

910
00:30:01,696 --> 0:30:02,386
我知道这些标签

911
00:30:02,426 --> 0:30:03,876
对应的是 标题标签

912
00:30:03,876 --> 0:30:05,686
日期标签和我们的日志输入标签

913
00:30:07,036 --> 0:30:08,516
这几乎是单元格内的

914
00:30:08,516 --> 0:30:09,086
全部视图了

915
00:30:09,086 --> 0:30:10,736
这让人有点担心

916
00:30:11,406 --> 0:30:12,136
我们一起来看看发生了什么

917
00:30:13,766 --> 0:30:15,376
好的 回到我们的规格说明

918
00:30:16,326 --> 0:30:19,626
通过查看代码发现

919
00:30:19,666 --> 0:30:21,566
UpdateConstraints 正在被覆写

920
00:30:22,526 --> 0:30:25,956
并且在该方法中 在发生任何改变或

921
00:30:25,956 --> 0:30:27,426
UpdateConstraints 在运行时

922
00:30:27,896 --> 0:30:28,696
都会移除全部约束

923
00:30:28,696 --> 0:30:30,716
然后再添加

924
00:30:30,716 --> 0:30:32,276
我们认为需要的约束

925
00:30:33,876 --> 0:30:35,956
一切又回到

926
00:30:35,956 --> 0:30:37,206
原来的样子

927
00:30:37,646 --> 0:30:39,436
正是这种移除

928
00:30:39,436 --> 0:30:41,516
导致性能问题

929
00:30:42,486 --> 0:30:44,986
那么 这里的社交标签

930
00:30:44,986 --> 0:30:46,986
也就是社交头像

931
00:30:47,356 --> 0:30:49,176
被反复添加和移除

932
00:30:49,176 --> 0:30:50,626
我们并不需要完全移除

933
00:30:51,806 --> 0:30:52,856
当你查看

934
00:30:52,856 --> 0:30:54,966
这一视图的约束时 你会看到

935
00:30:54,966 --> 0:30:56,036
它们实际上

936
00:30:56,036 --> 0:30:57,316
并不与其他任何东西互动

937
00:30:57,876 --> 0:30:58,946
仅仅是一个单一的视图

938
00:30:59,516 --> 0:31:01,156
此时你可以使用

939
00:30:59,516 --> 0:31:01,156
此时你可以使用

940
00:31:01,156 --> 0:31:03,366
这个非常简洁的功能叫做

941
00:31:03,566 --> 0:31:05,536
setHidden 也许你听说过

942
00:31:05,656 --> 0:31:07,936
而且由于它并不影响

943
00:31:07,936 --> 0:31:09,686
任何周围的视图

944
00:31:09,686 --> 0:31:10,626
它就会消失

945
00:31:10,626 --> 0:31:11,866
其约束则会得到保留

946
00:31:11,866 --> 0:31:13,656
这是一个非常非常简便的

947
00:31:14,136 --> 0:31:15,846
方法来隐藏和显示视图

948
00:31:16,416 --> 0:31:18,036
而非将它们从层级中移除

949
00:31:18,986 --> 0:31:19,736
因此这是没有问题的

950
00:31:20,246 --> 0:31:21,556
但是这是一个非常简单的例子

951
00:31:21,556 --> 0:31:22,546
那么图像视图呢

952
00:31:23,016 --> 0:31:24,606
好的 对于图像视图

953
00:31:24,606 --> 0:31:25,806
我们可能再一次

954
00:31:25,806 --> 0:31:26,686
试图将所有的

955
00:31:26,686 --> 0:31:28,176
约束移除 而后再添加

956
00:31:28,626 --> 0:31:30,896
已有的约束以及图像视图的约束

957
00:31:31,816 --> 0:31:34,446
一切又回到原来的样子

958
00:31:34,446 --> 0:31:35,356
这就是约束流失

959
00:31:36,566 --> 0:31:37,776
在这样的情况下

960
00:31:38,156 --> 0:31:39,326
我希望你们思考的方式是

961
00:31:39,326 --> 0:31:41,176
分组查看约束

962
00:31:41,896 --> 0:31:43,446
让我们从这个分组开始

963
00:31:43,446 --> 0:31:44,716
我将其高亮为绿色

964
00:31:45,756 --> 0:31:48,256
这些约束在

965
00:31:48,446 --> 0:31:49,476
每个布局都是一样的

966
00:31:50,466 --> 0:31:53,286
我们在隐藏或显示分享视图时

967
00:31:53,286 --> 0:31:54,196
分享视图不需要发生变化

968
00:31:54,196 --> 0:31:56,356
头像视图不会移动

969
00:31:56,356 --> 0:31:59,006
这些标签也不会发生移动

970
00:31:59,006 --> 0:32:00,806
除了日志输入标签会变得更长

971
00:31:59,006 --> 0:32:00,806
除了日志输入标签会变得更长

972
00:32:01,616 --> 0:32:02,726
因此这些绿色的约束

973
00:32:03,046 --> 0:32:04,866
应该在你创建

974
00:32:04,866 --> 0:32:08,206
视图时添加 然后被保留在原处

975
00:32:08,566 --> 0:32:09,046
不要修改它们

976
00:32:09,276 --> 0:32:10,446
它们要保持不变

977
00:32:12,026 --> 0:32:13,646
现在我们有四个

978
00:32:13,646 --> 0:32:15,586
约束控制着这个图像视图

979
00:32:15,846 --> 0:32:16,926
要如何处理它们呢

980
00:32:17,216 --> 0:32:21,366
我们把它们放入一个数组 然后我们再将

981
00:32:21,366 --> 0:32:22,276
在没有图像时

982
00:32:22,276 --> 0:32:23,746
将出现的约束放入另一个数组

983
00:32:24,126 --> 0:32:25,246
我很有创造性地将它们叫做

984
00:32:25,246 --> 0:32:26,416
imageConstraints 和

985
00:32:26,416 --> 0:32:27,696
noImageConstraints 这样你们就可以

986
00:32:27,696 --> 0:32:28,526
区分它们

987
00:32:29,216 --> 0:32:32,316
当我们即将

988
00:32:32,316 --> 0:32:34,526
需要添加

989
00:32:34,526 --> 0:32:36,366
或删除该图像视图时 让我们看看

990
00:32:36,366 --> 0:32:37,556
现在所处的布局

991
00:32:38,036 --> 0:32:40,546
如果需要的话 停用 noImageConstraints

992
00:32:41,086 --> 0:32:42,776
并且激活那些图像所需的约束

993
00:32:43,786 --> 0:32:45,516
如果我们不需要图像

994
00:32:45,516 --> 0:32:46,716
那么既然全部其他的

995
00:32:46,716 --> 0:32:48,886
约束已经被激活了 我们只需要再激活

996
00:32:49,186 --> 0:32:49,846
我们正在添加的约束即可

997
00:32:50,176 --> 0:32:51,416
现在我把它们都放入数组中

998
00:32:51,416 --> 0:32:53,936
尽管这是一个单一约束 因为这样可以

999
00:32:53,936 --> 0:32:55,226
简化我的代码

1000
00:32:55,756 --> 0:32:56,676
我不需要检查

1001
00:32:56,676 --> 0:32:57,486
我是在处理一个

1002
00:32:57,486 --> 0:32:58,846
数组还是一个单一约束

1003
00:32:59,206 --> 0:33:00,846
这样我一直都是在处理约束的数组

1004
00:32:59,206 --> 0:33:00,846
这样我一直都是在处理约束的数组

1005
00:33:01,856 --> 0:33:02,666
只是长度的不同

1006
00:33:03,526 --> 0:33:06,406
这样做的好处是

1007
00:33:06,406 --> 0:33:08,286
如果你像这样 正确地

1008
00:33:08,286 --> 0:33:09,766
追踪你的约束

1009
00:33:10,186 --> 0:33:11,716
而且你知道你想要

1010
00:33:11,716 --> 0:33:13,276
实时地在用户面前

1011
00:33:13,276 --> 0:33:15,876
添加这个图像视图 你可以停用这些

1012
00:33:15,876 --> 0:33:17,426
noImageConstraints 启用

1013
00:33:17,426 --> 0:33:18,966
ImageConstraints 并调用 

1014
00:33:18,966 --> 0:33:20,326
视觉动画模块中的

1015
00:33:20,326 --> 0:33:22,026
layoutIfNeeded

1016
00:33:22,026 --> 0:33:23,416
它就会很好地出现在你的视图中

1017
00:33:24,126 --> 0:33:25,996
如果你试图通过停用全部的

1018
00:33:25,996 --> 0:33:26,886
约束然后将它们

1019
00:33:26,886 --> 0:33:29,236
再次添加

1020
00:33:29,236 --> 0:33:30,756
委婉点说 情况会很有趣

1021
00:33:31,696 --> 0:33:33,006
好的 现在我们已经

1022
00:33:33,006 --> 0:33:34,296
调试了这个问题 我们正在

1023
00:33:34,296 --> 0:33:35,266
处理约束组

1024
00:33:35,266 --> 0:33:36,536
而非把所有约束堆在一起

1025
00:33:36,536 --> 0:33:38,646
让我们看一下 会是什么样子

1026
00:33:38,706 --> 0:33:39,376
提示一下 这是它

1027
00:33:39,376 --> 0:33:40,566
最开始的样子

1028
00:33:41,706 --> 0:33:44,906
我们向上滑动到顶部

1029
00:33:44,906 --> 0:33:45,216
非常糟糕

1030
00:33:45,216 --> 0:33:46,256
这是在我们调试之后

1031
00:33:46,256 --> 0:33:48,876
看起来的样子

1032
00:33:48,966 --> 0:33:50,136
这就顺滑多了

1033
00:33:50,776 --> 0:33:51,676
谢谢

1034
00:33:52,031 --> 0:33:54,031
[ 掌声 ]

1035
00:33:54,046 --> 0:33:54,986
但是等等 还有惊喜

1036
00:33:55,596 --> 0:33:57,936
我实际上是在 iOS 11 上录制的这个视频

1037
00:33:57,936 --> 0:34:00,586
没有利用

1038
00:33:57,936 --> 0:34:00,586
没有利用

1039
00:34:00,586 --> 0:34:02,826
我们在 iOS 12 上的性能提升

1040
00:34:03,826 --> 0:34:05,376
这只不过是一段

1041
00:34:06,366 --> 0:34:07,396
高效运行的客户端代码

1042
00:34:07,396 --> 0:34:09,626
在 iOS 12 中它看起来也非常棒

1043
00:34:09,626 --> 0:34:13,416
而且好的难以置信

1044
00:34:13,416 --> 0:34:14,016
[ 笑声 ]

1045
00:34:14,516 --> 0:34:17,446
[ 掌声 ] 是的 它非常棒

1046
00:34:20,396 --> 0:34:21,815
那么 我们如何避免

1047
00:34:21,815 --> 0:34:22,106
约束流失呢

1048
00:34:23,176 --> 0:34:25,106
避免移除全部约束

1049
00:34:25,106 --> 0:34:26,206
这样通常会让你

1050
00:34:26,206 --> 0:34:27,406
进入一个尴尬境地 你需要

1051
00:34:27,406 --> 0:34:29,036
把一部分的约束重新添加

1052
00:34:29,036 --> 0:34:30,956
而这会让你

1053
00:34:30,956 --> 0:34:32,596
重新布局

1054
00:34:32,596 --> 0:34:33,626
并不需要的帧

1055
00:34:33,626 --> 0:34:34,795
或是重新传送不需要

1056
00:34:34,795 --> 0:34:35,636
被再次展示的视图

1057
00:34:36,866 --> 0:34:38,286
如果你有一系列的约束

1058
00:34:38,315 --> 0:34:39,626
它们对于全部

1059
00:34:39,626 --> 0:34:40,585
你的 App 中可能的布局都是共用的

1060
00:34:40,585 --> 0:34:42,556
一次性将它们添加 然后不要

1061
00:34:42,556 --> 0:34:43,085
再修改它们

1062
00:34:43,156 --> 0:34:44,295
这对于使用 Interface

1063
00:34:44,295 --> 0:34:45,326
Builder 和你的 App 的

1064
00:34:45,326 --> 0:34:46,916
初始布局有好处

1065
00:34:46,916 --> 0:34:47,786
改变那些需要被改变的

1066
00:34:47,786 --> 0:34:48,826
约束 但不要去改变

1067
00:34:48,826 --> 0:34:49,956
那些不需要改变的

1068
00:34:50,886 --> 0:34:52,755
听起来有点像文字游戏 但是效果很不错

1069
00:34:53,186 --> 0:34:54,606
现在你已经有了简便的办法

1070
00:34:54,606 --> 0:34:56,786
隐藏视图而非

1071
00:34:56,786 --> 0:34:58,436
移除视图 可以解决你的需求

1072
00:34:59,076 --> 0:35:00,096
好的 这就是

1073
00:34:59,076 --> 0:35:00,096
好的 这就是

1074
00:35:00,096 --> 0:35:01,546
Instruments 中的约束流失问题

1075
00:35:01,626 --> 0:35:02,596
Instruments 中还有一个

1076
00:35:02,596 --> 0:35:04,326
底部视图 叫做 UILabel 尺寸计算

1077
00:35:05,236 --> 0:35:07,186
UILabel 尺寸计算追踪的是

1078
00:35:07,186 --> 0:35:08,246
标签计算其尺寸

1079
00:35:08,246 --> 0:35:09,926
所需要的时间

1080
00:35:10,226 --> 0:35:11,566
我们来讨论一下固有

1081
00:35:11,566 --> 0:35:12,236
内容尺寸

1082
00:35:12,566 --> 0:35:15,036
让我走到这边来

1083
00:35:15,886 --> 0:35:17,546
好的 并不是所有的视图

1084
00:35:17,896 --> 0:35:19,096
都需要有固有内容尺寸

1085
00:35:20,716 --> 0:35:21,426
一些视图需要

1086
00:35:21,836 --> 0:35:24,076
具有非视图内容的视图

1087
00:35:24,076 --> 0:35:25,276
会返回一个它们的

1088
00:35:25,276 --> 0:35:26,936
固有内容尺寸的大小

1089
00:35:26,936 --> 0:35:28,086
尺寸是基于该非视图内容的

1090
00:35:28,486 --> 0:35:30,126
举两个例子

1091
00:35:30,126 --> 0:35:32,156
一个是 UIImageView 它利用其

1092
00:35:32,156 --> 0:35:33,826
图像的尺寸来计算其

1093
00:35:33,826 --> 0:35:36,036
固有内容尺寸

1094
00:35:36,036 --> 0:35:38,116
另一个是 UILabel 它测量其文本

1095
00:35:38,576 --> 0:35:39,976
并依据此来返回其

1096
00:35:39,976 --> 0:35:41,056
固有内容尺寸

1097
00:35:41,636 --> 0:35:43,666
固有内容尺寸

1098
00:35:43,666 --> 0:35:45,076
并没有什么神奇之处

1099
00:35:45,486 --> 0:35:47,856
它的用处是通过 UIView 创建约束

1100
00:35:48,486 --> 0:35:49,886
确定约束的尺寸

1101
00:35:49,886 --> 0:35:50,886
仅此而已

1102
00:35:51,596 --> 0:35:52,476
你可以在

1103
00:35:52,476 --> 0:35:54,106
约束中定义全部的尺寸

1104
00:35:54,576 --> 0:35:55,576
并跳过这些内容

1105
00:35:56,436 --> 0:35:57,496
有一些情况下

1106
00:35:57,496 --> 0:35:58,646
它需要被覆写

1107
00:35:58,646 --> 0:36:00,026
这也是它存在的原因

1108
00:35:58,646 --> 0:36:00,026
这也是它存在的原因

1109
00:36:00,026 --> 0:36:01,156
这样的情况

1110
00:36:01,156 --> 0:36:02,586
以及一些其他的例子

1111
00:36:02,586 --> 0:36:03,776
都在 UIView 子集中

1112
00:36:04,346 --> 0:36:05,786
但是大部分情况下它被

1113
00:36:05,786 --> 0:36:07,026
覆写的原因是

1114
00:36:07,026 --> 0:36:07,986
人们认为这样会

1115
00:36:07,986 --> 0:36:10,136
更快或者更准确

1116
00:36:10,136 --> 0:36:10,946
但事实上都不会

1117
00:36:12,076 --> 0:36:14,546
但是 有一种情况下

1118
00:36:14,546 --> 0:36:16,506
覆写它会提高你的性能

1119
00:36:18,206 --> 0:36:19,926
因为文本测量可能消耗较高

1120
00:36:21,186 --> 0:36:24,106
在我们的这个 App 中 UILabel 尺寸计算

1121
00:36:24,106 --> 0:36:25,626
并没有花费很久

1122
00:36:25,716 --> 0:36:27,386
它的时间是很短的

1123
00:36:27,826 --> 0:36:28,986
因此 纠结这个问题

1124
00:36:28,986 --> 0:36:29,766
并不会提升

1125
00:36:29,766 --> 0:36:31,096
太多的性能

1126
00:36:31,666 --> 0:36:32,956
但如果你有一个文本密集型的

1127
00:36:32,956 --> 0:36:34,586
App 而你多次看到

1128
00:36:34,586 --> 0:36:36,106
在 UILabel 中发生

1129
00:36:36,106 --> 0:36:37,886
文本测量 或者你

1130
00:36:37,886 --> 0:36:38,936
在文本视图中有文本测量过程

1131
00:36:39,066 --> 0:36:39,956
或者其他功能中有文本测量

1132
00:36:40,386 --> 0:36:42,136
你或许能够通过这种方式

1133
00:36:42,136 --> 0:36:43,566
借助其他信息 提高性能

1134
00:36:45,116 --> 0:36:46,296
如果你知道

1135
00:36:46,296 --> 0:36:47,886
该文本所需要的尺寸

1136
00:36:47,886 --> 0:36:49,696
而无需完成文本测量

1137
00:36:49,696 --> 0:36:50,746
你可以返回该尺寸

1138
00:36:50,746 --> 0:36:53,916
和固有内容尺寸 或者是

1139
00:36:53,916 --> 0:36:55,286
在准备将

1140
00:36:55,286 --> 0:36:56,726
视图显示在屏幕时

1141
00:36:56,726 --> 0:36:57,546
完全使用约束

1142
00:36:57,546 --> 0:36:58,706
定义该尺寸

1143
00:36:58,776 --> 0:36:59,976
无论其中的文本

1144
00:37:00,046 --> 0:37:00,846
尺寸如何

1145
00:37:00,946 --> 0:37:02,306
举个例子 约束

1146
00:37:02,306 --> 0:37:03,156
总是会让尺寸

1147
00:37:03,156 --> 0:37:04,706
略大于你的文本量

1148
00:37:05,546 --> 0:37:06,586
然后你就可以直接不返回

1149
00:37:06,586 --> 0:37:07,996
任何固有内容尺寸

1150
00:37:07,996 --> 0:37:10,446
中对于宽度和高度的度量

1151
00:37:11,146 --> 0:37:12,206
这样做就是告诉

1152
00:37:12,206 --> 0:37:13,486
上一层级 “嘿我已经知道了

1153
00:37:13,486 --> 0:37:15,846
我的尺寸 不需要再进行文本测量了”

1154
00:37:16,826 --> 0:37:18,226
很明显 这只在

1155
00:37:18,226 --> 0:37:19,096
你不需要自己进行

1156
00:37:19,096 --> 0:37:21,826
测量时才适用 但是它可以

1157
00:37:21,826 --> 0:37:23,646
帮助一些 App 提高性能

1158
00:37:23,646 --> 0:37:24,886
因此我希望你们了解

1159
00:37:24,886 --> 0:37:26,016
这个小技巧

1160
00:37:26,766 --> 0:37:27,766
我们不能只谈

1161
00:37:27,766 --> 0:37:29,116
固有内容尺寸而不谈

1162
00:37:29,116 --> 0:37:30,566
系统布局适应尺寸

1163
00:37:30,566 --> 0:37:33,326
因为人们

1164
00:37:33,326 --> 0:37:35,666
往往混淆这两个概念

1165
00:37:35,666 --> 0:37:37,846
尽管它们几乎是相反的

1166
00:37:37,846 --> 0:37:41,456
很可惜固有内容尺寸是

1167
00:37:41,456 --> 0:37:42,446
你向引擎传输

1168
00:37:42,446 --> 0:37:44,226
需要添加的尺寸信息的方式

1169
00:37:45,206 --> 0:37:46,796
系统布局配合尺寸是

1170
00:37:47,156 --> 0:37:48,206
你将尺寸

1171
00:37:48,206 --> 0:37:49,826
信息从引擎中提取出来的方式

1172
00:37:50,356 --> 0:37:52,486
事实上它们几乎是相反的

1173
00:37:52,486 --> 0:37:54,696
这用于一些混合布局

1174
00:37:54,696 --> 0:37:56,086
出于有一些原因

1175
00:37:56,086 --> 0:37:57,136
导致你需要

1176
00:37:57,136 --> 0:37:58,816
从一个使用 Auto Layout

1177
00:37:58,816 --> 0:38:00,576
管理其子视图的视图中提取帧信息

1178
00:37:58,816 --> 0:38:00,576
管理其子视图的视图中提取帧信息

1179
00:38:01,876 --> 0:38:03,616
不是很常用 但是

1180
00:38:03,616 --> 0:38:05,306
确实可以这么使用

1181
00:38:05,696 --> 0:38:07,346
我想要告诉你们这个方法

1182
00:38:07,346 --> 0:38:09,096
如何运行 因为它可能

1183
00:38:09,096 --> 0:38:10,306
比你们认为的消耗更高一些

1184
00:38:11,736 --> 0:38:13,046
当你调用 systemLayoutSizeFittingSize 时

1185
00:38:13,046 --> 0:38:15,386
会创建一个引擎

1186
00:38:16,086 --> 0:38:17,006
约束被加入这个该引擎

1187
00:38:17,006 --> 0:38:18,886
计算布局

1188
00:38:19,536 --> 0:38:23,546
然后返回顶部视图的帧尺寸

1189
00:38:23,546 --> 0:38:24,666
之后此引擎被废弃

1190
00:38:25,706 --> 0:38:26,646
所以每次你调用

1191
00:38:26,646 --> 0:38:27,916
这个方法都会

1192
00:38:27,916 --> 0:38:28,946
创建然后废弃一个引擎

1193
00:38:29,856 --> 0:38:31,386
尽管对于小规模使用没问题

1194
00:38:31,386 --> 0:38:33,006
如果你多次使用

1195
00:38:33,286 --> 0:38:34,306
你可以看到它会

1196
00:38:34,306 --> 0:38:35,486
随着时间的流逝而堆积

1197
00:38:35,706 --> 0:38:37,336
因此谨慎使用

1198
00:38:37,336 --> 0:38:38,616
systemLayoutSizeFittingSize

1199
00:38:39,636 --> 0:38:41,486
其中的一个做法是

1200
00:38:41,486 --> 0:38:42,956
有时候看到有些人会

1201
00:38:42,996 --> 0:38:44,646
将这一调用从

1202
00:38:44,646 --> 0:38:45,886
自动调整选项或

1203
00:38:45,886 --> 0:38:47,636
表格视图单元格转到内容视图中

1204
00:38:47,896 --> 0:38:49,186
当你这么做时

1205
00:38:49,186 --> 0:38:50,326
你事实上在覆写一些

1206
00:38:50,326 --> 0:38:51,886
我们刚才做出的优化

1207
00:38:51,886 --> 0:38:53,026
让该视图滑动

1208
00:38:53,026 --> 0:38:54,716
更快的设置

1209
00:38:54,716 --> 0:38:55,706
并且还添加了多余的引擎

1210
00:38:56,026 --> 0:38:57,086
因此如果你目前这么做了

1211
00:38:57,086 --> 0:38:58,106
并且你的滑动不顺滑

1212
00:38:58,106 --> 0:38:59,946
你可以试着解决问题

1213
00:39:01,026 --> 0:39:02,266
好了 现在我们到了

1214
00:39:02,266 --> 0:39:03,366
我最喜欢的话题

1215
00:39:03,836 --> 0:39:05,216
不可满足约束

1216
00:39:06,226 --> 0:39:10,146
好的 那么什么是不可满足约束呢

1217
00:39:10,226 --> 0:39:11,116
如果你还未遇到过这个问题

1218
00:39:11,116 --> 0:39:13,216
这个问题发生的情况是

1219
00:39:13,216 --> 0:39:14,856
当你定义

1220
00:39:15,396 --> 0:39:16,806
这个视图的宽度应该是 50

1221
00:39:16,806 --> 0:39:18,936
同时也要是 200 的宽度

1222
00:39:19,836 --> 0:39:21,606
这不可能满足

1223
00:39:21,976 --> 0:39:24,116
事实上 量子手机不存在

1224
00:39:25,276 --> 0:39:26,436
你知道 我不能断言未来有没有

1225
00:39:26,436 --> 0:39:30,696
但是引擎不得不

1226
00:39:30,696 --> 0:39:31,876
计算得出结果

1227
00:39:31,876 --> 0:39:33,906
即不存在可用布局

1228
00:39:33,906 --> 0:39:35,566
于是破坏一个约束以

1229
00:39:35,956 --> 0:39:37,556
为你产生布局

1230
00:39:38,536 --> 0:39:39,626
它破坏约束时

1231
00:39:40,246 --> 0:39:42,026
会发送一个详细的日志

1232
00:39:42,386 --> 0:39:43,496
到你的调试器 也许你已经

1233
00:39:43,496 --> 0:39:46,026
见到过了 并且显示

1234
00:39:46,026 --> 0:39:47,316
不可满足约束

1235
00:39:47,636 --> 0:39:49,876
这是我破坏的约束 这些是其他

1236
00:39:49,876 --> 0:39:51,476
受到影响的约束 因此我

1237
00:39:51,476 --> 0:39:52,186
不得不破坏它

1238
00:39:53,146 --> 0:39:54,836
有时候这样会

1239
00:39:55,366 --> 0:39:56,856
直接影响性能

1240
00:39:56,856 --> 0:39:57,986
同时也可能掩盖其他问题

1241
00:39:57,986 --> 0:39:59,596
因此最好是调试解决此类情况

1242
00:40:00,206 --> 0:40:01,346
Auto Layout 的秘密 第二部分

1243
00:40:01,346 --> 0:40:02,756
提供了一些很好的

1244
00:40:02,756 --> 0:40:04,566
调试纠错信息

1245
00:40:04,566 --> 0:40:05,706
你可以看看

1246
00:40:05,936 --> 0:40:06,786
如果你在处理

1247
00:40:06,786 --> 0:40:08,236
不可满足约束时遇到了问题的话

1248
00:40:09,806 --> 0:40:11,556
好的 你们已经毕业了

1249
00:40:11,556 --> 0:40:12,346
恭喜你们

1250
00:40:12,346 --> 0:40:13,946
你们现在全部是 Auto Layout 专家了

1251
00:40:14,746 --> 0:40:17,856
你知道 我希望你们真正享受学习

1252
00:40:17,856 --> 0:40:19,236
它运作的内在问题

1253
00:40:19,866 --> 0:40:21,736
现在你们能够更好的了解

1254
00:40:21,736 --> 0:40:23,056
如何在更新约束之前思考

1255
00:40:23,256 --> 0:40:24,416
并且理解它们

1256
00:40:24,416 --> 0:40:25,826
所经历的过程 你们已经获得了一些

1257
00:40:25,826 --> 0:40:27,916
最新的关于尺寸

1258
00:40:27,916 --> 0:40:29,846
优先级和不等式的信息

1259
00:40:29,846 --> 0:40:32,056
你们的布局在 iOS 12 中会更快

1260
00:40:32,056 --> 0:40:32,726
这非常棒

1261
00:40:33,416 --> 0:40:34,426
我们明天会在实验室

1262
00:40:34,496 --> 0:40:35,886
如果任何人有问题的话

1263
00:40:35,926 --> 0:40:36,386
可以进行交流

1264
00:40:37,006 --> 0:40:39,696
这些是相关会议信息的链接

1265
00:40:40,286 --> 0:40:40,976
希望你们享受本周接下来的时间

1266
00:40:41,516 --> 0:40:45,500
[ 掌声 ]
