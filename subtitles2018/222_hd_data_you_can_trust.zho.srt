1
00:00:16,817 --> 0:00:22,289
（你可以信任的数据

2
00:00:28,428 --> 0:00:29,263
大家早上好

3
00:00:30,030 --> 0:00:32,598
感谢你们在喝咖啡前

4
00:00:33,267 --> 0:00:35,769
我叫Itai

5
00:00:36,637 --> 0:00:38,005
本次演讲中 我想介绍

6
00:00:38,071 --> 0:00:40,941
数据在你app中的流向

7
00:00:41,441 --> 0:00:43,210
以及你要如何建立在数据中的信任

8
00:00:43,277 --> 0:00:44,945
来更好地保护你的用户

9
00:00:45,946 --> 0:00:46,780
让我们开始吧

10
00:00:48,549 --> 0:00:49,783
app不是生存在真空中的

11
00:00:50,517 --> 0:00:52,452
为了能让你的app

12
00:00:52,686 --> 0:00:54,688
它们要从外部资源中提取数据

13
00:00:54,755 --> 0:00:57,357
像是磁盘 网络 或是用户本身

14
00:00:57,991 --> 0:01:00,027
然后利用这些数据做些有意义的事情

15
00:00:57,991 --> 0:01:00,027
然后利用这些数据做些有意义的事情

16
00:01:00,093 --> 0:01:01,595
再将其呈现给你的用户

17
00:01:02,863 --> 0:01:04,998
为了让该数据是可消耗的

18
00:01:05,065 --> 0:01:07,668
它应该以某种已知格式或结构来呈现

19
00:01:08,769 --> 0:01:10,103
若非这样的格式或结构呢？

20
00:01:11,872 --> 0:01:16,410
这通常意味着数据被损坏了

21
00:01:17,544 --> 0:01:18,579
但有时

22
00:01:18,645 --> 0:01:22,049
这些数据会让你app

23
00:01:22,583 --> 0:01:25,886
且它会导致你的app不能正常工作

24
00:01:28,021 --> 0:01:29,957
这会给在等待你的app

25
00:01:30,023 --> 0:01:32,926
在App Store更新的用户

26
00:01:33,827 --> 0:01:36,597
如果在发布时崩溃就更糟糕了

27
00:01:36,663 --> 0:01:38,298
因为他们甚至连app都用不了

28
00:01:38,699 --> 0:01:40,734
与此同时 在你等待的时候

29
00:01:40,801 --> 0:01:42,603
你会得到一波一星评价

30
00:01:43,170 --> 0:01:44,571
这对谁来说都不是好事

31
00:01:46,406 --> 0:01:48,408
如果你是个框架开发者的话

32
00:01:48,475 --> 0:01:49,810
这类事情就更容易被人记住

33
00:01:50,010 --> 0:01:52,946
因为它可能不仅仅会影响一个app

34
00:01:53,013 --> 0:01:54,181
还可能影响许多app

35
00:01:56,683 --> 0:01:58,585
今天我们要介绍的是关于信任的内容

36
00:01:59,119 --> 0:01:59,953
更具体地说

37
00:02:00,020 --> 0:02:03,123
我们要讨论的是如何通过保证两件事

38
00:02:03,190 --> 0:02:04,291
在数据中建立信任

39
00:02:04,358 --> 0:02:05,692
（令人信任的数据）

40
00:02:05,759 --> 0:02:07,594
首先就是我们要使用的数据

41
00:02:07,661 --> 0:02:09,630
没有被除我们之外的人修改过

42
00:02:10,531 --> 0:02:13,400
第二点就是它要包含我们想要的

43
00:02:13,467 --> 0:02:15,302
格式和结构

44
00:02:17,371 --> 0:02:21,175
要实现这些目的

45
00:02:21,842 --> 0:02:25,245
以及我们在生命周期的每个阶段

46
00:02:26,713 --> 0:02:30,617
然后我们再看下可以应用的

47
00:02:30,684 --> 0:02:32,152
来实现哪种类型级别的验证

48
00:02:33,053 --> 0:02:35,689
然后再对可编码类型进行相同的处理

49
00:02:37,124 --> 0:02:38,025
让我们开始吧

50
00:02:38,091 --> 0:02:40,294
（数据建模）

51
00:02:40,360 --> 0:02:41,628
为了介绍该数据

52
00:02:41,695 --> 0:02:43,497
我们要建立一个关于app中

53
00:02:43,564 --> 0:02:45,966
可获取的数据形式的构思模型

54
00:02:47,935 --> 0:02:49,369
在最基本的层级

55
00:02:49,436 --> 0:02:52,773
数据是以字节流的形式

56
00:02:54,341 --> 0:02:56,376
在这个阶段

57
00:02:56,443 --> 0:02:59,613
是讲不出有关这类数据的更多内容的

58
00:03:01,615 --> 0:03:03,617
要处理该数据

59
00:03:03,684 --> 0:03:06,987
我们需要保证

60
00:03:07,354 --> 0:03:08,188
在这种情况下

61
00:03:08,255 --> 0:03:12,359
每个编码点要对应一个UTF编码点

62
00:03:12,426 --> 0:03:13,660
抱歉 稍等一下

63
00:03:13,727 --> 0:03:15,329
让我把它变得更好读一点

64
00:03:15,395 --> 0:03:16,797
看来这是JSON数据文件

65
00:03:17,798 --> 0:03:20,601
而在我们保证了该数据

66
00:03:20,667 --> 0:03:23,237
是我们想处理的某种格式后

67
00:03:24,972 --> 0:03:27,708
格式化数据本身没有太多意义

68
00:03:27,774 --> 0:03:30,043
我们要对其创建主要值

69
00:03:30,110 --> 0:03:32,079
字符串 数组 以及字典

70
00:03:32,145 --> 0:03:35,249
这样我们就可以在以后的算法中

71
00:03:35,916 --> 0:03:37,518
我们将其称为我们的主要数据

72
00:03:39,653 --> 0:03:41,855
我们有经常要用到的构建块

73
00:03:41,922 --> 0:03:45,392
不仅是作为主要值

74
00:03:46,493 --> 0:03:47,661
在我们这么做之后

75
00:03:47,728 --> 0:03:50,864
我们会用到这个叫做

76
00:03:52,633 --> 0:03:57,838
这些我们app中的数据形式

77
00:03:59,072 --> 0:04:02,309
原始数据是我们所处理的

78
00:03:59,072 --> 0:04:02,309
原始数据是我们所处理的

79
00:04:02,376 --> 0:04:05,179
而我们自己的

80
00:04:05,445 --> 0:04:06,380
我们现在的目标

81
00:04:06,980 --> 0:04:09,983
就是尽可能大范围地获取数据

82
00:04:10,517 --> 0:04:14,221
我们的app可在任何合适点停下来

83
00:04:14,555 --> 0:04:16,490
但我们还想要随时处理

84
00:04:16,557 --> 0:04:17,491
我们自己的模型类型

85
00:04:18,692 --> 0:04:19,692
现在的目标

86
00:04:19,760 --> 0:04:23,230
就不仅仅是获得

87
00:04:23,297 --> 0:04:25,632
而是在过程中建立信任

88
00:04:26,466 --> 0:04:28,969
在每个阶段 数据都会变得更复杂

89
00:04:29,036 --> 0:04:31,605
而且会比我们进行验证

90
00:04:31,905 --> 0:04:32,739
而在这么做之后

91
00:04:32,806 --> 0:04:34,741
会得到比所需信任的数据

92
00:04:36,243 --> 0:04:37,644
对于我们今天的用例而言

93
00:04:37,711 --> 0:04:40,013
我们不会太过介绍格式化数据

94
00:04:40,080 --> 0:04:43,150
它通常就是原始数据

95
00:04:43,217 --> 0:04:44,651
你不会直接用到它

96
00:04:45,686 --> 0:04:47,754
例如 给出了原始数据后

97
00:04:47,821 --> 0:04:50,824
foundations JSON序列化

98
00:04:50,891 --> 0:04:52,793
你不会直接看到格式化数据

99
00:04:52,860 --> 0:04:53,994
也不会用到它

100
00:04:54,928 --> 0:04:58,498
所以今天我们要介绍的是

101
00:05:00,133 --> 0:05:02,069
让我们从原始数据开始讲起

102
00:05:02,836 --> 0:05:04,505
正如我们刚才所说的

103
00:05:04,571 --> 0:05:07,541
原始数据就是进入你app的

104
00:05:08,475 --> 0:05:11,211
在你检查了该数据并赋予其意义之前

105
00:05:11,278 --> 0:05:12,379
你用它干不了什么

106
00:05:12,446 --> 0:05:13,714
（原始数据）

107
00:05:13,780 --> 0:05:16,750
现在我们或许想知道

108
00:05:16,817 --> 0:05:18,986
在我们开始检查这个数据前

109
00:05:19,386 --> 0:05:20,721
这样做是不是安全呢？

110
00:05:22,022 --> 0:05:25,359
我们在用该数据之前

111
00:05:26,293 --> 0:05:29,196
比如 你的app

112
00:05:29,263 --> 0:05:31,231
但是在磁盘中找到了十亿字节的文件

113
00:05:32,199 --> 0:05:34,401
你是不是应该加载这个数据

114
00:05:34,468 --> 0:05:35,469
并且开始读取它呢？

115
00:05:35,969 --> 0:05:37,137
当然不是了

116
00:05:38,605 --> 0:05:41,175
有时候我们或许不能确定

117
00:05:41,241 --> 0:05:42,176
数据的长度

118
00:05:42,242 --> 0:05:43,944
可能它是不被我们拥有的外部数据

119
00:05:44,011 --> 0:05:45,679
我们不知道会有多少数据

120
00:05:46,880 --> 0:05:47,714
但是在某些情况下

121
00:05:47,781 --> 0:05:49,816
我们可以验证校验和

122
00:05:49,883 --> 0:05:51,418
或是加密签名

123
00:05:51,718 --> 0:05:53,654
这样就呈现了数据看起来是什么样子

124
00:05:53,720 --> 0:05:55,189
即使我们不知道内部什么样

125
00:05:56,056 --> 0:05:58,225
校验和就是对所有数据进行哈希处理

126
00:05:58,559 --> 0:06:00,360
如果数据有任何的变化

127
00:05:58,559 --> 0:06:00,360
如果数据有任何的变化

128
00:06:00,427 --> 0:06:03,063
不管是由于潜在的第三方恶意破坏

129
00:06:03,130 --> 0:06:04,731
还是常规的数据损坏

130
00:06:04,798 --> 0:06:07,134
磁盘的坏道

131
00:06:07,734 --> 0:06:11,505
如果数据的任何一个比特变化的话

132
00:06:11,572 --> 0:06:12,573
或签名无效

133
00:06:12,639 --> 0:06:14,875
我们会在读取这些字节之前就知道

134
00:06:14,942 --> 0:06:17,411
数据是不正确的

135
00:06:19,379 --> 0:06:21,615
我们不总有一个检验和

136
00:06:21,682 --> 0:06:24,484
可能这个数据不是我们所有的

137
00:06:24,551 --> 0:06:27,421
所以在这个阶段

138
00:06:27,788 --> 0:06:29,489
我们不能对它进行更多处理了

139
00:06:30,657 --> 0:06:33,493
在我们处理完原始数据后

140
00:06:34,728 --> 0:06:37,431
正如我们之前提到的

141
00:06:37,497 --> 0:06:39,566
将其传过

142
00:06:39,633 --> 0:06:41,568
像是foundations

143
00:06:42,803 --> 0:06:45,372
当我们完成操作时

144
00:06:45,439 --> 0:06:47,774
数字数组

145
00:06:48,141 --> 0:06:50,677
若这个过程成功了

146
00:06:50,744 --> 0:06:52,246
（主要数据）

147
00:06:52,312 --> 0:06:55,282
第一点就是

148
00:06:55,349 --> 0:06:58,185
例如

149
00:06:59,720 --> 0:07:01,822
第二点就是

150
00:06:59,720 --> 0:07:01,822
第二点就是

151
00:07:02,356 --> 0:07:04,157
我们会知道我们得到的运行时间对象

152
00:07:04,224 --> 0:07:06,026
会是有效的

153
00:07:06,560 --> 0:07:09,363
foundations JSON

154
00:07:09,429 --> 0:07:11,665
可用的字符串、数字和数组

155
00:07:12,332 --> 0:07:14,134
它是我们可以信任的独立值

156
00:07:15,869 --> 0:07:17,070
但在这个阶段 我们可能感到奇怪

157
00:07:17,137 --> 0:07:19,173
“好吧…我们应该如何使用这个数据

158
00:07:19,239 --> 0:07:20,741
我们可以信任它的哪些方面

159
00:07:20,807 --> 0:07:22,643
我们还需要进行什么验证呢？”

160
00:07:24,711 --> 0:07:28,549
在我们实际看到这个数据前

161
00:07:28,615 --> 0:07:29,950
我们对它内容没多少了解

162
00:07:30,517 --> 0:07:33,320
事实上 我们只有开始检查它的时候

163
00:07:33,387 --> 0:07:34,755
才能更好地了解数据结构

164
00:07:35,355 --> 0:07:37,558
如果你曾以这种方式

165
00:07:37,624 --> 0:07:39,826
你就会了解它有很多的缺点

166
00:07:40,460 --> 0:07:42,596
你不能提前得到数据是什么样的

167
00:07:42,663 --> 0:07:43,830
因为它是非常概括性的

168
00:07:44,231 --> 0:07:47,034
因此我们想看下该数据包含什么

169
00:07:47,100 --> 0:07:48,235
我们可以如何使用它

170
00:07:49,636 --> 0:07:51,104
让我们举例来说一下

171
00:07:51,872 --> 0:07:54,775
我最近一直在开发一个叫

172
00:07:54,842 --> 0:07:58,078
它可以让我

173
00:07:58,779 --> 0:08:03,350
当他们有人打开我的app时

174
00:07:58,779 --> 0:08:03,350
当他们有人打开我的app时

175
00:08:03,717 --> 0:08:07,754
它会请求一个目前可以卖给

176
00:08:07,821 --> 0:08:08,689
我的朋友和家人的物品列表

177
00:08:08,755 --> 0:08:10,157
（我的app）

178
00:08:10,224 --> 0:08:12,960
当服务器收到这个请求时

179
00:08:13,026 --> 0:08:15,562
这就表明

180
00:08:17,297 --> 0:08:20,701
从我的服务器

181
00:08:21,568 --> 0:08:24,471
它是一个产品列表的数组

182
00:08:24,538 --> 0:08:25,739
你值得去看一下

183
00:08:25,806 --> 0:08:27,274
（API响应示例）

184
00:08:27,341 --> 0:08:30,177
例如 每个列表中有个产品ID

185
00:08:30,244 --> 0:08:33,013
这是个用来标识产品的唯一正整数

186
00:08:33,080 --> 0:08:36,216
在本例中

187
00:08:37,384 --> 0:08:40,320
每个列表还有字符串型的名字和描述

188
00:08:40,386 --> 0:08:41,788
还有另外一些有类型的字段

189
00:08:41,855 --> 0:08:43,056
值得我们看一下

190
00:08:44,124 --> 0:08:45,959
例如 有一个字段是一个布林值

191
00:08:46,026 --> 0:08:48,462
它表明了这个列表项

192
00:08:50,030 --> 0:08:51,398
在其中还有一些内部结构

193
00:08:51,465 --> 0:08:54,234
我们可能会用到

194
00:08:56,069 --> 0:08:58,739
还有一些字符串型的字段

195
00:08:58,805 --> 0:09:01,909
呈现的是我们想看的其他数据形式

196
00:08:58,805 --> 0:09:01,909
呈现的是我们想看的其他数据形式

197
00:09:02,176 --> 0:09:04,178
例如 URL和日期

198
00:09:05,712 --> 0:09:07,080
让我们来使用下这个数据

199
00:09:07,881 --> 0:09:11,852
我的app中 我可从如URL会话

200
00:09:11,919 --> 0:09:13,654
我会验证其长度

201
00:09:13,720 --> 0:09:16,156
我的服务器可能会生成一个校验和

202
00:09:16,223 --> 0:09:17,658
或加密签名来让我进行验证

203
00:09:20,060 --> 0:09:20,894
在我完成之后

204
00:09:20,961 --> 0:09:23,730
我可以将该数据传入JSON序列化

205
00:09:24,631 --> 0:09:28,168
如果该数据的去序列化失败了

206
00:09:28,235 --> 0:09:29,937
以供你接下来检查 捕捉并处理

207
00:09:30,003 --> 0:09:31,772
它可能会给我的用户显示对话框

208
00:09:33,707 --> 0:09:35,108
我们现在的话

209
00:09:35,175 --> 0:09:37,945
我们就像获取原始数据

210
00:09:38,011 --> 0:09:40,347
并将其以抽象范围内变为主要数据

211
00:09:40,747 --> 0:09:42,916
如果出现了任何问题

212
00:09:44,551 --> 0:09:46,053
现在我们需要使用这个数据了

213
00:09:46,119 --> 0:09:47,254
我们能如何使用它呢？

214
00:09:47,754 --> 0:09:51,458
JSON是包含着实际值的变量

215
00:09:52,025 --> 0:09:53,360
所以我可以将其向下转型成

216
00:09:53,427 --> 0:09:55,596
我想要的字典数组

217
00:09:56,763 --> 0:09:58,765
我的app这个部分只关注

218
00:09:58,832 --> 0:10:00,067
与音乐有关的产品列表

219
00:09:58,832 --> 0:10:00,067
与音乐有关的产品列表

220
00:10:00,467 --> 0:10:03,470
这样就会过滤掉

221
00:10:03,537 --> 0:10:06,073
这里我有标签列表这个子结构

222
00:10:06,139 --> 0:10:09,710
我可将其向下转型为一个字符串数组

223
00:10:11,578 --> 0:10:12,513
哎呀

224
00:10:13,847 --> 0:10:17,384
每个这样的强制向下转型

225
00:10:18,218 --> 0:10:21,722
如果因为API或是数据

226
00:10:21,788 --> 0:10:24,558
而导致某个转型失败的话

227
00:10:24,625 --> 0:10:27,528
可能是由于数据损坏或是恶意篡改

228
00:10:28,529 --> 0:10:29,763
这些向下转型就会失败

229
00:10:29,830 --> 0:10:33,166
当它们转型失败的时候就会中止

230
00:10:33,233 --> 0:10:35,502
这会给我的用户带来糟糕的体验

231
00:10:36,703 --> 0:10:38,238
让我们看看这是如何发生的

232
00:10:39,039 --> 0:10:41,508
这里是那个示例API响应

233
00:10:42,409 --> 0:10:44,511
让我们看下这里的标签列表

234
00:10:44,578 --> 0:10:45,546
（类型验证）

235
00:10:45,612 --> 0:10:49,116
比如 这里的第二个标签被修改了

236
00:10:49,516 --> 0:10:51,618
由字符串变成了数字

237
00:10:51,685 --> 0:10:53,253
它是由第三方恶意篡改的

238
00:10:53,320 --> 0:10:55,189
或是由于常规数据损坏

239
00:10:55,255 --> 0:10:56,356
我们不总能分辨出造成的原因

240
00:10:57,858 --> 0:11:02,329
向下转型这个标签列表会失败

241
00:10:57,858 --> 0:11:02,329
向下转型这个标签列表会失败

242
00:11:02,396 --> 0:11:05,299
而且我们在进行转型前

243
00:11:05,933 --> 0:11:06,967
（先验证 再执行）

244
00:11:07,034 --> 0:11:08,869
为了避免该问题

245
00:11:08,936 --> 0:11:12,139
要先验证 再执行

246
00:11:13,173 --> 0:11:15,976
不要妄下断言你知道数据是什么结构

247
00:11:16,043 --> 0:11:17,044
先检查一下

248
00:11:17,411 --> 0:11:18,712
不要盲目假设

249
00:11:19,546 --> 0:11:20,714
看看如何进行检查

250
00:11:21,381 --> 0:11:24,184
这里又是第一个强制向下转型

251
00:11:24,251 --> 0:11:26,820
不要强制向下转型这些值

252
00:11:27,421 --> 0:11:28,922
我在这里会有条件地向下转型

253
00:11:32,659 --> 0:11:34,728
这可以让我验证

254
00:11:35,596 --> 0:11:38,065
该数据是不是包含我真正想要的内容

255
00:11:38,298 --> 0:11:39,833
如果转型失败的话

256
00:11:40,667 --> 0:11:43,270
我就可以对错误进行处理

257
00:11:44,505 --> 0:11:48,175
同样地 接下来向下转型

258
00:11:48,242 --> 0:11:52,279
不要强制向下转型

259
00:11:52,579 --> 0:11:54,681
在本例中 不会抛出错误

260
00:11:54,982 --> 0:11:57,985
而是我会给出一个默认值

261
00:11:58,185 --> 0:12:00,587
在本例中 我会忽略掉所有

262
00:11:58,185 --> 0:12:00,587
在本例中 我会忽略掉所有

263
00:12:00,654 --> 0:12:02,656
无有效标签列表的产品列表项

264
00:12:03,190 --> 0:12:05,792
我可以抛出一个错误

265
00:12:07,828 --> 0:12:10,797
类型验证不是你能在这个阶段所用的

266
00:12:10,864 --> 0:12:12,766
唯一验证形式

267
00:12:13,467 --> 0:12:15,936
例如 如果被替换成空的话

268
00:12:16,003 --> 0:12:17,504
在JSON中是完全有效的

269
00:12:17,571 --> 0:12:19,039
（可空性验证）

270
00:12:19,106 --> 0:12:20,674
我看到过一个类似的崩溃

271
00:12:22,142 --> 0:12:25,712
在Swift中 强静态类型

272
00:12:25,913 --> 0:12:28,382
而且你不能将空向下转型成字符串

273
00:12:28,582 --> 0:12:30,551
所以这个转型是会失败的

274
00:12:32,886 --> 0:12:36,323
即使所有值都有正确的类型和可空性

275
00:12:36,390 --> 0:12:39,026
我们还应该注意其他的验证形式

276
00:12:39,960 --> 0:12:41,895
例如 我说过每个产品列表项

277
00:12:41,962 --> 0:12:43,397
都有一个正整数ID

278
00:12:43,463 --> 0:12:45,465
在我的例子中 它们是顺序的整数

279
00:12:46,033 --> 0:12:48,468
若这些ID中有负数的话有意义吗？

280
00:12:49,203 --> 0:12:50,204
是没有意义的

281
00:12:50,270 --> 0:12:52,840
即使它一直是正数

282
00:12:52,906 --> 0:12:55,409
如果是很大的正整数值有意义吗？

283
00:12:56,577 --> 0:12:57,978
我卖不了那么多东西

284
00:12:58,045 --> 0:12:59,346
所以在本例中是没意义的

285
00:12:59,413 --> 0:13:02,883
这可能是有人想在我的app中

286
00:12:59,413 --> 0:13:02,883
这可能是有人想在我的app中

287
00:13:03,617 --> 0:13:05,352
这是你需要注意的地方

288
00:13:06,987 --> 0:13:09,656
跟范围验证类似的是长度验证

289
00:13:10,123 --> 0:13:13,026
每个产品列表项都有一个描述

290
00:13:13,660 --> 0:13:15,662
那么可以让描述是空的吗？

291
00:13:15,729 --> 0:13:16,797
（长度验证）

292
00:13:16,864 --> 0:13:17,698
在我的例子中

293
00:13:17,764 --> 0:13:20,167
我知道在我上传产品列表项的时候

294
00:13:20,234 --> 0:13:22,402
我总会放一个描述信息的

295
00:13:22,469 --> 0:13:23,670
所以在我的例子中

296
00:13:23,737 --> 0:13:24,705
将其设为空是说不通的

297
00:13:26,073 --> 0:13:28,008
不过即使它不是空的

298
00:13:28,075 --> 0:13:30,811
填满长度和内容有意义吗？

299
00:13:31,278 --> 0:13:32,713
是没有意义的

300
00:13:32,779 --> 0:13:35,282
这里有地方出错了

301
00:13:38,051 --> 0:13:39,553
还有一些验证形式

302
00:13:39,620 --> 0:13:40,888
是我们需要注意的

303
00:13:40,954 --> 0:13:43,891
即使所有的字段都有正确的类型

304
00:13:43,957 --> 0:13:45,926
有如我们预期的范围和长度

305
00:13:46,426 --> 0:13:49,296
它们的值和内容也同样重要

306
00:13:50,297 --> 0:13:53,000
每个产品列表项都有一个URL

307
00:13:53,066 --> 0:13:55,135
让他们看到

308
00:13:56,036 --> 0:13:59,573
我是以字符串形式得到的

309
00:13:59,640 --> 0:14:02,609
如果它是任意字符串的话有意义吗？

310
00:13:59,640 --> 0:14:02,609
如果它是任意字符串的话有意义吗？

311
00:14:02,910 --> 0:14:04,511
在我的例子中是没有意义的

312
00:14:04,578 --> 0:14:06,780
我想确保它表示的是URL

313
00:14:07,648 --> 0:14:10,617
但更重要的是

314
00:14:10,684 --> 0:14:12,719
并不意味着它会指向我的域名

315
00:14:12,986 --> 0:14:14,955
而这是我非常注意的一点

316
00:14:15,556 --> 0:14:17,958
我非常想保证我用户的安全性

317
00:14:18,025 --> 0:14:20,994
我不想发给他们一个网络钓鱼域名

318
00:14:21,061 --> 0:14:24,198
虽然看起来像是我的网址

319
00:14:25,299 --> 0:14:27,601
所以这是我很小心留意的一件事

320
00:14:27,668 --> 0:14:29,469
（值间验证）

321
00:14:29,536 --> 0:14:32,873
最后 即使每个字段本身是有效的

322
00:14:32,940 --> 0:14:35,542
有时候字段间的关系也很重要

323
00:14:37,010 --> 0:14:39,646
例如 每个产品列表项在被创建

324
00:14:39,713 --> 0:14:41,381
以及最近更新时都会产生一个日期

325
00:14:42,216 --> 0:14:43,817
它们本身是有效的

326
00:14:43,884 --> 0:14:46,220
但是如果最近更新的日期

327
00:14:46,286 --> 0:14:48,088
早于它的创建日期

328
00:14:49,122 --> 0:14:50,357
不 在我的例子中

329
00:14:50,424 --> 0:14:52,860
这可能不会在我的app中

330
00:14:53,293 --> 0:14:55,095
但这可能是你需要注意的地方

331
00:14:55,162 --> 0:14:57,464
因为它会在出现问题的时候

332
00:14:57,531 --> 0:14:59,366
或许我不应该信任这个数据

333
00:15:00,868 --> 0:15:02,669
让我们来看看

334
00:15:03,704 --> 0:15:06,640
这里我写了个函数

335
00:15:06,707 --> 0:15:08,542
并且开始验证所有的内容

336
00:15:09,843 --> 0:15:12,980
我会获得一个列表

337
00:15:13,714 --> 0:15:14,948
这里我们已经学过了

338
00:15:15,015 --> 0:15:17,618
不要强制将这个ID

339
00:15:17,684 --> 0:15:19,086
而是要有条件地向下转型

340
00:15:19,520 --> 0:15:22,389
如果这个转型失败

341
00:15:23,624 --> 0:15:24,658
现在我不想就此打住

342
00:15:24,725 --> 0:15:26,159
我想要执行范围验证

343
00:15:26,226 --> 0:15:28,896
以确保这个产品ID也是有效的

344
00:15:28,962 --> 0:15:30,664
这个ID是正数而且不会太大

345
00:15:30,731 --> 0:15:33,066
如果出现问题的话

346
00:15:36,970 --> 0:15:39,640
然后我想要检查下URL

347
00:15:39,706 --> 0:15:43,610
我会将其向下转型为字符串

348
00:15:44,311 --> 0:15:45,579
这里我可以检查这个链接

349
00:15:45,646 --> 0:15:49,082
在我的例子中 我知道

350
00:15:49,149 --> 0:15:52,519
所以如果我发现了一个很长的URL

351
00:15:54,054 --> 0:15:57,057
在我验证了它之后

352
00:15:57,124 --> 0:16:00,327
执行特定域名验证

353
00:15:57,124 --> 0:16:00,327
执行特定域名验证

354
00:16:00,394 --> 0:16:01,762
而不是一个垃圾字符串

355
00:16:01,828 --> 0:16:04,331
同样地 如果出现问题的话

356
00:16:05,766 --> 0:16:09,102
我不想止步于此

357
00:16:09,169 --> 0:16:12,272
我想要确保它会指向我的域名

358
00:16:12,606 --> 0:16:13,807
我会留意这一点

359
00:16:15,409 --> 0:16:16,276
在这里

360
00:16:16,343 --> 0:16:18,912
我可以将相同类型的验证

361
00:16:18,979 --> 0:16:21,215
如果出现问题的话

362
00:16:21,715 --> 0:16:22,783
有了这个函数

363
00:16:22,850 --> 0:16:26,486
我可以将其app到所有

364
00:16:27,487 --> 0:16:30,724
如果出现问题的话

365
00:16:33,894 --> 0:16:36,697
这就是我们要如何来验证主要数据

366
00:16:37,264 --> 0:16:39,399
如我们所见 主要数据是很笼统的

367
00:16:39,466 --> 0:16:40,601
（结构化数据）

368
00:16:40,667 --> 0:16:45,739
字符串可以是字符串

369
00:16:46,507 --> 0:16:48,642
也可以是一个URL

370
00:16:50,577 --> 0:16:54,515
有时候我们希望数据的语义

371
00:16:54,748 --> 0:16:57,818
我们想确保URL的主机名

372
00:16:57,885 --> 0:17:00,020
而使用常规的字符串是做不到的

373
00:16:57,885 --> 0:17:00,020
而使用常规的字符串是做不到的

374
00:17:01,555 --> 0:17:05,325
与之相似的 字典可以表示

375
00:17:05,626 --> 0:17:07,627
或是表示任意的我们根本不了解的

376
00:17:07,694 --> 0:17:08,962
用户数据

377
00:17:10,163 --> 0:17:12,465
不用在各个地方执行相同的验证

378
00:17:12,532 --> 0:17:14,902
来保证所有我们关注的字段是有效的

379
00:17:14,968 --> 0:17:17,204
而是使用我们自己的模型类型

380
00:17:17,271 --> 0:17:19,339
保障总是在那里不是很好吗？

381
00:17:21,108 --> 0:17:22,675
是的 在我们的例子中

382
00:17:22,976 --> 0:17:25,811
我们想在所有可能的地方

383
00:17:25,878 --> 0:17:28,281
我们可以将主要数据

384
00:17:28,715 --> 0:17:30,384
不过我们想处理那个数据形式

385
00:17:31,285 --> 0:17:32,786
让我们来看下要如何实现

386
00:17:35,522 --> 0:17:37,991
在我app的其他地方有个购买类型

387
00:17:38,058 --> 0:17:39,393
就像是这样

388
00:17:40,561 --> 0:17:44,031
当有顾客进行购买时

389
00:17:44,097 --> 0:17:45,465
然后当他们打开app时

390
00:17:45,532 --> 0:17:47,434
即使他们没有连接到网络

391
00:17:47,501 --> 0:17:49,102
也可浏览自己的购买历史纪录

392
00:17:50,103 --> 0:17:52,239
每条购买记录会追踪

393
00:17:52,306 --> 0:17:53,407
它所对应产品列表项

394
00:17:53,473 --> 0:17:56,610
是何时进行的购买

395
00:17:58,378 --> 0:18:02,182
我可以像这样 利用NS编码

396
00:17:58,378 --> 0:18:02,182
我可以像这样 利用NS编码

397
00:18:02,249 --> 0:18:03,350
我会对它进行归档

398
00:18:04,151 --> 0:18:06,320
但正如我们所见

399
00:18:06,386 --> 0:18:09,690
我们在处理原始数据和主要数据时

400
00:18:10,724 --> 0:18:12,159
让我们看看

401
00:18:12,226 --> 0:18:13,794
这里的编码器是如何初始化的

402
00:18:14,328 --> 0:18:15,796
若你曾写过编码器初始化方法

403
00:18:15,863 --> 0:18:17,197
这可能让你看上去很熟悉

404
00:18:17,798 --> 0:18:20,434
我们要先解码这个产品列表项

405
00:18:20,501 --> 0:18:22,703
我们提到了

406
00:18:22,769 --> 0:18:24,438
而不是强制向下转型

407
00:18:25,038 --> 0:18:27,841
如果出现问题的话

408
00:18:27,908 --> 0:18:29,676
我们返回空就好了 对吧？

409
00:18:31,078 --> 0:18:34,147
如果解码成功了

410
00:18:34,214 --> 0:18:35,215
然后接着操作

411
00:18:35,749 --> 0:18:37,351
我会对购买数据做相同的处理

412
00:18:37,417 --> 0:18:39,419
有条件地向下转型为日期

413
00:18:39,486 --> 0:18:41,989
如果出现问题了

414
00:18:42,055 --> 0:18:44,124
我对我类型的每个字段

415
00:18:45,959 --> 0:18:48,629
当我想将其中一个购买记录

416
00:18:48,695 --> 0:18:50,797
我有一个函数可以让我这么做

417
00:18:50,864 --> 0:18:54,434
它会将购买记录归档为二进制数据

418
00:18:55,435 --> 0:18:56,803
随后我将其保存到磁盘上

419
00:18:56,870 --> 0:18:59,206
或是将该数据保存到数据库等处

420
00:19:01,108 --> 0:19:03,877
当我想将数据加载回来时

421
00:19:03,944 --> 0:19:08,015
我可以获得原始数据 然后将其传给

422
00:19:08,081 --> 0:19:09,483
然后得到一个返回的对象

423
00:19:11,418 --> 0:19:15,155
正如我们所说的 在这的每个点

424
00:19:15,355 --> 0:19:17,791
在我们可能信任它之前

425
00:19:17,858 --> 0:19:18,792
我们还得对它进行更多验证

426
00:19:19,459 --> 0:19:21,628
你可能会感到奇怪

427
00:19:21,695 --> 0:19:23,263
还剩下什么可验证的呢？”

428
00:19:23,931 --> 0:19:26,300
这里的向下转型就是一个不错的点

429
00:19:27,968 --> 0:19:31,772
这个向下转型是发生于

430
00:19:32,706 --> 0:19:34,174
这怎么会失败呢？

431
00:19:35,242 --> 0:19:37,578
这表示有些其他的问题出现了

432
00:19:37,644 --> 0:19:38,946
让我们来看一下

433
00:19:39,012 --> 0:19:40,614
（有键归档中的模型表示）

434
00:19:40,681 --> 0:19:42,282
这是个我的归档中的模型对象的

435
00:19:42,349 --> 0:19:45,185
抽象表示

436
00:19:46,286 --> 0:19:48,889
这里有所有我们在编程中关心的字段

437
00:19:49,089 --> 0:19:51,558
每个字段都包含自己的结构 子结构

438
00:19:51,625 --> 0:19:52,993
以及内容等等

439
00:19:53,760 --> 0:19:55,095
但这里有意思的是

440
00:19:55,662 --> 0:20:00,300
这个表示还包含了这个对象的类名

441
00:19:55,662 --> 0:20:00,300
这个表示还包含了这个对象的类名

442
00:20:01,535 --> 0:20:04,538
让我们来看下KeyedUnarchiver

443
00:20:05,339 --> 0:20:07,908
我们正在进行一个解码调用

444
00:20:08,442 --> 0:20:10,611
这会创建一个

445
00:20:10,677 --> 0:20:12,946
并为对象键解码一个对象

446
00:20:13,013 --> 0:20:14,715
（对象解码）

447
00:20:14,781 --> 0:20:16,316
当你在KeyedUnarchiver中

448
00:20:16,383 --> 0:20:19,786
KeyedUnarchiver

449
00:20:20,187 --> 0:20:21,221
并将它调出来

450
00:20:21,655 --> 0:20:24,958
然后在你的app中

451
00:20:26,660 --> 0:20:29,463
然后它会分配该类的一个实例

452
00:20:29,863 --> 0:20:33,367
将其初始化

453
00:20:34,735 --> 0:20:38,205
然后它会唤醒对象

454
00:20:40,908 --> 0:20:43,043
我们的对象用起来很好

455
00:20:43,410 --> 0:20:47,147
不过我们可能会感到奇怪

456
00:20:47,214 --> 0:20:49,917
包含了一个我们不想要的

457
00:20:51,518 --> 0:20:53,620
我们刚执行过的整个过程

458
00:20:53,987 --> 0:20:55,556
会以不同的类型出现

459
00:20:56,456 --> 0:20:58,792
我们分配、初始化

460
00:20:59,126 --> 0:21:01,895
并且唤醒了一个

461
00:20:59,126 --> 0:21:01,895
并且唤醒了一个

462
00:21:02,863 --> 0:21:04,431
这会对app产生何种影响呢？

463
00:21:06,133 --> 0:21:08,869
正如我们之前所见

464
00:21:08,936 --> 0:21:12,272
会防止我们意外地使用

465
00:21:12,739 --> 0:21:15,876
我们只会用

466
00:21:15,943 --> 0:21:18,178
向下转型失败的话

467
00:21:20,781 --> 0:21:24,284
但解码这样一个对象会对app

468
00:21:24,685 --> 0:21:28,655
比方说这个类有个

469
00:21:28,722 --> 0:21:31,792
它可能会分配一个单例

470
00:21:33,460 --> 0:21:35,963
即便我们扔掉了这个对象

471
00:21:36,029 --> 0:21:37,865
这会对app产生一个持续的影响

472
00:21:37,931 --> 0:21:40,267
并且会导致某处出现异常行为

473
00:21:40,334 --> 0:21:43,737
而且归档可以这种方式被恶意构造

474
00:21:43,804 --> 0:21:45,539
从而导致我们app发生这种问题

475
00:21:46,673 --> 0:21:48,976
我们该如何验证这数据

476
00:21:50,277 --> 0:21:52,746
NSSecureCoding协议

477
00:21:52,813 --> 0:21:53,814
（NSSECURECODING）

478
00:21:53,881 --> 0:21:57,317
NSSecureCoding

479
00:21:57,918 --> 0:22:01,421
其目标就是为了防止这类攻击

480
00:21:57,918 --> 0:22:01,421
其目标就是为了防止这类攻击

481
00:22:01,488 --> 0:22:02,890
（NSSECURECODING

482
00:22:02,956 --> 0:22:06,426
通过让你提前传入类型信息

483
00:22:06,994 --> 0:22:10,964
它会防止验证归档内容

484
00:22:11,031 --> 0:22:13,834
以确保它只包含你想要的类型

485
00:22:15,969 --> 0:22:18,138
NSSecureCoding

486
00:22:18,205 --> 0:22:21,141
为键解码对象

487
00:22:21,208 --> 0:22:23,844
它可以让你提前传入类型信息

488
00:22:24,711 --> 0:22:27,681
通过使用该类型信息

489
00:22:27,748 --> 0:22:28,916
（NSSECURECODING中

490
00:22:28,982 --> 0:22:30,584
让我们来看下目前应对键调用

491
00:22:30,651 --> 0:22:32,052
的解码对象

492
00:22:32,119 --> 0:22:33,487
这个最上层解码

493
00:22:34,721 --> 0:22:36,657
如果我们使用变量

494
00:22:36,723 --> 0:22:38,825
让我们提前传入这个类

495
00:22:38,892 --> 0:22:40,794
在本例中 我们想解码购买记录

496
00:22:41,528 --> 0:22:44,932
不用执行整个过程

497
00:22:45,699 --> 0:22:47,935
你可以先进行类检查

498
00:22:49,169 --> 0:22:50,971
让我们看下这个类检查

499
00:22:52,906 --> 0:22:55,542
在解码的每个阶段

500
00:22:55,609 --> 0:22:58,045
NSKeyedUnarchiver

501
00:22:58,111 --> 0:22:59,580
类的列表

502
00:23:01,114 --> 0:23:03,884
当我们进行这么一个调用时

503
00:23:03,951 --> 0:23:06,753
会利用我们使用的对象

504
00:23:07,054 --> 0:23:09,323
并从这个类

505
00:23:10,924 --> 0:23:14,027
当我们接着

506
00:23:14,094 --> 0:23:17,130
允许的类列表

507
00:23:17,431 --> 0:23:18,732
如果它没有出现在列表中

508
00:23:19,499 --> 0:23:21,201
这个解码调用就会被拒绝

509
00:23:22,803 --> 0:23:25,639
如果我们在归档中

510
00:23:25,706 --> 0:23:27,074
出现在允许的类列表中

511
00:23:27,608 --> 0:23:29,376
我们需要执行几个检查

512
00:23:30,577 --> 0:23:32,913
我们需要保证这个类本身

513
00:23:32,980 --> 0:23:34,915
也遵从于

514
00:23:35,883 --> 0:23:38,285
如果它不遵从的话

515
00:23:38,352 --> 0:23:41,054
会在后面安全地

516
00:23:41,488 --> 0:23:43,991
那样的话我们就不能

517
00:23:44,992 --> 0:23:46,760
在我们的例子中

518
00:23:46,827 --> 0:23:48,595
所以它可以安全地解码并追踪

519
00:23:50,030 --> 0:23:51,031
还有其他两种检查

520
00:23:51,098 --> 0:23:54,301
是跟超类、子类关系有关的

521
00:23:55,669 --> 0:23:58,505
如果你有两个类

522
00:23:58,572 --> 0:24:00,207
两个类都遵从NSCoding

523
00:23:58,572 --> 0:24:00,207
两个类都遵从NSCoding

524
00:24:00,507 --> 0:24:03,477
超类采用了

525
00:24:03,977 --> 0:24:06,446
而子类继承了这个一致性

526
00:24:07,848 --> 0:24:10,384
子类没有办法

527
00:24:10,450 --> 0:24:13,187
重写编码器的初始化

528
00:24:13,754 --> 0:24:15,322
所以这里我们有一个出口

529
00:24:17,124 --> 0:24:19,660
支持安全编码的方法

530
00:24:19,726 --> 0:24:22,129
我其实不支持安全编码

531
00:24:22,329 --> 0:24:25,666
并且你可以把这个功能关了说

532
00:24:26,834 --> 0:24:29,403
如果你还是说支持

533
00:24:29,469 --> 0:24:32,206
我们得确保 你或是继承了

534
00:24:32,272 --> 0:24:35,409
来自超类 对于NSSecureCoding

535
00:24:35,709 --> 0:24:37,744
或是你覆盖了这两个方法

536
00:24:38,078 --> 0:24:40,914
表明

537
00:24:40,981 --> 0:24:42,316
这里没有问题

538
00:24:44,151 --> 0:24:46,720
在我们的例子中

539
00:24:46,787 --> 0:24:48,922
所以我们可以从归档中

540
00:24:51,592 --> 0:24:53,560
现在让我们解码一个购买记录

541
00:24:53,627 --> 0:24:55,596
它本身会解码一个列表项

542
00:24:55,662 --> 0:24:57,331
并且它会利用相同类型的调用

543
00:24:57,397 --> 0:24:58,966
来表明它想要一个列表项

544
00:24:59,366 --> 0:25:00,968
（利用NSSECURECODING

545
00:24:59,366 --> 0:25:00,968
（利用NSSECURECODING

546
00:25:01,034 --> 0:25:03,003
当它这么做的时候

547
00:25:03,070 --> 0:25:05,873
会使用这个类

548
00:25:06,340 --> 0:25:08,675
这个新版本的列表的

549
00:25:09,877 --> 0:25:12,679
我们解码一个对象时

550
00:25:12,746 --> 0:25:14,982
在本例中

551
00:25:17,851 --> 0:25:18,785
但是…

552
00:25:18,852 --> 0:25:21,488
如果我们试图解码一个不在列表中的

553
00:25:21,555 --> 0:25:23,390
不想要的类的对象的话

554
00:25:25,726 --> 0:25:28,495
让我们看下

555
00:25:28,929 --> 0:25:30,564
这叫做解码失败

556
00:25:30,631 --> 0:25:32,032
还有几种类型的失败

557
00:25:32,099 --> 0:25:33,300
我们应该留意一下

558
00:25:33,734 --> 0:25:35,235
当开启了安全编码时

559
00:25:35,302 --> 0:25:37,004
我们可以看到像是这样的

560
00:25:37,070 --> 0:25:38,138
违反安全解码

561
00:25:38,205 --> 0:25:40,007
还有其他的失败形式

562
00:25:41,375 --> 0:25:43,677
例如 如果你试图解码对象的话

563
00:25:43,744 --> 0:25:46,413
可能会出现类型的不匹配

564
00:25:46,480 --> 0:25:48,715
有一个像是整数的主要值

565
00:25:49,116 --> 0:25:52,186
或者你试图解码一个

566
00:25:52,252 --> 0:25:53,754
但我们找到一个

567
00:25:53,820 --> 0:25:56,256
不兼容类型的对象或是主要值

568
00:25:57,024 --> 0:25:58,625
这就会导致解码失败

569
00:25:58,692 --> 0:26:00,460
（解码失败）

570
00:25:58,692 --> 0:26:00,460
（解码失败）

571
00:26:00,527 --> 0:26:02,896
这里还有可能出现另一个形式的失败

572
00:26:02,963 --> 0:26:04,097
那就是归档损坏

573
00:26:04,164 --> 0:26:05,899
如果归档本身损坏严重

574
00:26:05,966 --> 0:26:09,369
而且不符合

575
00:26:09,436 --> 0:26:11,171
我们就不能解码任何内容

576
00:26:11,238 --> 0:26:12,806
因此你就会得到相同类型的失败

577
00:26:14,908 --> 0:26:16,743
出现失败时会发生什么

578
00:26:16,810 --> 0:26:20,447
是取决于Unarchiver上的

579
00:26:20,848 --> 0:26:21,949
这里有两个选项

580
00:26:22,850 --> 0:26:24,818
在失败的时候

581
00:26:25,752 --> 0:26:29,156
或是储存出现问题的有关信息

582
00:26:29,923 --> 0:26:32,125
抛出异常是当前的默认选项

583
00:26:34,027 --> 0:26:36,730
如果我们有个来自前面的调用

584
00:26:36,797 --> 0:26:38,165
试图解码一个列表项

585
00:26:38,465 --> 0:26:41,468
我们会在归档中

586
00:26:42,135 --> 0:26:44,505
它会在底层调用

587
00:26:44,571 --> 0:26:45,572
这个方法在Unarchiver中

588
00:26:46,106 --> 0:26:49,343
并会传入一个表明了

589
00:26:50,577 --> 0:26:53,380
在底层 failWithError

590
00:26:54,314 --> 0:26:56,683
如果解码失败政策

591
00:26:56,750 --> 0:26:58,619
它就会抛出异常

592
00:26:59,319 --> 0:27:00,354
如果你在写Swift app

593
00:26:59,319 --> 0:27:00,354
如果你在写Swift app

594
00:27:00,420 --> 0:27:01,855
这是你需要留心的东西

595
00:27:02,422 --> 0:27:05,259
Swift不能捕捉

596
00:27:05,325 --> 0:27:07,628
所以这可能会导致

597
00:27:07,895 --> 0:27:11,532
这会导致出现崩溃

598
00:27:13,367 --> 0:27:16,370
如果解码失败政策

599
00:27:16,436 --> 0:27:19,006
该错误会被分配到

600
00:27:19,506 --> 0:27:21,074
然后会继续执行

601
00:27:21,742 --> 0:27:24,144
在本例中 因为会继续执行

602
00:27:24,211 --> 0:27:26,547
解码调用必须得返回某些内容

603
00:27:26,613 --> 0:27:29,917
所以它会返回空

604
00:27:31,818 --> 0:27:33,987
如我们所提过的

605
00:27:34,054 --> 0:27:37,824
而且我们找到一个

606
00:27:38,225 --> 0:27:39,960
那么就会出现一系列相同的步骤

607
00:27:40,027 --> 0:27:41,929
本例中 就会不返回空

608
00:27:41,995 --> 0:27:43,897
我们就返回零

609
00:27:47,634 --> 0:27:50,204
failWithError是

610
00:27:50,270 --> 0:27:53,707
我鼓励你们使用自己的代码

611
00:27:53,774 --> 0:27:55,142
以及出现了什么问题

612
00:27:55,609 --> 0:27:57,211
这里不会返回空

613
00:27:57,277 --> 0:27:59,913
failWithError

614
00:27:59,980 --> 0:28:01,348
（失败得有意义）

615
00:27:59,980 --> 0:28:01,348
（失败得有意义）

616
00:28:01,415 --> 0:28:03,383
如果你这么做的话

617
00:28:04,451 --> 0:28:07,287
如果解码失败政策

618
00:28:07,688 --> 0:28:10,357
你要记住

619
00:28:10,424 --> 0:28:11,792
后面就不能重设了

620
00:28:12,826 --> 0:28:14,995
这是因为一个解码失败

621
00:28:15,062 --> 0:28:17,331
经常会导致一系列的解码失败

622
00:28:17,698 --> 0:28:19,800
我们不想丢掉

623
00:28:22,369 --> 0:28:25,372
其次你要记住 任何给定的

624
00:28:25,439 --> 0:28:28,008
要么会抛出一个异常

625
00:28:28,742 --> 0:28:30,644
所以这两种选项你都要留意

626
00:28:30,711 --> 0:28:32,246
特别是你在用

627
00:28:32,312 --> 0:28:33,947
你可能会捕捉到异常

628
00:28:34,248 --> 0:28:35,582
有些内容你需要处理一下

629
00:28:37,084 --> 0:28:39,953
最后 要留意下

630
00:28:40,454 --> 0:28:42,956
这两个值在解码失败的时候

631
00:28:43,023 --> 0:28:45,626
如果解码失败政策

632
00:28:46,059 --> 0:28:48,061
或是数据刚刚丢失了的话

633
00:28:48,128 --> 0:28:50,464
或是被编码成空或零

634
00:28:50,998 --> 0:28:53,033
为了消除这些情况间的歧义

635
00:28:53,100 --> 0:28:55,002
你要检查Unarchiver

636
00:28:57,704 --> 0:28:59,339
我们介绍了很多内容

637
00:28:59,907 --> 0:29:01,508
让我们将其提炼成一个清单

638
00:28:59,907 --> 0:29:01,508
让我们将其提炼成一个清单

639
00:29:01,575 --> 0:29:04,278
看看如何在我们自己的类型上

640
00:29:05,412 --> 0:29:08,348
开始时我们会将

641
00:29:08,415 --> 0:29:11,151
转变成允许我们

642
00:29:11,218 --> 0:29:12,619
（采用

643
00:29:12,686 --> 0:29:15,055
随后如果出现了问题

644
00:29:15,122 --> 0:29:17,191
用failWithError

645
00:29:18,659 --> 0:29:21,995
最后 这是个审计

646
00:29:22,062 --> 0:29:24,264
我们还没有对这些点进行过验证

647
00:29:24,798 --> 0:29:26,033
让我们这么做吧

648
00:29:27,267 --> 0:29:30,304
这里有个解码调用来解码列表项

649
00:29:30,504 --> 0:29:33,507
你会发现如果我们

650
00:29:33,574 --> 0:29:35,742
有条件地向下转型

651
00:29:36,910 --> 0:29:38,745
这个方法有个一般覆盖

652
00:29:38,812 --> 0:29:41,148
在静态地给出类型信息时

653
00:29:41,215 --> 0:29:44,084
会让你没法再有条件地向下转型

654
00:29:44,151 --> 0:29:46,119
你可以一直获得该类的对象

655
00:29:47,554 --> 0:29:50,657
不要在失败时返回空

656
00:29:50,724 --> 0:29:52,259
我们想要失败得有意义

657
00:29:52,492 --> 0:29:56,096
我们可以在失败时 创建一个

658
00:29:57,197 --> 0:29:58,031
在本例中

659
00:29:58,098 --> 0:30:00,634
我们可以使用CocoaError

660
00:29:58,098 --> 0:30:00,634
我们可以使用CocoaError

661
00:30:00,701 --> 0:30:03,237
来返回一个包含好的

662
00:30:03,303 --> 0:30:05,339
让我们的用户知道出现了什么问题

663
00:30:06,840 --> 0:30:09,276
如果需要的话 我们可以给自己

664
00:30:09,343 --> 0:30:10,944
后面日志上

665
00:30:11,011 --> 0:30:12,079
但这个是核心

666
00:30:12,145 --> 0:30:14,481
返回空之前 我们想用

667
00:30:17,017 --> 0:30:20,020
随后我们解码了购买日期

668
00:30:20,921 --> 0:30:24,224
这里也是个好机会 让我们添加

669
00:30:24,291 --> 0:30:25,526
之前没有进行的验证

670
00:30:26,627 --> 0:30:30,063
如果我们可以解码日期的话

671
00:30:30,497 --> 0:30:33,100
但我想保证这个日期是有效的

672
00:30:33,433 --> 0:30:35,669
例如 购买是不可能在

673
00:30:35,736 --> 0:30:37,771
我的app在App Store

674
00:30:38,038 --> 0:30:39,173
这些是你可以检查的内容

675
00:30:39,239 --> 0:30:43,343
若这里出现问题 我们想在失败时

676
00:30:44,311 --> 0:30:46,079
在本例中 数据没有丢失

677
00:30:46,146 --> 0:30:48,582
而是数据被损坏了

678
00:30:48,649 --> 0:30:50,217
我们会表明这一点

679
00:30:51,952 --> 0:30:53,220
（NSSECURECODING

680
00:30:53,287 --> 0:30:56,356
现在我们已经

681
00:30:56,790 --> 0:31:00,160
我们就可以声明

682
00:30:56,790 --> 0:31:00,160
我们就可以声明

683
00:31:00,727 --> 0:31:03,897
最后遵从

684
00:31:03,964 --> 0:31:06,433
来表明我们想要运行时间

685
00:31:06,500 --> 0:31:08,502
它真的支持安全编码

686
00:31:10,504 --> 0:31:12,873
然后 恭喜你

687
00:31:12,940 --> 0:31:14,942
我们获得了

688
00:31:15,008 --> 0:31:16,543
实际的徽章是分开卖的

689
00:31:19,446 --> 0:31:22,749
我们觉得 获得你自己的

690
00:31:22,816 --> 0:31:23,951
并使用它们

691
00:31:24,017 --> 0:31:26,620
今年我们添加了新的API

692
00:31:26,687 --> 0:31:29,656
保证了NSSecureCoding

693
00:31:30,157 --> 0:31:31,158
（默认安全的API）

694
00:31:31,225 --> 0:31:33,493
这个新的初始化器和便利方法

695
00:31:33,560 --> 0:31:35,295
会默认开启安全编码

696
00:31:35,562 --> 0:31:37,731
并且将默认解码失败政策设定为

697
00:31:37,798 --> 0:31:39,199
在返回时设定错误

698
00:31:39,266 --> 0:31:41,902
所以除非你自己更改了解码失败政策

699
00:31:41,969 --> 0:31:43,937
你不需要担心Swift中的异常

700
00:31:45,639 --> 0:31:48,609
而旧的初始化器和便利方法

701
00:31:48,675 --> 0:31:50,878
在新的版本中会设为过期了

702
00:31:50,944 --> 0:31:52,446
我们真的想让你使用它们

703
00:31:53,780 --> 0:31:57,251
类似地 我们引入了

704
00:31:57,484 --> 0:32:00,387
让你可以更容易地在归档时

705
00:31:57,484 --> 0:32:00,387
让你可以更容易地在归档时

706
00:32:00,454 --> 0:32:01,788
这是很重要的

707
00:32:02,122 --> 0:32:05,259
因为它可以保证你不会不小心地归档

708
00:32:05,325 --> 0:32:07,427
不遵从

709
00:32:07,494 --> 0:32:09,329
你后面就不能将它解码了

710
00:32:10,531 --> 0:32:13,467
旧的初始化器和便利方法

711
00:32:13,867 --> 0:32:15,402
这就意味着如果你有

712
00:32:15,469 --> 0:32:16,436
像是这样的旧代码

713
00:32:17,037 --> 0:32:19,940
在归档时

714
00:32:20,507 --> 0:32:21,975
并切换到允许你提前传入类型信息的

715
00:32:22,042 --> 0:32:24,611
便利方法

716
00:32:25,579 --> 0:32:28,248
这样你就可以使用

717
00:32:28,682 --> 0:32:29,816
请确保你获得了该徽章

718
00:32:31,084 --> 0:32:33,253
如果你因为你的类型不能遵从

719
00:32:33,320 --> 0:32:34,855
还不能支持安全编码的话

720
00:32:35,255 --> 0:32:38,625
或它们本身是取决于还未遵从的类型

721
00:32:38,692 --> 0:32:40,160
你还是可以在代码中

722
00:32:40,761 --> 0:32:41,595
使用这些方法

723
00:32:41,662 --> 0:32:44,064
只需要关掉安全编码需求就可以了

724
00:32:44,398 --> 0:32:45,232
在解码中

725
00:32:45,299 --> 0:32:47,901
这些便利中的安全编码一直是启用的

726
00:32:48,836 --> 0:32:52,272
你可以使用新的初始化器来创建

727
00:32:52,339 --> 0:32:54,641
并手动关闭安全编码

728
00:32:55,909 --> 0:32:59,079
你可以在需要的时候将解码失败政策

729
00:32:59,146 --> 0:33:01,181
重设回旧的默认值

730
00:32:59,146 --> 0:33:01,181
重设回旧的默认值

731
00:33:02,916 --> 0:33:06,086
在你有了Unarchiver后

732
00:33:08,989 --> 0:33:10,691
如果你在开发Swift app

733
00:33:10,757 --> 0:33:14,228
NSSecureCoding

734
00:33:14,294 --> 0:33:16,496
与外部表示间相互转换的方法了

735
00:33:16,563 --> 0:33:17,631
（可编码）

736
00:33:17,698 --> 0:33:20,167
去年在Swift 4中

737
00:33:20,234 --> 0:33:22,102
可以更容易地实现那些功能

738
00:33:22,936 --> 0:33:25,172
重要的是 所有NSSecureCoding

739
00:33:25,239 --> 0:33:29,910
从一开始就出现在可编码中

740
00:33:31,111 --> 0:33:35,015
可编码从来不会将类型信息

741
00:33:35,082 --> 0:33:36,850
所以后面没有什么可信任的

742
00:33:37,217 --> 0:33:40,420
通过让你提前传入要解码的

743
00:33:40,487 --> 0:33:42,155
静态类型信息

744
00:33:42,356 --> 0:33:44,525
你可以防止这类攻击

745
00:33:46,360 --> 0:33:48,128
可编码也有便利方法

746
00:33:48,195 --> 0:33:51,064
如果你有个类型

747
00:33:51,131 --> 0:33:53,433
你就可以得到 初始化需求

748
00:33:53,500 --> 0:33:55,035
以及编码需求的同步实现

749
00:33:56,003 --> 0:33:57,571
而同步实现

750
00:33:57,638 --> 0:33:59,840
会免费为你进行类型检查

751
00:34:00,207 --> 0:34:03,177
正如我们所见

752
00:34:03,243 --> 0:34:05,746
需要进行额外的验证

753
00:34:06,747 --> 0:34:08,148
我们需要对其进一步验证

754
00:34:09,850 --> 0:34:11,851
我们可以通过从解码器覆写其初始化

755
00:34:11,918 --> 0:34:14,221
来对我们自己的类型进行验证

756
00:34:14,554 --> 0:34:17,591
在本例中

757
00:34:17,658 --> 0:34:19,893
我可以通过创建一个

758
00:34:19,960 --> 0:34:22,362
来将它巧妙地转换成可编码类型

759
00:34:23,697 --> 0:34:25,364
因为所有字段都是可编码的

760
00:34:25,431 --> 0:34:28,335
我就可以得到初始化

761
00:34:28,902 --> 0:34:30,504
但我想要覆写初始化

762
00:34:30,571 --> 0:34:32,172
以确保我所执行的验证

763
00:34:32,239 --> 0:34:34,208
跟我前面对主要值

764
00:34:34,975 --> 0:34:37,244
我能以相同的方法在这里实现它

765
00:34:38,545 --> 0:34:43,650
我从负载解码ID的旧代码

766
00:34:43,984 --> 0:34:47,353
我在这只要从解码器

767
00:34:48,487 --> 0:34:52,492
如果在负载中找到的类型

768
00:34:52,559 --> 0:34:54,895
这就会抛出一个

769
00:34:56,396 --> 0:34:57,664
比这更重要的是

770
00:34:58,198 --> 0:35:01,268
我在这个验证方法中

771
00:34:58,198 --> 0:35:01,268
我在这个验证方法中

772
00:35:02,102 --> 0:35:04,705
这里我想执行相同的验证

773
00:35:04,771 --> 0:35:06,507
以保证ID是有效的

774
00:35:06,573 --> 0:35:09,209
这里我可以用一个便利方法

775
00:35:09,276 --> 0:35:10,777
来表明所出现的问题

776
00:35:13,480 --> 0:35:15,182
然后在该验证函数中

777
00:35:15,249 --> 0:35:18,185
我会以字符串调出创建日期

778
00:35:18,252 --> 0:35:20,687
然后将其传入日期格式化器

779
00:35:21,522 --> 0:35:23,524
来获取一个有效的日期

780
00:35:25,526 --> 0:35:29,763
因为我们使用的是JSON解码器

781
00:35:29,830 --> 0:35:32,099
我们不需要担心类型转换

782
00:35:32,733 --> 0:35:35,536
我们可以用JSON解码器

783
00:35:35,602 --> 0:35:38,071
来表明会进行哪种转换

784
00:35:38,739 --> 0:35:41,875
这样很不错

785
00:35:42,776 --> 0:35:43,610
而且…

786
00:35:43,677 --> 0:35:45,646
其他的解码调用也是一行就能实现

787
00:35:45,712 --> 0:35:47,214
这样我就可以更容易地关注

788
00:35:47,281 --> 0:35:49,183
我所关心的类型验证

789
00:35:51,685 --> 0:35:52,986
在这个验证函数中

790
00:35:53,053 --> 0:35:56,056
我可能已经以字符串数组的形式

791
00:35:56,123 --> 0:35:57,257
调出了标签的子结构

792
00:35:57,758 --> 0:36:00,060
然后将这些字符串映射到了

793
00:35:57,758 --> 0:36:00,060
然后将这些字符串映射到了

794
00:36:00,127 --> 0:36:02,296
以供后面的验证所用

795
00:36:04,064 --> 0:36:05,432
有了可编码

796
00:36:05,499 --> 0:36:08,101
我就可以利用

797
00:36:08,168 --> 0:36:11,138
所以我就可以直接解码一个标签数组

798
00:36:11,672 --> 0:36:13,173
这是自动发生的

799
00:36:13,240 --> 0:36:14,975
这样我就可以不用关注类型转化

800
00:36:15,042 --> 0:36:17,711
而是关注对我来说重要的验证了

801
00:36:18,212 --> 0:36:20,848
这可以让我确保

802
00:36:24,451 --> 0:36:26,253
我们今天介绍了很多内容

803
00:36:27,187 --> 0:36:28,388
我们从原始数据开始介绍

804
00:36:28,455 --> 0:36:31,291
然后围绕着抽象范围介绍到

805
00:36:31,358 --> 0:36:32,292
我们自己的模型类型

806
00:36:33,393 --> 0:36:36,330
接着我们看了下如何通过验证校验和

807
00:36:38,665 --> 0:36:41,568
来建立对于该数据的信任

808
00:36:41,635 --> 0:36:44,304
我们保证了是通过检查

809
00:36:44,638 --> 0:36:47,274
甚至检查了它是否遵从于某些格式

810
00:36:47,341 --> 0:36:49,943
在我们确保它遵从于一个已知格式后

811
00:36:50,611 --> 0:36:53,914
我们就知道了

812
00:36:53,981 --> 0:36:55,682
并且得到了主要值

813
00:36:56,216 --> 0:36:57,117
（总结）

814
00:36:57,184 --> 0:37:01,021
通过验证那些主要值的内容和结构

815
00:36:57,184 --> 0:37:01,021
通过验证那些主要值的内容和结构

816
00:37:01,088 --> 0:37:02,956
我们可以确保这些值是有效的

817
00:37:03,023 --> 0:37:05,192
并将其转换为我们自己的模型类型

818
00:37:06,460 --> 0:37:07,761
通过验证这些模型类型间的语义

819
00:37:07,828 --> 0:37:09,930
和关系

820
00:37:10,130 --> 0:37:12,065
我们保证了这些数据是有效的

821
00:37:12,132 --> 0:37:13,667
并且是可以被信任的数据

822
00:37:15,903 --> 0:37:17,070
然后呢？

823
00:37:17,137 --> 0:37:18,138
（下一步）

824
00:37:18,205 --> 0:37:19,273
你已了解这些内容

825
00:37:19,339 --> 0:37:22,442
我鼓励你们去看看你们的代码

826
00:37:23,410 --> 0:37:25,412
在每个生命周期验证数据

827
00:37:25,779 --> 0:37:27,781
在该数据生命周期的每个阶段

828
00:37:28,048 --> 0:37:29,583
检查类型和可空性

829
00:37:29,650 --> 0:37:33,120
更重要的是 范围和长度

830
00:37:34,855 --> 0:37:37,124
如果你有NSCoding类型

831
00:37:37,191 --> 0:37:38,959
来获得

832
00:37:39,026 --> 0:37:40,194
不要只是获得这个徽章

833
00:37:40,260 --> 0:37:42,262
在任何能用的地方

834
00:37:43,630 --> 0:37:47,301
最后 在所有可以的地方

835
00:37:47,367 --> 0:37:49,703
并且保证执行该验证

836
00:37:50,237 --> 0:37:53,373
保证你只用能信任的数据

837
00:37:54,374 --> 0:37:55,209
（更多信息）

838
00:37:55,275 --> 0:37:57,311
有关可编码的更多内容

839
00:37:57,511 --> 0:37:59,713
请参见去年关于Foundation新特性

840
00:38:00,080 --> 0:38:01,715
若你有更多关于这个主题的问题

841
00:38:01,782 --> 0:38:05,285
或想就如何将其app

842
00:38:05,352 --> 0:38:06,453
请参加今晚的实验室

843
00:38:06,520 --> 0:38:09,022
我们有个Foundation实验室

844
00:38:10,390 --> 0:38:12,392
非常感谢大家来参加我的演讲

845
00:38:13,227 --> 0:38:14,194
祝你们度过愉快的一天
