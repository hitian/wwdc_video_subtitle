1
00:00:17,618 --> 0:00:21,955
（能耗调试新特性）

2
00:00:22,022 --> 0:00:22,856
谢谢

3
00:00:24,825 --> 0:00:25,659
谢谢

4
00:00:26,593 --> 0:00:27,594
大家下午好

5
00:00:27,961 --> 0:00:29,029
我是Phil Azar

6
00:00:29,096 --> 0:00:31,031
我是Apple能耗团队的

7
00:00:31,832 --> 0:00:33,767
今天很荣幸和同事David一起

8
00:00:34,168 --> 0:00:37,237
和你们分享能耗调试新特性

9
00:00:40,574 --> 0:00:42,976
电池待机时间对客户来说非常重要

10
00:00:43,410 --> 0:00:45,279
能耗组竭尽全力

11
00:00:45,345 --> 0:00:48,182
设法让每个人每天

12
00:00:48,248 --> 0:00:49,750
只用为设备充一次电

13
00:00:50,918 --> 0:00:53,220
我们和Apple的开发人员

14
00:00:53,287 --> 0:00:55,989
通力合作指导协助

15
00:00:56,056 --> 0:00:58,825
以优化电池待机时间

16
00:01:00,527 --> 0:01:03,197
app对客户来说也非常重要

17
00:01:03,497 --> 0:01:06,733
事实上 我们发现大多数设备

18
00:01:06,800 --> 0:01:09,269
都直接用于第三方app

19
00:01:09,536 --> 0:01:10,637
这很不可思议

20
00:01:10,704 --> 0:01:13,841
关注app设计的电池效率

21
00:01:14,374 --> 0:01:17,678
变得比以往更加重要

22
00:01:18,812 --> 0:01:21,548
为此 我们今天将谈到三个方面

23
00:01:22,883 --> 0:01:25,586
首先 我们会讲到app中能用到的

24
00:01:25,652 --> 0:01:27,821
电池待机时间的几个概念

25
00:01:28,155 --> 0:01:30,757
以确保app尽可能低能耗

26
00:01:31,925 --> 0:01:35,295
然后会讲到几个可用的工具

27
00:01:35,696 --> 0:01:39,533
以理解和度量app中

28
00:01:40,200 --> 0:01:42,936
最后 交给同事David

29
00:01:43,003 --> 0:01:45,205
他会介绍可用的新工具

30
00:01:45,272 --> 0:01:47,674
让能耗调试更进一步

31
00:01:48,809 --> 0:01:50,444
现在开始

32
00:01:50,511 --> 0:01:52,112
介绍几个通用的概念

33
00:01:53,113 --> 0:01:55,215
为了获得满意的电池待机时间

34
00:01:55,282 --> 0:01:57,117
要从几个首要原则开始

35
00:01:57,184 --> 0:02:00,354
并理解电池待机时间的构成

36
00:01:57,184 --> 0:02:00,354
并理解电池待机时间的构成

37
00:02:01,388 --> 0:02:02,222
现在开始吧

38
00:02:04,091 --> 0:02:04,958
能量是什么？

39
00:02:05,025 --> 0:02:06,093
（能量是什么？）

40
00:02:06,159 --> 0:02:08,228
从根本上 从物理角度

41
00:02:08,595 --> 0:02:10,864
能量是动力和时间的产物

42
00:02:11,732 --> 0:02:14,301
app在平台上运行

43
00:02:14,368 --> 0:02:16,803
以不同的速度消耗能量

44
00:02:17,704 --> 0:02:19,606
因为app进行的任务不同

45
00:02:19,673 --> 0:02:21,241
消耗的能量也不同

46
00:02:21,975 --> 0:02:25,345
此外 app进行的耗能任务越多

47
00:02:25,412 --> 0:02:27,181
要面对的能量消耗也越多

48
00:02:27,881 --> 0:02:29,149
可以画一张图

49
00:02:30,150 --> 0:02:32,419
可以看到app在运行

50
00:02:32,486 --> 0:02:34,955
有不同能量消耗的峰值和低谷

51
00:02:35,856 --> 0:02:38,892
曲线下方是能量消耗

52
00:02:39,760 --> 0:02:41,895
这直接关系到app

53
00:02:41,962 --> 0:02:43,163
不同的运行模式

54
00:02:44,798 --> 0:02:47,568
app激活和空闲时

55
00:02:48,235 --> 0:02:50,103
消耗的能量不同

56
00:02:50,838 --> 0:02:53,173
app激活时

57
00:02:53,240 --> 0:02:54,408
消耗能量的速度最快

58
00:02:55,209 --> 0:02:57,578
因为用户为了所需的功能

59
00:02:57,644 --> 0:02:59,580
才直接使用app

60
00:03:00,314 --> 0:03:02,850
app空闲但保持运行时

61
00:03:02,916 --> 0:03:04,351
能量消耗下降

62
00:03:06,186 --> 0:03:07,955
最后app挂起时

63
00:03:08,021 --> 0:03:10,157
仍有基本的能量消耗

64
00:03:11,091 --> 0:03:12,392
这也很有意思

65
00:03:13,594 --> 0:03:16,597
app执行本来设计的任务时

66
00:03:16,663 --> 0:03:19,399
会请求系统调用

67
00:03:19,466 --> 0:03:21,101
执行任务需要的硬件

68
00:03:21,902 --> 0:03:23,604
调用相关硬件

69
00:03:23,670 --> 0:03:25,706
所需要的能量

70
00:03:26,240 --> 0:03:27,241
称作开销

71
00:03:28,141 --> 0:03:30,544
app无法直接控制开销

72
00:03:30,878 --> 0:03:34,414
但它的任何行为都会有影响

73
00:03:35,883 --> 0:03:38,886
app第一次使用硬件资源时

74
00:03:39,253 --> 0:03:40,687
叫做激活能量

75
00:03:41,088 --> 0:03:43,891
app访问 比如说 无线电

76
00:03:44,224 --> 0:03:46,226
或者访问 比如说 相机

77
00:03:46,527 --> 0:03:48,328
并用到子系统

78
00:03:49,263 --> 0:03:51,999
消耗的能量称作激活能量

79
00:03:53,100 --> 0:03:54,501
所以能看到

80
00:03:54,968 --> 0:03:58,372
电池待机问题是两部分

81
00:03:58,872 --> 0:04:00,340
我们要考虑

82
00:03:58,872 --> 0:04:00,340
我们要考虑

83
00:04:00,407 --> 0:04:02,176
在消耗的激活能量上保持高效

84
00:04:02,543 --> 0:04:05,746
也要考虑向系统

85
00:04:05,812 --> 0:04:08,348
请求不同的硬件资源产生的开销

86
00:04:11,218 --> 0:04:12,386
我讲过硬件

87
00:04:13,020 --> 0:04:15,455
和这些子系统都会消耗能量

88
00:04:15,989 --> 0:04:18,257
系统里到底什么在消耗能量

89
00:04:18,892 --> 0:04:19,927
作为开发者

90
00:04:19,993 --> 0:04:22,529
app开发过程中

91
00:04:22,863 --> 0:04:24,364
将遇到一些不同的硬件子系统

92
00:04:25,499 --> 0:04:28,335
但我们认为有四个子系统

93
00:04:28,402 --> 0:04:30,771
是能量消耗最多的

94
00:04:30,871 --> 0:04:32,606
（什么消耗能量？）

95
00:04:32,673 --> 0:04:33,907
这里列出来了

96
00:04:34,842 --> 0:04:38,345
任务处理、网络、位置和图像

97
00:04:39,813 --> 0:04:41,882
我们看看这些

98
00:04:43,483 --> 0:04:45,185
任务处理是你能想象到的

99
00:04:46,386 --> 0:04:48,388
它是app使用系统资源时

100
00:04:48,455 --> 0:04:50,424
要消耗的资源

101
00:04:50,490 --> 0:04:51,625
系统芯片作为例子

102
00:04:51,692 --> 0:04:54,228
例如内存、CPU等等

103
00:04:55,128 --> 0:04:56,964
是真正干活的部分

104
00:04:57,598 --> 0:04:58,966
这里消耗的能量

105
00:04:59,032 --> 0:05:02,503
大幅取决于app执行的代码

106
00:04:59,032 --> 0:05:02,503
大幅取决于app执行的代码

107
00:05:02,569 --> 0:05:04,771
请求系统执行的任务

108
00:05:06,006 --> 0:05:06,874
总的来说

109
00:05:07,307 --> 0:05:09,776
app执行的代码越多

110
00:05:10,143 --> 0:05:12,713
处理时消耗的能量就越多

111
00:05:12,779 --> 0:05:14,581
（任务处理）

112
00:05:14,648 --> 0:05:17,484
当我们谈到设备消耗的能量时

113
00:05:17,551 --> 0:05:20,153
网络是下一个要考虑的主要子系统

114
00:05:22,356 --> 0:05:24,458
网络消耗的能量是你能想到的

115
00:05:24,892 --> 0:05:27,594
只要app请求执行任何通过

116
00:05:27,661 --> 0:05:29,830
移动网、Wi-Fi

117
00:05:30,297 --> 0:05:32,799
就会以网络的形式消耗能量

118
00:05:34,268 --> 0:05:35,969
这部分能量取决于流量

119
00:05:36,470 --> 0:05:38,605
app请求通过这些技术

120
00:05:38,672 --> 0:05:40,307
发送越多的数据流量

121
00:05:40,374 --> 0:05:41,808
消耗的能量越多

122
00:05:42,543 --> 0:05:43,510
（网络）

123
00:05:43,577 --> 0:05:44,611
粗略而言

124
00:05:44,678 --> 0:05:46,747
app的网络请求越多

125
00:05:47,114 --> 0:05:49,183
网络方面消耗的能量越多

126
00:05:51,018 --> 0:05:53,020
位置服务也类似但有轻微不同

127
00:05:54,321 --> 0:05:55,822
位置子系统中

128
00:05:55,889 --> 0:06:01,395
app请求通过GPS

129
00:05:55,889 --> 0:06:01,395
app请求通过GPS

130
00:06:02,062 --> 0:06:03,864
位置系统就会耗能

131
00:06:05,899 --> 0:06:09,236
位置服务消耗的能量

132
00:06:10,103 --> 0:06:13,373
如果频繁的请求

133
00:06:13,440 --> 0:06:15,108
高精度的定位用户位置

134
00:06:15,542 --> 0:06:17,311
位置服务就会

135
00:06:17,377 --> 0:06:18,412
消耗大量能量

136
00:06:18,478 --> 0:06:20,314
（定位）

137
00:06:20,380 --> 0:06:21,582
归纳一下

138
00:06:21,648 --> 0:06:24,551
app越长时间跟踪位置

139
00:06:24,618 --> 0:06:27,221
位置服务消耗能量越多

140
00:06:30,457 --> 0:06:32,226
最后还有图像

141
00:06:33,994 --> 0:06:35,395
图像子系统中

142
00:06:35,462 --> 0:06:38,966
能想到GPU和CPU

143
00:06:39,032 --> 0:06:41,635
在绘图部分消耗能量

144
00:06:42,769 --> 0:06:44,938
这取决于动画和用户界面

145
00:06:45,839 --> 0:06:48,742
app请求显示动画

146
00:06:48,809 --> 0:06:50,043
或者渲染用户界面时

147
00:06:50,344 --> 0:06:52,613
绘图系统就会消耗能量

148
00:06:54,248 --> 0:06:56,016
这高度取决于复杂度

149
00:06:56,783 --> 0:06:59,219
动画和用户界面越复杂

150
00:06:59,286 --> 0:07:01,922
绘图消耗能量越多

151
00:06:59,286 --> 0:07:01,922
绘图消耗能量越多

152
00:07:01,989 --> 0:07:03,957
（绘图）

153
00:07:04,024 --> 0:07:06,059
最后 总的来说

154
00:07:06,126 --> 0:07:08,462
app显示动画

155
00:07:08,529 --> 0:07:10,030
和用户界面时渲染越多

156
00:07:10,397 --> 0:07:12,833
绘图消耗能量越多

157
00:07:15,802 --> 0:07:17,571
我们讲了四个子系统

158
00:07:18,071 --> 0:07:19,339
结论是什么

159
00:07:19,873 --> 0:07:21,942
有共同线索把它们联系起来

160
00:07:22,009 --> 0:07:22,876
app开发过程中

161
00:07:23,610 --> 0:07:26,480
执行任务越多 消耗能量越多

162
00:07:28,282 --> 0:07:31,952
反过来不一定

163
00:07:32,853 --> 0:07:36,023
因此关键是要优化我们的任务

164
00:07:36,089 --> 0:07:38,091
并尽量使其能耗低

165
00:07:40,460 --> 0:07:41,628
可这并不容易

166
00:07:42,663 --> 0:07:45,065
考虑耗能效率是一个过程

167
00:07:45,933 --> 0:07:47,768
不是简单优化一下

168
00:07:47,835 --> 0:07:51,572
突然app能耗就低起来

169
00:07:51,638 --> 0:07:53,407
app就能延长电池待机时间

170
00:07:54,842 --> 0:07:57,110
要建立这样的思维模式

171
00:07:57,177 --> 0:07:58,779
app有一组要用到的资源

172
00:07:58,846 --> 0:08:00,781
并需要高效的使用这些资源

173
00:07:58,846 --> 0:08:00,781
并需要高效的使用这些资源

174
00:08:02,649 --> 0:08:03,550
如上面所说

175
00:08:03,951 --> 0:08:07,120
我们看看现实世界的例子

176
00:08:07,421 --> 0:08:11,425
考虑低能耗并开始这个过程

177
00:08:12,559 --> 0:08:14,294
举例说app在前台时

178
00:08:15,596 --> 0:08:16,763
app在前台时

179
00:08:17,097 --> 0:08:19,700
它要提供主要的用户体验

180
00:08:19,766 --> 0:08:22,736
对很多人来说

181
00:08:23,504 --> 0:08:24,471
如上所述

182
00:08:25,506 --> 0:08:27,107
前台的能耗效率

183
00:08:27,174 --> 0:08:29,476
在于向用户提供价值

184
00:08:30,177 --> 0:08:33,313
确保在用户体验方面

185
00:08:33,679 --> 0:08:34,914
做什么都有立即响应

186
00:08:34,982 --> 0:08:35,816
（前台）

187
00:08:35,883 --> 0:08:39,119
一个原则是只做必要的工作

188
00:08:40,053 --> 0:08:41,255
听起来很直白

189
00:08:42,089 --> 0:08:45,893
我们看一个例子 为何这如此重要

190
00:08:47,261 --> 0:08:48,962
例如正在构建一个媒体app

191
00:08:49,530 --> 0:08:51,565
媒体app的主要目标

192
00:08:51,632 --> 0:08:54,535
是以固定的频率向用户展示内容

193
00:08:54,601 --> 0:08:55,435
（例子）

194
00:08:55,502 --> 0:08:57,704
一个有效的方案

195
00:08:57,771 --> 0:09:00,107
是以时间为基准

196
00:08:57,771 --> 0:09:00,107
是以时间为基准

197
00:09:00,174 --> 0:09:01,475
刷新显示内容

198
00:09:02,109 --> 0:09:04,811
这将确保用户看到的内容

199
00:09:04,878 --> 0:09:07,814
尽可能最新并没有干扰

200
00:09:09,249 --> 0:09:11,118
这不是个低能耗的方案

201
00:09:12,019 --> 0:09:13,453
我们想想为什么

202
00:09:14,888 --> 0:09:18,625
如果为方案画出耗能时间曲线

203
00:09:19,059 --> 0:09:21,094
能看到每次绘图时

204
00:09:21,395 --> 0:09:23,964
就要消耗一些激活能量

205
00:09:25,199 --> 0:09:28,669
但真正重要的在于有大量的开销

206
00:09:29,503 --> 0:09:33,040
因为每次请求显示新内容时

207
00:09:33,106 --> 0:09:36,944
很可能要调用网络

208
00:09:37,010 --> 0:09:39,947
处理这些任务并显示内容

209
00:09:40,013 --> 0:09:41,748
而用户未必想要这个

210
00:09:42,282 --> 0:09:44,751
我们会在app运行时

211
00:09:44,818 --> 0:09:46,053
持续大量耗能

212
00:09:47,354 --> 0:09:48,188
我们能做得更好

213
00:09:49,656 --> 0:09:51,758
如果考虑用户实际想要的

214
00:09:51,825 --> 0:09:52,759
刷新内容

215
00:09:53,160 --> 0:09:55,996
我们能实现一个贴合需求的方案

216
00:09:57,231 --> 0:09:58,732
新方案里

217
00:09:58,799 --> 0:10:01,902
用户交互或者某类服务器通知

218
00:09:58,799 --> 0:10:01,902
用户交互或者某类服务器通知

219
00:10:02,402 --> 0:10:05,606
会提供新内容并显示给用户

220
00:10:07,574 --> 0:10:08,942
这个方案区别不大

221
00:10:09,009 --> 0:10:10,777
但是个低耗能的方案

222
00:10:11,011 --> 0:10:13,847
在耗能方面有巨大的不同

223
00:10:14,314 --> 0:10:15,482
我们看看为什么

224
00:10:16,483 --> 0:10:18,952
设想app在前台运行

225
00:10:19,019 --> 0:10:20,254
现在发生用户交互

226
00:10:20,587 --> 0:10:23,790
我们会刷新内容并向用户显示

227
00:10:24,358 --> 0:10:27,895
然后app进入空闲

228
00:10:28,729 --> 0:10:31,164
此时用户滚动并阅读刚显示的内容

229
00:10:32,132 --> 0:10:34,468
会注意到这里的开销还是有点高

230
00:10:34,535 --> 0:10:36,336
但已经降低不少

231
00:10:36,970 --> 0:10:40,174
窍门在于让不再需要的子系统

232
00:10:40,240 --> 0:10:42,309
进入睡眠并空闲下来

233
00:10:45,546 --> 0:10:47,147
另一个降低

234
00:10:47,447 --> 0:10:49,683
前台能耗的原则是

235
00:10:50,517 --> 0:10:52,286
将用户界面的复杂度最小化

236
00:10:53,353 --> 0:10:55,322
我提到过绘图能耗

237
00:10:55,722 --> 0:10:58,725
高度取决于复杂度

238
00:10:59,760 --> 0:11:02,296
而我们想让app看起来尽可能好

239
00:10:59,760 --> 0:11:02,296
而我们想让app看起来尽可能好

240
00:11:02,362 --> 0:11:05,265
因此我们花大量时间让用户界面

241
00:11:05,332 --> 0:11:07,401
和动画看起来美观

242
00:11:08,669 --> 0:11:10,737
然而 这可能有意外的副作用

243
00:11:11,705 --> 0:11:13,640
举个例子看看为什么

244
00:11:15,642 --> 0:11:16,710
如果我是一个视频播放器

245
00:11:17,177 --> 0:11:19,179
目标是让用户观看视频

246
00:11:19,913 --> 0:11:20,747
很简单

247
00:11:21,114 --> 0:11:25,252
但我可能试图在视频上

248
00:11:25,319 --> 0:11:29,823
例如 和视频相关的

249
00:11:30,824 --> 0:11:33,193
这让用户在使用app

250
00:11:33,594 --> 0:11:36,096
和观看视频时有更大的控制权

251
00:11:37,898 --> 0:11:40,234
这实际上可能耗能很高

252
00:11:41,134 --> 0:11:42,503
我们想想为什么

253
00:11:43,570 --> 0:11:46,974
大多数设备上

254
00:11:47,040 --> 0:11:49,843
当屏幕上没有用户界面时允许低耗能

255
00:11:49,910 --> 0:11:51,512
播放视频的地方有显示优化

256
00:11:52,513 --> 0:11:54,214
当构建这样的app时

257
00:11:54,281 --> 0:11:56,149
这一点会不那么清晰

258
00:11:56,216 --> 0:11:58,252
然而却造成了很大不同

259
00:11:59,620 --> 0:12:02,523
一个利用优化

260
00:11:59,620 --> 0:12:02,523
一个利用优化

261
00:12:02,589 --> 0:12:05,993
应对我们看到的高耗能的好方案

262
00:12:07,127 --> 0:12:10,497
是自动隐藏用户界面控件

263
00:12:12,065 --> 0:12:14,568
这意味着任何显示在视频上

264
00:12:14,635 --> 0:12:17,337
或者用户界面层的相关内容

265
00:12:17,404 --> 0:12:19,540
在用户不交互时直接隐藏

266
00:12:20,707 --> 0:12:23,177
这在视频播放时的耗能方面

267
00:12:23,243 --> 0:12:24,278
带来很大不同

268
00:12:24,778 --> 0:12:26,747
这个显示优化对

269
00:12:26,813 --> 0:12:30,083
维持低耗能的播放非常关键

270
00:12:33,720 --> 0:12:35,155
我们讲了很多前台任务

271
00:12:35,589 --> 0:12:36,757
那后台任务呢？

272
00:12:37,391 --> 0:12:39,760
很多构建诸如音乐播放器

273
00:12:40,160 --> 0:12:42,763
或者闹钟这类app的人

274
00:12:43,130 --> 0:12:46,800
主要体验来自app后台的高效运行

275
00:12:49,069 --> 0:12:50,270
我们在后台时

276
00:12:50,337 --> 0:12:52,139
有一些要注意的事情

277
00:12:53,240 --> 0:12:56,076
可能app运行时

278
00:12:56,143 --> 0:12:57,845
要同时连接到设备其他系统

279
00:12:58,478 --> 0:13:01,615
例如要使用iMessage

280
00:12:58,478 --> 0:13:01,615
例如要使用iMessage

281
00:13:02,516 --> 0:13:05,686
这样 我们应该关注

282
00:13:06,119 --> 0:13:08,322
以确保后台运行低能耗

283
00:13:08,388 --> 0:13:09,990
（后台）

284
00:13:10,057 --> 0:13:11,825
这是个很宽泛的描述

285
00:13:11,892 --> 0:13:13,360
让我们试着理解一下

286
00:13:14,494 --> 0:13:15,562
在后台运行时

287
00:13:16,029 --> 0:13:18,632
你能够使用系统上其他app

288
00:13:18,699 --> 0:13:20,267
已经使用的子系统

289
00:13:20,834 --> 0:13:22,269
然而 注意

290
00:13:22,336 --> 0:13:25,205
能耗的优先级很重要

291
00:13:25,272 --> 0:13:27,407
倾向于那些前台的app

292
00:13:28,208 --> 0:13:31,345
所以我们要关注最小化工作任务

293
00:13:31,411 --> 0:13:33,347
确保不会中断那些体验

294
00:13:34,515 --> 0:13:38,118
能开始考虑的一个办法

295
00:13:38,919 --> 0:13:40,254
例如 如果要在后台

296
00:13:40,320 --> 0:13:41,722
进行大量维护工作

297
00:13:42,122 --> 0:13:44,491
或者我们要执行大量网络任务

298
00:13:44,858 --> 0:13:48,028
最好是把这些任务

299
00:13:48,095 --> 0:13:49,429
合起来一次完成

300
00:13:50,130 --> 0:13:53,567
那样我们对系统其他任务的

301
00:13:55,202 --> 0:13:57,337
一个遇到的很常见的例子

302
00:13:57,404 --> 0:14:00,541
是上传分析以及与app分析配合

303
00:13:57,404 --> 0:14:00,541
是上传分析以及与app分析配合

304
00:14:00,607 --> 0:14:01,675
（举例）

305
00:14:01,742 --> 0:14:04,144
可能你收集这些分析数据时

306
00:14:04,211 --> 0:14:07,381
会立即发送

307
00:14:07,447 --> 0:14:09,216
它让你构建一个数据集

308
00:14:09,583 --> 0:14:11,685
以应对app的崩溃情况

309
00:14:12,920 --> 0:14:15,122
那样做可能会能耗有点高

310
00:14:15,856 --> 0:14:18,692
如果每次进入后台都发送分析数据

311
00:14:19,159 --> 0:14:21,328
我们可能过度使用网络硬件

312
00:14:22,729 --> 0:14:23,764
我们看看能耗时间曲线

313
00:14:23,830 --> 0:14:25,699
它是这个样子的

314
00:14:26,567 --> 0:14:27,901
每次进入后台

315
00:14:28,235 --> 0:14:31,138
我们驱动网络资源发送分析数据

316
00:14:31,205 --> 0:14:32,806
然后再次空闲下来

317
00:14:34,074 --> 0:14:37,110
图上三点看起来不算太多

318
00:14:37,177 --> 0:14:40,247
但可以想象如果大量使用app

319
00:14:40,314 --> 0:14:41,648
这些会一次次叠加起来

320
00:14:44,051 --> 0:14:46,353
解决问题的正确方法非常简单

321
00:14:47,921 --> 0:14:50,057
就是分批次发送这些数据

322
00:14:50,958 --> 0:14:54,461
我们有大量符合聚合原则的API

323
00:14:54,928 --> 0:14:56,830
其中一个很大的组成部分

324
00:14:57,798 --> 0:15:00,334
通过一个自由属性

325
00:14:57,798 --> 0:15:00,334
通过一个自由属性

326
00:15:00,567 --> 0:15:01,602
和后台回话

327
00:15:01,869 --> 0:15:06,106
使用NSURLSession

328
00:15:08,375 --> 0:15:09,576
这也是解决的正确方法

329
00:15:11,178 --> 0:15:13,280
这样做以后

330
00:15:13,347 --> 0:15:15,182
我们再看看能耗时间曲线的样子

331
00:15:16,850 --> 0:15:20,454
这里能看到app执行

332
00:15:20,521 --> 0:15:23,023
上传分析数据的时间长了一些

333
00:15:23,090 --> 0:15:26,393
能耗却小了很多

334
00:15:26,727 --> 0:15:28,962
都集中在一次消耗

335
00:15:29,596 --> 0:15:32,766
这就是在后台运行时

336
00:15:33,200 --> 0:15:34,168
聚合任务的效果

337
00:15:35,335 --> 0:15:37,838
完成任务的短期能耗很高

338
00:15:37,905 --> 0:15:39,973
但一旦完成后

339
00:15:40,374 --> 0:15:42,276
不再需要担心这些任务

340
00:15:42,342 --> 0:15:44,811
或者中断另一个任务的体验

341
00:15:47,247 --> 0:15:50,184
另一个直观的例子

342
00:15:50,250 --> 0:15:51,585
是快速结束任务

343
00:15:52,686 --> 0:15:54,121
使用系统上允许

344
00:15:54,188 --> 0:15:55,989
你利用后台运行的API

345
00:15:57,224 --> 0:16:00,394
例如用户界面后台任务或者

346
00:15:57,224 --> 0:16:00,394
例如用户界面后台任务或者

347
00:16:01,995 --> 0:16:06,066
这些API有办法让你指明

348
00:16:06,133 --> 0:16:07,935
你不再需要在后台运行

349
00:16:10,704 --> 0:16:13,340
因此作为开发者

350
00:16:13,407 --> 0:16:14,908
如果在使用这些后台模式

351
00:16:15,742 --> 0:16:18,045
你应该调用这些完成处理函数

352
00:16:18,111 --> 0:16:19,279
让系统知道任务完成

353
00:16:20,080 --> 0:16:23,584
事实不总是这样 很多情况下

354
00:16:23,650 --> 0:16:26,954
我们可能忘了或者不想结束任务

355
00:16:27,821 --> 0:16:29,423
所以 让任务自己过期

356
00:16:30,757 --> 0:16:32,459
这对能耗影响很大

357
00:16:32,526 --> 0:16:37,798
也确实不是软件开发过程中

358
00:16:37,865 --> 0:16:39,066
必须看到的

359
00:16:40,133 --> 0:16:42,135
用能耗时间曲线解释一下

360
00:16:42,202 --> 0:16:43,470
为什么这会高能耗

361
00:16:44,705 --> 0:16:47,040
想象因为什么原因进入后台

362
00:16:47,107 --> 0:16:49,676
任务开始 一段时间后任务完成

363
00:16:50,277 --> 0:16:53,213
如果像说过的 让任务自己过期

364
00:16:53,981 --> 0:16:56,450
我们进入消耗能量的这段空闲期

365
00:16:56,517 --> 0:16:58,051
app在后台运行

366
00:16:58,118 --> 0:17:00,754
因为某些原因请求API

367
00:16:58,118 --> 0:17:00,754
因为某些原因请求API

368
00:17:01,288 --> 0:17:02,823
但并没什么发生

369
00:17:03,490 --> 0:17:05,325
然后我们有长期的开销

370
00:17:05,392 --> 0:17:06,926
因为保持系统唤醒

371
00:17:07,227 --> 0:17:09,896
使用资源的子系统

372
00:17:10,230 --> 0:17:13,333
现在等着我们完成

373
00:17:15,368 --> 0:17:16,470
一个快速的解决办法

374
00:17:17,237 --> 0:17:21,308
是可用时随时调用完成处理函数

375
00:17:22,675 --> 0:17:25,612
如前所述 用户界面后台任务

376
00:17:25,913 --> 0:17:27,981
从前台进入后台时

377
00:17:28,348 --> 0:17:29,917
我们调用该API和UIKit

378
00:17:30,717 --> 0:17:32,686
如果不让系统知道我们不再需要

379
00:17:33,086 --> 0:17:35,322
如果让系统知道

380
00:17:35,622 --> 0:17:39,226
我们让硬件系统在需要时进入空闲

381
00:17:39,526 --> 0:17:40,494
从而节省大量能量

382
00:17:41,428 --> 0:17:43,864
这是我们调用完成处理函数的样子

383
00:17:44,932 --> 0:17:45,866
能看见

384
00:17:45,933 --> 0:17:48,368
激活能量的尾部没有了

385
00:17:48,735 --> 0:17:51,438
也大幅降低了开销的尾部

386
00:17:52,973 --> 0:17:56,810
方案简单却极大影响能耗

387
00:18:01,381 --> 0:18:03,317
我们讲了一些方法

388
00:18:03,383 --> 0:18:05,986
开始把低能耗当做一个过程来考虑

389
00:18:06,587 --> 0:18:10,157
如果在所有用例中关注任务优化

390
00:18:10,624 --> 0:18:13,093
我们就能有效

391
00:18:13,160 --> 0:18:14,461
优化app能耗

392
00:18:16,630 --> 0:18:18,765
要继续深入刚才讲过的

393
00:18:18,832 --> 0:18:20,567
或者更深入了解

394
00:18:20,634 --> 0:18:23,003
讨论过的这些优化后的代码

395
00:18:23,470 --> 0:18:25,906
强烈建议查阅去年的视频

396
00:18:26,273 --> 0:18:27,741
怎样编写低能耗app

397
00:18:28,675 --> 0:18:29,576
那场演讲中

398
00:18:29,643 --> 0:18:31,512
能找大量有趣资源

399
00:18:31,578 --> 0:18:35,449
以及app中使用低能耗设计的

400
00:18:35,516 --> 0:18:36,416
更多例子

401
00:18:40,521 --> 0:18:41,722
现在讲过了

402
00:18:42,222 --> 0:18:43,957
app设计中

403
00:18:44,024 --> 0:18:45,292
改善能耗的一些方法

404
00:18:46,827 --> 0:18:49,897
我们花了大量时间讨论

405
00:18:50,464 --> 0:18:52,366
通过考虑app后面的

406
00:18:52,933 --> 0:18:54,835
硬件系统改善app能耗的方法

407
00:18:55,769 --> 0:18:57,538
我们如何量化这些

408
00:18:57,971 --> 0:18:58,839
例如修改后

409
00:18:58,906 --> 0:19:02,042
想了解对app的真实影响

410
00:18:58,906 --> 0:19:02,042
想了解对app的真实影响

411
00:19:03,177 --> 0:19:04,778
现在我们讲讲

412
00:19:04,845 --> 0:19:07,681
做那方面工作能用到的工具

413
00:19:09,983 --> 0:19:11,885
今天有两个能用来

414
00:19:12,186 --> 0:19:14,321
量化耗能影响的工具

415
00:19:15,489 --> 0:19:17,257
第一个是能耗表

416
00:19:17,324 --> 0:19:19,526
Xcode调试器里能直接访问

417
00:19:20,494 --> 0:19:21,995
能耗表是个不错的方法

418
00:19:22,062 --> 0:19:24,464
让你在代码能耗方面快速迭代

419
00:19:24,898 --> 0:19:26,800
帮助你在较高的层面理解

420
00:19:27,601 --> 0:19:30,170
哪些子系统消耗了能量

421
00:19:31,605 --> 0:19:33,240
如果能耗表还不够

422
00:19:33,607 --> 0:19:36,376
你能直接进入开发者工具包的工具

423
00:19:37,344 --> 0:19:38,645
工具会让你深入到

424
00:19:38,712 --> 0:19:41,448
设备的不同子系统

425
00:19:41,515 --> 0:19:45,519
在较低的层面理解

426
00:19:46,019 --> 0:19:46,920
和它们在干什么

427
00:19:48,622 --> 0:19:50,224
我们先看看能耗表

428
00:19:51,892 --> 0:19:54,995
如上所述 这些能在Xcode

429
00:19:55,295 --> 0:19:56,763
所以很方便使用

430
00:19:56,830 --> 0:19:58,298
（能耗表）

431
00:19:58,365 --> 0:19:59,466
我们跳到用户界面

432
00:19:59,967 --> 0:20:02,436
如你所见 选择耗能多的一行

433
00:19:59,967 --> 0:20:02,436
如你所见 选择耗能多的一行

434
00:20:02,503 --> 0:20:04,872
这片用户界面的主要区域

435
00:20:04,938 --> 0:20:06,673
由三部分组成

436
00:20:07,741 --> 0:20:10,377
左上是经典读数表

437
00:20:11,411 --> 0:20:15,382
读数从低到高到非常高

438
00:20:15,449 --> 0:20:17,584
表示app即时的

439
00:20:17,651 --> 0:20:19,620
平均能量消耗

440
00:20:20,821 --> 0:20:23,724
有必要知道读数下降的地方

441
00:20:23,790 --> 0:20:25,692
未必意味着好或者坏

442
00:20:26,126 --> 0:20:27,928
它表示不论app在做什么

443
00:20:28,495 --> 0:20:30,697
都相对消耗了这么多能量

444
00:20:31,698 --> 0:20:34,968
这很重要 取决于你

445
00:20:35,035 --> 0:20:36,036
需要考虑你的用例

446
00:20:36,103 --> 0:20:37,905
并且你是否想要它做

447
00:20:39,606 --> 0:20:40,574
右边

448
00:20:41,008 --> 0:20:42,743
是平均组件利用率

449
00:20:43,577 --> 0:20:45,012
这是个饼图

450
00:20:45,078 --> 0:20:47,581
显示了不同组件

451
00:20:47,848 --> 0:20:50,551
相对整体

452
00:20:51,018 --> 0:20:52,753
消耗的能量百分比

453
00:20:53,854 --> 0:20:54,855
这非常有用

454
00:20:54,922 --> 0:20:56,857
因为它代表了我们之前

455
00:20:56,924 --> 0:20:57,958
提到的不同子系统

456
00:20:58,025 --> 0:21:01,695
如果有过多的开销 它有助于识别

457
00:20:58,025 --> 0:21:01,695
如果有过多的开销 它有助于识别

458
00:21:01,762 --> 0:21:03,931
或者意料外的某个组件

459
00:21:03,997 --> 0:21:04,865
消耗了过多能量

460
00:21:06,834 --> 0:21:08,268
然后在那下面

461
00:21:08,936 --> 0:21:11,104
构成平均组件利用率饼图的

462
00:21:11,772 --> 0:21:12,940
是一个时序图

463
00:21:13,540 --> 0:21:16,610
代表app实际运行时

464
00:21:16,677 --> 0:21:18,278
每个组件平均利用率

465
00:21:18,946 --> 0:21:19,947
这里也能看到

466
00:21:20,280 --> 0:21:22,749
app当前运行状态

467
00:21:23,116 --> 0:21:25,819
前台或者后台 也会列出挂起

468
00:21:27,154 --> 0:21:28,455
这是十分有用的工具

469
00:21:28,522 --> 0:21:31,124
便于理解app的实时行为

470
00:21:33,760 --> 0:21:35,829
如我所说 能耗表用于

471
00:21:36,864 --> 0:21:38,899
高层面的特征识别

472
00:21:39,666 --> 0:21:40,901
和快速分析非常不错

473
00:21:41,502 --> 0:21:42,369
这是关键所在

474
00:21:42,736 --> 0:21:44,004
在代码上迭代时

475
00:21:44,071 --> 0:21:46,073
作为开发者 你试着完成任务

476
00:21:46,139 --> 0:21:47,508
试着将其组合起来

477
00:21:48,075 --> 0:21:51,078
对耗能的设想不能立即清晰起来

478
00:21:51,345 --> 0:21:52,946
但耗能表是个不错的开始

479
00:21:55,482 --> 0:21:56,517
但假如已经那样做过

480
00:21:56,583 --> 0:21:58,218
能耗表对你来说不够

481
00:21:59,786 --> 0:22:00,854
这时候就要用到工具

482
00:21:59,786 --> 0:22:00,854
这时候就要用到工具

483
00:22:01,922 --> 0:22:03,824
直接通过耗能表的用户界面

484
00:22:04,124 --> 0:22:05,926
能访问三个和之前说过的

485
00:22:05,993 --> 0:22:09,329
子系统最相关的工具

486
00:22:10,998 --> 0:22:14,568
这些包括时间分析器、网络分析器

487
00:22:14,868 --> 0:22:16,003
以及位置分析器

488
00:22:17,171 --> 0:22:19,206
如果从能耗表用户界面

489
00:22:19,273 --> 0:22:20,507
点击进入这些工具

490
00:22:20,874 --> 0:22:22,876
就能从当前的调试会话

491
00:22:23,277 --> 0:22:24,478
转换成工具会话

492
00:22:26,246 --> 0:22:28,749
我们看看这些工具之一

493
00:22:28,815 --> 0:22:31,084
时间分析器并试着理解用户界面

494
00:22:31,518 --> 0:22:33,487
（时间分析器）

495
00:22:33,554 --> 0:22:35,722
现在工具都有标准用户界面

496
00:22:36,089 --> 0:22:39,526
但有趣的是它们可用性很高

497
00:22:40,227 --> 0:22:41,161
我们来看看

498
00:22:42,396 --> 0:22:44,464
这里能看见时间分析器用户界面

499
00:22:45,199 --> 0:22:46,867
顶部是一个横条

500
00:22:46,934 --> 0:22:49,503
代表了实际工具

501
00:22:49,570 --> 0:22:50,838
的不同控件

502
00:22:51,405 --> 0:22:53,707
左上是运行暂停按钮

503
00:22:53,774 --> 0:22:56,043
还有要分析的目标

504
00:22:56,810 --> 0:22:58,912
右边是个加号按钮

505
00:22:58,979 --> 0:23:01,882
让你快速拖放其他工具

506
00:22:58,979 --> 0:23:01,882
让你快速拖放其他工具

507
00:23:01,949 --> 0:23:05,018
到这里的分析面板

508
00:23:06,253 --> 0:23:08,322
这个分析面板让你看到

509
00:23:08,388 --> 0:23:11,058
当前正在运行和分析app的工具

510
00:23:11,959 --> 0:23:15,329
因为用的是时间分析器

511
00:23:15,696 --> 0:23:17,965
图形展示不同时间的

512
00:23:18,031 --> 0:23:19,533
CPU利用率

513
00:23:21,635 --> 0:23:23,704
那下面是权重调用图

514
00:23:24,238 --> 0:23:26,607
因为用的是时间分析器

515
00:23:27,007 --> 0:23:28,809
我们要理解app怎样使用CPU

516
00:23:30,143 --> 0:23:31,879
为此 有个权重调用图

517
00:23:31,945 --> 0:23:35,115
让你精确看到app调用情况

518
00:23:35,182 --> 0:23:38,018
以及使用的CPU权重

519
00:23:39,520 --> 0:23:41,989
在那右边是app

520
00:23:42,055 --> 0:23:44,057
最重堆栈调用加总

521
00:23:44,858 --> 0:23:45,826
那基本表明了

522
00:23:46,593 --> 0:23:48,962
分析进行时最重的堆栈调用

523
00:23:50,964 --> 0:23:53,133
还有很多可用的出色工具

524
00:23:54,468 --> 0:23:55,636
这是其中的一些

525
00:23:55,702 --> 0:23:57,971
（工具有利于…）

526
00:23:58,038 --> 0:23:59,973
这意味着十分

527
00:24:00,541 --> 0:24:01,542
有利于一些任务

528
00:24:02,242 --> 0:24:06,113
其一是工具有利于根因分析

529
00:24:06,180 --> 0:24:08,315
例如特定子系统遇到问题

530
00:24:08,382 --> 0:24:09,850
例如 处理或者网络

531
00:24:11,018 --> 0:24:13,120
能用时间分析器

532
00:24:13,587 --> 0:24:15,989
或者网络分析器

533
00:24:16,423 --> 0:24:17,391
快速定位问题

534
00:24:18,458 --> 0:24:19,993
工具也有利于

535
00:24:20,761 --> 0:24:22,763
深入分析app

536
00:24:23,730 --> 0:24:27,734
如果实现了某种CPU效率改进

537
00:24:27,801 --> 0:24:30,537
例如削减算法运行时间

538
00:24:31,538 --> 0:24:34,775
工具是个不错的理解方式

539
00:24:34,842 --> 0:24:36,910
子系统上

540
00:24:36,977 --> 0:24:38,712
计划的优化是否生效

541
00:24:40,514 --> 0:24:41,582
工具还有利于

542
00:24:41,648 --> 0:24:43,150
一个今天还

543
00:24:43,550 --> 0:24:44,685
没讲到的东西

544
00:24:45,686 --> 0:24:47,054
就是不受限分析

545
00:24:48,388 --> 0:24:51,358
有个叫能耗日志的工具

546
00:24:51,892 --> 0:24:54,895
能让你在app运行时

547
00:24:55,329 --> 0:24:57,998
在设备上进行不受限分析

548
00:24:58,632 --> 0:25:00,767
可以在开发者设置里直接访问

549
00:24:58,632 --> 0:25:00,767
可以在开发者设置里直接访问

550
00:25:01,301 --> 0:25:02,769
启动它时

551
00:25:03,070 --> 0:25:04,605
能像往常一样使用电话

552
00:25:04,671 --> 0:25:06,206
如期望那样

553
00:25:06,273 --> 0:25:07,474
按任意数量用例使用app

554
00:25:08,275 --> 0:25:09,576
任务完成之后

555
00:25:09,643 --> 0:25:11,912
直接从开发者工具停止录制

556
00:25:12,346 --> 0:25:14,515
并跳到工具上传跟踪信息

557
00:25:15,282 --> 0:25:16,783
如果遇到

558
00:25:16,850 --> 0:25:18,852
影响能耗的环境问题时

559
00:25:18,919 --> 0:25:20,888
这非常有用

560
00:25:23,056 --> 0:25:25,626
我们讲过了工具 还讲过概念

561
00:25:26,159 --> 0:25:27,728
现在我想演示一下

562
00:25:28,195 --> 0:25:29,830
通过一个例子

563
00:25:29,897 --> 0:25:31,865
讲解怎样把这些串联起来

564
00:25:31,932 --> 0:25:34,902
解决能耗问题 让app低能耗

565
00:25:39,506 --> 0:25:42,609
今天我们准备了一个简单的能耗游戏

566
00:25:42,676 --> 0:25:44,211
其在屏幕上绘制小动画

567
00:25:44,578 --> 0:25:47,314
让app注入一些漏洞

568
00:25:47,915 --> 0:25:49,616
我们构建了一个简单的app

569
00:25:49,683 --> 0:25:51,652
只在视图控制器上有个代理

570
00:25:51,718 --> 0:25:55,455
主要目的是展示如何快速使用工具

571
00:25:55,522 --> 0:25:56,924
以迭代代码

572
00:25:58,625 --> 0:26:00,727
我将在这里通过Xcode的

573
00:25:58,625 --> 0:26:00,727
我将在这里通过Xcode的

574
00:26:00,794 --> 0:26:03,297
构建耗能游戏然后运行它

575
00:26:04,064 --> 0:26:06,200
你将看见在右边

576
00:26:06,667 --> 0:26:08,969
它实际上在随机时间画了一个

577
00:26:09,036 --> 0:26:10,037
电池小动画

578
00:26:10,704 --> 0:26:12,272
这样 非常简单

579
00:26:13,006 --> 0:26:16,009
如果直接跳到Xcode调试器

580
00:26:16,076 --> 0:26:19,279
跳到能耗影响 就能看见能耗表

581
00:26:21,081 --> 0:26:22,783
这是之前说过的用户界面

582
00:26:23,350 --> 0:26:25,886
这是之前讨论过的相同的三个区域

583
00:26:26,420 --> 0:26:28,922
能看到app

584
00:26:29,189 --> 0:26:30,324
完全按照设计在执行

585
00:26:30,824 --> 0:26:33,026
在屏幕上绘制小动画

586
00:26:33,927 --> 0:26:35,562
但注意到我在进行网络传输

587
00:26:35,629 --> 0:26:38,765
我的开销无缘无故有点高

588
00:26:39,466 --> 0:26:42,503
这是因为我们在进行少量网络传输

589
00:26:42,569 --> 0:26:45,739
每当在屏幕上绘制动画时

590
00:26:46,874 --> 0:26:48,375
如此通过Xcode能耗表

591
00:26:48,442 --> 0:26:50,410
能看到那样做的影响

592
00:26:51,879 --> 0:26:54,648
现在我要把这停下来

593
00:26:54,982 --> 0:26:57,885
跳到代码部分理解其中的原因

594
00:26:59,853 --> 0:27:02,656
假如前往添加新动画的视图控制器

595
00:26:59,853 --> 0:27:02,656
假如前往添加新动画的视图控制器

596
00:27:02,956 --> 0:27:05,192
我有一个函数上传动画计数

597
00:27:05,259 --> 0:27:08,896
其创建简单连接对象

598
00:27:08,962 --> 0:27:10,163
上传动画计数

599
00:27:10,597 --> 0:27:12,132
我将注释掉代码

600
00:27:13,433 --> 0:27:14,801
然后前往app代理

601
00:27:14,868 --> 0:27:17,905
将其移动到后台运行时

602
00:27:17,971 --> 0:27:19,006
唯一的上传动画计数

603
00:27:20,407 --> 0:27:21,441
在这个演示里

604
00:27:21,508 --> 0:27:23,277
我将其命名为网络优化

605
00:27:24,077 --> 0:27:25,846
然后重新构建能耗游戏

606
00:27:26,713 --> 0:27:28,916
向你们展示这对能耗表的影响

607
00:27:31,885 --> 0:27:33,687
能耗游戏再次运行

608
00:27:34,321 --> 0:27:36,456
我将回到Xcode调试器用户界面

609
00:27:37,324 --> 0:27:38,692
回到耗能影响

610
00:27:39,693 --> 0:27:42,696
我们再看不到网络耗能

611
00:27:42,763 --> 0:27:44,932
也看不到任何开销 这很不错

612
00:27:45,699 --> 0:27:47,034
这是个简单优化

613
00:27:47,367 --> 0:27:50,304
简单将网络请求从一处移到另一处

614
00:27:50,737 --> 0:27:52,739
阻止其频繁发生

615
00:27:53,473 --> 0:27:56,143
让我们在安静的用例中

616
00:27:56,910 --> 0:27:58,111
大幅降低能耗

617
00:28:00,047 --> 0:28:01,915
现在我要注入一个漏洞

618
00:28:01,982 --> 0:28:03,584
看看使用Xcode能耗表时

619
00:28:04,284 --> 0:28:06,019
怎样发现漏洞

620
00:28:07,254 --> 0:28:09,823
漏洞1是个简单漏洞

621
00:28:10,257 --> 0:28:12,793
其导致CPU在后台运转

622
00:28:13,260 --> 0:28:16,530
这是很多人在实际开发中会遇到的

623
00:28:17,464 --> 0:28:18,999
我将注入这个漏洞

624
00:28:20,968 --> 0:28:23,337
现在已经注入

625
00:28:24,304 --> 0:28:26,273
能在能耗表的用户界面中看见

626
00:28:26,340 --> 0:28:27,541
我们切换到后台

627
00:28:28,542 --> 0:28:29,643
进行少量网络传输

628
00:28:29,710 --> 0:28:31,879
因为将网络调用移到后台

629
00:28:32,613 --> 0:28:35,516
现在也能看见CPU在疯狂运转

630
00:28:36,950 --> 0:28:38,819
这就是能耗表的作用

631
00:28:38,886 --> 0:28:40,754
我们知道其中注入了一个漏洞

632
00:28:40,821 --> 0:28:42,756
但能在能耗表中

633
00:28:44,024 --> 0:28:45,125
现在为了找到根因

634
00:28:45,192 --> 0:28:47,494
我要前往时间分析器

635
00:28:47,561 --> 0:28:49,897
如前所述 转换调试会话

636
00:28:54,034 --> 0:28:57,204
现在转换了调试会话

637
00:28:59,940 --> 0:29:03,677
如你所见

638
00:28:59,940 --> 0:29:03,677
如你所见

639
00:29:07,214 --> 0:29:09,283
这里能看到发布线程

640
00:29:09,349 --> 0:29:10,717
消耗最多的CPU时间

641
00:29:11,051 --> 0:29:12,352
我们深入一点看

642
00:29:15,422 --> 0:29:19,059
我们看到在叫做

643
00:29:20,194 --> 0:29:23,497
我们回到app 试着理解那是什么

644
00:29:29,837 --> 0:29:31,205
演示的目的

645
00:29:32,206 --> 0:29:33,841
耗能游戏进入后台时

646
00:29:33,907 --> 0:29:35,475
我们调用叫做

647
00:29:36,877 --> 0:29:39,913
Computation

648
00:29:41,415 --> 0:29:45,853
当注入漏洞1时 其基本在

649
00:29:46,286 --> 0:29:47,654
疯狂运转

650
00:29:48,021 --> 0:29:50,090
演示目的很简单

651
00:29:50,157 --> 0:29:53,060
但是用能耗表和时间分析器

652
00:29:53,126 --> 0:29:55,629
能直接定位问题发生的位置

653
00:29:56,530 --> 0:29:59,199
能看到

654
00:30:00,400 --> 0:30:02,035
我要把这个注释掉

655
00:30:04,004 --> 0:30:06,139
我喜欢注释而不是删除

656
00:30:07,608 --> 0:30:09,476
然后重新构建耗能游戏

657
00:30:13,514 --> 0:30:16,283
回到能耗表看到一切正常

658
00:30:16,650 --> 0:30:18,619
我们再次注入漏洞1

659
00:30:22,789 --> 0:30:23,690
然后进入后台

660
00:30:29,796 --> 0:30:32,633
我们看到预期的网络活动

661
00:30:33,600 --> 0:30:34,801
不错 问题解决

662
00:30:35,435 --> 0:30:38,839
两个工具30秒到一分钟解决

663
00:30:39,606 --> 0:30:41,275
这就是工具的效力

664
00:30:41,341 --> 0:30:43,744
让你快速迭代发现

665
00:30:43,810 --> 0:30:45,746
日常开发遇到的问题根源

666
00:30:47,214 --> 0:30:48,515
我们回到幻灯片

667
00:30:51,785 --> 0:30:53,820
（耗能演示调试）

668
00:30:55,022 --> 0:30:56,557
这个演示的能获得一些结论

669
00:30:58,392 --> 0:31:00,060
第一个结论是耗能表

670
00:30:58,392 --> 0:31:00,060
第一个结论是耗能表

671
00:31:00,127 --> 0:31:01,962
有利于快速迭代

672
00:31:02,996 --> 0:31:05,866
他们让你快速定位问题

673
00:31:06,633 --> 0:31:08,068
让你进一步

674
00:31:08,135 --> 0:31:09,203
找出解决问题的方法

675
00:31:10,637 --> 0:31:11,638
（app已发布 然后呢？）

676
00:31:11,705 --> 0:31:13,140
第二个结论是

677
00:31:13,907 --> 0:31:16,476
工具有利于深入分析

678
00:31:18,145 --> 0:31:20,380
最后第三个结论是

679
00:31:20,447 --> 0:31:22,482
我们要你把能耗

680
00:31:22,950 --> 0:31:25,319
当做app开发的主要目标

681
00:31:25,953 --> 0:31:28,789
我们有强力的工具让你快速

682
00:31:29,122 --> 0:31:31,391
定位消耗能量的地方并发现

683
00:31:31,658 --> 0:31:32,793
能耗相关问题的根源

684
00:31:34,294 --> 0:31:35,696
如果你都做到了

685
00:31:35,762 --> 0:31:36,964
app也发布了

686
00:31:37,764 --> 0:31:39,566
其在App Store里发布

687
00:31:39,633 --> 0:31:42,302
所有用户都感激你

688
00:31:42,369 --> 0:31:43,303
及时发布了app

689
00:31:43,370 --> 0:31:44,238
然后呢？

690
00:31:44,972 --> 0:31:48,175
假如仍有用户抱怨

691
00:31:48,842 --> 0:31:50,277
你有怎样的资源

692
00:31:51,311 --> 0:31:54,248
现在要交给同事David

693
00:31:54,615 --> 0:31:55,816
他将向你们介绍

694
00:31:55,883 --> 0:31:57,551
如何面对这些挑战

695
00:31:57,618 --> 0:31:59,419
并使用新工具解决它们

696
00:31:59,486 --> 0:32:00,354
David

697
00:31:59,486 --> 0:32:00,354
David

698
00:32:05,359 --> 0:32:06,260
下午好

699
00:32:06,894 --> 0:32:09,196
我是David 我今天来介绍

700
00:32:09,263 --> 0:32:12,900
能耗调试的一些新工具

701
00:32:15,903 --> 0:32:17,171
如果你是iOS开发者

702
00:32:17,838 --> 0:32:20,307
在App Store或

703
00:32:20,541 --> 0:32:22,376
这部分介绍就是为你准备的

704
00:32:23,744 --> 0:32:25,312
我将从下面的问题开始

705
00:32:26,413 --> 0:32:27,514
既然app已经发布

706
00:32:28,115 --> 0:32:30,217
如何知道app在外表现如何？

707
00:32:30,284 --> 0:32:31,285
既然app已经发布

708
00:32:31,351 --> 0:32:33,687
换句话说 如何知道

709
00:32:34,087 --> 0:32:36,657
用户是否遭受

710
00:32:37,024 --> 0:32:38,792
缩短电池待机时间的耗能问题

711
00:32:40,394 --> 0:32:43,163
用户可能在

712
00:32:44,665 --> 0:32:47,134
使用app是电池电量消耗很多

713
00:32:48,335 --> 0:32:50,804
但他们没法告诉你发生了什么

714
00:32:51,705 --> 0:32:53,974
更糟的是 他们直接删除app

715
00:32:54,041 --> 0:32:55,709
没留下任何反馈

716
00:32:56,743 --> 0:32:58,779
所以弄清楚app

717
00:32:59,146 --> 0:33:01,181
是否有能耗问题是个挑战

718
00:32:59,146 --> 0:33:01,181
是否有能耗问题是个挑战

719
00:33:02,583 --> 0:33:04,718
即使知道有能耗问题

720
00:33:05,552 --> 0:33:08,989
如何在客户设备上调试问题

721
00:33:11,058 --> 0:33:12,526
你能使用Phil介绍过的

722
00:33:12,926 --> 0:33:15,395
工具和能耗表

723
00:33:16,196 --> 0:33:18,065
但除非知道要测试什么

724
00:33:18,465 --> 0:33:20,234
否则将很难复现

725
00:33:21,502 --> 0:33:23,203
可能有环境因素

726
00:33:23,770 --> 0:33:25,472
例如客户遭遇到

727
00:33:25,772 --> 0:33:27,107
糟糕的Wi-Fi环境

728
00:33:28,442 --> 0:33:30,511
而你的办公桌Wi-Fi环境良好

729
00:33:32,946 --> 0:33:34,848
因此这是富有挑战的问题

730
00:33:37,718 --> 0:33:39,286
为了帮助回答这些问题

731
00:33:39,353 --> 0:33:41,288
我今天有幸介绍

732
00:33:41,922 --> 0:33:44,191
使用Xcode能耗日志和

733
00:33:46,126 --> 0:33:49,530
调试耗能问题的新方法

734
00:33:49,596 --> 0:33:50,597
（调试耗能问题的新方法）

735
00:33:50,664 --> 0:33:52,799
首先我将介绍Xcode能耗日志

736
00:33:53,066 --> 0:33:56,703
其是报告设备能耗问题的新方法

737
00:33:57,704 --> 0:34:00,107
然后我将介绍Xcode

738
00:33:57,704 --> 0:34:00,107
然后我将介绍Xcode

739
00:34:00,174 --> 0:34:02,543
其是查看能耗日志的新工具

740
00:34:04,344 --> 0:34:06,847
第一次用这些工具

741
00:34:06,914 --> 0:34:08,614
你将获得找到

742
00:34:10,050 --> 0:34:12,753
并解决能耗问题的数据

743
00:34:13,487 --> 0:34:14,388
我们开始

744
00:34:16,023 --> 0:34:18,091
Xcode能耗日志是

745
00:34:18,158 --> 0:34:19,793
从设备报告问题的新方法

746
00:34:19,860 --> 0:34:22,029
（Xcode能耗日志）

747
00:34:22,094 --> 0:34:24,264
我们从CPU高能耗事件开始

748
00:34:24,331 --> 0:34:26,967
此时app占用大量CPU

749
00:34:27,967 --> 0:34:30,871
每个能耗日志有权重调用图

750
00:34:31,170 --> 0:34:33,806
其将指出代码中集中耗能点

751
00:34:34,975 --> 0:34:36,710
这些日志将在

752
00:34:36,777 --> 0:34:38,846
TestFlight

753
00:34:39,112 --> 0:34:40,647
你将获取真实世界

754
00:34:40,714 --> 0:34:43,250
用户的实际数据

755
00:34:43,984 --> 0:34:45,052
用这些日志

756
00:34:45,118 --> 0:34:47,688
你能够开始改进电池待机时间

757
00:34:50,123 --> 0:34:53,427
让我们讲讲Xcode

758
00:34:54,661 --> 0:34:56,463
例如用户正在使用app

759
00:34:56,897 --> 0:34:59,533
其给CPU带来沉重负荷

760
00:34:59,600 --> 0:35:00,801
（Xcode能耗日志何时产生？）

761
00:34:59,600 --> 0:35:00,801
（Xcode能耗日志何时产生？）

762
00:35:00,868 --> 0:35:03,370
这可能很自然

763
00:35:04,671 --> 0:35:07,007
假设其长期给CPU

764
00:35:07,508 --> 0:35:08,475
带来沉重负荷

765
00:35:12,179 --> 0:35:15,148
导致检测到CPU高能耗事件

766
00:35:17,251 --> 0:35:18,919
现在CPU高能耗事件

767
00:35:19,419 --> 0:35:20,587
有检测到

768
00:35:21,221 --> 0:35:22,523
两个关键阈值

769
00:35:23,156 --> 0:35:26,627
第一个阈值是app在前台

770
00:35:26,894 --> 0:35:29,496
占用80%CPU超过三分钟

771
00:35:30,297 --> 0:35:33,634
第二个阈值是app在后台

772
00:35:34,001 --> 0:35:36,136
占用80%CPU超过一分钟

773
00:35:37,104 --> 0:35:38,038
第二种情况

774
00:35:38,338 --> 0:35:42,042
为了避免后台过度占用

775
00:35:45,145 --> 0:35:47,814
每个CPU能耗日志条目

776
00:35:48,048 --> 0:35:51,585
表示app占用大量CPU

777
00:35:52,619 --> 0:35:54,188
实际上是说

778
00:35:54,955 --> 0:35:58,692
典型情况就是其导致了1%的

779
00:35:59,359 --> 0:36:00,260
电量下降

780
00:35:59,359 --> 0:36:00,260
电量下降

781
00:36:01,795 --> 0:36:03,564
你可能对自己说

782
00:36:03,630 --> 0:36:05,766
1%电量也没多糟

783
00:36:07,067 --> 0:36:08,168
但放到现实情况

784
00:36:09,136 --> 0:36:13,040
iPhone 6s的1%

785
00:36:13,807 --> 0:36:17,177
用户能额外通话8分钟

786
00:36:17,978 --> 0:36:20,180
或上网浏览6分钟

787
00:36:20,914 --> 0:36:23,550
或听音乐30分钟

788
00:36:24,718 --> 0:36:26,820
如果app继续这个速度消耗

789
00:36:28,121 --> 0:36:29,957
电池可能消耗更多

790
00:36:30,624 --> 0:36:32,593
因此编写CPU高效的app

791
00:36:32,826 --> 0:36:33,894
非常重要

792
00:36:34,394 --> 0:36:36,029
用户也会注意到

793
00:36:37,865 --> 0:36:39,833
能耗日志有三个部分

794
00:36:39,900 --> 0:36:41,835
能帮助理解发生了什么

795
00:36:42,736 --> 0:36:44,037
第一是触发报告时

796
00:36:44,104 --> 0:36:46,874
发生了什么的环境信息

797
00:36:47,441 --> 0:36:48,842
例如 其会说

798
00:36:49,343 --> 0:36:52,513
app消耗了80%超过三分钟

799
00:36:52,579 --> 0:36:53,914
（能耗日志里有什么？）

800
00:36:53,981 --> 0:36:56,350
第二部分信息是

801
00:36:56,416 --> 0:36:58,452
能耗日志创建位置的元数据

802
00:36:59,152 --> 0:37:01,388
例如 是iPhone还是iPad

803
00:36:59,152 --> 0:37:01,388
例如 是iPhone还是iPad

804
00:37:02,122 --> 0:37:04,224
还是app的Build 30版本

805
00:37:05,492 --> 0:37:07,861
第三 也是最重要的信息

806
00:37:08,195 --> 0:37:09,563
是权重调用图

807
00:37:09,763 --> 0:37:11,865
其将展示代码里的集中能耗点

808
00:37:13,200 --> 0:37:15,335
我们深入介绍权重调用图

809
00:37:16,003 --> 0:37:17,204
它是怎样产生的

810
00:37:17,571 --> 0:37:19,640
如何用它调试能耗问题

811
00:37:21,375 --> 0:37:23,343
（Xcode能耗日志：

812
00:37:23,410 --> 0:37:26,280
假如app由主函数

813
00:37:26,647 --> 0:37:27,614
还有一些方法构成

814
00:37:27,681 --> 0:37:30,784
方法1、方法2、方法3、方法4

815
00:37:33,687 --> 0:37:35,055
代码开始运行

816
00:37:35,389 --> 0:37:37,891
直到检测到CPU高能耗事件

817
00:37:40,661 --> 0:37:44,031
到这时以每秒固定周期

818
00:37:44,431 --> 0:37:46,867
采样调用堆栈

819
00:37:47,701 --> 0:37:50,571
调用堆栈是运行时

820
00:37:51,371 --> 0:37:54,107
活动帧的采样

821
00:37:55,876 --> 0:37:57,544
例如第一个调用堆栈

822
00:37:58,045 --> 0:38:01,348
显示主函数、方法1

823
00:37:58,045 --> 0:38:01,348
显示主函数、方法1

824
00:38:04,084 --> 0:38:07,855
第二个调用堆栈显示

825
00:38:07,921 --> 0:38:11,158
主函数、方法3

826
00:38:17,464 --> 0:38:20,467
现在试着把调用堆栈结合起来

827
00:38:20,534 --> 0:38:22,202
组成全局图

828
00:38:23,370 --> 0:38:25,439
这里看到的是权重调用图

829
00:38:26,106 --> 0:38:28,442
这个非常有用

830
00:38:29,443 --> 0:38:31,378
主函数在收集到的

831
00:38:31,445 --> 0:38:33,847
六个采样中都能看见

832
00:38:35,015 --> 0:38:37,451
意味着主函数全部时间都在运行

833
00:38:38,886 --> 0:38:42,189
其中方法1有五个采样

834
00:38:43,290 --> 0:38:45,559
而方法3只有一个

835
00:38:46,994 --> 0:38:50,297
方法1中看到方法2和方法3

836
00:38:50,364 --> 0:38:53,367
分别有三个和一个采样

837
00:38:54,501 --> 0:38:56,870
这给我们一个整体图

838
00:38:56,937 --> 0:38:59,406
关于哪儿的代码在执行

839
00:38:59,473 --> 0:39:01,341
花费多少时间

840
00:38:59,473 --> 0:39:01,341
花费多少时间

841
00:39:03,644 --> 0:39:04,978
（权重调用图）

842
00:39:05,045 --> 0:39:06,747
能耗日志创建时

843
00:39:07,481 --> 0:39:09,716
每秒有周期性

844
00:39:10,250 --> 0:39:11,585
采样调用堆栈

845
00:39:12,186 --> 0:39:13,554
每个调用堆栈

846
00:39:15,189 --> 0:39:18,592
包含CPU执行的活动帧

847
00:39:19,726 --> 0:39:22,196
这些调用堆栈按

848
00:39:23,197 --> 0:39:25,899
采样数聚合成树形图

849
00:39:26,733 --> 0:39:29,369
越多采样意味着越多代码执行次数

850
00:39:30,437 --> 0:39:32,139
能使用权重调用图

851
00:39:32,206 --> 0:39:35,175
识别app意外的工作负荷

852
00:39:37,578 --> 0:39:39,513
现在知道了能耗日志是什么

853
00:39:39,980 --> 0:39:41,114
怎么访问它们呢？

854
00:39:42,783 --> 0:39:45,285
首先能耗日志在设备上创建

855
00:39:46,687 --> 0:39:49,189
然后测试人员

856
00:39:49,256 --> 0:39:50,357
和下载app的客户

857
00:39:50,924 --> 0:39:53,360
将上传日志到Apple

858
00:39:54,628 --> 0:39:55,762
可能有成百

859
00:39:55,829 --> 0:39:57,564
甚至上千的日志

860
00:39:58,699 --> 0:40:01,401
我们把日志聚合起来

861
00:39:58,699 --> 0:40:01,401
我们把日志聚合起来

862
00:40:01,735 --> 0:40:06,240
分类以一系列顶级

863
00:40:07,307 --> 0:40:09,409
你能用新的Xcode

864
00:40:09,676 --> 0:40:12,446
下载查看这些日志

865
00:40:14,348 --> 0:40:17,618
Xcode能耗分析器是

866
00:40:17,684 --> 0:40:20,187
调试外界能耗问题的命令中心

867
00:40:20,254 --> 0:40:21,455
（Xcode能耗分析器）

868
00:40:21,522 --> 0:40:25,025
能耗分析器使得查看

869
00:40:26,627 --> 0:40:29,997
能耗分析器连到App Store

870
00:40:30,063 --> 0:40:32,366
将看到全部iOS app的列表

871
00:40:35,569 --> 0:40:37,437
能够看到外界这些能耗问题

872
00:40:37,504 --> 0:40:40,340
发生频率的统计数据

873
00:40:42,075 --> 0:40:44,211
将看到按多少设备受影响分类的

874
00:40:44,278 --> 0:40:46,446
顶级能耗问题的列表

875
00:40:48,515 --> 0:40:50,317
将看到一些不同日志的

876
00:40:50,784 --> 0:40:52,085
权重调用图

877
00:40:52,519 --> 0:40:55,155
能分页查看日志

878
00:40:57,724 --> 0:41:01,295
项目中用打开命令直接前往代码库

879
00:40:57,724 --> 0:41:01,295
项目中用打开命令直接前往代码库

880
00:41:01,361 --> 0:41:03,497
能开始调试这些能耗问题

881
00:41:04,431 --> 0:41:06,333
现在讲展示一个例子

882
00:41:15,676 --> 0:41:18,579
现在我确保登录了开发者账户

883
00:41:19,012 --> 0:41:21,381
也上传了能耗游戏app

884
00:41:21,815 --> 0:41:23,750
到App Store

885
00:41:24,952 --> 0:41:26,453
为了调用能耗分析器

886
00:41:26,787 --> 0:41:28,488
能前往这里的窗口

887
00:41:30,791 --> 0:41:31,892
点击分析器

888
00:41:35,896 --> 0:41:37,898
这是能耗分析器的用户界面

889
00:41:39,433 --> 0:41:42,169
确保选中顶部的能耗面板

890
00:41:43,470 --> 0:41:45,038
如果使用崩溃分析器

891
00:41:45,305 --> 0:41:47,908
你应该对这个用户界面很熟悉

892
00:41:48,909 --> 0:41:51,311
左边是全部的app列表

893
00:41:52,479 --> 0:41:55,182
之后是顶级能耗问题列表

894
00:41:56,083 --> 0:41:58,118
中间是权重调用图

895
00:41:59,152 --> 0:42:01,755
右边是一些能耗问题的

896
00:41:59,152 --> 0:42:01,755
右边是一些能耗问题的

897
00:42:01,822 --> 0:42:03,390
统计数据

898
00:42:04,758 --> 0:42:06,827
我们前往左边

899
00:42:07,761 --> 0:42:09,162
选择能耗游戏

900
00:42:09,229 --> 0:42:10,731
这是我们正在开发的游戏

901
00:42:12,332 --> 0:42:15,068
然后确保正确构建

902
00:42:20,040 --> 0:42:22,609
这里看见一系列

903
00:42:23,177 --> 0:42:25,012
按影响次数分类的能耗问题

904
00:42:27,147 --> 0:42:29,183
前往第一个能耗问题

905
00:42:30,717 --> 0:42:32,553
其影响了64台设备

906
00:42:36,790 --> 0:42:38,258
右手的面板上

907
00:42:38,325 --> 0:42:40,494
有发生了什么的细节

908
00:42:41,628 --> 0:42:42,563
还有能耗问题

909
00:42:42,629 --> 0:42:44,932
发生频率的分析

910
00:42:45,432 --> 0:42:50,304
能看见其在iPad、iPod

911
00:42:51,338 --> 0:42:54,007
能看见在过去两周

912
00:42:54,074 --> 0:42:55,275
其发生频率的分布情况

913
00:42:56,710 --> 0:42:58,478
我们看看权重调用图

914
00:43:01,815 --> 0:43:04,017
看到有大量时间

915
00:43:04,351 --> 0:43:05,586
花费在调用

916
00:43:06,053 --> 0:43:09,022
这个app代理计算函数里

917
00:43:10,691 --> 0:43:12,459
现在用这个按钮

918
00:43:13,327 --> 0:43:15,863
直接前往代码库

919
00:43:22,002 --> 0:43:24,104
直接回到代码

920
00:43:24,972 --> 0:43:28,375
左边是权重调用图里的

921
00:43:28,442 --> 0:43:29,843
调用堆栈采样之一

922
00:43:32,079 --> 0:43:34,448
能看到我们花费大量时间

923
00:43:34,515 --> 0:43:35,883
在这个计算函数里

924
00:43:37,351 --> 0:43:39,386
这就是Phil之前

925
00:43:39,887 --> 0:43:42,155
在演示里提到的函数

926
00:43:49,296 --> 0:43:50,197
我们能看到

927
00:43:51,999 --> 0:43:53,934
他已将代码注释掉

928
00:43:54,001 --> 0:43:55,903
已经解决了耗能问题

929
00:43:56,270 --> 0:43:57,771
我们回到分析器

930
00:44:04,578 --> 0:44:06,647
我能点击这个按钮

931
00:44:07,381 --> 0:44:09,049
把问题标记成已解决

932
00:44:10,150 --> 0:44:13,187
这样做的用处是

933
00:44:13,921 --> 0:44:16,089
下次打开分析器时

934
00:44:17,724 --> 0:44:19,526
我们前往第二个问题

935
00:44:19,826 --> 0:44:21,161
它影响了42台设备

936
00:44:22,763 --> 0:44:24,364
前往权重调用图之前

937
00:44:24,431 --> 0:44:25,532
我想让你们注意

938
00:44:25,599 --> 0:44:27,367
底部的三个特性

939
00:44:29,803 --> 0:44:32,573
第一是日志分页

940
00:44:33,674 --> 0:44:37,044
我能从外界42个设备的

941
00:44:37,110 --> 0:44:39,046
五个耗能日志采样中选出一个

942
00:44:42,382 --> 0:44:43,584
这些页面之间浏览

943
00:44:44,651 --> 0:44:47,554
能发现权重调用图有一点不同

944
00:44:48,088 --> 0:44:50,924
这没什么问题

945
00:44:50,991 --> 0:44:53,393
因为调用堆栈和权重调用图只是采样

946
00:44:54,595 --> 0:44:57,731
我们按相似度将其分类

947
00:44:57,798 --> 0:45:00,367
这些日志让你看起来很相似

948
00:44:57,798 --> 0:45:00,367
这些日志让你看起来很相似

949
00:45:02,870 --> 0:45:05,939
我点击这里的按钮时

950
00:45:06,373 --> 0:45:09,009
显示出之前隐藏的

951
00:45:09,076 --> 0:45:11,411
所有系统库帧

952
00:45:12,946 --> 0:45:15,249
这里的按钮

953
00:45:15,782 --> 0:45:19,052
显示所有低采样数据的帧

954
00:45:19,987 --> 0:45:21,555
我们会默认为你

955
00:45:21,955 --> 0:45:23,924
把大多数这些帧都隐藏起来

956
00:45:23,991 --> 0:45:26,360
只显示最重要的帧

957
00:45:34,501 --> 0:45:35,802
我们看看这个函数

958
00:45:38,705 --> 0:45:40,507
看起来这个计时函数里

959
00:45:40,574 --> 0:45:42,109
花费了大量时间

960
00:45:42,910 --> 0:45:45,846
事实上之前听Phil

961
00:45:45,913 --> 0:45:47,681
他说他会看一眼的

962
00:45:47,781 --> 0:45:48,782
因此我留给他处理

963
00:45:50,417 --> 0:45:51,752
我将其重命名

964
00:45:56,723 --> 0:45:58,058
然后前往下一个漏洞

965
00:45:59,126 --> 0:46:00,661
我们再看一个漏洞

966
00:45:59,126 --> 0:46:00,661
我们再看一个漏洞

967
00:46:13,607 --> 0:46:16,076
我看见大量时间花费在

968
00:46:16,143 --> 0:46:19,112
设置下一个定时器和添加新动画

969
00:46:19,713 --> 0:46:20,747
其作用是什么？

970
00:46:21,481 --> 0:46:22,449
我们深入看看

971
00:46:25,652 --> 0:46:27,221
我直接前往代码

972
00:46:37,197 --> 0:46:39,533
看到大量时间花费在

973
00:46:39,600 --> 0:46:41,702
添加新动画的函数里

974
00:46:42,636 --> 0:46:44,738
好吧 添加新动画开销很大

975
00:46:46,073 --> 0:46:48,408
但要问我们自己一个问题

976
00:46:48,475 --> 0:46:50,177
这是预期的工作量吗？

977
00:46:51,178 --> 0:46:53,847
这种情况下 答案并非如此

978
00:46:54,414 --> 0:46:57,284
因为预期每隔几秒

979
00:46:57,518 --> 0:46:58,919
才添加一次动画

980
00:46:59,586 --> 0:47:00,921
所以耗费

981
00:46:59,586 --> 0:47:00,921
所以耗费

982
00:47:00,988 --> 0:47:02,956
这么多CPU没什么道理

983
00:47:04,191 --> 0:47:06,660
我们看看调用堆栈有谁调用了我们

984
00:47:08,161 --> 0:47:11,131
我们被设置下次刷新定时器调用了

985
00:47:12,232 --> 0:47:13,433
所以函数的功能是什么

986
00:47:18,005 --> 0:47:20,407
看到在设置下次刷新定时器之内

987
00:47:20,474 --> 0:47:22,242
我们被调用以添加新动画

988
00:47:23,610 --> 0:47:24,845
函数末尾

989
00:47:25,479 --> 0:47:28,148
我们调用更新定时器

990
00:47:28,482 --> 0:47:31,418
计划该函数下次调用时间

991
00:47:33,487 --> 0:47:34,855
定时器设定在

992
00:47:34,922 --> 0:47:38,358
现在和下次刷新间隔内的

993
00:47:40,494 --> 0:47:44,831
下次刷新间隔递减1 直到0

994
00:47:46,200 --> 0:47:50,337
然后在这行代码重新初始化

995
00:47:52,639 --> 0:47:54,274
这就是问题所在

996
00:47:55,609 --> 0:47:57,711
从上次刷新到现在的

997
00:47:58,212 --> 0:48:00,280
时间间隔有可能是负数

998
00:47:58,212 --> 0:48:00,280
时间间隔有可能是负数

999
00:48:01,281 --> 0:48:03,016
我们见过这种事情

1000
00:48:03,483 --> 0:48:06,220
特别是用户折腾系统的时候

1001
00:48:07,087 --> 0:48:08,355
可能是在玩游戏

1002
00:48:09,523 --> 0:48:11,191
也可能他们想重置时钟

1003
00:48:11,758 --> 0:48:14,261
也许他们想要额外的时间或者机会

1004
00:48:14,695 --> 0:48:16,029
所以他们前往系统设置

1005
00:48:16,330 --> 0:48:18,332
把时间改到24小时之前

1006
00:48:19,566 --> 0:48:21,168
这种情况下

1007
00:48:21,235 --> 0:48:23,704
这将导致下次刷新时间变成负数

1008
00:48:24,605 --> 0:48:27,140
当我们为定时器设置一个

1009
00:48:27,508 --> 0:48:31,311
定时器将马上触发

1010
00:48:31,778 --> 0:48:33,847
然后反复调用自身

1011
00:48:34,948 --> 0:48:37,317
所以这里就成死循环了

1012
00:48:39,653 --> 0:48:41,655
幸运的是这很容易修复

1013
00:48:42,756 --> 0:48:47,761
我们前往这个函数

1014
00:48:48,328 --> 0:48:50,931
这样即使下次刷新时间是负数

1015
00:48:51,465 --> 0:48:52,733
也能从循环退出

1016
00:48:54,468 --> 0:48:56,570
这是不错的例子

1017
00:48:56,870 --> 0:49:00,607
这个能耗问题在普通测试中

1018
00:48:56,870 --> 0:49:00,607
这个能耗问题在普通测试中

1019
00:49:01,909 --> 0:49:02,943
很难发现

1020
00:49:03,810 --> 0:49:06,980
可一旦看到变量的值就变得明显

1021
00:49:08,415 --> 0:49:10,150
这就是能耗日志的作用

1022
00:49:11,018 --> 0:49:13,220
这就是能耗分析器的作用

1023
00:49:14,521 --> 0:49:17,191
我们看看这个演示的三个结论

1024
00:49:17,257 --> 0:49:18,492
（能耗分析器演示的结论）

1025
00:49:18,559 --> 0:49:20,427
你能使用能耗分析器

1026
00:49:20,494 --> 0:49:23,230
发现顶级能耗问题

1027
00:49:24,264 --> 0:49:25,766
通过查看顶级问题

1028
00:49:26,133 --> 0:49:27,901
查看发生的频率

1029
00:49:28,535 --> 0:49:31,738
查看受影响的设备和版本

1030
00:49:33,173 --> 0:49:35,609
其次 你能使用权重调用图

1031
00:49:36,043 --> 0:49:37,611
查看集中能耗点

1032
00:49:38,512 --> 0:49:41,281
寻找不寻常的高采样计数的帧

1033
00:49:42,549 --> 0:49:44,651
留心非预期的工作量

1034
00:49:46,286 --> 0:49:50,657
最后使用OpenEnd项目

1035
00:49:51,191 --> 0:49:53,994
能针对在运行的

1036
00:49:55,028 --> 0:49:55,863
修改并检查

1037
00:49:58,398 --> 0:49:59,933
总结下今天我们学到什么

1038
00:50:03,036 --> 0:50:05,572
首先考虑能量使用

1039
00:50:05,639 --> 0:50:09,643
在设计、开发和测试的每个方面

1040
00:50:10,344 --> 0:50:11,745
都优先考虑能耗

1041
00:50:12,980 --> 0:50:15,182
其次 使用出色的工具

1042
00:50:16,350 --> 0:50:19,786
例如能耗表和工具以分析app

1043
00:50:21,088 --> 0:50:23,290
第三 花点时间

1044
00:50:23,357 --> 0:50:25,859
查看新的Xcode能耗分析器

1045
00:50:26,159 --> 0:50:29,596
理解和修复能耗问题

1046
00:50:31,598 --> 0:50:34,568
更多信息请查阅下面的链接

1047
00:50:35,602 --> 0:50:38,438
记得参与周五9点到11点的

1048
00:50:39,273 --> 0:50:40,507
“动力性能实验室”

1049
00:50:41,308 --> 0:50:42,643
谢谢并愿大家度过愉快的夜晚
