1
00:00:07,016 --> 0:00:15,500
[ 音乐 ]

2
00:00:23,516 --> 0:00:27,616
[ 掌声 ]

3
00:00:28,116 --> 0:00:28,656
&gt;&gt; 大家好

4
00:00:29,016 --> 0:00:29,686
我是 Kyle

5
00:00:29,686 --> 0:00:30,776
我是一名 Apple 的软件工程师

6
00:00:30,876 --> 0:00:32,195
今天我们要将深入

7
00:00:32,195 --> 0:00:33,386
研究一下 iOS 内存

8
00:00:34,066 --> 0:00:35,986
要知道的是

9
00:00:35,986 --> 0:00:36,986
尽管这里说的是 iOS

10
00:00:36,986 --> 0:00:38,536
我们接下来涉及到的很多内容

11
00:00:38,536 --> 0:00:42,546
也适用于其他平台

12
00:00:43,186 --> 0:00:44,626
我们首先要讨论的

13
00:00:44,626 --> 0:00:46,706
是为什么要减少内存

14
00:00:48,886 --> 0:00:50,836
当我们提到减少内存时

15
00:00:50,836 --> 0:00:51,746
我们实际上

16
00:00:51,746 --> 0:00:53,116
是在讨论减少内存占用

17
00:00:53,296 --> 0:00:53,976
那么我们就来谈谈这点

18
00:00:55,326 --> 0:00:56,586
我们将讨论一些

19
00:00:56,586 --> 0:00:57,986
可以用来分析内存占用的工具

20
00:00:59,146 --> 0:01:00,706
我们会有一些针对图像的提醒

21
00:00:59,146 --> 0:01:00,706
我们会有一些针对图像的提醒

22
00:01:00,706 --> 0:01:03,116
还会讲到后台优化

23
00:01:03,196 --> 0:01:05,096
最后 我们会用一个很好的演示作为总结

24
00:01:06,446 --> 0:01:08,786
为什么减少内存呢

25
00:01:10,496 --> 0:01:12,196
简单的回答是

26
00:01:12,196 --> 0:01:13,086
为了使用户获得更好的体验

27
00:01:13,396 --> 0:01:14,986
不仅你的 App 会启动得更快

28
00:01:15,056 --> 0:01:16,276
系统会表现得更好

29
00:01:16,906 --> 0:01:18,016
你的 App 也会在内存中保留

30
00:01:18,016 --> 0:01:18,436
更长的时间

31
00:01:18,666 --> 0:01:19,646
其他 App 也会在内存中保留

32
00:01:19,646 --> 0:01:20,036
更长的时间

33
00:01:20,266 --> 0:01:21,466
几乎一切都变得更好

34
00:01:22,266 --> 0:01:23,176
现在 如果你看看周围

35
00:01:23,356 --> 0:01:25,426
你实际上也在通过

36
00:01:25,426 --> 0:01:26,796
减少内存

37
00:01:26,796 --> 0:01:27,676
来帮助其他开发者

38
00:01:28,766 --> 0:01:30,716
我们讨论的是减少内存

39
00:01:30,716 --> 0:01:32,616
但实际上减少的是内存占用

40
00:01:32,976 --> 0:01:34,376
内存和人不同 它们生而“不”平等

41
00:01:34,816 --> 0:01:35,616
这是什么意思呢

42
00:01:36,856 --> 0:01:38,186
我们需要谈谈 “Pages”

43
00:01:38,656 --> 0:01:39,646
不是这个 “Pages 文稿”

44
00:01:40,436 --> 0:01:41,876
我们将要讨论内存的页面

45
00:01:42,436 --> 0:01:44,196
系统给了你一个内存页

46
00:01:44,196 --> 0:01:46,096
它可以堆的形式

47
00:01:46,096 --> 0:01:47,676
存储多个对象

48
00:01:48,126 --> 0:01:50,206
有些对象实际上

49
00:01:50,206 --> 0:01:51,496
可以跨越多个内存页

50
00:01:52,056 --> 0:01:55,866
它们的大小一般是 16KB

51
00:01:56,276 --> 0:01:57,816
可以是净页

52
00:01:57,816 --> 0:01:58,176
也可以是脏页

53
00:02:00,236 --> 0:02:01,806
App 的内存使用

54
00:02:01,806 --> 0:02:03,036
实际上指的是页面数量

55
00:02:03,116 --> 0:02:04,686
乘以页面大小

56
00:02:05,366 --> 0:02:10,586
这有一个净页和脏页的例子

57
00:02:10,586 --> 0:02:13,766
假设我分配了一个含有 20000 个

58
00:02:13,766 --> 0:02:14,196
整数的数组

59
00:02:14,816 --> 0:02:16,916
系统可能会分配给我 6 个内存页面

60
00:02:18,036 --> 0:02:19,966
当我分配这些页面时

61
00:02:19,966 --> 0:02:20,676
它们是净页

62
00:02:21,156 --> 0:02:22,386
但是 当我开始

63
00:02:22,386 --> 0:02:23,816
对数据缓冲区进行写入时

64
00:02:23,816 --> 0:02:25,406
例如 如果我写入到这个数组的第一个位置

65
00:02:25,406 --> 0:02:27,766
这个内存页就会变成脏页

66
00:02:28,856 --> 0:02:30,996
类似地

67
00:02:30,996 --> 0:02:33,396
如果我写入到

68
00:02:33,396 --> 0:02:34,646
缓冲区中的最后一个位置

69
00:02:34,646 --> 0:02:35,686
最后一页也会变成 脏页

70
00:02:36,436 --> 0:02:37,416
请注意 中间的四个页面

71
00:02:37,416 --> 0:02:38,566
仍然是 净页

72
00:02:38,566 --> 0:02:42,896
因为 App 还没有写入它们

73
00:02:42,896 --> 0:02:45,556
另一个有趣的话题是内存映射文件

74
00:02:45,856 --> 0:02:48,206
它是一种在磁盘上的文件

75
00:02:48,206 --> 0:02:49,306
但加载到了内存中

76
00:02:50,296 --> 0:02:51,506
如果你用的是只读文件

77
00:02:51,506 --> 0:02:52,976
这些将一直是净页

78
00:02:53,846 --> 0:02:55,066
内核实际上

79
00:02:55,066 --> 0:02:57,056
是在它们离开磁盘写入 RAM 时进行管理的

80
00:02:57,746 --> 0:03:01,266
JPEG 就是一个很好的例子

81
00:02:57,746 --> 0:03:01,266
JPEG 就是一个很好的例子

82
00:03:01,656 --> 0:03:03,036
如果我有一个 JPEG 文件

83
00:03:03,036 --> 0:03:05,586
比如说 它有 50KB 大

84
00:03:05,646 --> 0:03:07,416
当它被映射到内存中时

85
00:03:07,416 --> 0:03:09,746
它实际上被映射到

86
00:03:09,746 --> 0:03:10,576
大约 4 页内存中

87
00:03:10,976 --> 0:03:12,436
第 4 页实际上

88
00:03:12,436 --> 0:03:13,936
并没有被完全填满

89
00:03:13,936 --> 0:03:14,876
所以它可以用来做其他的事情

90
00:03:14,876 --> 0:03:16,846
内存就是像这样复杂

91
00:03:16,936 --> 0:03:18,376
但是之前的那三页

92
00:03:18,456 --> 0:03:21,736
总是可以被系统释放

93
00:03:22,056 --> 0:03:26,156
当我们讨论某个典型的 App 时

94
00:03:26,446 --> 0:03:28,366
它们的内存占用和分析文件

95
00:03:28,366 --> 0:03:30,146
都会有一个脏的 一个压缩的

96
00:03:30,146 --> 0:03:31,166
以及一个干净的内存段

97
00:03:32,136 --> 0:03:32,926
让我分别来看看

98
00:03:34,766 --> 0:03:37,826
净内存是可以被分页的数据

99
00:03:38,346 --> 0:03:40,676
这些是我们刚刚讨论过的内存映射文件

100
00:03:41,016 --> 0:03:43,216
可以是图像文件 Blob.data

101
00:03:43,566 --> 0:03:44,376
或者 Training.model

102
00:03:44,916 --> 0:03:47,126
也可以是框架

103
00:03:48,546 --> 0:03:50,566
每个框架都有一个

104
00:03:50,566 --> 0:03:51,486
_DATA_CONST 部分

105
00:03:52,506 --> 0:03:53,466
它通常是 净内存

106
00:03:53,466 --> 0:03:54,406
但是如果你做了任何运行时的小把戏 

107
00:03:54,406 --> 0:03:55,726
比如 “Method Swizzling（方法交换）”

108
00:03:55,726 --> 0:04:00,876
那么它就会变成脏内存

109
00:03:55,726 --> 0:04:00,876
那么它就会变成脏内存

110
00:04:01,056 --> 0:04:03,146
脏内存是

111
00:04:03,146 --> 0:04:04,556
App 写入的任何内存

112
00:04:05,676 --> 0:04:07,516
它们可以是对象

113
00:04:07,946 --> 0:04:09,016
比如 malloc

114
00:04:09,146 --> 0:04:10,416
字符串 数组等等

115
00:04:11,056 --> 0:04:14,186
它可以是已解码的图像缓冲

116
00:04:14,366 --> 0:04:15,426
我们稍后会讲到这点

117
00:04:15,926 --> 0:04:18,576
它也可以是框架

118
00:04:19,305 --> 0:04:21,196
框架也有一个 _DATA 部分

119
00:04:21,196 --> 0:04:23,356
和一个 _DATA_DIRTY 部分

120
00:04:24,256 --> 0:04:26,786
它们总是指向脏内存

121
00:04:27,926 --> 0:04:29,216
你可能注意到了

122
00:04:29,216 --> 0:04:30,446
我曾两次提到了框架

123
00:04:30,776 --> 0:04:32,486
是的 你链接的框架

124
00:04:32,486 --> 0:04:34,976
实际上使用内存

125
00:04:34,976 --> 0:04:35,286
和脏内存

126
00:04:35,766 --> 0:04:36,976
它是一个

127
00:04:36,976 --> 0:04:39,066
连接框架的必要部分

128
00:04:39,066 --> 0:04:39,756
但如果你要保持自己的框架

129
00:04:39,756 --> 0:04:41,776
可以使用单例

130
00:04:41,776 --> 0:04:43,726
和全局初始化器

131
00:04:43,726 --> 0:04:45,256
来减少他们使用的

132
00:04:45,256 --> 0:04:46,786
脏内存

133
00:04:46,786 --> 0:04:48,146
因为单例

134
00:04:48,226 --> 0:04:49,246
在被创建之后

135
00:04:49,366 --> 0:04:51,376
才会进入内存 初始化器也只有

136
00:04:51,376 --> 0:04:53,976
在框架被链接或类被加载时

137
00:04:57,346 --> 0:05:00,986
才会运行 压缩内存非常酷

138
00:04:57,346 --> 0:05:00,986
才会运行 压缩内存非常酷

139
00:05:00,986 --> 0:05:03,066
iOS 没有传统的磁盘交换系统

140
00:05:03,946 --> 0:05:06,446
取而代之 它使用内存压缩器

141
00:05:06,626 --> 0:05:10,606
它是在 iOS 7 中被引入的内存压缩器

142
00:05:10,606 --> 0:05:12,526
接收未访问的内存页

143
00:05:12,526 --> 0:05:13,776
并压缩它们

144
00:05:13,776 --> 0:05:15,656
这实际上可以创建更多的空间

145
00:05:16,366 --> 0:05:17,586
但在访问时

146
00:05:17,586 --> 0:05:19,226
压缩器会对它们进行解压

147
00:05:19,516 --> 0:05:20,266
以便读取内存

148
00:05:20,936 --> 0:05:22,076
让我们看一个例子

149
00:05:23,296 --> 0:05:25,316
假设我有一个用于缓存的字典

150
00:05:25,876 --> 0:05:27,336
它占用了 3 页的内存

151
00:05:27,336 --> 0:05:29,796
但是如果我有一段时间

152
00:05:29,796 --> 0:05:31,266
没有访问过它

153
00:05:31,266 --> 0:05:32,436
且系统需要一些空间

154
00:05:32,436 --> 0:05:33,366
系统就可以把它

155
00:05:33,366 --> 0:05:35,436
压缩到一个内存页中

156
00:05:35,896 --> 0:05:38,156
它现在被压缩了

157
00:05:38,716 --> 0:05:40,806
但同时我节省了空间

158
00:05:40,806 --> 0:05:42,246
或者说我现在有了两个额外的内存页

159
00:05:42,896 --> 0:05:44,056
如果在未来的某个时刻我想访问它

160
00:05:44,056 --> 0:05:45,786
它将会恢复原来的大小

161
00:05:46,456 --> 0:05:48,696
我们来谈谈内存警告

162
00:05:49,446 --> 0:05:51,586
App 并不总是

163
00:05:51,946 --> 0:05:52,876
引起内存警告的原因

164
00:05:53,736 --> 0:05:54,736
如果你在一个低内存的设备上

165
00:05:54,736 --> 0:05:57,196
接到一个电话

166
00:05:57,256 --> 0:05:58,156
那也可能会触发一个内存警告

167
00:05:58,156 --> 0:05:59,036
你就有麻烦了

168
00:05:59,126 --> 0:06:00,586
所以不要想当然地认为

169
00:05:59,126 --> 0:06:00,586
所以不要想当然地认为

170
00:06:00,996 --> 0:06:02,826
内存警告是你造成的

171
00:06:03,986 --> 0:06:06,386
压缩器使内存的释放

172
00:06:06,386 --> 0:06:08,636
变得复杂

173
00:06:09,516 --> 0:06:10,146
因为根据压缩的内容

174
00:06:10,146 --> 0:06:12,106
实际上你可以 比以前使用更多的内存

175
00:06:12,356 --> 0:06:15,986
因此我们建议修改策略

176
00:06:15,986 --> 0:06:17,136
比如暂时不缓存任何内容

177
00:06:17,686 --> 0:06:18,896
或者在发生内存警告时

178
00:06:18,896 --> 0:06:21,106
限制一些后台工作

179
00:06:22,536 --> 0:06:24,386
我们中的一些人可能在 App 中

180
00:06:24,386 --> 0:06:24,846
遇到这种情况

181
00:06:25,476 --> 0:06:27,726
我们得到一个内存警告

182
00:06:27,726 --> 0:06:28,826
并决定从缓存中

183
00:06:28,826 --> 0:06:31,126
删除所有对象

184
00:06:31,336 --> 0:06:33,856
回到压缩字典的例子

185
00:06:34,646 --> 0:06:35,606
会发生什么呢

186
00:06:35,896 --> 0:06:37,446
既然我正在访问这个字典

187
00:06:37,446 --> 0:06:39,496
我现在比以前

188
00:06:39,496 --> 0:06:41,216
使用了更多的内存页

189
00:06:42,046 --> 0:06:43,866
在内存受限的环境中

190
00:06:43,926 --> 0:06:45,546
我们并不希望这样

191
00:06:46,466 --> 0:06:47,726
因为我删除了所有的对象

192
00:06:47,726 --> 0:06:50,186
我做了很多工作

193
00:06:50,186 --> 0:06:51,306
只是为了让它回到

194
00:06:51,306 --> 0:06:52,356
之前被压缩时的样子

195
00:06:52,356 --> 0:06:53,016
也就是只占用一个内存页

196
00:06:54,246 --> 0:06:57,796
所以我们要注意记忆警告

197
00:06:59,376 --> 0:07:02,466
这就提出了一个关于缓存的重要问题

198
00:06:59,376 --> 0:07:02,466
这就提出了一个关于缓存的重要问题

199
00:07:03,276 --> 0:07:05,926
当我们缓存时 我们实际上是在试图

200
00:07:05,926 --> 0:07:07,466
避免 CPU 重复工作

201
00:07:07,466 --> 0:07:08,826
但是如果我们缓存太多

202
00:07:08,826 --> 0:07:10,306
我们将耗尽所有的内存

203
00:07:10,716 --> 0:07:12,476
这可能会给系统带来问题

204
00:07:13,436 --> 0:07:15,316
所以请记住 我们有

205
00:07:15,316 --> 0:07:16,536
内存压缩器和缓存

206
00:07:16,696 --> 0:07:17,966
最好平衡一下

207
00:07:17,966 --> 0:07:20,326
缓存与重新计算的内容

208
00:07:21,386 --> 0:07:22,676
另一个注意事项是

209
00:07:22,676 --> 0:07:23,796
如果使用的不是字典

210
00:07:23,796 --> 0:07:25,706
而是 NSCache

211
00:07:25,706 --> 0:07:28,146
这将是存储缓存对象的安全方法

212
00:07:28,506 --> 0:07:30,336
由于 NSCache

213
00:07:30,336 --> 0:07:31,326
分配内存的方式

214
00:07:31,326 --> 0:07:32,806
它实际上是可被释放的

215
00:07:32,806 --> 0:07:33,396
所以在内存受限的环境中

216
00:07:33,396 --> 0:07:34,436
它的效果更好

217
00:07:34,876 --> 0:07:38,396
回到典型的 App 中的

218
00:07:38,396 --> 0:07:40,136
这三个部分

219
00:07:40,136 --> 0:07:41,166
当我们讨论 App 的内存占用时

220
00:07:41,166 --> 0:07:42,636
我们实际上是在讨论那些脏的

221
00:07:42,636 --> 0:07:44,046
和压缩的部分

222
00:07:44,146 --> 0:07:46,766
净内存在这里并不重要

223
00:07:47,876 --> 0:07:51,646
每个 App 都有一个内存占用限制

224
00:07:53,016 --> 0:07:54,816
这个限制对于一个 App 来说

225
00:07:54,816 --> 0:07:56,486
是相当高的

226
00:07:56,556 --> 0:07:57,786
但是请记住 根据设备的不同

227
00:07:58,276 --> 0:07:59,386
这个限制也会改变

228
00:07:59,506 --> 0:08:01,346
因此 你不能像

229
00:07:59,506 --> 0:08:01,346
因此 你不能像

230
00:08:01,346 --> 0:08:02,556
在内存 4GB 设备上那样 

231
00:08:02,556 --> 0:08:03,946
在 1GB 的设备上

232
00:08:03,946 --> 0:08:10,286
使用同样多的内存 还有扩展

233
00:08:10,636 --> 0:08:11,896
扩展的内存占用要小得多

234
00:08:11,896 --> 0:08:13,726
所以在使用扩展时

235
00:08:13,726 --> 0:08:16,426
你需要更加注意这一点

236
00:08:17,696 --> 0:08:19,836
当你超过了内存占用限制

237
00:08:19,836 --> 0:08:21,356
就会出现异常

238
00:08:22,146 --> 0:08:24,356
这种异常就是

239
00:08:24,356 --> 0:08:26,196
EXC_RESOURCE_EXCEPTION

240
00:08:27,366 --> 0:08:30,066
现在我想邀请

241
00:08:30,066 --> 0:08:31,616
James 来谈谈

242
00:08:31,616 --> 0:08:32,765
如何分析我们的内存占用

243
00:08:34,515 --> 0:08:36,775
[ 掌声 ]

244
00:08:37,275 --> 0:08:37,686
谢谢 James

245
00:08:38,236 --> 0:08:38,616
&gt;&gt; 谢谢你

246
00:08:40,655 --> 0:08:41,066
谢谢 Kyle

247
00:08:41,256 --> 0:08:42,035
好的

248
00:08:42,226 --> 0:08:42,736
我是 James

249
00:08:42,736 --> 0:08:44,155
我是一名 Apple 的软件工程师

250
00:08:44,456 --> 0:08:45,706
我想向你们介绍一些

251
00:08:45,706 --> 0:08:47,886
更高级的工具用于分析和研究

252
00:08:47,886 --> 0:08:49,406
App 的内存占用情况

253
00:08:51,456 --> 0:08:52,346
你可能已经熟悉了

254
00:08:52,346 --> 0:08:53,906
Xcode 内存测量计

255
00:08:54,436 --> 0:08:57,036
它就在调试导航器中

256
00:08:57,166 --> 0:08:59,086
它是帮助你快速查看 App 内存占用

257
00:08:59,086 --> 0:09:00,546
很好的一种方式

258
00:08:59,086 --> 0:09:00,546
很好的一种方式

259
00:09:00,966 --> 0:09:03,086
在 Xcode 10 中

260
00:09:03,086 --> 0:09:04,516
它现在可向你输出

261
00:09:04,516 --> 0:09:05,696
系统对你的评分值

262
00:09:05,696 --> 0:09:06,526
所以如果看起来与 Xcode 9 不同

263
00:09:06,526 --> 0:09:08,186
不要太在意

264
00:09:09,226 --> 0:09:11,676
我正在 Xcode 中运行我的 App

265
00:09:11,676 --> 0:09:12,606
我发现它消耗了更多的内存

266
00:09:13,386 --> 0:09:14,636
那么下一步我应该用什么工具呢

267
00:09:15,316 --> 0:09:17,306
显然是 Instruments

268
00:09:18,356 --> 0:09:19,826
它提供了许多方法

269
00:09:19,826 --> 0:09:21,186
来调查 App 的内存占用

270
00:09:21,916 --> 0:09:24,256
你可能已经熟悉

271
00:09:24,256 --> 0:09:25,556
“Allocations” 和 “Leaks”

272
00:09:25,776 --> 0:09:27,316
“Allocations”

273
00:09:27,316 --> 0:09:28,466
分析由你的 App 所分配的堆

274
00:09:28,886 --> 0:09:29,866
“Leaks”

275
00:09:29,866 --> 0:09:31,056
会检查一个进程中的内存泄漏

276
00:09:31,226 --> 0:09:32,756
但是你可能不太熟悉

277
00:09:32,756 --> 0:09:33,946
“VM Tracker”

278
00:09:33,946 --> 0:09:34,826
和 “Virtual memory trace（虚拟内存追踪）”

279
00:09:35,376 --> 0:09:37,326
如果你还记得

280
00:09:37,326 --> 0:09:38,066
Kyle 谈论过的

281
00:09:38,066 --> 0:09:39,416
iOS 内存的主要类别

282
00:09:39,486 --> 0:09:41,456
他谈到了脏内存

283
00:09:41,456 --> 0:09:42,516
和压缩内存

284
00:09:42,946 --> 0:09:44,556
VM Tracker 提供了一种

285
00:09:44,556 --> 0:09:45,806
很好的分析方式

286
00:09:47,116 --> 0:09:48,616
它为脏内存

287
00:09:48,616 --> 0:09:50,046
以及交换内存即 iOS 中的压缩内存

288
00:09:50,046 --> 0:09:51,646
分别提供了独立的追踪

289
00:09:51,646 --> 0:09:52,386
并告诉你

290
00:09:52,386 --> 0:09:53,186
关于常驻内存大小的信息

291
00:09:53,996 --> 0:09:55,176
我认为这对于

292
00:09:55,176 --> 0:09:57,926
研究 App 的脏内存大小 非常有用

293
00:09:58,516 --> 0:09:59,866
Instruments 中的最后一项是

294
00:09:59,866 --> 0:10:01,046
“Virtual memory trace（虚拟内存追踪）”

295
00:09:59,866 --> 0:10:01,046
“Virtual memory trace（虚拟内存追踪）”

296
00:10:01,786 --> 0:10:03,326
你可以凭借它

297
00:10:03,326 --> 0:10:04,446
与你 App 相关的虚拟内存系统的性能

298
00:10:04,446 --> 0:10:06,726
进行深入的了解

299
00:10:08,736 --> 0:10:10,486
我发现这里的 “By Operation” 标签页

300
00:10:10,486 --> 0:10:11,226
非常有用

301
00:10:11,916 --> 0:10:12,996
它为你提供了一个

302
00:10:12,996 --> 0:10:14,386
虚拟内存系统文件

303
00:10:14,386 --> 0:10:16,376
并向你展示虚拟内存的内存页缓存命中

304
00:10:16,376 --> 0:10:18,826
以及内存页零填充之类的内容

305
00:10:21,016 --> 0:10:22,536
Kyle 前面提到

306
00:10:22,536 --> 0:10:23,726
如果你接近设备的内存限制

307
00:10:23,726 --> 0:10:25,146
你将收到

308
00:10:25,146 --> 0:10:26,766
EXC_RESOURCE_EXCEPTION 的异常

309
00:10:27,276 --> 0:10:28,346
如果你正在 Xcode 10 中

310
00:10:28,346 --> 0:10:31,136
运行你的 App

311
00:10:31,136 --> 0:10:32,586
Xcode 将会捕获这个异常

312
00:10:32,586 --> 0:10:33,266
并暂停你的 App

313
00:10:33,636 --> 0:10:35,636
这意味着你可以启动内存调试器

314
00:10:35,636 --> 0:10:36,816
并从那里开始调查

315
00:10:37,066 --> 0:10:38,436
我认为这真的十分有用

316
00:10:39,016 --> 0:10:42,006
Xcode 的内存调试器

317
00:10:42,006 --> 0:10:43,606
是在 Xcode 8 中提供的

318
00:10:43,606 --> 0:10:44,926
它可以帮助你跟踪对象的依赖

319
00:10:44,926 --> 0:10:46,546
声明周期和泄漏

320
00:10:46,996 --> 0:10:48,336
在 Xcode 10 中

321
00:10:48,336 --> 0:10:50,036
内存调试器更新了布局

322
00:10:50,536 --> 0:10:52,066
它非常适合用来查看

323
00:10:52,066 --> 0:10:52,986
非常大的内存图文件

324
00:10:53,926 --> 0:10:55,836
在内部

325
00:10:55,836 --> 0:10:57,456
Xcode 使用 Memgraph 文件格式

326
00:10:57,456 --> 0:10:58,916
存储有关 App 的

327
00:10:58,916 --> 0:10:59,706
内存使用的信息

328
00:11:00,106 --> 0:11:01,356
你可能不知道

329
00:11:01,726 --> 0:11:03,066
你可以搭配我们的多种命令行工具

330
00:11:03,066 --> 0:11:04,496
使用 Memgraph

331
00:11:06,366 --> 0:11:07,566
首先 你需要从 Xcode 中

332
00:11:07,566 --> 0:11:08,586
导出 Memgraph

333
00:11:08,956 --> 0:11:09,856
这很简单

334
00:11:10,976 --> 0:11:12,336
你只需点按 “File（文件）”菜单中的

335
00:11:12,336 --> 0:11:14,006
“Export Memory Graph...（导出内存图）”

336
00:11:14,006 --> 0:11:14,686
并将其保存

337
00:11:15,336 --> 0:11:18,216
然后 你就可以将 Memgraph

338
00:11:18,256 --> 0:11:19,506
传递给命令行工具

339
00:11:19,506 --> 0:11:20,456
而不是目标本身

340
00:11:20,456 --> 0:11:21,036
这样就可以了

341
00:11:22,176 --> 0:11:23,796
我在 Xcode 10 中运行我的 App

342
00:11:23,796 --> 0:11:25,216
然后收到一个

343
00:11:25,216 --> 0:11:25,996
内存资源异常

344
00:11:26,356 --> 0:11:26,986
这可不太好

345
00:11:27,176 --> 0:11:29,536
我也许应该提取 Memgraph 来进一步研究

346
00:11:29,536 --> 0:11:30,536
但接下来我该怎么做呢

347
00:11:31,046 --> 0:11:32,526
显然 去终端

348
00:11:33,176 --> 0:11:35,396
我经常使用的第一个工具

349
00:11:35,536 --> 0:11:36,026
是 vmmap

350
00:11:36,626 --> 0:11:37,486
通过输出

351
00:11:37,486 --> 0:11:38,696
分配给进程的虚拟内存区域

352
00:11:38,696 --> 0:11:40,306
它给你的 App 提供了

353
00:11:40,306 --> 0:11:42,106
内存消耗的高级分析

354
00:11:43,576 --> 0:11:45,856
-summary 参数 是一个很好的起点

355
00:11:46,716 --> 0:11:49,866
它可以打印出很多细节 

356
00:11:49,866 --> 0:11:52,946
比如该区域的内存大小

357
00:11:52,946 --> 0:11:55,546
脏区域的数量

358
00:11:55,546 --> 0:11:56,286
以及交换内存

359
00:11:56,286 --> 0:11:58,026
也就是 iOS 中的压缩内存的数量

360
00:11:58,196 --> 0:12:00,956
请记住这里的脏和交换区域大小 是非常重要的

361
00:11:58,196 --> 0:12:00,956
请记住这里的脏和交换区域大小 是非常重要的

362
00:12:02,016 --> 0:12:03,646
值得注意的一点是

363
00:12:03,646 --> 0:12:05,066
交换区域大小指的是

364
00:12:05,066 --> 0:12:07,486
数据压缩前的大小

365
00:12:07,486 --> 0:12:08,746
而不是压缩后的大小

366
00:12:10,226 --> 0:12:11,686
如果你真的需要深入了解

367
00:12:11,756 --> 0:12:13,186
想要更多的信息

368
00:12:13,546 --> 0:12:14,956
你可以在 Memgraph 上

369
00:12:14,956 --> 0:12:16,186
运行 vmmap

370
00:12:16,186 --> 0:12:17,786
你会得到所有区域的具体信息

371
00:12:17,896 --> 0:12:19,606
我们首先向你们展示

372
00:12:19,606 --> 0:12:20,686
“Non-writable regions（不可写入区域）”

373
00:12:20,686 --> 0:12:22,156
比如程序的文本

374
00:12:22,156 --> 0:12:24,536
或可执行代码

375
00:12:24,536 --> 0:12:26,156
然后是 “Writable regions（可写入区域）”

376
00:12:26,156 --> 0:12:27,186
比如数据部分

377
00:12:27,256 --> 0:12:28,786
这就是你的进程堆

378
00:12:29,286 --> 0:12:30,436
所在的位置

379
00:12:30,676 --> 0:12:31,986
除了这些之外还有很酷的一点

380
00:12:31,986 --> 0:12:33,456
就是所有这些工具

381
00:12:33,456 --> 0:12:34,836
都可以很好地使用

382
00:12:34,836 --> 0:12:35,976
标准命令行实用程序

383
00:12:36,526 --> 0:12:38,286
例如 前几天

384
00:12:38,286 --> 0:12:39,356
我在 VM Tracker 中分析我的 App

385
00:12:39,356 --> 0:12:41,506
然后我看到了

386
00:12:41,506 --> 0:12:42,526
脏内存增加的情况

387
00:12:43,106 --> 0:12:45,316
所以我导出了 Memgraph 文件

388
00:12:45,316 --> 0:12:48,036
我想知道这些脏数据

389
00:12:48,036 --> 0:12:49,166
是否有一部分是由我链接的

390
00:12:49,166 --> 0:12:52,076
框架或库造成的

391
00:12:52,276 --> 0:12:54,216
于是我在这个 Memgraph 上

392
00:12:54,216 --> 0:12:55,296
运行 vmmap

393
00:12:56,296 --> 0:12:58,456
我使用了 -pages 参数

394
00:12:58,866 --> 0:13:00,206
这意味着 vmmap 将输出

395
00:12:58,866 --> 0:13:00,206
这意味着 vmmap 将输出

396
00:13:00,206 --> 0:13:01,496
内存页的数量

397
00:13:01,496 --> 0:13:02,376
而不仅仅是原始字节

398
00:13:02,866 --> 0:13:06,796
然后我将它传输到 grep

399
00:13:06,886 --> 0:13:08,206
并在那搜索 ‘.dylib’

400
00:13:08,206 --> 0:13:09,456
所以我在这里需要动态库

401
00:13:11,046 --> 0:13:12,166
最后 我将它导入到

402
00:13:12,166 --> 0:13:13,536
一个特别简单的 awk 脚本中

403
00:13:14,116 --> 0:13:15,816
来合计脏列

404
00:13:15,816 --> 0:13:16,826
然后最终将其输出为

405
00:13:16,826 --> 0:13:17,886
脏内存页的数量

406
00:13:19,386 --> 0:13:20,556
我觉得这很酷

407
00:13:20,556 --> 0:13:22,286
而且我一直在使用它

408
00:13:22,286 --> 0:13:23,676
它让你能够

409
00:13:23,676 --> 0:13:25,096
为你和你的团队编写

410
00:13:25,096 --> 0:13:26,216
非常强大的调试工作流

411
00:13:26,656 --> 0:13:30,466
另一个 macOS 开发人员

412
00:13:30,466 --> 0:13:31,686
可能已经熟悉的

413
00:13:31,686 --> 0:13:33,066
命令行实用程序是 leaks

414
00:13:33,836 --> 0:13:35,306
它在运行时跟踪堆中

415
00:13:35,696 --> 0:13:37,396
没有根的对象

416
00:13:37,726 --> 0:13:38,586
所以请记住

417
00:13:38,586 --> 0:13:39,816
如果你在 leaks 中看到一个对象

418
00:13:39,816 --> 0:13:41,466
那它占用的是你无法释放的脏内存

419
00:13:41,846 --> 0:13:44,866
让我们看看 内存调试器中的内存泄漏

420
00:13:46,176 --> 0:13:48,176
这里我有 3 个对象

421
00:13:48,176 --> 0:13:49,356
它们相互之间都有很强的引用

422
00:13:49,356 --> 0:13:51,166
创建了一个经典的 “Retain Cycle（留置环）”

423
00:13:51,876 --> 0:13:53,766
让我们在 leaks 工具中

424
00:13:54,216 --> 0:13:56,446
看看这个泄漏

425
00:13:56,646 --> 0:13:57,686
今年 leaks 已被更新

426
00:13:57,686 --> 0:13:59,676
不仅可以显示

427
00:13:59,676 --> 0:14:05,396
泄漏的对象 还可显示它们所属的 Retain Cycle

428
00:13:59,676 --> 0:14:05,396
泄漏的对象 还可显示它们所属的 Retain Cycle

429
00:14:05,396 --> 0:14:07,126
如果进程中启用了

430
00:14:07,126 --> 0:14:08,856
malloc 堆栈日志记录

431
00:14:08,856 --> 0:14:10,666
我们甚至为你提供了

432
00:14:11,786 --> 0:14:14,146
根节点 回溯

433
00:14:14,416 --> 0:14:15,796
我经常问自己的一个问题是

434
00:14:15,906 --> 0:14:17,276
内存都去哪了

435
00:14:18,096 --> 0:14:19,606
我查看了 vmmap

436
00:14:19,606 --> 0:14:20,716
发现堆很大

437
00:14:20,966 --> 0:14:22,006
但是接下来要做什么呢

438
00:14:22,626 --> 0:14:24,426
heap 工具提供了

439
00:14:24,426 --> 0:14:25,366
关于进程堆中

440
00:14:25,366 --> 0:14:26,836
对象分配的各种信息

441
00:14:27,046 --> 0:14:28,616
它可以帮助你追踪

442
00:14:28,616 --> 0:14:30,216
非常复杂的分配

443
00:14:30,216 --> 0:14:32,086
或者很多同类的对象

444
00:14:34,036 --> 0:14:36,236
我这里有一个 Memgraph 文件

445
00:14:36,236 --> 0:14:37,516
它是我在 Xcode 捕获到

446
00:14:37,516 --> 0:14:39,336
内存资源异常时得到的

447
00:14:39,336 --> 0:14:40,366
我想研究它的堆

448
00:14:40,906 --> 0:14:43,416
所以我把它传递给了 heap

449
00:14:43,926 --> 0:14:45,186
它告诉我

450
00:14:45,186 --> 0:14:49,696
每个对象的类名

451
00:14:49,696 --> 0:14:50,546
它们的数量

452
00:14:50,546 --> 0:14:52,366
它们的平均大小

453
00:14:52,366 --> 0:14:54,976
以及这类对象的总大小

454
00:14:54,976 --> 0:14:56,446
在这里

455
00:14:56,656 --> 0:14:58,156
我看到了很多很多小对象

456
00:14:58,156 --> 0:14:58,976
但我不认为

457
00:14:58,976 --> 0:14:59,676
这是什么问题

458
00:14:59,946 --> 0:15:01,066
我不认为

459
00:14:59,946 --> 0:15:01,066
我不认为

460
00:15:01,066 --> 0:15:01,786
这是主要的问题

461
00:15:05,336 --> 0:15:07,456
默认情况下 堆将按数量排序

462
00:15:08,376 --> 0:15:09,786
但是我希望看到的

463
00:15:09,936 --> 0:15:11,176
是最大的对象

464
00:15:11,176 --> 0:15:12,586
而不是数量最多的对象

465
00:15:12,586 --> 0:15:14,086
因此将 -sortBySize 参数传递给堆

466
00:15:14,086 --> 0:15:15,176
能让它们按大小排序

467
00:15:16,616 --> 0:15:17,606
这里我看到了一些

468
00:15:17,606 --> 0:15:19,576
硕大的 NSConcreteData 对象

469
00:15:19,926 --> 0:15:21,246
我应该将这个输出

470
00:15:21,246 --> 0:15:22,586
和 Memgraph

471
00:15:22,586 --> 0:15:24,726
附加到 Bug 报告中

472
00:15:24,726 --> 0:15:25,216
但这还不够

473
00:15:25,216 --> 0:15:25,966
我得弄清楚

474
00:15:25,966 --> 0:15:26,446
这些对象是怎么来的

475
00:15:27,806 --> 0:15:29,186
首先 我需要获得

476
00:15:29,186 --> 0:15:30,896
其中一个 NSConcreteData 对象的地址

477
00:15:31,606 --> 0:15:33,006
然后是 heap 工具中的 -addresses 参数

478
00:15:33,396 --> 0:15:34,436
当你将 -addresses 参数

479
00:15:34,436 --> 0:15:35,456
与一个类名一起传给 heap 工具时

480
00:15:35,456 --> 0:15:36,656
它将为你提供堆上的

481
00:15:36,656 --> 0:15:38,306
每个实例的地址

482
00:15:39,516 --> 0:15:41,186
现在我有了这些地址

483
00:15:41,186 --> 0:15:42,656
我可以知道它们每一个都来自哪里

484
00:15:43,926 --> 0:15:44,866
这就是 malloc 堆栈日志记录

485
00:15:44,866 --> 0:15:45,756
派上用场的地方

486
00:15:46,526 --> 0:15:47,976
当启用时

487
00:15:47,976 --> 0:15:49,826
系统将记录每个分配的回溯

488
00:15:50,316 --> 0:15:52,196
当我们记录一个 Memgraph 时

489
00:15:52,196 --> 0:15:53,576
这些日志就会被捕获

490
00:15:53,576 --> 0:15:54,616
它们将用于为我们的一些工具

491
00:15:54,616 --> 0:15:56,366
注释现有的输出 你可以在

492
00:15:57,136 --> 0:15:58,306
“Scheme Editor（Scheme 编辑器）”中的

493
00:15:58,306 --> 0:16:00,576
“Diagnostics（诊断）”标签页中 轻松启用它

494
00:15:58,306 --> 0:16:00,576
“Diagnostics（诊断）”标签页中 轻松启用它

495
00:16:01,426 --> 0:16:02,576
我建议你们

496
00:16:02,576 --> 0:16:03,696
在 Memgraph 中

497
00:16:03,696 --> 0:16:06,726
使用实时分配选项

498
00:16:06,726 --> 0:16:08,986
我的 Memgraph 文件

499
00:16:08,986 --> 0:16:10,196
在 malloc 堆栈日志记录中被捕获

500
00:16:10,866 --> 0:16:12,926
现在我们要找到分配的回溯

501
00:16:13,226 --> 0:16:14,776
这就是 malloc_history 发挥作用的地方

502
00:16:15,566 --> 0:16:16,946
你只需传递 malloc_history

503
00:16:17,136 --> 0:16:18,576
Memgraph

504
00:16:18,576 --> 0:16:19,886
以及内存中实例的地址

505
00:16:19,886 --> 0:16:20,876
那么 如果捕获到它的回溯

506
00:16:20,876 --> 0:16:24,016
malloc_history 就会将其提供给你

507
00:16:24,136 --> 0:16:25,276
这里我取了其中

508
00:16:25,276 --> 0:16:27,276
一个很大的 NSConcreteData 的地址

509
00:16:27,496 --> 0:16:28,376
我把它传递给了 malloc_history

510
00:16:28,376 --> 0:16:31,026
然后我就得到了一个回溯记录

511
00:16:31,486 --> 0:16:32,646
有趣的是

512
00:16:32,646 --> 0:16:34,166
看起来我的 NoirFilter.apply() 方法

513
00:16:34,166 --> 0:16:36,376
创建了一个巨大的 NSConcreteData

514
00:16:37,126 --> 0:16:38,526
我应该将这个和 Memgraph

515
00:16:38,526 --> 0:16:40,186
附加到一个 Bug 报告中

516
00:16:40,186 --> 0:16:43,206
其他人就可以查看它

517
00:16:43,476 --> 0:16:44,696
这些只是几种

518
00:16:44,696 --> 0:16:46,756
可以深入研究

519
00:16:46,756 --> 0:16:48,216
App 行为的方法

520
00:16:48,626 --> 0:16:49,526
当遇到内存问题时

521
00:16:49,526 --> 0:16:51,086
你会选择哪个工具

522
00:16:52,096 --> 0:16:53,676
有 3 种思考方式

523
00:16:53,956 --> 0:16:55,656
你想看到对象的创建吗

524
00:16:55,656 --> 0:16:56,956
你想要查看内存中

525
00:16:56,956 --> 0:16:58,696
引用对象或地址的内容吗

526
00:16:59,056 --> 0:17:00,926
或者你只是想看看 一个实例有多大

527
00:16:59,056 --> 0:17:00,926
或者你只是想看看 一个实例有多大

528
00:17:02,376 --> 0:17:03,366
如果你在进程启动时

529
00:17:03,366 --> 0:17:05,046
启用了 malloc 堆栈日志记录

530
00:17:05,046 --> 0:17:06,185
那么 malloc_history

531
00:17:06,185 --> 0:17:09,455
可以帮助你查找 该对象的回溯

532
00:17:10,896 --> 0:17:11,646
如果你只是想看看

533
00:17:11,646 --> 0:17:12,896
在内存中引用对象的内容

534
00:17:13,486 --> 0:17:15,576
你可以使用 leaks

535
00:17:15,576 --> 0:17:16,766
和在内存页面中

536
00:17:16,766 --> 0:17:17,915
提供的其他工具来帮助你

537
00:17:17,915 --> 0:17:20,366
最后 如果你只是想了解

538
00:17:20,366 --> 0:17:23,296
一个区域或一个实例有多大 vmmap

539
00:17:23,296 --> 0:17:24,056
和 heap 是首选工具

540
00:17:24,626 --> 0:17:27,376
作为起始点 我建议在进程的 Memgraph 上

541
00:17:27,376 --> 0:17:30,436
运行带有 -summary 命令的 vmmap

542
00:17:30,626 --> 0:17:34,096
然后顺着线程继续进行

543
00:17:34,096 --> 0:17:36,286
现在 我想请回 Kyle 他将会讨论

544
00:17:36,436 --> 0:17:37,736
iOS App 中最大的对象

545
00:17:37,736 --> 0:17:39,936
那就是图像

546
00:17:40,646 --> 0:17:40,856
有请 Kyle

547
00:17:42,516 --> 0:17:45,856
[ 掌声 ]

548
00:17:46,356 --> 0:17:46,916
&gt;&gt; 谢谢 James

549
00:17:47,916 --> 0:17:49,486
说到图像

550
00:17:50,306 --> 0:17:51,586
关于图像需要记住的

551
00:17:51,586 --> 0:17:54,296
最重要的就是

552
00:17:54,296 --> 0:17:55,506
内存使用与图像的尺寸有关

553
00:17:55,506 --> 0:17:58,536
而不与它的文件大小有关

554
00:17:59,696 --> 0:18:01,846
举个例子

555
00:17:59,696 --> 0:18:01,846
举个例子

556
00:18:01,996 --> 0:18:03,786
我有一张非常漂亮的图片

557
00:18:03,786 --> 0:18:04,986
并且我想把它作为

558
00:18:04,986 --> 0:18:05,496
一个 iPad App 的壁纸

559
00:18:06,646 --> 0:18:10,786
它的尺寸是 2048*1536

560
00:18:10,786 --> 0:18:13,436
磁盘上文件的大小是 590KB

561
00:18:13,966 --> 0:18:16,086
但是它实际使用了多少内存呢

562
00:18:18,516 --> 0:18:19,646
10MB

563
00:18:20,056 --> 0:18:21,746
10MB 这可够大的

564
00:18:22,146 --> 0:18:23,746
这是因为

565
00:18:23,746 --> 0:18:25,066
把像素的宽度乘以高

566
00:18:25,066 --> 0:18:28,406
即 2048 乘以 1536

567
00:18:28,406 --> 0:18:30,016
然后每像素乘以 4 字节

568
00:18:30,016 --> 0:18:30,786
就会达到 10MB

569
00:18:31,706 --> 0:18:33,956
那么为什么它会大这么多呢

570
00:18:35,016 --> 0:18:36,916
我们要谈谈图像

571
00:18:36,916 --> 0:18:38,076
是如何在 iOS 上工作的

572
00:18:38,196 --> 0:18:39,676
有加载 解码

573
00:18:39,706 --> 0:18:40,346
和渲染三个阶段

574
00:18:41,306 --> 0:18:43,516
在加载阶段

575
00:18:43,516 --> 0:18:45,646
这个被压缩的 590KB 的 JPEG 文件被接收

576
00:18:45,646 --> 0:18:48,646
并被加载到内存中

577
00:18:49,856 --> 0:18:51,996
在解码阶段 JPEG 文件

578
00:18:51,996 --> 0:18:55,366
将被转换为 GPU 可以读取的格式

579
00:18:55,936 --> 0:18:56,966
图像需要被解压

580
00:18:56,966 --> 0:18:58,996
这使得文件大小增至 10 mb

581
00:18:59,926 --> 0:19:01,446
被解码之后

582
00:18:59,926 --> 0:19:01,446
被解码之后

583
00:19:01,446 --> 0:19:02,556
图像就可以被随意渲染了

584
00:19:03,136 --> 0:19:05,206
要了解更多关于图像的信息

585
00:19:05,526 --> 0:19:06,936
以及如何对它们进行优化

586
00:19:06,936 --> 0:19:08,346
我建议你们查看

587
00:19:08,346 --> 0:19:10,296
本周早些时候举行的

588
00:19:10,416 --> 0:19:11,646
“Images and Graphics

589
00:19:11,646 --> 0:19:13,946
Best Practices” 的讨论会

590
00:19:14,216 --> 0:19:16,076
在 SRGB 格式中

591
00:19:16,176 --> 0:19:17,286
每个像素有 4 个字节

592
00:19:18,236 --> 0:19:19,186
这通常是图形中

593
00:19:19,186 --> 0:19:21,856
图像最常见的格式

594
00:19:22,356 --> 0:19:26,196
它是每个像素 8 位

595
00:19:26,816 --> 0:19:28,776
所以红色 1 字节 绿色 1 字节

596
00:19:28,776 --> 0:19:30,816
蓝色 1 字节

597
00:19:30,816 --> 0:19:31,596
Alpha 通道 1 字节

598
00:19:33,126 --> 0:19:36,036
但是 我们还可以将其继续变大

599
00:19:36,036 --> 0:19:39,176
iOS 硬件可以渲染宽格式

600
00:19:39,356 --> 0:19:40,736
宽格式中

601
00:19:40,736 --> 0:19:42,476
为了得到有表现力的颜色

602
00:19:42,476 --> 0:19:44,356
每个像素需要 2 个字节

603
00:19:44,356 --> 0:19:45,456
所以我们将图像的大小加倍

604
00:19:46,356 --> 0:19:49,176
iPhone 7 iPhone 8 iPhone X

605
00:19:49,356 --> 0:19:51,006
以及一些 iPad Pro 上的摄像头

606
00:19:51,436 --> 0:19:53,036
非常适合捕捉这种

607
00:19:53,266 --> 0:19:55,006
高保真的内容

608
00:19:55,576 --> 0:19:56,966
你也可以用它来制作

609
00:19:56,966 --> 0:19:57,976
非常精确的颜色

610
00:19:57,976 --> 0:19:58,946
比如运动商标等等

611
00:20:00,066 --> 0:20:01,706
但是这些只在

612
00:20:01,706 --> 0:20:02,856
宽格式显示器中有用

613
00:20:02,856 --> 0:20:03,766
所以我们不希望

614
00:20:03,766 --> 0:20:04,616
在不需要的时候使用它

615
00:20:05,756 --> 0:20:07,766
另一方面 我们也可以使图像变小

616
00:20:08,356 --> 0:20:10,066
比如 AL8 格式

617
00:20:10,606 --> 0:20:13,176
这种格式只存储灰度值

618
00:20:13,176 --> 0:20:14,236
和 Alpha 值

619
00:20:14,886 --> 0:20:16,486
它通常用于着色器

620
00:20:16,486 --> 0:20:18,626
比如 Metal App 等等

621
00:20:19,306 --> 0:20:21,246
这个格式并不常用 实际上 

622
00:20:21,446 --> 0:20:22,776
我们还可以让它继续变小

623
00:20:23,736 --> 0:20:24,936
我们可以使用所谓的

624
00:20:24,936 --> 0:20:26,086
Alpha 8 格式

625
00:20:26,516 --> 0:20:28,096
Alpha 8 只有 1 个通道

626
00:20:28,156 --> 0:20:30,196
每个像素 1 个字节 非常小

627
00:20:30,196 --> 0:20:32,056
它比 SRGB 小 75%

628
00:20:33,026 --> 0:20:34,546
这很适合蒙版

629
00:20:34,546 --> 0:20:36,246
或单色文本

630
00:20:36,246 --> 0:20:37,966
因为我们节省了 75% 的内存

631
00:20:39,096 --> 0:20:41,396
如果我们分开来看

632
00:20:42,296 --> 0:20:43,966
我们可以从 Alpha 8 格式的

633
00:20:44,006 --> 0:20:45,786
每个像素 1 个字节开始

634
00:20:45,786 --> 0:20:47,096
一直增加到宽格式的每个像素 8 个字节

635
00:20:47,466 --> 0:20:48,606
这个范围很大

636
00:20:48,916 --> 0:20:50,806
所以我们真正需要做的是

637
00:20:50,806 --> 0:20:52,046
知道如何选择正确的格式

638
00:20:52,926 --> 0:20:54,906
那么我们如何选择正确的格式呢

639
00:20:55,656 --> 0:20:58,126
简短的回答是不要选择格式

640
00:20:58,456 --> 0:20:59,646
让格式来选择你

641
00:21:01,106 --> 0:21:03,006
如果你不再使用

642
00:21:03,006 --> 0:21:04,876
自 iOS 诞生起就存在于 iOS 的

643
00:21:04,876 --> 0:21:07,416
UIGraphicsBeginImageContext

644
00:21:07,416 --> 0:21:09,276
WithOptions API

645
00:21:09,276 --> 0:21:12,576
而是切换到 UIGraphicsImageRenderer 格式

646
00:21:12,576 --> 0:21:14,206
你可以节省很多内存

647
00:21:15,036 --> 0:21:17,456
因为 UIGraphicsBeginImage

648
00:21:17,456 --> 0:21:19,006
ContextWithOptions 总是一个

649
00:21:19,356 --> 0:21:20,916
每像素 4 字节的格式

650
00:21:21,886 --> 0:21:22,866
它总是 SRGB 格式

651
00:21:23,186 --> 0:21:25,446
所以只要你不想 你就不会得到宽格式

652
00:21:25,446 --> 0:21:27,216
也不会得到

653
00:21:27,216 --> 0:21:28,596
每像素 1 字节的 A8 格式

654
00:21:28,716 --> 0:21:30,966
如果你使用在 iOS 10 中引入的

655
00:21:31,566 --> 0:21:33,576
UIGraphicsImageRenderer API

656
00:21:33,626 --> 0:21:35,156
在 iOS 12 中

657
00:21:35,156 --> 0:21:36,396
它会自动为你选择最好的图形格式

658
00:21:36,866 --> 0:21:39,176
这有一个例子

659
00:21:39,716 --> 0:21:41,146
假设我画了一个圆作为一个蒙版

660
00:21:41,956 --> 0:21:43,666
使用旧 API

661
00:21:43,666 --> 0:21:45,626
高亮的部分是

662
00:21:45,626 --> 0:21:46,866
我的绘制代码

663
00:21:46,866 --> 0:21:48,326
只是为了绘制一个黑色圆圈

664
00:21:48,326 --> 0:21:49,586
我得到的却是每个像素 4 字节的格式

665
00:21:51,026 --> 0:21:52,366
如果我转而使用新的 API

666
00:21:52,366 --> 0:21:54,826
我使用的是完全相同的绘制代码

667
00:21:55,676 --> 0:21:57,406
通过使用新的 API

668
00:21:57,406 --> 0:21:59,096
我现在得到的是每个像素 1 字节的图像

669
00:21:59,176 --> 0:22:01,396
这意味着它减少了

670
00:21:59,176 --> 0:22:01,396
这意味着它减少了

671
00:22:01,706 --> 0:22:02,346
75% 的内存使用

672
00:22:02,786 --> 0:22:04,316
在保证相同保真度的同时

673
00:22:04,316 --> 0:22:05,086
也获得了可观的内存节省

674
00:22:05,676 --> 0:22:11,916
另外一个好处是 如果我想再次使用这个蒙版

675
00:22:11,916 --> 0:22:13,476
我可以在一个 imageView 上

676
00:22:13,476 --> 0:22:16,006
改变 tintColor

677
00:22:16,006 --> 0:22:17,366
而且只用一个点号就可以做到

678
00:22:17,366 --> 0:22:20,906
这意味着我不必再分配内存了

679
00:22:21,216 --> 0:22:23,006
我不仅可以把它

680
00:22:23,006 --> 0:22:24,196
设成一个黑色的圆圈

681
00:22:24,196 --> 0:22:25,646
还可以设成蓝色的 红色的 绿色的圆圈

682
00:22:25,646 --> 0:22:26,896
且没有额外的内存占用

683
00:22:27,216 --> 0:22:27,826
这很酷

684
00:22:32,236 --> 0:22:34,136
我们通常对图像做的另一件事是

685
00:22:34,136 --> 0:22:34,876
对它们进行下采样

686
00:22:35,516 --> 0:22:36,936
当我们想要制作

687
00:22:36,936 --> 0:22:38,286
比如缩略图的时候

688
00:22:38,286 --> 0:22:38,866
我们想要缩小它

689
00:22:39,196 --> 0:22:41,426
我们不应该

690
00:22:41,426 --> 0:22:42,836
用 UIImage 进行缩小

691
00:22:42,956 --> 0:22:44,336
如果我们使用 UIImage 绘图

692
00:22:44,336 --> 0:22:46,126
由于内部坐标空间变换

693
00:22:46,126 --> 0:22:48,856
这种方法性能并不高

694
00:22:49,316 --> 0:22:50,946
就像我们之前看到的

695
00:22:50,946 --> 0:22:52,656
它会解压缩内存中的整个图像

696
00:22:53,616 --> 0:22:55,886
取而代之 我们可以使用 ImageIO 框架

697
00:22:56,536 --> 0:22:58,196
ImageIO 可以对图像进行下采样

698
00:22:58,196 --> 0:23:00,036
它使用 Streaming API

699
00:22:58,196 --> 0:23:00,036
它使用 Streaming API

700
00:23:00,036 --> 0:23:03,136
这样你只需为生成图像

701
00:23:03,136 --> 0:23:03,996
使用一些脏内存

702
00:23:04,196 --> 0:23:05,566
这将为你节省一个内存峰值

703
00:23:06,076 --> 0:23:09,126
例如 这里有一些代码

704
00:23:09,196 --> 0:23:10,346
以及我在磁盘上获得的一个文件

705
00:23:10,506 --> 0:23:11,996
也可以是我下载的一个文件

706
00:23:12,916 --> 0:23:16,456
我现在用 UIImage 绘制一个

707
00:23:16,546 --> 0:23:17,696
更小的矩形

708
00:23:18,106 --> 0:23:19,796
仍然会有一个大峰值

709
00:23:21,036 --> 0:23:22,626
如果切换到 ImageIO

710
00:23:22,626 --> 0:23:25,236
我仍然需要从磁盘加载文件

711
00:23:25,896 --> 0:23:27,846
因为它是一个较低级的 API

712
00:23:27,846 --> 0:23:29,476
我设置了一些参数

713
00:23:29,476 --> 0:23:30,936
来表示我希望这个图像有多大

714
00:23:31,186 --> 0:23:33,126
所以我让它用

715
00:23:33,126 --> 0:23:34,206
CGImageSourceCreateThumbnailAtIndex

716
00:23:34,246 --> 0:23:35,346
创建图像

717
00:23:35,916 --> 0:23:37,506
现在 我可以用 UIImage 封装这个 CGImage

718
00:23:37,506 --> 0:23:38,956
并准备好进行下一步了

719
00:23:39,096 --> 0:23:40,246
我有一个小得多的图像

720
00:23:40,526 --> 0:23:43,486
而且比之前的代码快 50%

721
00:23:45,146 --> 0:23:47,086
我们要讨论的

722
00:23:47,086 --> 0:23:48,406
另一件事是

723
00:23:48,406 --> 0:23:49,096
如何进行后台优化

724
00:23:49,946 --> 0:23:53,316
假设我在一个 App 中

725
00:23:53,616 --> 0:23:54,886
有一个全屏的图像 它很美

726
00:23:54,886 --> 0:23:55,446
我很喜欢

727
00:23:55,906 --> 0:23:57,376
但之后 我需要

728
00:23:57,376 --> 0:23:58,706
到我的主屏幕上处理通知

729
00:23:58,706 --> 0:24:00,376
或者转到

730
00:23:58,706 --> 0:24:00,376
或者转到

731
00:24:00,376 --> 0:24:01,316
另一个 App 上

732
00:24:01,986 --> 0:24:03,586
那张图像还在内存中

733
00:24:04,626 --> 0:24:06,806
经验之谈

734
00:24:06,806 --> 0:24:08,486
我们建议你卸载

735
00:24:08,486 --> 0:24:09,826
看不到的大型资源

736
00:24:10,276 --> 0:24:13,756
有两种方法可供选择

737
00:24:13,986 --> 0:24:15,246
第一种是 App 生命周期

738
00:24:15,296 --> 0:24:16,466
如果你把你的 App

739
00:24:16,466 --> 0:24:17,656
放在后台或者前台

740
00:24:17,656 --> 0:24:19,976
App 生命周期事件

741
00:24:19,976 --> 0:24:20,736
可以帮助你了解它

742
00:24:21,686 --> 0:24:22,926
这主要适用于

743
00:24:22,926 --> 0:24:24,486
屏幕上的视图

744
00:24:24,536 --> 0:24:25,316
因为它们不遵循

745
00:24:25,316 --> 0:24:27,106
UIViewController 外观的生命周期

746
00:24:27,756 --> 0:24:28,886
UIViewController 方法

747
00:24:28,886 --> 0:24:30,576
适用于标签控制器

748
00:24:31,476 --> 0:24:32,526
或导航控制器

749
00:24:32,526 --> 0:24:34,446
因为你会有多个视图控制器

750
00:24:34,446 --> 0:24:36,066
但只有一个出现在屏幕上

751
00:24:36,716 --> 0:24:37,486
如果你利用

752
00:24:37,486 --> 0:24:38,296
viewWillAppear 和

753
00:24:38,296 --> 0:24:39,946
viewDidDisappear 的代码或回调

754
00:24:40,176 --> 0:24:41,516
就可以使

755
00:24:41,726 --> 0:24:42,766
内存占用更小

756
00:24:44,036 --> 0:24:46,476
举一个例子

757
00:24:46,476 --> 0:24:48,246
如果我为进入后台的

758
00:24:48,246 --> 0:24:49,466
App 注册通知

759
00:24:49,566 --> 0:24:50,916
我可以卸载我的大型资源

760
00:24:50,916 --> 0:24:52,726
在这里就是图像

761
00:24:53,826 --> 0:24:54,696
当 App 回到前台时

762
00:24:54,696 --> 0:24:56,786
我就会收到通知

763
00:24:57,556 --> 0:24:59,686
如果我在这里重新加载图像

764
00:24:59,856 --> 0:25:00,746
当用户返回时

765
00:24:59,856 --> 0:25:00,746
当用户返回时

766
00:25:00,746 --> 0:25:02,406
我就可以在后台保存内存

767
00:25:02,406 --> 0:25:04,206
并保持同样的保真度

768
00:25:04,396 --> 0:25:05,436
这对他们来说是完全一样的

769
00:25:05,436 --> 0:25:07,226
但是系统有

770
00:25:07,226 --> 0:25:10,476
更多的内存可用

771
00:25:10,476 --> 0:25:12,306
与此类似 如果我在导航控制器

772
00:25:12,306 --> 0:25:14,056
或标签控制器中

773
00:25:14,536 --> 0:25:15,776
我的视图控制器可以

774
00:25:15,776 --> 0:25:17,146
在图像消失时卸载它们

775
00:25:17,746 --> 0:25:18,976
在返回 viewWillAppear() 方法之前

776
00:25:18,976 --> 0:25:21,916
我可以重新加载它们

777
00:25:22,116 --> 0:25:23,076
用户还是不会注意到

778
00:25:23,076 --> 0:25:24,066
有什么不同

779
00:25:24,216 --> 0:25:25,506
我们的 App 如今使用更少的内存

780
00:25:25,506 --> 0:25:26,696
这很好

781
00:25:27,286 --> 0:25:31,176
现在 我想邀请 Kris

782
00:25:31,216 --> 0:25:32,746
用一个很好的演示

783
00:25:32,746 --> 0:25:33,566
向你们展示之前的内容 

784
00:25:34,376 --> 0:25:34,646
Kris

785
00:25:35,516 --> 0:25:39,586
[ 掌声 ]

786
00:25:40,086 --> 0:25:41,436
&gt;&gt; 好的 我现在要

787
00:25:41,436 --> 0:25:42,376
切换到演示机器

788
00:25:43,316 --> 0:25:43,756
我们开始吧

789
00:25:44,116 --> 0:25:45,526
我一直在开发这个 App

790
00:25:45,606 --> 0:25:47,596
这些是我从

791
00:25:47,636 --> 0:25:50,386
NASA 那里得到的

792
00:25:50,796 --> 0:25:52,426
太阳系的高分辨率图像

793
00:25:52,426 --> 0:25:54,056
这个 App 可以让你

794
00:25:54,056 --> 0:25:55,866
对它们应用不同的滤镜

795
00:25:56,406 --> 0:25:57,416
接下来我们会看到一个

796
00:25:57,416 --> 0:26:00,386
简单的例子 在太阳上应用一个滤镜

797
00:25:57,416 --> 0:26:00,386
简单的例子 在太阳上应用一个滤镜

798
00:26:00,996 --> 0:26:02,496
我对目前的进展非常满意

799
00:26:02,496 --> 0:26:04,396
所以我把它发给 James

800
00:26:04,396 --> 0:26:05,926
征求他的意见

801
00:26:05,926 --> 0:26:07,956
他给我回了一封

802
00:26:08,056 --> 0:26:09,146
带有两个附件的邮件

803
00:26:09,826 --> 0:26:12,196
一个附件是 Memgraph 文件

804
00:26:12,196 --> 0:26:13,626
另一个是这个图像

805
00:26:15,776 --> 0:26:19,916
James 是一个相当保守和低调的人

806
00:26:19,916 --> 0:26:21,676
所以当他发送了两个红色的惊叹号

807
00:26:21,676 --> 0:26:23,746
和一个尖叫的表情符号时

808
00:26:23,746 --> 0:26:24,706
我知道他很难过

809
00:26:25,546 --> 0:26:27,156
所以我去找 James

810
00:26:27,516 --> 0:26:28,496
我说 “你知道

811
00:26:28,496 --> 0:26:29,386
我不明白这有什么大不了的

812
00:26:29,736 --> 0:26:31,626
很明显我需要

813
00:26:31,626 --> 0:26:33,026
再使用至少 0.5 GB 

814
00:26:33,086 --> 0:26:34,266
才能出现内存不足的情况

815
00:26:34,266 --> 0:26:35,776
然而我还有一些可用的内存

816
00:26:35,866 --> 0:26:36,796
我难道不能用它吗”

817
00:26:37,826 --> 0:26:39,646
James 一个比我

818
00:26:39,646 --> 0:26:41,016
优秀得多的开发者

819
00:26:41,016 --> 0:26:42,736
他指出了一些

820
00:26:42,736 --> 0:26:43,926
我的逻辑有问题的地方

821
00:26:44,156 --> 0:26:46,976
首先 这个测量计

822
00:26:47,026 --> 0:26:49,926
测量的是一个有 2GB 内存的设备

823
00:26:50,566 --> 0:26:51,866
并不是所有的设备

824
00:26:51,866 --> 0:26:52,406
都有那么多的内存

825
00:26:52,876 --> 0:26:54,106
如果这段代码运行在

826
00:26:54,106 --> 0:26:55,696
只有 1GB 内存的设备上

827
00:26:55,696 --> 0:26:57,306
那么很有可能

828
00:26:57,306 --> 0:27:00,056
我们的 App 已经被操作系统终止了

829
00:26:57,306 --> 0:27:00,056
我们的 App 已经被操作系统终止了

830
00:27:00,866 --> 0:27:04,076
其次 操作系统

831
00:27:04,076 --> 0:27:06,796
在决定何时

832
00:27:06,926 --> 0:27:08,396
终止 App 时

833
00:27:08,396 --> 0:27:09,606
不仅依照你的 App

834
00:27:09,606 --> 0:27:11,176
使用的内存大小

835
00:27:11,176 --> 0:27:13,206
还依照操作系统中的其他内容

836
00:27:13,696 --> 0:27:15,446
所以仅仅因为

837
00:27:15,446 --> 0:27:16,956
我们还没有耗尽内存

838
00:27:16,956 --> 0:27:19,176
并不意味着我们没有被终止的危险

839
00:27:20,076 --> 0:27:22,196
最后 这对用户来说

840
00:27:22,376 --> 0:27:24,076
是一种糟糕的体验

841
00:27:24,636 --> 0:27:25,706
事实上 如果你查看

842
00:27:25,706 --> 0:27:27,736
使用比较图表

843
00:27:27,736 --> 0:27:29,776
你可以看到其他进程的

844
00:27:29,776 --> 0:27:30,856
内存为 0KB

845
00:27:31,496 --> 0:27:32,726
那是因为它们都被

846
00:27:32,726 --> 0:27:33,866
操作系统抛弃了

847
00:27:33,866 --> 0:27:36,906
只是为我们的 App 腾出空间

848
00:27:36,906 --> 0:27:38,266
你们可能都在静静地看着我

849
00:27:38,266 --> 0:27:39,856
然后摆出一个嫌弃的表情

850
00:27:40,376 --> 0:27:41,686
因为当用户想去

851
00:27:41,686 --> 0:27:43,156
看你们的 App 时

852
00:27:43,156 --> 0:27:44,076
它必须从头开始加载

853
00:27:45,246 --> 0:27:47,046
James 说得很有道理

854
00:27:47,046 --> 0:27:48,316
我认为 总的来说

855
00:27:48,316 --> 0:27:49,566
我们应该让这个内存指针

856
00:27:49,566 --> 0:27:51,856
尽可能向左

857
00:27:51,856 --> 0:27:53,216
而不是向右

858
00:27:54,076 --> 0:27:55,766
看看我们能做什么

859
00:27:56,256 --> 0:27:57,496
让我先来看看

860
00:27:57,496 --> 0:27:58,706
Memgraph 文件

861
00:27:59,266 --> 0:28:03,496
我有一些

862
00:27:59,266 --> 0:28:03,496
我有一些

863
00:28:04,286 --> 0:28:06,686
在使用 Memgraph 文件

864
00:28:06,686 --> 0:28:08,216
的日常技巧

865
00:28:08,216 --> 0:28:08,946
或者说是策略

866
00:28:09,426 --> 0:28:10,756
第一个

867
00:28:10,856 --> 0:28:12,636
我需要把它向上拖动一下

868
00:28:13,076 --> 0:28:14,846
就是寻找泄漏

869
00:28:15,406 --> 0:28:18,286
如果我前往过滤器工具栏

870
00:28:18,286 --> 0:28:19,846
轻点泄漏过滤器

871
00:28:19,846 --> 0:28:22,106
它就会显示 Memgraph 文件中的

872
00:28:22,106 --> 0:28:23,736
每一个泄漏

873
00:28:24,666 --> 0:28:27,746
这个 Memgraph 文件没有泄漏

874
00:28:27,986 --> 0:28:29,526
这既是好消息

875
00:28:29,526 --> 0:28:30,656
又是坏消息

876
00:28:31,136 --> 0:28:32,136
好处在于 没有泄漏

877
00:28:32,136 --> 0:28:33,516
但现在我得弄清楚

878
00:28:33,516 --> 0:28:35,046
到底发生了什么

879
00:28:35,906 --> 0:28:37,746
Memgraph 的

880
00:28:37,746 --> 0:28:40,046
另一个好处是

881
00:28:40,046 --> 0:28:41,926
告诉我一个对象

882
00:28:41,926 --> 0:28:43,036
在内存中有多少个实例

883
00:28:43,036 --> 0:28:44,226
以及是否比我预期的要多

884
00:28:44,876 --> 0:28:46,166
当我查看这个 Memgraph 文件时

885
00:28:46,166 --> 0:28:47,476
如果我特意关注

886
00:28:47,476 --> 0:28:49,136
代码中的对象

887
00:28:49,136 --> 0:28:52,146
就可以看到

888
00:28:52,146 --> 0:28:53,966
内存中只有 5 个对象

889
00:28:53,966 --> 0:28:55,526
且每种都只有 1 个

890
00:28:56,136 --> 0:28:57,266
如果内存中

891
00:28:57,266 --> 0:28:59,066
有多个 RootViewController

892
00:28:59,336 --> 0:29:01,586
多个 NoirFilter

893
00:28:59,336 --> 0:29:01,586
多个 NoirFilter

894
00:29:01,586 --> 0:29:03,366
多个滤镜

895
00:29:03,366 --> 0:29:04,676
或其他预料之外的对象

896
00:29:04,676 --> 0:29:05,716
那些就是我可以调查的东西

897
00:29:06,496 --> 0:29:09,736
这里的实例数量

898
00:29:09,736 --> 0:29:10,816
在我的预料内

899
00:29:10,816 --> 0:29:12,076
但也许其中存在一个很大的实例

900
00:29:12,186 --> 0:29:13,726
尽管不太可能

901
00:29:13,726 --> 0:29:14,366
我还是得检查一下

902
00:29:14,566 --> 0:29:17,386
所以我需要使用内存检查器

903
00:29:17,386 --> 0:29:18,206
我要看看这些

904
00:29:18,286 --> 0:29:19,576
它们中的每一个

905
00:29:19,576 --> 0:29:20,666
都列出了每个对象的大小

906
00:29:21,016 --> 0:29:23,486
我可以看到我的 AppDelegate 是 32 字节

907
00:29:23,966 --> 0:29:25,796
DataViewController 是 1500 字节

908
00:29:26,216 --> 0:29:27,556
当我浏览每一个的时候

909
00:29:28,506 --> 0:29:30,056
没有一个明显地占用了

910
00:29:30,056 --> 0:29:33,596
我的 App 正在使用的

911
00:29:33,596 --> 0:29:36,436
1GB 多的内存

912
00:29:37,096 --> 0:29:38,766
这就是我在 Xcode 中

913
00:29:38,766 --> 0:29:40,936
处理 Memgraph 的技巧

914
00:29:41,466 --> 0:29:42,436
我接下来要做什么

915
00:29:43,256 --> 0:29:45,106
我刚刚看了这个

916
00:29:45,356 --> 0:29:48,236
关于在 Memgraph 文件中

917
00:29:48,366 --> 0:29:50,646
使用命令行工具的 WWDC 讨论会

918
00:29:51,516 --> 0:29:53,276
让我来试试

919
00:29:53,276 --> 0:29:55,876
能不能找到什么

920
00:29:55,876 --> 0:29:57,236
回想起来

921
00:29:57,236 --> 0:29:59,036
James 提出的第一件事

922
00:29:59,036 --> 0:30:01,636
就是使用 vmmap 的 -summary 参数

923
00:29:59,036 --> 0:30:01,636
就是使用 vmmap 的 -summary 参数

924
00:30:02,846 --> 0:30:04,196
所以我来试试

925
00:30:04,386 --> 0:30:06,816
传入 Memgraph 文件

926
00:30:06,886 --> 0:30:10,696
我们来看看这个输出

927
00:30:11,756 --> 0:30:13,016
现在 我应该在这里

928
00:30:13,016 --> 0:30:13,706
寻找什么呢

929
00:30:14,476 --> 0:30:15,716
总的来说

930
00:30:15,716 --> 0:30:16,776
我在寻找非常大的数字

931
00:30:16,776 --> 0:30:17,846
我想弄清楚

932
00:30:17,846 --> 0:30:19,196
是什么在使用这些内存

933
00:30:19,196 --> 0:30:20,946
大的数字意味着更多的内存使用

934
00:30:21,566 --> 0:30:25,876
这里有很多列

935
00:30:25,876 --> 0:30:27,196
有些列比其他列更重要

936
00:30:27,806 --> 0:30:30,166
首先 “VIRTUAL SIZE（虚拟内存大小）”

937
00:30:30,166 --> 0:30:32,226
虚拟意味着不是实际的

938
00:30:32,516 --> 0:30:34,846
我几乎可以忽略这一列

939
00:30:34,916 --> 0:30:36,246
它是 App 所需的内存

940
00:30:36,246 --> 0:30:38,056
但不一定要使用

941
00:30:38,736 --> 0:30:40,356
脏内存听起来像是

942
00:30:40,356 --> 0:30:42,036
我绝对不希望在 App 里存在的东西

943
00:30:42,546 --> 0:30:44,466
我希望我的 App 是干净的

944
00:30:44,466 --> 0:30:45,896
而不是脏的

945
00:30:45,896 --> 0:30:46,916
所以我想要这个数字尽量小

946
00:30:47,356 --> 0:30:48,416
然后交换内存

947
00:30:48,446 --> 0:30:49,456
因为我们谈的是 iOS 

948
00:30:49,456 --> 0:30:52,316
所以指的是压缩内存

949
00:30:52,316 --> 0:30:55,156
正如 Kyle 和 James 之前提到的

950
00:30:55,236 --> 0:30:57,386
操作系统凭借

951
00:30:57,386 --> 0:30:59,606
脏内存大小

952
00:30:59,606 --> 0:31:00,816
加上压缩内存大小的总和

953
00:30:59,606 --> 0:31:00,816
加上压缩内存大小的总和

954
00:31:00,816 --> 0:31:02,586
来确定我的 App 实际

955
00:31:02,586 --> 0:31:03,726
实际使用了多少内存

956
00:31:04,266 --> 0:31:05,516
所以这就是我想要

957
00:31:05,516 --> 0:31:06,796
关注的两列

958
00:31:06,796 --> 0:31:08,596
我们再来看一些较大的数字

959
00:31:08,596 --> 0:31:11,636
我马上就看到了 “CG image” 非常显眼

960
00:31:11,636 --> 0:31:13,996
它占用了非常多的

961
00:31:13,996 --> 0:31:15,206
脏内存和交换内存

962
00:31:15,256 --> 0:31:16,906
这是一个危险信号

963
00:31:16,956 --> 0:31:17,846
让我们继续观察

964
00:31:18,496 --> 0:31:21,616
我可以看到

965
00:31:21,616 --> 0:31:23,676
“IOSurface” 占用了很多的 脏内存

966
00:31:23,676 --> 0:31:24,686
但不占用交换内存

967
00:31:25,156 --> 0:31:29,876
“MALLOC_LARGE” 占用了很多脏内存

968
00:31:30,146 --> 0:31:31,256
但占用较少的交换内存

969
00:31:31,256 --> 0:31:33,396
之后就没有

970
00:31:33,396 --> 0:31:35,056
这么大的数字了

971
00:31:35,576 --> 0:31:37,696
基于我在这里看到的

972
00:31:37,696 --> 0:31:39,036
我认为我应该集中处理

973
00:31:39,036 --> 0:31:42,376
CG image 的虚拟内存区域

974
00:31:43,096 --> 0:31:44,606
让我们把它复制下来

975
00:31:45,586 --> 0:31:47,426
下一步该是什么呢

976
00:31:48,096 --> 0:31:50,266
我们想要了解更多

977
00:31:50,266 --> 0:31:52,326
关于虚拟内存的信息

978
00:31:52,326 --> 0:31:53,986
所以 vmmap 似乎还是我们要用的工具

979
00:31:54,636 --> 0:31:55,616
这次我将不再

980
00:31:55,616 --> 0:31:57,216
使用 -summary 参数

981
00:31:57,216 --> 0:32:00,376
而是传递我的 Memgraph 文件

982
00:31:57,216 --> 0:32:00,376
而是传递我的 Memgraph 文件

983
00:32:01,266 --> 0:32:02,806
但我只关心

984
00:32:02,896 --> 0:32:04,126
“CG image” 的内存

985
00:32:04,336 --> 0:32:05,936
并不关心 vmmap

986
00:32:05,936 --> 0:32:09,186
会告诉我的其他

987
00:32:09,186 --> 0:32:10,516
虚拟内存区域

988
00:32:10,516 --> 0:32:12,026
所以我应该使用 “grep”

989
00:32:12,026 --> 0:32:15,876
只向我展示

990
00:32:15,906 --> 0:32:17,736
关于 “CG image” 的行

991
00:32:18,016 --> 0:32:19,116
让我们看看会发生什么

992
00:32:20,016 --> 0:32:21,336
现在 我有三行信息

993
00:32:21,646 --> 0:32:25,096
我可以看到 有两个虚拟内存区域

994
00:32:25,426 --> 0:32:26,646
在那里我可以看到

995
00:32:26,646 --> 0:32:28,576
它们的起始地址和终止地址

996
00:32:28,906 --> 0:32:30,416
然后我可以看到

997
00:32:30,416 --> 0:32:31,636
和之前相同的列

998
00:32:31,636 --> 0:32:34,006
分别是虚拟内存 常驻内存

999
00:32:34,516 --> 0:32:36,066
脏内存和压缩内存

1000
00:32:36,686 --> 0:32:37,736
这里显示的最后一行

1001
00:32:37,736 --> 0:32:39,586
是总结行

1002
00:32:40,536 --> 0:32:43,666
也就是和上面一样的数据

1003
00:32:44,506 --> 0:32:45,966
看看这两个区域

1004
00:32:45,966 --> 0:32:47,616
我有一个很小的区域

1005
00:32:47,696 --> 0:32:49,026
和一个很大的区域

1006
00:32:49,416 --> 0:32:50,986
我显然更想了解

1007
00:32:50,986 --> 0:32:53,706
这个大一点的区域

1008
00:32:53,906 --> 0:32:55,876
那么我怎样才能找到

1009
00:32:55,876 --> 0:32:58,286
更多关于这个虚拟内存区域的信息呢

1010
00:32:58,936 --> 0:33:00,366
我查看了

1011
00:32:58,936 --> 0:33:00,366
我查看了

1012
00:33:00,366 --> 0:33:02,286
vmmap 的文档

1013
00:33:02,286 --> 0:33:03,746
然后注意到一个 -verbose 参数

1014
00:33:03,746 --> 0:33:05,786
顾名思义

1015
00:33:05,786 --> 0:33:08,506
它会输出更多的信息

1016
00:33:08,806 --> 0:33:10,446
我想知道它能告诉我什么

1017
00:33:11,486 --> 0:33:12,676
让我们继续

1018
00:33:12,706 --> 0:33:16,186
传入 -verbose 和 Memgraph 文件

1019
00:33:17,536 --> 0:33:21,266
同样 我只关心 “CG image” 区域

1020
00:33:22,306 --> 0:33:24,226
所以我用 “grep”

1021
00:33:24,226 --> 0:33:25,946
来进行过滤

1022
00:33:26,886 --> 0:33:28,396
现在我看到了

1023
00:33:28,396 --> 0:33:29,616
更多的区域

1024
00:33:30,156 --> 0:33:31,116
为什么会这样

1025
00:33:31,826 --> 0:33:33,576
默认情况下 

1026
00:33:33,576 --> 0:33:35,166
如果 vmmap 找到连续的区域

1027
00:33:35,256 --> 0:33:37,686
它会把它们

1028
00:33:37,686 --> 0:33:38,466
合并在一起

1029
00:33:38,856 --> 0:33:39,896
实际上

1030
00:33:39,896 --> 0:33:41,276
如果你从第二行开始看

1031
00:33:41,276 --> 0:33:43,346
这个区域的终止地址

1032
00:33:43,346 --> 0:33:44,596
和这个区域的起始地址

1033
00:33:44,596 --> 0:33:46,106
是一样的

1034
00:33:46,426 --> 0:33:48,496
下面也一样

1035
00:33:48,966 --> 0:33:51,076
因此 vmmap 在默认情况下

1036
00:33:51,076 --> 0:33:52,426
将其折叠成一个区域

1037
00:33:52,886 --> 0:33:54,086
但是看看这里的细节

1038
00:33:54,086 --> 0:33:54,976
却能发现一些

1039
00:33:54,976 --> 0:33:55,776
不同之处

1040
00:33:55,836 --> 0:33:57,746
特别是其中一些区域

1041
00:33:57,746 --> 0:34:00,826
使用了更多的 脏内存

1042
00:33:57,746 --> 0:34:00,826
使用了更多的 脏内存

1043
00:34:00,826 --> 0:34:02,016
而另一些使用了更多的压缩内存

1044
00:34:02,016 --> 0:34:04,426
这就会帮助我找到

1045
00:34:04,426 --> 0:34:06,126
应该关注的地方

1046
00:34:06,126 --> 0:34:07,626
但这里我要用

1047
00:34:07,626 --> 0:34:08,786
另一种策略

1048
00:34:09,216 --> 0:34:10,775
我知道 操作系统中

1049
00:34:10,775 --> 0:34:14,266
虽然不一定 但一般来说

1050
00:34:14,266 --> 0:34:17,076
虚拟内存区域创建得越晚

1051
00:34:17,166 --> 0:34:19,696
在 App 生命周期中

1052
00:34:19,846 --> 0:34:21,565
它发生得就越晚

1053
00:34:22,136 --> 0:34:23,466
由于这个 Memgraph 文件

1054
00:34:23,466 --> 0:34:25,576
是在内存使用峰值时获取的

1055
00:34:25,576 --> 0:34:27,596
所以很有可能

1056
00:34:27,666 --> 0:34:29,775
这些后面的区域

1057
00:34:29,896 --> 0:34:31,775
与导致峰值的原因更有关联

1058
00:34:32,426 --> 0:34:33,686
所以我不想寻找

1059
00:34:33,686 --> 0:34:35,295
最大的 脏内存

1060
00:34:35,295 --> 0:34:36,565
和压缩内存数字

1061
00:34:36,565 --> 0:34:38,056
而是要从底部这里开始

1062
00:34:38,676 --> 0:34:40,666
我要获取最后一个区域

1063
00:34:40,666 --> 0:34:42,406
的起始地址

1064
00:34:43,166 --> 0:34:44,786
我该怎么做呢

1065
00:34:45,366 --> 0:34:47,755
James 提到的一个工具是 heap

1066
00:34:47,755 --> 0:34:50,815
但它作用于堆上的对象

1067
00:34:50,815 --> 0:34:51,856
而我正在处理一个

1068
00:34:51,856 --> 0:34:53,196
虚拟内存区域

1069
00:34:53,196 --> 0:34:56,366
所以它并不适用

1070
00:34:56,366 --> 0:34:58,436
还有 leaks 工具

1071
00:34:58,436 --> 0:34:59,516
但是我这里并没有泄漏

1072
00:34:59,516 --> 0:35:00,466
我已经从 Memgraph 中

1073
00:34:59,516 --> 0:35:00,466
我已经从 Memgraph 中

1074
00:35:00,466 --> 0:35:01,796
知道了这里没有泄漏

1075
00:35:02,096 --> 0:35:03,346
所以它看起来不像是

1076
00:35:03,346 --> 0:35:04,276
我可以使用的工具

1077
00:35:04,696 --> 0:35:06,636
但是我查看了

1078
00:35:06,776 --> 0:35:09,896
关于 leaks 的帮助信息

1079
00:35:09,896 --> 0:35:11,466
发现 leaks 可以做很多事情

1080
00:35:11,466 --> 0:35:14,016
包括告诉我

1081
00:35:14,016 --> 0:35:16,296
哪些对堆上的对象

1082
00:35:16,296 --> 0:35:18,736
或虚拟内存区域有引用

1083
00:35:19,226 --> 0:35:20,236
我们来看看

1084
00:35:20,236 --> 0:35:21,016
它会告诉我们什么

1085
00:35:21,696 --> 0:35:23,556
我将使用 leaks

1086
00:35:23,556 --> 0:35:25,746
然后传递

1087
00:35:25,806 --> 0:35:27,326
-traceTree 参数

1088
00:35:27,986 --> 0:35:29,146
它的作用是

1089
00:35:29,146 --> 0:35:32,056
给了我一个树形视图

1090
00:35:32,056 --> 0:35:33,556
可以涵盖所有

1091
00:35:33,556 --> 0:35:34,826
与我要传入的地址有关的东西

1092
00:35:34,826 --> 0:35:36,916
在这个例子中 我传入的是

1093
00:35:36,916 --> 0:35:39,786
虚拟内存区域的

1094
00:35:39,786 --> 0:35:41,886
起始地址

1095
00:35:42,446 --> 0:35:44,006
最后我们提供

1096
00:35:44,006 --> 0:35:44,956
这个 Memgraph 文件

1097
00:35:45,906 --> 0:35:47,276
它会是什么样子呢

1098
00:35:47,466 --> 0:35:49,526
这里我们能看到

1099
00:35:49,636 --> 0:35:50,936
所有引用的树

1100
00:35:50,936 --> 0:35:52,136
如果我们向上滚动到顶部

1101
00:35:53,196 --> 0:35:55,076
在这里 我可以看到

1102
00:35:55,076 --> 0:35:56,746
这是我的虚拟内存区域

1103
00:35:56,746 --> 0:35:58,716
这是我的 “CG image” 区域

1104
00:35:58,716 --> 0:35:59,856
然后我可以看到

1105
00:35:59,856 --> 0:36:02,346
这个树视图

1106
00:35:59,856 --> 0:36:02,346
这个树视图

1107
00:36:02,346 --> 0:36:03,336
包含了所有具有引用的东西

1108
00:36:03,336 --> 0:36:04,676
以及引用它们的东西

1109
00:36:04,676 --> 0:36:06,006
以及引用这些东西的东西

1110
00:36:06,006 --> 0:36:06,616
等等等等

1111
00:36:06,616 --> 0:36:08,646
如果我们回到 Xcode

1112
00:36:08,646 --> 0:36:11,026
我们实际上过滤了

1113
00:36:11,026 --> 0:36:14,066
相同的地址

1114
00:36:14,066 --> 0:36:16,766
我来看看这个对象

1115
00:36:16,766 --> 0:36:18,406
这个树视图和我从 leaks 中

1116
00:36:18,406 --> 0:36:19,246
看到的一样

1117
00:36:19,436 --> 0:36:20,626
如果我想的话

1118
00:36:20,626 --> 0:36:22,146
我可以沿着树走下去

1119
00:36:22,146 --> 0:36:23,876
并展开每一个节点

1120
00:36:23,876 --> 0:36:25,436
看看每个节点的细节

1121
00:36:25,436 --> 0:36:26,946
但是这需要一段时间

1122
00:36:26,946 --> 0:36:28,306
而且有点乏味

1123
00:36:28,386 --> 0:36:29,986
leaks 的输出的优点是

1124
00:36:29,986 --> 0:36:32,566
我不仅可以

1125
00:36:32,566 --> 0:36:33,946
快速浏览它

1126
00:36:33,946 --> 0:36:36,296
还可以随意搜索或筛选

1127
00:36:36,296 --> 0:36:37,736
或者我可以把它放进

1128
00:36:37,736 --> 0:36:39,676
一个 Bug 报告或电子邮件中

1129
00:36:39,676 --> 0:36:40,786
然而我却不能对 Xcode 中的图形视图

1130
00:36:40,786 --> 0:36:42,786
进行上述的操作

1131
00:36:43,686 --> 0:36:44,996
那么在这个 leaks 的输出中

1132
00:36:44,996 --> 0:36:45,536
我要找什么呢

1133
00:36:46,116 --> 0:36:48,286
理想情况下

1134
00:36:48,286 --> 0:36:49,876
我会找到一个

1135
00:36:49,876 --> 0:36:51,326
我负责的类

1136
00:36:51,326 --> 0:36:52,146
一个来自我的 App 的类

1137
00:36:52,306 --> 0:36:54,066
我之前看过这个

1138
00:36:54,066 --> 0:36:55,106
我知道这里

1139
00:36:55,106 --> 0:36:56,846
没有我的类

1140
00:36:56,846 --> 0:36:57,976
那么我还能找到什么呢

1141
00:36:58,376 --> 0:37:00,236
我正在创建的类

1142
00:36:58,376 --> 0:37:00,236
我正在创建的类

1143
00:37:00,236 --> 0:37:01,566
比如一个框架类

1144
00:37:01,566 --> 0:37:02,766
它也许是以我的名义创建的

1145
00:37:02,766 --> 0:37:04,156
也可能是我

1146
00:37:04,206 --> 0:37:05,186
直接创建的

1147
00:37:05,596 --> 0:37:08,276
我知道我的 App 有 UIViews

1148
00:37:08,276 --> 0:37:09,156
它有 UIImages

1149
00:37:09,156 --> 0:37:11,966
我可以用这些 Core Image 类

1150
00:37:12,156 --> 0:37:13,926
来进行过滤

1151
00:37:13,926 --> 0:37:15,516
我们继续看这里

1152
00:37:15,606 --> 0:37:18,866
我用的是一个非常复杂的 

1153
00:37:18,866 --> 0:37:20,716
叫做 “My Eyeballs” 的调试工具

1154
00:37:21,566 --> 0:37:23,576
我们继续寻找

1155
00:37:23,786 --> 0:37:29,346
我看看能不能找到我想要的

1156
00:37:29,836 --> 0:37:32,576
这是一个很大的终端输出

1157
00:37:32,826 --> 0:37:34,356
所以让人更加困惑

1158
00:37:35,116 --> 0:37:36,686
举个例子

1159
00:37:36,686 --> 0:37:38,376
这里有一个字体引用

1160
00:37:38,376 --> 0:37:39,546
我知道我的 App

1161
00:37:39,546 --> 0:37:42,196
使用字体

1162
00:37:42,196 --> 0:37:44,706
但是字体并不会导致

1163
00:37:44,706 --> 0:37:46,156
很多的内存使用

1164
00:37:46,156 --> 0:37:47,886
所以它没有帮助

1165
00:37:47,886 --> 0:37:49,126
我们再往下看

1166
00:37:49,126 --> 0:37:51,476
我可以看到有很多

1167
00:37:51,476 --> 0:37:54,976
这样的 CI 类

1168
00:37:54,976 --> 0:37:56,346
它们是 Core Image 滤镜

1169
00:37:56,346 --> 0:37:57,666
或者是 Core Image 

1170
00:37:57,666 --> 0:37:58,926
在我的 App 中

1171
00:37:58,926 --> 0:38:00,346
起滤镜作用的东西

1172
00:37:58,926 --> 0:38:00,346
起滤镜作用的东西

1173
00:38:00,746 --> 0:38:02,076
它也许也是我该

1174
00:38:02,076 --> 0:38:04,036
进一步研究的东西

1175
00:38:04,036 --> 0:38:05,406
我已经做了

1176
00:38:05,406 --> 0:38:08,906
但没有发现任何有用的东西

1177
00:38:09,296 --> 0:38:11,286
我无法进一步研究

1178
00:38:11,286 --> 0:38:13,006
leaks 的输出

1179
00:38:13,216 --> 0:38:15,566
这很不幸

1180
00:38:15,666 --> 0:38:17,976
接下来我该做什么呢

1181
00:38:18,826 --> 0:38:21,716
幸运的是

1182
00:38:23,106 --> 0:38:25,536
James 在捕获

1183
00:38:25,536 --> 0:38:26,456
这个 Memgraph 时

1184
00:38:26,456 --> 0:38:29,736
打开了配置内存的回溯记录

1185
00:38:29,736 --> 0:38:31,366
这意味着我可以使用

1186
00:38:31,366 --> 0:38:33,336
他谈到的另一个工具

1187
00:38:33,336 --> 0:38:36,896
来查看对象的创建回溯

1188
00:38:36,896 --> 0:38:38,566
我将使用 malloc_history

1189
00:38:40,096 --> 0:38:42,206
这一次 我先传入

1190
00:38:42,206 --> 0:38:43,866
Memgraph 文件

1191
00:38:44,136 --> 0:38:48,836
然后再传入这个从帮助文档中获知的

1192
00:38:48,836 --> 0:38:50,256
-fullStacks 参数

1193
00:38:51,046 --> 0:38:52,546
它的功能就是

1194
00:38:52,546 --> 0:38:55,216
使每一帧都在它自己的行上显示

1195
00:38:55,216 --> 0:38:56,646
这样让人更容易阅读

1196
00:38:57,096 --> 0:38:58,366
然后我将传递

1197
00:38:58,556 --> 0:39:00,156
虚拟内存区域的

1198
00:38:58,556 --> 0:39:00,156
虚拟内存区域的

1199
00:39:00,156 --> 0:39:01,096
起始内存地址

1200
00:39:01,806 --> 0:39:02,856
让我们看看是什么样子

1201
00:39:04,036 --> 0:39:05,386
实际上这并不是一个

1202
00:39:05,386 --> 0:39:06,566
很大的回溯

1203
00:39:06,566 --> 0:39:09,066
我可以看到我的代码

1204
00:39:09,066 --> 0:39:10,126
出现在这里的几行

1205
00:39:10,576 --> 0:39:12,676
第 6 行到第 9 行

1206
00:39:12,676 --> 0:39:14,106
实际上来自我的 App 代码

1207
00:39:14,106 --> 0:39:16,066
我可以在第 6 行看到

1208
00:39:16,066 --> 0:39:19,046
NoirFilter.apply() 函数

1209
00:39:19,046 --> 0:39:21,186
负责创建

1210
00:39:21,186 --> 0:39:24,486
这个特定的虚拟内存区域

1211
00:39:24,996 --> 0:39:27,626
这是一个很好的证据

1212
00:39:27,626 --> 0:39:28,826
展示了我如何在 App 中

1213
00:39:28,826 --> 0:39:31,216
找到造成这些内存使用的东西

1214
00:39:31,746 --> 0:39:34,806
如果我们回到 Memgraph 文件

1215
00:39:34,806 --> 0:39:36,586
就可以发现这和 Xcode 中

1216
00:39:36,586 --> 0:39:38,626
出现的回溯是一样的

1217
00:39:39,186 --> 0:39:40,446
你可以看到这里

1218
00:39:40,446 --> 0:39:42,526
也是 NoirFilter.apply() 方法

1219
00:39:42,886 --> 0:39:44,046
我们没有像

1220
00:39:44,046 --> 0:39:45,646
通常在回溯视图中看到的那样

1221
00:39:45,646 --> 0:39:47,176
得到很好的高亮显示

1222
00:39:47,176 --> 0:39:48,796
因为我们没有调试一个活动进程

1223
00:39:48,796 --> 0:39:50,116
我们正在加载一个 Memgraph 文件

1224
00:39:50,526 --> 0:39:51,686
但是你可以看到它的输出

1225
00:39:51,686 --> 0:39:52,796
和我们从 malloc_history 中得到的输出

1226
00:39:52,796 --> 0:39:53,566
是完全一样的

1227
00:39:53,926 --> 0:39:57,786
事实上

1228
00:39:57,986 --> 0:39:59,616
为了进一步确认

1229
00:39:59,616 --> 0:40:02,036
我需要查看

1230
00:39:59,616 --> 0:40:02,036
我需要查看

1231
00:40:02,136 --> 0:40:05,956
“CG image” 虚拟内存区域的完整列表

1232
00:40:05,956 --> 0:40:09,066
接下来我选取了

1233
00:40:09,066 --> 0:40:10,156
倒数第二个

1234
00:40:10,156 --> 0:40:11,916
我们来看看

1235
00:40:11,916 --> 0:40:13,176
这个区域的回溯

1236
00:40:15,146 --> 0:40:17,326
结果是相同的回溯

1237
00:40:17,526 --> 0:40:18,896
同样的代码路径

1238
00:40:18,896 --> 0:40:20,496
也指向这个区域

1239
00:40:20,966 --> 0:40:23,486
如果继续观察

1240
00:40:23,486 --> 0:40:24,976
其中的几个区域

1241
00:40:24,976 --> 0:40:26,276
实际上仍使用了相同的回溯

1242
00:40:26,766 --> 0:40:27,886
这样我就明白了

1243
00:40:27,886 --> 0:40:30,086
在我的 App 中

1244
00:40:30,086 --> 0:40:32,326
是什么创建了这些

1245
00:40:32,326 --> 0:40:33,636
占用了 App 中

1246
00:40:33,636 --> 0:40:34,896
大量内存的

1247
00:40:34,896 --> 0:40:35,776
虚拟内存区域

1248
00:40:36,706 --> 0:40:37,836
那么我们能做些什么呢

1249
00:40:38,636 --> 0:40:40,186
让我们回到 Xcode

1250
00:40:40,186 --> 0:40:42,276
我现在可以关闭 Memgraph 文件

1251
00:40:43,396 --> 0:40:46,196
我要做的第一件事是

1252
00:40:46,196 --> 0:40:47,626
看看这里的代码

1253
00:40:48,406 --> 0:40:52,536
如果看看与我的滤镜相关的代码

1254
00:40:52,536 --> 0:40:54,436
我可以看到这里是 apply() 函数

1255
00:40:54,436 --> 0:40:55,926
我可以马上看到

1256
00:40:55,926 --> 0:40:57,026
一些东西跳出来

1257
00:40:57,026 --> 0:40:58,776
它们是我正在使用的

1258
00:40:58,776 --> 0:41:02,886
UIGraphicsBeginImageContextWithOptions

1259
00:40:58,776 --> 0:41:02,886
UIGraphicsBeginImageContextWithOptions

1260
00:41:02,886 --> 0:41:04,866
以及 UIGraphicsEndImageContext

1261
00:41:04,866 --> 0:41:06,086
我记得 Kyle 说过

1262
00:41:06,086 --> 0:41:06,846
你们不应该使用它

1263
00:41:06,846 --> 0:41:08,986
在那些情况下有更好的 API 可以使用

1264
00:41:09,346 --> 0:41:10,946
这是我肯定想要

1265
00:41:10,946 --> 0:41:12,386
再次讨论的内容

1266
00:41:12,386 --> 0:41:13,606
但我首先需要的

1267
00:41:13,606 --> 0:41:14,576
是某种基线

1268
00:41:14,576 --> 0:41:15,716
我需要知道

1269
00:41:15,716 --> 0:41:17,736
我的 App 使用了多少内存

1270
00:41:17,736 --> 0:41:18,886
这样我就可以确保我的更改

1271
00:41:18,886 --> 0:41:19,826
能让结果变得不同

1272
00:41:20,496 --> 0:41:21,726
我要运行

1273
00:41:21,726 --> 0:41:24,566
我的 App

1274
00:41:24,566 --> 0:41:26,786
然后找到调试导航器

1275
00:41:26,786 --> 0:41:28,456
查看内存报告

1276
00:41:28,626 --> 0:41:30,896
现在 我可以看到我的 App

1277
00:41:30,896 --> 0:41:32,566
在运行时使用的内存

1278
00:41:33,366 --> 0:41:35,946
我真的很喜欢这个

1279
00:41:35,946 --> 0:41:37,266
土星北极的图像

1280
00:41:37,836 --> 0:41:39,766
它是一个奇怪的六边形

1281
00:41:39,836 --> 0:41:41,346
炫酷的同时

1282
00:41:41,346 --> 0:41:42,356
又有点古怪

1283
00:41:42,816 --> 0:41:44,326
我们来看看这个

1284
00:41:44,326 --> 0:41:45,996
应用这个滤镜

1285
00:41:45,996 --> 0:41:46,716
然后看看会得到什么

1286
00:41:47,706 --> 0:41:51,336
1GB 3GB 4GB

1287
00:41:51,336 --> 0:41:52,576
6GB 7GB

1288
00:41:53,156 --> 0:41:54,706
这可不太好

1289
00:41:54,856 --> 0:41:58,636
不过可以

1290
00:41:58,636 --> 0:41:59,846
很好地告诉我们

1291
00:41:59,946 --> 0:42:02,006
它根本不会在设备上流畅运行

1292
00:41:59,946 --> 0:42:02,006
它根本不会在设备上流畅运行

1293
00:42:02,336 --> 0:42:03,186
所以当你在模拟器中运行时

1294
00:42:03,186 --> 0:42:04,586
你必须记住

1295
00:42:04,586 --> 0:42:06,036
它对于调试和

1296
00:42:06,036 --> 0:42:07,226
测试变更很有用

1297
00:42:07,226 --> 0:42:08,706
但是你也需要在设备上

1298
00:42:08,706 --> 0:42:09,796
验证所有的东西

1299
00:42:09,796 --> 0:42:11,206
但同时 另一件好事是

1300
00:42:11,206 --> 0:42:13,976
模拟器永远不会耗尽内存

1301
00:42:14,276 --> 0:42:15,616
如果我遇到了 App 在设备上

1302
00:42:15,616 --> 0:42:16,736
被关闭的情况

1303
00:42:16,736 --> 0:42:18,876
可以在模拟器中试试

1304
00:42:19,106 --> 0:42:20,296
我可以等待一个

1305
00:42:20,296 --> 0:42:21,836
非常大的分配

1306
00:42:21,836 --> 0:42:23,476
而不会被关闭

1307
00:42:23,476 --> 0:42:24,946
然后从那里进行调查

1308
00:42:25,666 --> 0:42:26,716
我想指出的一点是

1309
00:42:26,716 --> 0:42:28,786
我们其实给你们看了

1310
00:42:28,786 --> 0:42:31,336
这里标志的内存峰值

1311
00:42:31,336 --> 0:42:34,406
在这个例子中 我最多使用了 7.7GB

1312
00:42:35,226 --> 0:42:35,816
这很糟糕

1313
00:42:36,636 --> 0:42:39,126
我们来看看能做些什么

1314
00:42:39,226 --> 0:42:43,706
回到我的 apply() 函数

1315
00:42:44,326 --> 0:42:46,386
现在

1316
00:42:46,386 --> 0:42:47,026
我想使用这个

1317
00:42:47,026 --> 0:42:48,396
beginImageContextWithOptions

1318
00:42:48,396 --> 0:42:50,086
但是回想一下 Kyle 说过的

1319
00:42:50,086 --> 0:42:52,046
当你处理图像时

1320
00:42:52,046 --> 0:42:54,296
内存使用中

1321
00:42:54,296 --> 0:42:56,236
最重要的是什么

1322
00:42:56,696 --> 0:42:58,986
是图像的尺寸

1323
00:42:58,986 --> 0:43:00,446
让我们看看它是什么样子

1324
00:42:58,986 --> 0:43:00,446
让我们看看它是什么样子

1325
00:43:00,446 --> 0:43:03,056
我要再次

1326
00:43:03,056 --> 0:43:04,176
使用这个滤镜

1327
00:43:04,536 --> 0:43:07,896
我在调试器中停止时

1328
00:43:07,896 --> 0:43:11,936
就可以看到

1329
00:43:11,936 --> 0:43:14,476
这个图像的尺寸

1330
00:43:14,546 --> 0:43:15,556
在我按回车

1331
00:43:15,836 --> 0:43:19,516
我要先喝一小口水

1332
00:43:19,586 --> 0:43:22,836
我其实并不想喝水

1333
00:43:24,646 --> 0:43:27,466
它是 15000*13000

1334
00:43:27,986 --> 0:43:29,876
我检查过文档

1335
00:43:29,956 --> 0:43:32,196
在 UIImage 上

1336
00:43:32,476 --> 0:43:33,766
那是点（pt） 不是像素（px）

1337
00:43:33,766 --> 0:43:36,656
如果这是 2X 设备

1338
00:43:36,656 --> 0:43:38,896
或 3X 设备

1339
00:43:38,896 --> 0:43:40,906
你必须把它乘以一个很大的数字

1340
00:43:41,446 --> 0:43:43,026
Kyle 会很生气

1341
00:43:43,026 --> 0:43:44,846
因为一张图片就占用了 10MB

1342
00:43:45,276 --> 0:43:47,146
没人告诉他这件事

1343
00:43:47,986 --> 0:43:49,816
为了证实这一点

1344
00:43:49,816 --> 0:43:51,486
我想尝试一下

1345
00:43:51,486 --> 0:43:55,396
我要将 15000 乘以 13000

1346
00:43:56,126 --> 0:44:00,786
iPhone X 是一个 3X 设备

1347
00:43:56,126 --> 0:44:00,786
iPhone X 是一个 3X 设备

1348
00:44:00,786 --> 0:44:02,766
所以是 3 倍的宽度

1349
00:44:02,766 --> 0:44:06,436
乘以 3 倍的高度

1350
00:44:06,436 --> 0:44:09,696
再乘以 4 字节每像素

1351
00:44:10,506 --> 0:44:13,706
这个数字看起来很熟悉

1352
00:44:15,876 --> 0:44:17,786
所以我很确定

1353
00:44:17,786 --> 0:44:19,306
我清楚地知道到底是什么

1354
00:44:19,306 --> 0:44:20,886
使用了 7.5GB 的内存

1355
00:44:20,886 --> 0:44:24,386
并不一定是

1356
00:44:24,386 --> 0:44:25,966
我的 beginImageContext

1357
00:44:25,966 --> 0:44:27,376
而是图像的尺寸

1358
00:44:27,746 --> 0:44:29,186
没有理由需要

1359
00:44:29,186 --> 0:44:30,506
这么大的图像

1360
00:44:30,966 --> 0:44:32,146
我要做的是把它缩小成

1361
00:44:32,146 --> 0:44:33,826
和我的视图

1362
00:44:33,826 --> 0:44:34,666
相同的尺寸

1363
00:44:34,666 --> 0:44:36,086
这样 它就会占用

1364
00:44:36,086 --> 0:44:36,826
更少的内存

1365
00:44:37,526 --> 0:44:38,766
那么 我要回到

1366
00:44:38,766 --> 0:44:40,026
上面的图像加载代码

1367
00:44:40,136 --> 0:44:41,216
实际上 在我这么做之前

1368
00:44:41,216 --> 0:44:42,276
我想先禁用这个断点

1369
00:44:42,276 --> 0:44:45,146
让我们看看

1370
00:44:45,146 --> 0:44:46,286
它是做什么的

1371
00:44:46,286 --> 0:44:47,666
很简单

1372
00:44:47,666 --> 0:44:49,016
它从一个 Bundle 中获取 URL

1373
00:44:49,016 --> 0:44:51,176
它从那个 URL 中

1374
00:44:51,176 --> 0:44:52,796
加载一些数据

1375
00:44:52,796 --> 0:44:55,166
并将其加载到 UIImage 中

1376
00:44:55,346 --> 0:44:56,856
然后传递给滤镜

1377
00:44:57,406 --> 0:44:58,906
我想做的是

1378
00:44:58,906 --> 0:45:00,276
在我把它发送到滤镜之前

1379
00:44:58,906 --> 0:45:00,276
在我把它发送到滤镜之前

1380
00:45:00,276 --> 0:45:01,746
我想缩小这个图像

1381
00:45:02,096 --> 0:45:04,226
然而 我还记得 Kyle 说的

1382
00:45:04,536 --> 0:45:05,656
我不应该在 UIImage 上进行缩放

1383
00:45:05,656 --> 0:45:07,406
因为它仍然会

1384
00:45:07,406 --> 0:45:08,816
把整个图像

1385
00:45:08,816 --> 0:45:10,266
加载到内存中

1386
00:45:10,266 --> 0:45:11,396
这是我要避免的

1387
00:45:11,906 --> 0:45:13,876
把这个函数

1388
00:45:13,986 --> 0:45:15,826
折叠起来

1389
00:45:16,106 --> 0:45:17,556
我要用 Kyle 建议的代码

1390
00:45:17,676 --> 0:45:19,946
来替换它

1391
00:45:20,496 --> 0:45:23,386
好的 我们来看看

1392
00:45:23,386 --> 0:45:24,656
这段代码在做什么

1393
00:45:25,886 --> 0:45:28,696
这里是一样的

1394
00:45:28,996 --> 0:45:31,286
我们从 Bundle 中获取图像

1395
00:45:31,286 --> 0:45:33,206
但是这一次

1396
00:45:33,206 --> 0:45:35,376
我得稍微调宽一点

1397
00:45:35,746 --> 0:45:38,066
我调用了 CGImageSourceCreateWithURL

1398
00:45:38,066 --> 0:45:39,796
来获取对图像的引用

1399
00:45:39,796 --> 0:45:41,016
然后将其传递给

1400
00:45:41,096 --> 0:45:43,816
CGImageSourceCreateThumbnailAtIndex

1401
00:45:44,156 --> 0:45:45,906
现在 我可以将图像

1402
00:45:45,906 --> 0:45:47,526
缩放到我想要的大小

1403
00:45:47,526 --> 0:45:49,026
而不需要将整个内容载入内存

1404
00:45:49,656 --> 0:45:51,366
让我们试一试

1405
00:45:51,366 --> 0:45:52,506
看看会不会有什么不同

1406
00:45:52,626 --> 0:45:53,506
我将重新构建

1407
00:45:53,506 --> 0:45:56,866
然后等待它

1408
00:45:56,866 --> 0:45:58,176
在 App 上启动

1409
00:45:59,486 --> 0:46:02,356
重新生成中

1410
00:45:59,486 --> 0:46:02,356
重新生成中

1411
00:46:02,356 --> 0:46:05,636
哦 有一个警告

1412
00:46:06,216 --> 0:46:09,566
我需要再调整一下这个

1413
00:46:10,996 --> 0:46:11,676
再来看一下

1414
00:46:12,786 --> 0:46:14,226
好了 正在构建

1415
00:46:15,256 --> 0:46:16,466
构建 构建 构建

1416
00:46:17,236 --> 0:46:19,576
好的 正在启动 没有问题

1417
00:46:19,636 --> 0:46:20,406
现在 让我们来看看

1418
00:46:20,406 --> 0:46:21,526
内存报告

1419
00:46:22,886 --> 0:46:25,646
让我们回到

1420
00:46:25,686 --> 0:46:27,036
我一直很喜欢的

1421
00:46:27,036 --> 0:46:28,556
土星北极的图像

1422
00:46:29,926 --> 0:46:32,036
我们应用这个图像

1423
00:46:32,036 --> 0:46:33,496
看看会占用多少内存

1424
00:46:33,496 --> 0:46:35,936
现在是 75

1425
00:46:35,936 --> 0:46:36,456
93MB

1426
00:46:36,966 --> 0:46:38,786
在这里 我们的内存峰值

1427
00:46:38,786 --> 0:46:41,046
是 93MB

1428
00:46:41,626 --> 0:46:42,866
明显地改善

1429
00:46:44,946 --> 0:46:46,816
[ 掌声 ] 这要比

1430
00:46:46,816 --> 0:46:48,126
几乎百分百被关闭的

1431
00:46:48,176 --> 0:46:50,886
7.5GB 的内存占用要好得多

1432
00:46:51,516 --> 0:46:53,076
但现在 我记得有件事

1433
00:46:53,076 --> 0:46:55,126
我想回去

1434
00:46:55,126 --> 0:46:58,186
先停止运行

1435
00:46:58,186 --> 0:46:59,806
我还是想回到

1436
00:46:59,806 --> 0:47:03,556
我的 filter() 方法

1437
00:46:59,806 --> 0:47:03,556
我的 filter() 方法

1438
00:47:03,556 --> 0:47:05,456
改变这个 UIBeginImageContext 代码

1439
00:47:05,456 --> 0:47:06,746
然后按照 Kyle 的建议去做

1440
00:47:06,826 --> 0:47:08,206
所以我要删除这段代码

1441
00:47:08,746 --> 0:47:12,986
然后添加新的滤镜

1442
00:47:14,456 --> 0:47:16,126
在这里

1443
00:47:16,126 --> 0:47:18,136
我要创建一个

1444
00:47:18,136 --> 0:47:19,076
UIGraphicsImageRenderer

1445
00:47:19,356 --> 0:47:21,946
我要在这个渲染器中

1446
00:47:21,946 --> 0:47:24,136
使用 CIFilter

1447
00:47:24,786 --> 0:47:26,506
来应用这个滤镜

1448
00:47:26,956 --> 0:47:28,936
让我们运行这段代码

1449
00:47:29,306 --> 0:47:30,866
希望它可以成功构建

1450
00:47:30,866 --> 0:47:32,076
然后看看是否会对我的内存使用

1451
00:47:32,076 --> 0:47:33,876
产生影响

1452
00:47:35,316 --> 0:47:37,286
让我们回到调试导航器

1453
00:47:37,286 --> 0:47:39,616
和内存报告中

1454
00:47:40,586 --> 0:47:42,406
再一次

1455
00:47:42,406 --> 0:47:46,516
我们回到土星图像

1456
00:47:46,746 --> 0:47:50,306
然后应用我们的滤镜

1457
00:47:51,076 --> 0:47:51,766
让我们来看看

1458
00:47:51,766 --> 0:47:54,846
这次的内存峰值是多少

1459
00:47:54,846 --> 0:47:55,496
98MB

1460
00:47:56,066 --> 0:47:59,136
这和上次基本是一样的

1461
00:47:59,136 --> 0:48:00,206
但是如果你仔细思考

1462
00:47:59,136 --> 0:48:00,206
但是如果你仔细思考

1463
00:48:00,206 --> 0:48:01,666
这个其实就是我所期望的结果

1464
00:48:02,216 --> 0:48:03,496
在这种情况下

1465
00:48:03,496 --> 0:48:05,346
我的图像仍然是

1466
00:48:05,346 --> 0:48:07,006
每个像素 4 个字节

1467
00:48:07,006 --> 0:48:08,076
所以我不会使用

1468
00:48:08,076 --> 0:48:10,476
这个新方法来节省内存

1469
00:48:10,906 --> 0:48:12,176
然而 如果有一个

1470
00:48:12,176 --> 0:48:13,926
节省内存的机会

1471
00:48:14,406 --> 0:48:17,356
例如 如果操作系统可以判断

1472
00:48:17,356 --> 0:48:20,666
图像可以每像素使用更少

1473
00:48:20,666 --> 0:48:21,866
或更多的字节

1474
00:48:21,866 --> 0:48:23,156
那么系统就可以做出正确的处理

1475
00:48:23,156 --> 0:48:24,206
我就不需要担心了

1476
00:48:24,546 --> 0:48:25,886
因此 在代码经过这些更改后

1477
00:48:25,886 --> 0:48:28,636
即使我没有看到很大的改进

1478
00:48:28,636 --> 0:48:29,486
我也知道它变得更好了

1479
00:48:30,526 --> 0:48:33,246
我还可以做更多

1480
00:48:33,566 --> 0:48:35,956
我想确保当 App 进入后台时

1481
00:48:35,956 --> 0:48:37,686
我们会卸载图像

1482
00:48:37,686 --> 0:48:39,536
而且我们不会在屏幕之外的视图中

1483
00:48:39,536 --> 0:48:41,346
显示任何图像

1484
00:48:41,346 --> 0:48:42,286
我还有很多可以做的

1485
00:48:42,286 --> 0:48:44,026
但是我对这些结果

1486
00:48:44,026 --> 0:48:45,516
已经很满意了

1487
00:48:45,516 --> 0:48:46,896
所以我想把它们送回给 James

1488
00:48:47,156 --> 0:48:48,416
我要抓取一个屏幕快照

1489
00:48:48,416 --> 0:48:50,096
并给 James 添加一点备注

1490
00:48:50,096 --> 0:48:53,236
让他知道

1491
00:48:53,236 --> 0:48:55,716
我对这一切是多么的满意

1492
00:48:56,286 --> 0:48:57,476
我想我们可以

1493
00:48:57,476 --> 0:48:59,466
给他发一个

1494
00:49:01,516 --> 0:49:03,616
星星眼的表情符号

1495
00:49:04,526 --> 0:49:06,166
希望 James 会对这些结果

1496
00:49:06,166 --> 0:49:07,326
感到满意

1497
00:49:07,326 --> 0:49:11,876
现在 我想请回 Kyle

1498
00:49:11,876 --> 0:49:12,816
他会帮我们整理一遍

1499
00:49:13,326 --> 0:49:13,696
谢谢大家

1500
00:49:14,386 --> 0:49:16,386
[ 掌声 ]

1501
00:49:16,756 --> 0:49:17,186
&gt;&gt; 谢谢 Kris

1502
00:49:20,096 --> 0:49:20,526
谢谢 Kris

1503
00:49:21,566 --> 0:49:22,366
太棒了

1504
00:49:22,666 --> 0:49:24,096
只做了一点点工作

1505
00:49:24,326 --> 0:49:30,076
我们就能大大减少内存的使用

1506
00:49:30,786 --> 0:49:34,896
总结起来 内存是有限的

1507
00:49:34,896 --> 0:49:35,356
也是共享的

1508
00:49:36,516 --> 0:49:37,786
我们使用得越多

1509
00:49:37,786 --> 0:49:39,156
系统就为其他 App 分配越少的内存

1510
00:49:39,236 --> 0:49:40,076
我们真的需要做一个好市民

1511
00:49:40,076 --> 0:49:41,786
并注意我们对内存的使用

1512
00:49:41,786 --> 0:49:43,366
只使用我们需要的内存

1513
00:49:46,336 --> 0:49:47,706
在调试时

1514
00:49:47,706 --> 0:49:50,276
Xcode 中的内存报告是至关重要的

1515
00:49:50,636 --> 0:49:51,726
当我们的 App 运行时我们就可以打开它

1516
00:49:51,726 --> 0:49:52,756
因为当我们监视它的时候

1517
00:49:52,756 --> 0:49:54,516
随着调试的进行

1518
00:49:54,516 --> 0:49:57,206
我们能注意到内存使用的消退

1519
00:49:59,076 --> 0:50:01,076
我们要确保 iOS

1520
00:49:59,076 --> 0:50:01,076
我们要确保 iOS

1521
00:50:01,956 --> 0:50:03,496
可以为我们选择图像格式

1522
00:50:03,746 --> 0:50:06,156
通过使用新的 UIImage 的

1523
00:50:06,156 --> 0:50:08,766
GraphicsRenderer API

1524
00:50:08,766 --> 0:50:10,576
我们可以从 SRGB 到 alpha 8 的转变过程中

1525
00:50:10,846 --> 0:50:11,996
节省 75% 的内存使用

1526
00:50:11,996 --> 0:50:14,596
这对蒙版和文本来说都很重要

1527
00:50:16,376 --> 0:50:18,166
除此之外 我们可以使用 ImageIO

1528
00:50:18,936 --> 0:50:20,446
来对图像进行下采样

1529
00:50:21,176 --> 0:50:22,836
它可以防止过高的内存峰值

1530
00:50:22,836 --> 0:50:24,646
相较于将 UIImage 绘制到

1531
00:50:24,646 --> 0:50:25,836
更小的环境中时

1532
00:50:25,836 --> 0:50:26,776
它也会更快

1533
00:50:27,176 --> 0:50:30,856
最后 我们要卸载

1534
00:50:30,856 --> 0:50:32,706
不在屏幕上的

1535
00:50:32,706 --> 0:50:33,516
大型图像和资源

1536
00:50:33,886 --> 0:50:34,886
使用这些内存是没有意义的

1537
00:50:34,886 --> 0:50:36,836
因为用户看不到它们

1538
00:50:38,166 --> 0:50:39,936
即使经历了所有这些努力

1539
00:50:40,156 --> 0:50:40,896
我们仍然没有完成

1540
00:50:42,006 --> 0:50:44,216
正如我们刚才看到的

1541
00:50:44,326 --> 0:50:45,926
使用 Memgraph 可以帮助我们

1542
00:50:46,346 --> 0:50:47,606
进一步了解发生了什么

1543
00:50:47,606 --> 0:50:48,306
并减少内存占用

1544
00:50:48,686 --> 0:50:49,576
结合 malloc_history

1545
00:50:49,576 --> 0:50:50,906
我们可以深入了解

1546
00:50:50,906 --> 0:50:52,966
内存的去向以及用途

1547
00:50:54,026 --> 0:50:56,046
所以我建议

1548
00:50:56,046 --> 0:50:58,456
大家能在讨论会后打开 malloc_history

1549
00:50:58,456 --> 0:51:00,426
分析你的工具

1550
00:50:58,456 --> 0:51:00,426
分析你的工具

1551
00:51:00,426 --> 0:51:02,106
然后开始深入研究

1552
00:51:03,256 --> 0:51:04,726
要了解更多的信息

1553
00:51:04,726 --> 0:51:06,816
你们可以查看我们的幻灯片

1554
00:51:07,426 --> 0:51:11,956
除此之外 如果你们还有其他问题的话

1555
00:51:11,956 --> 0:51:13,786
我们稍后会去技术实验室

1556
00:51:15,116 --> 0:51:15,906
谢谢大家 希望你们享受

1557
00:51:15,906 --> 0:51:17,286
WWDC 中的其他讨论会

1558
00:51:18,516 --> 0:51:22,500
[ 掌声 ]
