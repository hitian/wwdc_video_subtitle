1
00:00:07,516 --> 0:00:15,500
[ 音乐 ]

2
00:00:21,516 --> 0:00:29,106
[ 掌声 ]

3
00:00:29,606 --> 0:00:30,276
&gt;&gt; 下午好

4
00:00:30,686 --> 0:00:31,776
我的名字是 Ali Ozer

5
00:00:31,916 --> 0:00:33,346
我和我的同事们 Chris

6
00:00:33,346 --> 0:00:34,876
Dreessen 和 Jesse Donaldson

7
00:00:35,196 --> 0:00:36,206
将要一起为大家介绍

8
00:00:36,206 --> 0:00:38,596
macOS Mojave Cocoa 的新功能

9
00:00:40,986 --> 0:00:42,286
如大家昨日所见

10
00:00:42,286 --> 0:00:43,696
今年我们在 AppKit 新增了

11
00:00:43,696 --> 0:00:44,456
一些惊人的新功能

12
00:00:44,976 --> 0:00:45,936
我们将会谈到

13
00:00:45,936 --> 0:00:47,826
如下的几个问题

14
00:00:48,286 --> 0:00:49,106
我们将会讨论到 

15
00:00:49,106 --> 0:00:50,606
我们一直在做的 API 改进

16
00:00:51,036 --> 0:00:52,476
令人惊艳的新的黑暗模式

17
00:00:52,476 --> 0:00:54,496
以及相关的功能

18
00:00:54,496 --> 0:00:56,476
在 layer backing 做出的一些改动

19
00:00:56,476 --> 0:00:57,616
以及定制的快捷操作

20
00:00:58,896 --> 0:00:59,776
那么 让我们就进入这些内容的讲解吧

21
00:01:00,396 --> 0:01:01,986
现在 正如你们知道的 

22
00:01:01,986 --> 0:01:04,105
我们对我们的 API 感到自豪 

23
00:01:04,105 --> 0:01:05,876
而且我们的目标一直是

24
00:01:05,876 --> 0:01:07,446
希望 API 可以是有效的  

25
00:01:07,446 --> 0:01:08,686
连续的和强大的

26
00:01:09,796 --> 0:01:10,756
依据这个理念 

27
00:01:10,756 --> 0:01:12,806
我们一直在改进 

28
00:01:12,806 --> 0:01:14,516
提高 Objective-C

29
00:01:14,516 --> 0:01:16,086
和 API 的 Swift exposure

30
00:01:16,086 --> 0:01:18,436
而且 这不仅仅存在于 AppKit

31
00:01:18,436 --> 0:01:20,306
或者 Foundation 其他的体系中

32
00:01:20,306 --> 0:01:21,906
包括 UIKit 中也存在

33
00:01:21,956 --> 0:01:23,166
以及你们今天早上可能也听到过的

34
00:01:23,166 --> 0:01:24,966
Cocoa Touch 有什么新的改变

35
00:01:26,226 --> 0:01:28,236
现在 我们正在做的 API 的改变

36
00:01:28,236 --> 0:01:30,586
在 Objective-C 是完全源头可兼容的

37
00:01:30,586 --> 0:01:32,646
而且我们也期待 到我们 GM SDK 的时候

38
00:01:32,646 --> 0:01:34,466
它们在 Swift 会是 

39
00:01:34,466 --> 0:01:36,846
100% 可移动的

40
00:01:37,516 --> 0:01:38,756
那么 基于以上 让我们看一下 

41
00:01:38,756 --> 0:01:39,906
在此次的发布中

42
00:01:39,906 --> 0:01:40,886
API 的一些改进

43
00:01:41,416 --> 0:01:44,226
首先我要说一下

44
00:01:44,656 --> 0:01:47,036
字符串种类的一些更新

45
00:01:48,296 --> 0:01:49,486
在上一个发布中 我们介绍了

46
00:01:49,486 --> 0:01:51,016
字符串枚举种类作为一种方式

47
00:01:51,016 --> 0:01:52,476
去一起搜集成群相关的

48
00:01:52,476 --> 0:01:53,616
字符串常数

49
00:01:54,286 --> 0:01:55,696
这些帮助 API 

50
00:01:55,746 --> 0:01:57,236
在这些种类中更加清晰

51
00:01:58,896 --> 0:02:00,116
以下是一些例子

52
00:01:58,896 --> 0:02:00,116
以下是一些例子

53
00:02:00,326 --> 0:02:03,286
第一个是 NS STRING ENUM

54
00:02:03,596 --> 0:02:05,356
这被用于字符串枚举

55
00:02:05,356 --> 0:02:07,206
枚举中 我们提供框架之外的

56
00:02:07,206 --> 0:02:09,666
同时框架也无法进行扩展

57
00:02:09,666 --> 0:02:12,016
因此是固定的一套值

58
00:02:12,536 --> 0:02:14,556
旁边的这个 NS EXTENSIBLE

59
00:02:14,556 --> 0:02:17,456
STRING ENUM 是被用于

60
00:02:17,456 --> 0:02:19,416
declare 字符串枚举

61
00:02:19,676 --> 0:02:20,646
此处我们可以提供一些 

62
00:02:20,646 --> 0:02:22,346
box 之外的值 但其他的

63
00:02:22,346 --> 0:02:23,936
框架和 App 也可以

64
00:02:23,936 --> 0:02:25,746
加入到这组设定中

65
00:02:26,556 --> 0:02:28,176
那么这里我们做了两个改变

66
00:02:28,526 --> 0:02:29,866
第一个是简单的

67
00:02:30,276 --> 0:02:31,896
我们很简单地用它们的

68
00:02:31,896 --> 0:02:34,766
类型变体取代了 NS STRING ENUM 和

69
00:02:34,766 --> 0:02:36,226
NS STRING EXTENSIBLE ENUM

70
00:02:36,226 --> 0:02:38,076
这是一个很有效的误操作变更

71
00:02:38,336 --> 0:02:39,376
这些更加常见的种类 

72
00:02:39,376 --> 0:02:40,866
的相同声明

73
00:02:41,196 --> 0:02:43,056
因此 你的代码 调用站点或者任何东西

74
00:02:43,056 --> 0:02:44,076
都不需要改变

75
00:02:44,736 --> 0:02:46,216
下一个是 NSImageName

76
00:02:46,876 --> 0:02:49,066
经历了更大一些的改变

77
00:02:49,066 --> 0:02:50,726
一个更加显著的改变

78
00:02:50,726 --> 0:02:52,256
与字符串枚举不同

79
00:02:52,256 --> 0:02:54,226
它被声明是 NS SWIFT BRIDGED

80
00:02:54,226 --> 0:02:56,766
TYPEDEF 实际上是一个定义类型

81
00:02:56,766 --> 0:02:58,456
现在 这就是 Swift

82
00:02:58,456 --> 0:02:59,716
显示出来的样子

83
00:03:00,926 --> 0:03:03,846
在 Swift 4 中 NSImage.Name 作为结构

84
00:03:03,846 --> 0:03:05,216
出现 这个结构就是

85
00:03:05,216 --> 0:03:07,596
你声明字符串枚举的形式

86
00:03:07,926 --> 0:03:09,886
在 Swift 4.2 中 它作为一个 TypeAlias 

87
00:03:09,886 --> 0:03:12,276
一个简单的 古老的

88
00:03:12,366 --> 0:03:14,936
普通 TypeAlias 更加简单

89
00:03:16,046 --> 0:03:17,726
因此 问题就是 为什么我们要如此做呢

90
00:03:18,136 --> 0:03:19,826
让我们来看看一个调用站点的例子

91
00:03:22,056 --> 0:03:24,786
这里在 Swift 4 中 就是你如何提取

92
00:03:24,826 --> 0:03:26,486
一个字符串 使用命名方式在其中

93
00:03:26,486 --> 0:03:29,606
创建一个 NSImage 的操作方式

94
00:03:29,976 --> 0:03:31,686
在这里你可以看到 

95
00:03:31,686 --> 0:03:32,986
你会提取这个字符串

96
00:03:32,986 --> 0:03:34,936
我们正将它转换成 一个 NSImage.Name

97
00:03:34,936 --> 0:03:36,126
再变成 named 在

98
00:03:36,126 --> 0:03:37,456
我们调用 NSImage named 之前

99
00:03:37,966 --> 0:03:38,796
由于这里不得不重复 NSImage.Name 

100
00:03:38,796 --> 0:03:42,316
这种操作并没有特别流线型的体验

101
00:03:42,956 --> 0:03:44,806
现在 由于 Swift 4.2 中的改变

102
00:03:45,296 --> 0:03:46,206
这就是我们需要写入的所有

103
00:03:46,286 --> 0:03:47,536
你无需一定要转换为

104
00:03:47,536 --> 0:03:49,246
NSImage name 这种操作会更顺畅

105
00:03:49,246 --> 0:03:50,736
更清晰一些

106
00:03:50,846 --> 0:03:51,846
也会更少冗杂

107
00:03:52,426 --> 0:03:53,636
因此我们相信这种定义类型

108
00:03:53,636 --> 0:03:55,976
方式对于传递值更为合适

109
00:03:56,516 --> 0:04:01,126
［ 掌声 ］

110
00:03:56,516 --> 0:04:01,126
［ 掌声 ］

111
00:04:01,626 --> 0:04:02,916
是的 我们也听到你们有些人说起来

112
00:04:04,616 --> 0:04:05,856
所以 我们相信这种方式

113
00:04:05,856 --> 0:04:08,636
对于传递值 比如 resource names 或者标识符

114
00:04:08,636 --> 0:04:09,396
更加合适

115
00:04:09,396 --> 0:04:11,756
基本上而言 值并不会被

116
00:04:11,756 --> 0:04:13,266
框架所体现

117
00:04:13,266 --> 0:04:14,926
它们只是被用于一个传递的样式

118
00:04:15,156 --> 0:04:16,886
图片名称 颜色名称

119
00:04:16,886 --> 0:04:18,875
以及窗口框自动保存的名称等等

120
00:04:18,875 --> 0:04:21,136
以及窗口框自动保存的名称的种类

121
00:04:21,245 --> 0:04:23,386
现在 需要注意的是 

122
00:04:23,386 --> 0:04:25,056
即使是使用这种新方式

123
00:04:25,096 --> 0:04:27,046
你们依然拥有特定的 API 所具有的好处

124
00:04:27,386 --> 0:04:30,146
这是对 NSImage 命名方式的声明

125
00:04:30,146 --> 0:04:31,226
你还要注意

126
00:04:31,226 --> 0:04:33,656
这里讲的还是 NSImage.Name

127
00:04:33,656 --> 0:04:34,166
与字符串截然相反

128
00:04:34,166 --> 0:04:35,676
所以 我们仍然会遇到它

129
00:04:36,516 --> 0:04:37,926
现在 这就是所有种类的清单

130
00:04:37,926 --> 0:04:39,086
我们对 NSAppKit 也进行了这种操作

131
00:04:39,136 --> 0:04:43,656
结果证明许多种类都能从中获益

132
00:04:45,356 --> 0:04:46,746
而且不仅仅是这一个

133
00:04:46,746 --> 0:04:47,606
更是这一套

134
00:04:47,706 --> 0:04:50,236
因此 许多种类在这个样式里面都发生了改变

135
00:04:52,126 --> 0:04:54,546
接下来 我要讲一下

136
00:04:54,546 --> 0:04:55,816
一般的前缀

137
00:04:56,376 --> 0:04:57,446
如你们在过去几年中所见

138
00:04:57,446 --> 0:04:58,576
随着时间流逝

139
00:04:58,576 --> 0:05:00,866
我们已经逐步从多年前使用的一般后缀

140
00:04:58,576 --> 0:05:00,866
我们已经逐步从多年前使用的一般后缀

141
00:05:00,866 --> 0:05:02,436
使用的一般后缀

142
00:05:02,436 --> 0:05:04,796
转移到 Objective-C 中的一般前缀

143
00:05:05,186 --> 0:05:07,466
使用一般前缀可以使得名字成组合

144
00:05:07,466 --> 0:05:08,936
使得名字成组合

145
00:05:08,936 --> 0:05:10,446
也会更容易被发现

146
00:05:10,686 --> 0:05:12,266
并在 Swift 中遇到

147
00:05:13,586 --> 0:05:16,776
那么 让我们来看下面这个例子

148
00:05:16,846 --> 0:05:18,996
这是 NSLineJoinStyle 

149
00:05:18,996 --> 0:05:21,156
出现在 10.13 SDK

150
00:05:21,156 --> 0:05:23,866
这是它在 10.14 中显示的样子

151
00:05:24,226 --> 0:05:25,866
你会发现枚举的值 

152
00:05:25,866 --> 0:05:26,786
比如说

153
00:05:26,826 --> 0:05:28,516
MiterLineJoinStyle 现在已经变成了

154
00:05:28,546 --> 0:05:30,316
LineJoinStyleMiter

155
00:05:30,936 --> 0:05:32,486
所以 因为一个一般前缀

156
00:05:33,116 --> 0:05:34,936
Swift 的显示从

157
00:05:35,436 --> 0:05:38,606
miterLineJoinStyle 变成了只有 miter

158
00:05:38,886 --> 0:05:40,616
因此 你可以看到 你不必

159
00:05:40,616 --> 0:05:41,756
再重复输入

160
00:05:41,756 --> 0:05:43,076
在调用站点体现得更为明显

161
00:05:43,076 --> 0:05:44,506
更加清晰

162
00:05:44,846 --> 0:05:46,936
体验这么好 此处需要一个笑脸的表情

163
00:05:47,151 --> 0:05:49,151
［ 掌声 ］

164
00:05:49,286 --> 0:05:49,876
谢谢

165
00:05:51,186 --> 0:05:53,246
同时 我们对很多之前没有进行过

166
00:05:53,246 --> 0:05:54,366
这种改变的其他种类

167
00:05:54,756 --> 0:05:56,396
也应用了此改变的特性

168
00:05:56,396 --> 0:05:57,956
以下是这些种类的清单

169
00:06:00,496 --> 0:06:01,376
接下来 我想说的是

170
00:06:01,376 --> 0:06:02,506
形式化的协议

171
00:06:03,446 --> 0:06:04,966
在过去的时间里 我们用的是

172
00:06:04,966 --> 0:06:06,936
非正式协议

173
00:06:06,936 --> 0:06:08,176
主要就是 NSObject 上面的种类

174
00:06:08,246 --> 0:06:09,556
将相关的方法

175
00:06:09,596 --> 0:06:10,356
组合在一起

176
00:06:10,966 --> 0:06:11,906
那时起 我们还增加了

177
00:06:11,906 --> 0:06:13,056
一些功能

178
00:06:13,056 --> 0:06:14,846
比如协议上的可选方法等等

179
00:06:14,846 --> 0:06:17,096
我们也在可能的时候 将其转换成正式协议

180
00:06:17,716 --> 0:06:19,336
下面 我将要给你们展示

181
00:06:19,336 --> 0:06:20,996
我们操作的其中的

182
00:06:20,996 --> 0:06:21,476
一个例子

183
00:06:23,156 --> 0:06:24,056
这就是这个方法

184
00:06:24,116 --> 0:06:26,106
validateMenuItem 它曾是一个

185
00:06:26,106 --> 0:06:28,826
非正式协议

186
00:06:28,826 --> 0:06:31,026
在 10.13 中的一个分类对象

187
00:06:31,346 --> 0:06:32,526
现在 它是一个正式协议

188
00:06:32,526 --> 0:06:34,376
称为 NSMenuItemValidation

189
00:06:34,376 --> 0:06:35,216
其中包含着方法

190
00:06:35,706 --> 0:06:37,336
Swift 的显示从 

191
00:06:37,336 --> 0:06:39,866
一个扩展 NSObject 变成一个

192
00:06:39,866 --> 0:06:41,016
正式协议

193
00:06:41,016 --> 0:06:42,886
当然就是 Swift 4.2 中的

194
00:06:42,886 --> 0:06:43,566
NSMenuItemValidation

195
00:06:43,936 --> 0:06:44,986
当然了 这里的好处就是

196
00:06:44,986 --> 0:06:46,846
执行菜单项目验证的对象

197
00:06:46,846 --> 0:06:48,416
现在有了一种方式

198
00:06:48,596 --> 0:06:49,956
可以正式声明

199
00:06:49,956 --> 0:06:51,506
它们是遵照这个协议来进行操作的

200
00:06:52,096 --> 0:06:53,426
我想再说一遍 我们很喜欢这样

201
00:06:53,426 --> 0:06:55,246
对许多其他的 API 我们也做了这样的 改造

202
00:06:55,806 --> 0:06:57,656
那么 这就是我们在 AppKit 中加入的

203
00:06:57,656 --> 0:06:59,586
正式协议的全部清单

204
00:07:00,056 --> 0:07:01,136
你会发现诸如颜色改变

205
00:07:01,136 --> 0:07:02,486
字体改变

206
00:07:02,646 --> 0:07:04,846
NSEditor NSEditorRegistration

207
00:07:05,176 --> 0:07:06,476
将相关绑定的方法等等 

208
00:07:06,516 --> 0:07:07,816
组合在一起 

209
00:07:07,816 --> 0:07:09,236
这就是新的

210
00:07:09,236 --> 0:07:10,306
正式协议的清单

211
00:07:12,016 --> 0:07:13,066
接下来 我想要说一说

212
00:07:13,066 --> 0:07:14,876
直接的实例变量访问

213
00:07:15,826 --> 0:07:19,716
目前 我们的 API 几乎所有的

214
00:07:19,716 --> 0:07:21,096
实例变量

215
00:07:21,196 --> 0:07:22,136
都是私密的

216
00:07:22,586 --> 0:07:24,346
但是 我们已经说过

217
00:07:24,736 --> 0:07:25,826
他们已经以某一种方式被声明

218
00:07:25,826 --> 0:07:27,156
尤其是在一些比较老的 AppKit 类

219
00:07:27,186 --> 0:07:29,466
子类被允许

220
00:07:29,556 --> 0:07:31,256
接触到实例变量

221
00:07:31,526 --> 0:07:33,216
直接获取到这些实例变量

222
00:07:33,716 --> 0:07:34,816
现在 你们中的一些人甚至

223
00:07:34,816 --> 0:07:36,286
没有意识到这个 所以请不要

224
00:07:36,286 --> 0:07:37,356
直接找到然后开始使用

225
00:07:37,706 --> 0:07:39,576
因为这可能是之前旧的代码

226
00:07:39,576 --> 0:07:40,956
我敢肯定这些代码你都没有写过

227
00:07:40,956 --> 0:07:42,656
可能是直接从前人那里获得的

228
00:07:42,656 --> 0:07:44,316
这些代码可能会直接使用实例变量

229
00:07:44,766 --> 0:07:46,306
所以 现在来讲

230
00:07:46,306 --> 0:07:47,666
我们将会

231
00:07:47,666 --> 0:07:50,656
对此操作明显地表达不赞成 并在之后弃用

232
00:07:51,166 --> 0:07:52,446
现在 如果你直接通过代码获取到

233
00:07:52,446 --> 0:07:53,756
实例变量

234
00:07:53,756 --> 0:07:55,436
会收到一个警告

235
00:07:55,436 --> 0:07:57,896
我们的想法是在未来的更新中 要切断这种操作 

236
00:07:57,896 --> 0:07:59,446
所以 如果你遇到了这种情况

237
00:07:59,486 --> 0:08:01,186
请不要理它 直接删除这些使用

238
00:07:59,486 --> 0:08:01,186
请不要理它 直接删除这些使用

239
00:08:02,406 --> 0:08:05,086
改进的方式也非常直接

240
00:08:05,086 --> 0:08:06,196
与直接获取

241
00:08:06,196 --> 0:08:07,366
实例变量不同的是

242
00:08:07,686 --> 0:08:08,866
你可以继续调用那些已经

243
00:08:08,866 --> 0:08:10,006
有获得者或者

244
00:08:10,006 --> 0:08:11,806
访问过的属性 或者其他可能的方式

245
00:08:11,986 --> 0:08:14,116
或许 你有要获取这些

246
00:08:14,116 --> 0:08:15,246
实例变量的原因

247
00:08:15,246 --> 0:08:16,266
你也没有看到任何一个可以获取的方式

248
00:08:16,266 --> 0:08:17,706
你或许可以告诉我们

249
00:08:18,936 --> 0:08:20,216
现在 说起弃用

250
00:08:20,576 --> 0:08:21,626
我们还正在做另一件事

251
00:08:23,276 --> 0:08:25,326
叫作正式软弃用

252
00:08:25,976 --> 0:08:26,906
这么多年来 我们已经弃用了 

253
00:08:26,906 --> 0:08:30,416
许多 API 的也使用更好的代替了它们

254
00:08:30,966 --> 0:08:32,275
当弃用不紧急的时候

255
00:08:32,275 --> 0:08:33,976
我们通常

256
00:08:33,976 --> 0:08:35,346
会走非正式弃用的流程

257
00:08:35,346 --> 0:08:36,765
我们会告知

258
00:08:36,765 --> 0:08:38,336
API 要弃用

259
00:08:38,336 --> 0:08:39,916
我们发布通知 对其进行标记

260
00:08:39,916 --> 0:08:41,426
等等

261
00:08:41,426 --> 0:08:42,456
在最终标记弃用之前

262
00:08:42,836 --> 0:08:44,116
通常这种操作可以减少破坏

263
00:08:44,916 --> 0:08:46,016
但是 我们有一种方式 要正式

264
00:08:46,016 --> 0:08:47,956
对 API 进行弃用标记

265
00:08:48,566 --> 0:08:49,556
我给大家举个例子

266
00:08:50,726 --> 0:08:51,626
这里我们有一个符号

267
00:08:51,676 --> 0:08:54,356
NSBoxOldStyle

268
00:08:54,356 --> 0:08:55,846
即将变成需要

269
00:08:55,846 --> 0:08:56,626
被弃用的名字

270
00:08:57,186 --> 0:08:58,176
你会发现我们已经

271
00:08:58,206 --> 0:08:59,696
将其标记为弃用

272
00:09:00,316 --> 0:09:01,386
它的版本号已经变成

273
00:09:01,386 --> 0:09:03,416
API 即将弃用

274
00:09:04,836 --> 0:09:07,386
此举就是为了告诉编译器

275
00:09:07,386 --> 0:09:09,186
不要产生一个

276
00:09:09,186 --> 0:09:10,706
弃用警告或者错误

277
00:09:11,206 --> 0:09:12,906
然而我们的目的是

278
00:09:12,906 --> 0:09:14,396
如果你 Xcode 或新代码中 或者获取文件中

279
00:09:14,426 --> 0:09:16,516
尝试使用这个符号

280
00:09:16,516 --> 0:09:18,026
你会收到一个警告

281
00:09:18,026 --> 0:09:19,216
警告此符号

282
00:09:19,216 --> 0:09:20,216
已弃用 并且 

283
00:09:20,216 --> 0:09:21,736
指向新的代替的符号

284
00:09:22,336 --> 0:09:23,546
当然了 同样也是在

285
00:09:23,546 --> 0:09:24,466
Swift 中碰上

286
00:09:24,556 --> 0:09:28,126
你要看这里 要提示的一点是

287
00:09:28,156 --> 0:09:29,016
版本号 100,000

288
00:09:29,706 --> 0:09:30,996
这不是一个提前的宣布

289
00:09:30,996 --> 0:09:32,956
或者是未来的 SDK 的泄露

290
00:09:32,956 --> 0:09:34,996
它只是一个占位符编码

291
00:09:34,996 --> 0:09:39,036
我们目前用它来显示这个功能

292
00:09:40,196 --> 0:09:41,206
现在 我们在一些其他的

293
00:09:41,206 --> 0:09:42,806
案例中也使用正式的软弃用

294
00:09:43,826 --> 0:09:45,286
更早之前我给你们展示过这个

295
00:09:46,146 --> 0:09:47,436
并且 我告诉过你们我们重新命名了

296
00:09:47,436 --> 0:09:49,076
MiterLineJoinStyle  

297
00:09:49,076 --> 0:09:50,126
变成 LineJoinStyleMiter

298
00:09:50,956 --> 0:09:53,786
我还说了 Objective-C 源代码是 100%

299
00:09:53,786 --> 0:09:54,326
兼容的

300
00:09:54,826 --> 0:09:56,066
那么你可能会想知道

301
00:09:56,066 --> 0:09:57,076
对于你重新命名的旧的符号

302
00:09:57,076 --> 0:09:58,336
进行了什么操作呢

303
00:09:58,876 --> 0:10:00,066
事实上 我们将那个你看到的旧富豪

304
00:09:58,876 --> 0:10:00,066
事实上 我们将那个你看到的旧富豪

305
00:10:00,066 --> 0:10:02,596
使用了这个新的版本号标记

306
00:10:02,596 --> 0:10:03,976
API TO BE DEPRECATED

307
00:10:04,046 --> 0:10:06,896
因此 我们宣布其已被弃用

308
00:10:07,016 --> 0:10:08,936
标记是 API TO BE DEPRECATED

309
00:10:08,936 --> 0:10:11,406
意为着任何试图使用它的操作都会被警告

310
00:10:11,406 --> 0:10:14,806
但已存在的使用会被保留 因为我们

311
00:10:14,806 --> 0:10:15,766
不想真正的破坏

312
00:10:16,236 --> 0:10:17,236
在 Objective-C 源代码中

313
00:10:17,236 --> 0:10:21,346
这个符号的使用

314
00:10:21,446 --> 0:10:22,576
现在 有许多符号等待着

315
00:10:22,576 --> 0:10:25,186
被进行这种操作

316
00:10:25,186 --> 0:10:29,626
因此许多会被标记为 API TO BE DEPRECATED

317
00:10:29,966 --> 0:10:31,246
数目很多是因为

318
00:10:31,246 --> 0:10:33,326
我们使用一般前缀取代一般

319
00:10:33,426 --> 0:10:35,046
后缀的命名 还有一些是

320
00:10:35,046 --> 0:10:36,406
其他的符号 我们

321
00:10:36,636 --> 0:10:38,156
不再强调弃用

322
00:10:38,636 --> 0:10:39,926
因为我们要引入新的来取代它们

323
00:10:39,926 --> 0:10:40,936
尤其是支持

324
00:10:40,936 --> 0:10:42,276
黑暗模式的功能

325
00:10:42,606 --> 0:10:43,836
你们在今天的晚些时候会听到有关这一方面的内容

326
00:10:44,486 --> 0:10:46,996
最后一个我想说的话题是

327
00:10:46,996 --> 0:10:48,326
安全编码

328
00:10:49,186 --> 0:10:50,116
你们可能有所了解

329
00:10:50,116 --> 0:10:53,016
我们在 10.8 and iOS 6 引入了 

330
00:10:53,016 --> 0:10:56,336
完全编码

331
00:10:56,446 --> 0:10:59,196
当你压缩的时候

332
00:10:59,196 --> 0:11:00,366
基本上会允许你

333
00:10:59,196 --> 0:11:00,366
基本上会允许你

334
00:11:00,366 --> 0:11:01,286
确认什么样的类是你需要的

335
00:11:01,286 --> 0:11:04,916
这样 如果在压缩文件中没有遇到这些

336
00:11:04,916 --> 0:11:05,766
就会成为一个

337
00:11:05,766 --> 0:11:06,946
明显的错误

338
00:11:08,126 --> 0:11:09,106
现在我们处理安全

339
00:11:09,106 --> 0:11:13,626
编码的方式

340
00:11:13,626 --> 0:11:14,436
是将其作为可选功能

341
00:11:14,906 --> 0:11:16,766
但是 我们新的 API 既允许

342
00:11:16,766 --> 0:11:18,886
安全编码作为默认动作

343
00:11:18,886 --> 0:11:20,376
也允许其作为备选项

344
00:11:20,376 --> 0:11:22,556
同时还可支持错误返回提示

345
00:11:23,076 --> 0:11:24,526
我们的压缩和解压

346
00:11:24,526 --> 0:11:25,836
API 会有一些例外

347
00:11:25,836 --> 0:11:27,576
但是当然我们更偏向于错误返回

348
00:11:27,576 --> 0:11:29,606
并且 新 API 激活的错误

349
00:11:29,606 --> 0:11:31,006
返回动作是默认的

350
00:11:32,296 --> 0:11:34,086
因此 我将给你展示 API 

351
00:11:34,086 --> 0:11:35,616
NSKeyedUnarchiver 

352
00:11:35,616 --> 0:11:36,546
因为这是其中最有意思的

353
00:11:37,126 --> 0:11:38,506
这是一个 NSKeyedUnarchiver

354
00:11:38,886 --> 0:11:39,896
其中一个新的方法在里面

355
00:11:39,976 --> 0:11:40,866
它简单地创建了一个

356
00:11:40,866 --> 0:11:43,296
keyedUnarchiver 非常安全地

357
00:11:43,296 --> 0:11:44,876
并且用一种方式返回错误

358
00:11:45,736 --> 0:11:49,296
其他两个新的方法 就是这些简便的 API

359
00:11:49,296 --> 0:11:51,506
unarchivedObject(ofClasses from

360
00:11:51,756 --> 0:11:53,986
和 unarchivedObject(ofClass from 

361
00:11:54,256 --> 0:11:56,086
这些基本上解压了

362
00:11:56,086 --> 0:11:57,466
单一个目标并返回

363
00:11:57,926 --> 0:11:59,046
操作很安全

364
00:11:59,046 --> 0:12:01,246
并且如果遇到问题

365
00:11:59,046 --> 0:12:01,246
并且如果遇到问题

366
00:12:01,246 --> 0:12:02,386
会返回错误

367
00:12:02,946 --> 0:12:04,306
现在 说一下这里的第二个方法

368
00:12:04,306 --> 0:12:05,526
这是一种装饰

369
00:12:06,116 --> 0:12:07,706
就如张扬美丽的孔雀

370
00:12:08,296 --> 0:12:12,006
所有的装饰帮助

371
00:12:12,006 --> 0:12:13,596
Swift 更好地推断返回种类

372
00:12:13,596 --> 0:12:14,666
这当然也是 Swift

373
00:12:14,716 --> 0:12:16,066
擅长的操作

374
00:12:16,866 --> 0:12:18,166
现在 要注意一下 在今年的

375
00:12:18,166 --> 0:12:20,156
SDK 中被抛弃的功能

376
00:12:20,156 --> 0:12:24,026
在 10.13 和 iOS 11 中仍可使用

377
00:12:24,196 --> 0:12:25,296
所以 你可以开始会用他们

378
00:12:25,616 --> 0:12:27,146
即使是通过那些调度目标

379
00:12:28,886 --> 0:12:32,056
这些方法 取代了这里这一页的方法

380
00:12:32,886 --> 0:12:34,416
现在 你要注意这些是在 

381
00:12:34,416 --> 0:12:36,596
10.14 和 iOS 12 中

382
00:12:36,596 --> 0:12:37,856
被弃用的

383
00:12:38,586 --> 0:12:40,226
因为这些不是源编码的操作

384
00:12:40,226 --> 0:12:42,116
我们会立刻弃用它们

385
00:12:42,116 --> 0:12:43,486
而不是通过

386
00:12:43,486 --> 0:12:44,426
正式软弃用的

387
00:12:44,426 --> 0:12:45,826
因为我们真心希望能够

388
00:12:45,826 --> 0:12:47,086
鼓励你们

389
00:12:47,086 --> 0:12:48,146
转换到安全编码

390
00:12:48,146 --> 0:12:49,826
如果你还没有开始的话

391
00:12:51,426 --> 0:12:53,636
现在 关于安全编码另一件事

392
00:12:53,636 --> 0:12:55,616
是一个新的值转换器

393
00:12:56,046 --> 0:12:56,676
你可能知道

394
00:12:56,786 --> 0:12:58,316
NSValueTransformer 是一个类

395
00:12:58,606 --> 0:12:59,446
用于自动将值做转换

396
00:12:59,446 --> 0:13:01,526
从一个转换成为另一个

397
00:12:59,446 --> 0:13:01,526
从一个转换成为另一个

398
00:13:02,076 --> 0:13:03,466
这里的两个 valueTransformers

399
00:13:03,466 --> 0:13:05,416
unarchiveFromData 和

400
00:13:05,416 --> 0:13:07,806
keyedUnarchivedFromData

401
00:13:07,806 --> 0:13:09,436
第一个进行无密码压缩

402
00:13:09,436 --> 0:13:10,426
第二个进行

403
00:13:10,426 --> 0:13:11,966
有密码压缩 但并不安全

404
00:13:12,436 --> 0:13:14,506
因此 这些方法

405
00:13:14,756 --> 0:13:16,026
并不是我们所喜欢的

406
00:13:16,026 --> 0:13:17,396
所以我们要弃用这两个

407
00:13:17,396 --> 0:13:19,696
然后使用这个新的安全的 Unarchive

408
00:13:19,696 --> 0:13:21,156
FromDataTransformerName 来替代它们

409
00:13:21,156 --> 0:13:23,086
从而可以安全地解压

410
00:13:23,316 --> 0:13:25,386
因此 我们也希望你们能尽快转换为这个

411
00:13:25,716 --> 0:13:28,696
现在 在安全编码的前线

412
00:13:28,696 --> 0:13:29,666
我们已经前进了不少 而且

413
00:13:29,666 --> 0:13:30,806
在许多 Appkit 类中

414
00:13:30,806 --> 0:13:32,716
新添加了安全编码

415
00:13:33,646 --> 0:13:35,536
要注意这里

416
00:13:36,106 --> 0:13:38,186
NSAppearance 最近已经

417
00:13:38,186 --> 0:13:39,156
越来越明显地

418
00:13:39,156 --> 0:13:40,566
成为你的朋友

419
00:13:40,566 --> 0:13:42,106
在之后我们在 AppKit 中添加黑暗模式

420
00:13:42,106 --> 0:13:44,246
及其他功能的演讲中也会遇到它

421
00:13:44,906 --> 0:13:46,246
我们也在一些基础的 API 中加入了安全编码

422
00:13:46,246 --> 0:13:48,356
这些 API 中此前都是没有安全编码的

423
00:13:48,756 --> 0:13:49,946
下面这个就是列表

424
00:13:51,136 --> 0:13:52,686
还有另外一个关于安全编码的提醒

425
00:13:53,016 --> 0:13:54,756
我们周四上午会有一个会议

426
00:13:55,856 --> 0:13:58,196
名为 你可以信任数据

427
00:13:58,196 --> 0:13:59,666
会上我们会讨论

428
00:14:00,166 --> 0:14:01,776
编程 压缩和解压缩

429
00:14:01,776 --> 0:14:03,296
以一种稳健又安全的形式

430
00:14:03,396 --> 0:14:05,146
我邀请你们去参加

431
00:14:05,196 --> 0:14:07,716
在周四早上九点

432
00:14:07,916 --> 0:14:09,566
现在 演讲下面的内容

433
00:14:09,566 --> 0:14:12,876
将是关于 AppKit 的新功能以及相关的领域

434
00:14:13,156 --> 0:14:14,976
因此 接下来我要请 Chris 上台给大家做讲解

435
00:14:15,516 --> 0:14:20,966
［ 掌声 ］

436
00:14:21,466 --> 0:14:21,986
&gt;&gt; 多谢 Ali

437
00:14:22,596 --> 0:14:25,036
黑暗模式是 macOS 10.14 版本

438
00:14:25,036 --> 0:14:25,946
推出的最令人惊喜的功能之一

439
00:14:26,406 --> 0:14:27,386
我估计大家昨天都已经一睹为快了

440
00:14:27,386 --> 0:14:28,796
可能你们其中的一些人

441
00:14:28,796 --> 0:14:29,656
现在正运行着这个模式

442
00:14:29,656 --> 0:14:31,076
不过我们还是来一起看一看

443
00:14:32,036 --> 0:14:34,666
我们提供了这些出色的

444
00:14:34,666 --> 0:14:35,556
新系统图案

445
00:14:36,126 --> 0:14:37,616
这使得我们系统的 UI 看起来很棒

446
00:14:37,616 --> 0:14:38,936
这也会使你的 App 获得良好的视觉观感

447
00:14:39,156 --> 0:14:40,836
也能保证你自创的用户内容有良好的视觉体现

448
00:14:41,186 --> 0:14:42,436
我们想要知道的是

449
00:14:42,436 --> 0:14:45,326
要兼容采用这个模式 都需要做什么呢

450
00:14:45,526 --> 0:14:47,536
第一步其实是特别简单的

451
00:14:47,906 --> 0:14:49,246
我们需要重新编译

452
00:14:49,246 --> 0:14:50,906
macOS 10.14 SDK

453
00:14:51,336 --> 0:14:52,146
这个挺简单的吧

454
00:14:52,436 --> 0:14:53,496
其实做这一步对于我们来说就够了

455
00:14:53,496 --> 0:14:54,736
但是大多数人

456
00:14:54,736 --> 0:14:55,836
还是需要继续操作 再多做几步

457
00:14:55,836 --> 0:14:57,896
才能让自己的 App 变得更加美观

458
00:14:58,676 --> 0:14:59,656
下一步我们要操作的

459
00:14:59,656 --> 0:15:01,176
就是需要在我们硬编码

460
00:14:59,656 --> 0:15:01,176
就是需要在我们硬编码

461
00:15:01,176 --> 0:15:03,936
颜色数值的存储地址检索

462
00:15:03,936 --> 0:15:04,376
我们的 App

463
00:15:04,566 --> 0:15:05,966
然后我们将它替换成一个

464
00:15:05,966 --> 0:15:07,486
对外观敏感的颜色

465
00:15:08,696 --> 0:15:10,646
对于大多数的系统 UI 元素而言

466
00:15:10,906 --> 0:15:12,656
AppKit 其实提供了

467
00:15:12,656 --> 0:15:14,226
多种动态的系统颜色

468
00:15:14,226 --> 0:15:16,546
可以和现有的外观互动 而且

469
00:15:16,546 --> 0:15:18,166
不论你想要使用什么样的 UI 元素

470
00:15:18,166 --> 0:15:19,216
视觉效果都会不错

471
00:15:19,476 --> 0:15:20,466
并且 为了充实原有的系统颜色

472
00:15:20,466 --> 0:15:22,156
我们在 macOS 10.14 中加入了

473
00:15:22,156 --> 0:15:23,006
更多上述的颜色

474
00:15:24,186 --> 0:15:25,836
当然 有些情况下

475
00:15:25,836 --> 0:15:26,676
你的操作对象不是系统 UI

476
00:15:26,676 --> 0:15:28,026
元素 而是想要去

477
00:15:28,026 --> 0:15:29,206
调整一些文档模式的部分

478
00:15:29,206 --> 0:15:30,596
使它们能在黑暗模式中

479
00:15:30,596 --> 0:15:31,156
表现得更加美观

480
00:15:31,266 --> 0:15:32,836
现在你可以在素材目录中

481
00:15:32,836 --> 0:15:34,806
整理你可以使用的颜色

482
00:15:35,796 --> 0:15:37,276
当你使用 Xcode 中的

483
00:15:37,276 --> 0:15:39,166
颜色编辑器时 你可以

484
00:15:39,166 --> 0:15:40,416
自行配置和想要设置颜色

485
00:15:40,676 --> 0:15:42,246
相对应的外观

486
00:15:42,246 --> 0:15:44,526
只需要使用在右方的工具栏就可以

487
00:15:45,046 --> 0:15:46,466
在这里 我们已经为

488
00:15:46,466 --> 0:15:47,986
日光外观模式

489
00:15:47,986 --> 0:15:49,266
黑暗外观模式

490
00:15:49,266 --> 0:15:50,396
以及备用外观模式

491
00:15:50,396 --> 0:15:52,246
都选择好了颜色

492
00:15:52,756 --> 0:15:56,296
同颜色设置一样

493
00:15:56,296 --> 0:15:57,436
接下来 让我们一起浏览一下

494
00:15:57,436 --> 0:15:59,096
我们的 UI 系统 也找找我们可以应用

495
00:15:59,156 --> 0:15:59,876
模板图像的地方

496
00:16:00,406 --> 0:16:01,506
模板图像的奇妙之处

497
00:16:01,546 --> 0:16:04,616
在于不论我们使用何种外观

498
00:16:04,726 --> 0:16:06,086
我们选择的模板图片都能自动匹配出正确的颜色

499
00:16:06,526 --> 0:16:07,476
例如 你可能在自己的 App 中

500
00:16:07,476 --> 0:16:10,046
加入了一些深灰色的元素

501
00:16:10,046 --> 0:16:11,576
或者纯黑色的元素

502
00:16:11,576 --> 0:16:12,826
这些元素在日间模式下看起来

503
00:16:12,826 --> 0:16:14,146
自然没有问题

504
00:16:14,146 --> 0:16:15,626
但是在黑暗模式下就出问题了

505
00:16:16,206 --> 0:16:18,786
因此呢 这时你就可以用编程方式使用模板图片

506
00:16:19,016 --> 0:16:21,336
你也可以在资源目录里面自己设置

507
00:16:22,286 --> 0:16:23,526
不过 你不需要

508
00:16:23,526 --> 0:16:24,816
在创建你的黑暗模式 UI 时

509
00:16:24,816 --> 0:16:25,706
把自己的思路限制在模板图片上

510
00:16:26,276 --> 0:16:27,826
你也可以指定颜色

511
00:16:28,156 --> 0:16:30,126
哦 对不起 是指定图片 指定在黑暗模式

512
00:16:30,126 --> 0:16:30,926
显示不同的图片

513
00:16:30,926 --> 0:16:32,086
比如 我们的 Planet App

514
00:16:32,086 --> 0:16:33,756
我们需要在黑暗外观模式的时候

515
00:16:33,756 --> 0:16:35,116
使北美这块区域更多呈现出夜晚的效果

516
00:16:35,116 --> 0:16:36,736
但是在其它外观情况下

517
00:16:36,736 --> 0:16:37,936
则需要使用日光

518
00:16:37,936 --> 0:16:38,606
外观模式

519
00:16:40,286 --> 0:16:43,746
这里不得不提黑暗模式的最妙之处

520
00:16:43,746 --> 0:16:45,936
就在于我们对

521
00:16:45,936 --> 0:16:47,116
桌面图片的处理

522
00:16:47,226 --> 0:16:48,676
大家可以通过我接下来的演示 更好地理解我说的这点

523
00:16:49,036 --> 0:16:50,896
如果你只是粗略地看一下

524
00:16:50,896 --> 0:16:52,986
系统偏好 UI 窗口

525
00:16:52,986 --> 0:16:54,106
似乎看起来只是一个暗灰色

526
00:16:54,106 --> 0:16:55,146
但是其实我们的系统偏好 UI 窗口

527
00:16:55,146 --> 0:16:56,086
比第一眼看上去要复杂多了

528
00:16:56,796 --> 0:16:58,666
我们来看一下这个窗口的后面

529
00:16:58,666 --> 0:16:59,516
我们能够看到这极美的沙丘

530
00:16:59,516 --> 0:17:00,706
而且还有

531
00:16:59,516 --> 0:17:00,706
而且还有

532
00:17:00,706 --> 0:17:02,326
很多蓝色 很多光线

533
00:17:02,326 --> 0:17:03,156
很多深灰色在那里

534
00:17:03,516 --> 0:17:04,715
如果我们

535
00:17:04,715 --> 0:17:05,876
要为这个长方形区域

536
00:17:05,876 --> 0:17:07,546
选择一个平均的蒙板颜色

537
00:17:07,546 --> 0:17:09,276
我们使用的是这个漂亮的深蓝色

538
00:17:10,266 --> 0:17:11,626
所以 当我们创建 UI

539
00:17:11,695 --> 0:17:12,955
然后再加回这个灰色颜色时

540
00:17:13,136 --> 0:17:14,156
它不是纯灰色

541
00:17:14,425 --> 0:17:16,256
我们还在里面保留了那个深蓝色

542
00:17:16,526 --> 0:17:18,086
这个甚至在我们

543
00:17:18,086 --> 0:17:20,036
再在窗口加回单个的控制器时 还会扩散开来

544
00:17:20,036 --> 0:17:22,465
他们都从桌面图片中获得了这个很棒的特性

545
00:17:23,425 --> 0:17:24,746
比如我们这次

546
00:17:24,746 --> 0:17:25,506
想要使用另外一个桌面图片

547
00:17:25,506 --> 0:17:27,425
比方说这个花朵背景的桌面

548
00:17:28,036 --> 0:17:29,866
看到了吧 我们

549
00:17:29,866 --> 0:17:31,646
的背景图片中有了更多亮紫色

550
00:17:31,646 --> 0:17:32,606
亮绿色

551
00:17:32,886 --> 0:17:33,906
这个也影响了系统

552
00:17:33,906 --> 0:17:34,886
的偏好显示窗口

553
00:17:35,496 --> 0:17:36,556
同理 如果我们在这里使用

554
00:17:36,556 --> 0:17:38,106
一个红色的花朵做背景

555
00:17:38,106 --> 0:17:39,546
大家也就能看到

556
00:17:39,546 --> 0:17:41,286
系统偏好窗口从

557
00:17:41,286 --> 0:17:42,826
这个桌面图片中获取了

558
00:17:42,826 --> 0:17:44,196
这样的暖色调

559
00:17:44,196 --> 0:17:46,126
并将这种暖色调适用到所有的 UI 元素之中

560
00:17:47,106 --> 0:17:49,506
你们肯定会自然想到

561
00:17:49,506 --> 0:17:50,786
要实现这个功能

562
00:17:50,786 --> 0:17:52,176
听起来是要有很多动态的工作要做

563
00:17:52,176 --> 0:17:53,736
才能确定窗口在哪里

564
00:17:53,736 --> 0:17:55,276
平均的色彩是什么

565
00:17:55,276 --> 0:17:57,646
然后再把这一切同步起来

566
00:17:57,986 --> 0:17:59,626
其实 大家不要觉得这个工作量很大

567
00:17:59,926 --> 0:18:01,536
而产生畏难情绪

568
00:17:59,926 --> 0:18:01,536
而产生畏难情绪

569
00:18:01,786 --> 0:18:03,026
AppKit 能够帮你搞定这些

570
00:18:04,336 --> 0:18:05,976
这里有很多大家都特别熟悉的类

571
00:18:05,976 --> 0:18:06,826
能够帮助

572
00:18:06,826 --> 0:18:07,886
我们把这些任务都

573
00:18:07,886 --> 0:18:09,056
自动完成好

574
00:18:09,376 --> 0:18:10,486
就是 Window

575
00:18:10,486 --> 0:18:11,806
ScrollView TableView

576
00:18:11,806 --> 0:18:12,546
和 CollectionView

577
00:18:12,816 --> 0:18:14,266
它们在黑暗模式下

578
00:18:14,266 --> 0:18:15,716
不需要任何调整都能看起来很美观

579
00:18:16,126 --> 0:18:16,876
当然了 如果你想要

580
00:18:16,876 --> 0:18:18,596
亲自上手 你也可以

581
00:18:18,596 --> 0:18:20,466
对它们进行微调

582
00:18:20,816 --> 0:18:21,926
这些类都有

583
00:18:21,926 --> 0:18:23,126
一个背景色属性

584
00:18:23,336 --> 0:18:24,706
有四个特别的

585
00:18:24,816 --> 0:18:26,386
NS 颜色是我想要多解释几句的

586
00:18:26,386 --> 0:18:27,806
控制背景颜色

587
00:18:27,806 --> 0:18:29,336
窗口背景颜色

588
00:18:29,336 --> 0:18:30,766
页面下颜色

589
00:18:30,796 --> 0:18:31,126
以及文本背景颜色

590
00:18:31,456 --> 0:18:32,676
这四个 NS 颜色

591
00:18:32,676 --> 0:18:34,586
在调用这些类的时候

592
00:18:34,586 --> 0:18:36,356
都会有一些桌面图片元素的注入

593
00:18:36,356 --> 0:18:37,436
都会随同你想要

594
00:18:37,436 --> 0:18:38,566
创建的 UI 元素

595
00:18:38,646 --> 0:18:39,996
相对应地看起来有些不同

596
00:18:41,176 --> 0:18:44,566
另一个我特别想要提到的类是

597
00:18:44,566 --> 0:18:45,516
NSBox 类

598
00:18:45,916 --> 0:18:47,386
当你想要配置成

599
00:18:47,386 --> 0:18:49,066
用户个性风格的话

600
00:18:49,066 --> 0:18:50,626
你可以使用填充颜色属性

601
00:18:50,626 --> 0:18:51,826
来选择一个特殊的 NS 颜色

602
00:18:51,826 --> 0:18:53,186
或者其它的 NS 颜色

603
00:18:53,666 --> 0:18:55,106
这一点意义非常重大

604
00:18:55,106 --> 0:18:56,466
你可以使用 NSBox 来

605
00:18:56,466 --> 0:18:57,856
给你的 UI 的某一部分

606
00:18:57,856 --> 0:18:59,296
加上颜色

607
00:18:59,296 --> 0:19:01,296
而其它特殊情况下 这些类表现会更不同

608
00:18:59,296 --> 0:19:01,296
而其它特殊情况下 这些类表现会更不同

609
00:19:02,446 --> 0:19:04,656
大家如果想要知道

610
00:19:04,656 --> 0:19:05,926
更多细节的话 我想介绍

611
00:19:05,926 --> 0:19:07,336
另一个 AppKit 类

612
00:19:07,336 --> 0:19:09,356
这就是 NSVisualEffectView

613
00:19:09,956 --> 0:19:11,376
另外 NSVisualEffectView

614
00:19:11,376 --> 0:19:13,336
拥有材料属性

615
00:19:13,336 --> 0:19:15,256
能够使你决定你使用的视觉效果如何

616
00:19:15,256 --> 0:19:16,576
处理其后的背景

617
00:19:16,576 --> 0:19:19,146
如何进行配色操作

618
00:19:19,366 --> 0:19:20,376
我们需要多讲几句

619
00:19:20,376 --> 0:19:21,736
才能让大家明白

620
00:19:21,736 --> 0:19:23,426
在你的 UI 中

621
00:19:23,426 --> 0:19:24,316
VisualEffectView 是如何运作的

622
00:19:24,456 --> 0:19:27,226
在 macOS 10.14 中 我们做了更多的补充

623
00:19:27,476 --> 0:19:30,016
所以 不论你要创建哪一种 UI

624
00:19:30,016 --> 0:19:31,286
我们都有适合你

625
00:19:31,286 --> 0:19:32,636
应用场景

626
00:19:33,376 --> 0:19:34,876
在过去的 OS 版本里

627
00:19:34,876 --> 0:19:36,116
大家都知道我们直接把一些材料属性

628
00:19:36,436 --> 0:19:38,026
标记为 light 或者 dark

629
00:19:38,276 --> 0:19:40,156
大家在新版本中都可以不使用这些

630
00:19:40,156 --> 0:19:41,726
这些和许多新的外观

631
00:19:41,726 --> 0:19:42,836
都不是特别适配

632
00:19:43,426 --> 0:19:46,466
这就引出了我下一个话题

633
00:19:46,466 --> 0:19:47,986
就是我们所说的强化色彩

634
00:19:48,686 --> 0:19:51,296
我们来看看屏幕上的这些 UI 元素

635
00:19:51,296 --> 0:19:53,086
这个视觉色彩确实很惊艳

636
00:19:53,086 --> 0:19:55,826
这些元素看起来很棒对吧

637
00:19:56,336 --> 0:19:59,826
在 macOS 10.14 我们还

638
00:20:00,116 --> 0:20:01,976
添加了更多的强化颜色供用户来进行选择 

639
00:20:02,096 --> 0:20:03,336
这些强化色彩

640
00:20:03,336 --> 0:20:04,056
看起来确实很惊艳

641
00:20:04,876 --> 0:20:06,256
如果你要定制自己的 UI 元素

642
00:20:06,256 --> 0:20:07,946
好吧 我先暂停下 大家先鼓掌

643
00:20:08,516 --> 0:20:12,806
［ 掌声 ］

644
00:20:13,306 --> 0:20:14,256
感谢强化颜色

645
00:20:14,906 --> 0:20:16,146
所以 如果你要创建自己的

646
00:20:16,146 --> 0:20:17,156
UI 元素的话

647
00:20:17,156 --> 0:20:18,286
你需要自己创建一个主题

648
00:20:18,286 --> 0:20:20,196
再把这些颜色融合进去

649
00:20:20,516 --> 0:20:21,856
如果你之前这样操作过的话

650
00:20:21,856 --> 0:20:23,366
你可能已经使用过

651
00:20:23,366 --> 0:20:25,266
NSColor.currentControlTint 方法了

652
00:20:25,266 --> 0:20:27,546
它会返回一个枚举结果

653
00:20:27,546 --> 0:20:29,476
说明系统的模式是 aqua 还是 graphite

654
00:20:29,886 --> 0:20:31,666
现在我们相比过去加入了更多的颜色

655
00:20:31,896 --> 0:20:33,616
那个枚举结果自然就不够用了

656
00:20:34,046 --> 0:20:36,386
因此在 macOS 10.14 我们请大家

657
00:20:36,386 --> 0:20:37,776
切换到 NSColor 中的

658
00:20:37,776 --> 0:20:40,316
controlAccentColor 这个方法

659
00:20:41,416 --> 0:20:44,066
NSColor 还能帮助你处理

660
00:20:44,066 --> 0:20:45,196
强化颜色

661
00:20:45,456 --> 0:20:46,836
NSColor 还能够帮你做很多其他的操作

662
00:20:47,386 --> 0:20:48,686
如果你要创建一个 UI 元素

663
00:20:48,906 --> 0:20:50,116
很常见的一个特征就是

664
00:20:50,116 --> 0:20:51,556
你需要调整

665
00:20:51,646 --> 0:20:52,946
UI 元素的颜色

666
00:20:53,016 --> 0:20:54,956
来反映用户的互动

667
00:20:55,416 --> 0:20:56,956
在这一点上 NSColor 引进了一种新的方式

668
00:20:56,956 --> 0:20:58,716
就是 withSystemEffect

669
00:20:59,336 --> 0:21:00,396
我们也预先定义了一些

670
00:20:59,336 --> 0:21:00,396
我们也预先定义了一些

671
00:21:00,396 --> 0:21:01,686
关于互动的系统效果

672
00:21:01,686 --> 0:21:02,576
例如按压状态

673
00:21:02,576 --> 0:21:04,036
和停用状态 

674
00:21:04,036 --> 0:21:05,616
我们需要继续进行操作

675
00:21:05,616 --> 0:21:07,066
给底色加上一个

676
00:21:07,066 --> 0:21:08,736
适合现在外观的颜色

677
00:21:08,736 --> 0:21:10,176
以及现在

678
00:21:10,176 --> 0:21:12,406
操作面板中的互动元素

679
00:21:12,956 --> 0:21:13,806
这样的话 能节省你很多的功夫

680
00:21:13,806 --> 0:21:14,906
你不需要再

681
00:21:14,906 --> 0:21:17,366
为这些状态开发一个配方

682
00:21:17,366 --> 0:21:18,506
来进行颜色的调整

683
00:21:18,506 --> 0:21:19,636
尤其是你需要

684
00:21:19,636 --> 0:21:20,676
针对不同的互动

685
00:21:20,676 --> 0:21:22,266
来适配数量超级多的

686
00:21:22,266 --> 0:21:23,766
硬编译的颜色

687
00:21:24,126 --> 0:21:25,966
大家都可以试试这个绝妙的 API

688
00:21:26,996 --> 0:21:30,136
我们来继续聊一聊颜色

689
00:21:30,446 --> 0:21:31,926
macOS 10.14 有一个新的

690
00:21:31,926 --> 0:21:34,086
功能特性

691
00:21:34,086 --> 0:21:34,966
我们称其为内容着色

692
00:21:35,996 --> 0:21:36,906
大家看一下我这里的模拟

693
00:21:36,906 --> 0:21:38,706
App 可以看到

694
00:21:38,706 --> 0:21:40,036
这个 App 绝大部分都是用户内容

695
00:21:40,036 --> 0:21:40,816
大部分都是文本

696
00:21:41,296 --> 0:21:42,426
有几个元素

697
00:21:42,426 --> 0:21:44,316
是我希望大家能够格外注意的

698
00:21:45,336 --> 0:21:47,516
这些就是用户可以

699
00:21:47,516 --> 0:21:49,146
点击 然后开展更多操作的元素

700
00:21:49,476 --> 0:21:50,486
在过去 我们不想使用

701
00:21:50,486 --> 0:21:52,276
常规的按钮图形

702
00:21:52,276 --> 0:21:54,026
因为我们觉得这样可能会冲淡内容的地位

703
00:21:54,586 --> 0:21:56,606
但是在 macOS 10.14 中

704
00:21:56,606 --> 0:21:57,686
我们可以允许你给无边框的按钮

705
00:21:57,686 --> 0:21:59,236
着色 然后给调用

706
00:21:59,236 --> 0:22:00,386
这些图像出现时着色

707
00:21:59,236 --> 0:22:00,386
这些图像出现时着色

708
00:22:00,386 --> 0:22:02,616
这样用户就能辨别出 哪些是可以点击可以进行互动的了

709
00:22:03,846 --> 0:22:05,146
这就变得很容易了

710
00:22:06,116 --> 0:22:08,586
NSButton 和 NSImageView 这两个

711
00:22:08,586 --> 0:22:09,536
都有一个新的属性

712
00:22:09,536 --> 0:22:10,456
叫做 contentTintColor

713
00:22:10,816 --> 0:22:11,916
你可以把它设置成任何想要的颜色

714
00:22:11,916 --> 0:22:13,236
比如我之前提到过的

715
00:22:13,236 --> 0:22:14,856
那些动态颜色 就是很好的选择

716
00:22:15,776 --> 0:22:16,826
你也能够在

717
00:22:16,826 --> 0:22:17,596
Interface Builder 里面进行设置

718
00:22:17,926 --> 0:22:19,256
对于配置按钮来说

719
00:22:19,256 --> 0:22:20,436
UI 外观大致就是这样的

720
00:22:20,726 --> 0:22:21,986
对于配置图片试图而言

721
00:22:21,986 --> 0:22:23,106
也基本是这样的

722
00:22:23,576 --> 0:22:25,066
配色选项在这里

723
00:22:25,066 --> 0:22:27,936
右边的工具栏中

724
00:22:28,396 --> 0:22:29,836
我们已经讲了很多

725
00:22:29,836 --> 0:22:31,516
macOS 10.14 中

726
00:22:31,516 --> 0:22:33,446
关于外观的很多很棒的特性

727
00:22:33,706 --> 0:22:35,146
我们也有更多的会议

728
00:22:35,146 --> 0:22:36,696
大家在 WWDC App 里可以看到

729
00:22:36,696 --> 0:22:37,666
我们最新的讲解

730
00:22:37,976 --> 0:22:40,376
都是很不错的

731
00:22:40,556 --> 0:22:41,706
接下来 我来讲讲下一个话题

732
00:22:42,896 --> 0:22:44,026
我们要讲 Cocoa

733
00:22:44,026 --> 0:22:45,976
就必须要谈谈 layer backing

734
00:22:47,436 --> 0:22:48,946
我希望大家都能记住

735
00:22:49,096 --> 0:22:51,056
在 macOS 10.14 中

736
00:22:51,056 --> 0:22:52,046
当你要和新 SDK 连接时

737
00:22:52,046 --> 0:22:54,666
AppKit 再也不会调用

738
00:22:54,666 --> 0:22:56,296
打开窗口的后备存储器

739
00:22:56,596 --> 0:22:58,016
而是直接提供

740
00:22:58,016 --> 0:22:59,246
内容到窗口的服务器

741
00:22:59,246 --> 0:23:01,376
它们使用核心动画图层

742
00:22:59,246 --> 0:23:01,376
它们使用核心动画图层

743
00:23:02,106 --> 0:23:03,326
可能比较熟悉

744
00:23:03,326 --> 0:23:04,456
iOS 开发的大家都会觉得

745
00:23:04,456 --> 0:23:06,156
这个听起来似曾相识

746
00:23:06,156 --> 0:23:07,476
但是大家还是

747
00:23:07,476 --> 0:23:08,416
仔细看看这到底有什么不同

748
00:23:09,186 --> 0:23:11,256
比如我们在 UIKit 有一个这样的树形视图

749
00:23:11,256 --> 0:23:12,596
图像和图层的

750
00:23:12,626 --> 0:23:14,966
关系其实是很简单的

751
00:23:15,306 --> 0:23:17,076
每个图像都有一个图层

752
00:23:17,516 --> 0:23:18,506
而且 图像间的父/子

753
00:23:18,506 --> 0:23:20,196
关系也会

754
00:23:20,196 --> 0:23:21,676
体现在图层树形视图中

755
00:23:22,686 --> 0:23:24,446
但是在 AppKit 中 我们创建的

756
00:23:24,446 --> 0:23:26,696
图层树状视图 其实只是一个过程

757
00:23:26,696 --> 0:23:28,106
只是处理视图层次的一个

758
00:23:28,416 --> 0:23:29,156
附带产物

759
00:23:29,986 --> 0:23:31,856
这样的话 我们就可以

760
00:23:31,856 --> 0:23:33,246
在一些情况下

761
00:23:33,246 --> 0:23:35,436
使用一个图层来处理多个视图

762
00:23:35,806 --> 0:23:37,166
这一点很棒

763
00:23:37,166 --> 0:23:38,036
因为这样可以减少系统内存消耗

764
00:23:38,036 --> 0:23:39,786
GPU 内存消耗

765
00:23:39,786 --> 0:23:41,736
也能减少窗口服务器

766
00:23:41,736 --> 0:23:43,276
在显示屏幕时

767
00:23:43,276 --> 0:23:44,946
要处理的请求压力

768
00:23:45,456 --> 0:23:46,896
这里我也想要

769
00:23:46,896 --> 0:23:48,126
特别指出

770
00:23:48,126 --> 0:23:49,276
刚才我提到的这个特性是动态的

771
00:23:49,276 --> 0:23:51,276
基于视图层次配置的

772
00:23:51,376 --> 0:23:52,966
所以 它可以进行实时变化

773
00:23:53,306 --> 0:23:56,506
因此 现在你就不能在图像间

774
00:23:56,506 --> 0:23:58,006
图层间一直使用一种固定的父/子关系

775
00:23:58,006 --> 0:23:58,946
这和过去的 iOS 是不一样的

776
00:24:03,436 --> 0:24:05,126
从编程角度来看

777
00:24:05,126 --> 0:24:06,776
现在你不需要

778
00:24:09,946 --> 0:24:12,206
来使用图层了

779
00:24:12,206 --> 0:24:13,386
当你在 macOS 10.14 操作时

780
00:24:13,386 --> 0:24:16,506
AppKit 可以帮你搞定这些

781
00:24:16,936 --> 0:24:19,976
如果你要配置

782
00:24:20,516 --> 0:24:24,566
［ 掌声 ］

783
00:24:25,066 --> 0:24:27,576
事实上 我们并不鼓励

784
00:24:27,576 --> 0:24:28,986
大家使用这个属性

785
00:24:28,986 --> 0:24:30,596
如果你把它设置成 ture

786
00:24:30,596 --> 0:24:32,056
我们就必须保证每个图像都

787
00:24:32,056 --> 0:24:33,146
能有自己的图层

788
00:24:33,146 --> 0:24:34,326
这样的话我们就没办法开展想要的优化

789
00:24:34,326 --> 0:24:35,666
开展想要的优化

790
00:24:35,666 --> 0:24:37,306
也就是把多个图像放在

791
00:24:37,306 --> 0:24:38,476
一个图层中

792
00:24:39,056 --> 0:24:40,406
如果你要配置

793
00:24:40,406 --> 0:24:41,176
旧版的 OS 的话 你可能还要用到这些

794
00:24:41,176 --> 0:24:42,956
但是大部分情况下

795
00:24:42,956 --> 0:24:45,516
你可以直接忽略它 不会有什么问题

796
00:24:45,846 --> 0:24:46,826
我也想要谈谈大家

797
00:24:46,826 --> 0:24:48,546
在 NSView UI 中

798
00:24:48,636 --> 0:24:51,076
使用 CALayers 创建的其他样式

799
00:24:51,456 --> 0:24:53,206
最简单的创建 CALayer 的方式

800
00:24:53,206 --> 0:24:54,606
就是在 CALayer 类中

801
00:24:54,606 --> 0:24:56,776
重写这个创建方式

802
00:24:57,196 --> 0:24:58,916
或者调用一个委托方法

803
00:24:59,536 --> 0:25:00,966
这个行得通

804
00:24:59,536 --> 0:25:00,966
这个行得通

805
00:25:00,966 --> 0:25:03,636
NSView 会给你提供很多功能

806
00:25:03,636 --> 0:25:04,796
你不需要每一步

807
00:25:04,796 --> 0:25:05,276
再耗费自己的精力去做

808
00:25:05,836 --> 0:25:08,526
如果你调用 NSView 的创建方法

809
00:25:08,706 --> 0:25:09,886
它就会自动运行

810
00:25:09,886 --> 0:25:11,056
搞定很多事情

811
00:25:11,056 --> 0:25:12,226
保证外观能够很好地

812
00:25:12,226 --> 0:25:13,056
适配动态颜色

813
00:25:13,336 --> 0:25:15,476
也会帮你管理好后备存储器的分辨率

814
00:25:15,876 --> 0:25:17,156
而且 这个和

815
00:25:17,156 --> 0:25:18,706
执行图层方法是一样简便的

816
00:25:18,986 --> 0:25:19,986
所以 我建议大家能够在

817
00:25:19,986 --> 0:25:21,166
图像层面来进行重写

818
00:25:21,166 --> 0:25:22,516
而不是在图层层面进行

819
00:25:23,626 --> 0:25:25,576
在一些情况下

820
00:25:25,916 --> 0:25:27,606
当你在执行 CALayer 的显示模式时

821
00:25:27,606 --> 0:25:29,016
你正在直接更新图层的属性

822
00:25:29,016 --> 0:25:31,486
这样做可能使你觉得更加高效

823
00:25:31,716 --> 0:25:32,486
或者是这样做

824
00:25:32,486 --> 0:25:33,706
能够帮你更好地

825
00:25:33,706 --> 0:25:35,136
实现自己的构想

826
00:25:35,446 --> 0:25:37,426
你仍然可以使用

827
00:25:37,426 --> 0:25:39,196
NSView API

828
00:25:39,196 --> 0:25:40,806
只要使用代理更新图层方法即可

829
00:25:40,806 --> 0:25:42,106
这个和使用 NSView drawRect 方法

830
00:25:42,106 --> 0:25:43,786
得到的效果是一样的

831
00:25:44,556 --> 0:25:46,756
另外 你也可以

832
00:25:46,756 --> 0:25:48,026
在 NSView 中

833
00:25:48,026 --> 0:25:50,226
同步执行图层更新和调用绘画方法

834
00:25:50,846 --> 0:25:52,256
如果你这样操作

835
00:25:52,256 --> 0:25:53,576
当你的图像只有一个图层的话

836
00:25:53,576 --> 0:25:54,496
我们就会使用

837
00:25:54,496 --> 0:25:55,546
可选图层版本

838
00:25:56,006 --> 0:25:57,296
如果你的图像正在和其它合并

839
00:25:57,296 --> 0:25:58,546
以节省内存的话

840
00:25:58,896 --> 0:26:00,536
我们就会使用 drawRect 版本

841
00:25:58,896 --> 0:26:00,536
我们就会使用 drawRect 版本

842
00:26:00,746 --> 0:26:01,996
对于 printing 而言

843
00:26:01,996 --> 0:26:02,556
我们也应用了这一点

844
00:26:02,616 --> 0:26:04,296
所以 执行这两点是完全行得通的

845
00:26:05,056 --> 0:26:06,386
如果你的一个图像

846
00:26:06,386 --> 0:26:07,726
是使用 CG drawing API 无法实现的

847
00:26:07,806 --> 0:26:09,346
AppKit drawing API 也无法实现

848
00:26:09,346 --> 0:26:11,336
你需要做的就是

849
00:26:11,336 --> 0:26:12,406
除了要使用更新图层方法外

850
00:26:12,406 --> 0:26:13,576
还要调用代理 wantsUpdateLayer 方法

851
00:26:13,576 --> 0:26:16,906
如果你返回 ture 的话

852
00:26:16,906 --> 0:26:18,186
我们就能够知道你需要一个

853
00:26:18,186 --> 0:26:20,216
显式图层来实现你想要的展示

854
00:26:22,276 --> 0:26:24,626
另一个能够将 AppKit

855
00:26:24,626 --> 0:26:26,476
和其它核心动画特性发挥到极致

856
00:26:26,476 --> 0:26:27,746
的方法是

857
00:26:27,976 --> 0:26:29,236
使用 NSViews 中特别简单的

858
00:26:29,236 --> 0:26:30,206
词汇创建

859
00:26:30,206 --> 0:26:33,096
你自己的 UI

860
00:26:33,456 --> 0:26:35,166
NSImageView NSBox 以及

861
00:26:35,166 --> 0:26:36,926
NSTextField 都是特别好的

862
00:26:36,926 --> 0:26:38,336
创建模块

863
00:26:38,336 --> 0:26:39,446
可以用来创建复杂的 UI

864
00:26:39,666 --> 0:26:42,286
不论你使用何种技术来展示

865
00:26:42,286 --> 0:26:43,966
它们都能适配正确的方式

866
00:26:45,606 --> 0:26:46,546
另外 因为我们对 layer backing

867
00:26:46,546 --> 0:26:48,376
做了一些改动

868
00:26:48,376 --> 0:26:49,566
有一些图案是

869
00:26:49,566 --> 0:26:51,396
不再和 macOS 10.14 适配的

870
00:26:51,996 --> 0:26:53,616
例如你使用 NSView lockFocus

871
00:26:53,616 --> 0:26:55,106
和 unlockFocus

872
00:26:55,106 --> 0:26:56,566
或者试图直接使用窗口的图像内容

873
00:26:56,566 --> 0:27:00,116
实际上有更好的实现方式

874
00:26:56,566 --> 0:27:00,116
实际上有更好的实现方式

875
00:27:00,116 --> 0:27:01,656
你只需要子类 NSView

876
00:27:01,656 --> 0:27:02,556
并执行 drawRect 就行

877
00:27:02,846 --> 0:27:04,786
这些方法之前都有些繁琐

878
00:27:04,786 --> 0:27:08,326
所以 你其实能够省去一些麻烦

879
00:27:08,756 --> 0:27:09,716
其次 我还想要说一点

880
00:27:09,716 --> 0:27:10,686
这个其实是用

881
00:27:10,686 --> 0:27:12,236
Objective-C 写的

882
00:27:12,236 --> 0:27:13,606
似乎在关于 Swift 的演讲中出现

883
00:27:13,606 --> 0:27:14,986
有些奇怪

884
00:27:14,986 --> 0:27:16,486
事实上 最好的消息是

885
00:27:16,486 --> 0:27:18,146
我还真没有看到

886
00:27:18,146 --> 0:27:19,676
任何 Swift 代码使用这些

887
00:27:20,276 --> 0:27:21,656
从中我觉得

888
00:27:21,656 --> 0:27:22,986
我不希望你们

889
00:27:22,986 --> 0:27:25,056
做第一个尝试并给我惊喜的人

890
00:27:26,456 --> 0:27:29,816
最后有关我们对 layer backing 做的改动

891
00:27:29,816 --> 0:27:31,086
还需要再说一点

892
00:27:31,456 --> 0:27:33,326
如果你使用 NSOpenGL 类

893
00:27:33,326 --> 0:27:34,726
来和 OpenGL 进行协同操作

894
00:27:34,726 --> 0:27:37,106
要和 macOS 10.14 连接的话

895
00:27:37,106 --> 0:27:38,466
我们一些执行细节

896
00:27:38,466 --> 0:27:39,756
有关我们将图层关联 OpenGL 系统

897
00:27:39,756 --> 0:27:41,976
的执行细节这一层面上有一些不同之处

898
00:27:41,976 --> 0:27:43,816
大家也可能发现了一些小小的变化

899
00:27:44,576 --> 0:27:45,846
不过最重要的是

900
00:27:45,846 --> 0:27:48,206
我想要大家明白一点

901
00:27:48,426 --> 0:27:49,756
在 macOS 10.14 上 我们不推荐大家

902
00:27:49,806 --> 0:27:50,426
使用 OpenGL

903
00:27:51,016 --> 0:27:52,626
如果你过去一直使用 NSOpenGL

904
00:27:52,626 --> 0:27:55,846
我们真的建议你换成 MTKView

905
00:27:55,956 --> 0:27:57,166
今天我们还有一场会议

906
00:27:57,166 --> 0:27:58,676
会仔细给大家介绍

907
00:27:58,676 --> 0:28:00,556
如何帮助开发者为 OpenGL 采用 Metal

908
00:27:58,676 --> 0:28:00,556
如何帮助开发者为 OpenGL 采用 Metal

909
00:28:03,286 --> 0:28:04,816
还有最后一点我想要聊聊的变化

910
00:28:04,816 --> 0:28:06,256
这个变化就是我们对于

911
00:28:06,256 --> 0:28:07,706
字体反混淆化做的努力

912
00:28:08,526 --> 0:28:09,796
大家可以仔细看看这两个屏幕的对比

913
00:28:09,796 --> 0:28:11,386
左边的是 10.13

914
00:28:11,386 --> 0:28:14,656
右边的是 macOS 10.14

915
00:28:14,656 --> 0:28:16,036
如果我们看窗口里的文字的话

916
00:28:16,036 --> 0:28:18,186
基本上是一样的

917
00:28:18,896 --> 0:28:21,416
但是如果我们放大拉近

918
00:28:21,416 --> 0:28:23,676
放大到 48X 的话

919
00:28:23,766 --> 0:28:26,246
我们就能够看到

920
00:28:26,246 --> 0:28:27,506
macOS 10.13 实际上用的是

921
00:28:27,506 --> 0:28:28,366
色彩边纹效果来显示其字体

922
00:28:29,216 --> 0:28:32,836
而在 macOS 10.14 中

923
00:28:32,836 --> 0:28:33,326
我们不再用这个效果了

924
00:28:33,596 --> 0:28:34,796
这就意味着

925
00:28:34,796 --> 0:28:36,806
我们的文字在更广的平台技术上

926
00:28:36,806 --> 0:28:38,436
会变得更加美观

927
00:28:38,436 --> 0:28:39,276
当然在扩展缩放模式上也会更好看

928
00:28:40,316 --> 0:28:42,166
这样说来

929
00:28:42,166 --> 0:28:43,096
我们还有很多好消息要和大家分享

930
00:28:43,406 --> 0:28:44,226
有关这一点

931
00:28:44,226 --> 0:28:45,956
我想要邀请 Jesse 上台给大家讲一讲

932
00:28:46,516 --> 0:28:51,686
［ 掌声 ］

933
00:28:52,186 --> 0:28:52,716
&gt;&gt; 谢谢 Chris

934
00:28:53,116 --> 0:28:54,876
大家好 今天很高兴能在这里见到你们

935
00:28:55,506 --> 0:28:57,236
我有很多话题要讲

936
00:28:57,236 --> 0:28:59,546
首先 我要从用户通知的框架开始

937
00:28:59,976 --> 0:29:01,506
这个功能已经在 iOS 上

938
00:28:59,976 --> 0:29:01,506
这个功能已经在 iOS 上

939
00:29:01,506 --> 0:29:02,806
使用一段时间了

940
00:29:02,806 --> 0:29:04,846
这次 macOS Mojave 我们将把这个功能

941
00:29:04,846 --> 0:29:05,316
带给 Mac

942
00:29:07,646 --> 0:29:09,546
这个功能也能使用户更好地

943
00:29:09,546 --> 0:29:10,676
控制通知

944
00:29:11,226 --> 0:29:12,126
而且这还意味着

945
00:29:12,126 --> 0:29:13,246
你的 App 也可以像在 iOS 上一样

946
00:29:13,296 --> 0:29:14,986
与这些通知协同工作

947
00:29:15,676 --> 0:29:17,576
它们将会使用 userNotificationCenter 的

948
00:29:17,576 --> 0:29:18,666
NSApplication 方法

949
00:29:18,886 --> 0:29:20,486
registerForRemoteNotifications

950
00:29:21,176 --> 0:29:25,536
以及 requestAuthorization 方法

951
00:29:27,306 --> 0:29:28,676
作为工作的一部分

952
00:29:28,676 --> 0:29:30,406
我们也会弃用一些已经存在的

953
00:29:30,806 --> 0:29:32,786
用户通知相关的 API

954
00:29:32,826 --> 0:29:34,956
尤其是在 NSApplication

955
00:29:35,316 --> 0:29:36,126
我们将弃用

956
00:29:36,126 --> 0:29:37,296
remoteNotificationType

957
00:29:37,386 --> 0:29:39,416
OptionSet 和

958
00:29:39,656 --> 0:29:41,776
registerForRemoteNotifications 方法 以及

959
00:29:41,776 --> 0:29:44,576
enabledRemoteNotificationTypes 性能

960
00:29:45,326 --> 0:29:46,686
我们也会弃用所有的

961
00:29:46,686 --> 0:29:47,846
NSUserNotification

962
00:29:49,256 --> 0:29:50,716
那么既然你要使用 SDK 重新建立

963
00:29:50,876 --> 0:29:54,256
你最好升级用户通知框架

964
00:29:56,586 --> 0:29:59,356
接下来 我想讲一讲 NSToolbar

965
00:30:00,396 --> 0:30:01,556
当你想在工具栏中居中

966
00:30:01,556 --> 0:30:02,876
一个项目时 你可能会想要在 item 的两个

967
00:30:02,876 --> 0:30:05,226
你可能会想要在项目的两侧

968
00:30:05,226 --> 0:30:07,686
各留一个灵活的空间

969
00:30:07,686 --> 0:30:09,446
这种方式可以奏效

970
00:30:09,446 --> 0:30:09,926
但还是有一些缺点

971
00:30:10,076 --> 0:30:11,706
尤其是当你在工具栏中添加

972
00:30:11,706 --> 0:30:13,106
额外的项目时 它将会 

973
00:30:13,106 --> 0:30:14,246
把你的项目从中间移走

974
00:30:14,946 --> 0:30:16,716
所以 NSToolbar 现在出现了一个

975
00:30:16,716 --> 0:30:17,456
新的属性

976
00:30:17,516 --> 0:30:18,616
centeredItemIdentifier

977
00:30:19,406 --> 0:30:21,906
你可以将想置于中心的项目设置标识

978
00:30:21,906 --> 0:30:23,416
这样 NSToolbar 就会

979
00:30:23,456 --> 0:30:24,876
一直将它放在那里

980
00:30:25,486 --> 0:30:26,736
除非其他工具栏项目

981
00:30:26,736 --> 0:30:28,376
迫使它移动

982
00:30:28,376 --> 0:30:29,696
否则它会一直在那里

983
00:30:31,276 --> 0:30:32,326
这里还有另外一个改变

984
00:30:32,326 --> 0:30:35,426
也值得一提

985
00:30:35,426 --> 0:30:38,616
就是自动布局现已用于

986
00:30:38,616 --> 0:30:40,036
衡量工具栏的项目

987
00:30:40,036 --> 0:30:41,816
在最大或最小的尺寸

988
00:30:41,816 --> 0:30:42,616
没有进行规定的时候

989
00:30:44,846 --> 0:30:46,466
这个功能仅适用于 

990
00:30:46,466 --> 0:30:48,746
10.14 SDK 的 App 但是这意味着比如说你可以

991
00:30:48,746 --> 0:30:50,066
比如说你可以改动

992
00:30:50,066 --> 0:30:52,976
按钮的大小 测量功能将会替你完成的

993
00:30:53,516 --> 0:30:59,546
［ 掌声 ］

994
00:31:00,046 --> 0:31:01,546
centeredItemIdentifier

995
00:31:01,766 --> 0:31:03,306
行为在 Interface Builder 中

996
00:31:03,306 --> 0:31:04,546
也可使用

997
00:31:04,546 --> 0:31:05,916
这是工具栏项目的

998
00:31:05,916 --> 0:31:08,846
检查窗格 你可以看到在最底下

999
00:31:08,846 --> 0:31:10,906
有一个新的勾选框 写着 “Is Centered Item.”

1000
00:31:11,206 --> 0:31:12,766
你可以勾选上 而不必再在代码中

1001
00:31:12,766 --> 0:31:13,836
进行设置

1002
00:31:13,836 --> 0:31:16,666
而且也不必再退回编程 API

1003
00:31:16,666 --> 0:31:18,366
你可以继续在 Interface Builder 中

1004
00:31:18,366 --> 0:31:20,306
进行你所有的 UI 工作

1005
00:31:21,916 --> 0:31:22,916
提到 Interface

1006
00:31:22,916 --> 0:31:24,696
Builder 我简直产生了无法形容的激动

1007
00:31:24,696 --> 0:31:26,286
因为 Interface

1008
00:31:26,326 --> 0:31:27,826
Builder 新增了支持编辑 

1009
00:31:27,826 --> 0:31:29,436
NSGridViews

1010
00:31:30,726 --> 0:31:31,646
如果你对 gridView 不熟悉的话

1011
00:31:31,646 --> 0:31:33,066
我可以告诉你 我们多年以前就引入了它

1012
00:31:33,066 --> 0:31:34,636
它是一种早期的布局

1013
00:31:34,636 --> 0:31:36,046
使用一种方格状的结构

1014
00:31:36,046 --> 0:31:37,656
来呈现你的视觉效果

1015
00:31:38,136 --> 0:31:39,166
这是从一个钥匙串访问 App 

1016
00:31:39,166 --> 0:31:40,276
中取的范例

1017
00:31:40,276 --> 0:31:42,026
你可以想象

1018
00:31:42,026 --> 0:31:43,326
要是手动创建这种布局

1019
00:31:43,326 --> 0:31:45,716
要动用多少系统规定参数

1020
00:31:46,186 --> 0:31:47,206
你还可以使用

1021
00:31:47,326 --> 0:31:49,436
stackViews 来构建这种效果

1022
00:31:49,436 --> 0:31:51,456
但是 NSGridView 使整个事件更加容易

1023
00:31:51,456 --> 0:31:52,936
并且这个 Interface Builder

1024
00:31:52,936 --> 0:31:54,266
中全新的编辑功能支持简直太赞了

1025
00:31:54,266 --> 0:31:56,066
太赞了 让我来给你展示一下

1026
00:31:57,396 --> 0:31:58,896
这是一些 UI 来自

1027
00:31:58,896 --> 0:31:59,846
storyboard 文件

1028
00:32:00,286 --> 0:32:01,846
你可以选中这些控制量

1029
00:32:02,176 --> 0:32:03,766
然后将它们纳入到方格的试图

1030
00:32:03,766 --> 0:32:05,216
那么之后 你就可以进行操作

1031
00:32:05,216 --> 0:32:06,486
将这些小格子的

1032
00:32:06,486 --> 0:32:07,826
填充和直线

1033
00:32:07,946 --> 0:32:10,646
调整成你想要的样子

1034
00:32:11,876 --> 0:32:13,756
编辑 UI 的工作方式很像 

1035
00:32:13,756 --> 0:32:14,916
编号电子表格 App

1036
00:32:15,256 --> 0:32:16,896
你可以将视图拖拉或者放置到

1037
00:32:16,896 --> 0:32:17,596
cell 里

1038
00:32:17,706 --> 0:32:19,356
你可以成行成列地选中

1039
00:32:19,356 --> 0:32:21,586
并调整它们的属性

1040
00:32:22,426 --> 0:32:23,836
你甚至可以合并 cells 

1041
00:32:23,836 --> 0:32:25,436
正如你看到的最后两行那里

1042
00:32:26,506 --> 0:32:29,236
这里举个例子 我们选中一列

1043
00:32:29,786 --> 0:32:31,466
这就是检查

1044
00:32:31,466 --> 0:32:32,866
窗格显示的样子 可以看到

1045
00:32:32,866 --> 0:32:34,366
你能调整

1046
00:32:34,366 --> 0:32:35,706
这一列 cells 的位置

1047
00:32:36,066 --> 0:32:37,936
你可以调整头和尾的填充

1048
00:32:38,356 --> 0:32:39,546
如果我们切换到尺寸检查器

1049
00:32:39,546 --> 0:32:41,336
你可以给纵列调整

1050
00:32:41,336 --> 0:32:42,976
明确的宽度

1051
00:32:42,976 --> 0:32:44,206
如果你不进行设置

1052
00:32:44,206 --> 0:32:45,216
纵列的大小就会

1053
00:32:45,216 --> 0:32:46,946
根据内容自动调整

1054
00:32:49,036 --> 0:32:50,106
关于这个特性

1055
00:32:50,106 --> 0:32:51,816
另外一个特别赞的事情就是

1056
00:32:52,606 --> 0:32:54,216
它是可逆展开

1057
00:32:54,426 --> 0:32:56,216
GridViews 在 Interface

1058
00:32:56,216 --> 0:32:58,456
Builder 中可使用 同样也可以回用到

1059
00:32:58,456 --> 0:33:01,686
macOS 10.13.4

1060
00:32:58,456 --> 0:33:01,686
macOS 10.13.4

1061
00:33:01,686 --> 0:33:03,306
如果你还没有使用合并的 cells

1062
00:33:03,306 --> 0:33:05,016
你甚至可以回用到10.12 

1063
00:33:05,556 --> 0:33:07,616
所以 如果你想要将你的 App 

1064
00:33:07,616 --> 0:33:08,696
使用在较老版本的 macOS 上

1065
00:33:08,696 --> 0:33:10,776
别再等待了

1066
00:33:10,776 --> 0:33:12,796
直接使用这个超赞的新功能吧

1067
00:33:15,186 --> 0:33:17,076
下一个我想要聊的话题是

1068
00:33:17,126 --> 0:33:18,826
NSTextView 的一些改变

1069
00:33:20,176 --> 0:33:22,046
首先 有一些新的代理方法

1070
00:33:22,756 --> 0:33:24,466
第一个是 fieldEditor

1071
00:33:24,896 --> 0:33:27,756
配置了一个 textView 

1072
00:33:27,756 --> 0:33:29,816
为了给 NSTextField 用作 fieldEditor 

1073
00:33:29,936 --> 0:33:32,716
这些都提供了一个更为简单的方式

1074
00:33:32,716 --> 0:33:34,276
来配置 textViews

1075
00:33:34,276 --> 0:33:35,226
用于常见案例的使用

1076
00:33:36,256 --> 0:33:38,666
后面的三个使得

1077
00:33:38,746 --> 0:33:40,366
textViews 被纳入到 scrollViews

1078
00:33:40,946 --> 0:33:42,296
这是目前为止 textView 最为常见的

1079
00:33:42,296 --> 0:33:44,266
使用案例

1080
00:33:44,266 --> 0:33:45,156
但如果你不得不对 textView 做

1081
00:33:45,156 --> 0:33:46,406
额外的配置

1082
00:33:46,406 --> 0:33:47,786
一定要记得查看

1083
00:33:47,786 --> 0:33:49,526
scrollView 的

1084
00:33:49,576 --> 0:33:50,146
documentView 这非常重要

1085
00:33:51,426 --> 0:33:52,756
这些在 Interface Builder 同样也是

1086
00:33:52,756 --> 0:33:53,526
可以使用的

1087
00:33:53,526 --> 0:33:54,566
因此 再次重复 这里也没有必要去

1088
00:33:54,566 --> 0:33:56,436
后退回编程 API

1089
00:33:57,366 --> 0:33:58,446
下面让我们看一下 它们是什么样子的

1090
00:33:59,356 --> 0:34:00,776
这里的窗口做例子

1091
00:33:59,356 --> 0:34:00,776
这里的窗口做例子

1092
00:34:00,776 --> 0:34:01,616
显示了全部的 4 个

1093
00:34:02,236 --> 0:34:03,226
TextViews 有时候

1094
00:34:03,226 --> 0:34:04,916
会被误配置 当客户需要在

1095
00:34:04,916 --> 0:34:06,506
textField 中优先

1096
00:34:06,576 --> 0:34:07,066
fieldEditor 时

1097
00:34:07,236 --> 0:34:08,766
所以 使用一个 fieldEditor

1098
00:34:08,766 --> 0:34:10,856
代理方法可以帮助避免此问题

1099
00:34:11,815 --> 0:34:13,636
下一个 scrollableTextView

1100
00:34:14,346 --> 0:34:15,716
应该被用于 textViews

1101
00:34:15,815 --> 0:34:17,946
中弹窗和检查器窗格的

1102
00:34:17,946 --> 0:34:19,726
补充文本

1103
00:34:19,726 --> 0:34:20,386
诸如此类的情况

1104
00:34:20,386 --> 0:34:22,376
接下来 最下面的两个

1105
00:34:22,376 --> 0:34:24,266
适用于文件内容的文本

1106
00:34:24,456 --> 0:34:25,996
左边的适用于格式化文本

1107
00:34:25,996 --> 0:34:28,025
右边的适用于纯文本

1108
00:34:28,846 --> 0:34:29,846
在这一点上你可能会想知道

1109
00:34:29,926 --> 0:34:31,466
它们的区别是什么

1110
00:34:31,516 --> 0:34:33,106
因为看起来真的非常相似

1111
00:34:33,596 --> 0:34:34,696
主要的好处就是

1112
00:34:34,696 --> 0:34:35,775
你不必再担心

1113
00:34:35,775 --> 0:34:36,755
系统配置的问题了

1114
00:34:37,496 --> 0:34:38,936
比如说 黑暗模式的系统中

1115
00:34:38,936 --> 0:34:41,326
它们会看起来截然不同

1116
00:34:42,266 --> 0:34:44,746
格式化文本的 textView 仍保持

1117
00:34:44,746 --> 0:34:46,045
白色背景

1118
00:34:46,045 --> 0:34:47,926
而纯文本会变成黑色

1119
00:34:48,016 --> 0:34:49,406
来匹配剩余的系统

1120
00:34:50,106 --> 0:34:51,396
所以 通常来讲 如果你使用这些

1121
00:34:51,396 --> 0:34:52,815
代理方法 会帮助你维持

1122
00:34:52,815 --> 0:34:55,775
你的 App 与系统其它 App

1123
00:34:55,775 --> 0:34:56,255
保持一致

1124
00:34:58,696 --> 0:34:59,876
我想说的关于 textView

1125
00:34:59,876 --> 0:35:01,206
的另一改变是

1126
00:34:59,876 --> 0:35:01,206
的另一改变是

1127
00:35:01,206 --> 0:35:03,486
修改文本的新方法

1128
00:35:04,176 --> 0:35:05,686
PerformValidatedReplacement

1129
00:35:06,276 --> 0:35:07,916
这个方法背后的想法是

1130
00:35:07,966 --> 0:35:09,186
它提供给你一种非常简单的方式

1131
00:35:09,186 --> 0:35:10,866
去修改 textView 中的文本

1132
00:35:10,866 --> 0:35:12,936
而且还给你一种行为 

1133
00:35:12,936 --> 0:35:14,516
就像是用户自己 

1134
00:35:14,516 --> 0:35:15,876
做出了这个修改

1135
00:35:16,916 --> 0:35:17,936
它控制了所有

1136
00:35:17,936 --> 0:35:20,286
适合的你期待的方法

1137
00:35:20,696 --> 0:35:21,936
但是 真正有趣的部分是

1138
00:35:21,936 --> 0:35:23,716
任何一个属性 当它没有被特定指派给

1139
00:35:23,716 --> 0:35:27,196
输入的字符串时 textView 的

1140
00:35:27,196 --> 0:35:28,506
typingAttributes 会自动将其

1141
00:35:28,616 --> 0:35:29,296
匹配输入

1142
00:35:30,466 --> 0:35:31,976
我来给你们举个例子吧

1143
00:35:32,506 --> 0:35:33,856
这个窗口有一些格式化文本 

1144
00:35:33,856 --> 0:35:36,196
代码中的一个小片段调用 

1145
00:35:36,266 --> 0:35:38,346
performValidatedReplacement

1146
00:35:38,346 --> 0:35:40,196
去在中间插入 "Developers" 这个单词

1147
00:35:41,266 --> 0:35:42,996
如果我们运行这个 这就是我们

1148
00:35:42,996 --> 0:35:43,256
获得的内容

1149
00:35:43,256 --> 0:35:45,226
单词出现了 而且与周围文本的

1150
00:35:45,226 --> 0:35:46,346
格式一致 

1151
00:35:46,406 --> 0:35:48,126
我们不必去特别指定

1152
00:35:48,126 --> 0:35:49,436
任何一个属性

1153
00:35:50,246 --> 0:35:51,896
但是 这里也有一个细微的地方

1154
00:35:51,896 --> 0:35:52,576
需要注意

1155
00:35:52,646 --> 0:35:55,236
因为后退

1156
00:35:55,236 --> 0:35:56,376
属性来自于 

1157
00:35:56,446 --> 0:35:57,316
typingAttributes 

1158
00:35:57,426 --> 0:35:59,226
因此 如果你开始使用格式化文本来进行

1159
00:35:59,336 --> 0:36:00,436
此操作

1160
00:35:59,336 --> 0:36:00,436
此操作

1161
00:36:00,436 --> 0:36:02,506
插入的部分

1162
00:36:02,506 --> 0:36:04,156
最后就会显示为亮色

1163
00:36:04,156 --> 0:36:06,496
我们运行的还是同样的代码

1164
00:36:06,496 --> 0:36:09,746
这就是结果 格式属性

1165
00:36:09,746 --> 0:36:10,896
来自于最后的亮色部分

1166
00:36:12,486 --> 0:36:14,036
这个原因让你发现

1167
00:36:14,036 --> 0:36:15,316
在调用

1168
00:36:15,316 --> 0:36:16,896
performValidatedReplacement 之前

1169
00:36:16,896 --> 0:36:18,136
你需要为你即将取代的部分设置

1170
00:36:18,136 --> 0:36:19,956
设置选定的范围

1171
00:36:22,896 --> 0:36:24,416
如果你如此操作的话

1172
00:36:24,416 --> 0:36:25,216
这就是你获得的结果

1173
00:36:27,336 --> 0:36:28,966
对于下一个话题

1174
00:36:28,966 --> 0:36:30,436
连续相机

1175
00:36:30,466 --> 0:36:31,406
我想快速讲一下

1176
00:36:31,856 --> 0:36:35,376
这是在 macOS Mojave 中另一个很赞的特性

1177
00:36:36,196 --> 0:36:37,216
如果你只是使用

1178
00:36:37,216 --> 0:36:38,746
标准的框架类 比如

1179
00:36:38,746 --> 0:36:40,196
NSTextView 要利用这个特性

1180
00:36:40,196 --> 0:36:41,746
你不需要做什么

1181
00:36:41,746 --> 0:36:42,766
特殊的设置

1182
00:36:42,806 --> 0:36:44,336
框架会为你解决一切事情

1183
00:36:45,016 --> 0:36:45,996
但是 如果你有更多

1184
00:36:45,996 --> 0:36:49,136
特定的 App 需要用到它

1185
00:36:49,306 --> 0:36:51,186
你可能需要更直接地使用它

1186
00:36:51,336 --> 0:36:52,296
另外还很重要的一点

1187
00:36:52,296 --> 0:36:53,806
需要了解的就是它是使用

1188
00:36:53,806 --> 0:36:56,066
现存服务的 API 去执行的

1189
00:36:56,726 --> 0:36:58,236
所以 你需要做的就是告诉

1190
00:36:58,236 --> 0:36:59,756
一个框架你的回应

1191
00:36:59,756 --> 0:37:01,606
类有能力解决图片数据

1192
00:36:59,756 --> 0:37:01,606
类有能力解决图片数据

1193
00:37:01,926 --> 0:37:04,366
并且 你可以通过执行 validRequestor 来实现

1194
00:37:05,166 --> 0:37:07,006
如果你想尝试

1195
00:37:07,006 --> 0:37:08,046
我会鼓励你去查看

1196
00:37:08,046 --> 0:37:09,866
validRequestor 的文稿以及

1197
00:37:09,866 --> 0:37:11,126
其他一些相关的方法

1198
00:37:13,686 --> 0:37:15,196
下面我想讲一下

1199
00:37:15,326 --> 0:37:16,296
自定义快捷操作

1200
00:37:16,436 --> 0:37:17,496
昨天年度咨文部分的会议上

1201
00:37:17,496 --> 0:37:19,716
你可能听到一些关于

1202
00:37:19,716 --> 0:37:21,126
快捷操作的内容

1203
00:37:21,126 --> 0:37:23,746
快捷操作使得简单的操作动作变得非常容易

1204
00:37:24,466 --> 0:37:26,496
比如说打开一个最喜爱的 App

1205
00:37:26,496 --> 0:37:27,916
复杂的动作比如

1206
00:37:27,916 --> 0:37:33,076
筛选文件或者调用脚本 也很简单

1207
00:37:33,326 --> 0:37:35,406
你可以使用 App 扩展或者

1208
00:37:35,406 --> 0:37:38,936
Automator 的动作套装 

1209
00:37:38,936 --> 0:37:40,296
构建自动移快捷操作

1210
00:37:41,136 --> 0:37:42,116
它们在很多地方都非常有用

1211
00:37:42,116 --> 0:37:43,926
并且也有诸多方式

1212
00:37:43,926 --> 0:37:45,406
可以调用它们

1213
00:37:45,406 --> 0:37:47,676
但是 到目前为止我最爱的还是触控栏

1214
00:37:48,376 --> 0:37:49,816
如果将你的快速操作应用到

1215
00:37:49,816 --> 0:37:51,036
触控栏上 会非常容易就可以使用

1216
00:37:51,036 --> 0:37:52,246
不管你在哪儿

1217
00:37:52,536 --> 0:37:54,186
不管何时你需要它们

1218
00:37:54,656 --> 0:37:55,786
你可以通过键盘的偏好设置中

1219
00:37:55,786 --> 0:37:56,816
偏好设置中获得

1220
00:37:56,816 --> 0:37:58,326
这项操作

1221
00:37:58,326 --> 0:37:59,846
并且可以重新设置你的触控栏

1222
00:37:59,846 --> 0:38:01,726
是一直展示

1223
00:37:59,846 --> 0:38:01,726
是一直展示

1224
00:38:01,726 --> 0:38:03,776
还是当控制功能键的时候 进行折叠

1225
00:38:04,416 --> 0:38:05,736
或者 你可以将触控栏自定义

1226
00:38:05,806 --> 0:38:07,796
将工作流的按钮

1227
00:38:07,796 --> 0:38:09,146
拉进控制脚本中

1228
00:38:11,596 --> 0:38:12,706
还有一点值得注意的是

1229
00:38:12,706 --> 0:38:13,876
你可以去快捷窗格浏览

1230
00:38:13,936 --> 0:38:15,926
在服务下面查看

1231
00:38:16,496 --> 0:38:18,096
这里你可以通过打开或者关闭

1232
00:38:18,096 --> 0:38:19,346
来控制哪一个

1233
00:38:19,576 --> 0:38:21,416
可以显示出来

1234
00:38:21,416 --> 0:38:22,366
正如我提到的

1235
00:38:22,366 --> 0:38:23,776
它们不仅仅是显示在触控栏

1236
00:38:23,776 --> 0:38:25,576
我用访达窗格来进行举例

1237
00:38:25,636 --> 0:38:27,366
如你所见 contextual 菜单下面的

1238
00:38:27,366 --> 0:38:31,086
还有一个快捷操作

1239
00:38:31,466 --> 0:38:33,386
访达的预览窗格

1240
00:38:33,386 --> 0:38:34,436
也有很多快捷操作 

1241
00:38:34,436 --> 0:38:36,026
显示在底部 而且完整的列表

1242
00:38:36,296 --> 0:38:37,406
在“更多”按钮下面

1243
00:38:38,056 --> 0:38:39,456
Automator 的行动套装显示在

1244
00:38:39,456 --> 0:38:41,866
服务菜单里面

1245
00:38:42,396 --> 0:38:44,036
比如说 TrimLogs 就是一个我写来用于

1246
00:38:44,036 --> 0:38:45,936
筛选校正错误的日志的

1247
00:38:47,176 --> 0:38:48,776
这也引入了我想要说的 

1248
00:38:48,776 --> 0:38:50,176
下一个话题

1249
00:38:50,516 --> 0:38:52,166
创建行动套装 也被成为

1250
00:38:52,166 --> 0:38:53,816
contextual 工作流

1251
00:38:54,406 --> 0:38:56,216
这是 Automator 的新功能 

1252
00:38:56,516 --> 0:38:57,456
当你进入

1253
00:38:57,456 --> 0:38:58,546
创建一个新文档

1254
00:38:58,546 --> 0:38:59,886
会有一个关于 contextual 工作流

1255
00:38:59,886 --> 0:39:01,006
的新的可选项

1256
00:38:59,886 --> 0:39:01,006
的新的可选项

1257
00:39:01,646 --> 0:39:02,896
他们看起来很像平常的工作流

1258
00:39:02,896 --> 0:39:04,146
除了在顶部有一个新的块

1259
00:39:04,146 --> 0:39:06,306
可以让你

1260
00:39:06,306 --> 0:39:07,596
配置输入和

1261
00:39:07,596 --> 0:39:10,116
输出以及选择图标和颜色

1262
00:39:11,716 --> 0:39:13,526
我们来迅速浏览一个示例

1263
00:39:14,026 --> 0:39:15,516
我经常会面临一个问题

1264
00:39:15,516 --> 0:39:16,886
当我想在 TextEdit 中打开一些文件时

1265
00:39:16,886 --> 0:39:18,586
我打不开因为

1266
00:39:18,586 --> 0:39:20,156
没有文件扩展

1267
00:39:20,616 --> 0:39:23,546
使用 Automator 就会非常容易就解决

1268
00:39:24,666 --> 0:39:25,816
你要做的只是点进资料库 

1269
00:39:25,816 --> 0:39:27,676
将打开访达项目行动 

1270
00:39:27,676 --> 0:39:29,396
拉取出来

1271
00:39:30,096 --> 0:39:32,166
你可以将其配置成为用 TextEdit 打开 

1272
00:39:32,166 --> 0:39:34,886
不再使用默认的 App

1273
00:39:35,646 --> 0:39:37,326
在访达中被选中的文件

1274
00:39:37,326 --> 0:39:38,736
自动成为这个动作的输入内容

1275
00:39:38,736 --> 0:39:43,926
如果你用什么名字保存这个文件 就会

1276
00:39:43,926 --> 0:39:44,816
自动出现在触控栏中

1277
00:39:44,876 --> 0:39:47,896
或者在其他有用的文本下

1278
00:39:50,686 --> 0:39:54,216
总结来说 我们提到了 

1279
00:39:54,216 --> 0:39:55,906
许多新的功能

1280
00:39:56,176 --> 0:39:57,666
以及其他的一些改变

1281
00:39:57,666 --> 0:39:59,006
将会使你的开发经历更为丰富 

1282
00:39:59,006 --> 0:40:00,976
你的 App 更加伟大

1283
00:39:59,006 --> 0:40:00,976
你的 App 更加伟大

1284
00:40:01,046 --> 0:40:04,936
查看新的 SDK 

1285
00:40:05,416 --> 0:40:07,426
并开始在你的 App 中

1286
00:40:07,696 --> 0:40:08,866
使用这些内容

1287
00:40:10,046 --> 0:40:11,756
会让你的 App 吸引人

1288
00:40:11,756 --> 0:40:14,356
你的顾客也会喜欢

1289
00:40:15,046 --> 0:40:17,436
更多信息 可以查看以下 URL

1290
00:40:17,436 --> 0:40:20,666
并且 也可进入 WWDC

1291
00:40:20,666 --> 0:40:21,846
的 App 此演讲部分下查看

1292
00:40:22,156 --> 0:40:23,826
所有相关的演讲链接

1293
00:40:23,826 --> 0:40:24,306
都在这里

1294
00:40:24,396 --> 0:40:24,926
非常感谢

1295
00:40:25,516 --> 0:40:31,500
［ 掌声 ］
