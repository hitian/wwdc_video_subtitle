1
00:00:07,516 --> 0:00:18,516
［ 音乐 ］

2
00:00:19,516 --> 0:00:25,416
［ 掌声 ］

3
00:00:25,916 --> 0:00:26,946
&gt;&gt; 大家下午好

4
00:00:27,406 --> 0:00:28,456
我是 John Hess

5
00:00:28,456 --> 0:00:30,586
今天我将和 Matthew Lucas 一起

6
00:00:30,586 --> 0:00:31,606
与在座的各位

7
00:00:31,606 --> 0:00:33,166
谈谈提高 App 性能的

8
00:00:33,166 --> 0:00:34,506
一些实用的方法

9
00:00:35,406 --> 0:00:36,906
我现在是一名 Xcode 团队的工程师

10
00:00:36,906 --> 0:00:38,286
在过去的七年

11
00:00:38,346 --> 0:00:39,796
我有幸一直专注于

12
00:00:39,796 --> 0:00:42,236
提高性能的工作

13
00:00:42,736 --> 0:00:44,226
首先是在 Xcode 的两个领域

14
00:00:44,226 --> 0:00:47,186
“Project Find” 和 “Open Quickly”

15
00:00:47,826 --> 0:00:49,896
二者的主要功能 都是提高性能

16
00:00:50,766 --> 0:00:52,056
最近 我有机会去

17
00:00:52,056 --> 0:00:54,136
做一项关于

18
00:00:54,136 --> 0:00:55,846
Xcode GY 响应性的调查

19
00:00:55,846 --> 0:00:57,126
我想与你们分享的是

20
00:00:57,126 --> 0:00:58,326
在进行性能工作时

21
00:00:58,326 --> 0:01:00,296
我所使用的方法

22
00:00:58,326 --> 0:01:00,296
我所使用的方法

23
00:01:00,296 --> 0:01:01,376
其中包括我十分熟悉的代码

24
00:01:01,376 --> 0:01:03,136
也包括我

25
00:01:03,136 --> 0:01:04,596
第一次接触到的代码

26
00:01:05,936 --> 0:01:07,716
那么 如果各位想从今天的演讲中有所收获

27
00:01:07,716 --> 0:01:09,496
我希望各位至少能

28
00:01:09,496 --> 0:01:11,886
记住一点 那就是

29
00:01:11,946 --> 0:01:13,276
你们所有提高性能的工作

30
00:01:13,276 --> 0:01:14,716
都要基于测量的结果

31
00:01:15,696 --> 0:01:17,096
在开始解决一个性能问题时

32
00:01:17,096 --> 0:01:18,816
你需要进行测量

33
00:01:18,816 --> 0:01:21,126
来建立一个基线

34
00:01:21,366 --> 0:01:22,536
让你知道自己所处的位置

35
00:01:23,666 --> 0:01:25,196
当你重复解决

36
00:01:25,196 --> 0:01:26,716
同一个性能问题时

37
00:01:26,716 --> 0:01:28,146
你应该测量每一步所使用的方法

38
00:01:28,576 --> 0:01:29,826
以确保性能的改变

39
00:01:29,826 --> 0:01:32,026
能够带来你所期待的效果

40
00:01:33,336 --> 0:01:34,346
当你解决了一个性能问题

41
00:01:34,346 --> 0:01:35,916
你还需要再测量一遍

42
00:01:35,916 --> 0:01:37,656
这样你可以与原先的基线

43
00:01:37,656 --> 0:01:38,846
进行对比

44
00:01:38,846 --> 0:01:41,046
从而给出一个量化的结果

45
00:01:41,046 --> 0:01:43,166
关于你将 App 的性能

46
00:01:43,166 --> 0:01:44,746
真正提高了多少

47
00:01:45,196 --> 0:01:46,766
你想要将成果报告给你的老板

48
00:01:46,766 --> 0:01:49,506
分享给你的同事和用户

49
00:01:50,566 --> 0:01:52,966
那么 当你想要为你的用户提高性能时

50
00:01:52,966 --> 0:01:55,166
你需要考虑这一点

51
00:01:55,166 --> 0:01:56,826
我喜欢称它为

52
00:01:56,826 --> 0:01:57,786
总体性能影响

53
00:01:58,656 --> 0:02:01,246
如果你将 App 的

54
00:01:58,656 --> 0:02:01,246
如果你将 App 的

55
00:02:01,246 --> 0:02:03,216
一个领域的性能

56
00:02:03,216 --> 0:02:06,706
提高了 50%

57
00:02:06,706 --> 0:02:08,136
但你的用户 

58
00:02:08,136 --> 0:02:10,006
只体验到了其中的 1%

59
00:02:10,006 --> 0:02:11,456
那么这种提升的影响广度

60
00:02:11,456 --> 0:02:13,286
还不及你只提高了其他领域的 10% 

61
00:02:13,286 --> 0:02:15,526
但所有用户都能体验到

62
00:02:15,526 --> 0:02:16,806
这全部的 10%

63
00:02:17,336 --> 0:02:19,676
所以一定不要去优化边缘的案例

64
00:02:19,676 --> 0:02:20,816
要确保你的性能的优化

65
00:02:20,816 --> 0:02:22,596
能够为全部的用户所体验

66
00:02:24,536 --> 0:02:27,736
那么我们如何修复

67
00:02:27,736 --> 0:02:28,086
性能漏洞呢

68
00:02:28,086 --> 0:02:29,526
如何修复常规的漏洞呢

69
00:02:29,966 --> 0:02:31,586
一般来说 最开始用户反馈给我们

70
00:02:31,586 --> 0:02:33,036
某方面的缺陷报告

71
00:02:33,036 --> 0:02:35,026
我们接收到这个报告

72
00:02:35,026 --> 0:02:36,466
了解到用户对 App 的性能

73
00:02:36,466 --> 0:02:38,216
有一些不满意的地方 

74
00:02:38,216 --> 0:02:39,946
于是我们会设法

75
00:02:40,066 --> 0:02:41,696
来综合步骤进行故障重现

76
00:02:41,696 --> 0:02:42,866
以便我们可以随意地使程序出错

77
00:02:43,646 --> 0:02:45,346
一旦我们成功的做到 我们就给

78
00:02:45,346 --> 0:02:46,526
程序附加一个调试器

79
00:02:46,526 --> 0:02:48,826
以便我们看到我们的程序出错的时候

80
00:02:48,826 --> 0:02:49,376
在做什么

81
00:02:50,866 --> 0:02:51,706
再结合我们的知识

82
00:02:51,706 --> 0:02:52,656
想想代码应该如何工作

83
00:02:52,656 --> 0:02:54,576
在必要时修改它

84
00:02:54,576 --> 0:02:56,176
来消除那些

85
00:02:56,176 --> 0:02:57,156
不如意的部分

86
00:02:57,936 --> 0:02:58,966
我们要确保我们没有

87
00:02:58,966 --> 0:03:00,516
带来任何不想要的副作用

88
00:02:58,966 --> 0:03:00,516
带来任何不想要的副作用

89
00:03:00,516 --> 0:03:02,046
同时 要进行必要的重复

90
00:03:02,046 --> 0:03:03,546
直到我们完全地

91
00:03:03,546 --> 0:03:04,186
解决了这个漏洞

92
00:03:05,736 --> 0:03:07,686
我已经用相同的方法

93
00:03:07,686 --> 0:03:08,996
修复了许多性能漏洞

94
00:03:10,086 --> 0:03:11,136
只不过我并没有使用调试器

95
00:03:11,136 --> 0:03:13,766
而是使用了一个分析器

96
00:03:13,826 --> 0:03:16,246
分析器就是一个很好的测量工具

97
00:03:16,996 --> 0:03:18,666
我用一些步骤

98
00:03:18,666 --> 0:03:20,806
来重现运行很慢的

99
00:03:20,806 --> 0:03:21,216
程序

100
00:03:21,966 --> 0:03:23,386
我用一个附加的分析器 

101
00:03:23,386 --> 0:03:25,106
来执行这些步骤

102
00:03:25,106 --> 0:03:26,606
因此我可以深入地了解

103
00:03:26,606 --> 0:03:27,656
当我的代码运行缓慢时

104
00:03:27,656 --> 0:03:28,106
它发生了什么

105
00:03:29,226 --> 0:03:31,016
然后再结合

106
00:03:31,016 --> 0:03:32,556
我的程序必须要如何运行

107
00:03:32,556 --> 0:03:34,206
才能完成手边的任务

108
00:03:34,266 --> 0:03:36,056
我找到其中正在进行的步骤

109
00:03:36,236 --> 0:03:37,606
并删除了它们

110
00:03:37,606 --> 0:03:39,926
因为想让你的代码变快的

111
00:03:39,926 --> 0:03:42,286
首要方法就是删除多余的步骤

112
00:03:42,286 --> 0:03:44,326
无论它正在计算的是什么

113
00:03:45,736 --> 0:03:47,456
现在 我修改了源代码

114
00:03:47,456 --> 0:03:49,136
在必要时进行反复测量

115
00:03:49,136 --> 0:03:50,486
直到我对整体的结果

116
00:03:50,486 --> 0:03:52,886
感到满意为止

117
00:03:54,936 --> 0:03:57,666
当我通过这种方法提高性能时

118
00:03:57,666 --> 0:03:59,486
我发现自己常常处于

119
00:03:59,486 --> 0:04:00,176
一些场景当中

120
00:03:59,486 --> 0:04:00,176
一些场景当中

121
00:04:00,736 --> 0:04:02,026
这些不同的场景

122
00:04:02,056 --> 0:04:03,406
改变了我测试有问题代码的方式

123
00:04:03,496 --> 0:04:05,166
以及复制这些

124
00:04:05,196 --> 0:04:06,126
漏洞的方法

125
00:04:06,776 --> 0:04:09,046
有时我会遇到

126
00:04:09,096 --> 0:04:10,926
严重的性能衰退问题 对吗

127
00:04:11,006 --> 0:04:12,086
开始一切都在平稳地运行

128
00:04:12,086 --> 0:04:14,116
然后我们的团队里

129
00:04:14,116 --> 0:04:15,396
有人对其进行了检测

130
00:04:15,446 --> 0:04:17,086
这个人也许是我

131
00:04:17,086 --> 0:04:18,226
然后发现性能出现了严重的衰退

132
00:04:18,226 --> 0:04:19,495
那么我们就需要回去

133
00:04:19,495 --> 0:04:21,296
找出这种衰退的原因

134
00:04:22,065 --> 0:04:23,246
如果这种衰退十分明显

135
00:04:23,246 --> 0:04:25,986
或者是它出现在一个

136
00:04:25,986 --> 0:04:27,186
我认为近期

137
00:04:27,186 --> 0:04:28,086
不可能再次衰退的地方

138
00:04:28,086 --> 0:04:29,576
我也许会自己手动地

139
00:04:29,676 --> 0:04:31,966
运用附加的分析器 

140
00:04:32,086 --> 0:04:33,216
对它进行测试

141
00:04:34,386 --> 0:04:36,116
但是 想提高你的性能

142
00:04:36,116 --> 0:04:37,376
这是一个不大容易的过程

143
00:04:37,376 --> 0:04:40,056
因为很可能

144
00:04:40,056 --> 0:04:42,126
只是一系列轻微的衰退

145
00:04:42,126 --> 0:04:43,196
就会让你功亏一篑

146
00:04:43,986 --> 0:04:45,806
我建议你们所有人

147
00:04:45,806 --> 0:04:46,926
创建自动化的性能测试

148
00:04:46,926 --> 0:04:48,986
来捕捉你的 App 的性能

149
00:04:48,986 --> 0:04:50,356
这样你就可以

150
00:04:50,356 --> 0:04:52,316
保证它不会随着时间而衰退

151
00:04:55,256 --> 0:04:56,596
我经常所处的另一个场景是

152
00:04:56,596 --> 0:04:58,726
App 的性能

153
00:04:58,726 --> 0:05:00,326
在很长一段时间后

154
00:04:58,726 --> 0:05:00,326
在很长一段时间后

155
00:05:00,326 --> 0:05:01,246
还能保持不变吗

156
00:05:01,656 --> 0:05:03,356
也许在一些绘图测试中

157
00:05:03,356 --> 0:05:04,666
它运行的速度是 45 帧每秒

158
00:05:05,156 --> 0:05:06,826
但是我们希望的运行速度是 60 每秒

159
00:05:06,826 --> 0:05:07,886
所以我们需要小幅地提高它

160
00:05:07,886 --> 0:05:09,426
并且我们有理由相信

161
00:05:09,426 --> 0:05:10,986
通过我们先前的性能工作

162
00:05:10,986 --> 0:05:12,736
我们可以利用现场修复

163
00:05:12,736 --> 0:05:14,126
以及增量式变化

164
00:05:14,126 --> 0:05:15,546
来对它进行提高

165
00:05:16,326 --> 0:05:17,726
在这种场景下

166
00:05:17,726 --> 0:05:19,186
我或许也已经自动地

167
00:05:19,186 --> 0:05:20,876
开始进行测试了 

168
00:05:20,876 --> 0:05:22,216
因为随着时间的推移 

169
00:05:24,796 --> 0:05:24,896
我已经很了解我的性能了

170
00:05:25,106 --> 0:05:26,856
还有第三种场景 

171
00:05:26,856 --> 0:05:28,176
我们的 App

172
00:05:28,176 --> 0:05:29,336
因为设计不良而受到损害

173
00:05:29,446 --> 0:05:30,666
性能也远远比不上

174
00:05:30,666 --> 0:05:32,226
它原应达到的效果

175
00:05:33,516 --> 0:05:34,726
我们知道我们不能用

176
00:05:34,726 --> 0:05:36,626
简单的场地修复来提高性能

177
00:05:36,626 --> 0:05:37,666
因为过去我们这么尝试过

178
00:05:37,906 --> 0:05:39,356
但并没有成功

179
00:05:39,606 --> 0:05:41,416
无法提高性能

180
00:05:42,006 --> 0:05:43,856
在这样的情况下

181
00:05:43,856 --> 0:05:45,986
你会想要做一次彻底的性能检修

182
00:05:45,986 --> 0:05:47,446
你会想重新设计一些特性的核心部分

183
00:05:47,446 --> 0:05:48,716
或是有问题的算法

184
00:05:48,716 --> 0:05:50,516
以使性能成为一个

185
00:05:50,786 --> 0:05:51,916
首要的约束条件

186
00:05:52,456 --> 0:05:53,746
在这些情况里

187
00:05:53,906 --> 0:05:55,216
你必然要对性能进行检测

188
00:05:55,536 --> 0:05:56,686
以测量你确实

189
00:05:56,686 --> 0:05:58,136
达到了你的性能目标

190
00:05:59,246 --> 0:06:01,936
知道你要测试什么 很重要

191
00:05:59,246 --> 0:06:01,936
知道你要测试什么 很重要

192
00:06:02,346 --> 0:06:03,686
我想要提醒你的是

193
00:06:03,686 --> 0:06:05,096
我从来都不会立刻投入

194
00:06:05,096 --> 0:06:06,086
这些性能检修

195
00:06:06,086 --> 0:06:08,106
将其视为解决

196
00:06:08,106 --> 0:06:08,896
某种性能问题的方法

197
00:06:09,296 --> 0:06:10,816
我喜欢这么做

198
00:06:10,816 --> 0:06:12,046
这是一种未曾开发的工程

199
00:06:12,046 --> 0:06:14,326
你能够从头开始 设计这些东西

200
00:06:14,326 --> 0:06:16,126
但这也颇具风险

201
00:06:16,556 --> 0:06:17,346
你最终要的是

202
00:06:17,346 --> 0:06:18,666
一个性能更好的产品

203
00:06:18,666 --> 0:06:19,686
但这却是一个曲折的过程

204
00:06:19,686 --> 0:06:21,376
因为你需要重新设计

205
00:06:21,376 --> 0:06:23,976
整个特性

206
00:06:24,116 --> 0:06:25,186
当你做这种工作的时候

207
00:06:25,186 --> 0:06:26,666
你不仅需要知道

208
00:06:26,666 --> 0:06:28,156
这些代码的 

209
00:06:28,286 --> 0:06:29,436
功能约束条件

210
00:06:29,436 --> 0:06:31,336
你还要知道

211
00:06:31,336 --> 0:06:32,986
性能约束条件 

212
00:06:32,986 --> 0:06:34,356
以及你的用户应用这一特性时

213
00:06:34,356 --> 0:06:35,616
最常使用的

214
00:06:35,616 --> 0:06:37,386
典型的模式

215
00:06:37,386 --> 0:06:39,106
而你只能从 

216
00:06:39,256 --> 0:06:40,276
过去这方面的性能工作中

217
00:06:40,276 --> 0:06:40,736
获得这方面信息

218
00:06:41,636 --> 0:06:43,326
我想和你们分享一件轶事

219
00:06:43,326 --> 0:06:45,046
是我们的一个

220
00:06:45,046 --> 0:06:46,216
在 Xcode 里工作的案例

221
00:06:47,216 --> 0:06:49,406
在 Xcode 9 中 我们重做了 “Project Find”

222
00:06:49,406 --> 0:06:50,606
将性能作为一个

223
00:06:50,606 --> 0:06:51,406
首要的目标

224
00:06:52,366 --> 0:06:53,716
我们的目标就是要

225
00:06:53,716 --> 0:06:55,376
在短短几十毫秒中

226
00:06:55,376 --> 0:06:56,076
传递出搜索结果

227
00:06:56,926 --> 0:06:59,156
当我们与同事

228
00:06:59,156 --> 0:07:00,006
讨论这个特性时

229
00:06:59,156 --> 0:07:00,006
讨论这个特性时

230
00:07:00,006 --> 0:07:01,366
我们常常遇到一些挑战

231
00:07:01,366 --> 0:07:03,536
比如让我们在一些大的项目上

232
00:07:03,536 --> 0:07:05,286
搜索一些类似于字符串

233
00:07:05,286 --> 0:07:07,106
或者甚至是字母 E 

234
00:07:07,106 --> 0:07:07,336
这样的东西

235
00:07:07,446 --> 0:07:08,976
这些东西能搜索出成千上万种结果

236
00:07:08,976 --> 0:07:10,446
不是吗

237
00:07:10,446 --> 0:07:12,106
当然如果你的 App

238
00:07:12,216 --> 0:07:13,426
能够迅速生产出成千上万的结果

239
00:07:13,426 --> 0:07:14,866
它搜索任何东西

240
00:07:14,866 --> 0:07:15,776
都会很快

241
00:07:16,476 --> 0:07:17,896
但是如果你思考一下

242
00:07:17,896 --> 0:07:20,516
什么是典型的模式

243
00:07:20,516 --> 0:07:22,046
我们搜索我们使用的 API

244
00:07:22,046 --> 0:07:24,336
我们自己的类名称

245
00:07:24,496 --> 0:07:25,616
还有我们引用的图片名称

246
00:07:25,616 --> 0:07:26,286
诸如此类的东西

247
00:07:26,346 --> 0:07:27,546
它能搜索出很多结果

248
00:07:27,546 --> 0:07:28,606
也许上百种结果

249
00:07:28,936 --> 0:07:30,276
当然十分重要的是 当有一百万种搜索结果时 

250
00:07:30,276 --> 0:07:32,076
你的 App 能够

251
00:07:32,076 --> 0:07:33,236
正常地工作运转

252
00:07:33,496 --> 0:07:35,086
但是通常的使用情况是

253
00:07:35,156 --> 0:07:36,026
有数百种搜索结果

254
00:07:36,806 --> 0:07:38,486
那么 在进行搜索这样的任务时

255
00:07:38,486 --> 0:07:40,186
你所做的一些工作 

256
00:07:40,186 --> 0:07:41,396
要与生成原始结果

257
00:07:41,746 --> 0:07:43,816
这样的东西相对应

258
00:07:43,816 --> 0:07:45,326
而其余的工作则要基于

259
00:07:45,326 --> 0:07:46,916
你能多有效地索引

260
00:07:46,916 --> 0:07:48,296
项目中的文本

261
00:07:48,296 --> 0:07:49,666
并预先避免工作

262
00:07:50,156 --> 0:07:51,996
在这两种场景中

263
00:07:51,996 --> 0:07:53,976
你可能会有完全

264
00:07:53,976 --> 0:07:55,286
不同的优化目标

265
00:07:55,286 --> 0:07:56,826
让其中一个目标的搜索速度

266
00:07:56,826 --> 0:07:59,046
快于其他的目标 对吗

267
00:07:59,046 --> 0:08:00,156
因而你有必要了解

268
00:07:59,046 --> 0:08:00,156
因而你有必要了解

269
00:08:00,156 --> 0:08:02,426
你的用户将要

270
00:08:02,426 --> 0:08:03,316
如何使用该产品

271
00:08:03,506 --> 0:08:04,696
这样你就可以优化

272
00:08:04,726 --> 0:08:05,536
应该优化的案例

273
00:08:07,956 --> 0:08:09,696
在所有的这些案例中

274
00:08:09,696 --> 0:08:11,206
我需要进行一些形式的测试

275
00:08:11,686 --> 0:08:13,556
无论是手动地 还是自动地

276
00:08:16,246 --> 0:08:17,556
我想要与你分享

277
00:08:17,556 --> 0:08:18,886
两类典型的性能测试

278
00:08:18,886 --> 0:08:20,196
我通常用它们

279
00:08:20,196 --> 0:08:22,186
来测量 Xcode 的性能

280
00:08:23,436 --> 0:08:25,436
我们或者进行单元测试

281
00:08:25,436 --> 0:08:26,376
或者进行综合测试

282
00:08:26,956 --> 0:08:28,176
我们来对比一下这两种测试

283
00:08:29,376 --> 0:08:31,306
在性能的单元测试中

284
00:08:31,306 --> 0:08:33,616
你的目标就是对你的 App 的

285
00:08:33,616 --> 0:08:35,096
某些特征进行隔离

286
00:08:35,096 --> 0:08:36,356
并单独地对其进行测量

287
00:08:36,966 --> 0:08:37,726
你也许会抹去它的相关性

288
00:08:37,756 --> 0:08:39,236
然后在一个

289
00:08:39,236 --> 0:08:41,126
隔离的环境中

290
00:08:41,126 --> 0:08:42,736
启动它

291
00:08:43,496 --> 0:08:45,666
如果我要为 Xcode 的代码完成 

292
00:08:45,666 --> 0:08:47,266
性能的单元测试

293
00:08:47,266 --> 0:08:48,676
那我也许会编写

294
00:08:48,676 --> 0:08:50,406
一系列的三个小测试

295
00:08:51,076 --> 0:08:52,896
其中一个测试会测量

296
00:08:53,256 --> 0:08:54,616
与编译器的对话

297
00:08:54,616 --> 0:08:56,426
并得到原始的结果

298
00:08:56,426 --> 0:08:57,876
和原始的代码完成候选的结果

299
00:08:58,946 --> 0:09:01,056
另一个性能测试则会测量

300
00:08:58,946 --> 0:09:01,056
另一个性能测试则会测量

301
00:09:01,056 --> 0:09:02,906
那些结果的相互关联

302
00:09:02,906 --> 0:09:04,386
对它们进行排列以及评分

303
00:09:04,386 --> 0:09:05,406
以便我们知道要将哪些结果

304
00:09:05,406 --> 0:09:05,806
显示给用户

305
00:09:06,926 --> 0:09:08,896
第三个测试会选取

306
00:09:08,926 --> 0:09:10,636
那些已经准备好的结果

307
00:09:10,636 --> 0:09:11,636
并测量将它们放入 UI 元素

308
00:09:11,636 --> 0:09:13,156
后最终展示出来的情况

309
00:09:13,156 --> 0:09:15,016
为了涉及到全部三个方面

310
00:09:15,016 --> 0:09:17,986
我会很好地覆盖 IDE 中

311
00:09:17,986 --> 0:09:20,546
代码完成的主要的组件

312
00:09:23,136 --> 0:09:24,796
这些性能单元测试

313
00:09:24,886 --> 0:09:26,976
有一些很好的方面

314
00:09:27,596 --> 0:09:28,326
我们将高度聚焦这些方面

315
00:09:28,326 --> 0:09:30,026
这意味着如果它们

316
00:09:30,026 --> 0:09:31,276
在将来出现衰退

317
00:09:31,276 --> 0:09:32,706
我会很清楚地知道

318
00:09:32,706 --> 0:09:33,986
这些衰退出现在哪里

319
00:09:34,026 --> 0:09:35,066
因为这些正在运行的代码

320
00:09:35,066 --> 0:09:36,086
已经处于检查之中了

321
00:09:36,706 --> 0:09:38,976
而它们也将在不断地运行过程中 

322
00:09:39,286 --> 0:09:40,626
产生出更多的

323
00:09:40,626 --> 0:09:41,336
可重复的结果

324
00:09:41,466 --> 0:09:42,436
而它们产生的时间 

325
00:09:42,436 --> 0:09:45,036
也不会有太大的波动

326
00:09:45,426 --> 0:09:46,676
因为这些代码

327
00:09:46,676 --> 0:09:47,156
是高度聚焦的

328
00:09:48,176 --> 0:09:49,186
现在 我们来将单元测试与

329
00:09:49,186 --> 0:09:50,056
综合测试进行对比

330
00:09:51,076 --> 0:09:52,936
在综合测试中

331
00:09:52,936 --> 0:09:54,796
你要做的是

332
00:09:54,796 --> 0:09:56,616
在用户使用 App 时

333
00:09:56,616 --> 0:09:59,016
对其性能进行全面地测量

334
00:09:59,866 --> 0:10:01,506
所以 如果我为 Xcode 编写

335
00:09:59,866 --> 0:10:01,506
所以 如果我为 Xcode 编写

336
00:10:01,506 --> 0:10:03,106
代码完成单元测试

337
00:10:03,756 --> 0:10:05,996
哦不对 是综合测试

338
00:10:05,996 --> 0:10:08,466
我会启动全部的 Xcode App

339
00:10:08,466 --> 0:10:09,566
我会打开一个源文件

340
00:10:09,566 --> 0:10:11,136
我会定位到该源文件

341
00:10:11,136 --> 0:10:13,366
然后进行书写

342
00:10:13,366 --> 0:10:15,306
再反复地进行代码完成

343
00:10:16,076 --> 0:10:17,636
当我执行这些步骤的时候 

344
00:10:17,636 --> 0:10:18,686
看看 Xcode 在做什么

345
00:10:18,686 --> 0:10:20,316
看看它花了多少时间

346
00:10:20,316 --> 0:10:22,956
我会发现这个测试 一点也不聚焦

347
00:10:24,006 --> 0:10:25,476
Xcode 会在我书写的时候

348
00:10:25,476 --> 0:10:26,986
进行绘制和布局

349
00:10:26,986 --> 0:10:29,906
当我归类时 它还会同时进行语法着色

350
00:10:30,556 --> 0:10:31,536
在后台 Xcode 也许正在进行索引

351
00:10:31,536 --> 0:10:33,636
读取获取状态 并决定把新的文件 

352
00:10:34,086 --> 0:10:35,976
显示在 Assistant Editor 中

353
00:10:36,056 --> 0:10:36,866
而所有的这些

354
00:10:37,166 --> 0:10:40,056
都将与代码完成一起

355
00:10:40,116 --> 0:10:42,246
来竞争 CPU 的资源

356
00:10:43,086 --> 0:10:44,046
也许当我查看 Profiler 时

357
00:10:44,046 --> 0:10:45,786
我会看到我们花费了

358
00:10:45,786 --> 0:10:47,636
80% 的时间在做语法着色

359
00:10:47,916 --> 0:10:50,626
而剩下的 20% 则用在了代码完成上

360
00:10:51,086 --> 0:10:52,636
从这个数据我可以知道

361
00:10:52,636 --> 0:10:54,776
要提高代码完成性能

362
00:10:54,816 --> 0:10:55,976
最好的方法就是

363
00:10:56,256 --> 0:10:58,076
推迟语法着色

364
00:10:58,686 --> 0:11:00,256
这样的知识

365
00:10:58,686 --> 0:11:00,256
这样的知识

366
00:11:00,256 --> 0:11:01,946
是我在高度聚焦的单元测试中

367
00:11:01,946 --> 0:11:02,546
所无法获得的

368
00:11:02,546 --> 0:11:04,366
所以如果今天各位听完这个演讲

369
00:11:04,366 --> 0:11:05,606
只能带走两样东西的话

370
00:11:05,606 --> 0:11:07,476
第二样就是

371
00:11:07,746 --> 0:11:08,866
要调查你的性能

372
00:11:08,866 --> 0:11:10,936
必然应该从这些

373
00:11:10,936 --> 0:11:12,506
广泛的综合测试开始

374
00:11:12,506 --> 0:11:14,226
它们会测量你的用户

375
00:11:14,226 --> 0:11:16,406
使用 App 时的用户体验

376
00:11:18,026 --> 0:11:19,296
对 我说的就是测试

377
00:11:19,626 --> 0:11:21,026
测量以及分析

378
00:11:21,456 --> 0:11:22,346
现在我想向你们

379
00:11:22,346 --> 0:11:24,166
介绍一下用工具

380
00:11:24,216 --> 0:11:25,546
在 Xcode 中进行分析

381
00:11:25,786 --> 0:11:26,646
让我们来看一下

382
00:11:26,646 --> 0:11:27,166
demo machine

383
00:11:35,056 --> 0:11:35,926
今天我们要看的是一个

384
00:11:35,926 --> 0:11:37,146
我们在 Xcode 9 和

385
00:11:37,146 --> 0:11:39,516
Xcode 10 之间修复了的性能问题

386
00:11:39,516 --> 0:11:41,216
我想展示给你们

387
00:11:41,696 --> 0:11:44,436
下面我先启动 Xcode 9

388
00:11:44,436 --> 0:11:45,856
打开我们的 Solar System App 

389
00:11:47,056 --> 0:11:47,766
那么 我们所

390
00:11:47,766 --> 0:11:49,796
面临的问题就是创建标记

391
00:11:50,456 --> 0:11:51,486
接着我要快速地

392
00:11:51,486 --> 0:11:52,956
按几下快捷键 “Command-T”

393
00:11:52,956 --> 0:11:54,996
如你所见

394
00:11:54,996 --> 0:11:56,896
整个屏幕闪现了黑色

395
00:11:56,896 --> 0:11:58,166
并且创建这些标记

396
00:11:58,166 --> 0:11:58,996
花了好几秒的时间

397
00:11:59,626 --> 0:12:01,116
这肯定达不到

398
00:11:59,626 --> 0:12:01,116
这肯定达不到

399
00:12:01,116 --> 0:12:02,216
我对性能的预期

400
00:12:02,216 --> 0:12:04,596
我们需要来对它进行修复

401
00:12:04,956 --> 0:12:06,376
那么我们来看看

402
00:12:06,376 --> 0:12:06,826
如何进行修复

403
00:12:08,266 --> 0:12:09,566
首先 我将启动 Instruments

404
00:12:09,606 --> 0:12:10,716
这是我们的分析工具

405
00:12:11,436 --> 0:12:12,686
你可以从 Xcode 菜单中打开它

406
00:12:12,686 --> 0:12:14,586
在 Instruments 中的

407
00:12:14,886 --> 0:12:15,506
Open Developer Tool 里面

408
00:12:15,976 --> 0:12:17,766
现在 我在 Xcode 9 里面

409
00:12:18,106 --> 0:12:19,146
所以如果我选择这个选项

410
00:12:19,146 --> 0:12:20,036
那我启动的是

411
00:12:20,036 --> 0:12:21,476
Xcode 9 中的 Instruments

412
00:12:21,476 --> 0:12:22,606
当然我想要从 Xcode 10 中启动 Instruments

413
00:12:22,706 --> 0:12:23,766
我已经把我的文件放在这里了

414
00:12:24,066 --> 0:12:26,066
我将隐藏 Xcode

415
00:12:26,066 --> 0:12:28,956
打开 Instruments

416
00:12:29,146 --> 0:12:30,366
当 Instruments 启动时

417
00:12:31,796 --> 0:12:33,026
就会出现一系列的分析工具

418
00:12:33,026 --> 0:12:34,226
我们可以用它们

419
00:12:34,226 --> 0:12:35,546
测量我们的 App

420
00:12:36,356 --> 0:12:37,426
这里是各种各样的工具

421
00:12:37,786 --> 0:12:38,736
它们能够测量

422
00:12:38,736 --> 0:12:41,186
图形的利用率 内存消耗

423
00:12:41,836 --> 0:12:44,006
IO 以及整体的时间

424
00:12:45,726 --> 0:12:47,096
你们也许会对从哪个工具

425
00:12:47,096 --> 0:12:48,406
先开始学习

426
00:12:48,406 --> 0:12:49,676
而感到不安

427
00:12:51,236 --> 0:12:53,936
那么我对你们的建议是

428
00:12:53,936 --> 0:12:55,596
如果只学习其中的一个工具

429
00:12:55,596 --> 0:12:56,976
那么你们应该学习

430
00:12:56,976 --> 0:12:57,516
Time Profiler

431
00:12:58,296 --> 0:13:00,426
在我的性能工作中

432
00:12:58,296 --> 0:13:00,426
在我的性能工作中

433
00:13:00,426 --> 0:13:01,166
有 95% 甚至更多的情况下都在使用它

434
00:13:01,736 --> 0:13:03,246
当你的用户抱怨

435
00:13:03,246 --> 0:13:04,546
你的 App 运行很慢时

436
00:13:04,546 --> 0:13:05,726
他们是在抱怨

437
00:13:05,726 --> 0:13:07,796
它花费了太多的时间

438
00:13:08,746 --> 0:13:10,116
假如你的 App 太慢了

439
00:13:10,116 --> 0:13:10,926
是因为你运行了太多的 IO

440
00:13:10,926 --> 0:13:12,636
从而花费了太多的时间

441
00:13:12,636 --> 0:13:13,706
那么你就能在 Time Profiler

442
00:13:13,706 --> 0:13:15,036
上看到这一点

443
00:13:15,036 --> 0:13:17,146
所以如果你只学习一个工具

444
00:13:17,146 --> 0:13:19,126
那就学 Time Profiler

445
00:13:20,276 --> 0:13:22,636
我们来看看它是如何工作的

446
00:13:25,346 --> 0:13:26,646
我要启动 Time Profiler 

447
00:13:26,646 --> 0:13:28,496
只需要双击这里

448
00:13:28,496 --> 0:13:31,246
然后将 Instruments

449
00:13:31,336 --> 0:13:32,226
全屏显示

450
00:13:33,646 --> 0:13:35,396
下面 我想要记录 Xcode

451
00:13:36,416 --> 0:13:38,086
在 Instruments 视窗的左上角

452
00:13:38,256 --> 0:13:39,836
你可以控制

453
00:13:39,836 --> 0:13:42,466
你想要附加和记录的进程

454
00:13:43,096 --> 0:13:45,236
在默认情况下 只要按下这个记录按钮

455
00:13:45,236 --> 0:13:46,726
我的 Mac 上的所有进程

456
00:13:46,726 --> 0:13:47,636
都会被记录

457
00:13:48,286 --> 0:13:50,926
而我只想锁定到 Xcode

458
00:13:54,856 --> 0:13:56,866
我会将这个弹出框

459
00:13:56,956 --> 0:13:59,046
切换到 Xcode 然后点击记录

460
00:13:59,536 --> 0:14:00,786
现在 当我记录的时候

461
00:13:59,536 --> 0:14:00,786
现在 当我记录的时候

462
00:14:00,786 --> 0:14:02,256
我就要关注视窗中的这个区域

463
00:14:02,256 --> 0:14:03,396
来追踪轨迹视图

464
00:14:03,786 --> 0:14:05,216
我要调整 Xcode 视窗的大小

465
00:14:05,216 --> 0:14:06,866
将它调小一点

466
00:14:06,866 --> 0:14:08,026
我就能看到那个区域

467
00:14:08,256 --> 0:14:09,896
然后我就要进行让它变慢的操作

468
00:14:09,896 --> 0:14:11,316
我要多创建几个标记

469
00:14:12,726 --> 0:14:15,826
你可以看到这里的图表 发生了变化

470
00:14:15,826 --> 0:14:17,016
现在 我要退出 App

471
00:14:17,086 --> 0:14:19,636
然后回到 Instruments

472
00:14:21,316 --> 0:14:23,056
所以刚刚发生了什么

473
00:14:23,936 --> 0:14:25,266
当分析器在运行时

474
00:14:26,126 --> 0:14:27,476
它被附加在我们的进程之中

475
00:14:27,476 --> 0:14:28,076
像一个调试器

476
00:14:28,076 --> 0:14:30,586
这个分析器每秒钟

477
00:14:30,586 --> 0:14:32,816
都数千次地停止

478
00:14:32,816 --> 0:14:34,936
我们的进程 并且它采集了跟踪轨迹

479
00:14:35,236 --> 0:14:37,026
那么 提醒一下

480
00:14:37,026 --> 0:14:38,546
跟踪轨迹描述了

481
00:14:38,546 --> 0:14:39,706
你的程序如何到达

482
00:14:39,706 --> 0:14:40,386
它目前所处的位置

483
00:14:40,876 --> 0:14:42,006
所以如果你现在

484
00:14:42,006 --> 0:14:43,716
处于 C 函数的第 6 行

485
00:14:43,716 --> 0:14:45,286
你到达那里的原因是因为 Main 函数调用了 A B C

486
00:14:45,326 --> 0:14:48,256
那么你的跟踪轨迹就是 Main A B C

487
00:14:49,006 --> 0:14:50,346
当 Instruments 捕捉到

488
00:14:50,346 --> 0:14:51,946
这些跟踪轨迹中的其中一个时

489
00:14:52,226 --> 0:14:53,356
它会说 嘿 我们刚刚在 C 函数中 

490
00:14:53,356 --> 0:14:54,686
花了一毫秒

491
00:14:54,686 --> 0:14:56,916
它说一毫秒

492
00:14:56,916 --> 0:14:58,056
是因为我们的

493
00:14:58,056 --> 0:14:59,016
记录采样间隔为

494
00:14:59,016 --> 0:14:59,546
一毫秒每次

495
00:15:01,016 --> 0:15:02,696
那么 在主线程上

496
00:15:02,696 --> 0:15:03,626
所有的这些跟踪轨迹都要

497
00:15:03,626 --> 0:15:04,556
从 Main 函数开始

498
00:15:04,556 --> 0:15:05,596
它们也许将要调用

499
00:15:05,596 --> 0:15:06,666
Application Main

500
00:15:06,796 --> 0:15:08,356
之后它们将会通过你的源代码

501
00:15:08,356 --> 0:15:09,536
不断地进行扩展

502
00:15:10,206 --> 0:15:11,896
我们可以将这些跟踪轨迹

503
00:15:11,956 --> 0:15:13,266
折叠在一起

504
00:15:13,266 --> 0:15:15,316
将它们覆盖放进一个前缀树

505
00:15:15,316 --> 0:15:16,983
以便它们从 Main 开始 进行下去

506
00:15:17,156 --> 0:15:18,646
我们可以将我们

507
00:15:18,646 --> 0:15:19,836
捕捉到的这些毫秒计数器

508
00:15:19,836 --> 0:15:21,386
放在顶端 这样我们就能够

509
00:15:21,386 --> 0:15:23,416
看到在我们源代码的

510
00:15:23,486 --> 0:15:24,716
所有不同层级的区域上

511
00:15:24,716 --> 0:15:26,126
我们都花费了多少时间

512
00:15:26,686 --> 0:15:27,636
我们要看看这个数据

513
00:15:27,636 --> 0:15:29,416
试着找出多余的

514
00:15:29,416 --> 0:15:31,066
和不必要的操作

515
00:15:31,066 --> 0:15:32,696
这样我们就可以提高速度

516
00:15:32,696 --> 0:15:33,836
这是我们提高

517
00:15:33,836 --> 0:15:34,916
App 性能的

518
00:15:34,916 --> 0:15:36,076
首要方法

519
00:15:37,026 --> 0:15:39,316
现在 正如你能想象到那样

520
00:15:39,316 --> 0:15:40,606
我们每秒能捕捉

521
00:15:40,606 --> 0:15:41,456
上千的跟踪轨迹

522
00:15:41,456 --> 0:15:43,326
在 Instruments 里

523
00:15:43,326 --> 0:15:45,246
有大量的数据需要你去处理

524
00:15:46,146 --> 0:15:48,356
我首先要给你的建议就是

525
00:15:48,356 --> 0:15:49,946
你想要尽可能多地

526
00:15:49,946 --> 0:15:51,596
过滤这里的数据 

527
00:15:51,596 --> 0:15:53,166
你需要看整个过程的性能 

528
00:15:53,166 --> 0:15:55,616
不要把精力集中在细节点上

529
00:15:55,616 --> 0:15:56,376
好吧

530
00:15:56,376 --> 0:15:57,786
我想要给你演示

531
00:15:57,786 --> 0:16:00,086
如何应用一堆强大的过滤器和工具

532
00:15:57,786 --> 0:16:00,086
如何应用一堆强大的过滤器和工具

533
00:16:04,276 --> 0:16:06,196
因为我之前做了记录

534
00:16:06,196 --> 0:16:07,806
还记得吧 我让轨迹视图显示了出来

535
00:16:09,356 --> 0:16:10,476
我这么做是因为我想要

536
00:16:10,476 --> 0:16:12,296
看看当我创建标记的时候 

537
00:16:12,296 --> 0:16:13,766
CPU 的利用率是如何变化的

538
00:16:13,766 --> 0:16:15,836
以及在哪里发生了变化

539
00:16:15,836 --> 0:16:18,156
然后我告诉自己

540
00:16:18,156 --> 0:16:19,416
就在这儿

541
00:16:20,186 --> 0:16:21,786
我只是拖动鼠标并选中了

542
00:16:21,856 --> 0:16:26,076
轨迹所在的区域

543
00:16:26,076 --> 0:16:27,786
我让 Instruments

544
00:16:27,786 --> 0:16:31,666
将它的跟踪轨迹数据只专注于

545
00:16:31,666 --> 0:16:32,706
那里的时间间隔上

546
00:16:33,126 --> 0:16:34,356
所有在这里的东西

547
00:16:34,356 --> 0:16:35,556
都是我创建标记之前的

548
00:16:36,026 --> 0:16:37,516
而所有这里的东西

549
00:16:37,626 --> 0:16:38,666
都是我创建了标记 

550
00:16:38,666 --> 0:16:39,786
退出 App 之后的

551
00:16:40,056 --> 0:16:40,976
那不是我现在要优化的地方

552
00:16:40,976 --> 0:16:42,576
所以我不需要

553
00:16:42,676 --> 0:16:45,016
看那里的数据

554
00:16:45,196 --> 0:16:48,376
现在 在 Instruments 视窗的底部区域

555
00:16:48,376 --> 0:16:49,836
Instruments 会显示出所有它

556
00:16:49,836 --> 0:16:51,366
所采集到的轨迹

557
00:16:51,786 --> 0:16:55,376
默认情况下

558
00:16:55,446 --> 0:16:56,206
每个线程上只有一行在运作

559
00:16:56,646 --> 0:16:57,756
在这个例子里

560
00:16:57,756 --> 0:16:59,126
看起来只有四个线程在运作

561
00:16:59,386 --> 0:17:00,556
而有时候则会更多

562
00:16:59,386 --> 0:17:00,556
而有时候则会更多

563
00:17:00,626 --> 0:17:01,716
这取决于你的 App

564
00:17:01,716 --> 0:17:02,436
是如何并行的

565
00:17:03,306 --> 0:17:04,796
我通常喜欢以聚焦的名义

566
00:17:06,276 --> 0:17:07,756
我也喜欢折叠它们

567
00:17:07,756 --> 0:17:10,356
让他们建立在每个线程中的

568
00:17:10,356 --> 0:17:11,976
函数执行的最顶层上

569
00:17:11,976 --> 0:17:13,346
而不是线程 ID 上

570
00:17:13,346 --> 0:17:14,636
因为前者与我使用 

571
00:17:14,636 --> 0:17:16,165
Grand Central Dispatch 的方式

572
00:17:16,165 --> 0:17:17,406
更为契合

573
00:17:18,616 --> 0:17:19,715
接下来我们看看

574
00:17:19,715 --> 0:17:21,076
Instruments 视窗的底部

575
00:17:21,076 --> 0:17:22,236
我要点击这个叫 Call Tree 的按钮

576
00:17:22,266 --> 0:17:24,576
然后放大它

577
00:17:24,576 --> 0:17:25,536
这样你就能看到

578
00:17:25,536 --> 0:17:26,076
我要做什么了

579
00:17:26,806 --> 0:17:28,556
这里有几个可用的过滤器

580
00:17:28,906 --> 0:17:30,516
其中一个被线程分开了

581
00:17:30,516 --> 0:17:31,756
默认情况下它就已经开启了

582
00:17:31,886 --> 0:17:33,176
接下来我要禁用它

583
00:17:33,176 --> 0:17:36,326
相反地 所有的线程都将按照

584
00:17:36,326 --> 0:17:37,586
它们的最顶层入口点来分组

585
00:17:37,586 --> 0:17:39,666
而不是它们的线程 ID

586
00:17:42,356 --> 0:17:45,646
现在 来看这个轨迹

587
00:17:45,646 --> 0:17:46,946
可以看到所有这些

588
00:17:46,946 --> 0:17:49,336
正在运作的线程 顺便提一下

589
00:17:49,336 --> 0:17:50,816
在主要轨迹的下面

590
00:17:50,816 --> 0:17:53,126
是总的 CPU 使用率

591
00:17:53,126 --> 0:17:54,416
CPU 使用率被分解到每一个线程上

592
00:17:54,416 --> 0:17:56,086
我们可以看到在这个轨迹中

593
00:17:56,086 --> 0:17:57,046
几乎其他所有的线程

594
00:17:57,176 --> 0:17:58,826
大部分都是闲置的

595
00:17:59,416 --> 0:18:00,836
我可以只聚焦主线程

596
00:17:59,416 --> 0:18:00,836
我可以只聚焦主线程

597
00:18:00,836 --> 0:18:03,036
从这里选择它

598
00:18:03,036 --> 0:18:04,626
现在我们就可以只看 

599
00:18:04,776 --> 0:18:06,476
在这个时间段内

600
00:18:06,526 --> 0:18:07,046
主线程的轨迹

601
00:18:08,086 --> 0:18:09,606
我准备开始深入到

602
00:18:09,606 --> 0:18:11,336
这个调用层级当中

603
00:18:11,336 --> 0:18:12,376
这样就能看到我的 App

604
00:18:12,416 --> 0:18:12,676
在做什么

605
00:18:13,606 --> 0:18:15,106
通常我会键入这一过程

606
00:18:15,106 --> 0:18:17,116
只要按下向右箭头和向下箭头

607
00:18:17,116 --> 0:18:18,666
然后不断地进行重复就可以了

608
00:18:19,366 --> 0:18:21,026
但是我想要给你们演示

609
00:18:21,026 --> 0:18:22,526
Instruments 提供的 

610
00:18:22,526 --> 0:18:24,136
最密集的跟踪轨迹检测

611
00:18:24,496 --> 0:18:25,416
如果你的检测是不可见的

612
00:18:25,416 --> 0:18:26,886
你可以用这个按钮

613
00:18:26,886 --> 0:18:28,756
进行切换

614
00:18:28,756 --> 0:18:29,746
最密集的追踪轨迹就都会在这

615
00:18:29,836 --> 0:18:31,706
在这个标记里

616
00:18:31,706 --> 0:18:32,046
“Extended Detail”

617
00:18:32,866 --> 0:18:34,296
那么 最密集的追踪轨迹

618
00:18:34,296 --> 0:18:35,496
正是出现得最频繁的

619
00:18:35,496 --> 0:18:36,566
那个轨迹

620
00:18:36,566 --> 0:18:37,486
当我们在当前选择下

621
00:18:37,486 --> 0:18:39,196
进行记录的时候

622
00:18:39,196 --> 0:18:41,476
追踪轨迹出现得最为频繁

623
00:18:42,116 --> 0:18:43,516
你可以利用这个

624
00:18:43,516 --> 0:18:45,556
在一段时间内 快速浏览许多帧

625
00:18:46,496 --> 0:18:47,846
我通常会浏览这里

626
00:18:48,096 --> 0:18:49,366
寻找我自己的 API 

627
00:18:49,656 --> 0:18:50,816
还有值得我花这么多时间

628
00:18:50,816 --> 0:18:51,856
来寻找的东西

629
00:18:51,856 --> 0:18:54,336
或者是寻找

630
00:18:54,336 --> 0:18:56,036
我们在样本数中

631
00:18:56,036 --> 0:18:57,306
有重要分支点的地方

632
00:18:58,356 --> 0:18:59,996
现在我们看这里

633
00:18:59,996 --> 0:19:02,036
我看到这个给 IDE 的调用

634
00:18:59,996 --> 0:19:02,036
我看到这个给 IDE 的调用

635
00:19:02,036 --> 0:19:04,636
Navigator Replacement View

636
00:19:04,636 --> 0:19:05,576
Did Install View Controller

637
00:19:05,936 --> 0:19:07,106
我十分熟悉这个 API 

638
00:19:07,106 --> 0:19:09,176
因为这是一个 Xcode 内部的 API

639
00:19:10,156 --> 0:19:12,686
在这个轨迹中 我可以查看这里

640
00:19:12,686 --> 0:19:13,636
在视窗的左手边

641
00:19:13,636 --> 0:19:14,686
这里负责的是

642
00:19:14,686 --> 0:19:18,656
我们记录的总时间中的

643
00:19:18,656 --> 0:19:21,596
或者 45% 的时间中的 1.19 秒

644
00:19:22,176 --> 0:19:24,196
这种方法要花费的时间

645
00:19:24,196 --> 0:19:27,756
远远超出了我的预期

646
00:19:27,936 --> 0:19:29,526
但是 我们很难聚焦在这里

647
00:19:29,526 --> 0:19:30,386
看看究竟发生了什么

648
00:19:30,586 --> 0:19:32,336
对吗 这是这个轨迹下面的

649
00:19:32,336 --> 0:19:33,346
其他所有的东西

650
00:19:33,346 --> 0:19:35,926
那么 它看起来就好像

651
00:19:35,926 --> 0:19:37,736
30 到 40 的堆线范围深度

652
00:19:38,056 --> 0:19:39,096
这是很吓人的

653
00:19:39,456 --> 0:19:40,726
我要给你演示如何聚焦这里

654
00:19:41,276 --> 0:19:43,006
第一种方法就在这里

655
00:19:43,006 --> 0:19:46,976
我们又要使用 “Call Tree” 弹出框

656
00:19:47,176 --> 0:19:49,126
我要在这个弹出框里

657
00:19:49,126 --> 0:19:50,516
选择 “flattened recursion”

658
00:19:51,756 --> 0:19:55,126
让我们来继续完成这步

659
00:19:55,196 --> 0:19:56,326
现在你就可以看到

660
00:19:56,326 --> 0:19:57,526
就在这里

661
00:19:57,526 --> 0:20:00,466
一组重复的方法调用

662
00:19:57,526 --> 0:20:00,466
一组重复的方法调用

663
00:20:00,466 --> 0:20:01,086
被折叠了

664
00:20:02,396 --> 0:20:04,536
不好意思 让我滑下来

665
00:20:05,586 --> 0:20:06,466
它被折叠了

666
00:20:06,816 --> 0:20:08,436
事实上 我就是想要

667
00:20:08,436 --> 0:20:09,586
继续我的性能测试

668
00:20:09,586 --> 0:20:11,556
在这个 IDE Navigator 范围里

669
00:20:11,556 --> 0:20:14,506
在这个 API 调用中

670
00:20:14,506 --> 0:20:16,336
我可以根据上下文

671
00:20:17,216 --> 0:20:19,376
重新聚焦整个 Call Tree 点击这里

672
00:20:19,376 --> 0:20:20,746
然后选择 “Focus on Subtree”

673
00:20:21,516 --> 0:20:22,446
之后 Instruments 就会

674
00:20:22,446 --> 0:20:23,896
将这个符号放到

675
00:20:23,896 --> 0:20:25,386
整个调用图的最顶层

676
00:20:25,386 --> 0:20:26,556
其他的所有东西都会被删除

677
00:20:26,556 --> 0:20:28,456
它会重新将百分比设置为 100%

678
00:20:28,726 --> 0:20:30,166
因此我可以就聚焦在这里

679
00:20:30,796 --> 0:20:33,096
现在 我可以用键盘上的箭头键

680
00:20:33,096 --> 0:20:35,686
来继续运行这个样本

681
00:20:35,686 --> 0:20:36,486
看看我们在做什么

682
00:20:36,686 --> 0:20:38,906
我很熟悉这些 API

683
00:20:38,906 --> 0:20:40,046
看起来我们好像正在进行

684
00:20:40,206 --> 0:20:41,196
状态恢复

685
00:20:41,766 --> 0:20:43,136
当我继续扩大这个

686
00:20:43,136 --> 0:20:45,936
我可以看到我们几乎

687
00:20:45,936 --> 0:20:47,176
深入了这个表格视图

688
00:20:47,466 --> 0:20:49,696
除了有这种

689
00:20:49,696 --> 0:20:51,476
热调用路径以外

690
00:20:51,476 --> 0:20:52,986
你知道 这种调用路径占了

691
00:20:52,986 --> 0:20:54,116
大部分的总百分比

692
00:20:54,436 --> 0:20:56,566
同时还有其他的这些附带样本

693
00:20:58,266 --> 0:20:59,896
它们很容易分散

694
00:20:59,896 --> 0:21:00,236
我们的注意力

695
00:20:59,896 --> 0:21:00,236
我们的注意力

696
00:21:01,286 --> 0:21:03,766
它们的其中之一就是

697
00:21:03,766 --> 0:21:04,076
OPC Message Send

698
00:21:04,646 --> 0:21:06,926
它可以遍布你的追踪器

699
00:21:06,926 --> 0:21:08,296
只要你在写 Objective C

700
00:21:08,606 --> 0:21:09,916
即使你在写 Swift 代码

701
00:21:09,916 --> 0:21:10,936
当你按照你的方式

702
00:21:10,936 --> 0:21:11,966
进入系统库时

703
00:21:11,966 --> 0:21:12,296
你也会看到这个

704
00:21:12,636 --> 0:21:13,856
你会经常看到它的对应函数

705
00:21:13,856 --> 0:21:15,916
OPC LoadStrong LoadWeak

706
00:21:15,916 --> 0:21:18,726
Retain 等等 你可以

707
00:21:18,726 --> 0:21:20,936
将所有的内容从调用关系树里删除

708
00:21:20,936 --> 0:21:23,826
根据上下文点开这里

709
00:21:23,866 --> 0:21:28,706
选择 “Charge OPC to Callers”

710
00:21:29,406 --> 0:21:30,436
它就会告诉 Instruments

711
00:21:30,466 --> 0:21:31,886
来选取所有

712
00:21:31,886 --> 0:21:33,686
来自于 OPC 库的样本

713
00:21:33,686 --> 0:21:35,176
然后将它们从调用数据中删除

714
00:21:35,176 --> 0:21:36,456
但是要将时间的属性归于

715
00:21:36,456 --> 0:21:37,846
调用它们的父框架

716
00:21:38,176 --> 0:21:39,776
我倾向于将那些

717
00:21:39,776 --> 0:21:41,126
Objective C 运行时的函数

718
00:21:41,126 --> 0:21:42,266
视为在书写 Objective C 代码时

719
00:21:42,266 --> 0:21:43,306
的代价成本

720
00:21:43,706 --> 0:21:46,136
我很少会去试图优化它们

721
00:21:46,136 --> 0:21:48,396
所以我只会

722
00:21:48,456 --> 0:21:49,596
将它们从数据中删除

723
00:21:49,596 --> 0:21:50,886
这样我就可以聚焦在

724
00:21:50,886 --> 0:21:51,916
我可能要处理的地方

725
00:21:53,176 --> 0:21:55,466
还有一个你们可以应用的

726
00:21:55,466 --> 0:21:56,866
强大的过滤器

727
00:21:56,866 --> 0:21:59,076
我要用它来删除所有

728
00:21:59,076 --> 0:22:00,356
出现在这一组帧中的小样本

729
00:21:59,076 --> 0:22:00,356
出现在这一组帧中的小样本

730
00:22:00,356 --> 0:22:02,186
它就在这里

731
00:22:02,226 --> 0:22:05,596
Call Tree 约束条件的部分

732
00:22:06,126 --> 0:22:07,646
让我来给你演示

733
00:22:11,146 --> 0:22:12,716
我将要告诉 Instruments

734
00:22:12,716 --> 0:22:14,006
我想要看到的轨迹范围

735
00:22:14,486 --> 0:22:16,236
只包括我们所说的

736
00:22:16,236 --> 0:22:18,966
20 或者更多的样本

737
00:22:19,256 --> 0:22:20,566
我选择 20 是因为

738
00:22:20,566 --> 0:22:21,606
我知道我已经选择了

739
00:22:21,606 --> 0:22:23,066
一个两秒的间隔

740
00:22:23,066 --> 0:22:24,376
那么 20 毫秒

741
00:22:24,376 --> 0:22:26,076
将会呈现出整个工作的大约 1%

742
00:22:26,076 --> 0:22:27,036
而就包含了

743
00:22:27,036 --> 0:22:29,846
在默认情况下 我想进行工作的粒度

744
00:22:31,336 --> 0:22:32,926
因此将 Call Tree 约束条件

745
00:22:33,986 --> 0:22:37,206
设置为一个最小值 20

746
00:22:37,206 --> 0:22:39,516
我就能更有效地聚焦在这里

747
00:22:40,456 --> 0:22:41,346
那么 我在这里提到过

748
00:22:41,346 --> 0:22:43,296
我们在扩展我的视图项目

749
00:22:43,336 --> 0:22:45,026
我看到在这里

750
00:22:45,026 --> 0:22:46,446
我们其实在调用 NS 大纲视图

751
00:22:46,446 --> 0:22:47,836
扩展项目 扩展子项

752
00:22:48,436 --> 0:22:51,816
在这里 很多人都会将调用图

753
00:22:51,876 --> 0:22:52,146
停在这里

754
00:22:52,556 --> 0:22:55,226
我们会看到 我正在调用一个系统框架

755
00:22:55,226 --> 0:22:56,346
我在那里花了很多时间

756
00:22:56,706 --> 0:22:58,086
这不是我的错 对吗

757
00:22:58,086 --> 0:22:58,926
那么我能做什么呢

758
00:22:58,926 --> 0:23:00,486
我不能优化 NS 大纲视图

759
00:22:58,926 --> 0:23:00,486
我不能优化 NS 大纲视图

760
00:23:00,486 --> 0:23:01,976
扩大项目

761
00:23:03,126 --> 0:23:04,606
但你肯定有能力

762
00:23:04,606 --> 0:23:05,806
改变这些情况

763
00:23:06,336 --> 0:23:07,706
例如 花费在系统框架上的

764
00:23:07,706 --> 0:23:08,936
所有这些时间

765
00:23:08,936 --> 0:23:10,976
都是因为

766
00:23:10,976 --> 0:23:12,526
它在运算你提供给它的数据

767
00:23:13,366 --> 0:23:14,546
这需要花费很多的时间

768
00:23:14,616 --> 0:23:15,496
因为你在成千上万次地

769
00:23:15,496 --> 0:23:17,476
调用这个方法

770
00:23:18,366 --> 0:23:19,526
它会花这么多时间

771
00:23:19,526 --> 0:23:20,666
还因为它还要通过授权

772
00:23:20,666 --> 0:23:22,376
回调你的代码

773
00:23:22,376 --> 0:23:24,566
而最重要的是

774
00:23:24,566 --> 0:23:25,906
你可以深入地了解

775
00:23:25,906 --> 0:23:27,836
系统框架在做什么

776
00:23:27,836 --> 0:23:28,886
只要沿着 Instruments 树

777
00:23:28,886 --> 0:23:30,186
不断地进行扩展

778
00:23:30,186 --> 0:23:31,816
并查看这些被调用的函数的名称

779
00:23:32,216 --> 0:23:33,766
其实 我就是这样学会

780
00:23:33,766 --> 0:23:36,966
修复这个漏洞的

781
00:23:37,166 --> 0:23:39,166
当我将这个轨迹

782
00:23:39,166 --> 0:23:41,406
扩展到大纲视图中

783
00:23:41,406 --> 0:23:42,966
我能看到 它正在调用这里的两种方法

784
00:23:44,716 --> 0:23:47,106
用项目入口来

785
00:23:47,106 --> 0:23:49,266
批量处理扩展项目和子项

786
00:23:49,266 --> 0:23:50,686
然后再进行最后更新后的工作

787
00:23:51,756 --> 0:23:53,356
现在 那些对我来说都是重要的线索

788
00:23:53,356 --> 0:23:54,366
说明我们或许

789
00:23:54,366 --> 0:23:56,226
有可能通过批量处理来提高效率

790
00:23:56,226 --> 0:23:58,326
正如你能想象的那样

791
00:23:58,326 --> 0:24:00,886
大纲视图从一小组项目开始

792
00:23:58,326 --> 0:24:00,886
大纲视图从一小组项目开始

793
00:24:00,886 --> 0:24:02,386
然后我们试着

794
00:24:02,386 --> 0:24:03,906
在我们代码的这个区域内

795
00:24:03,906 --> 0:24:05,676
不断修复扩展状态

796
00:24:05,676 --> 0:24:06,666
我们会告诉它打开

797
00:24:06,666 --> 0:24:08,256
比如说顶部的项目

798
00:24:08,506 --> 0:24:09,436
而当我告诉它打开顶部的项目时

799
00:24:09,436 --> 0:24:11,406
你能够想象

800
00:24:11,406 --> 0:24:12,576
它同时将里面的其他项目

801
00:24:12,576 --> 0:24:13,296
都向下移了

802
00:24:14,056 --> 0:24:15,716
然后我继续扩展第二个项目

803
00:24:16,106 --> 0:24:17,516
它就会再次下移其他项目

804
00:24:17,906 --> 0:24:19,386
接着是第三个项目 以此类推

805
00:24:19,386 --> 0:24:20,666
而等到你做完这些

806
00:24:20,966 --> 0:24:22,546
你已经将这些底部的项目

807
00:24:22,586 --> 0:24:24,246
向下移动了数千次

808
00:24:25,166 --> 0:24:26,396
那这些都是多余的工作

809
00:24:26,396 --> 0:24:27,626
而它们正是

810
00:24:27,656 --> 0:24:28,976
我在提高性能时

811
00:24:29,206 --> 0:24:30,736
想要消除的东西

812
00:24:31,406 --> 0:24:32,596
现在 这些方法调用

813
00:24:32,596 --> 0:24:35,376
谈到的批量处理

814
00:24:35,376 --> 0:24:36,666
让我觉得或许

815
00:24:36,666 --> 0:24:38,006
在一些 API 中我可以

816
00:24:38,006 --> 0:24:39,416
让大纲视图批量地进行工作

817
00:24:39,416 --> 0:24:41,436
因此它就可以对所有的位置

818
00:24:41,436 --> 0:24:43,336
只进行一次计算

819
00:24:43,336 --> 0:24:44,386
而不是在我进行调用的时候

820
00:24:44,426 --> 0:24:44,986
反复地计算

821
00:24:46,236 --> 0:24:48,256
我还看到一个调用

822
00:24:48,256 --> 0:24:50,056
用来进行最后更新之后的工作

823
00:24:50,406 --> 0:24:52,616
那么 有时 API 会提供那种

824
00:24:52,726 --> 0:24:53,956
在一组列阵上进行运算的

825
00:24:53,956 --> 0:24:55,696
整体方法

826
00:24:55,696 --> 0:24:57,416
而有时它则会提供一种

827
00:24:57,416 --> 0:24:59,456
事务型 API 

828
00:24:59,456 --> 0:25:00,806
它会说我要开始进行更改

829
00:24:59,456 --> 0:25:00,806
它会说我要开始进行更改

830
00:25:01,046 --> 0:25:01,716
然后就做了一系列的变化

831
00:25:01,716 --> 0:25:02,996
然后你说你完成了

832
00:25:02,996 --> 0:25:05,856
之后它会对你变化的全程 

833
00:25:05,856 --> 0:25:07,356
进行计算

834
00:25:07,356 --> 0:25:08,656
这比它自己独自完成这些

835
00:25:08,656 --> 0:25:10,116
要更有效率

836
00:25:11,126 --> 0:25:12,306
那么这时候 我会前往

837
00:25:12,306 --> 0:25:14,336
NS 大纲视图或者

838
00:25:14,336 --> 0:25:15,996
NS 表格视图 API

839
00:25:15,996 --> 0:25:17,296
我会找一些这样的方法

840
00:25:17,686 --> 0:25:19,646
那里确实有一个

841
00:25:19,646 --> 0:25:20,936
在 NS 表格视图里

842
00:25:20,936 --> 0:25:22,176
有一些开始和结束更新

843
00:25:22,176 --> 0:25:23,546
所使用的方法

844
00:25:23,546 --> 0:25:25,096
它们允许合并表格视图

845
00:25:25,096 --> 0:25:26,666
并能够大大提高这些工作的效率

846
00:25:27,426 --> 0:25:29,606
当然 我们要在 Xcode 10 中使用它

847
00:25:30,246 --> 0:25:32,966
让我来给你演示

848
00:25:33,046 --> 0:25:34,376
我要启动 Xcode 10

849
00:25:38,056 --> 0:25:39,136
我要把 Source

850
00:25:39,136 --> 0:25:43,086
作为一个 App 打开

851
00:25:43,086 --> 0:25:44,056
然后我来创建一些标记

852
00:25:44,586 --> 0:25:46,116
你可以看到

853
00:25:46,116 --> 0:25:47,666
这里屏幕没有出现闪黑

854
00:25:47,666 --> 0:25:48,626
标记也打开得更快了

855
00:25:49,506 --> 0:25:52,686
现在 我想让标记打开的速度

856
00:25:52,876 --> 0:25:54,846
比这个更快 对吗

857
00:25:54,846 --> 0:25:55,916
那么我接下来应该怎么做呢

858
00:25:56,596 --> 0:25:57,586
我很幸运

859
00:25:58,536 --> 0:25:59,496
因为你不是每天

860
00:25:59,496 --> 0:26:00,956
都需要进入轨迹中去寻找

861
00:25:59,496 --> 0:26:00,956
都需要进入轨迹中去寻找

862
00:26:00,956 --> 0:26:02,406
一些如此明显且容易修复的东西

863
00:26:02,406 --> 0:26:03,996
而这样的东西在样本里

864
00:26:03,996 --> 0:26:05,156
占到了 50%

865
00:26:05,916 --> 0:26:08,456
对吗 其实并没有

866
00:26:08,456 --> 0:26:09,896
什么巨大的严重问题

867
00:26:09,896 --> 0:26:10,806
等待我来解决

868
00:26:11,686 --> 0:26:12,746
相反 我要做的其实就是

869
00:26:12,746 --> 0:26:14,626
检查整个样本

870
00:26:14,626 --> 0:26:15,656
并在此过程中应用过滤器

871
00:26:15,656 --> 0:26:17,616
所以我只是寻找

872
00:26:17,616 --> 0:26:20,286
一些只占到 1% 或者更多时间的操作

873
00:26:20,286 --> 0:26:21,816
我要寻找每一个

874
00:26:21,816 --> 0:26:23,436
我认为能够运用一些方法

875
00:26:23,436 --> 0:26:24,836
来将其速度

876
00:26:24,836 --> 0:26:26,536
提高一点的东西

877
00:26:28,056 --> 0:26:29,016
我会将它们都记下来

878
00:26:29,016 --> 0:26:30,496
放在一张纸上或一个文档里

879
00:26:30,496 --> 0:26:32,216
或者其他什么东西上

880
00:26:32,216 --> 0:26:33,436
然后我就会着手解决它们

881
00:26:33,746 --> 0:26:34,736
现在 我需要选择一个

882
00:26:34,736 --> 0:26:35,656
解决它们的顺序 对吗

883
00:26:35,656 --> 0:26:37,326
因为有的时候

884
00:26:37,326 --> 0:26:38,716
用修复第二件事情时

885
00:26:38,716 --> 0:26:40,016
所用的方法来修复

886
00:26:40,016 --> 0:26:40,816
列表中的第五件事情

887
00:26:40,816 --> 0:26:42,516
这方法可能会是过时的

888
00:26:42,516 --> 0:26:43,646
如果没有排好顺序

889
00:26:43,646 --> 0:26:44,516
你就会做多余的工作

890
00:26:44,516 --> 0:26:45,536
这是十分糟糕的

891
00:26:45,586 --> 0:26:47,506
因为我们首先要删除的就是

892
00:26:47,506 --> 0:26:48,116
多余的工作

893
00:26:48,746 --> 0:26:50,476
但是这些工作都是如何进行的

894
00:26:50,476 --> 0:26:51,826
我们又很难去预测

895
00:26:52,066 --> 0:26:54,316
你通常无法事先知道这些

896
00:26:54,746 --> 0:26:57,746
所以不要因为这个

897
00:26:57,746 --> 0:26:59,446
停下你开始的脚步

898
00:26:59,446 --> 0:27:00,956
因为你想要把速度提高 30%

899
00:26:59,446 --> 0:27:00,956
因为你想要把速度提高 30%

900
00:27:00,956 --> 0:27:03,536
就得进行 103% 的

901
00:27:03,536 --> 0:27:04,186
改善工作

902
00:27:05,706 --> 0:27:05,976
明白吗

903
00:27:07,316 --> 0:27:10,756
现在 回到我们的幻灯片

904
00:27:10,756 --> 0:27:13,516
我要给你演示

905
00:27:13,516 --> 0:27:14,766
一些我们常用的方法

906
00:27:14,766 --> 0:27:16,126
用来持续改善我们的性能

907
00:27:21,346 --> 0:27:22,326
毫无疑问

908
00:27:22,326 --> 0:27:23,896
我们最常见的就是

909
00:27:23,896 --> 0:27:25,246
使用那些与大纲视觉里

910
00:27:25,246 --> 0:27:26,236
相同的方法

911
00:27:26,396 --> 0:27:28,276
批量处理和推迟处理 对吗

912
00:27:28,276 --> 0:27:29,736
你有一个 API 

913
00:27:29,736 --> 0:27:31,526
而当这个 API 被调用时

914
00:27:31,526 --> 0:27:31,836
会出现一些副作用

915
00:27:32,196 --> 0:27:33,226
然后你用一些代码

916
00:27:33,226 --> 0:27:34,426
调用你在循环中的 API 

917
00:27:34,426 --> 0:27:35,396
这就是你在做的

918
00:27:35,586 --> 0:27:36,536
被请求的首要工作

919
00:27:36,536 --> 0:27:38,566
这其中有一个副作用

920
00:27:39,206 --> 0:27:40,986
好 如果没有人读取

921
00:27:40,986 --> 0:27:42,516
这个副作用的结果

922
00:27:42,516 --> 0:27:43,416
那你就是在反复地

923
00:27:43,416 --> 0:27:44,916
进行多余的工作

924
00:27:45,736 --> 0:27:47,016
你通常可以

925
00:27:47,016 --> 0:27:48,696
通过使用成批的接口

926
00:27:48,696 --> 0:27:50,366
得到一个更加有效的接口

927
00:27:50,366 --> 0:27:52,376
在这里客户端会给你一系列的

928
00:27:52,376 --> 0:27:53,476
或者某种集合 包括所有要完成的工作

929
00:27:53,476 --> 0:27:54,796
以便你能够一次性地

930
00:27:54,796 --> 0:27:56,056
计算那个副作用

931
00:27:57,156 --> 0:27:59,526
那么 有时你有很多个客户端 对吗

932
00:27:59,526 --> 0:28:00,766
你无法对它们进行

933
00:27:59,526 --> 0:28:00,766
你无法对它们进行

934
00:28:00,766 --> 0:28:02,186
批量处理 那也没关系

935
00:28:02,596 --> 0:28:03,606
你仍然可以通过推迟工作

936
00:28:03,606 --> 0:28:04,946
以及缓慢地进行工作

937
00:28:04,946 --> 0:28:06,796
来获得一样的性能风格

938
00:28:09,196 --> 0:28:10,996
第三种提高你的性能的

939
00:28:10,996 --> 0:28:11,966
简单的方法

940
00:28:11,966 --> 0:28:14,026
是检查整个 Instruments 的轨迹

941
00:28:14,026 --> 0:28:15,156
来寻找你看到它

942
00:28:15,156 --> 0:28:17,016
对同样的东西进行反复计算

943
00:28:17,016 --> 0:28:17,656
的地方

944
00:28:18,236 --> 0:28:19,556
比如说 有一个方法

945
00:28:19,676 --> 0:28:20,856
在它计算某个文档的大小的过程中

946
00:28:20,856 --> 0:28:22,526
你看到同样的事情

947
00:28:22,526 --> 0:28:24,156
在之后的几帧中也出现了

948
00:28:24,156 --> 0:28:25,946
对于相同的文档

949
00:28:25,946 --> 0:28:27,006
不断地重复

950
00:28:27,436 --> 0:28:28,426
好 在这样的情况下

951
00:28:28,496 --> 0:28:29,536
当然 你肯定想

952
00:28:29,536 --> 0:28:31,076
一次性计算出该值

953
00:28:32,076 --> 0:28:33,226
在最顶端计算它

954
00:28:33,226 --> 0:28:35,406
让它不断地传下去 或者缓存它

955
00:28:36,476 --> 0:28:37,846
另一个你可以在你的

956
00:28:37,846 --> 0:28:38,876
UI App 中使用的方法

957
00:28:38,876 --> 0:28:41,166
就是考虑

958
00:28:41,166 --> 0:28:42,296
你使用了多少视图

959
00:28:42,296 --> 0:28:43,146
来渲染你的 UI

960
00:28:43,146 --> 0:28:46,466
使用一些带有小的

961
00:28:46,466 --> 0:28:48,106
函数集的很小的视图

962
00:28:48,106 --> 0:28:50,216
然后再将它们一起

963
00:28:50,216 --> 0:28:51,306
生成大的函数

964
00:28:51,306 --> 0:28:52,286
以此来组织你的源代码

965
00:28:52,286 --> 0:28:53,066
这是很好的

966
00:28:53,516 --> 0:28:55,216
但是你使用的视图越多

967
00:28:55,216 --> 0:28:57,516
你就越难负担绘图

968
00:28:57,516 --> 0:28:58,276
进行系统的布局

969
00:28:59,306 --> 0:29:01,066
现在 这是一条双向道

970
00:28:59,306 --> 0:29:01,066
现在 这是一条双向道

971
00:29:01,336 --> 0:29:02,776
因为更小的视图通常会

972
00:29:02,776 --> 0:29:04,086
让你有更多精密的捕捉

973
00:29:04,086 --> 0:29:06,156
它们也可以提高你的性能

974
00:29:07,266 --> 0:29:08,896
但是一般来说 你可以微调

975
00:29:08,896 --> 0:29:10,446
你拥有的视图的数量

976
00:29:10,446 --> 0:29:11,606
以对性能产生

977
00:29:11,606 --> 0:29:12,666
显著的影响

978
00:29:12,786 --> 0:29:14,596
但视图更少的话

979
00:29:14,596 --> 0:29:16,556
也并不都是最好的

980
00:29:16,556 --> 0:29:17,606
否则我们所有的 App

981
00:29:17,686 --> 0:29:18,866
都会只有一个包括所有内容的

982
00:29:18,866 --> 0:29:19,116
巨大视图了

983
00:29:21,266 --> 0:29:22,396
另一个经常

984
00:29:22,396 --> 0:29:24,806
用到的方法就是直接观察

985
00:29:25,356 --> 0:29:26,916
我们的源代码中通常

986
00:29:26,916 --> 0:29:30,136
有两个松散耦合的方面

987
00:29:30,286 --> 0:29:31,466
也许它们彼此知道对方

988
00:29:31,466 --> 0:29:33,296
而它们是通过一些

989
00:29:33,296 --> 0:29:34,996
间接的机制

990
00:29:34,996 --> 0:29:36,016
进行交流的

991
00:29:36,456 --> 0:29:37,796
也许它们用

992
00:29:37,796 --> 0:29:39,916
NS Notification Center

993
00:29:39,966 --> 0:29:41,316
一些基于代码块的回调

994
00:29:41,516 --> 0:29:43,606
授权或者关键值观察

995
00:29:45,006 --> 0:29:46,156
我常常见到

996
00:29:46,216 --> 0:29:47,326
我们会有一些模型代码

997
00:29:47,326 --> 0:29:49,076
它们在一个循环中

998
00:29:49,076 --> 0:29:50,946
被不断地改变

999
00:29:50,946 --> 0:29:51,856
而每次它走向循环

1000
00:29:52,206 --> 0:29:55,136
就会引起许多 KVO 通告机制

1001
00:29:55,386 --> 0:29:56,286
当然 你其实并不能

1002
00:29:56,286 --> 0:29:57,876
在模块代码中看到它

1003
00:29:57,956 --> 0:29:59,236
但是在一些其他的控件里

1004
00:29:59,526 --> 0:30:00,946
它会十分活跃地作出回应

1005
00:29:59,526 --> 0:30:00,946
它会十分活跃地作出回应

1006
00:30:00,946 --> 0:30:01,966
并试图与模块里的变化

1007
00:30:01,966 --> 0:30:03,126
保持一致

1008
00:30:03,126 --> 0:30:04,786
这时你就花费了许多 CPU 时间

1009
00:30:04,786 --> 0:30:06,636
最终当你考虑整个的

1010
00:30:06,636 --> 0:30:07,656
变化的时候

1011
00:30:07,656 --> 0:30:08,806
这些都是多余的工作

1012
00:30:09,496 --> 0:30:12,306
那么 如果这是模块代码中的

1013
00:30:12,776 --> 0:30:13,826
直接调用 那么

1014
00:30:13,826 --> 0:30:14,866
不论是通过通告机制或授权

1015
00:30:15,416 --> 0:30:17,106
还是手动进行基于代码块的回调

1016
00:30:17,106 --> 0:30:19,506
改变都会发生地更加明显

1017
00:30:19,506 --> 0:30:20,936
当你编辑该模块代码时

1018
00:30:21,396 --> 0:30:22,556
你也许认为

1019
00:30:22,556 --> 0:30:24,366
将一些通告机制从循环中

1020
00:30:24,366 --> 0:30:26,126
拖出到循环之外

1021
00:30:26,126 --> 0:30:27,916
以对性能产生

1022
00:30:27,916 --> 0:30:29,906
较大的影响 是完全合适的

1023
00:30:30,556 --> 0:30:31,856
那么 或者

1024
00:30:31,856 --> 0:30:33,476
在控件这边 你可以用这些

1025
00:30:33,476 --> 0:30:35,206
推迟和批量处理方法中的一个

1026
00:30:35,206 --> 0:30:36,946
来避免多余的工作

1027
00:30:36,946 --> 0:30:38,336
只是它们的回应

1028
00:30:38,336 --> 0:30:39,246
是不同步的

1029
00:30:41,136 --> 0:30:42,216
最后 这是最简单的一个

1030
00:30:42,836 --> 0:30:44,716
一旦你的代码已经在

1031
00:30:45,046 --> 0:30:46,386
一个很好的路径上了

1032
00:30:46,386 --> 0:30:47,586
你知道 它已经是线性的了

1033
00:30:47,586 --> 0:30:49,366
而且不会有比线性更好的了

1034
00:30:49,366 --> 0:30:50,346
这是一种你要

1035
00:30:51,796 --> 0:30:52,966
获得的最低性能

1036
00:30:53,626 --> 0:30:54,876
毕竟 你要尽可能地

1037
00:30:54,876 --> 0:30:57,186
改进常数时间

1038
00:30:57,246 --> 0:30:58,676
那么 很简单

1039
00:30:58,676 --> 0:31:00,096
如果你将词典

1040
00:30:58,676 --> 0:31:00,096
如果你将词典

1041
00:31:00,096 --> 0:31:01,366
作为对象使用

1042
00:31:01,366 --> 0:31:02,636
那你或许已经看到这点

1043
00:31:02,926 --> 0:31:04,216
如果你有一堆为秘钥准备的

1044
00:31:04,216 --> 0:31:06,166
字符串常数

1045
00:31:06,166 --> 0:31:07,466
那么你就可以大幅度提高

1046
00:31:07,466 --> 0:31:09,186
代码的清晰性

1047
00:31:09,186 --> 0:31:11,396
提高代码完成和重构

1048
00:31:11,396 --> 0:31:12,396
以及源代码验证

1049
00:31:12,396 --> 0:31:14,966
通过使用特定的形式

1050
00:31:15,076 --> 0:31:16,136
用它们的 strucks 和 swift

1051
00:31:16,136 --> 0:31:18,066
用它们隐含的初始化器和一致性

1052
00:31:18,066 --> 0:31:19,196
来平等哈希值

1053
00:31:19,196 --> 0:31:20,816
这再简单不过了

1054
00:31:21,336 --> 0:31:23,646
而这能轻而易举地

1055
00:31:23,646 --> 0:31:24,586
改进你的源代码

1056
00:31:24,586 --> 0:31:26,206
如果你在许多小目标上

1057
00:31:26,206 --> 0:31:27,916
完成数百万次的

1058
00:31:27,916 --> 0:31:29,546
字符串哈希映射

1059
00:31:29,546 --> 0:31:31,126
和字符串 equation 的话

1060
00:31:31,126 --> 0:31:32,546
你会惊讶于你花费了

1061
00:31:32,546 --> 0:31:33,316
多少时间

1062
00:31:34,516 --> 0:31:35,736
那么接下来的时间

1063
00:31:35,736 --> 0:31:37,386
我想请 Matthew 上台来

1064
00:31:37,386 --> 0:31:38,966
谈谈我们如何将这些方法

1065
00:31:39,056 --> 0:31:40,686
应用到“照片”中去

1066
00:31:42,516 --> 0:31:47,866
［ 掌声 ］

1067
00:31:48,366 --> 0:31:48,806
&gt;&gt; 谢谢 Jim

1068
00:31:49,966 --> 0:31:50,656
大家好

1069
00:31:50,826 --> 0:31:52,746
我是 Matthew Lucas

1070
00:31:52,806 --> 0:31:56,076
一名“照片”团队的工程师

1071
00:31:56,076 --> 0:31:57,536
今天我想给你们一些

1072
00:31:57,536 --> 0:31:59,316
直接从“照片”中来的

1073
00:31:59,316 --> 0:32:00,296
实用的性能的例子

1074
00:31:59,316 --> 0:32:00,296
实用的性能的例子

1075
00:32:01,306 --> 0:32:02,556
那么首先 让我们先来

1076
00:32:02,556 --> 0:32:03,536
简单谈谈“照片”

1077
00:32:04,076 --> 0:32:05,466
我们都十分熟悉这个 App

1078
00:32:06,026 --> 0:32:07,766
它可以供你存储 浏览

1079
00:32:07,846 --> 0:32:09,696
并体验你最喜爱的时刻

1080
00:32:10,236 --> 0:32:11,686
因此你可以浏览你最喜欢的时刻

1081
00:32:11,716 --> 0:32:13,526
从这个“时刻”视图里

1082
00:32:13,646 --> 0:32:14,596
在这里可以看到

1083
00:32:14,596 --> 0:32:15,496
这是默认视图

1084
00:32:15,926 --> 0:32:17,526
但是你也可以

1085
00:32:17,526 --> 0:32:19,456
切换到另一种视图“精选” 

1086
00:32:19,456 --> 0:32:19,926
或者“年度”

1087
00:32:20,566 --> 0:32:22,736
这个我一会再细说

1088
00:32:23,446 --> 0:32:25,306
现在图片库里可以有

1089
00:32:25,306 --> 0:32:28,346
1000 到 100000 张先前的素材

1090
00:32:29,126 --> 0:32:30,636
这取决于你对拍照的喜爱

1091
00:32:31,196 --> 0:32:33,036
我们都喜欢捕捉每天的生活中

1092
00:32:33,036 --> 0:32:34,976
那些快乐而珍贵的瞬间

1093
00:32:36,336 --> 0:32:37,366
所以我们都很耐心地去捕捉它们

1094
00:32:37,366 --> 0:32:38,846
但是当这样的事发生时

1095
00:32:38,846 --> 0:32:40,576
我们并不是那么地有耐心

1096
00:32:41,286 --> 0:32:42,346
在你启动“照片” 

1097
00:32:42,346 --> 0:32:44,226
这个 App 的时候

1098
00:32:44,226 --> 0:32:45,296
如果你的“时刻”变成了这样

1099
00:32:45,296 --> 0:32:46,926
你会有什么感受

1100
00:32:47,386 --> 0:32:48,636
那么 你也许

1101
00:32:48,636 --> 0:32:50,596
还会遇到这样的情况

1102
00:32:50,596 --> 0:32:51,716
在这里只有许多的

1103
00:32:51,716 --> 0:32:53,106
空白图片框 这样看起来

1104
00:32:53,106 --> 0:32:53,586
并不是非常好

1105
00:32:54,266 --> 0:32:55,356
也许你轻轻滑动

1106
00:32:55,856 --> 0:32:57,216
这个灰色的地方就会消失

1107
00:32:57,216 --> 0:33:00,736
照片就会开始加载

1108
00:32:57,216 --> 0:33:00,736
照片就会开始加载

1109
00:33:00,736 --> 0:33:01,766
但你继续滑动

1110
00:33:01,766 --> 0:33:02,886
你就会遇到一些掉帧

1111
00:33:02,886 --> 0:33:04,326
因为视图被更新了

1112
00:33:05,556 --> 0:33:06,836
好 我们的目标就是

1113
00:33:06,836 --> 0:33:07,626
不要出现这样的视图

1114
00:33:08,666 --> 0:33:09,876
我们认为这种视图

1115
00:33:09,926 --> 0:33:12,066
并不是好的用户体验

1116
00:33:12,066 --> 0:33:13,366
但是我们知道有时候

1117
00:33:13,366 --> 0:33:14,156
这是不可避免的

1118
00:33:14,556 --> 0:33:15,706
但是当它过于频繁时

1119
00:33:15,706 --> 0:33:16,666
就无法忍受了

1120
00:33:18,546 --> 0:33:19,666
现在 当你运行一个 App 时

1121
00:33:19,666 --> 0:33:20,756
你想要确保它一开始就能用

1122
00:33:20,756 --> 0:33:22,456
能够做出响应

1123
00:33:23,576 --> 0:33:25,296
你还要确保

1124
00:33:25,296 --> 0:33:26,516
动画是很流畅的

1125
00:33:27,226 --> 0:33:30,516
而这两个属性

1126
00:33:30,516 --> 0:33:31,796
对用户体验来说

1127
00:33:31,796 --> 0:33:32,786
都是十分重要的

1128
00:33:33,446 --> 0:33:35,766
如果用户发现你的 App

1129
00:33:35,766 --> 0:33:37,256
并不相关

1130
00:33:37,256 --> 0:33:38,146
他们也许不会再使用它了

1131
00:33:39,526 --> 0:33:40,706
现在我来举例说明这两点

1132
00:33:40,706 --> 0:33:42,626
我要给你们

1133
00:33:42,626 --> 0:33:43,426
举两个例子

1134
00:33:43,716 --> 0:33:45,726
第一个就是我们如何

1135
00:33:45,726 --> 0:33:47,406
对这个“时刻”视图的启动

1136
00:33:47,406 --> 0:33:48,166
进行优化

1137
00:33:48,886 --> 0:33:50,506
第二个则是我们如何

1138
00:33:50,506 --> 0:33:52,576
创建这个“精选”和“年度”视图

1139
00:33:52,576 --> 0:33:53,866
以更好地适应用户的偏好

1140
00:33:56,696 --> 0:33:59,876
首先是启动“时刻”

1141
00:34:00,296 --> 0:34:02,296
[ 音质不清晰 ]

1142
00:34:02,716 --> 0:34:03,876
那么什么是启动

1143
00:34:04,046 --> 0:34:05,386
我们有三种启动

1144
00:34:06,696 --> 0:34:08,176
第一种也是更为昂贵的一种

1145
00:34:08,176 --> 0:34:09,476
即我们所说的冷启动

1146
00:34:09,476 --> 0:34:11,406
它取决于在重启后

1147
00:34:11,406 --> 0:34:13,186
第一次重新启动你的 App

1148
00:34:14,346 --> 0:34:15,606
所以里面基本上

1149
00:34:15,606 --> 0:34:17,446
还没有缓存任何东西

1150
00:34:17,446 --> 0:34:19,096
也许你需要载入一些后台过程

1151
00:34:19,096 --> 0:34:19,946
或者一些库

1152
00:34:21,136 --> 0:34:23,116
下面在这样的情况也会冷启动

1153
00:34:23,206 --> 0:34:24,916
系统在内存压力下运行

1154
00:34:24,916 --> 0:34:29,686
开始回收一些内存

1155
00:34:30,045 --> 0:34:31,485
那么 如果你关闭一个 App

1156
00:34:31,485 --> 0:34:32,906
也许不会触发代码运行

1157
00:34:32,906 --> 0:34:34,606
因为是系统决定了资源

1158
00:34:34,606 --> 0:34:38,766
应该何时被放在

1159
00:34:38,766 --> 0:34:38,976
页面上

1160
00:34:39,065 --> 0:34:40,466
而如果你关闭了一个 App

1161
00:34:40,466 --> 0:34:41,646
然后几秒之后重新打开它

1162
00:34:41,726 --> 0:34:43,835
几乎可以肯定

1163
00:34:43,835 --> 0:34:45,565
你进行的是一个热启动

1164
00:34:46,036 --> 0:34:47,706
我们称其为热启动

1165
00:34:47,706 --> 0:34:50,386
是因为资源或从属的东西

1166
00:34:50,386 --> 0:34:52,116
都仍然在缓存里

1167
00:34:52,116 --> 0:34:52,996
所以它能更快地启动

1168
00:34:54,525 --> 0:34:56,636
那么 最后一种类型就是

1169
00:34:56,636 --> 0:34:59,026
我们所说的热启动

1170
00:34:59,026 --> 0:35:00,926
根本上说它就是继续启动

1171
00:34:59,026 --> 0:35:00,926
根本上说它就是继续启动

1172
00:35:00,926 --> 0:35:02,526
因为这时 App 已经处于运行状态

1173
00:35:02,526 --> 0:35:04,206
直接把它带回前台就可以了

1174
00:35:05,046 --> 0:35:06,136
所以当你开始测量启动时

1175
00:35:06,136 --> 0:35:07,656
你应该从测量

1176
00:35:07,656 --> 0:35:08,786
热启动开始

1177
00:35:09,456 --> 0:35:12,636
它所用的时间

1178
00:35:12,636 --> 0:35:14,036
要比冷启动所花的时间

1179
00:35:14,036 --> 0:35:17,326
变量更小

1180
00:35:17,326 --> 0:35:18,656
而测试迭代也更快

1181
00:35:18,656 --> 0:35:19,656
因为你不需要

1182
00:35:19,656 --> 0:35:20,536
重启你的设备

1183
00:35:21,846 --> 0:35:23,226
那么 我们用来测量启动的方法

1184
00:35:23,226 --> 0:35:25,156
是对从你点击这个 App

1185
00:35:25,156 --> 0:35:26,566
的图标的那一刻

1186
00:35:26,676 --> 0:35:28,236
到你可以开始与你的 App 进行互动

1187
00:35:28,236 --> 0:35:30,696
的整个时间进行评估

1188
00:35:30,986 --> 0:35:32,316
我说互动的意思就是

1189
00:35:32,316 --> 0:35:34,386
它真的可以使用了

1190
00:35:34,386 --> 0:35:35,726
而不再有旋转的圈

1191
00:35:37,436 --> 0:35:38,826
它通常会在显示

1192
00:35:38,856 --> 0:35:40,536
这个旋转的圈的同时 

1193
00:35:40,536 --> 0:35:41,956
分派一些工作

1194
00:35:41,956 --> 0:35:43,126
但并不能让 App 更快地投入使用

1195
00:35:43,126 --> 0:35:44,526
所以我们想要

1196
00:35:44,526 --> 0:35:47,086
避免这些

1197
00:35:47,386 --> 0:35:48,656
现在 我们有三个针对

1198
00:35:48,656 --> 0:35:49,886
“照片”的目标

1199
00:35:50,576 --> 0:35:52,056
第一个就是我们想要瞬时

1200
00:35:52,056 --> 0:35:54,486
我们不想出现任何

1201
00:35:54,486 --> 0:35:57,666
等待的圆圈

1202
00:35:57,666 --> 0:35:59,266
我们不想出现任何

1203
00:36:00,996 --> 0:36:02,256
空白的图片框

1204
00:36:03,286 --> 0:36:04,346
坦白地说

1205
00:36:04,346 --> 0:36:06,686
你也许会看到一些空白图片框

1206
00:36:06,686 --> 0:36:07,886
在你第一次

1207
00:36:07,886 --> 0:36:09,536
同步 iClub 的时候

1208
00:36:09,536 --> 0:36:11,196
但是当数据本地化后

1209
00:36:11,266 --> 0:36:13,746
就尽可能地不显示了

1210
00:36:13,996 --> 0:36:15,446
那么 我所说的瞬时是什么意思呢

1211
00:36:16,356 --> 0:36:17,606
就是它启动所花的时间

1212
00:36:17,606 --> 0:36:18,836
应该和从主屏幕上

1213
00:36:18,836 --> 0:36:20,646
放大的动画过程的时间 保持一致

1214
00:36:21,086 --> 0:36:22,506
这个时间通常是 500 到

1215
00:36:22,506 --> 0:36:24,796
600 毫秒之间

1216
00:36:25,176 --> 0:36:26,386
这样一来 从主屏幕到

1217
00:36:26,386 --> 0:36:27,726
App 的转换

1218
00:36:27,836 --> 0:36:29,426
就是无缝连接的了

1219
00:36:29,426 --> 0:36:31,036
用户可以立刻与 App 互动

1220
00:36:31,036 --> 0:36:32,876
只要它显示完动画过程

1221
00:36:33,446 --> 0:36:34,666
顺便说一下

1222
00:36:34,666 --> 0:36:35,986
这是最基本的建议

1223
00:36:35,986 --> 0:36:37,546
这不只是给“照片”的

1224
00:36:37,546 --> 0:36:40,186
所以它适用于所有的 App

1225
00:36:40,346 --> 0:36:41,666
那么让我们来看看“照片”

1226
00:36:41,666 --> 0:36:42,266
现在是如何启动的

1227
00:36:43,436 --> 0:36:44,956
如果我们近距离地

1228
00:36:44,956 --> 0:36:46,576
看看到底发生了什么

1229
00:36:46,576 --> 0:36:48,656
你就能看到“照片” 

1230
00:36:48,656 --> 0:36:50,146
在动画过程完成之前

1231
00:36:50,146 --> 0:36:50,576
就已经准备好了

1232
00:36:53,466 --> 0:36:55,216
如果我们深入剖析这个启动

1233
00:36:55,216 --> 0:36:57,356
我们就会看到

1234
00:36:57,356 --> 0:36:58,326
这里主要有两个部分

1235
00:36:58,746 --> 0:37:00,256
第一部分时间花在 DYD 中

1236
00:36:58,746 --> 0:37:00,256
第一部分时间花在 DYD 中

1237
00:37:00,256 --> 0:37:02,156
这是载入器

1238
00:37:02,156 --> 0:37:03,466
它将加载并连接 

1239
00:37:03,466 --> 0:37:05,416
你所有的动态链接器

1240
00:37:05,416 --> 0:37:06,436
而它还要运行你的

1241
00:37:06,436 --> 0:37:07,576
静态初始化器

1242
00:37:08,766 --> 0:37:10,316
虽然你对这部分

1243
00:37:10,426 --> 0:37:11,476
的控制是有限的

1244
00:37:11,476 --> 0:37:11,886
但也有可能做到

1245
00:37:12,576 --> 0:37:14,886
我鼓励你们去看看

1246
00:37:14,886 --> 0:37:17,166
去年 DYD 的部分

1247
00:37:18,196 --> 0:37:21,496
就能得到这个方面

1248
00:37:21,496 --> 0:37:21,896
更多的细节

1249
00:37:23,566 --> 0:37:25,686
那么 DYD 也要

1250
00:37:25,686 --> 0:37:27,486
在你的项目表中调用 Main

1251
00:37:27,486 --> 0:37:28,716
这就将我们带到了第二个部分

1252
00:37:29,106 --> 0:37:30,356
在这里你有很多控件

1253
00:37:30,356 --> 0:37:32,236
这个部分里 你需要确保

1254
00:37:32,236 --> 0:37:34,016
将它的时间保持在

1255
00:37:34,016 --> 0:37:35,056
500 毫秒以内

1256
00:37:35,976 --> 0:37:38,386
现在 第一个布局正好被排在

1257
00:37:38,386 --> 0:37:39,786
Did Finish Launching 之后

1258
00:37:40,276 --> 0:37:41,286
它将标记启动的结束

1259
00:37:41,286 --> 0:37:42,796
而这时你基本上

1260
00:37:42,796 --> 0:37:43,946
就可以使用你的 App 了

1261
00:37:46,016 --> 0:37:47,556
在这个部分 

1262
00:37:47,606 --> 0:37:49,116
我们将要提到

1263
00:37:49,116 --> 0:37:51,056
一些原则

1264
00:37:51,056 --> 0:37:52,316
它们的确是我们在

1265
00:37:52,316 --> 0:37:53,456
进行性能工作时

1266
00:37:53,456 --> 0:37:53,846
最大的收获

1267
00:37:55,116 --> 0:37:56,976
第一是我们需要惰性

1268
00:37:56,976 --> 0:37:59,566
推迟我们不需要

1269
00:37:59,616 --> 0:38:00,876
的工作

1270
00:37:59,616 --> 0:38:00,876
的工作

1271
00:38:01,396 --> 0:38:02,546
第二则是要积极主动

1272
00:38:02,546 --> 0:38:04,506
而这两个方面

1273
00:38:04,506 --> 0:38:05,256
都有它的效用

1274
00:38:05,256 --> 0:38:07,866
积极主动能够

1275
00:38:08,006 --> 0:38:09,716
十分有效地预料

1276
00:38:09,716 --> 0:38:12,296
我们之后要做的工作

1277
00:38:12,296 --> 0:38:13,526
我们想要积极主动地

1278
00:38:13,526 --> 0:38:15,176
快速捕捉到衰退

1279
00:38:15,176 --> 0:38:16,116
因而你要确保

1280
00:38:16,116 --> 0:38:18,716
你设置了连续的综合测试

1281
00:38:21,536 --> 0:38:23,116
最后一点就是

1282
00:38:23,116 --> 0:38:24,726
无论我们总共需要

1283
00:38:24,806 --> 0:38:26,046
加载多少数据

1284
00:38:26,046 --> 0:38:26,566
我们都要持续不变

1285
00:38:29,496 --> 0:38:31,646
现在 如果我们用这个方法

1286
00:38:31,646 --> 0:38:32,986
我们载入所有在启动中

1287
00:38:32,986 --> 0:38:34,186
要用到的东西

1288
00:38:34,186 --> 0:38:35,366
这是它大概会在一个

1289
00:38:35,366 --> 0:38:37,806
有 30000 项的库里

1290
00:38:37,806 --> 0:38:38,556
花费的时间

1291
00:38:39,696 --> 0:38:41,106
首先你需要初始化数据库

1292
00:38:41,106 --> 0:38:42,696
然后你需要

1293
00:38:42,696 --> 0:38:43,986
准备一些视图控件

1294
00:38:44,356 --> 0:38:45,516
接着需要配置数据资源

1295
00:38:45,516 --> 0:38:47,236
加载一些库图像

1296
00:38:47,236 --> 0:38:49,066
然后读取云状态

1297
00:38:49,986 --> 0:38:52,236
你要记住 这个时间也许会

1298
00:38:52,306 --> 0:38:54,496
随着数据的生长发生变化

1299
00:38:54,496 --> 0:38:56,666
而其实数据将会一直生长

1300
00:38:56,666 --> 0:38:59,593
只要人们每天都拍照

1301
00:39:00,046 --> 0:39:01,666
所以在“照片”里一定要记住

1302
00:39:01,666 --> 0:39:02,646
我们要处理的是没有边界的

1303
00:39:02,646 --> 0:39:05,526
数据集

1304
00:39:05,766 --> 0:39:07,016
那么让我们来看看

1305
00:39:07,016 --> 0:39:09,166
如何优化“照片”的每一个步骤

1306
00:39:09,166 --> 0:39:11,846
就让我们从初始化数据库开始

1307
00:39:13,236 --> 0:39:15,146
首先 数据库通常

1308
00:39:15,146 --> 0:39:16,606
是在执行第一个查询的时候

1309
00:39:16,606 --> 0:39:18,056
被初始化和载入的

1310
00:39:18,656 --> 0:39:19,886
我们发现了一个非常

1311
00:39:19,886 --> 0:39:21,806
值得优化的地方 就是尽快地

1312
00:39:21,806 --> 0:39:22,796
在后台线程中完成初始化

1313
00:39:22,796 --> 0:39:24,586
这样它就不需要

1314
00:39:24,586 --> 0:39:26,346
在执行第一个查询时

1315
00:39:26,346 --> 0:39:27,636
再进行初始化工作了

1316
00:39:28,996 --> 0:39:30,736
这是个问题 特别是

1317
00:39:30,946 --> 0:39:32,256
如果第一个查询已经

1318
00:39:32,256 --> 0:39:33,006
从主线程当中完成了

1319
00:39:34,756 --> 0:39:39,696
现在 我们已经花了很多时间

1320
00:39:39,696 --> 0:39:40,646
而我们仍要花费很多时间

1321
00:39:40,706 --> 0:39:41,956
来检查我们在启动过程中的

1322
00:39:41,956 --> 0:39:43,116
所有的查询

1323
00:39:43,626 --> 0:39:44,766
我们想要确保

1324
00:39:44,846 --> 0:39:46,396
我们正在做的工作

1325
00:39:46,396 --> 0:39:47,786
是必要的

1326
00:39:47,786 --> 0:39:49,276
我们不再做更多的工作

1327
00:39:53,246 --> 0:39:56,106
那么最后 我们要确保

1328
00:39:56,106 --> 0:39:57,586
我们所做的所有查询

1329
00:39:57,586 --> 0:39:59,576
都要尽可能地高效

1330
00:39:59,576 --> 0:40:01,086
我们也想尽可能地

1331
00:39:59,576 --> 0:40:01,086
我们也想尽可能地

1332
00:40:01,086 --> 0:40:04,876
避免复杂的查询

1333
00:40:05,276 --> 0:40:06,986
我们有时知道

1334
00:40:06,986 --> 0:40:08,646
我们需要这样做 针对这类情况

1335
00:40:08,686 --> 0:40:10,676
我们设置了一些索引

1336
00:40:10,676 --> 0:40:12,276
以便我们能提高速度

1337
00:40:15,676 --> 0:40:17,396
现在我们的目标是

1338
00:40:17,396 --> 0:40:19,546
在初始化上花费的时间

1339
00:40:19,546 --> 0:40:20,406
不超过 30 毫秒

1340
00:40:21,286 --> 0:40:22,526
那么接下来让我们看看

1341
00:40:22,526 --> 0:40:23,826
我们如何准备视图控件

1342
00:40:25,106 --> 0:40:25,986
这里我们有四个标记

1343
00:40:25,986 --> 0:40:27,796
呈现在 App 的

1344
00:40:27,906 --> 0:40:29,486
主要特性上

1345
00:40:29,656 --> 0:40:30,966
那么我们需要注意的第一件事

1346
00:40:30,966 --> 0:40:32,826
就是我们想要

1347
00:40:32,826 --> 0:40:33,926
通过做最少的工作

1348
00:40:33,926 --> 0:40:35,756
来初始化这三个

1349
00:40:35,756 --> 0:40:37,306
不可见的标记

1350
00:40:37,746 --> 0:40:39,896
这里我们要遵循的原则

1351
00:40:39,896 --> 0:40:41,516
就是做尽可能地

1352
00:40:41,566 --> 0:40:43,666
少的工作来进行初始化

1353
00:40:44,396 --> 0:40:45,436
我们想要将工作最小化

1354
00:40:45,436 --> 0:40:47,246
同时记录载入的视图中的

1355
00:40:47,246 --> 0:40:47,946
所有的数据

1356
00:40:50,486 --> 0:40:52,716
这也让我们可以

1357
00:40:52,786 --> 0:40:54,646
在恒定时间内

1358
00:40:54,706 --> 0:40:56,446
初始化我们的控件

1359
00:40:58,206 --> 0:40:59,936
那么最后 我们想要

1360
00:40:59,936 --> 0:41:02,376
确保我们只加载了可见视图

1361
00:40:59,936 --> 0:41:02,376
确保我们只加载了可见视图

1362
00:41:02,896 --> 0:41:06,116
这很简单 而我们通常是

1363
00:41:06,116 --> 0:41:07,806
在那个部分出现衰退的

1364
00:41:07,806 --> 0:41:11,376
因此你应该格外小心

1365
00:41:12,016 --> 0:41:12,706
那么在准备视图控件的工作上

1366
00:41:12,706 --> 0:41:14,106
我们现在的目标是

1367
00:41:14,106 --> 0:41:15,696
花费 120 毫秒

1368
00:41:16,626 --> 0:41:18,376
但是准备视图控件意味着

1369
00:41:18,376 --> 0:41:19,646
要配置数据资源

1370
00:41:19,646 --> 0:41:22,216
接下来我们就来看这一块

1371
00:41:25,056 --> 0:41:26,716
所以在“时刻”视图里

1372
00:41:26,716 --> 0:41:27,996
会呈现出这些东西

1373
00:41:27,996 --> 0:41:30,086
呈现你生活中的事件

1374
00:41:30,086 --> 0:41:31,376
而 UI 则通过获得

1375
00:41:31,426 --> 0:41:32,796
这组照片来呈现出

1376
00:41:32,866 --> 0:41:33,266
这些标题栏

1377
00:41:34,206 --> 0:41:35,866
比如说在这个图库中

1378
00:41:35,866 --> 0:41:38,596
我们也许有 500 张照片

1379
00:41:38,596 --> 0:41:40,026
为了创建一个视图

1380
00:41:40,026 --> 0:41:40,976
我们需要预先加载所有的图片

1381
00:41:43,236 --> 0:41:44,706
但是我们只是需要

1382
00:41:44,956 --> 0:41:46,846
这些照片的元数据

1383
00:41:46,846 --> 0:41:48,986
这样我们就可以创建视图了

1384
00:41:49,706 --> 0:41:50,676
我们不需要你的内容

1385
00:41:51,226 --> 0:41:54,846
因此我们首先要做的就是

1386
00:41:54,846 --> 0:41:56,726
执行那个超高速的询问

1387
00:41:56,926 --> 0:41:59,356
然后我们只加载

1388
00:41:59,396 --> 0:42:01,086
我们这里需要的内容

1389
00:41:59,396 --> 0:42:01,086
我们这里需要的内容

1390
00:42:02,286 --> 0:42:04,046
既然是这样

1391
00:42:04,046 --> 0:42:05,016
我们只要加载可见内容

1392
00:42:05,016 --> 0:42:07,466
在我们这个例子里

1393
00:42:07,466 --> 0:42:09,616
可见内容在 7 到 10 个图片之间

1394
00:42:10,956 --> 0:42:12,536
因为我们的可见内容

1395
00:42:12,876 --> 0:42:14,616
是有限值 所以我们可以

1396
00:42:14,616 --> 0:42:16,066
在主线程上

1397
00:42:16,066 --> 0:42:18,376
同时进行加载

1398
00:42:18,696 --> 0:42:20,896
同时 我们还想预先安排工作

1399
00:42:20,896 --> 0:42:23,526
这样我们就可以

1400
00:42:23,526 --> 0:42:25,546
开始异步加载

1401
00:42:25,546 --> 0:42:26,596
剩下的数据

1402
00:42:27,156 --> 0:42:28,406
我们在后台线程上

1403
00:42:28,406 --> 0:42:30,236
以正确的特性进行加载

1404
00:42:30,316 --> 0:42:31,356
来确保它不会

1405
00:42:31,356 --> 0:42:33,886
抢占主线程的运行

1406
00:42:38,416 --> 0:42:40,516
在这里我们的目标是

1407
00:42:40,516 --> 0:42:41,416
100 毫秒

1408
00:42:44,706 --> 0:42:48,266
那么最后 我们的数据源

1409
00:42:48,266 --> 0:42:50,226
还提供一些图像

1410
00:42:50,226 --> 0:42:51,736
我们来看看如何优化这个部分

1411
00:42:53,666 --> 0:42:54,916
所以目前为止

1412
00:42:54,916 --> 0:42:55,936
这是我们面对的

1413
00:42:55,936 --> 0:42:57,986
最大的数据块 

1414
00:42:57,986 --> 0:42:59,066
当我们意识到在启动时

1415
00:42:59,066 --> 0:43:00,376
我们花费了好几秒的时间

1416
00:42:59,066 --> 0:43:00,376
我们花费了好几秒的时间

1417
00:43:00,376 --> 0:43:02,536
来加载这个图像 我们就意识到

1418
00:43:02,586 --> 0:43:04,686
我们做了太多的工作

1419
00:43:05,086 --> 0:43:06,296
所以我们所做的第一件事

1420
00:43:06,296 --> 0:43:08,686
就是估计我们在启动时

1421
00:43:08,686 --> 0:43:10,246
需要用到多少张图像

1422
00:43:10,246 --> 0:43:12,556
然后在第一个事务中

1423
00:43:12,556 --> 0:43:14,566
我们只加载那些图像

1424
00:43:15,286 --> 0:43:17,216
这种情况下 这一数量

1425
00:43:17,216 --> 0:43:19,436
可以达到 60 张

1426
00:43:19,436 --> 0:43:19,876
包括上下堆起的

1427
00:43:20,576 --> 0:43:23,386
接下来 为了先加载那些图像

1428
00:43:23,386 --> 0:43:25,036
我们需要确保

1429
00:43:25,036 --> 0:43:26,676
我们只加载

1430
00:43:26,676 --> 0:43:28,046
低分辨率的图像

1431
00:43:28,806 --> 0:43:29,956
这样我们加载在

1432
00:43:29,956 --> 0:43:32,026
内存里的像素就越少

1433
00:43:32,026 --> 0:43:32,546
这样就能更高效

1434
00:43:35,316 --> 0:43:36,566
呈现出这个数据块

1435
00:43:36,566 --> 0:43:37,486
现在需要 200 毫秒

1436
00:43:39,316 --> 0:43:40,846
这是目前为止

1437
00:43:40,846 --> 0:43:41,566
我们提速最多的部分

1438
00:43:42,296 --> 0:43:43,466
我要它成为一个常数时间

1439
00:43:43,466 --> 0:43:46,966
真的很不错

1440
00:43:47,786 --> 0:43:49,346
那么 有时候你禁不住

1441
00:43:49,346 --> 0:43:50,806
问问自己这个问题

1442
00:43:50,806 --> 0:43:52,056
这在启动的时候真的需要吗

1443
00:43:52,286 --> 0:43:54,116
我们这里的一个例子

1444
00:43:54,116 --> 0:43:54,896
是页脚视图

1445
00:43:55,486 --> 0:43:57,256
它通过网络或数据库

1446
00:43:57,256 --> 0:44:00,316
来搜集信息

1447
00:43:57,256 --> 0:44:00,316
来搜集信息

1448
00:44:00,316 --> 0:44:01,666
而其实我们最先的设计

1449
00:44:01,666 --> 0:44:03,616
是不要在启动时显示它

1450
00:44:04,086 --> 0:44:05,806
以优先所有我们

1451
00:44:05,806 --> 0:44:06,636
在这里看到的图像

1452
00:44:06,906 --> 0:44:08,946
我们想要显示尽可能多的图像

1453
00:44:09,366 --> 0:44:10,356
那这样可能就更简单了

1454
00:44:11,456 --> 0:44:12,936
我们现在只要安排

1455
00:44:12,996 --> 0:44:14,596
启动后的工作

1456
00:44:14,596 --> 0:44:16,216
我们缓存并加工之后要

1457
00:44:16,216 --> 0:44:18,756
显示的信息

1458
00:44:20,686 --> 0:44:21,716
现在 如果我们已经需要

1459
00:44:21,716 --> 0:44:22,936
显示这个信息

1460
00:44:22,936 --> 0:44:24,606
有一个方法可以办到

1461
00:44:24,606 --> 0:44:25,786
利用后台来

1462
00:44:25,786 --> 0:44:27,176
从 UA 工具包中

1463
00:44:27,176 --> 0:44:29,506
刷新 API

1464
00:44:29,506 --> 0:44:31,036
它便会主动清除你的 App

1465
00:44:31,086 --> 0:44:32,376
这样当用户要启动 App 的时候

1466
00:44:32,376 --> 0:44:33,856
你就可以开始

1467
00:44:33,856 --> 0:44:35,446
准备一些内容了

1468
00:44:37,156 --> 0:44:38,836
所以现在 这个部分已经从启动中删除了

1469
00:44:38,836 --> 0:44:40,726
为我们节省了 400 秒的

1470
00:44:40,726 --> 0:44:42,066
CPU 时间

1471
00:44:43,486 --> 0:44:45,276
现在我们看这里的

1472
00:44:45,276 --> 0:44:47,046
更新后的分解图

1473
00:44:47,046 --> 0:44:48,866
可以看到这些工作

1474
00:44:48,866 --> 0:44:50,216
只值得花费 450 毫秒

1475
00:44:50,896 --> 0:44:53,776
而我们现在在这个 500 毫秒

1476
00:44:53,836 --> 0:44:55,866
窗口之中

1477
00:44:55,866 --> 0:44:58,006
而且不论如何

1478
00:44:58,006 --> 0:44:59,486
将其同时呈现出来

1479
00:44:59,486 --> 0:45:00,816
最重要的是

1480
00:44:59,486 --> 0:45:00,816
最重要的是

1481
00:45:01,246 --> 0:45:02,626
一定要确保

1482
00:45:02,626 --> 0:45:03,596
你要考虑你

1483
00:45:03,636 --> 0:45:04,656
准备内容的时间成本

1484
00:45:05,296 --> 0:45:07,466
我这里说的考虑

1485
00:45:07,466 --> 0:45:09,086
是要真的去测量它

1486
00:45:10,606 --> 0:45:12,806
现在 你应该争取

1487
00:45:12,806 --> 0:45:13,746
在常量时间里进行工作

1488
00:45:13,746 --> 0:45:14,926
无论你加载的

1489
00:45:14,926 --> 0:45:15,896
数据总共有多少

1490
00:45:16,676 --> 0:45:17,796
在我们的例子里

1491
00:45:17,796 --> 0:45:19,526
我们的确有许多数据集

1492
00:45:19,746 --> 0:45:21,976
我们需要保持常量时间

1493
00:45:24,756 --> 0:45:25,846
既然我们已经启动了 App

1494
00:45:25,846 --> 0:45:27,746
我们要开始使用它

1495
00:45:27,746 --> 0:45:28,866
那么我们来看看我们是

1496
00:45:29,096 --> 0:45:30,256
如何创建“精选”和“年度”视图的

1497
00:45:30,256 --> 0:45:31,146
以便我们提高性能

1498
00:45:31,226 --> 0:45:34,416
正如我之前提到过

1499
00:45:34,416 --> 0:45:37,236
我们的用户能够进行

1500
00:45:37,236 --> 0:45:39,136
从动画过程到“时刻”视图的无缝转换

1501
00:45:39,436 --> 0:45:40,966
再通过“精选”

1502
00:45:40,966 --> 0:45:41,496
到“年度”视图

1503
00:45:44,316 --> 0:45:46,206
这是一个复杂的层级

1504
00:45:46,886 --> 0:45:48,746
我们要展示数千张的照片

1505
00:45:49,606 --> 0:45:51,116
我们要支持实时更新

1506
00:45:51,686 --> 0:45:53,436
我们也要支持

1507
00:45:53,436 --> 0:45:55,186
这些图层间的动画过程

1508
00:45:55,816 --> 0:45:57,276
我们还有一些手势

1509
00:46:00,436 --> 0:46:02,076
那么 我们这里还有一些目标

1510
00:46:02,956 --> 0:46:05,356
对于带给我们用户的体验

1511
00:46:06,426 --> 0:46:07,726
第一个和之前一样

1512
00:46:07,726 --> 0:46:08,706
我们不想有任何

1513
00:46:08,706 --> 0:46:09,436
等待的圆圈

1514
00:46:09,436 --> 0:46:10,156
我们不想有空白的图片框

1515
00:46:10,256 --> 0:46:12,586
当然我们想要

1516
00:46:12,586 --> 0:46:13,806
流畅的动画过程

1517
00:46:13,996 --> 0:46:15,576
这里所说的流畅

1518
00:46:15,846 --> 0:46:19,396
是指 60 到 120 帧每秒

1519
00:46:19,446 --> 0:46:21,686
这依赖于你正在运行的屏幕

1520
00:46:23,266 --> 0:46:25,356
记得之前我们说过的原则

1521
00:46:25,876 --> 0:46:27,236
现在 它们在这里都是有用的

1522
00:46:27,586 --> 0:46:28,926
我们想要懈怠并推迟

1523
00:46:28,926 --> 0:46:30,036
我们预先递交的工作

1524
00:46:30,786 --> 0:46:31,876
我们想要积极地

1525
00:46:31,876 --> 0:46:34,316
快速捕捉衰退

1526
00:46:34,316 --> 0:46:35,956
但是我们也想要

1527
00:46:35,956 --> 0:46:37,476
在布局关口中保持不变

1528
00:46:37,476 --> 0:46:39,686
无论我们要加载多少数据

1529
00:46:41,566 --> 0:46:42,886
那么 这次我们还想要及时

1530
00:46:42,886 --> 0:46:44,396
我们想要记住

1531
00:46:44,396 --> 0:46:46,046
绘制循环周期

1532
00:46:47,076 --> 0:46:48,426
这里我的意思是

1533
00:46:48,426 --> 0:46:49,676
你要记住

1534
00:46:49,676 --> 0:46:52,096
我们只有 8 或 16 毫秒

1535
00:46:52,096 --> 0:46:53,426
来绘制那一帧

1536
00:46:53,426 --> 0:46:54,206
所以我们需要确保

1537
00:46:54,256 --> 0:46:55,876
我们不超时

1538
00:46:55,916 --> 0:46:57,156
否则就会开始掉帧

1539
00:46:59,356 --> 0:47:01,486
现在 让我们返回一步

1540
00:46:59,356 --> 0:47:01,486
现在 让我们返回一步

1541
00:47:01,486 --> 0:47:02,636
看看我们要在这里

1542
00:47:02,636 --> 0:47:03,176
获取什么

1543
00:47:03,866 --> 0:47:05,076
我们要这个便捷视图

1544
00:47:05,076 --> 0:47:07,466
里面有分栏和小单元格

1545
00:47:09,846 --> 0:47:11,226
而这基本上就是

1546
00:47:11,226 --> 0:47:12,836
“精选”视图给你提供的

1547
00:47:12,836 --> 0:47:13,076
对吗

1548
00:47:13,636 --> 0:47:15,036
只不过在这样极端的例子里

1549
00:47:15,036 --> 0:47:16,246
我们会限制

1550
00:47:16,246 --> 0:47:17,506
我们使用这个基本的方法

1551
00:47:17,506 --> 0:47:18,576
可以获得的极限

1552
00:47:18,746 --> 0:47:20,546
那样就会导致过多的

1553
00:47:20,546 --> 0:47:21,616
视图和过多的图层

1554
00:47:23,796 --> 0:47:26,256
但是随着分层的复杂性不断增加

1555
00:47:26,256 --> 0:47:28,396
花在内存上的时间

1556
00:47:28,396 --> 0:47:30,086
也在不断增加

1557
00:47:31,706 --> 0:47:33,086
所以这里我们需要创新

1558
00:47:33,846 --> 0:47:35,126
我们大幅地限制视图的数量

1559
00:47:35,126 --> 0:47:36,436
同时仍使用一个

1560
00:47:36,436 --> 0:47:37,966
“精选”视图

1561
00:47:40,176 --> 0:47:42,066
我们使用的这种方法

1562
00:47:42,066 --> 0:47:43,466
在电子游戏里更为常见

1563
00:47:43,466 --> 0:47:44,606
它叫做图谱法

1564
00:47:45,146 --> 0:47:47,106
它基本上就是

1565
00:47:47,106 --> 0:47:48,766
把一组图像组合

1566
00:47:48,766 --> 0:47:49,406
成为一个

1567
00:47:50,536 --> 0:47:52,186
我们高效地完成了它

1568
00:47:52,186 --> 0:47:53,806
开始只用很小的缩略图

1569
00:47:53,806 --> 0:47:56,736
然后我们将所有的原始图像数据

1570
00:47:56,736 --> 0:47:58,856
标记在一个我们用作

1571
00:47:58,856 --> 0:47:59,716
带状的画布上

1572
00:48:01,156 --> 0:48:03,336
接着 我们使用图像原始数据

1573
00:48:03,336 --> 0:48:04,866
这样就能够避免去解码每一个

1574
00:48:04,866 --> 0:48:07,766
我们发送的缩略图

1575
00:48:08,376 --> 0:48:09,576
因此基本上我们会显示一条

1576
00:48:09,576 --> 0:48:10,726
随机的图像

1577
00:48:12,406 --> 0:48:14,286
那么 我们飞速生成并缓存它们

1578
00:48:14,286 --> 0:48:16,206
因此我们可以更加灵活

1579
00:48:18,436 --> 0:48:20,086
当我们将多个图片绘制成一个时

1580
00:48:20,086 --> 0:48:22,026
我们会大量寄存

1581
00:48:22,026 --> 0:48:24,716
单元格 图层及目标的数量

1582
00:48:24,716 --> 0:48:26,006
这样便简化了布局

1583
00:48:26,006 --> 0:48:29,066
节省了创建它要花费的时间

1584
00:48:29,686 --> 0:48:31,266
现在这样很好 

1585
00:48:31,266 --> 0:48:32,356
但是也要有所取舍

1586
00:48:32,356 --> 0:48:34,966
这就是它们的其中一个

1587
00:48:36,806 --> 0:48:38,606
如果有人试着长按

1588
00:48:38,606 --> 0:48:40,996
或强制搜索一个这里的项目

1589
00:48:40,996 --> 0:48:42,866
我们就需要计算它的位置

1590
00:48:42,916 --> 0:48:44,536
这样我们才能

1591
00:48:44,536 --> 0:48:45,426
正确地获得预览

1592
00:48:45,996 --> 0:48:48,136
因为只要我们显示一张图像

1593
00:48:48,136 --> 0:48:50,776
我们就需要维持

1594
00:48:50,776 --> 0:48:53,156
每个图像的映射

1595
00:48:53,156 --> 0:48:54,736
以及它的绘制条

1596
00:48:56,086 --> 0:48:57,226
现在你也许在想

1597
00:48:57,226 --> 0:48:58,536
我们为什么要飞速地生成它们

1598
00:49:00,016 --> 0:49:01,736
我们要支持实时更新

1599
00:49:01,736 --> 0:49:03,626
这就是原因

1600
00:49:04,416 --> 0:49:06,536
我们也需要不一样的视图大小

1601
00:49:07,426 --> 0:49:09,016
比如说 我们这里有风景图

1602
00:49:09,516 --> 0:49:11,476
但也有人像图

1603
00:49:12,976 --> 0:49:16,276
但是这没有关系

1604
00:49:16,276 --> 0:49:17,096
因为我们的用户增长

1605
00:49:17,096 --> 0:49:18,786
在很长一段时间里 

1606
00:49:18,786 --> 0:49:20,606
是十分典型的

1607
00:49:20,606 --> 0:49:22,766
而我们需要生成

1608
00:49:22,766 --> 0:49:24,076
数千张图像这样的例子

1609
00:49:24,076 --> 0:49:25,016
相当地罕见

1610
00:49:27,716 --> 0:49:29,086
现在 你或许想知道

1611
00:49:29,086 --> 0:49:30,236
那我们为什么不生成

1612
00:49:30,236 --> 0:49:31,016
整个这部分呢

1613
00:49:32,616 --> 0:49:33,776
答案就是我们的设计记录

1614
00:49:33,776 --> 0:49:35,306
就是完成这个动画过程

1615
00:49:35,306 --> 0:49:36,966
在这里你能看到

1616
00:49:36,966 --> 0:49:37,926
在“精选”视图中它们

1617
00:49:37,926 --> 0:49:39,036
都扩展到自己的那部分中

1618
00:49:39,036 --> 0:49:40,436
或者相反地

1619
00:49:40,436 --> 0:49:42,986
折叠进它们的小组里

1620
00:49:45,616 --> 0:49:47,206
所以如果说第二部分里

1621
00:49:47,206 --> 0:49:48,376
你只要记住一件事情

1622
00:49:48,376 --> 0:49:49,776
那就是你应该考虑

1623
00:49:49,776 --> 0:49:50,916
你的层级的布局成本

1624
00:49:50,916 --> 0:49:54,506
然后对它进行测量

1625
00:49:56,356 --> 0:49:59,106
最后 你要时刻考虑性能

1626
00:49:59,566 --> 0:50:01,066
在“照片”里我们十分关心这点

1627
00:49:59,566 --> 0:50:01,066
在“照片”里我们十分关心这点

1628
00:50:01,066 --> 0:50:02,916
这正是我们日常工作的一部分

1629
00:50:04,906 --> 0:50:06,796
要了解更多的信息

1630
00:50:06,796 --> 0:50:09,026
你们可以观看我在这里提到的

1631
00:50:09,026 --> 0:50:10,146
三个实验室

1632
00:50:10,246 --> 0:50:12,486
祝你们

1633
00:50:12,486 --> 0:50:13,026
参会愉快

1634
00:50:13,526 --> 0:50:13,806
谢谢

1635
00:50:14,516 --> 0:50:20,450
［ 掌声 ］
