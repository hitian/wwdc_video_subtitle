1
00:00:06,516 --> 0:00:13,500
[ 音乐 ]

2
00:00:18,516 --> 0:00:25,786
[ 掌声 ]

3
00:00:26,286 --> 0:00:27,426
&gt;&gt; 上午好

4
00:00:27,536 --> 0:00:28,836
我是 Chad Woolf

5
00:00:28,956 --> 0:00:30,186
我是一名 Apple 的

6
00:00:30,186 --> 0:00:31,706
性能工具工程师

7
00:00:31,706 --> 0:00:32,886
欢迎各位参加今天的 410 号讨论会

8
00:00:32,886 --> 0:00:33,976
我们将讨论

9
00:00:33,976 --> 0:00:35,336
如何在 Instruments 10 中

10
00:00:35,336 --> 0:00:36,706
创建自定义 Instrument

11
00:00:37,346 --> 0:00:38,666
今天的讨论会是这样的

12
00:00:38,666 --> 0:00:39,576
我们将讨论一下

13
00:00:39,796 --> 0:00:41,226
为什么要创建

14
00:00:41,226 --> 0:00:42,246
自定义 Instrument

15
00:00:42,296 --> 0:00:43,526
我们将回顾一下

16
00:00:43,526 --> 0:00:45,406
Instruments 的结构

17
00:00:45,406 --> 0:00:46,366
我们今天有很多内容

18
00:00:46,366 --> 0:00:47,106
所以讨论将会分为

19
00:00:47,106 --> 0:00:48,726
三个部分

20
00:00:48,826 --> 0:00:50,256
入门 中级和进阶部分

21
00:00:50,316 --> 0:00:51,626
在那之后

22
00:00:51,626 --> 0:00:52,956
我们会讨论一些最佳实践

23
00:00:52,956 --> 0:00:54,036
以及一些在我们

24
00:00:54,096 --> 0:00:55,546
编写我们自己的 Instrument 时

25
00:00:55,546 --> 0:00:56,346
所学到的东西

26
00:00:57,166 --> 0:00:58,846
首先

27
00:00:58,846 --> 0:01:00,566
为什么要创建自定义 Instrument

28
00:00:58,846 --> 0:01:00,566
为什么要创建自定义 Instrument

29
00:01:00,996 --> 0:01:02,576
Instruments 已经集成了很多

30
00:01:02,576 --> 0:01:03,896
非常强大的工具

31
00:01:03,896 --> 0:01:05,616
例如这里我们有系统跟踪

32
00:01:05,616 --> 0:01:06,776
你可以看到 App 

33
00:01:06,776 --> 0:01:08,046
如何与调度器

34
00:01:08,046 --> 0:01:09,456
和虚拟内存交互

35
00:01:10,736 --> 0:01:12,076
今年我们有一个新的

36
00:01:12,106 --> 0:01:13,396
游戏性能模板 它结合了

37
00:01:13,396 --> 0:01:14,596
系统跟踪和 Metal 系统跟踪

38
00:01:14,596 --> 0:01:17,496
来帮助你发现 App 中的

39
00:01:17,496 --> 0:01:19,776
故障和丢失的帧

40
00:01:20,176 --> 0:01:24,916
在 App 的网络部分

41
00:01:24,916 --> 0:01:27,166
我们也有网络连接 Instrument

42
00:01:27,166 --> 0:01:28,916
它可以显示进出 App 的

43
00:01:28,916 --> 0:01:30,476
TCP/IP 流量

44
00:01:30,476 --> 0:01:32,126
当然还有

45
00:01:32,126 --> 0:01:34,156
很多人都熟悉的时间分析器

46
00:01:34,276 --> 0:01:35,506
时间分析器可以帮助你

47
00:01:35,506 --> 0:01:37,316
查看 App 

48
00:01:37,316 --> 0:01:38,866
在何处花费时间

49
00:01:38,866 --> 0:01:40,006
无论是网络层

50
00:01:40,006 --> 0:01:41,826
游戏引擎还是其他部分

51
00:01:42,816 --> 0:01:45,756
普遍来说

52
00:01:45,756 --> 0:01:48,896
如果你了解

53
00:01:48,896 --> 0:01:50,376
你正在编辑的代码

54
00:01:50,376 --> 0:01:51,646
这些都是非常有用的

55
00:01:51,646 --> 0:01:52,466
如果你知道这些 IP 地址

56
00:01:52,466 --> 0:01:53,416
是什么意思

57
00:01:53,416 --> 0:01:54,856
知道不同的函数

58
00:01:54,856 --> 0:01:56,306
是什么意思

59
00:01:56,306 --> 0:01:58,236
以及时间分析器的调用堆栈

60
00:01:58,306 --> 0:01:59,196
它会让事情变得更简单

61
00:01:59,966 --> 0:02:01,826
然而 如果有人打算分析你的 App 

62
00:01:59,966 --> 0:02:01,826
然而 如果有人打算分析你的 App 

63
00:02:01,826 --> 0:02:02,916
但他们不熟悉其中的代码

64
00:02:02,916 --> 0:02:04,176
那该怎么办呢

65
00:02:04,176 --> 0:02:05,746
要是他们只是想知道

66
00:02:05,746 --> 0:02:07,216
App 是否在网络层上

67
00:02:07,216 --> 0:02:08,265
花费了大量的时间

68
00:02:08,316 --> 0:02:10,086
如果是 它在做什么

69
00:02:10,596 --> 0:02:12,946
自定义 Instrument 的一个

70
00:02:12,946 --> 0:02:14,566
很好的用途就是

71
00:02:14,696 --> 0:02:16,886
尝试以一种

72
00:02:16,886 --> 0:02:18,096
使原本无法理解代码的人

73
00:02:18,096 --> 0:02:19,936
能够理解和欣赏代码的方式

74
00:02:19,936 --> 0:02:21,216
讲述你的某一层或 App 

75
00:02:21,496 --> 0:02:22,983
正在做什么

76
00:02:24,856 --> 0:02:25,986
在进阶部分中

77
00:02:25,986 --> 0:02:27,516
我们将向你展示如何

78
00:02:27,516 --> 0:02:28,596
利用在 Instruments

79
00:02:28,596 --> 0:02:30,296
内部构建的

80
00:02:30,296 --> 0:02:31,846
专家系统技术

81
00:02:31,846 --> 0:02:33,766
以便你可以创建一个

82
00:02:33,846 --> 0:02:35,366
即使你不亲力亲为

83
00:02:35,366 --> 0:02:36,476
也能够查找错误模式

84
00:02:36,476 --> 0:02:38,206
并在代码中

85
00:02:38,206 --> 0:02:38,786
发现反面模式的 Instrument

86
00:02:40,376 --> 0:02:41,256
好的 让我们来看看

87
00:02:41,256 --> 0:02:43,156
使上述功能成为可能的架构

88
00:02:43,626 --> 0:02:45,226
要做到这一点

89
00:02:45,226 --> 0:02:47,996
我们必须从这里开始

90
00:02:47,996 --> 0:02:48,406
回到原始版本

91
00:02:49,196 --> 0:02:51,276
起初的 Instruments 的

92
00:02:51,276 --> 0:02:52,866
工作原理和今天的差不多

93
00:02:52,936 --> 0:02:54,156
同样有一个库

94
00:02:54,196 --> 0:02:55,546
你仍然可以拖出 Instrument

95
00:02:55,546 --> 0:02:56,816
并将它们放入跟踪文档中

96
00:02:56,816 --> 0:02:58,456
然后按下记录按钮

97
00:02:58,456 --> 0:03:00,946
多个性能工具就可以同时运行

98
00:02:58,456 --> 0:03:00,946
多个性能工具就可以同时运行

99
00:03:01,616 --> 0:03:02,966
那时和现在的 Instruments 之间的

100
00:03:02,966 --> 0:03:04,646
主要区别是

101
00:03:04,716 --> 0:03:05,516
当时的 Instruments 基础结构

102
00:03:05,516 --> 0:03:06,816
并无法帮助我们

103
00:03:06,816 --> 0:03:08,976
快速编写 Instrument

104
00:03:09,746 --> 0:03:11,606
在当时这样还好

105
00:03:11,606 --> 0:03:12,866
因为我们已经

106
00:03:12,916 --> 0:03:14,526
继承了一些我们已有的

107
00:03:14,526 --> 0:03:16,336
素材和性能工具

108
00:03:16,796 --> 0:03:17,956
它们都有自己的

109
00:03:17,956 --> 0:03:18,726
记录技术和分析逻辑

110
00:03:18,726 --> 0:03:20,436
我们所要做的就是建立一个

111
00:03:20,436 --> 0:03:22,196
自定义的存储机制

112
00:03:22,196 --> 0:03:23,266
来获取跟踪中的数据

113
00:03:23,266 --> 0:03:25,506
以及一个自定义的 UI 来帮助它

114
00:03:25,506 --> 0:03:27,786
与 App 的其他部分集成

115
00:03:27,886 --> 0:03:29,816
随着时间的推移

116
00:03:29,816 --> 0:03:31,126
Instruments 的维护成本

117
00:03:31,126 --> 0:03:32,736
和模型的维护成本都上升了

118
00:03:33,576 --> 0:03:34,626
原因就是

119
00:03:34,626 --> 0:03:36,526
每次我们想要

120
00:03:36,526 --> 0:03:37,876
添加新特性时

121
00:03:37,876 --> 0:03:39,546
我们必须修改 7 个自定义 UI

122
00:03:39,546 --> 0:03:41,846
和 7 个自定义存储机制

123
00:03:42,196 --> 0:03:43,746
但这不是我们想让你们

124
00:03:43,746 --> 0:03:44,676
学习的处理方式

125
00:03:44,676 --> 0:03:45,626
我们不想让你们

126
00:03:45,626 --> 0:03:46,756
承担这种维护成本

127
00:03:47,216 --> 0:03:48,516
所以在我们讨论

128
00:03:48,516 --> 0:03:49,646
定制 Instrument 的特性之前

129
00:03:49,646 --> 0:03:51,236
我们首先需要解决这个问题

130
00:03:51,236 --> 0:03:52,776
我认为我们做到了

131
00:03:53,586 --> 0:03:54,556
在新版本的 Instruments 中

132
00:03:54,556 --> 0:03:56,186
我们没有自定义 UI

133
00:03:56,186 --> 0:03:57,516
和自定义存储机制

134
00:03:57,516 --> 0:03:58,906
而是有两个

135
00:03:58,906 --> 0:04:00,456
标准化的组件

136
00:03:58,906 --> 0:04:00,456
标准化的组件

137
00:04:00,456 --> 0:04:02,286
它们是 “Standard UI（标准 UI）”和

138
00:04:02,286 --> 0:04:03,116
“Analysis Core（分析核心）”

139
00:04:03,616 --> 0:04:06,606
标准 UI 实现了新版 Instruments 的

140
00:04:06,606 --> 0:04:07,926
整个用户界面

141
00:04:08,666 --> 0:04:09,986
它与分析核心

142
00:04:09,986 --> 0:04:10,776
紧密相连

143
00:04:11,496 --> 0:04:12,756
而分析核心

144
00:04:12,756 --> 0:04:13,976
你可以将其视为

145
00:04:13,976 --> 0:04:16,906
数据库和专家系统的结合

146
00:04:17,305 --> 0:04:18,516
这两种都针对

147
00:04:18,516 --> 0:04:19,745
时间序列数据进行了优化

148
00:04:19,846 --> 0:04:21,966
使得它们成为构建 Instrument 的重要基础

149
00:04:22,406 --> 0:04:23,786
当你使用新型架构

150
00:04:24,226 --> 0:04:25,406
构建一个 Instrument 时

151
00:04:25,626 --> 0:04:27,456
实际上你所做的是

152
00:04:27,456 --> 0:04:29,236
创建标准 UI 

153
00:04:29,876 --> 0:04:30,876
和分析核心

154
00:04:30,876 --> 0:04:32,916
的自定义配置

155
00:04:34,126 --> 0:04:35,636
如果你看一下

156
00:04:35,636 --> 0:04:36,826
我一开始展示的那些强大的 Instrument

157
00:04:36,826 --> 0:04:38,286
的屏幕快照

158
00:04:38,286 --> 0:04:40,006
我们有系统跟踪

159
00:04:40,006 --> 0:04:42,276
游戏性能模板

160
00:04:42,276 --> 0:04:44,196
网络连接模板

161
00:04:44,196 --> 0:04:48,196
以及时间分析器

162
00:04:48,886 --> 0:04:51,416
所有这些文档中的所有 Instrument

163
00:04:51,476 --> 0:04:53,076
都是完全基于标准 UI 

164
00:04:53,076 --> 0:04:55,246
和分析核心生成的

165
00:04:55,476 --> 0:04:56,616
所以你也同样可以做

166
00:04:56,616 --> 0:04:57,586
它们能做的事情

167
00:04:58,266 --> 0:05:01,516
在 Xcode 10 和 Instruments 10 中

168
00:04:58,266 --> 0:05:01,516
在 Xcode 10 和 Instruments 10 中

169
00:05:01,516 --> 0:05:02,976
我们提供了相同的工具 来构建你的 Instrument

170
00:05:03,046 --> 0:05:05,966
Xcode 集成的 Instrument

171
00:05:06,086 --> 0:05:07,156
和你生成的 Instrument 之间的

172
00:05:07,466 --> 0:05:10,336
唯一区别就是

173
00:05:10,336 --> 0:05:12,206
谁生成了它

174
00:05:12,886 --> 0:05:16,116
你的 Instrument 会显示在我们的库中

175
00:05:16,116 --> 0:05:18,266
你可以看到顶部的活动监视器

176
00:05:19,106 --> 0:05:20,176
就像这样

177
00:05:20,176 --> 0:05:21,696
你可以将你的 Instrument 拖放到

178
00:05:21,696 --> 0:05:23,386
跟踪文档中并进行记录

179
00:05:24,136 --> 0:05:25,076
接下来

180
00:05:25,076 --> 0:05:26,036
Instruments 将用数据

181
00:05:26,036 --> 0:05:27,646
填充分析核心

182
00:05:27,646 --> 0:05:29,436
标准 UI 将创建图形

183
00:05:29,436 --> 0:05:30,886
和表格视图

184
00:05:31,846 --> 0:05:33,696
Instruments 有两种

185
00:05:33,696 --> 0:05:34,306
显示数据的方式

186
00:05:34,416 --> 0:05:35,686
在顶部有一个图形化的视图

187
00:05:35,686 --> 0:05:36,876
我们称之为轨道视图

188
00:05:36,876 --> 0:05:38,486
一个 Instrument 可以根据需要

189
00:05:38,486 --> 0:05:41,186
定义多个轨道

190
00:05:42,236 --> 0:05:43,796
如果你想

191
00:05:43,796 --> 0:05:44,776
在定义 Instrument 的图之间

192
00:05:44,776 --> 0:05:45,706
进行选择

193
00:05:45,706 --> 0:05:47,056
在 Instrument 图标上

194
00:05:47,056 --> 0:05:48,456
有一个小控件

195
00:05:48,776 --> 0:05:49,886
你可以把它

196
00:05:49,986 --> 0:05:52,106
从 “CPU” 改为 “Network（网络）”

197
00:05:53,746 --> 0:05:55,966
每个图都被允许

198
00:05:55,966 --> 0:05:57,496
定义一定数量的轨道

199
00:05:57,736 --> 0:05:58,926
这里我们定义了 3 个轨道

200
00:05:58,926 --> 0:06:00,156
并绘制了 3 种不同类型的

201
00:05:58,926 --> 0:06:00,156
并绘制了 3 种不同类型的

202
00:06:00,156 --> 0:06:01,576
CPU 利用情况

203
00:06:02,266 --> 0:06:04,436
这里的每一个轨道

204
00:06:04,436 --> 0:06:05,906
都被绑定到分析核心中的

205
00:06:05,906 --> 0:06:07,426
不同的表上

206
00:06:07,426 --> 0:06:08,796
或者它可以被绑定到同一个表上

207
00:06:08,796 --> 0:06:09,646
但是你看到的是

208
00:06:09,646 --> 0:06:11,046
这个表中的另一列

209
00:06:12,266 --> 0:06:14,566
这个 Instrument 的另一部分

210
00:06:14,566 --> 0:06:16,556
就在下方

211
00:06:16,556 --> 0:06:17,786
它同样也很重要

212
00:06:17,786 --> 0:06:18,736
它叫做细节视图

213
00:06:18,896 --> 0:06:20,216
在这里你可以看到

214
00:06:20,216 --> 0:06:22,536
事件列表

215
00:06:22,816 --> 0:06:24,066
以及数据的任何类型的

216
00:06:24,066 --> 0:06:26,086
聚合和总结

217
00:06:26,986 --> 0:06:29,306
就像这些轨道

218
00:06:29,306 --> 0:06:31,146
抱歉 就像这些图一样

219
00:06:31,146 --> 0:06:32,836
你可以为你的 Instrument

220
00:06:32,836 --> 0:06:34,176
定义一些细节

221
00:06:34,176 --> 0:06:36,416
你也可以通过点按跳转栏的这个部分

222
00:06:36,416 --> 0:06:37,976
然后选择你定义的细节标题

223
00:06:37,976 --> 0:06:39,586
来选择哪个细节是活跃的

224
00:06:40,966 --> 0:06:42,616
就像图形视图中的轨道一样

225
00:06:42,616 --> 0:06:44,786
所有的细节都被

226
00:06:44,786 --> 0:06:46,656
绑定到分析核心的一个表上

227
00:06:46,656 --> 0:06:48,016
这就是它们

228
00:06:48,016 --> 0:06:48,786
接收数据的地方

229
00:06:49,166 --> 0:06:50,006
记录开始

230
00:06:50,006 --> 0:06:50,966
表格被填入

231
00:06:51,236 --> 0:06:52,626
UI 就会做出反应

232
00:06:52,626 --> 0:06:55,366
不需要你执行任何特殊代码

233
00:06:56,156 --> 0:06:58,836
从标准 UI 的角度来看

234
00:06:58,836 --> 0:07:00,036
分析核心中的所有内容

235
00:06:58,836 --> 0:07:00,036
分析核心中的所有内容

236
00:07:00,036 --> 0:07:02,096
似乎都是一个表格

237
00:07:02,096 --> 0:07:03,986
我们来谈谈表格

238
00:07:05,196 --> 0:07:06,916
表格是行的集合

239
00:07:06,916 --> 0:07:07,886
它们有一个

240
00:07:07,886 --> 0:07:09,516
由表格 Schema 定义的结构

241
00:07:09,666 --> 0:07:11,656
所以它和数据库 App 非常相似

242
00:07:12,536 --> 0:07:14,106
这个 Schema 定义了

243
00:07:14,106 --> 0:07:15,396
列 列的名称

244
00:07:15,396 --> 0:07:16,236
以及列的类型

245
00:07:16,746 --> 0:07:18,246
分析核心使用了一个

246
00:07:18,246 --> 0:07:19,606
非常丰富的类型系统

247
00:07:19,606 --> 0:07:21,296
叫做工程类型

248
00:07:21,296 --> 0:07:22,446
它告诉我们如何存储数据

249
00:07:22,446 --> 0:07:24,216
以及如何在标准 UI 中

250
00:07:24,216 --> 0:07:25,806
可视化和分析数据

251
00:07:27,556 --> 0:07:29,886
除此之外

252
00:07:29,886 --> 0:07:31,426
当 Schema 描述

253
00:07:31,546 --> 0:07:33,246
表的结构时

254
00:07:33,246 --> 0:07:34,516
你还可以使用 Key/value 这对属性

255
00:07:34,516 --> 0:07:36,146
来描述内容

256
00:07:36,616 --> 0:07:38,986
这能帮助我们描述表中的内容

257
00:07:39,566 --> 0:07:42,216
你可以将 Schema

258
00:07:42,216 --> 0:07:44,606
视为 Objective-C 或 Swift 中的一个类

259
00:07:44,606 --> 0:07:46,246
而行则类似于实例

260
00:07:46,586 --> 0:07:47,886
就像 Objective-C 中的

261
00:07:48,006 --> 0:07:50,236
类名是单数的一样

262
00:07:50,236 --> 0:07:51,296
你的 Schema 的名称

263
00:07:51,296 --> 0:07:53,516
也必须是单数的

264
00:07:53,516 --> 0:07:55,416
比如 NSString

265
00:07:55,416 --> 0:07:56,056
而不是 NSStrings

266
00:07:56,246 --> 0:07:58,136
当我们讲到进阶部分的时候

267
00:07:58,136 --> 0:07:58,906
这一点会更为重要

268
00:07:58,906 --> 0:07:59,876
但是我现在想把它强调一下

269
00:07:59,876 --> 0:08:01,496
到时我们就能知道

270
00:07:59,876 --> 0:08:01,496
到时我们就能知道

271
00:08:01,496 --> 0:08:03,026
我们在讨论什么了

272
00:08:03,026 --> 0:08:05,596
Schema 的一个例子是 Tick

273
00:08:06,136 --> 0:08:07,106
它是 Instruments

274
00:08:07,106 --> 0:08:08,926
内部的一种 Schema

275
00:08:08,926 --> 0:08:10,286
用于创建

276
00:08:10,286 --> 0:08:11,666
合成时钟节拍表

277
00:08:11,666 --> 0:08:13,676
稍后我们将在建模器中

278
00:08:13,676 --> 0:08:15,146
使用它进行统计计算

279
00:08:15,916 --> 0:08:17,076
Tick Schema 很简单

280
00:08:17,076 --> 0:08:18,456
它只有一个列要被定义

281
00:08:18,456 --> 0:08:19,956
那就是 time

282
00:08:19,956 --> 0:08:20,626
time 使用的工程类型是

283
00:08:20,626 --> 0:08:21,356
sample-time

284
00:08:22,196 --> 0:08:24,046
Tick Schema 还定义了

285
00:08:24,276 --> 0:08:26,796
一个可以附加到表格实例中的可选属性

286
00:08:26,796 --> 0:08:27,346
它叫做 frequency

287
00:08:27,856 --> 0:08:30,066
如果你为 Tick Schema

288
00:08:30,066 --> 0:08:32,096
创建一个

289
00:08:32,096 --> 0:08:34,456
频率为 10 的表格

290
00:08:34,775 --> 0:08:36,576
那么数据的提供者

291
00:08:36,576 --> 0:08:38,046
就会知道它需要

292
00:08:38,346 --> 0:08:40,806
每秒填充 10 个时间戳

293
00:08:40,806 --> 0:08:41,826
这样你就可以表达

294
00:08:41,826 --> 0:08:43,176
你想要填入表的内容

295
00:08:44,586 --> 0:08:45,916
现在 我认为

296
00:08:46,356 --> 0:08:47,766
我们有足够的信息

297
00:08:47,766 --> 0:08:48,366
来开始入门部分

298
00:08:48,856 --> 0:08:50,076
我们将展示

299
00:08:50,076 --> 0:08:52,256
如何在 Xcode 中

300
00:08:52,296 --> 0:08:54,046
创建你自己的 Instruments 包项目

301
00:08:54,046 --> 0:08:55,876
还将向你展示 如何创建你的第一个 Instrument

302
00:08:55,876 --> 0:08:57,316
来绘制这些 Tick

303
00:08:57,406 --> 0:08:59,886
并在细节视图中 显示这些 Tick

304
00:09:00,376 --> 0:09:01,916
为此我想请

305
00:09:01,916 --> 0:09:04,016
我的同事 Kacper

306
00:09:04,016 --> 0:09:04,976
给大家做一个展示

307
00:09:05,516 --> 0:09:07,966
[ 掌声 ]

308
00:09:08,466 --> 0:09:09,276
&gt;&gt; 谢谢大家

309
00:09:10,046 --> 0:09:12,136
现在我将向你们展示

310
00:09:12,136 --> 0:09:13,986
如何开始创建和运行

311
00:09:13,986 --> 0:09:15,306
你们的第一个自定义 Instrument 

312
00:09:16,346 --> 0:09:17,356
你们将会使用

313
00:09:17,356 --> 0:09:19,426
由 Chad 之前展示的 Tick Schema 

314
00:09:19,426 --> 0:09:21,096
并在频率恒定的节拍中

315
00:09:21,386 --> 0:09:22,556
制作一个 Instrument

316
00:09:23,256 --> 0:09:25,426
你们将会学到如何描述你们的包

317
00:09:25,426 --> 0:09:27,556
如何使用 Xcode 对其进行迭代

318
00:09:27,596 --> 0:09:30,116
以及如何在 Instruments 中进行测试

319
00:09:31,156 --> 0:09:31,866
让我们开始吧

320
00:09:33,266 --> 0:09:34,636
和在 Xcode 中

321
00:09:34,636 --> 0:09:36,596
以前的操作一样

322
00:09:36,596 --> 0:09:37,976
创建新的 Instruments 包项目

323
00:09:38,696 --> 0:09:40,216
你需要点击 “New Xcode Project”

324
00:09:40,996 --> 0:09:42,776
选择 “macOS” 作为平台

325
00:09:42,776 --> 0:09:43,706
并点击 “Instruments Package”

326
00:09:45,366 --> 0:09:46,146
你需要填写文件名称

327
00:09:46,146 --> 0:09:49,566
这将成为这个 Instrument 包的默认名称

328
00:09:50,026 --> 0:09:51,016
我们就命名为 “Ticks” 吧

329
00:09:51,626 --> 0:09:54,966
点击 “Next（下一步）”和“Create（创建）”

330
00:09:59,536 --> 0:10:01,626
Xcode 已经创建了

331
00:09:59,536 --> 0:10:01,626
Xcode 已经创建了

332
00:10:01,776 --> 0:10:03,656
带有包 Target 的项目和一个文件

333
00:10:04,406 --> 0:10:05,706
里面有对包的定义

334
00:10:06,246 --> 0:10:09,286
让我们来看看

335
00:10:10,176 --> 0:10:13,406
包是基于 XML 语法描述的

336
00:10:13,816 --> 0:10:15,626
首先 每个包最前面有

337
00:10:15,626 --> 0:10:18,846
标识符 标题和所有者

338
00:10:19,406 --> 0:10:21,146
当有人试图安装你的包时

339
00:10:21,146 --> 0:10:23,076
这些栏将是可见的

340
00:10:24,876 --> 0:10:26,466
通常 你可以从

341
00:10:26,466 --> 0:10:29,736
定义自己的 Schema

342
00:10:29,736 --> 0:10:31,546
和可选的建模器开始

343
00:10:31,756 --> 0:10:32,776
但是因为这里我们将使用

344
00:10:32,816 --> 0:10:34,776
预定义的 Tick Schema 

345
00:10:34,776 --> 0:10:36,576
我们将删除这些指示

346
00:10:38,876 --> 0:10:41,416
要从基础包中导入 Tick Schema 

347
00:10:41,416 --> 0:10:43,176
你只需指定

348
00:10:43,206 --> 0:10:44,926
import-schema 元素

349
00:10:45,586 --> 0:10:48,976
和 Schema 的名称 “tick”

350
00:10:53,696 --> 0:10:56,156
现在它可以被我们的 Instrument 使用了

351
00:10:58,516 --> 0:11:00,636
为了让你们更容易地定义

352
00:10:58,516 --> 0:11:00,636
为了让你们更容易地定义

353
00:11:00,636 --> 0:11:02,736
更复杂的元素

354
00:11:02,736 --> 0:11:04,466
我们在 Xcode 中配置了一些代码片段

355
00:11:05,296 --> 0:11:07,206
要使用它们

356
00:11:07,206 --> 0:11:09,146
只需写入元素名称

357
00:11:09,146 --> 0:11:11,436
比如 “instrument” 然后按回车

358
00:11:11,436 --> 0:11:14,256
你需要填写

359
00:11:14,256 --> 0:11:15,976
你的 Instrument 的唯一标识符

360
00:11:20,706 --> 0:11:22,946
以及稍后出现在

361
00:11:22,946 --> 0:11:23,976
Instrument 库中的一些属性

362
00:11:29,626 --> 0:11:31,216
这里是 “Instrument drawing

363
00:11:31,326 --> 0:11:34,946
ticks every 10ms”

364
00:11:39,306 --> 0:11:41,186
现在是创建表格的时候了

365
00:11:41,186 --> 0:11:42,696
当这个 Instrument 从库中

366
00:11:42,696 --> 0:11:44,416
被拖到跟踪文档时

367
00:11:44,546 --> 0:11:46,456
这个表格将被实例化

368
00:11:47,956 --> 0:11:49,346
在这个 Instrument 的定义中

369
00:11:49,346 --> 0:11:51,536
表格标识符必须是唯一的

370
00:11:52,446 --> 0:11:56,116
我们叫它 “tick-table”

371
00:11:56,226 --> 0:11:57,786
在 <schema-ref> 中

372
00:11:57,786 --> 0:11:58,966
我们需要引用以前

373
00:11:58,966 --> 0:12:03,816
导入的 Schema“tick”

374
00:11:58,966 --> 0:12:03,816
导入的 Schema“tick”

375
00:12:04,516 --> 0:12:05,986
现在我们需要定义

376
00:12:05,986 --> 0:12:08,126
在轨道视图和细节视图中

377
00:12:08,126 --> 0:12:09,556
会出现的内容

378
00:12:10,276 --> 0:12:11,966
我将使用 graph 元素

379
00:12:12,696 --> 0:12:15,886
我们需要为我们的图形

380
00:12:15,886 --> 0:12:16,596
填写 title

381
00:12:16,596 --> 0:12:19,166
我会命名为 “Ticks”

382
00:12:19,486 --> 0:12:21,296
轨道的标题也一样

383
00:12:21,916 --> 0:12:25,816
我需要按照前面创建的

384
00:12:25,816 --> 0:12:30,276
标识符来引用表格

385
00:12:30,276 --> 0:12:31,256
因此我将引用 “tick-table”

386
00:12:34,346 --> 0:12:36,376
现在我们要为我们的图

387
00:12:36,376 --> 0:12:37,186
指定绘制

388
00:12:38,186 --> 0:12:39,646
我会使用 plot 元素

389
00:12:40,556 --> 0:12:42,926
在最基本的形式中

390
00:12:42,926 --> 0:12:44,226
它只需要你传递

391
00:12:44,226 --> 0:12:45,446
包含要绘制的值的

392
00:12:45,496 --> 0:12:46,686
列的助记符

393
00:12:46,686 --> 0:12:48,876
我们将绘制 “time”

394
00:12:52,696 --> 0:12:53,956
我希望所有的时间戳

395
00:12:53,956 --> 0:12:57,156
都能在表格中显示出来

396
00:12:57,826 --> 0:12:59,976
为此 我将使用 list 元素

397
00:13:02,496 --> 0:13:04,916
我们需要为一个

398
00:13:04,916 --> 0:13:06,236
将会出现在 Instrument 中的列表

399
00:13:06,366 --> 0:13:11,516
填写 title 元素

400
00:13:11,516 --> 0:13:12,816
“table-ref” 就像之前的 lane 元素一样

401
00:13:12,816 --> 0:13:15,906
以及我们想要看到的 column

402
00:13:20,566 --> 0:13:22,556
现在我们的包已经准备好

403
00:13:22,556 --> 0:13:24,886
在 Instruments 中构建并运行了

404
00:13:25,946 --> 0:13:27,656
为此 你需要使用

405
00:13:27,656 --> 0:13:28,716
“Xcode Scheme Run” 操作

406
00:13:29,676 --> 0:13:34,936
我们就这样做吧

407
00:13:34,936 --> 0:13:35,336
你可以看到出现了构建错误

408
00:13:35,906 --> 0:13:37,696
在生成 Instruments 包时

409
00:13:37,696 --> 0:13:38,916
你拥有完整的 IDE 支持

410
00:13:39,336 --> 0:13:41,526
这里 出现了一行错误

411
00:13:41,526 --> 0:13:43,426
告诉我们在 Tick Schema 中

412
00:13:43,426 --> 0:13:45,386
找不到 “timestamp” 这一列

413
00:13:45,706 --> 0:13:46,816
没错 

414
00:13:46,816 --> 0:13:47,536
因为它不是 “timestamp”

415
00:13:47,536 --> 0:13:48,616
而应该是 “time”

416
00:13:48,836 --> 0:13:52,676
我将修复这个问题并再次运行它

417
00:13:53,296 --> 0:13:58,256
你可以看到它在运行

418
00:13:58,256 --> 0:13:59,796
因为这个新的 Instrument 副本出现了

419
00:13:59,796 --> 0:14:02,226
你可以通过不同的图标

420
00:13:59,796 --> 0:14:02,226
你可以通过不同的图标

421
00:14:02,226 --> 0:14:03,786
识别特殊的副本

422
00:14:04,816 --> 0:14:06,656
它仅为这个运行会话

423
00:14:06,976 --> 0:14:08,226
加载你的包

424
00:14:08,796 --> 0:14:10,516
它允许你更容易地

425
00:14:10,516 --> 0:14:11,446
对包进行迭代

426
00:14:12,066 --> 0:14:15,666
为了确保你的包已经加载

427
00:14:15,666 --> 0:14:17,356
我们可以在

428
00:14:17,356 --> 0:14:19,686
新建包管理的 UI 中检查它

429
00:14:20,396 --> 0:14:22,386
你可以在 “Instruments”-

430
00:14:22,556 --> 0:14:24,536
“Preferences（偏好设置）”

431
00:14:24,536 --> 0:14:25,176
-“Packages（包）”标签页中找到它

432
00:14:25,176 --> 0:14:29,556
你可以在这里看到

433
00:14:29,556 --> 0:14:31,746
我们新创建的包以及调试的下标

434
00:14:31,886 --> 0:14:33,466
这意味着它已经被

435
00:14:33,466 --> 0:14:35,736
临时加载

436
00:14:35,736 --> 0:14:37,296
你也可以在这里看到

437
00:14:37,296 --> 0:14:37,996
所有的系统包

438
00:14:38,396 --> 0:14:39,916
你可以通过使用副标题

439
00:14:40,096 --> 0:14:41,866
使用并链接它们

440
00:14:41,866 --> 0:14:46,576
在这里 我们的 Ticks 包里包含了

441
00:14:46,576 --> 0:14:52,776
Ticks Instrument 现在让我们用空白模板测试它

442
00:14:53,396 --> 0:14:55,966
我将把 Target 切换到我的 MacBook

443
00:15:00,456 --> 0:15:01,586
然后在 Instruments 库中

444
00:15:01,586 --> 0:15:03,386
搜索我的 Instrument

445
00:15:03,546 --> 0:15:08,106
我将填入 “Ticks”

446
00:15:08,606 --> 0:15:10,586
然后它将显示在这里

447
00:15:10,586 --> 0:15:12,226
包含从包定义中

448
00:15:12,226 --> 0:15:13,156
填充的所有属性

449
00:15:13,726 --> 0:15:15,976
让我们将它拖放到跟踪中

450
00:15:19,576 --> 0:15:20,976
并记录一秒钟

451
00:15:25,476 --> 0:15:28,486
你可以看到底部的面板

452
00:15:28,486 --> 0:15:30,506
是以每 10 毫秒生成的数据

453
00:15:30,506 --> 0:15:31,676
进行传递的

454
00:15:33,306 --> 0:15:35,896
细节和图形是相互协调的

455
00:15:36,366 --> 0:15:37,826
当我点击行时

456
00:15:37,826 --> 0:15:39,766
你可以看到检查线在这里移动

457
00:15:40,796 --> 0:15:42,706
我还可以通过 Option 点按并拖动

458
00:15:43,096 --> 0:15:48,806
来而放大一个图

459
00:15:48,806 --> 0:15:50,316
在这里 你可以看到

460
00:15:50,316 --> 0:15:51,656
Ticks 确实被画出来了

461
00:15:53,656 --> 0:15:55,736
这样你就可以创建

462
00:15:55,936 --> 0:15:56,886
第一个 Instrument 包

463
00:15:57,306 --> 0:15:59,446
现在让我们请回 Chad

464
00:15:59,446 --> 0:16:00,716
他会告诉你更多 关于标准 UI 的内容

465
00:15:59,446 --> 0:16:00,716
他会告诉你更多 关于标准 UI 的内容

466
00:16:01,516 --> 0:16:04,466
[ 掌声 ]

467
00:16:04,966 --> 0:16:05,226
&gt;&gt; 好的

468
00:16:05,226 --> 0:16:05,986
谢谢 Kacper

469
00:16:06,786 --> 0:16:07,906
我们已经知道了

470
00:16:07,906 --> 0:16:09,326
如何创建一个非常基本的 Instrument

471
00:16:09,326 --> 0:16:11,136
也了解了如何开始

472
00:16:11,326 --> 0:16:12,946
在 Xcode 中创建你的第一个项目

473
00:16:13,706 --> 0:16:15,126
现在让我们来谈谈

474
00:16:15,126 --> 0:16:17,416
我们拥有的不同类型的图

475
00:16:17,416 --> 0:16:18,846
不同类型的细节

476
00:16:18,846 --> 0:16:20,716
以及如何利用真实数据进行操作

477
00:16:21,656 --> 0:16:23,686
让我们从图形轨道开始

478
00:16:24,896 --> 0:16:27,206
你已经看到了 Kacper

479
00:16:27,206 --> 0:16:28,626
是如何使用我们称之为 plot 的元素

480
00:16:28,966 --> 0:16:30,636
来定义一个图形和轨道的

481
00:16:31,066 --> 0:16:34,256
plot 元素可以

482
00:16:34,366 --> 0:16:36,566
指示标准 UI 

483
00:16:36,566 --> 0:16:38,016
获取表的全部内容

484
00:16:38,016 --> 0:16:39,816
并尝试在特定的

485
00:16:39,816 --> 0:16:41,586
轨道中绘制它

486
00:16:42,276 --> 0:16:44,406
plot 元素

487
00:16:44,436 --> 0:16:46,536
通过查看

488
00:16:46,536 --> 0:16:49,406
Schema 和获取值的目标列

489
00:16:49,406 --> 0:16:52,446
来决定如何绘制这个内容

490
00:16:52,446 --> 0:16:53,306
以及如何处理图形

491
00:16:54,026 --> 0:16:55,586
如果是一个区间 Schema

492
00:16:55,586 --> 0:16:56,856
这意味着它有一个时间点

493
00:16:56,856 --> 0:16:58,286
和一个持续时间

494
00:16:58,286 --> 0:16:59,636
如果是一个点 Schema

495
00:16:59,636 --> 0:17:01,046
这意味着它只是一个时间戳

496
00:16:59,636 --> 0:17:01,046
这意味着它只是一个时间戳

497
00:17:01,046 --> 0:17:01,816
我们需要用不同的方式处理

498
00:17:02,586 --> 0:17:04,705
如果目标列有一个长度

499
00:17:04,705 --> 0:17:06,945
这意味着可以

500
00:17:06,945 --> 0:17:08,296
通过它画一个条形图

501
00:17:08,296 --> 0:17:10,396
就像这样

502
00:17:11,126 --> 0:17:13,136
另一种选择是

503
00:17:13,136 --> 0:17:15,476
生命周期轨道

504
00:17:15,476 --> 0:17:16,935
它仍然是一个区间 Schema

505
00:17:16,935 --> 0:17:18,756
但是我们针对的是

506
00:17:18,756 --> 0:17:20,366
一个状态列

507
00:17:20,366 --> 0:17:21,955
而状态本身并没有长度

508
00:17:22,185 --> 0:17:23,126
所以在这里画条形图

509
00:17:23,126 --> 0:17:23,896
是没有意义的

510
00:17:24,516 --> 0:17:25,476
标准 UI 会自动选择

511
00:17:25,476 --> 0:17:27,006
状态风格的处理方法

512
00:17:27,006 --> 0:17:28,976
包括用圆角矩形样式的标签

513
00:17:28,976 --> 0:17:31,626
绘制这些区间

514
00:17:31,626 --> 0:17:33,096
这样你就可以

515
00:17:33,096 --> 0:17:35,656
把它与平面条形图区分开来

516
00:17:36,356 --> 0:17:37,296
标准 UI 能够为你选择

517
00:17:37,296 --> 0:17:38,336
这些处理的功能

518
00:17:38,336 --> 0:17:39,796
是非常重要的

519
00:17:39,796 --> 0:17:42,086
因为这可以保持 Instruments UI 的一致性

520
00:17:42,376 --> 0:17:43,616
如果你定义一个状态图的同时

521
00:17:43,616 --> 0:17:45,356
我们也定义一个状态图

522
00:17:45,356 --> 0:17:46,896
标准 UI 就会强制它们

523
00:17:46,896 --> 0:17:48,046
看起来一样

524
00:17:48,296 --> 0:17:49,686
这样 Instruments 用户就可以

525
00:17:49,686 --> 0:17:51,526
更容易在 Instrument 之间

526
00:17:51,526 --> 0:17:54,496
进行切换

527
00:17:54,496 --> 0:17:58,236
如果你想 基于数据的内容

528
00:17:58,236 --> 0:18:01,866
动态地创建图形或轨道数目

529
00:17:58,236 --> 0:18:01,866
动态地创建图形或轨道数目

530
00:18:01,986 --> 0:18:02,326
你可以定义所谓的 “Plot Template”

531
00:18:02,996 --> 0:18:04,666
Plot 模板的定义

532
00:18:04,666 --> 0:18:06,316
与 Plot 非常类似

533
00:18:06,316 --> 0:18:07,406
除了其中有一个额外的元素

534
00:18:07,406 --> 0:18:08,936
允许你选择

535
00:18:08,936 --> 0:18:10,536
表中的一列

536
00:18:10,536 --> 0:18:12,276
它将为该列中的每个唯一值

537
00:18:12,276 --> 0:18:13,956
创建单独的行

538
00:18:16,016 --> 0:18:17,046
如果你正在寻找

539
00:18:17,046 --> 0:18:18,456
活动的峰值或周期

540
00:18:18,576 --> 0:18:19,126
我们有所谓的直方图

541
00:18:19,126 --> 0:18:21,016
你所要做的就是

542
00:18:21,016 --> 0:18:22,846
在不同的点

543
00:18:22,846 --> 0:18:24,066
或区间相交时

544
00:18:24,066 --> 0:18:25,566
打破超过某个特定大小的

545
00:18:25,566 --> 0:18:27,176
存储器中的时间轴

546
00:18:27,176 --> 0:18:29,996
假设 100 毫秒

547
00:18:29,996 --> 0:18:31,186
然后使用像 count() sum()

548
00:18:31,416 --> 0:18:32,976
min() 或 max() 这样的函数

549
00:18:32,976 --> 0:18:33,946
来提升这些存储器的大小

550
00:18:33,946 --> 0:18:36,066
这是一种寻找活动峰值的好方法

551
00:18:36,536 --> 0:18:38,136
例如 在系统跟踪中

552
00:18:38,136 --> 0:18:39,046
我们在环境切换

553
00:18:39,046 --> 0:18:40,216
或虚拟内存中

554
00:18:40,216 --> 0:18:42,086
寻找活动峰值

555
00:18:42,486 --> 0:18:45,126
现在我们来谈谈细节

556
00:18:45,156 --> 0:18:47,396
细节在这个 UI 的下半部分

557
00:18:48,486 --> 0:18:49,376
你们已经看过了第一个

558
00:18:49,376 --> 0:18:50,626
也就是列表

559
00:18:50,846 --> 0:18:52,266
它是表格 分析核心

560
00:18:52,266 --> 0:18:53,666
以及 UI 中表视图之间的

561
00:18:53,666 --> 0:18:56,896
非常简单的映射

562
00:18:56,896 --> 0:19:00,066
还有 “Aggregation（聚合）”

563
00:18:56,896 --> 0:19:00,066
还有 “Aggregation（聚合）”

564
00:19:00,176 --> 0:19:01,976
当你想要

565
00:19:01,976 --> 0:19:03,186
去除时间分量

566
00:19:03,186 --> 0:19:04,586
概览你的数据

567
00:19:04,586 --> 0:19:06,726
而且想要在表格中应用一些

568
00:19:06,726 --> 0:19:07,956
统计数据的时候

569
00:19:07,956 --> 0:19:08,556
聚合是很适合的选择

570
00:19:09,376 --> 0:19:10,406
当我们定义一个聚合

571
00:19:10,406 --> 0:19:12,316
我们需要注意

572
00:19:12,316 --> 0:19:14,596
列现在是函数

573
00:19:14,896 --> 0:19:15,956
你可以使用

574
00:19:16,026 --> 0:19:19,186
sum() average() count()

575
00:19:19,186 --> 0:19:20,436
以及其他的一些统计函数

576
00:19:20,726 --> 0:19:24,396
来帮助你创建

577
00:19:24,396 --> 0:19:26,256
你想要创建的聚合视图

578
00:19:28,146 --> 0:19:30,776
聚合的好处在于 你也可以定义

579
00:19:30,776 --> 0:19:32,096
一个层级结构

580
00:19:32,266 --> 0:19:33,846
这里我们在

581
00:19:33,926 --> 0:19:35,296
虚拟内存操作结构中

582
00:19:35,296 --> 0:19:37,316
定义了一个进程线程

583
00:19:37,316 --> 0:19:38,976
我们可以看到它被分解为

584
00:19:38,976 --> 0:19:40,626
进程 然后是

585
00:19:40,626 --> 0:19:41,766
进程中的每个线程

586
00:19:42,086 --> 0:19:43,286
然后是这个线程中的

587
00:19:43,286 --> 0:19:45,156
这个进程中的

588
00:19:45,246 --> 0:19:46,036
每个类型的操作

589
00:19:46,206 --> 0:19:47,556
所以聚合是一种很好

590
00:19:47,626 --> 0:19:49,156
很强大的方式

591
00:19:49,156 --> 0:19:50,386
来总结很多数据

592
00:19:51,476 --> 0:19:53,396
另一种类型的聚合

593
00:19:53,396 --> 0:19:54,476
称为 “Call Tree（调用树）”

594
00:19:55,496 --> 0:19:56,696
当你有一个列是回溯

595
00:19:56,696 --> 0:19:57,876
而且另一个列是

596
00:19:57,876 --> 0:19:59,466
权重的时候

597
00:19:59,466 --> 0:20:00,246
调用树就会很有用处

598
00:19:59,466 --> 0:20:00,246
调用树就会很有用处

599
00:20:00,476 --> 0:20:01,316
你可以使用调用树

600
00:20:01,316 --> 0:20:02,556
创建加权回溯

601
00:20:02,556 --> 0:20:04,546
或加权调用的树视图

602
00:20:04,616 --> 0:20:05,976
就像在时间分析器中看到的那样

603
00:20:07,136 --> 0:20:09,896
另一种样式叫做 “Narrative（叙事）”

604
00:20:10,096 --> 0:20:12,426
当你想要传达

605
00:20:12,426 --> 0:20:15,506
只有技术语言的信息

606
00:20:15,506 --> 0:20:17,046
比如专家系统的输出

607
00:20:17,046 --> 0:20:18,526
以及和叙事工程类型

608
00:20:18,526 --> 0:20:19,696
紧密相连的信息时

609
00:20:19,696 --> 0:20:21,346
叙事是常用的选择

610
00:20:23,856 --> 0:20:25,776
最后一种细节类型

611
00:20:25,866 --> 0:20:26,956
叫做 “Time Slice（时间片）”

612
00:20:27,086 --> 0:20:28,346
时间片看起来

613
00:20:28,346 --> 0:20:30,176
很像一个列表

614
00:20:30,176 --> 0:20:31,866
但是其中的内容被过滤

615
00:20:31,866 --> 0:20:33,506
只包含与图形中蓝色线

616
00:20:33,506 --> 0:20:35,086
相交的区间

617
00:20:35,236 --> 0:20:36,366
这条蓝色线叫做检查线

618
00:20:36,746 --> 0:20:37,866
当你把检查线

619
00:20:37,866 --> 0:20:39,436
移到图形上时

620
00:20:39,656 --> 0:20:40,756
列表的内容将被过滤

621
00:20:40,756 --> 0:20:42,586
从而与检查线

622
00:20:42,586 --> 0:20:44,226
相交的部分匹配

623
00:20:46,776 --> 0:20:49,156
所有这些 UI 都与

624
00:20:49,156 --> 0:20:50,896
分析核心中的表格绑定

625
00:20:51,306 --> 0:20:53,146
当你开始记录时

626
00:20:53,146 --> 0:20:55,586
数据进入 Instruments App

627
00:20:55,586 --> 0:20:57,176
并填入分析核心中

628
00:20:57,936 --> 0:20:59,396
让我们详细谈谈

629
00:20:59,396 --> 0:21:00,976
这个过程是如何进行的

630
00:20:59,396 --> 0:21:00,976
这个过程是如何进行的

631
00:21:02,786 --> 0:21:06,996
在开始记录之前的第一步

632
00:21:06,996 --> 0:21:08,416
分析核心将提取

633
00:21:08,416 --> 0:21:09,796
在其中创建的表格

634
00:21:09,796 --> 0:21:11,006
它将映射表格

635
00:21:11,006 --> 0:21:12,916
并在核心中为表分配存储

636
00:21:13,756 --> 0:21:15,236
如果一个表有

637
00:21:15,236 --> 0:21:16,516
相同的 Schema 和相同的属性

638
00:21:16,516 --> 0:21:17,796
那么根据定义

639
00:21:17,796 --> 0:21:19,686
它就是相同的数据

640
00:21:19,686 --> 0:21:21,696
所以它会被映射到相同的存储中

641
00:21:23,116 --> 0:21:24,956
对于每个存储

642
00:21:24,956 --> 0:21:26,406
第二步就是尝试为数据

643
00:21:26,406 --> 0:21:27,386
找到一个提供者

644
00:21:27,776 --> 0:21:29,056
有时 我们可以从

645
00:21:29,056 --> 0:21:30,196
从 Target 中通过数据流

646
00:21:30,196 --> 0:21:32,196
直接记录数据

647
00:21:32,196 --> 0:21:33,346
有时 我们则必须使用

648
00:21:33,486 --> 0:21:34,246
建模器来合成数据

649
00:21:35,296 --> 0:21:36,876
建模器可以请求自己的输入

650
00:21:36,876 --> 0:21:38,556
这些输入可以

651
00:21:38,556 --> 0:21:40,356
是其他建模器的输出

652
00:21:40,396 --> 0:21:42,926
或者直接从数据流中记录

653
00:21:42,926 --> 0:21:44,186
我们就是这样合成

654
00:21:44,186 --> 0:21:45,476
我们本来不知道如何直接记录的

655
00:21:45,476 --> 0:21:46,366
其余数据的

656
00:21:47,476 --> 0:21:49,516
现在我们已经得到了

657
00:21:49,516 --> 0:21:51,546
分析核心中

658
00:21:51,686 --> 0:21:53,786
所有存储的数据源

659
00:21:53,786 --> 0:21:54,866
也就是所谓的绑定方案

660
00:21:55,026 --> 0:21:57,356
第三步是优化绑定方案 

661
00:21:57,546 --> 0:21:59,966
在这里 你可以看到 Instruments 将自己的

662
00:21:59,966 --> 0:22:01,546
绑定方案可视化

663
00:21:59,966 --> 0:22:01,546
绑定方案可视化

664
00:22:01,546 --> 0:22:02,216
我们称之为线程叙事

665
00:22:03,706 --> 0:22:04,736
关于绑定方案的

666
00:22:04,736 --> 0:22:06,886
下一部分是

667
00:22:06,886 --> 0:22:09,056
它是 “Trace-wide（广跟踪）”的

668
00:22:09,056 --> 0:22:11,196
当你将 Instrument 拖放到跟踪中时

669
00:22:11,386 --> 0:22:13,906
Instruments 将计算

670
00:22:13,906 --> 0:22:15,956
尽可能最好的记录方案

671
00:22:16,166 --> 0:22:17,616
以尽量减少

672
00:22:17,616 --> 0:22:20,336
对 Target 的记录影响

673
00:22:20,886 --> 0:22:21,786
当你创建自己的表格

674
00:22:21,786 --> 0:22:23,256
或表实例时

675
00:22:23,256 --> 0:22:24,616
你必须给它们一个 Schema

676
00:22:25,256 --> 0:22:26,706
Instruments 已经定义了

677
00:22:26,766 --> 0:22:28,786
超过 100 种 Schema

678
00:22:29,536 --> 0:22:30,896
所有这些 Schema

679
00:22:30,896 --> 0:22:31,956
都可以使用

680
00:22:31,956 --> 0:22:33,896
并存在于在包管理的 UI 中

681
00:22:33,896 --> 0:22:34,506
所看到的包里面

682
00:22:35,236 --> 0:22:36,376
你只需将 Schema 导入到

683
00:22:36,376 --> 0:22:38,466
自己的包中

684
00:22:39,036 --> 0:22:41,216
如果该 Schema 包含在

685
00:22:41,216 --> 0:22:42,516
一个不是基础包的包中

686
00:22:42,516 --> 0:22:44,246
你需要在 Xcode 中的

687
00:22:44,246 --> 0:22:45,756
构建设置里面

688
00:22:45,756 --> 0:22:47,086
将包设置为

689
00:22:47,086 --> 0:22:49,046
“Linked Instruments Packages”

690
00:22:49,046 --> 0:22:50,116
这样我们就可以在生成时

691
00:22:50,116 --> 0:22:51,526
找到你涉及的额外的包

692
00:22:51,526 --> 0:22:53,096
并做一些类型检查

693
00:22:54,716 --> 0:22:56,276
因为所有这些 Schema

694
00:22:56,276 --> 0:22:57,586
都是在其他包中定义的

695
00:22:57,676 --> 0:22:59,346
当你开始记录时

696
00:22:59,386 --> 0:23:00,456
所有具有这些 Schema 的表格

697
00:22:59,386 --> 0:23:00,456
所有具有这些 Schema 的表格

698
00:23:00,456 --> 0:23:02,736
都会被填充

699
00:23:02,736 --> 0:23:04,026
因为要么它们定义了建模器

700
00:23:04,026 --> 0:23:04,866
要么我们知道如何

701
00:23:04,866 --> 0:23:05,176
从数据流中记录它们

702
00:23:05,176 --> 0:23:06,426
这些都是你的 Instrument 的

703
00:23:06,426 --> 0:23:07,766
出色的构件

704
00:23:08,216 --> 0:23:09,016
但它们更是

705
00:23:09,086 --> 0:23:10,856
编写建模器的

706
00:23:10,856 --> 0:23:11,706
优秀输入

707
00:23:12,576 --> 0:23:14,356
现在你已经可以编写一个建模器

708
00:23:14,356 --> 0:23:15,316
或者在你的 Instrument 包中

709
00:23:15,316 --> 0:23:16,896
用 modeler 元素

710
00:23:16,896 --> 0:23:19,046
定义一个建模器

711
00:23:19,046 --> 0:23:22,236
你还可以为该建模器

712
00:23:22,346 --> 0:23:23,676
创建一个自定义输出 Schema

713
00:23:24,066 --> 0:23:25,616
你可以只对一个时间点

714
00:23:25,616 --> 0:23:27,336
使用 point-schema

715
00:23:27,336 --> 0:23:28,416
或者如果你有一个时间点和一个区间

716
00:23:28,416 --> 0:23:29,726
你可以使用 interval-schema

717
00:23:30,386 --> 0:23:33,216
建模器可以定义

718
00:23:33,216 --> 0:23:35,126
它需要的输入

719
00:23:35,126 --> 0:23:36,266
这就告诉了绑定方案

720
00:23:36,266 --> 0:23:37,906
如何填充

721
00:23:37,906 --> 0:23:39,706
数据流图的其余部分

722
00:23:39,706 --> 0:23:41,976
这样你的建模器

723
00:23:41,976 --> 0:23:43,076
将融合到绑定方案中

724
00:23:43,906 --> 0:23:45,756
建模器实际上是

725
00:23:45,756 --> 0:23:47,576
微型专家系统

726
00:23:47,576 --> 0:23:48,626
它们是用 CLIPS 语言编写的

727
00:23:48,626 --> 0:23:50,136
这意味着

728
00:23:50,136 --> 0:23:52,006
它们非常强大

729
00:23:52,006 --> 0:23:53,206
同时非常先进

730
00:23:53,206 --> 0:23:54,346
关于如何创建

731
00:23:54,346 --> 0:23:55,896
建模器的细节

732
00:23:55,896 --> 0:23:57,106
我们将留在进阶部分讨论

733
00:23:57,106 --> 0:24:01,336
然而 能够定义自己的 Schema

734
00:23:57,106 --> 0:24:01,336
然而 能够定义自己的 Schema

735
00:24:01,336 --> 0:24:02,856
是非常重要的

736
00:24:02,856 --> 0:24:04,826
我们今年有了一个新的 os_signpost API

737
00:24:04,826 --> 0:24:06,696
它是把数据

738
00:24:06,696 --> 0:24:07,736
导入 Instruments 的绝佳方式

739
00:24:08,596 --> 0:24:10,756
我们为它创造了一条捷径

740
00:24:12,056 --> 0:24:14,246
在你的包中 你可以定义所谓的

741
00:24:14,246 --> 0:24:16,346
os-signpost-interval-schema

742
00:24:16,346 --> 0:24:17,616
它既可以定义 Schema

743
00:24:17,616 --> 0:24:20,046
也可以为我们提供足够的指令

744
00:24:20,046 --> 0:24:22,006
以便能够代替你

745
00:24:22,106 --> 0:24:23,616
生成一个建模器

746
00:24:24,226 --> 0:24:25,686
在那里你可以

747
00:24:25,686 --> 0:24:26,776
捕获在 os_signpost 调用的

748
00:24:26,776 --> 0:24:28,856
元数据中

749
00:24:28,856 --> 0:24:31,926
记录的数据

750
00:24:31,926 --> 0:24:33,986
你可以使用捕获的元数据

751
00:24:33,986 --> 0:24:35,776
和表达式来定义

752
00:24:35,776 --> 0:24:38,796
如何填充你的 Schema 的列

753
00:24:39,816 --> 0:24:42,196
我们来看一个非常简单的例子

754
00:24:43,136 --> 0:24:44,556
假设我们要做 JSON 解码

755
00:24:44,556 --> 0:24:46,776
我们有一个 os_signpost

756
00:24:47,026 --> 0:24:50,726
标记了解码 Activity 的开始

757
00:24:50,726 --> 0:24:52,186
和解码 Activity 的结束

758
00:24:52,746 --> 0:24:54,276
在开始时

759
00:24:54,276 --> 0:24:55,936
我们还需捕获一些元数据

760
00:24:55,936 --> 0:24:57,676
以指示我们将要解析的

761
00:24:57,676 --> 0:24:59,526
JSON 对象的大小

762
00:25:00,876 --> 0:25:01,956
在你的 Instrument 包定义中

763
00:25:01,956 --> 0:25:03,496
你可以创建一个

764
00:25:03,496 --> 0:25:06,136
os-signpost-interval-schema

765
00:25:06,136 --> 0:25:08,396
并在这里定义你的 Schema 名称

766
00:25:09,236 --> 0:25:11,656
你可以选择

767
00:25:11,656 --> 0:25:12,726
要记录的 signpost

768
00:25:12,786 --> 0:25:14,626
包括 signpost 名称

769
00:25:15,086 --> 0:25:16,806
然后在这里可以使用语法

770
00:25:16,806 --> 0:25:18,456
从起始元数据消息中

771
00:25:18,456 --> 0:25:20,186
捕获不同的

772
00:25:20,186 --> 0:25:21,586
元数据片段

773
00:25:21,656 --> 0:25:22,986
这里 我们将使用

774
00:25:23,016 --> 0:25:24,526
这个捕获的值

775
00:25:24,526 --> 0:25:25,296
我们将用它作为表达式

776
00:25:25,296 --> 0:25:27,016
来教我们如何

777
00:25:27,016 --> 0:25:28,956
填充我们刚才定义的

778
00:25:28,956 --> 0:25:30,256
数据大小的列

779
00:25:32,646 --> 0:25:35,756
在 405 号讨论会中 即 

780
00:25:35,756 --> 0:25:37,686
“Measuring Performance Using Logging”

781
00:25:37,686 --> 0:25:42,906
我演示了《Trailblazer》App 

782
00:25:43,216 --> 0:25:44,616
还展示了一个 Instrument

783
00:25:44,616 --> 0:25:46,056
你们可以根据这个 Instrument

784
00:25:46,196 --> 0:25:47,366
里面的 signpost 来进行编写

785
00:25:47,956 --> 0:25:49,716
现在我们对如何编写

786
00:25:49,716 --> 0:25:50,696
自定义 Instrument 

787
00:25:50,696 --> 0:25:52,406
有了更多的了解

788
00:25:52,656 --> 0:25:54,696
我想邀请 Kacper 回到台上

789
00:25:54,696 --> 0:25:56,136
来给大家演示一下

790
00:25:56,386 --> 0:25:57,626
我们是如何创建这个包的

791
00:25:58,516 --> 0:26:03,126
[ 掌声 ]

792
00:25:58,516 --> 0:26:03,126
[ 掌声 ]

793
00:26:03,626 --> 0:26:04,886
&gt;&gt; 谢谢你 Chad

794
00:26:09,836 --> 0:26:12,576
《Trailblazer》 App 是一款 iOS App

795
00:26:12,706 --> 0:26:14,676
它可以显示你附近

796
00:26:14,796 --> 0:26:16,176
流行的徒步旅行路线

797
00:26:16,856 --> 0:26:19,976
作为 UI 组件 它使用了 UITabelView

798
00:26:21,006 --> 0:26:22,766
每个单元异步加载

799
00:26:22,766 --> 0:26:24,156
路线的图像

800
00:26:25,276 --> 0:26:26,936
为了防止出现故障且作为优化

801
00:26:26,936 --> 0:26:28,876
当单元被重复使用时

802
00:26:28,876 --> 0:26:30,376
我们取消了下载

803
00:26:31,556 --> 0:26:33,276
为了可视化我的下载流

804
00:26:33,276 --> 0:26:35,546
我将每个下载都置入到

805
00:26:35,586 --> 0:26:36,356
os_signpost 调用中

806
00:26:36,356 --> 0:26:36,936
让我们看一下

807
00:26:41,536 --> 0:26:42,556
当我的保存的单元显示时

808
00:26:42,556 --> 0:26:45,556
调用 startImageDownload() 方法

809
00:26:46,046 --> 0:26:48,456
我们创建了 downloader 和 signpost ID

810
00:26:48,456 --> 0:26:50,946
它包含了 os 日志句柄

811
00:26:51,026 --> 0:26:52,466
和 downloader 对象

812
00:26:53,306 --> 0:26:55,516
然后我们获取 UI 表格视图

813
00:26:55,516 --> 0:26:59,366
单元的地址 

814
00:26:59,366 --> 0:27:03,016
并调用 os_signpost(.begin)

815
00:26:59,366 --> 0:27:03,016
并调用 os_signpost(.begin)

816
00:27:03,016 --> 0:27:04,676
它自于 signpostlog.networking

817
00:27:04,946 --> 0:27:07,336
让我们看一下

818
00:27:07,336 --> 0:27:08,916
这个日志以 App 的

819
00:27:08,916 --> 0:27:11,076
标识符为子系统

820
00:27:11,106 --> 0:27:12,296
networking 为类别

821
00:27:15,046 --> 0:27:16,506
我们传入 “Background Image” 这个名称

822
00:27:17,286 --> 0:27:18,996
之前创建的 “signpostID”

823
00:27:19,436 --> 0:27:20,886
以及信息格式

824
00:27:20,886 --> 0:27:22,016
其中包含 “Image name”

825
00:27:23,956 --> 0:27:25,276
在这里 我们将它放置在全局说明符中

826
00:27:25,276 --> 0:27:27,406
因为它是一个字符串

827
00:27:28,286 --> 0:27:30,406
还有 “Caller” 它是一个单元的地址

828
00:27:31,816 --> 0:27:33,916
我们的下载可以

829
00:27:33,956 --> 0:27:35,476
通过两种方法完成

830
00:27:36,106 --> 0:27:39,086
我们现在来看看

831
00:27:39,166 --> 0:27:40,236
当下载以这样的方式完成

832
00:27:40,756 --> 0:27:42,816
就会调用委托方法

833
00:27:43,866 --> 0:27:45,636
我们像之前一样创建 signpostID

834
00:27:45,636 --> 0:27:48,496
并调用 os_signpost(.end)

835
00:27:49,546 --> 0:27:52,556
这次我们传入 “Status” 和 “Size”

836
00:27:53,876 --> 0:27:56,956
“Status” 值是 “Completed”

837
00:27:58,256 --> 0:28:01,786
“Size” 设置为图像大小

838
00:27:58,256 --> 0:28:01,786
“Size” 设置为图像大小

839
00:28:02,236 --> 0:28:04,456
接下来让我们看一下

840
00:28:04,456 --> 0:28:06,166
我们为重写所做的准备

841
00:28:06,766 --> 0:28:09,546
当 downloader 正在运行时

842
00:28:09,546 --> 0:28:11,116
我们会取消它

843
00:28:12,126 --> 0:28:14,076
我们创建了 signpostID

844
00:28:14,076 --> 0:28:16,006
并使用相同的格式字符串

845
00:28:16,006 --> 0:28:18,016
调用我们的 os_signpost(.end)

846
00:28:18,016 --> 0:28:20,496
但是这里 值是 “Canceled” 并且 “Size”

847
00:28:20,496 --> 0:28:21,896
为 “0” 因为下载没有成功

848
00:28:22,406 --> 0:28:25,446
让我们来看看

849
00:28:25,446 --> 0:28:26,786
我们的 os-signpost-interval-schema 定义

850
00:28:26,786 --> 0:28:28,326
以及我们如何在包中

851
00:28:28,376 --> 0:28:30,386
捕获这些 signpost

852
00:28:32,456 --> 0:28:34,456
我们定义了具有唯一 id 和 title 的

853
00:28:34,456 --> 0:28:36,936
os-signpost-interval-schema

854
00:28:37,686 --> 0:28:40,306
然后我们定义 subsystem 和 category

855
00:28:40,306 --> 0:28:41,856
它与我们在创建

856
00:28:41,856 --> 0:28:43,326
日志句柄时

857
00:28:43,326 --> 0:28:44,596
传递的 category 相对应

858
00:28:46,816 --> 0:28:49,346
我们创建 name 元素

859
00:28:49,346 --> 0:28:50,846
它与我们在 os_signpost 

860
00:28:50,846 --> 0:28:53,646
调用 start-pattern 和 end-pattern 中

861
00:28:54,016 --> 0:28:56,156
传递的 name 相对应

862
00:28:56,736 --> 0:28:58,496
这两个都对应于

863
00:28:58,656 --> 0:29:00,296
我们在 os_signpost 中传入的

864
00:28:58,656 --> 0:29:00,296
我们在 os_signpost 中传入的

865
00:29:00,296 --> 0:29:01,756
开始和结束调用

866
00:29:04,266 --> 0:29:05,966
message 元素与

867
00:29:05,966 --> 0:29:07,596
传递的格式字符串相同

868
00:29:07,596 --> 0:29:10,326
但是在调用 os_signpost 时

869
00:29:10,326 --> 0:29:12,516
为了捕获传入的值

870
00:29:12,516 --> 0:29:14,406
你传递的将是这里的变量

871
00:29:14,406 --> 0:29:15,556
而不是格式化参数

872
00:29:16,066 --> 0:29:18,786
让我们看看如何

873
00:29:18,786 --> 0:29:20,576
在列中填入这些值

874
00:29:23,926 --> 0:29:26,876
在这里 你可以看到 status 列

875
00:29:27,066 --> 0:29:28,566
它是字符串类型

876
00:29:28,566 --> 0:29:30,246
因为它只可能是 “Completed” 或者 “Canceled”

877
00:29:31,486 --> 0:29:32,756
所以我们用状态变量的值

878
00:29:32,756 --> 0:29:34,956
来填充它

879
00:29:36,676 --> 0:29:38,806
因为 expression 元素可以采用

880
00:29:38,926 --> 0:29:40,826
任意的 CLIPS 表达式

881
00:29:41,706 --> 0:29:42,586
所以我们可以在其中

882
00:29:42,586 --> 0:29:44,156
做更复杂的事情

883
00:29:44,816 --> 0:29:47,056
在这里我们可以通过查看图像大小

884
00:29:47,056 --> 0:29:49,006
来计算事件影响

885
00:29:49,846 --> 0:29:51,536
如果它大于 3.5MB

886
00:29:51,536 --> 0:29:53,326
我们可以判定影响很大

887
00:29:53,416 --> 0:29:56,516
否则操作的影响很小

888
00:29:58,076 --> 0:30:00,236
这就是我们对 os-signpost-interval-schema 

889
00:29:58,076 --> 0:30:00,236
这就是我们对 os-signpost-interval-schema 

890
00:30:00,236 --> 0:30:00,976
所做的定义

891
00:30:01,106 --> 0:30:04,066
现在让我们来看看表格的创建

892
00:30:05,796 --> 0:30:07,696
对于 schema-ref

893
00:30:08,096 --> 0:30:10,456
我们传入 os-signpost-interval-schema 

894
00:30:10,456 --> 0:30:12,616
的标识符

895
00:30:12,616 --> 0:30:13,846
并为这个特定表格

896
00:30:13,846 --> 0:30:14,686
创建唯一标识符

897
00:30:15,906 --> 0:30:17,736
然后 我们可以在

898
00:30:17,736 --> 0:30:18,876
UI 定义中引用它

899
00:30:20,296 --> 0:30:22,676
对于 graph 我们创建一个单轨道

900
00:30:23,796 --> 0:30:26,036
它利用我们的表

901
00:30:26,036 --> 0:30:28,056
这次它通过使用 Plot 模板来绘制图形

902
00:30:28,796 --> 0:30:30,586
Plot 模板

903
00:30:30,586 --> 0:30:31,476
是创建图形的动态方法

904
00:30:32,146 --> 0:30:37,386
它查看在实例中

905
00:30:37,386 --> 0:30:40,126
按元素传递的列

906
00:30:40,226 --> 0:30:44,436
并为该列的每个唯一值创建 Plot

907
00:30:44,606 --> 0:30:46,436
label-format 元素

908
00:30:46,486 --> 0:30:49,966
允许我们为这个 Plot 创建格式标题

909
00:30:50,336 --> 0:30:53,956
这里是 img 列和 image-name 列中的值

910
00:30:54,516 --> 0:30:57,166
我们传入 image-name

911
00:30:57,166 --> 0:30:57,656
作为我们的 Plot 的值

912
00:30:58,766 --> 0:31:00,156
我们的每个轨道

913
00:30:58,766 --> 0:31:00,156
我们的每个轨道

914
00:31:00,206 --> 0:31:03,166
都会以 impact 列上色

915
00:31:03,326 --> 0:31:06,076
我们轨道上的标签

916
00:31:06,076 --> 0:31:06,976
会从 image-size 中提取出来

917
00:31:09,436 --> 0:31:12,796
接下来 我们看看 list

918
00:31:12,796 --> 0:31:14,726
你已经在 Ticks 的例子中

919
00:31:14,756 --> 0:31:15,526
见过它

920
00:31:16,866 --> 0:31:18,176
这里 我们将传入

921
00:31:18,176 --> 0:31:21,286
你希望看到的所有列

922
00:31:21,536 --> 0:31:22,766
接下来是 aggregation

923
00:31:23,726 --> 0:31:25,266
这个 aggregation 将跟踪

924
00:31:25,266 --> 0:31:26,406
所有已完成的下载

925
00:31:27,236 --> 0:31:29,836
因为我们的表

926
00:31:29,836 --> 0:31:31,146
包含已完成和已取消的下载

927
00:31:31,146 --> 0:31:32,406
所以我们需要应用

928
00:31:32,406 --> 0:31:34,836
slice 元素来过滤一些数据

929
00:31:36,016 --> 0:31:37,866
在 slice 元素中

930
00:31:37,866 --> 0:31:39,456
我们可以指定

931
00:31:39,456 --> 0:31:42,066
应用于 slice 的列

932
00:31:42,596 --> 0:31:43,496
以及需要匹配的谓词值

933
00:31:43,926 --> 0:31:45,546
在这里 我们只想从这个表中

934
00:31:45,546 --> 0:31:47,056
取出 “Completed” 的行

935
00:31:48,306 --> 0:31:50,746
我们定义了 hierarchy

936
00:31:50,746 --> 0:31:52,406
它是只有一个层级的结构

937
00:31:52,486 --> 0:31:55,276
具有 image-name

938
00:31:55,276 --> 0:31:55,836
和可见的列

939
00:31:56,676 --> 0:31:58,786
对于每个 image-name

940
00:31:58,786 --> 0:32:02,156
我们将指定 count 和 image-size

941
00:31:58,786 --> 0:32:02,156
我们将指定 count 和 image-size

942
00:32:02,156 --> 0:32:04,916
所以我们要将图像的大小求和

943
00:32:05,386 --> 0:32:09,426
接下来我们有 time-slice

944
00:32:10,456 --> 0:32:10,746
抱歉

945
00:32:10,746 --> 0:32:12,186
我们指定所有

946
00:32:12,186 --> 0:32:13,046
将会可见的列

947
00:32:16,096 --> 0:32:18,636
为了更容易地使用我们的 Instrument

948
00:32:18,636 --> 0:32:22,796
我们可以指定我们的

949
00:32:22,796 --> 0:32:23,566
自定义模板

950
00:32:24,126 --> 0:32:26,876
我们现在尝试构建和运行

951
00:32:26,986 --> 0:32:27,306
我们的包

952
00:32:34,416 --> 0:32:36,336
你可以看到这里的模板

953
00:32:36,396 --> 0:32:36,976
我可以选中它

954
00:32:41,536 --> 0:32:43,916
Target 是我的 iPhone

955
00:32:43,916 --> 0:32:45,186
和《Trailblazer》App

956
00:32:48,956 --> 0:32:50,976
我需要记录一会

957
00:33:00,716 --> 0:33:03,786
可以看到

958
00:33:03,786 --> 0:33:04,936
跟踪视图是以数据传递的

959
00:33:06,616 --> 0:33:08,746
每一个图像名称都创建了

960
00:33:08,746 --> 0:33:09,636
一个绘图

961
00:33:11,366 --> 0:33:12,816
你可以看到标签格式

962
00:33:12,816 --> 0:33:14,366
与我们在包定义中

963
00:33:14,366 --> 0:33:15,586
传入的格式相匹配

964
00:33:16,596 --> 0:33:19,056
如果下载

965
00:33:19,056 --> 0:33:21,176
高于 3.5 MB

966
00:33:21,176 --> 0:33:22,406
那么我们的轨道将是红色的

967
00:33:23,596 --> 0:33:25,266
具体的大小可以在轨道上查看

968
00:33:25,786 --> 0:33:28,576
接下来我们看看

969
00:33:28,576 --> 0:33:30,286
所有的细节

970
00:33:32,436 --> 0:33:35,146
首先 我们看一下下载列表

971
00:33:36,066 --> 0:33:38,096
这是刚才发生的

972
00:33:38,096 --> 0:33:38,976
所有下载的列表

973
00:33:39,636 --> 0:33:42,346
我们可以选择聚合

974
00:33:42,866 --> 0:33:46,746
按照图像名称

975
00:33:46,746 --> 0:33:48,236
划分所有下载

976
00:33:48,616 --> 0:33:49,926
你可以在上面看到

977
00:33:49,926 --> 0:33:51,856
我们下载了 12 张图像

978
00:33:52,156 --> 0:33:55,886
“location7” 的图像

979
00:33:55,886 --> 0:33:59,436
被下载了两次

980
00:33:59,616 --> 0:34:00,876
接下来

981
00:33:59,616 --> 0:34:00,876
接下来

982
00:34:00,876 --> 0:34:02,676
我们可以查看活动请求

983
00:34:03,296 --> 0:34:05,166
你可以在这里看到

984
00:34:05,166 --> 0:34:07,386
当我拖动我的检查线时

985
00:34:09,356 --> 0:34:12,786
细节视图中的数据发生了变化

986
00:34:13,646 --> 0:34:15,835
我们可以跟踪

987
00:34:15,876 --> 0:34:17,505
多个活动请求

988
00:34:17,505 --> 0:34:19,106
并查看截至当前检查线为止的

989
00:34:19,106 --> 0:34:20,426
持续时间

990
00:34:21,896 --> 0:34:23,976
如果你想从不同的角度

991
00:34:23,976 --> 0:34:25,286
查看你的数据

992
00:34:25,536 --> 0:34:28,226
并想查看你的存储和建模器

993
00:34:28,226 --> 0:34:31,056
我们通过 Instrument 检查器

994
00:34:31,056 --> 0:34:32,606
为你提供了这个功能

995
00:34:33,576 --> 0:34:34,976
它是调试自定义 Instrument 的

996
00:34:34,976 --> 0:34:36,076
一种方法

997
00:34:36,716 --> 0:34:38,396
在这里你可以看到

998
00:34:38,396 --> 0:34:41,646
我选择了存储步骤

999
00:34:41,976 --> 0:34:43,876
并看到创建 os-signpost 的存储

1000
00:34:44,556 --> 0:34:46,916
它属于网络类别

1001
00:34:47,335 --> 0:34:48,956
和 com.apple.trailblazer 子系统

1002
00:34:48,956 --> 0:34:52,216
我们在这里收集了 24 行

1003
00:34:53,235 --> 0:34:55,376
然后我们可以看到

1004
00:34:55,466 --> 0:34:57,216
创建的表格 image-download

1005
00:34:57,366 --> 0:34:57,896
它有 12 行

1006
00:35:02,156 --> 0:35:04,326
在底部的区域

1007
00:35:04,326 --> 0:35:04,976
你可以看到该表的整个内容

1008
00:35:07,396 --> 0:35:09,146
接下来 我们跳转到建模器

1009
00:35:09,546 --> 0:35:10,706
我们可以看到这里有

1010
00:35:10,806 --> 0:35:12,936
GENERATED-OS-LOG 建模器

1011
00:35:13,456 --> 0:35:16,916
它使用了 24 行 输出了 12 行

1012
00:35:18,346 --> 0:35:20,756
在右边 你可以看到绑定方案

1013
00:35:21,546 --> 0:35:23,826
所以我们的 GENERATED-OS-LOG 建模器

1014
00:35:24,206 --> 0:35:26,026
从 os-signpost 表格中获取数据

1015
00:35:26,026 --> 0:35:28,216
并将其放入图像下载表格中

1016
00:35:29,386 --> 0:35:31,886
然后被我们的 Instrument 使用

1017
00:35:32,446 --> 0:35:35,766
我们就是这样

1018
00:35:35,766 --> 0:35:37,966
捕获 os-signpost 调用

1019
00:35:38,036 --> 0:35:40,366
创建 UI 并使用 Instrument 检查器

1020
00:35:40,366 --> 0:35:41,376
查看数据

1021
00:35:42,036 --> 0:35:43,866
现在让我们请回 Chad

1022
00:35:43,916 --> 0:35:44,846
他会告诉你们更多

1023
00:35:44,846 --> 0:35:45,836
关于进阶建模的内容

1024
00:35:46,516 --> 0:35:50,500
[ 掌声 ]

1025
00:35:54,716 --> 0:35:55,056
&gt;&gt; 好的

1026
00:35:55,326 --> 0:35:56,006
谢谢 Kacper

1027
00:35:57,646 --> 0:35:59,366
现在我们已经了解了

1028
00:35:59,366 --> 0:36:01,686
如何将 os-signpost 数据

1029
00:35:59,366 --> 0:36:01,686
如何将 os-signpost 数据

1030
00:36:01,746 --> 0:36:03,396
与自定义 Instrument 结合起来

1031
00:36:03,776 --> 0:36:10,106
我们认为你们 能把这个结合做得很好

1032
00:36:10,886 --> 0:36:13,846
现在 我们可以讨论一些

1033
00:36:13,846 --> 0:36:15,026
进阶的内容

1034
00:36:15,056 --> 0:36:16,546
特别是如何创建

1035
00:36:16,546 --> 0:36:18,286
和定义建模器

1036
00:36:19,366 --> 0:36:20,466
建模器在概念上是

1037
00:36:20,466 --> 0:36:21,296
非常简单的机器

1038
00:36:21,296 --> 0:36:23,156
它需要一系列的输入

1039
00:36:23,266 --> 0:36:24,256
它对这些输入做出推理

1040
00:36:24,256 --> 0:36:26,376
然后进行输出

1041
00:36:27,326 --> 0:36:28,506
建模器的输入

1042
00:36:28,506 --> 0:36:30,246
是完全按照时间排序的

1043
00:36:30,736 --> 0:36:32,116
因此如果你请求

1044
00:36:32,116 --> 0:36:33,506
几个不同的输入表

1045
00:36:33,506 --> 0:36:34,756
这些表将首先按时间排序

1046
00:36:34,756 --> 0:36:36,246
然后合并到一个

1047
00:36:36,246 --> 0:36:38,646
按时间排序的队列中

1048
00:36:38,646 --> 0:36:39,406
该队列将提供工作内存

1049
00:36:39,916 --> 0:36:41,356
当我们把这些事件

1050
00:36:41,356 --> 0:36:42,476
一个接一个地取出时

1051
00:36:42,536 --> 0:36:43,776
它们被输入到所谓的

1052
00:36:43,776 --> 0:36:44,356
建模器的工作内存中

1053
00:36:45,236 --> 0:36:47,886
当建模器看到

1054
00:36:47,886 --> 0:36:49,306
这个工作内存的增长时

1055
00:36:49,306 --> 0:36:51,006
它就可以得出推论

1056
00:36:51,226 --> 0:36:52,766
当建模器看到需要为其

1057
00:36:52,766 --> 0:36:54,086
进行输出的模板时

1058
00:36:54,086 --> 0:36:56,206
它只需将其

1059
00:36:56,206 --> 0:36:57,406
写入对外输出表格

1060
00:36:58,166 --> 0:37:00,256
让我们以一个

1061
00:36:58,166 --> 0:37:00,256
让我们以一个

1062
00:37:00,406 --> 0:37:01,766
非常有趣的例子

1063
00:37:01,766 --> 0:37:03,336
来介绍如何使用建模器

1064
00:37:03,606 --> 0:37:05,966
假设你定义了一个 Schema

1065
00:37:06,106 --> 0:37:07,906
叫做 playing-with-matches

1066
00:37:08,006 --> 0:37:10,166
它是一个

1067
00:37:10,166 --> 0:37:12,666
os-signpost-interval-schema

1068
00:37:12,876 --> 0:37:14,156
可以使已经定义的 os_signpost

1069
00:37:14,156 --> 0:37:15,036
在你的代码中

1070
00:37:15,036 --> 0:37:17,226
做一些危险的操作

1071
00:37:17,726 --> 0:37:19,996
我们又定义了另一个 Schema

1072
00:37:20,156 --> 0:37:21,766
叫做 app-on-fire

1073
00:37:22,186 --> 0:37:23,916
它也是一个 signpost Schema

1074
00:37:24,066 --> 0:37:25,206
但是这些 signpost 意味着

1075
00:37:25,206 --> 0:37:27,386
App 进入了一个糟糕的状态

1076
00:37:27,386 --> 0:37:29,396
我们真的很想知道原因

1077
00:37:30,406 --> 0:37:31,816
还要创建一个输出 Schema

1078
00:37:31,816 --> 0:37:33,306
它是一个 point-schema

1079
00:37:33,306 --> 0:37:35,836
它会保存 playing-with-matches 的对象

1080
00:37:35,836 --> 0:37:37,476
以及对象“起火”的时间

1081
00:37:37,956 --> 0:37:38,676
我们打算将它

1082
00:37:38,676 --> 0:37:39,796
命名为 started-a-fire

1083
00:37:39,796 --> 0:37:44,066
建模器看起来是这样的

1084
00:37:44,226 --> 0:37:46,686
所有的输入

1085
00:37:46,686 --> 0:37:48,486
都按时间顺序设置好了

1086
00:37:48,486 --> 0:37:51,096
左边的虚线就是

1087
00:37:51,096 --> 0:37:53,126
所谓的建模器时钟

1088
00:37:54,136 --> 0:37:55,976
当我们获取第一个输入

1089
00:37:55,976 --> 0:37:57,206
将其置入到工作内存中时

1090
00:37:57,206 --> 0:37:58,636
建模器时钟

1091
00:37:58,686 --> 0:37:59,686
将移动到区间的起始处

1092
00:37:59,686 --> 0:38:03,076
然后我们获取下一个输入

1093
00:37:59,686 --> 0:38:03,076
然后我们获取下一个输入

1094
00:38:03,076 --> 0:38:04,666
建模器时钟

1095
00:38:04,666 --> 0:38:06,036
再次移动到区间的起始处

1096
00:38:06,036 --> 0:38:08,046
我们将其置入到工作内存中

1097
00:38:08,836 --> 0:38:10,376
建模器观察

1098
00:38:10,376 --> 0:38:12,656
工作内存的这两个区间

1099
00:38:12,656 --> 0:38:14,366
建模器可以观察

1100
00:38:14,366 --> 0:38:16,256
playing-with-matches 是否在

1101
00:38:16,256 --> 0:38:17,336
app-on-fire 之前开始

1102
00:38:17,336 --> 0:38:18,886
这其实没有多大区别

1103
00:38:19,176 --> 0:38:19,956
如果反过来

1104
00:38:19,956 --> 0:38:22,406
app-on-fire 也已经开始了

1105
00:38:22,406 --> 0:38:24,086
我们就可以得出一个合乎逻辑的结论

1106
00:38:25,396 --> 0:38:27,936
叫做 cause-of-fire 

1107
00:38:27,936 --> 0:38:29,846
并将它置入工作内存中

1108
00:38:31,676 --> 0:38:33,456
当我们获取第三个输入时

1109
00:38:33,756 --> 0:38:34,986
你会注意到

1110
00:38:34,986 --> 0:38:36,636
建模器时钟已经移动

1111
00:38:36,636 --> 0:38:38,996
它不再与前两个输入相交

1112
00:38:39,516 --> 0:38:41,956
所以它们将被从工作内存中移除

1113
00:38:42,766 --> 0:38:44,636
如果 cause-of-fire 有

1114
00:38:44,636 --> 0:38:45,886
所谓的逻辑支持

1115
00:38:46,326 --> 0:38:50,556
它也会被从内存中移除

1116
00:38:50,856 --> 0:38:52,926
回顾一下 时钟总是被设置为

1117
00:38:52,926 --> 0:38:54,926
当前输入的时间戳

1118
00:38:55,556 --> 0:38:57,576
对于留在工作内存中的

1119
00:38:57,576 --> 0:38:58,936
输入而言

1120
00:38:58,936 --> 0:39:01,836
它必须与建模器中的

1121
00:38:58,936 --> 0:39:01,836
它必须与建模器中的

1122
00:39:01,836 --> 0:39:02,406
当前时钟相交

1123
00:39:02,956 --> 0:39:04,876
这可以帮助我们建立重合

1124
00:39:04,876 --> 0:39:06,606
它能让我们删除旧数据

1125
00:39:06,606 --> 0:39:08,626
也能让我们了解

1126
00:39:08,666 --> 0:39:10,186
是否存在

1127
00:39:10,186 --> 0:39:13,386
可能与时间相关的输入

1128
00:39:13,916 --> 0:39:15,026
建模器对其

1129
00:39:15,156 --> 0:39:16,766
工作内存的解释

1130
00:39:17,066 --> 0:39:19,196
是通过所谓的 “Production System”

1131
00:39:19,196 --> 0:39:20,426
来定义的

1132
00:39:21,496 --> 0:39:23,466
生产系统处理

1133
00:39:23,466 --> 0:39:25,306
工作内存中的 “Facts（事实）”

1134
00:39:25,306 --> 0:39:26,486
它们由具有左手边 (LHS)

1135
00:39:26,486 --> 0:39:28,176
一个生产操作符

1136
00:39:28,176 --> 0:39:30,346
和右手边 (RHS) 的规则定义

1137
00:39:31,106 --> 0:39:32,896
LHS 是工作内存

1138
00:39:33,306 --> 0:39:35,106
中的一种模板

1139
00:39:35,106 --> 0:39:37,336
它能够激活规则

1140
00:39:37,336 --> 0:39:38,976
而 RHS 则是规则触发时

1141
00:39:38,976 --> 0:39:41,576
发生的动作

1142
00:39:42,036 --> 0:39:43,306
这些操作可以包括

1143
00:39:43,746 --> 0:39:45,686
向输出表中添加一行

1144
00:39:45,866 --> 0:39:48,476
或者在建模过程进行时

1145
00:39:48,526 --> 0:39:50,896
将一个新的事实

1146
00:39:50,896 --> 0:39:52,566
添加到工作内存中

1147
00:39:54,186 --> 0:39:56,826
事实有两个来源

1148
00:39:56,926 --> 0:39:58,046
首先 它们可以来自

1149
00:39:58,046 --> 0:39:59,566
你看到过的表格输入

1150
00:39:59,566 --> 0:40:01,206
通过使用我在建模时钟中

1151
00:39:59,566 --> 0:40:01,206
通过使用我在建模时钟中

1152
00:40:01,206 --> 0:40:03,336
展示的规则

1153
00:40:03,336 --> 0:40:04,246
表输入将被判定为事实

1154
00:40:04,246 --> 0:40:06,376
事实也可以通过

1155
00:40:06,376 --> 0:40:07,846
来自生产的 RHS 的

1156
00:40:07,846 --> 0:40:09,866
判定生成

1157
00:40:11,066 --> 0:40:12,196
如果你要创建你自己的事实

1158
00:40:12,196 --> 0:40:14,336
CLIPS 允许你

1159
00:40:14,336 --> 0:40:15,316
找到所谓的“事实模板”

1160
00:40:15,426 --> 0:40:16,106
你可以为你的事实

1161
00:40:16,106 --> 0:40:17,196
提供结构

1162
00:40:17,196 --> 0:40:17,976
并做一些基本的类型检查

1163
00:40:18,046 --> 0:40:21,306
让我们来看看 CLIPS 中的

1164
00:40:21,306 --> 0:40:22,356
一些规则

1165
00:40:23,226 --> 0:40:24,326
我们要讲的第一个规则

1166
00:40:24,326 --> 0:40:25,926
叫做 found-cause

1167
00:40:27,306 --> 0:40:30,446
它指的是 如果有一个对象

1168
00:40:30,446 --> 0:40:31,806
它的 playing-with-matches

1169
00:40:31,806 --> 0:40:35,526
在 t1 时开始

1170
00:40:35,526 --> 0:40:38,996
app-on-fire 在 t2 时开始

1171
00:40:39,286 --> 0:40:41,466
且 t1 比 t2 提前

1172
00:40:41,466 --> 0:40:42,236
那么在这个生产的 RHS 中

1173
00:40:42,236 --> 0:40:43,756
我们可以判定一个新的事实

1174
00:40:43,756 --> 0:40:46,026
叫做 cause-of-fire 

1175
00:40:46,076 --> 0:40:47,616
以及导致“起火”的对象

1176
00:40:48,196 --> 0:40:49,336
它将进入到

1177
00:40:49,426 --> 0:40:50,096
工作内存中

1178
00:40:51,136 --> 0:40:53,156
我们接下来讨论第二个规则

1179
00:40:53,156 --> 0:40:54,666
也就是 record-cause

1180
00:40:54,666 --> 0:40:58,296
如果我们有一个 App

1181
00:40:58,296 --> 0:41:00,166
在某个开始时间“起火”

1182
00:40:58,296 --> 0:41:00,166
在某个开始时间“起火”

1183
00:41:00,166 --> 0:41:01,796
并且我们知道“起火”的原因

1184
00:41:01,796 --> 0:41:03,536
我们有一个绑定到

1185
00:41:03,536 --> 0:41:05,876
side append 的表格

1186
00:41:05,876 --> 0:41:08,876
它是建模器的输出端

1187
00:41:08,946 --> 0:41:11,336
而且这个表是我们定义的

1188
00:41:11,336 --> 0:41:12,926
叫做 started-a-fire 的 Schema

1189
00:41:12,926 --> 0:41:16,776
我们可以创建一个表格的行

1190
00:41:16,776 --> 0:41:18,126
然后设置时间

1191
00:41:18,246 --> 0:41:19,946
以及导致

1192
00:41:19,946 --> 0:41:21,276
模板中所得的值

1193
00:41:21,276 --> 0:41:23,826
“起火”的 Schema

1194
00:41:23,906 --> 0:41:25,826
通过这两个规则

1195
00:41:25,826 --> 0:41:27,756
我们基本上创建了

1196
00:41:27,756 --> 0:41:29,356
第一个专家系统来查找

1197
00:41:29,356 --> 0:41:31,406
App 中的不良模式

1198
00:41:32,436 --> 0:41:34,376
现在你可能已经注意到

1199
00:41:34,376 --> 0:41:36,016
规则是由 MODELER::

1200
00:41:36,016 --> 0:41:38,396
或 RECORDER:: 预先编写的

1201
00:41:38,966 --> 0:41:39,546
这些都是 CLIPS 中的模块

1202
00:41:39,546 --> 0:41:41,606
它们允许你

1203
00:41:41,606 --> 0:41:43,916
同时把规则分组

1204
00:41:43,916 --> 0:41:45,956
并控制规则的执行顺序

1205
00:41:46,526 --> 0:41:48,556
举个例子

1206
00:41:48,556 --> 0:41:50,946
如果你保持了所有的

1207
00:41:50,946 --> 0:41:52,176
为 RECORDER:: 模块中的输出表格

1208
00:41:52,176 --> 0:41:54,006
生产输出的规则

1209
00:41:55,116 --> 0:41:57,536
你就可以确保

1210
00:41:57,536 --> 0:41:59,896
你不会在建模器的

1211
00:41:59,896 --> 0:42:01,916
推理过程中进行输出

1212
00:41:59,896 --> 0:42:01,916
推理过程中进行输出

1213
00:42:02,246 --> 0:42:03,566
因为在 MODELER:: 中的所有规则 

1214
00:42:03,566 --> 0:42:05,246
必须在 

1215
00:42:05,246 --> 0:42:06,966
RECORDER:: 中的规则

1216
00:42:06,966 --> 0:42:07,746
执行之前执行

1217
00:42:08,686 --> 0:42:10,736
我之前提到过的

1218
00:42:10,736 --> 0:42:12,296
逻辑支持

1219
00:42:12,776 --> 0:42:14,556
逻辑支持通常与

1220
00:42:14,776 --> 0:42:17,066
所谓的对等推理规则

1221
00:42:17,066 --> 0:42:18,586
联系在一起

1222
00:42:18,586 --> 0:42:20,336
这些规则就是 比如说

1223
00:42:20,336 --> 0:42:21,736
如果 A 和 B 那么 C

1224
00:42:22,156 --> 0:42:23,756
向生产中

1225
00:42:23,756 --> 0:42:25,286
添加逻辑支持

1226
00:42:25,286 --> 0:42:29,646
意思就是

1227
00:42:29,646 --> 0:42:30,786
如果 A 和 B 不再

1228
00:42:30,786 --> 0:42:32,126
处于工作内存中

1229
00:42:32,126 --> 0:42:33,606
那么 C 应该被自动收回

1230
00:42:33,656 --> 0:42:35,726
所以我们说

1231
00:42:35,726 --> 0:42:37,016
C 受 A 和 B 的存在的

1232
00:42:37,016 --> 0:42:38,326
逻辑支持

1233
00:42:38,806 --> 0:42:40,346
这很重要

1234
00:42:40,346 --> 0:42:41,606
因为它限制了工作内存膨胀

1235
00:42:41,606 --> 0:42:43,156
这有助于资源消耗

1236
00:42:43,156 --> 0:42:44,436
但从工作内存中

1237
00:42:44,436 --> 0:42:46,096
删除不再有效的事实

1238
00:42:46,096 --> 0:42:48,076
同样也很重要

1239
00:42:48,326 --> 0:42:49,486
如果 A 和 B 不再有效

1240
00:42:49,486 --> 0:42:51,526
那么你应该移除 C

1241
00:42:52,076 --> 0:42:54,596
为了向你的生产

1242
00:42:54,826 --> 0:42:57,606
添加逻辑支持 这里是相关的规则

1243
00:42:57,906 --> 0:42:59,826
你只需将关键字 logical

1244
00:42:59,866 --> 0:43:01,226
填入模板

1245
00:42:59,866 --> 0:43:01,226
填入模板

1246
00:43:01,226 --> 0:43:02,146
那么在向前移动的过程中

1247
00:43:02,146 --> 0:43:03,866
规则中的 RHS

1248
00:43:03,866 --> 0:43:05,986
所判定的任何内容

1249
00:43:05,986 --> 0:43:06,836
都将被自动收回

1250
00:43:07,056 --> 0:43:08,566
你们应该注意到了

1251
00:43:08,816 --> 0:43:10,566
来自我们的 Schema 的

1252
00:43:11,146 --> 0:43:12,876
这两个规则 抱歉

1253
00:43:12,876 --> 0:43:14,326
这两个事实

1254
00:43:14,766 --> 0:43:16,446
它们都是输入

1255
00:43:16,446 --> 0:43:17,176
所以当建模器时钟

1256
00:43:17,176 --> 0:43:18,456
向前移动时

1257
00:43:18,456 --> 0:43:19,636
这些将自动被收回

1258
00:43:22,196 --> 0:43:23,626
好的 现在我们已经了解了

1259
00:43:23,626 --> 0:43:25,476
如何在包中创建

1260
00:43:25,476 --> 0:43:27,336
建模器的基本内容

1261
00:43:27,436 --> 0:43:29,746
并且看到了一些 CLIPS 语言和规则

1262
00:43:30,186 --> 0:43:32,096
让我们来看看

1263
00:43:32,096 --> 0:43:34,626
是否可以在我们的网络 Instrument 中

1264
00:43:34,626 --> 0:43:37,646
添加一个专家系统

1265
00:43:37,646 --> 0:43:39,216
以查找我们的网络层中的

1266
00:43:39,426 --> 0:43:41,106
不良模式和潜在的误用

1267
00:43:41,706 --> 0:43:43,286
为此 让我们邀请 Kacper 上台

1268
00:43:43,286 --> 0:43:44,886
做最后一个演示

1269
00:43:45,516 --> 0:43:50,500
[ 掌声 ]

1270
00:43:55,016 --> 0:43:56,486
&gt;&gt; 有了现有的日志记录

1271
00:43:56,526 --> 0:43:58,176
我将尝试编写建模器

1272
00:43:58,246 --> 0:43:59,796
来检测 App 的

1273
00:43:59,796 --> 0:44:00,956
网络行为中的

1274
00:43:59,796 --> 0:44:00,956
网络行为中的

1275
00:44:00,956 --> 0:44:01,976
一些反面模式

1276
00:44:02,756 --> 0:44:03,656
我在运行我的

1277
00:44:03,656 --> 0:44:05,646
《Trailblazer》 App

1278
00:44:05,646 --> 0:44:07,086
如果我滚动得很快

1279
00:44:07,136 --> 0:44:08,746
这里就会出现

1280
00:44:08,746 --> 0:44:09,476
一些小故障

1281
00:44:09,906 --> 0:44:11,886
图像被多次替换

1282
00:44:11,886 --> 0:44:14,516
所以我怀疑我们的取消

1283
00:44:14,516 --> 0:44:15,906
并没有真正起作用

1284
00:44:17,366 --> 0:44:19,736
我想编写建模器来检测它

1285
00:44:21,186 --> 0:44:23,746
让我们来看看

1286
00:44:23,746 --> 0:44:24,736
我们的包定义

1287
00:44:25,246 --> 0:44:27,916
我们将从编写 modeler 元素开始

1288
00:44:28,636 --> 0:44:31,336
modeler 有 id title

1289
00:44:31,336 --> 0:44:32,366
和 purpose 几个栏

1290
00:44:33,336 --> 0:44:35,316
这些栏将被

1291
00:44:35,316 --> 0:44:36,406
提取到文档中

1292
00:44:37,536 --> 0:44:39,366
我们为 modeler 指定了

1293
00:44:39,366 --> 0:44:41,576
包含所有逻辑的

1294
00:44:41,576 --> 0:44:42,756
production system 的 path

1295
00:44:45,086 --> 0:44:47,466
然后 我们定义了 modeler 的 output

1296
00:44:48,086 --> 0:44:50,006
它将是一个 downloader-narrative Schema

1297
00:44:50,916 --> 0:44:53,506
我们的建模器的 required-input 

1298
00:44:53,506 --> 0:44:55,646
将是 os-signpost 表格

1299
00:44:56,556 --> 0:44:58,836
这个表包含开始

1300
00:44:58,836 --> 0:44:59,686
和结束事件

1301
00:45:00,926 --> 0:45:02,076
现在让我们看一下

1302
00:45:02,526 --> 0:45:03,816
downloader-narrative

1303
00:45:03,816 --> 0:45:04,946
Schema 的定义

1304
00:45:10,896 --> 0:45:13,006
它是一个 point-schema

1305
00:45:13,046 --> 0:45:15,026
定义了两个列

1306
00:45:15,526 --> 0:45:17,216
timestamp

1307
00:45:17,216 --> 0:45:19,046
跟踪记录诊断消息的时间

1308
00:45:20,176 --> 0:45:22,156
description 含有

1309
00:45:22,156 --> 0:45:23,666
运行错误的信息

1310
00:45:26,116 --> 0:45:28,346
然后 我们可以在 Instrument 定义中

1311
00:45:28,676 --> 0:45:30,086
创建这个表

1312
00:45:30,656 --> 0:45:33,316
我们传入 downloader-narrative 的

1313
00:45:33,316 --> 0:45:36,206
schema-ref 和唯一的 id 

1314
00:45:37,896 --> 0:45:40,006
然后我们可以在

1315
00:45:40,136 --> 0:45:42,206
narrative 元素定义中使用它

1316
00:45:44,556 --> 0:45:46,266
在这里我们定义 narrative 

1317
00:45:46,686 --> 0:45:49,006
我们为之前创建的表格

1318
00:45:49,006 --> 0:45:51,466
传入 table-ref

1319
00:45:51,546 --> 0:45:53,766
定义 time-column

1320
00:45:55,616 --> 0:45:55,846
和 narrative-column

1321
00:45:55,936 --> 0:45:57,876
我们已经准备好

1322
00:45:57,876 --> 0:45:58,756
为我们的建模器定义逻辑

1323
00:46:00,256 --> 0:46:01,826
为此 我将创建

1324
00:46:01,826 --> 0:46:03,736
之前在 modeler 定义中

1325
00:46:03,736 --> 0:46:04,766
引用的文件

1326
00:46:05,566 --> 0:46:07,256
为了创建 CLIPS 文件

1327
00:46:07,256 --> 0:46:12,796
前往 “File（文件）”-“New（新建）”

1328
00:46:14,276 --> 0:46:15,786
选择 “macOS” 作为平台 “Other（其他）”部分的

1329
00:46:15,786 --> 0:46:16,366
“CLIPS File（CLIPS 文件）”

1330
00:46:19,196 --> 0:46:27,586
我把名称填好并创建

1331
00:46:27,966 --> 0:46:30,286
下面展示的将是

1332
00:46:30,286 --> 0:46:31,936
检测一个单元

1333
00:46:31,936 --> 0:46:33,486
是否同时执行

1334
00:46:33,486 --> 0:46:34,256
多个请求的算法

1335
00:46:35,046 --> 0:46:37,036
我们将在工作内存中

1336
00:46:37,036 --> 0:46:38,756
追踪每一个作为事实的请求

1337
00:46:39,196 --> 0:46:40,856
首先 我们需要

1338
00:46:41,046 --> 0:46:42,946
为这个事实创建模板

1339
00:46:44,376 --> 0:46:47,696
每个事实都会有

1340
00:46:47,786 --> 0:46:49,996
存储 time

1341
00:46:49,996 --> 0:46:53,236
caller-address 也就是单元地址

1342
00:46:53,236 --> 0:46:56,286
我们捕获到的 signpost-id

1343
00:46:56,286 --> 0:46:57,286
以及我们请求的 image-name

1344
00:46:57,806 --> 0:46:59,796
我们将这个事实叫做 started-download

1345
00:47:01,036 --> 0:47:03,296
然后编写

1346
00:47:03,296 --> 0:47:05,816
在工作内存中 创建此事件的建模器规则

1347
00:47:08,576 --> 0:47:11,676
这个规则查看 os-signpost 表格

1348
00:47:12,536 --> 0:47:15,336
我们指定 subsystem name

1349
00:47:15,426 --> 0:47:18,006
并把 “Begin” 作为 even-type 的值

1350
00:47:18,006 --> 0:47:20,306
并捕获我们想要的所有信息

1351
00:47:21,186 --> 0:47:22,926
我们需要捕获 ?image-name

1352
00:47:22,926 --> 0:47:25,586
?caller-address time 以及 ?identifier

1353
00:47:25,586 --> 0:47:28,956
然后 我们向工作内存判定新的事实

1354
00:47:34,056 --> 0:47:36,676
要在下载完成后清理它

1355
00:47:36,746 --> 0:47:39,406
我们需要从工作内存中

1356
00:47:39,406 --> 0:47:40,666
收回这一事实

1357
00:47:44,426 --> 0:47:46,066
这里我们查看的是同一个表格

1358
00:47:46,066 --> 0:47:48,606
但是我们只查看

1359
00:47:48,866 --> 0:47:51,736
event-type “End”

1360
00:47:52,866 --> 0:47:54,836
我们捕获 signpost 的 identifier

1361
00:47:55,756 --> 0:47:57,426
在这里我们使用的事实

1362
00:47:57,846 --> 0:48:00,096
signpost “Begin” 和 “End”

1363
00:47:57,846 --> 0:48:00,096
signpost “Begin” 和 “End”

1364
00:48:00,136 --> 0:48:01,526
必须有相同的标识符

1365
00:48:02,706 --> 0:48:04,336
我们在工作内存中

1366
00:48:04,566 --> 0:48:07,296
寻找一个具有我们捕获到的

1367
00:48:07,296 --> 0:48:09,726
signpost identifier 的事实

1368
00:48:09,726 --> 0:48:11,346
并收回这个事实

1369
00:48:14,116 --> 0:48:16,286
然后我们可以编写 RECORDER:: 规则

1370
00:48:16,286 --> 0:48:18,976
来生成所有的叙事数据

1371
00:48:24,216 --> 0:48:27,106
这个 RECORDER:: 规则

1372
00:48:27,106 --> 0:48:28,546
查看所有 started-download 事实

1373
00:48:28,726 --> 0:48:29,986
并捕获它们

1374
00:48:30,616 --> 0:48:32,136
我们捕获 time caller-address

1375
00:48:32,136 --> 0:48:33,696
以及 image-name

1376
00:48:34,796 --> 0:48:36,936
如果这里是 true

1377
00:48:37,606 --> 0:48:39,176
有另一个具有相同 caller-address 的

1378
00:48:39,216 --> 0:48:40,996
started-download 事实

1379
00:48:40,996 --> 0:48:42,786
你就可以注意到

1380
00:48:42,786 --> 0:48:44,646
这里引用的变量是相同的

1381
00:48:45,376 --> 0:48:48,616
并且在第一个事实之前发生

1382
00:48:49,606 --> 0:48:51,136
我们注意到

1383
00:48:51,136 --> 0:48:52,326
存在一些反向模式

1384
00:48:52,326 --> 0:48:53,616
而且在请求中存在重叠

1385
00:48:54,716 --> 0:48:56,086
我们可以检查

1386
00:48:56,086 --> 0:48:57,346
是否可以访问

1387
00:48:57,346 --> 0:49:01,386
downloader-narrative Schema

1388
00:48:57,346 --> 0:49:01,386
downloader-narrative Schema

1389
00:49:01,386 --> 0:49:05,766
在其中创建新的行

1390
00:49:05,856 --> 0:49:08,976
将列的时间设置为第一个事实的时间

1391
00:49:08,976 --> 0:49:10,266
并设置列的描述

1392
00:49:11,036 --> 0:49:13,796
你需要输出

1393
00:49:13,796 --> 0:49:15,486
关于这个问题的一些信息

1394
00:49:15,846 --> 0:49:19,216
以便之后有人可以调试它

1395
00:49:19,456 --> 0:49:21,916
现在我可以在 App 上运行 Instruments 

1396
00:49:22,636 --> 0:49:24,956
让我们再次运行它

1397
00:49:32,216 --> 0:49:38,156
再次选择《Trailblazer》网络模板并记录

1398
00:49:38,936 --> 0:49:41,766
我将尝试执行一些

1399
00:49:41,766 --> 0:49:44,976
快速滚动并查看我的叙事表

1400
00:49:49,636 --> 0:49:51,836
你可以看到

1401
00:49:51,886 --> 0:49:53,406
叙事表包含大量

1402
00:49:53,406 --> 0:49:55,066
正在输出的诊断消息

1403
00:49:56,026 --> 0:49:57,706
我们可以看到

1404
00:49:57,706 --> 0:49:59,126
存在一些问题

1405
00:49:59,126 --> 0:49:59,866
之后再研究它们

1406
00:50:00,876 --> 0:50:03,086
你可以看到

1407
00:50:03,176 --> 0:50:04,186
叙事表是可互动的细节视图

1408
00:50:04,876 --> 0:50:06,526
例如 你可以检查

1409
00:50:06,526 --> 0:50:07,746
所有传入的参数

1410
00:50:07,876 --> 0:50:09,066
并进行筛选

1411
00:50:09,496 --> 0:50:11,586
我们可以添加这个调用者地址

1412
00:50:11,586 --> 0:50:13,826
成为一个细节过滤器

1413
00:50:13,826 --> 0:50:15,476
并拥有这个细节过滤器

1414
00:50:17,476 --> 0:50:19,386
现在 让我们请回 Chad

1415
00:50:19,386 --> 0:50:21,146
他将告诉你更多

1416
00:50:21,216 --> 0:50:23,446
关于开发 Instruments 的最佳实践经验

1417
00:50:24,516 --> 0:50:29,896
[ 掌声 ]

1418
00:50:30,396 --> 0:50:30,646
&gt;&gt; 好的

1419
00:50:30,646 --> 0:50:31,326
谢谢 Kacper

1420
00:50:32,076 --> 0:50:34,616
我们已经看到如何在 Instruments 中

1421
00:50:34,616 --> 0:50:37,016
创建一些基本的专家系统

1422
00:50:37,106 --> 0:50:39,656
好的 我们来谈谈

1423
00:50:39,826 --> 0:50:42,316
在这个过程中

1424
00:50:42,316 --> 0:50:43,156
我们学到的一些最佳实践经验

1425
00:50:43,416 --> 0:50:46,796
第一个是

1426
00:50:46,796 --> 0:50:47,986
编写多个 Instrument

1427
00:50:48,236 --> 0:50:49,566
我的意思并不是

1428
00:50:49,566 --> 0:50:50,286
练习编写 Instrument

1429
00:50:50,776 --> 0:50:52,146
而是 如果你

1430
00:50:52,146 --> 0:50:52,926
已经拥有了一个 Instrument

1431
00:50:52,926 --> 0:50:54,096
并且想给它添加一些特性

1432
00:50:54,396 --> 0:50:55,486
有时候 给你的 Instrument

1433
00:50:55,486 --> 0:50:56,826
添加额外的图形或细节

1434
00:50:56,826 --> 0:50:57,826
真的很容易

1435
00:50:57,826 --> 0:50:59,346
但是你应该

1436
00:50:59,346 --> 0:51:00,306
真正地思考

1437
00:50:59,346 --> 0:51:00,306
真正地思考

1438
00:51:00,306 --> 0:51:01,876
这样的话 它还可以成为自身的 Instrument 吗

1439
00:51:02,226 --> 0:51:03,216
这样想的原因是

1440
00:51:03,216 --> 0:51:05,366
如果你创建更细粒度的 Instrument

1441
00:51:05,726 --> 0:51:07,326
你会给这个 Instrument 的用户

1442
00:51:07,326 --> 0:51:08,766
更多的选择

1443
00:51:09,256 --> 0:51:10,686
他们可以从库中

1444
00:51:10,686 --> 0:51:11,716
拖出他们想要的 Instrument

1445
00:51:11,716 --> 0:51:13,156
这将最小化

1446
00:51:13,156 --> 0:51:15,496
对目标的记录影响

1447
00:51:15,876 --> 0:51:17,306
如果你把注意力集中在一个

1448
00:51:17,306 --> 0:51:18,546
有很多功能的 Instrument 上

1449
00:51:18,546 --> 0:51:19,416
那对用户来说 将是一个全盘接受

1450
00:51:19,416 --> 0:51:20,026
与被迫放弃之间的选择

1451
00:51:20,986 --> 0:51:24,616
如果你想创建

1452
00:51:24,616 --> 0:51:26,066
针对某个问题

1453
00:51:26,636 --> 0:51:27,476
的一组 Instrument

1454
00:51:27,476 --> 0:51:29,666
你一定想要看到

1455
00:51:29,666 --> 0:51:31,366
所有这些 Instrument 同时被使用

1456
00:51:31,366 --> 0:51:33,616
那么你所能做的就是

1457
00:51:33,616 --> 0:51:34,976
像我们创建网络模板那样

1458
00:51:35,146 --> 0:51:36,156
创建自己的自定义模板

1459
00:51:36,696 --> 0:51:37,896
所以你要做的应该是

1460
00:51:37,896 --> 0:51:39,486
创建一个文档

1461
00:51:39,486 --> 0:51:42,126
以你想要的方式拖拽 Instrument 配置它们

1462
00:51:42,126 --> 0:51:44,116
进入文件

1463
00:51:44,116 --> 0:51:45,316
然后保存为模板

1464
00:51:45,706 --> 0:51:46,696
然后你就可以在你的包中

1465
00:51:46,696 --> 0:51:48,656
使用那个模板

1466
00:51:48,836 --> 0:51:50,666
同时使用 Kacper

1467
00:51:50,666 --> 0:51:52,496
在我们的网络模板中添加的元素

1468
00:51:53,226 --> 0:51:54,606
使用多种 Instrument 编写

1469
00:51:54,606 --> 0:51:56,486
是使用工具更好的方式

1470
00:51:58,046 --> 0:52:00,336
第二 即时模式很难

1471
00:51:58,046 --> 0:52:00,336
第二 即时模式很难

1472
00:52:01,156 --> 0:52:03,256
即时模式指的是

1473
00:52:03,256 --> 0:52:04,616
Instruments 的记录模式

1474
00:52:04,916 --> 0:52:07,016
它可以在接近实时的时候

1475
00:52:07,016 --> 0:52:08,916
将数据可视化

1476
00:52:08,916 --> 0:52:12,766
有两个原因导致它很难

1477
00:52:12,856 --> 0:52:14,246
第一个原因是

1478
00:52:14,246 --> 0:52:16,006
它需要一些额外的支持

1479
00:52:16,006 --> 0:52:17,176
尽管今天我们很想向你们介绍这点

1480
00:52:17,176 --> 0:52:18,436
但是很遗憾没有办法

1481
00:52:18,436 --> 0:52:19,546
时间有限

1482
00:52:19,956 --> 0:52:20,726
所以我们将会

1483
00:52:20,726 --> 0:52:21,936
为此编写文档

1484
00:52:22,426 --> 0:52:24,156
第二个原因

1485
00:52:24,156 --> 0:52:26,456
也是更重要的原因

1486
00:52:26,456 --> 0:52:29,296
就是区间数据

1487
00:52:29,296 --> 0:52:31,236
区间不能被输入到

1488
00:52:31,236 --> 0:52:32,766
分析核心的表中

1489
00:52:32,766 --> 0:52:34,406
除非它们被关闭

1490
00:52:34,406 --> 0:52:35,316
这意味着这时我们已经

1491
00:52:35,316 --> 0:52:36,346
看到了开始和结束

1492
00:52:36,496 --> 0:52:37,576
所以当你查看

1493
00:52:37,576 --> 0:52:39,386
现场记录的时候

1494
00:52:39,386 --> 0:52:40,696
你会发现一堆所谓的“开区间”

1495
00:52:40,886 --> 0:52:42,216
如果你的建模器

1496
00:52:42,216 --> 0:52:43,506
需要它们作为输入

1497
00:52:43,586 --> 0:52:45,576
这是完全可行的

1498
00:52:45,576 --> 0:52:46,956
而且你会注意到

1499
00:52:46,956 --> 0:52:48,936
如果上游有一个开区间

1500
00:52:48,936 --> 0:52:50,426
那么下游的所有建模器时钟

1501
00:52:50,426 --> 0:52:52,266
都必须停止

1502
00:52:52,266 --> 0:52:53,716
直到那个区间关闭

1503
00:52:53,716 --> 0:52:55,186
因为建模器的视图

1504
00:52:55,186 --> 0:52:56,986
都是按时间排序的

1505
00:52:57,116 --> 0:52:58,796
除非所有的区间

1506
00:52:58,796 --> 0:53:00,196
都被关闭

1507
00:52:58,796 --> 0:53:00,196
都被关闭

1508
00:53:00,196 --> 0:53:01,516
否则无法把时钟向前移动

1509
00:53:02,076 --> 0:53:03,086
所以如果你有一些

1510
00:53:03,086 --> 0:53:04,856
占用时间很长的区间

1511
00:53:04,856 --> 0:53:06,636
你会注意到

1512
00:53:06,636 --> 0:53:08,276
建模器的输出似乎停止了

1513
00:53:08,986 --> 0:53:11,336
当用户点击

1514
00:53:11,626 --> 0:53:13,506
停止记录按钮

1515
00:53:13,556 --> 0:53:14,516
所有的开启的区间都被关闭时

1516
00:53:14,516 --> 0:53:15,836
所有的进程才将正常

1517
00:53:15,976 --> 0:53:17,136
数据也才会涌入

1518
00:53:17,606 --> 0:53:19,036
但这种用户体验并不好

1519
00:53:19,416 --> 0:53:21,676
如果停止录制

1520
00:53:21,676 --> 0:53:22,396
你将有两种选择

1521
00:53:22,396 --> 0:53:24,686
第一个是将 Instruments 退出

1522
00:53:24,686 --> 0:53:26,066
即时模式支持

1523
00:53:26,066 --> 0:53:27,376
为此你可以给你的 Instrument

1524
00:53:27,376 --> 0:53:28,846
添加一个限制元素

1525
00:53:28,916 --> 0:53:31,396
第二个是不再将区间数据

1526
00:53:31,396 --> 0:53:34,096
作为建模器的输入

1527
00:53:34,096 --> 0:53:35,746
就像我们在演示中

1528
00:53:35,746 --> 0:53:38,136
为我们的专家系统

1529
00:53:38,136 --> 0:53:39,856
所做的那样

1530
00:53:39,856 --> 0:53:41,316
我们实际上使用的是

1531
00:53:41,316 --> 0:53:42,746
os-signpost-point 事件

1532
00:53:42,746 --> 0:53:44,176
而不是 os-signpost-interval

1533
00:53:45,316 --> 0:53:47,156
我知道我们让它看起来简单

1534
00:53:47,326 --> 0:53:49,086
但是即时模式实现起来

1535
00:53:49,086 --> 0:53:50,046
确实有点棘手

1536
00:53:50,436 --> 0:53:55,056
第三 非常重要的一点

1537
00:53:55,056 --> 0:53:56,256
如果你要创建的 Instrument

1538
00:53:56,256 --> 0:53:57,046
针对的是

1539
00:53:57,046 --> 0:53:59,156
大量的输入数据

1540
00:53:59,156 --> 0:54:00,646
那么最后 5 秒

1541
00:53:59,156 --> 0:54:00,646
那么最后 5 秒

1542
00:54:00,646 --> 0:54:03,466
记录模式

1543
00:54:03,466 --> 0:54:04,066
是最有效的

1544
00:54:04,346 --> 0:54:05,816
你可以在跟踪文档的

1545
00:54:05,816 --> 0:54:07,256
记录选项中进行切换

1546
00:54:07,256 --> 0:54:08,886
之后你将看到

1547
00:54:08,886 --> 0:54:09,776
你可以在即时 延迟

1548
00:54:09,776 --> 0:54:11,256
和最后 n 秒模式之间

1549
00:54:11,256 --> 0:54:12,676
进行选择

1550
00:54:13,246 --> 0:54:14,486
更加有效的原因是

1551
00:54:14,486 --> 0:54:16,476
它允许记录技术

1552
00:54:16,476 --> 0:54:18,016
使用缓冲

1553
00:54:18,296 --> 0:54:19,666
来提高性能

1554
00:54:19,716 --> 0:54:20,906
这样它就不会一直尝试

1555
00:54:20,906 --> 0:54:22,976
实时向 Instruments 提供数据

1556
00:54:23,376 --> 0:54:24,586
这将产生深远的影响

1557
00:54:24,586 --> 0:54:26,876
它会对 signpost 数据

1558
00:54:26,876 --> 0:54:28,286
产生巨大的影响

1559
00:54:28,286 --> 0:54:29,856
在最后 5 秒模式下

1560
00:54:30,096 --> 0:54:31,756
速度可以提升 10 倍

1561
00:54:32,246 --> 0:54:33,326
当然 为此的权衡是

1562
00:54:33,466 --> 0:54:34,796
你只能看到

1563
00:54:34,796 --> 0:54:37,136
最后 5 秒的数据

1564
00:54:37,296 --> 0:54:39,056
但是对于产生大量

1565
00:54:39,056 --> 0:54:40,736
数据的 Instrument 来说

1566
00:54:40,736 --> 0:54:41,276
这通常是件好事

1567
00:54:41,446 --> 0:54:43,016
这使得它成为

1568
00:54:43,016 --> 0:54:45,346
系统跟踪和 Metal 系统跟踪

1569
00:54:45,346 --> 0:54:46,916
以及游戏性能模板的通用模式

1570
00:54:47,176 --> 0:54:50,066
如果你的目标是这类 App 

1571
00:54:50,066 --> 0:54:51,546
我也会建议

1572
00:54:51,546 --> 0:54:53,136
你的 Instrument 不要支持即时模式

1573
00:54:53,476 --> 0:54:54,506
这样你的用户体验

1574
00:54:54,506 --> 0:54:56,096
就不会很糟糕

1575
00:54:56,096 --> 0:54:58,086
Instruments 在获取数据时

1576
00:54:58,086 --> 0:54:59,236
也不会出现延后

1577
00:54:59,236 --> 0:55:00,746
你在区间中也不会遇到类似的问题

1578
00:54:59,236 --> 0:55:00,746
你在区间中也不会遇到类似的问题

1579
00:55:02,926 --> 0:55:04,326
我们的讨论会差不多结束了

1580
00:55:04,896 --> 0:55:08,026
我们今天谈论很多

1581
00:55:08,026 --> 0:55:09,116
关于创建 Instrument 特性的内容

1582
00:55:09,116 --> 0:55:10,456
我们真的非常兴奋

1583
00:55:10,456 --> 0:55:11,386
因为我们能够

1584
00:55:11,386 --> 0:55:12,306
在今年向你们展示这一切

1585
00:55:12,686 --> 0:55:14,636
我们迫不及待地想知道

1586
00:55:14,636 --> 0:55:15,746
你们能通过 Instruments 创造什么样的成果

1587
00:55:16,146 --> 0:55:17,906
如果你想和我们

1588
00:55:17,906 --> 0:55:18,926
谈谈自定义 Instrument

1589
00:55:18,926 --> 0:55:21,176
我们将在今天下午 3 点

1590
00:55:21,566 --> 0:55:23,986
8 号实验室等待各位

1591
00:55:23,986 --> 0:55:25,916
另外 405 号讨论会详细介绍了

1592
00:55:25,916 --> 0:55:27,256
如何使用 os_signpost API

1593
00:55:27,256 --> 0:55:29,156
你可以通过它将数据输入 Instruments 

1594
00:55:29,856 --> 0:55:30,976
请享受接下来的讨论会

1595
00:55:31,516 --> 0:55:34,500
[ 掌声 ]
