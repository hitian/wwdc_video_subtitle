1
00:00:07,516 --> 0:00:15,500
[ 音乐 ]

2
00:00:21,516 --> 0:00:26,466
[ 掌声 ]

3
00:00:26,966 --> 0:00:27,686
&gt;&gt; 欢迎大家

4
00:00:28,626 --> 0:00:30,496
去年 我们介绍了第二代

5
00:00:30,616 --> 0:00:32,996
Metal 技术 包括了新的用于

6
00:00:32,996 --> 0:00:34,426
图形处理器（GPU）来驱动

7
00:00:34,426 --> 0:00:34,936
渲染管线的方式

8
00:00:36,036 --> 0:00:37,526
今年 我们将带来

9
00:00:37,526 --> 0:00:39,046
更多新鲜的 激动人心的

10
00:00:39,046 --> 0:00:41,046
技术来解决

11
00:00:41,046 --> 0:00:42,026
常见的游戏开发中的挑战

12
00:00:43,086 --> 0:00:44,556
我叫 Brian Ross 

13
00:00:44,556 --> 0:00:45,676
我将和我的同事

14
00:00:46,096 --> 0:00:48,016
Michael Imbrogno 一起来展示

15
00:00:48,016 --> 0:00:49,416
一些新的方式来使你的

16
00:00:49,416 --> 0:00:52,606
App 更好 更快

17
00:00:52,606 --> 0:00:53,266
并且更加有效率

18
00:00:54,776 --> 0:00:57,016
但是首先 我想要谈一谈

19
00:00:57,016 --> 0:00:58,336
那些我们试图去

20
00:00:58,336 --> 0:00:59,426
帮助你们解决的问题

21
00:01:00,806 --> 0:01:02,086
现在大家的游戏

22
00:01:02,086 --> 0:01:03,176
使用了越来越多的

23
00:01:03,176 --> 0:01:05,896
对象 材质 和光线

24
00:01:07,056 --> 0:01:08,706
比如说 游戏“深处”（Inside）

25
00:01:09,156 --> 0:01:10,696
使用了大量的特效

26
00:01:10,696 --> 0:01:12,956
来捕捉和渲染

27
00:01:13,006 --> 0:01:14,316
游戏带来的的情感

28
00:01:16,296 --> 0:01:17,486
制作这样能让你全身心沉浸进去

29
00:01:17,586 --> 0:01:19,606
的游戏是十分有挑战性的

30
00:01:19,606 --> 0:01:21,836
因为它需要高效的

31
00:01:22,006 --> 0:01:23,196
图形处理器（GPU）利用率

32
00:01:23,756 --> 0:01:27,176
同时 游戏也需要

33
00:01:27,176 --> 0:01:28,886
越来越多的 CPU 周期

34
00:01:28,886 --> 0:01:30,436
为激动人心的游戏玩法做支撑

35
00:01:31,026 --> 0:01:33,116
举个例子 游戏古墓丽影

36
00:01:33,116 --> 0:01:34,336
不仅拥有

37
00:01:34,336 --> 0:01:36,256
令人惊叹的风景和

38
00:01:36,256 --> 0:01:38,466
极其细致的地形

39
00:01:38,526 --> 0:01:40,116
他们还在

40
00:01:40,116 --> 0:01:41,946
AI 中管理

41
00:01:41,946 --> 0:01:43,056
复杂的物理仿真

42
00:01:44,066 --> 0:01:45,166
这十分具有挑战性因为

43
00:01:45,166 --> 0:01:47,846
预留了更少的 CPU 时间来实现渲染

44
00:01:49,556 --> 0:01:52,206
最终 开发者们将把

45
00:01:52,206 --> 0:01:55,076
3A 级游戏比如像来自 Epic Games

46
00:01:55,076 --> 0:01:57,456
的《堡垒之夜》移植进

47
00:01:57,456 --> 0:01:59,606
iOS 中 然后你们就

48
00:01:59,606 --> 0:02:02,326
可以在手中玩游戏机级别的游戏了

49
00:01:59,606 --> 0:02:02,326
可以在手中玩游戏机级别的游戏了

50
00:02:02,976 --> 0:02:04,746
这是一个非常惊人的举动

51
00:02:05,496 --> 0:02:06,956
但是它给我们带来了

52
00:02:06,956 --> 0:02:09,336
更多的挑战 比如说像

53
00:02:09,336 --> 0:02:11,456
如何平衡电池的寿命

54
00:02:11,456 --> 0:02:12,326
和帧率之间的关系

55
00:02:12,896 --> 0:02:14,686
现在 让我们来看一看 Metal 技术

56
00:02:14,906 --> 0:02:17,056
是如何帮助我们解决这些挑战

57
00:02:18,656 --> 0:02:21,076
今天 我将要展示给你们如何

58
00:02:21,076 --> 0:02:22,996
在中央处理器（CPU）和图形处理器（GPU）

59
00:02:22,996 --> 0:02:25,806
上利用并行来绘制

60
00:02:25,806 --> 0:02:26,756
更复杂的场景

61
00:02:29,466 --> 0:02:31,386
我们也将会谈到如何对堆

62
00:02:31,386 --> 0:02:33,456
栅栏和事件进行

63
00:02:33,456 --> 0:02:35,306
更加精确的控制

64
00:02:35,596 --> 0:02:36,946
来最优化性能

65
00:02:37,386 --> 0:02:41,116
然后 我将要展示

66
00:02:41,116 --> 0:02:43,366
如何使用我们的最新功能

67
00:02:43,366 --> 0:02:44,816
参数缓冲区和间接命令缓冲区

68
00:02:44,816 --> 0:02:46,656
来构建图形处理器（GPU）

69
00:02:46,656 --> 0:02:47,896
驱动的管线

70
00:02:48,306 --> 0:02:49,656
虽然所有的这些 API 提升

71
00:02:49,656 --> 0:02:51,606
都很关键

72
00:02:51,606 --> 0:02:53,446
但理解支持他们运行的

73
00:02:53,446 --> 0:02:55,026
底层硬件也十分重要

74
00:02:55,866 --> 0:02:57,776
所以接下来

75
00:02:57,776 --> 0:02:59,226
我的同事 Michael 将要给

76
00:02:59,226 --> 0:03:01,126
你们展示如何针对

77
00:02:59,226 --> 0:03:01,126
你们展示如何针对

78
00:03:01,126 --> 0:03:03,086
A11 来进行优化以达到提升性能

79
00:03:03,246 --> 0:03:04,286
延长游戏时间的目的

80
00:03:05,176 --> 0:03:08,616
最后 我很高兴

81
00:03:08,616 --> 0:03:09,756
来自 Epic Games 的 Nick Penwarden

82
00:03:09,756 --> 0:03:12,386
将会加入我们

83
00:03:12,736 --> 0:03:14,366
他将给我们展示

84
00:03:14,366 --> 0:03:15,836
他们是如何运用 Metal 技术使

85
00:03:15,836 --> 0:03:17,736
游戏机级别的游戏可以在

86
00:03:17,736 --> 0:03:18,206
我们的设备上运行

87
00:03:19,216 --> 0:03:23,286
让我们开始吧

88
00:03:23,286 --> 0:03:25,176
利用中央处理器（CPU）和图形处理器（GPU）

89
00:03:25,176 --> 0:03:27,526
并行可能是

90
00:03:27,526 --> 0:03:28,816
你可以做到的最重要

91
00:03:28,816 --> 0:03:32,116
也是最简单的优化

92
00:03:32,116 --> 0:03:33,346
在单线程上构建

93
00:03:33,346 --> 0:03:35,476
命令流已经不能满足现在的要求了

94
00:03:36,266 --> 0:03:38,076
最新款的 iPhone 拥有 6 个内核

95
00:03:38,356 --> 0:03:40,476
而 iMac Pro 拥有多达 18 个内核

96
00:03:41,186 --> 0:03:42,876
因此 可扩展的多线程

97
00:03:42,876 --> 0:03:45,856
架构是我们所有设备

98
00:03:45,856 --> 0:03:49,896
拥有卓越表现的关键

99
00:03:49,896 --> 0:03:51,286
Metal 技术是为了

100
00:03:51,286 --> 0:03:51,936
多线程而设计的

101
00:03:51,936 --> 0:03:53,736
我将先向你们展示在中央处理器（CPU）

102
00:03:53,736 --> 0:03:55,966
进行并行操作的两种方法

103
00:03:55,966 --> 0:03:56,826
接下来我将展示 Metal 科技是

104
00:03:56,826 --> 0:03:58,526
如何在图形处理器（GPU）上

105
00:03:58,526 --> 0:04:00,036
自动进行并行的

106
00:03:58,526 --> 0:04:00,036
自动进行并行的

107
00:04:00,036 --> 0:04:01,346
作为本节的结尾

108
00:04:02,606 --> 0:04:04,426
我们来举一个典型的

109
00:04:04,466 --> 0:04:05,726
游戏架构的例子

110
00:04:06,816 --> 0:04:08,486
使用经典的单线程

111
00:04:08,486 --> 0:04:10,026
渲染 [ 音质不清晰 ]

112
00:04:10,156 --> 0:04:13,146
你会将图形处理器（GPU）命令和

113
00:04:13,146 --> 0:04:14,826
图形处理器（GPU）执行依次在单个

114
00:04:14,826 --> 0:04:15,446
命令缓冲区内构建

115
00:04:16,446 --> 0:04:17,596
通常情况下 你将会把这个时间

116
00:04:17,596 --> 0:04:18,995
匹配到适合你的

117
00:04:18,995 --> 0:04:20,266
帧时间当中

118
00:04:21,016 --> 0:04:22,766
而且当然 你将得到

119
00:04:22,766 --> 0:04:24,486
最长的延迟时间

120
00:04:24,486 --> 0:04:26,096
由于整个命令缓冲区必须在

121
00:04:26,096 --> 0:04:28,036
图形处理器（GPU）可以使用之前

122
00:04:28,036 --> 0:04:29,086
进行编码

123
00:04:29,436 --> 0:04:30,586
显然 有更好的方法可以来

124
00:04:30,586 --> 0:04:32,366
做到这一点 

125
00:04:32,366 --> 0:04:34,346
所以我们要做的就是

126
00:04:34,346 --> 0:04:35,976
和中央处理器（CPU）一起

127
00:04:36,056 --> 0:04:36,546
进行并行构建

128
00:04:37,036 --> 0:04:41,766
渲染和计算传递

129
00:04:41,766 --> 0:04:43,156
是 Metal 技术中多线程操作

130
00:04:43,156 --> 0:04:44,146
的基本粒度

131
00:04:45,046 --> 0:04:46,376
所有你需要做的

132
00:04:46,376 --> 0:04:48,616
就是创建多个命令缓冲区

133
00:04:48,616 --> 0:04:50,326
并在单独的线程上

134
00:04:50,326 --> 0:04:51,806
分别对不同的通道进行编码

135
00:04:52,356 --> 0:04:55,226
你可以按照任何你希望的顺序

136
00:04:55,226 --> 0:04:55,806
对它们进行编码

137
00:04:56,236 --> 0:04:57,856
最终的执行顺序

138
00:04:57,856 --> 0:04:59,156
取决于它们添加到

139
00:04:59,156 --> 0:05:00,216
命令队列的先后

140
00:04:59,156 --> 0:05:00,216
命令队列的先后

141
00:05:01,026 --> 0:05:02,696
所以 现在让我们来看一看

142
00:05:02,696 --> 0:05:04,316
在代码中这是多么容易实现

143
00:05:04,316 --> 0:05:09,606
你可以看到这并不需要很多代码

144
00:05:10,136 --> 0:05:11,016
你要做的第一件事是

145
00:05:11,016 --> 0:05:13,816
从队列中创建

146
00:05:13,816 --> 0:05:15,146
任意数量的命令缓冲区

147
00:05:16,346 --> 0:05:19,126
接下来 我们将通过使用

148
00:05:19,126 --> 0:05:21,456
enqueue 接口来提前定义

149
00:05:21,456 --> 0:05:22,846
图形处理器（GPU）的执行顺序

150
00:05:23,366 --> 0:05:25,526
这非常棒 因为

151
00:05:25,526 --> 0:05:27,076
你可以在不用等待命令缓冲区

152
00:05:27,076 --> 0:05:28,746
首先 被编码的情况下完成所有操作

153
00:05:29,436 --> 0:05:31,906
最后 我们将为

154
00:05:31,906 --> 0:05:33,696
每个部分创建

155
00:05:33,696 --> 0:05:35,536
单独的线程和调用编码函数

156
00:05:35,826 --> 0:05:36,506
这就是全部了

157
00:05:36,966 --> 0:05:37,996
这就是你需要做的内容

158
00:05:38,566 --> 0:05:40,186
它非常快速 非常

159
00:05:40,186 --> 0:05:41,446
高效 而且非常简单

160
00:05:42,136 --> 0:05:43,516
所以现在 让我们回到

161
00:05:43,516 --> 0:05:45,896
前面的图表 看一下另一个例子

162
00:05:46,246 --> 0:05:49,166
就像你所看到的 我们能够在

163
00:05:49,166 --> 0:05:51,356
中央处理器（CPU）上执行很好的

164
00:05:51,356 --> 0:05:54,196
并行操作 但是如果

165
00:05:54,196 --> 0:05:58,826
你有一个非常长的渲染通道呢

166
00:05:58,826 --> 0:06:01,036
在这种情况下 Metal 技术

167
00:05:58,826 --> 0:06:01,036
在这种情况下 Metal 技术

168
00:06:01,036 --> 0:06:02,726
使用了一个专用的并行编码器

169
00:06:02,766 --> 0:06:04,986
它允许你在多个线程上

170
00:06:04,986 --> 0:06:06,586
进行编码 并且无需

171
00:06:06,586 --> 0:06:08,266
明确划分

172
00:06:08,266 --> 0:06:10,026
渲染通道或命令缓冲区

173
00:06:10,686 --> 0:06:12,286
所以现在 让我们来看一看它

174
00:06:12,286 --> 0:06:13,786
在你的代码里有多简单

175
00:06:14,866 --> 0:06:17,106
它看起来非常像之前的例子

176
00:06:17,776 --> 0:06:18,956
你要做的第一件事就是

177
00:06:18,956 --> 0:06:21,066
创建一个并行编码器

178
00:06:21,606 --> 0:06:23,776
并且从这个并行编码器中

179
00:06:23,776 --> 0:06:25,386
创建任意数量的从属编码器

180
00:06:25,436 --> 0:06:27,066
很重要的一点是意识到

181
00:06:27,066 --> 0:06:28,146
这实际上就是你

182
00:06:28,146 --> 0:06:29,976
定义图形处理器（GPU）执行顺序的地方

183
00:06:32,026 --> 0:06:35,356
接下来 我们将创建

184
00:06:35,356 --> 0:06:37,736
单独的线程并单独对

185
00:06:37,776 --> 0:06:40,406
我们的每个 G 缓冲（G-buffer）函数进行编码

186
00:06:40,966 --> 0:06:44,956
最后 我们会设置一个

187
00:06:44,956 --> 0:06:46,286
通知 当线程

188
00:06:46,286 --> 0:06:48,726
完成时 我们可以在

189
00:06:48,726 --> 0:06:50,296
并行编码器上调用结束编码

190
00:06:50,296 --> 0:06:50,926
这就是全部了

191
00:06:51,186 --> 0:06:52,866
这就是你并行化渲染通道

192
00:06:52,866 --> 0:06:54,416
所需要做的全部内容

193
00:06:54,486 --> 0:06:55,606
它非常快速

194
00:06:55,606 --> 0:06:56,206
而且非常简单

195
00:06:56,206 --> 0:06:58,126
现在我已经向你展示了两种在

196
00:06:58,126 --> 0:06:59,886
中央处理器（CPU）上并行化的方法

197
00:07:00,836 --> 0:07:01,986
现在让我们看看 Metal 技术

198
00:07:01,986 --> 0:07:02,766
如何在图形处理器（GPU）上

199
00:07:02,766 --> 0:07:04,366
为你进行自动并行化

200
00:07:04,946 --> 0:07:07,316
所以让我们先从头看一下

201
00:07:07,316 --> 0:07:10,176
一个框架示例 然后看一看

202
00:07:10,176 --> 0:07:12,316
图形处理器（GPU）如何执行这个框架

203
00:07:13,296 --> 0:07:14,546
基于你平台的功能

204
00:07:14,546 --> 0:07:17,006
Metal 技术可以通过

205
00:07:17,006 --> 0:07:19,376
分析数据相关性

206
00:07:19,376 --> 0:07:20,956
自动提取并行性

207
00:07:21,576 --> 0:07:22,746
现在让我们看一看这些相关性

208
00:07:22,746 --> 0:07:23,376
当中的 2 个

209
00:07:24,726 --> 0:07:26,436
在这个例子中 粒子模拟会

210
00:07:26,436 --> 0:07:28,416
写入数据 而这些数据稍后

211
00:07:28,416 --> 0:07:30,116
将会被效果用来

212
00:07:30,316 --> 0:07:31,456
渲染粒子

213
00:07:32,816 --> 0:07:35,586
类似地 G 缓冲（G-buffer）通道

214
00:07:36,106 --> 0:07:37,796
生成几何图形 稍后将会通过

215
00:07:37,796 --> 0:07:38,916
延迟着色过程

216
00:07:38,916 --> 0:07:43,256
来计算材质的明暗

217
00:07:43,486 --> 0:07:45,216
所有这些信息都

218
00:07:45,216 --> 0:07:46,686
允许 Metal 技术自动

219
00:07:46,686 --> 0:07:49,276
并且便宜地识别

220
00:07:49,816 --> 0:07:51,236
可以并行运行的整个通道

221
00:07:51,236 --> 0:07:52,416
例如使用异步计算

222
00:07:55,616 --> 0:07:57,896
所以你可以在

223
00:07:57,936 --> 0:08:00,166
图形处理器（GPU）上获得免费的并

224
00:07:57,936 --> 0:08:00,166
图形处理器（GPU）上获得免费的并

225
00:08:00,166 --> 0:08:00,786
行和异步计算

226
00:08:01,256 --> 0:08:02,436
它是免费的原因是

227
00:08:02,436 --> 0:08:03,446
Metal 技术不需要你

228
00:08:03,446 --> 0:08:04,486
做任何特别的事情

229
00:08:04,486 --> 0:08:07,366
我认为我们都喜欢

230
00:08:07,366 --> 0:08:09,096
在图形处理器（GPU）上获得免费优化

231
00:08:09,726 --> 0:08:10,896
但有时候作为一名

232
00:08:10,896 --> 0:08:13,346
开发人员 你可能需要走得

233
00:08:13,346 --> 0:08:14,136
更远一点

234
00:08:14,786 --> 0:08:16,506
所以对于你代码中最关键的部分

235
00:08:16,506 --> 0:08:18,286
Metal 技术允许你

236
00:08:18,316 --> 0:08:20,646
逐步控制一些更深层次的内容

237
00:08:21,126 --> 0:08:23,546
例如 你可以禁用

238
00:08:23,546 --> 0:08:25,056
自动引用计数并

239
00:08:25,056 --> 0:08:27,286
自己执行以节省中央处理器（CPU）时间

240
00:08:28,116 --> 0:08:30,266
你也可以使用 Metal 堆

241
00:08:30,626 --> 0:08:33,466
来真正低消耗地严格控制分配

242
00:08:33,956 --> 0:08:36,616
并且 Metal 堆可以

243
00:08:36,616 --> 0:08:39,025
由栅栏和事件补充 这可以让你

244
00:08:39,025 --> 0:08:41,126
明确控制图形处理器（GPU）

245
00:08:41,126 --> 0:08:42,316
的并行操作

246
00:08:44,376 --> 0:08:46,736
许多游戏使用

247
00:08:46,736 --> 0:08:48,906
大量的资源 这可能需要花费高昂的代价

248
00:08:49,476 --> 0:08:51,526
分配需要不断和 OS

249
00:08:51,526 --> 0:08:54,076
进行双向沟通 OS 系统必须映射

250
00:08:54,076 --> 0:08:56,096
并初始化每个请求的内存

251
00:08:56,876 --> 0:08:58,066
如果你的游戏使用临时

252
00:08:58,066 --> 0:08:59,606
渲染目标 这些

253
00:08:59,606 --> 0:09:00,796
分配可能发生在

254
00:08:59,606 --> 0:09:00,796
分配可能发生在

255
00:09:00,796 --> 0:09:02,866
你的框架中间 造成卡顿

256
00:09:03,726 --> 0:09:05,156
资源堆是解决

257
00:09:05,256 --> 0:09:06,396
这个问题的好方法

258
00:09:07,556 --> 0:09:08,786
堆也可以让你提前从

259
00:09:09,386 --> 0:09:12,196
系统中分配大量内存

260
00:09:12,456 --> 0:09:13,566
然后 你就可以在

261
00:09:13,606 --> 0:09:14,966
这些内存上添加或删除纹理

262
00:09:14,966 --> 0:09:16,546
和缓冲区 而无需进行

263
00:09:16,546 --> 0:09:18,286
任何昂贵的双向沟通

264
00:09:18,836 --> 0:09:20,836
因此 从分配

265
00:09:20,836 --> 0:09:22,996
3 种常规纹理的情况开始

266
00:09:23,866 --> 0:09:25,406
Metal 技术通常将这些放到

267
00:09:25,406 --> 0:09:27,876
3 个单独的分配中 但是

268
00:09:27,986 --> 0:09:29,776
将这些全部分配到

269
00:09:29,776 --> 0:09:31,976
单个堆中可以让你

270
00:09:31,976 --> 0:09:34,396
提前在堆创建时执行

271
00:09:34,396 --> 0:09:35,286
所有的内存分配

272
00:09:35,696 --> 0:09:37,456
那么创建纹理

273
00:09:37,456 --> 0:09:39,296
将会变得非常低耗

274
00:09:40,506 --> 0:09:42,956
另外 堆有时可以

275
00:09:42,956 --> 0:09:44,836
通过使分配更紧密

276
00:09:45,206 --> 0:09:47,286
来更有效地使用空间

277
00:09:48,396 --> 0:09:50,696
因此在使用传统模型时

278
00:09:50,696 --> 0:09:51,886
你将取消分配纹理

279
00:09:52,736 --> 0:09:53,836
将页释放回系统

280
00:09:53,836 --> 0:09:55,836
然后重新分配

281
00:09:56,536 --> 0:09:57,796
重新分配将再一次分配

282
00:09:57,796 --> 0:09:58,976
一组新的纹理

283
00:09:59,476 --> 0:10:02,006
通过使用堆 你可以取消分配和

284
00:09:59,476 --> 0:10:02,006
通过使用堆 你可以取消分配和

285
00:10:02,006 --> 0:10:04,436
重新分配资源 而无需任何昂贵的

286
00:10:04,436 --> 0:10:06,226
和系统进行的双向沟通

287
00:10:08,156 --> 0:10:09,846
最后 堆也可以让你

288
00:10:09,846 --> 0:10:12,406
互相分享不同的内存资源

289
00:10:14,086 --> 0:10:15,376
这在当你的

290
00:10:15,376 --> 0:10:16,916
游戏框架有很多

291
00:10:16,916 --> 0:10:18,166
临时渲染目标时非常有用

292
00:10:18,686 --> 0:10:19,846
没有理由让这些目标

293
00:10:19,846 --> 0:10:21,276
不断地占用不同的内存

294
00:10:21,276 --> 0:10:23,696
所以你可以替换入口

295
00:10:23,696 --> 0:10:25,546
并省下数百兆字节

296
00:10:26,236 --> 0:10:28,376
现在 在替换入口的方式中

297
00:10:28,376 --> 0:10:30,666
分配速度更快 但在

298
00:10:30,666 --> 0:10:31,996
涉及相关性跟踪时 它并不是

299
00:10:31,996 --> 0:10:32,946
完全没有影响的

300
00:10:33,466 --> 0:10:34,536
让我们回到

301
00:10:34,536 --> 0:10:35,546
框架示例来进行

302
00:10:35,546 --> 0:10:36,306
更好的解释

303
00:10:38,356 --> 0:10:40,786
当使用了堆时

304
00:10:40,786 --> 0:10:42,556
Metal 技术就看不到单个的资源

305
00:10:42,556 --> 0:10:43,346
因此它不能

306
00:10:43,586 --> 0:10:44,956
自动识别通道之间

307
00:10:44,956 --> 0:10:46,236
的读写相关性

308
00:10:46,236 --> 0:10:48,366
例如示例中的

309
00:10:48,366 --> 0:10:49,946
G 缓冲（G-buffer）和延期着色通道

310
00:10:51,056 --> 0:10:53,516
所以你必须使用栅栏

311
00:10:53,516 --> 0:10:55,076
来明确地标记哪个

312
00:10:55,136 --> 0:10:57,276
通道产生数据 哪个通道

313
00:10:57,386 --> 0:10:58,286
消耗数据

314
00:10:58,906 --> 0:11:00,856
在这个例子中 G 缓冲（G-buffer） 

315
00:10:58,906 --> 0:11:00,856
在这个例子中 G 缓冲（G-buffer） 

316
00:11:00,856 --> 0:11:02,576
更新了栅栏 并且

317
00:11:02,576 --> 0:11:03,766
延迟着色等待着它的结果

318
00:11:04,686 --> 0:11:08,266
所以现在 让我们来看一看

319
00:11:08,266 --> 0:11:09,406
如何在你的代码中应用

320
00:11:09,406 --> 0:11:10,966
这些基本概念

321
00:11:12,856 --> 0:11:15,206
我们要做的第一件事

322
00:11:15,206 --> 0:11:16,006
就是将这个

323
00:11:16,006 --> 0:11:17,456
应用到我们的 G 缓冲（G-buffer）和

324
00:11:17,456 --> 0:11:18,676
延迟着色示例中

325
00:11:19,966 --> 0:11:21,356
首先 我们将

326
00:11:21,356 --> 0:11:23,046
从堆中分配我们的

327
00:11:23,046 --> 0:11:23,436
临时渲染目标

328
00:11:23,806 --> 0:11:24,866
这看起来非常像

329
00:11:24,866 --> 0:11:26,046
今天在分配纹理时可能

330
00:11:26,046 --> 0:11:28,706
已经做的事情

331
00:11:28,846 --> 0:11:31,056
接下来 我们将渲染

332
00:11:31,056 --> 0:11:32,246
该临时渲染目标

333
00:11:33,166 --> 0:11:35,646
最后 在分段阶段

334
00:11:36,316 --> 0:11:38,216
完成后更新栅栏

335
00:11:38,386 --> 0:11:39,526
这将确保所有数据

336
00:11:39,526 --> 0:11:41,656
在下一个通道使用它

337
00:11:41,656 --> 0:11:42,956
之前生成

338
00:11:43,706 --> 0:11:45,876
现在 让我们切换到

339
00:11:45,876 --> 0:11:47,356
延迟着色过程

340
00:11:48,156 --> 0:11:49,936
我们将使用

341
00:11:49,936 --> 0:11:51,346
这个临时渲染目标来

342
00:11:51,346 --> 0:11:52,606
计算材质的明暗

343
00:11:54,836 --> 0:11:56,196
然后 我们将等待栅栏

344
00:11:56,196 --> 0:11:57,986
来确保它在我们使用

345
00:11:58,046 --> 0:11:59,566
之前已经生产完成了

346
00:12:00,486 --> 0:12:03,486
最后 资源是可以替换的

347
00:12:03,486 --> 0:12:05,046
这样我们就可以重新使用它来

348
00:12:05,046 --> 0:12:06,456
进行其他操作

349
00:12:06,456 --> 0:12:07,816
节省数百兆字节

350
00:12:08,916 --> 0:12:09,886
现在我们已经讨论了

351
00:12:09,886 --> 0:12:11,866
如何通过明确的控制

352
00:12:11,906 --> 0:12:13,196
来进行并行化和优化性能

353
00:12:13,196 --> 0:12:16,126
这非常棒 但是

354
00:12:16,126 --> 0:12:18,696
如果你想让 GPU 更多地进入

355
00:12:18,696 --> 0:12:19,526
参与这个过程呢

356
00:12:20,936 --> 0:12:25,566
那么接下来我们来讨论一下 GPU 驱动的管线

357
00:12:25,626 --> 0:12:27,356
你们的游戏正在将越来

358
00:12:27,356 --> 0:12:29,816
越多的决策逻辑

359
00:12:30,356 --> 0:12:32,556
转移到 GPU 上 尤其是当在

360
00:12:32,556 --> 0:12:34,036
处理包含数千个

361
00:12:34,036 --> 0:12:36,046
对象的超大型数据集

362
00:12:36,046 --> 0:12:37,556
或场景图时

363
00:12:38,666 --> 0:12:41,376
Metal 二代技术使

364
00:12:41,496 --> 0:12:43,226
我们在 GPU 驱动管线

365
00:12:43,226 --> 0:12:45,236
方面又迈出了重要一步

366
00:12:46,236 --> 0:12:47,506
去年 我们引入了

367
00:12:47,606 --> 0:12:49,086
间接参数缓冲区

368
00:12:49,516 --> 0:12:51,386
这可以进一步降低

369
00:12:51,386 --> 0:12:53,336
CPU 使用率 并将大部分

370
00:12:53,336 --> 0:12:55,166
工作量转移到 GPU 上

371
00:12:56,046 --> 0:12:57,056
今年 我们再一次引入了

372
00:12:57,056 --> 0:12:59,346
间接命令缓冲区

373
00:12:59,346 --> 0:13:02,566
这将允许你将

374
00:12:59,346 --> 0:13:02,566
这将允许你将

375
00:13:02,566 --> 0:13:05,526
整个渲染循环转移到 GPU 上

376
00:13:06,776 --> 0:13:09,046
首先 让我们简要回顾一下

377
00:13:09,146 --> 0:13:10,236
参数缓冲区的功能

378
00:13:11,076 --> 0:13:12,826
参数缓冲区就是像大屏幕上

379
00:13:12,826 --> 0:13:16,386
呈现的这样一个结构

380
00:13:17,756 --> 0:13:18,946
以前这里

381
00:13:18,946 --> 0:13:20,026
只有常量 但有了

382
00:13:20,026 --> 0:13:21,256
参数缓冲区 我们可以拥有

383
00:13:21,326 --> 0:13:22,916
纹理和采样器

384
00:13:23,606 --> 0:13:24,716
在一切之前 这些必须具有

385
00:13:24,716 --> 0:13:26,646
独立的着色器绑定点

386
00:13:27,666 --> 0:13:30,226
但是由于这种结构

387
00:13:30,226 --> 0:13:31,366
你可以在你的处理中

388
00:13:31,366 --> 0:13:32,646
使用 Metal 着色语言的所有

389
00:13:32,646 --> 0:13:34,216
功能 因此它非常

390
00:13:34,216 --> 0:13:35,906
灵活并且非常简单

391
00:13:36,196 --> 0:13:37,156
你可以执行像添加

392
00:13:37,156 --> 0:13:39,476
子结构或数组甚至

393
00:13:39,476 --> 0:13:41,476
是指向其他参数缓冲区的指针的操作

394
00:13:43,156 --> 0:13:44,556
你可以修改纹理和

395
00:13:44,556 --> 0:13:46,856
采样器 在 GPU 上创建

396
00:13:46,856 --> 0:13:49,516
新材质并且无需 CPU 参与

397
00:13:50,766 --> 0:13:52,746
或者 你可以制作巨大的

398
00:13:52,746 --> 0:13:54,446
材质数组 并且使用

399
00:13:54,446 --> 0:13:56,886
单实例绘图调用

400
00:13:56,886 --> 0:13:58,956
来呈现许多具有独特属性的对象

401
00:14:00,466 --> 0:14:02,346
参数缓冲区允许你将

402
00:14:02,986 --> 0:14:04,536
材质管理卸载到

403
00:14:05,176 --> 0:14:08,366
GPU 上并节省宝贵的 CPU 资源

404
00:14:08,916 --> 0:14:10,206
但今年 我们把它稍微扩展了

405
00:14:10,206 --> 0:14:11,546
一点 再稍稍

406
00:14:11,546 --> 0:14:13,436
扩展了一点

407
00:14:13,926 --> 0:14:15,506
我们开始加入 2 个新的

408
00:14:15,506 --> 0:14:16,516
参数类型

409
00:14:17,426 --> 0:14:19,046
它们包括管线状态和

410
00:14:19,156 --> 0:14:20,126
命令缓冲区

411
00:14:21,056 --> 0:14:22,646
现在 这些将用于

412
00:14:22,646 --> 0:14:24,226
支持我们全新的

413
00:14:24,226 --> 0:14:24,836
间接命令缓冲区功能

414
00:14:26,116 --> 0:14:27,916
通过间接命令缓冲区

415
00:14:27,916 --> 0:14:30,956
你可以在 GPU 上编码整个场景

416
00:14:31,506 --> 0:14:33,066
在 CPU 上 你只有几个线程

417
00:14:33,066 --> 0:14:34,426
可用于渲染

418
00:14:34,866 --> 0:14:35,936
但是在 GPU 上

419
00:14:35,936 --> 0:14:37,986
你拥有数百甚至

420
00:14:37,986 --> 0:14:40,976
数千个可以同时运行的线程

421
00:14:41,716 --> 0:14:42,856
通过间接命令缓冲区

422
00:14:42,856 --> 0:14:44,416
你可以充分利用这种

423
00:14:44,416 --> 0:14:45,916
大规模的并行性质

424
00:14:47,236 --> 0:14:49,186
此外 间接命令缓冲区是

425
00:14:49,186 --> 0:14:51,376
完全可以复用的

426
00:14:51,376 --> 0:14:52,556
因此你可以只花费

427
00:14:52,556 --> 0:14:55,196
一次编码成本 然后不断重复使用它

428
00:14:55,886 --> 0:14:57,626
由于 ICB 是一个可直接

429
00:14:57,716 --> 0:15:00,276
访问的缓冲区 因此你可以

430
00:14:57,716 --> 0:15:00,276
访问的缓冲区 因此你可以

431
00:15:00,276 --> 0:15:01,836
随时修改它的内容

432
00:15:02,086 --> 0:15:03,976
例如更改着色器类型

433
00:15:03,976 --> 0:15:05,276
或相机矩阵 或者其他

434
00:15:05,276 --> 0:15:06,606
任何你可能需要更改的内容

435
00:15:07,036 --> 0:15:09,476
当然 通过将渲染

436
00:15:09,476 --> 0:15:11,566
转移到 GPU 上

437
00:15:11,566 --> 0:15:13,886
你可以移除昂贵的 CPU

438
00:15:13,886 --> 0:15:15,216
和 GPU 同步点 这些

439
00:15:15,216 --> 0:15:17,126
同步点通常需要提交数据给它们

440
00:15:18,346 --> 0:15:19,636
让我们来看一个例子

441
00:15:20,706 --> 0:15:23,186
这是一个典型的游戏框架

442
00:15:23,646 --> 0:15:24,856
一般的渲染循环有

443
00:15:24,856 --> 0:15:26,366
常见的几个阶段

444
00:15:27,046 --> 0:15:29,066
首先 你通过浏览

445
00:15:29,246 --> 0:15:30,806
场景图来确定哪些对象

446
00:15:30,806 --> 0:15:31,456
需要被渲染

447
00:15:32,016 --> 0:15:34,836
你可能使用

448
00:15:34,886 --> 0:15:36,226
视锥体剔除来确定

449
00:15:36,226 --> 0:15:37,236
视锥体内的物体

450
00:15:38,016 --> 0:15:39,266
你们中的一些人可能会

451
00:15:39,266 --> 0:15:41,486
使用更加复杂的方法来解决

452
00:15:41,486 --> 0:15:42,206
遮挡问题

453
00:15:42,576 --> 0:15:44,956
此外细节选择的程度自然

454
00:15:45,056 --> 0:15:46,816
而然地产生在这个阶段

455
00:15:47,576 --> 0:15:49,326
只有当你编码并

456
00:15:49,326 --> 0:15:51,176
提交命令缓冲区后 GPU 才会

457
00:15:51,176 --> 0:15:55,136
开始使用它

458
00:15:55,816 --> 0:15:57,356
越来越多的游戏正在将

459
00:15:57,356 --> 0:15:58,776
确定可见对象的过程

460
00:15:58,776 --> 0:16:00,496
转移到 GPU 上

461
00:15:58,776 --> 0:16:00,496
转移到 GPU 上

462
00:16:01,306 --> 0:16:03,236
GPU 在处理最近游戏中出现的

463
00:16:03,476 --> 0:16:04,906
越来越复杂的场景方面

464
00:16:04,906 --> 0:16:05,796
做得更好

465
00:16:06,936 --> 0:16:09,526
不幸的是 这会在你的框架中

466
00:16:09,526 --> 0:16:10,816
创建一个同步点

467
00:16:12,456 --> 0:16:14,486
而且它使得 CPU 不能对

468
00:16:14,486 --> 0:16:16,266
绘制调用进行编码直到

469
00:16:16,266 --> 0:16:17,996
GPU 产生数据

470
00:16:18,466 --> 0:16:19,826
在不浪费宝贵的

471
00:16:19,826 --> 0:16:21,436
CPU 和 GPU 同步时间的情况下

472
00:16:21,436 --> 0:16:24,636
完成该任务是极其困难的

473
00:16:25,716 --> 0:16:28,216
ICB 的好处是巨大的

474
00:16:28,726 --> 0:16:30,176
你不仅可以将最后的处理

475
00:16:30,176 --> 0:16:32,086
转移到 GPU 上 还可以

476
00:16:32,646 --> 0:16:34,176
自然移除任何

477
00:16:34,176 --> 0:16:35,426
交换数据所需的

478
00:16:35,426 --> 0:16:37,766
同步点 并且提高 CPU 和 GPU

479
00:16:37,806 --> 0:16:39,076
的利用率

480
00:16:39,706 --> 0:16:42,116
同时 你可以把

481
00:16:42,116 --> 0:16:43,886
CPU 开销降至一个常量

482
00:16:44,566 --> 0:16:47,086
所以让我们来看一下

483
00:16:47,086 --> 0:16:48,136
编码的细节

484
00:16:49,166 --> 0:16:51,806
我将首先使用前面的

485
00:16:51,806 --> 0:16:53,566
例子来看一看

486
00:16:53,566 --> 0:16:55,316
只有 GPU 可以提供的

487
00:16:55,316 --> 0:16:57,216
大规模并行化

488
00:16:57,876 --> 0:16:59,736
我们从剔除调度中的

489
00:16:59,736 --> 0:17:03,076
可见对象列表和 LOD 开始

490
00:16:59,736 --> 0:17:03,076
可见对象列表和 LOD 开始

491
00:17:03,796 --> 0:17:05,165
另外 请记住

492
00:17:05,165 --> 0:17:07,066
我们正在使用参数缓冲区的能力

493
00:17:07,896 --> 0:17:09,866
所以在这种情况下

494
00:17:10,266 --> 0:17:12,816
每个元素都有一个

495
00:17:12,816 --> 0:17:14,165
指向实际属性的指针 所以

496
00:17:14,165 --> 0:17:15,496
我们不需要将所有内容都存储在

497
00:17:15,496 --> 0:17:15,896
同一个缓冲区内

498
00:17:17,736 --> 0:17:20,136
这种方式为我们

499
00:17:20,136 --> 0:17:21,906
节省了大量的内存和性能

500
00:17:22,116 --> 0:17:23,726
这是因为我们只构建了

501
00:17:23,726 --> 0:17:25,126
一小部分信息

502
00:17:25,896 --> 0:17:27,026
实际参数缓冲区

503
00:17:27,026 --> 0:17:29,866
包含几个级别的几何细节

504
00:17:30,936 --> 0:17:33,726
它们包括位置

505
00:17:33,726 --> 0:17:35,406
顶点缓冲区 索引缓冲区

506
00:17:35,406 --> 0:17:36,626
和材质参数缓冲区

507
00:17:37,256 --> 0:17:39,486
关于渲染 我们只选择每个对象的

508
00:17:39,876 --> 0:17:41,206
多个 LOD 中的一个

509
00:17:41,836 --> 0:17:45,026
实际的编码发生在

510
00:17:45,026 --> 0:17:47,126
一个计算内核中 我们把它

511
00:17:47,126 --> 0:17:48,716
编码成一个间接命令缓冲区

512
00:17:49,826 --> 0:17:51,716
计算内核的每个

513
00:17:51,716 --> 0:17:53,756
线程都编码一个绘制调用

514
00:17:54,226 --> 0:17:55,976
所以我们读取对象

515
00:17:55,976 --> 0:17:58,756
具有的所有属性 并将它们编码

516
00:17:58,756 --> 0:18:00,526
到 ICB 中

517
00:17:58,756 --> 0:18:00,526
到 ICB 中

518
00:18:01,336 --> 0:18:03,216
这里有一些值得

519
00:18:03,216 --> 0:18:03,936
注意的细节

520
00:18:04,336 --> 0:18:06,036
你可以把 ICB 视为

521
00:18:06,036 --> 0:18:07,196
一系列渲染命令

522
00:18:07,796 --> 0:18:09,156
一个渲染命令包含

523
00:18:09,156 --> 0:18:10,716
带有着色器的管线对象

524
00:18:11,136 --> 0:18:12,846
任意数量的缓冲区

525
00:18:12,846 --> 0:18:14,466
和绘制调用

526
00:18:14,736 --> 0:18:16,366
然后 ICB 是为并行

527
00:18:16,366 --> 0:18:18,446
而构建的 因此你可以同时进行编码

528
00:18:18,446 --> 0:18:20,256
并且不用担心顺序

529
00:18:20,756 --> 0:18:23,316
最后 我们使 API 保持

530
00:18:23,316 --> 0:18:25,126
简单 所以以上这些操作

531
00:18:25,126 --> 0:18:26,836
就像你今天在可能在 CPU 上所做的一样

532
00:18:28,116 --> 0:18:29,886
另外 每个命令

533
00:18:29,886 --> 0:18:31,196
可以有不同的属性 甚至不同的

534
00:18:31,196 --> 0:18:32,306
绘制类型

535
00:18:32,566 --> 0:18:35,116
因此 这对于许多人

536
00:18:35,116 --> 0:18:36,486
可能在其他地方

537
00:18:36,486 --> 0:18:37,876
看到的所有

538
00:18:37,876 --> 0:18:38,996
间接渲染 都是十分

539
00:18:38,996 --> 0:18:39,886
重要的一步

540
00:18:40,976 --> 0:18:42,096
现在 我们来看看如何在

541
00:18:42,096 --> 0:18:43,036
代码中执行此操作

542
00:18:44,416 --> 0:18:46,476
编码一个绘图调用

543
00:18:46,476 --> 0:18:47,526
就是这么容易

544
00:18:48,436 --> 0:18:49,616
你要做的第一件事就是

545
00:18:49,616 --> 0:18:51,096
使用你的线程 ID 得到索引

546
00:18:51,096 --> 0:18:53,666
并通过索引来选择渲染命令

547
00:18:54,816 --> 0:18:57,296
然后 我们要设置属性

548
00:18:57,586 --> 0:18:58,906
在这个例子中

549
00:18:58,906 --> 0:19:00,286
我们设置了一个具有管线状态的着色器

550
00:18:58,906 --> 0:19:00,286
我们设置了一个具有管线状态的着色器

551
00:19:00,286 --> 0:19:03,396
然后为几何和材质设置了

552
00:19:03,396 --> 0:19:04,976
单独的缓冲区

553
00:19:05,886 --> 0:19:07,646
最后 这是你编码一个绘图调用

554
00:19:07,646 --> 0:19:08,566
一个绘图调用的方式

555
00:19:09,096 --> 0:19:10,126
由于 Metal 着色语言

556
00:19:10,126 --> 0:19:11,826
在 GPU 上编码真的变得

557
00:19:11,996 --> 0:19:13,136
非常 非常简单

558
00:19:13,906 --> 0:19:15,486
即使是在计算着色器中

559
00:19:15,486 --> 0:19:17,146
这看起来就像

560
00:19:17,146 --> 0:19:18,786
就像你今天在可能在 CPU 上所做的事一样

561
00:19:18,786 --> 0:19:21,636
现在 我们再看另一个例子

562
00:19:23,116 --> 0:19:24,336
这些是创建 编码和

563
00:19:24,946 --> 0:19:26,706
执行 ICB 所需做的

564
00:19:26,896 --> 0:19:28,746
一些基本工作

565
00:19:29,956 --> 0:19:32,576
你首先填写一个状态描述来创建它

566
00:19:33,016 --> 0:19:34,646
状态描述包含

567
00:19:34,646 --> 0:19:38,136
绘制类型 继承

568
00:19:38,136 --> 0:19:40,346
属性和每层的绑定计数等内容

569
00:19:40,596 --> 0:19:42,306
这描述了间接缓冲区的

570
00:19:42,306 --> 0:19:43,446
行为方式

571
00:19:44,116 --> 0:19:47,726
在对 ICB 进行编码时

572
00:19:47,726 --> 0:19:49,506
你只需创建

573
00:19:49,506 --> 0:19:50,996
计算编码器和调用调度

574
00:19:50,996 --> 0:19:52,276
就像你已经在做的一样

575
00:19:54,046 --> 0:19:55,786
一旦 ICB 被编码

576
00:19:55,786 --> 0:19:58,116
你可以选择是否要优化它

577
00:19:58,486 --> 0:19:59,786
当你决定优化它

578
00:19:59,886 --> 0:20:01,526
你会删除所有的冗余状态

579
00:19:59,886 --> 0:20:01,526
你会删除所有的冗余状态

580
00:20:01,526 --> 0:20:03,036
最终的结果是

581
00:20:03,036 --> 0:20:05,196
一组精简而高效的 GPU 命令

582
00:20:06,226 --> 0:20:08,876
现在 一旦 ICB 被编码

583
00:20:08,876 --> 0:20:10,416
和优化 就可以安排它进行

584
00:20:10,416 --> 0:20:11,286
执行操作了

585
00:20:11,776 --> 0:20:12,986
你会注意到

586
00:20:12,986 --> 0:20:14,996
在这里你实际上可以

587
00:20:14,996 --> 0:20:16,396
指定你执行的命令的确切范围

588
00:20:17,316 --> 0:20:18,736
同样在这个例子中

589
00:20:18,736 --> 0:20:20,666
我们使用了一个间接缓冲区

590
00:20:21,076 --> 0:20:22,476
它本身就可以用 GPU 编码

591
00:20:25,586 --> 0:20:28,066
所以一旦 ICB 完成编码

592
00:20:28,066 --> 0:20:29,746
它就可以被一次又一次地

593
00:20:29,746 --> 0:20:31,526
重复使用 并且开销是完全

594
00:20:31,526 --> 0:20:32,146
可以被忽略不计的

595
00:20:32,856 --> 0:20:33,966
我非常兴奋

596
00:20:33,966 --> 0:20:35,236
但我们还要接着往下走

597
00:20:35,236 --> 0:20:36,686
我们将一个例子与代码放在一起

598
00:20:36,686 --> 0:20:37,206
以便你们可以看一下

599
00:20:39,216 --> 0:20:41,066
在屏幕上

600
00:20:41,066 --> 0:20:42,756
你可以看到一些城市中的校车

601
00:20:43,996 --> 0:20:46,766
每辆校车由 500,000

602
00:20:46,766 --> 0:20:50,326
个多边形和 2000 个独立部分组成

603
00:20:50,866 --> 0:20:53,446
每个部分都需要

604
00:20:53,446 --> 0:20:55,116
一个单独的绘图调用 它自己的

605
00:20:55,116 --> 0:20:56,836
材质参数缓冲区 索引缓冲区

606
00:20:56,836 --> 0:20:57,636
和顶点缓冲区

607
00:20:58,606 --> 0:21:00,006
正如你想象的那样

608
00:20:58,606 --> 0:21:00,006
正如你想象的那样

609
00:21:00,006 --> 0:21:01,966
这将会有很多 CPU 上的 API 调用

610
00:21:02,036 --> 0:21:04,116
但是我们在这里使用了

611
00:21:04,116 --> 0:21:05,106
间接命令缓冲区

612
00:21:05,156 --> 0:21:07,356
所以一切都将在 GPU 上编码

613
00:21:09,276 --> 0:21:10,786
我们也会选择

614
00:21:10,926 --> 0:21:12,926
合适的的细节级别

615
00:21:12,926 --> 0:21:13,906
因此 我们可以在

616
00:21:13,906 --> 0:21:16,676
呈现多个对象的同时

617
00:21:16,676 --> 0:21:19,046
也不会增加 CPU 或 GPU 上的花费

618
00:21:19,736 --> 0:21:20,966
在屏幕左边 你可以看到

619
00:21:20,966 --> 0:21:22,486
常规相机的视图

620
00:21:22,776 --> 0:21:23,906
而在屏幕右侧

621
00:21:23,906 --> 0:21:25,786
我们放大了一辆校车

622
00:21:25,786 --> 0:21:27,916
你可以看到细节级别在变化

623
00:21:29,126 --> 0:21:31,346
ICB 使我们能够

624
00:21:31,346 --> 0:21:32,936
推出另一个令人难以置信的

625
00:21:32,936 --> 0:21:33,746
优化方式

626
00:21:35,886 --> 0:21:37,456
我们能够将几何体

627
00:21:37,456 --> 0:21:39,036
分成由几百个

628
00:21:39,036 --> 0:21:40,356
三角形组成的块 并在单独的

629
00:21:40,356 --> 0:21:42,126
计算内核中分析这些块

630
00:21:43,366 --> 0:21:44,466
你可以在屏幕上看到

631
00:21:44,466 --> 0:21:45,706
不同颜色的色块

632
00:21:47,106 --> 0:21:48,236
内核的每个线程都会

633
00:21:48,236 --> 0:21:49,796
确定三角形是否

634
00:21:49,796 --> 0:21:51,456
背对着相机 或者它们

635
00:21:51,456 --> 0:21:52,696
是否被场景中的

636
00:21:52,696 --> 0:21:54,906
其他对象或几何体遮挡

637
00:21:55,756 --> 0:21:57,566
这是真的非常快

638
00:21:57,566 --> 0:21:58,386
因为我们只对一个块

639
00:21:58,386 --> 0:22:00,526
进行计算 而不是每个

640
00:21:58,386 --> 0:22:00,526
进行计算 而不是每个

641
00:22:00,526 --> 0:22:02,356
单独的三角形

642
00:22:03,576 --> 0:22:05,496
然后我们告诉 GPU 

643
00:22:05,496 --> 0:22:06,536
只渲染那些

644
00:22:06,536 --> 0:22:07,416
实际可见的块

645
00:22:07,916 --> 0:22:11,956
再一次 让我们看一下

646
00:22:11,956 --> 0:22:13,016
屏幕左右侧的视图

647
00:22:13,406 --> 0:22:14,566
左侧是相机视图

648
00:22:14,566 --> 0:22:16,376
右侧是校车的

649
00:22:16,376 --> 0:22:17,556
另一个​​视图

650
00:22:18,466 --> 0:22:20,346
你可以在右侧看到红色和

651
00:22:20,346 --> 0:22:21,326
粉红色的色调

652
00:22:21,326 --> 0:22:22,846
这就是我们的计算着色器

653
00:22:22,846 --> 0:22:24,306
所确定的不可见的部分

654
00:22:25,536 --> 0:22:27,606
我们从未真正将此场景

655
00:22:27,606 --> 0:22:30,216
发送给 GPU 因此它可以节省 50％

656
00:22:30,216 --> 0:22:32,536
或更多的几何渲染成本

657
00:22:35,896 --> 0:22:38,316
这是最后一个视图

658
00:22:38,316 --> 0:22:40,666
它展示了这种技术 可以为你节省多少成本

659
00:22:41,846 --> 0:22:43,516
注意右侧的画面

660
00:22:43,516 --> 0:22:44,876
许多校车和救护车实际上

661
00:22:44,876 --> 0:22:45,976
是隐形的

662
00:22:50,516 --> 0:22:52,036
这实在是太神奇了

663
00:22:52,036 --> 0:22:52,866
我喜欢这个

664
00:22:53,556 --> 0:22:55,156
所以请尽情地探索代码

665
00:22:55,156 --> 0:22:56,996
我希望我将来会在

666
00:22:57,136 --> 0:22:58,776
一些游戏中看到

667
00:22:58,776 --> 0:22:59,986
这种技术的应用

668
00:23:00,366 --> 0:23:02,496
我想如果你使用了它

669
00:23:02,496 --> 0:23:03,746
ICB 可以将你的游戏推向

670
00:23:03,746 --> 0:23:04,396
更高的水平

671
00:23:05,356 --> 0:23:07,726
现在 我很高兴向大家介绍

672
00:23:07,726 --> 0:23:09,346
Michael 他将向你们

673
00:23:09,346 --> 0:23:11,596
展示如何针对 A11 进行优化 

674
00:23:11,596 --> 0:23:13,226
改善性能并延长游戏时间

675
00:23:13,466 --> 0:23:14,266
十分感谢

676
00:23:15,516 --> 0:23:20,156
[ 掌声 ]

677
00:23:20,656 --> 0:23:21,196
&gt;&gt; 谢谢 Brian

678
00:23:22,306 --> 0:23:23,386
Brian 刚刚展示的

679
00:23:23,386 --> 0:23:24,996
所有内容都适用于 iOS

680
00:23:25,296 --> 0:23:27,196
tvOS 和 macOS

681
00:23:27,976 --> 0:23:29,226
接下来 我将深入探讨

682
00:23:29,226 --> 0:23:30,696
Apple 最新的 GPU A11 Bionic

683
00:23:30,696 --> 0:23:32,706
拥有的 Metal 二代技术

684
00:23:32,706 --> 0:23:34,296
的一些新功能 它们

685
00:23:34,296 --> 0:23:35,806
旨在通过减少

686
00:23:35,866 --> 0:23:37,656
系统内存带宽和降低功耗

687
00:23:37,656 --> 0:23:39,106
来帮助你最大化游戏性能

688
00:23:39,256 --> 0:23:40,696
并且延长游戏时间

689
00:23:45,046 --> 0:23:46,556
Apple 设计的 GPU

690
00:23:46,556 --> 0:23:47,896
拥有切片式延迟渲染架构

691
00:23:47,896 --> 0:23:49,506
这是专为高性能和低功耗

692
00:23:49,506 --> 0:23:51,506
而设计的

693
00:23:52,336 --> 0:23:53,446
这种架构利用

694
00:23:53,446 --> 0:23:54,746
高带宽低延迟的

695
00:23:54,936 --> 0:23:56,766
内存来消除透支

696
00:23:57,036 --> 0:23:58,686
和不必要的

697
00:23:58,686 --> 0:23:59,876
内存流量

698
00:24:02,606 --> 0:24:03,796
现在 Metal 技术在

699
00:24:03,796 --> 0:24:05,036
每个渲染通道

700
00:24:05,036 --> 0:24:06,636
加载和存储操作中都

701
00:24:06,636 --> 0:24:08,796
自动利用 TBDR 架构

702
00:24:08,796 --> 0:24:10,636
明确了渲染通道的

703
00:24:10,636 --> 0:24:11,936
内容是如何写入和写出

704
00:24:11,996 --> 0:24:13,226
Tile 内存的

705
00:24:16,386 --> 0:24:18,266
但 A11 GPU 进一步利用了

706
00:24:18,266 --> 0:24:19,706
TBDR 架构

707
00:24:20,306 --> 0:24:21,656
我们在 Tile 的内存中

708
00:24:21,656 --> 0:24:23,046
添加了新功能 并且增加了一个

709
00:24:23,046 --> 0:24:24,656
全新的可编程阶段

710
00:24:25,556 --> 0:24:27,456
这为高级的渲染技术

711
00:24:27,456 --> 0:24:28,826
提供了至关重要

712
00:24:28,826 --> 0:24:30,056
的新的优化机会

713
00:24:30,456 --> 0:24:31,706
例如延迟着色

714
00:24:32,246 --> 0:24:33,546
与顺序无关的透明度

715
00:24:34,086 --> 0:24:35,726
平铺正向着色

716
00:24:35,726 --> 0:24:36,426
和粒子渲染

717
00:24:37,676 --> 0:24:39,096
让我们先

718
00:24:39,096 --> 0:24:40,796
看一下 A11 GPU 的架构

719
00:24:44,066 --> 0:24:46,236
好的 在屏幕的左边

720
00:24:46,236 --> 0:24:47,846
我们有 A11 GPU 的展示

721
00:24:47,956 --> 0:24:49,246
而在屏幕右边

722
00:24:49,246 --> 0:24:49,586
我们有系统内存的展示

723
00:24:51,486 --> 0:24:53,736
现在 A11 GPU 先处理

724
00:24:53,736 --> 0:24:54,866
所有顶点阶段在

725
00:24:54,866 --> 0:24:56,596
渲染通道中的几何

726
00:24:57,096 --> 0:24:58,646
它将你的几何

727
00:24:58,646 --> 0:25:00,136
变换并弯曲成屏幕对齐

728
00:24:58,646 --> 0:25:00,136
变换并弯曲成屏幕对齐

729
00:25:00,526 --> 0:25:01,796
的平铺顶点缓冲区

730
00:25:02,416 --> 0:25:03,766
然后这些平铺的

731
00:25:03,766 --> 0:25:04,886
顶点缓冲区 将会存储在系统内存中

732
00:25:07,606 --> 0:25:08,876
现在 每个平铺的顶点缓冲区

733
00:25:08,876 --> 0:25:10,876
将作为碎片阶段的一部分

734
00:25:10,976 --> 0:25:12,476
在传输时完全处理完

735
00:25:13,606 --> 0:25:15,026
这种平铺架构可

736
00:25:15,026 --> 0:25:16,586
以让你的游戏免费获得

737
00:25:16,586 --> 0:25:18,436
2 个主要优化

738
00:25:19,596 --> 0:25:22,156
首先 GPU 在使用快速的

739
00:25:22,156 --> 0:25:23,306
用于传输的内存对任何像素

740
00:25:23,306 --> 0:25:25,476
进行着色之前 对所有图元进行

741
00:25:25,476 --> 0:25:26,176
光栅化处理

742
00:25:26,846 --> 0:25:28,606
这消除了内存的透支

743
00:25:28,606 --> 0:25:30,386
从而提高了性能并

744
00:25:30,386 --> 0:25:30,756
降低了功耗

745
00:25:32,436 --> 0:25:36,886
其次 用更大 更灵活的 Tile 内存

746
00:25:36,886 --> 0:25:37,726
来存储着色片段

747
00:25:38,366 --> 0:25:39,766
混合操作速度很快

748
00:25:39,766 --> 0:25:40,796
这是是由于所有数据都

749
00:25:40,796 --> 0:25:42,416
存储在着色核心旁边用于

750
00:25:42,416 --> 0:25:42,806
传输的内存上

751
00:25:43,326 --> 0:25:46,096
现在 在所有 Tile 内存被

752
00:25:46,096 --> 0:25:48,266
着色之后 每个

753
00:25:48,266 --> 0:25:50,476
Tile 内存仅被写入系统内存一次

754
00:25:51,216 --> 0:25:52,946
这会降低带宽

755
00:25:52,946 --> 0:25:54,256
这同时也会提升你的性能

756
00:25:54,296 --> 0:25:56,696
并降低功耗

757
00:25:56,826 --> 0:25:59,896
现在 这些优化发生在一切之下

758
00:26:00,456 --> 0:26:01,736
你只需在 iOS 上使用 Metal 技术即可

759
00:26:01,736 --> 0:26:02,306
得到它们

760
00:26:03,106 --> 0:26:04,866
但 Metal 技术还可以

761
00:26:04,866 --> 0:26:06,036
通过明确控制 A11 的

762
00:26:06,036 --> 0:26:07,796
Tile 的内存来优化

763
00:26:07,796 --> 0:26:08,596
渲染技术

764
00:26:09,186 --> 0:26:12,166
现在 在 A11 GPU 的

765
00:26:12,166 --> 0:26:13,866
开发过程中 Apple 的硬件

766
00:26:13,866 --> 0:26:15,346
和软件团队分析了

767
00:26:15,346 --> 0:26:16,946
许多重要的现代

768
00:26:16,946 --> 0:26:17,846
渲染技术

769
00:26:18,696 --> 0:26:20,406
我们加速了内存

770
00:26:20,406 --> 0:26:22,166
我们注意到了很多共同的主题

771
00:26:22,166 --> 0:26:23,476
并且我们发现显式控制我们的

772
00:26:23,476 --> 0:26:26,906
Tile 内存 可以为所有的这些内存加速

773
00:26:27,026 --> 0:26:28,036
接下来 我们围绕

774
00:26:28,036 --> 0:26:29,656
这种显式控制的想法

775
00:26:29,656 --> 0:26:31,416
开发了硬件和软件功能

776
00:26:32,656 --> 0:26:34,976
那么现在让我们来谈谈这些功能

777
00:26:41,656 --> 0:26:42,796
可编程的混合让你

778
00:26:42,796 --> 0:26:43,676
可以在着色器中编写

779
00:26:43,676 --> 0:26:44,976
自定义的混合操作

780
00:26:45,386 --> 0:26:46,686
它也是一个可以用来

781
00:26:46,686 --> 0:26:48,146
合并渲染通道的

782
00:26:48,406 --> 0:26:49,396
强大工具 实际上它可以

783
00:26:49,396 --> 0:26:51,446
用于所有的 iOS 的 GPU

784
00:26:52,136 --> 0:26:53,726
图像块（Imageblocks）是 A11 的新增功能

785
00:26:53,996 --> 0:26:55,046
它们通过直接用

786
00:26:55,046 --> 0:26:56,756
着色语言控制

787
00:26:56,756 --> 0:26:58,116
像素布局 可以让你最大限度地

788
00:26:58,116 --> 0:26:58,936
利用 Tile 的内存

789
00:26:59,466 --> 0:27:02,076
Tile 的着色是我们

790
00:26:59,466 --> 0:27:02,076
Tile 的着色是我们

791
00:27:02,076 --> 0:27:03,336
全新的可编程舞台

792
00:27:03,336 --> 0:27:04,326
它是专为需要混合图形

793
00:27:04,326 --> 0:27:05,526
和计算处理的技术

794
00:27:05,526 --> 0:27:06,446
而设计的

795
00:27:08,216 --> 0:27:09,856
持久线程组内存是

796
00:27:09,856 --> 0:27:11,106
组合渲染和计算的

797
00:27:11,106 --> 0:27:12,456
重要工具 它允许

798
00:27:12,456 --> 0:27:13,556
你通过绘制和调度

799
00:27:13,596 --> 0:27:14,556
进行通信

800
00:27:15,076 --> 0:27:18,276
多样本颜色覆盖控制

801
00:27:18,276 --> 0:27:20,026
可以让你使用 Tile 的

802
00:27:20,026 --> 0:27:21,576
着色器直接在 Tile 的内存中

803
00:27:21,576 --> 0:27:23,446
执行解析操作

804
00:27:25,016 --> 0:27:26,036
所以我要和你说一说

805
00:27:26,036 --> 0:27:27,066
所有的这些功能

806
00:27:27,066 --> 0:27:28,336
让我们从可编程混合开始吧

807
00:27:28,866 --> 0:27:33,006
通过可编程混合

808
00:27:33,006 --> 0:27:34,056
你的片段着色器

809
00:27:34,056 --> 0:27:35,796
可以读取和写入像素和 Tile 的内存

810
00:27:36,466 --> 0:27:37,486
这可以让你编写自定义的

811
00:27:37,486 --> 0:27:38,666
混合操作

812
00:27:40,436 --> 0:27:42,256
但是 可编程混合

813
00:27:42,256 --> 0:27:43,626
还可以通过组合

814
00:27:43,626 --> 0:27:45,476
多个读取和写入

815
00:27:45,476 --> 0:27:46,656
相同内容的渲染通道来

816
00:27:46,656 --> 0:27:47,826
消除系统内存带宽

817
00:27:49,916 --> 0:27:50,906
现在 延迟着色

818
00:27:50,906 --> 0:27:52,166
特别适合于

819
00:27:52,166 --> 0:27:53,466
应用可编程混合 所以让

820
00:27:53,466 --> 0:27:58,016
我们仔细看一下

821
00:27:58,496 --> 0:27:59,506
延迟着色是

822
00:27:59,506 --> 0:28:00,456
一种一般使用

823
00:27:59,506 --> 0:28:00,456
一种一般使用

824
00:28:00,456 --> 0:28:02,446
2 遍传递实现的多光技术

825
00:28:03,046 --> 0:28:04,916
在第一遍中

826
00:28:04,916 --> 0:28:05,866
多个附件填充了

827
00:28:05,906 --> 0:28:07,366
每个像素可见的

828
00:28:07,366 --> 0:28:09,426
几何属性 例如法线

829
00:28:09,886 --> 0:28:11,316
反照率和粗糙度

830
00:28:12,136 --> 0:28:13,296
在第二遍中 通过对那些

831
00:28:13,296 --> 0:28:14,776
G 缓冲的内容进行采样来对

832
00:28:14,776 --> 0:28:15,856
片段进行着色

833
00:28:16,456 --> 0:28:20,396
现在 G 缓冲先被存储在

834
00:28:20,396 --> 0:28:21,766
系统内存中 然后再次在

835
00:28:21,766 --> 0:28:23,146
光照通道中读取

836
00:28:23,686 --> 0:28:24,976
并且从 Tile 的内存到系统内存的

837
00:28:24,976 --> 0:28:26,516
双向交流和再次回退

838
00:28:26,516 --> 0:28:28,046
可能使你的游戏进入

839
00:28:28,046 --> 0:28:29,546
瓶颈 因为 G 缓冲

840
00:28:29,546 --> 0:28:30,986
轨道消耗了大量的带宽

841
00:28:31,566 --> 0:28:33,626
现在 可编程混合可以

842
00:28:33,626 --> 0:28:35,206
让你直接从 Tile 的内存

843
00:28:35,206 --> 0:28:36,646
中读取到当前像素的

844
00:28:36,646 --> 0:28:38,636
数据 从而跳过内存的

845
00:28:38,636 --> 0:28:40,916
来回沟通

846
00:28:42,586 --> 0:28:43,506
这也意味着我们

847
00:28:43,506 --> 0:28:44,666
不再需要 2 次传递

848
00:28:44,966 --> 0:28:46,486
我们 G 缓冲的填充

849
00:28:46,486 --> 0:28:48,096
和光照步骤现在

850
00:28:48,096 --> 0:28:50,226
被编码和运行在每个渲染通道中

851
00:28:51,536 --> 0:28:52,896
这也意味着

852
00:28:52,896 --> 0:28:54,206
我们不再需要系统内存中的

853
00:28:54,206 --> 0:28:55,856
G 缓冲内容的副本

854
00:28:56,376 --> 0:28:59,166
有了内存 Metal 技术的

855
00:28:59,166 --> 0:29:00,216
无记忆渲染目标功能

856
00:28:59,166 --> 0:29:00,216
无记忆渲染目标功能

857
00:29:00,216 --> 0:29:02,066
对于节省内存来说真的非常

858
00:29:02,066 --> 0:29:03,066
非常简单

859
00:29:03,616 --> 0:29:04,846
你只需创建一个

860
00:29:04,846 --> 0:29:06,776
带有无记忆标记的纹理

861
00:29:06,776 --> 0:29:08,246
同时 Metal 技术仅允许

862
00:29:08,246 --> 0:29:09,416
你在没有进行加载或存储操作的情况下

863
00:29:09,416 --> 0:29:10,176
把它作为附件

864
00:29:10,746 --> 0:29:13,376
所以 现在让我们来看一看

865
00:29:13,376 --> 0:29:14,476
在着色器中使用可编程混合

866
00:29:14,476 --> 0:29:15,606
是多么的容易

867
00:29:16,156 --> 0:29:20,056
好的 这里是你的

868
00:29:20,056 --> 0:29:21,236
光通道的

869
00:29:21,236 --> 0:29:23,366
片段着色器在可编程混合中的样子

870
00:29:24,196 --> 0:29:25,786
当你读取和写入

871
00:29:25,786 --> 0:29:27,606
你的附件时 可编程混合将被启用

872
00:29:27,986 --> 0:29:29,526
在这个例子中

873
00:29:29,526 --> 0:29:30,666
我们看到 G 缓冲附件

874
00:29:30,666 --> 0:29:32,856
既是我们函数的输入 又是函数的输出

875
00:29:32,956 --> 0:29:36,826
我们首先使用我们的 G 缓冲的属性

876
00:29:36,826 --> 0:29:38,146
来计算我们的照明

877
00:29:38,856 --> 0:29:39,886
正如你在这里看到的

878
00:29:39,886 --> 0:29:41,006
我们正在读取我们的附件

879
00:29:41,006 --> 0:29:41,866
但我们并没有将它们作为纹理

880
00:29:41,866 --> 0:29:42,376
进行采样

881
00:29:42,916 --> 0:29:45,676
然后 我们将我们的照明的

882
00:29:45,676 --> 0:29:47,186
累积结果返回 G 缓冲

883
00:29:47,186 --> 0:29:48,126
在这一步中

884
00:29:48,126 --> 0:29:49,306
我们都在读取和写入

885
00:29:49,306 --> 0:29:50,226
我们的累积结果

886
00:29:50,616 --> 0:29:52,156
这就是最后了

887
00:29:52,406 --> 0:29:53,946
可编程混合真的非常简单

888
00:29:53,946 --> 0:29:55,256
只要你有多个

889
00:29:55,256 --> 0:29:56,516
读取和写入相同附件

890
00:29:56,516 --> 0:29:58,176
的渲染过程 你就应该在

891
00:29:58,176 --> 0:29:59,356
那里应用它

892
00:30:00,556 --> 0:30:02,416
所以现在我们来讨论

893
00:30:02,416 --> 0:30:04,376
一下图像块（Imageblocks）

894
00:30:04,376 --> 0:30:05,936
它允许你在更多的情况下

895
00:30:05,936 --> 0:30:06,696
合并渲染通道

896
00:30:12,476 --> 0:30:13,546
图像块（Imageblocks）可以

897
00:30:13,546 --> 0:30:14,736
让你在 Tile 的内存中完全

898
00:30:14,736 --> 0:30:15,116
控制你的数据

899
00:30:15,536 --> 0:30:17,196
图像块允许你以

900
00:30:17,196 --> 0:30:18,506
结构体的形式直接用

901
00:30:18,506 --> 0:30:20,486
着色语言声明像素布局

902
00:30:21,456 --> 0:30:22,696
而不是将像素描述

903
00:30:22,696 --> 0:30:24,006
为 Metal 技术的 API 中的

904
00:30:24,006 --> 0:30:25,816
渲染通道内容中的数组

905
00:30:28,056 --> 0:30:29,336
它将新的数据类型

906
00:30:29,336 --> 0:30:30,556
添加到与你已经使用的

907
00:30:30,556 --> 0:30:31,856
匹配纹理格式的

908
00:30:31,856 --> 0:30:33,446
着色语言当中

909
00:30:33,446 --> 0:30:35,116
并且在访问着色器时

910
00:30:35,116 --> 0:30:36,666
这些类型被透明地打包和解压

911
00:30:37,646 --> 0:30:39,196
实际上 你还可以在

912
00:30:39,196 --> 0:30:40,676
顶点缓冲区和

913
00:30:40,676 --> 0:30:42,216
常量缓冲区中使用

914
00:30:42,216 --> 0:30:43,976
这些新的数据类型来更紧密地

915
00:30:43,976 --> 0:30:44,476
打包所有数据

916
00:30:46,736 --> 0:30:47,946
图像块（Imageblocks）还允许

917
00:30:47,946 --> 0:30:49,996
你描述更复杂的每个像素

918
00:30:49,996 --> 0:30:50,826
数据结构

919
00:30:51,176 --> 0:30:52,806
你可以使用数组

920
00:30:52,806 --> 0:30:54,616
嵌套结构或其组合

921
00:30:55,126 --> 0:30:56,586
它们都可以正常运行

922
00:30:59,096 --> 0:31:01,016
现在 直接控制

923
00:30:59,096 --> 0:31:01,016
现在 直接控制

924
00:31:01,016 --> 0:31:02,176
像素布局意味着

925
00:31:02,176 --> 0:31:03,666
你现在可以在通道内

926
00:31:03,666 --> 0:31:04,186
更改布局

927
00:31:04,796 --> 0:31:06,136
这使你可以将渲染过程

928
00:31:06,136 --> 0:31:07,336
组合起来 从而消除

929
00:31:07,336 --> 0:31:08,796
系统内存带宽

930
00:31:08,796 --> 0:31:09,766
而这种方式仅凭

931
00:31:09,766 --> 0:31:11,656
可编程混合是无法实现的

932
00:31:11,656 --> 0:31:12,666
让我们来看一个例子

933
00:31:15,156 --> 0:31:16,966
在我们之前的例子中

934
00:31:16,966 --> 0:31:18,056
我们使用可编程混合

935
00:31:18,056 --> 0:31:19,846
来实现单通延迟着色

936
00:31:20,836 --> 0:31:21,756
你也可以使用

937
00:31:21,756 --> 0:31:23,906
图像块实现单通道延迟着色

938
00:31:25,346 --> 0:31:26,726
图像块只存在于 Tile 内存中

939
00:31:26,726 --> 0:31:27,816
所以没有渲染通道附件

940
00:31:27,816 --> 0:31:28,966
需要处理

941
00:31:29,716 --> 0:31:31,066
这不仅是一种

942
00:31:31,066 --> 0:31:32,406
更加自然的表达算法的方式

943
00:31:32,716 --> 0:31:34,386
而且现在你也可以在

944
00:31:34,386 --> 0:31:35,926
完成照明后读取

945
00:31:35,926 --> 0:31:37,756
G 缓冲 然后再重新使用 Tile 的内存

946
00:31:38,786 --> 0:31:39,996
让我们继续

947
00:31:39,996 --> 0:31:41,396
让我们重复使用

948
00:31:41,396 --> 0:31:43,006
Tile 的内存来添加

949
00:31:43,196 --> 0:31:44,856
一个称为多层 Alpha 混合的顺序无关的

950
00:31:44,896 --> 0:31:46,236
透明度技术

951
00:31:51,466 --> 0:31:52,816
多层 Alpha 混合（MLAB）

952
00:31:52,816 --> 0:31:55,676
可维护每个像素

953
00:31:55,676 --> 0:31:57,896
固定大小的半透明片段数组

954
00:31:58,556 --> 0:32:00,136
每个传入的片段按

955
00:31:58,556 --> 0:32:00,136
每个传入的片段按

956
00:32:00,136 --> 0:32:01,326
深度排序加到数组中

957
00:32:02,186 --> 0:32:03,706
如果一个片段的深度

958
00:32:03,706 --> 0:32:04,916
超出了数组的最后

959
00:32:04,916 --> 0:32:06,246
一个元素 那么

960
00:32:06,246 --> 0:32:07,536
这些元素就会被合并

961
00:32:07,536 --> 0:32:09,126
所以它实际上是

962
00:32:09,566 --> 0:32:09,766
一个近似的技术

963
00:32:11,376 --> 0:32:12,976
现在 对 MLAB 数组进行

964
00:32:12,976 --> 0:32:14,136
排序速度非常快 因为它存在于

965
00:32:14,136 --> 0:32:14,746
Tile 的内存中

966
00:32:15,556 --> 0:32:16,796
由于额外的带宽

967
00:32:16,796 --> 0:32:18,186
和同步开销 在芯片

968
00:32:18,186 --> 0:32:19,356
上做同样的操作会变得

969
00:32:19,356 --> 0:32:20,346
非常昂贵

970
00:32:20,856 --> 0:32:25,326
A11 实际上是对

971
00:32:25,326 --> 0:32:26,826
上一代支持的最大像素尺寸

972
00:32:26,826 --> 0:32:28,096
进行了加倍

973
00:32:28,866 --> 0:32:30,466
但这还不足以

974
00:32:30,466 --> 0:32:31,596
同时包含

975
00:32:31,596 --> 0:32:34,606
G 缓冲和 MLAB 数据结构

976
00:32:35,396 --> 0:32:37,366
幸运的是 你不需要

977
00:32:37,366 --> 0:32:38,106
同时使用两者

978
00:32:38,916 --> 0:32:40,076
图像块（Imageblocks）允许

979
00:32:40,076 --> 0:32:41,896
你在渲染过程中

980
00:32:41,896 --> 0:32:43,216
更改像素布局以符合

981
00:32:43,916 --> 0:32:44,036
你的当前需求

982
00:32:44,956 --> 0:32:47,296
改变像素布局实际上

983
00:32:47,296 --> 0:32:48,926
需要 Tile 的着色 所以我们接下来

984
00:32:48,926 --> 0:32:50,846
来讨论一下这个

985
00:32:56,256 --> 0:32:58,036
Tile 着色是

986
00:32:58,036 --> 0:32:59,516
新的可编程阶段

987
00:32:59,516 --> 0:33:01,246
它直接在渲染过程中提供了

988
00:32:59,516 --> 0:33:01,246
它直接在渲染过程中提供了

989
00:33:01,246 --> 0:33:02,036
计算能力

990
00:33:02,656 --> 0:33:04,016
这个阶段将会在

991
00:33:04,016 --> 0:33:06,216
每个 Tile 上执行一个可配置的线程组

992
00:33:06,756 --> 0:33:07,936
举个例子

993
00:33:07,936 --> 0:33:09,626
你可以为每个 Tile 启动一个线程

994
00:33:09,626 --> 0:33:10,846
或者也可以为每个像素启动一个线程

995
00:33:14,286 --> 0:33:15,296
Tile 的着色

996
00:33:15,336 --> 0:33:16,526
可以让你交叉使用

997
00:33:16,526 --> 0:33:17,916
对相同数据进行操作的绘制调用

998
00:33:17,916 --> 0:33:19,156
和线程组调度

999
00:33:19,496 --> 0:33:21,796
Tile 的着色器可

1000
00:33:21,796 --> 0:33:23,066
以访问所有 Tile 内存

1001
00:33:23,066 --> 0:33:24,446
因此它们可以读写图像块的任何像素

1002
00:33:26,196 --> 0:33:27,696
那么让我们来看一看

1003
00:33:27,696 --> 0:33:31,286
Tile 着色如何优化切片正向着色等技术

1004
00:33:34,536 --> 0:33:36,406
像延迟着色一样

1005
00:33:36,406 --> 0:33:37,866
切片正向着色是一种多层技术

1006
00:33:38,616 --> 0:33:39,986
我们通常会在

1007
00:33:39,986 --> 0:33:41,406
MSA 非常重要时

1008
00:33:41,406 --> 0:33:43,356
或需要各种材料时使用它

1009
00:33:43,356 --> 0:33:44,676
并且它对不透明和半透明几何图形

1010
00:33:44,676 --> 0:33:48,476
同样适用切片正向着色

1011
00:33:48,476 --> 0:33:50,546
一般由 3 次传递组成

1012
00:33:51,226 --> 0:33:53,436
首先 一个渲染通道生成了

1013
00:33:53,436 --> 0:33:54,256
一个场景深度缓冲区

1014
00:33:55,136 --> 0:33:56,626
其次 计算通道将会

1015
00:33:56,626 --> 0:33:58,806
生成并计算使用该场景

1016
00:33:58,806 --> 0:34:00,716
深度缓冲区的

1017
00:33:58,806 --> 0:34:00,716
深度缓冲区的

1018
00:34:00,716 --> 0:34:02,446
每个 Tile 深度边界和光源列表

1019
00:34:03,326 --> 0:34:04,886
最后 另一个渲染通道

1020
00:34:04,886 --> 0:34:05,956
将使用相应的光源列表

1021
00:34:05,956 --> 0:34:08,096
为每个 Tile 中的像素着色

1022
00:34:08,706 --> 0:34:13,235
现在 这种混合

1023
00:34:13,235 --> 0:34:14,976
渲染和计算的模式是很常见的

1024
00:34:14,976 --> 0:34:17,366
在 A11 之前

1025
00:34:17,366 --> 0:34:19,226
这些通道之间的交流需要系统内存

1026
00:34:19,936 --> 0:34:21,755
但是使用 Tile 着色

1027
00:34:21,755 --> 0:34:22,856
我们可以将计算内联

1028
00:34:22,856 --> 0:34:24,036
所以渲染通道就可以合并

1029
00:34:26,396 --> 0:34:28,356
在这里 深度边界和

1030
00:34:28,356 --> 0:34:29,476
光线剔除步骤被

1031
00:34:29,476 --> 0:34:31,036
作为 Tile 着色器实现

1032
00:34:31,036 --> 0:34:32,576
并内嵌到单个渲染通道中

1033
00:34:33,496 --> 0:34:34,735
深度现在只

1034
00:34:34,735 --> 0:34:36,426
存储在图像块中

1035
00:34:36,525 --> 0:34:42,706
但却可以在整个过程中被访问

1036
00:34:42,906 --> 0:34:44,496
所以现在 Tile 的着色

1037
00:34:44,496 --> 0:34:45,696
将帮助你消除大量带宽

1038
00:34:45,696 --> 0:34:47,626
但这些 Tile 的着色器的输出

1039
00:34:47,626 --> 0:34:49,545
仍然存储在系统内存中

1040
00:34:50,545 --> 0:34:51,826
Tile 的着色器

1041
00:34:51,826 --> 0:34:53,226
调度与绘制同步

1042
00:34:53,226 --> 0:34:54,286
所以这是完全安全的

1043
00:34:54,656 --> 0:34:55,606
但我认为我们仍然可以

1044
00:34:55,606 --> 0:34:57,136
使用我们的下一个功能

1045
00:34:57,706 --> 0:34:59,426
持久线程组内存 来使我们做得更好

1046
00:35:05,336 --> 0:35:06,846
好的 线程组内存

1047
00:35:06,846 --> 0:35:08,206
是 Metal 技术计算的一个众所周知的特性

1048
00:35:08,826 --> 0:35:09,856
它使线程组内的线程

1049
00:35:09,856 --> 0:35:11,766
可以使用快速的 用于传输的内存

1050
00:35:11,766 --> 0:35:12,636
来共享数据

1051
00:35:13,736 --> 0:35:14,886
现在 由于 Tile 着色

1052
00:35:14,936 --> 0:35:16,096
线程组内存也可以在

1053
00:35:16,096 --> 0:35:17,396
渲染通道中使用

1054
00:35:18,446 --> 0:35:19,586
但渲染通道中的

1055
00:35:19,586 --> 0:35:20,756
线程组内存含有

1056
00:35:20,756 --> 0:35:21,946
2 个传统上不可用于计算

1057
00:35:21,946 --> 0:35:22,766
的新功能

1058
00:35:23,376 --> 0:35:25,286
首先 片段着色器

1059
00:35:25,286 --> 0:35:26,756
现在也可以访问相同的

1060
00:35:26,756 --> 0:35:27,446
线程组内存

1061
00:35:28,126 --> 0:35:29,366
其次 线程组内存

1062
00:35:29,366 --> 0:35:30,496
的内容在整个

1063
00:35:30,496 --> 0:35:32,116
Tile 的整个生命周期中都存在

1064
00:35:33,476 --> 0:35:35,706
总而言之 这是

1065
00:35:35,756 --> 0:35:37,146
一个强大的工具

1066
00:35:37,146 --> 0:35:39,286
可以让数据在绘制和调度之间共享

1067
00:35:40,486 --> 0:35:41,646
实际上 我们相信

1068
00:35:41,646 --> 0:35:42,666
这会非常有用

1069
00:35:42,666 --> 0:35:43,916
因为我们实际上已经

1070
00:35:43,916 --> 0:35:44,876
使线程组内存的最大容量翻倍

1071
00:35:44,876 --> 0:35:46,466
比起上一代来说

1072
00:35:46,466 --> 0:35:47,326
你可以将更多的中间数据

1073
00:35:47,326 --> 0:35:50,606
存储在传输过程中

1074
00:35:50,786 --> 0:35:52,956
好的 现在让我们使用持久线程组

1075
00:35:52,956 --> 0:35:54,176
来进一步优化我们的

1076
00:35:54,176 --> 0:35:55,106
切片正向着色示例

1077
00:35:55,686 --> 0:36:00,576
因此 有了持久线程组

1078
00:35:55,686 --> 0:36:00,576
因此 有了持久线程组

1079
00:36:00,706 --> 0:36:02,116
Tile 的着色阶段

1080
00:36:02,116 --> 0:36:03,716
可以将深度边界和

1081
00:36:03,716 --> 0:36:05,086
剔除光线列表写入

1082
00:36:05,086 --> 0:36:06,416
线程组内存中供

1083
00:36:06,416 --> 0:36:07,766
以后使用

1084
00:36:08,716 --> 0:36:09,996
这意味着现在我们所有的

1085
00:36:09,996 --> 0:36:11,256
中间数据都会保留在传输过程上

1086
00:36:11,766 --> 0:36:13,056
并且永远不会离开 GPU

1087
00:36:13,056 --> 0:36:14,506
只有最终的图像存储

1088
00:36:14,506 --> 0:36:15,186
在系统内存中

1089
00:36:16,556 --> 0:36:17,876
尽量减少系统内存

1090
00:36:17,876 --> 0:36:19,516
的带宽对于游戏的

1091
00:36:19,516 --> 0:36:21,596
性能和游戏时间来说是非常重要的

1092
00:36:21,676 --> 0:36:24,546
现在 我们来看一看

1093
00:36:24,546 --> 0:36:25,616
在着色语言中

1094
00:36:25,616 --> 0:36:27,466
使用持久线程组有多容易

1095
00:36:31,336 --> 0:36:33,166
好的 所以这里的顶层函数

1096
00:36:33,166 --> 0:36:34,376
是我们的 Tile 着色器

1097
00:36:34,376 --> 0:36:35,426
它将执行我们的光线剔除过程

1098
00:36:35,726 --> 0:36:37,396
它将光线与

1099
00:36:37,396 --> 0:36:39,276
Tile 视锥相交以计算

1100
00:36:39,276 --> 0:36:41,026
主动的光掩码

1101
00:36:41,876 --> 0:36:43,096
底层函数是

1102
00:36:43,096 --> 0:36:44,376
我们的片段着色器

1103
00:36:44,376 --> 0:36:45,206
它执行我们的正向着色

1104
00:36:45,696 --> 0:36:46,846
它只使用该

1105
00:36:46,846 --> 0:36:48,486
主动光掩码遮住

1106
00:36:48,486 --> 0:36:49,806
与 Tile 相交的灯光

1107
00:36:51,456 --> 0:36:53,256
现在 在这两个着色器

1108
00:36:53,256 --> 0:36:54,766
通过使用相同类型和

1109
00:36:54,766 --> 0:36:56,116
绑定点实现跨函数

1110
00:36:56,406 --> 0:36:59,116
的共享线程组内存

1111
00:37:00,296 --> 0:37:02,826
这就是使用持久线程组有多容易

1112
00:37:05,806 --> 0:37:07,806
好吧 现在你已经看到了

1113
00:37:07,806 --> 0:37:08,686
Tile 着色和持久线程组

1114
00:37:08,686 --> 0:37:10,206
让我们再次回到

1115
00:37:10,206 --> 0:37:11,876
我们的顺序无关的透明度示例

1116
00:37:14,166 --> 0:37:15,446
好的 你们还记得我说的

1117
00:37:15,446 --> 0:37:17,126
改变图像块布局需要

1118
00:37:17,126 --> 0:37:18,116
Tile 着色的吗

1119
00:37:18,916 --> 0:37:20,106
这是因为 Tile 着色提供了

1120
00:37:20,106 --> 0:37:22,336
我们需要的同步

1121
00:37:22,336 --> 0:37:24,176
而这会安全地更改布局

1122
00:37:24,686 --> 0:37:26,276
这意味着我们实际上

1123
00:37:26,276 --> 0:37:27,926
必须在照明和 MLAB 步骤之间

1124
00:37:27,926 --> 0:37:29,316
插入 Tile 着色

1125
00:37:33,226 --> 0:37:34,436
因此在从 G 缓冲转换到

1126
00:37:34,516 --> 0:37:35,406
MLAB 之前 Tile 着色

1127
00:37:35,406 --> 0:37:36,576
必须等待

1128
00:37:36,576 --> 0:37:38,436
光照步骤完成

1129
00:37:38,436 --> 0:37:40,426
并且它还将把

1130
00:37:40,426 --> 0:37:41,466
光照步骤累积的

1131
00:37:41,466 --> 0:37:42,646
光照值转移到

1132
00:37:42,646 --> 0:37:44,776
MLAB 步骤中进行最终混合

1133
00:37:49,146 --> 0:37:50,706
好吧 现在我们已经

1134
00:37:50,706 --> 0:37:52,496
介绍了图像块 图块着色

1135
00:37:52,496 --> 0:37:53,576
和持久线程组 现在

1136
00:37:53,576 --> 0:37:54,736
是时候继续讨论我们的最终

1137
00:37:54,736 --> 0:37:56,376
主题 多重采样

1138
00:37:56,376 --> 0:37:58,676
抗锯齿和示例覆盖控制

1139
00:38:03,286 --> 0:38:04,676
多重采样抗锯齿功能

1140
00:38:04,676 --> 0:38:06,016
可通过超取样深度

1141
00:38:06,016 --> 0:38:08,396
模板和混合来

1142
00:38:08,766 --> 0:38:10,026
提高图像质量 但每个像素

1143
00:38:10,026 --> 0:38:10,676
只能着色一次

1144
00:38:11,816 --> 0:38:13,026
多个样本稍后

1145
00:38:13,026 --> 0:38:14,716
将会被简单平均法解析为

1146
00:38:14,896 --> 0:38:15,836
最终图像

1147
00:38:18,166 --> 0:38:19,676
现在 多重采样在

1148
00:38:19,676 --> 0:38:21,696
所有 A 系列 GPU 上

1149
00:38:21,746 --> 0:38:23,196
都是高效的 因为

1150
00:38:23,196 --> 0:38:24,546
样本存储在 Tile 内存中

1151
00:38:24,546 --> 0:38:25,946
从而其中混合和解析可以

1152
00:38:25,946 --> 0:38:26,986
快速地访问样本

1153
00:38:29,236 --> 0:38:31,436
A11 GPU 通过追踪

1154
00:38:31,436 --> 0:38:33,356
每个像素内的

1155
00:38:33,356 --> 0:38:34,616
独特颜色进一步优化了

1156
00:38:34,616 --> 0:38:35,346
多重采样

1157
00:38:36,036 --> 0:38:37,416
以前在每个样本上

1158
00:38:37,416 --> 0:38:38,386
进行的混合操作

1159
00:38:38,386 --> 0:38:40,746
现在仅对每种颜色进行操作

1160
00:38:41,616 --> 0:38:42,636
这可能是一个显著的

1161
00:38:42,636 --> 0:38:44,036
优化节约

1162
00:38:44,036 --> 0:38:45,756
因为每个三角形的内部

1163
00:38:45,756 --> 0:38:46,386
只包含 1 种独特的颜色

1164
00:38:49,186 --> 0:38:50,246
现在 独特颜色与

1165
00:38:50,276 --> 0:38:53,406
样本的映射被称为

1166
00:38:53,406 --> 0:38:54,606
颜色覆盖控制 并且

1167
00:38:54,606 --> 0:38:55,576
这由 GPU 管理

1168
00:38:56,206 --> 0:38:57,966
但是 Tile 着色器也可以读取

1169
00:38:57,966 --> 0:38:59,506
和修改这种颜色覆盖

1170
00:39:00,806 --> 0:39:02,176
我们可以使用它来执行

1171
00:39:02,216 --> 0:39:04,566
自定义解析和快速的

1172
00:39:04,566 --> 0:39:05,406
Tile 内存

1173
00:39:06,186 --> 0:39:07,466
现在 让我们来看一看

1174
00:39:07,696 --> 0:39:08,516
为什么这是有用的

1175
00:39:08,516 --> 0:39:10,316
让我们来看一下渲染粒子

1176
00:39:10,316 --> 0:39:11,166
的多重采样场景

1177
00:39:14,196 --> 0:39:15,766
粒子是透明的

1178
00:39:15,766 --> 0:39:17,356
所以我们将在渲染我们的

1179
00:39:17,356 --> 0:39:18,646
不透明场景几何体之后将它们混合

1180
00:39:19,306 --> 0:39:20,706
但是粒子渲染不能从

1181
00:39:20,706 --> 0:39:21,886
多重采样中受益

1182
00:39:21,886 --> 0:39:23,716
因为它实际上没有任何可见的边缘

1183
00:39:24,766 --> 0:39:26,236
因此 为了避免

1184
00:39:26,236 --> 0:39:27,496
无理由地混合

1185
00:39:27,496 --> 0:39:29,256
每个样本的额外成本

1186
00:39:29,256 --> 0:39:30,236
游戏将使用 2 次传递进行渲染

1187
00:39:30,956 --> 0:39:32,546
在第一遍中 你的不透明的

1188
00:39:32,546 --> 0:39:33,956
场景几何体

1189
00:39:33,956 --> 0:39:35,756
将使用多重采样来渲染以减少混叠

1190
00:39:36,666 --> 0:39:37,536
然后 你将解决

1191
00:39:37,536 --> 0:39:38,696
关于系统内存的颜色

1192
00:39:38,696 --> 0:39:40,036
和深度 并且处理

1193
00:39:40,036 --> 0:39:41,506
深度 因为之后它在之后

1194
00:39:41,506 --> 0:39:42,846
可以包含粒子

1195
00:39:43,916 --> 0:39:45,696
然后在第二遍中

1196
00:39:45,696 --> 0:39:47,496
使用解析颜色和

1197
00:39:47,636 --> 0:39:49,576
深度来渲染没有多次采样的粒子

1198
00:39:51,256 --> 0:39:52,466
现在 正如你现在可能

1199
00:39:52,466 --> 0:39:54,326
猜到的那样 我们的目标

1200
00:39:54,326 --> 0:39:55,396
是使用 Tile 着色来消除

1201
00:39:55,396 --> 0:39:56,876
中间传输的系统内存

1202
00:39:56,876 --> 0:39:58,646
以便合并这两个传递

1203
00:40:01,126 --> 0:40:02,716
但仅仅 Tile 着色是不够的

1204
00:40:02,956 --> 0:40:04,266
我们需要色彩覆盖控制来

1205
00:40:04,266 --> 0:40:06,586
改变多重采样率

1206
00:40:07,576 --> 0:40:08,876
颜色覆盖控制功能非常强大

1207
00:40:08,996 --> 0:40:10,996
并且使用非常简单

1208
00:40:11,526 --> 0:40:12,496
让我们来看一下着色器

1209
00:40:16,176 --> 0:40:17,976
好的 请记住

1210
00:40:17,976 --> 0:40:19,336
我们的目标是

1211
00:40:19,336 --> 0:40:20,766
平均每个像素的样本

1212
00:40:20,766 --> 0:40:22,126
然后将该结果

1213
00:40:22,236 --> 0:40:24,106
存储回图像块中作为整体像素值

1214
00:40:25,616 --> 0:40:27,276
现在 我们不是

1215
00:40:27,276 --> 0:40:29,686
循环每个颜色 循环

1216
00:40:29,826 --> 0:40:30,776
每个样本 而是

1217
00:40:30,776 --> 0:40:32,146
使用 A11 的色差率

1218
00:40:32,146 --> 0:40:34,916
功能 只循环独特的颜色

1219
00:40:36,836 --> 0:40:38,726
为了在所有样本中

1220
00:40:38,726 --> 0:40:40,066
正确地平均

1221
00:40:40,066 --> 0:40:41,416
我们需要根据与其相关的

1222
00:40:41,416 --> 0:40:43,166
样本数对每种颜色进行

1223
00:40:43,166 --> 0:40:46,436
加权 我们通过计算颜色掩码中

1224
00:40:46,436 --> 0:40:47,866
设置的位来实现这一点

1225
00:40:49,186 --> 0:40:50,426
然后 我们通过

1226
00:40:50,426 --> 0:40:51,606
除以总采样数来完成

1227
00:40:51,606 --> 0:40:54,766
平均 最后将

1228
00:40:54,766 --> 0:40:56,616
结果写回到图像块中

1229
00:40:57,136 --> 0:40:58,526
输出样本掩码告诉

1230
00:40:58,526 --> 0:41:00,126
Metal 技术将结果应用于

1231
00:40:58,526 --> 0:41:00,126
Metal 技术将结果应用于

1232
00:41:00,126 --> 0:41:01,136
像素的所有样本

1233
00:41:01,986 --> 0:41:03,876
而且 由于所有样本

1234
00:41:03,876 --> 0:41:05,486
现在都具有相同的值

1235
00:41:05,486 --> 0:41:06,426
因此后面的粒子绘制

1236
00:41:06,426 --> 0:41:08,646
将按每个像素而不是每个样本进行混合

1237
00:41:11,096 --> 0:41:13,056
这就是样本覆盖控制

1238
00:41:15,736 --> 0:41:18,216
现在 针对 Apple GPU

1239
00:41:18,216 --> 0:41:19,306
进行的优化对于

1240
00:41:19,306 --> 0:41:20,556
最大限度地提高

1241
00:41:20,586 --> 0:41:21,926
游戏性能并延长

1242
00:41:21,966 --> 0:41:23,806
游戏时间非常重要

1243
00:41:23,806 --> 0:41:25,236
但是在 iOS 平台上使用

1244
00:41:25,236 --> 0:41:27,036
Tile 你需要做更多的工作

1245
00:41:27,036 --> 0:41:27,946
特别是那些最初为电脑

1246
00:41:27,946 --> 0:41:28,986
和主机设计的游戏

1247
00:41:29,476 --> 0:41:31,266
现在我们将谈论

1248
00:41:31,266 --> 0:41:32,456
这个问题 并将我们刚刚讨论过的

1249
00:41:32,456 --> 0:41:34,036
内容付诸实践 我想邀请

1250
00:41:34,036 --> 0:41:35,716
Epic Games 的 Nick Penwarden 上台

1251
00:41:36,146 --> 0:41:40,566
Nick [ 掌声 ]

1252
00:41:41,066 --> 0:41:41,736
&gt;&gt; 谢谢 Michael

1253
00:41:42,876 --> 0:41:44,086
嗯 我想谈一谈

1254
00:41:44,086 --> 0:41:46,236
一些关于我们如何把

1255
00:41:46,236 --> 0:41:47,906
最初用于电脑和主机平台的游戏

1256
00:41:47,986 --> 0:41:50,786
使用 Metal 技术

1257
00:41:50,786 --> 0:41:53,326
将其引入 iOS 平台的问题

1258
00:41:53,906 --> 0:41:56,126
我们面临的一些

1259
00:41:56,126 --> 0:41:57,206
技术上的挑战

1260
00:41:57,206 --> 0:42:00,556
堡垒之夜的地图是 1 张地图

1261
00:41:57,206 --> 0:42:00,556
堡垒之夜的地图是 1 张地图

1262
00:42:00,556 --> 0:42:02,426
它大于 6 平方公里

1263
00:42:02,946 --> 0:42:04,976
这意味着它不适合

1264
00:42:04,976 --> 0:42:05,856
全部储存在内存中

1265
00:42:06,466 --> 0:42:07,726
我们也有动态的时间

1266
00:42:07,726 --> 0:42:09,266
流动和破坏

1267
00:42:09,266 --> 0:42:10,476
玩家可以摧毁

1268
00:42:10,476 --> 0:42:11,866
场景中的任何物体

1269
00:42:12,286 --> 0:42:14,386
玩家也可以建立自己的建筑

1270
00:42:14,726 --> 0:42:15,896
所以地图非常动态

1271
00:42:15,956 --> 0:42:16,916
这意味着我们不能做

1272
00:42:16,996 --> 0:42:17,856
很多预计算

1273
00:42:18,286 --> 0:42:21,846
我们在地图上有 100 个玩家

1274
00:42:21,846 --> 0:42:24,166
地图上有超过 50,000

1275
00:42:24,166 --> 0:42:25,506
个复制角色 这些

1276
00:42:25,506 --> 0:42:27,286
复制角色在服务器上模拟

1277
00:42:27,286 --> 0:42:28,506
并复制到客户端

1278
00:42:29,806 --> 0:42:31,216
最后 我们希望支持

1279
00:42:31,216 --> 0:42:33,246
主机和电脑

1280
00:42:33,246 --> 0:42:35,336
以及移动设备之间的联机游玩

1281
00:42:36,126 --> 0:42:37,206
这实际上是非常重要

1282
00:42:37,206 --> 0:42:38,396
的一点 因为它

1283
00:42:38,396 --> 0:42:39,926
限制了我们用

1284
00:42:39,926 --> 0:42:42,546
缩减游戏的体量

1285
00:42:42,546 --> 0:42:45,486
的方法来适应​​设备的

1286
00:42:45,486 --> 0:42:46,686
性能限制

1287
00:42:47,096 --> 0:42:48,776
基本上 如果有什么东西影响了

1288
00:42:48,776 --> 0:42:50,496
游戏玩法 我们不能改变它

1289
00:42:50,756 --> 0:42:52,016
所以如果有一个对象

1290
00:42:52,016 --> 0:42:53,186
它真的很小 它真的很遥远

1291
00:42:53,186 --> 0:42:55,166
也许通常情况下你会剔除它

1292
00:42:55,316 --> 0:42:57,306
但在以下这种情况下

1293
00:42:57,306 --> 0:42:58,836
我们不能 因为如果

1294
00:42:58,836 --> 0:43:00,306
玩家可以躲在它后面

1295
00:42:58,836 --> 0:43:00,306
玩家可以躲在它后面

1296
00:43:00,306 --> 0:43:02,666
我们就需要渲染它

1297
00:43:02,936 --> 0:43:04,906
所以现在我们来谈一谈

1298
00:43:04,906 --> 0:43:05,906
Metal 技术

1299
00:43:05,906 --> 0:43:07,306
Metal 技术在让我们

1300
00:43:07,306 --> 0:43:09,946
能够快速地运行游戏

1301
00:43:09,946 --> 0:43:12,086
以及让我们能够

1302
00:43:12,116 --> 0:43:13,396
实现的游戏品质方面

1303
00:43:13,396 --> 0:43:13,816
非常重要

1304
00:43:14,486 --> 0:43:15,876
绘制调用的表现是关键

1305
00:43:15,876 --> 0:43:17,626
因为我们有

1306
00:43:17,626 --> 0:43:20,776
一个非常复杂的场景

1307
00:43:20,776 --> 0:43:22,066
我们需要渲染来

1308
00:43:22,066 --> 0:43:23,406
呈现它 而 Metal 技术给了我们

1309
00:43:23,446 --> 0:43:24,116
这样的结果

1310
00:43:24,696 --> 0:43:26,196
Metal 技术还让我们

1311
00:43:26,196 --> 0:43:27,386
能够访问许多硬件功能

1312
00:43:27,386 --> 0:43:28,636
例如可编程混合

1313
00:43:28,636 --> 0:43:30,486
这些硬件特性使我们重新获得

1314
00:43:30,486 --> 0:43:31,566
重要的 GPU 性能

1315
00:43:32,286 --> 0:43:33,546
它还具有一套功能

1316
00:43:33,546 --> 0:43:34,866
这套功能包含了

1317
00:43:34,866 --> 0:43:36,316
可以让我们将堡垒之夜带到 iOS

1318
00:43:36,316 --> 0:43:38,506
所需的所有渲染技术

1319
00:43:38,856 --> 0:43:40,236
就渲染而言

1320
00:43:40,676 --> 0:43:42,056
我们使用可移动的

1321
00:43:42,056 --> 0:43:43,446
定向光来照明

1322
00:43:43,446 --> 0:43:44,226
级联阴影贴图

1323
00:43:44,226 --> 0:43:45,386
我们有一个可移动的天窗

1324
00:43:45,386 --> 0:43:47,016
因为天空整天都在变化

1325
00:43:47,786 --> 0:43:49,936
我们使用基于物理的材质

1326
00:43:51,436 --> 0:43:52,936
我们在 HDR 中进行渲染

1327
00:43:52,936 --> 0:43:54,306
并在最后进行色调映射

1328
00:43:55,476 --> 0:43:57,286
我们允许在 GPU 上

1329
00:43:57,286 --> 0:43:58,036
进行粒子模拟

1330
00:43:58,076 --> 0:43:59,456
我们也支持我们所有的

1331
00:43:59,456 --> 0:44:00,806
开发者自制的材质

1332
00:43:59,456 --> 0:44:00,806
开发者自制的材质

1333
00:44:01,416 --> 0:44:03,616
这实际上是非常重要的一点

1334
00:44:03,646 --> 0:44:05,796
因为我们的

1335
00:44:05,796 --> 0:44:08,316
一些材质实际上非常复杂

1336
00:44:08,316 --> 0:44:10,786
例如 我们用于

1337
00:44:10,786 --> 0:44:12,006
高效渲染树木的东西

1338
00:44:12,006 --> 0:44:13,496
完全是由开发者

1339
00:44:13,496 --> 0:44:16,636
在 Epic 中使用蓝图和

1340
00:44:16,636 --> 0:44:20,796
材质着色器图形创建的

1341
00:44:22,676 --> 0:44:24,086
接着我们刚刚说的话题

1342
00:44:24,086 --> 0:44:25,896
这里是堡垒之夜

1343
00:44:25,896 --> 0:44:27,696
以高可扩展性在 Mac 上

1344
00:44:27,696 --> 0:44:28,806
运行的图像

1345
00:44:30,016 --> 0:44:31,506
这在中等可扩展性下

1346
00:44:31,506 --> 0:44:33,716
运行在 Mac 上的图像

1347
00:44:34,826 --> 0:44:36,296
这里是在 iPhone 8 Plus

1348
00:44:36,336 --> 0:44:36,826
上运行的图像

1349
00:44:37,296 --> 0:44:38,706
所以我们能够在 iPhone 上

1350
00:44:38,706 --> 0:44:41,136
以我们在中端 Mac 上

1351
00:44:41,556 --> 0:44:42,836
呈现的品质完全地

1352
00:44:42,836 --> 0:44:44,276
表现游戏的质量

1353
00:44:44,816 --> 0:44:48,796
所以我们来谈一谈可扩展性

1354
00:44:49,526 --> 0:44:50,736
我们处理跨平台

1355
00:44:50,736 --> 0:44:52,156
和 iOS 系统的

1356
00:44:52,156 --> 0:44:53,616
可扩展性

1357
00:44:54,216 --> 0:44:55,986
因此 跨平台时

1358
00:44:55,986 --> 0:44:57,616
我们需要在平台上安装这一些东西

1359
00:44:57,616 --> 0:44:59,936
比如从网格中

1360
00:44:59,936 --> 0:45:01,456
移除永远不会显示的 LOD

1361
00:44:59,936 --> 0:45:01,456
移除永远不会显示的 LOD

1362
00:45:01,456 --> 0:45:03,016
因此我们可以把它

1363
00:45:03,466 --> 0:45:06,096
放入内存或更改我们在

1364
00:45:06,096 --> 0:45:08,866
特定级别上动画的

1365
00:45:08,866 --> 0:45:11,696
角色数量 以降低 CPU 成本

1366
00:45:12,736 --> 0:45:14,776
在 iOS 平台内部 我们还定义了 3 个

1367
00:45:14,776 --> 0:45:17,116
可扩展性 - 低

1368
00:45:17,116 --> 0:45:19,056
中 高 - 这些

1369
00:45:19,056 --> 0:45:20,136
通常与不同代

1370
00:45:20,136 --> 0:45:21,736
iPhone 相关

1371
00:45:21,806 --> 0:45:24,116
所以 iPhone 6 使用低端

1372
00:45:24,116 --> 0:45:26,046
iPhone 7 使用中档

1373
00:45:26,046 --> 0:45:27,806
iPhone 8 和

1374
00:45:27,806 --> 0:45:31,366
iPhone X 使用高端

1375
00:45:31,366 --> 0:45:34,226
分辨率显然是

1376
00:45:34,226 --> 0:45:36,356
我们拥有的最简单和最佳的

1377
00:45:36,516 --> 0:45:37,446
可扩展性选项

1378
00:45:37,786 --> 0:45:39,266
我们最终调整了每个设备

1379
00:45:39,766 --> 0:45:41,186
我们倾向于

1380
00:45:41,186 --> 0:45:42,456
在可能的情况下 使用后备缓冲分辨率

1381
00:45:42,456 --> 0:45:43,836
这是用户界面呈现的内容所决定的

1382
00:45:44,346 --> 0:45:45,996
因为如果我们这样做

1383
00:45:45,996 --> 0:45:47,676
那么我们不必支付单独的

1384
00:45:47,676 --> 0:45:48,726
上采样成本

1385
00:45:49,196 --> 0:45:50,746
但是 我们确实支持

1386
00:45:50,786 --> 0:45:52,736
以较低的分辨率

1387
00:45:52,736 --> 0:45:54,566
渲染 3D 分辨率 在某些情况下

1388
00:45:54,566 --> 0:45:56,826
我们需要一个清晰的用户界面

1389
00:45:56,826 --> 0:45:58,886
但不得不降低 3D 渲染

1390
00:45:58,886 --> 0:46:00,746
分辨率来适配

1391
00:45:58,886 --> 0:46:00,746
分辨率来适配

1392
00:46:00,746 --> 0:46:01,866
我们的性能 

1393
00:46:01,866 --> 0:46:04,456
以 iPhone 6s 为例

1394
00:46:06,176 --> 0:46:07,846
阴影是可扩展性的另一个轴

1395
00:46:07,846 --> 0:46:09,296
并且它非常重要

1396
00:46:09,296 --> 0:46:10,576
因为它们同时影响

1397
00:46:10,686 --> 0:46:12,376
CPU 和 GPU

1398
00:46:13,056 --> 0:46:15,076
在低端设备上

1399
00:46:15,076 --> 0:46:16,276
我们不呈现任何阴影

1400
00:46:16,586 --> 0:46:17,956
在我们的中档设备上

1401
00:46:17,956 --> 0:46:21,016
我们有 1 个级联 1024 乘 1024 大小

1402
00:46:21,506 --> 0:46:22,726
我们将距离设置为

1403
00:46:22,726 --> 0:46:24,006
与近似于建筑物的大小的数值

1404
00:46:24,006 --> 0:46:25,136
因此如果你位于建筑物内部

1405
00:46:25,426 --> 0:46:26,276
则不会看到另一侧的

1406
00:46:26,276 --> 0:46:28,056
光线泄漏

1407
00:46:28,736 --> 0:46:29,936
高端设备增加了第二个级联

1408
00:46:29,936 --> 0:46:31,246
这样可以提供更清晰的

1409
00:46:31,246 --> 0:46:32,586
人物阴影

1410
00:46:32,586 --> 0:46:34,096
并让我们可以进一步

1411
00:46:34,096 --> 0:46:35,966
推出阴影距离

1412
00:46:37,406 --> 0:46:38,956
植物是可扩展性的

1413
00:46:38,956 --> 0:46:39,646
另一个轴

1414
00:46:39,996 --> 0:46:41,426
在低端设备上

1415
00:46:41,426 --> 0:46:42,486
我们根本不渲染植物

1416
00:46:42,756 --> 0:46:43,656
在中等设备内 我们

1417
00:46:43,656 --> 0:46:45,556
呈现了我们在主机上支持的大约

1418
00:46:45,556 --> 0:46:46,516
30％ 的密度的植物阴影

1419
00:46:46,816 --> 0:46:47,936
在高端设备上 我们

1420
00:46:47,936 --> 0:46:49,716
实际上可以实现

1421
00:46:49,716 --> 0:46:50,836
我们在主机上支持的

1422
00:46:50,836 --> 0:46:51,266
100％ 的密度

1423
00:46:53,956 --> 0:46:55,666
内存在可扩展性

1424
00:46:55,666 --> 0:46:57,006
方面很有意思

1425
00:46:57,006 --> 0:46:58,296
因为它并不总是与

1426
00:46:58,336 --> 0:46:59,006
性能相关

1427
00:46:59,456 --> 0:47:00,866
例如 iPhone 8

1428
00:46:59,456 --> 0:47:00,866
例如 iPhone 8

1429
00:47:00,866 --> 0:47:02,336
比 iPhone 7 Plus 快

1430
00:47:02,336 --> 0:47:03,796
但它的物理内存更少

1431
00:47:04,256 --> 0:47:05,146
这意味着当你考虑到

1432
00:47:05,146 --> 0:47:06,506
可扩展性时 你需要

1433
00:47:06,506 --> 0:47:07,936
以不同的方式处理内存

1434
00:47:07,936 --> 0:47:09,786
我们最终将它

1435
00:47:09,786 --> 0:47:11,616
视为可伸缩性的正交轴

1436
00:47:12,226 --> 0:47:14,256
并且只有 2 个分类

1437
00:47:14,256 --> 0:47:15,226
分别是低内存和高内存

1438
00:47:16,046 --> 0:47:17,506
对于低存储设备

1439
00:47:17,506 --> 0:47:18,926
我们禁用了植物和阴影

1440
00:47:19,446 --> 0:47:21,656
我们还减少了一些内存池

1441
00:47:21,656 --> 0:47:23,296
因此 例如 我们

1442
00:47:23,296 --> 0:47:25,396
将 GPU 颗粒限制在总计 16,000 个

1443
00:47:25,846 --> 0:47:27,416
并减少了美化和纹理记忆池

1444
00:47:27,416 --> 0:47:29,246
的使用量

1445
00:47:29,816 --> 0:47:32,926
但我们仍然需要

1446
00:47:32,926 --> 0:47:34,266
进行相当多的内存优化

1447
00:47:34,266 --> 0:47:35,846
才能让游戏在该设备上运行

1448
00:47:36,366 --> 0:47:37,816
最重要的是

1449
00:47:37,816 --> 0:47:38,936
级别流 基本上

1450
00:47:38,936 --> 0:47:40,046
只是确保如果

1451
00:47:40,046 --> 0:47:41,176
对象不在玩家身边

1452
00:47:41,176 --> 0:47:41,566
就不占任何内存

1453
00:47:42,356 --> 0:47:44,606
在大多数情况下

1454
00:47:44,606 --> 0:47:46,116
我们还使用 ASTC 纹理压缩

1455
00:47:46,416 --> 0:47:48,776
并倾向于在大小而不是

1456
00:47:48,836 --> 0:47:50,476
质量上进行压缩

1457
00:47:50,846 --> 0:47:52,236
而且我们还为我们的

1458
00:47:52,236 --> 0:47:54,106
开发者提供了很多工具

1459
00:47:54,506 --> 0:47:57,426
可以用来制作不同的 LOD

1460
00:47:57,426 --> 0:47:59,946
它们有些不是必须的

1461
00:47:59,946 --> 0:48:02,326
或者有些可以减少每个平台的音频变化

1462
00:47:59,946 --> 0:48:02,326
或者有些可以减少每个平台的音频变化

1463
00:48:04,926 --> 0:48:06,736
接下来我想谈一下帧速率目标

1464
00:48:07,156 --> 0:48:08,566
所以在 iOS 上 我们希望

1465
00:48:08,566 --> 0:48:10,546
可以达到最高的视觉

1466
00:48:10,546 --> 0:48:11,626
保真度 30 fps

1467
00:48:12,176 --> 0:48:14,426
但是 你不能仅仅将设备的性能达到最大化

1468
00:48:14,426 --> 0:48:15,766
如果我们在整个时间内

1469
00:48:15,766 --> 0:48:17,676
最大限度地利用 CPU 和 GPU

1470
00:48:17,676 --> 0:48:19,466
操作系统最终会降低

1471
00:48:19,526 --> 0:48:21,206
我们的速度 那么我们就

1472
00:48:21,206 --> 0:48:22,486
不会再达到目标帧速率

1473
00:48:22,486 --> 0:48:25,126
我们同时也想要延长电池寿命

1474
00:48:25,476 --> 0:48:26,776
如果玩家在通勤过程

1475
00:48:26,776 --> 0:48:27,786
中连续玩几场比赛 我们希望

1476
00:48:27,786 --> 0:48:30,336
在他们开始玩

1477
00:48:30,336 --> 0:48:31,806
之前帮助他们

1478
00:48:31,806 --> 0:48:32,916
而不是使他们的设备死机

1479
00:48:33,766 --> 0:48:36,716
所以为此 我们决定

1480
00:48:36,716 --> 0:48:38,216
做的是针对环境时

1481
00:48:38,216 --> 0:48:39,686
达到每秒 60 帧

1482
00:48:39,686 --> 0:48:41,796
但是在垂直同步（VSync）时

1483
00:48:41,796 --> 0:48:42,936
达到 30 帧 这意味着

1484
00:48:43,106 --> 0:48:45,306
大多数时候当你在堡垒之夜探索地图时

1485
00:48:45,306 --> 0:48:47,146
手机将闲置约 50％ 时间

1486
00:48:47,216 --> 0:48:48,236
我们利用这段时间来延长电池寿命

1487
00:48:48,236 --> 0:48:49,986
并保持设备凉爽

1488
00:48:52,476 --> 0:48:53,916
为了确保我们能够

1489
00:48:53,916 --> 0:48:56,006
达到这些目标 我们每天跟踪

1490
00:48:56,006 --> 0:48:56,896
帧速率的表现

1491
00:48:57,396 --> 0:48:58,546
我们每天都有

1492
00:48:58,546 --> 0:49:00,496
一个自动化的通道用来做这个

1493
00:48:58,546 --> 0:49:00,496
一个自动化的通道用来做这个

1494
00:49:00,976 --> 0:49:04,106
我们看一看地图中的关键位置

1495
00:49:04,106 --> 0:49:06,056
并捕捉性能

1496
00:49:06,056 --> 0:49:08,126
例如 斜塔小镇

1497
00:49:08,126 --> 0:49:09,616
和矿井以及

1498
00:49:09,616 --> 0:49:11,396
你在堡垒之夜中所有

1499
00:49:11,396 --> 0:49:12,756
熟悉的常见兴趣点

1500
00:49:13,356 --> 0:49:15,126
当超过预算时

1501
00:49:15,126 --> 0:49:16,506
我们需要深入了解

1502
00:49:16,506 --> 0:49:17,676
了解性能进展情况

1503
00:49:17,676 --> 0:49:18,356
并对它进行优化

1504
00:49:18,966 --> 0:49:20,486
我们每天都会有一个 100 人

1505
00:49:20,486 --> 0:49:22,346
的玩家测试

1506
00:49:22,346 --> 0:49:23,566
用来捕捉你只能在游戏中看到的

1507
00:49:23,566 --> 0:49:24,696
帧速率动态表现

1508
00:49:25,246 --> 0:49:26,436
我们跟踪比赛时的

1509
00:49:26,436 --> 0:49:29,376
帧速率的关键表现

1510
00:49:29,376 --> 0:49:30,116
然后我们可以看一看

1511
00:49:30,116 --> 0:49:32,176
看看它是如何工作的

1512
00:49:32,176 --> 0:49:34,566
如何寻找连结

1513
00:49:34,566 --> 0:49:35,296
类似于这样的东西

1514
00:49:35,806 --> 0:49:37,966
如果出现问题

1515
00:49:37,966 --> 0:49:39,596
我们可以从设备中

1516
00:49:39,596 --> 0:49:41,256
取出设备配置文件

1517
00:49:41,256 --> 0:49:42,686
查看时间到底去了哪里

1518
00:49:42,686 --> 0:49:44,106
找出我们需要优化的地方

1519
00:49:45,086 --> 0:49:46,336
我们也支持重播

1520
00:49:46,336 --> 0:49:48,956
这是虚幻引擎的一个功能

1521
00:49:48,956 --> 0:49:50,546
它允许我们从玩家的角度去

1522
00:49:50,546 --> 0:49:51,986
重放比赛

1523
00:49:51,986 --> 0:49:53,266
所以我们可以反复播放

1524
00:49:53,266 --> 0:49:55,706
分析它 解剖它

1525
00:49:55,706 --> 0:49:57,306
甚至看看优化会

1526
00:49:57,306 --> 0:50:00,206
如何影响客户在游戏中的表现

1527
00:49:57,306 --> 0:50:00,206
如何影响客户在游戏中的表现

1528
00:50:01,976 --> 0:50:03,726
接下来我们专门

1529
00:50:03,726 --> 0:50:04,896
讨论一下 Metal 技术

1530
00:50:05,716 --> 0:50:09,006
我们在大多数设备上

1531
00:50:09,006 --> 0:50:11,786
都有 2 个核心 是的

1532
00:50:11,786 --> 0:50:13,626
所以我们使用的方式是

1533
00:50:14,206 --> 0:50:14,966
我们有一个传统的游戏主线

1534
00:50:14,966 --> 0:50:16,196
和渲染线程的拆分

1535
00:50:16,576 --> 0:50:17,676
在游戏主线上

1536
00:50:17,676 --> 0:50:19,086
我们正在进行联网 模拟

1537
00:50:19,086 --> 0:50:20,746
动画 物理等等工作

1538
00:50:21,316 --> 0:50:22,546
渲染线程执行

1539
00:50:22,546 --> 0:50:25,796
所有场景遍历剔除并

1540
00:50:25,796 --> 0:50:26,316
发布所有 Metal API 调用

1541
00:50:26,646 --> 0:50:29,316
我们也有一个异步线程

1542
00:50:29,626 --> 0:50:31,026
大多数情况下 它处理

1543
00:50:31,026 --> 0:50:32,796
流式传输任务 纹理流式传输

1544
00:50:32,796 --> 0:50:34,386
以及级别流式传输

1545
00:50:36,006 --> 0:50:37,726
在拥有 2 个快速内核

1546
00:50:37,726 --> 0:50:39,996
和 4 个高效内核的新设备上

1547
00:50:39,996 --> 0:50:41,456
我们增加了 3 个任务线程

1548
00:50:41,456 --> 0:50:42,656
并启用了虚幻引擎中的一些

1549
00:50:42,656 --> 0:50:44,186
并行算法

1550
00:50:44,796 --> 0:50:48,526
所以我们采取动画在多帧

1551
00:50:48,526 --> 0:50:51,126
CPU 粒子 物理等条件下

1552
00:50:51,126 --> 0:50:53,926
进行模拟 场景剔除

1553
00:50:53,926 --> 0:50:55,056
以及其他一些任务

1554
00:50:57,376 --> 0:50:59,166
我之前提到过绘图调用

1555
00:50:59,296 --> 0:51:00,916
绘图调用是我们的主要的

1556
00:50:59,296 --> 0:51:00,916
绘图调用是我们的主要的

1557
00:51:00,916 --> 0:51:02,586
表现瓶颈 而这实际上

1558
00:51:02,586 --> 0:51:03,836
是 Metal 技术真正帮助

1559
00:51:03,836 --> 0:51:04,536
到我们的地方

1560
00:51:05,516 --> 0:51:07,346
我们发现使用 Metal 技术

1561
00:51:07,346 --> 0:51:08,606
比使用 OpenGL 速度要

1562
00:51:08,606 --> 0:51:10,666
快 3 到 4 倍 这使我们

1563
00:51:10,666 --> 0:51:12,876
能够在没有进行

1564
00:51:12,876 --> 0:51:14,206
大量关于减少绘图调用的

1565
00:51:14,206 --> 0:51:15,876
积极工作的情况下进行交流

1566
00:51:16,186 --> 0:51:17,276
我们做了一些工作

1567
00:51:17,276 --> 0:51:19,116
来减少绘图调用

1568
00:51:19,116 --> 0:51:20,946
主要是在装饰物体上

1569
00:51:20,946 --> 0:51:23,236
剔除距离 并利用

1570
00:51:23,236 --> 0:51:25,236
细节系统的层次结构

1571
00:51:27,696 --> 0:51:29,066
这里是一个例子

1572
00:51:29,066 --> 0:51:30,656
这是我们一直追踪的

1573
00:51:30,656 --> 0:51:31,726
感兴趣的地点之一

1574
00:51:32,176 --> 0:51:33,006
如果你对游戏非常熟悉

1575
00:51:33,006 --> 0:51:34,216
那么这从悬崖上俯视斜塔小镇

1576
00:51:34,216 --> 0:51:38,386
的视角 也是我们在

1577
00:51:38,386 --> 0:51:40,866
地图上的频繁使用绘图调用的地点

1578
00:51:41,396 --> 0:51:42,686
正如你所看到的

1579
00:51:42,686 --> 0:51:45,056
它大约需要 1300 次绘制调来渲染

1580
00:51:45,196 --> 0:51:46,476
这只是主要的传递

1581
00:51:46,476 --> 0:51:47,896
它不包括阴影

1582
00:51:48,776 --> 0:51:50,126
用户界面 其他任何

1583
00:51:50,126 --> 0:51:50,686
消耗绘图调用时间的内容

1584
00:51:51,196 --> 0:51:52,606
但在这里使用 Metal 技术 真的可以变得很快

1585
00:51:52,606 --> 0:51:53,766
在 iPhone 8 Plus 上

1586
00:51:53,766 --> 0:51:56,266
我们能够在 5 毫秒的时间内完成

1587
00:51:58,456 --> 0:51:59,946
我提到了分级 LOD

1588
00:51:59,946 --> 0:52:01,446
这是虚幻引擎中的一项功能

1589
00:51:59,946 --> 0:52:01,446
这是虚幻引擎中的一项功能

1590
00:52:01,486 --> 0:52:02,806
我们可以进行

1591
00:52:03,276 --> 0:52:04,976
多次绘图调用并生成

1592
00:52:04,976 --> 0:52:06,226
一个简化版本

1593
00:52:06,226 --> 0:52:08,426
简化网格以及材质

1594
00:52:08,426 --> 0:52:09,466
以便我们可以在

1595
00:52:09,466 --> 0:52:10,286
单个绘图调用中

1596
00:52:10,286 --> 0:52:14,176
渲染该区域的基本

1597
00:52:14,176 --> 0:52:15,036
表示形式

1598
00:52:15,526 --> 0:52:18,116
我们使用它来获取

1599
00:52:18,356 --> 0:52:19,566
我们感兴趣的地点

1600
00:52:19,566 --> 0:52:20,906
生成用于渲染当距离非常

1601
00:52:20,906 --> 0:52:21,646
非常遥远的简化版本

1602
00:52:22,056 --> 0:52:22,816
例如 在跳伞期间

1603
00:52:22,816 --> 0:52:24,696
你可以看到整个地图

1604
00:52:25,166 --> 0:52:26,296
事实上 当你在地图上时

1605
00:52:26,296 --> 0:52:28,086
你可以爬上悬崖

1606
00:52:28,166 --> 0:52:29,606
或者建造一座非常高的属于

1607
00:52:29,606 --> 0:52:32,096
自己的塔楼 你可以看到

1608
00:52:32,096 --> 0:52:33,616
距离自己 2 公里远的风景

1609
00:52:35,936 --> 0:52:38,056
接下来我将深入探讨

1610
00:52:38,056 --> 0:52:40,476
Metal 的其他细节

1611
00:52:40,476 --> 0:52:41,376
我想谈一谈一些关于

1612
00:52:41,376 --> 0:52:42,366
管线状态对象的内容

1613
00:52:42,366 --> 0:52:43,546
这是花一点时间

1614
00:52:43,546 --> 0:52:44,706
才能进入堡垒之夜的

1615
00:52:44,706 --> 0:52:46,146
内部运输状态

1616
00:52:46,796 --> 0:52:48,116
你非常想最小化

1617
00:52:48,116 --> 0:52:50,446
你在框架中模拟游戏时

1618
00:52:50,446 --> 0:52:52,286
创建的管线状态对象数量

1619
00:52:52,586 --> 0:52:53,816
如果你创造的太多

1620
00:52:53,816 --> 0:52:55,396
就很容易造成故障

1621
00:52:55,396 --> 0:52:56,686
并造成糟糕的游戏体验

1622
00:52:57,236 --> 0:52:58,606
首先 请遵循最佳

1623
00:52:58,606 --> 0:52:59,456
实践准则 对

1624
00:52:59,846 --> 0:53:01,266
离线编译你的函数

1625
00:52:59,846 --> 0:53:01,266
离线编译你的函数

1626
00:53:01,266 --> 0:53:03,426
离线构建你的函数库

1627
00:53:03,476 --> 0:53:04,566
并将所有函数提取到

1628
00:53:04,566 --> 0:53:05,326
单个函数库中

1629
00:53:05,846 --> 0:53:07,056
但是你实在是想

1630
00:53:07,056 --> 0:53:08,656
确保在加载时创建所有

1631
00:53:08,656 --> 0:53:09,146
管线状态对象

1632
00:53:09,556 --> 0:53:11,346
但是如果你不能这样做 你会怎么办

1633
00:53:11,786 --> 0:53:12,966
所以对于我们来说

1634
00:53:12,966 --> 0:53:14,086
置换矩阵只是一个疯狂的行为

1635
00:53:14,136 --> 0:53:15,516
对于我们来说

1636
00:53:15,516 --> 0:53:18,016
在加载时 实际创建的方式太多了

1637
00:53:18,076 --> 0:53:20,586
我们有多个开发者创作的着色器

1638
00:53:20,586 --> 0:53:22,286
数千个着色器

1639
00:53:22,846 --> 0:53:24,306
基于阴影级联数量

1640
00:53:24,306 --> 0:53:26,356
的多个照明场景等

1641
00:53:26,356 --> 0:53:28,926
不同渲染目标格式

1642
00:53:28,926 --> 0:53:30,546
MSAA

1643
00:53:30,776 --> 0:53:31,516
名单有很长

1644
00:53:32,726 --> 0:53:33,576
我们尽可能减少

1645
00:53:33,576 --> 0:53:35,116
排列组合的数量

1646
00:53:35,116 --> 0:53:35,776
这确实有帮助

1647
00:53:35,776 --> 0:53:37,136
有时候动态分支比

1648
00:53:37,136 --> 0:53:38,626
创建静态排列表现

1649
00:53:38,626 --> 0:53:42,356
更好 但有时候就不行

1650
00:53:42,736 --> 0:53:44,716
我们必须要做的是

1651
00:53:44,716 --> 0:53:45,966
决定可能需要的

1652
00:53:45,966 --> 0:53:47,186
最常见的子集

1653
00:53:47,186 --> 0:53:49,196
并且在载入时创建这些子集

1654
00:53:49,566 --> 0:53:50,856
我们不试图创造一切

1655
00:53:51,306 --> 0:53:52,576
我们实现这一目标

1656
00:53:52,576 --> 0:53:54,116
的方式是创建了一个自动化的管线

1657
00:53:54,116 --> 0:53:55,296
我们基本上是在环境中

1658
00:53:55,296 --> 0:53:56,716
安装了一台摄像机

1659
00:53:56,716 --> 0:53:58,116
并记录了所有的

1660
00:53:58,116 --> 0:53:59,286
需要实际渲染环境的

1661
00:53:59,286 --> 0:53:59,876
管线状态对象

1662
00:54:00,316 --> 0:54:01,226
然后 在我们的日常

1663
00:54:01,226 --> 0:54:03,396
测试中 我们获得了

1664
00:54:03,396 --> 0:54:06,106
所有未被该自动化管线

1665
00:54:06,106 --> 0:54:07,576
所捕获的管线状态对象

1666
00:54:07,966 --> 0:54:09,276
自动化管线也

1667
00:54:09,756 --> 0:54:12,476
可以捕获像美化

1668
00:54:12,896 --> 0:54:14,176
和发射不同武器的效果

1669
00:54:14,176 --> 0:54:15,136
等等对象

1670
00:54:16,556 --> 0:54:18,056
我们把从自动化

1671
00:54:18,056 --> 0:54:19,126
和游戏测试中获取

1672
00:54:19,126 --> 0:54:20,666
所有这些信息组合成一个列表

1673
00:54:20,856 --> 0:54:22,486
这是我们在加载时创建的

1674
00:54:22,486 --> 0:54:24,416
也是我们随游戏一起运行的内容

1675
00:54:24,956 --> 0:54:26,266
这并不完美 但我们发现

1676
00:54:26,266 --> 0:54:27,556
我们在运行时创建的

1677
00:54:27,556 --> 0:54:28,686
管线状态对象数量

1678
00:54:28,686 --> 0:54:31,146
平均为任何游戏部分创建的个位数

1679
00:54:31,516 --> 0:54:32,926
所以玩家不会遇到任何

1680
00:54:32,926 --> 0:54:34,846
生成管线状态对象的麻烦

1681
00:54:37,356 --> 0:54:39,096
资源分配

1682
00:54:39,196 --> 0:54:43,216
所以基本上 创建和

1683
00:54:43,366 --> 0:54:46,466
删除资源是昂贵的

1684
00:54:46,466 --> 0:54:47,326
或可能是昂贵的

1685
00:54:47,326 --> 0:54:50,046
这有点像 想一想

1686
00:54:50,046 --> 0:54:50,113
[ 音质不清晰 ]

1687
00:54:50,113 --> 0:54:51,166
你非常想尽可能

1688
00:54:51,166 --> 0:54:52,276
减少你每帧

1689
00:54:52,276 --> 0:54:53,036
制作的 [ 音质不清晰 ] 数量

1690
00:54:53,436 --> 0:54:54,246
你非常不想

1691
00:54:54,246 --> 0:54:55,416
动态创建和销毁

1692
00:54:55,416 --> 0:54:57,246
大量资源 但是当你

1693
00:54:57,246 --> 0:54:58,476
动态地在内容中进行流式传输时

1694
00:54:58,656 --> 0:55:00,606
当你有很多

1695
00:54:58,656 --> 0:55:00,606
当你有很多

1696
00:55:00,606 --> 0:55:02,746
可移动的对象时

1697
00:55:02,866 --> 0:55:05,026
有些操作是无法避免的

1698
00:55:05,646 --> 0:55:09,636
所以我们对缓冲区所做的

1699
00:55:09,806 --> 0:55:11,276
只是使用缓冲区子分配 

1700
00:55:11,276 --> 0:55:13,006
基本上是一种不直接分配的策略

1701
00:55:13,346 --> 0:55:14,476
首先 我们分配一个大缓冲区

1702
00:55:14,476 --> 0:55:15,996
然后我们将大缓冲区

1703
00:55:16,606 --> 0:55:19,146
分成小块并重新分配回引擎

1704
00:55:19,146 --> 0:55:20,906
以回避始终向 Metal

1705
00:55:20,906 --> 0:55:22,776
请求新的缓冲区的操作

1706
00:55:23,056 --> 0:55:24,446
而这最终起到了很大的作用

1707
00:55:25,976 --> 0:55:27,636
我们还利用可编程混合

1708
00:55:27,636 --> 0:55:30,186
来减少解析

1709
00:55:30,186 --> 0:55:31,906
和恢复次数

1710
00:55:31,906 --> 0:55:33,786
以及我们使用的内存带宽量

1711
00:55:34,356 --> 0:55:36,596
具体来说 我们对此的

1712
00:55:36,596 --> 0:55:38,536
主要使用场景是任何我们

1713
00:55:38,536 --> 0:55:40,336
需要访问场景深度的地方

1714
00:55:40,336 --> 0:55:41,416
例如软粒子混合

1715
00:55:41,416 --> 0:55:43,286
或投影贴图

1716
00:55:43,286 --> 0:55:45,036
我们所做的是在

1717
00:55:45,036 --> 0:55:46,586
正向传递期间将线性深度

1718
00:55:46,586 --> 0:55:47,546
写入 Alpha 通道

1719
00:55:47,946 --> 0:55:49,126
然后 在我们

1720
00:55:49,126 --> 0:55:50,546
的贴图和半透明化的过程中

1721
00:55:50,546 --> 0:55:52,246
我们需要做的就是

1722
00:55:52,246 --> 0:55:53,266
使用可编程混合来

1723
00:55:53,266 --> 0:55:55,146
读取该 Alpha 通道

1724
00:55:55,146 --> 0:55:57,796
并且可以使用深度信息

1725
00:55:57,916 --> 0:56:00,186
而不必将深度缓冲区解析到主内存

1726
00:55:57,916 --> 0:56:00,186
而不必将深度缓冲区解析到主内存

1727
00:56:01,916 --> 0:56:03,006
我们也使用它来提高

1728
00:56:03,006 --> 0:56:04,286
MSAA 的质量

1729
00:56:04,806 --> 0:56:06,356
正如我所提到的

1730
00:56:06,356 --> 0:56:08,316
我们进行 HDR 渲染 但是

1731
00:56:08,316 --> 0:56:10,906
仅仅是 HDR 的 MSAA 解析仍然会

1732
00:56:10,906 --> 0:56:12,116
导致非常参差的边缘

1733
00:56:12,506 --> 0:56:13,556
想想你有一个

1734
00:56:13,556 --> 0:56:15,226
非常非常明亮的天空和

1735
00:56:15,226 --> 0:56:16,636
非常非常黑暗的前视图的情况

1736
00:56:17,126 --> 0:56:19,616
这时只需要做一个

1737
00:56:19,616 --> 0:56:22,526
盒式过滤器就可以了 基本上

1738
00:56:22,526 --> 0:56:24,396
是说如果其中一个子样本

1739
00:56:24,576 --> 0:56:25,876
非常明亮 其他样本非常

1740
00:56:25,876 --> 0:56:27,516
黑暗 那么结果将是

1741
00:56:27,516 --> 0:56:29,106
一个令人难以置信的明亮像素

1742
00:56:29,106 --> 0:56:30,066
当色调映射时

1743
00:56:30,066 --> 0:56:31,136
它会接近白色

1744
00:56:31,516 --> 0:56:32,656
你最终会看到边缘看起来

1745
00:56:32,656 --> 0:56:33,766
完全没有反锯齿的样子

1746
00:56:33,766 --> 0:56:36,436
因此 我们的解决方案

1747
00:56:36,436 --> 0:56:38,866
是对所有 MSAA 样本执行

1748
00:56:38,866 --> 0:56:41,686
预先的色调映射 然后

1749
00:56:41,686 --> 0:56:43,606
执行正常的 MSAA 分辨率

1750
00:56:43,606 --> 0:56:44,766
然后第一个后处理通道

1751
00:56:44,766 --> 0:56:46,576
只是反转之前的预映射图

1752
00:56:47,486 --> 0:56:49,026
我们使用可编程混合进行

1753
00:56:49,026 --> 0:56:50,116
预色调贴图过程

1754
00:56:50,746 --> 0:56:51,946
否则 我们必须将

1755
00:56:51,946 --> 0:56:53,576
整个 MSAA 颜色缓冲区

1756
00:56:53,576 --> 0:56:55,366
解析为内存并将其读回

1757
00:56:55,366 --> 0:56:56,796
这是我们负担不起的

1758
00:56:58,676 --> 0:57:00,316
接下来我将展望一下

1759
00:56:58,676 --> 0:57:00,316
接下来我将展望一下

1760
00:57:00,316 --> 0:57:01,546
未来我们希望在

1761
00:57:01,546 --> 0:57:04,556
Metal 中进行的一些工作并行渲染

1762
00:57:04,556 --> 0:57:06,996
所以在 macOS 上 我们

1763
00:57:07,416 --> 0:57:08,626
确实支持并行地创建

1764
00:57:08,626 --> 0:57:09,216
命令缓冲区

1765
00:57:09,756 --> 0:57:12,186
在 iOS 上 我们需要

1766
00:57:12,186 --> 0:57:13,266
支持并行命令

1767
00:57:13,266 --> 0:57:14,876
的编码器才能使用它

1768
00:57:15,176 --> 0:57:16,476
我们的很多绘制

1769
00:57:16,476 --> 0:57:17,646
最终都会发生在

1770
00:57:17,646 --> 0:57:19,376
主要正向传递中 因此将其

1771
00:57:20,176 --> 0:57:21,546
并行化非常重要

1772
00:57:22,206 --> 0:57:23,436
我认为 看到

1773
00:57:23,436 --> 0:57:25,076
并行渲染对单片快速

1774
00:57:25,076 --> 0:57:27,876
内核的影响和

1775
00:57:28,006 --> 0:57:30,786
在高端设备高效内核上使用

1776
00:57:30,896 --> 0:57:33,156
并行命令编码器

1777
00:57:33,156 --> 0:57:34,616
的效果进行比较会

1778
00:57:34,616 --> 0:57:35,626
非常有趣

1779
00:57:35,946 --> 0:57:36,616
这可能会在

1780
00:57:36,616 --> 0:57:38,416
电池使用方面产生

1781
00:57:38,416 --> 0:57:38,896
一些有趣的结果

1782
00:57:40,656 --> 0:57:41,696
Metal 堆

1783
00:57:41,786 --> 0:57:42,736
所以我们希望用 Metal 堆

1784
00:57:42,736 --> 0:57:44,276
来代替我们的缓冲区

1785
00:57:44,276 --> 0:57:46,396
子分配 首先

1786
00:57:46,396 --> 0:57:47,586
因为它只是简单的代码

1787
00:57:47,586 --> 0:57:49,246
其次 因为我们也可以

1788
00:57:49,246 --> 0:57:50,056
把它用于纹理

1789
00:57:50,366 --> 0:57:51,576
我们由于纹理流式传输

1790
00:57:51,576 --> 0:57:52,746
仍然偶尔会遇到麻烦

1791
00:57:52,746 --> 0:57:54,546
因为我们会在显式地

1792
00:57:54,546 --> 0:57:55,736
动态地创建和销毁纹理

1793
00:57:55,736 --> 0:57:57,586
就像把纹理不断的在内存里进行读写

1794
00:57:58,146 --> 0:57:59,946
使用堆可以摆脱

1795
00:57:59,946 --> 0:58:01,516
那些困境

1796
00:57:59,946 --> 0:58:01,516
那些困境

1797
00:58:01,516 --> 0:58:05,016
对我们来说

1798
00:58:05,016 --> 0:58:05,976
我们面前的工作就是

1799
00:58:05,976 --> 0:58:08,226
要在不同的通道

1800
00:58:08,276 --> 0:58:10,636
之间设置精确的栅栏

1801
00:58:10,986 --> 0:58:13,266
所以我们需要明确地

1802
00:58:13,266 --> 0:58:14,786
知道资源是否被顶点

1803
00:58:14,786 --> 0:58:16,146
或像素着色器在

1804
00:58:16,146 --> 0:58:18,266
不同的过程中读取或写入

1805
00:58:18,266 --> 0:58:19,776
并且这需要我们

1806
00:58:19,776 --> 0:58:22,406
对一些渲染器进行一些修改才能实现

1807
00:58:22,936 --> 0:58:25,236
当然 也要继续推动 iOS 上的图形学

1808
00:58:25,236 --> 0:58:26,616
向高端的发展

1809
00:58:27,456 --> 0:58:29,686
去年在 WWDC 上

1810
00:58:29,736 --> 0:58:31,106
我们展示了将我们的

1811
00:58:31,106 --> 0:58:32,436
桌面级正向渲染器

1812
00:58:32,436 --> 0:58:33,966
引入高端 iOS 设备的可能性

1813
00:58:33,966 --> 0:58:35,916
并且我们继续在做这件事

1814
00:58:35,916 --> 0:58:37,126
我们希望继续在 iOS 上

1815
00:58:37,126 --> 0:58:39,656
推动这一目标

1816
00:58:39,656 --> 0:58:43,016
继续为 iOS 带来

1817
00:58:43,936 --> 0:58:47,026
桌面级功能并寻找机会

1818
00:58:47,026 --> 0:58:49,756
将我们的桌面渲染器与

1819
00:58:49,896 --> 0:58:51,506
iOS 渲染器统一起来

1820
00:58:52,046 --> 0:58:55,846
然后 我要把场地交回给 Michael

1821
00:58:57,516 --> 0:58:59,716
[ 掌声 ]

1822
00:59:00,216 --> 0:59:01,596
&gt;&gt; Metal 技术

1823
00:59:01,596 --> 0:59:03,696
的开销很低

1824
00:59:03,696 --> 0:59:05,106
但可以通过多线程

1825
00:59:05,106 --> 0:59:05,836
高效地渲染许多对象

1826
00:59:06,246 --> 0:59:07,736
Metal 技术是

1827
00:59:07,736 --> 0:59:09,736
为了充分利用我们系统中的所有 GPU

1828
00:59:09,736 --> 0:59:10,366
和所有 CPU 而创建的

1829
00:59:11,326 --> 0:59:13,156
Metal 技术也是

1830
00:59:13,156 --> 0:59:14,776
真正可访问的 但高级渲染

1831
00:59:14,776 --> 0:59:16,106
有时需要显式控制

1832
00:59:16,856 --> 0:59:18,386
当你需要内存管理和

1833
00:59:18,386 --> 0:59:19,226
GPU 并行性时

1834
00:59:19,226 --> 0:59:21,306
Metal 技术提供了这种控制

1835
00:59:22,526 --> 0:59:23,816
我们还引入了间接命令缓冲区

1836
00:59:23,816 --> 0:59:25,026
这是我们的全新功能

1837
00:59:25,026 --> 0:59:26,116
它可以让你将命令

1838
00:59:26,116 --> 0:59:27,616
生成完全移至 GPU

1839
00:59:27,616 --> 0:59:30,276
释放 CPU 来执行其他任务

1840
00:59:31,106 --> 0:59:32,666
与参数缓冲区一起

1841
00:59:32,906 --> 0:59:33,816
这些功能为 GPU 驱动的

1842
00:59:33,816 --> 0:59:36,216
管线提供了完整的解决方案

1843
00:59:37,306 --> 0:59:39,236
最后 Metal 允许你

1844
00:59:39,236 --> 0:59:40,086
利用 A11 GPU 的

1845
00:59:40,086 --> 0:59:42,256
高级架构来优化

1846
00:59:42,256 --> 0:59:43,426
渲染技术

1847
00:59:43,426 --> 0:59:44,796
以实现最佳性能

1848
00:59:44,796 --> 0:59:47,396
和更长的游戏时间

1849
00:59:49,126 --> 0:59:50,896
想要了解更多信息

1850
00:59:50,896 --> 0:59:52,656
请访问我们的网站 并确保

1851
00:59:52,736 --> 0:59:55,446
访问我们明天的实验室 谢谢

1852
00:59:56,516 --> 1:00:04,010
[ 掌声 ]
