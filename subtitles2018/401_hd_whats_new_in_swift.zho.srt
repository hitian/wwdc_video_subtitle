1
00:00:07,016 --> 0:00:15,500
[ 音乐 ]

2
00:00:25,516 --> 0:00:28,586
[ 掌声 ]

3
00:00:29,086 --> 0:00:31,526
&gt;&gt; 上午好 欢迎参加

4
00:00:31,526 --> 0:00:32,836
Swift 新功能介绍会议

5
00:00:33,546 --> 0:00:36,986
今年对于 Swift 和 Swift 社区来说

6
00:00:37,046 --> 0:00:37,596
发生了许多激动人心的事

7
00:00:37,966 --> 0:00:39,076
接下来的 40 分钟里

8
00:00:39,136 --> 0:00:40,606
Slava 和我将很荣幸

9
00:00:40,606 --> 0:00:42,526
向大家介绍一系列最新进展

10
00:00:43,696 --> 0:00:44,956
本会议大致

11
00:00:44,956 --> 0:00:45,346
分为两部分

12
00:00:46,126 --> 0:00:47,296
首先 我会介绍

13
00:00:47,296 --> 0:00:48,606
Swift 开源计划

14
00:00:48,646 --> 0:00:51,126
以及整个社区的新情况

15
00:00:51,606 --> 0:00:52,796
接下来 我们会探讨 Swift 4.2 

16
00:00:52,796 --> 0:00:54,666
Swift 4.2 将从今天起

17
00:00:54,666 --> 0:00:58,206
在 Xcode 10 测试版中提供预览

18
00:00:58,756 --> 0:01:00,786
2015 年年底开始

19
00:00:58,756 --> 0:01:00,786
2015 年年底开始

20
00:01:00,786 --> 0:01:02,946
Swift 作为开源项目登陆 GitHub

21
00:01:04,546 --> 0:01:06,476
用户社区十分活跃

22
00:01:06,476 --> 0:01:10,226
大家展开讨论 提交新功能

23
00:01:10,226 --> 0:01:11,556
审核后将新功能

24
00:01:11,556 --> 0:01:13,366
加入语言和标准库中

25
00:01:15,726 --> 0:01:17,476
在此期间 有 600 人

26
00:01:17,476 --> 0:01:18,776
向 GitHub 上的

27
00:01:18,776 --> 0:01:20,926
Swift 开源项目

28
00:01:20,926 --> 0:01:21,706
贡献了代码

29
00:01:22,576 --> 0:01:23,686
总共合并了

30
00:01:23,686 --> 0:01:26,046
18000 多项合并请求

31
00:01:27,316 --> 0:01:29,386
自从 Swift.org 上线以来

32
00:01:29,386 --> 0:01:31,326
Swift 便可以在

33
00:01:31,326 --> 0:01:33,966
Swift.org 上下载

34
00:01:33,966 --> 0:01:36,956
作为可下载工具链用于 Xcode

35
00:01:36,996 --> 0:01:38,216
以及多个版本的 Ubuntu

36
00:01:38,646 --> 0:01:43,536
其中既包括开发快照 也包括正式版本

37
00:01:45,016 --> 0:01:46,106
我们希望 Swift

38
00:01:46,106 --> 0:01:48,646
得到所有平台的支持

39
00:01:48,796 --> 0:01:50,396
方便大家使用

40
00:01:50,396 --> 0:01:53,086
重要工作之一

41
00:01:53,086 --> 0:01:54,766
就是拓展社区的

42
00:01:55,116 --> 0:01:56,586
测试支持

43
00:01:57,046 --> 0:01:58,476
许多开源项目用户

44
00:01:58,506 --> 0:02:01,506
也在努力让 Swift 支持

45
00:01:58,506 --> 0:02:01,506
也在努力让 Swift 支持

46
00:02:01,506 --> 0:02:02,106
其他平台

47
00:02:02,476 --> 0:02:04,166
我们也想要助一臂之力

48
00:02:05,396 --> 0:02:07,726
大约一个月前 我们

49
00:02:07,726 --> 0:02:08,545
扩展了公共持续集成系统

50
00:02:08,545 --> 0:02:10,006
以支持社区设立的

51
00:02:10,006 --> 0:02:12,066
持续集成节点

52
00:02:12,566 --> 0:02:13,576
如果你是社区的一员

53
00:02:13,576 --> 0:02:14,796
想要让 Swift

54
00:02:14,796 --> 0:02:16,386
得到其他平台的支持

55
00:02:16,436 --> 0:02:18,046
你现在可以

56
00:02:18,046 --> 0:02:19,266
直接接入你的硬件支持

57
00:02:19,266 --> 0:02:20,726
并开始测试

58
00:02:21,146 --> 0:02:22,776
这一前提可以帮助

59
00:02:22,776 --> 0:02:23,956
Swift 得到

60
00:02:23,956 --> 0:02:24,566
其他平台的支持

61
00:02:26,826 --> 0:02:28,816
我们还投入了很多

62
00:02:29,056 --> 0:02:31,056
建立了 Swift 开源项目的

63
00:02:31,106 --> 0:02:32,716
周边社区 在这里

64
00:02:33,056 --> 0:02:35,966
社区成员可以讨论语言中的所有变化

65
00:02:36,966 --> 0:02:38,936
大约六个月前 我们

66
00:02:38,936 --> 0:02:40,196
不再使用邮件列表

67
00:02:40,196 --> 0:02:42,556
因为信息量太大 而改用论坛

68
00:02:42,986 --> 0:02:44,746
这是当时社区的呼声

69
00:02:45,366 --> 0:02:48,776
起初有很多人想要以适合

70
00:02:48,776 --> 0:02:50,446
自己的方式真正

71
00:02:50,446 --> 0:02:54,126
参与项目 但发现困难重重

72
00:02:54,666 --> 0:02:55,586
有了论坛 你们就可以

73
00:02:55,586 --> 0:02:57,656
以适合自己的

74
00:02:57,656 --> 0:03:00,926
方式参与项目 论坛非常成功

75
00:02:57,656 --> 0:03:00,926
方式参与项目 论坛非常成功

76
00:03:00,926 --> 0:03:02,476
我们也想拓展

77
00:03:02,476 --> 0:03:04,586
它的用途 支持

78
00:03:04,586 --> 0:03:06,746
整个开源项目

79
00:03:07,476 --> 0:03:10,196
如果你在维护

80
00:03:10,196 --> 0:03:11,696
一个开源项目 例如

81
00:03:11,696 --> 0:03:13,526
很受欢迎的 Swift 库

82
00:03:13,526 --> 0:03:14,906
你就可以用论坛

83
00:03:15,186 --> 0:03:16,436
来讨论项目内容

84
00:03:16,436 --> 0:03:18,506
例如与用户沟通

85
00:03:18,506 --> 0:03:19,286
或讨论开发进度

86
00:03:20,986 --> 0:03:22,376
我们还想

87
00:03:22,376 --> 0:03:24,386
拓展 Swift.org 的作用

88
00:03:24,426 --> 0:03:26,016
让它能为整个社区所用

89
00:03:26,566 --> 0:03:28,936
本周 我们将把 Swift 编程语言手册

90
00:03:29,006 --> 0:03:30,486
迁移到 Swift.org

91
00:03:31,486 --> 0:03:33,706
地址为 docs.swift.org

92
00:03:33,706 --> 0:03:35,146
我们今后也会在这里

93
00:03:35,186 --> 0:03:37,716
公布更多文档

94
00:03:37,716 --> 0:03:39,026
供社区使用

95
00:03:39,606 --> 0:03:42,876
关于 Swift

96
00:03:42,876 --> 0:03:45,006
最激动人心的是

97
00:03:45,006 --> 0:03:46,776
人们很喜欢使用 Swift

98
00:03:46,776 --> 0:03:48,406
并且在很多场合

99
00:03:48,406 --> 0:03:49,376
讨论 Swift

100
00:03:49,606 --> 0:03:51,246
例如博客 聚会

101
00:03:51,696 --> 0:03:52,556
还有会议

102
00:03:53,126 --> 0:03:54,916
而 Apple 认为

103
00:03:54,916 --> 0:03:56,726
我们很有必要

104
00:03:56,996 --> 0:03:59,966
参与其中 因为讨论就是在这些地方发生

105
00:04:00,736 --> 0:04:02,696
过去一年间

106
00:04:02,696 --> 0:04:04,116
我们格外重视

107
00:04:04,116 --> 0:04:06,046
参与这些会议

108
00:04:06,046 --> 0:04:09,016
并且进行了技术展示

109
00:04:09,406 --> 0:04:10,826
包括我们在 Swift 上的

110
00:04:10,826 --> 0:04:13,026
工作 Swift 的工作原理

111
00:04:13,026 --> 0:04:14,386
还有你们参与

112
00:04:14,386 --> 0:04:15,376
开源项目的方式

113
00:04:16,375 --> 0:04:17,576
这些我们在今后

114
00:04:17,576 --> 0:04:19,616
也会致力于向前推进

115
00:04:21,466 --> 0:04:22,466
其中一项重要努力

116
00:04:22,466 --> 0:04:25,096
是周五在 WWDC

117
00:04:25,166 --> 0:04:27,266
场地附近举办的 try Swift

118
00:04:27,336 --> 0:04:29,226
圣何塞会议

119
00:04:29,866 --> 0:04:31,596
届时会有工作坊

120
00:04:31,836 --> 0:04:33,256
成员来自社区

121
00:04:33,256 --> 0:04:34,806
帮助有兴趣

122
00:04:34,806 --> 0:04:36,326
为 Swift 开源项目做贡献的

123
00:04:36,326 --> 0:04:38,196
与会人员

124
00:04:38,626 --> 0:04:39,916
届时 Apple 的

125
00:04:39,916 --> 0:04:41,836
编译器团队也会出席

126
00:04:42,046 --> 0:04:44,416
帮助大家进行交流

127
00:04:45,146 --> 0:04:48,446
以上就是关于社区的新进展

128
00:04:49,066 --> 0:04:50,166
我们来谈谈 Swift 4.2

129
00:04:50,166 --> 0:04:53,346
我认为 首先应当谈谈 这个版本的

130
00:04:53,346 --> 0:04:55,466
内容 以及在整体发展过程中的地位

131
00:04:58,276 --> 0:05:01,906
Swift 更新 特别是大版本更新 大约

132
00:04:58,276 --> 0:05:01,906
Swift 更新 特别是大版本更新 大约

133
00:05:01,906 --> 0:05:02,386
两年一次

134
00:05:02,996 --> 0:05:04,926
Swift 4.2 是继 Swift 4.1

135
00:05:04,956 --> 0:05:07,026
和 4.0 之后的大版本更新

136
00:05:08,246 --> 0:05:10,116
总体而言 这个版本

137
00:05:10,216 --> 0:05:11,736
有两大要点

138
00:05:12,316 --> 0:05:14,686
第一是进一步关注

139
00:05:14,686 --> 0:05:15,386
开发者效率

140
00:05:15,826 --> 0:05:16,946
你们可以在很多方面

141
00:05:16,946 --> 0:05:17,136
感受到

142
00:05:17,686 --> 0:05:19,186
项目构建速度更快

143
00:05:19,546 --> 0:05:20,826
但整体而言

144
00:05:20,826 --> 0:05:22,876
核心工具的体验

145
00:05:22,876 --> 0:05:24,676
也大幅改善

146
00:05:24,676 --> 0:05:26,106
例如调试器（Debugger）和编辑器（Editor）

147
00:05:26,186 --> 0:05:28,306
Swift 社区也

148
00:05:28,306 --> 0:05:30,216
也不断重视改进语言

149
00:05:30,616 --> 0:05:32,206
从而改善一般的

150
00:05:32,206 --> 0:05:33,796
开发者工作流

151
00:05:33,796 --> 0:05:34,386
去除鸡肋代码

152
00:05:34,926 --> 0:05:36,936
Apple 也一直在

153
00:05:36,936 --> 0:05:39,406
改进 SDK 从而

154
00:05:39,406 --> 0:05:41,646
让 Objective-C API 更好地

155
00:05:41,686 --> 0:05:44,226
映射到 Swift 中

156
00:05:44,386 --> 0:05:45,456
改善对语言

157
00:05:45,456 --> 0:05:47,006
和 API 的运用

158
00:05:48,266 --> 0:05:49,626
另一方面

159
00:05:49,626 --> 0:05:51,766
语言底层得到

160
00:05:51,846 --> 0:05:53,736
大幅改善 

161
00:05:53,736 --> 0:05:55,636
运行时间也有很多变化

162
00:05:55,636 --> 0:05:58,156
以实现二进制兼容性

163
00:05:58,156 --> 0:06:01,946
这一功能将在 Swift 5 中推出

164
00:05:58,156 --> 0:06:01,946
这一功能将在 Swift 5 中推出

165
00:06:01,946 --> 0:06:04,916
预计于 2019 年早些时候发布

166
00:06:05,926 --> 0:06:07,486
什么是二进制兼容性

167
00:06:08,406 --> 0:06:09,806
二进制兼容性指

168
00:06:09,806 --> 0:06:11,536
构建 Swift 代码时

169
00:06:11,576 --> 0:06:13,286
你可以使用 Swift 5 的编译器和层

170
00:06:13,286 --> 0:06:15,036
而在二进制层面

171
00:06:15,036 --> 0:06:16,626
代码可以与

172
00:06:16,696 --> 0:06:17,866
同一编译器或其他编译器层

173
00:06:17,866 --> 0:06:19,686
构建的代码

174
00:06:19,686 --> 0:06:20,016
相互操作

175
00:06:20,496 --> 0:06:22,266
这一点十分重要

176
00:06:22,266 --> 0:06:23,966
标志着这门语言

177
00:06:23,966 --> 0:06:24,506
走向成熟

178
00:06:25,146 --> 0:06:26,606
有了这一功能

179
00:06:26,606 --> 0:06:28,436
Apple 就可以将 Swift 运行时

180
00:06:28,586 --> 0:06:30,746
移入操作系统

181
00:06:30,746 --> 0:06:32,156
App 可以直接使用它

182
00:06:32,576 --> 0:06:33,496
而不再需要

183
00:06:33,496 --> 0:06:34,976
将其放入 App 包中

184
00:06:35,346 --> 0:06:37,446
这样可以缩减代码体积

185
00:06:37,446 --> 0:06:38,966
但同样重要的是

186
00:06:38,966 --> 0:06:40,146
启动时间和

187
00:06:40,146 --> 0:06:42,286
内存使用也能得到优化

188
00:06:42,286 --> 0:06:44,056
对社区而言帮助很大

189
00:06:44,056 --> 0:06:46,876
我们也会

190
00:06:46,876 --> 0:06:48,046
公布实现

191
00:06:48,286 --> 0:06:50,196
ABI 稳定性或二进制兼容性的

192
00:06:50,196 --> 0:06:50,906
相关进展

193
00:06:51,286 --> 0:06:52,826
可以访问 Swift.org 的

194
00:06:52,826 --> 0:06:54,366
ABI 稳定性总览页面

195
00:06:54,406 --> 0:06:55,806
跟踪进展

196
00:06:57,696 --> 0:07:00,186
今天的重点是 Swift 4.2

197
00:06:57,696 --> 0:07:00,186
今天的重点是 Swift 4.2

198
00:07:00,186 --> 0:07:01,596
这是实现 Swift 5 的

199
00:07:01,916 --> 0:07:02,696
重要一步

200
00:07:03,426 --> 0:07:05,446
我们来谈谈

201
00:07:05,446 --> 0:07:06,166
源兼容性

202
00:07:07,526 --> 0:07:10,106
像 Xcode 9 一样

203
00:07:10,166 --> 0:07:12,696
Xcode 10 只搭载一种 Swift 编译器

204
00:07:13,686 --> 0:07:15,086
如果你使用 Xcode 10

205
00:07:15,086 --> 0:07:16,256
你就在使用 Swift 4.2

206
00:07:17,226 --> 0:07:19,716
但就像 Xcode 9 一样

207
00:07:20,276 --> 0:07:21,746
这一编译器也支持

208
00:07:22,236 --> 0:07:23,896
多种语言

209
00:07:23,896 --> 0:07:24,366
兼容性模式

210
00:07:25,256 --> 0:07:27,906
在所有模式中 你都可以使用新 API

211
00:07:28,676 --> 0:07:30,476
可以使用全部新特性

212
00:07:30,856 --> 0:07:31,676
这足以带来

213
00:07:31,676 --> 0:07:33,476
影响代码源的变化

214
00:07:34,036 --> 0:07:37,286
前两个模式

215
00:07:37,286 --> 0:07:39,026
在 Xcode 9 中就已存在

216
00:07:39,426 --> 0:07:40,676
保留它们是为了提供

217
00:07:40,676 --> 0:07:41,776
开箱即用式的体验

218
00:07:41,776 --> 0:07:43,046
你可以直接构建 Swift 3 

219
00:07:43,046 --> 0:07:44,926
和 Swift 4 代码 不需修改

220
00:07:45,656 --> 0:07:47,206
Swift 4.2 模式与

221
00:07:47,206 --> 0:07:49,586
Swift 4 模式基本相同

222
00:07:49,586 --> 0:07:51,216
但包含刚才提到的

223
00:07:51,476 --> 0:07:52,266
SDK 改进

224
00:07:53,426 --> 0:07:54,346
就这样

225
00:07:54,976 --> 0:07:57,026
如果使用之前版本的 Xcode

226
00:07:57,086 --> 0:07:58,526
可以使用迁移帮助（Migrator Support）

227
00:07:58,526 --> 0:07:59,436
该功能位于编辑（Edit）菜单

228
00:07:59,436 --> 0:08:01,556
用来自动进行大部分修改

229
00:07:59,436 --> 0:08:01,556
用来自动进行大部分修改

230
00:08:02,806 --> 0:08:03,876
我想先做一项

231
00:08:03,876 --> 0:08:06,166
关于 Swift 4.2 SDK 变化的

232
00:08:06,306 --> 0:08:07,146
免责声明

233
00:08:07,496 --> 0:08:09,436
后期的 Xcode 10 测试版可能

234
00:08:09,436 --> 0:08:11,036
会进一步改进 SDK

235
00:08:11,416 --> 0:08:13,206
这是为了能够

236
00:08:13,206 --> 0:08:14,916
整合大家

237
00:08:14,916 --> 0:08:16,976
关于 API 改进方向

238
00:08:16,976 --> 0:08:18,676
和改进如何反映在 Swift 中

239
00:08:18,676 --> 0:08:19,626
等反馈意见

240
00:08:20,236 --> 0:08:22,246
这意味着 如果你提前

241
00:08:22,416 --> 0:08:23,926
迁移到 Swift 4.2

242
00:08:23,926 --> 0:08:25,096
就要注意后续可能出现的变化

243
00:08:25,576 --> 0:08:27,446
你也可以先不迁移 之后再选择迁移

244
00:08:27,836 --> 0:08:28,816
完全取决于你

245
00:08:30,616 --> 0:08:32,176
Swift 4.2 中

246
00:08:32,176 --> 0:08:34,126
我们在加速让

247
00:08:34,166 --> 0:08:35,476
Swift 代码成型

248
00:08:35,876 --> 0:08:36,635
并面向未来

249
00:08:36,666 --> 0:08:40,716
这是语言成熟的重要阶段

250
00:08:41,506 --> 0:08:43,046
因此 我们认为

251
00:08:43,046 --> 0:08:44,596
大家都有必要

252
00:08:44,596 --> 0:08:47,486
从 Swift 3 迁移到

253
00:08:47,486 --> 0:08:48,086
Swift 4.2

254
00:08:48,086 --> 0:08:50,456
代码体积得到了重要改善

255
00:08:50,456 --> 0:08:51,396
语言整体也

256
00:08:51,396 --> 0:08:52,006
有所改进

257
00:08:52,836 --> 0:08:54,106
Xcode 10 将会是

258
00:08:54,156 --> 0:08:55,636
最后一个支持

259
00:08:55,636 --> 0:08:58,916
Swift 3 兼容模式的版本

260
00:08:59,586 --> 0:09:00,506
我们来谈谈工具

261
00:08:59,586 --> 0:09:00,506
我们来谈谈工具

262
00:09:00,506 --> 0:09:01,446
方面的改进

263
00:09:02,536 --> 0:09:04,076
在 Platform State of the Union 会议中

264
00:09:04,076 --> 0:09:05,006
我们提到

265
00:09:05,106 --> 0:09:06,206
Xcode 9 中的

266
00:09:06,206 --> 0:09:07,416
Swift 项目构建

267
00:09:07,416 --> 0:09:09,366
也得到了显著改善

268
00:09:10,176 --> 0:09:12,176
这些结果是在一台配备

269
00:09:12,176 --> 0:09:13,516
四核 i7 处理器的 MacBook Pro 上得到的

270
00:09:13,516 --> 0:09:17,416
我们来仔细看看其中之一

271
00:09:18,896 --> 0:09:20,456
这个项目混合了

272
00:09:20,456 --> 0:09:21,776
Objective-C 和 Swift 代码

273
00:09:22,066 --> 0:09:24,666
它最初是一个 Objective-C 项目 随后

274
00:09:24,666 --> 0:09:25,526
开始采用 Swift

275
00:09:26,216 --> 0:09:27,786
这种情况很常见

276
00:09:28,756 --> 0:09:29,576
屏幕上的构建时间

277
00:09:29,576 --> 0:09:32,156
提升无法反映

278
00:09:32,156 --> 0:09:33,826
构建这段 Swift 代码

279
00:09:33,876 --> 0:09:35,536
到底比之前快了多少

280
00:09:36,356 --> 0:09:37,526
如果我们只关注

281
00:09:37,526 --> 0:09:39,826
Swift 构建速度的提升

282
00:09:39,826 --> 0:09:42,896
构建速度实际上快了三倍

283
00:09:43,386 --> 0:09:44,776
这就是为什么

284
00:09:45,046 --> 0:09:47,536
项目速度提升只有 1.6 倍

285
00:09:49,656 --> 0:09:51,096
可以看到

286
00:09:51,096 --> 0:09:52,216
构建速度提升

287
00:09:52,216 --> 0:09:53,706
整体取决于

288
00:09:53,706 --> 0:09:54,766
项目性质 使用多少

289
00:09:54,766 --> 0:09:56,816
Swift 代码 以及处理器的

290
00:09:56,816 --> 0:09:58,606
核数 但实际情况中

291
00:09:58,766 --> 0:10:01,476
许多项目都提速多达两倍

292
00:09:58,766 --> 0:10:01,476
许多项目都提速多达两倍

293
00:10:02,416 --> 0:10:04,366
提升主要由于

294
00:10:04,366 --> 0:10:06,326
Swift 目标

295
00:10:06,326 --> 0:10:08,286
具有跨文件

296
00:10:08,286 --> 0:10:10,896
可见性 这是 Swift 的优异特性之一

297
00:10:10,896 --> 0:10:11,946
不需要头文件

298
00:10:12,606 --> 0:10:13,976
过去编译器会执行

299
00:10:13,976 --> 0:10:15,586
许多冗余工作

300
00:10:15,586 --> 0:10:17,056
于是 我们就

301
00:10:17,056 --> 0:10:18,346
重新设计了编译

302
00:10:18,346 --> 0:10:20,136
流程 大幅减少了

303
00:10:20,136 --> 0:10:21,626
冗余 并且更好的利用处理器

304
00:10:21,626 --> 0:10:22,936
你机器上的核

305
00:10:23,096 --> 0:10:24,466
因此才会有这样的速度提升

306
00:10:25,206 --> 0:10:27,616
欲知更多细节 本周晚些时候

307
00:10:27,616 --> 0:10:28,886
会有两场讲座

308
00:10:28,886 --> 0:10:30,346
深入分析构建过程

309
00:10:30,396 --> 0:10:31,846
背后的工作原理 会提到

310
00:10:31,846 --> 0:10:32,906
更多细节 解释

311
00:10:32,946 --> 0:10:34,146
为何会有如此性能提升

312
00:10:36,356 --> 0:10:37,906
性能大幅提升是由于

313
00:10:38,606 --> 0:10:40,526
调试版本构建的改进

314
00:10:41,566 --> 0:10:44,776
我想重点讲这一功能

315
00:10:44,776 --> 0:10:47,846
为何出现在 Xcode 的构建选项中

316
00:10:48,746 --> 0:10:49,926
最近我们将

317
00:10:49,926 --> 0:10:51,386
编译模式（Compilation Mode）从

318
00:10:51,386 --> 0:10:52,506
优化水平（Optimization Level）中分离出来

319
00:10:53,206 --> 0:10:55,286
编译模式决定

320
00:10:55,286 --> 0:10:56,726
项目构建的方式

321
00:10:57,256 --> 0:10:58,566
如果是构建发行版本（Release）

322
00:10:58,566 --> 0:10:59,566
默认设置是全模组

323
00:10:59,566 --> 0:11:01,446
编译（Whole Module Compilation）

324
00:10:59,566 --> 0:11:01,446
编译（Whole Module Compilation）

325
00:11:01,446 --> 0:11:02,906
目标中全部文件

326
00:11:02,906 --> 0:11:04,226
总是一起构建

327
00:11:04,386 --> 0:11:05,836
进行优化的

328
00:11:05,836 --> 0:11:07,326
可能性最高

329
00:11:07,326 --> 0:11:09,756
重点不是优化的数量 而是

330
00:11:09,756 --> 0:11:11,366
进行优化的可能性

331
00:11:12,166 --> 0:11:14,146
而如果是调试版本（Debug）

332
00:11:14,146 --> 0:11:15,176
则是增量（Incremental）构建

333
00:11:15,386 --> 0:11:16,486
并非所有文件

334
00:11:16,486 --> 0:11:18,626
都会构建 或者再构建

335
00:11:19,616 --> 0:11:20,506
这是性能表现

336
00:11:20,506 --> 0:11:22,536
和构建时间权衡的结果

337
00:11:23,516 --> 0:11:24,826
调试版本构建的

338
00:11:24,826 --> 0:11:25,746
优化水平默认仍然是

339
00:11:25,746 --> 0:11:26,966
无优化（No optimization）

340
00:11:26,966 --> 0:11:27,946
这样构建速度更快

341
00:11:27,946 --> 0:11:29,806
调试信息更全

342
00:11:29,806 --> 0:11:32,096
发行版本构建则着重优化速度

343
00:11:32,636 --> 0:11:35,306
我们稍后会再提到优化水平

344
00:11:38,436 --> 0:11:42,696
好的 分离编译模式和

345
00:11:42,696 --> 0:11:45,296
优化水平

346
00:11:45,356 --> 0:11:46,516
反映了一个非常有趣的权宜之计

347
00:11:46,516 --> 0:11:48,096
有人发现有时候

348
00:11:48,096 --> 0:11:50,176
如果

349
00:11:50,176 --> 0:11:51,126
结合全模组

350
00:11:51,126 --> 0:11:53,946
编译并且无优化时

351
00:11:53,946 --> 0:11:54,876
可以更快的

352
00:11:55,036 --> 0:11:56,026
构建调试版本

353
00:11:56,966 --> 0:11:58,786
这是因为

354
00:11:58,786 --> 0:12:02,246
这一组合显著减少了

355
00:11:58,786 --> 0:12:02,246
这一组合显著减少了

356
00:12:02,246 --> 0:12:04,136
我们现在努力

357
00:12:04,136 --> 0:12:08,666
消除或大幅减少的冗余工作

358
00:12:10,036 --> 0:12:12,496
而这样组合的问题在于 它会减慢

359
00:12:12,496 --> 0:12:13,296
增量构建的速度

360
00:12:13,506 --> 0:12:14,716
只要你修改了目标中的

361
00:12:14,716 --> 0:12:16,806
一个文件 整个目标就要重新构建

362
00:12:17,496 --> 0:12:18,836
而 Xcode 10 改进了

363
00:12:18,836 --> 0:12:20,406
调试版本构建 我们认为

364
00:12:20,406 --> 0:12:21,936
你们不再需要

365
00:12:21,986 --> 0:12:24,416
使用这种权宜之计 我们也

366
00:12:24,416 --> 0:12:25,626
发现 默认的

367
00:12:25,626 --> 0:12:27,316
增量构建 表现

368
00:12:27,316 --> 0:12:29,356
同这种组合相当 甚至更好

369
00:12:29,356 --> 0:12:30,976
特别是现在 增量构建得到了正式支持

370
00:12:34,696 --> 0:12:35,826
我们来谈谈

371
00:12:35,826 --> 0:12:37,006
运行时得到的

372
00:12:37,006 --> 0:12:38,256
底层优化 这也是

373
00:12:38,256 --> 0:12:39,356
实现二进制兼容的

374
00:12:39,406 --> 0:12:40,586
环节之一

375
00:12:43,436 --> 0:12:45,126
Swift 使用自动内存

376
00:12:45,126 --> 0:12:47,726
管理 并且像 Objective-C 一样

377
00:12:47,726 --> 0:12:49,236
使用引用计数（reference counting）

378
00:12:49,386 --> 0:12:51,026
管理对象实例

379
00:12:51,916 --> 0:12:53,526
这张幻灯片上 用备注

380
00:12:53,526 --> 0:12:54,786
显示出编译器在哪里

381
00:12:54,786 --> 0:12:56,426
插入（insert） 保留（retain） 释放（release）

382
00:12:57,516 --> 0:13:02,116
这是 Swift 4.1 中的运行方式

383
00:12:57,516 --> 0:13:02,116
这是 Swift 4.1 中的运行方式

384
00:13:02,316 --> 0:13:03,276
对象创建时

385
00:13:03,276 --> 0:13:04,716
会关联一个 +1

386
00:13:04,716 --> 0:13:05,896
引用计数

387
00:13:05,896 --> 0:13:08,176
惯例是 如果

388
00:13:08,176 --> 0:13:09,596
对象作为一个参数

389
00:13:09,596 --> 0:13:10,806
传递到另一个函数中

390
00:13:11,286 --> 0:13:12,406
那个函数的调用

391
00:13:12,466 --> 0:13:14,526
就应该释放对象

392
00:13:14,986 --> 0:13:16,626
这基本上就是让

393
00:13:16,626 --> 0:13:18,036
函数调用

394
00:13:18,036 --> 0:13:19,406
释放对象

395
00:13:20,376 --> 0:13:21,556
这样一来 就有

396
00:13:21,556 --> 0:13:22,926
机会改进性能 缩减

397
00:13:22,926 --> 0:13:25,156
一些对象的生命周期

398
00:13:25,156 --> 0:13:26,936
限制到最小范围

399
00:13:27,806 --> 0:13:29,976
但是 如果你的代码

400
00:13:30,056 --> 0:13:32,076
将对象传递到

401
00:13:32,076 --> 0:13:33,886
不同 API 的话

402
00:13:34,276 --> 0:13:35,236
可能会是这样

403
00:13:35,906 --> 0:13:37,096
由于存在这种

404
00:13:37,136 --> 0:13:38,856
调用惯例 就依然存在

405
00:13:38,856 --> 0:13:40,226
这种往复操作

406
00:13:40,226 --> 0:13:41,316
最初的引用计数

407
00:13:41,366 --> 0:13:42,466
在最后的调用中

408
00:13:42,516 --> 0:13:43,066
抵消

409
00:13:43,466 --> 0:13:44,666
但中间的步骤

410
00:13:44,666 --> 0:13:45,776
又应当有额外的

411
00:13:45,776 --> 0:13:48,246
保留和释放过程 因为

412
00:13:48,246 --> 0:13:49,956
这是惯例

413
00:13:50,876 --> 0:13:52,406
这样会造成浪费 因为

414
00:13:52,626 --> 0:13:53,886
对象在函数

415
00:13:53,886 --> 0:13:55,156
执行期间

416
00:13:55,156 --> 0:13:57,106
始终存活（alive）

417
00:13:57,816 --> 0:13:59,876
所以 Swift 4.2 中 我们改变了

418
00:13:59,876 --> 0:14:01,396
调用惯例 这样一来

419
00:13:59,876 --> 0:14:01,396
调用惯例 这样一来

420
00:14:01,396 --> 0:14:02,606
就不再由被调用的

421
00:14:02,606 --> 0:14:04,806
一方来释放对象

422
00:14:05,206 --> 0:14:06,526
这样一来 所有的保留

423
00:14:06,526 --> 0:14:10,366
和释放都不复存在

424
00:14:10,606 --> 0:14:12,066
可以显著减少

425
00:14:12,066 --> 0:14:13,016
保留和释放的数据量

426
00:14:13,936 --> 0:14:15,076
这有两重意义

427
00:14:15,546 --> 0:14:16,916
一 可以缩减代码体积

428
00:14:16,986 --> 0:14:19,026
因为这些调用不复存在

429
00:14:19,026 --> 0:14:20,336
二 可以改善运行时

430
00:14:21,776 --> 0:14:24,746
另一项重要的优化

431
00:14:24,746 --> 0:14:25,746
针对字符串

432
00:14:26,186 --> 0:14:28,506
Swift 4.2 的字符串为 16 个

433
00:14:28,506 --> 0:14:30,316
字节长 此前长度为 24

434
00:14:30,756 --> 0:14:31,976
这也是我们 

435
00:14:31,976 --> 0:14:33,266
权衡内存使用和

436
00:14:33,266 --> 0:14:33,936
性能的结果

437
00:14:35,346 --> 0:14:37,356
但同时 这一长度

438
00:14:37,356 --> 0:14:38,936
也足以对小字符串

439
00:14:38,936 --> 0:14:40,026
进行优化

440
00:14:40,706 --> 0:14:42,746
如果字符串不足 15

441
00:14:42,746 --> 0:14:45,226
字节长 实际的字符串

442
00:14:45,226 --> 0:14:46,636
就可以直接用

443
00:14:46,636 --> 0:14:48,246
字符串类型表示 而不用

444
00:14:48,246 --> 0:14:49,306
分配单独的

445
00:14:49,306 --> 0:14:50,806
缓冲区来表示字符串

446
00:14:51,436 --> 0:14:53,456
这显然既有利于内存

447
00:14:53,456 --> 0:14:55,066
也有利于性能

448
00:14:55,716 --> 0:14:56,546
这很像我们在

449
00:14:56,546 --> 0:14:57,866
NSString 中

450
00:14:57,866 --> 0:14:58,286
所做的优化

451
00:14:58,586 --> 0:15:00,516
但我们可以存储更大的字符串

452
00:14:58,586 --> 0:15:00,516
但我们可以存储更大的字符串

453
00:15:03,396 --> 0:15:05,096
最后 在我把舞台交给

454
00:15:05,156 --> 0:15:06,126
Slava 之前 我们来谈谈

455
00:15:06,126 --> 0:15:07,086
语言本身的改进

456
00:15:07,086 --> 0:15:08,576
我想多谈一下

457
00:15:08,576 --> 0:15:10,636
缩减代码体积方面的努力

458
00:15:12,176 --> 0:15:13,146
我之前在谈到

459
00:15:13,146 --> 0:15:14,586
调用惯例改变的时候 提到了

460
00:15:14,586 --> 0:15:15,826
缩减代码体积

461
00:15:15,826 --> 0:15:17,546
我们还推出了一个新的

462
00:15:17,546 --> 0:15:19,936
优化水平选项 即优化

463
00:15:19,936 --> 0:15:20,256
体积（Optimize for Size [-Osize]）

464
00:15:21,466 --> 0:15:22,366
这一点很有用

465
00:15:22,366 --> 0:15:23,986
尤其是当 App 非常

466
00:15:24,056 --> 0:15:25,966
关心体积限制的时候 例如

467
00:15:25,966 --> 0:15:27,216
使用蜂窝网络进行

468
00:15:27,216 --> 0:15:28,056
下载的限制

469
00:15:29,146 --> 0:15:30,626
Swift 是一门强大的

470
00:15:30,696 --> 0:15:33,656
静态语言 以静态的方式

471
00:15:33,656 --> 0:15:34,846
理解程序行为

472
00:15:35,306 --> 0:15:36,306
因此 编译器有很多

473
00:15:36,306 --> 0:15:38,626
优化性能的

474
00:15:38,626 --> 0:15:40,016
机会 例如

475
00:15:40,016 --> 0:15:41,596
将函数调用内联（function call inlining）

476
00:15:41,596 --> 0:15:43,126
以及推测性去虚化（speculative 

477
00:15:43,126 --> 0:15:44,326
devirtualization） 这些方法牺牲代码体积

478
00:15:44,326 --> 0:15:45,846
以换取性能 然而

479
00:15:45,846 --> 0:15:46,936
有时候 这部分性能

480
00:15:47,226 --> 0:15:49,346
并非实际需要

481
00:15:49,956 --> 0:15:51,726
这是对 Swift 源编译套件

482
00:15:51,786 --> 0:15:54,466
实行 Osize 优化的结果 其中

483
00:15:54,466 --> 0:15:55,546
包括一系列

484
00:15:55,546 --> 0:15:58,266
GitHub 项目 如框架和 App

485
00:15:59,156 --> 0:16:00,176
可以看到 优化范围

486
00:15:59,156 --> 0:16:00,176
可以看到 优化范围

487
00:16:00,176 --> 0:16:01,626
取决于使用了

488
00:16:01,626 --> 0:16:03,456
哪些语言特性 代码体积

489
00:16:03,456 --> 0:16:05,136
缩减了 10% 到 30%

490
00:16:05,826 --> 0:16:07,896
这里所说的代码体积指的是编译

491
00:16:07,896 --> 0:16:09,636
Swift 代码过程中

492
00:16:09,636 --> 0:16:11,046
构建的机器码

493
00:16:11,046 --> 0:16:12,676
不是 App 的整体体积

494
00:16:12,906 --> 0:16:14,206
App 整体体积取决于

495
00:16:14,206 --> 0:16:15,766
应用素材等多重因素

496
00:16:17,576 --> 0:16:19,416
现实中 我们发现

497
00:16:19,416 --> 0:16:21,836
运行时性能会下降大约 5%

498
00:16:21,836 --> 0:16:23,776
这需要牺牲一小部分性能

499
00:16:24,336 --> 0:16:25,766
对很多 App 而言 这一点

500
00:16:25,766 --> 0:16:26,496
无伤大雅

501
00:16:26,926 --> 0:16:28,716
所以确实取决于实际用例

502
00:16:29,216 --> 0:16:30,096
但如果你对此

503
00:16:30,096 --> 0:16:31,516
感兴趣 我们也鼓励你

504
00:16:31,516 --> 0:16:33,956
进行尝试

505
00:16:34,456 --> 0:16:35,476
现在 我要把舞台

506
00:16:35,476 --> 0:16:36,916
交给 Slava  他会谈到

507
00:16:36,916 --> 0:16:37,806
Swift 4.2 中

508
00:16:37,806 --> 0:16:39,826
语言方面的重大改进

509
00:16:40,516 --> 0:16:45,546
[ 掌声 ]

510
00:16:46,046 --> 0:16:47,856
&gt;&gt; 大家好 我是 Slava Pestov

511
00:16:47,896 --> 0:16:49,586
我负责 Swift 编译器

512
00:16:49,586 --> 0:16:50,886
今天 我想谈谈

513
00:16:50,886 --> 0:16:52,366
Swift 4.2 中的新语言特性

514
00:16:52,366 --> 0:16:54,216
可以如何帮助你

515
00:16:54,216 --> 0:16:55,956
写出更简单 更易维护的代码

516
00:16:57,556 --> 0:16:59,156
在讲到语言的

517
00:16:59,196 --> 0:17:00,766
新变化之前 先来

518
00:16:59,196 --> 0:17:00,766
新变化之前 先来

519
00:17:00,766 --> 0:17:02,576
回顾一下改进

520
00:17:02,576 --> 0:17:03,886
语言的过程

521
00:17:04,516 --> 0:17:06,506
如同 Ted 所说 Swift 是一个

522
00:17:06,506 --> 0:17:08,506
开源项目 也具备

523
00:17:08,506 --> 0:17:09,556
开放式设计

524
00:17:10,165 --> 0:17:11,435
也就是说 如果你有

525
00:17:11,435 --> 0:17:13,066
改进语言的想法

526
00:17:13,386 --> 0:17:14,636
你可以在论坛上

527
00:17:14,715 --> 0:17:16,826
提出来 如果想法

528
00:17:16,826 --> 0:17:18,536
得到足够认可 并列入

529
00:17:18,606 --> 0:17:20,465
提议案 你就可以

530
00:17:20,465 --> 0:17:21,606
把想法和

531
00:17:21,606 --> 0:17:23,435
实现提交给核心团队

532
00:17:23,506 --> 0:17:24,286
以供审核

533
00:17:24,626 --> 0:17:26,165
此时 会有正式审核期

534
00:17:26,165 --> 0:17:27,596
社区成员

535
00:17:27,626 --> 0:17:28,946
可以提供额外反馈

536
00:17:29,016 --> 0:17:30,726
之后 核心团队

537
00:17:30,726 --> 0:17:32,486
就会决定是否

538
00:17:32,486 --> 0:17:33,606
接受提议

539
00:17:34,796 --> 0:17:36,196
如果访问 Swift Evolution

540
00:17:36,196 --> 0:17:38,346
网站 就能看到一系列

541
00:17:38,346 --> 0:17:39,596
提议 这些提议均得到了

542
00:17:39,596 --> 0:17:42,406
接受 并将在 Swift 4.2 中实现

543
00:17:43,396 --> 0:17:44,976
列表中包含的提议

544
00:17:44,976 --> 0:17:46,646
数量很多

545
00:17:46,646 --> 0:17:47,946
我今天无法涉及

546
00:17:47,946 --> 0:17:48,316
所有提议

547
00:17:48,776 --> 0:17:50,046
但有一点我想要

548
00:17:50,046 --> 0:17:51,776
强调 那就是

549
00:17:51,776 --> 0:17:53,086
有很多提议是

550
00:17:53,086 --> 0:17:55,476
由社区设计并

551
00:17:55,476 --> 0:17:56,136
实现的

552
00:17:56,566 --> 0:17:58,066
这表明 这些

553
00:17:58,066 --> 0:17:59,626
提议针对

554
00:17:59,666 --> 0:18:01,406
你们遇到的

555
00:17:59,666 --> 0:18:01,406
你们遇到的

556
00:18:01,406 --> 0:18:03,276
各类常见问题

557
00:18:03,276 --> 0:18:05,756
也是你们想出了

558
00:18:05,756 --> 0:18:07,636
解决方案

559
00:18:07,636 --> 0:18:09,246
并向 Swift 贡献了

560
00:18:09,286 --> 0:18:11,766
解决方案 使人人收益

561
00:18:12,166 --> 0:18:12,516
谢谢大家

562
00:18:14,516 --> 0:18:19,016
[ 掌声 ]

563
00:18:19,516 --> 0:18:20,936
第一项改进

564
00:18:21,126 --> 0:18:22,226
我们来看看

565
00:18:22,226 --> 0:18:23,636
如何在使用枚举时

566
00:18:23,636 --> 0:18:25,486
去除鸡肋代码

567
00:18:26,566 --> 0:18:28,196
比如说 我要获得一个枚举

568
00:18:28,616 --> 0:18:30,486
我想要打印出

569
00:18:30,486 --> 0:18:32,846
这个枚举包含的所有值

570
00:18:33,376 --> 0:18:36,286
在 Swift 4 中 我需要定义

571
00:18:36,286 --> 0:18:38,636
一个属性 例如包括所有

572
00:18:39,026 --> 0:18:40,386
可能样例的列表

573
00:18:41,056 --> 0:18:44,656
如果我要添加新的样例

574
00:18:44,656 --> 0:18:46,016
我要记得更新

575
00:18:46,086 --> 0:18:48,376
属性 否则就会呈现

576
00:18:48,376 --> 0:18:49,706
行为或运行时错误

577
00:18:50,976 --> 0:18:53,536
这种做法并不好

578
00:18:53,536 --> 0:18:54,936
因为你在向编译器

579
00:18:54,936 --> 0:18:56,406
重复自己的工作

580
00:18:56,986 --> 0:18:59,296
所以在 Swift 4.2 中 我们添加了

581
00:18:59,296 --> 0:19:01,966
新的 CaseIterable 协议

582
00:18:59,296 --> 0:19:01,966
新的 CaseIterable 协议

583
00:19:01,966 --> 0:19:03,346
如果你表示遵从（conformance）

584
00:19:03,406 --> 0:19:04,726
这一协议 编译器就会

585
00:19:04,726 --> 0:19:06,676
将包含所有样例的属性

586
00:19:06,676 --> 0:19:07,096
同步

587
00:19:07,096 --> 0:19:08,976
简短而有效

588
00:19:09,516 --> 0:19:12,546
[ 鼓掌 ]

589
00:19:13,046 --> 0:19:15,216
下一项改进 我们

590
00:19:15,216 --> 0:19:16,476
要去除另一个

591
00:19:16,476 --> 0:19:17,806
鸡肋代码的根源

592
00:19:18,016 --> 0:19:19,216
这种情况下

593
00:19:19,306 --> 0:19:20,436
你的代码往往

594
00:19:20,626 --> 0:19:21,786
不够泛型（generic）

595
00:19:22,726 --> 0:19:24,916
Swift 4 中 我们为序列

596
00:19:24,956 --> 0:19:26,596
引入了 contains() 方法

597
00:19:27,006 --> 0:19:28,506
这就要求

598
00:19:28,506 --> 0:19:30,106
序列的元素类型

599
00:19:30,106 --> 0:19:32,186
为 Equatable

600
00:19:32,186 --> 0:19:33,666
才能找出所需的元素

601
00:19:34,636 --> 0:19:36,736
当然 我可以对

602
00:19:36,736 --> 0:19:37,966
字符串组成的数组调用

603
00:19:38,236 --> 0:19:39,616
因为字符串是 Equatable 类型

604
00:19:39,616 --> 0:19:41,516
但如果对数组组成的数组

605
00:19:41,516 --> 0:19:42,346
调用呢

606
00:19:43,226 --> 0:19:45,736
如果子数组包含整型（integer）

607
00:19:45,736 --> 0:19:47,756
类型就不为 Equatable

608
00:19:48,126 --> 0:19:49,486
也就是说

609
00:19:49,486 --> 0:19:50,596
编译时间错误

610
00:19:51,796 --> 0:19:53,796
你可能会问 为什么

611
00:19:53,796 --> 0:19:55,106
标准库不让

612
00:19:55,196 --> 0:19:56,796
所有数列为 Equatable 呢

613
00:19:57,136 --> 0:19:58,316
但那样不合逻辑

614
00:19:58,316 --> 0:20:00,666
因为如果数列的

615
00:19:58,316 --> 0:20:00,666
因为如果数列的

616
00:20:00,666 --> 0:20:01,836
元素类型不为

617
00:20:01,836 --> 0:20:03,366
Equatable 例如函数

618
00:20:03,396 --> 0:20:06,566
你也不能让数列为 Equatable

619
00:20:07,956 --> 0:20:09,286
但显然 如果数列的

620
00:20:09,326 --> 0:20:10,846
元素类型为 Equatable

621
00:20:10,846 --> 0:20:12,726
我就可以为数组

622
00:20:12,726 --> 0:20:14,516
定义等值运算

623
00:20:14,516 --> 0:20:16,376
以比较数组中的元素对

624
00:20:17,116 --> 0:20:18,516
而这就是条件一致性

625
00:20:18,516 --> 0:20:20,116
（conditional conformance）对标准库

626
00:20:20,116 --> 0:20:21,286
发挥的作用

627
00:20:21,376 --> 0:20:23,076
现在 如果数组元素

628
00:20:23,076 --> 0:20:24,916
类型为 Equatable

629
00:20:24,916 --> 0:20:26,246
那么数组样例也可以

630
00:20:26,246 --> 0:20:27,056
实现 Equatable

631
00:20:27,416 --> 0:20:29,776
Swift 4.2 中 之前展示的

632
00:20:29,776 --> 0:20:31,366
例子可以运行

633
00:20:31,856 --> 0:20:34,776
除了数组为 Equatable 外

634
00:20:34,776 --> 0:20:37,636
标准库还定义了其他一些

635
00:20:37,636 --> 0:20:38,896
条件一致性

636
00:20:39,436 --> 0:20:41,026
例如 选项（options）

637
00:20:41,026 --> 0:20:42,726
和字典（dictionaries）也是 Equatable

638
00:20:42,726 --> 0:20:44,126
前提是它们的

639
00:20:44,126 --> 0:20:46,486
元素类型为 Equatable

640
00:20:46,536 --> 0:20:49,576
Hashable Encodable 和

641
00:20:49,576 --> 0:20:51,306
Decodable 同理

642
00:20:52,516 --> 0:20:57,576
[ 掌声 ]

643
00:20:58,076 --> 0:20:59,746
这样一来 你就可以

644
00:20:59,746 --> 0:21:01,156
用全新的方法

645
00:20:59,746 --> 0:21:01,156
用全新的方法

646
00:21:01,156 --> 0:21:02,256
构建集合（collections）

647
00:21:02,986 --> 0:21:05,886
这里 有一些由

648
00:21:05,886 --> 0:21:08,166
整数构成的数组

649
00:21:09,176 --> 0:21:10,366
一切运行正常

650
00:21:10,916 --> 0:21:13,416
欲知更多细节

651
00:21:13,416 --> 0:21:14,656
本周晚些时候有一场会议

652
00:21:14,656 --> 0:21:17,026
可以进一步了解

653
00:21:17,026 --> 0:21:18,476
条件一致性

654
00:21:18,476 --> 0:21:19,946
以及 Swift 4.2 中

655
00:21:19,946 --> 0:21:21,256
今天无法提及的

656
00:21:21,256 --> 0:21:22,536
泛型改进

657
00:21:23,896 --> 0:21:25,756
如果要定义自己的

658
00:21:25,756 --> 0:21:26,776
Equatable 和 Hashable

659
00:21:26,776 --> 0:21:27,606
成员（conformances）呢

660
00:21:28,596 --> 0:21:30,376
Swift 中的通用做法是

661
00:21:30,446 --> 0:21:32,446
用包含许多存储属性（stored properties）的

662
00:21:32,446 --> 0:21:34,516
结构体来实现

663
00:21:34,516 --> 0:21:36,006
而这些存储属性

664
00:21:36,006 --> 0:21:37,096
应为 Equatable

665
00:21:37,436 --> 0:21:38,546
接下来 要想让

666
00:21:38,546 --> 0:21:40,656
结构体 Equatable

667
00:21:40,656 --> 0:21:42,156
只需比较两个值的

668
00:21:42,156 --> 0:21:43,056
属性即可

669
00:21:43,516 --> 0:21:45,616
此前在 Swift 4 中 你需要

670
00:21:45,616 --> 0:21:46,726
亲手写出这些内容

671
00:21:47,166 --> 0:21:48,486
这就是鸡肋代码

672
00:21:48,706 --> 0:21:50,276
如果添加一个新的

673
00:21:50,276 --> 0:21:51,836
存储属性 就要记得

674
00:21:51,836 --> 0:21:53,286
更新 Equatable

675
00:21:53,286 --> 0:21:54,926
实现 很容易在

676
00:21:54,926 --> 0:21:57,166
拷贝粘贴等过程中出错

677
00:21:57,796 --> 0:21:59,676
Swift 4.1 中 我们可以

678
00:21:59,676 --> 0:22:01,536
合成 equality（相等性）

679
00:21:59,676 --> 0:22:01,536
合成 equality（相等性）

680
00:22:01,536 --> 0:22:02,926
的使用

681
00:22:03,386 --> 0:22:04,966
如果忘记了实现部分

682
00:22:05,186 --> 0:22:06,326
编译器会为你

683
00:22:06,326 --> 0:22:08,046
补上 前提是

684
00:22:08,046 --> 0:22:10,036
存储属性本身为 Equatable

685
00:22:11,076 --> 0:22:12,626
这也适用于 Hashable

686
00:22:13,996 --> 0:22:15,726
那么如果是泛型呢

687
00:22:16,266 --> 0:22:17,986
这个数据类型中

688
00:22:17,986 --> 0:22:19,556
值可能是

689
00:22:19,556 --> 0:22:22,316
左类型的实例 或者是右类型的实例

690
00:22:22,936 --> 0:22:26,216
我想让左右类型都为

691
00:22:26,216 --> 0:22:28,876
Equatable  因为我想令这两个类型

692
00:22:28,876 --> 0:22:31,046
为函数 错误（errors）

693
00:22:31,046 --> 0:22:32,446
或其他不为 Equatable 的类型

694
00:22:32,916 --> 0:22:34,326
但显然 我可以定义

695
00:22:34,326 --> 0:22:36,226
条件一致性 这样

696
00:22:36,226 --> 0:22:37,506
如果左右类型都为

697
00:22:37,506 --> 0:22:39,726
Equatable  二者之一即为 Equatable

698
00:22:40,116 --> 0:22:41,696
但还可以进一步改进

699
00:22:42,166 --> 0:22:43,666
注意此处的可等性

700
00:22:43,666 --> 0:22:45,576
实现 只有一种

701
00:22:45,576 --> 0:22:47,616
显然正确的实现方式

702
00:22:47,946 --> 0:22:49,186
需要确保两个值

703
00:22:49,186 --> 0:22:51,416
包含相同的样例

704
00:22:51,416 --> 0:22:53,286
如果确实如此 则需要检查载体（payloads）

705
00:22:53,286 --> 0:22:53,996
以确保可等性

706
00:22:54,776 --> 0:22:56,396
你可能会想 

707
00:22:56,396 --> 0:22:57,426
编译器应该能够

708
00:22:57,426 --> 0:22:58,926
替你进行合成

709
00:22:58,926 --> 0:23:00,256
Swift 4.2 中确实可以

710
00:22:58,926 --> 0:23:00,256
Swift 4.2 中确实可以

711
00:23:01,176 --> 0:23:02,666
该功能也可用于

712
00:23:02,666 --> 0:23:03,186
Hashable

713
00:23:04,676 --> 0:23:07,166
比方说 现在就可以创建

714
00:23:07,356 --> 0:23:09,786
元素为整型或字符串的集合了

715
00:23:11,546 --> 0:23:11,656
好的

716
00:23:12,516 --> 0:23:15,676
[ 掌声 ]

717
00:23:16,176 --> 0:23:18,146
有时 你确实需要

718
00:23:18,146 --> 0:23:19,526
手动实现

719
00:23:19,586 --> 0:23:22,766
可等性和哈希值（Hashing）

720
00:23:23,436 --> 0:23:25,456
我们来看一个例子

721
00:23:26,616 --> 0:23:27,866
假如说 有一个数据类型

722
00:23:28,006 --> 0:23:30,796
表示一座城市 其中

723
00:23:30,796 --> 0:23:32,166
包括城市名 包括所在的

724
00:23:32,166 --> 0:23:34,296
州 还包括城市的人口

725
00:23:34,706 --> 0:23:35,556
在这个例子中

726
00:23:35,556 --> 0:23:38,006
我只需要

727
00:23:38,006 --> 0:23:39,536
比较城市名和州

728
00:23:39,536 --> 0:23:41,456
以确保可等性

729
00:23:41,456 --> 0:23:42,826
如果数值相等 就不需要

730
00:23:42,826 --> 0:23:43,926
对比人口了

731
00:23:44,616 --> 0:23:46,446
如果我让编译器

732
00:23:46,446 --> 0:23:48,056
合成可等性的

733
00:23:48,056 --> 0:23:49,706
实现 就会产生

734
00:23:49,706 --> 0:23:52,006
冗余 因为它还比较了

735
00:23:52,006 --> 0:23:53,046
人口信息

736
00:23:53,776 --> 0:23:55,436
我当然可以把这部分

737
00:23:55,436 --> 0:23:56,976
写成代码 或许此时

738
00:23:56,976 --> 0:23:57,636
这样还可以

739
00:23:58,556 --> 0:23:59,796
但 Hashable 呢

740
00:24:01,286 --> 0:24:02,796
如果我想计算

741
00:24:02,836 --> 0:24:04,566
城市对象的哈希值

742
00:24:05,066 --> 0:24:06,986
我就要算出

743
00:24:07,016 --> 0:24:08,336
城市名的哈希值和

744
00:24:08,336 --> 0:24:09,636
州的哈希值

745
00:24:09,636 --> 0:24:11,086
再想办法结合二者

746
00:24:11,646 --> 0:24:12,686
但该怎么做呢

747
00:24:13,296 --> 0:24:15,286
可以用异或运算

748
00:24:15,286 --> 0:24:18,246
也可以用

749
00:24:18,246 --> 0:24:20,196
网上随便找的

750
00:24:20,196 --> 0:24:21,866
或者自己编的

751
00:24:21,866 --> 0:24:22,656
运算方式

752
00:24:23,246 --> 0:24:24,976
但这两种办法

753
00:24:24,976 --> 0:24:27,306
都不够好 好像

754
00:24:27,306 --> 0:24:28,896
结合哈希值的函数

755
00:24:29,176 --> 0:24:30,556
是一种魔法似的

756
00:24:30,876 --> 0:24:32,336
而出错的成本

757
00:24:32,336 --> 0:24:34,376
也相当高 因为

758
00:24:34,376 --> 0:24:35,846
字典和集合

759
00:24:35,846 --> 0:24:37,526
要想具备良好性能

760
00:24:37,526 --> 0:24:39,716
确实需要依赖

761
00:24:39,716 --> 0:24:41,416
高质量的哈希函数

762
00:24:42,146 --> 0:24:44,266
同时也有安全考量

763
00:24:44,636 --> 0:24:46,966
如果攻击者

764
00:24:46,966 --> 0:24:49,336
打造的输入能生成

765
00:24:49,336 --> 0:24:51,086
相同的哈希值

766
00:24:51,086 --> 0:24:52,336
并通过互联网发给你的 App 

767
00:24:52,396 --> 0:24:54,286
就可能降低 App

768
00:24:54,286 --> 0:24:55,466
运行速度 以致

769
00:24:55,466 --> 0:24:56,906
无法使用 即发起

770
00:24:56,906 --> 0:24:58,056
阻断服务攻击（denial-of-service attack）

771
00:24:58,536 --> 0:25:01,066
所以 在 Swift 4.2 中 我们添加了

772
00:24:58,536 --> 0:25:01,066
所以 在 Swift 4.2 中 我们添加了

773
00:25:01,066 --> 0:25:02,476
更好的 API 实现该功能

774
00:25:03,316 --> 0:25:05,396
可以回想一下 Swift 4

775
00:25:05,396 --> 0:25:06,896
和 4.1 中的 Hashable 协议

776
00:25:07,486 --> 0:25:09,076
其中一个 hashValue

777
00:25:09,076 --> 0:25:10,446
要求（requirement） 返回一个

778
00:25:10,446 --> 0:25:11,696
整型值

779
00:25:12,446 --> 0:25:14,676
Swift 4.2 中 我们重新设计了

780
00:25:14,676 --> 0:25:16,936
Hashable 协议 现在

781
00:25:17,296 --> 0:25:19,746
有了新的 Hash into 要求

782
00:25:20,126 --> 0:25:21,346
Hash into 不产生

783
00:25:21,346 --> 0:25:23,466
单一哈希值

784
00:25:23,466 --> 0:25:26,146
而是选用一个 Hasher 实例

785
00:25:26,146 --> 0:25:27,636
之后可以将

786
00:25:27,636 --> 0:25:29,616
多个值传入 Hasher

787
00:25:29,616 --> 0:25:31,376
Hasher 会结合传入值 生成一个哈希值

788
00:25:32,306 --> 0:25:34,096
回到城市数据类型的

789
00:25:34,096 --> 0:25:36,076
例子 我们只需要 

790
00:25:36,076 --> 0:25:38,226
对我们给出的 Hasher 对象实例中

791
00:25:38,226 --> 0:25:42,576
传入的城市名和州

792
00:25:42,576 --> 0:25:44,596
进行递归的

793
00:25:44,596 --> 0:25:45,316
Hash into 调用

794
00:25:46,486 --> 0:25:49,786
Hasher 中的

795
00:25:49,786 --> 0:25:51,726
哈希合并算法

796
00:25:51,726 --> 0:25:53,526
可以有效平衡

797
00:25:53,526 --> 0:25:55,146
哈希值质量和性能

798
00:25:55,476 --> 0:25:56,556
还可以作为额外保护

799
00:25:56,606 --> 0:25:57,816
抵御阻断服务攻击

800
00:25:57,816 --> 0:25:59,686
为此 它使用了

801
00:25:59,686 --> 0:26:01,616
App 启动时生成的

802
00:25:59,686 --> 0:26:01,616
App 启动时生成的

803
00:26:01,616 --> 0:26:03,346
随机预处理种子

804
00:26:05,136 --> 0:26:07,236
我们认为 你可以

805
00:26:07,316 --> 0:26:09,136
很轻松地迁移代码

806
00:26:09,136 --> 0:26:10,746
来使用新的 Hashable

807
00:26:10,746 --> 0:26:12,756
协议 我们也鼓励你这样做

808
00:26:13,206 --> 0:26:15,016
有一条警告

809
00:26:15,016 --> 0:26:16,936
你可能原本

810
00:26:16,936 --> 0:26:18,746
希望哈希值

811
00:26:18,746 --> 0:26:20,426
能够在多次运行 App 中

812
00:26:20,426 --> 0:26:22,296
保持不变 或者

813
00:26:22,296 --> 0:26:23,566
在遍历字典

814
00:26:23,566 --> 0:26:25,416
或集合的时候

815
00:26:25,416 --> 0:26:26,976
希望以同一顺序获取元素

816
00:26:27,256 --> 0:26:28,726
这些已经不再可行

817
00:26:28,726 --> 0:26:29,656
因为使用了随机

818
00:26:29,656 --> 0:26:30,676
预处理种子

819
00:26:30,746 --> 0:26:32,116
你可能需要调整代码

820
00:26:32,916 --> 0:26:35,096
为了简化工作 我们

821
00:26:35,096 --> 0:26:37,336
添加了一项构建设置 即 

822
00:26:37,336 --> 0:26:38,426
SWIFT_DETERMINISTIC_HASHING

823
00:26:38,426 --> 0:26:39,996
环境变量 你可以

824
00:26:39,996 --> 0:26:41,666
在方案编辑器（Scheme Editor）中激活

825
00:26:42,246 --> 0:26:43,736
以暂时停用

826
00:26:43,786 --> 0:26:45,256
随机预处理种子

827
00:26:45,796 --> 0:26:49,466
接下来 来谈谈

828
00:26:49,606 --> 0:26:51,096
随机数生成

829
00:26:52,396 --> 0:26:53,656
现在 你们在 Swift 中

830
00:26:53,656 --> 0:26:54,706
如何生成随机数

831
00:26:55,356 --> 0:26:58,376
你需要导入 C 语言的 API

832
00:26:58,446 --> 0:26:59,876
这确实不够理想

833
00:26:59,876 --> 0:27:01,446
因为 API 

834
00:26:59,876 --> 0:27:01,446
因为 API 

835
00:27:01,446 --> 0:27:03,866
因平台而异

836
00:27:03,866 --> 0:27:04,876
名字不同

837
00:27:04,876 --> 0:27:06,586
行为不同

838
00:27:06,666 --> 0:27:08,156
需要检查构建配置

839
00:27:08,566 --> 0:27:10,486
此外 这些 API 位于底层

840
00:27:10,486 --> 0:27:12,806
还会用到一些

841
00:27:12,806 --> 0:27:14,566
不太直观的常见运算

842
00:27:15,316 --> 0:27:16,886
例如 如果我想得到

843
00:27:16,886 --> 0:27:19,016
1 到 6 之间的随机数

844
00:27:19,406 --> 0:27:21,446
我需要调用

845
00:27:21,446 --> 0:27:23,716
Darwin 中的 arc4random 函数

846
00:27:23,826 --> 0:27:25,366
再除以 6

847
00:27:25,366 --> 0:27:26,556
来求余

848
00:27:26,836 --> 0:27:27,916
但这样的结果

849
00:27:27,916 --> 0:27:29,476
往往并非均匀

850
00:27:29,476 --> 0:27:31,566
分布在 1 到 6 之间

851
00:27:32,346 --> 0:27:35,386
Swift 4.2 中 我们添加了

852
00:27:35,386 --> 0:27:37,236
一组新的 API

853
00:27:37,236 --> 0:27:38,086
以简化操作

854
00:27:39,146 --> 0:27:41,186
首先 我们为所有数字类型

855
00:27:41,186 --> 0:27:43,296
定义了 random 方法

856
00:27:43,486 --> 0:27:45,576
可以获取一个范围 返回

857
00:27:45,576 --> 0:27:47,986
平均分布在范围中的数字

858
00:27:48,196 --> 0:27:49,816
这种方法使用了正确算法

859
00:27:49,816 --> 0:27:51,316
也适用于浮点型（floats）

860
00:27:52,516 --> 0:27:58,596
[ 掌声 ]

861
00:27:59,096 --> 0:28:00,676
对于顶层代码 我们

862
00:27:59,096 --> 0:28:00,676
对于顶层代码 我们

863
00:28:00,676 --> 0:28:03,076
为集合协议添加了

864
00:28:03,076 --> 0:28:04,196
randomElement 方法

865
00:28:04,786 --> 0:28:07,026
可以像 min 和 max 方法一样

866
00:28:07,026 --> 0:28:08,636
返回选项

867
00:28:08,636 --> 0:28:10,376
如果传入空集合

868
00:28:10,526 --> 0:28:11,506
会返回空

869
00:28:12,596 --> 0:28:14,326
最后 我们为集合添加了

870
00:28:14,326 --> 0:28:17,116
shuffle 方法

871
00:28:17,116 --> 0:28:18,926
可以生成一个

872
00:28:18,926 --> 0:28:21,616
该集合元素的随机排列组合的数组

873
00:28:22,146 --> 0:28:25,216
我们认为 默认的随机数

874
00:28:25,216 --> 0:28:26,636
生成器（Random Number Generator）

875
00:28:26,636 --> 0:28:27,996
适合大多数 App

876
00:28:28,296 --> 0:28:29,883
但你也可以采用自己的算法

877
00:28:30,676 --> 0:28:31,836
现在 有了新的

878
00:28:31,836 --> 0:28:34,206
RandomNumberGenerator 协议

879
00:28:34,206 --> 0:28:35,606
一旦你创建一个符合

880
00:28:35,606 --> 0:28:37,826
该协议的类型 就可以将它

881
00:28:37,826 --> 0:28:39,326
传递给我提到的 API

882
00:28:39,326 --> 0:28:40,846
API 拥有一个使用 using 参数的

883
00:28:40,846 --> 0:28:43,416
额外重载（additional overload）

884
00:28:43,576 --> 0:28:44,706
可以接收 RandomNumberGenerator

885
00:28:44,706 --> 0:28:45,236
作为输入

886
00:28:46,746 --> 0:28:49,456
好的 之前我们看到了

887
00:28:49,456 --> 0:28:51,446
构建配置检查

888
00:28:51,526 --> 0:28:54,346
我们再多了解一些

889
00:28:54,566 --> 0:28:56,806
这是 Swift 中常见的情况

890
00:28:57,026 --> 0:28:58,356
有一小段代码

891
00:28:58,356 --> 0:29:00,796
在 iOS 和 macOS 间共用

892
00:28:58,356 --> 0:29:00,796
在 iOS 和 macOS 间共用

893
00:29:00,796 --> 0:29:03,836
在 iOS 上 你应该

894
00:29:03,836 --> 0:29:05,206
使用 UIKit

895
00:29:05,586 --> 0:29:06,776
在 macOS 上 你应该

896
00:29:06,776 --> 0:29:08,156
使用 AppKit

897
00:29:08,896 --> 0:29:10,466
现在要做到这一点

898
00:29:10,466 --> 0:29:11,816
你要写一段 #if 代码

899
00:29:12,236 --> 0:29:14,186
来进行编译时间检查

900
00:29:14,186 --> 0:29:15,386
之后需要列出

901
00:29:15,386 --> 0:29:17,736
支持 UIKit 的操作系统

902
00:29:18,566 --> 0:29:20,046
但你真正关心的

903
00:29:20,046 --> 0:29:21,836
不是你在运行

904
00:29:21,836 --> 0:29:23,016
什么操作系统

905
00:29:23,016 --> 0:29:25,096
而是导入 UIKit

906
00:29:25,626 --> 0:29:27,956
Swift 4.2 中 我们添加了

907
00:29:27,956 --> 0:29:30,086
canImport() 构建配置指令

908
00:29:30,086 --> 0:29:32,486
（Build Configuration Directive）

909
00:29:32,486 --> 0:29:33,476
帮助你表达本意

910
00:29:34,171 --> 0:29:36,171
[ 掌声 ]

911
00:29:36,326 --> 0:29:38,026
而利用 Swift 4.2 的新特性

912
00:29:38,026 --> 0:29:39,686
我还可以进一步

913
00:29:39,686 --> 0:29:40,766
完善代码

914
00:29:41,246 --> 0:29:43,326
比方说 我还要

915
00:29:43,326 --> 0:29:44,966
专门检查 AppKit

916
00:29:45,306 --> 0:29:47,036
如果 UIKit 和

917
00:29:47,036 --> 0:29:48,866
AppKit 都不可用

918
00:29:48,866 --> 0:29:50,576
例如我在 Linux 上构建

919
00:29:50,576 --> 0:29:52,356
我就可以使用新的 #error

920
00:29:52,546 --> 0:29:53,916
构建指令来生成

921
00:29:53,916 --> 0:29:55,796
编译时间错误信息

922
00:29:57,206 --> 0:29:59,376
好的 还有一种类似的

923
00:29:59,376 --> 0:30:00,416
鸡肋代码

924
00:29:59,376 --> 0:30:00,416
鸡肋代码

925
00:30:01,616 --> 0:30:03,126
如果我想在

926
00:30:03,126 --> 0:30:05,066
模拟器环境中

927
00:30:05,066 --> 0:30:06,476
编译代码

928
00:30:06,776 --> 0:30:09,266
在 Swift 4 中 我需要

929
00:30:09,266 --> 0:30:11,546
把这一段东西

930
00:30:11,546 --> 0:30:12,686
拷贝 粘贴到所有我想要进行检查的地方 才能

931
00:30:12,686 --> 0:30:13,176
进行检测

932
00:30:14,056 --> 0:30:16,456
Swift 4.2 中 你可以使用新的

933
00:30:16,456 --> 0:30:18,596
hasTargetEnvironment() 环境判断

934
00:30:18,906 --> 0:30:21,216
来更好地表达本意

935
00:30:21,216 --> 0:30:23,006
还可以直接询问

936
00:30:23,006 --> 0:30:25,026
编译器 我是不是在

937
00:30:25,026 --> 0:30:26,106
为模拟器编译

938
00:30:26,876 --> 0:30:28,826
说到这里

939
00:30:28,826 --> 0:30:30,566
我们再把 FIXME 换成

940
00:30:30,656 --> 0:30:32,036
#warning 构建指令

941
00:30:32,076 --> 0:30:33,986
来生成信息

942
00:30:34,046 --> 0:30:35,856
或运行时间 提醒我别忘了

943
00:30:35,856 --> 0:30:38,126
修复 FIXME

944
00:30:38,126 --> 0:30:40,916
好的 这差不多就是

945
00:30:40,916 --> 0:30:42,306
我今天要讲的

946
00:30:42,306 --> 0:30:43,516
全部特性

947
00:30:43,516 --> 0:30:44,936
但我还有几项要提一下

948
00:30:46,026 --> 0:30:47,646
我们来解析一下

949
00:30:47,646 --> 0:30:48,586
隐式解析选项（Implicitly Unwrapped 

950
00:30:48,806 --> 0:30:49,646
Optionals） 这个梗没效果啊

951
00:30:50,296 --> 0:30:52,986
好吧 隐式解析选项

952
00:30:52,986 --> 0:30:54,326
可能会有点

953
00:30:54,326 --> 0:30:57,686
让人疑惑 我们先来

954
00:30:57,686 --> 0:31:00,196
看看它的思维模型

955
00:30:57,686 --> 0:31:00,196
看看它的思维模型

956
00:31:00,196 --> 0:31:01,266
应该如何理解它

957
00:31:01,966 --> 0:31:04,426
从 Swift 3 开始

958
00:31:04,426 --> 0:31:06,326
不是表达式的一种类型

959
00:31:06,816 --> 0:31:08,006
不要认为它是一种类型

960
00:31:08,446 --> 0:31:09,856
而要认为

961
00:31:09,856 --> 0:31:11,256
它是声明的

962
00:31:11,256 --> 0:31:13,096
特性之一

963
00:31:13,996 --> 0:31:15,756
当你引用这种声明是

964
00:31:15,756 --> 0:31:17,526
编译器会首先

965
00:31:17,846 --> 0:31:19,186
检查它的类型

966
00:31:19,186 --> 0:31:21,536
看它是不是普通的选项

967
00:31:21,536 --> 0:31:23,006
如果在它的使用场景中

968
00:31:23,006 --> 0:31:24,556
它不合理

969
00:31:24,746 --> 0:31:26,916
编译器就会将其解析

970
00:31:26,916 --> 0:31:28,096
进行类型检查 将其标记为

971
00:31:28,096 --> 0:31:28,876
下划线类型（underlined type）

972
00:31:30,296 --> 0:31:31,746
我们来看看第一种

973
00:31:31,746 --> 0:31:32,506
情况的例子

974
00:31:33,236 --> 0:31:34,886
这里有两个函数

975
00:31:34,966 --> 0:31:36,596
第一个会生成

976
00:31:36,596 --> 0:31:37,906
整型的隐式解析选项

977
00:31:37,906 --> 0:31:39,656
第二个则会接受

978
00:31:39,656 --> 0:31:41,226
任何类型的传入值

979
00:31:41,836 --> 0:31:43,306
我要用第一个函数的

980
00:31:43,306 --> 0:31:45,256
结果 来调用第二个函数

981
00:31:45,916 --> 0:31:47,966
这个例子中 我可以

982
00:31:47,966 --> 0:31:50,506
在任意（Any）类型中存入整型选项

983
00:31:50,856 --> 0:31:53,206
不会进行强制解析

984
00:31:53,466 --> 0:31:55,896
值会变成一个普通的选项

985
00:31:55,896 --> 0:31:59,966
我们再看看第二种情况的例子

986
00:32:00,876 --> 0:32:02,856
现在 第一个函数生成

987
00:32:02,856 --> 0:32:05,486
对不起 第二个函数

988
00:32:05,486 --> 0:32:07,086
现在接受整型

989
00:32:07,516 --> 0:32:09,066
如果我使用第一个函数的

990
00:32:09,066 --> 0:32:10,646
结果 调用第二个

991
00:32:10,706 --> 0:32:13,006
函数 我就不能

992
00:32:13,086 --> 0:32:14,986
传递整型选项 因为

993
00:32:14,986 --> 0:32:16,126
函数需要整型

994
00:32:16,596 --> 0:32:18,246
所以 编译器必须进行

995
00:32:18,246 --> 0:32:21,296
强制解析 之后

996
00:32:21,296 --> 0:32:22,656
代码运行正常 因为这里需要整型

997
00:32:22,836 --> 0:32:26,266
也传入了整型 这个思维模型

998
00:32:26,346 --> 0:32:27,626
可以很好地

999
00:32:27,626 --> 0:32:29,506
帮助理解隐式解析选项

1000
00:32:30,206 --> 0:32:32,566
但直到最近 编译器

1001
00:32:32,776 --> 0:32:34,166
还是会遇到一些不遵从

1002
00:32:34,166 --> 0:32:35,636
此模型的极端案例

1003
00:32:36,316 --> 0:32:38,956
所以记住 隐式解析选项

1004
00:32:38,956 --> 0:32:41,696
不能是其他类型的一部分

1005
00:32:42,416 --> 0:32:43,706
Swift 4.2 中

1006
00:32:43,706 --> 0:32:44,646
依然如此

1007
00:32:44,816 --> 0:32:46,616
数组不能包含

1008
00:32:46,676 --> 0:32:48,296
隐式解析整型

1009
00:32:49,136 --> 0:32:51,566
但在 Swift 4 中

1010
00:32:51,876 --> 0:32:53,536
有一些像这样的极端案例

1011
00:32:53,536 --> 0:32:55,606
我可以定义一个 typealias

1012
00:32:55,796 --> 0:32:57,596
它的实际类型可以是

1013
00:32:57,776 --> 0:32:59,606
隐式解析整型

1014
00:32:59,606 --> 0:33:00,956
接下来 我就可以用这个

1015
00:32:59,606 --> 0:33:00,956
接下来 我就可以用这个

1016
00:33:01,016 --> 0:33:03,166
typealias 创建数组

1017
00:33:03,166 --> 0:33:04,756
从而使编译器的行为

1018
00:33:04,756 --> 0:33:06,906
匪夷所思 令代码难以理解

1019
00:33:07,596 --> 0:33:09,516
因此 在 Swift 4.2 中 我们

1020
00:33:09,516 --> 0:33:10,816
重新采用了

1021
00:33:10,816 --> 0:33:12,556
隐式解析选项

1022
00:33:12,666 --> 0:33:14,736
完美契合我之前

1023
00:33:14,736 --> 0:33:17,186
提到的思维模型

1024
00:33:17,386 --> 0:33:19,226
这一段匪夷所思的代码

1025
00:33:19,226 --> 0:33:20,986
现在会生成编译时间错误

1026
00:33:21,306 --> 0:33:23,586
编译器也会将其

1027
00:33:23,946 --> 0:33:25,816
按照普通整型数组

1028
00:33:25,816 --> 0:33:27,576
或整型选项数组来解析

1029
00:33:28,546 --> 0:33:30,836
大多数代码不会

1030
00:33:30,836 --> 0:33:32,266
因隐式解析选项的

1031
00:33:32,266 --> 0:33:33,626
这一变化而受影响

1032
00:33:34,036 --> 0:33:35,436
但如果你碰巧

1033
00:33:35,436 --> 0:33:37,426
用到了这些极端案例

1034
00:33:37,426 --> 0:33:38,696
我建议你看一看

1035
00:33:38,746 --> 0:33:41,096
Swift.org 上的这篇博客文章

1036
00:33:41,096 --> 0:33:42,486
这篇文章包含更多细节

1037
00:33:42,486 --> 0:33:44,736
举了很多例子 来说明

1038
00:33:44,736 --> 0:33:47,136
变化的种类和方式

1039
00:33:47,376 --> 0:33:50,566
好的 还有最后一项

1040
00:33:50,986 --> 0:33:52,566
我们来谈谈内存

1041
00:33:52,566 --> 0:33:53,866
独占性检查（memory exclusivity checking）

1042
00:33:55,196 --> 0:33:57,946
大家还记得 在 Swift 4 中 我们

1043
00:33:57,946 --> 0:33:59,896
带来了所谓的

1044
00:33:59,896 --> 0:34:01,386
内存独占性检查

1045
00:33:59,896 --> 0:34:01,386
内存独占性检查

1046
00:34:01,646 --> 0:34:02,896
该功能结合了

1047
00:34:02,956 --> 0:34:05,186
运行时检查

1048
00:34:05,436 --> 0:34:06,696
和编译时检查

1049
00:34:06,696 --> 0:34:08,856
但一些功能受限

1050
00:34:09,315 --> 0:34:10,976
我们专门限制了

1051
00:34:11,286 --> 0:34:13,376
对同一内存区域的

1052
00:34:13,376 --> 0:34:14,356
重复访问

1053
00:34:14,856 --> 0:34:15,656
这意味着什么

1054
00:34:15,815 --> 0:34:17,096
我们来看个例子

1055
00:34:17,666 --> 0:34:20,085
这一段代码

1056
00:34:20,085 --> 0:34:21,706
为操作系统路径

1057
00:34:21,896 --> 0:34:23,246
实现了一个数据类型

1058
00:34:23,766 --> 0:34:25,446
表现为包含路径元素的

1059
00:34:25,565 --> 0:34:27,005
一个数组

1060
00:34:27,576 --> 0:34:29,206
还使用了 withAppended 方法

1061
00:34:30,216 --> 0:34:31,946
这个方法可以向数组中

1062
00:34:31,946 --> 0:34:33,735
添加元素 再调用 closure()

1063
00:34:33,735 --> 0:34:35,806
作用于你传入的元素

1064
00:34:35,806 --> 0:34:37,626
再将它从数组中移出

1065
00:34:38,295 --> 0:34:40,036
这段代码没有问题

1066
00:34:40,036 --> 0:34:41,726
在 Swift 4 中运行无误

1067
00:34:42,755 --> 0:34:44,505
但我们来看一下

1068
00:34:44,505 --> 0:34:45,536
Path 数据类型的使用

1069
00:34:46,545 --> 0:34:47,976
这个 path 变量

1070
00:34:47,976 --> 0:34:49,746
存储在局部变量中

1071
00:34:50,056 --> 0:34:51,806
我对它调用 withAppended 方法

1072
00:34:52,295 --> 0:34:54,856
在 closure 中 我再访问

1073
00:34:54,856 --> 0:34:56,306
这个局部变量

1074
00:34:56,536 --> 0:34:57,056
并将它打印出来

1075
00:34:57,556 --> 0:34:58,696
问题出在哪儿

1076
00:34:59,436 --> 0:35:01,076
事实上 这段代码

1077
00:34:59,436 --> 0:35:01,076
事实上 这段代码

1078
00:35:01,076 --> 0:35:03,756
有歧义 因为

1079
00:35:03,756 --> 0:35:05,866
当我访问 closure 中的

1080
00:35:06,136 --> 0:35:08,436
局部变量时 它已经被

1081
00:35:08,436 --> 0:35:10,086
withAppended

1082
00:35:10,086 --> 0:35:11,686
这一可变方法（mutating method）

1083
00:35:11,686 --> 0:35:12,586
修改过了

1084
00:35:13,306 --> 0:35:16,136
歧义之处在于

1085
00:35:16,136 --> 0:35:18,466
我所指的是 path

1086
00:35:18,806 --> 0:35:20,556
在调用 withAppended 之前的

1087
00:35:20,556 --> 0:35:22,706
原始值 还是

1088
00:35:22,706 --> 0:35:24,106
修改之后的

1089
00:35:24,106 --> 0:35:25,926
当前值

1090
00:35:26,756 --> 0:35:28,636
Swift 4 中 这是一处

1091
00:35:28,636 --> 0:35:30,396
编译时错误 因为

1092
00:35:30,396 --> 0:35:32,226
它违反了独占性

1093
00:35:32,756 --> 0:35:34,716
要解决这一问题

1094
00:35:34,716 --> 0:35:35,976
消除歧义 办法之一

1095
00:35:35,976 --> 0:35:37,926
是告诉编译器

1096
00:35:37,926 --> 0:35:40,496
我想要获得当前值 所以

1097
00:35:40,496 --> 0:35:41,766
我只将其作为参数

1098
00:35:41,766 --> 0:35:44,986
传入 closure 而不去捕获它

1099
00:35:45,586 --> 0:35:47,936
可以 但再看看这个例子

1100
00:35:48,266 --> 0:35:49,586
这个函数和刚才的

1101
00:35:49,586 --> 0:35:51,376
几乎相同 除了这是一个泛型

1102
00:35:51,376 --> 0:35:53,326
函数 参数由

1103
00:35:53,326 --> 0:35:54,646
closure 返回值的类型决定

1104
00:35:55,306 --> 0:35:57,436
这个例子中 我们会遇到

1105
00:35:57,436 --> 0:35:59,286
类似的歧义 因为

1106
00:35:59,286 --> 0:36:01,246
要从闭包内部获得

1107
00:35:59,286 --> 0:36:01,246
要从闭包内部获得

1108
00:36:01,246 --> 0:36:02,166
path 的值

1109
00:36:02,496 --> 0:36:04,766
但 Swift 4 无法在

1110
00:36:04,766 --> 0:36:06,866
编译时捕获到这个错误

1111
00:36:08,286 --> 0:36:10,436
Swift 4.2 中 我们改进了

1112
00:36:10,436 --> 0:36:12,526
静态独占性检查（static exclusivity 

1113
00:36:12,526 --> 0:36:15,256
checking） 可以在更多情况下 指出这样的歧义

1114
00:36:16,386 --> 0:36:18,546
除了改进

1115
00:36:19,146 --> 0:36:20,526
好吧 你还可以用类似方法

1116
00:36:20,526 --> 0:36:22,236
将变量值作为

1117
00:36:22,236 --> 0:36:23,566
closure 的参数传入

1118
00:36:23,566 --> 0:36:24,026
来消除歧义

1119
00:36:24,576 --> 0:36:26,876
除了改进

1120
00:36:26,876 --> 0:36:28,986
静态检查 我们还新增了

1121
00:36:28,986 --> 0:36:30,796
使用运行时独占性检查

1122
00:36:30,796 --> 0:36:32,906
和释放构造的功能

1123
00:36:33,336 --> 0:36:35,166
这会牺牲一些性能

1124
00:36:35,166 --> 0:36:36,606
但如果你的 App 不注重

1125
00:36:36,606 --> 0:36:38,096
性能 我们鼓励你尝试一下

1126
00:36:38,096 --> 0:36:39,746
并且始终开启

1127
00:36:39,746 --> 0:36:40,216
这一功能

1128
00:36:40,686 --> 0:36:42,386
未来 我们会将

1129
00:36:42,386 --> 0:36:44,236
动态检查的性能损耗

1130
00:36:44,306 --> 0:36:46,276
大幅降低 这样就可以

1131
00:36:46,276 --> 0:36:48,126
始终开启这一功能

1132
00:36:48,186 --> 0:36:49,226
这一功能还能带来

1133
00:36:49,226 --> 0:36:50,846
额外保护 就像

1134
00:36:50,896 --> 0:36:53,296
数组边界检查（array bounds checking）

1135
00:36:53,296 --> 0:36:54,596
或整型溢出检查（integer overflow checking）

1136
00:36:55,166 --> 0:36:58,316
一样 Swift 4.2 中还有

1137
00:36:58,316 --> 0:37:01,576
很多我没有涉及的特性

1138
00:36:58,316 --> 0:37:01,576
很多我没有涉及的特性

1139
00:37:02,096 --> 0:37:03,716
我们鼓励大家

1140
00:37:03,716 --> 0:37:05,496
在现有 App 中尝试

1141
00:37:05,546 --> 0:37:06,776
我们希望大家多尝试

1142
00:37:06,776 --> 0:37:08,536
新特性 如果有

1143
00:37:08,536 --> 0:37:10,056
任何问题 欢迎来到

1144
00:37:10,056 --> 0:37:11,966
实验室 咨询我们

1145
00:37:12,556 --> 0:37:12,956
谢谢

1146
00:37:14,516 --> 0:37:19,500
[ 掌声 ]
