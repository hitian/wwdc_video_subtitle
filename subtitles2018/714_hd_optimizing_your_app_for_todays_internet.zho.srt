1
00:00:06,516 --> 0:00:15,500
[ 音乐 ]

2
00:00:19,516 --> 0:00:26,386
[ 掌声 ]

3
00:00:26,886 --> 0:00:28,196
&gt;&gt; 女士们 先生们 早上好

4
00:00:28,986 --> 0:00:29,986
你们中有多少人

5
00:00:29,986 --> 0:00:31,706
是第一次来 WWDC 

6
00:00:33,666 --> 0:00:34,806
非常棒

7
00:00:34,806 --> 0:00:36,536
每年都能见到一些新面孔

8
00:00:36,536 --> 0:00:37,336
实在是太好了

9
00:00:38,046 --> 0:00:39,146
我是 Stuart Cheshire

10
00:00:39,266 --> 0:00:41,166
我们将会讨论网络

11
00:00:42,176 --> 0:00:45,946
我会先从影响你的 App 性能的

12
00:00:45,946 --> 0:00:47,296
一些话题开始

13
00:00:47,886 --> 0:00:48,806
如今完全不利用网络的

14
00:00:48,806 --> 0:00:51,766
App 已经几乎没有了

15
00:00:52,246 --> 0:00:54,026
而让网络性能

16
00:00:54,026 --> 0:00:55,856
达到最优非常重要

17
00:00:56,386 --> 0:00:57,236
我们会讲到

18
00:00:57,236 --> 0:00:58,806
可以帮助你优化

19
00:00:58,806 --> 0:00:59,896
网络性能的一些技术

20
00:01:00,936 --> 0:01:05,296
也会讲到一些有用的提示和方法

21
00:01:05,716 --> 0:01:07,656
来指导你如何最大程度地利用

22
00:01:07,696 --> 0:01:10,176
Apple 的 API 以及关于

23
00:01:10,176 --> 0:01:12,346
即将到来的新技术的一些信息

24
00:01:12,346 --> 0:01:14,716
然后我的同事

25
00:01:14,716 --> 0:01:16,556
Jiten 将会更详细地

26
00:01:16,556 --> 0:01:18,106
讲解 URLSession

27
00:01:21,066 --> 0:01:23,956
我们先从互联网的

28
00:01:23,956 --> 0:01:24,796
近况说起

29
00:01:25,416 --> 0:01:27,666
今年早些时候

30
00:01:27,666 --> 0:01:30,476
使用互联网的人数

31
00:01:30,476 --> 0:01:30,966
达到了 40 亿

32
00:01:31,256 --> 0:01:33,626
超过了世界人口的一半

33
00:01:34,166 --> 0:01:35,876
我们早已习惯了

34
00:01:35,876 --> 0:01:36,846
互联网使用人数的不断翻倍

35
00:01:37,696 --> 0:01:39,286
而当已经超过一半时

36
00:01:39,776 --> 0:01:40,606
显然互联网使用人数

37
00:01:40,606 --> 0:01:42,766
不可能继续翻倍 所以

38
00:01:43,096 --> 0:01:45,316
互联网使用人数增长的速度在减缓

39
00:01:45,316 --> 0:01:46,306
但并不意味着

40
00:01:46,396 --> 0:01:47,576
互联网的发展会减缓

41
00:01:48,426 --> 0:01:49,626
在机器对机器通讯

42
00:01:49,626 --> 0:01:50,426
物联网以及

43
00:01:50,426 --> 0:01:51,996
智能家庭方面

44
00:01:51,996 --> 0:01:53,536
仍然有很高的增长率

45
00:01:54,256 --> 0:01:55,546
另外 在一些地方 例如印度和中国

46
00:01:55,546 --> 0:01:57,046
仍然有很高的增长率

47
00:01:58,276 --> 0:01:59,826
并且仍然有很多人

48
00:01:59,826 --> 0:02:01,256
从未拥有过一台桌面计算机

49
00:01:59,826 --> 0:02:01,256
从未拥有过一台桌面计算机

50
00:02:01,296 --> 0:02:03,646
甚至未来也不会拥有

51
00:02:03,646 --> 0:02:04,596
自己的桌面计算机

52
00:02:05,016 --> 0:02:06,926
他们主要的计算

53
00:02:06,926 --> 0:02:08,675
和通讯设备

54
00:02:08,675 --> 0:02:09,356
是他们的智能手机

55
00:02:09,895 --> 0:02:12,356
而这些智能手机中

56
00:02:12,396 --> 0:02:14,166
很多都仍在使用 2G 网络

57
00:02:15,066 --> 0:02:17,486
我相信这间屋子里的绝大多数

58
00:02:17,486 --> 0:02:20,166
都足够幸运

59
00:02:20,166 --> 0:02:21,916
居住的地方 工作的地方

60
00:02:21,916 --> 0:02:23,406
以及开发我们的 App 的地方

61
00:02:23,406 --> 0:02:24,946
都有快速的 LTE 网络

62
00:02:25,396 --> 0:02:27,266
而这可能会成为一个短板

63
00:02:27,736 --> 0:02:31,076
因为如果你开发 App 时

64
00:02:31,076 --> 0:02:33,896
考虑的是它在 LTE 下运行良好

65
00:02:33,896 --> 0:02:35,996
它可能在 2G 下表现得非常糟糕

66
00:02:36,916 --> 0:02:37,956
在世界的另一个角落

67
00:02:37,956 --> 0:02:39,106
你的某个竞争对手

68
00:02:39,106 --> 0:02:40,476
开发的 App 在 2G 下运行良好

69
00:02:40,476 --> 0:02:43,366
那么在 LTE 下会表现得更为出色

70
00:02:43,976 --> 0:02:46,436
所以我们有了一个工具

71
00:02:46,436 --> 0:02:48,946
可以让所有人都模拟

72
00:02:48,946 --> 0:02:50,766
那些较慢网络的

73
00:02:50,766 --> 0:02:52,476
一些特性

74
00:02:52,476 --> 0:02:53,056
这就是 Network Link Conditioner

75
00:02:54,016 --> 0:02:55,266
从开发 App 的第一刻起

76
00:02:55,446 --> 0:02:57,026
就应该运行

77
00:02:57,026 --> 0:02:57,946
Network Link Conditioner

78
00:02:58,206 --> 0:02:59,476
不要认为你可以

79
00:02:59,476 --> 0:03:02,046
到最后再来改善性能

80
00:02:59,476 --> 0:03:02,046
到最后再来改善性能

81
00:03:02,046 --> 0:03:02,716
因为到时就来不及了

82
00:03:03,456 --> 0:03:05,176
请一定一直记得

83
00:03:05,176 --> 0:03:06,646
使用 Network Link Conditioner

84
00:03:06,646 --> 0:03:08,266
来运行和测试你的 App

85
00:03:08,266 --> 0:03:10,266
这样的话 如果程序中有个错误

86
00:03:10,266 --> 0:03:11,276
带来了糟糕的性能问题

87
00:03:11,276 --> 0:03:12,726
你马上就能发现它

88
00:03:12,726 --> 0:03:14,186
并且立刻修复

89
00:03:15,476 --> 0:03:16,986
使用像 Wireshark 和

90
00:03:16,986 --> 0:03:19,036
tcptrace 的工具

91
00:03:19,036 --> 0:03:20,336
来弄清楚你的 App 的网络性能

92
00:03:20,906 --> 0:03:21,746
这很像是用

93
00:03:21,746 --> 0:03:23,046
Instruments 来查看

94
00:03:23,046 --> 0:03:24,166
内存和 CPU 的占用情况

95
00:03:25,056 --> 0:03:26,866
如果你还没用过 tcptrace

96
00:03:26,866 --> 0:03:28,186
这个工具可以

97
00:03:28,186 --> 0:03:29,976
生成像这样的图表

98
00:03:29,976 --> 0:03:31,476
让你一眼就看清楚

99
00:03:31,476 --> 0:03:32,486
网络上进行中的事

100
00:03:33,356 --> 0:03:34,566
如果你想要了解更多

101
00:03:34,566 --> 0:03:38,546
请查看三年前的视频

102
00:03:39,456 --> 0:03:41,566
IPv6 的使用率持续上升

103
00:03:42,426 --> 0:03:43,816
为什么这很重要

104
00:03:43,986 --> 0:03:46,006
这是因为 IPv6

105
00:03:46,356 --> 0:03:47,946
比 IPv4 的性能

106
00:03:47,946 --> 0:03:48,846
表现更好

107
00:03:48,906 --> 0:03:50,286
所以如果你在意性能

108
00:03:50,286 --> 0:03:51,796
你应该确保

109
00:03:51,796 --> 0:03:53,596
不仅你的 App

110
00:03:53,596 --> 0:03:55,236
还有你的 App 使用的网络服务

111
00:03:55,426 --> 0:03:56,836
支持原生 IPv6

112
00:03:57,716 --> 0:03:59,156
在这方面

113
00:03:59,156 --> 0:04:01,086
有些地方的情况比其他地方好一些

114
00:03:59,156 --> 0:04:01,086
有些地方的情况比其他地方好一些

115
00:04:01,906 --> 0:04:04,006
在美国 已经有 87% 的

116
00:04:04,006 --> 0:04:05,996
移动运营商支持 IPv6

117
00:04:06,036 --> 0:04:08,456
其他地方 例如印度

118
00:04:08,456 --> 0:04:09,546
也非常好

119
00:04:10,256 --> 0:04:11,696
那么我们现在来看看印度

120
00:04:12,596 --> 0:04:14,596
这里是今年早些时候

121
00:04:14,596 --> 0:04:15,766
Apple 的网络团队

122
00:04:15,766 --> 0:04:18,326
收集到的一些数据

123
00:04:18,466 --> 0:04:21,086
有关印度蜂窝移动网络下

124
00:04:21,516 --> 0:04:24,566
TCP 网络连接建立时长

125
00:04:25,256 --> 0:04:26,606
以及持续的往返延迟

126
00:04:27,266 --> 0:04:28,756
蓝色的线是 IPv6

127
00:04:29,486 --> 0:04:31,416
举例来说 如果我们

128
00:04:31,416 --> 0:04:33,946
观察 75% 这里

129
00:04:34,226 --> 0:04:39,316
可以看出 IPv6 上 75% 的 TCP 连接

130
00:04:39,376 --> 0:04:41,746
在 150 毫秒内建立完成

131
00:04:42,446 --> 0:04:44,576
而相应的

132
00:04:44,576 --> 0:04:46,796
在 IPv4 上则超过 325 毫秒

133
00:04:47,336 --> 0:04:48,636
比 IPv6 慢了不止一倍

134
00:04:49,036 --> 0:04:50,976
因此如果你想要为你的用户

135
00:04:50,976 --> 0:04:53,526
提供响应速度快的 App

136
00:04:53,526 --> 0:04:55,166
请采用 IPv6

137
00:04:56,926 --> 0:04:58,516
另一项通过

138
00:04:58,566 --> 0:05:00,526
降低丢包率和重发率

139
00:04:58,566 --> 0:05:00,526
降低丢包率和重发率

140
00:05:00,526 --> 0:05:02,286
来提升性能的技术

141
00:05:02,286 --> 0:05:03,266
是 Explicit Congestion

142
00:05:03,266 --> 0:05:04,026
Notification

143
00:05:04,836 --> 0:05:06,056
我们在 macOS 和 iOS 上

144
00:05:06,056 --> 0:05:08,026
默认启用这项技术

145
00:05:08,026 --> 0:05:09,496
已经有些年了

146
00:05:09,496 --> 0:05:10,306
因此想要利用这项技术

147
00:05:10,306 --> 0:05:12,376
你不需要在你的 App 中

148
00:05:12,376 --> 0:05:12,726
进行额外操作

149
00:05:13,706 --> 0:05:16,506
不过要确保你的服务支持 ECN

150
00:05:17,296 --> 0:05:20,026
我们调研了 Alexa

151
00:05:20,026 --> 0:05:22,076
前一百万网站

152
00:05:22,076 --> 0:05:24,276
发现截止上月

153
00:05:24,276 --> 0:05:25,316
前一百万服务中有 77% 已经

154
00:05:25,316 --> 0:05:27,226
支持了 ECN

155
00:05:27,226 --> 0:05:28,666
相比几年前

156
00:05:28,666 --> 0:05:32,206
这是个很大的进步

157
00:05:32,936 --> 0:05:34,936
另一项帮助你提升

158
00:05:34,936 --> 0:05:36,506
连接的性能和

159
00:05:36,506 --> 0:05:37,766
弹性的技术

160
00:05:37,766 --> 0:05:39,016
是多路 TCP

161
00:05:39,796 --> 0:05:41,336
用户常常可能在

162
00:05:41,336 --> 0:05:43,426
办公室的 Wi-Fi 下发起连接

163
00:05:43,426 --> 0:05:45,676
然后走出办公室

164
00:05:46,436 --> 0:05:47,896
就丢失了 Wi-Fi 信号

165
00:05:47,896 --> 0:05:49,516
如果是传统 TCP

166
00:05:49,516 --> 0:05:50,666
连接就断了

167
00:05:50,666 --> 0:05:51,506
必须重新连接

168
00:05:51,506 --> 0:05:52,516
重新开始发起

169
00:05:53,176 --> 0:05:55,356
多路 TCP 以包为单位

170
00:05:55,356 --> 0:05:56,716
做数据包的路由选择

171
00:05:56,716 --> 0:05:58,636
而不是以连接为单位

172
00:05:59,236 --> 0:06:01,976
所以可以即时把连接

173
00:05:59,236 --> 0:06:01,976
所以可以即时把连接

174
00:06:01,976 --> 0:06:03,846
转向另一个接口

175
00:06:05,876 --> 0:06:08,416
去年我们讨论了如何

176
00:06:08,416 --> 0:06:09,876
在你的 App 中启用这项技术

177
00:06:10,016 --> 0:06:11,706
当然 请和你的

178
00:06:11,706 --> 0:06:13,076
服务器运营商

179
00:06:13,076 --> 0:06:14,976
确认你的服务器也支持多路

180
00:06:16,146 --> 0:06:18,246
我们最近调查了

181
00:06:18,246 --> 0:06:20,196
全世界与 Apple 合作的

182
00:06:20,196 --> 0:06:22,036
移动运营商

183
00:06:22,036 --> 0:06:28,226
其中 78% 支持多路 TCP

184
00:06:28,696 --> 0:06:30,496
只有 22% 的运营商

185
00:06:30,496 --> 0:06:32,016
仍限制多路连接

186
00:06:32,536 --> 0:06:37,456
TCP Fast Open 是一项

187
00:06:37,706 --> 0:06:39,536
可以让你避免通常情况下

188
00:06:39,536 --> 0:06:41,446
TCP 连接建立时的

189
00:06:41,446 --> 0:06:42,426
往返延迟的技术

190
00:06:42,906 --> 0:06:46,216
TCP Fast Open 可以让你

191
00:06:46,216 --> 0:06:48,766
把初始数据放在

192
00:06:48,766 --> 0:06:50,706
连接建立数据包里

193
00:06:52,546 --> 0:06:53,856
你可以在三年前的

194
00:06:53,856 --> 0:06:55,976
视频中找到更多相关信息

195
00:06:56,476 --> 0:06:57,856
也请和你的

196
00:06:57,856 --> 0:06:59,286
服务器运营商

197
00:06:59,286 --> 0:07:03,256
确认支持 TCP Fast Open

198
00:06:59,286 --> 0:07:03,256
确认支持 TCP Fast Open

199
00:07:03,476 --> 0:07:05,586
现在我们来说讲一些新消息

200
00:07:06,216 --> 0:07:09,176
你们中很多人应该

201
00:07:09,176 --> 0:07:10,776
听说过一个技术

202
00:07:10,836 --> 0:07:11,106
叫做 QUIC

203
00:07:11,986 --> 0:07:13,326
这是一种新的传输协议

204
00:07:13,326 --> 0:07:15,856
也是近 30 年来

205
00:07:15,856 --> 0:07:17,516
第一个真正意义上的

206
00:07:17,516 --> 0:07:19,246
可能取代 TCP 的候选者

207
00:07:19,796 --> 0:07:21,576
它起源于 Google 的一些工程师

208
00:07:21,676 --> 0:07:23,086
做的一项实验

209
00:07:23,566 --> 0:07:25,366
这项实验很成功

210
00:07:25,366 --> 0:07:29,876
现在已成为 IETF

211
00:07:29,876 --> 0:07:30,766
为了标准化的一项工作

212
00:07:31,966 --> 0:07:33,256
Apple 的工程师

213
00:07:33,256 --> 0:07:34,446
也参与其中

214
00:07:34,446 --> 0:07:35,816
实际上 此时此刻我们的工程师

215
00:07:35,816 --> 0:07:37,786
就在瑞典的

216
00:07:37,786 --> 0:07:38,596
QUIC 会议上

217
00:07:39,996 --> 0:07:42,286
不过这项技术还没有完全准备好

218
00:07:42,286 --> 0:07:43,506
标准尚未完成

219
00:07:44,016 --> 0:07:45,416
但是 Apple 正在为之努力

220
00:07:45,416 --> 0:07:47,146
一旦准备好了

221
00:07:47,146 --> 0:07:48,306
你会看到 Apple 有 API

222
00:07:48,436 --> 0:07:50,916
来支持这项技术

223
00:07:51,266 --> 0:07:52,256
继续有关性能的话题

224
00:07:52,306 --> 0:07:55,406
我们观察到了一些

225
00:07:55,406 --> 0:07:56,656
非常常见的行为

226
00:07:57,356 --> 0:07:59,336
相当多的网站和

227
00:07:59,336 --> 0:08:01,036
互联网服务 使用

228
00:07:59,336 --> 0:08:01,036
互联网服务 使用

229
00:08:01,036 --> 0:08:04,266
生命周期短的 DNS 记录

230
00:08:04,666 --> 0:08:06,596
他们之所以这样做

231
00:08:06,596 --> 0:08:08,736
是因为如果一个数据中心出了故障

232
00:08:08,736 --> 0:08:10,496
他们希望能够更新 DNS

233
00:08:10,496 --> 0:08:12,686
从而迅速地把流量导向

234
00:08:12,686 --> 0:08:13,666
另一个不同的数据中心

235
00:08:15,266 --> 0:08:16,636
这个方法的问题在于

236
00:08:17,076 --> 0:08:19,166
你在为一个

237
00:08:19,166 --> 0:08:21,506
几乎从未发生过的情况牺牲性能

238
00:08:21,596 --> 0:08:24,186
数据中心极少出故障

239
00:08:25,066 --> 0:08:27,316
这意味着

240
00:08:27,316 --> 0:08:29,276
每当一个 DNS 地址记录过期

241
00:08:29,276 --> 0:08:31,096
你的客户端不得不

242
00:08:31,096 --> 0:08:32,736
再用一个往返延迟

243
00:08:33,046 --> 0:08:35,496
去等候来自 DNS 服务器的回应

244
00:08:35,496 --> 0:08:37,306
而这个回应

245
00:08:37,306 --> 0:08:39,155
和它上次获知的一模一样

246
00:08:39,756 --> 0:08:42,736
所以 考虑到这点

247
00:08:42,736 --> 0:08:44,826
我们做了一个

248
00:08:44,826 --> 0:08:45,216
可以实现的优化

249
00:08:45,866 --> 0:08:47,856
如果你传了参与这种新方式的标记

250
00:08:47,856 --> 0:08:50,866
那么当你发起 DNS 请求时

251
00:08:50,866 --> 0:08:52,846
如果我们的缓存中

252
00:08:52,846 --> 0:08:54,446
有一个此前过期的回应

253
00:08:54,446 --> 0:08:56,956
我们会把它立即给你

254
00:08:57,056 --> 0:08:59,286
与此同时

255
00:08:59,286 --> 0:09:00,876
进行原本就会做的

256
00:08:59,286 --> 0:09:00,876
进行原本就会做的

257
00:09:00,876 --> 0:09:03,476
普通的 DNS 请求

258
00:09:04,576 --> 0:09:05,796
如果请求到相同的结果

259
00:09:05,796 --> 0:09:07,636
我们预计大多数时候都是如此

260
00:09:07,636 --> 0:09:09,586
那么一切正常

261
00:09:09,586 --> 0:09:12,516
你就省了一次往返时长

262
00:09:12,516 --> 0:09:13,766
从而更快速地建立连接

263
00:09:14,426 --> 0:09:15,856
如果请求到一个不同的地址

264
00:09:15,856 --> 0:09:18,156
我们就会给你的

265
00:09:18,156 --> 0:09:19,356
客户端发另一个异步的通知

266
00:09:19,356 --> 0:09:21,416
来告诉它

267
00:09:21,416 --> 0:09:22,666
这里有一个新的地址

268
00:09:22,696 --> 0:09:23,926
也需要进行尝试

269
00:09:24,706 --> 0:09:26,096
想要利用这个特性

270
00:09:26,096 --> 0:09:27,446
你需要与 Happy Eyeballs 算法

271
00:09:27,446 --> 0:09:28,946
一起使用

272
00:09:29,436 --> 0:09:30,996
这意味着你需要

273
00:09:30,996 --> 0:09:32,126
同期进行多个连接

274
00:09:32,996 --> 0:09:33,976
你需要尝试 IPv4 IPv6

275
00:09:34,006 --> 0:09:36,886
多个地址

276
00:09:36,886 --> 0:09:37,756
多个接口

277
00:09:38,566 --> 0:09:39,846
这听起来工作量很大

278
00:09:39,846 --> 0:09:41,356
也很难正确完成

279
00:09:41,516 --> 0:09:42,606
确实如此

280
00:09:42,606 --> 0:09:43,496
确实有很多工作要做

281
00:09:44,096 --> 0:09:46,246
中场休息后回来

282
00:09:46,246 --> 0:09:48,686
我们会告诉你一些新的 API

283
00:09:48,966 --> 0:09:50,406
可以让你在无需做

284
00:09:50,406 --> 0:09:52,346
所有麻烦的工作的情况下 利用此特性

285
00:09:54,526 --> 0:09:56,056
现在我们看一些指导信息

286
00:09:56,726 --> 0:09:58,836
我们见到

287
00:09:59,246 --> 0:10:02,296
很多开发者

288
00:09:59,246 --> 0:10:02,296
很多开发者

289
00:10:02,446 --> 0:10:04,426
都把 SCNetworkReachability

290
00:10:04,556 --> 0:10:05,326
用作预检查

291
00:10:06,396 --> 0:10:07,686
他们想要预测将来

292
00:10:07,916 --> 0:10:09,076
他们想知道

293
00:10:09,076 --> 0:10:10,936
下一个要做的网络操作

294
00:10:10,936 --> 0:10:12,096
会成功还是会失败

295
00:10:12,626 --> 0:10:14,956
然后 不幸的是

296
00:10:14,956 --> 0:10:16,116
预测将来总是

297
00:10:16,116 --> 0:10:16,666
一件困难的事情

298
00:10:17,216 --> 0:10:18,786
现在你可能连着网

299
00:10:19,476 --> 0:10:20,966
但是两秒后

300
00:10:21,026 --> 0:10:22,366
用户走出了这栋建筑

301
00:10:22,366 --> 0:10:24,496
就没有 Wi-Fi 信号了

302
00:10:24,886 --> 0:10:27,656
所以并没有一种方式

303
00:10:27,656 --> 0:10:29,566
可以保证下一个操作能成功

304
00:10:30,486 --> 0:10:32,356
我们常常会看到这样的情况

305
00:10:32,356 --> 0:10:34,326
他们检查预检成功

306
00:10:34,406 --> 0:10:35,686
于是他们去做 结果失败了

307
00:10:36,126 --> 0:10:37,716
他们又回来重新检查

308
00:10:38,526 --> 0:10:41,016
这也有很多工作量

309
00:10:41,016 --> 0:10:42,546
很多临界情况

310
00:10:42,546 --> 0:10:44,026
很多麻烦的事情要处理

311
00:10:44,606 --> 0:10:46,426
比如使用代理的网络

312
00:10:47,606 --> 0:10:48,776
我们可以帮你搞定

313
00:10:50,506 --> 0:10:53,746
只需要使用

314
00:10:53,746 --> 0:10:56,006
waitsForConnectivity 选项来

315
00:10:56,006 --> 0:10:58,616
建立连接就行

316
00:10:58,816 --> 0:11:00,326
你可以从去年的视频中

317
00:10:58,816 --> 0:11:00,326
你可以从去年的视频中

318
00:11:00,326 --> 0:11:01,526
了解更多

319
00:11:01,966 --> 0:11:03,956
意思是说 如果你需要

320
00:11:03,956 --> 0:11:05,566
一个连接 你告诉系统

321
00:11:05,566 --> 0:11:06,566
说你需要一个连接

322
00:11:06,806 --> 0:11:09,006
如果可以 现在就需要 如果不行 就之后

323
00:11:09,326 --> 0:11:10,976
如果设备当前在飞行模式

324
00:11:10,976 --> 0:11:12,396
那么当它关闭飞行模式时

325
00:11:12,396 --> 0:11:14,216
你的连接就会成功

326
00:11:14,686 --> 0:11:16,266
这比你自己

327
00:11:16,266 --> 0:11:17,866
创建一个重试循环 要简单得多

328
00:11:18,876 --> 0:11:20,466
我们发现开发者会遇到

329
00:11:20,466 --> 0:11:22,456
这样一种情况

330
00:11:22,456 --> 0:11:24,516
如果你需要让用户

331
00:11:24,516 --> 0:11:27,876
在一个表格里提供很多信息

332
00:11:27,876 --> 0:11:29,146
而你又有足够的理由相信

333
00:11:29,146 --> 0:11:31,186
接下来用户会提交失败

334
00:11:31,186 --> 0:11:33,096
所以不想浪费用户的时间

335
00:11:34,126 --> 0:11:35,736
如果你在意这种情况

336
00:11:35,736 --> 0:11:37,366
请在中场休息后回来

337
00:11:37,606 --> 0:11:39,076
因为我们有一种更好的

338
00:11:39,076 --> 0:11:43,166
处理这种问题的办法

339
00:11:43,356 --> 0:11:46,286
一直以来 安全问题都很重要

340
00:11:47,316 --> 0:11:49,696
TLS 1.2 已经十年了 

341
00:11:49,736 --> 0:11:52,256
互联网现在准备转向

342
00:11:52,256 --> 0:11:54,646
它的继承者 TLS 1.3

343
00:11:55,286 --> 0:11:57,566
它有很多提升安全性的特性

344
00:11:58,146 --> 0:12:00,066
类似 TCP Fast Open

345
00:11:58,146 --> 0:12:00,066
类似 TCP Fast Open

346
00:12:00,106 --> 0:12:02,576
会减少连接建立时间

347
00:12:03,496 --> 0:12:05,536
这项标准已经完成

348
00:12:05,716 --> 0:12:07,506
今年早些时候

349
00:12:07,506 --> 0:12:09,286
互联网工程指导小组

350
00:12:09,286 --> 0:12:10,616
批准发布

351
00:12:10,906 --> 0:12:11,726
最终草案

352
00:12:12,586 --> 0:12:14,766
我们在等待

353
00:12:14,766 --> 0:12:16,366
RFC 编辑者

354
00:12:16,366 --> 0:12:17,406
公布正式文档

355
00:12:17,836 --> 0:12:22,246
到那时 我们会默认打开 TLS 1.3

356
00:12:23,326 --> 0:12:25,026
目前在你的配置文件里

357
00:12:25,026 --> 0:12:25,976
还是默认关闭的

358
00:12:27,166 --> 0:12:28,426
你可以按照这里的说明

359
00:12:28,426 --> 0:12:32,636
在你 iOS 和 macOS

360
00:12:32,896 --> 0:12:35,726
App 中启用 TLS 1.3

361
00:12:36,016 --> 0:12:37,386
并且我们希望你现在就启用

362
00:12:37,386 --> 0:12:39,696
因为这样一来 今年晚些时候

363
00:12:39,696 --> 0:12:41,926
当 TLS 1.3 默认打开时

364
00:12:41,926 --> 0:12:45,936
你不会有服务不兼容的问题

365
00:12:46,236 --> 0:12:48,346
所以现在就测试好

366
00:12:48,346 --> 0:12:49,896
确保当今年晚些时候

367
00:12:50,166 --> 0:12:51,946
切换的时候一切正常

368
00:12:56,046 --> 0:12:57,446
有关安全的另一个

369
00:12:57,446 --> 0:12:58,956
新要素是

370
00:12:58,956 --> 0:12:59,676
证书透明度

371
00:12:59,676 --> 0:13:02,116
你可能听说过

372
00:12:59,676 --> 0:13:02,116
你可能听说过

373
00:13:02,366 --> 0:13:05,666
有时证书颁发机构

374
00:13:06,036 --> 0:13:07,026
可能是恶意

375
00:13:07,026 --> 0:13:08,986
也可能是无能

376
00:13:08,986 --> 0:13:10,646
会给不符合要求的机构

377
00:13:10,646 --> 0:13:11,196
颁发证书

378
00:13:12,556 --> 0:13:14,046
解决这个问题的方法是

379
00:13:14,046 --> 0:13:16,766
一种叫做 证书透明日志的东西

380
00:13:17,556 --> 0:13:19,426
每个合法的证书颁发机构

381
00:13:19,426 --> 0:13:22,326
每颁发一个证书

382
00:13:22,926 --> 0:13:24,766
现在都需要

383
00:13:24,766 --> 0:13:25,516
公开声明

384
00:13:25,596 --> 0:13:27,076
这些公开声明会记录在公共日志中

385
00:13:27,076 --> 0:13:29,296
供任何人检查

386
00:13:30,236 --> 0:13:31,836
这意味着如果

387
00:13:32,406 --> 0:13:34,436
资质较差的证书颁发机构

388
00:13:34,436 --> 0:13:36,596
颁发了一张假证书

389
00:13:36,596 --> 0:13:37,786
一旦公布

390
00:13:37,786 --> 0:13:40,656
立刻会被发现

391
00:13:40,656 --> 0:13:41,856
如果它们不公布的话

392
00:13:42,186 --> 0:13:43,486
会被客户端发现

393
00:13:44,966 --> 0:13:46,596
这也许是你

394
00:13:46,596 --> 0:13:47,966
很熟悉的一种办法

395
00:13:48,436 --> 0:13:50,356
这里新增的实体是日志

396
00:13:51,186 --> 0:13:52,736
当一个证书颁发机构

397
00:13:52,936 --> 0:13:54,786
给一个服务器颁发证书

398
00:13:54,786 --> 0:13:57,616
它也会在日志上记录

399
00:13:57,616 --> 0:13:59,896
然后日志给服务器

400
00:13:59,896 --> 0:14:01,776
一张签名的宣誓书

401
00:13:59,896 --> 0:14:01,776
一张签名的宣誓书

402
00:14:02,146 --> 0:14:03,656
证明它的证书已经

403
00:14:03,656 --> 0:14:04,646
被公开记录

404
00:14:04,926 --> 0:14:06,076
然后当客户端连接时

405
00:14:06,166 --> 0:14:08,066
服务器可以把这些信息

406
00:14:08,066 --> 0:14:09,096
提供给客户端

407
00:14:09,096 --> 0:14:11,046
客户端就能够确认

408
00:14:11,046 --> 0:14:12,256
这不仅是签名证书

409
00:14:12,256 --> 0:14:14,236
更是一个被公开记录了的

410
00:14:14,236 --> 0:14:15,786
签名证书

411
00:14:16,916 --> 0:14:18,156
现在假设有一个

412
00:14:18,156 --> 0:14:20,226
资质较差的证书颁发机构

413
00:14:20,326 --> 0:14:23,836
不公开它颁发的异常证书

414
00:14:24,726 --> 0:14:26,426
客户端就会拒绝它

415
00:14:26,426 --> 0:14:27,916
因为它没有宣誓书

416
00:14:27,916 --> 0:14:30,386
能够证明

417
00:14:30,476 --> 0:14:31,826
这张证书存在于公开记录

418
00:14:33,006 --> 0:14:34,286
今年晚些时候起

419
00:14:34,596 --> 0:14:35,896
我们会强制实施这个机制

420
00:14:37,456 --> 0:14:39,806
所有新颁发的 TLS

421
00:14:39,806 --> 0:14:41,726
证书必须包含

422
00:14:41,726 --> 0:14:44,096
确认他们被公开记录的证明

423
00:14:44,486 --> 0:14:46,036
那么如果他们没有被记录

424
00:14:46,036 --> 0:14:47,056
客户端就会拒绝它

425
00:14:47,536 --> 0:14:49,686
你的 App 不需要做任何改动

426
00:14:49,686 --> 0:14:51,926
但是如果你的

427
00:14:51,926 --> 0:14:53,006
服务器有专门的证书

428
00:14:53,006 --> 0:14:56,686
确保你的证书颁发机构

429
00:14:56,686 --> 0:14:58,186
在公开的证书透明日志中

430
00:14:58,306 --> 0:14:59,906
留下了记录

431
00:15:00,486 --> 0:15:03,686
现在 针对硬件开发者

432
00:15:04,246 --> 0:15:05,286
我们有一些新消息

433
00:15:06,286 --> 0:15:08,396
Bonjour Conformance Test 工具

434
00:15:08,396 --> 0:15:10,776
可以让你确认

435
00:15:10,776 --> 0:15:12,386
你的硬件设备

436
00:15:12,386 --> 0:15:13,376
是否正确使用 Bonjour

437
00:15:14,466 --> 0:15:15,946
如果你想要

438
00:15:15,946 --> 0:15:17,086
在你的包装上

439
00:15:17,086 --> 0:15:18,796
使用 Bonjour 商标的名字和标识

440
00:15:18,796 --> 0:15:19,376
你需要运行这个测试

441
00:15:20,256 --> 0:15:21,796
如果你想把 Bonjour for Windows 安装包

442
00:15:21,796 --> 0:15:23,826
与 Windows App 捆绑

443
00:15:23,866 --> 0:15:27,086
也需要运行这个测试

444
00:15:27,696 --> 0:15:28,896
如果你想在包装上使用

445
00:15:28,896 --> 0:15:30,736
隔空打印 隔空播放 CarPlay 车载

446
00:15:30,736 --> 0:15:32,506
HomeKit 标识

447
00:15:33,046 --> 0:15:34,356
通过 Bonjour Conformance Test

448
00:15:34,356 --> 0:15:36,136
是标识授权过程的

449
00:15:36,136 --> 0:15:37,976
一部分 因为

450
00:15:37,976 --> 0:15:39,916
可靠的 Bonjour 是这些产品的

451
00:15:39,916 --> 0:15:41,006
重要组成部分

452
00:15:41,926 --> 0:15:44,056
但更重要的是

453
00:15:44,056 --> 0:15:44,966
运行 Bonjour Conformance Test 的价值

454
00:15:44,966 --> 0:15:46,996
在于它帮你

455
00:15:46,996 --> 0:15:48,136
提升了产品质量

456
00:15:48,136 --> 0:15:50,096
让产品更可靠

457
00:15:50,096 --> 0:15:53,996
从而让你的顾客满意

458
00:15:53,996 --> 0:15:55,536
而不会因为

459
00:15:55,536 --> 0:15:57,756
无法使用你的产品而退货

460
00:15:58,226 --> 0:16:00,196
这正是你的顾客想要的

461
00:15:58,226 --> 0:16:00,196
这正是你的顾客想要的

462
00:16:00,296 --> 0:16:01,066
也是你想要的

463
00:16:01,146 --> 0:16:01,996
更是我们想要的

464
00:16:02,046 --> 0:16:04,426
我们想让顾客开心

465
00:16:04,426 --> 0:16:05,606
与可靠的产品

466
00:16:05,606 --> 0:16:06,436
度过美好的时光

467
00:16:06,436 --> 0:16:11,556
现在我想讲一下对 API 的选择

468
00:16:12,596 --> 0:16:15,776
30 年前我们有了 BSD Sockets

469
00:16:16,396 --> 0:16:18,616
30 年前它是个很棒的 API

470
00:16:19,046 --> 0:16:21,616
但是 30 年前我们口袋里

471
00:16:22,426 --> 0:16:24,476
没有移动计算机

472
00:16:24,546 --> 0:16:26,216
也没有无线网络

473
00:16:26,216 --> 0:16:29,126
没有 IPv6

474
00:16:29,326 --> 0:16:31,026
很多计算机

475
00:16:31,026 --> 0:16:32,746
只有一个网络接口

476
00:16:32,896 --> 0:16:34,936
如果那时候你的电脑上有一个以太网接口

477
00:16:34,936 --> 0:16:36,716
那一定是台很不错的电脑

478
00:16:37,376 --> 0:16:40,236
现在世界上有 40 亿人

479
00:16:40,236 --> 0:16:42,806
拥有多宿主的 IPv6 的

480
00:16:43,136 --> 0:16:46,226
无线的 内置电池的计算设备

481
00:16:46,226 --> 0:16:47,456
具备电池管理功能

482
00:16:47,456 --> 0:16:48,116
可以休眠以节省电量

483
00:16:48,496 --> 0:16:49,716
这个世界变得

484
00:16:49,716 --> 0:16:50,376
复杂了许多

485
00:16:52,056 --> 0:16:53,246
你们中很多人可能

486
00:16:53,246 --> 0:16:55,326
正在使用一些基于

487
00:16:55,376 --> 0:16:57,016
Sockets 的第三方库

488
00:16:57,686 --> 0:16:59,996
而更多人可能在用

489
00:16:59,996 --> 0:17:00,816
URLSession

490
00:16:59,996 --> 0:17:00,816
URLSession

491
00:17:01,306 --> 0:17:03,006
而你可能会以为

492
00:17:03,006 --> 0:17:05,626
URLSession 也只是在

493
00:17:05,626 --> 0:17:06,556
Sockets 外面包了一层

494
00:17:07,906 --> 0:17:09,526
好吧 并不太一样

495
00:17:11,006 --> 0:17:13,046
URLSession 实际上建立在

496
00:17:13,326 --> 0:17:15,445
Apple 的用户空间

497
00:17:15,656 --> 0:17:17,856
网络代码 Network.framework 上的

498
00:17:18,346 --> 0:17:21,306
从现在开始 在 iOS 12 上

499
00:17:21,306 --> 0:17:23,976
我们会把 URLSession 使用的 API

500
00:17:23,976 --> 0:17:26,056
开放出来 这样你的

501
00:17:26,056 --> 0:17:29,316
App 可以直接用这个 API

502
00:17:29,486 --> 0:17:31,986
建立 TCP 连接

503
00:17:31,986 --> 0:17:33,266
或者做其他合理的事情

504
00:17:33,526 --> 0:17:35,266
如果你在使用 URL

505
00:17:35,266 --> 0:17:37,356
和 HTTP GET

506
00:17:37,356 --> 0:17:38,716
URLSession 仍然是 API 中的不二选择

507
00:17:39,056 --> 0:17:41,116
而对于 URLSession 做不了的事情

508
00:17:41,116 --> 0:17:43,316
我们现在开放了

509
00:17:43,316 --> 0:17:45,766
Network.framework

510
00:17:45,766 --> 0:17:46,896
你的 App 可以直接使用

511
00:17:47,876 --> 0:17:49,816
并且如果你是某个

512
00:17:49,816 --> 0:17:50,896
基于 BSD Sockets 的

513
00:17:50,896 --> 0:17:54,156
第三方库的开发者

514
00:17:54,156 --> 0:17:56,606
希望你可以

515
00:17:56,606 --> 0:17:59,216
关注 Network.framework 的 API

516
00:17:59,596 --> 0:18:02,016
把你的库转移到

517
00:17:59,596 --> 0:18:02,016
把你的库转移到

518
00:18:02,016 --> 0:18:04,326
基于这些优化的高性能 API 上

519
00:18:04,926 --> 0:18:07,886
然后告诉我们效果如何

520
00:18:08,866 --> 0:18:11,086
总结一下

521
00:18:11,086 --> 0:18:13,786
我们在此强烈建议

522
00:18:14,076 --> 0:18:18,296
现在是 2018 年了 应该避免使用 BSD Sockets

523
00:18:18,686 --> 0:18:20,756
不要使用那些仅仅在

524
00:18:20,756 --> 0:18:22,706
BSD Sockets 外面

525
00:18:22,706 --> 0:18:23,316
包了一层的库

526
00:18:23,766 --> 0:18:25,146
而如果你是使用这些

527
00:18:25,146 --> 0:18:27,146
老旧的 API 的库的作者

528
00:18:27,146 --> 0:18:30,116
请考虑一下切换过来

529
00:18:30,116 --> 0:18:32,056
今天下午或者明天

530
00:18:32,106 --> 0:18:34,106
请来实验室和我们交流

531
00:18:34,236 --> 0:18:36,246
告诉我们如果把你的库转移到

532
00:18:36,246 --> 0:18:37,816
新的 API 上

533
00:18:38,046 --> 0:18:39,076
都需要做什么

534
00:18:40,076 --> 0:18:41,316
说到这里

535
00:18:41,316 --> 0:18:43,106
我想请我的同事 Jiten

536
00:18:43,106 --> 0:18:44,996
来到台上与你们分享

537
00:18:45,166 --> 0:18:46,816
更多关于 URLSession 的细节

538
00:18:47,516 --> 0:18:51,976
[ 掌声 ]

539
00:18:52,476 --> 0:18:53,086
&gt;&gt; 谢谢 Stuart

540
00:18:53,686 --> 0:18:55,176
大家早上好

541
00:18:55,726 --> 0:18:57,416
我叫 Jiten Mehta

542
00:18:57,416 --> 0:18:59,316
我是 CFNetwork 团队的一名工程师

543
00:19:00,266 --> 0:19:01,326
今天我想和你们聊聊

544
00:19:01,326 --> 0:19:02,666
关于你们 App 的

545
00:19:02,666 --> 0:19:03,956
一些网络最佳实践

546
00:19:05,396 --> 0:19:07,076
网络是每个 App

547
00:19:07,076 --> 0:19:08,386
必不可少的一部分

548
00:19:09,346 --> 0:19:10,616
每年你们都会给

549
00:19:10,616 --> 0:19:12,276
你们的 App 增加一些

550
00:19:12,276 --> 0:19:12,986
非常棒的功能

551
00:19:13,406 --> 0:19:14,976
那么今天我会与你们聊聊

552
00:19:15,136 --> 0:19:16,706
一些简单的

553
00:19:16,706 --> 0:19:19,086
有关网络的细节

554
00:19:19,086 --> 0:19:20,236
让你的 App 更好

555
00:19:20,796 --> 0:19:24,836
我们今天计划

556
00:19:24,836 --> 0:19:27,296
讲四类问题

557
00:19:27,296 --> 0:19:29,926
减少延迟 最大化吞吐量

558
00:19:31,036 --> 0:19:33,396
提升响应度

559
00:19:33,396 --> 0:19:34,876
更好地利用

560
00:19:34,876 --> 0:19:35,596
系统资源

561
00:19:36,806 --> 0:19:38,506
在这之前

562
00:19:38,506 --> 0:19:40,386
我们快速回顾一下

563
00:19:40,386 --> 0:19:40,976
你们一直在用的 API URLSession

564
00:19:45,526 --> 0:19:47,956
URLSession 是一个

565
00:19:48,106 --> 0:19:50,306
Apple 的全平台可用的

566
00:19:50,686 --> 0:19:52,976
高级网络 API

567
00:19:54,426 --> 0:19:56,766
URLSession 对 HTTP/2 和 HTTP/1.1

568
00:19:56,766 --> 0:20:00,746
的支持是一流的

569
00:19:56,766 --> 0:20:00,746
的支持是一流的

570
00:20:02,056 --> 0:20:04,136
如果你的 App 不使用 HTTP

571
00:20:04,136 --> 0:20:05,966
我们也支持

572
00:20:06,066 --> 0:20:09,226
URLSessionStreamTask

573
00:20:09,226 --> 0:20:11,056
这个 API 让你确保

574
00:20:11,056 --> 0:20:12,946
你可以在与服务器的 TCP 连接中

575
00:20:13,256 --> 0:20:15,796
建立任意的协议

576
00:20:17,136 --> 0:20:18,656
这是 URLSession

577
00:20:19,716 --> 0:20:20,866
我们来说说第一项

578
00:20:20,866 --> 0:20:23,926
减少延迟

579
00:20:25,296 --> 0:20:26,246
假设你和你的朋友

580
00:20:26,246 --> 0:20:28,096
去一个餐馆

581
00:20:28,226 --> 0:20:29,706
服务员走向你们 

582
00:20:29,706 --> 0:20:31,866
你说 “请给我一杯水可以吗？”

583
00:20:32,746 --> 0:20:34,576
服务员说 “没问题” 后离开

584
00:20:34,576 --> 0:20:36,196
然后给你拿了一杯水

585
00:20:37,016 --> 0:20:38,366
你的朋友说 

586
00:20:38,366 --> 0:20:39,406
“也请给我一杯水 可以吗？”

587
00:20:40,066 --> 0:20:41,386
服务员说 “没问题” 后离开

588
00:20:41,386 --> 0:20:43,876
然后给你的朋友拿了一杯水

589
00:20:44,526 --> 0:20:45,576
如果服务员一次性获知

590
00:20:45,576 --> 0:20:46,836
每个人想要的东西

591
00:20:46,836 --> 0:20:48,556
从而减少来回当趟数

592
00:20:48,556 --> 0:20:49,486
不是会更快吗

593
00:20:50,816 --> 0:20:52,746
减少延迟的方法很简单

594
00:20:53,536 --> 0:20:54,966
当你获取一项资源时

595
00:20:54,966 --> 0:20:56,696
减少往返的次数即可

596
00:20:57,626 --> 0:21:01,936
现在我们看看你的 App 如何做到这点

597
00:20:57,626 --> 0:21:01,936
现在我们看看你的 App 如何做到这点

598
00:21:02,136 --> 0:21:03,796
首先我们看一下

599
00:21:03,796 --> 0:21:05,446
HTTP/1.1 的一些问题

600
00:21:06,896 --> 0:21:07,846
你的 App 需要获取资源

601
00:21:07,846 --> 0:21:10,486
你可以创建一个 URLSession 任务

602
00:21:10,486 --> 0:21:13,196
然后调用 resume

603
00:21:14,146 --> 0:21:16,626
URLSession 会为你创建

604
00:21:16,626 --> 0:21:21,136
一个包含 DNS TCP 和 TLS 的新连接

605
00:21:22,626 --> 0:21:25,606
一旦和服务器的连接被建立 

606
00:21:25,606 --> 0:21:26,656
你的请求会被发出

607
00:21:27,256 --> 0:21:30,046
然后等待从服务器

608
00:21:30,046 --> 0:21:32,446
返回的回应

609
00:21:32,656 --> 0:21:34,176
这就是网络的闲时

610
00:21:34,356 --> 0:21:35,666
你的 App 没有做任何跟

611
00:21:35,666 --> 0:21:37,096
网络相关的事情

612
00:21:37,096 --> 0:21:40,486
只是在等服务器的回应

613
00:21:40,596 --> 0:21:42,616
一旦得到回应

614
00:21:42,616 --> 0:21:44,376
我们会调用你的完成代码块

615
00:21:44,376 --> 0:21:46,156
或向你的 Delegate 发消息

616
00:21:46,156 --> 0:21:47,366
告知已经完成加载

617
00:21:47,946 --> 0:21:50,446
假设在加载的过程中

618
00:21:50,446 --> 0:21:51,676
你的 App 想要从

619
00:21:51,676 --> 0:21:53,756
同一服务器获取另一项资源

620
00:21:54,376 --> 0:21:56,346
你可以再创建一个

621
00:21:56,406 --> 0:21:58,776
URLSession 任务并调用 resume

622
00:21:59,346 --> 0:22:01,766
然后 URLSession 会创建一个新的

623
00:21:59,346 --> 0:22:01,766
然后 URLSession 会创建一个新的

624
00:22:01,766 --> 0:22:03,126
连接以获取这个资源

625
00:22:03,126 --> 0:22:04,726
因为它在连接池中

626
00:22:04,726 --> 0:22:06,676
并没有空闲的连接

627
00:22:08,136 --> 0:22:09,336
如果你的 App 又要

628
00:22:09,336 --> 0:22:10,576
从同一服务器再获取

629
00:22:10,576 --> 0:22:12,616
一项资源 你可以再创建

630
00:22:12,616 --> 0:22:14,726
一个 URLSession 任务并调用 resume

631
00:22:15,126 --> 0:22:16,196
然后为了获取资源

632
00:22:16,196 --> 0:22:17,856
会再创建一个新的连接

633
00:22:18,376 --> 0:22:21,236
在这个例子中

634
00:22:21,236 --> 0:22:24,236
我们为了从同一个服务器获取资源

635
00:22:24,306 --> 0:22:26,356
创建了 3 个不同的连接

636
00:22:27,726 --> 0:22:29,246
你可能注意到了

637
00:22:29,246 --> 0:22:31,076
我们花了很多时间创建新连接

638
00:22:31,606 --> 0:22:33,466
我们再看看如果

639
00:22:33,466 --> 0:22:35,716
你只用一个连接会怎样

640
00:22:38,416 --> 0:22:40,306
这是单一连接的情况

641
00:22:41,006 --> 0:22:42,436
因为没有不断创建新连接

642
00:22:42,436 --> 0:22:44,366
我们省了很多时间

643
00:22:44,366 --> 0:22:45,456
但这里有另一个问题

644
00:22:46,636 --> 0:22:48,406
请求 2 也就是绿色的请求

645
00:22:48,406 --> 0:22:50,416
必须要等待

646
00:22:50,586 --> 0:22:52,316
请求 1 的回应

647
00:22:52,316 --> 0:22:53,056
被完全接收

648
00:22:54,216 --> 0:22:57,196
请求 3 也有同样的问题

649
00:22:57,196 --> 0:22:59,016
也就是橘黄色的请求

650
00:22:59,016 --> 0:23:01,116
必须等请求 2 的回应

651
00:22:59,016 --> 0:23:01,116
必须等请求 2 的回应

652
00:23:01,356 --> 0:23:02,286
被完全接收

653
00:23:03,436 --> 0:23:05,666
这个问题被称为

654
00:23:05,666 --> 0:23:06,746
HTTP 队头阻塞

655
00:23:08,096 --> 0:23:10,406
现在来考虑 HTTP/2 

656
00:23:11,676 --> 0:23:14,126
HTTP/2 使用单一连接

657
00:23:14,496 --> 0:23:16,166
并且也解决了

658
00:23:16,166 --> 0:23:17,866
HTTP 队头阻塞的问题

659
00:23:18,396 --> 0:23:21,956
HTTP/2 在一条连接上

660
00:23:21,956 --> 0:23:24,156
多路传输多条数据流

661
00:23:24,696 --> 0:23:29,136
让你可以同时收到多个回应

662
00:23:29,666 --> 0:23:32,456
我们再来仔细分析一下这个例子

663
00:23:32,456 --> 0:23:34,966
看看 HTTP/2

664
00:23:35,026 --> 0:23:37,166
是怎样比 HTTP/1.1 表现得更好的

665
00:23:39,456 --> 0:23:41,406
注意以下这些时间节点

666
00:23:41,406 --> 0:23:42,656
当你的 App 试图

667
00:23:42,656 --> 0:23:44,806
获取资源的时候

668
00:23:44,806 --> 0:23:45,966
当请求被发送出去的时候

669
00:23:47,206 --> 0:23:50,156
如果使用 HTTP/1.1

670
00:23:50,156 --> 0:23:52,306
从你的 App

671
00:23:52,306 --> 0:23:53,676
需要资源起

672
00:23:53,676 --> 0:23:55,126
到请求被发送之间

673
00:23:55,126 --> 0:23:56,106
有明显的延迟

674
00:23:57,336 --> 0:24:00,336
HTTP/2 能显著减少

675
00:23:57,336 --> 0:24:00,336
HTTP/2 能显著减少

676
00:24:00,336 --> 0:24:02,916
这个延迟

677
00:24:02,916 --> 0:24:04,636
在每当 App 需要资源时

678
00:24:04,636 --> 0:24:06,866
基本上立刻发送请求

679
00:24:07,306 --> 0:24:12,576
再来看一下这些灰色的方块

680
00:24:13,446 --> 0:24:14,946
如果你还记得

681
00:24:14,946 --> 0:24:17,016
这是你的 App 没有做任何

682
00:24:17,016 --> 0:24:18,546
跟网络相关的事时的空闲时间

683
00:24:18,836 --> 0:24:21,476
只是在等待服务器的回应

684
00:24:22,736 --> 0:24:25,606
HTTP/2 能显著减少

685
00:24:25,656 --> 0:24:27,876
这样的网络闲时

686
00:24:27,876 --> 0:24:29,376
允许你更充分地利用带宽

687
00:24:35,476 --> 0:24:37,236
我们刚才讨论了

688
00:24:37,236 --> 0:24:40,186
HTTP/2 相比 HTTP/1.1 的

689
00:24:40,636 --> 0:24:41,726
许多优点

690
00:24:41,726 --> 0:24:41,926
简单总结一下

691
00:24:43,166 --> 0:24:45,086
HTTP/2 在 HTTP 层面

692
00:24:45,086 --> 0:24:47,146
解决了队头阻塞问题

693
00:24:47,476 --> 0:24:49,696
它同时允许你更充分地

694
00:24:49,696 --> 0:24:50,686
利用带宽

695
00:24:52,286 --> 0:24:54,786
如果你的 App 使用 URLSession

696
00:24:54,786 --> 0:24:55,826
你不需要对客户端

697
00:24:55,826 --> 0:24:57,016
做任何改动

698
00:24:57,926 --> 0:25:00,556
仅需在服务器上启用 HTTP/2

699
00:24:57,926 --> 0:25:00,556
仅需在服务器上启用 HTTP/2

700
00:25:00,556 --> 0:25:02,246
你就能看到这些改善

701
00:25:03,736 --> 0:25:06,246
采用 HTTP/2 同时也能使你

702
00:25:06,246 --> 0:25:07,996
在服务器端有所改善

703
00:25:08,466 --> 0:25:10,296
因为那些运行你的 App 的设备

704
00:25:10,296 --> 0:25:15,066
与服务器连接次数变少了

705
00:25:15,166 --> 0:25:17,286
今年 我们在 URLSession 里有一些

706
00:25:17,386 --> 0:25:19,346
新东西 可以作为

707
00:25:19,346 --> 0:25:23,946
HTTP/2 优势的补充

708
00:25:24,196 --> 0:25:26,496
下面我们介绍针对 URLSession 的 

709
00:25:26,496 --> 0:25:28,106
HTTP/2 Connection Coalescing

710
00:25:28,586 --> 0:25:32,376
HTTP/2 Connection Coalescing 将会

711
00:25:32,376 --> 0:25:35,036
让连接被更充分利用

712
00:25:36,556 --> 0:25:39,226
因为你的 App 不会再一直

713
00:25:39,226 --> 0:25:40,886
建立新连接

714
00:25:40,886 --> 0:25:44,276
对用户的响应会更加及时

715
00:25:45,636 --> 0:25:46,906
从 WWDC 配置文件开始

716
00:25:46,906 --> 0:25:50,866
HTTP/2 Connection Coalescing

717
00:25:50,866 --> 0:25:52,246
会自动在所有使用

718
00:25:52,246 --> 0:25:55,026
URLSession 的 App 上启用

719
00:25:56,296 --> 0:25:57,976
现在我们来看看 HTTP/2

720
00:25:57,976 --> 0:25:59,676
Connection Coalescing

721
00:25:59,676 --> 0:26:00,356
怎样决定重用连接的

722
00:25:59,676 --> 0:26:00,356
怎样决定重用连接的

723
00:26:00,886 --> 0:26:05,516
假设你有一个 App

724
00:26:05,516 --> 0:26:06,806
这个 App 想要获得

725
00:26:06,806 --> 0:26:09,586
来自 menu.example.com 的资源

726
00:26:10,746 --> 0:26:12,526
我们建立一个与服务器的连接

727
00:26:12,606 --> 0:26:14,806
然后服务器给我们一个证书

728
00:26:16,076 --> 0:26:18,206
如果你的 App 想要获得另一项

729
00:26:18,446 --> 0:26:21,026
处于 delivery.example.com 上的资源

730
00:26:21,026 --> 0:26:22,486
我们建立另一个连接

731
00:26:22,486 --> 0:26:24,066
服务器再给我们另一个证书

732
00:26:25,436 --> 0:26:27,526
在这种旧的运作模式下

733
00:26:27,646 --> 0:26:29,556
URLSession 会从给定的主机名上

734
00:26:29,556 --> 0:26:31,366
创建两个连接

735
00:26:31,366 --> 0:26:33,236
来获取这些资源

736
00:26:33,726 --> 0:26:36,836
但如果你细想一下

737
00:26:36,936 --> 0:26:39,016
提供给我们的第一个证书

738
00:26:39,016 --> 0:26:41,596
覆盖了 example.com 下的所有子域名

739
00:26:41,796 --> 0:26:44,606
这意味着

740
00:26:44,946 --> 0:26:48,536
delivery.example.com 也被

741
00:26:48,566 --> 0:26:50,316
第一个证书包含在内

742
00:26:50,356 --> 0:26:51,506
同时也注意到

743
00:26:51,716 --> 0:26:54,146
delivery.example.com 和第一个连接

744
00:26:54,146 --> 0:26:56,886
导向的 IP 地址一样

745
00:26:57,426 --> 0:27:00,406
到这里 我们完全可以

746
00:26:57,426 --> 0:27:00,406
到这里 我们完全可以

747
00:27:00,406 --> 0:27:01,486
假定与我们对话的是同一个端点

748
00:27:01,486 --> 0:27:03,796
那么当我们需要获取

749
00:27:03,796 --> 0:27:05,726
第二个资源时可以重用连接 

750
00:27:05,726 --> 0:27:07,346
而不是重新建立

751
00:27:07,346 --> 0:27:08,406
一个新的连接 

752
00:27:09,126 --> 0:27:10,506
这么做节省了时间

753
00:27:10,506 --> 0:27:11,936
因为不需要建立一个新的连接

754
00:27:11,936 --> 0:27:13,316
这会让加载速度快很多

755
00:27:13,896 --> 0:27:16,086
这就是 HTTP/2 Connection Coalescing

756
00:27:16,086 --> 0:27:22,156
在 iOS 12 和 macOS Mojave 中的新特性

757
00:27:23,416 --> 0:27:26,296
现在让我们看一下

758
00:27:26,386 --> 0:27:28,716
如何通过减少 URLSession 对象的使用

759
00:27:28,716 --> 0:27:29,826
来减少延迟

760
00:27:30,356 --> 0:27:34,656
在刚才的几页幻灯片中

761
00:27:34,656 --> 0:27:36,876
我们讨论的所有

762
00:27:36,876 --> 0:27:38,876
有关连接的好处

763
00:27:38,876 --> 0:27:41,306
都只在你用同一个

764
00:27:41,306 --> 0:27:43,546
URLSession 对象

765
00:27:43,546 --> 0:27:44,916
创建任务的情况下生效

766
00:27:47,016 --> 0:27:48,876
以下这点也同样重要

767
00:27:48,936 --> 0:27:51,586
每个 URLSession 对象都有

768
00:27:51,586 --> 0:27:53,206
一个连接池

769
00:27:53,206 --> 0:27:54,506
当你创建多个

770
00:27:54,506 --> 0:27:56,106
URLSession 对象

771
00:27:56,106 --> 0:27:57,606
你无法得到任何有关

772
00:27:57,606 --> 0:27:58,026
连接的好处

773
00:27:59,066 --> 0:28:01,306
同时也需要说明的是

774
00:27:59,066 --> 0:28:01,306
同时也需要说明的是

775
00:28:01,356 --> 0:28:02,726
创建 URLSession 对象

776
00:28:02,726 --> 0:28:04,846
相对来说性能消耗不低

777
00:28:04,846 --> 0:28:06,206
并且在内存方面的占用

778
00:28:06,206 --> 0:28:06,676
不能忽略不计

779
00:28:08,036 --> 0:28:09,776
和以前一样

780
00:28:09,816 --> 0:28:11,726
我们仍然建议你使用

781
00:28:11,726 --> 0:28:13,466
尽可能少的 URLSession 对象

782
00:28:13,986 --> 0:28:17,496
让我们开始今天的下一个话题

783
00:28:17,496 --> 0:28:19,796
最大化吞吐量

784
00:28:19,796 --> 0:28:23,156
回到我们那个餐馆的例子

785
00:28:23,986 --> 0:28:25,956
服务员问你要什么

786
00:28:25,956 --> 0:28:30,206
然后你说 “来一份烤鸡拌酱汁

787
00:28:30,206 --> 0:28:32,006
酱汁要奶油番茄洋葱肉汁

788
00:28:32,006 --> 0:28:32,646
要用大量黄油做”

789
00:28:33,906 --> 0:28:34,846
那真是相当绕口

790
00:28:35,656 --> 0:28:36,596
如果这样会不会就简单得多

791
00:28:36,596 --> 0:28:38,356
就说“我要一份黄油鸡”

792
00:28:39,936 --> 0:28:41,556
最大化吞吐量的方法

793
00:28:41,556 --> 0:28:43,216
也是一样的

794
00:28:43,216 --> 0:28:44,296
每当你想要获取资源

795
00:28:44,296 --> 0:28:46,536
减少你传输的数据量

796
00:28:47,306 --> 0:28:48,686
我们来看看你的 App

797
00:28:48,686 --> 0:28:49,036
如何做到这点

798
00:28:49,116 --> 0:28:52,796
有几种方法

799
00:28:52,796 --> 0:28:55,086
来减少请求的大小

800
00:28:55,956 --> 0:28:58,246
请注意 HTTP Cookies

801
00:28:59,076 --> 0:29:01,646
不是无代价的

802
00:28:59,076 --> 0:29:01,646
不是无代价的

803
00:29:01,646 --> 0:29:03,216
储存和查找他们

804
00:29:03,216 --> 0:29:03,846
都消耗空间和时间

805
00:29:05,256 --> 0:29:08,676
Cookies 附加于所有符合域

806
00:29:08,676 --> 0:29:09,946
和路径的属性的请求上

807
00:29:10,506 --> 0:29:11,856
这会极大增加

808
00:29:11,856 --> 0:29:12,636
你的请求大小

809
00:29:13,996 --> 0:29:17,966
请善用域和路径的属性

810
00:29:17,966 --> 0:29:19,826
来确保服务器需要的 Cookies 

811
00:29:19,896 --> 0:29:21,306
附在你的请求上

812
00:29:22,526 --> 0:29:23,756
使用尽可能少的 Cookies

813
00:29:23,756 --> 0:29:25,336
并当你不再需要

814
00:29:25,336 --> 0:29:26,606
它们的时候

815
00:29:26,606 --> 0:29:26,846
及时删除

816
00:29:28,226 --> 0:29:29,896
试着把一些状态保存在服务器上

817
00:29:29,896 --> 0:29:31,686
这样你就能减少

818
00:29:31,686 --> 0:29:33,246
客户端上的 Cookies

819
00:29:33,716 --> 0:29:36,856
同时也请考虑转换到 HTTP/2

820
00:29:37,326 --> 0:29:39,356
从而获得头部压缩的好处

821
00:29:39,906 --> 0:29:43,176
我们再来多聊聊压缩

822
00:29:43,706 --> 0:29:48,646
HTTP 压缩

823
00:29:48,646 --> 0:29:51,126
即储存信息与编码

824
00:29:51,176 --> 0:29:53,026
其实就是压缩那些

825
00:29:53,026 --> 0:29:56,096
穿梭于客户端与服务器之间的数据

826
00:29:56,096 --> 0:29:58,276
这使得我们可以更好地利用带宽

827
00:29:59,706 --> 0:30:02,046
URLSession 支持与推荐的

828
00:29:59,706 --> 0:30:02,046
URLSession 支持与推荐的

829
00:30:02,246 --> 0:30:05,796
算法是 Gzip 和 Brotli

830
00:30:07,226 --> 0:30:09,756
Gzip 被广泛支持

831
00:30:09,756 --> 0:30:10,706
而且相对较快

832
00:30:11,906 --> 0:30:13,616
Brotli 的支持出现在

833
00:30:13,616 --> 0:30:16,686
去年发布 iOS 11 和 macOS

834
00:30:16,686 --> 0:30:17,356
High Sierra 时

835
00:30:18,626 --> 0:30:20,076
Brotli 为结构化的文本

836
00:30:20,076 --> 0:30:22,136
和 HTML 做了优化

837
00:30:22,136 --> 0:30:24,356
而且它在短数据上

838
00:30:24,356 --> 0:30:26,726
具有最优的压缩率

839
00:30:27,416 --> 0:30:29,196
如果你还没有启用压缩的话

840
00:30:29,196 --> 0:30:31,476
请在你的服务器上启用

841
00:30:32,016 --> 0:30:34,986
让我们继续今天的下一个话题

842
00:30:34,986 --> 0:30:37,926
提升响应度

843
00:30:39,146 --> 0:30:40,926
回到我们餐馆的例子

844
00:30:40,926 --> 0:30:42,906
你来圣何塞参加 WWDC

845
00:30:42,906 --> 0:30:44,656
你决定去见见

846
00:30:44,656 --> 0:30:45,986
一些老朋友

847
00:30:46,116 --> 0:30:48,086
你和你的朋友就坐在

848
00:30:48,086 --> 0:30:49,056
餐馆的餐桌旁

849
00:30:49,636 --> 0:30:51,456
你的饮料上来了

850
00:30:51,456 --> 0:30:52,746
但是你想要更多时间

851
00:30:52,746 --> 0:30:53,866
来和你的朋友们叙叙旧

852
00:30:53,966 --> 0:30:55,216
而不是直接上菜吃饭

853
00:30:56,216 --> 0:30:57,346
你可以简单地跟服务员说

854
00:30:58,076 --> 0:30:58,956
“请你过一会

855
00:30:58,956 --> 0:30:59,926
再上菜可以吗？

856
00:30:59,926 --> 0:31:01,216
我们不赶时间”

857
00:30:59,926 --> 0:31:01,216
我们不赶时间”

858
00:31:02,226 --> 0:31:03,646
这里有一个同样的理念

859
00:31:03,646 --> 0:31:05,366
可以被应用在响应度上

860
00:31:05,366 --> 0:31:06,866
你根据你正在进行的

861
00:31:07,096 --> 0:31:09,166
其它任务给你的任务标上优先级

862
00:31:10,106 --> 0:31:11,306
我们来看看你的 App

863
00:31:11,306 --> 0:31:12,186
可以如何从中获益

864
00:31:12,566 --> 0:31:16,936
你也许很熟悉

865
00:31:16,936 --> 0:31:19,756
跟派遣队列和 NSOperation

866
00:31:19,756 --> 0:31:22,026
对象有关的

867
00:31:22,026 --> 0:31:22,666
这五个 QoS 类

868
00:31:23,616 --> 0:31:24,976
数据需要依靠

869
00:31:24,976 --> 0:31:26,096
CPU 的调度策略

870
00:31:27,656 --> 0:31:31,156
URLSession 是对 QoS 敏感的

871
00:31:31,156 --> 0:31:33,356
意味着它可以在

872
00:31:33,426 --> 0:31:36,146
你调用 task.resume 的队列中采集 QoS

873
00:31:37,156 --> 0:31:38,646
它发给你的 Delegate 的

874
00:31:38,646 --> 0:31:41,086
所有消息都会遵守这个 QoS

875
00:31:41,086 --> 0:31:44,196
举个例子

876
00:31:45,246 --> 0:31:46,986
如果你的 App 想要获取一些

877
00:31:46,986 --> 0:31:48,786
与时间无关的数据

878
00:31:49,406 --> 0:31:51,476
考虑在一个有后台 QoS 的队列上

879
00:31:51,476 --> 0:31:53,356
继续这个任务

880
00:31:54,026 --> 0:31:56,056
保证这个任务不会

881
00:31:56,056 --> 0:31:58,066
与其他正在做的

882
00:31:58,066 --> 0:31:59,436
更高优先级的工作

883
00:31:59,436 --> 0:32:04,016
争夺 CPU 资源

884
00:31:59,436 --> 0:32:04,016
争夺 CPU 资源

885
00:32:04,186 --> 0:32:06,086
网络服务类型

886
00:32:06,086 --> 0:32:08,156
是 URLSession 配置对象上的

887
00:32:08,226 --> 0:32:10,946
一个属性 可以让你

888
00:32:10,946 --> 0:32:12,916
将你的网络流量分类

889
00:32:12,916 --> 0:32:15,596
从而帮助系统提升

890
00:32:15,596 --> 0:32:17,926
将要离开设备的数据的优先级

891
00:32:19,276 --> 0:32:21,236
今年 我们有了一个

892
00:32:21,236 --> 0:32:22,276
新的网络服务类型

893
00:32:22,276 --> 0:32:23,346
就是 responsiveData

894
00:32:24,656 --> 0:32:26,676
responsiveData 比默认的类型

895
00:32:26,676 --> 0:32:28,596
优先级稍高

896
00:32:28,596 --> 0:32:30,416
但是应该被合理利用

897
00:32:31,446 --> 0:32:32,906
举个你应该使用

898
00:32:32,906 --> 0:32:35,606
responsiveData 的例子

899
00:32:35,606 --> 0:32:37,856
如果你有个购物的 App

900
00:32:37,856 --> 0:32:38,786
在结算页面

901
00:32:39,586 --> 0:32:40,816
你应该把支付请求

902
00:32:40,886 --> 0:32:42,346
标记为 responsiveData

903
00:32:42,346 --> 0:32:44,376
来保证可以从

904
00:32:44,376 --> 0:32:46,636
服务器得到响应

905
00:32:48,096 --> 0:32:49,766
用网络服务类型属性

906
00:32:49,766 --> 0:32:51,676
标记的流量

907
00:32:51,676 --> 0:32:53,986
在 Cisco Fast Lane 上跳转时

908
00:32:53,986 --> 0:32:56,886
会一直保留这个标记

909
00:32:58,026 --> 0:32:59,516
有关这个 API 的更多信息

910
00:32:59,516 --> 0:33:02,226
请查看 2016 年的

911
00:32:59,516 --> 0:33:02,226
请查看 2016 年的

912
00:33:02,226 --> 0:33:08,086
有关部分

913
00:33:08,086 --> 0:33:09,736
去年我们介绍了

914
00:33:09,736 --> 0:33:11,556
URLSession 自适应

915
00:33:11,556 --> 0:33:12,896
连接 API

916
00:33:13,376 --> 0:33:14,596
waitsForConnectivity

917
00:33:15,976 --> 0:33:18,106
waitsForConnectivity 会一直等待

918
00:33:18,106 --> 0:33:20,736
而不是在你的任务没有

919
00:33:21,176 --> 0:33:22,616
连接的时候

920
00:33:22,666 --> 0:33:23,246
直接加载失败

921
00:33:24,606 --> 0:33:26,006
过去 你们一直在用

922
00:33:26,006 --> 0:33:28,016
STNeworkReachability

923
00:33:28,016 --> 0:33:30,426
来完成发送请求前的预先检查

924
00:33:31,126 --> 0:33:32,486
但是正如 Stuart 刚指出的

925
00:33:32,486 --> 0:33:34,296
这其实是一场赛跑

926
00:33:34,296 --> 0:33:37,046
因为系统可能告诉你

927
00:33:37,046 --> 0:33:39,186
你连上了一个服务器

928
00:33:39,186 --> 0:33:40,406
但是当你创建并发出请求的时候

929
00:33:40,406 --> 0:33:41,946
你已经失去了机会

930
00:33:41,946 --> 0:33:45,826
你不再与服务器连接着了

931
00:33:45,826 --> 0:33:46,776
我们推荐使用

932
00:33:46,776 --> 0:33:48,406
waitsForConnectivity

933
00:33:48,406 --> 0:33:50,316
它会在连接一旦可用时

934
00:33:50,316 --> 0:33:52,496
把你的请求发出去

935
00:33:53,946 --> 0:33:58,066
你也可以执行 taskIsWaitigForConnectivity

936
00:33:58,066 --> 0:33:59,786
Delegate 方法

937
00:33:59,786 --> 0:34:01,896
它会在你的任务无连接时被调用

938
00:33:59,786 --> 0:34:01,896
它会在你的任务无连接时被调用

939
00:34:03,286 --> 0:34:04,876
这会在为用户呈现

940
00:34:04,876 --> 0:34:06,426
另一个流程或者离线的 UI 时

941
00:34:06,686 --> 0:34:09,766
带来更好的用户体验

942
00:34:11,376 --> 0:34:13,085
有关这个 API 的更多信息

943
00:34:13,085 --> 0:34:15,396
请看去年 WWDC

944
00:34:15,396 --> 0:34:18,246
介绍这个 API 的有关会谈

945
00:34:18,246 --> 0:34:21,716
现在我们来看今天的

946
00:34:21,716 --> 0:34:23,676
最后一个话题

947
00:34:23,676 --> 0:34:25,496
更好地利用系统资源

948
00:34:26,606 --> 0:34:28,045
回到我们餐馆的例子

949
00:34:28,496 --> 0:34:30,896
你很喜欢这里的食物

950
00:34:31,036 --> 0:34:32,505
你决定第二天

951
00:34:32,505 --> 0:34:33,755
来这里吃晚饭

952
00:34:35,025 --> 0:34:36,366
餐馆有外送服务

953
00:34:36,366 --> 0:34:38,255
你可以今天下单

954
00:34:38,255 --> 0:34:40,166
他们第二天会

955
00:34:40,166 --> 0:34:41,896
把餐品送到你家

956
00:34:42,735 --> 0:34:44,616
这不仅帮你省掉了

957
00:34:44,616 --> 0:34:46,376
去取食物耗费的时间和精力

958
00:34:46,376 --> 0:34:48,366
还帮助餐馆

959
00:34:48,366 --> 0:34:50,056
根据你的截止时间

960
00:34:50,226 --> 0:34:51,295
更好地确定工作的优先级

961
00:34:52,496 --> 0:34:54,366
让我们来看看你的 App 如何

962
00:34:54,366 --> 0:34:56,266
更好地利用系统资源

963
00:34:56,266 --> 0:34:57,326
从而提升效率

964
00:35:00,056 --> 0:35:02,206
后台会话有上传

965
00:35:02,206 --> 0:35:03,456
和下载的任务

966
00:35:04,456 --> 0:35:06,156
这些任务让

967
00:35:06,156 --> 0:35:08,046
系统智能地决定何时开始

968
00:35:08,046 --> 0:35:09,876
以及何时结束下载

969
00:35:09,876 --> 0:35:11,926
这个决定基于很多因素

970
00:35:11,926 --> 0:35:15,726
例如电量 CPU Wi-Fi 等等

971
00:35:17,616 --> 0:35:19,276
如果你的 App 想要下载

972
00:35:19,276 --> 0:35:21,416
一个大文件

973
00:35:21,416 --> 0:35:22,346
考虑使用后台会话

974
00:35:23,736 --> 0:35:26,036
这些任务在进程外运行

975
00:35:26,836 --> 0:35:28,276
意味着即使你的 App

976
00:35:28,276 --> 0:35:30,676
在暂停状态

977
00:35:30,676 --> 0:35:31,766
下载也会继续

978
00:35:33,036 --> 0:35:34,476
与后台会话有关的

979
00:35:34,476 --> 0:35:36,246
更多信息 

980
00:35:36,246 --> 0:35:42,676
参见 2014 年的 WWDC 会议

981
00:35:42,796 --> 0:35:46,576
缓存是减少延迟的好方法

982
00:35:46,576 --> 0:35:48,526
但是需要注意的是

983
00:35:48,526 --> 0:35:50,076
缓存可能会导致磁盘存取问题

984
00:35:51,366 --> 0:35:52,816
在现实世界里

985
00:35:52,816 --> 0:35:54,596
我们看到有些 App

986
00:35:54,596 --> 0:35:56,746
每天往磁盘里写入若干 GB 的数据

987
00:35:56,746 --> 0:35:58,656
会引起严重的

988
00:35:58,656 --> 0:35:59,706
闪存劣化

989
00:36:01,076 --> 0:36:02,746
请不要缓存唯一的信息

990
00:36:04,196 --> 0:36:05,166
举个例子

991
00:36:06,096 --> 0:36:08,246
假设你有个 App

992
00:36:08,246 --> 0:36:09,856
约会的 App

993
00:36:09,856 --> 0:36:11,076
而你负责其中

994
00:36:11,076 --> 0:36:13,086
网络部分的代码

995
00:36:13,086 --> 0:36:15,136
这个 App 加载高分辨率的

996
00:36:15,486 --> 0:36:17,356
用户照片

997
00:36:18,516 --> 0:36:20,206
缓存这些高分辨率图像

998
00:36:20,206 --> 0:36:21,826
可能有些浪费

999
00:36:22,346 --> 0:36:23,636
因为用户会向左滑动

1000
00:36:23,666 --> 0:36:25,286
去看下一个

1001
00:36:25,286 --> 0:36:28,786
意味着你刚才缓存的图像

1002
00:36:28,846 --> 0:36:30,756
可能再也不会被请求到

1003
00:36:32,076 --> 0:36:33,446
请考虑做些

1004
00:36:33,476 --> 0:36:35,396
客户端侧的修改 比如

1005
00:36:35,396 --> 0:36:37,296
采用 willChacheResponse Delegate 方法

1006
00:36:37,296 --> 0:36:39,596
来决定哪些资源

1007
00:36:39,596 --> 0:36:40,396
应该被缓存

1008
00:36:41,886 --> 0:36:43,896
如果你拥有服务器的话

1009
00:36:43,896 --> 0:36:45,436
请考虑在请求头中使用缓存控制

1010
00:36:45,436 --> 0:36:48,016
来决定哪些资源

1011
00:36:48,016 --> 0:36:48,826
可以被缓存

1012
00:36:49,346 --> 0:36:53,006
我们迅速地过一遍

1013
00:36:53,006 --> 0:36:54,506
今天讨论过的关键点

1014
00:36:55,346 --> 0:36:57,286
第一点 当你去餐馆时

1015
00:36:57,286 --> 0:36:58,836
一次性把所有要点的菜都点完

1016
00:36:59,166 --> 0:37:00,766
我开个玩笑

1017
00:36:59,166 --> 0:37:00,766
我开个玩笑

1018
00:37:01,666 --> 0:37:03,976
转移到 HTTP/2

1019
00:37:03,976 --> 0:37:05,326
从而利用头部压缩

1020
00:37:05,546 --> 0:37:07,116
Connection Coalescing

1021
00:37:07,116 --> 0:37:07,986
以及无队头阻塞问题等等好处

1022
00:37:08,506 --> 0:37:12,596
用更少的 URLSession 对象

1023
00:37:12,596 --> 0:37:15,076
通过重用连接来减少延迟

1024
00:37:15,826 --> 0:37:17,816
这也减少了内存占用

1025
00:37:17,816 --> 0:37:20,726
所以也更好地利用了系统资源

1026
00:37:21,176 --> 0:37:23,936
减小请求的大小

1027
00:37:24,236 --> 0:37:25,456
来最大化吞吐量

1028
00:37:27,316 --> 0:37:29,736
注意 QoS

1029
00:37:29,736 --> 0:37:31,386
提高你的 App 的响应灵敏度

1030
00:37:32,216 --> 0:37:34,146
最后 使用后台会话

1031
00:37:34,146 --> 0:37:35,896
从而可以更好地

1032
00:37:35,896 --> 0:37:37,856
利用系统资源

1033
00:37:39,536 --> 0:37:40,936
关于这个会议的更多信息

1034
00:37:40,936 --> 0:37:42,726
请访问这个网站

1035
00:37:43,766 --> 0:37:45,006
现在我们短暂休息一下

1036
00:37:45,696 --> 0:37:46,796
休息过后

1037
00:37:46,796 --> 0:37:47,856
我们会向你介绍

1038
00:37:47,856 --> 0:37:49,856
Sockets 的现代替代者

1039
00:37:49,856 --> 0:37:50,556
Network.framework

1040
00:37:51,246 --> 0:37:52,596
我很希望在

1041
00:37:52,596 --> 0:37:54,426
今天和明天举办的

1042
00:37:54,426 --> 0:37:55,856
网络实验室里见到各位

1043
00:37:57,236 --> 0:37:58,546
感谢各位来到这里

1044
00:37:58,546 --> 0:38:00,326
希望大家享受

1045
00:37:58,546 --> 0:38:00,326
希望大家享受

1046
00:38:00,326 --> 0:38:01,306
大会的其他部分

1047
00:38:02,508 --> 0:38:04,508
[ 掌声 ]
