1
00:00:07,516 --> 0:00:15,500
[ 音乐 ]

2
00:00:17,516 --> 0:00:23,056
[ 掌声 ]

3
00:00:23,556 --> 0:00:24,156
&gt;&gt; 大家好

4
00:00:24,876 --> 0:00:26,136
非常高兴见到今天

5
00:00:26,136 --> 0:00:26,446
到场的各位

6
00:00:27,306 --> 0:00:29,676
我是 Dave 之后的 40 分钟

7
00:00:29,676 --> 0:00:32,436
是关于理解

8
00:00:32,485 --> 0:00:33,996
和致敬 驱动我们的

9
00:00:34,036 --> 0:00:35,716
程序运行的东西

10
00:00:36,766 --> 0:00:38,286
我们将会聊到一些实用的建议

11
00:00:38,636 --> 0:00:40,986
但这并不是一个关于

12
00:00:41,056 --> 0:00:43,116
技巧 技术

13
00:00:43,116 --> 0:00:44,876
或者任何具体算法的演讲

14
00:00:44,876 --> 0:00:45,816
尽管我们仍会有所涉及

15
00:00:47,026 --> 0:00:49,156
这个演讲主要的内容是

16
00:00:49,296 --> 0:00:50,956
揭示一些根本的东西 它的潜力

17
00:00:51,036 --> 0:00:54,006
已经在你的代码中有所体现

18
00:00:54,936 --> 0:00:57,216
我希望至少对于你们之中的一些人

19
00:00:57,216 --> 0:00:58,796
这标志着与编程实践

20
00:00:58,796 --> 0:01:01,056
建立新关系的开始

21
00:00:58,796 --> 0:01:01,056
建立新关系的开始

22
00:01:02,236 --> 0:01:03,446
就个人而言 

23
00:01:03,446 --> 0:01:05,116
当我发现这种方法时

24
00:01:05,116 --> 0:01:06,446
我的生活和事业的航向

25
00:01:06,756 --> 0:01:07,486
就由此改变

26
00:01:08,446 --> 0:01:09,926
这就是为什么

27
00:01:09,926 --> 0:01:11,966
我如此关心软件库

28
00:01:11,966 --> 0:01:13,786
但它也是

29
00:01:13,786 --> 0:01:15,866
我所编写过的具体代码的

30
00:01:15,866 --> 0:01:17,976
每一部分之中的可靠性

31
00:01:17,976 --> 0:01:19,436
可维护性以及性能表现的来源

32
00:01:20,836 --> 0:01:22,876
但在我们开始之前

33
00:01:22,876 --> 0:01:24,226
请允许我向你们介绍

34
00:01:24,226 --> 0:01:24,396
我的一个朋友

35
00:01:26,776 --> 0:01:27,506
他就是 Crusty

36
00:01:28,516 --> 0:01:31,616
[ 掌声 ]

37
00:01:32,116 --> 0:01:34,006
Crusty 是一个传统派

38
00:01:34,896 --> 0:01:37,026
他不相信调试工具

39
00:01:37,026 --> 0:01:40,016
也不爱使用集成开发环境

40
00:01:40,806 --> 0:01:43,246
没错 他喜欢那种 80 × 24

41
00:01:43,246 --> 0:01:45,436
的纯文本终端窗口

42
00:01:45,506 --> 0:01:46,246
非常感谢

43
00:01:47,516 --> 0:01:49,566
现在 Crusty 对最新的编程潮流

44
00:01:49,566 --> 0:01:51,916
持悲观态度

45
00:01:51,916 --> 0:01:53,476
所以想把他拖到 21 世纪

46
00:01:53,476 --> 0:01:55,166
有时会比较费力

47
00:01:56,126 --> 0:01:57,636
他总是有不同的想法

48
00:01:58,656 --> 0:02:00,866
但是如果你仔细听

49
00:01:58,656 --> 0:02:00,866
但是如果你仔细听

50
00:02:00,866 --> 0:02:03,336
你肯定会学到点东西

51
00:02:03,576 --> 0:02:05,356
有时他会有一些

52
00:02:05,356 --> 0:02:07,666
神奇的表达方式

53
00:02:07,666 --> 0:02:10,156
比如“编程揭示本真”  甚至可以说

54
00:02:10,156 --> 0:02:10,675
有点玄幻了

55
00:02:11,416 --> 0:02:13,576
为了理解他

56
00:02:13,576 --> 0:02:15,096
我发现一种方法很有帮助

57
00:02:15,096 --> 0:02:16,286
那就是写代码

58
00:02:17,526 --> 0:02:18,796
所以最近我在编写

59
00:02:18,796 --> 0:02:20,586
一个叫做《Shapes》的小程序

60
00:02:21,656 --> 0:02:22,906
我希望将它创造成

61
00:02:22,906 --> 0:02:24,216
一个全能矢量绘图程序

62
00:02:24,216 --> 0:02:26,876
但目前为止 它只能让你

63
00:02:26,876 --> 0:02:28,836
在无限画布上排列形状

64
00:02:30,416 --> 0:02:31,376
现在 我想与你们讲一个

65
00:02:31,376 --> 0:02:33,226
关于删除选择指令的故事

66
00:02:33,226 --> 0:02:37,826
因为我从实现这一功能的过程中

67
00:02:37,826 --> 0:02:38,266
学习到了很多

68
00:02:39,596 --> 0:02:41,216
我想我们可能都

69
00:02:41,216 --> 0:02:43,426
经历过这个过程的一部分

70
00:02:43,426 --> 0:02:45,436
作为程序员 我们要学会

71
00:02:45,436 --> 0:02:46,856
如何从数组中删除东西

72
00:02:47,816 --> 0:02:49,106
每一个人都会从

73
00:02:49,106 --> 0:02:51,000
做这种事情开始

74
00:02:53,596 --> 0:02:57,026
刚刚这个就是删除选择指令

75
00:02:58,656 --> 0:03:02,316
我们从 0 开始循环计数

76
00:02:58,656 --> 0:03:02,316
我们从 0 开始循环计数

77
00:03:02,316 --> 0:03:03,326
当我们发现要删除的东西

78
00:03:03,326 --> 0:03:05,126
我们就调用 remove(at: )方法

79
00:03:05,126 --> 0:03:07,546
然后我们就可以继续循环

80
00:03:07,546 --> 0:03:11,846
直到 哦 溢出了

81
00:03:13,366 --> 0:03:14,906
数组会变短

82
00:03:14,906 --> 0:03:16,256
但是当循环开始时

83
00:03:16,256 --> 0:03:17,166
我们选择了固定的迭代次数

84
00:03:17,876 --> 0:03:19,196
幸运的是 如果你使用 Swift 

85
00:03:19,246 --> 0:03:20,796
并测试你的代码 你不可能遗漏这个 Bug

86
00:03:20,826 --> 0:03:23,436
因为程序会产生内中断

87
00:03:23,946 --> 0:03:25,226
但如果你像我一样

88
00:03:25,266 --> 0:03:26,996
是 C 语言出身的程序员

89
00:03:26,996 --> 0:03:28,966
面对这种问题 你可能没那么幸运

90
00:03:29,926 --> 0:03:30,256
好的

91
00:03:30,626 --> 0:03:32,796
我们可以通过将 for 循环替换为

92
00:03:32,796 --> 0:03:34,096
更难看的 while 循环

93
00:03:34,096 --> 0:03:36,346
来修复它 

94
00:03:36,346 --> 0:03:37,516
这可以使我们在每一次迭代中

95
00:03:37,516 --> 0:03:38,096
检查计数

96
00:03:38,646 --> 0:03:42,736
但这里也有一个细微的 Bug

97
00:03:43,956 --> 0:03:46,056
如果两个连续的元素被选中

98
00:03:46,056 --> 0:03:48,706
它将会删除第一个

99
00:03:48,706 --> 0:03:51,916
并且立即

100
00:03:51,916 --> 0:03:54,256
跳过下一个

101
00:03:54,466 --> 0:03:56,956
这个 Bug 更加的阴险

102
00:03:56,956 --> 0:03:58,496
因为它隐藏了起来

103
00:03:58,496 --> 0:04:00,286
除非你的测试碰巧

104
00:03:58,496 --> 0:04:00,286
除非你的测试碰巧

105
00:04:00,286 --> 0:04:02,716
试运行了它

106
00:04:02,946 --> 0:04:04,416
但是如果我们足够幸运注意到了它

107
00:04:04,416 --> 0:04:06,496
我们便可以继续

108
00:04:06,496 --> 0:04:08,826
用一个 else 代码块

109
00:04:08,826 --> 0:04:10,026
来保护自增语句 再次修复

110
00:04:10,026 --> 0:04:10,586
这个实现

111
00:04:11,226 --> 0:04:13,596
那么 我们完成了吗

112
00:04:13,596 --> 0:04:16,476
我们有把握确定 这次是正确的吗

113
00:04:17,706 --> 0:04:19,906
我认为我可以自证

114
00:04:19,995 --> 0:04:20,755
它能够运行

115
00:04:21,875 --> 0:04:24,106
不管怎样 经过这次的严峻的考验

116
00:04:24,106 --> 0:04:25,356
我们收获了什么

117
00:04:25,746 --> 0:04:27,336
当然 我们将这个

118
00:04:27,336 --> 0:04:28,696
九行的代码套路 牢记在脑中

119
00:04:28,696 --> 0:04:30,506
这样我们就可以在想要

120
00:04:30,506 --> 0:04:32,456
删除什么的时候 把它调出来

121
00:04:33,026 --> 0:04:35,666
现在 我确定你们中的许多人

122
00:04:35,666 --> 0:04:36,676
正控制着自己

123
00:04:36,676 --> 0:04:38,566
不向我大声喊叫

124
00:04:38,656 --> 0:04:40,506
因为有一个

125
00:04:40,506 --> 0:04:41,906
更加优雅的方式可以用

126
00:04:41,906 --> 0:04:43,206
我仍然记得 自己发现了

127
00:04:43,206 --> 0:04:44,686
这个技巧的那一天

128
00:04:45,106 --> 0:04:46,666
因为一旦你发现了它 你就不用

129
00:04:46,666 --> 0:04:48,456
再用那九行套路代码了

130
00:04:49,406 --> 0:04:51,496
迭代限制以及

131
00:04:51,556 --> 0:04:52,786
下一个要检查的项的索引

132
00:04:52,786 --> 0:04:54,956
像传送带一样不断滚动

133
00:04:54,956 --> 0:04:56,866
因为 remove(at: i)

134
00:04:57,746 --> 0:04:59,696
改变了数组中 i 之后的部分

135
00:05:00,766 --> 0:05:06,266
但是如果你从后往前检查

136
00:05:06,266 --> 0:05:07,526
你只会迭代数组中

137
00:05:07,526 --> 0:05:08,896
你还没有改变的部分

138
00:05:10,056 --> 0:05:10,776
干得漂亮 对吗

139
00:05:11,456 --> 0:05:12,556
这就是我一直

140
00:05:12,606 --> 0:05:14,916
使用的模式

141
00:05:14,946 --> 0:05:19,476
因为它简洁并且从不失败

142
00:05:20,086 --> 0:05:21,736
直到几个月前

143
00:05:21,736 --> 0:05:24,056
一天早晨 我刚吃完

144
00:05:24,056 --> 0:05:26,216
我的牛油果吐司

145
00:05:26,306 --> 0:05:28,376
并漫不经心地摆弄我的 App

146
00:05:28,376 --> 0:05:29,986
当我尝试从一个非常复杂的画布中

147
00:05:29,986 --> 0:05:31,686
删除差不多一半的图形时

148
00:05:33,016 --> 0:05:35,166
我的 iPad 卡死了

149
00:05:35,526 --> 0:05:36,206
将近 3 秒钟

150
00:05:36,886 --> 0:05:40,586
所以 我喝了一口

151
00:05:40,626 --> 0:05:42,746
装在竹质随行保温杯里的

152
00:05:43,156 --> 0:05:44,716
三倍浓度半因拿铁咖啡压压惊

153
00:05:44,716 --> 0:05:45,936
开始考虑我的对策

154
00:05:47,656 --> 0:05:48,526
这令人十分不安

155
00:05:49,136 --> 0:05:50,006
我的意思是 这是一个

156
00:05:50,006 --> 0:05:51,716
非常简单的操作

157
00:05:51,716 --> 0:05:53,686
我的代码如此简洁

158
00:05:53,686 --> 0:05:54,286
怎么可能出错呢

159
00:05:56,176 --> 0:05:58,256
性能分析结果告诉我

160
00:05:58,256 --> 0:06:01,156
红点就在这 但是除了这个

161
00:05:58,256 --> 0:06:01,156
红点就在这 但是除了这个

162
00:06:01,156 --> 0:06:02,056
我一点头绪都没有

163
00:06:02,706 --> 0:06:05,636
然后 就在这时

164
00:06:05,636 --> 0:06:07,076
Crusty 在我身后经过

165
00:06:07,076 --> 0:06:09,416
拿着一罐从当地超市买的

166
00:06:09,416 --> 0:06:10,796
准备作为日常饮品的

167
00:06:10,796 --> 0:06:11,546
杂牌咖啡

168
00:06:12,936 --> 0:06:15,876
“卡住了？” 他说

169
00:06:16,086 --> 0:06:18,016
“是的” 我叹了口气

170
00:06:18,016 --> 0:06:19,216
并向他解释情况

171
00:06:19,706 --> 0:06:24,556
“那么 你有为此

172
00:06:24,556 --> 0:06:25,796
看过文档吗？”

173
00:06:27,826 --> 0:06:29,916
显然我没有 所以我呼出了

174
00:06:29,916 --> 0:06:31,516
remove(at: ) 的 “Quick Help（快速帮助）”

175
00:06:31,806 --> 0:06:33,526
Crusty 靠近了一点

176
00:06:34,316 --> 0:06:35,856
“你的问题就在这” 

177
00:06:35,856 --> 0:06:38,986
他说 并在我华丽的

178
00:06:38,986 --> 0:06:41,036
视网膜显示屏上留下了一个指纹

179
00:06:42,906 --> 0:06:45,506
我用一块手工制作的

180
00:06:45,546 --> 0:06:47,216
意大利超细纤维布

181
00:06:47,216 --> 0:06:50,596
小心地擦掉了指纹

182
00:06:50,596 --> 0:06:53,386
这时 Crusty 说 “小子

183
00:06:53,996 --> 0:06:54,856
它告诉你了什么”

184
00:06:55,096 --> 0:06:57,516
“唔” 我说 “它说

185
00:06:57,596 --> 0:06:59,056
移除一个元素

186
00:06:59,056 --> 0:07:01,216
需要使用大量的步骤

187
00:06:59,056 --> 0:07:01,216
需要使用大量的步骤

188
00:07:01,216 --> 0:07:02,476
而且与数组的长度成正比”

189
00:07:02,476 --> 0:07:04,456
这的确有些道理

190
00:07:04,456 --> 0:07:06,686
因为数组需要将

191
00:07:06,686 --> 0:07:08,316
之后所有的元素

192
00:07:08,316 --> 0:07:09,186
放入它们的新位置

193
00:07:10,996 --> 0:07:12,466
“那么 这对你的删除选择指令

194
00:07:12,466 --> 0:07:14,996
又有什么意义呢” 他问道

195
00:07:16,166 --> 0:07:17,646
“呃” 我说

196
00:07:18,186 --> 0:07:21,606
就在这时他拿出

197
00:07:21,606 --> 0:07:22,976
一包薄荷糖

198
00:07:22,976 --> 0:07:24,086
然后排成线放在我的桌子上

199
00:07:24,756 --> 0:07:25,596
“你自己试一试”

200
00:07:27,246 --> 0:07:29,216
所以我走完一遍流程

201
00:07:29,216 --> 0:07:30,656
试图回答他的问题

202
00:07:30,896 --> 0:07:32,096
“嗯 既然删除选择指令

203
00:07:32,096 --> 0:07:34,116
需要进行 O(n) 个步骤

204
00:07:34,116 --> 0:07:35,486
每一步都对应每一个已选的元素

205
00:07:35,486 --> 0:07:36,996
而且你可以选择最多 n 个元素

206
00:07:37,276 --> 0:07:38,396
那么总步数将与

207
00:07:38,396 --> 0:07:40,906
n 的二次方成正比”

208
00:07:42,276 --> 0:07:44,356
Crusty 继续说 “那可是二次方

209
00:07:44,356 --> 0:07:46,296
小子 无论你用丑陋的方式正着走

210
00:07:46,296 --> 0:07:48,186
还是穿着花哨的

211
00:07:48,186 --> 0:07:50,346
裤子倒着来”

212
00:07:50,976 --> 0:07:54,106
我那时才意识到

213
00:07:54,106 --> 0:07:56,036
对于我的 10 到 20 个元素的

214
00:07:56,036 --> 0:07:58,006
小型测试案例 我们只需使用

215
00:07:58,006 --> 0:08:00,376
几百个步骤

216
00:07:58,006 --> 0:08:00,376
几百个步骤

217
00:08:00,376 --> 0:08:01,936
由于每一步都运行迅速

218
00:08:02,046 --> 0:08:02,876
一切看起来棒极了

219
00:08:04,116 --> 0:08:05,396
但是问题是

220
00:08:05,396 --> 0:08:06,296
它的延展性不足

221
00:08:06,796 --> 0:08:10,576
50 的二次方是 2500

222
00:08:10,576 --> 0:08:11,986
100 的二次方更能达到 10000

223
00:08:12,546 --> 0:08:15,326
如果你所做的所有测试

224
00:08:15,326 --> 0:08:17,186
都在这个狭小范围之内

225
00:08:17,476 --> 0:08:18,766
那你可能永远发现不了问题

226
00:08:19,336 --> 0:08:21,746
但是延展性很重要

227
00:08:21,746 --> 0:08:23,336
因为人们正在使用他们的手机和 iPad

228
00:08:23,336 --> 0:08:25,626
处理越来越多的数据

229
00:08:25,626 --> 0:08:27,376
我们也一直提供带有

230
00:08:27,376 --> 0:08:29,096
更多存储空间的设备

231
00:08:29,096 --> 0:08:29,586
帮助他们这么做

232
00:08:30,606 --> 0:08:32,346
你们要关心这一点

233
00:08:32,346 --> 0:08:34,476
因为对你们的用户而言

234
00:08:34,476 --> 0:08:35,296
延展性意味着可预测性

235
00:08:35,826 --> 0:08:39,946
所以 我理解了问题所在

236
00:08:39,946 --> 0:08:41,986
但是我仍然不能确定

237
00:08:41,986 --> 0:08:42,746
我应该怎么解决它

238
00:08:43,326 --> 0:08:43,706
“现在我该怎么办？”

239
00:08:43,706 --> 0:08:44,446
我问 Crusty

240
00:08:45,526 --> 0:08:47,056
“你知道吗 小伙子” 他一边说

241
00:08:47,496 --> 0:08:49,776
一边把一粒薄荷糖放到嘴里

242
00:08:49,776 --> 0:08:51,466
“有一个解决这个问题的算法”

243
00:08:53,056 --> 0:08:56,236
我和他说 “听着 Crusty

244
00:08:56,236 --> 0:08:57,176
我是一个 App 开发者

245
00:08:58,226 --> 0:09:00,716
你说过你不做面向对象的东西

246
00:08:58,226 --> 0:09:00,716
你说过你不做面向对象的东西

247
00:09:00,716 --> 0:09:02,646
同样 我也不做算法

248
00:09:03,276 --> 0:09:04,406
你关注在算法类中的

249
00:09:04,406 --> 0:09:06,066
数据结构

250
00:09:06,396 --> 0:09:08,036
因为你知道

251
00:09:08,036 --> 0:09:09,806
找工作的时候

252
00:09:09,806 --> 0:09:10,946
你的面试官会考你

253
00:09:11,346 --> 0:09:12,776
但在真正的编程世界

254
00:09:12,776 --> 0:09:14,766
区分大神和菜鸟的关键

255
00:09:14,926 --> 0:09:16,946
是将控制器 委托

256
00:09:16,946 --> 0:09:18,396
以及响应程序

257
00:09:18,396 --> 0:09:19,766
连接在一起

258
00:09:19,766 --> 0:09:22,546
构建一个工作系统的能力”

259
00:09:22,996 --> 0:09:24,906
“豆包” 他说 

260
00:09:24,906 --> 0:09:27,276
我不知道为什么他这么称呼我

261
00:09:27,506 --> 0:09:28,656
“计算机是做什么的”

262
00:09:30,096 --> 0:09:30,816
“它们计算”

263
00:09:31,796 --> 0:09:33,086
“那么 你的代码中的计算

264
00:09:33,086 --> 0:09:34,286
在哪里呢”

265
00:09:35,356 --> 0:09:37,966
“好吧” 我回答 

266
00:09:37,966 --> 0:09:39,106
“我想在我的代码里

267
00:09:39,106 --> 0:09:40,496
我看不见什么东西像个算法”

268
00:09:41,046 --> 0:09:43,296
但是 Crusty 不这么认为

269
00:09:43,806 --> 0:09:45,106
“哦 你的 App 里面可全都是算法”

270
00:09:45,106 --> 0:09:46,646
他说 接着将一本破旧的字典

271
00:09:46,646 --> 0:09:47,956
扔在我的桌子上

272
00:09:48,526 --> 0:09:50,496
“翻翻看”

273
00:09:51,266 --> 0:09:54,066
在我镇定下来后

274
00:09:54,066 --> 0:09:55,396
我小心地将书移到一边

275
00:09:55,396 --> 0:09:57,226
在聚焦搜索栏中输入

276
00:09:57,226 --> 0:09:58,886
“define: Algorithm (定义：算法)”

277
00:09:58,886 --> 0:10:00,000
Crusty 认为这是个巧妙的技巧

278
00:10:03,976 --> 0:10:04,976
嗯

279
00:10:05,046 --> 0:10:06,876
在计算或其他解决问题的

280
00:10:06,876 --> 0:10:08,656
运算中

281
00:10:08,656 --> 0:10:10,416
要遵循的过程或规则集

282
00:10:11,756 --> 0:10:13,356
好吧 细想一下

283
00:10:13,806 --> 0:10:16,016
这听起来像大多数的代码

284
00:10:16,016 --> 0:10:16,906
但是我仍不能确定

285
00:10:18,036 --> 0:10:19,446
“你有做过长除法吗”

286
00:10:19,596 --> 0:10:20,236
Crusty 问道

287
00:10:20,646 --> 0:10:21,576
“那就是一个算法”

288
00:10:25,766 --> 0:10:27,606
我又开始将它打到聚焦搜索中

289
00:10:27,606 --> 0:10:29,266
但是他突然说

290
00:10:29,266 --> 0:10:29,646
“在纸上算”

291
00:10:30,306 --> 0:10:31,616
不想让自己难堪

292
00:10:31,616 --> 0:10:32,746
我把话题转回到

293
00:10:32,746 --> 0:10:33,476
我的代码上

294
00:10:35,316 --> 0:10:35,386
“嗯”

295
00:10:36,256 --> 0:10:39,926
我问 “所以 这个可以解决

296
00:10:39,926 --> 0:10:41,666
我的代码性能问题的

297
00:10:41,666 --> 0:10:42,856
神奇的算法是什么呢”

298
00:10:44,126 --> 0:10:45,496
“那么 如果你愿意

299
00:10:45,496 --> 0:10:46,976
让我用一下你的打字机”

300
00:10:46,976 --> 0:10:48,626
他说 “这个东西怎么用

301
00:10:48,626 --> 0:10:49,816
哦 这是一个触控板

302
00:10:49,816 --> 0:10:50,826
我会尽量不碰它

303
00:10:51,226 --> 0:10:53,356
所以首先 你要删掉这些

304
00:10:53,356 --> 0:10:54,330
愚蠢的代码

305
00:10:57,046 --> 0:11:00,676
然后 shapes.removeAll

306
00:10:57,046 --> 0:11:00,676
然后 shapes.removeAll

307
00:11:00,676 --> 0:11:02,186
(where: { $0.isSelected})

308
00:11:03,146 --> 0:11:03,326
嗯

309
00:11:04,026 --> 0:11:05,236
试试合不合身”

310
00:11:06,216 --> 0:11:07,756
然后 Crusty 离开了

311
00:11:07,756 --> 0:11:08,856
去洗他的咖啡机的拉花缸

312
00:11:08,856 --> 0:11:11,066
留下我去琢磨

313
00:11:11,066 --> 0:11:12,816
我的代码里到底

314
00:11:13,666 --> 0:11:13,766
发生了什么

315
00:11:14,736 --> 0:11:17,756
首先 我检查过并且发现

316
00:11:17,756 --> 0:11:19,286
性能问题确实解决了

317
00:11:19,856 --> 0:11:20,226
太棒了

318
00:11:21,536 --> 0:11:22,886
我不想再听一遍

319
00:11:22,886 --> 0:11:24,226
Crusty 唠叨说看文档

320
00:11:24,226 --> 0:11:26,626
所以我弹出 removeAll(where: ) 的

321
00:11:26,626 --> 0:11:28,126
“Quick Help”

322
00:11:28,676 --> 0:11:32,856
然后我发现它的复杂度

323
00:11:32,856 --> 0:11:34,266
也与集合的长度

324
00:11:34,266 --> 0:11:36,176
成正地变化

325
00:11:36,176 --> 0:11:36,806
就像 removeAt 一样

326
00:11:37,796 --> 0:11:39,656
但是由于我不必

327
00:11:39,656 --> 0:11:41,576
把它放入循环中

328
00:11:41,576 --> 0:11:42,836
那么它就变成了我整个

329
00:11:42,836 --> 0:11:43,376
运算的复杂度

330
00:11:44,576 --> 0:11:46,776
现在 我想让你们

331
00:11:46,776 --> 0:11:48,026
直观地理解

332
00:11:48,106 --> 0:11:50,106
这能带来什么不同

333
00:11:50,566 --> 0:11:52,476
O(n) 表示算法运行的时间

334
00:11:52,476 --> 0:11:54,216
与问题的大小

335
00:11:54,566 --> 0:11:56,166
成线性关系

336
00:11:56,696 --> 0:11:57,936
这个图是一条直线

337
00:11:59,396 --> 0:12:00,826
然后 这个橙色线是

338
00:11:59,396 --> 0:12:00,826
然后 这个橙色线是

339
00:12:00,826 --> 0:12:02,076
n 的二次方的形状

340
00:12:03,356 --> 0:12:04,846
正如你所见

341
00:12:04,846 --> 0:12:06,406
线性算法也许在小型问题中

342
00:12:06,406 --> 0:12:07,956
表现稍差

343
00:12:07,956 --> 0:12:09,596
但他最终比

344
00:12:09,596 --> 0:12:10,606
二次方算法运行更快

345
00:12:11,926 --> 0:12:13,716
很棒的是

346
00:12:13,716 --> 0:12:15,546
不管你用线性算法

347
00:12:15,546 --> 0:12:16,856
的成本有多高

348
00:12:16,856 --> 0:12:19,226
如果你继续放更大的问题尺寸

349
00:12:19,226 --> 0:12:22,456
你总是会找到

350
00:12:22,566 --> 0:12:24,736
一个线性算法会赢

351
00:12:24,736 --> 0:12:27,206
并且在后面

352
00:12:27,206 --> 0:12:28,206
一直赢的点

353
00:12:29,346 --> 0:12:30,506
所以 我们正在讨论的是

354
00:12:30,506 --> 0:12:33,000
延展性 而不是绝对的性能

355
00:12:36,436 --> 0:12:40,346
好了 我的延展性问题终于解决了

356
00:12:40,346 --> 0:12:42,316
但我真的很想看看

357
00:12:42,316 --> 0:12:44,196
标准程序库如何改进

358
00:12:44,196 --> 0:12:46,616
我倒着来的删除方法

359
00:12:47,886 --> 0:12:49,586
Crusty 提醒我说

360
00:12:49,586 --> 0:12:50,986
Swift 是开放源码 所以我可以把它

361
00:12:50,986 --> 0:12:53,426
放在他口中的“嬉皮士网”上

362
00:12:53,816 --> 0:12:55,500
也就是我们其他人所知的 GitHub

363
00:12:59,266 --> 0:13:00,776
现在 我注意到的第一件事

364
00:12:59,266 --> 0:13:00,776
现在 我注意到的第一件事

365
00:13:00,776 --> 0:13:03,106
便是点注释

366
00:13:03,136 --> 0:13:04,456
它是所有 “Quick Help” 的来源

367
00:13:04,456 --> 0:13:09,136
描述了算法的功能以及复杂度

368
00:13:09,596 --> 0:13:14,046
接下来 结果是

369
00:13:14,046 --> 0:13:15,946
removeAll(where) 不是什么

370
00:13:15,946 --> 0:13:18,486
常规的方法

371
00:13:18,486 --> 0:13:20,466
它是一个通用的算法

372
00:13:20,466 --> 0:13:22,126
这意味着

373
00:13:22,126 --> 0:13:22,926
它可以在各种不同的集合上运行

374
00:13:24,286 --> 0:13:25,296
这取决于很多因素

375
00:13:25,296 --> 0:13:28,376
重新排列元素的能力

376
00:13:28,376 --> 0:13:29,556
它来自于

377
00:13:29,556 --> 0:13:31,636
MutableCollection

378
00:13:31,966 --> 0:13:34,626
改变长度和结构的能力

379
00:13:34,626 --> 0:13:36,506
它来自于

380
00:13:36,506 --> 0:13:37,656
RangeReplaceableCollection

381
00:13:38,186 --> 0:13:41,606
它是由一些其他的

382
00:13:41,606 --> 0:13:43,206
O(n) 算法构成的

383
00:13:44,016 --> 0:13:46,126
第一个是 halfStablePartition

384
00:13:46,126 --> 0:13:48,096
它将所有

385
00:13:48,096 --> 0:13:49,416
满足某些谓词的元素

386
00:13:49,416 --> 0:13:53,456
移动到末尾

387
00:13:53,456 --> 0:13:54,846
并告诉我们后缀从哪里开始

388
00:13:56,136 --> 0:13:57,786
halfStable 正如其名

389
00:13:58,186 --> 0:14:00,196
表明了

390
00:13:58,186 --> 0:14:00,196
表明了

391
00:14:00,196 --> 0:14:02,116
它保留了不移动的

392
00:14:02,116 --> 0:14:03,646
元素的顺序

393
00:14:04,486 --> 0:14:06,396
但是它也可以打乱

394
00:14:06,436 --> 0:14:09,026
移动到最后的元素

395
00:14:09,206 --> 0:14:10,426
有些时候

396
00:14:10,426 --> 0:14:11,786
这不是很重要

397
00:14:11,786 --> 0:14:13,166
因为第二个算法 removeSubrange()

398
00:14:13,166 --> 0:14:14,146
无论如何也会

399
00:14:14,146 --> 0:14:14,456
删除子区间

400
00:14:16,476 --> 0:14:17,956
我们都见过这个

401
00:14:17,956 --> 0:14:18,696
部分区间的标记吗

402
00:14:19,256 --> 0:14:21,426
它是一种非常方便的

403
00:14:21,426 --> 0:14:22,656
方式来编写扩展到

404
00:14:22,656 --> 0:14:24,000
集合末尾的范围

405
00:14:26,896 --> 0:14:27,116
好的

406
00:14:27,846 --> 0:14:29,986
现在 removeSubrange 是

407
00:14:29,986 --> 0:14:31,826
库全局 API 的一部分

408
00:14:31,826 --> 0:14:33,496
因此你可以在网上找到它的文档

409
00:14:33,496 --> 0:14:36,276
但是 halfStablePartition

410
00:14:36,456 --> 0:14:37,696
是一个运行的细节

411
00:14:38,236 --> 0:14:42,166
现在 我们不打算

412
00:14:42,166 --> 0:14:43,556
一一介绍 但是这里有一些

413
00:14:43,556 --> 0:14:45,116
值得注意的地方

414
00:14:46,516 --> 0:14:48,846
首先 它一开始

415
00:14:48,846 --> 0:14:49,696
调用另一个算法

416
00:14:50,486 --> 0:14:52,596
firstIndex(where: )

417
00:14:52,856 --> 0:14:54,716
来查找属于后缀的

418
00:14:54,716 --> 0:14:55,796
第一个元素的位置

419
00:14:57,176 --> 0:14:58,766
接下来 它设置了一个循环变量 j

420
00:14:58,766 --> 0:15:01,126
有一个循环

421
00:14:58,766 --> 0:15:01,126
有一个循环

422
00:15:01,616 --> 0:15:04,906
然后这个循环指数 j 在每次迭代中

423
00:15:05,046 --> 0:15:06,646
会从前向后移动一位

424
00:15:07,696 --> 0:15:09,196
所以 可以肯定的是

425
00:15:09,196 --> 0:15:10,716
j 只对元素进行了一次传递

426
00:15:11,116 --> 0:15:14,086
你几乎可以从这里看到

427
00:15:14,086 --> 0:15:20,306
量级和复杂度

428
00:15:20,516 --> 0:15:22,106
最后 由于该方法

429
00:15:22,106 --> 0:15:23,526
需要重新排列元素

430
00:15:23,526 --> 0:15:24,726
但不更改

431
00:15:24,726 --> 0:15:26,396
集合的长度或结构 

432
00:15:26,396 --> 0:15:27,506
因此它只依赖于对

433
00:15:27,506 --> 0:15:28,606
MutableCollection 的遵循

434
00:15:29,146 --> 0:15:32,676
所以 这就是我学到的第一堂课

435
00:15:33,686 --> 0:15:34,966
熟悉 Swift

436
00:15:34,966 --> 0:15:36,166
标准库中的内容

437
00:15:37,176 --> 0:15:38,606
它包含一组

438
00:15:38,606 --> 0:15:40,416
提供文档描述

439
00:15:40,416 --> 0:15:42,316
和性能特征的算法

440
00:15:43,406 --> 0:15:45,526
虽然我们看了一点执行过程

441
00:15:45,526 --> 0:15:47,416
你也可以从中学到很多东西

442
00:15:47,416 --> 0:15:49,126
但由于它是设计好的

443
00:15:49,156 --> 0:15:50,946
所以你不必用我之前的笨方法

444
00:15:52,426 --> 0:15:53,756
官方文档会告诉你

445
00:15:53,756 --> 0:15:55,046
需要知道的一切

446
00:15:55,046 --> 0:15:58,006
以便有效地使用该库

447
00:15:58,996 --> 0:16:00,126
你甚至可以在那找到

448
00:15:58,996 --> 0:16:00,126
你甚至可以在那找到

449
00:16:00,126 --> 0:16:00,846
一个 Playground 教程

450
00:16:01,906 --> 0:16:03,856
我知道 Swift 中有很多内容

451
00:16:03,856 --> 0:16:05,436
所以它的确可能看起来很吓人

452
00:16:06,196 --> 0:16:07,706
但是你不需要记住一切

453
00:16:08,696 --> 0:16:10,066
知道那里有什么

454
00:16:10,066 --> 0:16:12,156
以及如何找到它将

455
00:16:12,156 --> 0:16:13,326
为你省下很多精力

456
00:16:14,396 --> 0:16:16,466
现在 在我们继续之前

457
00:16:16,466 --> 0:16:18,326
我想指出

458
00:16:18,326 --> 0:16:19,576
当 Crusty 做出此更改时

459
00:16:19,576 --> 0:16:20,276
在代码中发生的其他事情

460
00:16:21,136 --> 0:16:22,816
这两个中哪一个最直接地

461
00:16:22,816 --> 0:16:23,776
描述了它的意义

462
00:16:24,346 --> 0:16:27,166
现在 我必须先通读

463
00:16:27,226 --> 0:16:28,406
并思考第一个

464
00:16:28,406 --> 0:16:29,216
才能知道它在做什么

465
00:16:30,086 --> 0:16:30,376
嗯

466
00:16:30,616 --> 0:16:31,836
也许我最好加个注释

467
00:16:32,806 --> 0:16:33,026
好的

468
00:16:33,026 --> 0:16:33,646
看起来怎么样

469
00:16:34,196 --> 0:16:35,836
哦 即使有了评论

470
00:16:35,836 --> 0:16:37,156
反向迭代仍旧有点棘手

471
00:16:37,156 --> 0:16:38,356
而且我也不想

472
00:16:38,356 --> 0:16:40,826
有人因为他们不理解而破坏

473
00:16:40,826 --> 0:16:40,946
这个代码

474
00:16:41,266 --> 0:16:45,046
所以我最好解释一下

475
00:16:45,256 --> 0:16:45,726
好的

476
00:16:46,126 --> 0:16:47,596
当我们一一澄清时

477
00:16:47,656 --> 0:16:49,866
Crusty 改过的代码实际上更好理解

478
00:16:49,866 --> 0:16:50,956
因为它有一个

479
00:16:50,956 --> 0:16:51,606
尾随闭包语法

480
00:16:51,966 --> 0:16:54,896
现在 让我们深呼吸

481
00:16:54,896 --> 0:16:55,196
然后再看

482
00:16:56,606 --> 0:16:58,346
哪一个更明显是正确的

483
00:16:59,526 --> 0:17:00,956
即使带有这些评论

484
00:16:59,526 --> 0:17:00,956
即使带有这些评论

485
00:17:00,956 --> 0:17:02,016
我仍然需要通读第一个

486
00:17:02,016 --> 0:17:03,936
去明白它其实和第二个

487
00:17:03,936 --> 0:17:05,886
做的是同样的事

488
00:17:05,955 --> 0:17:06,976
但是效率更低

489
00:17:08,056 --> 0:17:09,465
使用这个算法可以使代码

490
00:17:09,465 --> 0:17:10,955
在各个方面都做得更好

491
00:17:11,526 --> 0:17:15,356
所以 这是你的代码的

492
00:17:15,356 --> 0:17:16,955
一个准则 也是一个目标

493
00:17:16,986 --> 0:17:18,486
是由 Sean Parent 首先提出的

494
00:17:19,636 --> 0:17:20,836
每当你编写一个循环时

495
00:17:21,316 --> 0:17:22,526
就用对某个算法的调用

496
00:17:22,526 --> 0:17:23,046
来替换它

497
00:17:23,846 --> 0:17:25,955
如果你找不到对应的算法

498
00:17:25,955 --> 0:17:27,366
就自己做一个算法

499
00:17:27,366 --> 0:17:28,656
然后用这个算法来执行循环

500
00:17:30,656 --> 0:17:32,496
实际上 现在对你来说

501
00:17:32,496 --> 0:17:34,156
这似乎是不现实的

502
00:17:34,196 --> 0:17:36,166
但是在谈话的最后

503
00:17:36,516 --> 0:17:37,056
我希望它不再是这样

504
00:17:38,096 --> 0:17:39,356
不过为了获得一点动力

505
00:17:39,856 --> 0:17:42,246
回想一下上一次

506
00:17:42,246 --> 0:17:43,536
你看到乱得像面条一样的代码的时候

507
00:17:44,066 --> 0:17:46,296
是不是充满了循环

508
00:17:47,506 --> 0:17:50,276
我打赌一定是

509
00:17:50,766 --> 0:17:51,236
好吧

510
00:17:51,386 --> 0:17:52,286
大功告成

511
00:17:52,506 --> 0:17:53,666
我已经使代码

512
00:17:53,666 --> 0:17:56,066
变得更短 更快 

513
00:17:56,066 --> 0:17:56,686
在各个方面都更好

514
00:17:56,686 --> 0:17:58,726
我准备今天到此为止

515
00:17:59,376 --> 0:18:00,546
“感谢你的帮助 Crusty”

516
00:17:59,376 --> 0:18:00,546
“感谢你的帮助 Crusty”

517
00:18:00,546 --> 0:18:02,576
我说 同时系上

518
00:18:02,576 --> 0:18:05,036
我定制的皮革邮差包上的钛制钩环

519
00:18:05,036 --> 0:18:07,336
但他怀疑地看着我

520
00:18:07,336 --> 0:18:09,586
然后说

521
00:18:09,586 --> 0:18:10,966
“你不认为你可能在别的地方

522
00:18:10,966 --> 0:18:12,330
犯过那样的错误吗”

523
00:18:14,166 --> 0:18:16,746
我叹了口气 把包放下

524
00:18:16,746 --> 0:18:18,746
开始追踪我代码中的循环

525
00:18:20,016 --> 0:18:21,786
然后我发现 在处理层级命令的

526
00:18:22,106 --> 0:18:24,106
文件中 有很多

527
00:18:24,426 --> 0:18:28,666
放到最前 放到最后

528
00:18:29,596 --> 0:18:31,126
向前移动一层

529
00:18:31,126 --> 0:18:32,686
也就是把选定的图形移到

530
00:18:32,686 --> 0:18:33,486
前面的图形上

531
00:18:34,746 --> 0:18:38,206
让我们来多做几次吧

532
00:18:38,406 --> 0:18:40,536
向后移动

533
00:18:40,536 --> 0:18:41,756
放在选定的图形下面

534
00:18:41,756 --> 0:18:45,486
最后

535
00:18:45,486 --> 0:18:49,776
在左边的图形列表中拖拽

536
00:18:49,776 --> 0:18:52,196
现在 这些操作听起来非常简单

537
00:18:52,746 --> 0:18:56,126
直到你意识到

538
00:18:56,126 --> 0:18:57,566
它们都需要对多个选定的图形进行操作

539
00:18:57,566 --> 0:18:59,096
这些图形在列表中

540
00:18:59,096 --> 0:19:01,316
甚至可能都不是连续的

541
00:18:59,096 --> 0:19:01,316
甚至可能都不是连续的

542
00:19:05,226 --> 0:19:06,486
因此结果表明 

543
00:19:06,486 --> 0:19:07,906
在操作完成后

544
00:19:07,906 --> 0:19:09,166
将所有选定的元素

545
00:19:09,166 --> 0:19:10,826
放在一起

546
00:19:10,826 --> 0:19:12,126
才是有意义的

547
00:19:13,126 --> 0:19:14,176
所以 当你把图形向前移动时

548
00:19:14,176 --> 0:19:15,596
你把选定的最前面的图形

549
00:19:15,596 --> 0:19:17,136
放在紧邻它的图形前面

550
00:19:17,136 --> 0:19:18,936
然后你把所有其他的图形

551
00:19:18,936 --> 0:19:20,566
放在它后面

552
00:19:22,386 --> 0:19:23,736
当你向后移动图形时

553
00:19:23,776 --> 0:19:25,496
你把选定的最后面的图形

554
00:19:25,496 --> 0:19:26,926
放在紧邻它的图形后面

555
00:19:26,926 --> 0:19:28,396
然后把其他的图形

556
00:19:28,396 --> 0:19:30,366
放在它前面

557
00:19:33,756 --> 0:19:36,256
如果你没有完全跟上

558
00:19:36,256 --> 0:19:37,626
不要担心

559
00:19:37,626 --> 0:19:38,526
我们会回头再讲

560
00:19:38,856 --> 0:19:41,386
但我只想说

561
00:19:41,386 --> 0:19:42,836
我有一些精心设计的代码

562
00:19:42,836 --> 0:19:44,606
来正确地处理所有这些细节 就足够了

563
00:19:45,866 --> 0:19:47,996
例如 这是 bringToFront()

564
00:19:47,996 --> 0:19:51,256
当我看到它时

565
00:19:51,256 --> 0:19:53,656
我十分地确定

566
00:19:53,656 --> 0:19:55,366
这些图形有一个 O(n) 的循环

567
00:19:55,956 --> 0:19:57,716
还包含两个 O(n) 的运算

568
00:19:57,716 --> 0:20:00,186
remove(at:)  insert(at:)

569
00:19:57,716 --> 0:20:00,186
remove(at:)  insert(at:)

570
00:20:00,186 --> 0:20:02,756
这就产生了

571
00:20:03,246 --> 0:20:04,786
没错 n 的二次方

572
00:20:06,246 --> 0:20:08,526
事实上 同样的问题

573
00:20:08,526 --> 0:20:10,076
出现在每一个

574
00:20:10,076 --> 0:20:11,076
我其他的四个命令中

575
00:20:12,516 --> 0:20:14,046
这里的所有执行

576
00:20:14,386 --> 0:20:16,196
都对数组进行循环

577
00:20:16,196 --> 0:20:17,936
执行插入和删除操作

578
00:20:17,936 --> 0:20:19,126
这意味着它们都是二次的

579
00:20:19,626 --> 0:20:23,096
现在 我有点气馁

580
00:20:23,096 --> 0:20:24,996
所以我问 Crusty

581
00:20:24,996 --> 0:20:26,106
他是否愿意和我一起看

582
00:20:27,406 --> 0:20:29,106
他说 “我不能待太晚”

583
00:20:29,186 --> 0:20:31,156
他说 “我今晚有一个

584
00:20:31,156 --> 0:20:33,096
交际舞聚会 但是我想

585
00:20:33,226 --> 0:20:34,546
我们还是抓紧继续吧”

586
00:20:35,306 --> 0:20:37,486
我在 bringToFront() 这里停下来

587
00:20:38,686 --> 0:20:40,946
Crusty 的第一个问题是

588
00:20:42,156 --> 0:20:44,546
“它到底是做什么的”

589
00:20:45,846 --> 0:20:47,566
“好吧” 我说 “这是个 while 循环

590
00:20:47,566 --> 0:20:49,426
j 跟踪插入点

591
00:20:49,426 --> 0:20:51,266
i 跟踪我们正在

592
00:20:51,266 --> 0:20:51,906
查看的元素

593
00:20:52,226 --> 0:20:54,216
“用语言 而不是用代码”

594
00:20:54,246 --> 0:20:57,126
Crusty 说“描述它”

595
00:20:58,146 --> 0:20:59,286
“好吧 我们来看看

596
00:20:59,776 --> 0:21:01,616
它将选定的图形移动到前面

597
00:20:59,776 --> 0:21:01,616
它将选定的图形移动到前面

598
00:21:01,616 --> 0:21:04,176
保持它们的相对顺序”

599
00:21:04,706 --> 0:21:07,136
“把它写在点注释上

600
00:21:07,136 --> 0:21:08,376
然后读给我听”

601
00:21:10,406 --> 0:21:13,146
我是一个手速超快的打字员

602
00:21:15,236 --> 0:21:17,416
“将选定的图形移动到前面

603
00:21:17,416 --> 0:21:19,286
保持它们的相对顺序”

604
00:21:19,706 --> 0:21:21,766
“听起来熟悉吗”

605
00:21:22,186 --> 0:21:22,796
Crusty 说

606
00:21:24,066 --> 0:21:25,276
就在那时我意识到

607
00:21:25,276 --> 0:21:26,736
它很像 halfStablePartition

608
00:21:26,766 --> 0:21:29,676
但它是完全稳定的

609
00:21:29,676 --> 0:21:32,046
我开始激动起来

610
00:21:32,556 --> 0:21:34,226
“你觉得这个叫什么”

611
00:21:34,906 --> 0:21:36,516
我不得不猜

612
00:21:36,516 --> 0:21:37,026
“stablePartition”

613
00:21:37,566 --> 0:21:38,346
“没错

614
00:21:38,536 --> 0:21:41,126
我最喜欢的一个

615
00:21:41,126 --> 0:21:42,426
你可以在这个 Swift 开源项目中

616
00:21:42,426 --> 0:21:43,946
找到一个

617
00:21:43,946 --> 0:21:45,486
执行文件”

618
00:21:46,356 --> 0:21:48,396
因此 我把文件拖进了我的项目中

619
00:21:48,396 --> 0:21:50,006
同时 Crusty 含糊地说

620
00:21:50,006 --> 0:21:51,266
我们添加的注释

621
00:21:51,266 --> 0:21:52,206
应该在一开始就写上

622
00:21:52,206 --> 0:21:55,756
我开始编写代码

623
00:21:56,936 --> 0:22:00,196
写了这么多 就又遇到了一个问题

624
00:21:56,936 --> 0:22:00,196
写了这么多 就又遇到了一个问题

625
00:22:01,666 --> 0:22:03,716
你看 stablePartition 使用了一个谓词

626
00:22:03,716 --> 0:22:06,306
它表示是否将元素

627
00:22:06,306 --> 0:22:09,126
移动到集合的后缀中

628
00:22:09,946 --> 0:22:11,326
所以 要把东西搬到后面

629
00:22:11,516 --> 0:22:13,496
我需要执行

630
00:22:13,496 --> 0:22:14,046
bringToFront()

631
00:22:15,406 --> 0:22:16,256
我看向 Crusty

632
00:22:17,276 --> 0:22:19,286
“脑补一下” 他说

633
00:22:20,286 --> 0:22:21,986
于是 我闭上眼睛

634
00:22:22,646 --> 0:22:24,176
看着那些未被选中的图形

635
00:22:24,176 --> 0:22:25,936
聚集在后面

636
00:22:25,936 --> 0:22:26,616
这就给了我答案

637
00:22:27,226 --> 0:22:31,096
我猜 sendToBack 会更加简单

638
00:22:31,096 --> 0:22:32,436
因为我们只需

639
00:22:32,436 --> 0:22:33,276
反转谓词

640
00:22:33,836 --> 0:22:34,996
我们将选定的图形

641
00:22:35,056 --> 0:22:38,126
移动到后面

642
00:22:38,346 --> 0:22:40,566
现在 我正准备执行

643
00:22:40,566 --> 0:22:42,476
向前移动的命令

644
00:22:42,476 --> 0:22:43,986
我想 Crusty 会和我一样

645
00:22:43,986 --> 0:22:46,346
急于继续

646
00:22:46,346 --> 0:22:47,436
考虑到他晚上的计划

647
00:22:47,756 --> 0:22:48,376
但他阻止了我

648
00:22:49,296 --> 0:22:50,446
“刹车 Snuffy

649
00:22:51,616 --> 0:22:52,856
我不想错过开场探戈

650
00:22:52,856 --> 0:22:54,676
但你不打算看看

651
00:22:54,676 --> 0:22:55,926
它能不能延展尺寸吗”

652
00:22:57,326 --> 0:22:59,776
他有道理 所以我弹出 stablePartition 的

653
00:22:59,776 --> 0:23:00,766
“Quick Help”

654
00:22:59,776 --> 0:23:00,766
“Quick Help”

655
00:23:00,806 --> 0:23:04,196
然后看到它的复杂度

656
00:23:04,416 --> 0:23:06,046
是 O(n log n) 

657
00:23:06,606 --> 0:23:09,356
为了有一个 O(n log n) 的概念

658
00:23:09,356 --> 0:23:11,506
我们不妨看看 O(log n)

659
00:23:12,096 --> 0:23:15,236
它从开始很快就进入

660
00:23:15,236 --> 0:23:17,246
平稳状态 n 越大

661
00:23:17,496 --> 0:23:19,856
它增长的越慢

662
00:23:19,886 --> 0:23:21,716
越接近一个常数

663
00:23:22,526 --> 0:23:24,136
所以当你乘 n 时

664
00:23:24,136 --> 0:23:27,366
你所得到延展性图像

665
00:23:27,566 --> 0:23:29,376
与 O(n) 的并不同

666
00:23:29,876 --> 0:23:31,466
但是随着它的增长它

667
00:23:31,466 --> 0:23:32,946
越来越接近线性

668
00:23:34,146 --> 0:23:36,696
所以 O(n log n) 

669
00:23:36,696 --> 0:23:38,556
通常被认为

670
00:23:38,556 --> 0:23:40,066
和 O(n) 差不多

671
00:23:40,896 --> 0:23:42,296
我对此十分开心

672
00:23:43,056 --> 0:23:44,326
所以我们继续处理

673
00:23:44,326 --> 0:23:44,696
bringFoward()

674
00:23:45,246 --> 0:23:49,646
现在 就像我们之前说过的

675
00:23:49,726 --> 0:23:51,626
bringFoward() 将最前面选定的图形

676
00:23:51,626 --> 0:23:53,006
向前移动一层

677
00:23:53,006 --> 0:23:55,296
并将后面的其他

678
00:23:55,296 --> 0:23:56,576
被选定的图形聚集起来

679
00:23:57,876 --> 0:24:00,156
但是 Crusty 根本不喜欢

680
00:23:57,876 --> 0:24:00,156
但是 Crusty 根本不喜欢

681
00:24:00,156 --> 0:24:01,506
这种思考方法

682
00:24:02,146 --> 0:24:03,396
“刚开始的时候

683
00:24:03,396 --> 0:24:05,026
那个绕来绕去的东西 让那行代码

684
00:24:05,026 --> 0:24:06,096
像是在跳狐步舞狐步舞”

685
00:24:06,356 --> 0:24:08,466
他说 “你并不需要它”

686
00:24:09,096 --> 0:24:10,906
当我茫然地看着他的时候

687
00:24:10,906 --> 0:24:12,206
他又拿出了薄荷糖

688
00:24:13,976 --> 0:24:15,616
用他五根灵活的手指

689
00:24:15,616 --> 0:24:17,836
执行了

690
00:24:17,836 --> 0:24:19,926
bringForward() 指令

691
00:24:22,556 --> 0:24:23,506
“看到了吗”

692
00:24:23,776 --> 0:24:24,226
他问

693
00:24:25,416 --> 0:24:26,816
我感觉就像 明知道“赌徒三张”是一个陷阱

694
00:24:26,816 --> 0:24:33,976
但我还是踩了进去

695
00:24:34,256 --> 0:24:35,176
“看着熟悉吗”

696
00:24:36,336 --> 0:24:36,616
“不”

697
00:24:37,826 --> 0:24:40,006
他用手帕盖住了前几个

698
00:24:42,296 --> 0:24:46,366
“现在呢”

699
00:24:46,636 --> 0:24:48,876
就在这时我意识到

700
00:24:48,876 --> 0:24:50,226
这就是另一个 stablePartition

701
00:24:51,416 --> 0:24:51,766
好吧

702
00:24:52,236 --> 0:24:54,046
我明白了 我想

703
00:24:55,856 --> 0:24:58,096
如果我们找到选定的

704
00:24:58,096 --> 0:25:01,716
最前面的图形

705
00:24:58,096 --> 0:25:01,716
最前面的图形

706
00:25:01,746 --> 0:25:05,326
然后移动到它前面图形的位置

707
00:25:05,606 --> 0:25:07,086
并隔离从那里开始的数组的部分

708
00:25:07,086 --> 0:25:10,666
我们可以对它进行分区

709
00:25:12,236 --> 0:25:14,166
“但是，你如何只修改

710
00:25:14,166 --> 0:25:14,776
集合中的一部分呢”

711
00:25:14,976 --> 0:25:15,676
我问 Crusty

712
00:25:16,876 --> 0:25:18,296
“你难道没听说过切片吗”

713
00:25:18,526 --> 0:25:19,946
他说 同时接管了键盘

714
00:25:23,156 --> 0:25:25,106
“shapes

715
00:25:25,726 --> 0:25:26,336
[predecessor...]

716
00:25:27,656 --> 0:25:28,256
好了

717
00:25:28,256 --> 0:25:29,596
把它放在你的算法里

718
00:25:29,596 --> 0:25:30,146
然后进行变换”

719
00:25:30,896 --> 0:25:32,000
我立即照做

720
00:25:37,716 --> 0:25:41,456
因此 人类关于如何

721
00:25:41,456 --> 0:25:43,096
正确有效地

722
00:25:43,096 --> 0:25:44,976
计算事物的知识

723
00:25:44,976 --> 0:25:47,156
要比计算机早几千年

724
00:25:47,156 --> 0:25:48,846
至少可以追溯到古埃及

725
00:25:49,546 --> 0:25:50,656
自从计算机发明以来

726
00:25:50,656 --> 0:25:52,086
这一领域的工作

727
00:25:52,086 --> 0:25:53,696
出现了爆炸式增长

728
00:25:55,186 --> 0:25:56,586
如果标准库没有

729
00:25:56,586 --> 0:25:58,386
你所需要的

730
00:25:58,386 --> 0:26:00,556
那么你需要做的

731
00:25:58,386 --> 0:26:00,556
那么你需要做的

732
00:26:00,556 --> 0:26:03,396
可能是测试 阅读文档

733
00:26:03,396 --> 0:26:04,786
通常更正后还要检查一下

734
00:26:05,746 --> 0:26:07,436
要学会如何在网络上

735
00:26:07,436 --> 0:26:08,746
搜索适用于

736
00:26:08,746 --> 0:26:10,086
你的问题领域的研究

737
00:26:12,716 --> 0:26:12,946
好的

738
00:26:12,946 --> 0:26:13,596
回到代码上来

739
00:26:14,076 --> 0:26:15,656
我对这个切片很感兴趣

740
00:26:15,706 --> 0:26:17,136
当我检查它的类型时

741
00:26:17,136 --> 0:26:20,156
我发现它不是一个数组

742
00:26:20,716 --> 0:26:23,306
由于我们是在一个数组上

743
00:26:23,306 --> 0:26:24,876
使用了 stablePartition

744
00:26:24,876 --> 0:26:27,216
bringToFront 以及 sendToBack

745
00:26:27,216 --> 0:26:28,776
现在我们还在一个数组切片上使用它

746
00:26:28,776 --> 0:26:30,876
所以我大胆猜测

747
00:26:30,876 --> 0:26:32,496
它一定是通用的

748
00:26:32,496 --> 0:26:34,636
“当然是

749
00:26:35,176 --> 0:26:36,446
stablePartition

750
00:26:36,446 --> 0:26:37,846
和特定的数组有什么关系”

751
00:26:39,166 --> 0:26:40,436
“没错 没有联系

752
00:26:41,336 --> 0:26:44,046
说到这 豆包

753
00:26:44,046 --> 0:26:45,416
bringForward() 与图形和选择

754
00:26:45,416 --> 0:26:46,946
又有什么关系呢”

755
00:26:48,616 --> 0:26:51,166
“嗯” 我说 “它作用于图形

756
00:26:51,166 --> 0:26:52,876
然后将选定的图形

757
00:26:52,876 --> 0:26:53,796
移到前面”

758
00:26:54,046 --> 0:26:55,936
“没错 也没关系”

759
00:26:55,936 --> 0:26:56,736
他听都没听便说道

760
00:26:58,636 --> 0:27:00,006
“你能在一排薄荷糖上

761
00:26:58,636 --> 0:27:00,006
“你能在一排薄荷糖上

762
00:27:00,006 --> 0:27:00,926
执行向前移动吗

763
00:27:01,926 --> 0:27:03,106
当然 你可以

764
00:27:04,086 --> 0:27:05,516
所以 这和图形

765
00:27:06,206 --> 0:27:06,500
没有关系”

766
00:27:08,206 --> 0:27:08,446
嗯

767
00:27:08,896 --> 0:27:10,916
“你是在建议我们让它

768
00:27:10,916 --> 0:27:11,376
变得通用吗”

769
00:27:11,556 --> 0:27:12,056
我问道

770
00:27:12,676 --> 0:27:13,626
“难道它不早就是

771
00:27:13,626 --> 0:27:14,426
通用的了吗”

772
00:27:15,416 --> 0:27:16,546
用一个新问题回答了这个问题

773
00:27:16,546 --> 0:27:20,866
Crusty 回答道

774
00:27:20,866 --> 0:27:22,416
“唔 你打算怎样

775
00:27:22,416 --> 0:27:23,330
测试这个方法”

776
00:27:24,946 --> 0:27:26,736
“好的” 我说

777
00:27:26,736 --> 0:27:27,376
“我会创造一个画布

778
00:27:27,616 --> 0:27:29,186
我会添加一些随机的图形

779
00:27:29,186 --> 0:27:30,886
我会选定它们中的一些

780
00:27:30,886 --> 0:27:31,676
然后最终”

781
00:27:32,466 --> 0:27:33,776
但我的话没有说完

782
00:27:33,776 --> 0:27:35,506
因为我知道

783
00:27:35,506 --> 0:27:36,216
这是个坏主意

784
00:27:37,076 --> 0:27:39,126
如果我就这么做

785
00:27:39,126 --> 0:27:40,456
我真的会测试我的功能吗

786
00:27:40,966 --> 0:27:42,066
还是我会测试

787
00:27:42,066 --> 0:27:43,646
画布和不同图形的初始化设定

788
00:27:43,646 --> 0:27:45,606
addMethod() 方法

789
00:27:45,606 --> 0:27:47,776
再或者测试

790
00:27:47,976 --> 0:27:49,136
各种形状的 isSelected 属性是否

791
00:27:49,136 --> 0:27:49,706
计算出来

792
00:27:50,106 --> 0:27:52,356
我的确应该建立测试用例

793
00:27:52,356 --> 0:27:54,506
但是理想情况下

794
00:27:54,736 --> 0:27:56,266
那段代码不应取决于其他

795
00:27:56,266 --> 0:27:57,826
我需要再测试的代码

796
00:27:59,126 --> 0:28:00,506
如果我可以将薄荷糖向前移

797
00:27:59,126 --> 0:28:00,506
如果我可以将薄荷糖向前移

798
00:28:00,506 --> 0:28:02,776
那么我也应有可能

799
00:28:02,776 --> 0:28:04,406
用 Playground 中的整数

800
00:28:04,866 --> 0:28:05,636
做一些随机的事

801
00:28:05,986 --> 0:28:08,226
就像这样 用 bringForward() 方法

802
00:28:08,226 --> 0:28:09,796
把能被 3 整除的数提到前面来

803
00:28:13,276 --> 0:28:14,596
现在 在频谱的另一端

804
00:28:14,596 --> 0:28:16,296
我应该可以向它抛出

805
00:28:16,296 --> 0:28:19,856
大量随机生成的测试数据

806
00:28:19,856 --> 0:28:21,256
并确保算法的

807
00:28:21,256 --> 0:28:22,386
可扩展性

808
00:28:23,246 --> 0:28:24,696
只要代码与画布和图形

809
00:28:24,696 --> 0:28:26,076
绑定在一起

810
00:28:26,116 --> 0:28:27,906
这些事情就都不会简单

811
00:28:29,146 --> 0:28:33,546
所以 我向 Crusty 承认他是对的

812
00:28:33,546 --> 0:28:34,846
并开始把这个非通用的

813
00:28:35,616 --> 0:28:37,106
bringForward() 变成通用的算法

814
00:28:38,436 --> 0:28:40,666
第一步是将它

815
00:28:40,666 --> 0:28:44,896
从画布中解耦出来 

816
00:28:44,896 --> 0:28:45,696
并将其移动到图形数组中

817
00:28:47,216 --> 0:28:49,266
当然 这个数组就是 shapes

818
00:28:49,266 --> 0:28:50,556
所以我必须用 self

819
00:28:50,556 --> 0:28:54,366
把它替换掉

820
00:28:54,366 --> 0:28:56,866
然后我通过传递一个谓词

821
00:28:56,866 --> 0:28:58,636
将它从选择中解耦出来

822
00:28:58,736 --> 0:29:00,046
该谓词指示是否应该将选定的图形

823
00:28:58,736 --> 0:29:00,046
该谓词指示是否应该将选定的图形

824
00:29:00,046 --> 0:29:00,866
向前移动

825
00:29:04,716 --> 0:29:06,156
一切都在正常编译着

826
00:29:07,036 --> 0:29:07,386
太棒了

827
00:29:08,266 --> 0:29:10,826
此时 我很高兴地发现

828
00:29:10,826 --> 0:29:12,086
在 shapes 上没有依赖

829
00:29:12,086 --> 0:29:14,266
我可以删除

830
00:29:14,426 --> 0:29:15,406
where 子句了

831
00:29:15,956 --> 0:29:18,106
非常好 我想

832
00:29:18,106 --> 0:29:20,106
现在 我可以在任何数组中

833
00:29:20,106 --> 0:29:20,506
执行 bringForward 了

834
00:29:21,636 --> 0:29:23,386
我看了看 Crusty 

835
00:29:23,386 --> 0:29:24,636
他一直在角落里

836
00:29:24,676 --> 0:29:26,876
安静地练习恰恰舞

837
00:29:26,876 --> 0:29:28,586
但他似乎认为我还

838
00:29:29,736 --> 0:29:30,000
没有结束

839
00:29:31,316 --> 0:29:32,996
“bringForward() 和数组

840
00:29:32,996 --> 0:29:37,196
有什么关系”他问

841
00:29:37,436 --> 0:29:38,976
“好吧 的确没有” 我叹了口气

842
00:29:38,976 --> 0:29:40,046
然后开始思考

843
00:29:40,046 --> 0:29:41,206
如何移除这个依赖

844
00:29:42,656 --> 0:29:43,706
让我们看看 

845
00:29:43,706 --> 0:29:46,066
这有一个 stablePartition()

846
00:29:46,066 --> 0:29:47,636
需要遵循 MutableCollection 

847
00:29:48,186 --> 0:29:49,416
所以 也许我只需要将它移动到

848
00:29:49,416 --> 0:29:52,676
MutableCollection 中

849
00:29:53,006 --> 0:29:53,466
嗯

850
00:29:53,896 --> 0:29:56,076
我想 显然索引类型

851
00:29:56,116 --> 0:29:59,746
与 int 类型不匹配 好吧

852
00:29:59,746 --> 0:30:01,000
这应该很好修复 对吧

853
00:29:59,746 --> 0:30:01,000
这应该很好修复 对吧

854
00:30:04,216 --> 0:30:04,936
你是这么做的吗

855
00:30:06,176 --> 0:30:08,106
不要这么做

856
00:30:09,546 --> 0:30:11,326
它编译好了

857
00:30:11,326 --> 0:30:12,586
但是 Crusty 突然停止了跳舞

858
00:30:12,586 --> 0:30:15,156
我知道有些不对劲

859
00:30:15,366 --> 0:30:16,166
“什么” 我说

860
00:30:16,966 --> 0:30:18,836
“菜鸟总是这样做”

861
00:30:18,836 --> 0:30:20,036
Crusty 边摇着头边说

862
00:30:21,566 --> 0:30:23,216
“首先 你让它与 0 的比较

863
00:30:23,216 --> 0:30:26,056
这对于数组切片来说是错误的

864
00:30:26,686 --> 0:30:29,456
所以 你知道数组切片

865
00:30:29,456 --> 0:30:31,596
它们的索引不是

866
00:30:31,596 --> 0:30:32,216
从 0 开始的吗

867
00:30:32,216 --> 0:30:35,696
所有切片的索引

868
00:30:35,966 --> 0:30:37,506
从它们被切片的

869
00:30:37,506 --> 0:30:38,786
底层集合中的

870
00:30:38,786 --> 0:30:40,246
相应索引开始

871
00:30:40,796 --> 0:30:42,976
这种关系十分关键

872
00:30:42,976 --> 0:30:44,126
如果你想要用切片

873
00:30:44,126 --> 0:30:46,466
组成通用算法

874
00:30:47,056 --> 0:30:47,946
所以它真的很重要”

875
00:30:49,156 --> 0:30:52,406
好吧 我知道要修正这个问题

876
00:30:53,146 --> 0:30:54,126
只需将它与开始索引

877
00:30:54,126 --> 0:30:54,516
进行比较

878
00:30:55,766 --> 0:30:58,346
但是真正的问题是

879
00:30:58,346 --> 0:31:00,056
“bringForward() 与拥有整数索引

880
00:30:58,346 --> 0:31:00,056
“bringForward() 与拥有整数索引

881
00:31:00,056 --> 0:31:01,846
有什么关系”

882
00:31:01,846 --> 0:31:02,576
我打断了他

883
00:31:03,416 --> 0:31:04,416
“是的 我知道”

884
00:31:05,266 --> 0:31:07,466
“我必须在 i 之前

885
00:31:07,466 --> 0:31:10,156
得到索引

886
00:31:10,156 --> 0:31:10,876
我可以用减法获得”

887
00:31:12,856 --> 0:31:14,976
Crusty 只是叹了口气

888
00:31:14,976 --> 0:31:15,906
然后又将薄荷糖拿了出来

889
00:31:17,466 --> 0:31:19,376
然后 他把两个手指

890
00:31:19,376 --> 0:31:22,156
放在桌子上 像小人一样走啊走

891
00:31:22,566 --> 0:31:24,966
直到右手指向

892
00:31:25,136 --> 0:31:27,276
第一块绿色的薄荷糖

893
00:31:27,806 --> 0:31:31,446
“整支舞中都没有

894
00:31:31,446 --> 0:31:32,506
向后的舞步” 他说

895
00:31:33,406 --> 0:31:35,286
之后我意识到 

896
00:31:35,286 --> 0:31:37,586
Crusty 刚刚向我展示了一个新的算法

897
00:31:38,636 --> 0:31:39,546
“我们叫它

898
00:31:39,696 --> 0:31:40,986
indexBeforeFirst 吧”

899
00:31:42,066 --> 0:31:43,776
“现在 这里的诀窍是

900
00:31:43,776 --> 0:31:46,086
保持注意力集中

901
00:31:46,086 --> 0:31:46,976
假设有人已经为你写了它”

902
00:31:47,826 --> 0:31:49,116
然后他把我们不需要的

903
00:31:49,116 --> 0:31:50,336
代码都删掉了

904
00:31:50,336 --> 0:31:53,906
像这样 这样

905
00:31:56,616 --> 0:32:00,866
“predecessor 就是第一个

906
00:31:56,616 --> 0:32:00,866
“predecessor 就是第一个

907
00:32:00,866 --> 0:32:02,416
在谓词被满足之前的元素

908
00:32:02,416 --> 0:32:04,286
前面的索引

909
00:32:05,346 --> 0:32:06,656
现在 快来看看这读起来

910
00:32:06,656 --> 0:32:07,046
多么动人”

911
00:32:08,486 --> 0:32:10,946
如果你看到了这个代码

912
00:32:10,946 --> 0:32:11,706
你就会发现他是对的

913
00:32:13,116 --> 0:32:15,006
删除所有无关的细节

914
00:32:15,006 --> 0:32:17,436
包括图形 选择

915
00:32:17,546 --> 0:32:20,066
数据以及整数

916
00:32:20,066 --> 0:32:22,006
给我留下更清晰的代码

917
00:32:22,006 --> 0:32:23,626
因为它只处理

918
00:32:23,696 --> 0:32:24,356
问题的本质

919
00:32:24,926 --> 0:32:27,496
“我已经向你展示了

920
00:32:27,496 --> 0:32:28,956
indexBeforeFirst 是如何工作的

921
00:32:29,266 --> 0:32:32,236
试一试你能不能写出来” 他说

922
00:32:32,706 --> 0:32:34,036
所以 我想我现在开始

923
00:32:34,036 --> 0:32:36,016
跟得上他了

924
00:32:36,016 --> 0:32:37,036
因为我第一次做对了

925
00:32:37,666 --> 0:32:40,996
我说过 我是个手速超快的打字员

926
00:32:41,466 --> 0:32:41,726
好吧

927
00:32:42,236 --> 0:32:45,436
所以 返回第一个

928
00:32:45,436 --> 0:32:48,536
successor 与谓词匹配的索引

929
00:32:49,206 --> 0:32:51,556
我非常兴奋地看到

930
00:32:51,556 --> 0:32:52,396
这进展得有多么顺利

931
00:32:53,436 --> 0:32:54,456
“好吧 Crusty” 我说

932
00:32:54,766 --> 0:32:55,726
“让我们做下一个”

933
00:32:57,516 --> 0:32:58,946
“你难道没有忘记什么事吗

934
00:32:58,946 --> 0:33:00,586
豆包” 他问道

935
00:32:58,946 --> 0:33:00,586
豆包” 他问道

936
00:33:00,586 --> 0:33:02,306
我不知道

937
00:33:02,306 --> 0:33:02,906
他在说什么

938
00:33:03,466 --> 0:33:05,276
代码很简洁

939
00:33:05,276 --> 0:33:05,666
而且运行正常

940
00:33:07,016 --> 0:33:08,336
“语义 小子

941
00:33:09,046 --> 0:33:10,216
我怎么能从其他代码中使用它们

942
00:33:10,216 --> 0:33:11,416
如果我不知道

943
00:33:11,416 --> 0:33:12,156
它们是什么意思呢”

944
00:33:12,786 --> 0:33:17,156
于是我意识到

945
00:33:17,156 --> 0:33:18,926
每一次我们使用新的算法

946
00:33:19,446 --> 0:33:20,326
我们都依靠他的文档

947
00:33:20,326 --> 0:33:21,936
得出关于

948
00:33:21,936 --> 0:33:23,416
我们自己代码的

949
00:33:23,726 --> 0:33:25,296
意义和效率的结论

950
00:33:26,346 --> 0:33:27,846
因为大多数算法都是

951
00:33:27,846 --> 0:33:29,456
由其他算法构建的

952
00:33:29,896 --> 0:33:32,816
所以它们依赖于相同的东西

953
00:33:33,026 --> 0:33:34,826
最近 我正在面试一位

954
00:33:34,826 --> 0:33:36,486
未来的实习生并且问他

955
00:33:36,486 --> 0:33:38,236
关于文档的作用

956
00:33:38,636 --> 0:33:40,226
他以一个我不会忘记的

957
00:33:40,226 --> 0:33:41,156
短语开始

958
00:33:41,966 --> 0:33:44,206
“哦 它实在太重要了” 他说

959
00:33:45,646 --> 0:33:46,816
“我们正在构建这些抽象的塔”

960
00:33:46,816 --> 0:33:48,996
我在向你们复述他的话

961
00:33:48,996 --> 0:33:50,946
“我们之所以能够成功构建

962
00:33:50,946 --> 0:33:52,286
而无需经常检查

963
00:33:52,286 --> 0:33:54,086
下面层级的内容

964
00:33:54,706 --> 0:33:56,036
是因为我们构建的部分

965
00:33:56,036 --> 0:33:57,176
是有文档记录的”

966
00:33:57,666 --> 0:34:01,966
现在 作为一名 App 开发者

967
00:33:57,666 --> 0:34:01,966
现在 作为一名 App 开发者

968
00:34:02,176 --> 0:34:03,746
你正在一个塔尖上工作

969
00:34:03,746 --> 0:34:05,356
这个塔贯穿了

970
00:34:05,356 --> 0:34:07,966
你的系统框架 DOS

971
00:34:07,966 --> 0:34:09,556
一直延伸到硬件

972
00:34:10,146 --> 0:34:11,216
这是基于物理定律的

973
00:34:12,815 --> 0:34:14,096
但是一旦你调用了

974
00:34:14,096 --> 0:34:15,936
你自己的方法

975
00:34:15,936 --> 0:34:18,146
它就成为你的基础的一部分

976
00:34:18,146 --> 0:34:19,666
所以 请为你的代码写文档

977
00:34:20,235 --> 0:34:21,565
顺便说一下

978
00:34:21,565 --> 0:34:23,946
那位实习生被录用了

979
00:34:26,295 --> 0:34:26,406
他就坐在那里

980
00:34:26,616 --> 0:34:28,896
所以 我接受了提示

981
00:34:28,896 --> 0:34:29,936
并把 Crusty 的新算法写入了文档

982
00:34:29,936 --> 0:34:32,956
这意味着

983
00:34:32,956 --> 0:34:33,716
我们可以忘记

984
00:34:33,716 --> 0:34:36,956
它如何实现 并使用它

985
00:34:37,206 --> 0:34:38,306
因为我们知道 “Quick Help”

986
00:34:38,306 --> 0:34:39,416
拥有我们所需要的一切

987
00:34:41,246 --> 0:34:43,496
现在 我也记录了 bringForward

988
00:34:45,956 --> 0:34:46,565
酷

989
00:34:48,136 --> 0:34:49,456
现在 因为它似乎

990
00:34:49,456 --> 0:34:51,626
解决了我所有的问题

991
00:34:51,626 --> 0:34:53,496
在这时 我真的很好奇

992
00:34:53,496 --> 0:34:55,786
想看看在 stablePartition 里

993
00:34:55,786 --> 0:34:56,596
发生了什么

994
00:34:57,806 --> 0:34:59,456
结果是我得到了很好的回报

995
00:34:59,526 --> 0:35:01,416
因为这是一个非常漂亮

996
00:34:59,526 --> 0:35:01,416
因为这是一个非常漂亮

997
00:35:01,416 --> 0:35:02,486
而且有指导意义的算法

998
00:35:03,766 --> 0:35:05,196
这个公共的方法

999
00:35:05,196 --> 0:35:06,846
获取集合计数

1000
00:35:06,846 --> 0:35:10,506
并将其传递给这个 helper 方法

1001
00:35:10,506 --> 0:35:11,776
该 helper 方法使用“分而治之”的策略

1002
00:35:13,056 --> 0:35:15,136
首先 它会处理基本情况 

1003
00:35:15,136 --> 0:35:17,276
当计数小于 2 时

1004
00:35:17,276 --> 0:35:18,436
我们便结束了

1005
00:35:18,966 --> 0:35:19,916
我们只需要弄清楚

1006
00:35:20,396 --> 0:35:21,656
分区点是在

1007
00:35:21,656 --> 0:35:23,046
集合的开始处

1008
00:35:23,046 --> 0:35:26,016
或者在集合的末尾

1009
00:35:26,116 --> 0:35:28,496
接下来 我们将集合

1010
00:35:28,546 --> 0:35:29,416
分成两部分

1011
00:35:31,136 --> 0:35:33,696
现在 在这一点上 

1012
00:35:33,746 --> 0:35:35,136
你必须暂时相信

1013
00:35:35,136 --> 0:35:37,146
算法是有效的

1014
00:35:37,146 --> 0:35:38,346
因为我们要用 stablePartition() 处理

1015
00:35:38,346 --> 0:35:41,446
左半边和右半边

1016
00:35:42,136 --> 0:35:46,766
现在 如果你看一下这两端

1017
00:35:46,766 --> 0:35:49,166
你会发现

1018
00:35:49,166 --> 0:35:50,746
所有东西都在正确的位置

1019
00:35:50,746 --> 0:35:54,556
但是这个中心区段

1020
00:35:54,556 --> 0:35:56,516
有两个部分

1021
00:35:56,516 --> 0:35:57,316
需要交换

1022
00:35:58,806 --> 0:36:01,016
现在 它们不会总是

1023
00:35:58,806 --> 0:36:01,016
现在 它们不会总是

1024
00:36:01,016 --> 0:36:03,126
和在这个例子中一样长

1025
00:36:03,126 --> 0:36:06,716
幸运的是

1026
00:36:06,716 --> 0:36:07,986
“有一个算法可以使用”

1027
00:36:08,906 --> 0:36:10,636
我们叫它 rotate()

1028
00:36:11,176 --> 0:36:11,276
好的

1029
00:36:14,466 --> 0:36:16,496
我不打算在这里深入讨论 rotate 算法

1030
00:36:16,496 --> 0:36:18,226
但是它真的很漂亮

1031
00:36:18,256 --> 0:36:19,156
如果你感兴趣

1032
00:36:19,156 --> 0:36:22,446
你可以在与 stablePartition 同样的文件中

1033
00:36:22,446 --> 0:36:23,436
找到它的实现方法

1034
00:36:24,116 --> 0:36:24,216
好的

1035
00:36:25,596 --> 0:36:27,146
回到图形

1036
00:36:28,186 --> 0:36:32,486
现在 这个烂摊子实现了

1037
00:36:32,696 --> 0:36:34,706
在图形列表中拖放

1038
00:36:34,706 --> 0:36:36,626
这一直是我最复杂

1039
00:36:36,626 --> 0:36:39,326
和 Bug 最多的运算之一

1040
00:36:40,336 --> 0:36:41,616
我的策略是

1041
00:36:41,616 --> 0:36:43,246
分配临时缓冲区

1042
00:36:44,536 --> 0:36:46,486
然后在插入点之前

1043
00:36:47,076 --> 0:36:48,506
对 shapes 进行循环

1044
00:36:48,736 --> 0:36:50,196
提取选定的图形

1045
00:36:50,196 --> 0:36:51,576
并调整插入点

1046
00:36:52,526 --> 0:36:54,086
然后在不调整插入点的情况下

1047
00:36:54,086 --> 0:36:55,896
分别对其余的图形

1048
00:36:55,896 --> 0:36:57,236
进行循环

1049
00:36:57,236 --> 0:36:58,596
提取选定的图形

1050
00:36:59,126 --> 0:37:02,916
最后 重新插入它们

1051
00:36:59,126 --> 0:37:02,916
最后 重新插入它们

1052
00:37:06,536 --> 0:37:10,726
老实说 我有点害怕触碰代码

1053
00:37:10,726 --> 0:37:12,156
因为我觉得我终于做对了

1054
00:37:12,156 --> 0:37:14,276
距离我最后一次发现新 Bug

1055
00:37:14,276 --> 0:37:15,536
已经差不多有

1056
00:37:15,536 --> 0:37:16,056
一个星期了

1057
00:37:16,526 --> 0:37:21,026
但是我现在已经在这个过程中

1058
00:37:21,026 --> 0:37:22,726
做得很好了

1059
00:37:23,286 --> 0:37:28,976
所以我试着把操作可视化一次完成

1060
00:37:29,106 --> 0:37:31,116
嘿 看起来很熟悉

1061
00:37:31,326 --> 0:37:34,856
让我们再看看

1062
00:37:35,056 --> 0:37:35,486
嗯

1063
00:37:36,946 --> 0:37:39,826
假设我们先做这个

1064
00:37:39,826 --> 0:37:40,926
然后分别处理

1065
00:37:40,926 --> 0:37:41,456
各个部分

1066
00:37:43,456 --> 0:37:44,246
没错

1067
00:37:44,706 --> 0:37:45,946
这就是两个

1068
00:37:45,946 --> 0:37:48,976
带有反转谓词的 stablePartition

1069
00:37:49,596 --> 0:37:51,316
所以 这个通用的算法

1070
00:37:51,736 --> 0:37:52,846
被压缩到了这两行

1071
00:37:52,886 --> 0:37:57,636
而这是 Canvas 上剩下的

1072
00:37:58,186 --> 0:38:01,126
现在 让我们把它放在

1073
00:37:58,186 --> 0:38:01,126
现在 让我们把它放在

1074
00:38:01,126 --> 0:38:02,426
旧代码旁边看看

1075
00:38:04,456 --> 0:38:07,886
还不错 但是我们得到了

1076
00:38:07,886 --> 0:38:10,396
一个可重复使用的

1077
00:38:10,766 --> 0:38:12,346
高效文档化的通用算法

1078
00:38:12,346 --> 0:38:13,846
这是非常棒的

1079
00:38:14,446 --> 0:38:21,846
好的 这是一种需要习得的技能

1080
00:38:21,846 --> 0:38:23,746
审视特定于你的 App

1081
00:38:23,746 --> 0:38:25,086
领域的细节

1082
00:38:25,086 --> 0:38:27,056
了解你的代码从根本上在做什么

1083
00:38:27,056 --> 0:38:29,126
并在可重复使用的通用代码中

1084
00:38:29,126 --> 0:38:31,416
捕获这些细节

1085
00:38:32,276 --> 0:38:33,776
这需要实践

1086
00:38:34,966 --> 0:38:35,636
但是 为什么要那么麻烦呢

1087
00:38:36,536 --> 0:38:38,636
实践得到的答案是

1088
00:38:38,636 --> 0:38:39,966
因为它们是从无关的细节中

1089
00:38:39,966 --> 0:38:41,896
解耦出来的

1090
00:38:42,336 --> 0:38:44,126
通用的算法更加

1091
00:38:44,126 --> 0:38:46,296
可重复使用 经得起考验

1092
00:38:46,296 --> 0:38:47,976
甚至比对应的非通用代码

1093
00:38:47,976 --> 0:38:48,706
更加简洁

1094
00:38:49,676 --> 0:38:51,336
但我也认为

1095
00:38:51,586 --> 0:38:53,156
对于任何真正喜欢编程的人来说

1096
00:38:53,296 --> 0:38:54,446
这都是非常有益的

1097
00:38:55,646 --> 0:38:56,996
它是对真与美的追求

1098
00:38:56,996 --> 0:38:59,406
而不是抽象的

1099
00:38:59,406 --> 0:39:01,266
不可触及的真理

1100
00:38:59,406 --> 0:39:01,266
不可触及的真理

1101
00:39:01,266 --> 0:39:02,876
因为实际硬件的约束

1102
00:39:02,876 --> 0:39:03,696
让你保持诚实

1103
00:39:04,836 --> 0:39:06,066
就像 Crusty 常说的

1104
00:39:07,026 --> 0:39:10,136
“编程揭示本真”

1105
00:39:10,346 --> 0:39:12,296
因此 将你的计算视为

1106
00:39:12,296 --> 0:39:14,576
具有类型

1107
00:39:14,576 --> 0:39:16,186
和 App 体系结构的

1108
00:39:16,186 --> 0:39:19,856
具有权利和义务的 VIP

1109
00:39:20,316 --> 0:39:22,566
标识它 给它一个名字

1110
00:39:22,846 --> 0:39:25,756
对它进行单元测试

1111
00:39:25,756 --> 0:39:27,006
并记录它的语义和性能

1112
00:39:27,096 --> 0:39:30,556
最后 我想把

1113
00:39:30,556 --> 0:39:32,366
Sean Parent 的建议

1114
00:39:32,366 --> 0:39:34,136
包括上下文引用一下 作为结束语

1115
00:39:34,676 --> 0:39:37,466
“如果你想要提高

1116
00:39:37,466 --> 0:39:39,146
组织中的代码质量

1117
00:39:39,606 --> 0:39:41,586
请将所有的代码标准

1118
00:39:41,586 --> 0:39:44,976
替换为一个目标 不要单独写循环”

1119
00:39:46,386 --> 0:39:46,696
谢谢大家

1120
00:39:47,516 --> 0:39:52,500
[ 掌声 ]
