1
00:00:07,516 --> 0:00:15,500
[ 音乐 ]

2
00:00:21,516 --> 0:00:27,776
[ 掌声 ]

3
00:00:28,276 --> 0:00:28,666
&gt;&gt; 谢谢

4
00:00:29,326 --> 0:00:30,746
我叫 Dan Omachi

5
00:00:30,746 --> 0:00:32,946
我是 Apple Metal Ecosystem 团队的工程师

6
00:00:33,606 --> 0:00:35,536
现在我在团队内的主要工作是

7
00:00:35,536 --> 0:00:37,136
帮助开发者们学习 Metal

8
00:00:37,136 --> 0:00:38,766
以及获得很好的使用体验

9
00:00:39,476 --> 0:00:41,326
但是在这之前很多年

10
00:00:41,326 --> 0:00:43,456
我都致力于 Apple 的 OpenGL 和

11
00:00:43,636 --> 0:00:44,686
OpenGL ES 框架

12
00:00:45,086 --> 0:00:46,716
在我加入 Apple 以前

13
00:00:46,716 --> 0:00:47,746
我曾参与实现其他几个

14
00:00:47,746 --> 0:00:48,936
OpenGL 应用

15
00:00:50,926 --> 0:00:53,286
所以我非常骄傲

16
00:00:53,446 --> 0:00:55,576
我过去几年在

17
00:00:55,736 --> 0:00:57,866
OpenGL 上的成就

18
00:00:57,866 --> 0:00:59,976
但是对于 Metal 带领我们的方向

19
00:00:59,976 --> 0:01:02,166
我也非常激动

20
00:00:59,976 --> 0:01:02,166
我也非常激动

21
00:01:02,936 --> 0:01:04,726
今天我和我的同事

22
00:01:04,726 --> 0:01:05,906
Sukanya Sudugu

23
00:01:05,906 --> 0:01:07,556
将会向你们简略地

24
00:01:07,556 --> 0:01:10,066
介绍 Metal 同时对于

25
00:01:10,456 --> 0:01:12,526
如何轻松地移植你们的 OpenGL App

26
00:01:12,526 --> 0:01:15,156
提供一些建议

27
00:01:15,386 --> 0:01:16,906
今年尤其的重要

28
00:01:16,906 --> 0:01:19,016
因为 就像昨天

29
00:01:19,016 --> 0:01:20,876
在 union OpenGL 上说的

30
00:01:20,876 --> 0:01:23,466
OpenGL ES 和 OpenCL

31
00:01:23,676 --> 0:01:25,366
是不被允许的

32
00:01:26,336 --> 0:01:28,206
现在和即将发布的

33
00:01:28,206 --> 0:01:30,346
App 仍可在 tvOS 和 iOS 12 上使用

34
00:01:30,716 --> 0:01:35,006
OpenGL ES 以及在 macOS 10.14 Mojave 上

35
00:01:35,636 --> 0:01:40,706
使用 OpenGL and OpenCL

36
00:01:40,706 --> 0:01:44,626
而且这将持续一段时间

37
00:01:45,476 --> 0:01:48,286
但是 新项目应该

38
00:01:48,286 --> 0:01:50,486
从开始就面向 Metal

39
00:01:51,026 --> 0:01:51,886
所以如果你还不熟悉 Metal

40
00:01:51,886 --> 0:01:54,156
那么 你应该开始熟悉一下它

41
00:01:55,806 --> 0:01:56,886
在你把所有 OpenGL 代码都销毁

42
00:01:56,886 --> 0:01:58,416
并开始把所有东西 都转移到 Metal 之前

43
00:01:58,416 --> 0:01:59,526
你还有几个选择

44
00:01:59,526 --> 0:02:00,446
可以考虑

45
00:01:59,526 --> 0:02:00,446
可以考虑

46
00:02:01,376 --> 0:02:03,156
Apple 提供了很多高层面

47
00:02:03,226 --> 0:02:04,906
的渲染框架

48
00:02:05,466 --> 0:02:06,446
不同种类的渲染

49
00:02:06,836 --> 0:02:08,846
适用于 2D 游戏的 SpriteKit

50
00:02:08,846 --> 0:02:10,756
适用于 3D 游戏的 SceneKit

51
00:02:10,756 --> 0:02:11,966
能有很棒效果的 Core Image

52
00:02:13,526 --> 0:02:15,456
另外 每个主要的

53
00:02:15,566 --> 0:02:17,366
第三方游戏引擎已经

54
00:02:17,366 --> 0:02:19,596
使用 Metal 作为他们的主要渲染器

55
00:02:20,776 --> 0:02:22,886
但你或许会认为

56
00:02:22,886 --> 0:02:24,426
这些方法不适合你

57
00:02:24,756 --> 0:02:25,866
你也可以

58
00:02:25,866 --> 0:02:28,086
自己在 Metal 里实现这些

59
00:02:28,086 --> 0:02:30,416
这就是我们今天要讨论的东西

60
00:02:30,566 --> 0:02:31,746
所以我们从 Metal 的设计

61
00:02:31,746 --> 0:02:33,966
和一些基本概念说起

62
00:02:35,536 --> 0:02:37,246
OpenGL 最开始

63
00:02:37,246 --> 0:02:39,326
是 25 年前开发的

64
00:02:39,366 --> 0:02:41,286
它的核心是反映了

65
00:02:41,286 --> 0:02:43,226
3D 图像的硬件加速

66
00:02:44,696 --> 0:02:46,676
所以新版本的更新

67
00:02:46,676 --> 0:02:48,266
和拓展确实为我们

68
00:02:48,266 --> 0:02:49,766
探索新的 GPU 特性和

69
00:02:49,836 --> 0:02:51,666
性能技术提供了服务

70
00:02:52,806 --> 0:02:54,436
但是 仍旧有一些

71
00:02:54,436 --> 0:02:56,276
基础设计决策

72
00:02:56,276 --> 0:02:58,396
不再适用于现在的硬件设备

73
00:03:00,856 --> 0:03:02,326
OpenGL 管道你曾是

74
00:03:02,326 --> 0:03:03,826
完全固定的功能

75
00:03:03,826 --> 0:03:07,526
虽然现在 OpenGL 提供可编程的管道

76
00:03:07,526 --> 0:03:12,826
但是它并不完全匹配当代 GPU

77
00:03:13,036 --> 0:03:15,356
另外 异步处理不再是

78
00:03:15,356 --> 0:03:16,726
API 的核心特性

79
00:03:17,476 --> 0:03:18,436
还有很多其他功能

80
00:03:18,436 --> 0:03:19,576
暗示 GPU 会与

81
00:03:19,576 --> 0:03:20,656
你的 App 同时工作

82
00:03:20,656 --> 0:03:22,586
但大多数都是隐式的

83
00:03:23,046 --> 0:03:27,766
25 年前 只有最贵的工作站

84
00:03:27,766 --> 0:03:29,186
和服务器是多核的

85
00:03:29,676 --> 0:03:30,956
所以 设计一个高效的

86
00:03:30,956 --> 0:03:33,216
多线模型 不是最优选择

87
00:03:33,216 --> 0:03:37,516
所以在 2014 年的时候很明显

88
00:03:37,516 --> 0:03:39,116
设计新的 GPU

89
00:03:39,116 --> 0:03:40,836
App 接口是必要的

90
00:03:41,696 --> 0:03:42,856
很明显我们需要

91
00:03:42,856 --> 0:03:45,406
一个可以高效利用 GPU 能力的接口

92
00:03:46,576 --> 0:03:48,076
要做到这一点

93
00:03:48,076 --> 0:03:49,826
App 需要 CPU 让道

94
00:03:49,826 --> 0:03:51,946
才能让 GPU 可以做他的事情

95
00:03:52,146 --> 0:03:53,836
但是当 App 需要 CPU 做渲染时

96
00:03:53,836 --> 0:03:54,976
它又可以

97
00:03:54,976 --> 0:03:56,466
调用所有的 CPU

98
00:03:56,906 --> 0:03:58,176
包括它的多核

99
00:03:59,626 --> 0:04:01,146
如果接口需要预测

100
00:03:59,626 --> 0:04:01,146
如果接口需要预测

101
00:04:01,146 --> 0:04:04,056
去避免开发者陷入

102
00:04:04,136 --> 0:04:08,586
API 的隐藏陷阱

103
00:04:08,586 --> 0:04:09,926
那么每一个调用需要有明显的结果

104
00:04:09,926 --> 0:04:12,146
并且最好不要有

105
00:04:12,206 --> 0:04:13,846
隐式的操作

106
00:04:14,336 --> 0:04:16,476
这种预测的一部分

107
00:04:16,576 --> 0:04:17,805
需要去控制

108
00:04:17,805 --> 0:04:19,916
资源分布和

109
00:04:19,956 --> 0:04:22,376
什么时候需要同步

110
00:04:27,896 --> 0:04:29,456
我们想要这个接口

111
00:04:29,456 --> 0:04:31,416
是可触及的

112
00:04:31,416 --> 0:04:32,536
它需要正确的

113
00:04:32,536 --> 0:04:34,306
平衡低层次控制和明确的用量

114
00:04:34,306 --> 0:04:36,436
因为当你了解一个东西以后

115
00:04:36,436 --> 0:04:40,566
你能更高效和有效的使用它

116
00:04:41,976 --> 0:04:43,766
当然 我们设计 Metal

117
00:04:43,766 --> 0:04:46,516
是为了更好地映射到各种当代 GPU 上

118
00:04:46,516 --> 0:04:49,486
特别是我们知道

119
00:04:49,486 --> 0:04:50,446
管道中的硬件

120
00:04:50,496 --> 0:04:53,216
需要软件去推动它

121
00:04:53,906 --> 0:04:55,556
这就包括了 Apple 设计的

122
00:04:55,696 --> 0:04:58,486
所有 A11 仿生 GPU

123
00:04:59,956 --> 0:05:01,736
所以为什么 Metal 不同于 OpenGL

124
00:04:59,956 --> 0:05:01,736
所以为什么 Metal 不同于 OpenGL

125
00:05:02,196 --> 0:05:03,556
你会更少地去进行

126
00:05:03,626 --> 0:05:06,036
昂贵的操作

127
00:05:07,046 --> 0:05:08,236
对象的设计是这样的

128
00:05:08,236 --> 0:05:09,916
API 的状态可以被转换

129
00:05:09,916 --> 0:05:12,226
并且在创建时被预包装进

130
00:05:12,226 --> 0:05:13,926
GPU 命令

131
00:05:15,726 --> 0:05:17,406
这样做会在真正渲染时

132
00:05:17,406 --> 0:05:19,266
最大程度减少成本

133
00:05:20,576 --> 0:05:21,656
拥有 Vertex 和片段着色器的

134
00:05:21,686 --> 0:05:23,286
图形管道也

135
00:05:23,286 --> 0:05:24,756
反映了当代 GPU

136
00:05:25,716 --> 0:05:27,396
所以这会降低

137
00:05:27,516 --> 0:05:29,986
将 API 设置转换到 GP 命令的成本

138
00:05:31,236 --> 0:05:32,926
这并不表示

139
00:05:32,926 --> 0:05:34,296
管道是截然不同的

140
00:05:34,296 --> 0:05:36,026
或者说需要一个全新的方式去考虑

141
00:05:36,946 --> 0:05:38,256
Metal 最大的区别是

142
00:05:38,256 --> 0:05:39,406
将管道的各个阶段

143
00:05:39,436 --> 0:05:41,686
分组成对象

144
00:05:41,686 --> 0:05:43,326
是更高效的

145
00:05:43,326 --> 0:05:45,396
并不是管道本身改变了

146
00:05:46,816 --> 0:05:49,366
Metal 为了执行多线程

147
00:05:49,366 --> 0:05:50,616
还有一个清晰的模型

148
00:05:51,496 --> 0:05:52,356
有很多种不同的方法

149
00:05:52,356 --> 0:05:53,976
让 App 在不同线程上

150
00:05:53,976 --> 0:05:55,796
去驱动 GPU

151
00:05:56,286 --> 0:05:57,906
但是对于每一个

152
00:05:57,996 --> 0:05:59,686
都有明确但不受限的规则去实现它

153
00:06:01,036 --> 0:06:02,546
此外最常用的对象

154
00:06:02,546 --> 0:06:05,936
像纹理 缓冲和着色器 可以安全

155
00:06:05,936 --> 0:06:07,726
并有效地在不同线程中使用

156
00:06:08,526 --> 0:06:10,156
Metal 并不需要去实现

157
00:06:10,326 --> 0:06:11,776
昂贵的内部日志操作

158
00:06:11,776 --> 0:06:13,306
去防止这些

159
00:06:13,306 --> 0:06:14,546
对象进入

160
00:06:14,546 --> 0:06:15,456
无效状态

161
00:06:17,516 --> 0:06:21,036
最后 它的执行模式反映了软件与 GPU 之间

162
00:06:21,076 --> 0:06:22,696
真正发生的事

163
00:06:23,266 --> 0:06:24,926
很多通过 OpenGL 展现

164
00:06:25,046 --> 0:06:26,406
的隐性操作

165
00:06:26,406 --> 0:06:28,116
通过 Metal 在 App 中

166
00:06:28,116 --> 0:06:29,886
被明显地展示出来

167
00:06:30,636 --> 0:06:31,836
这就让你可以对于什么时候

168
00:06:31,836 --> 0:06:33,666
和怎样在 App 中使用 GPU

169
00:06:33,666 --> 0:06:35,966
做出明智的决定

170
00:06:36,946 --> 0:06:37,966
这还代表着

171
00:06:37,966 --> 0:06:39,036
你的 App 和 GPU 之间将有

172
00:06:39,036 --> 0:06:40,586
更少的软件

173
00:06:41,216 --> 0:06:43,286
大多数的 Metal 调用直接

174
00:06:43,286 --> 0:06:45,096
指向 GPU 驱动

175
00:06:45,096 --> 0:06:46,726
这样驱动也需要做更少的处理

176
00:06:46,726 --> 0:06:49,526
去将 API 调用转换为 GPU 命令

177
00:06:51,216 --> 0:06:52,216
所以让我们来跟深入地看看

178
00:06:52,216 --> 0:06:52,636
它是怎么工作的

179
00:06:53,256 --> 0:06:56,466
所有的 GL 调用都在 OpenGL 中

180
00:06:56,466 --> 0:06:57,506
展现出来

181
00:06:57,916 --> 0:06:59,846
这个内容就包含了很多东西

182
00:06:59,846 --> 0:07:01,966
它追踪 API 的状态

183
00:06:59,846 --> 0:07:01,966
它追踪 API 的状态

184
00:07:02,166 --> 0:07:03,766
它管理 OpenGL 对象和其它内存

185
00:07:03,766 --> 0:07:05,246
同时还转换

186
00:07:05,246 --> 0:07:06,506
并递交 GPU 命令

187
00:07:07,366 --> 0:07:09,066
Metal 将所有这些

188
00:07:09,066 --> 0:07:10,626
OpenGL 内容的工作分成

189
00:07:10,626 --> 0:07:12,956
很多个小对象

190
00:07:14,056 --> 0:07:18,616
第一个被创建的对象就是 Metal 设备

191
00:07:18,716 --> 0:07:20,626
它是一个物理 GPU 的

192
00:07:20,776 --> 0:07:21,686
抽象表现

193
00:07:22,256 --> 0:07:26,286
这个设备创建对象

194
00:07:26,286 --> 0:07:27,646
比如说纹理 缓冲

195
00:07:27,646 --> 0:07:29,906
和包含着色器的管道对象

196
00:07:31,026 --> 0:07:32,886
它还创建了一个关键对象

197
00:07:33,136 --> 0:07:34,636
叫做 Metal 命令队列

198
00:07:35,196 --> 0:07:37,816
这个命令队列只有一个工作

199
00:07:37,816 --> 0:07:39,796
就是去创建

200
00:07:39,796 --> 0:07:41,176
一系列的命令缓存

201
00:07:41,956 --> 0:07:43,506
这里我们已经创建了一个命令缓存

202
00:07:43,506 --> 0:07:44,856
并且这个命令缓存是

203
00:07:44,856 --> 0:07:46,706
一系列 GPU 命令的简单列表

204
00:07:46,956 --> 0:07:48,956
你的 App 将填写这个列表

205
00:07:48,956 --> 0:07:50,146
并且发送给 GPU 去执行

206
00:07:51,166 --> 0:07:52,836
通常你的 App 要在每一帧去创建一个

207
00:07:52,836 --> 0:07:54,926
单独的命令缓存

208
00:07:55,016 --> 0:07:55,866
但是有些情况下

209
00:07:55,866 --> 0:07:57,566
它也会觉得需要

210
00:07:57,696 --> 0:08:00,886
在一帧里创建两三个

211
00:07:57,696 --> 0:08:00,886
在一帧里创建两三个

212
00:08:01,026 --> 0:08:02,256
但是 App 本身并不会直接写这些

213
00:08:02,256 --> 0:08:03,606
命令到命令缓存里

214
00:08:03,606 --> 0:08:05,216
它是创建了一个

215
00:08:05,216 --> 0:08:06,586
Metal 命令编码器

216
00:08:07,886 --> 0:08:09,356
这个命令编码器将

217
00:08:09,446 --> 0:08:11,686
API 调用转换成 GPU 指令

218
00:08:11,906 --> 0:08:13,266
并将它们写入命令缓存

219
00:08:14,336 --> 0:08:15,666
在一系列命令

220
00:08:15,666 --> 0:08:17,426
被编码以后 App 就会

221
00:08:17,426 --> 0:08:19,336
结束编码 并且释放编码对象

222
00:08:20,536 --> 0:08:22,756
事实上有不同的编码器

223
00:08:22,756 --> 0:08:24,146
你的 App 可以从命令缓存中

224
00:08:24,146 --> 0:08:25,876
创建新的编码器 去编码更多的指令

225
00:08:31,156 --> 0:08:32,616
特别注意一点是

226
00:08:32,616 --> 0:08:34,346
直到现在在这流程上

227
00:08:34,346 --> 0:08:36,186
GPU 还什么都没做

228
00:08:37,106 --> 0:08:40,726
Metal 创建了对象和编码命令

229
00:08:40,775 --> 0:08:41,145
都是基于 CPU 的

230
00:08:41,876 --> 0:08:43,166
只有在你的 App

231
00:08:43,216 --> 0:08:45,356
完成编码命令和

232
00:08:45,356 --> 0:08:46,356
提交命令缓存以后

233
00:08:47,446 --> 0:08:49,226
GPU 才会开始工作并

234
00:08:49,226 --> 0:08:51,376
执行那些命令

235
00:08:52,576 --> 0:08:54,566
你也可以将这些命令编译成

236
00:08:54,566 --> 0:08:56,226
多个并行的命令缓存

237
00:08:56,266 --> 0:08:57,816
到分开的线程上

238
00:08:58,466 --> 0:09:02,056
现在我已经谈到了

239
00:08:58,466 --> 0:09:02,056
现在我已经谈到了

240
00:09:02,056 --> 0:09:03,876
命令队列是如何

241
00:09:03,876 --> 0:09:06,276
产生一个命令缓存的序列

242
00:09:06,276 --> 0:09:07,606
并且你能从命令缓存中

243
00:09:07,606 --> 0:09:09,286
创建一个命令编译器

244
00:09:10,196 --> 0:09:11,216
让我们更细致地看一看

245
00:09:11,216 --> 0:09:13,096
这些用来写入命令缓存的

246
00:09:13,096 --> 0:09:14,466
编码器对象

247
00:09:15,726 --> 0:09:17,036
它们有三种主要类型

248
00:09:18,096 --> 0:09:18,986
Render Command Encoder

249
00:09:18,986 --> 0:09:20,606
它的命令类似于 OpenGL 命令字符串

250
00:09:20,606 --> 0:09:22,266
对于这些命令你可以

251
00:09:22,356 --> 0:09:23,776
设置状态

252
00:09:23,776 --> 0:09:25,316
绑定对象和发出绘图申请

253
00:09:26,446 --> 0:09:27,736
还有一个是 Blit Command Encoder

254
00:09:27,906 --> 0:09:29,306
基于它你可以发出纹理

255
00:09:29,306 --> 0:09:31,246
和缓存拷贝操作

256
00:09:31,576 --> 0:09:32,786
你也可以用它来生成

257
00:09:32,786 --> 0:09:34,526
用于纹理和从缓存中 转移

258
00:09:34,566 --> 0:09:36,156
像素数据的 Mipmap 就类似于

259
00:09:36,156 --> 0:09:38,076
glReadPixels 如何对 OpenGL 的

260
00:09:38,076 --> 0:09:40,266
像素缓存对象操作的

261
00:09:40,806 --> 0:09:43,496
最后是 Compute Command Encoder

262
00:09:43,756 --> 0:09:46,076
它让你可以

263
00:09:46,076 --> 0:09:48,466
分派内核

264
00:09:49,316 --> 0:09:50,826
Render Command Encoder 可能将会是

265
00:09:50,826 --> 0:09:51,746
你最熟悉的编码器

266
00:09:51,746 --> 0:09:54,346
因为它负责

267
00:09:54,346 --> 0:09:56,206
大部分基于图形的 App

268
00:09:56,206 --> 0:09:57,976
需要的操作

269
00:09:59,306 --> 0:10:00,816
这一组命令编译进

270
00:09:59,306 --> 0:10:00,816
这一组命令编译进

271
00:10:00,816 --> 0:10:01,966
Render Command Encoder

272
00:10:02,006 --> 0:10:03,836
通常被称为 Render Pass

273
00:10:05,406 --> 0:10:06,576
在 Render Pass 中你可以设置

274
00:10:06,576 --> 0:10:08,016
为图形管道建立的渲染对象

275
00:10:08,016 --> 0:10:10,236
和发出与这些对象一起的

276
00:10:10,676 --> 0:10:11,586
绘图命令

277
00:10:12,226 --> 0:10:13,726
这就包括了一些

278
00:10:13,726 --> 0:10:15,946
类似于 glDrawArrays 和

279
00:10:15,946 --> 0:10:18,696
glDrawElements 和其他一些

280
00:10:18,816 --> 0:10:19,566
OpenGL 绘图命令

281
00:10:21,006 --> 0:10:22,416
每个 Render Command Encoder 都

282
00:10:22,416 --> 0:10:24,156
紧密地与一系列渲染对象

283
00:10:24,306 --> 0:10:25,126
联系在一起

284
00:10:26,976 --> 0:10:28,806
渲染目标就是一个

285
00:10:28,806 --> 0:10:30,306
可以绘制的简单纹理

286
00:10:30,846 --> 0:10:32,636
它包括了颜色 深度和

287
00:10:32,666 --> 0:10:34,166
模板纹理以及

288
00:10:34,166 --> 0:10:35,356
多样本纹理

289
00:10:36,436 --> 0:10:37,606
你可以指定一系列渲染目标

290
00:10:37,606 --> 0:10:38,976
在你从命令缓存中

291
00:10:38,976 --> 0:10:42,336
创建渲染命令编码器的时候

292
00:10:42,516 --> 0:10:43,906
所有绘图命令

293
00:10:43,906 --> 0:10:45,596
都在编码器的寿命内

294
00:10:45,596 --> 0:10:47,036
指向这些目标

295
00:10:48,506 --> 0:10:49,826
如果想要导向 一个命令去新的对象

296
00:10:49,826 --> 0:10:51,396
你可以通过当前的渲染命令编译器

297
00:10:51,396 --> 0:10:52,886
结束编码过程

298
00:10:53,116 --> 0:10:55,536
然后去和新的对象去

299
00:10:55,536 --> 0:10:56,256
创建新的编译器

300
00:10:57,216 --> 0:10:58,836
这就明确地

301
00:10:58,836 --> 0:11:01,076
区分了导向

302
00:10:58,836 --> 0:11:01,076
区分了导向

303
00:11:01,126 --> 0:11:03,506
不同渲染对象的命令

304
00:11:04,186 --> 0:11:06,196
我们再说一说

305
00:11:06,506 --> 0:11:08,256
你们在渲染过程中要用到的对象

306
00:11:09,446 --> 0:11:10,476
Metal 有很多类似于

307
00:11:10,476 --> 0:11:11,276
OpenGL 的对象

308
00:11:11,276 --> 0:11:14,346
包括纹理 缓存

309
00:11:15,136 --> 0:11:17,846
采样器和管道状态对象

310
00:11:17,846 --> 0:11:19,666
这些对象类似于 OpenGL 的

311
00:11:19,696 --> 0:11:22,086
程序对象

312
00:11:22,206 --> 0:11:23,766
还有深度模板状态对象

313
00:11:23,766 --> 0:11:24,966
它们并不真的存在于 OpenGL 中

314
00:11:25,176 --> 0:11:26,706
而只是 OpenGL 有的

315
00:11:26,706 --> 0:11:28,156
有相同深度和

316
00:11:28,396 --> 0:11:29,346
模板状态的容器

317
00:11:31,496 --> 0:11:32,996
一个区别 OpenGL 和 Metal 对象

318
00:11:33,076 --> 0:11:35,556
的重要不同是

319
00:11:35,906 --> 0:11:37,866
它们怎么被创建的和管理的

320
00:11:39,176 --> 0:11:40,336
这些对象都是通过

321
00:11:40,336 --> 0:11:41,756
设备对象创建的

322
00:11:41,756 --> 0:11:43,426
所以它们只与单个 GPU 相关联

323
00:11:44,716 --> 0:11:46,156
你设置大部分对象状态

324
00:11:46,276 --> 0:11:48,316
是你通过指定属性

325
00:11:48,646 --> 0:11:50,656
在描述符对象中创建它的时候

326
00:11:51,936 --> 0:11:53,656
所有状态都是在

327
00:11:53,656 --> 0:11:55,166
对象被创建的时候设置的

328
00:11:55,166 --> 0:11:55,596
这些状态是固定的 并且不可改变的

329
00:11:56,946 --> 0:11:58,306
虽然这个纹理和缓存的状态

330
00:11:58,306 --> 0:11:59,856
是在创建时就被固定的

331
00:11:59,856 --> 0:12:02,226
但是这些对象包含的数据

332
00:11:59,856 --> 0:12:02,226
但是这些对象包含的数据

333
00:12:02,226 --> 0:12:03,976
是可以被改变的

334
00:12:04,626 --> 0:12:07,296
Metal 可以为这些对象

335
00:12:07,446 --> 0:12:09,596
创建新的编码器 当它被创建的时候

336
00:12:10,396 --> 0:12:12,146
OpenGL 的可变模型

337
00:12:12,176 --> 0:12:13,766
完全可能让

338
00:12:13,766 --> 0:12:15,186
你的 App 在触碰到一小块状态的时候

339
00:12:15,186 --> 0:12:18,176
这个对象会重新

340
00:12:18,176 --> 0:12:19,206
开始编译

341
00:12:19,946 --> 0:12:21,256
即便你的 App 没有

342
00:12:21,256 --> 0:12:23,846
改变对象的状态

343
00:12:23,846 --> 0:12:25,176
OpenGL 也会需要检查标记的层次结构

344
00:12:25,226 --> 0:12:27,326
这样做是为了在绘图之前确认无误

345
00:12:28,186 --> 0:12:30,596
所以通过这个不可改变的模型

346
00:12:30,596 --> 0:12:32,176
Metal 永远不需要检查

347
00:12:32,176 --> 0:12:34,106
对象状态的改变

348
00:12:34,106 --> 0:12:36,016
这就使绘图调用快很多

349
00:12:37,556 --> 0:12:39,166
另外 对象能在跨线程中

350
00:12:39,256 --> 0:12:41,106
更高效的被利用

351
00:12:41,516 --> 0:12:42,756
Metal 永远不用锁定一个对象

352
00:12:42,756 --> 0:12:43,746
只是因为避免它

353
00:12:43,746 --> 0:12:44,996
在转换到其他线程的时候

354
00:12:45,146 --> 0:12:45,956
陷入无效状态

355
00:12:51,306 --> 0:12:52,826
那么我们再来谈谈移植

356
00:12:52,826 --> 0:12:57,256
这是一个典型的阶段

357
00:12:57,256 --> 0:12:59,286
这些是一些经典的

358
00:12:59,286 --> 0:13:00,226
渲染 App 的阶段

359
00:12:59,286 --> 0:13:00,226
渲染 App 的阶段

360
00:13:01,046 --> 0:13:02,166
你搭建一个 App 去编译资源

361
00:13:02,166 --> 0:13:03,746
和捆绑资产

362
00:13:04,696 --> 0:13:05,926
开始并初始化它

363
00:13:06,306 --> 0:13:07,796
加载这些资产

364
00:13:07,796 --> 0:13:09,666
初始化将会一直

365
00:13:09,666 --> 0:13:11,986
出现在你 App 里的对象

366
00:13:13,236 --> 0:13:14,966
然后你不断地重复

367
00:13:15,456 --> 0:13:16,976
渲染设定状态

368
00:13:16,976 --> 0:13:19,336
发布多个绘图需求

369
00:13:19,486 --> 0:13:19,986
然后一帧一帧地展现

370
00:13:20,676 --> 0:13:23,816
我将会谈谈

371
00:13:23,816 --> 0:13:25,686
在早期阶段 App 中的

372
00:13:25,686 --> 0:13:26,796
Metal 开发过程

373
00:13:28,316 --> 0:13:29,806
包括着色器的离线创建

374
00:13:29,806 --> 0:13:32,136
创建对象的初始化

375
00:13:33,256 --> 0:13:34,666
之后 Sukanya 会解释如何

376
00:13:34,666 --> 0:13:36,656
移植每一帧的渲染代码

377
00:13:38,676 --> 0:13:39,936
所以让我们从

378
00:13:39,936 --> 0:13:41,706
App 的创建时间开始

379
00:13:41,706 --> 0:13:43,736
就是着色器被编译的时候

380
00:13:44,896 --> 0:13:47,006
我们将从着色语言开始

381
00:13:47,866 --> 0:13:49,006
Metal 的着色语言

382
00:13:49,126 --> 0:13:50,476
是基于 C++ 的

383
00:13:50,936 --> 0:13:53,316
所以就像你创建 C++ 的

384
00:13:53,386 --> 0:13:55,206
类 模板 结构

385
00:13:55,606 --> 0:13:57,336
定义 名称空间 一样

386
00:13:58,466 --> 0:14:00,156
比如说 GLSL

387
00:13:58,466 --> 0:14:00,156
比如说 GLSL

388
00:14:00,156 --> 0:14:02,796
我们有内置的向量和矩阵类型

389
00:14:02,796 --> 0:14:04,176
也有很多的内置方法和

390
00:14:04,176 --> 0:14:06,436
图形处理常用的运算符

391
00:14:06,486 --> 0:14:09,236
也有一些类

392
00:14:09,316 --> 0:14:11,006
指定采样器的状态

393
00:14:11,006 --> 0:14:11,426
并在纹理上执行

394
00:14:12,966 --> 0:14:13,986
描述这个语言最好的方式

395
00:14:13,986 --> 0:14:15,166
刚才已经展示给你们了

396
00:14:15,396 --> 0:14:17,846
所以这是顶点和片段着色器对

397
00:14:19,336 --> 0:14:20,966
顶部方法中的顶点关键字

398
00:14:20,966 --> 0:14:24,196
说明了它是一个顶点着色器

399
00:14:24,196 --> 0:14:25,886
同样适用于

400
00:14:25,886 --> 0:14:28,306
底部方法的片段关键字

401
00:14:29,706 --> 0:14:31,366
注意它们有自定义的名字

402
00:14:31,426 --> 0:14:33,226
这一点不像 GLSL 一样每个着色器

403
00:14:33,266 --> 0:14:34,116
就只是被叫做 main

404
00:14:34,756 --> 0:14:35,726
这非常的关键 因为

405
00:14:35,726 --> 0:14:37,166
它允许你去构建一个大型的库

406
00:14:37,166 --> 0:14:38,976
库里的每一个着色器都用名字

407
00:14:39,206 --> 0:14:41,506
去表明它们的功能

408
00:14:41,936 --> 0:14:44,446
每一个从你的 App 传出的东西

409
00:14:44,446 --> 0:14:47,266
都是这些其中一个着色器的参数

410
00:14:48,026 --> 0:14:49,316
并且它不像 GLSL 一样

411
00:14:49,316 --> 0:14:50,486
会在方法外有

412
00:14:50,486 --> 0:14:51,416
松散变量

413
00:14:52,486 --> 0:14:53,786
就像你看到的

414
00:14:53,846 --> 0:14:55,646
这些参数旁边会有括号

415
00:14:56,226 --> 0:14:58,136
它们是属性说明符

416
00:14:58,386 --> 0:14:59,946
这是从 C++ 里拓展来的

417
00:14:59,946 --> 0:15:02,236
为了表示特殊的变量

418
00:14:59,946 --> 0:15:02,236
为了表示特殊的变量

419
00:15:03,456 --> 0:15:05,666
所以这个顶点 ID 属性

420
00:15:05,746 --> 0:15:07,446
表明了这个 VID 参数

421
00:15:07,446 --> 0:15:08,576
应该在顶点被执行时包括

422
00:15:08,666 --> 0:15:12,826
当前顶点的索引值

423
00:15:13,196 --> 0:15:14,906
在这两个地方我们会用到它

424
00:15:14,906 --> 0:15:17,676
去将索引值放置到顶点数组中

425
00:15:18,226 --> 0:15:20,636
这些带有缓存属性的

426
00:15:20,636 --> 0:15:22,866
参数说明符

427
00:15:22,866 --> 0:15:24,186
表明了这些变量

428
00:15:24,226 --> 0:15:26,106
被 Metal API 里设定的

429
00:15:26,246 --> 0:15:27,436
缓存对象所填满

430
00:15:27,436 --> 0:15:29,596
我一会将会多说一些

431
00:15:29,596 --> 0:15:31,596
Metal API 是怎么与这些有关联的

432
00:15:32,266 --> 0:15:33,626
但是首先我们先来看看

433
00:15:33,626 --> 0:15:35,136
这里用到的一些类型

434
00:15:36,056 --> 0:15:37,776
现在这些都是你可以定义的

435
00:15:38,366 --> 0:15:39,386
自定义类型

436
00:15:40,406 --> 0:15:41,656
这里的顶点参数

437
00:15:41,656 --> 0:15:43,606
被定义为指向顶点类型的指针

438
00:15:43,606 --> 0:15:45,886
这就是它的定义

439
00:15:46,706 --> 0:15:48,836
这个结构包括两个成员

440
00:15:48,836 --> 0:15:50,586
一个是模型位置成员

441
00:15:50,586 --> 0:15:51,736
另一个是纹理坐标成员

442
00:15:52,446 --> 0:15:54,116
它在顶点数组里定义了 每一个顶点的

443
00:15:54,146 --> 0:15:56,186
布局和内存

444
00:15:56,526 --> 0:15:58,096
这个数据会被传递到这个顶点的着色器

445
00:15:59,836 --> 0:16:01,336
我们再来看看这个顶点的输出类型

446
00:15:59,836 --> 0:16:01,336
我们再来看看这个顶点的输出类型

447
00:16:01,336 --> 0:16:03,186
它是从顶点着色器里返回的

448
00:16:03,776 --> 0:16:06,506
它这里的定义指定了

449
00:16:06,506 --> 0:16:07,736
什么被传递下去用于

450
00:16:07,736 --> 0:16:09,186
光栈化阶段并

451
00:16:09,186 --> 0:16:10,806
最终用于分片程序

452
00:16:11,336 --> 0:16:13,756
包含了四个部分的

453
00:16:13,756 --> 0:16:15,146
浮动点成员被称为 clipPos

454
00:16:15,186 --> 0:16:17,396
clipPos 在他的旁边有

455
00:16:17,396 --> 0:16:18,766
位置属性说明符

456
00:16:19,336 --> 0:16:20,756
这就表明了这个成员

457
00:16:20,756 --> 0:16:22,096
会作为一个顶点着色器的

458
00:16:22,136 --> 0:16:23,746
位置输出

459
00:16:25,116 --> 0:16:26,376
这个 texCoord 成员

460
00:16:26,376 --> 0:16:27,326
并不带有默认为变量的

461
00:16:27,326 --> 0:16:30,096
属性说明符

462
00:16:30,306 --> 0:16:31,656
它会和其他顶点的纹理坐标值

463
00:16:31,656 --> 0:16:36,726
一起被插入去定义

464
00:16:36,726 --> 0:16:38,616
光栅化三角形

465
00:16:38,616 --> 0:16:39,986
这就跟 GLSL 很不一样

466
00:16:41,616 --> 0:16:42,616
我们再来看看

467
00:16:42,616 --> 0:16:44,046
我们分片着色器的参数

468
00:16:45,146 --> 0:16:46,796
所以我们会用到这个 vertexOutput 结构体

469
00:16:46,796 --> 0:16:48,966
我们刚刚看过的这个结构体

470
00:16:49,406 --> 0:16:51,716
会作为我们分片着色器的输入

471
00:16:52,336 --> 0:16:53,966
同时它给了我们插入的

472
00:16:54,006 --> 0:16:55,446
纹理坐标

473
00:16:55,716 --> 0:16:57,346
这个坐标我们已经在顶点着色器里构造了

474
00:16:58,486 --> 0:17:00,206
我们这里用它来

475
00:16:58,486 --> 0:17:00,206
我们这里用它来

476
00:17:00,366 --> 0:17:02,966
从纹理中取样

477
00:17:03,086 --> 0:17:04,586
在我们写好的 Objective-C 

478
00:17:04,586 --> 0:17:06,486
App 代码中

479
00:17:06,486 --> 0:17:08,316
我们用 Render Command Encoder 去

480
00:17:08,406 --> 0:17:10,226
将对象映射到着色器参数

481
00:17:12,915 --> 0:17:15,016
这个带有请求的索引参数

482
00:17:15,016 --> 0:17:16,396
非常类似于

483
00:17:16,396 --> 0:17:18,316
OpenGL 的属性索引

484
00:17:18,366 --> 0:17:20,715
顶点属性索引和纹理单元

485
00:17:21,336 --> 0:17:23,415
它们指定了哪一个索引

486
00:17:23,526 --> 0:17:25,836
映射到了我们着色器参数

487
00:17:27,026 --> 0:17:29,056
所以通过请求编译器的含有三个索引值的

488
00:17:29,106 --> 0:17:30,526
集合片段缓存方法

489
00:17:30,526 --> 0:17:33,046
我们可以将我的标准缓存对象

490
00:17:33,046 --> 0:17:37,446
映射到我们的着色器的

491
00:17:37,446 --> 0:17:38,936
标准编码器参数

492
00:17:39,536 --> 0:17:42,326
我们进行类似的请求去

493
00:17:42,326 --> 0:17:44,836
设置我们的纹理和采样器对象

494
00:17:50,396 --> 0:17:52,096
现在我们来多说一下

495
00:17:52,096 --> 0:17:53,996
着色器开发里

496
00:17:54,106 --> 0:17:55,606
特别有用的一个库

497
00:17:57,236 --> 0:17:58,576
它叫 SIMD

498
00:17:58,896 --> 0:18:00,666
现在 SIMD 实际上是一个

499
00:17:58,896 --> 0:18:00,666
现在 SIMD 实际上是一个

500
00:18:00,966 --> 0:18:02,616
分离于 Metal 的库

501
00:18:03,126 --> 0:18:05,246
经常用于许多正交框架

502
00:18:05,836 --> 0:18:07,366
但是它在思想上

503
00:18:07,366 --> 0:18:07,686
跟 Metal 很相似

504
00:18:08,936 --> 0:18:10,886
SIMD 定义了常用的

505
00:18:10,886 --> 0:18:12,786
向量和矩阵类型

506
00:18:13,286 --> 0:18:15,056
去实现图形化算法

507
00:18:15,056 --> 0:18:16,036
所以它包括了三四个

508
00:18:16,036 --> 0:18:17,846
向量类型和

509
00:18:17,846 --> 0:18:19,976
三乘三和四乘四 矩阵类型

510
00:18:24,046 --> 0:18:24,906
这个库最棒的特性之一是

511
00:18:24,906 --> 0:18:26,676
你能用它

512
00:18:26,676 --> 0:18:30,496
在你的 App 代码

513
00:18:30,496 --> 0:18:33,306
和着色语言代码之间

514
00:18:33,306 --> 0:18:34,966
分享代码

515
00:18:35,596 --> 0:18:37,216
这真的很有用

516
00:18:37,216 --> 0:18:38,856
因为你可以定义数据的布局

517
00:18:38,926 --> 0:18:39,986
这些数据和结构就是通过这些类型

518
00:18:39,986 --> 0:18:42,066
从你的 App 传递

519
00:18:42,066 --> 0:18:43,426
到你的着色器

520
00:18:44,046 --> 0:18:44,766
它怎么工作的呢

521
00:18:45,996 --> 0:18:47,276
你先创建一个带有数据的结构

522
00:18:47,346 --> 0:18:48,216
这些数据是你想要从你的 App

523
00:18:48,216 --> 0:18:49,516
传递到你的着色器的

524
00:18:49,836 --> 0:18:51,396
所以举例来说

525
00:18:51,396 --> 0:18:52,536
如果你想传递一个

526
00:18:52,536 --> 0:18:55,206
模型视图投影矩阵

527
00:18:55,206 --> 0:18:56,646
和这个 SIMD 的首要光源位置

528
00:18:56,646 --> 0:18:58,696
你就可以在你的结构中

529
00:18:58,696 --> 0:19:01,546
通过 SIMD 类型去实现

530
00:18:58,696 --> 0:19:01,546
通过 SIMD 类型去实现

531
00:19:01,976 --> 0:19:02,746
你将结构的定义

532
00:19:02,746 --> 0:19:05,106
和头文件都包含在

533
00:19:05,106 --> 0:19:08,796
你的 App 代码和 Metal 文件里

534
00:19:09,116 --> 0:19:10,756
这样的话你着色器里用的

535
00:19:10,756 --> 0:19:12,566
数据布局就能与你的代码

536
00:19:12,566 --> 0:19:14,036
匹配上 因为它们

537
00:19:14,036 --> 0:19:15,286
使用了相同的类型

538
00:19:16,686 --> 0:19:18,296
这样布局不匹配的问题就会

539
00:19:18,296 --> 0:19:19,976
出现的更少

540
00:19:24,046 --> 0:19:25,556
Metal 实现高效的

541
00:19:25,556 --> 0:19:27,716
一个关键因素是

542
00:19:27,716 --> 0:19:30,456
更早地开始工作并且频率更低

543
00:19:31,376 --> 0:19:33,426
所以你将需要在建立 App 的时候

544
00:19:33,426 --> 0:19:34,896
用 Xcode 去编译

545
00:19:34,896 --> 0:19:35,856
Metal 着色器

546
00:19:36,986 --> 0:19:38,206
这运行了一个前端编译

547
00:19:38,206 --> 0:19:39,866
来执行字符串解析

548
00:19:39,866 --> 0:19:41,826
着色器分析和

549
00:19:41,826 --> 0:19:43,226
一些基本的优化

550
00:19:43,986 --> 0:19:45,526
它将你的代码转换成

551
00:19:45,526 --> 0:19:46,796
一个二进制的中间表示

552
00:19:46,796 --> 0:19:49,456
它在任何硬件上都能使用

553
00:19:50,456 --> 0:19:52,566
实际的 GPU 机器代码

554
00:19:52,566 --> 0:19:54,156
直到你的代码在用户系统上运行以前

555
00:19:54,156 --> 0:19:54,976
都不会被构建的

556
00:19:55,516 --> 0:19:56,726
但是这在你的代码运行的时候

557
00:19:56,726 --> 0:19:58,976
移除了一半的编译时间

558
00:19:59,996 --> 0:20:02,886
这个搭建的

559
00:19:59,996 --> 0:20:02,886
这个搭建的

560
00:20:02,886 --> 0:20:05,286
二进制中间表示

561
00:20:05,376 --> 0:20:07,926
是通过 Metal 库文件实现的

562
00:20:08,576 --> 0:20:10,376
Xcode 会将所有 Metal

563
00:20:10,376 --> 0:20:11,656
着色器源文件编译进

564
00:20:11,776 --> 0:20:13,856
一个默认的 Metal 库

565
00:20:13,856 --> 0:20:16,256
为了运行时检索

566
00:20:16,256 --> 0:20:17,276
将他放进你的 App 包中

567
00:20:17,936 --> 0:20:20,686
除了有 Xcode 建立的着色器

568
00:20:20,686 --> 0:20:23,286
你也可以在 App

569
00:20:23,286 --> 0:20:24,726
运行过程中创建着色器

570
00:20:26,126 --> 0:20:27,436
一些 OpenGL App 在运行过程中

571
00:20:27,436 --> 0:20:28,446
创建着色器是通过

572
00:20:28,546 --> 0:20:30,096
连接字符串或者运行

573
00:20:30,096 --> 0:20:31,616
源代码生成器实现的

574
00:20:32,646 --> 0:20:33,846
要在构建期间

575
00:20:33,846 --> 0:20:35,826
获取所有着色器会非常有挑战性

576
00:20:36,846 --> 0:20:38,756
但是为了特定的目的或者

577
00:20:38,856 --> 0:20:40,476
如果构建时间编译

578
00:20:40,476 --> 0:20:41,486
在你的 App 里并不可能实现

579
00:20:41,876 --> 0:20:43,486
那么 Metal 是可以像 OpenGL 一样

580
00:20:43,486 --> 0:20:45,326
在运行期间通过源文件

581
00:20:45,326 --> 0:20:45,836
编译着色器的

582
00:20:46,386 --> 0:20:49,346
然而 这样做

583
00:20:49,346 --> 0:20:50,896
会有很多不好的地方

584
00:20:50,896 --> 0:20:52,416
最明显的是你会放弃

585
00:20:52,416 --> 0:20:53,636
节约性能

586
00:20:53,636 --> 0:20:54,986
因为这在用户系统之外工作

587
00:20:56,216 --> 0:20:57,206
你不会在构建期间

588
00:20:57,206 --> 0:20:58,546
看见任何的着色器编译错误

589
00:20:58,546 --> 0:21:00,776
所以你只能在你运行代码的时候才发现

590
00:20:58,546 --> 0:21:00,776
所以你只能在你运行代码的时候才发现

591
00:21:01,896 --> 0:21:03,436
最后 如果你是在运行时编译

592
00:21:03,436 --> 0:21:04,766
你就不能在着色器中包含

593
00:21:04,766 --> 0:21:06,246
头文件 所以你就不能

594
00:21:06,246 --> 0:21:07,526
在你的 App 代码

595
00:21:07,526 --> 0:21:09,686
和着色器代码之间分享代码

596
00:21:10,236 --> 0:21:12,776
如果你在运行期间通过

597
00:21:12,776 --> 0:21:14,546
分享编译来使你的 App 工作

598
00:21:14,546 --> 0:21:16,066
那我强烈地建议你

599
00:21:16,066 --> 0:21:18,146
花点时间让你的

600
00:21:18,146 --> 0:21:19,966
着色器在 Xcode 里边编译

601
00:21:20,586 --> 0:21:21,676
这样做你可以获得很多好处

602
00:21:21,676 --> 0:21:23,056
比如说节约运行时间

603
00:21:23,056 --> 0:21:24,246
和更为方便

604
00:21:24,246 --> 0:21:26,046
你的着色器开发

605
00:21:26,526 --> 0:21:29,426
我们来看看

606
00:21:29,426 --> 0:21:30,646
你的 App 

607
00:21:30,646 --> 0:21:31,946
初始化你的 Metal 渲染器 的步骤

608
00:21:32,186 --> 0:21:33,376
这要创建

609
00:21:33,376 --> 0:21:34,246
很多对象

610
00:21:34,746 --> 0:21:36,286
我将从设备入手

611
00:21:36,286 --> 0:21:37,666
然后是命令队列

612
00:21:37,666 --> 0:21:39,826
之后我会描述怎样

613
00:21:39,826 --> 0:21:40,966
建立对象 

614
00:21:40,966 --> 0:21:43,426
包括纹理 缓存器和管道对象

615
00:21:45,046 --> 0:21:47,566
所以设备和队列

616
00:21:47,726 --> 0:21:50,016
是你要创建的第一个对象

617
00:21:50,636 --> 0:21:53,506
设备是 GPU 的一个

618
00:21:53,506 --> 0:21:54,866
抽象表现

619
00:21:56,226 --> 0:21:57,346
它负责创建

620
00:21:57,346 --> 0:21:58,436
用于渲染的对象

621
00:21:58,436 --> 0:21:59,416
它们包括

622
00:21:59,456 --> 0:22:01,386
纹理 缓存和管道对象

623
00:21:59,456 --> 0:22:01,386
纹理 缓存和管道对象

624
00:22:02,846 --> 0:22:04,506
在 iOS 还只有一个

625
00:22:04,506 --> 0:22:06,826
GPU 的时候

626
00:22:06,826 --> 0:22:08,626
你只能有一个设备

627
00:22:08,916 --> 0:22:10,356
但是在 macOS 系统上可以有

628
00:22:10,356 --> 0:22:12,216
多个设备因为它们可能

629
00:22:12,216 --> 0:22:14,126
都集成在了分散的 GPU

630
00:22:14,126 --> 0:22:16,026
或多个 eGPU 上

631
00:22:17,236 --> 0:22:18,286
虽然通常情况下

632
00:22:18,286 --> 0:22:20,146
用默认的设备对于大多数 App

633
00:22:20,146 --> 0:22:21,126
都足够了

634
00:22:21,886 --> 0:22:23,776
而且获取这个设备

635
00:22:23,826 --> 0:22:25,216
是很简单的

636
00:22:25,276 --> 0:22:26,876
你调用 MTLCreateSystem

637
00:22:26,876 --> 0:22:27,616
DefaultDevice 即可

638
00:22:28,296 --> 0:22:31,136
对于这个设备

639
00:22:31,136 --> 0:22:33,396
你要做的第一件事就是

640
00:22:33,396 --> 0:22:33,966
创建一个命令队列

641
00:22:35,746 --> 0:22:37,416
这个队列主要用于你的

642
00:22:37,416 --> 0:22:38,736
App 渲染循环

643
00:22:38,736 --> 0:22:40,036
去在每一帧里获取命令缓存

644
00:22:40,086 --> 0:22:41,536
但是你需要在

645
00:22:41,536 --> 0:22:42,836
初始化的时候创建

646
00:22:42,996 --> 0:22:43,826
命令队列

647
00:22:45,036 --> 0:22:46,176
通常情况下 单个队列就足够了

648
00:22:46,176 --> 0:22:48,006
但是更复杂的 App 

649
00:22:48,276 --> 0:22:49,926
会在多个队列中

650
00:22:49,926 --> 0:22:51,986
同时被执行

651
00:22:53,206 --> 0:22:54,696
创建一个队列也是非常简单的

652
00:22:54,696 --> 0:22:56,666
你可以调用 newCommandQueue

653
00:22:56,906 --> 0:22:58,336
和刚才你创建好的设备

654
00:22:58,956 --> 0:22:59,996
一旦你获取了你的队列

655
00:23:00,276 --> 0:23:02,306
你就可以得到渲染循环的命令缓存

656
00:23:02,806 --> 0:23:06,846
我们继续来看一看创建

657
00:23:06,846 --> 0:23:07,546
渲染对象

658
00:23:08,216 --> 0:23:10,546
我将会说一说创建

659
00:23:10,736 --> 0:23:12,106
三种类型的对象

660
00:23:12,106 --> 0:23:14,426
它们用于渲染 纹理 缓存和管道

661
00:23:15,496 --> 0:23:17,846
我们先从纹理开始

662
00:23:18,106 --> 0:23:19,466
就像之前所提到的

663
00:23:19,466 --> 0:23:21,066
你通过设备对象 创建渲染对象

664
00:23:22,416 --> 0:23:23,756
你大部分情况下 将会用到描述符对象

665
00:23:23,756 --> 0:23:24,836
去创造这些对象

666
00:23:25,546 --> 0:23:26,916
描述符是非常简单的对象

667
00:23:26,916 --> 0:23:28,756
它没有任何真方法

668
00:23:29,296 --> 0:23:31,856
它们只包含用于对象建立的属性

669
00:23:33,146 --> 0:23:34,526
举个例子

670
00:23:34,526 --> 0:23:36,326
你会需要一个纹理描述符去创建纹理

671
00:23:37,076 --> 0:23:38,306
你可以指定

672
00:23:38,306 --> 0:23:39,666
你想要创建的纹理的属性

673
00:23:40,186 --> 0:23:41,406
比如说纹理的类型

674
00:23:41,436 --> 0:23:43,396
2D 3D 和 cubeMap

675
00:23:44,146 --> 0:23:45,296
纹理的维度和

676
00:23:45,296 --> 0:23:47,286
它所需要的 Mipmap 的数量

677
00:23:47,286 --> 0:23:49,746
还有纹理中包含的

678
00:23:50,676 --> 0:23:51,576
数据像素格式

679
00:23:51,706 --> 0:23:53,416
一旦你设定好

680
00:23:53,416 --> 0:23:54,346
每一个属性需要的值

681
00:23:54,346 --> 0:23:56,076
你就可以在设备上调用方法

682
00:23:56,076 --> 0:23:58,856
去创建可用的纹理对象

683
00:24:00,816 --> 0:24:03,156
这也需要为返回纹理图像

684
00:24:03,266 --> 0:24:04,726
分配内存

685
00:24:06,086 --> 0:24:07,946
一旦你创建了对象 你就不再需要

686
00:24:07,946 --> 0:24:09,286
描述符了 因为它只是用来

687
00:24:09,286 --> 0:24:10,126
创建对象的

688
00:24:11,256 --> 0:24:12,296
然后你设置在描述符中的属性

689
00:24:12,296 --> 0:24:14,396
就会被锁定并且不能再改变

690
00:24:15,766 --> 0:24:17,056
然后 纹理图像的内容

691
00:24:17,056 --> 0:24:18,726
是可以修改的

692
00:24:18,756 --> 0:24:21,816
所以我会再说一下一个

693
00:24:21,816 --> 0:24:22,816
你将设定在纹理描述符中的属性

694
00:24:22,816 --> 0:24:24,096
同时你也能

695
00:24:24,096 --> 0:24:25,876
在创建缓存的时候使用

696
00:24:26,626 --> 0:24:28,166
这被称为存储模式

697
00:24:29,286 --> 0:24:30,366
就像之前提到的

698
00:24:30,366 --> 0:24:31,966
在你创建纹理的时候

699
00:24:31,966 --> 0:24:33,596
Metal 会为它分配内存

700
00:24:34,106 --> 0:24:35,276
存储模式属性告诉

701
00:24:35,276 --> 0:24:37,406
Metal 要在哪一个内存池中去分配内存

702
00:24:38,576 --> 0:24:40,056
最简单的方式

703
00:24:40,056 --> 0:24:42,436
去共享存储模式就是同时给

704
00:24:42,876 --> 0:24:44,046
CPU 和 GPU 访问权限

705
00:24:44,656 --> 0:24:46,076
对于缓存来说这就是

706
00:24:46,076 --> 0:24:47,666
你为指向对象的内存

707
00:24:47,666 --> 0:24:48,156
获取了一个指针

708
00:24:48,996 --> 0:24:50,166
Protector 代表着你可以

709
00:24:50,166 --> 0:24:51,926
调用简易的方法

710
00:24:52,196 --> 0:24:54,196
从纹理中去设定和获取数据

711
00:24:54,736 --> 0:24:57,246
你可以用私有存储模式

712
00:24:57,246 --> 0:24:58,836
这种模式只给了 GPU 访问

713
00:24:58,926 --> 0:25:00,486
数据的权限

714
00:24:58,926 --> 0:25:00,486
数据的权限

715
00:25:00,486 --> 0:25:01,356
这就允许了 Metal 

716
00:25:01,356 --> 0:25:03,906
去执行优化

717
00:25:03,906 --> 0:25:05,786
不然可能在 CPU 有访问数据权限的时候

718
00:25:05,786 --> 0:25:06,206
是无法达成的

719
00:25:06,896 --> 0:25:08,776
但是只有 GPU 可以直接

720
00:25:08,886 --> 0:25:11,096
填写这种纹理类型的内容

721
00:25:12,606 --> 0:25:14,016
你也可以间接的通过 CPU 去填写数据

722
00:25:14,206 --> 0:25:15,996
这可以通过使用 blit 编码器让 CPU 实现

723
00:25:15,996 --> 0:25:17,786
blit 通过共享的存储

724
00:25:18,076 --> 0:25:21,026
从第二中间资源去拷贝

725
00:25:22,446 --> 0:25:23,966
在具有专用视频内存的设备上

726
00:25:23,966 --> 0:25:25,656
设定这个资源去使用

727
00:25:25,656 --> 0:25:27,306
私有存储

728
00:25:27,306 --> 0:25:28,396
将它分配成仅用于视频存储

729
00:25:30,396 --> 0:25:32,776
最后 在 macOS 上你可以使用

730
00:25:32,866 --> 0:25:34,756
第三种存储模式 托管存储

731
00:25:35,696 --> 0:25:37,796
这种模式允许 GPU 和 CPU 一起

732
00:25:37,826 --> 0:25:39,066
访问对象数据

733
00:25:39,776 --> 0:25:40,946
而且对于有专用视频内存的系统

734
00:25:40,946 --> 0:25:43,226
Metal 会建立一个镜像内存

735
00:25:43,226 --> 0:25:46,696
反向用于两个处理器的高效访问

736
00:25:47,926 --> 0:25:49,396
正因为这样

737
00:25:49,396 --> 0:25:51,166
显性的调用对于确认

738
00:25:51,236 --> 0:25:53,876
数据在 CPU GPU 上的同步访问是很有必要的

739
00:25:58,126 --> 0:26:00,376
这里是一个创建纹理对象的例子

740
00:25:58,126 --> 0:26:00,376
这里是一个创建纹理对象的例子

741
00:26:00,816 --> 0:26:04,256
首先你创建一个纹理描述符

742
00:26:04,256 --> 0:26:06,126
以及内部的一系列属性

743
00:26:06,126 --> 0:26:08,586
包括存储模式

744
00:26:09,106 --> 0:26:12,836
然后我们通过这个设备

745
00:26:13,586 --> 0:26:14,556
去创建一个纹理

746
00:26:15,916 --> 0:26:17,166
为了去填充纹理的图像数据

747
00:26:17,316 --> 0:26:18,936
我们计算每一行的字节数

748
00:26:19,886 --> 0:26:21,336
这就像用 GLText 一样

749
00:26:21,336 --> 0:26:23,466
[ 音质不清晰 ] 我们指定一个区域去加载

750
00:26:26,196 --> 0:26:27,536
然后我们调用纹理对象的

751
00:26:27,536 --> 0:26:29,506
替换区域方法

752
00:26:29,756 --> 0:26:31,596
它从我们提供的指针中

753
00:26:31,596 --> 0:26:32,926
复制数据到纹理中

754
00:26:37,046 --> 0:26:38,266
这里是一些值得注意的

755
00:26:38,266 --> 0:26:39,396
OpenGL 和 Metal 纹理对象

756
00:26:39,396 --> 0:26:40,446
之间的一些区别

757
00:26:40,816 --> 0:26:42,556
虽然 OpenGL 确实有采样器对象

758
00:26:42,556 --> 0:26:43,886
但是他们是可选的

759
00:26:44,406 --> 0:26:45,576
在 OpenGL 中 

760
00:26:45,576 --> 0:26:46,826
包装模式和过滤器可以被设定在

761
00:26:46,826 --> 0:26:47,886
纹理对象中

762
00:26:48,276 --> 0:26:49,736
在 Metal 里你需要在着色器中

763
00:26:49,816 --> 0:26:51,376
去创建单独的采样器对象

764
00:26:51,376 --> 0:26:53,576
或者是指定的

765
00:26:54,206 --> 0:26:55,096
采样器参数

766
00:26:55,786 --> 0:26:57,336
在 Metal 里纹理图像数据

767
00:26:57,416 --> 0:26:57,946
是不可被翻转的

768
00:26:58,496 --> 0:27:00,996
OpenGL 使用的是左下角原点

769
00:26:58,496 --> 0:27:00,996
OpenGL 使用的是左下角原点

770
00:27:01,306 --> 0:27:03,196
但是 Metal 用的是左上角原点

771
00:27:03,196 --> 0:27:04,426
所以在你加载纹理的时候

772
00:27:04,426 --> 0:27:06,266
你要留意这些区别

773
00:27:06,686 --> 0:27:09,696
桌面版 OpenGL 同时也执行转化

774
00:27:09,796 --> 0:27:10,866
当提供的数据是

775
00:27:10,916 --> 0:27:13,376
不同的格式而不是

776
00:27:13,376 --> 0:27:15,016
内部格式的时候

777
00:27:16,456 --> 0:27:18,106
但是 Metal 和 OpenGL ES 很类似

778
00:27:18,206 --> 0:27:20,346
所以你需要确认

779
00:27:20,346 --> 0:27:21,406
你的数据都已经被

780
00:27:21,436 --> 0:27:23,436
设定成了合适的格式或者

781
00:27:23,696 --> 0:27:25,696
执行路径去进行转化

782
00:27:29,066 --> 0:27:32,316
我们再来看看缓存器

783
00:27:32,456 --> 0:27:34,266
Metal 对于所有非结构体数据

784
00:27:34,266 --> 0:27:34,976
都是用的缓存器

785
00:27:41,456 --> 0:27:42,406
它们非常类似于 OpenGL 的顶点 

786
00:27:42,406 --> 0:27:45,646
元素和标准缓存

787
00:27:45,926 --> 0:27:47,076
所以如果你已经在 OpenGL 中用了这些缓存器

788
00:27:47,076 --> 0:27:48,456
你在处理你的端口的时候

789
00:27:48,506 --> 0:27:50,126
就会更容易一些

790
00:27:51,506 --> 0:27:52,686
通过设备你能很轻易地创建缓存器

791
00:27:52,686 --> 0:27:54,456
这个设备是你通过 newBufferWithLength

792
00:27:54,516 --> 0:27:55,986
调用的 它指定了你想要

793
00:27:55,986 --> 0:27:57,146
多大的缓存

794
00:27:57,826 --> 0:27:59,626
你也可以指定存储模式

795
00:28:00,986 --> 0:28:01,996
你通过内容属性

796
00:28:02,036 --> 0:28:03,506
去加载缓存器

797
00:28:03,506 --> 0:28:05,026
这个属性是一个没有返回值的指针

798
00:28:05,026 --> 0:28:06,186
指向返回缓存器的内存

799
00:28:07,276 --> 0:28:08,706
对于 Metal 的核

800
00:28:08,706 --> 0:28:10,076
这个数据是完全没有结构的

801
00:28:10,076 --> 0:28:11,896
所以这就取决于你要怎么去定义

802
00:28:12,196 --> 0:28:14,066
你 App 的布局和怎样

803
00:28:14,066 --> 0:28:14,296
去分享你的代码

804
00:28:15,086 --> 0:28:16,746
这里我们分配一个内容指针

805
00:28:16,826 --> 0:28:18,486
指向一个使用了一些 SIMD 类型的结构

806
00:28:18,486 --> 0:28:20,546
这个在之前

807
00:28:20,546 --> 0:28:21,236
我已经提到过了

808
00:28:21,236 --> 0:28:23,796
我们设置一系列结构体

809
00:28:23,796 --> 0:28:25,466
这些结构体填充缓存区的数据

810
00:28:25,466 --> 0:28:26,936
这是通过使用已经通过

811
00:28:26,936 --> 0:28:28,286
结构体的定义 定义过的布局或 App

812
00:28:28,606 --> 0:28:29,816
来实现的

813
00:28:31,306 --> 0:28:32,506
就像之前提到的

814
00:28:32,506 --> 0:28:34,026
你可以在你的 App

815
00:28:34,276 --> 0:28:35,406
之间分享你的代码

816
00:28:35,406 --> 0:28:36,736
这就确定了你的布局

817
00:28:36,736 --> 0:28:38,886
在这两个部件之间可以匹配

818
00:28:39,466 --> 0:28:44,846
一个很常见的错误是

819
00:28:44,886 --> 0:28:46,456
缓存数据和它

820
00:28:46,456 --> 0:28:48,226
如何在着色器中被翻译不匹配

821
00:28:48,356 --> 0:28:49,556
这是因为一个关于

822
00:28:49,556 --> 0:28:51,196
校准的假设

823
00:28:52,136 --> 0:28:53,476
举个例子

824
00:28:53,476 --> 0:28:54,496
你可能会假设着色器的语言是

825
00:28:54,826 --> 0:28:57,256
flout3 的类型

826
00:28:57,296 --> 0:28:57,576
它只消耗 12 个字节的内存

827
00:28:58,266 --> 0:29:00,506
三个 4 字节的部件就是

828
00:28:58,266 --> 0:29:00,506
三个 4 字节的部件就是

829
00:29:00,506 --> 0:29:01,096
12 个字节对吧

830
00:29:01,936 --> 0:29:03,436
那么如果你将你的数据这样打包

831
00:29:03,436 --> 0:29:04,716
你就会有麻烦的

832
00:29:05,356 --> 0:29:06,586
因为你的着色器语言

833
00:29:06,666 --> 0:29:08,296
实际上将 float3 类型解释为 

834
00:29:08,296 --> 0:29:09,586
会消耗 16 个字节

835
00:29:10,336 --> 0:29:11,236
这是因为类型被更严格

836
00:29:11,236 --> 0:29:12,936
地定义了对准方式

837
00:29:12,936 --> 0:29:16,366
这是为了 CPU 和 GPU 的优化以及

838
00:29:16,366 --> 0:29:16,816
CPU 和 GPU 的用量

839
00:29:18,026 --> 0:29:19,626
类似的错误还经常发生在

840
00:29:19,996 --> 0:29:21,176
三乘三的矩阵中

841
00:29:22,316 --> 0:29:23,936
如果你真的想追踪它

842
00:29:23,936 --> 0:29:26,046
如果你真的想紧密地包装数据

843
00:29:26,186 --> 0:29:28,996
我们在 Metal 着色器语言中

844
00:29:28,996 --> 0:29:30,776
提供了包装类型

845
00:29:31,246 --> 0:29:33,126
在你将打包好的数据传进缓存以后

846
00:29:33,126 --> 0:29:34,596
你的着色器代码将会

847
00:29:34,596 --> 0:29:37,356
去包装数据

848
00:29:37,356 --> 0:29:38,846
在你处理这些数据以前

849
00:29:38,846 --> 0:29:40,686
你需要将这些包装好的数据传递给

850
00:29:40,686 --> 0:29:42,236
一个规则向量

851
00:29:43,716 --> 0:29:45,436
所以在你发布你的 App 时

852
00:29:45,436 --> 0:29:48,446
我建议你使用

853
00:29:48,756 --> 0:29:50,376
最方便的存储模式

854
00:29:51,396 --> 0:29:53,436
这使得你在那些资源中

855
00:29:53,466 --> 0:29:55,976
访问数据变得更简单

856
00:29:57,006 --> 0:29:58,676
所以在 iOS 系统中

857
00:29:58,676 --> 0:29:59,696
我们通过 StorageModeShared 创建所有的

858
00:30:00,086 --> 0:30:00,976
纹理和缓存

859
00:30:02,386 --> 0:30:03,726
在 macOS 系统上 你就不能用

860
00:30:03,726 --> 0:30:05,076
StorageModeShared 处理纹理

861
00:30:05,246 --> 0:30:07,146
但是 StorageModeManaged 会让你访问

862
00:30:07,146 --> 0:30:08,526
图像数据变得更容易一些

863
00:30:08,856 --> 0:30:10,846
虽然私有存储是最优选择

864
00:30:16,046 --> 0:30:16,996
你可以在 macOS 上使用

865
00:30:16,996 --> 0:30:19,216
StorageModeShared 和缓存

866
00:30:19,216 --> 0:30:19,906
但你需要特别的小心

867
00:30:20,526 --> 0:30:22,456
如果你混合了 CPU 和 GPU 

868
00:30:22,576 --> 0:30:26,066
都需要访问的数据和只有

869
00:30:26,066 --> 0:30:28,336
GPU 需要访问的数据

870
00:30:28,376 --> 0:30:29,456
你可能在之后会很难去

871
00:30:29,456 --> 0:30:31,246
分开这两种类型的数据

872
00:30:31,246 --> 0:30:33,046
再把它们放到

873
00:30:33,046 --> 0:30:34,286
单独的内存池中

874
00:30:34,906 --> 0:30:37,816
现在我已经说了一些

875
00:30:37,816 --> 0:30:39,166
关于创建纹理和

876
00:30:39,166 --> 0:30:41,186
缓存对象的内容

877
00:30:41,186 --> 0:30:42,106
我会再提一下 MetalKit 框架

878
00:30:42,156 --> 0:30:43,526
它是用来更简单地去

879
00:30:43,526 --> 0:30:44,676
通过常用文件格式去

880
00:30:44,676 --> 0:30:46,606
创建纹理和顶点的框架

881
00:30:47,146 --> 0:30:48,336
这里面包含了纹理加载类

882
00:30:48,626 --> 0:30:50,286
和一些功能去创建

883
00:30:50,286 --> 0:30:52,216
Metal 缓存支持的网格

884
00:30:52,376 --> 0:30:53,936
这些网格是通过 Model I/O 加载的

885
00:30:58,046 --> 0:30:59,106
现在我们来说一说

886
00:30:59,106 --> 0:31:00,506
包含它们的着色器和

887
00:30:59,106 --> 0:31:00,506
包含它们的着色器和

888
00:31:00,506 --> 0:31:02,036
渲染管道对象

889
00:31:02,776 --> 0:31:04,046
你可以通过渲染

890
00:31:04,046 --> 0:31:05,766
管道描述符对象创建

891
00:31:05,766 --> 0:31:07,096
管道状态对象

892
00:31:08,466 --> 0:31:10,116
这个对象包含了顶点和

893
00:31:10,116 --> 0:31:11,066
分片着色器对它

894
00:31:12,446 --> 0:31:13,886
也指定了提供

895
00:31:13,886 --> 0:31:16,416
顶点着色器的顶点布局

896
00:31:17,066 --> 0:31:19,506
你也能混合状态和

897
00:31:19,586 --> 0:31:21,586
渲染目标的像素格式

898
00:31:21,866 --> 0:31:23,706
这里的渲染目标是分片和着色器

899
00:31:23,706 --> 0:31:24,136
可以渲染到的

900
00:31:25,666 --> 0:31:27,206
就像用纹理对象一样

901
00:31:27,206 --> 0:31:28,556
你在设备上调用方法

902
00:31:28,556 --> 0:31:30,136
这会产生一个不可改变的

903
00:31:30,136 --> 0:31:32,406
渲染状态管道对象

904
00:31:33,706 --> 0:31:34,926
也就像纹理对象一样

905
00:31:35,056 --> 0:31:36,306
你只需要使用描述符

906
00:31:36,306 --> 0:31:37,546
去创建这些对象

907
00:31:38,156 --> 0:31:40,456
这里是一些代码

908
00:31:40,456 --> 0:31:41,726
展现了怎样去搭建这些

909
00:31:41,726 --> 0:31:42,226
管道状态对象

910
00:31:43,536 --> 0:31:44,916
在你创建管道以前

911
00:31:45,096 --> 0:31:47,456
你需要从 Metal 库中

912
00:31:47,456 --> 0:31:48,686
获取着色器

913
00:31:49,256 --> 0:31:51,446
这一行代码加载了我们在 Xcode 里

914
00:31:51,446 --> 0:31:54,586
搭建的默认的 Metal 库文件 

915
00:31:54,726 --> 0:31:56,616
对于这个库你可以

916
00:31:56,616 --> 0:31:58,316
通过他们的函数名

917
00:31:59,116 --> 0:32:00,726
获取你的顶点和分片着色器

918
00:31:59,116 --> 0:32:00,726
获取你的顶点和分片着色器

919
00:32:01,906 --> 0:32:03,146
你创建一个渲染管道

920
00:32:03,146 --> 0:32:05,316
描述符对象在

921
00:32:05,316 --> 0:32:06,866
你设定这些着色函数的地方

922
00:32:06,866 --> 0:32:09,356
同时还有指定渲染目标像素格式

923
00:32:10,306 --> 0:32:12,336
最后你用设备和

924
00:32:12,336 --> 0:32:13,726
我们已经设定好的描述符对象

925
00:32:13,726 --> 0:32:17,026
来生成管道状态对象

926
00:32:18,136 --> 0:32:19,836
OpenGL 和 Metal 

927
00:32:19,866 --> 0:32:21,906
图形化管道之间

928
00:32:21,936 --> 0:32:25,316
最大的区别就是

929
00:32:25,316 --> 0:32:26,856
OpenGL 编写的对象

930
00:32:26,896 --> 0:32:28,196
只包含顶点和

931
00:32:28,226 --> 0:32:29,906
分片着色对

932
00:32:29,946 --> 0:32:31,816
但是 Metal 管道对象还包括了

933
00:32:31,816 --> 0:32:33,536
顶点布局 混合状态和

934
00:32:33,536 --> 0:32:34,726
渲染目标像素格式

935
00:32:35,566 --> 0:32:36,776
所以你需要在你搭建管道之前

936
00:32:36,816 --> 0:32:39,896
知道所有这些东西

937
00:32:40,016 --> 0:32:41,576
这些管道状态中的

938
00:32:41,646 --> 0:32:43,166
额外部分

939
00:32:43,166 --> 0:32:44,886
使得 Metal 可以在对象建立中完

940
00:32:44,886 --> 0:32:46,746
全将着色器编译进

941
00:32:46,816 --> 0:32:47,576
GPU 机器语言

942
00:32:48,116 --> 0:32:49,006
这是在 OpenGL 编程对象中

943
00:32:49,006 --> 0:32:50,836
根本不可能实现的

944
00:32:51,706 --> 0:32:52,796
现在你就需要去建立一个系统

945
00:32:52,796 --> 0:32:54,146
这个系统允许你在

946
00:32:54,146 --> 0:32:56,086
初始化你的 app 的时候去创建管道

947
00:32:57,266 --> 0:32:58,236
它可以很有用

948
00:32:58,236 --> 0:32:59,816
如果你选择一个规范的顶点布局

949
00:32:59,816 --> 0:33:01,546
和有限的渲染目标集合

950
00:32:59,816 --> 0:33:01,546
和有限的渲染目标集合

951
00:33:02,156 --> 0:33:03,766
这就减少了你 App 

952
00:33:03,766 --> 0:33:05,486
的状态组合

953
00:33:05,486 --> 0:33:07,706
和需要的管道对象的数量

954
00:33:08,976 --> 0:33:10,786
然而不是所有人都知道

955
00:33:10,846 --> 0:33:12,656
他们的 App 会需要哪些管道

956
00:33:13,286 --> 0:33:14,666
一般情况下移植

957
00:33:14,666 --> 0:33:16,306
App 到 Metal 的第一步

958
00:33:16,306 --> 0:33:17,786
是持有一个管道词典

959
00:33:17,786 --> 0:33:18,396
这个词典是之前就已经建立好了的

960
00:33:19,326 --> 0:33:20,566
介于你的 App 会遇到

961
00:33:20,566 --> 0:33:22,196
新的状态组合

962
00:33:22,196 --> 0:33:23,836
它可以将描述符看作是钥匙

963
00:33:23,836 --> 0:33:25,326
去建立和存储管道

964
00:33:26,626 --> 0:33:28,206
一定要记得我刚才说到的这个方法

965
00:33:28,206 --> 0:33:30,326
是一种破解方法

966
00:33:30,326 --> 0:33:31,406
同时你也会想要你的 App 避免

967
00:33:31,406 --> 0:33:31,856
通过这种方法被传输

968
00:33:32,426 --> 0:33:33,856
这是因为创建这些对象中的

969
00:33:33,856 --> 0:33:35,316
任何一个都是很昂贵的

970
00:33:36,346 --> 0:33:37,196
当你想要创建管道对象的时候

971
00:33:37,196 --> 0:33:39,336
GPU 编译器会起到作用

972
00:33:39,336 --> 0:33:41,396
并且翻译和优化

973
00:33:41,396 --> 0:33:42,786
着色器的二进制中间

974
00:33:42,786 --> 0:33:44,636
表示到机器代码

975
00:33:45,386 --> 0:33:46,356
如果你的 App 在你的渲染器循环中

976
00:33:46,386 --> 0:33:47,986
及时地创建了这些

977
00:33:47,986 --> 0:33:51,046
你就很有可能会看到

978
00:33:51,356 --> 0:33:53,046
短时间内

979
00:33:53,046 --> 0:33:55,786
减少帧率

980
00:33:55,986 --> 0:33:57,366
给纹理和缓存

981
00:33:57,366 --> 0:33:58,906
分配内存也是很昂贵的操作

982
00:33:58,906 --> 0:34:00,526
这甚至不是

983
00:33:58,906 --> 0:34:00,526
这甚至不是

984
00:34:00,526 --> 0:34:01,586
要考虑将数据

985
00:34:01,586 --> 0:34:03,726
填充到这些资源中的操作

986
00:34:04,946 --> 0:34:06,076
然而一旦你创建了这些对象

987
00:34:06,076 --> 0:34:07,866
在你在渲染循环中使用它们的时候

988
00:34:07,866 --> 0:34:09,646
就只需要非常小的 CPU 了

989
00:34:09,746 --> 0:34:11,045
[ 音质不清晰 ] 因为这在之前的操作中

990
00:34:11,045 --> 0:34:12,966
已经做得够多了

991
00:34:14,176 --> 0:34:15,485
现在我们交给 Sukanya 去解释

992
00:34:15,485 --> 0:34:16,716
他会告诉你们

993
00:34:16,716 --> 0:34:17,735
如何移植你的渲染循环

994
00:34:18,516 --> 0:34:22,545
[ 掌声 ]

995
00:34:23,045 --> 0:34:24,065
&gt;&gt; 晚上好各位

996
00:34:24,065 --> 0:34:25,886
我是 Sukanya Sudugu

997
00:34:25,886 --> 0:34:26,856
是 Apple 的 GPU 软件工程师

998
00:34:27,646 --> 0:34:29,696
我真的超级兴奋去跟你们分享一些

999
00:34:29,696 --> 0:34:31,496
我们在移植上的经验

1000
00:34:31,496 --> 0:34:32,976
所以我们来继续看看移植问题

1001
00:34:35,876 --> 0:34:37,096
Dan 已经说了很多关于

1002
00:34:37,096 --> 0:34:39,496
App 的建立 所以目前为止

1003
00:34:39,496 --> 0:34:40,795
你已经建立了所有的

1004
00:34:40,795 --> 0:34:43,596
着色器同时也创建了所有的

1005
00:34:43,596 --> 0:34:45,216
帧分片所需要的

1006
00:34:45,216 --> 0:34:46,275
持久对象

1007
00:34:47,196 --> 0:34:48,656
那么现在我们来深入了解一下

1008
00:34:48,656 --> 0:34:50,795
你的 App 的渲染循环

1009
00:34:50,795 --> 0:34:52,926
它是在每一帧里都会执行的代码

1010
00:34:53,186 --> 0:34:55,996
通过 Metal 你会

1011
00:34:55,996 --> 0:34:57,616
在你的渲染循环里明确地

1012
00:34:57,616 --> 0:35:00,196
管理 GPU 执行的异步性

1013
00:34:57,616 --> 0:35:00,196
管理 GPU 执行的异步性

1014
00:35:00,876 --> 0:35:03,156
所以这包括了

1015
00:35:03,206 --> 0:35:04,826
和 GPU 命令一起获取

1016
00:35:04,826 --> 0:35:06,736
和提交命令缓存到 GPU

1017
00:35:06,736 --> 0:35:10,046
同时以这样的方式 更新你的资源

1018
00:35:10,046 --> 0:35:12,206
使得你的 GPU

1019
00:35:12,206 --> 0:35:13,926
可以异步地从它里边读取信息

1020
00:35:14,566 --> 0:35:16,086
这些资源是你之前 就已经写好在你的

1021
00:35:16,176 --> 0:35:16,726
渲染循环里的

1022
00:35:17,266 --> 0:35:19,526
然后通过创建渲染命令编码器

1023
00:35:19,526 --> 0:35:21,326
来编码渲染通行证

1024
00:35:21,936 --> 0:35:24,636
最后将你的帧

1025
00:35:24,636 --> 0:35:25,776
展现出来

1026
00:35:25,776 --> 0:35:29,196
所以我们先来说一说

1027
00:35:29,196 --> 0:35:30,356
命令缓存对象

1028
00:35:32,396 --> 0:35:34,066
与 OpenGL 最大的不同点之一就是

1029
00:35:34,066 --> 0:35:36,536
Metal 通过命令缓存

1030
00:35:36,606 --> 0:35:38,196
提供了准确的控制

1031
00:35:38,196 --> 0:35:40,366
这表示着创建这些命令缓存

1032
00:35:40,366 --> 0:35:42,396
完全是取决于你

1033
00:35:42,396 --> 0:35:44,106
同时你也能决定什么时候

1034
00:35:44,106 --> 0:35:46,486
去将这些执行提交给 GPU

1035
00:35:47,306 --> 0:35:49,496
一种直接的实现方法就是

1036
00:35:49,496 --> 0:35:51,056
创建一个命令缓存

1037
00:35:51,056 --> 0:35:53,236
它可以渲染你的整个帧

1038
00:35:53,946 --> 0:35:55,796
然后一旦你的 App 准备好了

1039
00:35:55,796 --> 0:35:57,916
并且可以跑了并且如果

1040
00:35:57,916 --> 0:35:59,816
你在 GPU 上看到一些空余时间

1041
00:35:59,816 --> 0:36:01,976
这样的话你就可以去考虑

1042
00:35:59,816 --> 0:36:01,976
这样的话你就可以去考虑

1043
00:36:02,146 --> 0:36:03,396
将你的帧分开到

1044
00:36:03,396 --> 0:36:04,606
多个命令缓存内

1045
00:36:05,006 --> 0:36:08,086
然后 GPU 就可以在

1046
00:36:08,086 --> 0:36:09,796
CPU 编译其他命令缓存的时候开始

1047
00:36:10,086 --> 0:36:11,886
执行一个命令缓存

1048
00:36:13,346 --> 0:36:15,106
或者将你的帧

1049
00:36:15,106 --> 0:36:17,386
分割编译进多个线程

1050
00:36:17,386 --> 0:36:19,136
这就需要你去

1051
00:36:19,136 --> 0:36:20,436
在每一帧里都创建一个命令缓存

1052
00:36:20,436 --> 0:36:23,196
但是一定要记住

1053
00:36:23,196 --> 0:36:25,056
每一个命令缓存都会需要

1054
00:36:25,056 --> 0:36:27,056
额外的 CPU 消耗

1055
00:36:27,496 --> 0:36:30,066
所以你最好尽可能的少用

1056
00:36:32,216 --> 0:36:34,306
Metal 也提供 API 来

1057
00:36:34,356 --> 0:36:36,436
注册一个完整的回调

1058
00:36:37,136 --> 0:36:38,846
它会在 GPU 完成执行

1059
00:36:38,846 --> 0:36:41,386
这些命令缓存的时候被涉及到

1060
00:36:41,986 --> 0:36:43,686
让我来给你们展现一下

1061
00:36:43,686 --> 0:36:44,766
这些 API

1062
00:36:45,216 --> 0:36:48,316
你将会在你的

1063
00:36:48,316 --> 0:36:49,516
App 初始化方法里

1064
00:36:49,516 --> 0:36:50,856
创建命令队列

1065
00:36:51,356 --> 0:36:53,246
现在 在渲染循环里你将会用到它

1066
00:36:53,246 --> 0:36:55,676
去获取命令缓存

1067
00:36:55,676 --> 0:36:57,386
这是通过调用它的命令缓存方法来实现的

1068
00:36:57,946 --> 0:37:00,156
现在你要把这些命令编译进

1069
00:36:57,946 --> 0:37:00,156
现在你要把这些命令编译进

1070
00:37:00,156 --> 0:37:01,156
这个命令缓存里

1071
00:37:01,156 --> 0:37:03,086
我将会简短地说一下

1072
00:37:03,146 --> 0:37:04,616
这个编码器

1073
00:37:05,936 --> 0:37:06,936
当你完成编码以后

1074
00:37:06,936 --> 0:37:08,846
你需要调用提交方法

1075
00:37:08,846 --> 0:37:11,446
来让这个命令缓存

1076
00:37:11,446 --> 0:37:14,366
被提交到 GPU 里执行

1077
00:37:14,366 --> 0:37:17,846
现在你有两个选择

1078
00:37:17,916 --> 0:37:19,686
去决定在这个命令缓存在 GPU 上被执行的时候

1079
00:37:19,686 --> 0:37:21,806
应该去做点什么

1080
00:37:22,316 --> 0:37:25,526
你可以通过调用这个

1081
00:37:25,526 --> 0:37:27,436
waitUntilCompleted 方法来等待

1082
00:37:27,436 --> 0:37:29,256
这就像 OpenGL 里边的

1083
00:37:29,256 --> 0:37:29,956
glFinish

1084
00:37:30,896 --> 0:37:33,026
这个方法会同步等待

1085
00:37:33,026 --> 0:37:35,456
并且只在所有命令缓存里的

1086
00:37:35,456 --> 0:37:38,806
命令被 GPU 执行完以后才会返回

1087
00:37:40,916 --> 0:37:44,816
或者在你提交这个

1088
00:37:44,816 --> 0:37:46,206
命令缓存给 GPU 以前

1089
00:37:46,206 --> 0:37:48,566
你可以添加一个完成处理器

1090
00:37:49,406 --> 0:37:51,286
这个处理器会在 GPU 

1091
00:37:51,286 --> 0:37:53,296
完成执行以后被调用

1092
00:37:53,946 --> 0:37:56,476
这就允许 CPU 和 GPU 去

1093
00:37:56,476 --> 0:37:57,576
并行执行

1094
00:37:58,456 --> 0:38:00,486
同时这样就允许我们去追踪

1095
00:37:58,456 --> 0:38:00,486
同时这样就允许我们去追踪

1096
00:38:00,486 --> 0:38:02,116
和有效地更新

1097
00:38:02,116 --> 0:38:04,236
在每一帧里都被改变的

1098
00:38:04,236 --> 0:38:05,076
分享的资源

1099
00:38:05,556 --> 0:38:08,676
既然我们到了这里 我们再来说一说

1100
00:38:08,676 --> 0:38:09,876
这些资源的更新

1101
00:38:09,876 --> 0:38:12,486
和看一看我们如何

1102
00:38:12,486 --> 0:38:14,656
通过完成处理器来让它们更高效

1103
00:38:14,656 --> 0:38:18,626
几乎所有的 App 都会在

1104
00:38:18,626 --> 0:38:21,436
每一帧将新的数据推送给 GPU

1105
00:38:21,926 --> 0:38:24,206
举个例子比如说动画里需要的

1106
00:38:24,316 --> 0:38:25,716
新的渲染单元

1107
00:38:26,256 --> 0:38:29,146
在 Metal 里 CPU 可以在任意时候

1108
00:38:29,146 --> 0:38:31,776
写入这些共享资源

1109
00:38:31,886 --> 0:38:33,966
即使 GPU 是在同一时刻访问

1110
00:38:35,206 --> 0:38:36,276
同一内存

1111
00:38:37,376 --> 0:38:38,876
Metal 并不能保护你不被这些

1112
00:38:38,876 --> 0:38:40,456
数据竞争影响

1113
00:38:41,256 --> 0:38:44,176
相比之下

1114
00:38:44,176 --> 0:38:45,666
OpenGL 默认地会避免这些

1115
00:38:45,666 --> 0:38:48,056
数据竞争

1116
00:38:48,056 --> 0:38:50,676
要么是等待 GPU 完成工作

1117
00:38:50,676 --> 0:38:53,166
要么是制作额外的副本

1118
00:38:53,166 --> 0:38:54,586
这样对你的 App 而言 可能并不是

1119
00:38:54,586 --> 0:38:55,376
最优选择

1120
00:38:56,256 --> 0:38:58,756
通过 Metal 你可以实现任何

1121
00:38:58,756 --> 0:39:01,546
最适合你 App 的

1122
00:38:58,756 --> 0:39:01,546
最适合你 App 的

1123
00:39:01,546 --> 0:39:03,376
优化同步策略

1124
00:39:04,256 --> 0:39:06,966
所以在很多情况下

1125
00:39:07,026 --> 0:39:08,686
最好的方法是 你分享资源使用的多个缓存

1126
00:39:08,686 --> 0:39:11,706
这样的话 CPU 和 GPU

1127
00:39:11,706 --> 0:39:13,286
就永远不会同时试图

1128
00:39:13,286 --> 0:39:15,136
访问同一个缓存

1129
00:39:17,436 --> 0:39:19,916
让我们来看一个例子

1130
00:39:19,916 --> 0:39:22,126
你有一个 OpenGL App

1131
00:39:22,126 --> 0:39:24,676
并且你刚刚把它移植到 Metal

1132
00:39:24,736 --> 0:39:26,296
这个 App 使用的是单个缓存去

1133
00:39:26,296 --> 0:39:28,956
更新这些数据并且

1134
00:39:28,956 --> 0:39:30,386
你还没有在 App 里

1135
00:39:30,386 --> 0:39:32,766
实现任何同步方法

1136
00:39:32,766 --> 0:39:36,356
那么 可能发生的事情是

1137
00:39:36,906 --> 0:39:38,316
你的 App 会在

1138
00:39:38,316 --> 0:39:39,956
生成第一个帧的命令的时候

1139
00:39:39,956 --> 0:39:41,866
写进那个缓存里

1140
00:39:41,866 --> 0:39:45,426
然后将这个命令缓存提交给 GPU

1141
00:39:45,426 --> 0:39:47,406
然后当你的 GPU 在

1142
00:39:47,406 --> 0:39:48,876
执行这个命令缓存的时候

1143
00:39:48,876 --> 0:39:49,896
会尝试从缓存里读取信息

1144
00:39:50,436 --> 0:39:53,796
并且当你在为下一帧

1145
00:39:53,796 --> 0:39:55,446
更新同一个缓存的时候

1146
00:39:55,686 --> 0:39:57,816
GPU 依旧会从这个缓存里读取

1147
00:39:58,076 --> 0:40:01,266
所以这很明显是个

1148
00:39:58,076 --> 0:40:01,266
所以这很明显是个

1149
00:40:01,266 --> 0:40:03,806
竞争条件并且结果还是未知的

1150
00:40:03,806 --> 0:40:06,826
有一些潜在的修复

1151
00:40:07,356 --> 0:40:09,806
你可以在你的 App 中实现它们

1152
00:40:10,396 --> 0:40:13,386
最简单的方法是在每一帧之后

1153
00:40:13,386 --> 0:40:14,396
调用命令缓存里的

1154
00:40:14,396 --> 0:40:17,306
waitUntilCompleted 方法

1155
00:40:18,516 --> 0:40:22,556
但是这样的话需要等到 GPU

1156
00:40:22,556 --> 0:40:24,246
在你为了下一帧重写这一缓存之前

1157
00:40:24,246 --> 0:40:26,296
完成读取工作之后

1158
00:40:27,096 --> 0:40:30,936
不过就像你看到的

1159
00:40:30,936 --> 0:40:32,866
这里 CPU 和 GPU 的利用率都很差

1160
00:40:33,036 --> 0:40:35,606
所以这并不是

1161
00:40:35,606 --> 0:40:38,166
你想要完成的传输代码

1162
00:40:38,936 --> 0:40:40,756
但是如果你想要你的 Metal 

1163
00:40:40,756 --> 0:40:42,856
App 设置好并跑起来它还是很有用的

1164
00:40:43,746 --> 0:40:45,976
甚至如果你的 App

1165
00:40:45,976 --> 0:40:47,766
真的有这样的数据冲突

1166
00:40:47,766 --> 0:40:49,716
它是能检测出来的

1167
00:40:51,756 --> 0:40:54,366
一个高效的方法去同步

1168
00:40:54,366 --> 0:40:55,926
你的资源更新是使用

1169
00:40:55,926 --> 0:40:56,826
多个缓存

1170
00:40:57,546 --> 0:40:58,906
所以在这种情况下我们会用到

1171
00:40:58,956 --> 0:41:00,526
三个缓存去更新

1172
00:40:58,956 --> 0:41:00,526
三个缓存去更新

1173
00:41:00,526 --> 0:41:02,126
我们的动态数据

1174
00:41:02,816 --> 0:41:04,756
我们在第一帧里写进缓存

1175
00:41:04,756 --> 0:41:06,846
然后之后 GPU 会

1176
00:41:06,846 --> 0:41:07,516
从中读取

1177
00:41:08,206 --> 0:41:10,166
然后在第二帧里我们为了

1178
00:41:10,166 --> 0:41:11,856
避免竞争的情况我们写进

1179
00:41:11,856 --> 0:41:12,666
第二个缓存里

1180
00:41:13,326 --> 0:41:15,246
类似的我们在第三帧里

1181
00:41:15,246 --> 0:41:18,146
写第三个缓存

1182
00:41:18,346 --> 0:41:20,176
但是现在我们已经用完了所有

1183
00:41:20,176 --> 0:41:22,406
三个缓存并且用尽了我们的缓存池

1184
00:41:23,526 --> 0:41:25,246
我们需要等到 GPU 

1185
00:41:25,246 --> 0:41:27,166
完成第一帧这样我们才能

1186
00:41:27,166 --> 0:41:28,616
在第四帧重复使用

1187
00:41:29,186 --> 0:41:33,736
现在这个完成处理器就变得

1188
00:41:33,736 --> 0:41:35,906
得心应手了

1189
00:41:35,906 --> 0:41:38,046
它会让我们知道什么时候 GPU 完成了

1190
00:41:38,096 --> 0:41:38,406
这一帧的执行

1191
00:41:39,096 --> 0:41:41,396
所以当第一帧完成以后

1192
00:41:41,396 --> 0:41:43,586
我们可以在第四帧里重新使用它的缓存

1193
00:41:44,396 --> 0:41:48,696
以此类推 所以我们现在来看一个例子

1194
00:41:49,226 --> 0:41:52,916
对于你渲染循环外的

1195
00:41:53,326 --> 0:41:55,316
三个缓存实现

1196
00:41:55,316 --> 0:41:56,996
第一件事是我们会为三个缓存

1197
00:41:57,086 --> 0:41:57,726
创建一个 FIFO 队列

1198
00:41:58,286 --> 0:42:01,006
同时我们还需要一个

1199
00:41:58,286 --> 0:42:01,006
同时我们还需要一个

1200
00:42:01,006 --> 0:42:02,616
frameBoundarySemaphore

1201
00:42:02,616 --> 0:42:04,466
它在初始化的时候被设置成了 3

1202
00:42:05,096 --> 0:42:06,906
所以这就表明信号量

1203
00:42:06,906 --> 0:42:09,276
会在每一帧的边缘被测到

1204
00:42:09,576 --> 0:42:11,246
就是在 GPU 完成

1205
00:42:11,246 --> 0:42:14,046
执行一帧的时候

1206
00:42:14,046 --> 0:42:17,466
这允许 CPU 去重复使用它的缓存

1207
00:42:17,466 --> 0:42:19,826
同样 初始化缓存索引去

1208
00:42:19,826 --> 0:42:23,466
指向当前帧的缓存

1209
00:42:23,806 --> 0:42:26,386
而且在你的渲染循环里

1210
00:42:26,386 --> 0:42:28,006
在你写进缓存之前我们需要

1211
00:42:28,006 --> 0:42:30,006
先确定它的

1212
00:42:30,006 --> 0:42:31,276
响应帧已经

1213
00:42:31,326 --> 0:42:33,926
在 GPU 上完成了执行

1214
00:42:34,366 --> 0:42:35,836
所以在帧的一开始

1215
00:42:36,236 --> 0:42:37,386
我们等待

1216
00:42:37,386 --> 0:42:38,656
frameBoundarySemaphore

1217
00:42:39,696 --> 0:42:41,386
一旦信号量被检测到了

1218
00:42:41,506 --> 0:42:42,786
这就表明当前帧

1219
00:42:42,786 --> 0:42:44,166
已经完成了它的

1220
00:42:44,166 --> 0:42:46,126
GPU 上的执行 

1221
00:42:47,536 --> 0:42:50,846
所以为了新的一帧的数据

1222
00:42:50,846 --> 0:42:51,716
去重复利用缓存是安全的

1223
00:42:52,406 --> 0:42:55,426
而且现在我们会编码一些

1224
00:42:55,426 --> 0:42:59,176
命令去绑定这个缓存和 GPU

1225
00:42:59,176 --> 0:43:01,186
在我们提交这个命令缓存给 GPU 之前

1226
00:42:59,176 --> 0:43:01,186
在我们提交这个命令缓存给 GPU 之前

1227
00:43:01,186 --> 0:43:03,066
我们会给这一帧添加

1228
00:43:03,066 --> 0:43:05,156
一个完成处理器

1229
00:43:05,156 --> 0:43:06,556
到命令缓存里

1230
00:43:07,186 --> 0:43:10,066
在添加完 完成处理器之后

1231
00:43:10,066 --> 0:43:12,026
我们会提交这个命令缓存给 GPU

1232
00:43:12,926 --> 0:43:16,036
现在一旦 GPU 完成了

1233
00:43:16,036 --> 0:43:17,806
执行这一帧

1234
00:43:17,806 --> 0:43:19,846
我们的完成处理器就会被调用

1235
00:43:19,846 --> 0:43:22,006
处理器之后就会在这一帧发出信号

1236
00:43:23,766 --> 0:43:26,156
这就允许 CPU 去重复使用它的缓存

1237
00:43:26,186 --> 0:43:27,986
给新的帧编码

1238
00:43:28,786 --> 0:43:30,666
所以这是一个简单的

1239
00:43:30,666 --> 0:43:32,196
三缓存实现

1240
00:43:32,196 --> 0:43:33,846
你可以用它来执行任何

1241
00:43:33,846 --> 0:43:35,996
动态数据的资源更新

1242
00:43:36,476 --> 0:43:39,376
现在我们有了命令缓存

1243
00:43:39,376 --> 0:43:41,426
同时我们还处理了

1244
00:43:41,726 --> 0:43:44,246
资源更新现在我们

1245
00:43:44,246 --> 0:43:46,136
来多说一点关于渲染通行编码器

1246
00:43:46,626 --> 0:43:48,306
它是你将会在你的绘图请求中

1247
00:43:48,306 --> 0:43:49,796
用到的编码

1248
00:43:50,276 --> 0:43:52,496
就像 Dan 之前提到的

1249
00:43:52,496 --> 0:43:56,906
命令编码器在命令缓存里

1250
00:43:57,146 --> 0:43:59,046
将 API 请求转换成

1251
00:43:59,046 --> 0:43:59,926
GPU 硬件命令

1252
00:43:59,926 --> 0:44:02,936
我将会谈到渲染命令编码器

1253
00:43:59,926 --> 0:44:02,936
我将会谈到渲染命令编码器

1254
00:44:02,936 --> 0:44:06,656
它提供了一些针对典型图形的 API

1255
00:44:06,816 --> 0:44:08,216
一些操作 如设定管道

1256
00:44:08,216 --> 0:44:10,186
纹理缓存对象

1257
00:44:10,186 --> 0:44:12,276
还有绘图请求

1258
00:44:12,786 --> 0:44:16,816
所以当你们创建编码器时

1259
00:44:16,966 --> 0:44:18,906
你需要先去设定渲染目标

1260
00:44:18,936 --> 0:44:20,756
所以这是个渲染通行描述符

1261
00:44:20,756 --> 0:44:22,396
这里你将会设置你的

1262
00:44:22,396 --> 0:44:24,746
渲染目标并且在之后请求

1263
00:44:24,746 --> 0:44:26,586
命令缓存为了这个渲染通行

1264
00:44:26,586 --> 0:44:28,706
去创建一个新的编码器 

1265
00:44:29,366 --> 0:44:31,186
现在你就可以用这个编码器

1266
00:44:31,186 --> 0:44:33,256
去编码你的绘图请求了

1267
00:44:35,136 --> 0:44:37,946
跟 OpenGL 不一样的一个地方是

1268
00:44:38,106 --> 0:44:40,666
在 Metal 里一旦编码器被创建了

1269
00:44:40,666 --> 0:44:42,736
你不能再更改它的渲染目标

1270
00:44:42,736 --> 0:44:45,606
因为 GPU 如果看见了一个

1271
00:44:45,696 --> 0:44:47,646
巨大的绘图请求跨度

1272
00:44:47,646 --> 0:44:49,776
它会表现得好很多

1273
00:44:49,776 --> 0:44:51,436
这些请求是去渲染同一个

1274
00:44:51,436 --> 0:44:53,106
渲染目标集合

1275
00:44:54,046 --> 0:44:56,906
所以 Metal API 通过给渲染通行一个

1276
00:44:57,246 --> 0:44:59,876
明确的开始和结束

1277
00:44:59,956 --> 0:45:00,906
来反映这一点

1278
00:44:59,956 --> 0:45:00,906
来反映这一点

1279
00:45:01,316 --> 0:45:03,636
现在这个编码器给出的所有绘图请求

1280
00:45:03,636 --> 0:45:05,596
会渲染进

1281
00:45:05,596 --> 0:45:06,936
这些渲染目标里

1282
00:45:08,566 --> 0:45:09,816
当你想要向不同的渲染目标

1283
00:45:09,816 --> 0:45:11,406
绘图的时候

1284
00:45:11,576 --> 0:45:13,246
你可以结束这个渲染通行

1285
00:45:13,246 --> 0:45:14,226
然后开启一个新的

1286
00:45:14,756 --> 0:45:18,936
这就是我们创建

1287
00:45:18,936 --> 0:45:20,286
一个渲染通行描述符

1288
00:45:20,286 --> 0:45:23,876
并且绑定颜色和深度关系的地方

1289
00:45:25,166 --> 0:45:27,036
现在你可以使用那个描述符

1290
00:45:27,086 --> 0:45:29,716
并且创建一个渲染命令编码器

1291
00:45:30,436 --> 0:45:33,116
现在所有由这个编码器发出的图画

1292
00:45:33,116 --> 0:45:34,966
都会被渲染到这些目标

1293
00:45:37,216 --> 0:45:39,426
另外在 Metal 里

1294
00:45:39,426 --> 0:45:41,856
你也可以为这些附件提供

1295
00:45:41,856 --> 0:45:43,546
加载和存储行为

1296
00:45:43,786 --> 0:45:46,126
这是为了优化 GPU 的带宽用量

1297
00:45:48,236 --> 0:45:50,076
所以这些加载和存储的行为

1298
00:45:50,076 --> 0:45:52,086
允许你去控制

1299
00:45:52,086 --> 0:45:53,796
纹理内容会在渲染通行

1300
00:45:53,956 --> 0:45:55,876
之前和之后被怎样处理

1301
00:45:56,266 --> 0:45:59,016
现在我们有了为渲染通行产生的

1302
00:45:59,016 --> 0:46:01,856
颜色和深度附属品

1303
00:45:59,016 --> 0:46:01,856
颜色和深度附属品

1304
00:46:02,066 --> 0:46:03,856
如果它清晰地为两个

1305
00:46:03,856 --> 0:46:05,906
渲染目标指定了加载行为

1306
00:46:05,906 --> 0:46:08,346
GPU 就会首先

1307
00:46:08,386 --> 0:46:09,836
清除它们的内容

1308
00:46:10,266 --> 0:46:13,246
之后 GPU 会在这个编码器中

1309
00:46:13,246 --> 0:46:14,556
执行命令

1310
00:46:14,556 --> 0:46:16,346
来渲染这些渲染目标

1311
00:46:16,886 --> 0:46:19,616
现在你可以指定

1312
00:46:19,616 --> 0:46:21,026
在渲染通行的末尾

1313
00:46:21,136 --> 0:46:22,176
进行的存储行为

1314
00:46:22,536 --> 0:46:24,486
这里对于颜色缓存来说

1315
00:46:24,486 --> 0:46:25,996
介于存储行为被存储起来了

1316
00:46:25,996 --> 0:46:28,656
它会在渲染通行

1317
00:46:28,686 --> 0:46:30,966
的最后保留颜色缓存的内容

1318
00:46:31,576 --> 0:46:33,006
然后对于深度附件来说

1319
00:46:33,006 --> 0:46:35,286
因为我们说了存储行为是不关心的

1320
00:46:35,286 --> 0:46:37,786
所以它会放弃它的内容

1321
00:46:39,006 --> 0:46:40,876
所以这些纹理加载和存储

1322
00:46:40,876 --> 0:46:42,806
是非常昂贵的

1323
00:46:42,806 --> 0:46:44,376
消耗内存带宽的操作

1324
00:46:44,946 --> 0:46:47,346
所以慎重地选择并且不要关心

1325
00:46:47,346 --> 0:46:48,416
是不是可能

1326
00:46:48,976 --> 0:46:52,246
那么这就是你怎么设定你行为的过程

1327
00:46:52,526 --> 0:46:54,876
在这个例子里我们指定了清除为

1328
00:46:54,876 --> 0:46:57,966
加载行为并且设定了清除颜色

1329
00:46:59,186 --> 0:47:01,236
然后这里我们指定了存储行为为存储

1330
00:46:59,186 --> 0:47:01,236
然后这里我们指定了存储行为为存储

1331
00:47:01,806 --> 0:47:03,656
相似的你可以为每一个渲染目标

1332
00:47:03,656 --> 0:47:05,636
指定加载和存储行为

1333
00:47:05,636 --> 0:47:07,196
这些渲染目标是你设定在

1334
00:47:07,196 --> 0:47:08,326
渲染通行描述符里的

1335
00:47:08,926 --> 0:47:11,936
所以这就是我们如何配置我们的

1336
00:47:11,936 --> 0:47:12,896
渲染目标

1337
00:47:12,946 --> 0:47:16,596
现在你可以从这个描述符

1338
00:47:16,596 --> 0:47:19,076
创建编码器

1339
00:47:19,076 --> 0:47:20,526
然后我们就可以开始编码绘图请求了

1340
00:47:21,886 --> 0:47:23,606
但是在这之前我想给你们展现

1341
00:47:23,606 --> 0:47:25,756
一些 OpenGL 命令

1342
00:47:25,756 --> 0:47:27,326
然后它们会向你们展现它们的

1343
00:47:27,326 --> 0:47:28,146
Metal 等价表示

1344
00:47:28,686 --> 0:47:32,626
这就是典型 OpenGL 绘图序列

1345
00:47:33,156 --> 0:47:36,526
在这个分片里我们先绑定一个

1346
00:47:36,526 --> 0:47:38,776
会设定所有渲染目标的

1347
00:47:38,776 --> 0:47:39,826
帧缓存器

1348
00:47:41,096 --> 0:47:42,966
然后我们绑定我们的程序

1349
00:47:42,966 --> 0:47:45,676
程序内包含了顶点和分片着色器

1350
00:47:46,226 --> 0:47:48,206
然后我们绑定带有顶点数据的

1351
00:47:48,206 --> 0:47:49,676
顶点缓存器

1352
00:47:50,136 --> 0:47:53,036
之后我们再绑定另一个

1353
00:47:53,036 --> 0:47:54,576
含有所有标准数据的缓存器

1354
00:47:55,416 --> 0:47:57,686
再然后我们就会设定一个

1355
00:47:57,686 --> 0:47:58,536
被采样的纹理

1356
00:47:59,776 --> 0:48:00,916
最后绘图

1357
00:47:59,776 --> 0:48:00,916
最后绘图

1358
00:48:01,546 --> 0:48:03,956
所以这就是 Metal 的等价操作

1359
00:48:04,566 --> 0:48:05,956
这会稍微多出几行代码

1360
00:48:05,996 --> 0:48:07,936
因为它是明确的但是它

1361
00:48:07,936 --> 0:48:09,766
和 OpenGL 非常类似

1362
00:48:10,586 --> 0:48:11,866
首先我们用渲染通行描述符

1363
00:48:11,866 --> 0:48:13,336
创建一个渲染命令编码器

1364
00:48:13,336 --> 0:48:15,456
这个描述符含有我们的

1365
00:48:15,456 --> 0:48:16,346
渲染目标

1366
00:48:17,696 --> 0:48:19,296
然后我们设定含有

1367
00:48:19,296 --> 0:48:20,506
着色器的管道对象

1368
00:48:21,836 --> 0:48:24,606
然后我们再去设定缓存器

1369
00:48:24,606 --> 0:48:26,276
去访问顶点着色器

1370
00:48:26,676 --> 0:48:27,836
同时它还含有我们要画的

1371
00:48:27,836 --> 0:48:29,226
图像的顶点

1372
00:48:30,436 --> 0:48:32,316
值得注意的是 Metal 并不会

1373
00:48:32,316 --> 0:48:33,846
区别包含标准数据

1374
00:48:33,846 --> 0:48:36,026
的缓存器和那些

1375
00:48:36,026 --> 0:48:37,176
包含顶点的缓存器

1376
00:48:37,816 --> 0:48:40,276
所以我们会用相同的 API

1377
00:48:40,276 --> 0:48:41,386
去设置标准缓存

1378
00:48:41,386 --> 0:48:44,026
所以这里第一个请求会给

1379
00:48:44,026 --> 0:48:46,026
缓存器访问顶点着色器的权限

1380
00:48:46,026 --> 0:48:47,236
第二个请求会给出访问

1381
00:48:47,236 --> 0:48:48,746
分片着色器的权限

1382
00:48:49,286 --> 0:48:52,166
接下来我们为要去采样的

1383
00:48:52,166 --> 0:48:54,026
分片着色器设定纹理

1384
00:48:54,516 --> 0:48:56,556
然后绘图

1385
00:48:57,076 --> 0:48:59,846
一旦我们完成了编码命令

1386
00:48:59,846 --> 0:49:01,456
我们会通过在编码对象上

1387
00:48:59,846 --> 0:49:01,456
我们会通过在编码对象上

1388
00:49:01,456 --> 0:49:03,396
调用 endEncoding 向 Metal 

1389
00:49:03,396 --> 0:49:05,376
指出这些

1390
00:49:06,196 --> 0:49:07,916
所以这就是一个简单的

1391
00:49:07,916 --> 0:49:09,406
Metal 渲染通行的例子

1392
00:49:09,926 --> 0:49:12,926
现在我们已经有了一个完整的渲染通行 

1393
00:49:12,926 --> 0:49:14,696
我们再来看看怎样去

1394
00:49:14,696 --> 0:49:16,806
让这些渲染表现出来

1395
00:49:17,336 --> 0:49:21,526
通过 OpenGl 你将你的渲染帧

1396
00:49:21,526 --> 0:49:23,156
展现到屏幕上

1397
00:49:23,436 --> 0:49:25,336
但是你并没有明确地管理

1398
00:49:25,336 --> 0:49:27,996
系统的渲染缓存

1399
00:49:27,996 --> 0:49:29,006
依旧被设定为 drawable

1400
00:49:30,336 --> 0:49:32,126
但是要是通过 Metal 将你的

1401
00:49:32,126 --> 0:49:34,476
内容显示在屏幕上

1402
00:49:34,906 --> 0:49:36,186
首先你需要确认包含特殊的纹理

1403
00:49:36,186 --> 0:49:37,516
这种特殊纹理在系统里

1404
00:49:37,516 --> 0:49:39,116
被称为 drawable

1405
00:49:39,746 --> 0:49:41,676
所以你可以使用 MetalKit 视图

1406
00:49:41,816 --> 0:49:42,756
MetalKit 视图提供了每一帧中的

1407
00:49:42,756 --> 0:49:44,846
drawable 纹理

1408
00:49:45,426 --> 0:49:46,886
然后一旦你获得这个 drawable

1409
00:49:46,886 --> 0:49:49,276
你就可以编码渲染通行

1410
00:49:49,276 --> 0:49:51,226
并且渲染到这些

1411
00:49:51,226 --> 0:49:53,096
drawable 就像你

1412
00:49:53,096 --> 0:49:54,586
渲染到任意其他一个纹理一样

1413
00:49:55,126 --> 0:49:57,766
然而并不像其他纹理一样

1414
00:49:57,766 --> 0:49:59,976
现在你可以将这个 drawable 展现出来

1415
00:50:00,096 --> 0:50:02,996
那么让我来给你们展示一下代码例子

1416
00:50:03,516 --> 0:50:06,196
首先我需要说一下

1417
00:50:06,196 --> 0:50:07,886
这些 drawable 受限于你的

1418
00:50:08,166 --> 0:50:10,696
着色器系统资源

1419
00:50:10,696 --> 0:50:12,206
所以你应该尽可能简单

1420
00:50:12,206 --> 0:50:13,536
地处理他们

1421
00:50:14,236 --> 0:50:15,776
这代表着你应该

1422
00:50:15,776 --> 0:50:18,096
在你获取 drawable 以前编码

1423
00:50:18,126 --> 0:50:20,606
所有的离线渲染通行

1424
00:50:21,906 --> 0:50:23,626
之后你可以创建一个 MetalKit 视图

1425
00:50:23,626 --> 0:50:26,856
不但可以去看一个完整的

1426
00:50:26,856 --> 0:50:29,206
填充渲染通行描述符

1427
00:50:29,466 --> 0:50:30,926
这个描述符你可以直接用来

1428
00:50:30,926 --> 0:50:33,836
创建编码器 就是这里你们看到的这个

1429
00:50:33,836 --> 0:50:36,336
同时你还可以通过

1430
00:50:36,336 --> 0:50:37,746
view.currentDrawable 属性

1431
00:50:37,976 --> 0:50:41,626
请求指定的纹理

1432
00:50:41,626 --> 0:50:42,706
之后你可以围绕它创建你自己的

1433
00:50:42,706 --> 0:50:45,086
渲染通行描述符

1434
00:50:47,136 --> 0:50:48,846
一旦你完成了编码你的帧

1435
00:50:48,846 --> 0:50:50,496
你可以调用

1436
00:50:50,496 --> 0:50:51,896
现有的命令缓存中的

1437
00:50:51,896 --> 0:50:53,456
drawable 方法

1438
00:50:53,456 --> 0:50:55,626
这在 GPU 完成执行命令换内存后

1439
00:50:55,626 --> 0:50:58,166
将你的 drawable 输出到屏幕上

1440
00:50:58,986 --> 0:51:00,946
所以一旦 GPU 完成了

1441
00:50:58,986 --> 0:51:00,946
所以一旦 GPU 完成了

1442
00:51:00,946 --> 0:51:02,586
执行这一帧

1443
00:51:02,586 --> 0:51:04,116
你就可以在显示上看到这一帧

1444
00:51:04,646 --> 0:51:07,606
这样的话通过 Metal

1445
00:51:07,606 --> 0:51:09,286
将你的渲染展现出来

1446
00:51:09,286 --> 0:51:10,596
就变得相当的快了

1447
00:51:11,156 --> 0:51:14,166
但是我还有几个小建议与你们分享

1448
00:51:15,366 --> 0:51:17,296
将一个渲染器

1449
00:51:17,966 --> 0:51:19,936
传递到 Metal 是可行的

1450
00:51:19,936 --> 0:51:21,436
IOSurface 和 CVPixelBuffer

1451
00:51:21,436 --> 0:51:25,696
API 可以被用来创建纹理

1452
00:51:25,726 --> 0:51:27,596
这个纹理可以在

1453
00:51:27,596 --> 0:51:29,266
OpenGL 和 Metal 之间共享

1454
00:51:30,376 --> 0:51:32,586
这就允许你在 OpenGL 里面

1455
00:51:32,586 --> 0:51:34,596
渲染一个纹理

1456
00:51:34,596 --> 0:51:36,746
然后从 Metal 里读取

1457
00:51:36,746 --> 0:51:36,926
反之亦然

1458
00:51:36,926 --> 0:51:39,876
所以一些 App 可以

1459
00:51:39,876 --> 0:51:41,616
利用这一点去

1460
00:51:41,616 --> 0:51:43,476
逐步移植

1461
00:51:43,756 --> 0:51:45,076
特别是当存在搭建在 OpenGL 里的

1462
00:51:45,076 --> 0:51:46,466
插件结构的时候

1463
00:51:47,206 --> 0:51:49,546
所以这里有一个关联到这个会话的

1464
00:51:49,686 --> 0:51:51,796
示例代码准确地展现了

1465
00:51:51,796 --> 0:51:52,846
如何做到这一点

1466
00:51:55,416 --> 0:51:56,796
现在你已经有了一个 Metal App

1467
00:51:56,796 --> 0:51:58,806
你可以采用所有

1468
00:51:58,806 --> 0:51:59,906
新的 Metal 特性

1469
00:52:01,076 --> 0:52:03,046
如果你的 App 是与 CPU 绑定的

1470
00:52:03,046 --> 0:52:05,436
那么使你的 CPU 编码多线程工作

1471
00:52:05,436 --> 0:52:07,006
会很有用

1472
00:52:07,746 --> 0:52:09,636
你可以在不同线程上

1473
00:52:09,636 --> 0:52:11,316
同时编码多个

1474
00:52:11,316 --> 0:52:12,346
命令缓存

1475
00:52:12,926 --> 0:52:14,776
你甚至可以将一个单独的命令缓存

1476
00:52:14,776 --> 0:52:16,556
拆分编码到

1477
00:52:16,556 --> 0:52:18,346
多个线程中

1478
00:52:18,346 --> 0:52:18,976
这是通过使用并行渲染命令编码器实现的

1479
00:52:25,046 --> 0:52:26,926
同样的通过计划处理

1480
00:52:26,926 --> 0:52:30,186
API 来做的 GPU 计算内置于 Metal 中

1481
00:52:30,776 --> 0:52:33,536
你可以用全新的方法去使用 GPU

1482
00:52:34,046 --> 0:52:36,666
不用 CPU 去开始的话

1483
00:52:36,666 --> 0:52:38,976
你可以利用计算管道来

1484
00:52:38,976 --> 0:52:40,746
生成图像的 GPU 数据

1485
00:52:41,336 --> 0:52:43,616
通过让 GPU 去生成它自己的数据

1486
00:52:43,616 --> 0:52:45,346
你不但可以

1487
00:52:45,346 --> 0:52:47,846
减少 CPU 的利用率和同步率

1488
00:52:47,846 --> 0:52:49,776
同时你还可以

1489
00:52:49,776 --> 0:52:50,796
自由地决定数据对于 GPU

1490
00:52:50,796 --> 0:52:52,106
所需的带宽

1491
00:52:53,176 --> 0:52:54,946
现在通过这个高带宽

1492
00:52:55,246 --> 0:52:56,846
计算处理器你可以

1493
00:52:56,846 --> 0:52:58,456
实现更多更复杂的

1494
00:52:58,456 --> 0:52:58,966
算法 就像这些

1495
00:53:03,356 --> 0:53:05,256
Metal 支持很多很强大的特性

1496
00:53:05,296 --> 0:53:07,216
这些功能你可以用到

1497
00:53:07,216 --> 0:53:09,706
你的 App 里来提高其自身的性能

1498
00:53:10,256 --> 0:53:13,556
此外作为你移植过程的一部分

1499
00:53:13,596 --> 0:53:15,186
我们强烈地鼓励你

1500
00:53:15,186 --> 0:53:17,406
去使用我们的 Metal 

1501
00:53:17,406 --> 0:53:19,096
的极其强大的调试和

1502
00:53:19,096 --> 0:53:21,226
优化工具

1503
00:53:21,256 --> 0:53:23,456
它们都被集合在了 Xcode 里

1504
00:53:24,446 --> 0:53:26,476
所以 Metal 有一个很强大的 API

1505
00:53:26,476 --> 0:53:28,536
验证层来表明

1506
00:53:28,796 --> 0:53:30,816
任何不正常的 API 用量

1507
00:53:30,816 --> 0:53:33,176
的细节信息

1508
00:53:33,176 --> 0:53:34,756
同时也会给出一些可能的修复策略

1509
00:53:36,316 --> 0:53:38,826
这是一个可以让你

1510
00:53:38,826 --> 0:53:40,536
一步一步进行 Metal 

1511
00:53:40,596 --> 0:53:42,706
的调用和

1512
00:53:42,706 --> 0:53:44,466
一步一步看到你的帧是如何被渲染的

1513
00:53:44,466 --> 0:53:45,816
GPU 调试器

1514
00:53:46,726 --> 0:53:48,796
你可以看到和你的帧

1515
00:53:48,796 --> 0:53:50,246
一起出现的所有资源

1516
00:53:50,926 --> 0:53:53,116
它也基于资源的用量

1517
00:53:53,166 --> 0:53:55,036
给 GPU 提供了专业的建议

1518
00:53:55,586 --> 0:53:58,916
今年我们还添加了

1519
00:53:58,916 --> 0:54:00,556
着色器调试器 

1520
00:53:58,916 --> 0:54:00,556
着色器调试器 

1521
00:54:00,916 --> 0:54:02,326
这样你可以调试你的着色器方法

1522
00:54:02,326 --> 0:54:04,006
就像其他的函数一样

1523
00:54:04,516 --> 0:54:07,686
我们还添加了着色器分析器

1524
00:54:07,956 --> 0:54:09,646
它会显示一个

1525
00:54:09,646 --> 0:54:11,266
与你的着色器有关的

1526
00:54:11,266 --> 0:54:11,936
性能矩阵集合

1527
00:54:12,046 --> 0:54:15,556
同时还有一个依赖观察器

1528
00:54:15,556 --> 0:54:17,156
让你能评判

1529
00:54:17,156 --> 0:54:18,626
渲染通行的依赖关系

1530
00:54:18,626 --> 0:54:22,096
你也可以潜在的

1531
00:54:22,096 --> 0:54:24,336
合并任何多余的渲染通行

1532
00:54:24,336 --> 0:54:26,726
以此来提高你的

1533
00:54:26,726 --> 0:54:27,976
App 的性能

1534
00:54:30,216 --> 0:54:32,166
最后 在instruments 里的

1535
00:54:32,166 --> 0:54:33,966
Metal 系统追踪工具

1536
00:54:33,966 --> 0:54:36,696
会给你展现一个完整的

1537
00:54:36,736 --> 0:54:38,486
App 表现和性能

1538
00:54:38,486 --> 0:54:40,276
所以我们强烈建议你

1539
00:54:40,276 --> 0:54:42,396
使用这些工具去

1540
00:54:42,396 --> 0:54:44,146
简化你的移植工作量

1541
00:54:45,296 --> 0:54:47,906
将它打包起来 

1542
00:54:47,906 --> 0:54:49,536
OpenGL 和 OpenCL 已经被放弃了

1543
00:54:49,536 --> 0:54:52,656
但是它们依旧在

1544
00:54:52,656 --> 0:54:54,466
我们很担忧它们的未来使用率

1545
00:54:54,826 --> 0:54:56,526
现在是时候接受 Metal 了

1546
00:54:57,216 --> 0:54:59,106
我们有一整套的开发者工具

1547
00:54:59,106 --> 0:55:00,806
很多经验来

1548
00:54:59,106 --> 0:55:00,806
很多经验来

1549
00:55:00,806 --> 0:55:02,896
帮助开发团队成功地

1550
00:55:02,896 --> 0:55:04,616
完成了这项工作

1551
00:55:04,616 --> 0:55:07,006
并且大幅提高了性能

1552
00:55:07,736 --> 0:55:09,236
我希望我今天分享的信息

1553
00:55:09,236 --> 0:55:10,846
可以给予你们

1554
00:55:10,846 --> 0:55:12,356
顺利移植地经验

1555
00:55:12,866 --> 0:55:15,846
同时我们也很愿意与你们沟通

1556
00:55:15,846 --> 0:55:17,376
谈一谈你们的 App 和

1557
00:55:17,376 --> 0:55:19,406
你们如何通过 Metal 让他们运行的

1558
00:55:20,006 --> 0:55:21,776
所以明天下午我们将

1559
00:55:21,776 --> 0:55:23,506
在 OpenGL 到 Metal 移植实验室里

1560
00:55:23,666 --> 0:55:25,736
介时会有很多

1561
00:55:25,736 --> 0:55:27,696
关于 Metal 的会议

1562
00:55:28,006 --> 0:55:29,426
我建议你们来参加这些会议

1563
00:55:29,426 --> 0:55:31,546
可以学到很多关于

1564
00:55:31,546 --> 0:55:33,106
如何利用 Metal 去调试和

1565
00:55:33,106 --> 0:55:34,466
优化你的 App 的方法

1566
00:55:36,106 --> 0:55:37,866
在此感谢大家参与这次会议

1567
00:55:37,866 --> 0:55:39,706
希望你们能享受这一周

1568
00:55:39,706 --> 0:55:40,716
剩下的时光

1569
00:55:41,516 --> 0:55:44,500
[ 掌声 ]
