1
00:00:17,618 --> 0:00:22,122
（优化app资源

2
00:00:25,492 --> 0:00:28,495
下午好

3
00:00:29,062 --> 0:00:31,765
我叫Will

4
00:00:32,031 --> 0:00:35,102
今天我和我的同事Patrick

5
00:00:35,169 --> 0:00:37,137
会介绍一些优化你app中资源的

6
00:00:37,204 --> 0:00:39,306
好办法

7
00:00:41,775 --> 0:00:43,043
在当今这个时代

8
00:00:43,110 --> 0:00:46,413
很多app和游戏会通过

9
00:00:46,480 --> 0:00:49,449
在app中使用高保真度的插图

10
00:00:49,516 --> 0:00:50,384
来获得好的用户体验

11
00:00:50,918 --> 0:00:51,752
而通过这样做

12
00:00:52,085 --> 0:00:54,354
它们可以吸引更多的用户

13
00:00:54,688 --> 0:00:56,290
还具有互动性

14
00:00:56,924 --> 0:00:59,259
我想让你们所有的app都像这样

15
00:00:59,593 --> 0:01:01,161
这就是为什么我们今天来到这里

16
00:00:59,593 --> 0:01:01,161
这就是为什么我们今天来到这里

17
00:01:01,695 --> 0:01:04,364
我们要展示一些

18
00:01:04,631 --> 0:01:05,966
更重要的是

19
00:01:06,333 --> 0:01:09,269
你要更好地将app中的资源部署给

20
00:01:09,336 --> 0:01:10,270
你的用户

21
00:01:10,337 --> 0:01:13,073
以及如何将其转换到整个用户体验上

22
00:01:15,442 --> 0:01:16,610
在这个演讲中

23
00:01:17,377 --> 0:01:20,447
我们会涉及到几个不同的方面

24
00:01:20,547 --> 0:01:24,151
包括传统、设计、开发和部署工作流

25
00:01:24,985 --> 0:01:28,188
但首先我想花点时间

26
00:01:28,255 --> 0:01:31,825
来谈一下图像压缩

27
00:01:33,660 --> 0:01:34,628
（压缩）

28
00:01:34,695 --> 0:01:37,764
图像压缩是资源目录编辑器的

29
00:01:39,166 --> 0:01:42,536
也是资源目录编译管道的最后一步

30
00:01:43,036 --> 0:01:46,139
而且还跟管道中出现的

31
00:01:46,206 --> 0:01:47,708
其他优化有关

32
00:01:49,510 --> 0:01:51,245
资源目录会

33
00:01:51,311 --> 0:01:55,315
会提供一些默认压缩类型

34
00:01:55,849 --> 0:01:59,553
而且默认会选择优化最好的压缩类型

35
00:01:59,620 --> 0:02:02,155
来获取所给的图像或纹理

36
00:01:59,620 --> 0:02:02,155
来获取所给的图像或纹理

37
00:02:03,524 --> 0:02:05,759
这可能对绝大多数的项目来说足够了

38
00:02:06,326 --> 0:02:10,130
不过了解一下

39
00:02:10,631 --> 0:02:13,834
更重要的是 要了解它们的取舍

40
00:02:13,901 --> 0:02:16,336
以及对你项目所做的实现

41
00:02:17,037 --> 0:02:18,038
（图像压缩）

42
00:02:18,438 --> 0:02:19,439
（自动图像打包）

43
00:02:19,506 --> 0:02:23,143
在我深入介绍图像压缩的内容之前

44
00:02:23,744 --> 0:02:28,081
我想介绍一些

45
00:02:28,549 --> 0:02:31,552
它对于我们所有要进行的

46
00:02:32,352 --> 0:02:34,321
它叫做自动化图像打包

47
00:02:38,025 --> 0:02:41,028
通常在注入资源目录前

48
00:02:41,662 --> 0:02:44,364
将资源部署到你app中的一种方法

49
00:02:44,431 --> 0:02:46,333
将一些图像文件丢到

50
00:02:46,400 --> 0:02:48,268
你项目的app捆绑里

51
00:02:49,469 --> 0:02:52,372
你需要注意的是

52
00:02:52,439 --> 0:02:55,309
还有取舍

53
00:02:56,109 --> 0:03:00,214
有两个缺点是你需要注意的

54
00:02:56,109 --> 0:03:00,214
有两个缺点是你需要注意的

55
00:03:00,948 --> 0:03:04,585
首先是伴随而来的

56
00:03:04,651 --> 0:03:05,786
额外存储空间

57
00:03:06,954 --> 0:03:09,389
传统的图像容器格式

58
00:03:10,190 --> 0:03:14,061
会使用额外的空间

59
00:03:14,795 --> 0:03:16,563
还有跟图像对应的其他属性

60
00:03:17,698 --> 0:03:20,200
如果你的app有很多的资源

61
00:03:20,567 --> 0:03:22,569
而且它们有相似的元数据

62
00:03:23,203 --> 0:03:27,474
那么相同的信息

63
00:03:28,876 --> 0:03:32,513
另外 如果你的绝大多数资源很小

64
00:03:33,280 --> 0:03:36,383
你也不能最大程度

65
00:03:38,252 --> 0:03:42,289
另一个缺点主要是你要花费的

66
00:03:42,356 --> 0:03:43,590
组织上的开销

67
00:03:44,491 --> 0:03:47,561
处理如此多零散的图像文件

68
00:03:48,629 --> 0:03:52,599
而且将它们跟NSImage

69
00:03:52,666 --> 0:03:54,535
和UIImage类的API

70
00:03:55,869 --> 0:03:57,104
最后还有一点就是

71
00:03:57,171 --> 0:04:00,641
你还需要处理图像格式的不一致性

72
00:03:57,171 --> 0:04:00,641
你还需要处理图像格式的不一致性

73
00:04:00,707 --> 0:04:03,710
还有其他的图像属性

74
00:04:04,545 --> 0:04:05,546
例如

75
00:04:05,612 --> 0:04:08,415
在你的插图集合中

76
00:04:08,482 --> 0:04:11,785
但其中有些图像支持透明化

77
00:04:13,020 --> 0:04:17,024
同样的问题也会出现在

78
00:04:19,526 --> 0:04:21,928
由于目录可以通过

79
00:04:22,362 --> 0:04:26,266
识别共享相似色域配置的图像

80
00:04:26,767 --> 0:04:30,404
并且将其分成一组

81
00:04:31,271 --> 0:04:35,142
这样你就不需要为你所有的图像插图

82
00:04:35,209 --> 0:04:36,476
重复存储相同的元数据了

83
00:04:37,277 --> 0:04:38,846
你还可以从所有的图像压缩中

84
00:04:39,279 --> 0:04:41,315
获得更多的收益

85
00:04:42,816 --> 0:04:45,919
让我们来看个现实世界的例子吧

86
00:04:48,689 --> 0:04:52,426
在屏幕的左边有一些图像插图

87
00:04:53,060 --> 0:04:54,428
你可能看起来很熟悉

88
00:04:55,095 --> 0:04:56,697
因为它们是直接从

89
00:04:56,763 --> 0:04:57,998
我们的一个平台取出来的

90
00:04:59,366 --> 0:05:01,802
这些图像插图都非常小

91
00:04:59,366 --> 0:05:01,802
这些图像插图都非常小

92
00:05:02,469 --> 0:05:06,840
但加起来的总大小

93
00:05:10,344 --> 0:05:11,712
通过这个自动化图像打包

94
00:05:12,579 --> 0:05:15,782
资源目录可以识别出这些图像插图

95
00:05:15,849 --> 0:05:17,851
是不是共享了相类似的色域

96
00:05:18,652 --> 0:05:23,524
如果是的话 它就会集合这些图像

97
00:05:25,025 --> 0:05:25,859
这样的话…

98
00:05:27,060 --> 0:05:32,466
总的文件大小

99
00:05:33,233 --> 0:05:36,603
这样节省了80%的文件大小

100
00:05:38,071 --> 0:05:42,109
还有需要注意的是

101
00:05:42,543 --> 0:05:46,213
你app中的资源数量越多

102
00:05:46,780 --> 0:05:49,149
你通过这个优化得到的收益就越多

103
00:05:52,686 --> 0:05:54,354
这就是关于自动化图像打包的内容

104
00:05:55,689 --> 0:05:56,523
（有损压缩）

105
00:05:56,590 --> 0:05:59,059
现在让我们介绍下有损压缩

106
00:06:01,395 --> 0:06:06,099
有损压缩就是要损失少量视觉保真度

107
00:06:06,567 --> 0:06:10,370
从而在压缩时省出更多的空间

108
00:06:11,305 --> 0:06:12,940
所以知道你app

109
00:06:13,507 --> 0:06:15,409
有损压缩最多的场景

110
00:06:15,475 --> 0:06:17,911
很重要

111
00:06:19,613 --> 0:06:22,916
我通常可以推荐你

112
00:06:23,617 --> 0:06:26,386
在短时间在屏幕显示的图像上

113
00:06:27,788 --> 0:06:29,623
例如 就是出现在

114
00:06:29,690 --> 0:06:31,658
你app启动画面中的图像

115
00:06:32,259 --> 0:06:34,228
或是过场动画和特效

116
00:06:36,163 --> 0:06:38,332
我不想只是站在这

117
00:06:38,398 --> 0:06:39,933
介绍有损压缩

118
00:06:40,467 --> 0:06:41,935
我想介绍资源目录中的

119
00:06:42,002 --> 0:06:43,170
一种新的有损压缩

120
00:06:44,137 --> 0:06:48,408
所以我非常高兴地宣布

121
00:06:48,475 --> 0:06:52,412
资源目录中

122
00:06:52,479 --> 0:06:54,481
（高效图像文件格式）

123
00:06:54,548 --> 0:06:57,017
如果你了解过我们去年发布的内容

124
00:06:57,351 --> 0:07:00,854
就会知道我们在所有平台上

125
00:06:57,351 --> 0:07:00,854
就会知道我们在所有平台上

126
00:07:01,154 --> 0:07:05,425
还有资源目录编辑器中

127
00:07:06,627 --> 0:07:08,962
今年我们会更进一步

128
00:07:09,329 --> 0:07:11,865
我们会将高效图像文件格式

129
00:07:11,932 --> 0:07:14,735
与资源目录的

130
00:07:21,909 --> 0:07:22,743
谢谢你们

131
00:07:23,844 --> 0:07:26,346
让我们来看看高效图像文件格式

132
00:07:26,413 --> 0:07:29,149
会给我们带来哪些收益吧

133
00:07:30,851 --> 0:07:32,953
很重要的一点就是 它可以提供

134
00:07:33,020 --> 0:07:34,788
更好的压缩比

135
00:07:35,422 --> 0:07:37,925
对比我们已经提供的

136
00:07:37,991 --> 0:07:39,259
其他有损压缩来说

137
00:07:40,060 --> 0:07:41,995
其中你可能很熟悉的一种格式

138
00:07:42,863 --> 0:07:43,764
就是JPEG

139
00:07:45,299 --> 0:07:46,400
该高效图像文件格式

140
00:07:46,466 --> 0:07:49,369
有很多优点

141
00:07:49,670 --> 0:07:52,306
像是对于框外透明度的支持

142
00:07:53,907 --> 0:07:54,908
还有更重要的是

143
00:07:55,375 --> 0:07:58,078
资源目录

144
00:07:58,145 --> 0:08:01,915
可以自动地将其他格式

145
00:07:58,145 --> 0:08:01,915
可以自动地将其他格式

146
00:08:02,316 --> 0:08:04,351
转换为高效图像文件格式

147
00:08:05,118 --> 0:08:08,288
这就意味着

148
00:08:08,355 --> 0:08:09,723
这种有损压缩格式的

149
00:08:09,790 --> 0:08:14,561
你这边就不需要再做额外的操作了

150
00:08:14,628 --> 0:08:18,899
这一切都会在资源目录

151
00:08:20,834 --> 0:08:24,505
有关高效图像文件格式的

152
00:08:24,571 --> 0:08:27,474
我建议你们去参考下去年的演讲

153
00:08:29,810 --> 0:08:31,712
（无损压缩）

154
00:08:31,778 --> 0:08:34,515
现在让我们把目光转移到无损压缩上

155
00:08:35,682 --> 0:08:38,552
无损压缩是默认的压缩类型

156
00:08:38,919 --> 0:08:42,022
它被用于绝大多数的app资源上

157
00:08:43,190 --> 0:08:45,459
因此 知道你应该如何

158
00:08:45,526 --> 0:08:48,362
充分利用有损压缩

159
00:08:51,665 --> 0:08:55,869
通常 图像插图可以根据其色域配置

160
00:08:55,936 --> 0:08:57,905
分成两大类

161
00:08:58,972 --> 0:09:03,443
并且它们从无损压缩中

162
00:08:58,972 --> 0:09:03,443
并且它们从无损压缩中

163
00:09:04,311 --> 0:09:05,546
让我们来看一下

164
00:09:08,215 --> 0:09:12,619
第一类图像通常指的是简单插图

165
00:09:13,720 --> 0:09:15,556
它们被这么叫

166
00:09:16,490 --> 0:09:18,892
是因为它们有相对较窄的色域

167
00:09:19,293 --> 0:09:22,296
以及相对少的离散颜色值

168
00:09:23,630 --> 0:09:26,099
这是由于其简单化的设计

169
00:09:26,433 --> 0:09:29,169
它们最好的代表就是app图标

170
00:09:31,338 --> 0:09:34,308
另一方面 另一种图像插图

171
00:09:34,374 --> 0:09:36,410
被称为复杂插图

172
00:09:37,945 --> 0:09:41,448
两种图像资源从无损压缩中

173
00:09:41,515 --> 0:09:42,783
获得的收益是不同的

174
00:09:43,283 --> 0:09:45,819
通常来说 所有的无损压缩

175
00:09:45,886 --> 0:09:49,723
在这两种图像上表现得都很好

176
00:09:51,058 --> 0:09:55,462
我们意识到这两种图像

177
00:09:56,296 --> 0:09:58,665
而且我想要你们所有的资源

178
00:09:58,932 --> 0:10:01,935
都尽可能地通过无损压缩进行部署

179
00:09:58,932 --> 0:10:01,935
都尽可能地通过无损压缩进行部署

180
00:10:03,203 --> 0:10:05,205
我非常高兴地宣布今年

181
00:10:05,706 --> 0:10:09,676
我们会在资源目录中

182
00:10:11,378 --> 0:10:14,548
它叫做Apple深度像素图像压缩

183
00:10:22,222 --> 0:10:23,156
再次感谢大家

184
00:10:24,825 --> 0:10:28,996
Apple深度像素图像压缩是一种

185
00:10:29,062 --> 0:10:31,698
适应于图像色域的灵活压缩格式

186
00:10:32,599 --> 0:10:33,433
这就意味着

187
00:10:33,500 --> 0:10:36,103
它可以根据图像插图

188
00:10:36,436 --> 0:10:38,405
色域特征来选择

189
00:10:38,805 --> 0:10:41,041
最优的压缩算法

190
00:10:42,509 --> 0:10:47,381
今年 我们不仅将这个

191
00:10:47,748 --> 0:10:50,284
还会使其在我们所有的平台上

192
00:10:50,350 --> 0:10:51,752
还有原生app上可用

193
00:10:53,453 --> 0:10:54,454
通过这种压缩格式

194
00:10:54,521 --> 0:10:58,325
我们观察到 我们所有的项目

195
00:10:58,392 --> 0:11:00,894
减少了平均20%的大小

196
00:10:58,392 --> 0:11:00,894
减少了平均20%的大小

197
00:11:02,162 --> 0:11:03,530
这是相当可观的

198
00:11:09,002 --> 0:11:11,972
现在 让我们看看一些数字

199
00:11:15,108 --> 0:11:19,580
这是一张图表

200
00:11:20,047 --> 0:11:22,516
所有资源目录的总体规模

201
00:11:24,017 --> 0:11:26,820
很明显 我们能够在所有平台上看到

202
00:11:26,887 --> 0:11:31,024
最多20%的尺寸缩减

203
00:11:35,963 --> 0:11:40,467
说到无损压缩

204
00:11:41,468 --> 0:11:43,303
由于你app中的大部分插图

205
00:11:43,370 --> 0:11:46,607
用的都是无损压缩

206
00:11:47,107 --> 0:11:49,643
所以解码时间也很重要

207
00:11:50,711 --> 0:11:52,546
Apple深度像素图像压缩

208
00:11:53,113 --> 0:11:57,618
也能够缩减20%的解码时间

209
00:12:01,088 --> 0:12:02,756
（部署目标与app精简）

210
00:12:02,823 --> 0:12:04,758
这就是关于无损压缩的内容

211
00:12:05,993 --> 0:12:07,394
现在我想换个话题

212
00:12:07,761 --> 0:12:12,666
谈谈两个独立但很相关的主题

213
00:12:13,433 --> 0:12:16,904
它们对我刚才谈到

214
00:12:16,970 --> 0:12:18,105
有很大的影响

215
00:12:19,740 --> 0:12:21,975
这就是部署和app精简

216
00:12:25,612 --> 0:12:28,015
下面是有关app精简的介绍

217
00:12:28,649 --> 0:12:31,718
app精简是发生在

218
00:12:31,785 --> 0:12:33,954
它会根据所有设备模型

219
00:12:34,221 --> 0:12:35,856
生成项目的所有变量

220
00:12:36,256 --> 0:12:39,259
还有部署目标的版本

221
00:12:41,295 --> 0:12:44,865
app精简的好处之一就是

222
00:12:45,666 --> 0:12:47,935
可以让你app的部署目标版本

223
00:12:48,335 --> 0:12:51,405
低于你目标平台

224
00:12:51,471 --> 0:12:53,040
的最新版本

225
00:12:53,807 --> 0:12:56,710
这样你可以吸引更多用户

226
00:12:58,579 --> 0:13:01,415
app精简可以

227
00:12:58,579 --> 0:13:01,415
app精简可以

228
00:13:01,782 --> 0:13:03,951
生成你项目的所有变量

229
00:13:04,284 --> 0:13:08,822
并且在你所有的用户群中

230
00:13:10,757 --> 0:13:13,827
如果你今年使用Xcode 10

231
00:13:13,894 --> 0:13:16,263
和iOS 12系列的

232
00:13:16,830 --> 0:13:19,166
你的项目会自动得益于

233
00:13:19,233 --> 0:13:20,400
我刚才谈到的

234
00:13:20,534 --> 0:13:22,803
所有的优化和新的压缩方式

235
00:13:24,271 --> 0:13:25,105
然而

236
00:13:25,639 --> 0:13:29,109
如果你将你的app部署回较早版本

237
00:13:30,777 --> 0:13:34,414
新的优化将不会被保留

238
00:13:35,816 --> 0:13:37,317
这是由于app精简

239
00:13:37,618 --> 0:13:39,853
必须生成与目标平台的

240
00:13:39,920 --> 0:13:42,489
早期版本更兼容的版本

241
00:13:44,758 --> 0:13:46,026
这不是很理想

242
00:13:46,793 --> 0:13:49,563
更重要的是

243
00:13:49,630 --> 0:13:52,266
都以最优化的方式进行部署

244
00:13:53,300 --> 0:13:54,935
我很高兴地宣布今年

245
00:13:55,002 --> 0:13:58,305
我们将要推出新版本的app精简

246
00:13:58,572 --> 0:13:59,973
它叫做操作系统变量精简

247
00:14:02,409 --> 0:14:03,744
通过操作系统变量精简

248
00:14:05,746 --> 0:14:07,981
你的app仍然可以

249
00:14:08,749 --> 0:14:11,652
面向你的目标平台上

250
00:14:12,252 --> 0:14:15,455
在这里就是

251
00:14:17,224 --> 0:14:19,826
对于那些运行

252
00:14:20,594 --> 0:14:24,231
操作系统变量精简能够在你的项目里

253
00:14:24,565 --> 0:14:27,634
这个变量具有所有的

254
00:14:28,702 --> 0:14:33,073
这样 每个人都可以

255
00:14:33,140 --> 0:14:35,442
每个人就都满意了

256
00:14:42,816 --> 0:14:43,817
（app精简的输出）

257
00:14:43,884 --> 0:14:46,119
这就是app精简

258
00:14:47,454 --> 0:14:49,389
现在我想通过一个例子

259
00:14:49,456 --> 0:14:53,460
说明该如何在Xcode本地环境中

260
00:14:53,527 --> 0:14:55,128
专家工作流

261
00:14:56,763 --> 0:14:58,432
这是个很简单的过程

262
00:14:59,132 --> 0:15:02,736
你只需要点击Xcode的归档按钮

263
00:14:59,132 --> 0:15:02,736
你只需要点击Xcode的归档按钮

264
00:15:04,071 --> 0:15:08,008
这样就会告诉Xcode

265
00:15:10,344 --> 0:15:14,481
在这些完成之后

266
00:15:14,848 --> 0:15:17,885
就可以打开一个

267
00:15:17,951 --> 0:15:19,419
所有变量的窗口

268
00:15:22,189 --> 0:15:25,225
这个是乐队项目的窗口

269
00:15:25,292 --> 0:15:27,628
我们可以用它来演练一下

270
00:15:29,162 --> 0:15:33,800
首先Xcode会让你

271
00:15:34,668 --> 0:15:37,304
你可以用这个方法

272
00:15:38,539 --> 0:15:42,976
为了达到这个演练的目的

273
00:15:46,313 --> 0:15:50,150
在接下来出现窗口的

274
00:15:51,151 --> 0:15:52,052
选择

275
00:15:53,320 --> 0:15:54,922
所有可兼容的设备变量

276
00:15:56,156 --> 0:16:00,460
这会告诉Xcode输出所有

277
00:15:56,156 --> 0:16:00,460
这会告诉Xcode输出所有

278
00:16:01,028 --> 0:16:03,530
指向所有支持设备类型的变量

279
00:16:06,466 --> 0:16:10,370
在完成之后

280
00:16:10,871 --> 0:16:13,440
总结了所有刚刚生成的变量的报告

281
00:16:14,474 --> 0:16:17,744
你可以从报告中

282
00:16:17,811 --> 0:16:20,581
来帮助你更好地理解项目的部署

283
00:16:21,114 --> 0:16:23,517
并且帮助回答一些关键问题

284
00:16:23,817 --> 0:16:27,020
比如“我的报告生成了

285
00:16:27,754 --> 0:16:29,523
“它们的大小如何呢？”

286
00:16:30,257 --> 0:16:32,993
“对于某个变量还有没有优化

287
00:16:33,060 --> 0:16:35,295
和调整的空间呢？”

288
00:16:37,898 --> 0:16:40,400
其实车库项目生成的半数变量

289
00:16:40,467 --> 0:16:43,003
是其刚输出的

290
00:16:43,904 --> 0:16:45,205
让我们来看一下

291
00:16:47,508 --> 0:16:48,842
在这个表中

292
00:16:50,711 --> 0:16:51,945
你们可以看到

293
00:16:52,212 --> 0:16:56,617
所有为一个选定设备模型集

294
00:16:58,752 --> 0:17:01,555
这是为iOS11

295
00:16:58,752 --> 0:17:01,555
这是为iOS11

296
00:17:01,622 --> 0:17:03,624
以及更早版本的变量所生成的大小

297
00:17:05,092 --> 0:17:08,295
因为乐队是个很大的项目

298
00:17:08,362 --> 0:17:10,464
它有着数以千计的图像插图

299
00:17:11,064 --> 0:17:13,066
所生成变量的大小

300
00:17:13,567 --> 0:17:16,502
从90MB到超过100MB

301
00:17:19,506 --> 0:17:20,574
这些是iOS 12中

302
00:17:21,175 --> 0:17:22,476
变量的数字

303
00:17:23,977 --> 0:17:26,946
从这个图标中 可以立竿见影地看到

304
00:17:27,146 --> 0:17:31,985
我们节省了10%到20%的

305
00:17:33,620 --> 0:17:35,822
你可能现在看这个数字

306
00:17:36,456 --> 0:17:37,691
所有这些优化

307
00:17:38,125 --> 0:17:41,762
都是我刚才介绍过的优化和压缩方法

308
00:17:46,366 --> 0:17:47,835
这就是关于图像压缩的内容

309
00:17:48,836 --> 0:17:51,038
我想让我的同事Patrick

310
00:17:51,104 --> 0:17:54,942
来介绍下有关你app资源的

311
00:17:59,079 --> 0:18:00,013
谢谢 Will

312
00:17:59,079 --> 0:18:00,013
谢谢 Will

313
00:18:02,482 --> 0:18:05,319
这很棒

314
00:18:05,385 --> 0:18:09,857
你可以用这些方法在Xcode的

315
00:18:10,791 --> 0:18:13,193
我要介绍一些

316
00:18:13,260 --> 0:18:15,429
你可以通过资源目录

317
00:18:15,495 --> 0:18:18,832
来优化你app中资源的方法

318
00:18:19,566 --> 0:18:23,237
我想从设计和生产开始说

319
00:18:23,303 --> 0:18:25,472
因为这是项目开始的地方

320
00:18:25,539 --> 0:18:27,441
（设计和生产）

321
00:18:28,308 --> 0:18:30,744
正如你所知 资源是来自于很多工具

322
00:18:30,811 --> 0:18:33,480
很多不同的工作流

323
00:18:33,714 --> 0:18:34,848
但它们有一个共同点

324
00:18:34,915 --> 0:18:37,384
它们终究在某种程度上是来自于人的

325
00:18:38,185 --> 0:18:40,087
而且它组织良好

326
00:18:40,988 --> 0:18:42,856
以便理解那些资源

327
00:18:42,923 --> 0:18:45,859
进入你软件工作流的过程

328
00:18:45,926 --> 0:18:47,361
而且要留意那些

329
00:18:47,427 --> 0:18:51,064
在你app的整体效率中

330
00:18:52,833 --> 0:18:56,837
首先我想介绍的主题就是色彩管理

331
00:18:56,904 --> 0:18:59,506
它总是被忽略 但是却十分重要

332
00:19:01,208 --> 0:19:06,480
图像资源在磁盘上就是

333
00:19:06,547 --> 0:19:10,184
在你加上颜色之前

334
00:19:10,250 --> 0:19:11,118
那么它是如何有颜色的呢？

335
00:19:11,185 --> 0:19:13,053
系统是怎么知道

336
00:19:13,120 --> 0:19:14,421
那些字节上的数字是什么意思？

337
00:19:14,488 --> 0:19:16,623
答案就是色彩配置文件

338
00:19:17,024 --> 0:19:21,228
该文件会给每种颜色一个值

339
00:19:21,295 --> 0:19:23,030
还有一个绝对比色分析值

340
00:19:23,096 --> 0:19:25,165
它会告诉系统

341
00:19:25,799 --> 0:19:26,900
我想要强调的是

342
00:19:26,967 --> 0:19:29,169
维护你资源中的色彩配置文件

343
00:19:29,236 --> 0:19:31,138
真的很重要

344
00:19:31,438 --> 0:19:35,976
它们是保证资源如设计者

345
00:19:36,376 --> 0:19:38,579
的元数据的重要组成部分

346
00:19:38,645 --> 0:19:42,082
不要因为你觉得

347
00:19:42,149 --> 0:19:43,951
就将那些配置文件丢掉

348
00:19:44,017 --> 0:19:45,819
就当是占去一堆负载

349
00:19:45,886 --> 0:19:48,188
这些是进入你项目中的资源

350
00:19:48,288 --> 0:19:51,225
让工具来操心

351
00:19:53,594 --> 0:19:56,263
为什么这个色彩配置文件很重要呢？

352
00:19:56,330 --> 0:19:59,900
因为我们的设备有不同特征

353
00:20:00,200 --> 0:20:01,535
不同大小的显示屏

354
00:20:01,602 --> 0:20:04,338
所以就要有某些东西

355
00:20:04,404 --> 0:20:07,508
会匹配合适

356
00:20:07,574 --> 0:20:08,809
看起来及缩放时比较得当

357
00:20:08,876 --> 0:20:11,278
这就是色彩管理的职责

358
00:20:11,845 --> 0:20:13,647
这是个计算的过程

359
00:20:14,081 --> 0:20:17,618
它可以由CPU完成

360
00:20:17,684 --> 0:20:18,819
不过它的计算量不小

361
00:20:20,053 --> 0:20:21,088
现在…

362
00:20:21,154 --> 0:20:22,823
资源目录就会发挥作用了

363
00:20:22,923 --> 0:20:25,158
因为在编译过程

364
00:20:25,225 --> 0:20:26,793
的构建时间

365
00:20:27,060 --> 0:20:29,396
它们会为你进行颜色匹配

366
00:20:29,830 --> 0:20:32,432
这真的很棒 因为计算根本

367
00:20:32,499 --> 0:20:35,102
不必在设备上进行

368
00:20:35,802 --> 0:20:38,071
而且你的资源在设备上已经准备好了

369
00:20:38,138 --> 0:20:38,972
准备好加载

370
00:20:39,039 --> 0:20:41,308
准备好被显示 不会有任何的麻烦

371
00:20:42,109 --> 0:20:42,943
还有意外收获就是

372
00:20:43,010 --> 0:20:46,280
这个多出来的在构造时间

373
00:20:46,346 --> 0:20:48,115
消除了你原来

374
00:20:48,182 --> 0:20:50,184
可能要去掉的配置文件负载

375
00:20:50,250 --> 0:20:55,122
并且将它替换成

376
00:20:55,189 --> 0:20:56,823
我们所拥有的颜色空间

377
00:20:58,659 --> 0:21:00,093
这就是色彩管理的内容

378
00:20:58,659 --> 0:21:00,093
这就是色彩管理的内容

379
00:21:00,794 --> 0:21:04,031
我想介绍一个相关的主题

380
00:21:04,097 --> 0:21:05,165
（工作空间）

381
00:21:05,232 --> 0:21:08,302
这里的工作空间 我指的是

382
00:21:08,368 --> 0:21:10,671
这些资源最开始起源的环境

383
00:21:10,737 --> 0:21:13,574
这可能是设计者 或是工程师

384
00:21:13,640 --> 0:21:15,542
在完成这些素材

385
00:21:15,776 --> 0:21:17,311
你在设计工具中进行工作

386
00:21:17,377 --> 0:21:18,679
你在创造内容

387
00:21:18,979 --> 0:21:22,950
在这些场景中对你项目中

388
00:21:23,016 --> 0:21:25,319
使用一致的色彩设定非常重要

389
00:21:25,586 --> 0:21:27,254
这是个不错的实践方法

390
00:21:27,321 --> 0:21:29,756
也有着技术层面的好处

391
00:21:29,823 --> 0:21:35,062
因为它可以保证你app

392
00:21:35,128 --> 0:21:37,931
管理的一致性

393
00:21:38,699 --> 0:21:42,402
有两种被谈得最多

394
00:21:42,469 --> 0:21:45,873
也是最推荐用来创建

395
00:21:45,939 --> 0:21:47,508
8位sRGB

396
00:21:47,908 --> 0:21:50,344
是目前最常见 最受欢迎的选择

397
00:21:50,410 --> 0:21:53,280
它对于我们所有的设备

398
00:21:53,680 --> 0:21:55,616
和你的内容类型有着最广泛的适用性

399
00:21:56,149 --> 0:21:59,152
但是如果你在制作重要的资源

400
00:21:59,319 --> 0:22:01,255
比如像是这个很棒的鲜花图标

401
00:21:59,319 --> 0:22:01,255
比如像是这个很棒的鲜花图标

402
00:22:01,321 --> 0:22:03,991
一样的鲜活的设计

403
00:22:04,057 --> 0:22:05,592
你可能要用到

404
00:22:05,659 --> 0:22:09,396
我们某些设备上的广色域特性

405
00:22:10,330 --> 0:22:12,566
并且使用广色域

406
00:22:13,433 --> 0:22:14,968
使用生成的广色域资源吧

407
00:22:15,035 --> 0:22:17,371
我推荐你们将Display P3

408
00:22:17,437 --> 0:22:18,805
作为你们的工作配置文件

409
00:22:18,939 --> 0:22:21,942
每个信道16位可以保证

410
00:22:22,643 --> 0:22:24,278
你执行该设计时

411
00:22:24,912 --> 0:22:27,014
现在Xcode 以及运行时间平台

412
00:22:27,080 --> 0:22:30,984
就有了更广的处理范围以及管理选项

413
00:22:31,051 --> 0:22:33,253
来处理这个广色域资源

414
00:22:34,021 --> 0:22:35,822
我不会太过深入介绍

415
00:22:35,889 --> 0:22:38,258
但是我建议你们去参考一下

416
00:22:38,325 --> 0:22:41,361
我两年前讲过的

417
00:22:41,995 --> 0:22:43,964
我详细介绍了这些主题

418
00:22:44,031 --> 0:22:45,832
并且会给你更多的背景知识

419
00:22:45,899 --> 0:22:48,402
从去年开始

420
00:22:48,468 --> 0:22:51,538
在developer.apple.com网站上的

421
00:22:51,605 --> 0:22:55,976
iOS设计资源区有了

422
00:22:56,743 --> 0:22:58,378
（可拉伸图像）

423
00:22:58,445 --> 0:23:00,781
现在让我们介绍一些

424
00:22:58,445 --> 0:23:00,781
现在让我们介绍一些

425
00:23:02,482 --> 0:23:03,417
实际的软件资源

426
00:23:03,483 --> 0:23:04,952
可能你的

427
00:23:07,221 --> 0:23:12,125
用户界面要调整很多不同的

428
00:23:12,860 --> 0:23:16,430
它通常会调用需要拉伸和变大的插图

429
00:23:16,864 --> 0:23:19,466
以适应这些布局的变化

430
00:23:19,933 --> 0:23:21,735
你要如何实现这些变化呢？

431
00:23:22,436 --> 0:23:24,137
最常见的方法就是

432
00:23:24,204 --> 0:23:26,773
识别出图像中可拉伸的部分

433
00:23:26,840 --> 0:23:28,575
与不可拉伸的部分

434
00:23:28,976 --> 0:23:29,843
为什么要有所区别呢？

435
00:23:29,910 --> 0:23:33,046
幻灯片上有个简单的例子

436
00:23:33,113 --> 0:23:35,883
假设我们的资源中有个漂亮的形状

437
00:23:35,949 --> 0:23:37,618
像圆角这样

438
00:23:37,684 --> 0:23:39,786
保留的内容 就像是相框一样

439
00:23:40,220 --> 0:23:42,389
你要保证不会拉伸

440
00:23:42,456 --> 0:23:45,792
但是你可以拉伸黄色的部分

441
00:23:46,426 --> 0:23:50,430
通常情况下

442
00:23:50,497 --> 0:23:54,568
就是要将这些项分开

443
00:23:54,635 --> 0:23:56,803
并将它们当做独立的资源进行分发

444
00:23:57,104 --> 0:24:01,008
比方说 程序员可以使用

445
00:23:57,104 --> 0:24:01,008
比方说 程序员可以使用

446
00:24:01,074 --> 0:24:03,944
draw three或是nine-part API

447
00:24:04,811 --> 0:24:06,380
这样做是可以的

448
00:24:06,446 --> 0:24:08,849
而且已经被实践和使用了多年

449
00:24:09,249 --> 0:24:10,684
不过它有一个不足之处

450
00:24:11,118 --> 0:24:15,122
将这些图像重组成最终尺寸

451
00:24:15,189 --> 0:24:17,691
它可能会有点复杂而且低效

452
00:24:17,758 --> 0:24:23,197
这对于像是

453
00:24:23,263 --> 0:24:24,298
现代GPU UI管道来说并不合适

454
00:24:25,866 --> 0:24:27,100
更好的方法是什么呢？

455
00:24:27,601 --> 0:24:30,070
更好的办法就是 对于单个图像

456
00:24:30,470 --> 0:24:33,340
就提供表明其拉伸部分的

457
00:24:33,407 --> 0:24:35,876
拉伸元数据

458
00:24:36,910 --> 0:24:39,947
这会带来对于可变尺寸图像来说

459
00:24:40,013 --> 0:24:41,114
最优的、流畅的GPU动画

460
00:24:42,783 --> 0:24:44,585
而且我很高兴地告诉你们资源目录

461
00:24:44,651 --> 0:24:46,353
可以轻松使其实现

462
00:24:47,621 --> 0:24:49,456
它叫做展示分割编辑器

463
00:24:50,557 --> 0:24:54,194
它真的很容易用

464
00:24:54,628 --> 0:24:58,031
然后你就会开始分割行

465
00:24:58,098 --> 0:25:01,668
这可以让你识别出图像的可拉伸部分

466
00:24:58,098 --> 0:25:01,668
这可以让你识别出图像的可拉伸部分

467
00:25:01,735 --> 0:25:03,837
与不可拉伸部分

468
00:25:03,971 --> 0:25:06,206
在本例中 左侧和右侧检查完了

469
00:25:06,273 --> 0:25:10,077
而中间部分是橙色的

470
00:25:10,544 --> 0:25:11,445
现在

471
00:25:12,079 --> 0:25:14,581
你可能注意到了

472
00:25:14,648 --> 0:25:17,084
地方都有白色阴影

473
00:25:17,150 --> 0:25:18,385
这是怎么回事呢？

474
00:25:18,785 --> 0:25:20,754
这其实是一个很有意思的事

475
00:25:20,821 --> 0:25:25,192
这部分的资源其实是不再被需要了

476
00:25:25,259 --> 0:25:28,996
因为我们用剩下的三个部分

477
00:25:29,429 --> 0:25:31,231
为什么这很重要呢？

478
00:25:31,899 --> 0:25:35,702
好处就是现在Xcode

479
00:25:35,769 --> 0:25:40,073
我们可以只取需要的部分

480
00:25:40,674 --> 0:25:41,942
所以我们就不要

481
00:25:42,009 --> 0:25:43,710
将这一大块部分保存在磁盘字节上

482
00:25:43,777 --> 0:25:45,579
这些字节会被用到你的app中的

483
00:25:46,113 --> 0:25:47,114
这很棒

484
00:25:47,181 --> 0:25:50,450
它还有另一个好处

485
00:25:50,517 --> 0:25:53,253
这个更加隐晦一点 不过我很喜欢

486
00:25:53,320 --> 0:25:55,122
这意味着你可以告诉你的设计师

487
00:25:55,189 --> 0:25:57,658
可以以原始尺寸

488
00:25:57,724 --> 0:25:59,593
送达资源

489
00:25:59,726 --> 0:26:01,795
且不用为了有效部署

490
00:25:59,726 --> 0:26:01,795
且不用为了有效部署

491
00:26:01,862 --> 0:26:06,066
以使其尽可能地小

492
00:26:06,133 --> 0:26:07,668
这不应该是设计师所考虑的

493
00:26:07,734 --> 0:26:09,770
长远来说

494
00:26:09,837 --> 0:26:12,739
放到源代码中

495
00:26:12,806 --> 0:26:13,841
更有意义

496
00:26:14,241 --> 0:26:16,944
让工具来考虑部署的细节问题

497
00:26:17,010 --> 0:26:18,545
（资源目录展示分割）

498
00:26:18,612 --> 0:26:20,514
除了图形化的检查器

499
00:26:20,581 --> 0:26:22,816
以及图形化识别可拉伸部分的方法

500
00:26:22,883 --> 0:26:25,285
当然了还有展示分割检查器

501
00:26:25,352 --> 0:26:28,522
你可以更好地控制边缘插图

502
00:26:28,589 --> 0:26:32,226
还可以控制中心部分

503
00:26:32,292 --> 0:26:34,194
拉伸或覆盖的行为

504
00:26:36,129 --> 0:26:37,264
所有这些内容

505
00:26:37,331 --> 0:26:40,467
结合起来就是为了

506
00:26:40,701 --> 0:26:43,537
这会让后面产生很大的收益

507
00:26:43,604 --> 0:26:45,038
设计师会不可避免地

508
00:26:45,105 --> 0:26:47,407
更新你的设计

509
00:26:48,141 --> 0:26:50,277
现在你就可以在一个地方

510
00:26:50,344 --> 0:26:52,646
而不用记住代码中的五六个地方

511
00:26:52,713 --> 0:26:55,349
这些地方你可能

512
00:26:56,283 --> 0:26:58,552
现在它都集中到一个地方了

513
00:27:00,721 --> 0:27:01,722
谢谢

514
00:27:04,658 --> 0:27:07,160
接下来我想介绍一下矢量资源

515
00:27:07,227 --> 0:27:08,495
（矢量资源）

516
00:27:08,562 --> 0:27:11,465
由于我们所有产品的显示屏

517
00:27:11,532 --> 0:27:13,367
都有不同的分辨率

518
00:27:13,433 --> 0:27:16,303
你可能已经习惯于根据目标平台

519
00:27:16,370 --> 0:27:18,505
使用1倍、2倍、3倍大的图像

520
00:27:18,572 --> 0:27:19,640
不同的资源

521
00:27:20,073 --> 0:27:22,209
这用起来并没有问题

522
00:27:22,643 --> 0:27:25,679
但每次对于一个设计

523
00:27:25,746 --> 0:27:27,314
挺麻烦的

524
00:27:28,015 --> 0:27:29,750
就是因为分辨率

525
00:27:30,817 --> 0:27:32,920
如果你可以避免使用这个方法

526
00:27:32,986 --> 0:27:33,987
只用一个资源就可以？

527
00:27:34,054 --> 0:27:37,024
你确实可以这么做

528
00:27:37,090 --> 0:27:39,426
支持矢量资源已经有些年头了

529
00:27:39,826 --> 0:27:42,996
通过使用Xcode资源目录

530
00:27:43,664 --> 0:27:45,532
你可以提供一个PDF

531
00:27:45,866 --> 0:27:49,369
Xcode就可以根据平台

532
00:27:49,670 --> 0:27:52,639
那个PDF文件

533
00:27:53,340 --> 0:27:55,843
你app正指向的因素

534
00:27:57,177 --> 0:27:58,378
这很棒 因为这意味着

535
00:27:58,445 --> 0:28:00,948
你不要担心需要支付任何开销

536
00:27:58,445 --> 0:28:00,948
你不要担心需要支付任何开销

537
00:28:01,481 --> 0:28:02,449
在运行时间的设备上

538
00:28:02,516 --> 0:28:06,954
渲染一个可能挺复杂的

539
00:28:08,322 --> 0:28:10,557
这让你对使用矢量有了些概念

540
00:28:11,425 --> 0:28:14,161
有时候你可能

541
00:28:14,228 --> 0:28:17,564
想在某种情况下将你的资源

542
00:28:17,631 --> 0:28:21,935
以对比其最常用的设计尺寸不同

543
00:28:22,002 --> 0:28:23,203
的尺寸或范围来显示

544
00:28:23,704 --> 0:28:28,342
从去年的iOS 11

545
00:28:28,408 --> 0:28:30,777
我们现在可以让你保留矢量数据

546
00:28:31,245 --> 0:28:35,949
以便在图像被放入比该资源的

547
00:28:36,016 --> 0:28:38,519
实际尺寸大的图像视图时

548
00:28:38,585 --> 0:28:41,688
它可以找到原始的PDF矢量数据

549
00:28:41,755 --> 0:28:45,726
另外我们已经去除链接

550
00:28:45,792 --> 0:28:47,461
和配置文件

551
00:28:47,528 --> 0:28:49,429
还是尽可能小的

552
00:28:50,497 --> 0:28:52,466
让我们在运行时间重新栅格化

553
00:28:52,533 --> 0:28:54,501
但是除非你超出了原始尺寸

554
00:28:54,568 --> 0:28:57,771
否则我们就用优化过的预渲染位图

555
00:28:58,405 --> 0:29:00,207
这样做很棒

556
00:28:58,405 --> 0:29:00,207
这样做很棒

557
00:29:00,274 --> 0:29:03,043
可以更灵活得响应动态类型

558
00:29:03,477 --> 0:29:07,281
并且在你改变UIImage

559
00:29:07,347 --> 0:29:10,083
自动地让你的图像看着更干脆

560
00:29:12,586 --> 0:29:13,720
这就是矢量资源的内容

561
00:29:14,988 --> 0:29:19,359
接下来我想介绍一点

562
00:29:20,027 --> 0:29:21,061
（2倍图像设计）

563
00:29:21,128 --> 0:29:22,963
2倍图像 通常以视网膜为人所知

564
00:29:23,931 --> 0:29:26,867
它是你的app用到的

565
00:29:27,434 --> 0:29:30,270
最受欢迎 以及最常见的显示密度

566
00:29:30,971 --> 0:29:32,339
这很棒 不是吗？

567
00:29:32,406 --> 0:29:34,341
这是很大的进步

568
00:29:34,408 --> 0:29:36,844
然而还是有时候

569
00:29:37,411 --> 0:29:40,147
你在设计的时候

570
00:29:41,448 --> 0:29:44,718
一道笔画或边

571
00:29:44,785 --> 0:29:46,186
从而导致边缘很模糊

572
00:29:46,253 --> 0:29:49,389
它还没有那么高的分辨率

573
00:29:49,456 --> 0:29:51,225
是锐利的还是模糊的边缘

574
00:29:52,192 --> 0:29:56,897
有时候这仍然是设计资源的挑战

575
00:29:58,265 --> 0:30:02,135
可以用什么技术来解决这个问题呢？

576
00:29:58,265 --> 0:30:02,135
可以用什么技术来解决这个问题呢？

577
00:30:04,037 --> 0:30:07,741
一个常见的设计手段

578
00:30:07,808 --> 0:30:09,343
点边缘修整功能

579
00:30:09,409 --> 0:30:12,279
设置一个点间隔的网格

580
00:30:12,346 --> 0:30:15,349
打开修整功能 在你调整形状

581
00:30:15,415 --> 0:30:17,951
或控制点的时候

582
00:30:18,018 --> 0:30:19,086
在它们修到边的时候

583
00:30:19,152 --> 0:30:22,422
你就可以知道这是个像素边

584
00:30:23,223 --> 0:30:24,224
这很不错

585
00:30:24,725 --> 0:30:28,195
还有时候 你可能有个设计

586
00:30:28,262 --> 0:30:31,532
的某些边或许是介于

587
00:30:32,966 --> 0:30:35,102
1倍和2倍之间 但是你并不确定

588
00:30:35,169 --> 0:30:38,038
你想知道

589
00:30:38,105 --> 0:30:40,507
会是什么样的

590
00:30:40,574 --> 0:30:42,843
做进一步优化吗？

591
00:30:43,544 --> 0:30:46,113
你其实可以用一个两倍的网格

592
00:30:46,180 --> 0:30:49,650
在你的矢量设计工具中

593
00:30:50,083 --> 0:30:53,387
并且把该网格变为一个像素的网格

594
00:30:53,453 --> 0:30:57,691
也就是每两个点 每两个单元

595
00:30:58,592 --> 0:31:02,796
然后调整你的资源 并使用点修整

596
00:30:58,592 --> 0:31:02,796
然后调整你的资源 并使用点修整

597
00:31:02,863 --> 0:31:05,933
来调整你的笔画和边缘来适应这里

598
00:31:07,234 --> 0:31:08,268
真很不错

599
00:31:08,335 --> 0:31:09,870
那现在该怎么做呢？

600
00:31:09,937 --> 0:31:11,872
它太大了不是吗 难道不能用吗？

601
00:31:12,206 --> 0:31:13,040
是可以用的！

602
00:31:13,440 --> 0:31:16,343
你只需要把它放到

603
00:31:16,410 --> 0:31:18,879
资源目录缩放桶里的2倍那一格

604
00:31:19,213 --> 0:31:23,150
这就可以让Xcode

605
00:31:23,217 --> 0:31:25,185
知道它其实是插图的两倍部分

606
00:31:25,252 --> 0:31:26,653
它有点太大了

607
00:31:26,720 --> 0:31:29,356
一点并不等于视网膜显示的两个像素

608
00:31:29,423 --> 0:31:31,225
而是刚好相反

609
00:31:31,291 --> 0:31:32,426
我们来计算一下

610
00:31:32,492 --> 0:31:35,028
我们要为所有其他范围因素渲染

611
00:31:35,095 --> 0:31:37,364
右边所有的栅格化位图

612
00:31:37,865 --> 0:31:42,102
将设计师解放出来使用两倍网格

613
00:31:43,103 --> 0:31:44,037
（有提示的资源）

614
00:31:44,104 --> 0:31:46,940
当然了 如果自动缩放还不够

615
00:31:47,007 --> 0:31:49,676
或是在某些地方出问题的话

616
00:31:50,611 --> 0:31:53,514
你对结果是有最终控制权的

617
00:31:53,580 --> 0:31:57,084
你可以将有提示的位图

618
00:31:57,150 --> 0:31:58,452
接下来我们会使用它

619
00:31:58,519 --> 0:32:02,956
来替代生成的PDF栅格化

620
00:31:58,519 --> 0:32:02,956
来替代生成的PDF栅格化

621
00:32:04,825 --> 0:32:09,429
这就是关于设计与生产的最后内容

622
00:32:09,496 --> 0:32:13,267
现在让我们介绍下在Xcode中

623
00:32:13,534 --> 0:32:15,269
收录和整理方面的内容

624
00:32:15,335 --> 0:32:16,403
（很多选项）

625
00:32:16,470 --> 0:32:19,406
对于你们当中使用过

626
00:32:19,473 --> 0:32:22,476
看到你面前有这么多东西

627
00:32:22,543 --> 0:32:24,178
可能会感觉有些应付不过来

628
00:32:24,244 --> 0:32:26,947
你们应该用什么呢 选择有很多

629
00:32:27,314 --> 0:32:28,782
我要告诉你们

630
00:32:29,816 --> 0:32:32,653
你应该只用有意义的那些选项

631
00:32:33,086 --> 0:32:34,888
对你的项目来说有意义的

632
00:32:35,556 --> 0:32:38,258
对于你要处理的内容有意义

633
00:32:38,325 --> 0:32:41,628
有很多的选项

634
00:32:41,695 --> 0:32:44,364
以及功能非常多的组织方案

635
00:32:44,431 --> 0:32:46,733
不过你应该按需使用

636
00:32:46,800 --> 0:32:48,836
从最简单的开始

637
00:32:48,902 --> 0:32:50,003
然后一点点深入

638
00:32:50,070 --> 0:32:51,405
（只用有意义的选项）

639
00:32:51,471 --> 0:32:55,008
我想介绍两种可以在这个领域帮助

640
00:32:55,075 --> 0:32:57,344
进行组织的方法

641
00:32:58,312 --> 0:32:59,646
第一种是捆绑

642
00:33:00,514 --> 0:33:02,950
我为什么要在介绍资源的

643
00:33:03,016 --> 0:33:04,017
这好像有点不太搭调

644
00:33:04,084 --> 0:33:05,719
我想解决的是

645
00:33:07,754 --> 0:33:08,789
大项目可能遇到的问题

646
00:33:09,323 --> 0:33:11,124
如果你有一个大项目

647
00:33:11,458 --> 0:33:14,294
可能有多个框架参与其中

648
00:33:14,361 --> 0:33:16,296
你甚至可能会和多个团队一起协作

649
00:33:16,997 --> 0:33:19,900
如果你要把所有的资源

650
00:33:19,967 --> 0:33:22,503
有时候会很困难

651
00:33:22,569 --> 0:33:26,073
你要在那管理所有这些资源

652
00:33:26,139 --> 0:33:27,574
而且…

653
00:33:28,542 --> 0:33:31,378
被恰当地导入你app中的对应位置

654
00:33:31,812 --> 0:33:33,580
你能解决这个问题的一个办法就是

655
00:33:33,647 --> 0:33:36,650
把这些资源构建到多个捆绑中

656
00:33:36,717 --> 0:33:38,552
因为Xcode会为每个捆绑或目标

657
00:33:38,619 --> 0:33:42,055
生成一个唯一的资源目录部署

658
00:33:42,589 --> 0:33:46,860
例如 考虑下创建一个

659
00:33:46,927 --> 0:33:49,897
这会是个不错的重用策略

660
00:33:49,963 --> 0:33:54,134
用一个统一的组件

661
00:33:54,201 --> 0:33:55,969
这个组件有一致的命名空间

662
00:33:57,571 --> 0:34:00,240
可以为你app的

663
00:33:57,571 --> 0:34:00,240
可以为你app的

664
00:34:00,307 --> 0:34:01,575
其他组件提供图像

665
00:34:03,410 --> 0:34:05,712
你要如何得到这些内容呢？很简单！

666
00:34:06,280 --> 0:34:11,351
你只需要使用像是

667
00:34:11,418 --> 0:34:14,420
以与特征集合兼容的捆绑命名

668
00:34:14,487 --> 0:34:15,722
当然了 在macOS端

669
00:34:15,789 --> 0:34:18,692
有一个资源NS捆绑类图像

670
00:34:18,759 --> 0:34:19,927
（捆绑）

671
00:34:19,993 --> 0:34:21,195
你要记住的是

672
00:34:21,695 --> 0:34:23,996
每个捆绑都会提供一个

673
00:34:24,498 --> 0:34:27,967
因此在这些空间中

674
00:34:28,034 --> 0:34:31,905
但是在捆绑间 你可以使用

675
00:34:34,574 --> 0:34:36,109
说到命名空间

676
00:34:36,176 --> 0:34:38,712
我想介绍另一个特性

677
00:34:38,779 --> 0:34:41,047
以及大项目中所遇到的另一个挑战

678
00:34:41,348 --> 0:34:44,217
在本例中 我所解决的问题是

679
00:34:44,284 --> 0:34:46,152
大的集合

680
00:34:46,485 --> 0:34:48,455
它们之中可能会有一些结构

681
00:34:48,522 --> 0:34:49,389
（命名空间）

682
00:34:49,456 --> 0:34:50,290
对吗？

683
00:34:50,357 --> 0:34:54,061
想象下 你可能在某个app中

684
00:34:54,127 --> 0:34:56,463
每个房间里有一张桌子和一把椅子

685
00:34:56,530 --> 0:34:58,098
它们每个都有资源

686
00:34:58,165 --> 0:35:00,634
在你的代码中

687
00:34:58,165 --> 0:35:00,634
在你的代码中

688
00:35:00,701 --> 0:35:03,570
这看起来似乎很自然

689
00:35:03,637 --> 0:35:04,671
你要怎么做呢？

690
00:35:05,339 --> 0:35:09,176
一种替代方案就是

691
00:35:09,243 --> 0:35:11,111
看看在你的代码中如何多路分配

692
00:35:11,512 --> 0:35:12,546
这不是最理想的方法

693
00:35:13,113 --> 0:35:15,449
资源目录可以提供一个解决方案

694
00:35:15,516 --> 0:35:17,951
就是使用所提供的命名空间选项

695
00:35:19,019 --> 0:35:20,654
在将你的插图整理到

696
00:35:20,954 --> 0:35:23,657
通过勾选这个框

697
00:35:24,324 --> 0:35:27,194
我们就可以自动地将文件名

698
00:35:29,396 --> 0:35:32,633
记录到每个图像

699
00:35:33,300 --> 0:35:34,968
你后面可以用来得到相关数据

700
00:35:35,402 --> 0:35:36,403
这是组织庞大结构的资源集合

701
00:35:36,470 --> 0:35:39,573
的好方法

702
00:35:40,674 --> 0:35:41,508
好了

703
00:35:42,142 --> 0:35:42,976
那么

704
00:35:43,577 --> 0:35:45,045
我们已经介绍了目录

705
00:35:45,879 --> 0:35:48,615
现在让我们介绍一些

706
00:35:48,982 --> 0:35:51,451
这里真的很令人兴奋

707
00:35:52,486 --> 0:35:53,754
（app精简）

708
00:35:53,820 --> 0:35:55,656
Will已介绍了

709
00:35:56,190 --> 0:35:57,724
我想大体上介绍下

710
00:35:57,791 --> 0:36:00,327
我们对资源目录的

711
00:35:57,791 --> 0:36:00,327
我们对资源目录的

712
00:36:00,394 --> 0:36:01,962
总的来说你要做的就是

713
00:36:02,029 --> 0:36:05,265
提供你app所有的变量内容

714
00:36:05,332 --> 0:36:08,435
你要根据在不同设备上

715
00:36:08,502 --> 0:36:09,570
来调整你的内容

716
00:36:09,636 --> 0:36:12,105
最常见的实现方法就是

717
00:36:12,172 --> 0:36:15,008
划分产品组

718
00:36:15,075 --> 0:36:21,181
TV或是Watch或不同的分辨率

719
00:36:21,782 --> 0:36:25,018
你要提供所有内容变量

720
00:36:25,319 --> 0:36:27,621
然后app精简要保证

721
00:36:27,688 --> 0:36:30,224
我们选择了该内容的正确子集

722
00:36:30,290 --> 0:36:31,425
这个子集的内容

723
00:36:31,491 --> 0:36:33,560
所使用的设备

724
00:36:36,396 --> 0:36:38,465
我想介绍另一种

725
00:36:38,532 --> 0:36:40,834
你可以实现同种内容调整的方式

726
00:36:41,668 --> 0:36:43,170
那就是性能类

727
00:36:43,237 --> 0:36:45,506
只是看待相同问题的一种不同方式

728
00:36:46,406 --> 0:36:48,609
如果这个产品混合了

729
00:36:48,909 --> 0:36:52,479
你的app看待连贯性的方式

730
00:36:52,746 --> 0:36:55,782
由性能来划分

731
00:36:55,849 --> 0:36:58,118
而不是其他特征呢？

732
00:36:58,819 --> 0:37:00,787
你可以通过资源目录来实现这个目的

733
00:36:58,819 --> 0:37:00,787
你可以通过资源目录来实现这个目的

734
00:37:01,455 --> 0:37:04,391
我们所支持的设备

735
00:37:04,458 --> 0:37:06,593
有着很大范围的硬件变化

736
00:37:06,660 --> 0:37:08,161
即使你回退了几个iOS版本

737
00:37:08,228 --> 0:37:12,432
我是说从iPhone 5

738
00:37:12,499 --> 0:37:15,002
这是很大范围的性能变化

739
00:37:15,736 --> 0:37:17,404
如果我们可以利用这点

740
00:37:17,471 --> 0:37:21,141
可以不必限制你的app

741
00:37:21,208 --> 0:37:24,611
来满足对最低性能设备

742
00:37:25,078 --> 0:37:26,380
这就是我们的目标

743
00:37:26,446 --> 0:37:28,248
为了鱼和熊掌可以兼得

744
00:37:28,315 --> 0:37:31,785
你可以通过适应性资源来解决

745
00:37:32,186 --> 0:37:33,620
我会给你们介绍下如何解决

746
00:37:33,687 --> 0:37:34,521
（内存类）

747
00:37:34,588 --> 0:37:38,058
我们要划分性能连贯性的话

748
00:37:38,125 --> 0:37:39,426
第一种是内存类

749
00:37:39,493 --> 0:37:41,628
这可能是最重要的一个

750
00:37:41,695 --> 0:37:44,598
我们有4个内存层级

751
00:37:44,865 --> 0:37:47,067
这对应了不同设备上

752
00:37:47,134 --> 0:37:48,836
已经安装好的内存

753
00:37:48,902 --> 0:37:51,171
这跨越了我们的整个产品线

754
00:37:51,238 --> 0:37:53,874
是什么都没关系

755
00:37:55,609 --> 0:38:00,781
第二个集合访问就是图形类

756
00:37:55,609 --> 0:38:00,781
第二个集合访问就是图形类

757
00:38:00,848 --> 0:38:03,650
这其实反映了两件事

758
00:38:04,017 --> 0:38:07,588
第一个就是

759
00:38:07,654 --> 0:38:09,823
若你是Metal程序员

760
00:38:09,890 --> 0:38:11,525
这个是GPU家族的概念

761
00:38:11,592 --> 0:38:13,427
但它们实际上也与

762
00:38:13,493 --> 0:38:17,764
你设备的处理器版本有关

763
00:38:18,298 --> 0:38:22,636
Metal 1对应的是

764
00:38:22,703 --> 0:38:24,872
而Metal 4对应的是

765
00:38:25,272 --> 0:38:28,709
我们允许你编类以及传送这些资源

766
00:38:28,775 --> 0:38:31,545
到这些特定图形中的每一个类

767
00:38:31,612 --> 0:38:32,846
（图形类）

768
00:38:32,913 --> 0:38:36,183
对它们中的每个来说

769
00:38:36,250 --> 0:38:37,951
有趣的是

770
00:38:38,018 --> 0:38:41,788
你可以将这两个特征组合在一起

771
00:38:41,855 --> 0:38:44,024
来形成一个完整的性能矩阵

772
00:38:44,091 --> 0:38:47,461
你可以对如何

773
00:38:47,528 --> 0:38:49,830
进行最后的校准

774
00:38:49,897 --> 0:38:51,932
（完整性能矩阵）

775
00:38:51,999 --> 0:38:53,333
这是如何实现的呢？

776
00:38:54,368 --> 0:38:58,038
我想通过一个简单的例子

777
00:38:58,105 --> 0:39:00,174
这对于我们理解所做的事情来说

778
00:38:58,105 --> 0:39:00,174
这对于我们理解所做的事情来说

779
00:39:00,240 --> 0:39:02,676
它可以帮助你理解应该如何使用它

780
00:39:03,243 --> 0:39:06,213
在本例中

781
00:39:06,280 --> 0:39:11,151
一个是供低性能设备所用的资源

782
00:39:11,218 --> 0:39:13,187
然后我们提供了两种优化的资源

783
00:39:13,253 --> 0:39:16,657
一个支持使用Metal 3的

784
00:39:16,723 --> 0:39:19,660
一个支持使用Metal 4的

785
00:39:20,561 --> 0:39:24,598
假设我是从

786
00:39:24,665 --> 0:39:27,134
选择的资源

787
00:39:27,634 --> 0:39:30,637
我是以Metal 4的

788
00:39:31,238 --> 0:39:35,175
我找了一下 在4GB内存

789
00:39:36,009 --> 0:39:39,580
接下来我就会降一个内存层级

790
00:39:39,646 --> 0:39:43,116
并且在3GB内存层级进行查找

791
00:39:44,451 --> 0:39:46,920
我在这找到了这个资源

792
00:39:48,088 --> 0:39:49,623
我要选择它

793
00:39:49,690 --> 0:39:51,959
重要的是

794
00:39:52,025 --> 0:39:56,697
我已经在3GB的Metal 3

795
00:39:56,763 --> 0:39:58,131
尽管有一个资源

796
00:39:58,198 --> 0:40:01,134
刚好匹配我的GPU类

797
00:39:58,198 --> 0:40:01,134
刚好匹配我的GPU类

798
00:40:01,502 --> 0:40:06,440
但是因为在我们做图形类之前

799
00:40:06,507 --> 0:40:09,009
我们更喜欢并以内存优先顺序

800
00:40:09,076 --> 0:40:09,977
这非常重要

801
00:40:10,043 --> 0:40:12,946
因为我们确定内存是表现

802
00:40:13,013 --> 0:40:15,582
最重要方式

803
00:40:15,649 --> 0:40:19,486
所以 当我们在通过选择矩阵选择时

804
00:40:21,488 --> 0:40:24,124
这就是它的工作原理

805
00:40:24,858 --> 0:40:28,362
内存实际上代表了

806
00:40:28,695 --> 0:40:31,732
而且是性能的最佳聚合指标

807
00:40:31,798 --> 0:40:34,701
这是一个非常好的选择

808
00:40:34,768 --> 0:40:37,437
更详细的资料

809
00:40:37,504 --> 0:40:38,839
以及占有更多储存空间

810
00:40:38,906 --> 0:40:41,942
当它们在内存中拓展用于渲染时

811
00:40:42,609 --> 0:40:45,746
丰富的用户体验通常

812
00:40:45,812 --> 0:40:47,915
更高质量的图形

813
00:40:47,981 --> 0:40:50,417
因为它记录设备的原始处理能力

814
00:40:50,484 --> 0:40:52,686
包括CPU和GPU

815
00:40:52,753 --> 0:40:54,755
因此它适合处理更复杂的资源

816
00:40:55,455 --> 0:40:58,725
也许 你使用了着色器

817
00:40:58,792 --> 0:41:00,961
某些仅在特定GPU上

818
00:40:58,792 --> 0:41:00,961
某些仅在特定GPU上

819
00:41:01,028 --> 0:41:05,566
或者你放置的资源需要

820
00:41:06,433 --> 0:41:08,535
我想举两个简单的例子

821
00:41:09,203 --> 0:41:11,271
作为思考的重点

822
00:41:11,338 --> 0:41:12,940
（使用性能类）

823
00:41:13,006 --> 0:41:16,443
我想举例介绍下

824
00:41:16,944 --> 0:41:19,880
NSDataAsset是资产目录

825
00:41:19,947 --> 0:41:21,181
但是它非常强大

826
00:41:21,248 --> 0:41:23,851
它主要是提供一个

827
00:41:23,917 --> 0:41:27,154
你可以在资源目录中的任何文件中

828
00:41:27,221 --> 0:41:29,223
放置内容变量

829
00:41:29,790 --> 0:41:30,891
这不一定是一个图像

830
00:41:30,958 --> 0:41:32,125
不一定是一个非常具体的格式

831
00:41:32,192 --> 0:41:33,193
这可以是任何东西

832
00:41:33,527 --> 0:41:37,231
但是你可以将其在app精简中

833
00:41:37,297 --> 0:41:40,934
将任意的数据发送到

834
00:41:41,001 --> 0:41:44,605
例如游戏中的剪切场景视频

835
00:41:45,873 --> 0:41:48,308
你可能会提供一个很好的视频

836
00:41:48,375 --> 0:41:50,978
你可以把它放在

837
00:41:51,945 --> 0:41:54,314
然后你就有了一个

838
00:41:54,381 --> 0:41:55,816
它甚至可能是HDR 谁知道呢？

839
00:41:55,883 --> 0:41:59,219
你可以将视频放在性能范围

840
00:41:59,286 --> 0:42:00,954
的合适象限内

841
00:41:59,286 --> 0:42:00,954
的合适象限内

842
00:42:01,021 --> 0:42:04,591
然后在低端 你可以放置静态图像

843
00:42:04,658 --> 0:42:07,794
或是简单的图像序列 这些图像序列

844
00:42:07,861 --> 0:42:09,997
或过多的资源

845
00:42:10,063 --> 0:42:12,232
你可以为仍然使用旧设备的用户

846
00:42:12,299 --> 0:42:14,535
提供良好且响应迅速的用户体验

847
00:42:16,003 --> 0:42:17,004
这是其中一个例子

848
00:42:17,070 --> 0:42:19,373
另一个更有趣的例子是plist

849
00:42:19,439 --> 0:42:21,241
为何我把plist放入资源目录？

850
00:42:21,308 --> 0:42:24,444
似乎有比资源目录

851
00:42:24,511 --> 0:42:28,615
比如说 当你将它与

852
00:42:28,682 --> 0:42:31,318
你可以考虑使用plist来

853
00:42:32,186 --> 0:42:35,989
并在你的NSDataAsset中

854
00:42:36,056 --> 0:42:40,327
这些参数根据你编入plist的

855
00:42:40,394 --> 0:42:42,095
例如 如果你有

856
00:42:43,130 --> 0:42:45,933
一个渲染人群的app

857
00:42:45,999 --> 0:42:48,902
你可以根据底层硬件的性能

858
00:42:48,969 --> 0:42:50,270
设置人群的大小

859
00:42:50,337 --> 0:42:53,807
你的代码将根据当时运行的设备

860
00:42:53,874 --> 0:42:56,910
自动进行自我调整

861
00:42:57,644 --> 0:43:00,747
这就是有关如何使用

862
00:42:57,644 --> 0:43:00,747
这就是有关如何使用

863
00:43:02,883 --> 0:43:05,452
接下来我想介绍下精灵地图集

864
00:43:06,053 --> 0:43:09,823
精灵地图集是在几年前推出的

865
00:43:10,324 --> 0:43:14,127
用来支持SpriteKit

866
00:43:14,194 --> 0:43:15,195
（精灵地图集）

867
00:43:15,262 --> 0:43:16,096
那么…

868
00:43:16,463 --> 0:43:20,534
我不打算在SpriteKit

869
00:43:20,601 --> 0:43:23,837
我将在常规app的环境中讨论它们

870
00:43:25,372 --> 0:43:28,509
它们有一些属性

871
00:43:28,575 --> 0:43:30,978
跟Will介绍过的

872
00:43:31,044 --> 0:43:33,480
你要采集精灵地图集中的

873
00:43:33,547 --> 0:43:35,015
并将它们打包成一个单元

874
00:43:35,082 --> 0:43:36,717
它们会立即被加载

875
00:43:36,783 --> 0:43:40,320
然后包含在该地图集中的

876
00:43:40,387 --> 0:43:44,391
都只是轻量级引用地图集中的位置

877
00:43:45,425 --> 0:43:46,360
这很棒

878
00:43:48,295 --> 0:43:49,463
但关键问题所在就是

879
00:43:49,530 --> 0:43:52,366
你并不需要

880
00:43:52,432 --> 0:43:54,334
你可以就将其作为分组机制使用

881
00:43:54,401 --> 0:43:56,270
因为Sprite地图集与

882
00:43:56,336 --> 0:43:59,339
你可以控制分组

883
00:43:59,640 --> 0:44:01,074
并且可以为其分配名称

884
00:43:59,640 --> 0:44:01,074
并且可以为其分配名称

885
00:44:01,141 --> 0:44:02,042
你可以处理它

886
00:44:02,109 --> 0:44:05,345
你可以控制它们

887
00:44:06,146 --> 0:44:08,782
不过你还是可以通过使用标准化的

888
00:44:08,849 --> 0:44:12,553
来访问里面的图像

889
00:44:12,619 --> 0:44:13,854
还有它里面的名称

890
00:44:13,921 --> 0:44:14,755
另外

891
00:44:15,289 --> 0:44:17,858
还有一种使用SpriteKit

892
00:44:17,925 --> 0:44:20,327
即使你构建的不是

893
00:44:20,627 --> 0:44:21,628
但是通过利用

894
00:44:21,695 --> 0:44:24,998
SKTextureAtlas

895
00:44:25,065 --> 0:44:28,068
如果你需要载入大量的图片

896
00:44:28,135 --> 0:44:31,939
需要很快的加载

897
00:44:32,005 --> 0:44:33,340
那么这个API

898
00:44:33,407 --> 0:44:36,176
会预先加载或从磁盘加载并解码

899
00:44:36,243 --> 0:44:38,011
在内存中做好准备

900
00:44:38,712 --> 0:44:41,882
并为一个已命名的地图集

901
00:44:42,382 --> 0:44:44,751
异步回调一个

902
00:44:44,818 --> 0:44:45,752
这很棒

903
00:44:46,386 --> 0:44:47,454
但我要提醒你

904
00:44:47,521 --> 0:44:49,756
不要随意使用这个API

905
00:44:50,657 --> 0:44:53,227
因为它会完全按照它所说的去做

906
00:44:53,827 --> 0:44:56,930
这意味着它可能会消耗大量的

907
00:44:56,997 --> 0:45:00,901
I/O和内存来加载所有这些图像

908
00:44:56,997 --> 0:45:00,901
I/O和内存来加载所有这些图像

909
00:45:00,968 --> 0:45:03,804
所以请确保你会马上使用它们

910
00:45:03,871 --> 0:45:04,905
这就是正确的选择

911
00:45:05,305 --> 0:45:07,374
否则就会有没用的东西

912
00:45:10,077 --> 0:45:13,447
精灵地图集的另一个强大之处在于

913
00:45:13,514 --> 0:45:18,285
其中的任何图像都具有所有

914
00:45:18,352 --> 0:45:21,288
在代码资源目录中

915
00:45:21,355 --> 0:45:23,090
包括所有的目录功能

916
00:45:23,624 --> 0:45:25,158
所有压缩设置

917
00:45:25,459 --> 0:45:27,694
以及所有的app精简功能

918
00:45:27,761 --> 0:45:31,098
我们会注意自动

919
00:45:31,164 --> 0:45:32,065
所有图像

920
00:45:32,666 --> 0:45:34,701
按照像素格式

921
00:45:34,768 --> 0:45:37,337
不同的设备特征

922
00:45:37,404 --> 0:45:39,173
并确保所有内容都得到热处理

923
00:45:39,239 --> 0:45:40,307
然后适当地进行精简

924
00:45:40,374 --> 0:45:44,144
以便数据以正确的方式

925
00:45:46,980 --> 0:45:49,416
这些是关于部署的一些有趣的细节

926
00:45:49,483 --> 0:45:50,984
我们在这项工作中的最后阶段

927
00:45:51,385 --> 0:45:53,320
因此 我想提醒你

928
00:45:53,387 --> 0:45:54,922
优化app资产的重要事项

929
00:45:54,988 --> 0:45:58,458
首先 我认为Xcode资源目录

930
00:45:58,525 --> 0:46:01,828
确实是管理你的app中

931
00:45:58,525 --> 0:46:01,828
确实是管理你的app中

932
00:46:01,895 --> 0:46:06,066
今年你只需使用我们新的压缩算法

933
00:46:06,133 --> 0:46:08,402
就可以使占用的

934
00:46:08,735 --> 0:46:11,271
无论你采用何种部署目标

935
00:46:11,338 --> 0:46:14,474
你在iOS 12平台上的用户

936
00:46:14,541 --> 0:46:16,743
这要归功于app精简的改进

937
00:46:16,810 --> 0:46:20,113
现在可以优化最新的操作系统

938
00:46:20,714 --> 0:46:23,784
而且 我们拥有大量的目录功能

939
00:46:23,851 --> 0:46:26,086
你可以使用这些功能

940
00:46:26,153 --> 0:46:28,222
来适应用户使用的设备

941
00:46:29,823 --> 0:46:34,261
要了解相关的更多信息

942
00:46:34,328 --> 0:46:35,696
（更多内容）

943
00:46:35,762 --> 0:46:37,264
希望你们今天过得愉快

944
00:46:37,664 --> 0:46:38,565
谢谢大家
