1
00:00:08,516 --> 0:00:15,500
[ 音乐 ]

2
00:00:25,516 --> 0:00:29,596
[ 掌声 ]

3
00:00:30,096 --> 0:00:31,336
&gt;&gt; 大家好 

4
00:00:31,336 --> 0:00:31,906
早上好

5
00:00:31,906 --> 0:00:32,896
我很高兴

6
00:00:32,896 --> 0:00:33,536
你们今天早上能来

7
00:00:34,026 --> 0:00:35,316
我叫 David Owens

8
00:00:35,446 --> 0:00:37,346
我是 Xcode 团队的一名工程师

9
00:00:37,706 --> 0:00:39,566
今天 我将和 Swift 团队的

10
00:00:39,566 --> 0:00:41,026
工程师 我的同事 Jordan Rose

11
00:00:41,026 --> 0:00:42,556
一起和你们讲讲

12
00:00:42,556 --> 0:00:44,406
如何在 Xcode 中

13
00:00:44,406 --> 0:00:46,136
构建的更快

14
00:00:47,056 --> 0:00:48,626
现在 基于你的项目

15
00:00:48,686 --> 0:00:49,826
它们的配置 

16
00:00:49,826 --> 0:00:51,516
它们的复杂性

17
00:00:51,516 --> 0:00:53,646
有很多机会可以让你对其

18
00:00:53,646 --> 0:00:55,396
进行改进

19
00:00:55,536 --> 0:00:57,496
在某些情况下

20
00:00:57,496 --> 0:00:58,936
可以显著地提高你的构建

21
00:00:58,936 --> 0:00:59,736
运行情况

22
00:01:00,996 --> 0:01:02,696
今天我们讨论的是

23
00:01:02,696 --> 0:01:04,036
在 Xcode 中构建更快

24
00:01:04,646 --> 0:01:05,856
我们会从两个不同的角度

25
00:01:05,856 --> 0:01:06,786
来考虑

26
00:01:07,356 --> 0:01:10,166
第一个就是

27
00:01:10,166 --> 0:01:12,636
提升你的整体构建效率

28
00:01:12,636 --> 0:01:15,356
第二个则是

29
00:01:15,356 --> 0:01:16,696
减少你在构建中需要

30
00:01:16,696 --> 0:01:18,306
做的工作

31
00:01:18,306 --> 0:01:19,656
尤其是你的

32
00:01:19,656 --> 0:01:20,116
增量式构建

33
00:01:21,756 --> 0:01:23,556
现在 我将为你们介绍一些

34
00:01:23,556 --> 0:01:25,326
项目级对象 

35
00:01:25,326 --> 0:01:26,626
包括如何并行你的

36
00:01:26,696 --> 0:01:27,296
构建过程

37
00:01:27,846 --> 0:01:29,146
如何宣告并配置你的

38
00:01:29,146 --> 0:01:30,506
运行的脚本阶段

39
00:01:31,256 --> 0:01:32,306
我还会给你们介绍一些

40
00:01:32,606 --> 0:01:34,596
Xcode 10 中的关于测量你的

41
00:01:34,916 --> 0:01:38,386
构建时间的新性能

42
00:01:38,566 --> 0:01:39,446
现在 Jordan 将给我们介绍

43
00:01:39,446 --> 0:01:40,556
一些我们可以

44
00:01:40,626 --> 0:01:41,716
为我们的项目带来的

45
00:01:41,716 --> 0:01:43,056
源级的提升

46
00:01:43,516 --> 0:01:44,636
包括使用 Swift 来

47
00:01:44,636 --> 0:01:45,756
理解我们的依赖性

48
00:01:46,486 --> 0:01:48,486
在 Swift 中处理复杂的表达式

49
00:01:49,436 --> 0:01:50,416
以及如何将

50
00:01:50,416 --> 0:01:52,436
Objective-C 限制到 Swift 界面

51
00:01:54,016 --> 0:01:55,126
现在让我们来讨论一下

52
00:01:55,126 --> 0:01:56,056
并行你的构建

53
00:01:56,676 --> 0:01:58,816
Xcode 通过使用目标

54
00:01:58,816 --> 0:02:00,736
来配置你的项目

55
00:02:01,606 --> 0:02:04,016
目标指定了你想要构建的

56
00:02:04,016 --> 0:02:05,566
产品或者输出

57
00:02:06,226 --> 0:02:07,916
有一些例子是 iOS App

58
00:02:08,756 --> 0:02:10,546
框架和单位测试

59
00:02:11,276 --> 0:02:12,776
还有另一个信息

60
00:02:12,776 --> 0:02:13,846
那就是

61
00:02:13,846 --> 0:02:15,696
目标之间的依赖性

62
00:02:16,226 --> 0:02:17,886
Xcode 为定义我们的依赖性

63
00:02:18,326 --> 0:02:19,526
提供了两种方法

64
00:02:19,816 --> 0:02:21,556
有一种很清楚的方法

65
00:02:21,556 --> 0:02:22,396
就是通过

66
00:02:22,396 --> 0:02:23,436
目标依赖性阶段

67
00:02:24,046 --> 0:02:25,276
还有一种隐含的方法

68
00:02:25,336 --> 0:02:26,586
就是通过函数库阶段的

69
00:02:26,586 --> 0:02:28,526
连接的二进制

70
00:02:28,926 --> 0:02:29,806
一会我们会用一点时间

71
00:02:29,806 --> 0:02:32,696
深入地了解这些

72
00:02:33,426 --> 0:02:34,546
现在 我想用

73
00:02:34,546 --> 0:02:35,956
一个样本项目来

74
00:02:35,956 --> 0:02:36,996
开始我们的讨论

75
00:02:37,686 --> 0:02:38,656
我们将看到

76
00:02:38,656 --> 0:02:40,686
这个项目的依赖性图表

77
00:02:41,706 --> 0:02:43,736
现在 一个依赖性图表

78
00:02:43,796 --> 0:02:46,006
只是一个包含所有目标的名单

79
00:02:46,146 --> 0:02:47,206
在这个例子中

80
00:02:47,206 --> 0:02:48,896
我们将要构建五个目标

81
00:02:50,226 --> 0:02:51,336
在这些目标中间

82
00:02:51,336 --> 0:02:53,466
有依赖性信息

83
00:02:54,376 --> 0:02:55,966
基于这两个信息

84
00:02:55,966 --> 0:02:58,696
Xcode 可以得到我们的

85
00:02:58,696 --> 0:02:59,226
构建次序

86
00:02:59,226 --> 0:03:01,696
现在 让我们看看

87
00:03:01,696 --> 0:03:02,966
它在时间表中是

88
00:03:02,966 --> 0:03:03,246
什么样的

89
00:03:03,306 --> 0:03:08,086
正如我们所见 

90
00:03:08,086 --> 0:03:09,486
每个目标都按顺序构建得

91
00:03:09,486 --> 0:03:10,876
很有秩序

92
00:03:11,396 --> 0:03:12,796
它们都需要等到之前的

93
00:03:12,796 --> 0:03:14,386
目标完成构建

94
00:03:14,786 --> 0:03:16,366
就其本身而言 构建

95
00:03:16,366 --> 0:03:17,946
时间线并没有什么错

96
00:03:18,356 --> 0:03:20,436
但是这代表了对潜在的

97
00:03:20,436 --> 0:03:22,026
硬件资源应用的浪费

98
00:03:22,376 --> 0:03:23,146
尤其是在你有一个

99
00:03:23,146 --> 0:03:24,326
如 iMac Pro 的

100
00:03:24,326 --> 0:03:25,846
多核或微核机器

101
00:03:26,726 --> 0:03:28,356
这对于作为开发者的你来说

102
00:03:28,356 --> 0:03:29,616
就是一种时间的浪费

103
00:03:30,346 --> 0:03:32,416
因此我们要采用

104
00:03:32,416 --> 0:03:34,466
另一种方法

105
00:03:37,476 --> 0:03:37,576
看起来大概是这样

106
00:03:37,786 --> 0:03:38,846
现在 有几件事

107
00:03:38,846 --> 0:03:39,876
或者很少的几件事

108
00:03:39,876 --> 0:03:40,456
我想要提醒大家

109
00:03:40,926 --> 0:03:42,726
首先 我们在构建项目中

110
00:03:42,726 --> 0:03:43,936
所做的工作量

111
00:03:43,936 --> 0:03:45,286
其实并没有变化

112
00:03:46,696 --> 0:03:49,456
但是用来构建的时间 的确减少了

113
00:03:50,126 --> 0:03:51,396
在这种情况下

114
00:03:51,396 --> 0:03:53,486
时间其实大幅度减少了

115
00:03:53,946 --> 0:03:56,196
我们可以通过

116
00:03:56,196 --> 0:03:59,466
更好地利用可用的硬件

117
00:03:59,466 --> 0:04:02,736
来减少构建的时间

118
00:04:02,946 --> 0:04:04,736
如果并行

119
00:04:04,736 --> 0:04:07,366
或者说并行是这么好的一件事

120
00:04:07,366 --> 0:04:09,036
为什么我们不创建一个

121
00:04:09,036 --> 0:04:10,326
和这个很像的构建图表

122
00:04:10,536 --> 0:04:11,796
我们只需要在我们的构建时间表中

123
00:04:11,796 --> 0:04:13,016
从头开始构建

124
00:04:14,156 --> 0:04:16,276
在最好的情况下

125
00:04:16,276 --> 0:04:17,516
你们将遇到确定性的

126
00:04:17,856 --> 0:04:18,876
构建错误

127
00:04:19,096 --> 0:04:20,596
这是因为依赖信息

128
00:04:20,596 --> 0:04:22,076
其实是你们

129
00:04:22,076 --> 0:04:24,136
项目配置的重要部分

130
00:04:24,796 --> 0:04:25,916
当它像这样被设置时

131
00:04:26,636 --> 0:04:28,306
你们将试着在你们构建

132
00:04:28,306 --> 0:04:29,956
依赖性之前

133
00:04:29,956 --> 0:04:31,196
去构建你们的游戏目标

134
00:04:31,456 --> 0:04:32,816
这并不是一个好的状态

135
00:04:34,176 --> 0:04:35,216
所以我们如何做到这样

136
00:04:35,876 --> 0:04:37,906
我们如何从漫长的

137
00:04:37,906 --> 0:04:39,896
系列化的构建时间线

138
00:04:39,896 --> 0:04:43,486
转换成并行的构建时间

139
00:04:44,356 --> 0:04:45,586
首先 你需要确保

140
00:04:45,586 --> 0:04:48,206
Xcode 被设置并配置成

141
00:04:48,206 --> 0:04:49,446
允许我们的目标

142
00:04:49,446 --> 0:04:51,076
被平行构建

143
00:04:51,126 --> 0:04:52,516
我们通过 Scheme Editor (方案编辑器）

144
00:04:52,516 --> 0:04:53,056
完成这个指令

145
00:04:53,796 --> 0:04:54,876
你可以打开 Scheme Chooser（方案选择器）

146
00:04:54,876 --> 0:04:56,226
选择 Edit Scheme (编辑方案）

147
00:04:57,176 --> 0:04:58,366
然后来到 Scheme Editor

148
00:04:58,836 --> 0:05:00,696
明确来说 你需要

149
00:05:00,696 --> 0:05:01,826
看一下 Build Action (构建行为）

150
00:05:02,936 --> 0:05:05,046
在这里是 Build Options (构建选项）

151
00:05:05,366 --> 0:05:06,866
这里有两个已经列出来的

152
00:05:07,196 --> 0:05:08,866
第一个是 Parallelize Build (并行构建选项）

153
00:05:08,986 --> 0:05:10,916
第二个是 Find Implicit Dependencies

154
00:05:10,916 --> 0:05:11,656
（寻找隐含依赖性）

155
00:05:12,426 --> 0:05:14,146
你可能想检查 Parallelize Build

156
00:05:14,706 --> 0:05:16,176
这会允许 Xcode 通过

157
00:05:16,176 --> 0:05:17,656
你的目标来使用

158
00:05:17,656 --> 0:05:19,296
依赖性信息

159
00:05:19,296 --> 0:05:20,846
这样就可以让其尝试着并行

160
00:05:20,846 --> 0:05:21,376
构建你的目标

161
00:05:21,956 --> 0:05:24,646
让我们来看看

162
00:05:24,936 --> 0:05:25,996
如何在 Xcode 内

163
00:05:25,996 --> 0:05:27,116
配置你的依赖性

164
00:05:28,286 --> 0:05:29,406
这是通过 Build Phase Editor (构建阶段

165
00:05:29,406 --> 0:05:30,036
编辑器）实现的

166
00:05:30,586 --> 0:05:31,496
你可以通过你的 Project Navigator

167
00:05:31,496 --> 0:05:33,616
 (项目导航器） 选择你的项目

168
00:05:33,616 --> 0:05:35,566
然后来到 Build 

169
00:05:35,566 --> 0:05:36,116
Phase Editor

170
00:05:36,636 --> 0:05:37,806
在这个例子中我们

171
00:05:37,806 --> 0:05:39,556
来看下 Game Target (游戏目标）或者 Game

172
00:05:39,556 --> 0:05:39,916
Project (游戏项目）

173
00:05:40,326 --> 0:05:43,816
接下来点击 Build Phases (构建阶段）

174
00:05:44,916 --> 0:05:46,036
我们来看一下

175
00:05:46,036 --> 0:05:46,626
Game Target

176
00:05:46,866 --> 0:05:47,946
这是针对我们的 Game Target 的

177
00:05:47,946 --> 0:05:48,806
Build Phase Editor 

178
00:05:48,886 --> 0:05:50,156
我们将看看它的依赖性

179
00:05:50,156 --> 0:05:51,536
是如何配置的

180
00:05:52,056 --> 0:05:52,826
首先我希望 你们能注意一下 

181
00:05:52,826 --> 0:05:54,916
Link Binary with Libraries phase

182
00:05:55,186 --> 0:05:57,166
（带函数库阶段的连接二进制）

183
00:05:57,836 --> 0:05:59,446
现在是你定义

184
00:05:59,446 --> 0:06:00,746
所有你想要连接到你目标的

185
00:06:00,746 --> 0:06:03,566
项目的构建过程阶段

186
00:06:04,676 --> 0:06:06,046
这种情况下我有两个项目

187
00:06:06,046 --> 0:06:08,346
分别是物理和实用性

188
00:06:08,716 --> 0:06:11,526
现在这些是在我们的项目中

189
00:06:11,526 --> 0:06:12,856
和我们的工作环境中的目标

190
00:06:13,086 --> 0:06:14,696
Xcode 可以在这些目标中

191
00:06:14,696 --> 0:06:16,716
创建一个隐含的依赖性

192
00:06:17,766 --> 0:06:19,356
如果你在使用如

193
00:06:19,356 --> 0:06:22,156
自动连接或

194
00:06:22,216 --> 0:06:23,756
其他的 LD 构建标志构建设置

195
00:06:23,786 --> 0:06:25,416
这些都不会

196
00:06:25,416 --> 0:06:27,846
暗中地在你这里生效

197
00:06:28,166 --> 0:06:29,236
你要么在这个构建中

198
00:06:29,236 --> 0:06:30,636
或者在目标依赖性构建过程中

199
00:06:30,686 --> 0:06:34,996
生成一个明确的依赖性

200
00:06:35,396 --> 0:06:37,806
我们可以看到在这里

201
00:06:37,806 --> 0:06:38,686
还有一个名为 Shaders (渲染）的

202
00:06:38,686 --> 0:06:39,206
另一个项目

203
00:06:39,616 --> 0:06:42,106
Shaders 并不在连接时候

204
00:06:42,106 --> 0:06:43,926
使用 而是在

205
00:06:43,926 --> 0:06:45,776
我们现有的目标中

206
00:06:45,776 --> 0:06:47,456
被另一个构建过程使用

207
00:06:48,096 --> 0:06:49,316
很重要的一件事就是

208
00:06:49,316 --> 0:06:50,926
我们让 Xcode 知道

209
00:06:50,926 --> 0:06:52,256
这是一个依赖性而且我们需要

210
00:06:52,256 --> 0:06:54,506
等 Shaders 完成编辑

211
00:06:54,566 --> 0:06:57,886
同时 在我们构建现有的目标前

212
00:06:57,886 --> 0:06:58,876
就进行构建

213
00:06:59,406 --> 0:07:02,336
现在 这个目标实际上

214
00:07:02,336 --> 0:07:03,256
存在于不同的项目

215
00:07:03,846 --> 0:07:05,626
如果你想要

216
00:07:05,626 --> 0:07:06,826
对该项目做个参考

217
00:07:06,826 --> 0:07:08,376
你可以拖拽如

218
00:07:08,376 --> 0:07:10,266
你目前正在处理的项目的孩子一样

219
00:07:10,266 --> 0:07:11,526
拖拽该项目

220
00:07:11,526 --> 0:07:13,776
我想再介绍一下

221
00:07:13,776 --> 0:07:15,276
我们项目其余的依赖性

222
00:07:16,576 --> 0:07:17,916
我们的 Shaders 目标

223
00:07:17,916 --> 0:07:19,196
对于我们的实用性目标

224
00:07:19,196 --> 0:07:19,506
有一个依赖性

225
00:07:20,886 --> 0:07:22,196
我们的实用性 目标

226
00:07:22,196 --> 0:07:23,806
在我们的物理目标上

227
00:07:23,806 --> 0:07:24,106
有一个依赖性

228
00:07:25,146 --> 0:07:27,206
最后 我们的测试（Tests)

229
00:07:27,206 --> 0:07:30,516
对我们的 Shaders 和实用性目标

230
00:07:30,516 --> 0:07:31,676
有一个依赖性

231
00:07:32,616 --> 0:07:33,206
现在我们对我们项目的

232
00:07:33,206 --> 0:07:34,296
配置有了

233
00:07:34,296 --> 0:07:35,806
一定的了解

234
00:07:35,806 --> 0:07:37,266
我们来看看

235
00:07:37,266 --> 0:07:38,996
将这个序列化的构建过程

236
00:07:38,996 --> 0:07:41,106
变成并行的

237
00:07:41,446 --> 0:07:43,556
必要步骤

238
00:07:44,136 --> 0:07:45,286
首先我们要看一看

239
00:07:45,286 --> 0:07:46,746
我们的测试依赖性

240
00:07:48,876 --> 0:07:50,566
现在 我将依赖性

241
00:07:50,566 --> 0:07:51,556
分成了三种

242
00:07:51,556 --> 0:07:52,366
不同类型

243
00:07:52,366 --> 0:07:53,896
我想要谈论的依赖性

244
00:07:54,466 --> 0:07:55,866
第一个依赖性

245
00:07:55,866 --> 0:07:57,366
我称之为 “什么都做的”

246
00:07:57,366 --> 0:07:58,646
依赖性

247
00:07:59,316 --> 0:08:00,566
有一点很清楚的就是

248
00:08:00,566 --> 0:08:01,946
这个测试

249
00:08:02,036 --> 0:08:03,686
测试了很多成分

250
00:08:04,056 --> 0:08:05,096
它测试了 Game

251
00:08:05,516 --> 0:08:06,596
还测试了 Shaders

252
00:08:07,236 --> 0:08:08,606
同时还测试了 Utilities

253
00:08:10,056 --> 0:08:11,866
在这个例子中

254
00:08:11,866 --> 0:08:13,426
最好将我们的测试分解

255
00:08:13,426 --> 0:08:14,366
这样它就能测试

256
00:08:14,366 --> 0:08:15,356
每个单独的成分

257
00:08:15,356 --> 0:08:17,586
我们来试试这样操作会怎样

258
00:08:17,586 --> 0:08:18,686
我们将介绍

259
00:08:18,686 --> 0:08:21,766
构建过程中的并行性

260
00:08:23,306 --> 0:08:25,246
我们在三个依赖性中都被构建了的

261
00:08:25,246 --> 0:08:26,676
测试目标

262
00:08:26,736 --> 0:08:27,926
现在可以只构建

263
00:08:27,926 --> 0:08:29,466
在 Game 测试中寻找的部分

264
00:08:30,436 --> 0:08:31,896
我们的 Shaders 测试和

265
00:08:31,896 --> 0:08:33,816
Utilities 测试可以被移去

266
00:08:33,816 --> 0:08:34,996
与我们其他的目标

267
00:08:34,996 --> 0:08:35,776
并行构建

268
00:08:36,066 --> 0:08:37,236
当它们各自的成分 

269
00:08:37,236 --> 0:08:38,396
Shaders 和 Utilities

270
00:08:38,396 --> 0:08:40,456
完成时即可进行构建

271
00:08:42,286 --> 0:08:44,626
下一个我想要看的

272
00:08:44,626 --> 0:08:46,696
依赖性类型就是

273
00:08:46,696 --> 0:08:48,526
我称之为“爱管闲事的邻居”的

274
00:08:48,526 --> 0:08:49,126
依赖性

275
00:08:49,706 --> 0:08:51,596
这是需要存在的一种

276
00:08:51,596 --> 0:08:53,426
依赖性

277
00:08:53,586 --> 0:08:54,806
这个要考虑另一个目标

278
00:08:55,136 --> 0:08:57,226
但是它只需要那个目标的一点

279
00:08:57,946 --> 0:08:59,276
不过它将获得

280
00:08:59,276 --> 0:09:00,426
在那个目标中的一切

281
00:09:01,226 --> 0:09:02,386
如果我们看一下我们的游戏

282
00:09:02,806 --> 0:09:04,506
它对 Physics Shaders 和 Utilities

283
00:09:04,676 --> 0:09:05,696
有一个依赖性

284
00:09:06,046 --> 0:09:06,906
这其实没问题

285
00:09:08,196 --> 0:09:09,936
值得怀疑的是

286
00:09:09,936 --> 0:09:11,306
在 Shaders 目标和 Utilities 目标

287
00:09:11,306 --> 0:09:13,026
之间的依赖性

288
00:09:13,786 --> 0:09:15,436
现在 我们的 Shaders目标

289
00:09:15,436 --> 0:09:16,936
产生了一个元函数库

290
00:09:16,936 --> 0:09:18,556
它本质上来说是一群

291
00:09:18,556 --> 0:09:19,596
将在我们的显示卡上 

292
00:09:19,596 --> 0:09:20,256
运行的 GPU 代码 

293
00:09:21,376 --> 0:09:23,286
我们的 Utilities 目标

294
00:09:23,286 --> 0:09:24,696
生成的则是一个正常的框架

295
00:09:24,696 --> 0:09:25,666
也就是 CPU 代码

296
00:09:25,936 --> 0:09:26,906
所以已经有一些

297
00:09:26,906 --> 0:09:28,946
疑似依赖性了

298
00:09:29,506 --> 0:09:30,926
当我们深入挖掘时

299
00:09:30,926 --> 0:09:32,796
我们会发现 Utilities 目标

300
00:09:32,796 --> 0:09:34,466
实际上有一个会生成

301
00:09:34,466 --> 0:09:36,316
被两个目标使用的信息

302
00:09:36,316 --> 0:09:37,566
的构建过程

303
00:09:37,826 --> 0:09:38,726
这样很好

304
00:09:39,276 --> 0:09:40,466
只不过 Shaders

305
00:09:40,466 --> 0:09:42,016
不再需要从 Utilities 目标中

306
00:09:42,016 --> 0:09:42,796
获得任何其他事物

307
00:09:43,306 --> 0:09:47,356
所以最好将其转入其目标

308
00:09:48,226 --> 0:09:49,666
我们会看到

309
00:09:49,666 --> 0:09:50,866
这个小小的增量改变

310
00:09:50,866 --> 0:09:52,196
其实对我们整个的

311
00:09:52,196 --> 0:09:53,666
构建时间线有着

312
00:09:53,666 --> 0:09:54,746
巨大的影响

313
00:09:56,826 --> 0:09:58,446
所以刚刚移入的

314
00:09:58,446 --> 0:09:59,896
新的绿色框是我们新的代码目标

315
00:10:00,186 --> 0:10:01,476
现在我们可以缩小我们的实用性目标

316
00:10:01,476 --> 0:10:03,426
因为我们将其

317
00:10:03,426 --> 0:10:05,346
移入到 Code Gen (自动生产安全程式码)

318
00:10:06,076 --> 0:10:07,426
因为 Code Gen 没有其他

319
00:10:07,426 --> 0:10:09,336
依赖性 它可以移动到

320
00:10:09,336 --> 0:10:11,176
我们构建过程的前端

321
00:10:11,506 --> 0:10:13,056
它还可以与我们的 Physics 目标

322
00:10:13,346 --> 0:10:14,516
也就是底端的红框

323
00:10:14,516 --> 0:10:15,686
一起并行构建

324
00:10:17,146 --> 0:10:18,756
最后 因为 Shaders 不再

325
00:10:18,756 --> 0:10:20,436
依赖于 Utilities

326
00:10:20,436 --> 0:10:21,616
它不需要等待

327
00:10:21,616 --> 0:10:25,396
Utilities 和 Physics 目标的构建

328
00:10:25,686 --> 0:10:26,896
与此相反 一旦 Code Gen 目标

329
00:10:26,896 --> 0:10:30,566
完成后它就能被构建

330
00:10:30,766 --> 0:10:31,986
最后我想要和大家介绍的

331
00:10:31,986 --> 0:10:33,476
依赖性我称之为

332
00:10:33,476 --> 0:10:35,336
“被遗忘的”

333
00:10:35,826 --> 0:10:37,906
在我们产品或

334
00:10:37,906 --> 0:10:40,376
代码的进化或生命周期中

335
00:10:40,376 --> 0:10:42,956
我们需要移动代码

336
00:10:42,956 --> 0:10:44,106
并删除事情

337
00:10:44,106 --> 0:10:45,356
我们得到的 仿佛是无作用程序代码

338
00:10:45,766 --> 0:10:47,056
我们的依赖性

339
00:10:47,056 --> 0:10:48,326
也会发生这样的事情

340
00:10:48,706 --> 0:10:49,816
有时候我们只是忘记

341
00:10:49,816 --> 0:10:50,376
清理它们

342
00:10:51,386 --> 0:10:52,506
在这些情况中

343
00:10:52,926 --> 0:10:54,306
移除依赖性

344
00:10:54,306 --> 0:10:54,976
是比较安全的

345
00:10:56,456 --> 0:10:58,276
最后一个变化将通过

346
00:10:58,276 --> 0:11:00,396
允许 Utilities 目标

347
00:11:00,396 --> 0:11:03,156
在 Code Gen 目标之后立马搭建

348
00:11:03,156 --> 0:11:04,716
而不需要等待

349
00:11:04,716 --> 0:11:06,146
Physics 目标完成

350
00:11:06,146 --> 0:11:11,156
来加强或构建图

351
00:11:11,346 --> 0:11:13,746
早前在 Xcode 中

352
00:11:13,746 --> 0:11:15,046
当你构建对其他目标

353
00:11:15,046 --> 0:11:16,396
有依赖性的目标时

354
00:11:16,396 --> 0:11:18,326
你必须要等待依赖的目标

355
00:11:18,326 --> 0:11:19,646
完成它的整体

356
00:11:19,646 --> 0:11:21,236
构建过程

357
00:11:21,756 --> 0:11:23,096
在 Xcode 10 中我们有

358
00:11:23,096 --> 0:11:24,916
一个新性能 

359
00:11:24,916 --> 0:11:27,046
可以让我们为你的构建

360
00:11:27,046 --> 0:11:28,086
引入一些并行

361
00:11:28,596 --> 0:11:32,226
一旦构建过程

362
00:11:32,226 --> 0:11:34,626
与适合我们编辑的依赖性

363
00:11:34,626 --> 0:11:36,596
完成了 我们就

364
00:11:36,596 --> 0:11:38,666
可以开始

365
00:11:38,706 --> 0:11:40,636
编辑你的目标了

366
00:11:41,696 --> 0:11:42,926
像连接之类的事情

367
00:11:42,926 --> 0:11:43,746
可以并行完成

368
00:11:45,936 --> 0:11:47,486
现在如果你运行了脚本阶段

369
00:11:47,486 --> 0:11:49,266
这就是你的目标

370
00:11:49,316 --> 0:11:50,896
在可以利用这些

371
00:11:50,996 --> 0:11:53,216
新的并行性之前

372
00:11:53,216 --> 0:11:54,796
为了有秩序的

373
00:11:54,796 --> 0:11:56,436
完成而需要

374
00:11:56,806 --> 0:11:58,886
等待的众多构建过程之一

375
00:11:58,956 --> 0:12:01,976
让我们来讨论一下 运行脚本过程

376
00:12:02,776 --> 0:12:04,116
运行脚本过程允许你

377
00:12:04,116 --> 0:12:05,636
根据你的需求来

378
00:12:05,636 --> 0:12:06,496
自定义你的构建过程

379
00:12:07,066 --> 0:12:08,436
这个弹性也给

380
00:12:08,826 --> 0:12:10,436
作为开发者的你

381
00:12:10,436 --> 0:12:11,906
带来了一些责任

382
00:12:12,316 --> 0:12:13,206
所以我们想要带大家

383
00:12:13,206 --> 0:12:14,266
看一下配置过程

384
00:12:14,266 --> 0:12:15,856
同时确保你已经

385
00:12:15,856 --> 0:12:17,196
设定好了你的脚本过程

386
00:12:17,196 --> 0:12:18,866
同时已经配置好

387
00:12:18,866 --> 0:12:19,856
这样你的构建才能运行

388
00:12:22,116 --> 0:12:24,786
这个是你的脚本过程编辑器

389
00:12:25,226 --> 0:12:26,566
它也可以在你的构建过程

390
00:12:26,566 --> 0:12:27,356
编辑器中被发现

391
00:12:27,356 --> 0:12:28,766
现在我想要

392
00:12:28,766 --> 0:12:31,406
让你们注意一下第一个

393
00:12:31,696 --> 0:12:32,176
脚本主体

394
00:12:32,786 --> 0:12:33,916
你可以把你整体的

395
00:12:33,916 --> 0:12:34,916
脚本内容放在这里

396
00:12:34,916 --> 0:12:36,176
或者你可以像我刚刚那样做

397
00:12:36,176 --> 0:12:37,456
并参考在你项目中的

398
00:12:37,456 --> 0:12:38,286
另一个脚本

399
00:12:39,666 --> 0:12:40,876
现在 在你运行的脚本过程的

400
00:12:40,876 --> 0:12:42,806
整体中 有一整套

401
00:12:42,806 --> 0:12:43,996
对你有效的

402
00:12:43,996 --> 0:12:44,746
构建设置

403
00:12:44,906 --> 0:12:45,926
我现在在利用这些中的

404
00:12:45,926 --> 0:12:47,746
一个 即源组

405
00:12:48,956 --> 0:12:50,506
在这种情况下你的

406
00:12:50,506 --> 0:12:52,646
产品工作时就不需要

407
00:12:52,646 --> 0:12:54,336
提供绝对路径

408
00:12:54,336 --> 0:12:55,956
或尝试做一些相关的

409
00:12:55,956 --> 0:12:56,116
路径侵入

410
00:12:57,436 --> 0:13:00,136
第二个部分是你输入文件

411
00:13:00,836 --> 0:13:02,286
这对于你的

412
00:13:02,286 --> 0:13:03,536
运行脚本过程非常重要

413
00:13:03,896 --> 0:13:05,356
这也是 Xcode 构建系统

414
00:13:05,356 --> 0:13:07,126
用来决定

415
00:13:07,126 --> 0:13:08,386
你的运行脚本是否能

416
00:13:08,386 --> 0:13:09,606
成功运行的

417
00:13:09,606 --> 0:13:12,146
关键信息

418
00:13:12,146 --> 0:13:13,946
这应该包含你运行脚本过程的

419
00:13:13,946 --> 0:13:15,986
所有文件 

420
00:13:16,026 --> 0:13:17,426
脚本内容其实应该在这个过程中

421
00:13:17,426 --> 0:13:19,646
被阅读或者被观看

422
00:13:21,096 --> 0:13:23,306
现在 你们中的一些人可能

423
00:13:23,876 --> 0:13:25,676
在你们的运行脚本过程中 有很多输入

424
00:13:25,816 --> 0:13:27,906
这个任务可能会有些令人气馁

425
00:13:28,506 --> 0:13:31,046
在 Xcode 10 中我们有能力为你

426
00:13:31,046 --> 0:13:32,666
或者说我们为你提供了

427
00:13:32,666 --> 0:13:33,776
能在一个外部文件中

428
00:13:33,776 --> 0:13:34,966
保留这个名单的能力

429
00:13:34,966 --> 0:13:37,426
我们称之为

430
00:13:37,426 --> 0:13:38,236
文件名单

431
00:13:39,626 --> 0:13:41,056
现在 一个文件名单是一个

432
00:13:41,256 --> 0:13:42,996
把所有输入都列在其中的

433
00:13:42,996 --> 0:13:44,826
简单的文本文件

434
00:13:46,226 --> 0:13:47,246
在你的运行脚本过程中

435
00:13:47,246 --> 0:13:48,866
你可以使用

436
00:13:48,866 --> 0:13:49,946
所有有效的

437
00:13:49,946 --> 0:13:51,456
相同的构建设置

438
00:13:52,656 --> 0:13:53,806
有一件重要的事需要注意

439
00:13:53,806 --> 0:13:54,796
这些文件不能

440
00:13:54,796 --> 0:13:56,376
在你的构建过程中

441
00:13:56,376 --> 0:13:58,306
被修改或生成

442
00:13:58,766 --> 0:14:00,796
当你的构建过程开始时

443
00:14:00,796 --> 0:14:01,666
它们就可以读取了

444
00:14:02,086 --> 0:14:03,576
所有的信息都被使用了

445
00:14:03,576 --> 0:14:07,216
接下来我要向你介绍一下

446
00:14:07,216 --> 0:14:08,266
你的输出文件

447
00:14:08,516 --> 0:14:09,596
你的输出文件是

448
00:14:09,596 --> 0:14:10,886
你的构建过程中使用的

449
00:14:10,886 --> 0:14:12,396
另一个关键信息

450
00:14:13,016 --> 0:14:14,086
Xcode 会使用

451
00:14:14,086 --> 0:14:15,926
这个信息来决定

452
00:14:15,926 --> 0:14:17,786
你的运行脚本过程 是否需要运行

453
00:14:17,886 --> 0:14:20,616
当然了 我们对输出文件

454
00:14:20,616 --> 0:14:23,026
有支撑 还有对你的输出

455
00:14:23,026 --> 0:14:24,376
文件的名单

456
00:14:25,336 --> 0:14:27,066
所以当你的

457
00:14:27,066 --> 0:14:28,726
运行脚本过程运行时 我想要为你概括

458
00:14:29,856 --> 0:14:31,186
如果你没有宣告任何

459
00:14:31,186 --> 0:14:33,896
输入文件 那 Xcode 构建系统

460
00:14:34,076 --> 0:14:35,186
会需要在每个单一的

461
00:14:35,186 --> 0:14:36,896
构建中都进入到你的运行脚本过程

462
00:14:37,556 --> 0:14:38,936
这就是为什么

463
00:14:38,936 --> 0:14:40,106
宣告你的输入是很重要的一个

464
00:14:40,106 --> 0:14:40,626
关键原因

465
00:14:42,006 --> 0:14:43,476
如果你的输入文件变化了

466
00:14:43,476 --> 0:14:45,396
包括你文件名单的内容

467
00:14:45,396 --> 0:14:47,996
或者其他文件名单指向的

468
00:14:47,996 --> 0:14:49,506
任何输入

469
00:14:49,506 --> 0:14:51,376
Xcode 都会知道它将

470
00:14:51,376 --> 0:14:52,596
为你返回你的

471
00:14:52,596 --> 0:14:53,196
脚本过程

472
00:14:53,696 --> 0:14:56,216
最后 如果你的任何输出

473
00:14:56,216 --> 0:14:58,426
文件丢失了

474
00:14:58,426 --> 0:14:59,876
Xcode 构建系统会运行

475
00:14:59,876 --> 0:15:01,116
你的运行脚本过程

476
00:15:01,116 --> 0:15:03,126
来为你提供

477
00:15:03,366 --> 0:15:04,606
生成丢失的输出文件的机会

478
00:15:05,836 --> 0:15:08,446
Xcode 10 还有一个新性能

479
00:15:08,446 --> 0:15:10,466
就是我们为运行脚本过程

480
00:15:10,466 --> 0:15:11,396
提供了文档

481
00:15:12,516 --> 0:15:16,916
[ 掌声 ]

482
00:15:17,416 --> 0:15:18,746
这包含了更多

483
00:15:18,746 --> 0:15:19,966
我刚刚解释过的细节

484
00:15:19,966 --> 0:15:20,726
也告诉了你

485
00:15:20,726 --> 0:15:21,886
那些对你有效的

486
00:15:21,886 --> 0:15:22,956
新增的构建设置

487
00:15:23,256 --> 0:15:24,546
包括你如何在

488
00:15:24,736 --> 0:15:26,906
你的脚本内容中 使用这些文件名单

489
00:15:28,216 --> 0:15:29,636
当你设定你的运行脚本过程

490
00:15:29,636 --> 0:15:30,896
并宣告所有这些

491
00:15:30,896 --> 0:15:32,166
新的依赖性

492
00:15:32,166 --> 0:15:34,046
包括你在目标中

493
00:15:34,046 --> 0:15:35,316
修改依赖性时

494
00:15:35,866 --> 0:15:37,986
你都可能遇到依赖性周期

495
00:15:38,636 --> 0:15:40,386
依赖性周期是一个

496
00:15:40,516 --> 0:15:42,036
有着回路的

497
00:15:42,036 --> 0:15:43,706
相互依赖的图表

498
00:15:44,836 --> 0:15:46,346
在 Xcode 10 中

499
00:15:46,346 --> 0:15:48,586
我们有检测这些周期的更好诊断

500
00:15:48,586 --> 0:15:49,836
同时会告诉你错误

501
00:15:49,836 --> 0:15:51,546
包括扩大

502
00:15:51,546 --> 0:15:53,046
获得所有输入的框的能力

503
00:15:53,046 --> 0:15:54,406
这些输入

504
00:15:54,406 --> 0:15:56,076
都是 Xcode 构建系统了解的参与了周期

505
00:15:56,076 --> 0:15:57,516
创建的

506
00:15:58,916 --> 0:16:01,016
其实 周期因为一些原因

507
00:16:01,746 --> 0:16:02,636
并不是很好

508
00:16:02,716 --> 0:16:04,516
首先 它们代表了在你项目中的

509
00:16:04,516 --> 0:16:06,386
一个配置问题

510
00:16:07,306 --> 0:16:08,846
其次 他们可能是

511
00:16:08,846 --> 0:16:10,676
你项目中虚假重建的来源

512
00:16:11,126 --> 0:16:12,346
或者在你的构建过程中

513
00:16:12,346 --> 0:16:13,956
获得过时的信息

514
00:16:15,176 --> 0:16:17,236
我们还在依赖性周期中

515
00:16:17,286 --> 0:16:19,156
更新了一些话题

516
00:16:20,026 --> 0:16:22,356
包括一些我们找到的

517
00:16:22,356 --> 0:16:26,086
你最常遇到的依赖性

518
00:16:26,086 --> 0:16:28,236
周期以及

519
00:16:28,236 --> 0:16:29,626
你修复它们的

520
00:16:29,626 --> 0:16:30,276
方法

521
00:16:30,796 --> 0:16:34,636
我今天要和你说的

522
00:16:34,636 --> 0:16:35,966
最后一件事

523
00:16:35,966 --> 0:16:37,256
就是测量你的构建时间

524
00:16:37,516 --> 0:16:39,406
在 Xcode 10 中

525
00:16:39,406 --> 0:16:40,976
我们针对此有两个新功能

526
00:16:42,436 --> 0:16:45,026
第一个就是我们介绍的

527
00:16:45,126 --> 0:16:47,016
内嵌的任务时间

528
00:16:47,016 --> 0:16:48,226
它可以告诉你

529
00:16:48,226 --> 0:16:49,586
每个任务运行的时间

530
00:16:49,586 --> 0:16:52,796
现在 我想要指出一些

531
00:16:52,796 --> 0:16:54,156
关于你的构建日志中的东西

532
00:16:54,586 --> 0:16:56,236
在顶端有一个过滤栏

533
00:16:57,166 --> 0:16:58,956
准确来说 是 All (所有）

534
00:16:58,956 --> 0:17:00,866
Recent (最近的）过滤器

535
00:17:02,236 --> 0:17:03,306
当你选择 ”All" 时

536
00:17:03,306 --> 0:17:04,626
它将会展示

537
00:17:04,626 --> 0:17:05,866
所有帮助你

538
00:17:05,866 --> 0:17:07,586
最终产品整体输出的

539
00:17:07,586 --> 0:17:08,506
任务

540
00:17:09,396 --> 0:17:10,436
这些往往是

541
00:17:10,436 --> 0:17:11,116
你不想看的

542
00:17:11,546 --> 0:17:12,456
你想要看的

543
00:17:12,456 --> 0:17:13,616
尤其是当你在

544
00:17:13,616 --> 0:17:15,486
增量构建中

545
00:17:15,486 --> 0:17:17,586
试图诊断的是 Recent 标签

546
00:17:18,506 --> 0:17:20,646
这将会向你展示

547
00:17:20,646 --> 0:17:22,096
所有在之前的构建运行中的

548
00:17:22,266 --> 0:17:23,886
构建路径

549
00:17:26,536 --> 0:17:29,056
Xcode 10 里另一个

550
00:17:29,056 --> 0:17:31,236
新特征是一个计时总结

551
00:17:31,526 --> 0:17:32,616
你可以通过打开

552
00:17:32,616 --> 0:17:34,326
Product (产品） 菜单

553
00:17:34,326 --> 0:17:36,066
选择 Perform with Action（与动作运行）

554
00:17:36,066 --> 0:17:38,196
再选择 Build with Timing Summary（采用

555
00:17:38,196 --> 0:17:38,576
计时总结构建）

556
00:17:39,796 --> 0:17:40,736
在你这样操作后 

557
00:17:40,736 --> 0:17:42,046
你会在构建日志最后

558
00:17:42,046 --> 0:17:43,046
得到一个新的日志部分

559
00:17:43,116 --> 0:17:47,606
如果我们集中关注它的话

560
00:17:47,606 --> 0:17:48,346
你会看到它给你

561
00:17:48,346 --> 0:17:50,026
一个你最后构建的操作内

562
00:17:50,026 --> 0:17:53,116
所有任务的时间总和

563
00:17:53,916 --> 0:17:54,786
这也是查看

564
00:17:54,786 --> 0:17:56,586
Recent 过滤器的

565
00:17:56,736 --> 0:17:57,376
另一个重要原因

566
00:17:57,856 --> 0:18:00,196
有一点我需要

567
00:18:00,196 --> 0:18:01,936
特别指出的是

568
00:18:01,936 --> 0:18:03,086
Phase Script Execution（过程脚本执行）

569
00:18:03,836 --> 0:18:05,196
你可以看到在我们刚刚操作的

570
00:18:05,196 --> 0:18:06,966
最后一个构建中

571
00:18:06,966 --> 0:18:07,886
我们有一个 shell 脚本

572
00:18:07,886 --> 0:18:08,816
这只是众多脚本中的一个

573
00:18:08,816 --> 0:18:09,676
它指明一个任务

574
00:18:10,276 --> 0:18:11,726
花费 5 秒钟

575
00:18:12,496 --> 0:18:14,266
如果你在你的

576
00:18:14,266 --> 0:18:15,476
每一个增量构建中

577
00:18:15,476 --> 0:18:17,126
都看到了它们

578
00:18:17,126 --> 0:18:18,506
这是在你的运行脚本过程中

579
00:18:18,506 --> 0:18:20,556
错误配置的指示

580
00:18:20,996 --> 0:18:21,836
可能有一些事情是

581
00:18:21,836 --> 0:18:23,726
你为了减少整体构建时间

582
00:18:23,726 --> 0:18:24,986
而想要说明的

583
00:18:28,456 --> 0:18:29,906
通过从命令行输入 Show Build Timing 

584
00:18:30,256 --> 0:18:34,796
Summary（展示构建计时总结）标识 你也可以获取

585
00:18:35,096 --> 0:18:37,456
构建计时总结

586
00:18:39,566 --> 0:18:40,976
下面我想要让 

587
00:18:40,976 --> 0:18:42,186
上台来给大家

588
00:18:42,186 --> 0:18:42,926
讲一下大家自己的项目也可以

589
00:18:42,926 --> 0:18:45,186
做的资源层面的提升

590
00:18:46,516 --> 0:18:51,966
[ 掌声 ]

591
00:18:52,466 --> 0:18:53,176
&gt;&gt; 谢谢 David

592
00:18:53,996 --> 0:18:54,456
好的

593
00:18:54,456 --> 0:18:56,066
只要一个小小的改变

594
00:18:56,066 --> 0:18:57,936
你们会有

595
00:18:57,936 --> 0:18:59,906
提升你们 Xcode 项目的

596
00:18:59,906 --> 0:19:00,886
多种方法

597
00:19:01,266 --> 0:19:02,116
在我们来到

598
00:19:02,116 --> 0:19:03,346
资源级和文件级

599
00:19:03,346 --> 0:19:05,256
主题时 我想要再说一个

600
00:19:05,256 --> 0:19:07,016
Xcode 10 中的新性能

601
00:19:07,016 --> 0:19:10,656
这是一个

602
00:19:10,656 --> 0:19:11,626
你们当中有些人

603
00:19:11,626 --> 0:19:13,096
在你们的项目有很多 Swift 文件时

604
00:19:13,346 --> 0:19:14,666
为了让它们构建得更快而采用的

605
00:19:14,666 --> 0:19:15,976
临时解决方法

606
00:19:17,696 --> 0:19:18,936
你们已经听说了

607
00:19:19,636 --> 0:19:21,026
这是用在调配置

608
00:19:21,026 --> 0:19:23,166
中的 Whole Module（整体模块）设置

609
00:19:23,966 --> 0:19:25,266
在之前版本的 Xcode 中

610
00:19:25,266 --> 0:19:27,236
对于一些项目来说

611
00:19:27,236 --> 0:19:28,446
开启整体模块编辑模式

612
00:19:28,446 --> 0:19:30,646
即便是调试构建

613
00:19:30,706 --> 0:19:32,496
也会比在默认增量模式

614
00:19:32,496 --> 0:19:36,336
中的构建速度更快

615
00:19:37,326 --> 0:19:39,186
这确实提升了构建速度

616
00:19:39,246 --> 0:19:40,846
因为它可以分享

617
00:19:40,846 --> 0:19:42,656
Swift 的编译器

618
00:19:42,656 --> 0:19:44,546
可以用增量模式不可行的方法

619
00:19:44,916 --> 0:19:46,846
在文件中分享工作

620
00:19:47,386 --> 0:19:48,576
但这也意味着

621
00:19:48,576 --> 0:19:49,806
你每次都要放弃

622
00:19:49,806 --> 0:19:51,286
你的增量构建

623
00:19:51,286 --> 0:19:52,826
并重建整个目标 Swift 

624
00:19:52,826 --> 0:19:54,446
文件的价值

625
00:19:55,346 --> 0:19:57,266
所以在 Xcode 10 中

626
00:19:57,266 --> 0:19:58,926
我们提升了增量构建

627
00:19:58,926 --> 0:20:00,546
让它们也能拥有那些通过文件

628
00:20:00,546 --> 0:20:01,416
分享的工作

629
00:20:01,416 --> 0:20:02,986
所以你应该不再需要

630
00:20:02,986 --> 0:20:04,646
使用整体模块模式

631
00:20:04,646 --> 0:20:06,660
来获得良好的构建时间

632
00:20:08,516 --> 0:20:11,376
[ 掌声 ]

633
00:20:11,876 --> 0:20:13,066
如果你在项目中完成了这个

634
00:20:13,066 --> 0:20:14,846
那你应该回到你的

635
00:20:14,846 --> 0:20:15,966
构建设定编辑器

636
00:20:16,176 --> 0:20:17,246
在编辑模式构架设置中

637
00:20:17,246 --> 0:20:18,426
选择编译配置

638
00:20:18,426 --> 0:20:21,466
然后点击删除

639
00:20:22,186 --> 0:20:23,606
这将回到 Xcode 的

640
00:20:23,606 --> 0:20:24,926
增量构建的

641
00:20:24,926 --> 0:20:25,716
默认设置

642
00:20:25,846 --> 0:20:27,916
关于这个我不会再多说

643
00:20:27,916 --> 0:20:29,826
因为你们已经了解了 这方面的知识

644
00:20:30,096 --> 0:20:31,066
我们在周二时在

645
00:20:31,066 --> 0:20:32,596
“Swift 中有什么新性能”演讲里提到了这个

646
00:20:33,056 --> 0:20:35,206
如果你想要了解更多

647
00:20:35,336 --> 0:20:36,786
在明天的 “Xcode 构建过程背后的情景”中

648
00:20:36,786 --> 0:20:37,956
我们将提到这个

649
00:20:37,956 --> 0:20:39,496
和其他可以让你的

650
00:20:39,496 --> 0:20:42,266
构建更有深度的话题

651
00:20:42,266 --> 0:20:46,606
今天我们有很多

652
00:20:46,606 --> 0:20:47,786
需要讲到的话题

653
00:20:47,786 --> 0:20:49,766
David 已经介绍了一半的内容

654
00:20:50,006 --> 0:20:51,346
我将会介绍剩下的

655
00:20:51,346 --> 0:20:53,156
三个解决

656
00:20:53,156 --> 0:20:55,606
列表顶端复杂表达式的问题

657
00:20:56,506 --> 0:20:58,186
这是因为它很好的同时

658
00:20:58,186 --> 0:20:59,126
举证了我们两个部分的

659
00:20:59,126 --> 0:21:01,966
一个关键点

660
00:21:01,966 --> 0:21:05,206
当一个构建花费很长时间时

661
00:21:05,206 --> 0:21:07,266
总会有一个

662
00:21:07,266 --> 0:21:08,556
你可以提供给 Xcode 的

663
00:21:08,556 --> 0:21:11,896
用来提升状态的关键信息

664
00:21:13,036 --> 0:21:13,946
所以我们要

665
00:21:13,946 --> 0:21:16,006
在复杂的 Swift 表达式语境中

666
00:21:16,006 --> 0:21:17,446
首先看看它

667
00:21:18,066 --> 0:21:21,546
这是我最近的一个项目

668
00:21:21,546 --> 0:21:22,836
中的一些编码

669
00:21:23,966 --> 0:21:26,406
这个结构的一个问题就是

670
00:21:26,966 --> 0:21:29,206
我在各个地方都使用它

671
00:21:30,076 --> 0:21:31,926
拥有一个结构真的很好

672
00:21:32,166 --> 0:21:33,016
拥有一个有性能的结构

673
00:21:33,016 --> 0:21:34,136
也很好

674
00:21:34,136 --> 0:21:35,346
拥有一个有推论的类型的

675
00:21:35,596 --> 0:21:37,826
性能的结构也很好

676
00:21:38,516 --> 0:21:39,696
但是我们在这里

677
00:21:39,696 --> 0:21:41,806
推论的表达式可能

678
00:21:41,806 --> 0:21:43,236
有一些复杂

679
00:21:43,416 --> 0:21:44,986
这不是像

680
00:21:45,256 --> 0:21:47,806
啊 我的 PPT 上已经展示出来了

681
00:21:48,126 --> 0:21:50,426
好吧 我在这里泄露了答案

682
00:21:50,586 --> 0:21:53,316
如果这是一些像 0.0 的东西

683
00:21:53,816 --> 0:21:55,506
那么 double 类型的推论

684
00:21:55,506 --> 0:21:57,636
在这里是没有必要的

685
00:21:58,126 --> 0:21:59,696
因为我们已经从系统框架中

686
00:21:59,696 --> 0:22:01,256
拥有包含

687
00:22:01,256 --> 0:22:03,236
简化函数和幂函数

688
00:22:03,236 --> 0:22:06,586
的大型、复杂的表达式

689
00:22:06,586 --> 0:22:08,026
你可能不会猜到

690
00:22:08,026 --> 0:22:09,566
double 是这个性能中的

691
00:22:09,566 --> 0:22:10,296
推论类型

692
00:22:11,066 --> 0:22:12,126
通过在这里提供这个信息

693
00:22:12,126 --> 0:22:14,076
编译器使用这个结构

694
00:22:14,076 --> 0:22:15,406
在每个文件中

695
00:22:15,406 --> 0:22:17,796
需要做的工作

696
00:22:17,826 --> 0:22:18,876
都被你节省了

697
00:22:19,626 --> 0:22:21,636
你还节省了

698
00:22:21,636 --> 0:22:23,046
你的同事

699
00:22:23,336 --> 0:22:25,086
为了弄清楚这个 big number 到底是什么  

700
00:22:25,086 --> 0:22:26,576
而花费的时间

701
00:22:27,156 --> 0:22:30,166
所以你通过用

702
00:22:30,166 --> 0:22:31,226
这个额外信息来帮助您

703
00:22:31,226 --> 0:22:32,596
优化构建时间

704
00:22:32,596 --> 0:22:34,786
就是一个很好的

705
00:22:34,786 --> 0:22:36,666
软件工程实践的案例

706
00:22:37,806 --> 0:22:38,846
我们看看涉及闭包的

707
00:22:38,846 --> 0:22:40,516
其他例子

708
00:22:41,536 --> 0:22:43,286
这次我将会试着宏定义一个

709
00:22:43,286 --> 0:22:44,936
会返回所有

710
00:22:44,936 --> 0:22:48,186
非可选参数值的和的函数

711
00:22:48,926 --> 0:22:50,156
如果这三个参数是零

712
00:22:50,156 --> 0:22:51,826
它就会返回零

713
00:22:53,136 --> 0:22:54,696
我将会试着使用一个

714
00:22:54,696 --> 0:22:56,726
Swift 的性能

715
00:22:56,726 --> 0:22:58,526
如果你在主体内

716
00:22:58,526 --> 0:23:00,646
有一个拥有单一表达式的闭包

717
00:23:00,646 --> 0:23:02,026
那么编译器会

718
00:23:02,026 --> 0:23:03,986
使用该表达式来决定

719
00:23:03,986 --> 0:23:04,976
闭包的类型

720
00:23:05,786 --> 0:23:07,506
有时候这真的很方便

721
00:23:08,086 --> 0:23:10,976
其他时候它则会导致像这样的代码

722
00:23:12,506 --> 0:23:13,916
这样非常丑

723
00:23:13,916 --> 0:23:14,846
我不认为我会用这个

724
00:23:14,846 --> 0:23:16,046
来回顾过去的代码

725
00:23:17,276 --> 0:23:18,796
我们还有一些内嵌的工艺运算符

726
00:23:18,796 --> 0:23:20,876
和一些针对 nil 的

727
00:23:20,876 --> 0:23:22,316
明确的比较方法

728
00:23:22,406 --> 0:23:24,636
还有一些相关的其他运算

729
00:23:24,636 --> 0:23:26,676
我不认为它会运行的很好

730
00:23:27,316 --> 0:23:29,086
并且还有另一个问题

731
00:23:29,626 --> 0:23:31,136
因为这个表达式太大了

732
00:23:31,136 --> 0:23:32,976
拥有着很多独立的块

733
00:23:32,976 --> 0:23:35,316
Swift 编译器会报错说

734
00:23:35,316 --> 0:23:36,996
它不能在一个合理数量的

735
00:23:36,996 --> 0:23:38,656
时间内完成编译

736
00:23:38,656 --> 0:23:39,906
这个构建时间

737
00:23:40,966 --> 0:23:42,186
简直慢到头了

738
00:23:42,186 --> 0:23:44,646
甚至连编译器都放弃了

739
00:23:45,776 --> 0:23:46,826
这也真的让我对

740
00:23:46,826 --> 0:23:48,046
这个代码加深了理解

741
00:23:48,876 --> 0:23:50,906
我的首选是

742
00:23:50,906 --> 0:23:52,026
如之前的例子一样做相同的事情

743
00:23:52,026 --> 0:23:54,806
同时提供附加的类型

744
00:23:55,186 --> 0:23:56,586
通过一个闭包 你可以在 In Key 词

745
00:23:56,586 --> 0:23:57,906
之前就完成这些

746
00:23:59,156 --> 0:24:01,446
不过这对于特定的问题来说

747
00:24:01,446 --> 0:24:02,706
可能不是最好的

748
00:24:02,706 --> 0:24:03,256
解决办法

749
00:24:03,536 --> 0:24:05,116
所以让我们回到之前有的东西

750
00:24:06,686 --> 0:24:08,416
回想起我之前说的

751
00:24:08,416 --> 0:24:09,646
我想要试着在这里写一个

752
00:24:09,646 --> 0:24:11,596
表达式这样它就可以用来

753
00:24:11,596 --> 0:24:13,996
决定闭包的类型

754
00:24:15,176 --> 0:24:16,846
但是在这种情况下 

755
00:24:16,846 --> 0:24:17,856
这其实不太必要

756
00:24:18,716 --> 0:24:20,316
我们已经从 Reduce 的调用中了解到

757
00:24:20,316 --> 0:24:22,916
这个闭包是什么样的

758
00:24:23,266 --> 0:24:24,716
Reduce 对一个整型可选择的

759
00:24:24,716 --> 0:24:26,156
数组调用

760
00:24:26,766 --> 0:24:28,736
这个结果类型需要

761
00:24:28,776 --> 0:24:30,126
匹配这个函数的返回类型

762
00:24:31,076 --> 0:24:33,186
我们已经知道 Reduce 的回调

763
00:24:33,486 --> 0:24:35,576
只能对可选择

764
00:24:35,576 --> 0:24:37,746
的整型参数操作

765
00:24:38,336 --> 0:24:40,136
这意味着我们不需要

766
00:24:40,136 --> 0:24:42,046
在闭包中放上一个表达式

767
00:24:42,436 --> 0:24:44,626
我们可以把它分解成

768
00:24:44,626 --> 0:24:46,146
各自的部分

769
00:24:46,146 --> 0:24:47,146
成为更可读的指令

770
00:24:48,556 --> 0:24:49,966
这里有一个我之前的

771
00:24:49,966 --> 0:24:51,306
代码的直译

772
00:24:52,616 --> 0:24:53,936
我现在还可以让它

773
00:24:54,326 --> 0:24:55,776
更加的灵活

774
00:24:56,196 --> 0:24:57,806
这就更具有可读性了

775
00:24:58,076 --> 0:24:59,346
也可以更容易维护

776
00:24:59,686 --> 0:25:01,226
它在一个快速的

777
00:25:01,296 --> 0:25:02,596
合理的时间内编译

778
00:25:03,106 --> 0:25:06,336
我要在这个环节展示的最后一个例子

779
00:25:06,336 --> 0:25:07,856
并不像之前两个

780
00:25:07,856 --> 0:25:09,236
一样 应用的

781
00:25:09,236 --> 0:25:10,786
那么广泛

782
00:25:11,396 --> 0:25:13,256
我要说说 Any Object 这个类型

783
00:25:14,766 --> 0:25:17,516
Any Object 是一个描述

784
00:25:17,516 --> 0:25:20,646
所有类别实例的便利的类型

785
00:25:20,736 --> 0:25:22,226
不是一个结构体 或一个枚举

786
00:25:22,326 --> 0:25:23,416
而是一个类

787
00:25:23,526 --> 0:25:24,666
但是我们不知道是哪一个

788
00:25:25,726 --> 0:25:27,076
不过它还有一个

789
00:25:27,076 --> 0:25:28,736
从 Objective-C's ID 类型

790
00:25:28,736 --> 0:25:30,376
传下来的附加的功能

791
00:25:31,206 --> 0:25:33,886
这也是为什么 这个方法被称作语法

792
00:25:34,106 --> 0:25:36,066
如果你试图调用一个方法

793
00:25:36,066 --> 0:25:38,096
或在 Any Object 类型的数值上

794
00:25:38,156 --> 0:25:40,936
读取其性质

795
00:25:40,936 --> 0:25:42,816
Swift 会允许你这样做

796
00:25:42,816 --> 0:25:45,146
前提是这个方法在你的

797
00:25:45,146 --> 0:25:47,106
项目中是可见的

798
00:25:47,106 --> 0:25:48,416
并被展示给了 Objective-C 运行时间

799
00:25:49,416 --> 0:25:51,576
不过 这样是有代价的

800
00:25:52,346 --> 0:25:53,976
因为编译器不知道

801
00:25:53,976 --> 0:25:55,306
你要调用哪个方法

802
00:25:55,306 --> 0:25:57,616
它需要检索

803
00:25:57,616 --> 0:25:59,516
你整个项目所有可能的应用

804
00:25:59,756 --> 0:26:00,986
和你所有引入的框架

805
00:26:00,986 --> 0:26:03,516
因为编译器会认为

806
00:26:03,516 --> 0:26:04,576
任何一个都有可能

807
00:26:04,576 --> 0:26:05,746
是你要调用的那个

808
00:26:06,756 --> 0:26:08,316
必须这样做的原因是

809
00:26:08,316 --> 0:26:09,706
如果它们中没一个匹配

810
00:26:09,706 --> 0:26:10,776
它就需要报错

811
00:26:12,586 --> 0:26:14,966
所以与此相反 我们可以

812
00:26:14,966 --> 0:26:16,706
更好更多更全面的

813
00:26:16,706 --> 0:26:19,106
描述我们的意图

814
00:26:19,626 --> 0:26:21,096
我们可以宏定义一个协议

815
00:26:21,866 --> 0:26:22,696
它可以在相同的文件

816
00:26:22,696 --> 0:26:24,876
或不同的文件中完成

817
00:26:25,426 --> 0:26:27,236
重要的是一旦我们

818
00:26:27,236 --> 0:26:28,616
将委托的性质

819
00:26:28,616 --> 0:26:30,546
改成去使用我们协议

820
00:26:30,626 --> 0:26:32,756
而不是 Any Object

821
00:26:32,756 --> 0:26:34,806
那编译器就知道

822
00:26:34,806 --> 0:26:35,826
在调用的是哪个方法

823
00:26:37,186 --> 0:26:38,276
现在你有机会

824
00:26:38,276 --> 0:26:39,546
检查所有实施类型

825
00:26:39,546 --> 0:26:41,846
是否在正确

826
00:26:42,026 --> 0:26:43,866
实施方法

827
00:26:46,496 --> 0:26:48,186
我们已经谈论了

828
00:26:48,186 --> 0:26:50,576
当编译器决定

829
00:26:50,576 --> 0:26:51,856
重新编译一个文件时

830
00:26:51,856 --> 0:26:53,816
我们可以通过一些技术来减少

831
00:26:53,816 --> 0:26:55,136
编译器的工作量

832
00:26:56,106 --> 0:26:58,486
但是如果完全不重新编译

833
00:26:58,486 --> 0:26:59,556
这些文件会怎么样呢

834
00:26:59,956 --> 0:27:01,696
是什么让编译器决定

835
00:27:01,926 --> 0:27:03,186
一个文件是否需要

836
00:27:03,186 --> 0:27:03,906
重新编译呢

837
00:27:04,636 --> 0:27:06,536
这就需要我们了解

838
00:27:06,536 --> 0:27:07,836
Swift 的依赖性模型

839
00:27:09,496 --> 0:27:12,326
Swift 的依赖性模型

840
00:27:12,356 --> 0:27:13,686
是基于文件的

841
00:27:14,056 --> 0:27:15,366
这有一点棘手因为

842
00:27:15,466 --> 0:27:17,926
在 Swift 中没有头文件

843
00:27:18,546 --> 0:27:20,236
我们看到的都是

844
00:27:20,796 --> 0:27:22,626
在我们的目标中被

845
00:27:22,706 --> 0:27:23,286
默认定义的

846
00:27:24,256 --> 0:27:25,486
在这个例子中

847
00:27:25,486 --> 0:27:26,936
我在文件的左侧声明了

848
00:27:26,936 --> 0:27:27,316
一个结构体 名字是 Point

849
00:27:27,866 --> 0:27:29,176
如果我这时候从右侧引入一个文件

850
00:27:29,176 --> 0:27:31,106
编译器就会知道我是对

851
00:27:31,106 --> 0:27:33,656
第一个声明引入的

852
00:27:34,316 --> 0:27:35,766
这也同样适用于

853
00:27:35,766 --> 0:27:37,466
右侧文件的

854
00:27:37,466 --> 0:27:41,216
X 和 Y 属性

855
00:27:41,416 --> 0:27:43,286
这个以文件为基础的依赖性

856
00:27:43,286 --> 0:27:44,776
意味着如果我改变左边的文件

857
00:27:44,776 --> 0:27:47,846
那么两个文件

858
00:27:47,846 --> 0:27:49,086
都需要被重新编译

859
00:27:50,306 --> 0:27:51,686
这很重要因为

860
00:27:51,686 --> 0:27:52,886
我们其实在尝试调用这个

861
00:27:52,886 --> 0:27:53,816
初始化程序

862
00:27:54,016 --> 0:27:55,326
我们想要确保我们

863
00:27:55,326 --> 0:27:56,486
对其正确调用

864
00:27:57,036 --> 0:28:00,306
编译器很智能

865
00:28:00,306 --> 0:28:01,976
它能知道你什么时候在

866
00:28:01,976 --> 0:28:04,136
一个函数主体中做了修改

867
00:28:04,166 --> 0:28:05,586
在这个例子中是将 assertion 做得

868
00:28:05,586 --> 0:28:09,056
更加合适 所以就只有那个文件

869
00:28:09,056 --> 0:28:10,316
需要被重新编译

870
00:28:11,136 --> 0:28:13,446
其他文件不需要改变

871
00:28:13,616 --> 0:28:15,556
它们是如何使用第一个文件

872
00:28:15,586 --> 0:28:16,196
的 API 的

873
00:28:16,646 --> 0:28:20,946
不过 它确实需要稳妥一些

874
00:28:21,096 --> 0:28:22,916
如果我为这个文件

875
00:28:22,916 --> 0:28:25,326
增加了一个单独的类型 人们可以知道

876
00:28:25,326 --> 0:28:26,706
这个新的 名为 path segment 的结构体

877
00:28:26,906 --> 0:28:28,636
不会影响右侧的文件

878
00:28:29,256 --> 0:28:30,596
但是编译器还是需要稳妥一些

879
00:28:30,596 --> 0:28:31,876
它会重新编译

880
00:28:31,876 --> 0:28:32,186
这两个文件

881
00:28:32,726 --> 0:28:36,116
我们来看看这如何

882
00:28:36,116 --> 0:28:37,456
应用到前面 David 用到的

883
00:28:37,456 --> 0:28:38,216
游戏例子中

884
00:28:39,246 --> 0:28:40,576
现在我们有 App 目标

885
00:28:40,576 --> 0:28:41,856
和 Utilities 框架

886
00:28:41,856 --> 0:28:42,766
我要在每个目标中

887
00:28:42,766 --> 0:28:44,426
展示一些 Swift 文件

888
00:28:45,586 --> 0:28:47,096
如果我在 App 目标中

889
00:28:47,096 --> 0:28:50,636
改变了一个文件 我们就已经知道

890
00:28:50,636 --> 0:28:52,286
该文件需要被重新编译了

891
00:28:52,436 --> 0:28:53,606
当然了 任何依赖于

892
00:28:53,606 --> 0:28:55,146
这个文件的文件

893
00:28:55,146 --> 0:28:56,236
都需要被重新编译

894
00:28:57,026 --> 0:28:58,316
但是在 utilities 目标中的

895
00:28:58,316 --> 0:28:59,716
任何文件

896
00:28:59,756 --> 0:29:01,376
都不需要被重新编译

897
00:29:02,276 --> 0:29:03,326
因为这是另一个分离的目标

898
00:29:03,326 --> 0:29:05,576
它有明确的依赖性

899
00:29:05,676 --> 0:29:07,426
在两个文件中

900
00:29:07,426 --> 0:29:09,406
并没有不清晰的

901
00:29:09,406 --> 0:29:12,456
可见关系

902
00:29:12,626 --> 0:29:15,286
与此相似的是

903
00:29:15,286 --> 0:29:16,376
如果我在框架目标中做一些改变

904
00:29:16,376 --> 0:29:17,896
我将会需要

905
00:29:17,896 --> 0:29:20,246
重新编译这个文件以及

906
00:29:20,246 --> 0:29:21,416
在 utilities 框架中

907
00:29:21,416 --> 0:29:22,236
所有依赖于此的其他文件

908
00:29:23,156 --> 0:29:25,776
但是 这些依赖性更加保守

909
00:29:26,236 --> 0:29:28,296
所以 Xcode 也会

910
00:29:28,296 --> 0:29:29,906
重新编译在 Game 目标中的

911
00:29:29,906 --> 0:29:32,136
一切 除非修改

912
00:29:32,136 --> 0:29:34,846
被完全限制在函数体中

913
00:29:35,436 --> 0:29:38,996
为了综合这些规则

914
00:29:38,996 --> 0:29:40,746
编译器需要保守点

915
00:29:41,056 --> 0:29:42,506
即使人们知道说

916
00:29:42,506 --> 0:29:43,656
这个修改不会影响

917
00:29:43,656 --> 0:29:45,506
其他文件 这不代表

918
00:29:45,506 --> 0:29:46,936
编译器就可以知道

919
00:29:47,716 --> 0:29:49,486
不过 编译器可以知道

920
00:29:49,486 --> 0:29:52,696
该如何处理函数体的变化

921
00:29:52,936 --> 0:29:54,196
它知道其不会影响

922
00:29:54,196 --> 0:29:55,576
文件的界面

923
00:29:55,896 --> 0:29:57,776
因此 也不会要求其他

924
00:29:57,776 --> 0:29:59,406
文件被重新编译

925
00:30:02,406 --> 0:30:04,146
这个通过文件的依赖性基础

926
00:30:04,146 --> 0:30:06,006
在模块内发生

927
00:30:06,006 --> 0:30:08,386
在这里 Swift 的声明

928
00:30:08,386 --> 0:30:10,026
对彼此是隐式可见的

929
00:30:10,876 --> 0:30:11,666
当你在通过你的

930
00:30:11,666 --> 0:30:13,756
引入文件或者你的

931
00:30:13,756 --> 0:30:15,006
头文件来处理

932
00:30:15,006 --> 0:30:16,736
跨模块依赖性时 这些都是

933
00:30:16,736 --> 0:30:17,846
整个目标的依赖性

934
00:30:18,386 --> 0:30:21,836
这些就是关于 Swift 依赖性

935
00:30:21,836 --> 0:30:25,546
和 Swift 目标的好的信息

936
00:30:25,856 --> 0:30:27,336
但我知道你们中很多人

937
00:30:27,546 --> 0:30:29,766
都是混合 Objective-C 目标和 Swift 目标

938
00:30:29,976 --> 0:30:31,336
所以最后一个部分将

939
00:30:31,336 --> 0:30:33,276
集中在

940
00:30:33,276 --> 0:30:34,696
混合源的 App 中如何减少

941
00:30:34,696 --> 0:30:37,756
Swift 和 Objective-C 代码的接口

942
00:30:38,976 --> 0:30:40,506
为了实现这一点 我们将

943
00:30:40,506 --> 0:30:42,966
讨论一下混合源 App 的一些内容

944
00:30:44,096 --> 0:30:46,796
这个图表将有些复杂 所以请耐心点

945
00:30:46,796 --> 0:30:48,356
如果你在观看视频

946
00:30:48,406 --> 0:30:49,626
你可能需要暂停并重新开始

947
00:30:50,386 --> 0:30:51,106
放轻松

948
00:30:52,406 --> 0:30:54,306
首先看到的是

949
00:30:54,676 --> 0:30:56,926
描述你的 Objective-C 接口的头文件

950
00:30:57,646 --> 0:30:58,756
这就是你 App 中用

951
00:30:58,796 --> 0:31:00,136
Objective-C 写的部分

952
00:31:00,296 --> 0:31:01,896
你可能想要把这部分给 Swift

953
00:31:02,376 --> 0:31:03,966
或者你只是想对

954
00:31:03,966 --> 0:31:05,656
你的 App 中的其他 Objective-C 

955
00:31:05,656 --> 0:31:07,046
部分 声明头文件

956
00:31:08,246 --> 0:31:09,796
我们还有桥接头文件

957
00:31:10,236 --> 0:31:11,696
这就是收集

958
00:31:11,696 --> 0:31:13,416
所有你想要展示给你的 App 的

959
00:31:13,416 --> 0:31:15,566
Swift 部分的信息

960
00:31:15,566 --> 0:31:16,886
的头文件

961
00:31:17,766 --> 0:31:19,656
这是 Xcode 中

962
00:31:19,786 --> 0:31:21,616
控制头文件使用的构建设置

963
00:31:21,836 --> 0:31:23,756
一旦它设置完成

964
00:31:23,756 --> 0:31:25,846
Swift 编译器就知道

965
00:31:25,846 --> 0:31:27,906
该把这些 Objective-C 接口

966
00:31:27,906 --> 0:31:28,736
给你的 Swift 代码

967
00:31:30,216 --> 0:31:32,196
Swift 编译器会接着

968
00:31:32,196 --> 0:31:34,616
产生一个生成的头文件

969
00:31:35,036 --> 0:31:36,796
它会反向地做相同的事情

970
00:31:37,246 --> 0:31:39,026
它描述了你的 Swift 代码中

971
00:31:39,026 --> 0:31:41,526
哪些部分会被展示给

972
00:31:41,526 --> 0:31:42,496
Objective-C

973
00:31:43,796 --> 0:31:45,656
这个可以在你的 Objective-C 应用

974
00:31:45,656 --> 0:31:47,046
文件中被使用 

975
00:31:47,046 --> 0:31:49,976
它们可能也会使用一些

976
00:31:49,976 --> 0:31:51,436
第一步中的头文件

977
00:31:51,956 --> 0:31:53,896
当然了 你可能拥有

978
00:31:53,896 --> 0:31:55,946
不依赖于任何 Swift 代码的

979
00:31:55,946 --> 0:31:58,246
Objective-C 代码

980
00:31:58,846 --> 0:32:00,106
这可能不是我们今天在这里

981
00:32:00,106 --> 0:32:01,596
要讨论的内容

982
00:32:02,316 --> 0:32:03,486
所以 让我们从左到右

983
00:32:03,486 --> 0:32:04,626
再缕一次

984
00:32:05,836 --> 0:32:07,746
我们拥有 Objective-C 头文件

985
00:32:08,996 --> 0:32:10,706
为了将某些

986
00:32:10,706 --> 0:32:12,176
信息接入 Swift 的桥接头文件

987
00:32:13,296 --> 0:32:14,906
你们的 Swift 应用文件

988
00:32:15,976 --> 0:32:17,556
将信息送回

989
00:32:17,556 --> 0:32:19,076
Objective-C 的

990
00:32:19,076 --> 0:32:20,176
生成的头文件

991
00:32:20,686 --> 0:32:21,966
最后 就是你的

992
00:32:21,966 --> 0:32:24,036
Objective-C 应用文件

993
00:32:24,506 --> 0:32:28,536
在像这样的图表中

994
00:32:28,536 --> 0:32:30,456
所有这些箭头都代表

995
00:32:30,456 --> 0:32:31,396
依赖性

996
00:32:31,476 --> 0:32:32,876
不是目标层面的依赖性

997
00:32:32,876 --> 0:32:34,966
而是目标内的

998
00:32:35,186 --> 0:32:37,516
文件间的依赖性

999
00:32:38,336 --> 0:32:40,216
所以 我们想要做的是

1000
00:32:40,216 --> 0:32:41,556
关注生成的头文件和

1001
00:32:41,556 --> 0:32:43,046
桥接头文件

1002
00:32:43,046 --> 0:32:44,546
因为如果我们可以

1003
00:32:44,546 --> 0:32:46,916
缩小这些头文件的内容

1004
00:32:46,916 --> 0:32:48,326
那我们就会知道事情变化的机会

1005
00:32:48,326 --> 0:32:49,056
其实更少

1006
00:32:49,366 --> 0:32:51,596
因此 需要重新构建的也更少

1007
00:32:52,206 --> 0:32:54,116
让我们来看一下

1008
00:32:54,916 --> 0:32:56,486
对于生成的头文件来说

1009
00:32:56,486 --> 0:32:57,906
你最有力的工具是

1010
00:32:57,906 --> 0:32:58,866
私有关键词

1011
00:32:59,486 --> 0:33:01,086
在这个例子中

1012
00:33:01,086 --> 0:33:02,126
我有一个在 Swift 定义的

1013
00:33:02,126 --> 0:33:03,036
视图控制器

1014
00:33:03,316 --> 0:33:04,476
它有一个 IBOutlet 属性

1015
00:33:04,516 --> 0:33:06,636
和一个 IBAction 方法

1016
00:33:07,606 --> 0:33:09,526
在默认情况下 这些会

1017
00:33:09,526 --> 0:33:11,966
展示在你生成的头文件中

1018
00:33:12,426 --> 0:33:16,596
因为它们是展示给 Objective-C 的方法和属性

1019
00:33:17,226 --> 0:33:18,876
它们并没有被声明成私有的

1020
00:33:20,276 --> 0:33:22,216
但大部分时间

1021
00:33:22,216 --> 0:33:23,756
你不需要将这些

1022
00:33:23,756 --> 0:33:24,986
展示给你项目中的任何其他文件

1023
00:33:25,376 --> 0:33:26,276
它们只是为了与

1024
00:33:26,276 --> 0:33:27,206
Interface Builder（接口构建器）交互的

1025
00:33:28,286 --> 0:33:30,326
所以 在这种情况下 我可以将其标为私有

1026
00:33:30,366 --> 0:33:32,636
并看着属性和方法

1027
00:33:32,676 --> 0:33:35,396
从生成的头文件中消失

1028
00:33:37,216 --> 0:33:39,606
另外一个例子就是

1029
00:33:39,606 --> 0:33:41,746
在为了用于 Objective-C 运行时间特征

1030
00:33:41,746 --> 0:33:43,526
如 #selector

1031
00:33:43,526 --> 0:33:46,126
而处理展示给 Objective-C 的方法时

1032
00:33:46,786 --> 0:33:47,886
在这个例子中

1033
00:33:47,886 --> 0:33:49,476
我使用基础的  Notification Center

1034
00:33:49,476 --> 0:33:51,646
API 在通知发送时

1035
00:33:51,646 --> 0:33:54,326
它使用 selector 作为回调

1036
00:33:55,896 --> 0:33:58,026
再一次 这里唯一的要求

1037
00:33:58,086 --> 0:33:59,086
就是将方法

1038
00:33:59,086 --> 0:34:00,816
展示给 Objective-C

1039
00:34:00,916 --> 0:34:02,056
在我的项目

1040
00:34:02,056 --> 0:34:03,786
其他文件中 不论是

1041
00:34:03,786 --> 0:34:06,046
Swift 还是 Objective-C 它其实不太被使用

1042
00:34:06,486 --> 0:34:09,286
所以我可以把它标记为私有

1043
00:34:10,106 --> 0:34:11,776
这再一次

1044
00:34:11,776 --> 0:34:14,176
缩小了我生成的头文件的大小

1045
00:34:14,816 --> 0:34:17,256
在这种情况中

1046
00:34:17,256 --> 0:34:19,246
往往还有其他选择

1047
00:34:19,596 --> 0:34:20,586
那就是将其转换为

1048
00:34:20,586 --> 0:34:21,896
基于分块的 API

1049
00:34:22,776 --> 0:34:24,166
在很多例子中

1050
00:34:24,166 --> 0:34:25,866
这甚至可以清理你的代码

1051
00:34:25,866 --> 0:34:27,536
因为你可从那些

1052
00:34:27,666 --> 0:34:28,486
注册事件通知

1053
00:34:28,486 --> 0:34:30,016
的函数

1054
00:34:30,396 --> 0:34:31,516
暗中地获取状态

1055
00:34:31,516 --> 0:34:33,066
而不用一直带着它

1056
00:34:33,066 --> 0:34:33,456
就像带着个环境目标

1057
00:34:34,076 --> 0:34:37,286
最后一个

1058
00:34:37,286 --> 0:34:38,486
减少你生成的头文件大小

1059
00:34:38,486 --> 0:34:41,576
的方法其实是非常古老的

1060
00:34:41,816 --> 0:34:43,256
你可以更新到 Swift 4

1061
00:34:44,366 --> 0:34:45,646
你应该已经听说了

1062
00:34:45,646 --> 0:34:47,216
今年你就需要这么做

1063
00:34:47,596 --> 0:34:49,076
Xcode 10 将会是

1064
00:34:49,076 --> 0:34:51,796
Swift 3 模式被支持的

1065
00:34:51,796 --> 0:34:52,886
最后一个版本了

1066
00:34:53,976 --> 0:34:56,386
所以 这会是你之后

1067
00:34:56,386 --> 0:34:57,946
需要做的事情

1068
00:34:57,976 --> 0:34:59,166
编辑 转换

1069
00:34:59,316 --> 0:35:01,076
至现行的 Swift 语法

1070
00:35:02,496 --> 0:35:04,126
然而 当你在更新的时候

1071
00:35:04,396 --> 0:35:06,906
你可能会选择

1072
00:35:06,906 --> 0:35:09,936
为一个特定的构建设置

1073
00:35:09,936 --> 0:35:11,446
保持 Swift 3 的

1074
00:35:11,446 --> 0:35:12,576
兼容性模式

1075
00:35:12,696 --> 0:35:14,776
这就是 Swift 3 @objc 

1076
00:35:14,776 --> 0:35:15,406
inference

1077
00:35:16,196 --> 0:35:17,086
当你更新到 Swift 4 时

1078
00:35:17,086 --> 0:35:19,316
这是一个你可以选择的选项

1079
00:35:19,316 --> 0:35:22,176
它可以保持 Swift 3 中

1080
00:35:22,176 --> 0:35:23,686
在 NS 对象的任何子类中

1081
00:35:23,736 --> 0:35:26,416
自动向 Objective-C 展示内置方法和性能

1082
00:35:26,416 --> 0:35:30,096
的规则

1083
00:35:30,236 --> 0:35:31,626
如果你在 Swift 3 中编写程序

1084
00:35:31,666 --> 0:35:33,846
你可能会依赖这个性能

1085
00:35:34,196 --> 0:35:35,936
但是还有很多种情况

1086
00:35:36,086 --> 0:35:37,626
你们可能根本不需要

1087
00:35:37,626 --> 0:35:38,806
依赖于此

1088
00:35:39,446 --> 0:35:40,586
在运行时间

1089
00:35:40,746 --> 0:35:42,616
编译时间都不需要

1090
00:35:43,666 --> 0:35:45,466
一旦你合适的

1091
00:35:45,816 --> 0:35:47,256
将你的 Objective-C 依赖性明确地

1092
00:35:47,256 --> 0:35:48,176
标注为 @objc 

1093
00:35:48,176 --> 0:35:51,506
或者 IBOutlet 

1094
00:35:52,016 --> 0:35:54,116
或者 IBAction 

1095
00:35:54,116 --> 0:35:56,096
你就可以选择这些

1096
00:35:56,096 --> 0:35:57,826
构建设置并点击

1097
00:35:57,826 --> 0:35:59,186
删除来回到

1098
00:35:59,186 --> 0:36:01,176
默认模式 

1099
00:36:01,176 --> 0:36:02,866
在该模式下 OB-C 属性只会从

1100
00:36:03,566 --> 0:36:05,316
遵循协议要求的方法

1101
00:36:05,316 --> 0:36:08,176
和性能或者

1102
00:36:08,176 --> 0:36:09,716
那些重写自 Objective-C 的

1103
00:36:09,716 --> 0:36:10,806
方法推导出来

1104
00:36:11,306 --> 0:36:14,576
我们谈论了很多关于

1105
00:36:14,576 --> 0:36:15,856
生成的头文件和对你的 Swift 代码

1106
00:36:15,856 --> 0:36:17,026
可以做的事情

1107
00:36:17,416 --> 0:36:19,816
但是你也有 Objective-C 代码

1108
00:36:20,066 --> 0:36:21,386
Objective-C 代码也同样会

1109
00:36:21,386 --> 0:36:23,596
造成重新构建

1110
00:36:24,656 --> 0:36:25,846
一个桥接头文件一般看起来

1111
00:36:25,846 --> 0:36:27,186
是这样的

1112
00:36:27,186 --> 0:36:28,556
它拥有很多在项目中

1113
00:36:28,556 --> 0:36:29,996
你想要展示给

1114
00:36:29,996 --> 0:36:31,386
Swift 的其他头文件

1115
00:36:32,616 --> 0:36:34,016
我们可以放大显示

1116
00:36:34,016 --> 0:36:34,886
这些头文件中的一个

1117
00:36:34,886 --> 0:36:37,436
MyViewController 头文件

1118
00:36:37,436 --> 0:36:38,716
可以看到 它视图控制器的

1119
00:36:38,716 --> 0:36:40,086
一个非常正常的声明

1120
00:36:40,616 --> 0:36:42,476
它自己本身还包含了

1121
00:36:42,476 --> 0:36:43,196
其他头文件

1122
00:36:44,376 --> 0:36:46,006
这意味着如果

1123
00:36:46,006 --> 0:36:48,126
这些头文件中的任意一个变化了

1124
00:36:48,126 --> 0:36:49,886
你目标中的 Swift 代码

1125
00:36:49,886 --> 0:36:51,866
需要重新编译 

1126
00:36:51,866 --> 0:36:53,356
因为它可能依赖于 某些已经变化的东西

1127
00:36:54,616 --> 0:36:56,206
这并不是最理想的

1128
00:36:56,466 --> 0:36:59,886
在这个例子中我们可以注意

1129
00:36:59,886 --> 0:37:01,656
我们引入 MyNetwork Manager 头文件的

1130
00:37:01,656 --> 0:37:03,096
唯一理由就是

1131
00:37:03,096 --> 0:37:04,986
声明这个属性

1132
00:37:04,986 --> 0:37:06,436
这个视图控制器上的

1133
00:37:06,436 --> 0:37:08,176
网络管理属性

1134
00:37:09,576 --> 0:37:11,986
很有可能

1135
00:37:11,986 --> 0:37:14,816
该属性从来没在 Swift 中被使用过

1136
00:37:15,436 --> 0:37:17,876
在这种情况下

1137
00:37:17,876 --> 0:37:19,376
我们就不需要在这里声明它

1138
00:37:20,346 --> 0:37:21,976
你能做的就是使用分类

1139
00:37:21,976 --> 0:37:23,886
Objective-C 的等价

1140
00:37:23,886 --> 0:37:25,486
拓展包

1141
00:37:25,486 --> 0:37:26,866
来将这个接口分解

1142
00:37:27,606 --> 0:37:28,566
我将在这里定义

1143
00:37:28,566 --> 0:37:30,186
一个新的文件  MyViewController

1144
00:37:30,186 --> 0:37:32,526
Internal 并使用特别的

1145
00:37:32,526 --> 0:37:34,586
无名的语法 来让我们可以

1146
00:37:34,586 --> 0:37:36,116
声明附加的属性并

1147
00:37:36,116 --> 0:37:37,896
依旧可以使用

1148
00:37:37,896 --> 0:37:41,276
我的主要区块 Add Implementation 中的

1149
00:37:41,276 --> 0:37:42,326
属性整合功能

1150
00:37:42,436 --> 0:37:47,066
现在我可以将引入代码

1151
00:37:47,066 --> 0:37:48,696
和属性移入到的这个类别

1152
00:37:49,426 --> 0:37:50,066
看

1153
00:37:50,796 --> 0:37:52,316
引入到 Swift 的头文件

1154
00:37:52,316 --> 0:37:54,636
变得更小了

1155
00:37:54,636 --> 0:37:56,536
而且被改变的可能更小

1156
00:37:56,536 --> 0:37:58,246
同时也不会造成

1157
00:37:58,246 --> 0:37:59,506
不必要的重新构建

1158
00:38:00,476 --> 0:38:01,566
还有一点要注意的是

1159
00:38:02,636 --> 0:38:04,206
我刚刚定义的文件

1160
00:38:04,796 --> 0:38:06,626
很有可能在我的 Objective-C 代码中的

1161
00:38:06,626 --> 0:38:08,256
所有代码都不需要

1162
00:38:08,256 --> 0:38:09,966
访问这个属性

1163
00:38:11,156 --> 0:38:12,796
在这种情况下

1164
00:38:12,796 --> 0:38:13,786
我们不需要一个单独的文件

1165
00:38:14,266 --> 0:38:16,256
我可以直接将这个分类放进

1166
00:38:16,256 --> 0:38:17,176
我的 .m

1167
00:38:18,356 --> 0:38:19,946
这样做不会报错

1168
00:38:20,056 --> 0:38:21,316
一切都会运行得很好

1169
00:38:21,646 --> 0:38:23,076
正如我之前说的

1170
00:38:23,076 --> 0:38:24,736
属性综合还是会为

1171
00:38:24,736 --> 0:38:26,046
网络管理属性工作

1172
00:38:26,536 --> 0:38:28,976
所以我们看了些什么

1173
00:38:29,946 --> 0:38:34,456
我们使用私有和基于分块的 API

1174
00:38:34,456 --> 0:38:35,906
关闭构建设置来

1175
00:38:35,906 --> 0:38:37,586
缩减生成头文件的内容

1176
00:38:38,786 --> 0:38:40,826
我们从声明的 Objective-C

1177
00:38:40,826 --> 0:38:42,736
头文件中分离

1178
00:38:42,736 --> 0:38:44,266
单独的内容 

1179
00:38:44,266 --> 0:38:46,306
它们缩减了桥接头文件的内容

1180
00:38:47,096 --> 0:38:49,076
更少的内容意味着

1181
00:38:49,076 --> 0:38:49,996
在每个构建中更少的工作量

1182
00:38:50,336 --> 0:38:51,856
同时也意味着出现变化的

1183
00:38:51,856 --> 0:38:53,916
几率更小了

1184
00:38:53,916 --> 0:38:56,026
也意味着重新构建的几率更小

1185
00:38:56,686 --> 0:38:57,936
这真的是一箭双雕

1186
00:38:59,126 --> 0:39:01,066
让我们整理一下今天的内容

1187
00:39:02,316 --> 0:39:04,646
David 和我讲了

1188
00:39:04,946 --> 0:39:06,486
很多不同的话题

1189
00:39:06,486 --> 0:39:07,556
包括你可以从 Xcode 中获得

1190
00:39:07,556 --> 0:39:09,186
更多信息的方法

1191
00:39:09,186 --> 0:39:10,906
以及你可以为 Xcode 提供更多的信息

1192
00:39:11,196 --> 0:39:14,256
来提升你构建的速度

1193
00:39:14,646 --> 0:39:16,266
这包括提升你

1194
00:39:16,266 --> 0:39:17,366
构建的效率

1195
00:39:17,366 --> 0:39:19,426
和减少你重新构建

1196
00:39:19,426 --> 0:39:21,956
所需要的工作

1197
00:39:23,416 --> 0:39:25,436
所以我们就快速地总结一下

1198
00:39:25,616 --> 0:39:26,816
如果你想要再次观看

1199
00:39:26,816 --> 0:39:27,956
可以去我们的视频页面

1200
00:39:27,956 --> 0:39:29,486
你今天下午和

1201
00:39:29,486 --> 0:39:31,746
和明天下午也可以在

1202
00:39:31,746 --> 0:39:33,326
我们的实验室找到我们

1203
00:39:33,326 --> 0:39:33,936
非常感谢

1204
00:39:34,086 --> 0:39:36,426
祝你们享受接下来的会议

1205
00:39:37,176 --> 0:39:39,500
[ 掌声 ]
