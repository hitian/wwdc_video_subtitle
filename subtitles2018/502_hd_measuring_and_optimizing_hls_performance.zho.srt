1
00:00:07,516 --> 0:00:15,500
[ 音乐 ]

2
00:00:20,456 --> 0:00:22,976
&gt;&gt; 各位 上午好

3
00:00:23,516 --> 0:00:27,016
[ 掌声 ]

4
00:00:27,516 --> 0:00:28,696
欢迎大家参加今年的

5
00:00:28,696 --> 0:00:30,586
关于 HTTP 流媒体网络传输协议（HLS）的会议

6
00:00:31,486 --> 0:00:32,786
我是 Emil Andriescu

7
00:00:33,476 --> 0:00:35,286
今天我们将讨论

8
00:00:35,286 --> 0:00:37,516
测量和优化 HLS 性能

9
00:00:38,516 --> 0:00:40,226
首先 让我们思考一下

10
00:00:40,226 --> 0:00:42,936
为什么我们应该关注它

11
00:00:42,936 --> 0:00:44,796
以及为什么它对于 App 很重要

12
00:00:45,336 --> 0:00:48,646
假设在一个星期六的晚上

13
00:00:48,646 --> 0:00:50,276
你们坐在舒适的沙发上

14
00:00:50,276 --> 0:00:52,076
熟练地浏览了所有的评论

15
00:00:52,076 --> 0:00:53,676
确定了要观看的视频

16
00:00:53,676 --> 0:00:55,446
爆米花也已经准备好了

17
00:00:55,886 --> 0:00:58,046
你们迫不及待地轻点播放键

18
00:00:58,046 --> 0:01:01,526
但是这时发生了这样的事

19
00:00:58,046 --> 0:01:01,526
但是这时发生了这样的事

20
00:01:02,916 --> 0:01:05,336
面对这种神秘且永无止境的动画

21
00:01:05,336 --> 0:01:07,376
你们会问自己

22
00:01:07,376 --> 0:01:09,096
还有什么比这更糟糕的呢

23
00:01:10,506 --> 0:01:12,296
让我们面对它 你们知道吗

24
00:01:12,296 --> 0:01:13,136
它其实是一个播放错误

25
00:01:13,706 --> 0:01:17,846
但是客户真正期望

26
00:01:17,906 --> 0:01:20,306
HLS 会提供什么样的体验呢

27
00:01:21,016 --> 0:01:22,126
他们期待清晰的图像

28
00:01:22,256 --> 0:01:24,176
高保真的音质

29
00:01:24,176 --> 0:01:26,506
以及轻点播放键时

30
00:01:26,506 --> 0:01:28,686
即时的媒体反应

31
00:01:29,466 --> 0:01:31,096
然而 互联网上流媒体 App

32
00:01:31,096 --> 0:01:32,836
的性能表现总是受网络的影响

33
00:01:32,836 --> 0:01:35,616
那么我们该如何调和呢

34
00:01:36,696 --> 0:01:38,656
HLS 的设计

35
00:01:38,656 --> 0:01:40,176
就是为了解决这个问题

36
00:01:40,176 --> 0:01:42,246
即在不可预知的

37
00:01:42,516 --> 0:01:43,786
网络环境中

38
00:01:43,786 --> 0:01:46,166
提供最好的

39
00:01:46,166 --> 0:01:47,156
不间断的流媒体体验

40
00:01:47,156 --> 0:01:48,406
所以我们为什么今天在这里

41
00:01:48,666 --> 0:01:49,576
还有很多理由

42
00:01:50,006 --> 0:01:52,696
如今 HLS 已经发展成一个

43
00:01:52,696 --> 0:01:54,336
更动态的生态系统

44
00:01:54,546 --> 0:01:56,566
它支持新的功能

45
00:01:56,566 --> 0:01:58,376
如 I-frame 播放

46
00:01:58,376 --> 0:02:00,896
新媒体格式 当然还有新的编解码器

47
00:01:58,376 --> 0:02:00,896
新媒体格式 当然还有新的编解码器

48
00:02:01,336 --> 0:02:03,316
与此同时

49
00:02:03,316 --> 0:02:05,896
我们不断地添加强大的

50
00:02:06,046 --> 0:02:08,985
iOS tvOS 以及 macOS 的 API

51
00:02:09,316 --> 0:02:12,236
比如你们可以针对你们的目标用户

52
00:02:12,236 --> 0:02:13,946
优化和调整播放

53
00:02:13,946 --> 0:02:15,786
并提供更丰富的用户体验

54
00:02:16,876 --> 0:02:18,686
交付模式和传输协议

55
00:02:18,726 --> 0:02:20,136
也在不断发展

56
00:02:20,136 --> 0:02:22,186
因此重要的是

57
00:02:22,186 --> 0:02:23,776
结合观察

58
00:02:23,776 --> 0:02:26,046
在移动设备上或客厅中

59
00:02:26,046 --> 0:02:27,506
内容被消费的情况

60
00:02:27,776 --> 0:02:33,996
以判断服务器端的性能

61
00:02:34,216 --> 0:02:36,266
考虑到所有这些指标

62
00:02:36,266 --> 0:02:37,616
你们如何确定

63
00:02:37,616 --> 0:02:39,616
你们为观众提供的用户体验

64
00:02:39,616 --> 0:02:41,016
是最好的呢

65
00:02:41,016 --> 0:02:43,256
第一步是

66
00:02:43,256 --> 0:02:47,296
结合你们对内容 App

67
00:02:47,296 --> 0:02:48,796
或交付的更改

68
00:02:49,056 --> 0:02:51,056
理解并量化用户体验

69
00:02:52,176 --> 0:02:53,866
我们认为在这一方面

70
00:02:53,866 --> 0:02:55,456
确定哪种配置是最优的方法

71
00:02:55,906 --> 0:02:57,416
应该是测量

72
00:02:57,416 --> 0:02:58,996
而不是猜测

73
00:03:00,246 --> 0:03:01,416
那么这个会议将是什么内容呢

74
00:03:02,176 --> 0:03:03,846
首先 我们想要建立一种

75
00:03:03,846 --> 0:03:05,456
共同的语言

76
00:03:05,456 --> 0:03:06,946
来讨论流媒体服务的质量

77
00:03:07,636 --> 0:03:09,436
然后我们想讨论

78
00:03:09,436 --> 0:03:11,156
如何客观地度量

79
00:03:11,156 --> 0:03:12,836
App 的流媒体性能

80
00:03:13,766 --> 0:03:15,266
第三 我们希望

81
00:03:15,266 --> 0:03:17,796
帮助你们识别

82
00:03:17,796 --> 0:03:19,746
并解决一些

83
00:03:19,746 --> 0:03:20,906
影响流媒体服务质量的问题

84
00:03:22,416 --> 0:03:24,196
最后 我们想修正

85
00:03:24,196 --> 0:03:25,606
主播放列表

86
00:03:25,976 --> 0:03:27,486
这是因为

87
00:03:27,616 --> 0:03:29,376
我们在流媒体质量中

88
00:03:29,596 --> 0:03:31,056
看到的许多问题

89
00:03:31,056 --> 0:03:33,226
实际上根源于

90
00:03:33,256 --> 0:03:34,626
主播放列表的编写

91
00:03:35,446 --> 0:03:37,216
在详细讨论之前

92
00:03:37,216 --> 0:03:38,916
让我们先简要概述一下

93
00:03:38,916 --> 0:03:40,246
HLS 播放会话

94
00:03:41,216 --> 0:03:42,736
正如你们所期望的

95
00:03:42,736 --> 0:03:44,426
它从下载一个主播放列表开始

96
00:03:44,896 --> 0:03:47,396
一旦 AVPlayer 开始读取播放列表

97
00:03:47,396 --> 0:03:50,176
它就知道这个播放列表指向的是什么内容

98
00:03:50,416 --> 0:03:51,496
在这种情况下

99
00:03:51,496 --> 0:03:53,836
我们有两个比特率 1 兆比特和 2 兆比特

100
00:03:53,836 --> 0:03:55,546
AVPlayer 会选择其中的一个

101
00:03:55,546 --> 0:03:57,406
然后下载

102
00:03:57,406 --> 0:03:58,846
一个媒体播放列表

103
00:03:58,846 --> 0:03:59,816
以及附加的

104
00:03:59,816 --> 0:04:01,806
例如密钥的工件

105
00:03:59,816 --> 0:04:01,806
例如密钥的工件

106
00:04:01,806 --> 0:04:03,026
然后继续下载

107
00:04:03,026 --> 0:04:05,216
媒体片段

108
00:04:05,216 --> 0:04:06,596
直到缓冲层足够播放

109
00:04:07,106 --> 0:04:10,446
这种情况出现时

110
00:04:10,446 --> 0:04:11,916
AVPlayeItem

111
00:04:11,916 --> 0:04:14,516
将通过设置

112
00:04:14,516 --> 0:04:16,176
playbackLikeyToKeepUp == true 的方式

113
00:04:16,176 --> 0:04:17,766
来传达对播放性能的预测

114
00:04:18,406 --> 0:04:20,466
如果你预先将

115
00:04:20,546 --> 0:04:22,125
AVPlayer 速率设置为 1

116
00:04:22,125 --> 0:04:24,026
那么你正在使用

117
00:04:24,026 --> 0:04:26,426
AVPlayer 的自动播放功能

118
00:04:26,426 --> 0:04:27,886
该播放器将立即开始播放

119
00:04:28,476 --> 0:04:29,946
我们称之为时间间隔

120
00:04:29,946 --> 0:04:30,786
启动时间

121
00:04:31,666 --> 0:04:33,426
从这一点开始

122
00:04:33,426 --> 0:04:35,516
挂钟（也称为实时时钟）

123
00:04:35,866 --> 0:04:37,516
将和 PlayerItem.timebase

124
00:04:37,516 --> 0:04:39,076
以相同的速度前进

125
00:04:39,436 --> 0:04:41,396
有一个条件

126
00:04:41,396 --> 0:04:43,786
即内容必须以

127
00:04:43,786 --> 0:04:46,056
与 AVPlayer 使用的内容

128
00:04:46,056 --> 0:04:47,926
相同或更快的速度到达

129
00:04:48,586 --> 0:04:49,916
如果这样不行

130
00:04:49,966 --> 0:04:52,036
AVPlayer 会尝试

131
00:04:52,036 --> 0:04:53,336
切换到这里的 1 兆比特

132
00:04:53,766 --> 0:04:55,426
如果网络仍然不能

133
00:04:55,426 --> 0:04:57,446
在 1 兆比特时保持实时速度

134
00:04:57,726 --> 0:04:59,276
那么缓冲区将最终耗尽

135
00:04:59,276 --> 0:05:01,566
AVPlayer 没有选择

136
00:04:59,276 --> 0:05:01,566
AVPlayer 没有选择

137
00:05:01,566 --> 0:05:03,006
它需要停止播放

138
00:05:03,006 --> 0:05:04,926
我们将这种事件称为卡顿

139
00:05:05,816 --> 0:05:07,246
播放器将保持这种状态

140
00:05:07,246 --> 0:05:09,196
不仅直到数据

141
00:05:09,196 --> 0:05:10,776
再次开始流动

142
00:05:10,776 --> 0:05:11,996
而且直到有足够的缓冲区

143
00:05:11,996 --> 0:05:13,796
为 PlayItem 触发

144
00:05:13,796 --> 0:05:15,346
另一个积极的

145
00:05:15,416 --> 0:05:18,596
播放性能预测之后

146
00:05:18,596 --> 0:05:19,576
播放将正常继续

147
00:05:20,666 --> 0:05:22,166
现在让我们讨论一下

148
00:05:22,456 --> 0:05:24,176
如何量化这种会话中的

149
00:05:24,176 --> 0:05:25,116
用户体验

150
00:05:26,216 --> 0:05:27,926
我们通过定义一组

151
00:05:27,926 --> 0:05:29,526
关键性能指标 也就是 KPI

152
00:05:29,526 --> 0:05:30,396
来实现这一点

153
00:05:31,056 --> 0:05:32,596
我们选择了其中 5 个

154
00:05:32,596 --> 0:05:34,166
我们认为是 HLS 中

155
00:05:34,196 --> 0:05:35,556
最具代表性的 KPI

156
00:05:36,946 --> 0:05:38,776
你们可能会问

157
00:05:38,776 --> 0:05:40,436
我的用户需要花多少时间

158
00:05:40,836 --> 0:05:42,996
等待播放

159
00:05:42,996 --> 0:05:47,166
1 秒吗 还是 5 秒或30 秒

160
00:05:47,486 --> 0:05:49,036
这是用户体验的

161
00:05:49,036 --> 0:05:50,486
一个重要方面

162
00:05:51,336 --> 0:05:53,906
此外 播放卡顿

163
00:05:53,906 --> 0:05:55,616
就像我们刚才看到的那样

164
00:05:55,616 --> 0:05:56,966
也会对用户造成干扰

165
00:05:57,076 --> 0:05:59,156
我们关心这两者发生的频率

166
00:05:59,156 --> 0:06:00,936
但也许更重要的是

167
00:05:59,156 --> 0:06:00,936
但也许更重要的是

168
00:06:00,936 --> 0:06:02,646
从卡顿中恢复

169
00:06:02,676 --> 0:06:04,126
需要多长时间

170
00:06:05,126 --> 0:06:09,126
然而 在不了解未来的情况下

171
00:06:09,126 --> 0:06:11,136
最好的策略是

172
00:06:11,136 --> 0:06:12,666
以最低的可用比特率交付内容

173
00:06:13,106 --> 0:06:14,666
但那当然不是我们想要的

174
00:06:14,666 --> 0:06:16,076
我们希望提供

175
00:06:16,076 --> 0:06:18,206
最好的音频和视频质量

176
00:06:18,206 --> 0:06:19,356
同时仍不卡顿

177
00:06:19,686 --> 0:06:21,116
所以 在卡顿的风险

178
00:06:21,116 --> 0:06:23,136
以及媒体质量之间

179
00:06:23,136 --> 0:06:24,526
有一个明显的权衡

180
00:06:24,626 --> 0:06:28,566
为此 我们需要另一个

181
00:06:28,566 --> 0:06:29,776
可以衡量整体媒体质量的会话

182
00:06:30,736 --> 0:06:32,976
最后 播放错误

183
00:06:32,976 --> 0:06:33,806
我已经讨论过这点

184
00:06:34,166 --> 0:06:36,166
它们比卡顿更具破坏性

185
00:06:36,826 --> 0:06:39,806
我们如何跟踪

186
00:06:39,806 --> 0:06:40,276
播放错误呢

187
00:06:41,196 --> 0:06:42,866
好的 让我们从启动时间开始讲起

188
00:06:43,676 --> 0:06:45,526
有很多种 API 

189
00:06:45,526 --> 0:06:48,296
你可以用来获取或计算启动时间

190
00:06:48,666 --> 0:06:50,786
首先 不要使用将 AVPlayer.status 更改为

191
00:06:51,046 --> 0:06:52,836
.readyToPlay 这种方法

192
00:06:52,836 --> 0:06:53,796
这并没有告诉你

193
00:06:53,836 --> 0:06:56,256
播放将要开始

194
00:06:56,446 --> 0:06:58,086
然而 如果你正在使用自动播放

195
00:06:58,086 --> 0:06:59,346
那么你可以预先设置

196
00:06:59,346 --> 0:07:00,726
播放器的速率

197
00:06:59,346 --> 0:07:00,726
播放器的速率

198
00:07:00,726 --> 0:07:02,716
你可以将 AVPlayerItem.status 更改为

199
00:07:02,716 --> 0:07:04,506
.readyToPlay

200
00:07:04,506 --> 0:07:06,606
或者将

201
00:07:06,606 --> 0:07:08,536
AVPlayerItem.isPlaybackLikelyToKeepUp

202
00:07:08,536 --> 0:07:09,516
更改为 true

203
00:07:09,516 --> 0:07:11,026
这些都是可观测的属性

204
00:07:12,176 --> 0:07:13,836
这样做之后

205
00:07:13,886 --> 0:07:15,876
你就可以知道播放即将开始

206
00:07:15,876 --> 0:07:16,916
但是播放可能需要

207
00:07:17,076 --> 0:07:19,616
几毫秒才会开始

208
00:07:19,876 --> 0:07:21,346
所以我们向你们推荐两种方法

209
00:07:21,346 --> 0:07:23,766
一种是将 AVPlayer.timeControlStatus

210
00:07:23,766 --> 0:07:25,056
更改为 .Playing

211
00:07:25,056 --> 0:07:26,836
另一种是跟踪

212
00:07:26,836 --> 0:07:28,376
AVplayerItem.timebase

213
00:07:28,376 --> 0:07:30,086
而且会有一个通知允许你这么做

214
00:07:30,596 --> 0:07:34,526
AVPlayer 依靠探试法来避免卡顿

215
00:07:34,526 --> 0:07:36,696
但我们知道

216
00:07:36,696 --> 0:07:38,026
有时它们是不可避免的

217
00:07:38,846 --> 0:07:40,946
你可以通过观察

218
00:07:40,946 --> 0:07:43,946
AVPlayerItemPlaybackStalled 的通知

219
00:07:43,946 --> 0:07:44,736
来监控卡顿

220
00:07:45,136 --> 0:07:46,816
这里的建议是计数

221
00:07:46,876 --> 0:07:48,126
卡顿的出现

222
00:07:48,736 --> 0:07:49,776
当然 如果你想要

223
00:07:49,776 --> 0:07:52,346
比较和合计

224
00:07:52,346 --> 0:07:54,466
不同时长的会话的

225
00:07:54,466 --> 0:07:56,016
卡顿行为

226
00:07:56,016 --> 0:07:57,096
那么你需要将其正常化

227
00:07:57,096 --> 0:07:57,826
这又该如何做到呢

228
00:07:58,296 --> 0:08:00,056
我们建议你使用

229
00:07:58,296 --> 0:08:00,056
我们建议你使用

230
00:08:00,296 --> 0:08:01,996
总观看时长

231
00:08:01,996 --> 0:08:04,636
并计算卡顿率

232
00:08:04,636 --> 0:08:09,326
以单位观看时间内的卡顿次数为单位 例如卡顿/小时

233
00:08:09,926 --> 0:08:13,976
对用户来说

234
00:08:13,976 --> 0:08:16,296
30 秒的卡顿

235
00:08:16,296 --> 0:08:17,206
比 1 秒的卡顿更糟糕

236
00:08:17,436 --> 0:08:19,296
这就是为什么我们也关心

237
00:08:19,506 --> 0:08:21,356
再缓冲时间或卡顿时长

238
00:08:22,276 --> 0:08:23,716
通过测量

239
00:08:23,716 --> 0:08:25,026
播放卡顿的通知

240
00:08:25,026 --> 0:08:26,956
以及当 PlayerItem.timebase 变为 1 时

241
00:08:26,956 --> 0:08:28,566
之间的时间间隔

242
00:08:28,566 --> 0:08:31,306
你就可以计算出

243
00:08:31,306 --> 0:08:32,206
准确的卡顿时长

244
00:08:32,936 --> 0:08:34,956
此外 通过使用

245
00:08:34,956 --> 0:08:37,206
会话的播放时长

246
00:08:37,206 --> 0:08:38,746
你也可以对总时长进行正常化

247
00:08:39,025 --> 0:08:40,106
那么 你可能想知道

248
00:08:40,106 --> 0:08:41,356
我是如何计算

249
00:08:41,356 --> 0:08:43,006
一个会话的播放时长的

250
00:08:43,395 --> 0:08:45,636
答案是通过访问日志

251
00:08:45,636 --> 0:08:46,596
让我们来看看怎么做

252
00:08:47,686 --> 0:08:49,866
这是一段代码

253
00:08:50,806 --> 0:08:52,396
首先 我们从 PlayerItem 中

254
00:08:52,396 --> 0:08:54,126
获得对访问日志的引用

255
00:08:55,096 --> 0:08:57,386
我们迭代访问日志中的事件

256
00:08:57,386 --> 0:08:59,316
并简单地

257
00:08:59,316 --> 0:09:02,156
计算每个

258
00:08:59,316 --> 0:09:02,156
计算每个

259
00:09:02,156 --> 0:09:02,456
event.durationWatched

260
00:09:02,456 --> 0:09:04,466
就是这样 我们计算了

261
00:09:04,466 --> 0:09:05,406
一个会话的总播放时长

262
00:09:05,936 --> 0:09:07,416
现在你可能会想

263
00:09:07,416 --> 0:09:08,576
这个事件是什么

264
00:09:08,576 --> 0:09:09,946
访问日志中的事件

265
00:09:09,946 --> 0:09:10,456
是什么意思呢

266
00:09:10,726 --> 0:09:12,206
那么 让我们看看

267
00:09:12,206 --> 0:09:14,486
AVPlayerItemAccessLog 是如何工作的

268
00:09:15,306 --> 0:09:16,976
AVPlayerItemAccessLog 提供了

269
00:09:16,976 --> 0:09:18,876
你的会话的历史记录

270
00:09:19,476 --> 0:09:21,196
它最初是 null

271
00:09:21,196 --> 0:09:23,476
但是当播放开始时

272
00:09:23,476 --> 0:09:25,476
你将收到一个

273
00:09:25,476 --> 0:09:27,086
AVPlayerItemNewAccessLogEntry 通知

274
00:09:27,086 --> 0:09:29,396
到那时你将拥有一个访问日志

275
00:09:29,916 --> 0:09:30,946
你将看到

276
00:09:30,946 --> 0:09:33,136
访问日志中的事件

277
00:09:33,856 --> 0:09:36,426
包含关于不同方面的信息

278
00:09:36,426 --> 0:09:38,436
例如 当前变体 URL 当前比特率

279
00:09:38,436 --> 0:09:41,326
播放时长

280
00:09:41,326 --> 0:09:45,636
卡顿次数等等这些值

281
00:09:45,636 --> 0:09:49,326
初始化为负值或 null

282
00:09:49,906 --> 0:09:52,316
当播放开始时

283
00:09:52,316 --> 0:09:53,706
它们会依据实际的测量数据

284
00:09:53,706 --> 0:09:56,406
和正在播放的实际变量 URL 进行更新

285
00:09:56,406 --> 0:09:59,016
两种情况下

286
00:09:59,016 --> 0:10:00,576
我们会向访问日志中添加新事件

287
00:09:59,016 --> 0:10:00,576
我们会向访问日志中添加新事件

288
00:10:00,576 --> 0:10:02,886
一种是变量切换

289
00:10:02,886 --> 0:10:04,916
就像在本例中一样

290
00:10:04,916 --> 0:10:05,806
另一种是播放查找

291
00:10:06,256 --> 0:10:08,056
但是在添加新事件之前

292
00:10:08,126 --> 0:10:10,036
旧的事件不再可变

293
00:10:10,416 --> 0:10:11,926
然后我们才能添加新事件

294
00:10:12,226 --> 0:10:13,606
现在请记住

295
00:10:13,606 --> 0:10:16,066
当播放开始时

296
00:10:16,066 --> 0:10:17,876
这些值会不断更新

297
00:10:17,876 --> 0:10:20,286
所以上一个事件中的值

298
00:10:21,436 --> 0:10:22,976
并不是可观察的属性

299
00:10:25,116 --> 0:10:26,966
我们也提到我们关心的

300
00:10:26,966 --> 0:10:29,466
媒体质量

301
00:10:29,956 --> 0:10:31,566
我们应如何计算它呢

302
00:10:33,376 --> 0:10:35,326
衡量用户

303
00:10:35,326 --> 0:10:36,966
是否获得最好的

304
00:10:36,966 --> 0:10:38,346
媒体质量的一种方法

305
00:10:38,346 --> 0:10:40,136
当然是看视频比特率

306
00:10:40,636 --> 0:10:42,646
这里我们不关心

307
00:10:42,646 --> 0:10:44,416
启动时间或卡顿时长

308
00:10:44,416 --> 0:10:46,026
所以我们把它们去掉

309
00:10:46,396 --> 0:10:47,946
我们还剩下播放状态

310
00:10:48,446 --> 0:10:50,066
在这个例子中

311
00:10:50,066 --> 0:10:52,426
我们看到我们在 2 兆比特的变量上

312
00:10:52,426 --> 0:10:55,536
播放的时间更长

313
00:10:55,576 --> 0:10:56,476
而 1 兆比特的时间更短

314
00:10:57,016 --> 0:10:59,166
按时间加权每一个比特率

315
00:10:59,466 --> 0:11:01,326
我们可以获得一个

316
00:10:59,466 --> 0:11:01,326
我们可以获得一个

317
00:11:01,326 --> 0:11:02,766
视频质量的单一值

318
00:11:02,766 --> 0:11:04,956
并对此在不同的会话中进行比较

319
00:11:06,046 --> 0:11:07,226
我们称这个度量为

320
00:11:07,226 --> 0:11:09,206
时间加权的指示比特率

321
00:11:09,586 --> 0:11:11,706
计算它就像计算

322
00:11:11,836 --> 0:11:14,266
总时长一样简单

323
00:11:15,116 --> 0:11:17,496
再一次 我们获得了

324
00:11:17,496 --> 0:11:19,176
对 PlayerItems 的访问日志的引用

325
00:11:19,546 --> 0:11:21,526
我们迭代日志中的事件

326
00:11:21,846 --> 0:11:23,526
我们也计算了

327
00:11:23,526 --> 0:11:25,026
相对于我们之前计算过的

328
00:11:25,026 --> 0:11:26,936
totalDurationWatched 的每个事件的

329
00:11:26,936 --> 0:11:29,396
时间权重 最后

330
00:11:29,586 --> 0:11:31,126
我们计算得出了加权比特率值

331
00:11:31,526 --> 0:11:33,036
现在请记住

332
00:11:33,036 --> 0:11:35,546
有些属性可能没有初始化

333
00:11:35,546 --> 0:11:36,516
所以在代码中

334
00:11:36,516 --> 0:11:39,206
应进行适当的检查

335
00:11:41,076 --> 0:11:44,286
另一个你绝对应该跟踪的事件

336
00:11:44,376 --> 0:11:45,306
当然是播放失败

337
00:11:45,866 --> 0:11:47,526
为此 你需要观察

338
00:11:47,526 --> 0:11:48,796
AVPlayerItem.status

339
00:11:49,646 --> 0:11:51,256
如果它的值更改为 false

340
00:11:51,256 --> 0:11:52,986
则意味着 AVPlayer

341
00:11:52,986 --> 0:11:54,746
遇到不可恢复的错误

342
00:11:55,666 --> 0:11:56,926
有没有将这种观察

343
00:11:56,926 --> 0:11:58,576
转换成 KPI 的好方法呢

344
00:11:59,736 --> 0:12:02,856
一种方法是

345
00:11:59,736 --> 0:12:02,856
一种方法是

346
00:12:03,026 --> 0:12:04,636
观察失败的会话

347
00:12:04,636 --> 0:12:06,526
占总会话的百分比

348
00:12:06,526 --> 0:12:07,436
但是可能

349
00:12:07,436 --> 0:12:08,206
还有其他的方法

350
00:12:08,856 --> 0:12:10,636
这里我想强调的一点是

351
00:12:10,636 --> 0:12:12,596
并非你的流中的

352
00:12:12,596 --> 0:12:14,246
所有错误都是致命的

353
00:12:14,376 --> 0:12:16,316
有些可能会影响媒体质量

354
00:12:16,536 --> 0:12:18,066
而有些错误

355
00:12:18,066 --> 0:12:19,386
用户甚至可能无法察觉

356
00:12:19,676 --> 0:12:21,046
但是尽管如此

357
00:12:21,046 --> 0:12:23,806
如果存在错误

358
00:12:23,806 --> 0:12:25,656
它们就反映了你的流存在问题

359
00:12:25,876 --> 0:12:29,286
那么 我该如何深入了解

360
00:12:29,286 --> 0:12:30,626
流中出现了什么问题呢

361
00:12:31,176 --> 0:12:32,986
答案就来自

362
00:12:32,986 --> 0:12:34,586
PlayerItemErrorLog

363
00:12:35,436 --> 0:12:37,046
AVPlayerItemErrorLog

364
00:12:37,156 --> 0:12:38,756
错误日志记录了

365
00:12:38,756 --> 0:12:40,636
对用户造成不同程度影响的错误

366
00:12:41,136 --> 0:12:43,626
它的工作方式

367
00:12:43,836 --> 0:12:45,446
与访问日志类似

368
00:12:45,446 --> 0:12:47,426
只是事件表示错误

369
00:12:47,426 --> 0:12:48,806
而不是播放器的访问状态

370
00:12:49,936 --> 0:12:52,766
它们涉及很多方面

371
00:12:52,766 --> 0:12:54,586
如交付问题 网络问题

372
00:12:54,586 --> 0:12:57,476
内容编写错误等等

373
00:12:57,666 --> 0:12:59,476
例如 它们可以让你了解

374
00:12:59,476 --> 0:13:01,076
发生卡顿的原因

375
00:12:59,476 --> 0:13:01,076
发生卡顿的原因

376
00:13:01,076 --> 0:13:03,296
比如媒体文件

377
00:13:03,296 --> 0:13:05,286
在大约 10 秒内没有响应

378
00:13:05,886 --> 0:13:09,126
我们之前讨论了

379
00:13:09,126 --> 0:13:11,006
你可以在每次会话中跟踪的启动时间

380
00:13:11,646 --> 0:13:12,876
我们建议你查看一下

381
00:13:12,876 --> 0:13:14,256
你的 App 的

382
00:13:14,286 --> 0:13:15,666
启动时间分布

383
00:13:16,346 --> 0:13:18,086
我们还讨论了卡顿的发生

384
00:13:18,086 --> 0:13:19,906
以及卡顿时长

385
00:13:20,926 --> 0:13:22,356
我们也提到了

386
00:13:22,436 --> 0:13:23,816
时间加权表示的比特率

387
00:13:23,816 --> 0:13:25,716
可以很好地表示

388
00:13:25,716 --> 0:13:27,946
整个会话的媒体质量

389
00:13:27,946 --> 0:13:29,526
最后 你可能希望

390
00:13:29,526 --> 0:13:30,916
尽可能降低

391
00:13:30,916 --> 0:13:32,806
失败会话的百分比

392
00:13:36,716 --> 0:13:39,066
请记住 并非所有的 KPI

393
00:13:39,066 --> 0:13:41,606
都可以在会话中进行比较

394
00:13:42,246 --> 0:13:44,256
一个例子就是

395
00:13:44,256 --> 0:13:46,476
AVPlayerFoundation

396
00:13:46,476 --> 0:13:48,696
使用屏幕上的 AVPlayer 层大小

397
00:13:48,916 --> 0:13:51,116
来评估 HLS 的模糊变体

398
00:13:51,686 --> 0:13:53,246
例如 

399
00:13:53,336 --> 0:13:55,556
如果你有 10 个 ATP 的内容

400
00:13:55,556 --> 0:13:57,486
它可能不会显示在 200 像素的视图上

401
00:13:57,486 --> 0:13:58,856
但这并不意味着

402
00:13:58,856 --> 0:14:01,486
用户体验了很差的图像质量

403
00:13:58,856 --> 0:14:01,486
用户体验了很差的图像质量

404
00:14:02,026 --> 0:14:03,826
接下怎么做

405
00:14:03,966 --> 0:14:05,366
我们建议你

406
00:14:05,366 --> 0:14:07,276
收集附加的上下文信息

407
00:14:07,346 --> 0:14:08,886
以及流化度量

408
00:14:09,466 --> 0:14:10,876
这将允许你

409
00:14:10,926 --> 0:14:12,556
稍后在对 App 

410
00:14:12,776 --> 0:14:14,296
有意义的类中

411
00:14:14,296 --> 0:14:15,106
对回放会话进行分区

412
00:14:16,396 --> 0:14:18,726
作为 HLS 目录示例的一部分

413
00:14:18,726 --> 0:14:20,306
本节的示例代码

414
00:14:20,306 --> 0:14:21,786
可在 Apple 开发人员

415
00:14:21,786 --> 0:14:23,136
网站上获得

416
00:14:24,276 --> 0:14:26,776
现在 请允许我欢迎 Zhenheng Li

417
00:14:26,776 --> 0:14:28,026
她将与你们讨论

418
00:14:28,026 --> 0:14:29,636
如何提高 HLS 的性能

419
00:14:29,636 --> 0:14:29,976
谢谢大家

420
00:14:30,516 --> 0:14:34,666
[ 掌声 ]

421
00:14:35,166 --> 0:14:43,626
&gt;&gt; 谢谢 Emil 大家好

422
00:14:43,736 --> 0:14:44,816
我是 Zhenheng

423
00:14:45,376 --> 0:14:50,236
我们已经讨论了

424
00:14:50,556 --> 0:14:52,636
所有用户最关心的 KPI

425
00:14:53,256 --> 0:14:55,166
在这部分的讨论中

426
00:14:55,246 --> 0:14:57,076
我们将着重探讨如何

427
00:14:57,076 --> 0:14:57,416
改进这些 API

428
00:14:57,456 --> 0:15:00,376
我们将在三个方面进行更深入的研究

429
00:14:57,456 --> 0:15:00,376
我们将在三个方面进行更深入的研究

430
00:15:00,976 --> 0:15:04,036
第一 如何减少启动时间

431
00:15:05,136 --> 0:15:07,486
第二 如何调查和

432
00:15:07,486 --> 0:15:08,346
避免卡顿

433
00:15:09,186 --> 0:15:11,736
第三 如何调查和

434
00:15:11,736 --> 0:15:12,906
避免错误

435
00:15:13,506 --> 0:15:14,276
让我们开始吧

436
00:15:15,756 --> 0:15:18,166
什么可以导致播放延迟开始呢

437
00:15:19,006 --> 0:15:20,596
下面是用户

438
00:15:20,596 --> 0:15:23,056
从点按播放键

439
00:15:23,056 --> 0:15:25,536
到视频开始的操作示例

440
00:15:27,096 --> 0:15:28,606
App 创建每个资源

441
00:15:28,606 --> 0:15:31,026
并开始对资源进行检查

442
00:15:31,026 --> 0:15:33,756
以确定资源的时长

443
00:15:34,146 --> 0:15:37,226
和可授予的媒体选项

444
00:15:38,106 --> 0:15:40,016
下载主播放列表

445
00:15:40,516 --> 0:15:42,526
和 [ 音质不清晰 ] 播放列表

446
00:15:42,526 --> 0:15:44,946
需要在设备和

447
00:15:45,136 --> 0:15:47,656
内容服务器之间来回运行几次

448
00:15:48,606 --> 0:15:53,696
然后 App 会创建 AVPlayer 和 AVPlayerItem

449
00:15:54,646 --> 0:15:55,426
开始缓冲

450
00:15:56,966 --> 0:15:59,096
有时 缓冲会被中断

451
00:15:59,096 --> 0:16:01,716
内容被加密

452
00:15:59,096 --> 0:16:01,716
内容被加密

453
00:16:02,606 --> 0:16:04,386
它需要在设备

454
00:16:04,436 --> 0:16:06,216
和密钥服务器之间

455
00:16:06,216 --> 0:16:07,846
进行几次往返

456
00:16:07,846 --> 0:16:08,776
以获取解密密钥

457
00:16:09,576 --> 0:16:11,256
一旦密钥被获取

458
00:16:12,876 --> 0:16:14,306
缓冲便会恢复

459
00:16:15,046 --> 0:16:17,756
然而 它也可能再次被中断

460
00:16:18,346 --> 0:16:20,846
假设这个 App 提供了一个特性

461
00:16:20,936 --> 0:16:22,986
可以从之前播放的

462
00:16:22,986 --> 0:16:24,506
断点处恢复

463
00:16:25,546 --> 0:16:27,816
App 为用户

464
00:16:27,816 --> 0:16:28,876
在播放器上

465
00:16:28,916 --> 0:16:31,116
设置一个 sic 时间[ 音质不清晰 ]

466
00:16:32,096 --> 0:16:34,366
播放器将丢弃

467
00:16:34,366 --> 0:16:36,396
现有的缓冲区

468
00:16:36,396 --> 0:16:37,966
并从新的位置开始下载

469
00:16:38,656 --> 0:16:39,856
第 100 个片段

470
00:16:41,776 --> 0:16:43,516
它还可能再一次被打断

471
00:16:44,026 --> 0:16:47,246
用户在 App 中

472
00:16:47,326 --> 0:16:49,356
拥有语言首选项设置

473
00:16:50,186 --> 0:16:52,316
她或他更喜欢西班牙语

474
00:16:53,226 --> 0:16:56,966
因此 App 在 PlayerItem 上

475
00:16:57,996 --> 0:16:59,656
设置 MediaSelection

476
00:16:59,656 --> 0:17:01,906
丢弃现有的音频缓冲区

477
00:16:59,656 --> 0:17:01,906
丢弃现有的音频缓冲区

478
00:17:01,906 --> 0:17:05,266
播放器开始下载不同的语言变量

479
00:17:05,266 --> 0:17:08,736
几秒钟后

480
00:17:08,736 --> 0:17:11,965
PlayerItem 通知 isPlaybackLikeToKeepUp

481
00:17:11,996 --> 0:17:14,626
App 设置一个速率

482
00:17:15,376 --> 0:17:17,746
播放开始 并从断点继续

483
00:17:18,465 --> 0:17:20,856
这一段时间 用户都在等待

484
00:17:22,165 --> 0:17:28,266
所以正如我们所看到的启动

485
00:17:28,266 --> 0:17:30,686
以及在设备 内容服务器

486
00:17:31,076 --> 0:17:33,436
和密钥服务器之间运行

487
00:17:33,896 --> 0:17:34,796
还有 AVPlayer 和

488
00:17:35,326 --> 0:17:37,726
App 之间的往返

489
00:17:37,726 --> 0:17:39,556
均需要一些耗时的操作

490
00:17:40,156 --> 0:17:42,236
通常 AVPlayer 和 App

491
00:17:42,236 --> 0:17:43,266
在不同的进程中

492
00:17:44,446 --> 0:17:46,176
那么 App 如何

493
00:17:46,516 --> 0:17:48,506
测量时间成本和启动时间呢

494
00:17:49,536 --> 0:17:52,776
它可以测量在 API 调用

495
00:17:52,776 --> 0:17:55,426
与 Player/PlayerItem

496
00:17:55,426 --> 0:17:56,936
状态更改通知之间

497
00:17:57,156 --> 0:17:58,916
所花费的时间

498
00:17:59,516 --> 0:18:02,836
每个 PlayerItem 也提供

499
00:17:59,516 --> 0:18:02,836
每个 PlayerItem 也提供

500
00:18:02,936 --> 0:18:05,546
访问日志中的启动时间

501
00:18:06,146 --> 0:18:09,416
这个时间是

502
00:18:09,456 --> 0:18:11,986
由 AVPlayeritem 测量的

503
00:18:11,986 --> 0:18:13,476
只表示缓存的时间

504
00:18:14,506 --> 0:18:15,816
它从开始媒体下载时开始测量

505
00:18:15,816 --> 0:18:17,896
并在第一个播放

506
00:18:17,896 --> 0:18:20,376
被选定开始时结束

507
00:18:21,676 --> 0:18:23,366
我们的用户希望视频快速启动

508
00:18:23,366 --> 0:18:26,876
最多几秒钟内完成

509
00:18:27,366 --> 0:18:29,546
有很多方法可以做到这一点

510
00:18:30,236 --> 0:18:33,606
一种方法是

511
00:18:33,606 --> 0:18:36,006
我们可以在用户点按播放键之前

512
00:18:36,826 --> 0:18:39,886
将一些操作移动到另一个阶段

513
00:18:40,676 --> 0:18:43,776
例如 可以将 AV 资源创建

514
00:18:44,556 --> 0:18:46,266
和检查移出

515
00:18:46,966 --> 0:18:50,376
密钥获取可以被移出

516
00:18:51,756 --> 0:18:54,456
因此 当用户开始视频播放时

517
00:18:54,456 --> 0:18:58,616
等待的时间会更少

518
00:18:59,296 --> 0:19:00,886
那么我们将这些操作

519
00:18:59,296 --> 0:19:00,886
那么我们将这些操作

520
00:19:00,886 --> 0:19:01,866
移到哪里呢

521
00:19:03,916 --> 0:19:06,156
当你的用户正在查看

522
00:19:06,156 --> 0:19:09,286
视频目录或视频信息时

523
00:19:09,776 --> 0:19:11,336
在用户决定播放之前

524
00:19:12,356 --> 0:19:15,026
就可以提前

525
00:19:15,026 --> 0:19:17,696
创建并检查 AV 资源了

526
00:19:17,916 --> 0:19:19,926
去年我们引入了

527
00:19:19,926 --> 0:19:21,446
AVContentKeySession 的 API

528
00:19:22,346 --> 0:19:25,646
这个新的 API 将媒体负载

529
00:19:25,646 --> 0:19:27,056
与密钥获取分离开来

530
00:19:27,596 --> 0:19:29,836
它为 App 提供了

531
00:19:29,836 --> 0:19:31,326
对密钥管理的全面控制

532
00:19:31,926 --> 0:19:35,336
它提供了优化密钥获取的方法

533
00:19:35,336 --> 0:19:39,316
例如将多个密钥请求打包回

534
00:19:39,816 --> 0:19:40,686
密钥服务器

535
00:19:41,566 --> 0:19:43,346
如果你碰巧采用

536
00:19:43,346 --> 0:19:45,906
AVContentKeySession

537
00:19:45,906 --> 0:19:47,686
并花费几个小时的工程时间

538
00:19:48,566 --> 0:19:50,886
你的用户将会注意到

539
00:19:50,886 --> 0:19:52,356
启动时间变得更快

540
00:19:53,476 --> 0:19:56,136
现在我们已经将创建 AV 资源

541
00:19:56,186 --> 0:19:58,436
和密钥获取的工作

542
00:19:58,436 --> 0:19:59,316
从启动时间中移出

543
00:19:59,896 --> 0:20:03,256
那么剩下的主要是

544
00:19:59,896 --> 0:20:03,256
那么剩下的主要是

545
00:20:03,306 --> 0:20:05,906
AVPlayerItem 缓冲时间

546
00:20:05,906 --> 0:20:08,576
以及 AVPlayer

547
00:20:08,576 --> 0:20:10,286
和 App 之间的通信时间

548
00:20:11,356 --> 0:20:14,686
通常情况下 

549
00:20:14,906 --> 0:20:18,266
由于播放查找或媒体选项等等因素

550
00:20:19,176 --> 0:20:20,346
App 可以避免缓冲

551
00:20:20,906 --> 0:20:24,036
我们甚至可以尝试

552
00:20:24,036 --> 0:20:26,736
减少播放器

553
00:20:26,736 --> 0:20:28,136
和 App 之间的往返次数

554
00:20:29,186 --> 0:20:31,646
这样 启动时间将进一步减少

555
00:20:33,056 --> 0:20:33,806
我们来看一下

556
00:20:34,386 --> 0:20:38,386
当你创建 AVPlayerItem 时

557
00:20:38,996 --> 0:20:42,246
如果你知道

558
00:20:42,246 --> 0:20:44,016
用户打算在哪里开始回放

559
00:20:45,056 --> 0:20:47,176
请设置 PlayerItem 上的当前时间

560
00:20:47,846 --> 0:20:49,106
如果你知道媒体选项

561
00:20:49,106 --> 0:20:51,476
都是如何设置的

562
00:20:51,476 --> 0:20:53,966
比如要下载哪一种语言进行播放

563
00:20:53,966 --> 0:20:56,956
那么在你将 AVPlayerItem 放置到

564
00:20:56,956 --> 0:20:58,906
播放器上之前也要设置它

565
00:20:59,806 --> 0:21:01,456
AVPlayer 也是如此

566
00:20:59,806 --> 0:21:01,456
AVPlayer 也是如此

567
00:21:02,006 --> 0:21:03,946
一旦用户点按播放键

568
00:21:05,106 --> 0:21:07,336
在为 AVPlayerItem

569
00:21:07,336 --> 0:21:11,406
开始下载之前设置速率

570
00:21:12,086 --> 0:21:13,496
因此 只要 PlayerItem

571
00:21:13,496 --> 0:21:16,586
有足够的内容播放

572
00:21:16,586 --> 0:21:18,176
播放就会自动开始

573
00:21:19,016 --> 0:21:22,386
总而言之

574
00:21:22,646 --> 0:21:23,366
即在缓冲之前设置 AVPlayer

575
00:21:24,486 --> 0:21:27,476
在将 PlayerItem 设置到播放器之前

576
00:21:28,366 --> 0:21:31,646
设置 AVPlayer速率

577
00:21:31,696 --> 0:21:36,096
很多 App 都提供了一个特性

578
00:21:36,096 --> 0:21:38,626
即允许用户

579
00:21:39,176 --> 0:21:41,696
选择多个视频

580
00:21:41,746 --> 0:21:43,936
然后一个接一个地播放

581
00:21:43,936 --> 0:21:45,576
比如狂热地观看电视节目

582
00:21:46,756 --> 0:21:48,636
我们已经看到了

583
00:21:48,636 --> 0:21:50,986
例如每个视频分配一个播放器和一个 PlayerItem

584
00:21:50,986 --> 0:21:52,266
的这种实现

585
00:21:52,846 --> 0:21:54,616
每个新视频都

586
00:21:54,746 --> 0:21:57,036
需要一个启动缓冲时间

587
00:21:57,706 --> 0:21:59,686
你可以使用 AVQueuePlayer

588
00:22:00,236 --> 0:22:02,956
以减少新视频的

589
00:22:02,956 --> 0:22:03,936
缓冲时间

590
00:22:05,576 --> 0:22:07,916
创建多个 PlayerItem

591
00:22:08,426 --> 0:22:10,706
将它们全部包含在播放队列中

592
00:22:11,256 --> 0:22:14,356
在播放器

593
00:22:14,356 --> 0:22:17,796
播放当前项目的过程中

594
00:22:17,796 --> 0:22:19,186
当媒体下载结束时

595
00:22:19,186 --> 0:22:22,246
播放器将开始

596
00:22:22,246 --> 0:22:23,626
下载下一个项目

597
00:22:24,226 --> 0:22:26,016
同时当前项目仍在播放

598
00:22:27,346 --> 0:22:30,666
因此 一旦当前事件

599
00:22:30,666 --> 0:22:32,656
播放到最后

600
00:22:32,706 --> 0:22:34,916
下一个 PlayerItem 将立即开始播放

601
00:22:35,526 --> 0:22:39,446
因此一定要使用 AVQueuePlayer

602
00:22:39,446 --> 0:22:42,086
来播放多个项目

603
00:22:42,086 --> 0:22:44,826
并提前将第二个 AVPlayerItem 编入队列

604
00:22:47,406 --> 0:22:48,266
那么还剩下些什么呢

605
00:22:49,516 --> 0:22:50,266
缓冲时间

606
00:22:51,446 --> 0:22:55,086
首先 什么决定了网络缓冲时间

607
00:22:55,696 --> 0:22:56,566
有四个因素

608
00:22:57,796 --> 0:23:00,886
变量的选择

609
00:22:57,796 --> 0:23:00,886
变量的选择

610
00:23:01,136 --> 0:23:04,556
内容的比特率

611
00:23:04,556 --> 0:23:06,696
播放列表目标时长

612
00:23:06,696 --> 0:23:09,276
当然还有 网络带宽

613
00:23:09,806 --> 0:23:13,706
让我们看几个

614
00:23:13,706 --> 0:23:14,776
缓冲时间的例子

615
00:23:16,286 --> 0:23:19,016
首先 这是一个简单的主播放列表

616
00:23:19,396 --> 0:23:22,236
它将一个 ATP 视频

617
00:23:22,236 --> 0:23:24,386
设置在 5 mbps 左右的下载速度

618
00:23:24,386 --> 0:23:26,656
假设网络带宽

619
00:23:26,656 --> 0:23:28,986
在 6 mbps 左右

620
00:23:28,986 --> 0:23:31,896
我们的目标时长是 10 秒

621
00:23:32,886 --> 0:23:35,116
在大多数情况下

622
00:23:35,186 --> 0:23:38,556
PlayerItem 会在通知播放

623
00:23:39,446 --> 0:23:41,216
需要开始之前

624
00:23:41,216 --> 0:23:42,526
缓冲一个片段

625
00:23:42,636 --> 0:23:46,336
然而 相同的主播放列表

626
00:23:46,336 --> 0:23:48,816
在几乎相同的网络条件下

627
00:23:48,816 --> 0:23:51,676
用户可能会

628
00:23:51,676 --> 0:23:54,246
观察到较慢的启动

629
00:23:55,996 --> 0:23:58,216
请记住 原因是

630
00:23:58,216 --> 0:24:00,256
网络带宽改变

631
00:23:58,216 --> 0:24:00,256
网络带宽改变

632
00:24:00,256 --> 0:24:02,366
内容比特率也会改变

633
00:24:02,776 --> 0:24:04,506
在这种情况下

634
00:24:04,506 --> 0:24:06,176
有一些片段需要更长的时间来下载

635
00:24:06,566 --> 0:24:08,106
因此播放器需要更久的时间来启动

636
00:24:09,086 --> 0:24:11,946
要解决这个问题

637
00:24:13,286 --> 0:24:14,916
提供一个低比特率的变量

638
00:24:14,916 --> 0:24:15,236
可能会有所帮助

639
00:24:16,896 --> 0:24:19,936
播放器就可以选择

640
00:24:20,426 --> 0:24:23,586
调低比特率并更快启动

641
00:24:24,336 --> 0:24:26,056
当其他信息均缺失时

642
00:24:26,056 --> 0:24:29,026
所列出的第一个变量

643
00:24:29,026 --> 0:24:30,946
将是你的启动变量

644
00:24:31,586 --> 0:24:35,536
在这个例子中 有两个变量

645
00:24:36,216 --> 0:24:37,466
在相同的网络条件下

646
00:24:37,506 --> 0:24:40,106
首先列出较低比特率的变量

647
00:24:40,636 --> 0:24:43,666
播放器将会启动更快

648
00:24:45,196 --> 0:24:50,086
并且在网络带宽

649
00:24:50,086 --> 0:24:52,646
足够的情况下快速切换

650
00:24:53,936 --> 0:24:58,466
总之 为了减少网络缓冲时间

651
00:24:58,466 --> 0:25:00,306
我们应该明智地

652
00:24:58,466 --> 0:25:00,306
我们应该明智地

653
00:25:00,306 --> 0:25:01,736
选择初始变量

654
00:25:02,936 --> 0:25:04,516
更低的内容比特率

655
00:25:05,266 --> 0:25:07,676
意味着更短的缓冲时间

656
00:25:07,676 --> 0:25:09,826
但也同时是视频质量的折衷

657
00:25:11,406 --> 0:25:13,486
如果你正在提供

658
00:25:13,486 --> 0:25:16,366
多种媒体格式

659
00:25:16,496 --> 0:25:19,646
例如 HDR 和 SDR 视频

660
00:25:19,646 --> 0:25:22,976
或者立体声音频和多声道音频

661
00:25:22,976 --> 0:25:26,276
请确保每种媒体格式的初始版本

662
00:25:26,316 --> 0:25:29,246
都处于类似的比特率级别

663
00:25:29,246 --> 0:25:32,216
以便你的用户

664
00:25:32,216 --> 0:25:33,706
将拥有类似的体验

665
00:25:34,066 --> 0:25:36,166
无论他们进行

666
00:25:36,166 --> 0:25:37,826
何种类型的观看设置

667
00:25:38,536 --> 0:25:42,216
这就是我要讲的关于减少启动时间的内容

668
00:25:42,746 --> 0:25:43,926
我们的视频已经开始播放了

669
00:25:45,556 --> 0:25:47,566
现在我们来谈谈卡顿

670
00:25:48,526 --> 0:25:51,186
需要明确的是

671
00:25:51,186 --> 0:25:53,396
尤其是当网络带宽特别低的时候

672
00:25:53,396 --> 0:25:55,456
卡顿就可能发生

673
00:25:56,176 --> 0:25:58,116
所以在这部分的演讲中

674
00:25:58,116 --> 0:25:59,796
让我们关注如何调查卡顿

675
00:25:59,906 --> 0:26:03,636
以及如何改进 或避免卡顿

676
00:25:59,906 --> 0:26:03,636
以及如何改进 或避免卡顿

677
00:26:04,196 --> 0:26:08,696
App 是如何调查卡顿的呢

678
00:26:09,246 --> 0:26:12,616
App 应该一直在

679
00:26:12,616 --> 0:26:14,416
监听卡顿通知

680
00:26:16,296 --> 0:26:20,286
App 也应该检查

681
00:26:20,286 --> 0:26:23,096
AVPlayer.status 

682
00:26:23,456 --> 0:26:27,546
例如 isPlayBackLikelyToKeepUp

683
00:26:27,546 --> 0:26:30,106
AVPlayerItem 还提供

684
00:26:30,106 --> 0:26:32,006
错误日志和访问日志

685
00:26:32,576 --> 0:26:33,666
当暂停发生时

686
00:26:33,906 --> 0:26:37,846
App 应该时刻关注

687
00:26:37,846 --> 0:26:38,996
对那些日志的检查

688
00:26:39,546 --> 0:26:43,896
接下来让我们看两个卡顿的例子

689
00:26:44,716 --> 0:26:49,096
首先 App 已收到了卡顿通知

690
00:26:49,616 --> 0:26:51,956
也应该收到了

691
00:26:52,076 --> 0:26:54,116
错误日志

692
00:26:55,126 --> 0:26:58,236
错误注释会告诉你

693
00:26:58,396 --> 0:27:00,886
所发生的事情的详细信息

694
00:26:58,396 --> 0:27:00,886
所发生的事情的详细信息

695
00:27:01,456 --> 0:27:03,266
在这种情况下它的记录是

696
00:27:03,266 --> 0:27:05,206
“15 秒内未收到媒体文件”

697
00:27:06,406 --> 0:27:09,056
App 检查访问日志

698
00:27:09,056 --> 0:27:12,286
以找出发生卡顿时

699
00:27:12,346 --> 0:27:14,856
AVPlayer 正在播放的内容

700
00:27:15,846 --> 0:27:17,886
它会记录详细的信息

701
00:27:17,886 --> 0:27:20,046
比如播放器

702
00:27:20,046 --> 0:27:23,186
正在播放什么内容以及 URI

703
00:27:24,506 --> 0:27:26,036
indicatedBitrate 指的是

704
00:27:26,036 --> 0:27:27,046
内容比特率

705
00:27:27,416 --> 0:27:30,656
这里具体是 36 mbps

706
00:27:30,656 --> 0:27:31,756
它是一个 4K 内容

707
00:27:32,606 --> 0:27:35,166
observedBitrate 指的是

708
00:27:35,356 --> 0:27:36,766
当前的网络带宽

709
00:27:37,066 --> 0:27:39,616
这里具体是 2.8 mbps

710
00:27:40,236 --> 0:27:45,276
显然网络带宽跟不上

711
00:27:45,316 --> 0:27:47,286
内容比特率

712
00:27:47,916 --> 0:27:50,536
所以要处理变化的网络情况

713
00:27:50,536 --> 0:27:53,686
请记得提供一套

714
00:27:53,686 --> 0:27:54,706
完整的比特率层

715
00:27:55,226 --> 0:27:57,436
你的一些用户的网络

716
00:27:57,436 --> 0:27:58,966
可能连接较慢

717
00:27:58,966 --> 0:28:01,336
或者你的用户可能正忙

718
00:27:58,966 --> 0:28:01,336
或者你的用户可能正忙

719
00:28:01,336 --> 0:28:03,306
比如在查看视频时

720
00:28:03,596 --> 0:28:04,886
使用蜂窝网络

721
00:28:05,746 --> 0:28:07,236
如果你提供多种视频

722
00:28:07,236 --> 0:28:09,846
和多种媒体格式

723
00:28:10,616 --> 0:28:12,216
那么每个编解码组合

724
00:28:12,216 --> 0:28:15,826
都需要自己的一组层

725
00:28:16,806 --> 0:28:20,166
并不是所有的卡顿

726
00:28:20,166 --> 0:28:21,096
都是由于网络环境造成的

727
00:28:22,356 --> 0:28:23,416
让我们来看看这个

728
00:28:24,536 --> 0:28:26,986
卡顿发生了

729
00:28:26,986 --> 0:28:28,486
然而错误日志中却有了不同的记录

730
00:28:29,786 --> 0:28:32,756
“播放列表文件

731
00:28:32,756 --> 0:28:34,956
连续两次没有改变”

732
00:28:35,976 --> 0:28:37,976
如果你在那个时候检查访问日志

733
00:28:37,976 --> 0:28:40,986
播放器正在线播放

734
00:28:42,336 --> 0:28:44,456
indicatedBitrate 很低

735
00:28:44,996 --> 0:28:48,296
内容比特率是 400 kbps

736
00:28:48,296 --> 0:28:51,546
而网络带宽是 3.7 mbps

737
00:28:51,956 --> 0:28:53,646
这看起来像是一个

738
00:28:53,646 --> 0:28:54,586
内容交付问题

739
00:28:57,016 --> 0:28:59,156
因此 为了减少或避免

740
00:28:59,156 --> 0:29:01,696
由于内容交付而造成的卡顿

741
00:28:59,156 --> 0:29:01,696
由于内容交付而造成的卡顿

742
00:29:01,696 --> 0:29:04,626
内容服务器和 CDN

743
00:29:04,626 --> 0:29:07,166
必须无延迟地

744
00:29:07,166 --> 0:29:08,246
交付媒体文件 片段和密钥

745
00:29:09,196 --> 0:29:11,776
至少每一个目标时长

746
00:29:11,776 --> 0:29:15,446
更新实时播放列表 CDN 缓存

747
00:29:15,666 --> 0:29:17,576
必须加以配置

748
00:29:17,576 --> 0:29:22,416
以交付最新的播放列表 避免过时

749
00:29:22,466 --> 0:29:26,086
同步播放列表之间的不连续序号

750
00:29:27,996 --> 0:29:29,466
使用正确的 HTTP 状态代码

751
00:29:29,466 --> 0:29:33,096
进而清楚地指示服务器端失败

752
00:29:35,416 --> 0:29:36,856
这就是所有关于卡顿的内容

753
00:29:37,336 --> 0:29:38,026
那么错误又是怎么回事

754
00:29:39,206 --> 0:29:42,066
我们应该如何调查错误呢

755
00:29:42,066 --> 0:29:44,746
有几种方法可供选择

756
00:29:45,906 --> 0:29:49,346
我们有来自 AVPlayerItem 的

757
00:29:49,346 --> 0:29:51,226
错误日志和访问日志

758
00:29:52,186 --> 0:29:55,486
我们也有来自

759
00:29:55,486 --> 0:29:57,196
每个 Player 和

760
00:29:57,516 --> 0:30:00,506
PlayerItem 的错误属性

761
00:29:57,516 --> 0:30:00,506
PlayerItem 的错误属性

762
00:30:02,016 --> 0:30:04,066
此外 我们还为你们提供了

763
00:30:04,066 --> 0:30:06,176
一些媒体验证工具

764
00:30:06,486 --> 0:30:08,926
来检测内容问题

765
00:30:09,536 --> 0:30:11,076
让我们一个一个地看

766
00:30:11,686 --> 0:30:15,086
AVPlayerItemErrorLog

767
00:30:15,086 --> 0:30:17,696
Emil 对此已经与我们讨论了一些 

768
00:30:19,146 --> 0:30:21,056
这种类型的错误日志

769
00:30:21,056 --> 0:30:22,906
表明网络或

770
00:30:22,906 --> 0:30:25,186
内容格式存在问题

771
00:30:25,746 --> 0:30:28,136
然而这些问题并不总是致命的

772
00:30:28,726 --> 0:30:31,666
当错误被指示出来时

773
00:30:31,856 --> 0:30:33,406
播放可能是完全

774
00:30:33,626 --> 0:30:34,446
没问题的

775
00:30:36,516 --> 0:30:40,356
但是 App 显示了在错误注释中的检查结果

776
00:30:40,706 --> 0:30:42,796
以查找更多的细节

777
00:30:42,796 --> 0:30:46,486
比如这个我们之前见过的

778
00:30:46,486 --> 0:30:48,766
“15 秒内未收到媒体文件”

779
00:30:49,476 --> 0:30:54,286
这表明你的用户可能已经

780
00:30:54,286 --> 0:30:55,096
或者即将观察到卡顿

781
00:30:56,916 --> 0:31:00,206
下一个是 HTTP 错误

782
00:30:56,916 --> 0:31:00,206
下一个是 HTTP 错误

783
00:31:00,206 --> 0:31:01,336
它记录“文件没有找到”

784
00:31:01,916 --> 0:31:03,716
这表明了

785
00:31:03,716 --> 0:31:04,566
内容交付的问题

786
00:31:05,376 --> 0:31:07,696
用户可能会观察到音频丢失或视频丢失 

787
00:31:07,916 --> 0:31:13,926
甚至同时观察到这两者

788
00:31:13,926 --> 0:31:15,516
[ 音质不清晰 ] 变量的

789
00:31:15,516 --> 0:31:16,206
指定带宽

790
00:31:16,576 --> 0:31:17,836
这个很有趣

791
00:31:18,096 --> 0:31:19,856
它指示了卡顿的风险

792
00:31:20,236 --> 0:31:22,546
然而当错误被指示时

793
00:31:22,616 --> 0:31:25,296
播放可能没有问题

794
00:31:25,836 --> 0:31:28,336
它意味着

795
00:31:28,336 --> 0:31:30,466
某些片段的比特率

796
00:31:30,466 --> 0:31:32,556
比主播放列表中指定的比特率要高

797
00:31:32,996 --> 0:31:36,276
最后一个例子

798
00:31:37,046 --> 0:31:39,626
加密格式错误 “不支持的加密格式”

799
00:31:40,026 --> 0:31:42,316
这可能指示了一个

800
00:31:42,316 --> 0:31:43,926
播放失败

801
00:31:44,816 --> 0:31:47,926
当我们有 AVPlayer 和 PlayerItem 的错误时

802
00:31:47,926 --> 0:31:49,556
所有列出的这些

803
00:31:49,556 --> 0:31:52,006
以及这里没有提到的

804
00:31:52,006 --> 0:31:54,966
其他错误信息 都非常有用

805
00:31:55,816 --> 0:31:57,046
让我们看一下

806
00:31:59,016 --> 0:32:00,476
App 应该观察

807
00:31:59,016 --> 0:32:00,476
App 应该观察

808
00:32:01,076 --> 0:32:03,476
AVPlayerItem.status

809
00:32:04,006 --> 0:32:05,576
和 AVPlayerItem 的错误属性

810
00:32:05,576 --> 0:32:08,086
以查找此类错误

811
00:32:09,146 --> 0:32:10,816
这些便是致命错误

812
00:32:11,916 --> 0:32:13,056
当错误被指示

813
00:32:13,406 --> 0:32:15,106
且播放已经终止时

814
00:32:15,106 --> 0:32:17,586
我们该怎么办呢

815
00:32:18,306 --> 0:32:19,626
我们如何找出原因

816
00:32:20,206 --> 0:32:22,016
这有一个例子

817
00:32:22,806 --> 0:32:24,576
App 观察到

818
00:32:24,986 --> 0:32:27,706
PlayerItem.status 

819
00:32:27,706 --> 0:32:29,346
已经改成失败状态

820
00:32:30,286 --> 0:32:35,636
然后 App 对 AVPlayer 的错误属性

821
00:32:35,636 --> 0:32:37,766
和 AVPlayerItem的 错误日志

822
00:32:37,766 --> 0:32:39,416
进行检查

823
00:32:41,376 --> 0:32:45,766
这个就是

824
00:32:45,766 --> 0:32:46,716
PlayerItem 的错误属性

825
00:32:47,146 --> 0:32:49,056
它提供了一些有用的信息

826
00:32:50,206 --> 0:32:52,296
来自于 AVFoundationErrorDomain 的

827
00:32:52,296 --> 0:32:53,026
错误代码

828
00:32:53,746 --> 0:32:56,536
它还提供了一些提示

829
00:32:56,536 --> 0:32:59,246
检查了 AVPlayerItem 的

830
00:32:59,246 --> 0:33:00,516
错误日志

831
00:32:59,246 --> 0:33:00,516
错误日志

832
00:33:01,526 --> 0:33:05,446
相对应的 AVPlayer 错误日志

833
00:33:05,446 --> 0:33:07,766
可以提供更多细节

834
00:33:08,506 --> 0:33:10,706
它会告诉你日期 时间

835
00:33:10,706 --> 0:33:13,786
以及在什么 URI 上

836
00:33:13,786 --> 0:33:14,396
有什么类型的错误

837
00:33:14,396 --> 0:33:18,066
在这里错误是“不支持的加密格式”

838
00:33:19,056 --> 0:33:22,226
它还告诉你

839
00:33:22,566 --> 0:33:24,496
当发生错误时

840
00:33:24,606 --> 0:33:29,356
设备处于哪种类型的网络接口

841
00:33:29,606 --> 0:33:31,776
下一种错误类型 HDCP

842
00:33:33,006 --> 0:33:34,796
如果你正在提供

843
00:33:34,796 --> 0:33:38,086
需要 HDCP 保护的内容

844
00:33:38,086 --> 0:33:39,666
你的 App 应该注意

845
00:33:39,666 --> 0:33:43,186
这个十分长的属性名

846
00:33:43,736 --> 0:33:45,776
IsOutputObscuredDueTo

847
00:33:46,076 --> 0:33:48,066
InsufficientExternalProtection

848
00:33:49,236 --> 0:33:50,566
此属性的值变化为 2 时

849
00:33:50,566 --> 0:33:52,726
意味着三件事情

850
00:33:54,166 --> 0:33:57,996
当前项目需要外部保护

851
00:33:58,726 --> 0:34:01,696
设备不满足保护级别

852
00:33:58,726 --> 0:34:01,696
设备不满足保护级别

853
00:34:02,326 --> 0:34:04,506
用户将会观察到

854
00:34:04,506 --> 0:34:06,566
或已经观察到视频丢失

855
00:34:06,566 --> 0:34:07,866
例如通过 [ 音质不清晰 ]

856
00:34:08,866 --> 0:34:13,255
为了避免这个问题

857
00:34:13,255 --> 0:34:16,565
你的主播放列表应该提供

858
00:34:16,565 --> 0:34:19,226
至少一个不需要 HDCP

859
00:34:19,226 --> 0:34:21,926
作为回退的变量

860
00:34:22,626 --> 0:34:24,656
请记住 并不是所有的用户

861
00:34:24,876 --> 0:34:27,326
都有 HDCP 支持的

862
00:34:27,326 --> 0:34:28,065
查看设置

863
00:34:28,996 --> 0:34:31,436
App 用户界面

864
00:34:31,436 --> 0:34:33,706
应反映属性的变化

865
00:34:33,706 --> 0:34:35,116
以便及时提示用户

866
00:34:36,496 --> 0:34:38,766
许多播放问题

867
00:34:38,766 --> 0:34:40,616
都是由创建内容引起的

868
00:34:41,176 --> 0:34:43,396
比如在 [ 音质不清晰 ] 切换时

869
00:34:43,396 --> 0:34:46,166
声音和视频出现了

870
00:34:46,376 --> 0:34:46,916
中断或故障

871
00:34:48,085 --> 0:34:49,076
除了我们讨论过的

872
00:34:49,076 --> 0:34:50,815
错误调查

873
00:34:50,815 --> 0:34:53,146
和错误处理之外

874
00:34:53,146 --> 0:34:55,755
我们还建议你们使用

875
00:34:55,755 --> 0:34:58,656
我们的媒体流验证器

876
00:34:58,656 --> 0:35:01,256
它可以在开发者网站中获得

877
00:34:58,656 --> 0:35:01,256
它可以在开发者网站中获得

878
00:35:02,026 --> 0:35:03,826
这就是我今天想说的全部内容

879
00:35:04,606 --> 0:35:08,806
现在让我们欢迎我的同事 Eryk Vershen

880
00:35:10,136 --> 0:35:12,006
来谈谈如何以正确的方式

881
00:35:12,676 --> 0:35:14,166
编写主播放列表 谢谢大家

882
00:35:15,516 --> 0:35:18,500
[ 掌声 ]

883
00:35:25,046 --> 0:35:25,976
&gt;&gt; 谢谢你 Zhenheng

884
00:35:26,346 --> 0:35:27,336
我是 Eryk Vershen

885
00:35:27,336 --> 0:35:29,566
我是一名从事于 HLS 工具的工程师

886
00:35:29,566 --> 0:35:31,596
我们已经讨论了

887
00:35:31,596 --> 0:35:33,606
如何衡量

888
00:35:33,826 --> 0:35:35,406
流媒体 App 的性能表现

889
00:35:35,406 --> 0:35:36,236
以及如何解决相关问题

890
00:35:36,746 --> 0:35:38,166
然而 获得成功且无错误的

891
00:35:38,786 --> 0:35:40,436
播放体验的

892
00:35:40,436 --> 0:35:42,656
关键元素之一

893
00:35:42,656 --> 0:35:44,636
是确保你的

894
00:35:44,636 --> 0:35:45,566
主播放列表是正确的

895
00:35:46,246 --> 0:35:47,826
主播放列表

896
00:35:47,826 --> 0:35:49,216
使得播放器

897
00:35:49,216 --> 0:35:51,426
在播放之前和播放期间

898
00:35:51,476 --> 0:35:53,226
做出明智的决定

899
00:35:53,756 --> 0:35:55,196
所以确保它的正确是十分重要的

900
00:35:56,466 --> 0:35:57,846
让我们开始吧 我的建议是

901
00:35:58,046 --> 0:35:59,246
不不 这只是个玩笑

902
00:35:59,646 --> 0:36:01,066
我想我需要给你们

903
00:35:59,646 --> 0:36:01,066
我想我需要给你们

904
00:36:01,066 --> 0:36:02,356
更多的背景知识

905
00:36:02,356 --> 0:36:03,476
来理解 Roger 的意思

906
00:36:04,426 --> 0:36:06,086
我们希望你们

907
00:36:06,086 --> 0:36:07,706
把所有的编码选项

908
00:36:07,756 --> 0:36:09,666
都放到你的主播放列表中

909
00:36:09,666 --> 0:36:11,796
并且尽可能完整地描述它们

910
00:36:12,556 --> 0:36:14,296
假设你在问我这个问题

911
00:36:14,846 --> 0:36:17,876
这是一个关键问题

912
00:36:17,876 --> 0:36:19,296
也是你们必须解决的主要问题

913
00:36:20,316 --> 0:36:22,866
首先 你需要记住

914
00:36:22,866 --> 0:36:24,396
一个主播放列表不能仅仅因为有效

915
00:36:24,396 --> 0:36:26,826
就被判定是正确的

916
00:36:27,446 --> 0:36:28,686
我就见过

917
00:36:28,686 --> 0:36:30,596
像这样的主播放列表

918
00:36:30,996 --> 0:36:32,576
它在语法上是正确的

919
00:36:32,576 --> 0:36:33,756
却几乎没用

920
00:36:34,356 --> 0:36:36,616
好的 那这个怎么样

921
00:36:36,616 --> 0:36:37,956
它有更多的变量

922
00:36:38,816 --> 0:36:41,386
好一点 但还是很糟糕

923
00:36:41,856 --> 0:36:42,836
我们还能播放这个视频吗

924
00:36:42,836 --> 0:36:43,986
它使用什么编解码器

925
00:36:44,266 --> 0:36:45,156
它是 HDR 吗

926
00:36:45,156 --> 0:36:46,166
它是 60 fps 吗

927
00:36:46,916 --> 0:36:48,316
你需要告诉我们一切

928
00:36:48,316 --> 0:36:50,096
我们想要你告诉我们一切

929
00:36:50,716 --> 0:36:52,256
比如 平均带宽

930
00:36:52,536 --> 0:36:54,486
平均带宽

931
00:36:54,486 --> 0:36:56,396
使我们能够更好地决定

932
00:36:56,396 --> 0:36:57,616
切换到哪个变量

933
00:36:58,446 --> 0:36:59,396
它能更好地预测

934
00:36:59,396 --> 0:37:00,626
我们是否能

935
00:36:59,396 --> 0:37:00,626
我们是否能

936
00:37:00,626 --> 0:37:01,306
与流保持同步

937
00:37:02,276 --> 0:37:04,276
编解码器使我们能够过滤掉

938
00:37:04,276 --> 0:37:06,416
不能播放的东西

939
00:37:06,416 --> 0:37:08,806
分辨率使我们能够

940
00:37:08,806 --> 0:37:10,156
对选择哪种变量

941
00:37:10,156 --> 0:37:11,236
做出正确的决定

942
00:37:12,086 --> 0:37:13,806
请记住 直到我们需要

943
00:37:13,806 --> 0:37:15,776
我们才会查看

944
00:37:15,776 --> 0:37:17,436
媒体播放列表或媒体片段

945
00:37:17,816 --> 0:37:19,246
所以你需要提前在你的

946
00:37:19,466 --> 0:37:20,846
主播放列表中

947
00:37:20,846 --> 0:37:21,406
告诉我们一些事情

948
00:37:22,616 --> 0:37:25,406
这是一个简单的

949
00:37:25,406 --> 0:37:26,266
主播放列表的例子

950
00:37:26,766 --> 0:37:28,306
这个播放列表使得播放器

951
00:37:28,306 --> 0:37:30,266
适应带宽的变化

952
00:37:30,266 --> 0:37:31,876
并正确地选择

953
00:37:31,876 --> 0:37:32,816
使用哪种变量

954
00:37:33,756 --> 0:37:36,436
我们在这里所做的一切

955
00:37:36,436 --> 0:37:38,066
对于用户来说都是不可见的

956
00:37:38,066 --> 0:37:39,896
它只会让流播放得更好

957
00:37:41,156 --> 0:37:43,516
好的 让我们来看一个常见的问题

958
00:37:43,516 --> 0:37:45,546
你的流正在播放

959
00:37:45,546 --> 0:37:46,876
但你没有在快进中看到任何图像

960
00:37:46,876 --> 0:37:48,186
或者 你没有在搓擦条中

961
00:37:48,186 --> 0:37:49,496
看到缩略图

962
00:37:50,826 --> 0:37:52,656
这是 Apple TV 的搓擦条

963
00:37:53,616 --> 0:37:55,356
你可以看到你的内容有多长

964
00:37:55,596 --> 0:37:56,586
你也可以看到你在内容中的位置

965
00:37:56,586 --> 0:37:57,826
以及你想去的位置

966
00:37:58,756 --> 0:37:59,976
为了得到缩略图

967
00:37:59,976 --> 0:38:02,126
你需要给我们一个

968
00:37:59,976 --> 0:38:02,126
你需要给我们一个

969
00:38:02,126 --> 0:38:04,316
I-frame 播放列表

970
00:38:04,356 --> 0:38:06,226
I-frame 播放列表允许我们

971
00:38:06,506 --> 0:38:09,166
在你的 iPad 

972
00:38:09,206 --> 0:38:10,646
或 iPhone 上提供

973
00:38:10,646 --> 0:38:13,526
快进和回放中的图像

974
00:38:14,046 --> 0:38:15,616
为了讨论

975
00:38:15,616 --> 0:38:17,526
I-frame 播放列表

976
00:38:17,616 --> 0:38:18,986
我们首先需要讨论一下

977
00:38:18,986 --> 0:38:19,716
普通视频

978
00:38:20,516 --> 0:38:22,286
这是一种在 HLS 中

979
00:38:22,866 --> 0:38:24,406
可视化常规视频片段的方法

980
00:38:25,076 --> 0:38:26,796
每个段都有

981
00:38:26,796 --> 0:38:28,136
若干帧的内容

982
00:38:28,136 --> 0:38:30,266
所以它有一个总帧数

983
00:38:30,266 --> 0:38:31,776
也有一个特定的平均比特率

984
00:38:31,776 --> 0:38:34,346
这个比特率在每个片段中

985
00:38:34,866 --> 0:38:36,176
都是不同的

986
00:38:36,516 --> 0:38:38,586
由于压缩技术

987
00:38:38,586 --> 0:38:40,096
视频中的大多数帧

988
00:38:40,096 --> 0:38:41,326
只能依照其他帧

989
00:38:41,326 --> 0:38:42,756
进行解码

990
00:38:43,676 --> 0:38:45,436
但是 I-frame

991
00:38:45,436 --> 0:38:47,056
其中的 I 代表的是

992
00:38:47,056 --> 0:38:48,536
内部编码的帧

993
00:38:48,536 --> 0:38:49,876
它们是可独立解码的帧

994
00:38:49,876 --> 0:38:52,126
也是允许其他帧进行解码的基本帧

995
00:38:52,996 --> 0:38:54,846
正如我在这里展示的

996
00:38:54,846 --> 0:38:56,716
在一个片段中

997
00:38:56,716 --> 0:38:58,696
你可能有多个 I-frame

998
00:38:58,696 --> 0:39:02,836
并且 I-frame 不需要

999
00:38:58,696 --> 0:39:02,836
并且 I-frame 不需要

1000
00:39:02,836 --> 0:39:03,826
以固定间隔排列

1001
00:39:05,676 --> 0:39:07,366
I-frame 播放列表

1002
00:39:07,366 --> 0:39:09,036
是一个只指向 I-frame 内容的

1003
00:39:09,036 --> 0:39:10,806
播放列表

1004
00:39:10,806 --> 0:39:12,926
也就是说 它只下载 I-frame 数据

1005
00:39:13,236 --> 0:39:14,786
当我们讨论

1006
00:39:14,786 --> 0:39:16,016
一个 I-frame 的时长时

1007
00:39:16,016 --> 0:39:17,536
我们指的是从这个 I-frame

1008
00:39:17,536 --> 0:39:19,626
到下一个 I-frame 的时间

1009
00:39:20,456 --> 0:39:21,596
我已经将这个特殊的 I-frame 组

1010
00:39:21,596 --> 0:39:23,956
从正常的内容中

1011
00:39:23,956 --> 0:39:24,976
提取出来了

1012
00:39:24,976 --> 0:39:26,986
但是你也可以制作一个

1013
00:39:26,986 --> 0:39:28,156
所谓高密度的

1014
00:39:28,156 --> 0:39:29,066
I-frame 播放列表

1015
00:39:29,996 --> 0:39:31,376
你不能仅仅从

1016
00:39:31,376 --> 0:39:32,886
正常内容中将它提取出来

1017
00:39:32,886 --> 0:39:33,696
相反 你需要刻意地

1018
00:39:33,946 --> 0:39:35,696
用间隔更加均匀的

1019
00:39:35,696 --> 0:39:36,846
I-frame 来制作

1020
00:39:37,516 --> 0:39:38,756
这样会更有效

1021
00:39:38,756 --> 0:39:40,716
它允许我们在快进的时候

1022
00:39:40,716 --> 0:39:42,736
为你提供一个更加平滑的体验

1023
00:39:44,376 --> 0:39:45,576
现在 我给你们看一个

1024
00:39:45,576 --> 0:39:47,866
没有添加 I-frame 的主播放列表

1025
00:39:49,236 --> 0:39:51,956
请注意 I-frame 播放列表

1026
00:39:51,956 --> 0:39:53,816
与普通播放列表的标签

1027
00:39:53,816 --> 0:39:56,336
几乎完全相同

1028
00:39:56,946 --> 0:39:58,656
唯一的区别是

1029
00:39:58,656 --> 0:39:59,906
I-frame 播放列表不支持

1030
00:39:59,906 --> 0:40:01,786
帧速率这个属性

1031
00:39:59,906 --> 0:40:01,786
帧速率这个属性

1032
00:40:02,096 --> 0:40:02,886
因为在那个上下文中

1033
00:40:02,886 --> 0:40:04,136
它没有任何意义

1034
00:40:04,986 --> 0:40:06,166
对于你的 I-frame 播放列表而言

1035
00:40:06,166 --> 0:40:07,936
一个好的测试

1036
00:40:07,936 --> 0:40:08,746
是尝试直接播放它

1037
00:40:09,346 --> 0:40:11,376
也就是说

1038
00:40:11,376 --> 0:40:13,116
将 I-frame 播放列表的 URI

1039
00:40:13,116 --> 0:40:13,846
粘贴到 Safari 浏览器中

1040
00:40:14,316 --> 0:40:16,496
它应该以 1 倍的速度播放

1041
00:40:16,496 --> 0:40:18,136
你会看到 I-frame

1042
00:40:18,136 --> 0:40:20,916
一个接一个地

1043
00:40:20,916 --> 0:40:22,216
在一个缓慢变化的序列中显示

1044
00:40:23,596 --> 0:40:24,886
现在我还要指出

1045
00:40:24,886 --> 0:40:26,266
比特率方面的区别

1046
00:40:27,036 --> 0:40:28,516
请注意 I-frame 的比特率

1047
00:40:28,516 --> 0:40:30,796
比正常的比特率要低得多

1048
00:40:30,936 --> 0:40:33,806
应该一直是这样的

1049
00:40:34,256 --> 0:40:36,326
谈到比特率

1050
00:40:36,616 --> 0:40:39,366
我们已经在 HLS 规范中

1051
00:40:39,436 --> 0:40:40,766
定义了如何计算

1052
00:40:40,766 --> 0:40:41,616
峰值比特率

1053
00:40:42,396 --> 0:40:43,976
一定要这样做

1054
00:40:43,976 --> 0:40:44,986
否则你可能会得到

1055
00:40:45,086 --> 0:40:46,616
片段超过

1056
00:40:46,616 --> 0:40:49,436
指定带宽的错误

1057
00:40:50,026 --> 0:40:52,306
现在 我们不再讨论视频

1058
00:40:52,306 --> 0:40:54,986
将话题转向音频

1059
00:40:55,426 --> 0:40:57,046
对此最常见的问题是

1060
00:40:57,046 --> 0:40:58,606
我如何支持多种语言

1061
00:40:59,306 --> 0:41:00,986
界面是这个样子

1062
00:40:59,306 --> 0:41:00,986
界面是这个样子

1063
00:41:01,296 --> 0:41:03,846
我有一个语言列表

1064
00:41:03,846 --> 0:41:05,146
用户可以从中选择一种语言

1065
00:41:06,336 --> 0:41:08,786
这是一个样本播放列表

1066
00:41:09,036 --> 0:41:10,746
我们所做的就是

1067
00:41:10,746 --> 0:41:13,836
在每个视频变量上

1068
00:41:13,836 --> 0:41:17,356
添加一个

1069
00:41:17,356 --> 0:41:19,976
音频属性

1070
00:41:19,976 --> 0:41:21,966
我们也添加了

1071
00:41:21,966 --> 0:41:22,716
带有组 ID 的媒体标签

1072
00:41:23,126 --> 0:41:27,646
组 ID 是一个标签

1073
00:41:27,646 --> 0:41:30,496
它允许你将音频展示

1074
00:41:30,596 --> 0:41:32,876
与视频变量关联起来

1075
00:41:33,546 --> 0:41:34,996
请注意这两个

1076
00:41:34,996 --> 0:41:37,266
音频版本之间

1077
00:41:37,266 --> 0:41:38,316
有很多不同之处

1078
00:41:38,846 --> 0:41:40,266
就像对待你的变量一样 我们希望你

1079
00:41:40,266 --> 0:41:42,196
尽可能详细地

1080
00:41:42,196 --> 0:41:43,726
描述你的媒体

1081
00:41:44,626 --> 0:41:46,216
在媒体标签上

1082
00:41:46,216 --> 0:41:47,396
有两个属性

1083
00:41:47,396 --> 0:41:49,446
令人们困扰

1084
00:41:49,446 --> 0:41:51,096
那就是 Default 和 Autoselect

1085
00:41:52,306 --> 0:41:56,376
好的 Autoselect 指的是

1086
00:41:56,376 --> 0:41:57,426
播放器中的媒体选择代码

1087
00:41:57,426 --> 0:42:00,576
可以在用户没有

1088
00:41:57,426 --> 0:42:00,576
可以在用户没有

1089
00:42:00,576 --> 0:42:02,596
任何特殊输入的情况下

1090
00:42:02,596 --> 0:42:03,586
进行选择

1091
00:42:04,316 --> 0:42:05,836
大多数情况下

1092
00:42:05,836 --> 0:42:07,436
你会将 Autoselect 设置为 yes

1093
00:42:08,506 --> 0:42:10,066
如果你没有设置

1094
00:42:10,066 --> 0:42:11,156
用户将不得不做出一个明确的选择

1095
00:42:11,156 --> 0:42:13,546
从而进行视频的播放

1096
00:42:15,276 --> 0:42:17,496
另一方面 Default 是指

1097
00:42:17,496 --> 0:42:19,496
当用户没有提供首选语言时

1098
00:42:19,496 --> 0:42:20,916
所进行的选择

1099
00:42:22,216 --> 0:42:23,406
一般来说

1100
00:42:23,406 --> 0:42:25,566
它应该是你的视频的原始语言

1101
00:42:26,066 --> 0:42:27,186
并且 Default

1102
00:42:27,186 --> 0:42:28,986
必须是可自动选择的

1103
00:42:28,986 --> 0:42:30,436
因为系统必须进行选择

1104
00:42:31,136 --> 0:42:33,696
这里的 Default

1105
00:42:33,696 --> 0:42:35,326
与默认的视频变量没有关系

1106
00:42:35,326 --> 0:42:38,426
它是演示组中的默认值

1107
00:42:39,916 --> 0:42:43,166
好的 我有多种语言

1108
00:42:43,166 --> 0:42:44,496
但我真的想要一些

1109
00:42:44,566 --> 0:42:45,496
多声道音频

1110
00:42:45,496 --> 0:42:47,186
我有 5.1 声道音频

1111
00:42:48,126 --> 0:42:50,086
好的 首先要记住的是

1112
00:42:50,086 --> 0:42:52,126
并不是所有的设备

1113
00:42:52,126 --> 0:42:53,156
都能播放多声道音频

1114
00:42:53,516 --> 0:42:56,606
你还需要为用户提供

1115
00:42:56,606 --> 0:42:58,236
立体声选项

1116
00:42:58,826 --> 0:43:00,066
你应该把这件事看成

1117
00:42:58,826 --> 0:43:00,066
你应该把这件事看成

1118
00:43:00,066 --> 0:43:01,676
填满一个矩阵

1119
00:43:02,256 --> 0:43:04,516
你需要拥有

1120
00:43:04,676 --> 0:43:05,796
涵盖每种语言的每种格式

1121
00:43:07,456 --> 0:43:10,296
你可能会说 好吧

1122
00:43:10,296 --> 0:43:14,076
我没有法语版多声道的原版音频

1123
00:43:14,076 --> 0:43:16,206
我没有法语版的 5.1 声道音频

1124
00:43:16,396 --> 0:43:17,616
在这种情况下

1125
00:43:17,616 --> 0:43:19,936
你仍应该把你的立体声内容

1126
00:43:19,936 --> 0:43:22,546
放到那个组中

1127
00:43:23,786 --> 0:43:25,396
你需要填满

1128
00:43:25,396 --> 0:43:26,906
在这个矩阵中的每个槽

1129
00:43:27,586 --> 0:43:31,116
我们再来看一个播放列表

1130
00:43:31,256 --> 0:43:34,666
这个播放列表

1131
00:43:34,666 --> 0:43:36,626
和之前的例子一样

1132
00:43:36,626 --> 0:43:38,256
只是我改变了组 ID

1133
00:43:38,256 --> 0:43:39,566
而且这样没有问题

1134
00:43:39,566 --> 0:43:41,426
因为组 ID 只是用来

1135
00:43:41,426 --> 0:43:43,686
连接音频

1136
00:43:43,686 --> 0:43:44,806
和视频变量的

1137
00:43:45,406 --> 0:43:48,356
我们有了多声道组

1138
00:43:48,356 --> 0:43:50,396
然后我用法语

1139
00:43:50,396 --> 0:43:52,956
把它设置为立体声

1140
00:43:52,956 --> 0:43:54,986
在这你可以看到如何做到这点

1141
00:43:55,566 --> 0:43:58,146
你需要做的是确保

1142
00:43:58,146 --> 0:44:00,306
编解码器标签指示了

1143
00:43:58,146 --> 0:44:00,306
编解码器标签指示了

1144
00:44:00,716 --> 0:44:04,096
所有可能出现在该演示组中的

1145
00:44:04,096 --> 0:44:07,766
不同的编解码器

1146
00:44:08,086 --> 0:44:09,126
请注意 我们需要复制

1147
00:44:09,126 --> 0:44:11,506
我们的视频变量

1148
00:44:12,196 --> 0:44:13,986
现在我们有两个条目

1149
00:44:13,986 --> 0:44:16,186
一个条目指向其中一个音频组

1150
00:44:16,536 --> 0:44:17,416
另一个条目

1151
00:44:17,416 --> 0:44:18,256
则指向另一个音频组

1152
00:44:18,476 --> 0:44:19,286
在后面的幻灯片中

1153
00:44:19,286 --> 0:44:21,596
你会再次看到这种重复

1154
00:44:22,936 --> 0:44:25,856
假设我有几个不同音频比特率的音频

1155
00:44:25,856 --> 0:44:27,566
但不是 5.1 声道的

1156
00:44:27,566 --> 0:44:30,616
我有一些高比特率音频

1157
00:44:30,616 --> 0:44:32,176
而且我知道我需要

1158
00:44:32,176 --> 0:44:35,476
为一些用户提供

1159
00:44:35,786 --> 0:44:36,326
低比特率音频

1160
00:44:36,996 --> 0:44:38,566
所以在展示方面

1161
00:44:38,736 --> 0:44:41,386
和我们之前所谈到的类似

1162
00:44:41,596 --> 0:44:42,636
我们仍然需要一个矩阵

1163
00:44:42,636 --> 0:44:43,676
并用每种语言

1164
00:44:44,046 --> 0:44:45,996
来填充每一个比特率变量

1165
00:44:47,126 --> 0:44:48,606
由于这两者都是 AAC

1166
00:44:48,606 --> 0:44:50,266
我们可以认为它们是相同格式的

1167
00:44:50,706 --> 0:44:52,426
如果我想要另一种格式

1168
00:44:52,886 --> 0:44:55,556
我所做的就是

1169
00:44:55,556 --> 0:44:56,606
扩展这个矩阵

1170
00:44:57,096 --> 0:44:58,306
我想提出一点

1171
00:44:58,306 --> 0:44:59,256
我一直说语言是为了便利

1172
00:44:59,256 --> 0:45:00,296
但是你们应该记住

1173
00:44:59,256 --> 0:45:00,296
但是你们应该记住

1174
00:45:00,296 --> 0:45:01,876
这里涉及的

1175
00:45:01,876 --> 0:45:03,906
唯一的属性是名称属性

1176
00:45:04,466 --> 0:45:06,616
而不是语言属性

1177
00:45:07,056 --> 0:45:09,286
在这个播放列表中

1178
00:45:09,286 --> 0:45:10,726
我不会给你们展示媒体标签

1179
00:45:10,726 --> 0:45:11,776
但我将展示

1180
00:45:11,776 --> 0:45:13,876
带有音频组名称的视频变量

1181
00:45:14,416 --> 0:45:16,426
你需要将你的低比特率视频

1182
00:45:16,426 --> 0:45:18,006
与你的低比特率音频相关联

1183
00:45:18,006 --> 0:45:21,476
同时将高比特率视频

1184
00:45:21,476 --> 0:45:22,936
与高比特率音频相关联

1185
00:45:23,986 --> 0:45:26,346
你总是需要将它们像这样分开

1186
00:45:27,036 --> 0:45:29,316
如果你有一套

1187
00:45:29,316 --> 0:45:30,556
配有低比特率音频的

1188
00:45:30,556 --> 0:45:31,866
完整视频变量

1189
00:45:31,866 --> 0:45:33,716
和一套配有高比特率音频的

1190
00:45:33,716 --> 0:45:35,016
完整视频变量

1191
00:45:35,016 --> 0:45:36,156
那么这种情况是完全错误的

1192
00:45:36,156 --> 0:45:37,786
因为如果你这样做

1193
00:45:37,786 --> 0:45:39,876
你就会在

1194
00:45:39,876 --> 0:45:41,816
高视频比特率和低音频比特率变量

1195
00:45:41,816 --> 0:45:42,726
之间跳跃

1196
00:45:43,236 --> 0:45:49,376
在这里 我添加了 AC3 内容

1197
00:45:50,006 --> 0:45:51,876
再次注意

1198
00:45:51,876 --> 0:45:54,446
我们必须复制我们的视频变量条目

1199
00:45:54,446 --> 0:45:56,176
但是它们指向

1200
00:45:56,176 --> 0:45:57,346
相同的视频播放列表

1201
00:45:58,196 --> 0:45:59,926
也要注意视频变量中的

1202
00:45:59,926 --> 0:46:02,536
比特率也在变化

1203
00:45:59,926 --> 0:46:02,536
比特率也在变化

1204
00:46:02,826 --> 0:46:03,926
这是因为

1205
00:46:03,926 --> 0:46:06,486
与视频变量

1206
00:46:06,486 --> 0:46:07,496
相关的比特率

1207
00:46:07,496 --> 0:46:08,966
是视频本身

1208
00:46:08,966 --> 0:46:11,806
以及任何相关展示的比特率

1209
00:46:12,406 --> 0:46:16,056
现在让我们

1210
00:46:16,056 --> 0:46:18,406
再次讨论一下视频

1211
00:46:18,406 --> 0:46:19,896
因为我想要具有多个视频格式

1212
00:46:19,896 --> 0:46:22,756
我想要 HEVC

1213
00:46:23,186 --> 0:46:25,366
这样我就可以以同样的比特率

1214
00:46:25,366 --> 0:46:26,816
获得更好的质量

1215
00:46:26,816 --> 0:46:28,196
或者我想要杜比视界（Dolby Vision）

1216
00:46:28,196 --> 0:46:29,266
这样我就可以获得 HDR 内容

1217
00:46:29,806 --> 0:46:33,936
同样 我们需要填一个矩阵

1218
00:46:34,116 --> 0:46:35,556
在这种情况下

1219
00:46:35,556 --> 0:46:37,886
无论我们选择哪种视频格式

1220
00:46:37,886 --> 0:46:39,406
我们都需要设置一组

1221
00:46:39,496 --> 0:46:40,136
合理的变量

1222
00:46:40,626 --> 0:46:42,576
所以这里的行是基于质量的层

1223
00:46:42,576 --> 0:46:46,006
我们需要

1224
00:46:46,006 --> 0:46:47,906
用每一层中每一个格式的变量

1225
00:46:47,906 --> 0:46:49,466
来填充矩阵

1226
00:46:50,846 --> 0:46:52,956
我们不需要

1227
00:46:52,956 --> 0:46:57,496
在旧格式中填写

1228
00:46:57,496 --> 0:46:58,686
更高的层

1229
00:46:58,686 --> 0:46:59,906
你可以节省一下

1230
00:47:00,336 --> 0:47:02,876
但与音频类似

1231
00:47:02,876 --> 0:47:04,586
并不是所有设备

1232
00:47:04,586 --> 0:47:06,516
都支持杜比视界（Dolby Vision）等功能

1233
00:47:06,516 --> 0:47:10,476
因此你需要提供一个 H.264 变体作为备用

1234
00:47:11,476 --> 0:47:12,586
有一个主要的点需要记住

1235
00:47:12,586 --> 0:47:13,806
在每一列中

1236
00:47:13,806 --> 0:47:16,066
你都需要让比特率形成一个良好的递进

1237
00:47:16,616 --> 0:47:19,266
这个播放列表

1238
00:47:19,266 --> 0:47:20,876
有点太大了

1239
00:47:20,876 --> 0:47:21,946
不能在一张幻灯片上显示

1240
00:47:21,946 --> 0:47:22,806
所以我要把它分成三张幻灯片

1241
00:47:23,276 --> 0:47:25,686
这一部分向你展示 H.264 的变量

1242
00:47:26,336 --> 0:47:29,946
在这张幻灯片中 我们展示了 HEVC 变量

1243
00:47:30,026 --> 0:47:31,906
请注意 任何变量

1244
00:47:31,906 --> 0:47:34,206
都有其指向的

1245
00:47:34,206 --> 0:47:36,046
视频播放列表

1246
00:47:36,046 --> 0:47:37,926
这是我们的杜比视界（Dolby Vision）变量

1247
00:47:37,926 --> 0:47:40,016
这里的一切变量

1248
00:47:40,016 --> 0:47:40,956
都有相同的音频组

1249
00:47:41,336 --> 0:47:42,976
如果我们想要

1250
00:47:42,976 --> 0:47:45,216
含有多种音频格式

1251
00:47:45,216 --> 0:47:47,146
我们需要为每种音频格式

1252
00:47:47,146 --> 0:47:49,466
复制视频变量

1253
00:47:49,796 --> 0:47:51,326
同样 这不会增加

1254
00:47:51,326 --> 0:47:53,206
视频播放列表的数量

1255
00:47:53,646 --> 0:47:54,566
只会增加

1256
00:47:54,566 --> 0:47:56,666
播放列表中条目的数量

1257
00:47:57,696 --> 0:48:00,016
好的 我们几乎完成了

1258
00:47:57,696 --> 0:48:00,016
好的 我们几乎完成了

1259
00:48:00,436 --> 0:48:02,366
最后一点关于一般字幕

1260
00:48:02,366 --> 0:48:03,316
和可隐藏式字幕

1261
00:48:03,316 --> 0:48:05,946
你可能可以猜到

1262
00:48:05,946 --> 0:48:06,536
它是如何工作的

1263
00:48:07,316 --> 0:48:09,676
我们的变量

1264
00:48:10,206 --> 0:48:12,316
需要指向我们正在使用的

1265
00:48:12,446 --> 0:48:13,616
一般字幕和可隐藏式字幕

1266
00:48:14,096 --> 0:48:15,946
所以我们需要

1267
00:48:15,946 --> 0:48:18,686
为视频变量添加一个属性

1268
00:48:18,686 --> 0:48:20,166
我们也需要描述这个展示

1269
00:48:20,826 --> 0:48:24,146
请注意可隐藏式字幕的展示

1270
00:48:24,146 --> 0:48:25,456
没有 URI 属性

1271
00:48:26,526 --> 0:48:28,456
这告诉系统

1272
00:48:28,456 --> 0:48:30,396
可隐藏式字幕的数据

1273
00:48:30,616 --> 0:48:33,516
存在于在视频内容中

1274
00:48:33,516 --> 0:48:34,396
而不是在单独的播放列表中

1275
00:48:34,946 --> 0:48:38,216
那么没错

1276
00:48:38,216 --> 0:48:38,816
“正确的做法是

1277
00:48:38,816 --> 0:48:39,456
把一切都交给我们”

1278
00:48:39,616 --> 0:48:41,666
现在你应该更加明白我的意思了

1279
00:48:42,476 --> 0:48:44,836
好的 请允许我快速地总结一下

1280
00:48:44,836 --> 0:48:46,186
我们今天的演讲

1281
00:48:47,036 --> 0:48:48,236
Emil 谈到了

1282
00:48:48,236 --> 0:48:49,976
关键性能指标

1283
00:48:49,976 --> 0:48:51,406
关于如何获取或计算这些值

1284
00:48:51,406 --> 0:48:52,156
以及它们的含义

1285
00:48:52,776 --> 0:48:55,246
Zhenheng 谈到了

1286
00:48:55,246 --> 0:48:57,476
减少启动时间的方法

1287
00:48:57,476 --> 0:49:00,426
以及如何解决

1288
00:48:57,476 --> 0:49:00,426
以及如何解决

1289
00:49:00,426 --> 0:49:01,206
卡顿和其他错误

1290
00:49:01,336 --> 0:49:02,896
我则谈到了

1291
00:49:02,896 --> 0:49:03,756
如何制作主播放列表

1292
00:49:04,216 --> 0:49:06,156
我想简单地提一下

1293
00:49:06,156 --> 0:49:07,586
HLS 验证工具

1294
00:49:08,266 --> 0:49:10,466
它们可以发现

1295
00:49:10,466 --> 0:49:12,316
很多与主播放列表和媒体播放列表有关的问题

1296
00:49:12,566 --> 0:49:14,446
值得你花时间去使用

1297
00:49:15,616 --> 0:49:17,816
一如既往地 你可以从

1298
00:49:17,816 --> 0:49:20,316
WWDC App 或者

1299
00:49:20,366 --> 0:49:21,496
开发者网站中获得更多信息

1300
00:49:21,946 --> 0:49:22,906
这就是我们今天要讲的全部内容

1301
00:49:23,136 --> 0:49:24,706
非常感谢各位的关注和时间

1302
00:49:25,508 --> 0:49:27,508
[ 掌声 ]
