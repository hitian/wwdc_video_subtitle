1
00:00:16,750 --> 0:00:21,588
（测试新特性 演讲403）

2
00:00:25,659 --> 0:00:26,660
上午好

3
00:00:32,833 --> 0:00:35,736
欢迎参加演讲403

4
00:00:36,436 --> 0:00:38,005
我是Honza Dvorsky

5
00:00:38,305 --> 0:00:41,542
我将和我的同事

6
00:00:43,677 --> 0:00:45,179
首先我们将会讨论

7
00:00:45,245 --> 0:00:48,315
Xcode 9.3中的

8
00:00:49,550 --> 0:00:53,887
然后讨论测试选择和和排序

9
00:00:54,721 --> 0:00:57,090
最后 Ethan将会上台

10
00:00:57,157 --> 0:01:01,228
谈谈如何并行运行测试以加速测试

11
00:00:57,157 --> 0:01:01,228
谈谈如何并行运行测试以加速测试

12
00:01:02,963 --> 0:01:04,665
我们首先来看代码覆盖

13
00:01:06,733 --> 0:01:09,770
在Xcode 9.3中

14
00:01:10,470 --> 0:01:14,308
性能和准确性有了很大改进

15
00:01:14,875 --> 0:01:19,146
我们能够添加新功能

16
00:01:19,213 --> 0:01:22,082
测试目标 以帮助改进代码覆盖

17
00:01:23,984 --> 0:01:26,820
我们创建了一个新的

18
00:01:28,155 --> 0:01:29,356
最后同样重要的是

19
00:01:29,423 --> 0:01:32,860
我们在源代码编辑器中

20
00:01:34,027 --> 0:01:35,829
让我们来详细了解

21
00:01:36,730 --> 0:01:37,664
首先

22
00:01:37,731 --> 0:01:40,901
让你们感受一下

23
00:01:41,134 --> 0:01:44,171
我们在一大型内部Apple项目上

24
00:01:46,240 --> 0:01:49,610
为了解速度提升幅度

25
00:01:49,676 --> 0:01:52,579
在源代码编辑器中加载和显示

26
00:01:54,414 --> 0:01:57,918
在Xcode 9中

27
00:01:59,920 --> 0:02:03,223
在Xcode 9.3中

28
00:01:59,920 --> 0:02:03,223
在Xcode 9.3中

29
00:02:03,290 --> 0:02:05,325
速度提高95%

30
00:02:12,132 --> 0:02:15,202
但是我们希望覆盖文件变得更小

31
00:02:15,469 --> 0:02:17,938
因为Xcode能够写出很多内容

32
00:02:18,205 --> 0:02:20,307
如果你经常运行测试

33
00:02:21,208 --> 0:02:24,545
我很高兴告诉大家

34
00:02:26,180 --> 0:02:29,416
Xcode 9的覆盖文件大小

35
00:02:29,983 --> 0:02:33,921
文件很大 但是请注意

36
00:02:33,987 --> 0:02:35,556
大型项目

37
00:02:37,758 --> 0:02:41,695
Xcode 9.3写出的文件大小

38
00:02:47,167 --> 0:02:48,502
我相信你们会喜欢这一点

39
00:02:48,569 --> 0:02:50,938
如果你们维护一个连续集成机器

40
00:02:51,205 --> 0:02:53,473
或者磁盘空间不足

41
00:02:54,508 --> 0:02:56,176
但是最大的优点不仅在于

42
00:02:56,243 --> 0:02:59,746
覆盖文件变得更小

43
00:02:59,980 --> 0:03:02,249
它们比以前更准确了

44
00:02:59,980 --> 0:03:02,249
它们比以前更准确了

45
00:03:03,817 --> 0:03:05,619
头文件就是这样的例子之一

46
00:03:06,019 --> 0:03:09,756
Xcode 9不能正确收集

47
00:03:10,257 --> 0:03:13,393
对于使用C++的代码库来说

48
00:03:13,760 --> 0:03:14,962
因为在C++语言中

49
00:03:15,028 --> 0:03:18,432
有相当一部分可执行代码

50
00:03:19,700 --> 0:03:22,603
如果这个问题影响到你

51
00:03:22,669 --> 0:03:25,873
Xcode现在能够正确地

52
00:03:25,939 --> 0:03:28,342
的代码覆盖

53
00:03:29,576 --> 0:03:32,012
现在 让我们来看代码覆盖功能

54
00:03:33,447 --> 0:03:35,315
第一个功能是目标选择

55
00:03:36,583 --> 0:03:37,851
这是一个新选项

56
00:03:37,918 --> 0:03:41,221
不仅控制启用或禁用代码覆盖

57
00:03:41,822 --> 0:03:43,123
并且控制何时启用

58
00:03:43,190 --> 0:03:46,894
可以控制包含哪些目标

59
00:03:48,028 --> 0:03:51,698
如果你的项目使用第三方代码

60
00:03:52,065 --> 0:03:54,468
或者你在一家公司工作

61
00:03:54,535 --> 0:03:56,170
其他团队提供已经测试的框架

62
00:03:56,236 --> 0:04:00,040
这项功能就很有用

63
00:03:56,236 --> 0:04:00,040
这项功能就很有用

64
00:04:02,309 --> 0:04:06,380
在方案测试计划中

65
00:04:06,680 --> 0:04:07,814
能自定义包含的目标

66
00:04:08,782 --> 0:04:12,886
这意味代码覆盖可以包含所有目标

67
00:04:13,187 --> 0:04:14,788
也可以手动挑选其中一部分

68
00:04:17,224 --> 0:04:19,793
为了改进工作流程

69
00:04:19,860 --> 0:04:22,362
我们创建了一个名为xccov的

70
00:04:24,231 --> 0:04:27,301
可以很容易地自动

71
00:04:27,601 --> 0:04:31,238
它产生人工可识读

72
00:04:32,339 --> 0:04:36,910
在更高层面

73
00:04:37,878 --> 0:04:40,480
我已经多次提到代码覆盖数据

74
00:04:40,547 --> 0:04:42,449
让我们来看底层原理

75
00:04:43,917 --> 0:04:46,353
启用代码覆盖后

76
00:04:46,687 --> 0:04:48,789
Xcode生成两个文件

77
00:04:49,723 --> 0:04:51,758
首先是覆盖报告

78
00:04:52,025 --> 0:04:55,662
或xccovreport文件扩展

79
00:04:56,630 --> 0:05:01,568
包含每个目标、源文件

80
00:04:56,630 --> 0:05:01,568
包含每个目标、源文件

81
00:05:03,403 --> 0:05:05,439
第二个是覆盖存档文件

82
00:05:05,806 --> 0:05:10,310
在报告中包含每个文件的

83
00:05:13,347 --> 0:05:17,117
这些覆盖文件位于

84
00:05:17,618 --> 0:05:18,819
此外

85
00:05:18,886 --> 0:05:22,523
如果将结果包路径标识符

86
00:05:23,056 --> 0:05:26,193
这些文件也会被放入结果捆绑包之中

87
00:05:28,262 --> 0:05:29,696
让我们来看一个例子

88
00:05:30,030 --> 0:05:35,402
我们看Hello World

89
00:05:36,170 --> 0:05:38,805
可以看到每个目标

90
00:05:39,873 --> 0:05:42,276
甚至每个方法的

91
00:05:43,177 --> 0:05:44,411
总体覆盖情况

92
00:05:45,679 --> 0:05:46,613
当然

93
00:05:47,614 --> 0:05:50,050
通过传递正确的旗帜标识

94
00:05:50,884 --> 0:05:54,321
可以在JSON中

95
00:05:56,023 --> 0:05:58,892
这样就可以与其他工具集成

96
00:06:00,060 --> 0:06:02,329
可以看到 xccov非常灵活

97
00:06:02,396 --> 0:06:04,998
因此我鼓励你们阅读它的文档

98
00:06:06,834 --> 0:06:09,770
现在 我们来讨论使用方法…

99
00:06:09,837 --> 0:06:14,041
可在命令行上查看代码覆盖

100
00:06:14,107 --> 0:06:16,944
在源代码旁边查看

101
00:06:18,512 --> 0:06:20,981
可以控制是否显示代码覆盖

102
00:06:21,048 --> 0:06:24,918
只需选择编辑器

103
00:06:28,589 --> 0:06:29,723
启用之后

104
00:06:29,790 --> 0:06:32,593
将在源代码编辑器中

105
00:06:33,293 --> 0:06:34,628
整行高亮显示

106
00:06:34,695 --> 0:06:37,698
当鼠标悬停在右侧的

107
00:06:38,765 --> 0:06:41,201
能够最方便地查看

108
00:06:41,268 --> 0:06:43,871
你的哪些代码已经测试

109
00:06:44,204 --> 0:06:45,839
哪些仍然需要进一步测试

110
00:06:47,674 --> 0:06:50,477
现在 让我来实际演示

111
00:07:01,221 --> 0:07:03,924
这里有一个项目

112
00:07:04,324 --> 0:07:05,626
这是一个简单的消息app

113
00:07:05,692 --> 0:07:08,595
这是去年开发的iOS版本

114
00:07:08,962 --> 0:07:11,298
今年 我想要开发一个Mac版本

115
00:07:12,232 --> 0:07:15,769
我想要在iOS和Mac版本

116
00:07:15,836 --> 0:07:18,472
因此将它全部放入

117
00:07:19,373 --> 0:07:21,808
今天 我的目标是探索

118
00:07:21,875 --> 0:07:24,578
甚至改进这个框架的代码覆盖

119
00:07:25,612 --> 0:07:26,580
现在

120
00:07:26,647 --> 0:07:29,449
我不会收集代码覆盖

121
00:07:30,484 --> 0:07:34,755
选择方案

122
00:07:35,422 --> 0:07:36,690
进入测试操作

123
00:07:37,858 --> 0:07:39,092
进入选项

124
00:07:40,694 --> 0:07:43,397
在这里 我启用代码覆盖

125
00:07:47,601 --> 0:07:50,504
现在我进入产品测试

126
00:07:51,338 --> 0:07:56,310
现在 创建我的框架

127
00:07:56,643 --> 0:07:57,978
然后运行我的测试

128
00:07:59,947 --> 0:08:02,282
现在 测试完成

129
00:07:59,947 --> 0:08:02,282
现在 测试完成

130
00:08:02,349 --> 0:08:03,984
我们转到报告导航器

131
00:08:04,885 --> 0:08:06,787
查看最新的报告覆盖报告

132
00:08:08,755 --> 0:08:11,425
我可以看到

133
00:08:11,725 --> 0:08:15,262
两个目标 Mac app和框架

134
00:08:15,963 --> 0:08:20,267
现在 Mac app仅用作

135
00:08:20,634 --> 0:08:23,437
我并不担心低代码覆盖率

136
00:08:23,504 --> 0:08:27,241
事实上 我并不想

137
00:08:28,709 --> 0:08:31,011
因此我可以再次编辑方案

138
00:08:33,647 --> 0:08:34,881
在测试操作中

139
00:08:36,683 --> 0:08:39,318
并不收集所有目标的覆盖率

140
00:08:39,886 --> 0:08:41,655
我更改为只覆盖一些目标

141
00:08:42,890 --> 0:08:45,425
这为我提供一个硬性覆盖列表

142
00:08:45,759 --> 0:08:48,462
仅添加我感兴趣的目标

143
00:08:48,529 --> 0:08:49,630
也就是框架

144
00:08:53,800 --> 0:08:55,536
再次运行测试

145
00:08:59,540 --> 0:09:01,642
查看经过更新的覆盖率报告

146
00:08:59,540 --> 0:09:01,642
查看经过更新的覆盖率报告

147
00:09:03,010 --> 0:09:03,911
现在你可以看到

148
00:09:03,977 --> 0:09:06,713
覆盖率报告中只有框架的结果

149
00:09:06,780 --> 0:09:07,814
这正是我想要的

150
00:09:08,182 --> 0:09:10,617
现在 我专注于这个目标

151
00:09:11,618 --> 0:09:14,421
看 覆盖率现在是84%

152
00:09:14,821 --> 0:09:17,157
这还不错

153
00:09:17,758 --> 0:09:20,694
为了理解需要更多地

154
00:09:21,094 --> 0:09:22,596
我将会显示目标的覆盖率

155
00:09:23,697 --> 0:09:27,467
看到第一个文件的覆盖率仅有66%

156
00:09:28,468 --> 0:09:31,205
我点击这里的箭头

157
00:09:33,907 --> 0:09:34,741
在这里

158
00:09:35,209 --> 0:09:37,344
我将查看我的本地服务器类

159
00:09:38,245 --> 0:09:39,213
在右侧

160
00:09:39,279 --> 0:09:42,216
我可以看到每个代码块的执行次数

161
00:09:42,649 --> 0:09:43,717
因此我可以看到

162
00:09:43,784 --> 0:09:47,888
测试所覆盖的类可执行代码

163
00:09:47,955 --> 0:09:48,789
这很不错

164
00:09:49,356 --> 0:09:52,826
不幸的是 我的一个常用功能

165
00:09:52,893 --> 0:09:56,463
完全没有被我的测试调用

166
00:09:57,731 --> 0:10:01,068
为了解决这个问题

167
00:09:57,731 --> 0:10:01,068
为了解决这个问题

168
00:10:03,737 --> 0:10:05,038
我添加一个新测试

169
00:10:07,741 --> 0:10:11,578
此测试将一些消息

170
00:10:11,645 --> 0:10:13,680
然后 我获得最近的消息

171
00:10:13,747 --> 0:10:15,916
正如我所预期的

172
00:10:17,351 --> 0:10:19,086
在添加新测试之后

173
00:10:19,586 --> 0:10:21,488
我再次运行测试

174
00:10:25,959 --> 0:10:29,830
很好 测试完成

175
00:10:30,497 --> 0:10:35,369
现在 查看我的框架

176
00:10:35,435 --> 0:10:36,870
这正是我想要的

177
00:10:38,272 --> 0:10:41,575
来看我如何使用

178
00:10:41,642 --> 0:10:43,777
来专注于一些目标的测试

179
00:10:44,444 --> 0:10:48,115
然后 我使用覆盖率文件

180
00:10:48,715 --> 0:10:49,550
最后

181
00:10:49,616 --> 0:10:52,252
我在源代码编辑器中

182
00:10:52,319 --> 0:10:55,322
来了解我的哪些代码部分

183
00:10:56,723 --> 0:10:59,026
这就是Xcode中的

184
00:11:06,433 --> 0:11:08,635
讲完代码覆盖之后

185
00:11:09,736 --> 0:11:12,039
让我们来看Xcode 10中的

186
00:11:13,040 --> 0:11:14,942
首先 来看我们如何更好地

187
00:11:15,576 --> 0:11:17,611
选择和排序我们的测试

188
00:11:19,346 --> 0:11:20,581
为什么这很重要？

189
00:11:20,981 --> 0:11:26,253
你的套件中的所有测试

190
00:11:26,620 --> 0:11:30,591
每次运行测试时

191
00:11:30,657 --> 0:11:31,925
所有1000个测试单元

192
00:11:32,226 --> 0:11:35,929
但是在夜间 可能只需要

193
00:11:36,864 --> 0:11:38,065
现在 可以通过禁用

194
00:11:38,131 --> 0:11:40,601
来实现这个目的

195
00:11:42,469 --> 0:11:45,739
方案编码禁用测试列表

196
00:11:46,039 --> 0:11:49,009
这样XE测试就知道

197
00:11:49,910 --> 0:11:52,012
这会伴随着一个有趣的副作用

198
00:11:52,346 --> 0:11:54,047
无论你何时编写一个新测试

199
00:11:54,114 --> 0:11:56,350
它都会被自动添加到

200
00:11:56,416 --> 0:11:58,519
所有方案之中

201
00:11:59,186 --> 0:12:00,587
但是 如果你不想要这样做

202
00:11:59,186 --> 0:12:00,587
但是 如果你不想要这样做

203
00:12:00,654 --> 0:12:04,491
你必须检查所有方案

204
00:12:05,759 --> 0:12:06,827
因此在Xcode 10中

205
00:12:06,894 --> 0:12:10,631
我们引入新的方案模式

206
00:12:12,633 --> 0:12:14,635
如果将方案切换到此模式

207
00:12:14,701 --> 0:12:18,005
只有手动挑选的测试

208
00:12:21,208 --> 0:12:24,044
可以在方案编辑器测试操作中

209
00:12:25,279 --> 0:12:28,448
在测试目标列表中

210
00:12:28,515 --> 0:12:29,349
你可以声明

211
00:12:29,416 --> 0:12:32,486
方案是否应该自动包括新测试

212
00:12:33,320 --> 0:12:34,888
这样 一些方案

213
00:12:34,955 --> 0:12:37,357
可以继续运行

214
00:12:37,758 --> 0:12:41,128
其他方案仅运行

215
00:12:43,397 --> 0:12:44,631
我们讨论了

216
00:12:44,698 --> 0:12:48,035
如何更好地控制

217
00:12:48,335 --> 0:12:51,271
但是测试顺序也很重要

218
00:12:53,106 --> 0:12:56,543
默认情况下 Xcode中的

219
00:12:57,444 --> 0:12:59,913
这意味着 除非更名测试

220
00:12:59,980 --> 0:13:01,782
否则它们始终

221
00:12:59,980 --> 0:13:01,782
否则它们始终

222
00:13:02,816 --> 0:13:04,952
这种决定方法是一把双刃剑

223
00:13:05,686 --> 0:13:07,487
这样很容易遗漏漏洞

224
00:13:07,554 --> 0:13:11,925
因为一个测试显式地

225
00:13:13,460 --> 0:13:15,629
让我们来看这一个例子

226
00:13:16,697 --> 0:13:18,765
假设你有测试A、B和C

227
00:13:19,399 --> 0:13:22,135
它们按照此顺序运行

228
00:13:22,603 --> 0:13:24,738
但是详细地观察测试

229
00:13:25,072 --> 0:13:27,908
你会发现测试A

230
00:13:29,176 --> 0:13:32,579
然后 测试B会运行

231
00:13:33,647 --> 0:13:36,984
然后测试C运行

232
00:13:40,721 --> 0:13:44,258
这些测试获得通过

233
00:13:44,791 --> 0:13:48,695
--如果打乱它们的顺序

234
00:13:49,796 --> 0:13:51,365
然后再次运行

235
00:13:51,431 --> 0:13:54,801
测试B可能会将数据

236
00:13:54,868 --> 0:13:56,370
你的测试将会失败

237
00:13:57,738 --> 0:14:00,574
为了防止这样的问题

238
00:13:57,738 --> 0:14:00,574
为了防止这样的问题

239
00:14:00,641 --> 0:14:04,912
必须始终正确设置测试

240
00:14:06,313 --> 0:14:10,050
不仅会让它变得更可靠

241
00:14:10,117 --> 0:14:12,953
而且让你的测试独立于

242
00:14:13,921 --> 0:14:16,690
在开发和调试期间

243
00:14:18,525 --> 0:14:19,660
为了帮助你确保

244
00:14:19,726 --> 0:14:22,729
测试之间不存在

245
00:14:23,130 --> 0:14:26,767
在Xcode 10中 我们引入

246
00:14:28,268 --> 0:14:29,536
如果启用此模式

247
00:14:29,603 --> 0:14:33,006
在每次运行之前

248
00:14:34,341 --> 0:14:37,144
如果在此模式下

249
00:14:37,211 --> 0:14:40,747
就能够更加确信

250
00:14:42,649 --> 0:14:45,552
可以在方案编辑器中

251
00:14:45,853 --> 0:14:47,888
与前面讲过的其他特性一样

252
00:14:50,324 --> 0:14:53,360
这些就是Xcode 10中

253
00:14:55,796 --> 0:14:58,131
现在 我很高兴地

254
00:14:59,366 --> 0:15:02,469
为你们介绍Xcode中的

255
00:14:59,366 --> 0:15:02,469
为你们介绍Xcode中的

256
00:15:02,636 --> 0:15:05,239
欢迎Ethan Vaughan

257
00:15:12,246 --> 0:15:13,380
谢谢Honza

258
00:15:15,015 --> 0:15:19,052
你们的许多开发周期

259
00:15:19,586 --> 0:15:23,924
编写代码、调试

260
00:15:24,157 --> 0:15:27,027
然后提交 将更改存入存储库

261
00:15:27,828 --> 0:15:29,863
在存入之前运行测试

262
00:15:30,130 --> 0:15:33,433
可以进行回归分析

263
00:15:35,903 --> 0:15:38,405
但是 这个流程有一个瓶颈

264
00:15:38,672 --> 0:15:41,508
即测试运行时间

265
00:15:42,142 --> 0:15:43,777
你们可能有一些测试套件

266
00:15:43,844 --> 0:15:47,080
运行时间长达30分钟甚至数小时

267
00:15:47,915 --> 0:15:51,952
如果需要花费过多的时间

268
00:15:52,019 --> 0:15:54,621
将会形成严重的工作流程瓶颈

269
00:15:55,856 --> 0:15:59,193
我们希望尽量提高测试运行速度

270
00:15:59,459 --> 0:16:02,696
缩短这个重要的开发环节

271
00:15:59,459 --> 0:16:02,696
缩短这个重要的开发环节

272
00:16:03,263 --> 0:16:09,136
因此去年我们在Xcode 9中

273
00:16:09,636 --> 0:16:11,805
此特性名为并行目标位置测试

274
00:16:12,306 --> 0:16:14,708
能够同时在多个目标位置

275
00:16:14,775 --> 0:16:17,177
运行你的所有测试

276
00:16:18,045 --> 0:16:19,913
你需要使用命令行

277
00:16:19,980 --> 0:16:23,483
将多个目标位置说明符

278
00:16:25,586 --> 0:16:30,490
以前若你运行测试 比如

279
00:16:31,091 --> 0:16:34,428
xcodebuild将会

280
00:16:34,494 --> 0:16:36,630
然后在iPad上运行所有测试

281
00:16:37,364 --> 0:16:40,100
设备不能同时运行测试

282
00:16:42,169 --> 0:16:44,805
但是在Xcode 9中

283
00:16:44,872 --> 0:16:48,509
默认情况下

284
00:16:49,109 --> 0:16:52,012
这可以极大缩短执行时间

285
00:16:52,079 --> 0:16:52,913
这很不错

286
00:16:54,548 --> 0:16:57,217
但是这个方法有一些限制

287
00:16:58,852 --> 0:17:02,656
首先 只有在多个目标位置

288
00:16:58,852 --> 0:17:02,656
首先 只有在多个目标位置

289
00:17:03,423 --> 0:17:06,827
举例来说 如果运行

290
00:17:07,261 --> 0:17:08,328
就没有帮助作用

291
00:17:09,863 --> 0:17:12,432
只能在xcodebuild中

292
00:17:12,766 --> 0:17:16,837
因此 这主要在连续集成环境中有用

293
00:17:16,904 --> 0:17:18,972
比如Xcode Server

294
00:17:21,208 --> 0:17:24,744
我很高兴告诉你们

295
00:17:24,810 --> 0:17:26,579
名为“并行分布式测试”

296
00:17:28,515 --> 0:17:30,217
利用并行分布式测试功能

297
00:17:30,284 --> 0:17:33,487
可以在一个目标位置

298
00:17:34,688 --> 0:17:38,025
以前 在单一目标位置

299
00:17:38,292 --> 0:17:42,329
依次连续执行测试

300
00:17:44,298 --> 0:17:47,634
分布式测试允许同时运行多个测试

301
00:17:47,935 --> 0:17:49,636
因此 现在测试是这样的

302
00:17:51,004 --> 0:17:54,374
此外 Xcode和

303
00:17:54,775 --> 0:17:58,178
无论在哪里运行测试

304
00:18:00,280 --> 0:18:03,617
为了理解Xcode

305
00:18:03,984 --> 0:18:06,687
我们首先来看测试是如何执行的

306
00:18:07,087 --> 0:18:08,689
在运行时发生了什么？

307
00:18:10,591 --> 0:18:12,192
我们先来看单元测试

308
00:18:12,926 --> 0:18:16,363
单元测试被编译成一个测试包

309
00:18:17,731 --> 0:18:23,203
在运行时层面 Xcode启动

310
00:18:24,671 --> 0:18:28,375
运行器加载测试包

311
00:18:29,877 --> 0:18:31,545
单元测试就是这样执行的

312
00:18:32,346 --> 0:18:33,714
那么用户界面测试呢？

313
00:18:34,214 --> 0:18:35,916
对于用户界面测试 原理基本相似

314
00:18:36,483 --> 0:18:38,719
测试被编译成为一个捆绑包

315
00:18:39,286 --> 0:18:42,723
但是捆绑包由Xcode

316
00:18:43,357 --> 0:18:45,759
你的app不再运行测试

317
00:18:46,593 --> 0:18:49,329
相反 测试自动控制你的app

318
00:18:49,763 --> 0:18:53,433
通过启动app

319
00:18:55,135 --> 0:18:57,437
如果想要详细了解此流程

320
00:18:57,738 --> 0:19:00,374
请你们观看2016年的演讲

321
00:18:57,738 --> 0:19:00,374
请你们观看2016年的演讲

322
00:19:00,774 --> 0:19:02,476
此演讲进行了更详细的讲解

323
00:19:04,044 --> 0:19:06,647
现在 我们已经了解

324
00:19:07,114 --> 0:19:10,017
最后让我们看看

325
00:19:11,385 --> 0:19:12,686
如前所述

326
00:19:12,753 --> 0:19:16,190
Xcode启动一个测试运行器

327
00:19:17,191 --> 0:19:19,393
但是不同于启动一个运行器

328
00:19:19,726 --> 0:19:21,995
Xcode将启动多个运行器

329
00:19:22,429 --> 0:19:25,232
每个运行器

330
00:19:26,366 --> 0:19:29,903
事实上 Xcode动态

331
00:19:30,337 --> 0:19:33,473
在机器上实现最高的利用效率

332
00:19:35,309 --> 0:19:36,543
让我们来了解详细过程

333
00:19:38,011 --> 0:19:42,616
Xcode分配测试到运行器时

334
00:19:43,450 --> 0:19:45,953
每个运行器接收

335
00:19:46,553 --> 0:19:50,257
它将执行这个类

336
00:19:51,291 --> 0:19:54,561
在测试完成时

337
00:19:56,463 --> 0:20:00,267
你可能会想

338
00:19:56,463 --> 0:20:00,267
你可能会想

339
00:20:00,534 --> 0:20:03,637
而不是将单个测试方法

340
00:20:04,605 --> 0:20:06,340
这有多方面的原因

341
00:20:07,641 --> 0:20:11,545
首先 类内部的测试之间

342
00:20:11,612 --> 0:20:13,180
Honza前面已经讲过

343
00:20:13,847 --> 0:20:18,385
如果Xcode接收类内部的测试

344
00:20:18,852 --> 0:20:21,154
可能难以诊断测试问题

345
00:20:23,357 --> 0:20:27,995
其次 每个测试类

346
00:20:28,328 --> 0:20:30,564
可能会执行大量的计算

347
00:20:31,398 --> 0:20:34,368
通过将类内部的有限数量

348
00:20:34,801 --> 0:20:37,771
XE测试仅需一次调用这些方法

349
00:20:38,005 --> 0:20:39,473
可以显著节省时间

350
00:20:42,409 --> 0:20:46,547
现在 我想谈谈在模拟器上

351
00:20:48,348 --> 0:20:50,651
在模拟器上并行运行测试时

352
00:20:51,084 --> 0:20:53,954
Xcode开始接收

353
00:20:54,254 --> 0:20:57,891
创建多个独特的模拟器副本或克隆

354
00:20:58,959 --> 0:21:01,895
这些克隆

355
00:20:58,959 --> 0:21:01,895
这些克隆

356
00:21:01,962 --> 0:21:03,664
与原始模拟器相同

357
00:21:04,731 --> 0:21:08,769
如有必要 Xcode将自动创建

358
00:21:10,037 --> 0:21:12,172
在多次克隆模拟器之后

359
00:21:12,573 --> 0:21:15,609
Xcode在每个克隆上

360
00:21:16,076 --> 0:21:18,979
然后 运行器开始执行测试类

361
00:21:19,413 --> 0:21:20,814
正如我们前面所说的那样

362
00:21:22,516 --> 0:21:24,218
由于在模拟器的

363
00:21:24,284 --> 0:21:26,386
多个克隆上执行测试

364
00:21:26,653 --> 0:21:29,056
这会存在一些问题

365
00:21:30,991 --> 0:21:35,028
首先 在测试期间

366
00:21:35,863 --> 0:21:38,432
相反 它作为一个模板模拟器

367
00:21:39,099 --> 0:21:42,436
可以使用你想要的设置

368
00:21:42,503 --> 0:21:46,006
在创建克隆时

369
00:21:47,608 --> 0:21:50,444
接下来 你的app将会有多个副本

370
00:21:51,144 --> 0:21:55,015
每个副本都有自己的数据容器

371
00:21:55,983 --> 0:21:59,786
这意味着 如果一个测试类

372
00:22:00,120 --> 0:22:04,291
这些文件修改

373
00:22:04,358 --> 0:22:07,494
因为它可以访问

374
00:22:08,896 --> 0:22:12,399
在实践中

375
00:22:12,666 --> 0:22:16,770
这对于你的测试来说

376
00:22:18,939 --> 0:22:21,008
那么 你可以在哪里

377
00:22:21,675 --> 0:22:24,378
可以在macOS上并行

378
00:22:24,678 --> 0:22:29,249
也可在iOS 和tvOS模拟器上

379
00:22:30,884 --> 0:22:34,922
对此 我想要为你们在实战中

380
00:22:48,168 --> 0:22:50,304
这是

381
00:22:50,671 --> 0:22:53,674
在以前的演讲中

382
00:22:54,274 --> 0:22:57,911
作为这个app的开发者之一

383
00:22:57,978 --> 0:23:00,581
然后提交并将我的更改推送入存储库

384
00:22:57,978 --> 0:23:00,581
然后提交并将我的更改推送入存储库

385
00:23:01,615 --> 0:23:03,650
但是 随着我添加更多的测试

386
00:23:03,717 --> 0:23:05,619
将需要更多的时间

387
00:23:05,686 --> 0:23:07,654
这成为工作流程中的瓶颈

388
00:23:08,422 --> 0:23:10,357
让我们来看并行测试

389
00:23:11,625 --> 0:23:13,927
我切换到Xcode项目

390
00:23:14,494 --> 0:23:16,230
我已经运行我的测试

391
00:23:16,296 --> 0:23:18,131
我想看它们用了多少时间

392
00:23:21,502 --> 0:23:22,336
好的

393
00:23:22,870 --> 0:23:24,371
让我们返回到测试报告

394
00:23:25,239 --> 0:23:27,241
在这里 可以看到

395
00:23:27,307 --> 0:23:30,143
显示执行每个方法所用的时间

396
00:23:31,245 --> 0:23:33,080
接下来 对于每个测试类

397
00:23:33,146 --> 0:23:35,883
我们显示测试通过和失败百分比

398
00:23:36,583 --> 0:23:39,319
以及测试类的执行时间

399
00:23:40,420 --> 0:23:42,189
最后 在右上角

400
00:23:42,256 --> 0:23:45,425
可以看到所有测试的运行时间

401
00:23:46,226 --> 0:23:48,729
在这里 可以看到测试用时14秒

402
00:23:49,630 --> 0:23:51,632
现在 我想启用并行测试

403
00:23:51,932 --> 0:23:53,600
我可以进入方案

404
00:23:54,134 --> 0:23:56,837
选择方案 然后编辑方案

405
00:23:57,771 --> 0:23:59,506
接下来 我点击测试操作

406
00:24:00,107 --> 0:24:03,377
点击测试目标旁边的选项按钮

407
00:24:04,611 --> 0:24:07,581
最后 选中“并行执行”复选框

408
00:24:08,448 --> 0:24:11,018
就可以启用并行测试

409
00:24:11,985 --> 0:24:16,056
现在 选择“产品测试”

410
00:24:19,560 --> 0:24:21,461
你们应该查看文档

411
00:24:21,828 --> 0:24:24,698
Xcode启动

412
00:24:24,965 --> 0:24:26,633
并行运行单元测试

413
00:24:27,701 --> 0:24:29,736
很好 看来已经完成了

414
00:24:29,803 --> 0:24:34,007
现在 我们返回到报告

415
00:24:36,076 --> 0:24:39,313
以前 测试所用时间为14秒

416
00:24:39,379 --> 0:24:40,914
现在仅用时5秒

417
00:24:41,248 --> 0:24:43,116
启用并行测试后

418
00:24:43,183 --> 0:24:46,453
测试执行时间节省了超过50%

419
00:24:53,760 --> 0:24:57,331
Solar System app

420
00:24:57,664 --> 0:24:59,466
而且有iOS版本

421
00:25:00,167 --> 0:25:03,270
我的任务之一是

422
00:25:03,337 --> 0:25:06,406
以使用我的iOS app的

423
00:25:07,040 --> 0:25:10,711
我现已为iOS方案启动并行测试

424
00:25:11,144 --> 0:25:13,313
现在我切换到此模式

425
00:25:16,683 --> 0:25:20,120
然后我选择“产品测试”

426
00:25:22,990 --> 0:25:25,526
现在 我们切换到模拟器

427
00:25:26,493 --> 0:25:27,794
在这里 可以看到

428
00:25:27,861 --> 0:25:31,598
Xcode创建我所选定模拟器

429
00:25:32,366 --> 0:25:35,969
这些克隆使用原始模拟器的名称

430
00:25:36,336 --> 0:25:38,005
因此容易进行区分

431
00:25:39,273 --> 0:25:42,876
在每个模拟器上

432
00:25:43,777 --> 0:25:46,914
每个运行器执行套件中的不同测试类

433
00:26:00,027 --> 0:26:01,795
执行我的测试时

434
00:26:02,229 --> 0:26:05,799
我将切换回Xcode显示测试日志

435
00:26:06,500 --> 0:26:10,103
可以找到测试报告的相关测试日志

436
00:26:11,338 --> 0:26:13,040
在日志中可以清楚地看到

437
00:26:13,373 --> 0:26:16,510
你的类如何被分配给不同的运行器

438
00:26:18,278 --> 0:26:20,948
在日志中 可以看到

439
00:26:21,949 --> 0:26:23,350
在每个给定运行器下方

440
00:26:23,417 --> 0:26:26,520
可以看到当前正在执行的测试类

441
00:26:28,021 --> 0:26:30,190
当测试完全结束后

442
00:26:30,257 --> 0:26:33,393
在这里可以看到类是如何分配的

443
00:26:33,460 --> 0:26:36,029
让你了解整个并行执行流程的概况

444
00:26:37,397 --> 0:26:39,299
让我们回到幻灯片

445
00:26:48,475 --> 0:26:51,044
让我们简要回顾在演示中学到的知识

446
00:26:52,045 --> 0:26:56,083
首先 我们看到

447
00:26:57,351 --> 0:27:00,120
接下来 我们介绍如何

448
00:26:57,351 --> 0:27:00,120
接下来 我们介绍如何

449
00:27:00,521 --> 0:27:03,590
以及在测试日志中查看类的分配方式

450
00:27:05,626 --> 0:27:09,663
然后我们看到Xcode启动

451
00:27:09,730 --> 0:27:11,498
以并行运行单元测试

452
00:27:13,000 --> 0:27:16,003
最后 我们看到模拟器的多个克隆

453
00:27:16,370 --> 0:27:18,105
它们并行运行用户界面测试

454
00:27:20,541 --> 0:27:22,009
如前所述

455
00:27:22,342 --> 0:27:25,512
xcodebuild也很好地

456
00:27:26,446 --> 0:27:30,450
我们添加了一些新命令行选项

457
00:27:30,517 --> 0:27:32,386
现在 我想指出两点

458
00:27:34,021 --> 0:27:36,890
首先 我们设有

459
00:27:37,257 --> 0:27:39,793
允许你控制工作线程的数量

460
00:27:39,860 --> 0:27:43,397
或并行测试期间

461
00:27:44,765 --> 0:27:48,502
通常情况下 Xcode将会

462
00:27:48,569 --> 0:27:51,939
确定最优的运行器数量

463
00:27:52,873 --> 0:27:56,910
这意味着 机器内核数量越多

464
00:27:58,111 --> 0:28:01,281
但是 如果你发现默认的

465
00:27:58,111 --> 0:28:01,281
但是 如果你发现默认的

466
00:28:01,348 --> 0:28:03,750
可以使用命令行选项进行重写

467
00:28:05,986 --> 0:28:08,222
接下来 我们启用并行测试

468
00:28:08,288 --> 0:28:10,757
允许你重写方案中的设置

469
00:28:10,824 --> 0:28:13,861
以显式启用或禁用并行测试

470
00:28:16,864 --> 0:28:18,799
在大多数情况下

471
00:28:18,866 --> 0:28:21,702
只需要启用

472
00:28:22,469 --> 0:28:24,171
这里有一些提示和技巧

473
00:28:24,438 --> 0:28:26,640
帮助你充分利用此功能

474
00:28:28,041 --> 0:28:29,676
首先 应考虑

475
00:28:29,743 --> 0:28:32,779
将长时运行测试类拆分为两个类

476
00:28:34,248 --> 0:28:36,984
因为测试类并行执行

477
00:28:37,384 --> 0:28:40,521
测试时间不会超过

478
00:28:41,889 --> 0:28:45,459
并行运行测试时

479
00:28:45,792 --> 0:28:49,363
一个类占用全部执行时间

480
00:28:50,430 --> 0:28:52,799
如果拆分这个类

481
00:28:53,300 --> 0:28:57,070
Xcode可以在不同的运行器之间

482
00:28:57,137 --> 0:28:58,705
更均衡地分配测试执行工作

483
00:28:58,772 --> 0:29:00,974
从而缩短执行总用时

484
00:28:58,772 --> 0:29:00,974
从而缩短执行总用时

485
00:29:02,242 --> 0:29:03,610
你并不需要

486
00:29:03,677 --> 0:29:05,946
拆分所有的类

487
00:29:06,380 --> 0:29:09,716
这没有必根本

488
00:29:09,983 --> 0:29:11,185
可以尝试这样做

489
00:29:13,887 --> 0:29:17,858
接下来 将性能测试

490
00:29:17,925 --> 0:29:19,526
并禁用并行测试

491
00:29:20,661 --> 0:29:22,362
这似乎不够直观

492
00:29:22,429 --> 0:29:26,300
但是性能测试对系统活动十分敏感

493
00:29:26,800 --> 0:29:29,069
如果并行地进行测试

494
00:29:29,136 --> 0:29:31,371
可能无法达到性能指标

495
00:29:33,473 --> 0:29:37,511
最后应该理解并行测试并不安全

496
00:29:38,478 --> 0:29:41,014
大多数测试都可以并行完成

497
00:29:41,481 --> 0:29:44,284
但是如果多个测试访问共享系统资源

498
00:29:44,351 --> 0:29:45,886
比如文件或数据库

499
00:29:46,286 --> 0:29:48,989
需要引入显式同步机制

500
00:29:49,056 --> 0:29:50,757
以允许它们同时运行

501
00:29:52,226 --> 0:29:53,961
说到测试提示和技巧

502
00:29:54,027 --> 0:29:56,864
如果想要详细了解如何测试你的代码

503
00:29:57,297 --> 0:29:59,900
我建议你们参加星期五的演讲

504
00:29:59,967 --> 0:30:02,903
由我的同事Stuart

505
00:29:59,967 --> 0:30:02,903
由我的同事Stuart

506
00:30:05,439 --> 0:30:06,473
最后总结

507
00:30:06,540 --> 0:30:09,076
今天我讨论了代码覆盖

508
00:30:09,409 --> 0:30:12,112
性能和准确性改进

509
00:30:13,280 --> 0:30:17,050
接下来 我们讨论了新的

510
00:30:17,451 --> 0:30:20,287
让你能够准确控制运行哪些测试

511
00:30:20,654 --> 0:30:22,689
并且控制测试运行顺序

512
00:30:23,724 --> 0:30:26,660
最后 我们介绍了并行分布式测试

513
00:30:26,960 --> 0:30:30,464
此功能让你能够把测试类

514
00:30:30,531 --> 0:30:31,965
以并行执行

515
00:30:33,400 --> 0:30:34,368
要了解详细信息

516
00:30:34,434 --> 0:30:37,938
建议从developer.apple.com

517
00:30:38,005 --> 0:30:40,407
也可以在今天下午前往

518
00:30:41,241 --> 0:30:42,843
祝大家度过一个愉快的WWDC
