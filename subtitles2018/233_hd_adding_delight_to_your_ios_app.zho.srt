1
00:00:17,417 --> 0:00:19,953
（为你的iOS app增添光彩

2
00:00:20,020 --> 0:00:20,854
嘿 伙计们！

3
00:00:21,321 --> 0:00:22,456
下午好

4
00:00:22,523 --> 0:00:23,657
（演讲233）

5
00:00:27,794 --> 0:00:30,964
欢迎来到

6
00:00:31,598 --> 0:00:32,633
我叫Ben

7
00:00:32,698 --> 0:00:33,934
我叫Peter

8
00:00:34,001 --> 0:00:37,271
我们将向你展示六个专业技巧

9
00:00:38,005 --> 0:00:40,774
我们将从外部显示器支持开始

10
00:00:41,441 --> 0:00:44,011
将你的app体验带到大屏幕上

11
00:00:46,046 --> 0:00:50,050
接下来我们将为你介绍一种

12
00:00:50,117 --> 0:00:51,451
它被称为布局驱动UI

13
00:00:52,653 --> 0:00:53,687
然后我们将向你展示

14
00:00:53,754 --> 0:00:56,523
如何通过极速启动让你的客户

15
00:00:56,590 --> 0:00:59,560
尽可能快地获得愉快体验

16
00:01:00,260 --> 0:01:02,462
我们将重点关注平滑滚动

17
00:01:02,529 --> 0:01:04,631
并让用户体验感觉良好

18
00:01:05,566 --> 0:01:08,669
连贯性是iOS上最神奇的体验之一

19
00:01:08,902 --> 0:01:11,705
我们将向你展示在你的app中

20
00:01:11,772 --> 0:01:12,906
实现接力是多么容易

21
00:01:13,574 --> 0:01:17,744
最后 我们将教你一些

22
00:01:17,811 --> 0:01:19,313
并像专业人员一样进行调试

23
00:01:20,414 --> 0:01:22,816
我们有很多内容要涵盖

24
00:01:28,455 --> 0:01:33,861
iOS设备因其令人惊叹的

25
00:01:35,562 --> 0:01:38,532
而你可以通过添加

26
00:01:38,966 --> 0:01:41,802
来进一步提升app的体验

27
00:01:43,403 --> 0:01:46,006
为了演示这一点

28
00:01:47,174 --> 0:01:50,210
内置于iOS中的屏幕镜像

29
00:01:50,277 --> 0:01:52,646
它能够将整个系统UI

30
00:01:52,713 --> 0:01:55,182
复制到外部连接显示器上

31
00:01:56,416 --> 0:01:57,484
这是演示app

32
00:01:57,885 --> 0:01:59,887
如你所见

33
00:02:00,254 --> 0:02:04,591
当你点击照片缩略图时

34
00:02:05,392 --> 0:02:09,630
这整个体验都会复制到外部显示器上

35
00:02:11,331 --> 0:02:15,002
为了充分利用外部显示器的尺寸

36
00:02:15,068 --> 0:02:17,104
从而填充它

37
00:02:19,006 --> 0:02:20,007
这很棒

38
00:02:20,073 --> 0:02:23,443
我们不需要做任何工作

39
00:02:24,578 --> 0:02:27,281
但我们可以做得更好

40
00:02:28,382 --> 0:02:31,285
还有一些内置于iOS中的API

41
00:02:31,351 --> 0:02:35,355
允许你创建一个完全自定义的

42
00:02:35,422 --> 0:02:37,591
并显示在此外接显示器上

43
00:02:39,593 --> 0:02:42,729
让我们来看看

44
00:02:45,532 --> 0:02:47,501
Keynote就是一个很好的例子

45
00:02:48,135 --> 0:02:50,804
你可以在外部显示器上

46
00:02:50,871 --> 0:02:52,940
显示当前手头上的幻灯片

47
00:02:53,740 --> 0:02:57,311
但在iPhone显示屏上

48
00:02:57,377 --> 0:03:01,048
和下一张幻灯片

49
00:02:57,377 --> 0:03:01,048
和下一张幻灯片

50
00:03:02,983 --> 0:03:04,218
又或者你有一个游戏

51
00:03:05,419 --> 0:03:08,055
但通常情况下 它会有覆盖控件

52
00:03:08,989 --> 0:03:13,327
现在你可以创建一个

53
00:03:13,393 --> 0:03:16,129
并将其放在iOS设备的显示屏上

54
00:03:16,763 --> 0:03:21,101
从而将完整流畅的

55
00:03:21,168 --> 0:03:22,369
带到外部显示器上

56
00:03:25,506 --> 0:03:28,842
在为外部显示器设计app时

57
00:03:29,409 --> 0:03:31,979
你应该考虑一些关键的事情

58
00:03:33,780 --> 0:03:38,919
除了明显的尺寸差异外

59
00:03:39,353 --> 0:03:41,355
所以你应该考虑作为私有信息

60
00:03:41,421 --> 0:03:43,757
显示在屏幕上的那类信息

61
00:03:45,392 --> 0:03:48,629
而外部显示器通常位于

62
00:03:48,695 --> 0:03:53,300
很多人可以看到它的环境中

63
00:03:54,067 --> 0:03:56,003
或会议厅的投影系统

64
00:03:57,571 --> 0:04:01,575
因此你应该假设在此显示屏上

65
00:03:57,571 --> 0:04:01,575
因此你应该假设在此显示屏上

66
00:04:03,210 --> 0:04:05,279
此外 iPhone和iPad的

67
00:04:05,345 --> 0:04:10,184
是可交互的

68
00:04:10,651 --> 0:04:12,986
因此你应该避免在外部显示器上

69
00:04:13,053 --> 0:04:16,322
显示UI元素或其它可交互控件

70
00:04:18,024 --> 0:04:21,394
所以让我们将这种想法

71
00:04:21,461 --> 0:04:22,930
并看看我们能做出什么

72
00:04:24,198 --> 0:04:27,334
这是我们针对外部显示器的优化版本

73
00:04:28,535 --> 0:04:33,106
如你所见 现在我们能够

74
00:04:33,173 --> 0:04:34,575
所选照片的完整尺寸

75
00:04:35,409 --> 0:04:38,879
而在集成显示屏上

76
00:04:38,946 --> 0:04:40,514
和一个新的选中标志

77
00:04:40,581 --> 0:04:43,550
它显示了当前正在全屏显示的照片

78
00:04:45,385 --> 0:04:48,822
虽然简单 但这是对该设计的

79
00:04:50,891 --> 0:04:53,393
为了向你展示

80
00:04:53,460 --> 0:04:55,062
我们将讨论三个主题

81
00:04:56,096 --> 0:04:58,131
连接、行为

82
00:04:58,532 --> 0:04:59,933
和连接转换

83
00:05:01,168 --> 0:05:02,603
我们先从连接开始

84
00:05:03,370 --> 0:05:06,507
你如何知道是否连接了外接显示器

85
00:05:08,075 --> 0:05:10,611
UIScreen有一个类变量

86
00:05:11,078 --> 0:05:13,480
其中包含所有已连接的显示器列表

87
00:05:13,547 --> 0:05:15,849
包括内置于iPhone的显示设备

88
00:05:16,884 --> 0:05:19,620
因此如果这个数组中的元素不止一个

89
00:05:20,053 --> 0:05:22,656
你就知道你连接了一个外部显示器

90
00:05:24,525 --> 0:05:30,097
此外 由于外部显示器可以

91
00:05:30,931 --> 0:05:34,601
UIKit会发布一些通知

92
00:05:35,602 --> 0:05:39,439
因此你应该监听UIScreen.didConnect

93
00:05:39,506 --> 0:05:41,909
和UIScreen.didDisconnect

94
00:05:42,276 --> 0:05:44,711
然后相应地调出或移除你的用户界面

95
00:05:46,180 --> 0:05:48,782
Peter 你能告诉我们的开发者

96
00:05:48,849 --> 0:05:50,417
设置第二用户界面有多容易吗？

97
00:05:50,918 --> 0:05:52,519
Ben 我很乐意

98
00:05:52,886 --> 0:05:56,557
让我们看看UIScreen的

99
00:05:57,724 --> 0:06:01,929
我们在这里将一个局部变量

100
00:05:57,724 --> 0:06:01,929
我们在这里将一个局部变量

101
00:06:02,429 --> 0:06:04,565
我们知道这是外部屏幕

102
00:06:04,631 --> 0:06:07,734
因为我们当前在

103
00:06:08,569 --> 0:06:12,773
接下来我们将创建一个新的UIWindow

104
00:06:13,240 --> 0:06:16,910
并且我们将其screen属性

105
00:06:17,177 --> 0:06:20,047
接下来我们要确保配置此窗口

106
00:06:20,347 --> 0:06:23,283
我们将其归因到一个函数中

107
00:06:23,350 --> 0:06:26,286
创建一个根视图控制器

108
00:06:26,653 --> 0:06:29,256
这和我们为板载显示器所做的一样

109
00:06:29,923 --> 0:06:33,493
最后我们要将此窗口标记为非隐藏

110
00:06:33,560 --> 0:06:35,295
来将其显示在外部屏幕上

111
00:06:36,196 --> 0:06:37,397
所以这就是连接

112
00:06:37,764 --> 0:06:40,534
现在我们来看看断开连接

113
00:06:41,335 --> 0:06:46,106
这里我们位于UIScreen.didDisconnect

114
00:06:46,173 --> 0:06:48,609
我们在这里要做的只是隐藏窗口

115
00:06:48,942 --> 0:06:52,279
并将其局部引用设为nil

116
00:06:52,346 --> 0:06:53,247
就这么多

117
00:06:53,313 --> 0:06:56,650
我们已经在app中实现了

118
00:06:57,384 --> 0:06:58,785
哇 Peter 这真容易

119
00:07:00,721 --> 0:07:02,556
接下来你要考虑的事情

120
00:07:02,756 --> 0:07:04,691
是在连接上外部显示器时

121
00:07:05,125 --> 0:07:07,227
更改app的默认行为

122
00:07:09,096 --> 0:07:12,199
让我们看看演示app中的

123
00:07:13,133 --> 0:07:16,904
这是我们点击集合视图中的照片时

124
00:07:18,305 --> 0:07:20,040
当我们处于单一显示模式时

125
00:07:20,107 --> 0:07:24,578
我们创建一个photoViewController

126
00:07:25,579 --> 0:07:28,015
但当我们连接了外部显示器时

127
00:07:28,081 --> 0:07:30,717
我们已经在第二个UI中

128
00:07:30,784 --> 0:07:35,255
因此我们只是告诉它呈现那张照片

129
00:07:35,822 --> 0:07:36,657
非常容易

130
00:07:38,091 --> 0:07:41,828
在为外部显示器设计app时

131
00:07:43,096 --> 0:07:45,098
是你应该使用优雅的过渡

132
00:07:45,165 --> 0:07:46,700
来处理连接更改

133
00:07:48,836 --> 0:07:51,138
让我们回到演示app来说明这一点

134
00:07:52,773 --> 0:07:56,710
这里你可以看到我们的演示app

135
00:07:57,077 --> 0:07:59,646
而且我们还没有连接外部显示器

136
00:08:00,747 --> 0:08:02,416
请看当我们连接时会发生什么

137
00:08:06,386 --> 0:08:08,889
这里所发生的事情是我们弹出了

138
00:08:08,956 --> 0:08:12,326
返回缩略图视图

139
00:08:12,392 --> 0:08:16,430
并同时在外部显示器上以全尺寸

140
00:08:17,898 --> 0:08:23,003
正是这些优雅的过渡

141
00:08:23,070 --> 0:08:26,206
并帮助你的用户了解

142
00:08:28,208 --> 0:08:31,545
这就是外部显示器支持

143
00:08:32,546 --> 0:08:34,615
只需在设计app时

144
00:08:34,681 --> 0:08:36,183
考虑不同的显示上下文

145
00:08:36,717 --> 0:08:39,086
并确保能够优雅地处理连接更改

146
00:08:40,153 --> 0:08:44,591
若想了解有关此内容的更多信息

147
00:08:45,325 --> 0:08:46,159
谢谢

148
00:08:46,226 --> 0:08:50,564
（布局驱动UI）

149
00:08:51,698 --> 0:08:54,768
布局驱动UI是一种强大的

150
00:08:54,835 --> 0:08:58,038
它使你的app便于添加功能

151
00:08:58,438 --> 0:09:00,307
并且更容易调试

152
00:08:58,438 --> 0:09:00,307
并且更容易调试

153
00:09:01,441 --> 0:09:05,445
布局驱动UI有助于我们解决iOS

154
00:09:05,512 --> 0:09:09,917
即管理UI复杂性

155
00:09:10,851 --> 0:09:13,787
我确信你曾遇到过这些问题

156
00:09:14,454 --> 0:09:16,757
你添加了一些代码和手势回调

157
00:09:17,191 --> 0:09:20,627
你甚至在通知回调中

158
00:09:20,694 --> 0:09:24,498
当UI控件被触发并获取值时

159
00:09:24,965 --> 0:09:29,369
突然间 你的app处于这种

160
00:09:30,003 --> 0:09:32,005
你必须沿着这些奇怪的顺序

161
00:09:32,072 --> 0:09:34,007
才能重现这些不寻常的漏洞

162
00:09:34,675 --> 0:09:38,912
当你向app添加更多功能时

163
00:09:40,214 --> 0:09:46,553
如果我们改为遵循一个简单的配方

164
00:09:47,120 --> 0:09:50,624
我们就可以摆脱这些漏洞

165
00:09:51,391 --> 0:09:55,662
让我们来看看为你的app

166
00:09:57,497 --> 0:09:58,999
你需要做的第一件事是

167
00:09:59,066 --> 0:10:03,904
你需要识别并跟踪

168
00:09:59,066 --> 0:10:03,904
你需要识别并跟踪

169
00:10:05,506 --> 0:10:07,908
然后 每当状态发生变化时

170
00:10:08,242 --> 0:10:11,445
你应该通过调用setNeedsLayout

171
00:10:12,846 --> 0:10:13,847
最后

172
00:10:14,515 --> 0:10:18,151
你需要在layoutSubviews中

173
00:10:19,253 --> 0:10:20,153
就是这样

174
00:10:20,687 --> 0:10:24,024
我喜欢这个配方就是因为它的易用性

175
00:10:25,492 --> 0:10:29,296
如果我们将布局驱动UI

176
00:10:30,531 --> 0:10:33,700
同时考虑iOS app的

177
00:10:34,168 --> 0:10:39,273
即布局、动画和手势

178
00:10:39,339 --> 0:10:44,645
能以一种非常棒的方式和谐地工作

179
00:10:45,879 --> 0:10:47,681
让我们从布局开始

180
00:10:49,783 --> 0:10:52,052
布局是你在屏幕上定位

181
00:10:52,119 --> 0:10:54,521
app内容的过程

182
00:10:55,522 --> 0:11:00,294
但我们也建议你在布局中

183
00:10:55,522 --> 0:11:00,294
但我们也建议你在布局中

184
00:11:00,761 --> 0:11:04,431
看一个我们写的简单示例app

185
00:11:04,965 --> 0:11:06,366
Ben 你能带我们

186
00:11:07,234 --> 0:11:08,168
当然 Peter

187
00:11:09,069 --> 0:11:12,272
这是一个非常简单的示例app

188
00:11:13,140 --> 0:11:14,541
当我们感觉很酷时

189
00:11:14,942 --> 0:11:16,677
否则它会隐藏起来

190
00:11:17,911 --> 0:11:19,680
但我们现在感觉很酷 Peter

191
00:11:19,746 --> 0:11:20,914
所以让我把它显示出来

192
00:11:21,815 --> 0:11:26,687
很好 虽然这是一个简单的例子

193
00:11:26,753 --> 0:11:29,556
以便我们可以理解

194
00:11:30,224 --> 0:11:34,228
让我们来看看这个app的骨架

195
00:11:34,294 --> 0:11:37,397
以及Ben之前向我们展示的

196
00:11:38,198 --> 0:11:42,369
一管理视图 在coolView中

197
00:11:42,436 --> 0:11:45,105
这是我预先写好的

198
00:11:45,906 --> 0:11:48,041
那么 Ben 我们配方的

199
00:11:48,609 --> 0:11:53,046
我们需要识别并跟踪

200
00:11:53,747 --> 0:11:55,349
记住Ben说的话

201
00:11:55,415 --> 0:11:57,985
当我们感觉很酷时

202
00:11:58,318 --> 0:11:59,987
否则它就不在

203
00:12:00,754 --> 0:12:03,323
所以我猜我们会有一个

204
00:12:03,891 --> 0:12:04,858
好

205
00:12:04,925 --> 0:12:06,927
Ben 配方的第二步是什么？

206
00:12:07,494 --> 0:12:09,730
现在 每当这种状态改变时

207
00:12:09,796 --> 0:12:13,033
我们需要通过调用setNeedsLayout

208
00:12:13,600 --> 0:12:17,371
但我们需要确保每次状态发生变化时

209
00:12:17,437 --> 0:12:21,141
此状态可能会在我们app中的

210
00:12:21,575 --> 0:12:24,678
那么 Peter

211
00:12:24,745 --> 0:12:25,846
我们总能脏化布局系统呢？

212
00:12:25,913 --> 0:12:26,847
我很高兴你问这点

213
00:12:26,914 --> 0:12:28,749
因为我觉得我对此有个好主意

214
00:12:29,316 --> 0:12:32,452
我们可以使用一个名为

215
00:12:33,287 --> 0:12:37,257
它让我们能够在属性被设置

216
00:12:37,758 --> 0:12:40,160
因此我们可以使用

217
00:12:40,627 --> 0:12:42,129
来调用

218
00:12:42,563 --> 0:12:46,366
这是在你的app中使用

219
00:12:47,267 --> 0:12:49,102
好的 我们差不多完成了

220
00:12:49,536 --> 0:12:51,405
Ben 配方的最后一步是什么

221
00:12:51,839 --> 0:12:53,507
Peter 通过使用该状态

222
00:12:53,574 --> 0:12:56,376
我们需要在layoutSubviews中

223
00:12:57,311 --> 0:12:58,879
好的 这很简单

224
00:12:59,313 --> 0:13:03,083
覆盖layoutSubviews

225
00:12:59,313 --> 0:13:03,083
覆盖layoutSubviews

226
00:13:03,150 --> 0:13:06,620
更新酷家伙视图的

227
00:13:07,120 --> 0:13:11,191
就是这样 这就是为你的app添加

228
00:13:11,592 --> 0:13:15,529
这不仅对这个简单的例子非常有效

229
00:13:15,596 --> 0:13:17,531
它也适用于一些更早

230
00:13:18,298 --> 0:13:22,402
Ben和我昨晚熬夜玩了

231
00:13:22,469 --> 0:13:25,839
《万智牌》卡牌游戏

232
00:13:27,307 --> 0:13:30,177
我们写了有趣的卡堆生成器app

233
00:13:30,244 --> 0:13:32,045
下周末的比赛 我们真打算这么干

234
00:13:32,880 --> 0:13:35,215
它允许你拿起并拖动这些卡片

235
00:13:35,282 --> 0:13:37,384
并且你可以将它们扔进这个卡堆区域

236
00:13:37,718 --> 0:13:41,955
它非常迅速、有趣和流畅

237
00:13:42,422 --> 0:13:46,593
我认为我们可以通过该app

238
00:13:47,060 --> 0:13:50,664
而且很重要的是

239
00:13:51,431 --> 0:13:54,301
所以让我们来看看iOS app的

240
00:13:54,368 --> 0:13:55,469
另外两个核心组件

241
00:13:55,536 --> 0:13:58,138
以及我们如何将布局驱动UI

242
00:13:58,205 --> 0:14:00,207
先从动画开始

243
00:13:58,205 --> 0:14:00,207
先从动画开始

244
00:14:01,808 --> 0:14:05,612
动画是任何卓越iOS体验的标志

245
00:14:06,513 --> 0:14:09,149
用户界面的逼真动作

246
00:14:09,216 --> 0:14:10,951
真正让app看起来像活的一样

247
00:14:12,452 --> 0:14:14,755
UIKit提供了一些很棒的API

248
00:14:14,821 --> 0:14:17,257
来帮助你创建这些赏心悦目的动画

249
00:14:18,825 --> 0:14:22,529
UIViewPropertyAnimator API

250
00:14:23,063 --> 0:14:26,099
并且去年它增加了大量新功能

251
00:14:26,967 --> 0:14:28,502
若想了解如何使用其所有信息

252
00:14:28,569 --> 0:14:33,340
请观看2017年WWDC中的演讲

253
00:14:34,741 --> 0:14:36,109
除此之外

254
00:14:36,176 --> 0:14:38,278
久经考验的UIView闭包API

255
00:14:38,345 --> 0:14:40,514
也是制作这些动画的好方法

256
00:14:42,516 --> 0:14:43,517
太棒了

257
00:14:43,884 --> 0:14:48,188
我们可以将UIViewAnimations

258
00:14:49,022 --> 0:14:52,092
要记住的一件事是我们总是想要使用

259
00:14:52,159 --> 0:14:54,828
beginFromCurrentState动画选项

260
00:14:55,829 --> 0:14:57,197
这告诉UIKit

261
00:14:57,264 --> 0:15:00,234
在播放动画时

262
00:14:57,264 --> 0:15:00,234
在播放动画时

263
00:15:00,300 --> 0:15:03,670
即使是在动画运行中期

264
00:15:04,238 --> 0:15:05,772
所以这让我们实现了

265
00:15:05,839 --> 0:15:09,243
这些非常精彩的和可中断的互动动画

266
00:15:09,810 --> 0:15:13,881
让我们来看看macOS上的

267
00:15:15,382 --> 0:15:19,553
这里有一个变量来跟踪

268
00:15:19,853 --> 0:15:23,023
通过使用我们之前讨论过的

269
00:15:23,390 --> 0:15:26,360
每当其发生变化时 我们可以调用

270
00:15:26,426 --> 0:15:28,061
来脏化布局系统

271
00:15:29,997 --> 0:15:34,168
然后当我们想要在卡堆中放一张牌时

272
00:15:34,434 --> 0:15:37,838
将该卡添加到此数组中

273
00:15:38,438 --> 0:15:40,874
然后在动画块内

274
00:15:40,941 --> 0:15:45,379
设置这个beginFromCurrentState选项

275
00:15:46,146 --> 0:15:49,316
这将触发对layoutSubviews

276
00:15:49,383 --> 0:15:51,318
它会移动我们的视图

277
00:15:51,385 --> 0:15:54,188
播放适当的动画以及进行状态转换

278
00:15:54,655 --> 0:15:58,025
我想在这里特别强调的

279
00:15:58,091 --> 0:16:01,495
我们没有为这些动画

280
00:15:58,091 --> 0:16:01,495
我们没有为这些动画

281
00:16:02,129 --> 0:16:04,965
我们只是通过在动画块内部进行布局

282
00:16:05,265 --> 0:16:08,368
而轻易得到这个动画布局

283
00:16:09,203 --> 0:16:10,871
这真的非常棒

284
00:16:11,471 --> 0:16:14,975
这就是我们如何将动画

285
00:16:16,310 --> 0:16:17,144
最后

286
00:16:17,211 --> 0:16:21,448
我们来谈谈iOS app的

287
00:16:21,982 --> 0:16:23,050
当然

288
00:16:23,116 --> 0:16:27,454
不谈论UIGestureRecognizer

289
00:16:27,821 --> 0:16:31,625
它是UIKit中用于为你的app

290
00:16:33,527 --> 0:16:36,763
UIKit提供了许多

291
00:16:36,830 --> 0:16:38,265
很棒的具体子类

292
00:16:38,866 --> 0:16:41,935
其涵盖从拖动到捏合到滑动

293
00:16:42,436 --> 0:16:45,539
你可以使用它们创建所需的交互类型

294
00:16:45,772 --> 0:16:47,808
它们也是高度可定制的

295
00:16:48,942 --> 0:16:51,078
如果你想要一些非常疯狂的东西

296
00:16:51,345 --> 0:16:54,114
你也可以自己继承

297
00:16:56,116 --> 0:16:59,753
当查看内置的

298
00:16:59,820 --> 0:17:01,722
了解离散和连续手势

299
00:16:59,820 --> 0:17:01,722
了解离散和连续手势

300
00:17:01,788 --> 0:17:04,758
之间的差异非常重要

301
00:17:05,925 --> 0:17:08,795
离散手势告诉你某个事件发生了

302
00:17:09,530 --> 0:17:13,333
它们从Possible状态开始

303
00:17:13,400 --> 0:17:15,002
它们也不收200美元

304
00:17:15,068 --> 0:17:17,503
而是立即进入

305
00:17:18,472 --> 0:17:22,342
这对你的app中的

306
00:17:22,742 --> 0:17:25,913
但不会告诉你交互过程中的各个阶段

307
00:17:27,548 --> 0:17:30,250
另一种类型的手势是连续手势

308
00:17:30,617 --> 0:17:33,187
它们为你提供更高级别的保真度

309
00:17:34,288 --> 0:17:37,090
与离散手势一样

310
00:17:37,758 --> 0:17:41,228
但随着它们开始被认出

311
00:17:42,629 --> 0:17:45,332
在进行跟踪时

312
00:17:45,632 --> 0:17:48,535
当手势四处移动时

313
00:17:48,602 --> 0:17:50,070
你会接收到连续的事件流

314
00:17:51,471 --> 0:17:55,576
最后 当手势完成后

315
00:17:57,611 --> 0:18:00,147
我们最喜欢的连续手势之一

316
00:17:57,611 --> 0:18:00,147
我们最喜欢的连续手势之一

317
00:18:00,214 --> 0:18:02,082
是UIPanGestureRecognizer

318
00:18:02,749 --> 0:18:05,085
而且有两个很棒的函数

319
00:18:05,152 --> 0:18:06,820
可以帮助你充分利用它

320
00:18:08,121 --> 0:18:11,558
translationInView

321
00:18:11,625 --> 0:18:12,926
你的手势跟踪的位置

322
00:18:14,194 --> 0:18:17,931
而velocityInView

323
00:18:18,365 --> 0:18:22,169
这对于在手势和后续动画之间

324
00:18:22,236 --> 0:18:23,770
切换速度非常有用

325
00:18:25,472 --> 0:18:29,743
若想了解如何使用它们构建

326
00:18:29,810 --> 0:18:32,880
请查看2014年WWDC中的演讲

327
00:18:32,946 --> 0:18:34,848
构建可中断和响应式交互

328
00:18:36,250 --> 0:18:39,453
我也喜欢

329
00:18:39,520 --> 0:18:40,787
我们用它构建了

330
00:18:40,854 --> 0:18:43,590
你之前看到的卡片拖动行为

331
00:18:44,391 --> 0:18:47,327
让我们看看我们是如何

332
00:18:49,263 --> 0:18:53,700
我们这里也有一个局部变量

333
00:18:53,767 --> 0:18:56,703
每张卡片的偏移量

334
00:18:57,337 --> 0:19:00,374
注意每当此变量发生变化时

335
00:18:57,337 --> 0:19:00,374
注意每当此变量发生变化时

336
00:19:00,440 --> 0:19:04,478
我们都使用Swift的属性观察器

337
00:19:06,280 --> 0:19:10,117
接下来 在我们的

338
00:19:10,584 --> 0:19:12,619
我们将从手势中获取

339
00:19:12,686 --> 0:19:14,254
当前的变化和视图

340
00:19:14,755 --> 0:19:18,091
并将此手势与我们的一张卡相关联

341
00:19:18,892 --> 0:19:23,931
然后我们在该字典中

342
00:19:25,499 --> 0:19:29,903
最后 在layoutSubviews中

343
00:19:29,970 --> 0:19:34,908
更新它们的视图的位置

344
00:19:36,210 --> 0:19:41,381
再次注意 我们并没有做

345
00:19:41,448 --> 0:19:43,417
除了传统的布局驱动UI事务

346
00:19:44,151 --> 0:19:47,988
我们只是使用了这个状态

347
00:19:48,055 --> 0:19:50,457
并且在layoutSubviews中响应它

348
00:19:51,592 --> 0:19:55,195
事实上 如果你在整个app中

349
00:19:55,262 --> 0:19:57,664
你会发现它让很多这类交互

350
00:19:57,731 --> 0:19:59,333
变得更容易使用

351
00:20:00,601 --> 0:20:03,971
这就是布局驱动UI

352
00:20:04,638 --> 0:20:07,875
查找并跟踪影响UI的所有状态

353
00:20:08,175 --> 0:20:10,143
并使用Swift属性观察器

354
00:20:10,210 --> 0:20:13,647
来在此状态发生变化时

355
00:20:14,681 --> 0:20:17,651
最后 在layoutSubviews的实现中

356
00:20:17,918 --> 0:20:22,890
确保根据你所跟踪的状态

357
00:20:23,290 --> 0:20:24,191
谢谢

358
00:20:29,062 --> 0:20:32,833
iOS体验的核心就是强响应性

359
00:20:34,034 --> 0:20:37,671
你希望你的用户可以尽可能快地

360
00:20:38,071 --> 0:20:39,673
获得愉悦的体验

361
00:20:40,974 --> 0:20:46,079
在点击你的图标并获得这种

362
00:20:46,947 --> 0:20:50,083
而这一步就是你的启动时间

363
00:20:52,486 --> 0:20:55,956
为了帮助你优化这点

364
00:20:56,023 --> 0:21:00,928
构成启动内部过程的五个高级组件

365
00:20:56,023 --> 0:21:00,928
构成启动内部过程的五个高级组件

366
00:21:02,763 --> 0:21:03,931
从第一个开始

367
00:21:04,665 --> 0:21:05,799
即进程分叉

368
00:21:07,000 --> 0:21:09,403
Peter 在启动阶段

369
00:21:10,103 --> 0:21:13,674
至于进程分叉 它真的很复杂

370
00:21:13,740 --> 0:21:16,910
你需要阅读

371
00:21:16,977 --> 0:21:19,780
并熟悉POSIX基础知识

372
00:21:20,080 --> 0:21:21,215
不 我只是在开玩笑

373
00:21:21,481 --> 0:21:24,384
iOS将为你处理进程分叉

374
00:21:25,652 --> 0:21:28,488
我们为你处理了第一步

375
00:21:31,358 --> 0:21:32,492
动态链接

376
00:21:34,428 --> 0:21:38,832
在此阶段 我们分配内存以开始

377
00:21:39,833 --> 0:21:41,969
我们链接库和框架

378
00:21:42,636 --> 0:21:45,606
我们初始化Swift、Objective-C

379
00:21:46,473 --> 0:21:48,809
我们也进行静态对象初始化

380
00:21:50,177 --> 0:21:51,278
通常我们会看到

381
00:21:51,345 --> 0:21:55,883
它可能占app典型启动时间的

382
00:21:57,251 --> 0:21:58,852
要记住的一件重要的事情是

383
00:21:58,919 --> 0:22:01,321
此时你的代码还没有开始运行

384
00:21:58,919 --> 0:22:01,321
此时你的代码还没有开始运行

385
00:22:02,623 --> 0:22:05,392
因此了解如何优化它至关重要

386
00:22:06,159 --> 0:22:08,462
Peter 你对开发者

387
00:22:08,695 --> 0:22:12,799
我很高兴你问这个问题 Ben

388
00:22:12,866 --> 0:22:15,969
在优化app启动的链接阶段时

389
00:22:16,303 --> 0:22:20,007
因为它占用了大量的启动时间

390
00:22:21,441 --> 0:22:23,177
我给你的第一条建议

391
00:22:23,243 --> 0:22:26,346
是尽可能避免代码重复

392
00:22:26,980 --> 0:22:32,686
如果你有多余的函数、对象或结构

393
00:22:32,753 --> 0:22:34,054
不要重复自己

394
00:22:35,222 --> 0:22:39,126
接下来 你最好限制使用第三方库

395
00:22:40,060 --> 0:22:42,796
iOS自己的库会被缓存

396
00:22:42,963 --> 0:22:47,367
并且如果另一个app正在使用它们

397
00:22:48,402 --> 0:22:51,071
但第三方库不会被缓存

398
00:22:51,138 --> 0:22:54,341
即使其它app使用

399
00:22:55,108 --> 0:22:58,245
如果你的app也使用它

400
00:22:58,679 --> 0:23:01,715
因此你应该尽可能多地

401
00:22:58,679 --> 0:23:01,715
因此你应该尽可能多地

402
00:23:01,782 --> 0:23:02,950
限制使用这些第三方库

403
00:23:03,917 --> 0:23:07,855
最后 你要避免使用静态初始化器

404
00:23:08,255 --> 0:23:13,026
避免在诸如+initialize

405
00:23:13,360 --> 0:23:17,130
因为它们必须在你的app

406
00:23:18,632 --> 0:23:22,135
若想了解有关启动时间

407
00:23:22,202 --> 0:23:26,840
请观看2017年WWDC中的演讲

408
00:23:28,709 --> 0:23:32,045
启动的下一阶段是UI构建

409
00:23:32,880 --> 0:23:37,217
此时你正在准备UI

410
00:23:38,585 --> 0:23:42,289
系统会进行状态恢复

411
00:23:43,790 --> 0:23:46,059
你也会加载为了让你的app

412
00:23:46,126 --> 0:23:47,728
变得具有响应性所需的数据

413
00:23:49,530 --> 0:23:52,933
Peter 我们可以在该启动阶段

414
00:23:53,734 --> 0:23:56,236
你需要尽可能快地优化

415
00:23:56,303 --> 0:23:58,438
app中的UI构建阶段

416
00:23:59,339 --> 0:24:01,942
这意味着你需要

417
00:23:59,339 --> 0:24:01,942
这意味着你需要

418
00:24:02,142 --> 0:24:05,112
从UI app激活方法中尽快返回

419
00:24:05,579 --> 0:24:07,080
即WillFinishLaunching

420
00:24:07,147 --> 0:24:09,783
didFinishLaunching

421
00:24:10,184 --> 0:24:13,220
因为UIKit只有

422
00:24:13,287 --> 0:24:15,689
才将你的app标记为活跃状态

423
00:24:17,024 --> 0:24:21,295
接下来 你需要在app启动期间

424
00:24:21,361 --> 0:24:22,930
避免任何文件系统写入

425
00:24:23,530 --> 0:24:25,999
因为它们是阻塞的

426
00:24:26,834 --> 0:24:30,204
同样的 你也需要在app启动期间

427
00:24:30,270 --> 0:24:32,306
避免执行非常大的读取操作

428
00:24:33,006 --> 0:24:35,075
相反 你应该只读入

429
00:24:35,142 --> 0:24:38,011
你现在绝对需要的数据

430
00:24:39,046 --> 0:24:42,616
最后我建议你检查数据库的健康状况

431
00:24:42,683 --> 0:24:44,585
保持整洁总是一个好主意

432
00:24:45,452 --> 0:24:47,721
如果你使用的是

433
00:24:48,222 --> 0:24:52,326
考虑优化你的模式以使其尽可能快

434
00:24:52,826 --> 0:24:56,797
而如果你使用SQLite

435
00:24:57,064 --> 0:25:00,434
考虑定期清空数据库

436
00:24:57,064 --> 0:25:00,434
考虑定期清空数据库

437
00:25:00,667 --> 0:25:03,203
例如在每次你的app更新时

438
00:25:03,871 --> 0:25:05,105
谢谢 Peter

439
00:25:06,106 --> 0:25:09,743
启动的下一阶段是

440
00:25:11,245 --> 0:25:14,581
此时Core Animation

441
00:25:14,648 --> 0:25:15,849
来准备好那个帧

442
00:25:17,050 --> 0:25:18,485
它会进行文字绘图

443
00:25:18,552 --> 0:25:20,854
并加载和解压缩任何需要

444
00:25:20,921 --> 0:25:22,656
在你的UI中显示的图像

445
00:25:24,491 --> 0:25:26,627
Peter 你对启动的这个阶段

446
00:25:26,693 --> 0:25:28,028
有更多的高见吗？

447
00:25:28,729 --> 0:25:31,265
当然有 在准备第一帧时

448
00:25:31,331 --> 0:25:34,268
你务必要谨慎

449
00:25:34,334 --> 0:25:37,171
并只准备你在启动时

450
00:25:37,237 --> 0:25:38,305
绝对需要的用户界面

451
00:25:38,872 --> 0:25:42,843
如果你的用户尚未导航到

452
00:25:43,210 --> 0:25:44,278
那就不要加载它

453
00:25:44,344 --> 0:25:47,748
相反 你应该将加载操作

454
00:25:48,715 --> 0:25:53,253
此外 你应该避免隐藏不应该显示的

455
00:25:53,320 --> 0:25:54,922
当我们首次导航到你的app时

456
00:25:56,023 --> 0:25:57,958
即使你隐藏了视图和图层

457
00:25:58,025 --> 0:25:59,426
它们也需要成本

458
00:25:59,493 --> 0:26:01,028
所以只引入首帧中

459
00:25:59,493 --> 0:26:01,028
所以只引入首帧中

460
00:26:01,094 --> 0:26:03,730
必要的视图和图层

461
00:26:05,699 --> 0:26:10,571
启动的最后阶段就是我们所说的

462
00:26:12,406 --> 0:26:14,908
这些是你在启动路径中

463
00:26:14,975 --> 0:26:18,679
从而帮助你更快地获得响应

464
00:26:19,646 --> 0:26:21,882
虽然你的app可能会

465
00:26:22,216 --> 0:26:24,117
但它还无法使用

466
00:26:25,652 --> 0:26:28,789
这个阶段的核心在于

467
00:26:29,456 --> 0:26:31,859
引入当前必须显示在屏幕上的内容

468
00:26:33,026 --> 0:26:35,796
并且如果要从远程服务器加载内容

469
00:26:36,330 --> 0:26:39,733
请务必考虑你可能处于

470
00:26:40,000 --> 0:26:43,971
必要时可以显示占位符UI

471
00:26:46,440 --> 0:26:48,575
所以这些就是构成启动步骤的

472
00:26:48,642 --> 0:26:50,978
五个高级组件

473
00:26:52,579 --> 0:26:54,181
我们今天还为你准备了一件事

474
00:26:55,682 --> 0:26:57,217
ABM

475
00:26:58,151 --> 0:27:01,588
A代表总是 B代表进行

476
00:26:58,151 --> 0:27:01,588
A代表总是 B代表进行

477
00:27:01,655 --> 0:27:03,590
只有快的app才能享受咖啡

478
00:27:04,358 --> 0:27:08,095
你必须了解启动时间花费最多的位置

479
00:27:08,529 --> 0:27:11,365
因此使用Time Profiler定期测量它

480
00:27:12,032 --> 0:27:15,669
每次更改启动路径中的代码时

481
00:27:15,736 --> 0:27:16,870
你都需要重新测量

482
00:27:17,304 --> 0:27:19,072
并取统计平均值

483
00:27:19,139 --> 0:27:22,176
不要依赖单次测试

484
00:27:23,977 --> 0:27:27,514
这就是极速启动部分的内容

485
00:27:27,581 --> 0:27:31,485
仅使用你需要的内容

486
00:27:31,952 --> 0:27:32,953
谢谢

487
00:27:34,821 --> 0:27:39,193
（平滑滚动）

488
00:27:39,259 --> 0:27:43,697
滚动是iOS用户体验的关键部分

489
00:27:44,131 --> 0:27:47,534
也是你app中的大部分体验

490
00:27:48,702 --> 0:27:52,039
iPhone和iPad

491
00:27:52,372 --> 0:27:55,876
它们可以变成你的app

492
00:27:57,044 --> 0:28:00,480
所以你必须努力保持这种

493
00:27:57,044 --> 0:28:00,480
所以你必须努力保持这种

494
00:28:00,547 --> 0:28:03,917
在这块神奇的玻璃板上滑动的错觉

495
00:28:05,018 --> 0:28:07,521
在Apple 我们有一句老话

496
00:28:07,588 --> 0:28:10,190
你的app应该像黄油一样平滑

497
00:28:11,491 --> 0:28:14,962
但有时候app会拖沓和卡顿

498
00:28:15,028 --> 0:28:19,032
这使它感觉不像黄油 而像是花生酱

499
00:28:20,200 --> 0:28:23,403
而且你应该遇到过这种情况

500
00:28:24,705 --> 0:28:28,342
Ben app行为缓慢

501
00:28:29,276 --> 0:28:31,945
Peter

502
00:28:32,012 --> 0:28:34,781
其实是由于我们丢帧了

503
00:28:35,215 --> 0:28:37,451
所以我们需要理解

504
00:28:37,518 --> 0:28:40,387
这可能发生在两个关键地方

505
00:28:40,954 --> 0:28:43,824
首先 你可能做了太多的计算

506
00:28:44,625 --> 0:28:49,096
其次 你可能做了太多

507
00:28:50,531 --> 0:28:53,867
让我们依次看一下这些情况

508
00:28:54,902 --> 0:28:57,404
你怎么知道是否做了太多的计算呢？

509
00:28:58,705 --> 0:29:01,508
内置于Instruments中的

510
00:28:58,705 --> 0:29:01,508
内置于Instruments中的

511
00:29:01,575 --> 0:29:02,976
是此目的的终极工具

512
00:29:03,844 --> 0:29:07,181
它可以为你提供

513
00:29:07,247 --> 0:29:09,449
执行每个代码行所需的CPU时间

514
00:29:10,150 --> 0:29:13,387
这是一个非常强大的工具

515
00:29:13,453 --> 0:29:17,691
在2016年WWDC中的演讲

516
00:29:18,926 --> 0:29:21,161
一旦你使用

517
00:29:21,228 --> 0:29:22,896
发现了这些热点

518
00:29:23,297 --> 0:29:25,966
我们为你提供了一些很棒的优化技巧

519
00:29:27,234 --> 0:29:31,572
首先是使用UICollectionView

520
00:29:32,239 --> 0:29:35,943
这些API会告诉你用户何时

521
00:29:36,009 --> 0:29:40,781
并且为你提供预加载该数据的机会

522
00:29:41,615 --> 0:29:45,586
2016年有两位非常英俊的主持人

523
00:29:45,652 --> 0:29:47,721
我非常鼓励你观看它

524
00:29:49,489 --> 0:29:53,894
我给你的下一个技巧是

525
00:29:53,961 --> 0:29:56,930
移出主队列并放入后台队列

526
00:29:57,231 --> 0:30:01,668
腾出主队列以便更新UI

527
00:29:57,231 --> 0:30:01,668
腾出主队列以便更新UI

528
00:30:02,469 --> 0:30:05,339
Ben 我们可以从主队列

529
00:30:06,073 --> 0:30:08,308
你期待的可能是一些平常的东西

530
00:30:08,375 --> 0:30:11,345
比如网络和文件系统访问

531
00:30:11,411 --> 0:30:13,480
它们永远不应该在主线程上运行

532
00:30:14,114 --> 0:30:16,216
但你可能没想到其它一些东西

533
00:30:16,283 --> 0:30:18,018
比如图像绘制和文本大小调整

534
00:30:18,919 --> 0:30:22,022
UIGraphicsImageRenderer

535
00:30:22,256 --> 0:30:24,925
都具有可在后台线程上

536
00:30:24,992 --> 0:30:27,394
这正可以帮助你

537
00:30:27,461 --> 0:30:31,598
将一些复杂计算移出主队列

538
00:30:33,200 --> 0:30:34,668
哇 Ben 这些都是很棒的技巧

539
00:30:34,735 --> 0:30:37,504
我从未想过要在主队列之外做这些事

540
00:30:38,172 --> 0:30:41,208
假设我已经运行了

541
00:30:41,275 --> 0:30:44,111
我也使用了预取

542
00:30:44,178 --> 0:30:46,947
并且我已将尽可能多的工作

543
00:30:47,748 --> 0:30:49,383
但我的app仍然很慢

544
00:30:49,917 --> 0:30:52,052
这肯定不是我的问题

545
00:30:52,986 --> 0:30:55,656
好吧 Peter

546
00:30:56,323 --> 0:30:58,725
虽然我们可能已经优化了计算

547
00:30:59,459 --> 0:31:00,928
我们仍然可能

548
00:30:59,459 --> 0:31:00,928
我们仍然可能

549
00:31:01,395 --> 0:31:02,663
遇到图形系统的问题

550
00:31:05,098 --> 0:31:07,534
幸运的是 这里有另一个很棒的工具

551
00:31:09,069 --> 0:31:12,573
Core Animation Instrument

552
00:31:12,639 --> 0:31:14,741
可以用来准确了解

553
00:31:15,275 --> 0:31:18,745
同时它还可以查看你的GPU利用率

554
00:31:19,980 --> 0:31:23,951
它是另一个非常强大的工具

555
00:31:24,017 --> 0:31:28,922
请查看2014年WWDC中的演讲

556
00:31:30,757 --> 0:31:34,094
一旦确定你的app是图形约束型的

557
00:31:34,161 --> 0:31:37,264
你就可以调查一些很易于发现的问题

558
00:31:38,332 --> 0:31:43,103
你有一个图形约束型app

559
00:31:43,604 --> 0:31:46,340
即视觉效果 或遮罩和剪裁

560
00:31:47,107 --> 0:31:49,943
视觉效果 如毛玻璃效果

561
00:31:50,010 --> 0:31:54,014
它们的代价昂贵

562
00:31:54,815 --> 0:31:59,353
你也应该避免做在模糊效果上

563
00:31:59,686 --> 0:32:03,924
因为这导致GPU在高速模式下工作

564
00:31:59,686 --> 0:32:03,924
因为这导致GPU在高速模式下工作

565
00:32:05,058 --> 0:32:09,263
此外 你应该尽可能避免遮罩和剪裁

566
00:32:09,963 --> 0:32:13,834
如果你可以在视图顶部

567
00:32:14,101 --> 0:32:17,271
即可达到相同的视觉效果

568
00:32:17,804 --> 0:32:19,439
那么我鼓励你这样做

569
00:32:19,506 --> 0:32:24,444
而不是使用UIViewer CALayer的

570
00:32:25,445 --> 0:32:28,715
这就是我们如何优化平滑滚动的性能

571
00:32:29,383 --> 0:32:31,251
确保在你的app上

572
00:32:31,318 --> 0:32:33,854
和Core Animation

573
00:32:35,022 --> 0:32:39,092
使用预取并尽可能多地

574
00:32:40,527 --> 0:32:45,098
并节制地使用视觉效果和遮罩及剪裁

575
00:32:45,899 --> 0:32:51,705
有关分析的更多信息 请查看

576
00:32:51,939 --> 0:32:52,773
谢谢

577
00:32:52,840 --> 0:32:56,643
（保持连贯性）

578
00:32:56,710 --> 0:32:57,811
连贯性

579
00:32:57,878 --> 0:33:01,215
是Apple平台上

580
00:32:57,878 --> 0:33:01,215
是Apple平台上

581
00:33:02,282 --> 0:33:06,587
而接力是真正让用户满意的绝佳方式

582
00:33:07,688 --> 0:33:10,958
能够从一台设备获取任务

583
00:33:11,291 --> 0:33:14,661
并将其无缝转移到另一台设备

584
00:33:15,229 --> 0:33:17,731
绝对是一次非常棒的体验

585
00:33:19,266 --> 0:33:22,903
接力适用于iOS

586
00:33:23,570 --> 0:33:27,374
它不需要互联网连接

587
00:33:28,675 --> 0:33:32,045
而对于你们来说最重要的是

588
00:33:34,147 --> 0:33:36,950
那么你应该如何看待在app中

589
00:33:38,085 --> 0:33:42,222
让我们来看一些我们在

590
00:33:43,924 --> 0:33:47,194
假设我从我的英俊搭档那里

591
00:33:47,594 --> 0:33:51,064
我想在我的iPhone X上

592
00:33:52,199 --> 0:33:54,635
我可以用iOS上的

593
00:33:54,968 --> 0:33:57,404
直接回到该谈话中

594
00:33:58,805 --> 0:34:02,009
或者如果我在Mac上的

595
00:33:58,805 --> 0:34:02,009
或者如果我在Mac上的

596
00:34:02,809 --> 0:34:05,846
而现在我必须离开电脑

597
00:34:06,079 --> 0:34:08,482
我可以通过点击Dock中的图标

598
00:34:10,117 --> 0:34:13,320
或者如果我随意在手表上浏览照片

599
00:34:14,254 --> 0:34:16,489
我找到了之前的一张WWDC的照片

600
00:34:16,556 --> 0:34:18,992
而我想看看那张专辑中的所有照片

601
00:34:19,726 --> 0:34:22,529
我可以在iPhone上

602
00:34:22,596 --> 0:34:24,731
而无需搜索那张照片

603
00:34:26,099 --> 0:34:28,001
接力非常强大

604
00:34:28,068 --> 0:34:30,504
它可以在设备之间传递内容时

605
00:34:30,571 --> 0:34:32,438
为你的用户节省大量时间

606
00:34:34,274 --> 0:34:36,510
我们将向你展示使用它是多么容易

607
00:34:36,909 --> 0:34:40,447
它完全建立在

608
00:34:42,049 --> 0:34:46,186
NSUserActivity

609
00:34:46,253 --> 0:34:47,688
或正在进行的活动

610
00:34:47,754 --> 0:34:49,690
在这个例子中

611
00:34:52,893 --> 0:34:57,130
创建此活动时 附近所有登陆

612
00:34:57,197 --> 0:35:01,535
都会显示接力可用

613
00:34:57,197 --> 0:35:01,535
都会显示接力可用

614
00:35:02,603 --> 0:35:04,938
在Mac上

615
00:35:06,673 --> 0:35:09,476
当你单击此邮件图标时

616
00:35:09,543 --> 0:35:12,312
该活动将转移到Mac

617
00:35:13,213 --> 0:35:16,350
而且Mail将会启动

618
00:35:18,619 --> 0:35:21,388
让我们看一下设置它所需的代码

619
00:35:24,658 --> 0:35:26,026
在源设备上

620
00:35:26,093 --> 0:35:29,596
首先要创建具有给定类型的

621
00:35:30,430 --> 0:35:32,799
此类型代表了你的用户

622
00:35:32,866 --> 0:35:34,401
当前正在进行的一种活动

623
00:35:36,103 --> 0:35:39,806
然后设置标题并将

624
00:35:40,908 --> 0:35:43,677
接着你需要填充

625
00:35:44,545 --> 0:35:47,548
你需要填入为了继续此活动

626
00:35:47,614 --> 0:35:49,750
所需的所有信息

627
00:35:50,684 --> 0:35:53,153
在这个例子中 我们用的是一个视频

628
00:35:53,220 --> 0:35:56,190
并且我们填入视频ID

629
00:35:58,225 --> 0:36:00,460
最后 你需要将此活动设置为

630
00:35:58,225 --> 0:36:00,460
最后 你需要将此活动设置为

631
00:36:00,527 --> 0:36:03,030
viewController的

632
00:36:03,997 --> 0:36:06,266
每当显示该

633
00:36:06,333 --> 0:36:08,235
这都会使它成为当前活动

634
00:36:09,503 --> 0:36:11,738
这就是你需要在源设备上

635
00:36:12,940 --> 0:36:17,077
在后续设备上

636
00:36:17,144 --> 0:36:19,446
它能够支持你创建的该活动类型

637
00:36:20,113 --> 0:36:23,851
然后你需要实现两个

638
00:36:24,651 --> 0:36:27,754
第一个是application(_:willContinue

639
00:36:28,055 --> 0:36:31,758
只要你点击或点按图标以启动接力

640
00:36:31,825 --> 0:36:33,260
就会调用此函数

641
00:36:34,428 --> 0:36:37,698
此时 我们还没有准备好

642
00:36:38,365 --> 0:36:41,101
但你知道将要继续的活动类型

643
00:36:41,435 --> 0:36:43,403
因此你就可以先开始准备UI了

644
00:36:44,705 --> 0:36:46,573
很快 你将收到

645
00:36:46,640 --> 0:36:49,176
application(_:continue:

646
00:36:49,843 --> 0:36:53,280
其将包含完全重建的

647
00:36:54,681 --> 0:36:58,685
此后你就可以设置好并在该设备上

648
00:36:58,752 --> 0:36:59,820
继续原先的体验了

649
00:37:00,921 --> 0:37:04,892
若信息多于userInfo字典中

650
00:37:04,958 --> 0:37:07,694
你可以使用NSUserActivity的

651
00:37:08,128 --> 0:37:10,097
它被称为延续流

652
00:37:10,697 --> 0:37:14,701
你所要做的就是将

653
00:37:14,768 --> 0:37:15,769
设为true

654
00:37:16,270 --> 0:37:18,705
然后在后续设备上

655
00:37:19,173 --> 0:37:22,509
你将调用

656
00:37:22,576 --> 0:37:24,011
getContinuationStreams方法

657
00:37:24,444 --> 0:37:27,447
它将为你提供输入和输出流

658
00:37:28,482 --> 0:37:32,586
在源设备上

659
00:37:32,653 --> 0:37:37,057
将收到一个回调

660
00:37:37,858 --> 0:37:41,495
通过这些管道 你就可以在源设备

661
00:37:41,562 --> 0:37:44,565
和后续设备之间进行双向通信

662
00:37:45,332 --> 0:37:48,202
但你最好尽快完成这个过程

663
00:37:48,268 --> 0:37:51,471
因为用户可能正在离开

664
00:37:52,439 --> 0:37:53,941
关于流的更多信息

665
00:37:54,007 --> 0:37:57,611
请查看developer.apple.com上的

666
00:37:58,846 --> 0:38:00,480
这非常适合传输某些

667
00:37:58,846 --> 0:38:00,480
这非常适合传输某些

668
00:38:00,547 --> 0:38:03,183
不适合放入userInfo字典

669
00:38:03,250 --> 0:38:07,487
比如图片或视频内容

670
00:38:08,322 --> 0:38:12,326
但对于基于文档的app

671
00:38:13,193 --> 0:38:15,262
因为你自动获得了很多这种行为

672
00:38:16,263 --> 0:38:20,467
UIDocument和NSDocument

673
00:38:20,734 --> 0:38:23,604
以表示当前正在编辑的文档

674
00:38:25,339 --> 0:38:28,342
这适用于存储在

675
00:38:30,043 --> 0:38:33,914
你在app中所要做的就是

676
00:38:36,283 --> 0:38:38,185
除了app到app接力

677
00:38:38,986 --> 0:38:41,855
我们还支持app到网页浏览器接力

678
00:38:43,023 --> 0:38:47,628
如果你拥有出色的网页体验

679
00:38:48,996 --> 0:38:51,832
而且后续设备未安装原生app

680
00:38:52,733 --> 0:38:57,070
你可以接力到Safari

681
00:38:58,872 --> 0:39:02,643
接力还支持网页浏览器

682
00:38:58,872 --> 0:39:02,643
接力还支持网页浏览器

683
00:39:03,510 --> 0:39:07,247
你需要在网络服务器上配置

684
00:39:07,681 --> 0:39:10,651
然后你需要在iOS app中

685
00:39:10,984 --> 0:39:12,152
添加相应的域权利

686
00:39:12,553 --> 0:39:15,022
接下来用户可以无缝地

687
00:39:15,088 --> 0:39:18,192
从你的网页体验

688
00:39:18,792 --> 0:39:23,730
关于这点的更多信息

689
00:39:25,666 --> 0:39:26,900
这就是接力

690
00:39:27,601 --> 0:39:29,770
走出去并在你的app中实现它

691
00:39:29,837 --> 0:39:33,140
从而真正让你的用户满意

692
00:39:33,440 --> 0:39:37,110
NSUserActivity API

693
00:39:37,177 --> 0:39:40,647
比如类似Spotlight搜索

694
00:39:41,882 --> 0:39:45,853
有关此内容的更多信息

695
00:39:45,919 --> 0:39:47,087
谢谢

696
00:39:56,797 --> 0:39:59,900
你写出了很棒的app和体验

697
00:40:00,868 --> 0:40:04,838
但你有时会遇到需要调查的问题

698
00:40:05,305 --> 0:40:10,177
为此我们将教你一些

699
00:40:10,544 --> 0:40:12,880
但首先要提醒一句

700
00:40:14,681 --> 0:40:17,384
在我们给你这个红药丸

701
00:40:17,451 --> 0:40:19,086
并告诉你兔子洞有多深之前

702
00:40:19,152 --> 0:40:21,955
我想告诉你我们在这部分

703
00:40:22,022 --> 0:40:24,491
虽然非常适合调试

704
00:40:24,892 --> 0:40:27,194
但不得提交到App Store

705
00:40:27,961 --> 0:40:30,397
如果你这样做 你的申请将被拒绝

706
00:40:30,464 --> 0:40:31,732
你将度过糟糕的一天

707
00:40:32,466 --> 0:40:34,535
现在有了这个警告 让我们开始吧

708
00:40:35,969 --> 0:40:38,605
首先我们将从侦探的心态开始

709
00:40:38,872 --> 0:40:41,975
你该如何处理程序中发现的问题

710
00:40:43,043 --> 0:40:44,511
接下来 我们将与你讨论

711
00:40:44,578 --> 0:40:47,514
如何调试视图和视图控制器中的问题

712
00:40:48,382 --> 0:40:50,317
我们将教你LLDB

713
00:40:50,384 --> 0:40:53,554
以及如何使用它

714
00:40:54,488 --> 0:40:56,456
最后 我们将讨论一些技巧

715
00:40:56,523 --> 0:40:59,626
用于处理你可能遇到的一些

716
00:40:59,893 --> 0:41:01,728
让你感觉糟糕的重大内存问题

717
00:40:59,893 --> 0:41:01,728
让你感觉糟糕的重大内存问题

718
00:41:02,462 --> 0:41:05,132
让我们从侦探心态开始吧

719
00:41:05,899 --> 0:41:09,570
当你查看程序中的问题时

720
00:41:09,636 --> 0:41:11,305
你需要确保验证你的假设

721
00:41:11,738 --> 0:41:13,841
你期待你的程序做什么

722
00:41:14,107 --> 0:41:16,410
然后验证它实际上正是这样做的

723
00:41:17,044 --> 0:41:20,681
当你开始调试app中的问题时

724
00:41:21,915 --> 0:41:24,117
一旦你非常确定

725
00:41:24,184 --> 0:41:25,385
你的哪个假设被违反了

726
00:41:25,986 --> 0:41:29,389
你可以从寻找线索开始

727
00:41:29,790 --> 0:41:34,094
你将使用我们在本节中

728
00:41:34,161 --> 0:41:35,796
来仔细检查你的对象和结构

729
00:41:36,697 --> 0:41:39,266
然后你需要通过更改app中的状态

730
00:41:39,933 --> 0:41:43,737
来测试你的预感

731
00:41:44,738 --> 0:41:47,841
让我们从一个示例漏洞开始

732
00:41:49,109 --> 0:41:50,911
作为Apple员工

733
00:41:50,978 --> 0:41:53,981
就是可以使用截屏编辑器

734
00:41:54,815 --> 0:41:57,184
最近我们正在调试一个问题

735
00:41:57,251 --> 0:42:01,088
即我的截屏笔工具丢失了

736
00:41:57,251 --> 0:42:01,088
即我的截屏笔工具丢失了

737
00:42:03,156 --> 0:42:06,293
Ben 有什么工具可以用来

738
00:42:07,160 --> 0:42:08,095
当然有

739
00:42:08,495 --> 0:42:11,398
Xcode中

740
00:42:12,432 --> 0:42:15,569
只需单击底部工具栏中的此图标

741
00:42:16,503 --> 0:42:19,206
Xcode会向你展示

742
00:42:19,273 --> 0:42:21,108
整个视图层次结构的3D表示

743
00:42:22,709 --> 0:42:25,846
正如你在这里看到的

744
00:42:26,313 --> 0:42:29,550
但是它们被前面的全屏视图遮挡了

745
00:42:30,551 --> 0:42:32,653
因此我们需查看

746
00:42:32,719 --> 0:42:35,189
检查顺序出了什么问题

747
00:42:35,956 --> 0:42:36,857
这很好

748
00:42:36,924 --> 0:42:38,225
Xcode视图调试器

749
00:42:38,292 --> 0:42:41,795
是调试app中视图问题的绝佳工具

750
00:42:42,863 --> 0:42:45,966
还有更多工具可以用来

751
00:42:48,035 --> 0:42:50,270
UIView recursiveDescription

752
00:42:50,671 --> 0:42:52,539
UIView _parentDescription

753
00:42:53,006 --> 0:42:56,276
以及类方法UIViewController

754
00:42:56,710 --> 0:43:00,948
是用于在app中调试视图

755
00:42:56,710 --> 0:43:00,948
是用于在app中调试视图

756
00:43:01,882 --> 0:43:03,851
同样 它们虽然很棒

757
00:43:03,917 --> 0:43:06,119
但你无法将其提交到

758
00:43:07,354 --> 0:43:10,691
重要的是要注意它们是

759
00:43:11,091 --> 0:43:13,861
因此在使用它们之前

760
00:43:13,927 --> 0:43:17,331
将调试器设为

761
00:43:18,365 --> 0:43:22,269
我们将逐步介绍每种调试方法

762
00:43:22,336 --> 0:43:23,770
以及它们如何帮助你

763
00:43:23,837 --> 0:43:26,640
先从UIView

764
00:43:28,642 --> 0:43:30,811
UIView recursiveDescription

765
00:43:31,211 --> 0:43:35,749
将打印出接收者的视图层次结构

766
00:43:36,049 --> 0:43:38,218
以及一些相关的属性

767
00:43:38,285 --> 0:43:40,420
以帮助你了解布局属性

768
00:43:41,622 --> 0:43:43,023
让我们来看一个例子

769
00:43:43,657 --> 0:43:46,527
我们的截屏UI中

770
00:43:47,561 --> 0:43:49,530
我们将在viewController的视图上

771
00:43:49,596 --> 0:43:51,565
调用recursiveDescription

772
00:43:53,767 --> 0:43:57,237
这看起来像是一面调试文本墙

773
00:43:58,972 --> 0:44:02,509
但我们知道我们在寻找什么

774
00:43:58,972 --> 0:44:02,509
但我们知道我们在寻找什么

775
00:44:02,576 --> 0:44:06,547
我们可以看到它 而在审查中

776
00:44:08,282 --> 0:44:11,318
所以我们需要看看我们在这个视图上

777
00:44:11,385 --> 0:44:13,587
并搞清楚为什么它没有显示

778
00:44:16,089 --> 0:44:18,125
除了recursiveDescription

779
00:44:18,192 --> 0:44:22,496
UIView还有parentDescription

780
00:44:22,563 --> 0:44:27,000
直到它到达一个值为nil的父视图

781
00:44:27,467 --> 0:44:29,670
它将打印相同类型的调试信息

782
00:44:32,139 --> 0:44:33,173
recursiveDescription

783
00:44:33,240 --> 0:44:36,577
和parentDescription

784
00:44:36,643 --> 0:44:40,047
但有时候你遇到的是

785
00:44:40,414 --> 0:44:43,317
为此你可以使用一个很棒的类方法

786
00:44:43,383 --> 0:44:45,752
即UIViewController

787
00:44:46,987 --> 0:44:49,756
最近我们的截屏编辑器中

788
00:44:49,823 --> 0:44:52,059
我们的一个viewController无法收到

789
00:44:52,125 --> 0:44:53,894
viewDidAppear消息

790
00:44:54,194 --> 0:44:56,296
所以它没有适当地设置其状态

791
00:44:57,231 --> 0:45:00,000
通过运行UIViewController

792
00:45:00,567 --> 0:45:03,670
我们可以获得来自以下对象的输出

793
00:45:03,904 --> 0:45:07,941
我们提供的viewController

794
00:45:08,008 --> 0:45:12,012
和childViewController

795
00:45:12,279 --> 0:45:13,714
这简直是是控制器大荟萃

796
00:45:14,448 --> 0:45:17,518
所以让我们在截屏UI中

797
00:45:19,453 --> 0:45:22,222
这里我们可以看到

798
00:45:22,523 --> 0:45:25,459
而当我们检查发生问题的

799
00:45:25,926 --> 0:45:28,662
我们可以看到

800
00:45:29,263 --> 0:45:32,699
所以我们错过了回调

801
00:45:32,766 --> 0:45:36,703
调用此回调的位置

802
00:45:37,504 --> 0:45:42,543
太棒了 通过使用这些方法

803
00:45:43,210 --> 0:45:46,280
但有时你的app存在更基本的问题

804
00:45:47,080 --> 0:45:50,083
为此我们可以使用一些

805
00:45:50,150 --> 0:45:51,251
很棒的状态调试技巧

806
00:45:51,919 --> 0:45:57,391
LLDB的表达式命令可以让你

807
00:45:57,958 --> 0:46:01,595
想想这点 你在代码编辑器中

808
00:45:57,958 --> 0:46:01,595
想想这点 你在代码编辑器中

809
00:46:01,662 --> 0:46:05,732
现在都可以在调试器中直接编写

810
00:46:06,466 --> 0:46:08,502
这对调试非常有用

811
00:46:09,169 --> 0:46:13,407
你可以调用结构上的函数

812
00:46:13,473 --> 0:46:16,143
并更好地诊断你的程序正在做什么

813
00:46:17,110 --> 0:46:18,745
有关调试的更多信息

814
00:46:19,079 --> 0:46:23,650
请观看2012年的精彩演讲

815
00:46:23,717 --> 0:46:26,854
以及2014年的演讲

816
00:46:27,821 --> 0:46:31,658
你可以在LLDB中使用表达式命令

817
00:46:31,725 --> 0:46:34,394
运行一些我们将教你的很棒的函数

818
00:46:34,461 --> 0:46:36,163
第一个是dump

819
00:46:41,368 --> 0:46:47,007
dump将打印

820
00:46:48,208 --> 0:46:52,412
我们来看看我们的一些自定义UI中

821
00:46:53,647 --> 0:46:58,785
我们有包含些子视图的视图

822
00:46:59,052 --> 0:47:01,188
而现在我们的一个标签丢失了

823
00:46:59,052 --> 0:47:01,188
而现在我们的一个标签丢失了

824
00:47:02,256 --> 0:47:04,224
因此我们将在父视图上运行dump

825
00:47:04,992 --> 0:47:06,593
并看看这里发生了什么

826
00:47:07,761 --> 0:47:12,933
我们发现了丢失的标签 它就在这里

827
00:47:13,000 --> 0:47:14,935
位于它旁边的imageView

828
00:47:15,669 --> 0:47:19,273
我们注意到这两者的frame属性

829
00:47:19,339 --> 0:47:21,008
都具有相同的源

830
00:47:22,042 --> 0:47:26,313
所以这里可能发生的是

831
00:47:27,214 --> 0:47:29,583
因此我想我们需要再次查看

832
00:47:31,451 --> 0:47:34,555
除了对Swift对象的

833
00:47:35,656 --> 0:47:37,925
如果你还有一些

834
00:47:38,492 --> 0:47:41,695
NSObject也有

835
00:47:42,696 --> 0:47:43,730
这将打印出

836
00:47:43,797 --> 0:47:47,000
Objective-C对象的

837
00:47:48,435 --> 0:47:50,771
我们的截屏代码中还有另一个漏洞

838
00:47:51,371 --> 0:47:53,740
我们的裁剪处理功能

839
00:47:55,342 --> 0:47:58,779
如果我们在截屏的视图中调用

840
00:47:59,613 --> 0:48:02,149
我们仔细观察可以看到

841
00:47:59,613 --> 0:48:02,149
我们仔细观察可以看到

842
00:48:02,216 --> 0:48:06,286
cropEnabled ivar

843
00:48:07,721 --> 0:48:10,624
因此我们知道从哪开始研究这个漏洞

844
00:48:11,825 --> 0:48:12,960
这很棒

845
00:48:13,026 --> 0:48:15,762
使用dump

846
00:48:15,829 --> 0:48:18,832
是诊断app问题的好方法

847
00:48:20,200 --> 0:48:24,738
我们为你准备的另一个很棒的

848
00:48:25,606 --> 0:48:29,743
断点可以让你在任意执行状态下

849
00:48:30,244 --> 0:48:31,578
并运行命令

850
00:48:32,446 --> 0:48:36,683
并且通过使用

851
00:48:37,050 --> 0:48:40,220
你甚至可以在运行这些断点之前

852
00:48:40,721 --> 0:48:43,590
并且设置每次命中断点时

853
00:48:44,558 --> 0:48:47,694
断点是调试工作流程的重要组成部分

854
00:48:48,028 --> 0:48:52,533
你可以在Xcode中设置的断点中

855
00:48:52,599 --> 0:48:54,568
dump

856
00:48:54,902 --> 0:48:57,504
我真的鼓励你下次调试app问题时

857
00:48:57,571 --> 0:48:59,940
能够使用断点

858
00:49:01,375 --> 0:49:04,745
但有时我们的view

859
00:49:05,345 --> 0:49:07,347
我们的状态也没有问题

860
00:49:08,048 --> 0:49:11,185
我们遇到的是一个非常棘手的

861
00:49:12,319 --> 0:49:14,288
Ben 为此我们有何工具使用吗？

862
00:49:15,322 --> 0:49:16,623
我很高兴你问这个问题 Peter

863
00:49:16,690 --> 0:49:19,960
因为Xcode中

864
00:49:20,427 --> 0:49:21,862
即Xcode内存调试器

865
00:49:23,530 --> 0:49:27,868
此工具将帮助你可视化

866
00:49:29,570 --> 0:49:31,405
Peter和我

867
00:49:31,471 --> 0:49:33,073
我们有一个泄漏的

868
00:49:33,841 --> 0:49:36,610
这里我们可以看到

869
00:49:37,778 --> 0:49:39,813
通过启用Malloc堆栈日志记录

870
00:49:39,880 --> 0:49:44,151
我们能够看到分配此块时的完整回溯

871
00:49:46,019 --> 0:49:47,754
通过放大 我们可以看到这个块

872
00:49:47,821 --> 0:49:50,490
实际上由该

873
00:49:51,358 --> 0:49:53,961
因此那个块持有着

874
00:49:54,027 --> 0:49:56,296
但该viewController

875
00:49:57,164 --> 0:49:58,432
这就是一个持有循环

876
00:49:59,633 --> 0:50:02,469
哇 太棒了

877
00:49:59,633 --> 0:50:02,469
哇 太棒了

878
00:50:02,536 --> 0:50:06,373
是一款非常棒的工具

879
00:50:07,007 --> 0:50:11,678
欲了解更多 查看2017年的演讲

880
00:50:13,280 --> 0:50:16,350
以上就是如何像专业人士一样

881
00:50:18,785 --> 0:50:21,088
每当你遇到程序问题时

882
00:50:21,154 --> 0:50:23,824
记住一定要像侦探一样思考

883
00:50:25,192 --> 0:50:27,561
使用Xcode视图调试器

884
00:50:27,628 --> 0:50:32,366
和内存图调试器深入研究

885
00:50:33,066 --> 0:50:38,539
并使用LLDB的

886
00:50:38,605 --> 0:50:41,475
以及我们在这里谈到的

887
00:50:44,545 --> 0:50:45,445
谢谢

888
00:50:52,286 --> 0:50:55,956
今天早上我们讨论了

889
00:50:56,023 --> 0:50:57,124
甚至今天下午

890
00:50:58,659 --> 0:51:00,561
但这些仍只是一些皮毛

891
00:50:58,659 --> 0:51:00,561
但这些仍只是一些皮毛

892
00:51:00,827 --> 0:51:03,363
我们鼓励你查看我们在整个演讲中

893
00:51:03,430 --> 0:51:04,865
所引用的那些演讲

894
00:51:04,932 --> 0:51:07,734
并为你的app增添更多光彩

895
00:51:08,435 --> 0:51:13,140
更多相关信息

896
00:51:13,207 --> 0:51:14,808
我们希望你们享受这次大会

897
00:51:14,875 --> 0:51:15,709
谢谢
