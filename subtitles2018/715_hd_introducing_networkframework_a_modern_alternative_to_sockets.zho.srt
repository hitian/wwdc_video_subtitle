1
00:00:17,784 --> 0:00:19,820
（Network.framework简介

2
00:00:19,887 --> 0:00:20,721
（演讲715）

3
00:00:20,787 --> 0:00:21,655
早上好

4
00:00:22,990 --> 0:00:24,191
我叫Josh Graessley

5
00:00:24,258 --> 0:00:26,293
我很高兴今天早上能来到这里

6
00:00:26,360 --> 0:00:28,228
向你介绍

7
00:00:30,531 --> 0:00:33,467
Network.framework

8
00:00:33,934 --> 0:00:37,738
今天我们将讨论现代化传输API

9
00:00:37,804 --> 0:00:39,773
这将提供一些背景知识以便你理解

10
00:00:39,840 --> 0:00:43,110
Network.framework是什么

11
00:00:43,377 --> 0:00:46,146
以及你的app是否应该使用它

12
00:00:47,247 --> 0:00:48,782
我们将通过引导你完成

13
00:00:48,849 --> 0:00:51,285
第一次连接来向你介绍其API

14
00:00:52,186 --> 0:00:54,621
我们将讨论如何使用此API

15
00:00:54,688 --> 0:00:56,890
来真正优化你的数据传输

16
00:00:56,957 --> 0:01:00,127
并提供远超套接字所能提供的性能

17
00:00:56,957 --> 0:01:00,127
并提供远超套接字所能提供的性能

18
00:01:01,261 --> 0:01:02,663
我们将讨论这个API

19
00:01:02,729 --> 0:01:05,232
如何帮助你应对

20
00:01:05,399 --> 0:01:07,935
最后我们将提供一些

21
00:01:08,001 --> 0:01:09,269
并开始使用的信息

22
00:01:10,270 --> 0:01:11,104
首先…

23
00:01:11,238 --> 0:01:15,108
我想花一点时间谈论

24
00:01:15,642 --> 0:01:17,177
当我说传输API时

25
00:01:17,244 --> 0:01:19,112
我在谈论这样的API

26
00:01:19,179 --> 0:01:21,381
即它可以让你在网络上两个端点之间

27
00:01:21,448 --> 0:01:23,350
发送和接收任意数据

28
00:01:23,684 --> 0:01:25,152
这是一个相当广泛的定义

29
00:01:25,219 --> 0:01:28,188
有很多API可能属于此类别

30
00:01:30,290 --> 0:01:32,659
也许其中应用最广泛的就是套接字

31
00:01:32,826 --> 0:01:35,229
我们使用套接字已经有30多年了

32
00:01:35,395 --> 0:01:36,897
而且我认为

33
00:01:36,964 --> 0:01:38,899
说套接字改变了世界并不夸张

34
00:01:39,266 --> 0:01:40,801
但世界一直在变化

35
00:01:41,068 --> 0:01:42,202
其结果是

36
00:01:42,736 --> 0:01:46,840
使用套接字为今天的互联网

37
00:01:47,241 --> 0:01:50,410
在三个主要领域中

38
00:01:50,477 --> 0:01:51,812
非常困难

39
00:01:53,146 --> 0:01:55,249
第一个是建立连接

40
00:01:55,516 --> 0:01:58,986
有很多原因导致使用套接字

41
00:01:59,119 --> 0:02:00,954
来建立连接非常困难

42
00:01:59,119 --> 0:02:00,954
来建立连接非常困难

43
00:02:01,455 --> 0:02:03,957
首先 套接字连接到地址

44
00:02:04,191 --> 0:02:06,927
所以大多数时候你需要有一个主机名

45
00:02:06,994 --> 0:02:09,663
并且你必须将该主机名

46
00:02:10,497 --> 0:02:11,832
当你这样做时

47
00:02:11,899 --> 0:02:13,700
你通常会得到多个地址

48
00:02:13,800 --> 0:02:17,404
你会得到一些IPv4地址

49
00:02:18,071 --> 0:02:19,206
现在你遇到了这个挑战

50
00:02:19,273 --> 0:02:21,008
你应该尝试连接哪个地址

51
00:02:21,074 --> 0:02:21,942
以什么顺序

52
00:02:22,009 --> 0:02:23,877
你在尝试下一个之前等待多久

53
00:02:24,244 --> 0:02:26,413
你可以花费数年时间来完善这一点

54
00:02:26,680 --> 0:02:28,215
我知道

55
00:02:30,150 --> 0:02:32,719
一旦你解决了双协议栈主机问题

56
00:02:33,020 --> 0:02:35,088
你还会遇到更多其它问题

57
00:02:35,389 --> 0:02:36,957
有些网络使用一种

58
00:02:37,024 --> 0:02:39,660
叫做代理自动配置或PAC的东西

59
00:02:40,027 --> 0:02:42,529
在这些网络上

60
00:02:42,696 --> 0:02:44,898
并且你必须将一个URL

61
00:02:45,098 --> 0:02:47,434
然后JavaScript

62
00:02:47,634 --> 0:02:50,070
其中说明你可以直接连接

63
00:02:50,137 --> 0:02:52,406
或是你必须使用这个SOCKS代理

64
00:02:52,472 --> 0:02:54,608
或者那个HTTP连接代理

65
00:02:54,875 --> 0:02:57,144
这样你的app就必须

66
00:02:57,211 --> 0:02:58,979
和HTTP连接代理

67
00:02:59,313 --> 0:03:01,248
这真的很难做好

68
00:02:59,313 --> 0:03:01,248
这真的很难做好

69
00:03:01,949 --> 0:03:03,150
最困难的事情

70
00:03:03,217 --> 0:03:05,419
是你可能没有其中一个网络以供测试

71
00:03:05,619 --> 0:03:08,288
所以你可能会收到

72
00:03:08,555 --> 0:03:10,757
他们可能会抱怨它在他们的环境下

73
00:03:10,824 --> 0:03:11,859
无法正常工作

74
00:03:12,092 --> 0:03:14,194
你可能想要添加代码来解决问题

75
00:03:14,695 --> 0:03:15,529
但…

76
00:03:15,729 --> 0:03:16,730
尽管你修改了代码

77
00:03:16,797 --> 0:03:18,265
你却无法测试它

78
00:03:18,332 --> 0:03:20,100
你最终必须构建整个环境

79
00:03:20,167 --> 0:03:22,002
来重现其所在的相同环境

80
00:03:22,503 --> 0:03:23,971
这是一个真正的挑战

81
00:03:24,738 --> 0:03:27,074
所以用套接字连接真的很难

82
00:03:28,542 --> 0:03:30,978
使用套接字的第二个挑战

83
00:03:31,044 --> 0:03:32,346
是数据传输

84
00:03:32,946 --> 0:03:35,449
使用套接字传输数据非常困难

85
00:03:35,516 --> 0:03:36,583
这有很多原因

86
00:03:37,885 --> 0:03:41,722
主要的问题是读写模型本身

87
00:03:42,656 --> 0:03:45,259
如果你使用阻塞套接字

88
00:03:45,759 --> 0:03:46,960
但是你要绑定一个线程

89
00:03:47,094 --> 0:03:49,730
而在等待读取或写入数据时

90
00:03:49,796 --> 0:03:51,431
真的不是一个好主意

91
00:03:52,099 --> 0:03:54,301
你可以切换到非阻塞

92
00:03:54,368 --> 0:03:56,470
但最终你会遇到更多其它挑战

93
00:03:57,371 --> 0:03:58,605
当你使用非阻塞时

94
00:03:58,672 --> 0:04:00,707
你可能告诉内核

95
00:03:58,672 --> 0:04:00,707
你可能告诉内核

96
00:04:00,841 --> 0:04:03,577
而内核可能会回答说

97
00:04:03,644 --> 0:04:04,778
你为何不稍后再回来呢

98
00:04:04,945 --> 0:04:06,113
你必须建立一个状态机

99
00:04:06,180 --> 0:04:07,548
以跟踪你读取的字节数

100
00:04:07,614 --> 0:04:09,016
与你想要读取的字节数

101
00:04:09,216 --> 0:04:11,885
这个工作量可能会很大

102
00:04:11,952 --> 0:04:13,153
可能是一个真正的挑战

103
00:04:14,555 --> 0:04:15,689
最重要的是

104
00:04:15,756 --> 0:04:17,991
你真的不应该直接读写套接字

105
00:04:18,058 --> 0:04:20,627
因为你应该使用安全传输层协议

106
00:04:20,694 --> 0:04:21,728
即TLS之类的东西

107
00:04:24,097 --> 0:04:25,766
套接字不支持TLS

108
00:04:25,832 --> 0:04:28,001
所以你可能正在使用其它一些库

109
00:04:28,402 --> 0:04:30,971
它们会为你处理TLS

110
00:04:31,038 --> 0:04:33,040
并替你读取和写入套接字

111
00:04:33,106 --> 0:04:35,943
或者你也可以编写

112
00:04:36,109 --> 0:04:37,744
而且你必须弄清楚如何预先放入

113
00:04:37,811 --> 0:04:40,113
那些复杂的连接逻辑

114
00:04:41,515 --> 0:04:43,283
这里有很多东西可能非常困难

115
00:04:45,285 --> 0:04:48,088
最后 使用套接字对移动性

116
00:04:48,388 --> 0:04:49,690
这有多种原因

117
00:04:51,225 --> 0:04:55,262
我认为这很大程度上归结于

118
00:04:56,029 --> 0:04:58,632
许多设备需要不止一个人来移动它们

119
00:04:58,699 --> 0:05:00,434
而且它们只用一根网线连接

120
00:04:58,699 --> 0:05:00,434
而且它们只用一根网线连接

121
00:05:00,501 --> 0:05:03,904
并且它们只有一个静态IP地址

122
00:05:04,304 --> 0:05:08,375
而今天我们的口袋里

123
00:05:08,442 --> 0:05:11,612
其可能同时开启多射频

124
00:05:11,945 --> 0:05:14,381
并且其中一些正在从一个网络

125
00:05:14,515 --> 0:05:17,317
而你的app必须很好地处理

126
00:05:17,384 --> 0:05:19,686
来为你的客户提供无缝体验

127
00:05:22,656 --> 0:05:24,925
套接字无法帮你解决此问题

128
00:05:25,092 --> 0:05:28,161
你可以使用路由套接字

129
00:05:28,495 --> 0:05:30,631
我们认为传输API可以做得更好

130
00:05:32,165 --> 0:05:35,469
幸运的是 在我们的平台上

131
00:05:35,536 --> 0:05:38,071
你在URLSession中

132
00:05:39,006 --> 0:05:42,409
URLSession

133
00:05:43,110 --> 0:05:46,346
它真正专注于HTTP

134
00:05:46,547 --> 0:05:49,917
它能为你提供

135
00:05:51,151 --> 0:05:52,486
现在你可能正在看这幅图

136
00:05:52,786 --> 0:05:55,222
并且如果你没有通过查看

137
00:05:55,289 --> 0:05:56,590
WWDC app中的描述而作弊

138
00:05:56,924 --> 0:06:00,527
你可能认为URLSession

139
00:05:56,924 --> 0:06:00,527
你可能认为URLSession

140
00:06:00,594 --> 0:06:02,095
相同的原语所构建的

141
00:06:03,297 --> 0:06:04,932
但事实并非如此

142
00:06:05,899 --> 0:06:09,236
URLSession建立在我们称之为

143
00:06:10,037 --> 0:06:13,407
URLSession

144
00:06:13,907 --> 0:06:17,578
它将很多传输功能委托给

145
00:06:20,948 --> 0:06:22,749
我们研发

146
00:06:22,816 --> 0:06:24,017
已经有许多年了

147
00:06:24,218 --> 0:06:26,653
在支持URLSession方面

148
00:06:26,954 --> 0:06:29,556
并且我们把很多这些经验

149
00:06:29,623 --> 0:06:33,126
我们的许多工程师经常参加IETF

150
00:06:33,193 --> 0:06:35,028
并与其它公司的工程师见面

151
00:06:35,229 --> 0:06:36,930
他们讨论了许多

152
00:06:36,997 --> 0:06:38,799
我们在传输服务工作组中

153
00:06:39,032 --> 0:06:41,401
在这些讨论中

154
00:06:41,468 --> 0:06:43,670
我们研究这些反馈

155
00:06:43,737 --> 0:06:44,605
改进

156
00:06:45,439 --> 0:06:47,908
我们很高兴地宣布

157
00:06:47,975 --> 0:06:52,179
今年你的app

158
00:06:58,552 --> 0:07:01,154
我们知道人们喜欢套接字的原因之一

159
00:06:58,552 --> 0:07:01,154
我们知道人们喜欢套接字的原因之一

160
00:07:01,221 --> 0:07:04,825
是它给予人们

161
00:07:05,125 --> 0:07:06,527
而他们真的不想失去这点

162
00:07:07,294 --> 0:07:08,896
因此我们在开发

163
00:07:08,962 --> 0:07:11,932
我们希望确保默认情况下

164
00:07:12,065 --> 0:07:13,534
而套接字不会这样做

165
00:07:13,800 --> 0:07:16,303
但同时它也给了你

166
00:07:16,470 --> 0:07:20,207
并且它是以一种渐进的方式

167
00:07:20,274 --> 0:07:21,575
它变得越复杂

168
00:07:22,142 --> 0:07:23,744
它为你提供所需的所有功能

169
00:07:24,044 --> 0:07:25,746
但你不必为复杂性付出代价

170
00:07:25,812 --> 0:07:27,548
除非你真的需要它

171
00:07:30,317 --> 0:07:34,154
Network.framework

172
00:07:34,755 --> 0:07:36,823
它能处理双协议栈用例

173
00:07:36,890 --> 0:07:38,592
它能处理仅IPv6网络

174
00:07:38,825 --> 0:07:39,793
它能处理PAC

175
00:07:39,860 --> 0:07:41,128
它也能处理代理

176
00:07:41,595 --> 0:07:42,429
它会…

177
00:07:42,729 --> 0:07:45,666
帮助你连接在不使用它的情况下

178
00:07:45,732 --> 0:07:46,567
很难处理的网络

179
00:07:47,034 --> 0:07:49,937
它具有令人难以置信的

180
00:07:50,237 --> 0:07:51,939
其性能要远远超过

181
00:07:52,005 --> 0:07:54,808
套接字可以达到的效果

182
00:07:56,210 --> 0:07:57,945
它支持内置安全性

183
00:07:58,245 --> 0:08:01,281
它默认支持TLS和DTLS

184
00:07:58,245 --> 0:08:01,281
它默认支持TLS和DTLS

185
00:08:01,348 --> 0:08:02,916
它使用起来非常简单

186
00:08:04,184 --> 0:08:06,253
它对移动性有很好的支持

187
00:08:06,320 --> 0:08:08,622
它提供有关网络更改的通知

188
00:08:08,689 --> 0:08:12,125
其与你的app正在建立的连接相关

189
00:08:14,761 --> 0:08:19,032
它可以在iOS、macOS

190
00:08:19,166 --> 0:08:20,367
作为带有自动引用计数的

191
00:08:20,434 --> 0:08:24,571
它很容易在Objective C中使用

192
00:08:26,807 --> 0:08:29,009
我想把话筒交给

193
00:08:29,076 --> 0:08:30,978
他会引导你完成你的第一次连接

194
00:08:31,378 --> 0:08:32,212
谢谢

195
00:08:38,719 --> 0:08:39,986
好的 大家好

196
00:08:40,053 --> 0:08:41,121
我叫Tommy Pauly

197
00:08:41,188 --> 0:08:43,823
我在Apple的网络团队工作

198
00:08:44,658 --> 0:08:47,995
我相信很多人都很高兴能够看到

199
00:08:48,061 --> 0:08:52,165
如何开始在你的app中

200
00:08:53,267 --> 0:08:54,902
开始学习并立即尝试的最好方式

201
00:08:55,169 --> 0:08:57,771
就是尝试建立你的第一个连接

202
00:08:58,539 --> 0:09:00,841
你将从本地设备建立连接

203
00:08:58,539 --> 0:09:00,841
你将从本地设备建立连接

204
00:09:01,108 --> 0:09:02,009
到你的服务器

205
00:09:02,543 --> 0:09:05,479
或本地网络上的其它对等设备

206
00:09:07,114 --> 0:09:08,348
但你可能在想

207
00:09:08,916 --> 0:09:11,318
哪种连接适合使用

208
00:09:11,385 --> 0:09:12,452
Network.framework呢

209
00:09:12,653 --> 0:09:13,887
有什么用例？

210
00:09:14,521 --> 0:09:20,027
让我们首先探讨一些可能正在使用

211
00:09:20,460 --> 0:09:23,197
它们若能在以后利用

212
00:09:23,263 --> 0:09:24,965
将会大有裨益

213
00:09:26,900 --> 0:09:28,669
我要强调的第一种

214
00:09:29,136 --> 0:09:30,370
是游戏app

215
00:09:30,971 --> 0:09:35,042
游戏app通常使用UDP

216
00:09:35,108 --> 0:09:38,412
关于游戏状态的数据

217
00:09:39,446 --> 0:09:42,182
它们非常重视优化延迟

218
00:09:42,316 --> 0:09:44,985
并确保没有任何滞后

219
00:09:45,953 --> 0:09:47,688
如果你有这样的app

220
00:09:48,288 --> 0:09:50,190
你会爱上

221
00:09:50,257 --> 0:09:52,693
因为它允许你真正优化UDP

222
00:09:52,893 --> 0:09:56,830
发送和接收比以往更快

223
00:09:56,897 --> 0:09:58,765
以及具有尽可能短的延迟时间

224
00:10:00,968 --> 0:10:01,969
另一种能够得益于

225
00:10:02,035 --> 0:10:04,438
Network.framework的

226
00:10:04,838 --> 0:10:06,440
是直播app

227
00:10:06,673 --> 0:10:08,775
直播app

228
00:10:08,842 --> 0:10:10,477
通常在app中结合使用UDP

229
00:10:10,777 --> 0:10:12,579
和TCP

230
00:10:13,313 --> 0:10:17,484
但这里的关键点是

231
00:10:17,885 --> 0:10:20,654
如果你有新的视频帧或音频帧

232
00:10:20,821 --> 0:10:23,056
你需要确保它们步调一致

233
00:10:23,190 --> 0:10:24,992
而且你不会在设备或网络上

234
00:10:25,058 --> 0:10:27,461
造成很多缓冲

235
00:10:28,629 --> 0:10:31,698
Network.framework中

236
00:10:31,999 --> 0:10:33,834
可以完美的应用于

237
00:10:34,067 --> 0:10:36,036
确保你能够减少这种缓冲

238
00:10:38,238 --> 0:10:42,075
我要强调的最后一个用例

239
00:10:42,910 --> 0:10:45,879
这些app将使用更传统的协议

240
00:10:45,946 --> 0:10:48,081
即TCP上的TLS

241
00:10:48,916 --> 0:10:51,051
然而优雅地处理网络转换

242
00:10:51,118 --> 0:10:53,587
对于像这样的app来说非常重要

243
00:10:55,355 --> 0:10:59,026
通常 如果你有一个消息传递app

244
00:10:59,092 --> 0:11:00,494
使用你的app

245
00:10:59,092 --> 0:11:00,494
使用你的app

246
00:11:00,561 --> 0:11:03,096
给他的朋友发消息让他们知道

247
00:11:03,630 --> 0:11:06,333
你想确保你能够处理这种转变

248
00:11:06,400 --> 0:11:07,801
从大楼内的Wi-Fi网络

249
00:11:07,868 --> 0:11:09,670
切换到他即将进入的蜂窝网络

250
00:11:10,037 --> 0:11:12,339
并且你没有用很长时间来将消息

251
00:11:12,406 --> 0:11:13,874
送到他的朋友那里

252
00:11:15,342 --> 0:11:18,212
这些只是可能会使用

253
00:11:18,278 --> 0:11:20,647
三种类型的app

254
00:11:21,481 --> 0:11:24,585
还有许多其它类型的app

255
00:11:24,651 --> 0:11:26,453
所以如果你有一个这些类型的app

256
00:11:26,854 --> 0:11:29,389
或当前使用套接字的其它一些用例

257
00:11:29,456 --> 0:11:33,627
我邀请你继续跟随我

258
00:11:34,795 --> 0:11:37,464
首先我想专注于最后一个用例

259
00:11:37,631 --> 0:11:40,167
最简单的邮件和消息app用例

260
00:11:40,234 --> 0:11:42,569
并看下他们如何建立连接

261
00:11:44,538 --> 0:11:47,174
当你想建立与服务器的连接时

262
00:11:47,241 --> 0:11:52,646
假设这是一个邮件连接 即带有

263
00:11:53,447 --> 0:11:56,517
你从主机名

264
00:11:57,251 --> 0:12:00,087
你有一个要连接的端口

265
00:11:57,251 --> 0:12:00,087
你有一个要连接的端口

266
00:12:00,687 --> 0:12:03,757
并且你希望使用TLS

267
00:12:05,058 --> 0:12:07,594
那么传统的套接字是如何做的呢

268
00:12:08,362 --> 0:12:09,997
这样的事情开始了

269
00:12:10,397 --> 0:12:11,565
你得到该主机名

270
00:12:11,999 --> 0:12:14,868
你会调用一些DNS API

271
00:12:15,068 --> 0:12:16,770
若它是getaddrinfo()

272
00:12:17,271 --> 0:12:19,072
你将得到一个或多个地址

273
00:12:19,139 --> 0:12:21,642
你必须决定要先连接哪一个

274
00:12:22,476 --> 0:12:25,345
你将调用socket()

275
00:12:26,346 --> 0:12:28,715
你将设置一系列套接字选项

276
00:12:29,049 --> 0:12:33,020
假设你希望使用非阻塞套接字

277
00:12:34,655 --> 0:12:39,159
调用connect()启动TCP

278
00:12:39,927 --> 0:12:42,429
而且这是在你使用TLS

279
00:12:42,496 --> 0:12:44,531
那又是一大堆其它问题

280
00:12:46,400 --> 0:12:48,535
这在Network.framework中

281
00:12:48,669 --> 0:12:50,938
我们希望它看起来很熟悉

282
00:12:51,905 --> 0:12:53,106
但更简单一些

283
00:12:53,707 --> 0:12:56,276
所以你做的第一件事

284
00:12:56,343 --> 0:12:58,812
连接对象基于两件事

285
00:12:59,046 --> 0:12:59,980
第一个是端点

286
00:13:00,047 --> 0:13:02,182
它定义了你要访问的目标

287
00:13:02,549 --> 0:13:05,886
这可能是像以前那样的IP地址

288
00:13:06,253 --> 0:13:09,923
但通常 就像在这个例子中

289
00:13:10,157 --> 0:13:13,026
所以我们的端点

290
00:13:13,427 --> 0:13:16,163
这也可能是

291
00:13:17,397 --> 0:13:19,233
接下来是参数

292
00:13:19,499 --> 0:13:22,002
参数定义了我想要使用的协议

293
00:13:22,202 --> 0:13:24,872
TLS、DTLS、UDP、TCP

294
00:13:25,372 --> 0:13:27,841
它定义了我想要用的协议选项

295
00:13:28,609 --> 0:13:31,445
以及我想用来连接的路径

296
00:13:31,645 --> 0:13:34,915
即我是想使用任何东西连接呢

297
00:13:36,250 --> 0:13:38,452
一旦你配置好连接后

298
00:13:38,852 --> 0:13:41,255
你只需要调用start()

299
00:13:41,588 --> 0:13:44,391
然后等待连接进入就绪状态

300
00:13:44,791 --> 0:13:45,659
这就是为了建立完整TLS连接

301
00:13:45,726 --> 0:13:48,061
你需要做的所有事情

302
00:13:48,862 --> 0:13:51,298
而且我认为你会喜欢

303
00:13:52,766 --> 0:13:53,600
这就是你所要做的

304
00:13:53,667 --> 0:13:56,170
你首先导入Network模块

305
00:13:57,404 --> 0:14:00,474
然后你创建一个

306
00:13:57,404 --> 0:14:00,474
然后你创建一个

307
00:14:00,707 --> 0:14:02,042
所以一个NWConnection

308
00:14:02,376 --> 0:14:04,244
无论是在Swift还是C中

309
00:14:04,511 --> 0:14:07,247
都是读取和写入数据的基本对象

310
00:14:08,415 --> 0:14:11,685
在这个例子中

311
00:14:11,818 --> 0:14:13,020
来初始化你的端点

312
00:14:13,287 --> 0:14:16,356
所以我给它我的主机名

313
00:14:16,857 --> 0:14:18,292
以及端口 在这个例子中

314
00:14:18,358 --> 0:14:19,760
这是一个众所周知的端口

315
00:14:20,027 --> 0:14:21,295
即iMaps

316
00:14:21,528 --> 0:14:23,830
所以我可以把它放在Swift中

317
00:14:23,897 --> 0:14:27,100
但我也可以在那里输入

318
00:14:28,569 --> 0:14:30,737
然后我通过传入参数来定义

319
00:14:30,804 --> 0:14:32,005
我想要使用的协议

320
00:14:32,706 --> 0:14:34,374
由于这是客户端连接

321
00:14:34,441 --> 0:14:37,544
我只想要默认 TLS和TCP参数

322
00:14:38,111 --> 0:14:40,681
只需要输入.tls

323
00:14:40,948 --> 0:14:43,050
现在我有了一个完整的TLS连接

324
00:14:45,118 --> 0:14:47,554
我做的下一件事就是设置

325
00:14:47,621 --> 0:14:50,724
来处理我的连接可能经历的所有切换

326
00:14:51,592 --> 0:14:53,961
你要处理的第一个

327
00:14:54,127 --> 0:14:55,362
就是就绪状态

328
00:14:55,863 --> 0:14:59,967
就绪意味着你的app已准备好

329
00:15:00,033 --> 0:15:01,301
连接已经完全建立

330
00:15:01,802 --> 0:15:04,471
如果你使用的是TCP和TLS

331
00:15:04,538 --> 0:15:06,507
这意味着TLS握手已完成

332
00:15:08,342 --> 0:15:11,345
我们也会告知你等待状态

333
00:15:11,778 --> 0:15:16,416
去年在URLSession中

334
00:15:16,583 --> 0:15:20,153
而NWConnection的

335
00:15:20,420 --> 0:15:22,556
而且默认情况下它始终处于启用状态

336
00:15:22,789 --> 0:15:24,758
因此当你创建连接并启动它时

337
00:15:24,825 --> 0:15:27,828
如果没有可用的网络

338
00:15:28,095 --> 0:15:30,664
我们只是告诉你

339
00:15:30,731 --> 0:15:32,833
我们会给你一个有用的原因代码

340
00:15:33,300 --> 0:15:36,803
但你不必再做任何其它事情

341
00:15:37,404 --> 0:15:40,607
移动性是此API的重要组成部分

342
00:15:41,842 --> 0:15:44,144
如果出现严重错误 我们也会通知你

343
00:15:44,211 --> 0:15:47,247
假设我们必须从服务器重置

344
00:15:47,314 --> 0:15:49,116
我们会将其作为失败事件告知你

345
00:15:50,517 --> 0:15:51,652
一旦你设置好了这些

346
00:15:52,252 --> 0:15:53,487
只需调用start()

347
00:15:53,754 --> 0:15:58,358
并提供你希望接收回调的调度队列

348
00:16:00,360 --> 0:16:03,096
我想深入探讨一下

349
00:16:03,163 --> 0:16:04,464
实际发生了什么

350
00:16:05,499 --> 0:16:06,767
NWConnection的

351
00:16:07,201 --> 0:16:09,269
是一个小状态机

352
00:16:09,770 --> 0:16:11,905
当我们从设置状态开始

353
00:16:12,372 --> 0:16:14,775
我们进入准备状态

354
00:16:14,842 --> 0:16:16,310
（连接生命周期）

355
00:16:16,376 --> 0:16:18,145
准备状态

356
00:16:18,612 --> 0:16:22,783
它不仅仅是在TCP套接字上

357
00:16:23,550 --> 0:16:24,952
对于TCP套接字

358
00:16:25,018 --> 0:16:28,655
这会将SYN数据包发送到

359
00:16:28,722 --> 0:16:29,656
想要连接的服务器

360
00:16:30,824 --> 0:16:32,926
但当你在NWConnection上

361
00:16:32,993 --> 0:16:36,330
它实际上处理了

362
00:16:37,531 --> 0:16:39,233
它会评估你所在的网络

363
00:16:39,299 --> 0:16:42,369
并尝试为你提供最快的连接

364
00:16:42,769 --> 0:16:44,538
我想继续深入讨论一下

365
00:16:44,972 --> 0:16:48,475
所以这就是我们所说的

366
00:16:49,943 --> 0:16:51,678
当你调用start()时

367
00:16:52,012 --> 0:16:53,213
我们所做的第一件事是

368
00:16:53,780 --> 0:16:55,115
我们获取你的端点

369
00:16:55,749 --> 0:16:57,584
然后我们评估当前可用的

370
00:16:57,651 --> 0:16:59,119
所有网络是什么

371
00:16:59,786 --> 0:17:02,556
在这个例子中

372
00:16:59,786 --> 0:17:02,556
在这个例子中

373
00:17:03,056 --> 0:17:07,361
通常我们更喜欢Wi-Fi网络

374
00:17:08,028 --> 0:17:09,463
所以我们先看看那个

375
00:17:10,998 --> 0:17:14,667
然后我们检查一下

376
00:17:14,734 --> 0:17:16,569
有VPN吗？有代理吗？

377
00:17:16,637 --> 0:17:18,405
我们将为你评估

378
00:17:19,339 --> 0:17:20,240
在这个例子中

379
00:17:20,473 --> 0:17:25,212
假设有一个配置了

380
00:17:25,512 --> 0:17:27,748
如果代理不适用于你的连接

381
00:17:28,048 --> 0:17:30,250
它也可以直连

382
00:17:30,551 --> 0:17:32,619
所以我们将评估这两个选项

383
00:17:33,554 --> 0:17:35,222
我们将检查是否需要使用代理

384
00:17:35,689 --> 0:17:37,057
继续并连接到它

385
00:17:37,424 --> 0:17:38,892
在那里创建一个TCP连接

386
00:17:39,893 --> 0:17:40,928
但如果我们不需要它

387
00:17:41,228 --> 0:17:43,297
我们将替你执行DNS

388
00:17:43,864 --> 0:17:44,898
直接连接

389
00:17:45,165 --> 0:17:48,368
取回所有回复的DNS IP地址

390
00:17:48,702 --> 0:17:49,837
并连接到它们

391
00:17:50,704 --> 0:17:53,307
一个接一个地让它们并行执行

392
00:17:53,373 --> 0:17:56,510
我们比较它们的速度

393
00:17:59,379 --> 0:18:01,415
然后 如果Wi-Fi出现问题

394
00:17:59,379 --> 0:18:01,415
然后 如果Wi-Fi出现问题

395
00:18:01,481 --> 0:18:04,017
假设Wi-Fi信号质量非常糟糕

396
00:18:04,084 --> 0:18:05,752
因为你离开了大楼

397
00:18:07,287 --> 0:18:10,657
我们实际上可以利用

398
00:18:10,924 --> 0:18:14,061
并无缝回退到蜂窝网络

399
00:18:14,595 --> 0:18:16,296
在那里进行DNS解析

400
00:18:16,630 --> 0:18:19,566
并一个接一个地尝试连接

401
00:18:20,267 --> 0:18:24,571
所以这样你的连接搭建非常有弹性

402
00:18:24,638 --> 0:18:25,973
处理VPN

403
00:18:26,240 --> 0:18:27,441
为你处理代理

404
00:18:27,875 --> 0:18:29,943
并为你提供可能的最佳连接

405
00:18:31,912 --> 0:18:32,846
现在 当然

406
00:18:33,080 --> 0:18:35,516
你可能不想尝试所有这些选项

407
00:18:35,582 --> 0:18:38,652
你可能希望限制连接搭建的行为

408
00:18:39,620 --> 0:18:42,656
所以我们有许多不同的旋钮

409
00:18:42,723 --> 0:18:44,958
我今天要强调其中的三个

410
00:18:46,827 --> 0:18:50,330
首先 你可能不想使用昂贵的网络

411
00:18:50,397 --> 0:18:51,565
比如蜂窝网络

412
00:18:51,632 --> 0:18:55,369
因为此连接仅适合使用Wi-Fi

413
00:18:56,003 --> 0:18:58,405
所以在连接的参数中

414
00:18:59,006 --> 0:19:02,643
具有控制你所使用接口的选项

415
00:18:59,006 --> 0:19:02,643
具有控制你所使用接口的选项

416
00:19:03,010 --> 0:19:04,545
所以如果你不想使用蜂窝

417
00:19:04,611 --> 0:19:08,982
只需将cellular添加到

418
00:19:10,684 --> 0:19:12,019
实际上将一般的

419
00:19:12,085 --> 0:19:15,022
昂贵网络都禁止掉甚至要更好

420
00:19:15,255 --> 0:19:20,694
因为这也会屏蔽掉 比如说

421
00:19:22,930 --> 0:19:25,766
另一种限制连接搭建的方法是

422
00:19:25,966 --> 0:19:28,569
明确指定你想要使用的

423
00:19:28,635 --> 0:19:29,803
IP地址系列

424
00:19:30,370 --> 0:19:34,208
假设你非常喜欢IPv6

425
00:19:34,408 --> 0:19:36,743
你根本不想在连接上使用IPv4

426
00:19:37,244 --> 0:19:39,713
为此你可以使用参数

427
00:19:39,847 --> 0:19:42,616
找到其中针对IP的选项

428
00:19:42,850 --> 0:19:45,485
并且在这里你可以看到

429
00:19:45,552 --> 0:19:46,854
与你在当前套接字中的

430
00:19:47,254 --> 0:19:48,388
套接字选项相类似

431
00:19:48,455 --> 0:19:52,092
你还可以明确指定要使用的IP版本

432
00:19:52,626 --> 0:19:56,163
这会影响你的连接以及DNS解析

433
00:19:57,564 --> 0:20:00,100
最后 你可能不想

434
00:19:57,564 --> 0:20:00,100
最后 你可能不想

435
00:20:00,267 --> 0:20:01,401
在你的连接上使用代理

436
00:20:01,468 --> 0:20:03,470
也许你的连接不适合

437
00:20:03,537 --> 0:20:05,172
使用SOCKS代理

438
00:20:05,639 --> 0:20:09,276
在这种情况下

439
00:20:10,844 --> 0:20:13,547
这就是准备状态中所发生的事情

440
00:20:14,648 --> 0:20:17,451
我之前提到过

441
00:20:17,518 --> 0:20:19,920
在尝试建立连接时

442
00:20:20,320 --> 0:20:24,291
我们在进入准备状态之后所做的是

443
00:20:24,358 --> 0:20:27,794
DNS失败 没有网络

444
00:20:27,995 --> 0:20:30,697
我们将进入等待状态

445
00:20:31,398 --> 0:20:35,369
并且每次网络发生变化时

446
00:20:35,435 --> 0:20:38,038
这时系统认为

447
00:20:38,238 --> 0:20:40,340
“现在你的连接说不定

448
00:20:40,641 --> 0:20:42,176
我们将为你处理所有这些事情

449
00:20:42,309 --> 0:20:44,711
并且每次我们重新尝试时都会通知你

450
00:20:46,446 --> 0:20:49,750
最终你会有希望成功建立连接

451
00:20:49,950 --> 0:20:52,085
此时我们将进入就绪状态

452
00:20:53,187 --> 0:20:55,122
就像我之前提到的那样

453
00:20:55,455 --> 0:20:57,858
就绪状态是你的连接完全建立的时候

454
00:20:57,925 --> 0:21:02,663
此时已准备好了你的协议栈中

455
00:20:57,925 --> 0:21:02,663
此时已准备好了你的协议栈中

456
00:21:03,430 --> 0:21:05,098
此时你可以读和写

457
00:21:05,766 --> 0:21:08,435
这也是我们对你所经历的网络切换

458
00:21:08,969 --> 0:21:12,172
进行回调的地方

459
00:21:12,439 --> 0:21:15,709
因此如果你的连接已建立

460
00:21:15,943 --> 0:21:19,680
我们会为你提供相应的更新

461
00:21:20,113 --> 0:21:22,416
我们稍后再继续讨论这个问题

462
00:21:24,718 --> 0:21:25,886
如果连接出错

463
00:21:25,953 --> 0:21:28,188
无论是在连接建立期间

464
00:21:28,422 --> 0:21:29,923
还是已经连接后

465
00:21:29,990 --> 0:21:31,792
你会得到一个错误并进入失败状态

466
00:21:32,826 --> 0:21:34,828
然后一旦你用完了连接

467
00:21:34,895 --> 0:21:36,196
假设你已经把它关闭了

468
00:21:36,263 --> 0:21:38,365
或者你从另一端收到了关闭请求

469
00:21:38,632 --> 0:21:40,601
并且你想要使连接无效

470
00:21:40,667 --> 0:21:43,570
你可以调用cancel()

471
00:21:43,637 --> 0:21:46,507
这必定是我们将传递给

472
00:21:46,640 --> 0:21:50,410
以便你可以清理所使用的任何内存

473
00:21:50,477 --> 0:21:52,579
并继续进行下一步

474
00:21:53,847 --> 0:21:56,750
就是这样 这是对

475
00:21:57,050 --> 0:21:59,119
基本生命周期的概述

476
00:21:59,453 --> 0:22:02,656
为了向你展示如何使用它

477
00:21:59,453 --> 0:22:02,656
为了向你展示如何使用它

478
00:22:02,856 --> 0:22:04,858
我想邀请Eric上台

479
00:22:13,400 --> 0:22:14,301
谢谢Tommy

480
00:22:14,535 --> 0:22:15,502
我是Eric Kinnear

481
00:22:15,569 --> 0:22:17,671
我也来自Apple的网络团队

482
00:22:17,738 --> 0:22:20,674
我非常高兴能与你一起

483
00:22:20,841 --> 0:22:22,209
使用Network.framework

484
00:22:22,976 --> 0:22:25,145
我们将使用Tommy先前提到的

485
00:22:25,212 --> 0:22:26,613
视频直播用例

486
00:22:26,980 --> 0:22:30,784
构建一个可以在一台设备上

487
00:22:30,951 --> 0:22:34,188
并通过网络发送

488
00:22:35,289 --> 0:22:38,592
由于我们将持续生成实时视频帧

489
00:22:38,659 --> 0:22:42,362
我们将使用UDP通过网络

490
00:22:43,096 --> 0:22:44,131
那我们该怎么做呢？

491
00:22:46,133 --> 0:22:47,100
首先…

492
00:22:47,334 --> 0:22:49,136
我们需要与相机进行捕捉会话

493
00:22:49,303 --> 0:22:52,272
以便我们可以从图像传感器

494
00:22:53,006 --> 0:22:56,310
为了这个例子 我们不打算使用

495
00:22:56,376 --> 0:22:57,578
或其它压缩算法

496
00:22:57,811 --> 0:23:00,180
我们只是从相机中取出原始字节

497
00:22:57,811 --> 0:23:00,180
我们只是从相机中取出原始字节

498
00:23:00,314 --> 0:23:03,050
通过网络发送它们

499
00:23:04,351 --> 0:23:07,120
为此我们需要将这些帧分割成

500
00:23:07,187 --> 0:23:10,624
我们可以用UDP数据

501
00:23:11,859 --> 0:23:14,194
当然 要想在网络上发送

502
00:23:14,328 --> 0:23:15,295
我们需要一个连接

503
00:23:16,830 --> 0:23:19,566
对于另一台设备

504
00:23:19,766 --> 0:23:21,502
它可以接收传入的连接

505
00:23:22,269 --> 0:23:24,471
并从网络上读取数据包

506
00:23:25,038 --> 0:23:27,307
此后我们只是逆转了之前的过程

507
00:23:27,674 --> 0:23:30,677
重新组装视频帧并将其发送到显示器

508
00:23:30,744 --> 0:23:32,246
以便我们能在屏幕上看到它们

509
00:23:34,047 --> 0:23:37,284
为了简单起见

510
00:23:37,351 --> 0:23:38,719
和显示功能

511
00:23:38,886 --> 0:23:42,089
这样我们就可以专注于使用

512
00:23:43,524 --> 0:23:45,492
这里有一个我们尚未涉及的内容

513
00:23:45,626 --> 0:23:46,593
它就是监听器

514
00:23:46,727 --> 0:23:48,395
所以我们现在花点时间来了解它

515
00:23:50,230 --> 0:23:53,534
监听器功能

516
00:23:53,901 --> 0:23:56,537
你可以使用与你用于配置连接的

517
00:23:56,703 --> 0:23:58,472
相同的参数对象来创建它

518
00:23:59,706 --> 0:24:03,810
设置一个监听器来发布

519
00:23:59,706 --> 0:24:03,810
设置一个监听器来发布

520
00:24:04,044 --> 0:24:06,446
在这个例子中

521
00:24:08,949 --> 0:24:11,485
当监听器收到新连接时

522
00:24:11,618 --> 0:24:14,087
它会将该连接传递给你提供的

523
00:24:14,254 --> 0:24:15,622
newConnectionHandler块中

524
00:24:16,423 --> 0:24:19,693
这是你执行针对该连接的

525
00:24:19,760 --> 0:24:20,727
所选配置的机会

526
00:24:20,961 --> 0:24:22,429
然后你需要调用start()

527
00:24:22,496 --> 0:24:24,998
来让这个连接知道是时候开始了

528
00:24:26,800 --> 0:24:29,169
同样你也需在你的监听器上

529
00:24:29,336 --> 0:24:31,071
也像连接一样

530
00:24:31,205 --> 0:24:32,472
你需要提供一个调度队列

531
00:24:32,539 --> 0:24:34,341
即你希望在哪里调度这些回调

532
00:24:35,809 --> 0:24:36,777
这就是监听器

533
00:24:36,977 --> 0:24:38,879
如果你仔细想想 我们刚实现了

534
00:24:38,946 --> 0:24:41,915
相当于在UDP套接字上

535
00:24:42,850 --> 0:24:45,919
除了listen()

536
00:24:47,387 --> 0:24:49,556
我们已准备好在Xcode中

537
00:24:50,524 --> 0:24:52,092
这是我们的app

538
00:24:52,492 --> 0:24:54,228
我们这里有一堆文件

539
00:24:54,394 --> 0:24:57,164
它们已经处理了相机和显示功能

540
00:24:57,664 --> 0:25:00,400
所以我们将只关注

541
00:24:57,664 --> 0:25:00,400
所以我们将只关注

542
00:25:00,734 --> 0:25:02,269
和UDPServer类

543
00:25:03,103 --> 0:25:04,304
UDPClient

544
00:25:04,438 --> 0:25:07,641
将负责创建与另一端的连接

545
00:25:07,708 --> 0:25:09,243
并发送帧

546
00:25:10,177 --> 0:25:13,313
同样的 服务器负责创建监听器

547
00:25:13,814 --> 0:25:15,349
接受传入的连接

548
00:25:15,782 --> 0:25:17,351
从该连接中读取数据

549
00:25:17,518 --> 0:25:18,785
并将其发送到屏幕

550
00:25:19,620 --> 0:25:20,687
让我们从客户端开始

551
00:25:22,422 --> 0:25:25,626
我的客户端类有个接收一个名字的

552
00:25:25,926 --> 0:25:28,629
它是描述我们要连接的

553
00:25:28,695 --> 0:25:29,963
Bonjour服务名称的字符串

554
00:25:31,598 --> 0:25:32,799
我通过调用

555
00:25:33,634 --> 0:25:35,369
并传入服务端点

556
00:25:35,769 --> 0:25:37,471
来创建我的连接

557
00:25:38,005 --> 0:25:39,706
使用提供给我的名称

558
00:25:40,207 --> 0:25:42,242
并将_camera._udp

559
00:25:43,644 --> 0:25:45,979
我们还传递了默认的UDP参数

560
00:25:47,714 --> 0:25:50,584
正如Tommy所说我们可以使用

561
00:25:52,286 --> 0:25:55,155
来检查就绪状态和失败状态

562
00:25:55,989 --> 0:25:59,726
这里 当我们的连接就绪

563
00:26:00,027 --> 0:26:01,361
我们稍后再实现它

564
00:26:02,596 --> 0:26:05,566
因为我们使用的是UDP

565
00:26:05,866 --> 0:26:08,936
我们将一些数据通过网络发送到

566
00:26:09,536 --> 0:26:10,504
其它设备

567
00:26:10,838 --> 0:26:12,372
并在我们开始生成大量视频帧

568
00:26:12,506 --> 0:26:14,541
并将其放到网络中之前

569
00:26:14,608 --> 0:26:15,909
等待它的回应

570
00:26:19,413 --> 0:26:22,082
我们需要记住在我们的连接上

571
00:26:22,316 --> 0:26:24,351
并且传入上面创建的队列

572
00:26:26,153 --> 0:26:27,688
让我们实现

573
00:26:32,392 --> 0:26:34,962
这里我们使用

574
00:26:35,229 --> 0:26:37,097
创建一个数据对象

575
00:26:38,065 --> 0:26:39,766
要在连接上发送内容

576
00:26:40,133 --> 0:26:41,768
我们可以调用

577
00:26:41,969 --> 0:26:44,671
并提供该数据对象作为内容

578
00:26:45,772 --> 0:26:49,243
我们提供了一个完成处理程序

579
00:26:49,409 --> 0:26:51,211
可能遇到的错误

580
00:26:53,113 --> 0:26:55,816
由于我们预期该内容可以

581
00:26:55,883 --> 0:26:58,285
我们马上调用

582
00:26:58,485 --> 0:27:00,754
来从连接中读取传入的数据

583
00:26:58,485 --> 0:27:00,754
来从连接中读取传入的数据

584
00:27:01,455 --> 0:27:04,525
在该完成处理程序中

585
00:27:04,825 --> 0:27:07,427
如果存在

586
00:27:07,561 --> 0:27:08,529
我们已经连接上了

587
00:27:08,595 --> 0:27:10,197
它应该调出相机硬件

588
00:27:10,264 --> 0:27:11,632
并开始生成帧

589
00:27:13,934 --> 0:27:15,269
生成这些帧时

590
00:27:15,536 --> 0:27:19,306
app的其余部分知道

591
00:27:22,709 --> 0:27:26,046
并向其传递一个表示

592
00:27:26,113 --> 0:27:27,181
数据对象数组

593
00:27:29,016 --> 0:27:30,951
由于我们要在很短的时间内

594
00:27:31,018 --> 0:27:34,154
进行大量发送操作

595
00:27:34,221 --> 0:27:36,056
connection.batch

596
00:27:37,591 --> 0:27:40,194
在这个块中 我们将遍历该

597
00:27:40,627 --> 0:27:45,299
并将每个数据对象都传递给

598
00:27:45,766 --> 0:27:46,967
与上面类似

599
00:27:47,301 --> 0:27:49,536
我们使用完成处理程序来检查

600
00:27:49,670 --> 0:27:50,971
发送时遇到的任何错误

601
00:27:51,939 --> 0:27:52,773
就是这样

602
00:27:53,106 --> 0:27:55,709
我们已经有了UDPClient类

603
00:27:57,678 --> 0:27:58,679
让我们来看看服务器

604
00:27:59,780 --> 0:28:01,982
在服务器端 我们需要一个监听器

605
00:27:59,780 --> 0:28:01,982
在服务器端 我们需要一个监听器

606
00:28:02,182 --> 0:28:03,817
它可以接收传入的连接

607
00:28:04,151 --> 0:28:06,987
我们需要回应

608
00:28:07,287 --> 0:28:10,557
我们需要从网络上读取数据

609
00:28:11,225 --> 0:28:12,492
从监听器开始

610
00:28:16,196 --> 0:28:19,800
我们只是使用默认的UDP参数

611
00:28:21,134 --> 0:28:23,203
如果我愿意的话 这也是

612
00:28:23,270 --> 0:28:25,205
使用这些参数告诉监听器

613
00:28:25,272 --> 0:28:27,007
监听特定的本地端口的时机

614
00:28:27,274 --> 0:28:29,977
但由于我们用Bonjour服务

615
00:28:33,514 --> 0:28:34,715
为了设置该服务

616
00:28:34,948 --> 0:28:37,217
我将listener的

617
00:28:38,185 --> 0:28:40,554
_camera._udp类型的

618
00:28:41,121 --> 0:28:42,789
注意我没有在此处传递名称

619
00:28:43,090 --> 0:28:46,326
因为我希望系统为我提供

620
00:28:47,661 --> 0:28:49,296
我还为serviceRegistration

621
00:28:49,363 --> 0:28:51,498
提供了一个块

622
00:28:52,065 --> 0:28:53,901
它将在系统发布的

623
00:28:53,967 --> 0:28:57,204
端点集发生改变时被调用

624
00:28:57,905 --> 0:29:00,641
这里 我对添加端点的情况感兴趣

625
00:28:57,905 --> 0:29:00,641
这里 我对添加端点的情况感兴趣

626
00:29:00,974 --> 0:29:02,776
如果它是服务类型

627
00:29:03,010 --> 0:29:06,446
我将告诉app的其余部分

628
00:29:06,513 --> 0:29:09,116
即我要求系统提供的默认设备名称

629
00:29:09,183 --> 0:29:10,851
以便我可以在UI中显示它

630
00:29:10,984 --> 0:29:12,753
并让我的用户在其它地方输入它

631
00:29:19,960 --> 0:29:22,729
我要在监听器上设置一个新的

632
00:29:22,963 --> 0:29:24,431
它在每次监听器收到新的

633
00:29:24,498 --> 0:29:26,099
传入连接时都会被调用

634
00:29:27,534 --> 0:29:29,603
我可以对这些连接进行一些配置

635
00:29:29,736 --> 0:29:31,238
但这里使用默认配置就够了

636
00:29:31,305 --> 0:29:33,974
因此我只需调用connection.start()

637
00:29:36,376 --> 0:29:40,581
我在这里通知app的其余部分

638
00:29:40,781 --> 0:29:42,850
以便它可以开始预热显示管道

639
00:29:42,983 --> 0:29:45,252
并准备好显示视频帧

640
00:29:46,320 --> 0:29:49,723
我也会调用自身receive()

641
00:29:49,857 --> 0:29:51,725
来开始从网络中读取该数据

642
00:29:51,792 --> 0:29:53,427
并将其发送到显示管道

643
00:29:55,596 --> 0:29:57,664
就像连接一样 监听器也有

644
00:30:00,934 --> 0:30:02,302
stateUpdateHandler

645
00:30:02,369 --> 0:30:05,172
我将用它来检查就绪状态和失败状态

646
00:30:07,474 --> 0:30:09,409
别忘了启动我的监听器

647
00:30:09,943 --> 0:30:11,712
为此我调用

648
00:30:11,912 --> 0:30:13,847
并传入我们在上面创建的队列

649
00:30:15,716 --> 0:30:18,919
现在我准备好了监听器

650
00:30:19,186 --> 0:30:20,654
并实现该receive函数

651
00:30:24,858 --> 0:30:27,261
我们在这里首先调用

652
00:30:27,461 --> 0:30:29,096
并传入完成处理程序

653
00:30:29,563 --> 0:30:31,365
当数据进入该连接时

654
00:30:31,765 --> 0:30:33,333
我们将检查我们是否尚未连接

655
00:30:33,867 --> 0:30:35,035
如果我们没有连接

656
00:30:35,169 --> 0:30:38,539
这可能是客户端通过发送

657
00:30:40,240 --> 0:30:42,809
我们只需调用

658
00:30:43,177 --> 0:30:47,047
并将相同的内容传回去

659
00:30:47,581 --> 0:30:49,049
然后我们记录下连接已经建立

660
00:30:49,283 --> 0:30:51,952
在此后的

661
00:30:52,186 --> 0:30:54,521
我们将告诉app的其余部分

662
00:30:54,688 --> 0:30:56,456
我们收到了这个帧

663
00:30:56,657 --> 0:30:58,559
它应该将其发送到显示管道

664
00:30:58,825 --> 0:31:00,227
以便我们能在屏幕上看到它

665
00:30:58,825 --> 0:31:00,227
以便我们能在屏幕上看到它

666
00:31:01,862 --> 0:31:05,098
最后 如果没有错误

667
00:31:05,299 --> 0:31:08,569
以便我们接收后续帧

668
00:31:08,635 --> 0:31:11,672
并将这些独立的图像拼接成视频

669
00:31:13,307 --> 0:31:15,042
就是这样

670
00:31:15,342 --> 0:31:17,878
也有了UDPServer

671
00:31:20,480 --> 0:31:23,116
我将在我的手机上运行客户端

672
00:31:23,383 --> 0:31:26,954
并在Mac上运行服务器

673
00:31:28,288 --> 0:31:29,756
这里 服务器刚刚启动

674
00:31:30,290 --> 0:31:32,993
我们看到它正作为

675
00:31:33,393 --> 0:31:35,529
这是我让系统其余部分

676
00:31:35,929 --> 0:31:37,331
给我这个名称的地方

677
00:31:38,098 --> 0:31:39,199
在我的手机上

678
00:31:39,266 --> 0:31:40,167
如果我点击连接

679
00:31:41,201 --> 0:31:42,135
一瞬间

680
00:31:42,336 --> 0:31:47,007
我就可以通过UDP Live看到

681
00:31:58,252 --> 0:32:02,890
我们刚才看到了我能够多么快地

682
00:31:58,252 --> 0:32:02,890
我们刚才看到了我能够多么快地

683
00:32:02,956 --> 0:32:04,825
并连接到Bonjour服务

684
00:32:05,792 --> 0:32:07,327
它可以发送握手

685
00:32:07,661 --> 0:32:09,096
等待其被处理

686
00:32:09,830 --> 0:32:11,532
获取来自相机的视频帧

687
00:32:11,598 --> 0:32:12,966
并通过网络发送它们

688
00:32:14,334 --> 0:32:18,672
服务器端启动了

689
00:32:18,972 --> 0:32:22,276
它公布了一项服务

690
00:32:22,342 --> 0:32:23,510
然后对握手进行回应

691
00:32:23,677 --> 0:32:26,280
并将它们全部发送到显示器

692
00:32:27,147 --> 0:32:29,616
现在为了更详细的介绍

693
00:32:29,683 --> 0:32:30,817
优化该数据传输过程

694
00:32:30,884 --> 0:32:32,686
我想邀请Tommy回到舞台上

695
00:32:38,859 --> 0:32:40,027
谢谢 Eric

696
00:32:40,994 --> 0:32:42,129
这是一个非常酷的演示

697
00:32:42,196 --> 0:32:45,432
它很容易实现

698
00:32:45,499 --> 0:32:48,001
我们知道如何建立出站连接

699
00:32:48,068 --> 0:32:49,937
如何接收入站连接

700
00:32:50,604 --> 0:32:53,240
但Network.framework的

701
00:32:53,307 --> 0:32:54,708
也是这里的杀手级特性

702
00:32:54,775 --> 0:32:57,644
是其优化性能的方式

703
00:32:57,711 --> 0:33:00,280
我们将超越套接字所能够做的事情

704
00:32:57,711 --> 0:33:00,280
我们将超越套接字所能够做的事情

705
00:33:01,548 --> 0:33:04,985
我想先谈谈

706
00:33:05,052 --> 0:33:07,154
进行交互的

707
00:33:07,621 --> 0:33:08,989
最基本的方式

708
00:33:09,590 --> 0:33:11,692
即发送和接收数据

709
00:33:12,659 --> 0:33:14,828
这些调用非常简单

710
00:33:15,162 --> 0:33:18,465
但是关于你如何处理

711
00:33:18,665 --> 0:33:22,536
将对app的响应能力

712
00:33:22,603 --> 0:33:26,473
以及设备和网络上正在进行多少缓冲

713
00:33:27,808 --> 0:33:29,710
所以我想介绍的第一个例子

714
00:33:29,977 --> 0:33:31,445
是当我们在app中

715
00:33:31,845 --> 0:33:32,679
发送数据时

716
00:33:32,746 --> 0:33:34,848
就像Eric刚向你展示的那样

717
00:33:35,182 --> 0:33:36,350
一些正在直播的东西

718
00:33:36,416 --> 0:33:38,819
一些动态生成数据的东西

719
00:33:39,620 --> 0:33:43,557
但在这个例子中 让我们谈谈

720
00:33:43,857 --> 0:33:46,293
即可以在网络上恢复的TCP流

721
00:33:46,493 --> 0:33:48,395
它具有可以发送的特定时间窗口

722
00:33:48,529 --> 0:33:49,830
我们该如何处理该情况呢

723
00:33:51,598 --> 0:33:54,368
这是一个发送单帧的函数

724
00:33:54,434 --> 0:33:57,871
这是你的app生成的某些数据帧

725
00:33:59,439 --> 0:34:01,074
你在连接上发送它的方式

726
00:33:59,439 --> 0:34:01,074
你在连接上发送它的方式

727
00:34:01,141 --> 0:34:03,477
是通过调用

728
00:34:03,544 --> 0:34:04,811
并传入该数据

729
00:34:05,712 --> 0:34:10,217
如果你习惯在连接上

730
00:34:10,851 --> 0:34:13,020
你要么使用阻塞套接字

731
00:34:13,085 --> 0:34:14,755
在这种情况下

732
00:34:15,121 --> 0:34:16,889
如果你要发送100个字节的数据

733
00:34:17,224 --> 0:34:20,960
如果发送缓冲区中没有空间

734
00:34:21,027 --> 0:34:23,830
并等待网络连接消耗掉这些数据

735
00:34:25,065 --> 0:34:27,701
或者 如果你使用的是非阻塞套接字

736
00:34:28,869 --> 0:34:31,772
该发送过程实际上可能

737
00:34:31,839 --> 0:34:33,639
它会说

738
00:34:33,706 --> 0:34:35,909
过一段时间再发送剩下的50字节”

739
00:34:36,443 --> 0:34:39,346
这要求你和你的app需要处理很多

740
00:34:39,612 --> 0:34:42,783
关于你实际发送了多少数据的状态

741
00:34:44,484 --> 0:34:46,085
所以NWConnection

742
00:34:46,152 --> 0:34:48,388
你可以一次发送所有数据

743
00:34:48,455 --> 0:34:49,822
你不必担心这些问题

744
00:34:50,524 --> 0:34:51,992
并且它不会阻塞任何东西

745
00:34:53,025 --> 0:34:54,795
然而你必须处理

746
00:34:55,195 --> 0:34:57,164
如果连接正在恢复该怎么办

747
00:34:57,231 --> 0:35:00,634
因为我们不想不必要地

748
00:34:57,231 --> 0:35:00,634
因为我们不想不必要地

749
00:35:00,701 --> 0:35:01,735
发送到此连接

750
00:35:01,802 --> 0:35:05,138
如果你想要一个响应性强的

751
00:35:06,240 --> 0:35:07,274
这里的关键

752
00:35:07,741 --> 0:35:09,543
是我们提供给你的回调块

753
00:35:10,244 --> 0:35:12,179
它被称为

754
00:35:12,679 --> 0:35:17,050
每当网络栈消耗你的数据时

755
00:35:17,551 --> 0:35:20,254
这并不意味着必须发送数据

756
00:35:20,320 --> 0:35:21,822
或另一方进行确认

757
00:35:22,055 --> 0:35:25,959
它完全等同于阻塞套接字的调用

758
00:35:26,026 --> 0:35:27,127
返回的情况

759
00:35:27,461 --> 0:35:30,998
或非阻塞套接字

760
00:35:31,064 --> 0:35:31,965
所有字节的情况

761
00:35:33,333 --> 0:35:36,737
在此完成处理程序中

762
00:35:37,471 --> 0:35:38,305
首先

763
00:35:38,372 --> 0:35:39,506
你可以检查错误

764
00:35:39,907 --> 0:35:40,774
如果有错误

765
00:35:40,841 --> 0:35:43,277
这意味着在我们尝试发送你的数据时

766
00:35:43,610 --> 0:35:46,346
这通常表示整体连接失败

767
00:35:47,948 --> 0:35:51,919
然后 如果没有错误

768
00:35:52,152 --> 0:35:55,956
来查看你的app中

769
00:35:56,023 --> 0:35:58,892
所以如果你正在生成实时数据帧

770
00:35:59,593 --> 0:36:01,562
你应该发送它并从视频流中

771
00:35:59,593 --> 0:36:01,562
你应该发送它并从视频流中

772
00:36:01,628 --> 0:36:03,630
因为现在正是你将下一个数据包

773
00:36:03,697 --> 0:36:04,631
放入队列的时机

774
00:36:04,965 --> 0:36:07,901
这使你可以一步一步地发送所有数据

775
00:36:08,702 --> 0:36:11,305
正如你在这里看到的

776
00:36:11,605 --> 0:36:16,677
形成了一个循环

777
00:36:16,743 --> 0:36:19,813
并非常优雅地处理它

778
00:36:22,516 --> 0:36:24,818
关于发送我想指出的另一件事

779
00:36:25,252 --> 0:36:29,156
是Eric之前展示的

780
00:36:29,223 --> 0:36:32,659
这类app需要一次发送多个数据报

781
00:36:33,861 --> 0:36:36,263
如果你需要发送一大堆很小的数据

782
00:36:36,330 --> 0:36:38,999
或独立数据包

783
00:36:40,100 --> 0:36:43,370
你可以使用我们添加的

784
00:36:43,604 --> 0:36:48,008
UDP套接字以前一次只能发送

785
00:36:48,542 --> 0:36:50,043
这可能效率很低

786
00:36:50,110 --> 0:36:52,880
因为如果我需要发送

787
00:36:53,146 --> 0:36:56,116
它们每个都是不同的系统调用

788
00:36:56,183 --> 0:36:57,918
并且导致内核中大量的上下文切换

789
00:36:59,186 --> 0:37:01,989
但如果你在那个块中调用batch

790
00:36:59,186 --> 0:37:01,989
但如果你在那个块中调用batch

791
00:37:02,289 --> 0:37:05,759
你想调用send或receive

792
00:37:05,893 --> 0:37:08,996
并且连接将停止处理任何数据

793
00:37:09,630 --> 0:37:11,698
直到你完成此batch块

794
00:37:11,865 --> 0:37:13,967
并尝试将所有这些数据报

795
00:37:14,034 --> 0:37:17,371
作为单个批次传入系统

796
00:37:17,604 --> 0:37:21,241
理想情况下

797
00:37:21,308 --> 0:37:22,743
并最终从接口发送出去

798
00:37:23,043 --> 0:37:25,345
这使你非常非常有效率

799
00:37:27,414 --> 0:37:28,315
以上就是发送

800
00:37:28,715 --> 0:37:32,152
接收与发送一样是异步的

801
00:37:32,352 --> 0:37:35,088
而异步性质则会给你

802
00:37:35,155 --> 0:37:36,523
能够让你调整app的背压

803
00:37:38,492 --> 0:37:42,196
在这个例子中

804
00:37:42,763 --> 0:37:45,299
并且app想要读取某种类型的

805
00:37:45,699 --> 0:37:49,203
记录格式非常常见

806
00:37:50,571 --> 0:37:54,508
假设你的协议有一个10字节的头部

807
00:37:54,708 --> 0:37:57,177
它告诉你有关你将要收到的

808
00:37:57,311 --> 0:37:59,513
比如你将要接收的主体长度

809
00:38:00,547 --> 0:38:03,984
因此你想首先读取该头部

810
00:38:04,251 --> 0:38:05,586
也许你的内容很长

811
00:38:05,652 --> 0:38:07,754
假设有几兆字节

812
00:38:08,956 --> 0:38:12,159
使用传统的套接字时

813
00:38:12,626 --> 0:38:14,428
你可能得到10个字节或更少

814
00:38:14,494 --> 0:38:16,463
你须继续读取

815
00:38:16,530 --> 0:38:17,364
从而读取头部信息

816
00:38:17,965 --> 0:38:20,167
然后你还要读取几兆字节

817
00:38:20,534 --> 0:38:21,435
你会读取一些数据

818
00:38:21,502 --> 0:38:23,136
进行一大堆不同的read调用

819
00:38:23,203 --> 0:38:26,607
并且需要在你的app

820
00:38:28,575 --> 0:38:31,612
使用NWConnection的情况下

821
00:38:32,212 --> 0:38:35,682
你可以提供你想要接收的最小数据

822
00:38:35,749 --> 0:38:36,950
和最大数据

823
00:38:37,618 --> 0:38:40,687
所以你实际上可以指定

824
00:38:40,754 --> 0:38:42,689
因为那是你的协议所规定的

825
00:38:43,090 --> 0:38:45,392
“我想要最小10字节

826
00:38:45,459 --> 0:38:46,793
即给我正好10个字节”

827
00:38:47,194 --> 0:38:48,829
而我们只会在以下情况发生时

828
00:38:49,162 --> 0:38:52,466
才对你进行回调

829
00:38:52,799 --> 0:38:55,035
要么我们正好读了10个字节

830
00:38:55,502 --> 0:38:57,971
然后你就可以读取

831
00:38:58,038 --> 0:39:00,674
头部中你需要的内容 比如长度

832
00:38:58,038 --> 0:39:00,674
头部中你需要的内容 比如长度

833
00:39:01,241 --> 0:39:02,876
然后假设你想继续读取

834
00:39:03,377 --> 0:39:04,545
几兆字节

835
00:39:04,611 --> 0:39:07,247
你基本上只需做同样的事情

836
00:39:07,814 --> 0:39:08,916
你只需传入

837
00:39:08,982 --> 0:39:11,885
你想要从连接中读取的数量

838
00:39:11,952 --> 0:39:13,587
这可以让你不必

839
00:39:13,654 --> 0:39:15,088
在堆和app之间来回切换

840
00:39:15,222 --> 0:39:18,325
这是通过在所有数据准备好时

841
00:39:19,626 --> 0:39:22,963
所以这是一种优化交互的好方法

842
00:39:24,598 --> 0:39:25,899
除了发送和接收

843
00:39:26,300 --> 0:39:28,168
我还想强调一下

844
00:39:28,235 --> 0:39:29,369
你的网络参数中的

845
00:39:30,070 --> 0:39:31,271
几个高级选项

846
00:39:31,338 --> 0:39:33,507
它们允许你配置连接

847
00:39:33,740 --> 0:39:36,176
从而当你实际发送和接收数据时

848
00:39:36,443 --> 0:39:38,579
具有合适的启动时间

849
00:39:38,645 --> 0:39:40,147
以及网络上的行为

850
00:39:41,114 --> 0:39:42,115
第一个

851
00:39:42,316 --> 0:39:45,319
是我们在WWDC中多次讨论的内容

852
00:39:45,652 --> 0:39:46,753
它是ECN

853
00:39:46,820 --> 0:39:48,822
即显式拥塞通知

854
00:39:49,990 --> 0:39:53,827
它为你提供了一种平滑连接的方法

855
00:39:54,161 --> 0:39:57,965
即让终端主机知道

856
00:39:58,165 --> 0:39:59,733
何时发生了网络拥塞

857
00:39:59,967 --> 0:40:01,635
从而使我们可以很好地调整速度

858
00:39:59,967 --> 0:40:01,635
从而使我们可以很好地调整速度

859
00:40:02,569 --> 0:40:07,274
最棒的是默认情况下

860
00:40:07,441 --> 0:40:08,675
你无需做任何事情

861
00:40:09,376 --> 0:40:12,846
但过去在基于UDP的协议上

862
00:40:13,213 --> 0:40:15,182
使用ECN非常困难

863
00:40:15,983 --> 0:40:18,285
所以我想在这里向你展示

864
00:40:19,686 --> 0:40:23,624
你要做的第一件事是

865
00:40:23,690 --> 0:40:27,561
ECN由IP数据包中的标志控制

866
00:40:28,028 --> 0:40:29,830
所以这个ipMetadata对象

867
00:40:29,897 --> 0:40:33,333
允许你在每个数据包上设置各种标志

868
00:40:34,201 --> 0:40:37,037
并且你可以把它包装成

869
00:40:37,204 --> 0:40:40,407
它描述了你想与某次send调用

870
00:40:40,574 --> 0:40:42,476
相关联的若干协议的所有选项

871
00:40:42,976 --> 0:40:46,947
以及该特定消息的相对优先级

872
00:40:48,115 --> 0:40:51,451
然后使用

873
00:40:51,518 --> 0:40:52,619
传入send调用中

874
00:40:53,120 --> 0:40:55,222
就在你的content参数后面

875
00:40:55,956 --> 0:40:57,224
所以现在当你发送它时

876
00:40:57,424 --> 0:41:00,360
由此内容生成的任何数据包

877
00:40:57,424 --> 0:41:00,360
由此内容生成的任何数据包

878
00:41:00,427 --> 0:41:02,996
都将包含你想要标记的所有标志

879
00:41:03,197 --> 0:41:04,198
所以这很容易

880
00:41:05,265 --> 0:41:07,367
而且你也可以在收到连接时

881
00:41:07,434 --> 0:41:09,503
获取这些相同的标志

882
00:41:09,570 --> 0:41:12,506
你将在收到的数据包中得到

883
00:41:12,739 --> 0:41:15,709
你将能够读出你想得到的

884
00:41:15,776 --> 0:41:16,777
特定的低级标志

885
00:41:19,246 --> 0:41:21,815
类似地 我们也有服务类

886
00:41:22,349 --> 0:41:27,020
这是一个在URLSession中

887
00:41:27,187 --> 0:41:30,924
它定义你的流量的相对优先级

888
00:41:31,425 --> 0:41:34,328
这会影响我们在发送数据时

889
00:41:34,394 --> 0:41:36,230
流量在本地接口上排队的方式

890
00:41:36,663 --> 0:41:40,033
及在Cisco Fastlane

891
00:41:41,435 --> 0:41:45,839
你可以通过使用参数对象中的

892
00:41:46,106 --> 0:41:50,677
来将服务类标记为整个连接上的属性

893
00:41:51,378 --> 0:41:55,315
在这个例子中 我们展示了

894
00:41:55,649 --> 0:41:58,252
这是将你的连接标记为

895
00:41:58,585 --> 0:42:00,187
较低优先级的好方法

896
00:41:58,585 --> 0:42:00,187
较低优先级的好方法

897
00:42:00,254 --> 0:42:03,624
我们不希望它妨碍用户交互式数据

898
00:42:03,957 --> 0:42:06,560
所以如果你需要后台数据传输

899
00:42:06,793 --> 0:42:09,096
将它们标记为后台服务类

900
00:42:10,731 --> 0:42:14,401
但你也可以对那些UDP连接

901
00:42:14,635 --> 0:42:16,136
标记服务类

902
00:42:16,904 --> 0:42:18,505
假设你有一个连接

903
00:42:18,705 --> 0:42:22,176
其中在同一个UDP流上包含

904
00:42:22,242 --> 0:42:23,810
语音和信号数据

905
00:42:24,878 --> 0:42:28,515
在这种情况下

906
00:42:28,582 --> 0:42:29,950
ipMetadata对象

907
00:42:30,517 --> 0:42:33,554
在这里标记你的服务类

908
00:42:34,121 --> 0:42:36,223
将其附加到context上

909
00:42:36,456 --> 0:42:39,493
这样你就在每个数据包的基础上

910
00:42:43,096 --> 0:42:45,098
你可以优化连接的另一种方式

911
00:42:45,866 --> 0:42:49,303
是减少为了建立它们所需的往返次数

912
00:42:50,103 --> 0:42:52,372
所以在这里我想强调

913
00:42:53,073 --> 0:42:56,109
第一种是在你的连接上启用快速打开

914
00:42:56,677 --> 0:42:59,680
TCP快速打开允许你

915
00:42:59,980 --> 0:43:03,517
在TCP发出的第一个数据包中

916
00:42:59,980 --> 0:43:03,517
在TCP发出的第一个数据包中

917
00:43:03,584 --> 0:43:04,484
即在SYN包中

918
00:43:04,751 --> 0:43:06,687
这样你就不必等待整个握手过程完成

919
00:43:06,854 --> 0:43:08,922
才开始发送你的app数据

920
00:43:10,390 --> 0:43:13,694
为此 你的app

921
00:43:13,760 --> 0:43:15,729
需要与连接达成协议

922
00:43:15,929 --> 0:43:19,833
并说明你将提供此初始数据

923
00:43:20,601 --> 0:43:21,502
为了启用它

924
00:43:21,568 --> 0:43:24,338
你需要在参数上

925
00:43:24,905 --> 0:43:26,440
然后创建连接

926
00:43:27,341 --> 0:43:29,309
在你调用start()之前

927
00:43:29,376 --> 0:43:33,814
你实际上可以调用send()

928
00:43:35,349 --> 0:43:38,085
现在我想指出

929
00:43:38,151 --> 0:43:41,588
被替换为该数据为幂等的标志

930
00:43:41,655 --> 0:43:44,491
幂等意味着可以安全地重新发送数据

931
00:43:44,558 --> 0:43:47,594
因为初始数据可能会

932
00:43:47,794 --> 0:43:50,764
因此如果重新发送的话

933
00:43:53,033 --> 0:43:54,601
然后你只需调用start()

934
00:43:54,935 --> 0:43:57,171
当我们正在启动连接时

935
00:43:57,237 --> 0:43:59,106
我们之前提到过的所有尝试

936
00:43:59,173 --> 0:44:03,677
如果可以的话 我们将使用

937
00:43:59,173 --> 0:44:03,677
如果可以的话 我们将使用

938
00:44:05,179 --> 0:44:08,849
我还想指出使用TCP快速打开的

939
00:44:09,082 --> 0:44:12,586
它不要求你的app发送自己的数据

940
00:44:14,655 --> 0:44:17,357
如果你在TCP之上使用TLS

941
00:44:17,958 --> 0:44:20,928
来自TLS的第一条消息

942
00:44:21,161 --> 0:44:25,098
实际上可以用作

943
00:44:25,866 --> 0:44:29,937
如果你只想启用此功能

944
00:44:31,071 --> 0:44:33,774
只需找到针对TCP的选项

945
00:44:34,241 --> 0:44:36,577
并在那里标记你想要

946
00:44:37,044 --> 0:44:40,914
它会在连接建立期间自动将

947
00:44:40,981 --> 0:44:43,217
来自TLS的第一条消息发送出去

948
00:44:47,120 --> 0:44:48,355
你还可以做另外一件事

949
00:44:48,422 --> 0:44:50,290
来优化你的连接建立过程

950
00:44:50,357 --> 0:44:51,491
并节省一次往返

951
00:44:51,859 --> 0:44:53,727
这是Stuart

952
00:44:53,794 --> 0:44:55,095
在前一个演讲中提到的

953
00:44:55,596 --> 0:44:58,031
我们称之为乐观DNS

954
00:44:58,665 --> 0:45:02,769
这允许你使用以前过期的DNS回复

955
00:44:58,665 --> 0:45:02,769
这允许你使用以前过期的DNS回复

956
00:45:02,903 --> 0:45:05,038
其生存时间可能很短

957
00:45:06,473 --> 0:45:08,041
并尝试连接到它们

958
00:45:08,242 --> 0:45:12,646
同时我们并行执行一个

959
00:45:13,614 --> 0:45:14,448
所以…

960
00:45:14,581 --> 0:45:18,151
如果你之前收到的地址

961
00:45:18,452 --> 0:45:20,420
虽然过期但却仍然有效

962
00:45:21,021 --> 0:45:24,358
并且你将expiredDNSBehavior

963
00:45:24,625 --> 0:45:25,993
当你调用start()时

964
00:45:26,059 --> 0:45:27,961
我们将首先尝试连接这些地址

965
00:45:28,028 --> 0:45:31,164
而不必等待新的DNS查询完成

966
00:45:31,398 --> 0:45:35,035
这可以减少大量的连接建立时间

967
00:45:35,769 --> 0:45:39,173
但如果你的服务器的确改变了地址

968
00:45:39,506 --> 0:45:42,309
因为我们正在尝试

969
00:45:42,876 --> 0:45:44,378
如果第一个不起作用

970
00:45:44,511 --> 0:45:46,013
我们会优雅地等待

971
00:45:46,313 --> 0:45:48,315
新的DNS查询返回

972
00:45:48,448 --> 0:45:50,617
并再次尝试这些地址

973
00:45:51,418 --> 0:45:53,053
所以这是一种非常简单的方法

974
00:45:53,120 --> 0:45:55,722
如果它适合你的服务器配置

975
00:45:56,089 --> 0:45:58,759
你就可以更快地建立连接

976
00:46:01,995 --> 0:46:04,331
我想谈的关于性能的下一个领域

977
00:46:04,398 --> 0:46:07,868
你实际上并不需要在app中

978
00:46:08,135 --> 0:46:12,673
这是你在使用URLSession

979
00:46:12,940 --> 0:46:14,474
自动得到的东西

980
00:46:15,275 --> 0:46:17,077
这就是用户态网络

981
00:46:17,644 --> 0:46:21,582
这是我们去年在WWDC上

982
00:46:22,182 --> 0:46:25,886
并在iOS和tvOS上都启用了它

983
00:46:26,286 --> 0:46:28,622
我们在这里完全避开了套接字层

984
00:46:28,689 --> 0:46:31,825
我们将传输栈移到你的app中

985
00:46:32,426 --> 0:46:34,528
为了让你知道它是做什么的

986
00:46:35,062 --> 0:46:36,830
我想先介绍一下通常的

987
00:46:36,897 --> 0:46:38,632
传统栈模型是什么样的

988
00:46:40,100 --> 0:46:42,703
假设你正在通过网络接收数据包

989
00:46:42,836 --> 0:46:44,371
这里是Wi-Fi接口

990
00:46:44,805 --> 0:46:46,573
该数据包先进入驱动程序

991
00:46:46,740 --> 0:46:51,345
然后被发送到内核中的

992
00:46:52,746 --> 0:46:55,682
然后当你的app读取套接字时

993
00:46:56,083 --> 0:46:59,653
将进行一次上下文切换

994
00:46:59,720 --> 0:47:00,621
你的app中

995
00:46:59,720 --> 0:47:00,621
你的app中

996
00:47:01,388 --> 0:47:03,290
接着一般情况下如果你使用了TLS

997
00:47:03,357 --> 0:47:06,293
它必须进行另一次转换来解密该数据

998
00:47:06,493 --> 0:47:08,929
然后才能将其发送到app

999
00:47:10,264 --> 0:47:13,500
那么当我们进行用户态网络时

1000
00:47:16,170 --> 0:47:17,137
你可以看到

1001
00:47:17,237 --> 0:47:19,907
主要的变化是我们将传输栈

1002
00:47:19,973 --> 0:47:21,208
即TCP和UDP

1003
00:47:21,542 --> 0:47:22,709
向上移到你的app中

1004
00:47:22,943 --> 0:47:24,278
这有什么好处呢？

1005
00:47:24,945 --> 0:47:27,181
现在当一个数据包从网络进入时

1006
00:47:27,347 --> 0:47:29,082
像以前一样先进入驱动程序

1007
00:47:29,316 --> 0:47:31,852
但我们将其移动到一块内存映射区域

1008
00:47:32,219 --> 0:47:33,854
你的app可以

1009
00:47:34,354 --> 0:47:36,723
自动从中获取这些数据包

1010
00:47:36,924 --> 0:47:39,893
不需要复制

1011
00:47:40,027 --> 0:47:42,429
并自动开始处理数据包

1012
00:47:42,729 --> 0:47:44,831
这样我们需要做的唯一转换

1013
00:47:44,898 --> 0:47:47,935
就是我们为TLS无论如何

1014
00:47:49,469 --> 0:47:52,439
这确实可以减少用于

1015
00:47:52,506 --> 0:47:54,474
发送和接收数据包的CPU时间

1016
00:47:54,975 --> 0:47:57,344
特别是对于UDP这类协议

1017
00:47:57,578 --> 0:48:00,147
你需要直接在你的app中使用它

1018
00:47:57,578 --> 0:48:00,147
你需要直接在你的app中使用它

1019
00:48:00,314 --> 0:48:01,815
来回发送大量数据包

1020
00:48:03,150 --> 0:48:05,419
为了说明这是如何工作的

1021
00:48:05,652 --> 0:48:07,120
我想给你看一个视频

1022
00:48:07,754 --> 0:48:12,526
它是使用Eric之前向你展示的

1023
00:48:12,793 --> 0:48:15,896
并通过用户态网络

1024
00:48:17,965 --> 0:48:19,233
在这个例子中

1025
00:48:19,299 --> 0:48:21,301
两个视频同时播放

1026
00:48:22,970 --> 0:48:27,040
左侧的设备正在接收一个视频流

1027
00:48:27,808 --> 0:48:28,642
其来自…

1028
00:48:28,709 --> 0:48:31,011
使用套接字编写的app

1029
00:48:32,079 --> 0:48:33,480
右边的设备

1030
00:48:33,547 --> 0:48:36,016
将接收完全相同的视频流

1031
00:48:37,317 --> 0:48:38,218
其来自一个设备上的

1032
00:48:38,652 --> 0:48:39,553
一个app

1033
00:48:40,120 --> 0:48:41,889
该app使用

1034
00:48:41,955 --> 0:48:45,058
因此它可以利用用户态网络栈

1035
00:48:46,927 --> 0:48:48,729
在这个例子中

1036
00:48:48,929 --> 0:48:51,465
它只是原始帧 并没有被压缩

1037
00:48:51,532 --> 0:48:52,833
它没很好质量或其它东西

1038
00:48:52,900 --> 0:48:54,801
但是有大量数据包来回传递

1039
00:48:55,702 --> 0:48:58,038
在此演示中 我们不会降低视频质量

1040
00:48:58,572 --> 0:49:02,009
无论是在我们遇到争用时

1041
00:48:58,572 --> 0:49:02,009
无论是在我们遇到争用时

1042
00:49:02,075 --> 0:49:04,244
还是当我们无法足够快的

1043
00:49:04,511 --> 0:49:05,712
或是不丢弃任何东西时

1044
00:49:05,979 --> 0:49:07,814
而是在必要时放慢速度

1045
00:49:08,148 --> 0:49:10,150
你的app可能在实际中不会这样做

1046
00:49:10,217 --> 0:49:12,586
但它突出了这两种栈之间的

1047
00:49:13,387 --> 0:49:15,656
性能区别

1048
00:49:16,056 --> 0:49:16,990
现在让我们看看吧

1049
00:49:21,895 --> 0:49:23,564
它们使用的数据完全相同

1050
00:49:24,464 --> 0:49:26,099
以它们各自尽可能快的速度

1051
00:49:26,166 --> 0:49:27,334
在网络上

1052
00:49:28,235 --> 0:49:29,236
发送完全相同的帧

1053
00:49:31,638 --> 0:49:32,573
我们看到右边的那个

1054
00:49:32,639 --> 0:49:35,242
很容易就超过了左边的那个

1055
00:49:37,044 --> 0:49:38,779
事实上 如果你看看其差异

1056
00:49:38,846 --> 0:49:40,581
我们仅在接收端就看到了

1057
00:49:40,647 --> 0:49:43,183
30%的开销削减

1058
00:49:44,284 --> 0:49:49,256
这是因为在比较套接字

1059
00:49:49,323 --> 0:49:51,892
我们看到它们发送和接收

1060
00:49:52,259 --> 0:49:54,595
所需的CPU百分比存在巨大差异

1061
00:49:55,095 --> 0:49:56,897
这只是一个例子

1062
00:49:57,431 --> 0:49:59,666
这不会是每个app的样子

1063
00:49:59,733 --> 0:50:01,568
因为你将以不同方式进行压缩

1064
00:49:59,733 --> 0:50:01,568
因为你将以不同方式进行压缩

1065
00:50:01,635 --> 0:50:04,438
你将会尝试提高连接的效率

1066
00:50:05,138 --> 0:50:07,975
但如果你有一个

1067
00:50:08,041 --> 0:50:11,545
尤其是如果你使用UDP

1068
00:50:11,879 --> 0:50:15,449
我邀请你尝试在你的app中

1069
00:50:15,816 --> 0:50:17,084
并在工具软件中运行它

1070
00:50:17,651 --> 0:50:20,621
测量当你使用Network.framework

1071
00:50:20,687 --> 0:50:22,823
它们各自的CPU使用量的差异

1072
00:50:23,056 --> 0:50:24,992
我认为你会对所看到的结果感到满意

1073
00:50:30,531 --> 0:50:32,766
我们今天要讨论的最后一个话题

1074
00:50:33,000 --> 0:50:36,436
是解决网络移动性问题的方法

1075
00:50:36,904 --> 0:50:39,273
这是我们使用

1076
00:50:40,274 --> 0:50:41,875
尝试解决的关键领域

1077
00:50:42,643 --> 0:50:44,711
它的第一步

1078
00:50:45,345 --> 0:50:47,915
只是确保我们能够优雅地开始连接

1079
00:50:48,715 --> 0:50:51,118
我们已经提到了这一点

1080
00:50:51,752 --> 0:50:52,953
等待状态

1081
00:50:53,487 --> 0:50:56,523
是在你的连接刚建立时

1082
00:50:57,191 --> 0:50:59,226
处理网络切换的关键

1083
00:50:59,593 --> 0:51:01,862
当你正在做DNS或TCP时

1084
00:50:59,593 --> 0:51:01,862
当你正在做DNS或TCP时

1085
00:51:02,095 --> 0:51:03,764
它会指出当前无连接

1086
00:51:03,830 --> 0:51:06,533
或连接已更改

1087
00:51:07,534 --> 0:51:12,105
我们鼓励你避免使用

1088
00:51:12,272 --> 0:51:15,609
来在建立连接之前检查网络状态

1089
00:51:16,210 --> 0:51:19,813
这将导致竞争条件

1090
00:51:19,880 --> 0:51:22,182
来描述连接中实际发生的事情

1091
00:51:23,917 --> 0:51:25,853
如果你需要确保你的连接

1092
00:51:25,919 --> 0:51:28,488
不会通过蜂窝网络建立

1093
00:51:29,356 --> 0:51:30,190
不要…

1094
00:51:30,324 --> 0:51:33,460
预先检查设备当前是否运行在

1095
00:51:33,527 --> 0:51:34,828
因为那可能会改变

1096
00:51:35,362 --> 0:51:38,198
只需使用

1097
00:51:38,332 --> 0:51:40,067
你要使用的接口类型

1098
00:51:41,368 --> 0:51:42,870
一旦你启动了你的连接

1099
00:51:43,504 --> 0:51:44,571
并处于就绪状态

1100
00:51:44,638 --> 0:51:47,007
我们会为你提供一系列事件

1101
00:51:47,341 --> 0:51:50,077
来让你知道网络何时发生变化

1102
00:51:51,545 --> 0:51:54,615
第一个被称为连接可行性

1103
00:51:55,482 --> 0:51:56,583
可行性

1104
00:51:57,050 --> 0:52:00,587
表示你的连接能够通过该接口

1105
00:51:57,050 --> 0:52:00,587
表示你的连接能够通过该接口

1106
00:52:01,355 --> 0:52:03,624
即它有一个有效的路由

1107
00:52:05,192 --> 0:52:07,060
为了演示这一点

1108
00:52:07,528 --> 0:52:09,162
若当设备连到Wi-Fi网络时

1109
00:52:09,396 --> 0:52:12,366
你开始建立连接

1110
00:52:13,667 --> 0:52:14,601
然后

1111
00:52:14,668 --> 0:52:17,004
你的用户走进电梯

1112
00:52:17,304 --> 0:52:18,639
他们失去了信号

1113
00:52:19,206 --> 0:52:21,341
此时我们将会给你一个事件

1114
00:52:21,775 --> 0:52:25,112
让你知道连接不再可用

1115
00:52:25,812 --> 0:52:27,581
那么这时你应该怎么做呢？

1116
00:52:29,016 --> 0:52:29,917
两件事

1117
00:52:30,350 --> 0:52:32,686
我们建议 如果这对你的app来说

1118
00:52:32,753 --> 0:52:35,923
你可以让用户知道他们目前没有连接

1119
00:52:36,223 --> 0:52:38,258
如果他们试图发送和接收数据

1120
00:52:38,325 --> 0:52:39,893
现在这将无法正常工作

1121
00:52:41,161 --> 0:52:43,897
但是 你不一定要拆掉该连接

1122
00:52:44,731 --> 0:52:46,967
反正此时你也没有

1123
00:52:47,034 --> 0:52:48,635
可用的更好的接口

1124
00:52:48,902 --> 0:52:51,371
并且之前的Wi-Fi接口

1125
00:52:51,805 --> 0:52:54,074
通常 如果你走出电梯

1126
00:52:54,141 --> 0:52:55,409
并回到同一个Wi-Fi网络范围

1127
00:52:55,542 --> 0:52:58,078
你的连接立即可以在断开的地方恢复

1128
00:53:00,581 --> 0:53:04,418
我们给你的另一个事件

1129
00:53:05,786 --> 0:53:07,354
我们还是使用刚才的例子

1130
00:53:07,554 --> 0:53:09,690
即你通过Wi-Fi网络连接

1131
00:53:10,724 --> 0:53:14,428
假设你走出一幢建筑

1132
00:53:14,494 --> 0:53:16,864
但你现在可以使用蜂窝网络

1133
00:53:17,397 --> 0:53:19,399
此时我们会让你知道两件事

1134
00:53:20,033 --> 0:53:23,437
首先 你的连接不再像之前一样可用

1135
00:53:23,637 --> 0:53:27,274
但我们也会告诉你

1136
00:53:27,441 --> 0:53:28,842
如果你再次连接

1137
00:53:29,042 --> 0:53:31,011
你就能够使用蜂窝网络

1138
00:53:32,446 --> 0:53:33,714
这里的建议是

1139
00:53:34,515 --> 0:53:37,184
如果这对你的连接合适的话

1140
00:53:37,351 --> 0:53:39,753
尝试迁移到新连接

1141
00:53:39,820 --> 0:53:42,256
如果你能恢复刚才正在进行的工作

1142
00:53:44,091 --> 0:53:48,428
但只有在新连接完全就绪后

1143
00:53:48,629 --> 0:53:50,731
同样 Wi-Fi网络可能会回来

1144
00:53:51,598 --> 0:53:54,368
或蜂窝网络连接可能会失败

1145
00:53:56,503 --> 0:53:58,105
我想在这里强调的最后一种情况

1146
00:53:59,039 --> 0:54:02,442
是用户最初通过蜂窝网络连接

1147
00:53:59,039 --> 0:54:02,442
是用户最初通过蜂窝网络连接

1148
00:54:02,509 --> 0:54:06,346
然后用户走进建筑物

1149
00:54:07,014 --> 0:54:08,582
在这种情况下 你的连接

1150
00:54:08,649 --> 0:54:10,083
即原来的那个完全没问题

1151
00:54:10,150 --> 0:54:11,285
它仍然可用

1152
00:54:11,418 --> 0:54:13,854
但你现在也有更优的路径可用

1153
00:54:15,656 --> 0:54:18,792
同样的 在这种情况下

1154
00:54:18,859 --> 0:54:22,729
这可能是尝试建立新连接并使用它

1155
00:54:22,796 --> 0:54:23,997
来发送数据的好时机

1156
00:54:24,431 --> 0:54:26,533
这将为用户节省流量账单

1157
00:54:28,435 --> 0:54:31,238
但请继续使用原始连接

1158
00:54:31,405 --> 0:54:33,106
直到你完全建立新的连接

1159
00:54:34,274 --> 0:54:35,976
我们来看下代码的样子

1160
00:54:36,210 --> 0:54:38,579
你可以在连接上设置一个

1161
00:54:38,846 --> 0:54:41,048
它会返回一个布尔值

1162
00:54:41,114 --> 0:54:43,217
来让你知道当时连接是否可用

1163
00:54:43,984 --> 0:54:46,086
以及一个betterPathUpdateHandler

1164
00:54:46,153 --> 0:54:48,856
它告诉你何时有更优的路径可用

1165
00:54:49,089 --> 0:54:50,524
或不再可用

1166
00:54:53,427 --> 0:54:57,397
现在 处理网络移动性的

1167
00:54:57,464 --> 0:54:59,933
是我们前几年所谈到的

1168
00:55:00,200 --> 0:55:03,604
多路径连接 多路径TCP

1169
00:55:04,204 --> 0:55:07,941
如果你能够在服务器上

1170
00:55:08,675 --> 0:55:12,779
并且在客户端启用参数中的

1171
00:55:12,846 --> 0:55:13,847
multipathServiceType

1172
00:55:14,414 --> 0:55:16,750
那么你的连接将随着网络的变换

1173
00:55:16,817 --> 0:55:18,685
而在它们之间自动迁移

1174
00:55:18,986 --> 0:55:22,122
这是一种非常棒的无缝体验

1175
00:55:22,322 --> 0:55:23,857
你的app不需要处理任何工作

1176
00:55:24,858 --> 0:55:28,762
这也是URLSession中

1177
00:55:30,731 --> 0:55:34,768
关于Network.framework

1178
00:55:35,569 --> 0:55:38,772
若你在NWParameters中

1179
00:55:39,173 --> 0:55:42,543
这将适用于MPTCP

1180
00:55:42,876 --> 0:55:45,979
所以在使用多路径连接时

1181
00:55:46,046 --> 0:55:47,481
不使用蜂窝网络

1182
00:55:47,848 --> 0:55:51,251
这样我们只会在可用的

1183
00:55:51,318 --> 0:55:52,553
进行无缝迁移

1184
00:55:54,721 --> 0:55:58,091
此外 之前我提到的

1185
00:55:58,392 --> 0:56:00,260
与多路径TCP略有不同

1186
00:55:58,392 --> 0:56:00,260
与多路径TCP略有不同

1187
00:56:01,028 --> 0:56:04,331
因为每当我们更改网络时

1188
00:56:04,865 --> 0:56:06,633
你的连接

1189
00:56:06,700 --> 0:56:09,403
只有在你完全没有可用的网络时

1190
00:56:13,273 --> 0:56:16,777
因此在等待连接之间

1191
00:56:17,845 --> 0:56:20,647
可用性 更优路径 MPTCP

1192
00:56:21,014 --> 0:56:23,884
我们真的希望你的app中

1193
00:56:24,084 --> 0:56:27,087
所有这些使用

1194
00:56:27,254 --> 0:56:29,456
来手动检查网络更改的用例

1195
00:56:29,823 --> 0:56:30,991
都能被替换掉

1196
00:56:31,491 --> 0:56:32,993
然而我们的确意识到了

1197
00:56:33,360 --> 0:56:36,663
在有些情况下你仍然想知道

1198
00:56:37,164 --> 0:56:39,466
有哪些可用的网络

1199
00:56:40,667 --> 0:56:46,440
为此Network.framework提供了

1200
00:56:47,641 --> 0:56:48,909
这个PathMonitor

1201
00:56:49,209 --> 0:56:51,378
并不监视可达性

1202
00:56:51,445 --> 0:56:54,181
或尝试预测给定主机的可达性

1203
00:56:54,414 --> 0:56:55,315
而只是让你知道

1204
00:56:55,382 --> 0:56:57,484
你的设备上接口的当前状态是什么

1205
00:56:57,651 --> 0:56:59,820
以及它们何时改变

1206
00:57:01,054 --> 0:57:03,524
它允许你遍历

1207
00:57:03,590 --> 0:57:05,559
你可以连接的所有接口

1208
00:57:05,792 --> 0:57:07,995
以备你想要在其中每个上面

1209
00:57:09,129 --> 0:57:12,332
并且只要这些网络发生变化

1210
00:57:13,200 --> 0:57:16,503
这可能非常有用

1211
00:57:16,570 --> 0:57:18,839
来让用户知道他们是否已连接的话

1212
00:57:19,873 --> 0:57:22,209
如Stuart在上次演讲中提到的

1213
00:57:22,409 --> 0:57:23,744
可能有这样的场景

1214
00:57:23,810 --> 0:57:26,813
其中用户需要填写一个很长的表格

1215
00:57:26,880 --> 0:57:29,416
但他们可不想在填完的时候

1216
00:57:29,483 --> 0:57:31,885
才意识到他们没有连接

1217
00:57:32,819 --> 0:57:36,056
因此在这些情况下使用

1218
00:57:36,323 --> 0:57:39,459
只是等待连接的

1219
00:57:39,927 --> 0:57:43,096
所以在所有这些情况下

1220
00:57:43,263 --> 0:57:44,331
不再使用可达性

1221
00:57:44,598 --> 0:57:48,535
并比以往更优雅地处理网络转换

1222
00:57:50,804 --> 0:57:52,339
接下来 我想邀请Josh

1223
00:57:52,406 --> 0:57:55,108
回到舞台上来并告诉你如何参与

1224
00:57:55,242 --> 0:57:56,610
并开始使用

1225
00:58:02,482 --> 0:58:03,317
谢谢 Tommy

1226
00:58:03,817 --> 0:58:07,387
我们有一个很棒的新API

1227
00:58:08,222 --> 0:58:09,990
我想谈谈为了立即开始使用它

1228
00:58:10,057 --> 0:58:11,091
你可以做的事情

1229
00:58:11,158 --> 0:58:13,093
但首先我要谈一些

1230
00:58:13,160 --> 0:58:14,728
我们希望你不要做的事情

1231
00:58:14,795 --> 0:58:16,864
以便我们可以真正利用这些新技术

1232
00:58:16,930 --> 0:58:18,365
比如用户态网络

1233
00:58:19,733 --> 0:58:22,269
若你使用的是macOS

1234
00:58:22,336 --> 0:58:24,538
而且你正在该网络内核扩展中

1235
00:58:24,605 --> 0:58:27,975
执行某些用其它方法实现不了的操作

1236
00:58:28,041 --> 0:58:29,843
我们会为你提供更好的选择

1237
00:58:30,077 --> 0:58:32,412
因为网络内核扩展不兼容

1238
00:58:32,479 --> 0:58:33,780
用户态网络

1239
00:58:35,315 --> 0:58:37,451
你需要注意

1240
00:58:38,585 --> 0:58:41,088
代理自动配置将不再支持

1241
00:58:41,154 --> 0:58:42,856
FTP和文件URL

1242
00:58:42,923 --> 0:58:45,392
以后唯一支持的URL方案

1243
00:58:45,459 --> 0:58:48,161
将是HTTP和HTTPS

1244
00:58:49,496 --> 0:58:52,332
我们希望你停止使用

1245
00:58:52,399 --> 0:58:53,901
Core Foundation层

1246
00:58:53,967 --> 0:58:55,469
它们最终会被弃用

1247
00:58:55,536 --> 0:58:57,571
虽然它们尚未标记为已弃用

1248
00:58:57,971 --> 0:59:02,409
它们是CFStreamCreatePairWith

1249
00:58:57,971 --> 0:59:02,409
它们是CFStreamCreatePairWith

1250
00:59:02,743 --> 0:59:03,911
以及CFSocket

1251
00:59:04,645 --> 0:59:07,748
它们不能很好利用我们通过

1252
00:59:07,814 --> 0:59:08,682
Network.framework

1253
00:59:08,982 --> 0:59:10,517
许多关于连接建立的优化

1254
00:59:10,584 --> 0:59:12,920
并且也无法利用新的用户态网络

1255
00:59:12,986 --> 0:59:14,488
我们真的希望你能摆脱它们

1256
00:59:14,555 --> 0:59:18,358
以利用Network.framework

1257
00:59:18,425 --> 0:59:21,094
强大的连接性改进

1258
00:59:21,461 --> 0:59:22,896
和性能改进

1259
00:59:24,364 --> 0:59:27,534
还有一些Foundation API

1260
00:59:27,601 --> 0:59:33,240
如果你使用NSStream、NSNetService

1261
00:59:33,373 --> 0:59:36,743
请改为使用Network.framework

1262
00:59:37,611 --> 0:59:39,746
最后 如果你使用的是

1263
00:59:40,514 --> 0:59:42,182
我们觉得等待连接模型

1264
00:59:42,249 --> 0:59:45,419
是一个更好的模型

1265
00:59:46,053 --> 0:59:48,121
对于那些等待连接并不合适的

1266
00:59:48,188 --> 0:59:49,223
少数情况

1267
00:59:49,289 --> 0:59:52,259
以后NWPathMonitor

1268
00:59:53,393 --> 0:59:55,462
我们已经说了一些不希望你做的事情

1269
00:59:55,529 --> 0:59:57,764
现在我想专注于

1270
00:59:58,632 --> 0:59:59,566
从此以后

1271
00:59:59,633 --> 1:00:02,002
我们平台上的网络首选API

1272
00:59:59,633 --> 1:00:02,002
我们平台上的网络首选API

1273
01:00:02,069 --> 1:00:04,571
是URLSession

1274
01:00:04,705 --> 1:00:07,641
URLSession

1275
01:00:07,708 --> 1:00:11,411
但流任务提供了非常简单的

1276
01:00:11,478 --> 1:00:12,813
TCP和TLS连接

1277
01:00:13,881 --> 1:00:15,449
如果你需要更先进的东西

1278
01:00:15,749 --> 1:00:17,417
Network.framework

1279
01:00:17,484 --> 1:00:20,954
对TCP、TLS

1280
01:00:21,088 --> 1:00:23,123
它处理监听入站连接

1281
01:00:23,190 --> 1:00:24,691
以及出站连接

1282
01:00:24,758 --> 1:00:27,794
并且我们用PathMonitor

1283
01:00:29,530 --> 1:00:31,965
下一步 我们真的希望看到你采用

1284
01:00:32,499 --> 1:00:34,668
Network.framework

1285
01:00:35,002 --> 1:00:37,771
你的客户将会赞赏

1286
01:00:38,172 --> 1:00:40,440
你建立的连接有多么可靠

1287
01:00:40,674 --> 1:00:42,209
并赞赏更好的性能所带来的

1288
01:00:42,276 --> 1:00:43,343
更长的电池续航时间

1289
01:00:45,145 --> 1:00:47,047
当你做这些事时 请关注于

1290
01:00:48,215 --> 1:00:49,850
你如何处理发送和接收

1291
01:00:49,917 --> 1:00:51,618
来真正优化其性能

1292
01:00:52,052 --> 1:00:54,388
并多花些时间来获得

1293
01:00:54,454 --> 1:00:57,324
对可行性和更优路径变化的支持

1294
01:00:57,391 --> 1:00:58,992
它对于提供无缝的网络体验

1295
01:00:59,059 --> 1:01:01,128
至关重要

1296
01:00:59,059 --> 1:01:01,128
至关重要

1297
01:01:02,863 --> 1:01:05,732
现在我们知道Network.framework

1298
01:01:06,066 --> 1:01:07,434
所以若你正使用UDP组播

1299
01:01:07,501 --> 1:01:09,336
我们真的很想了解你的用例

1300
01:01:09,403 --> 1:01:11,438
以便以后我们可以将这些考虑在内

1301
01:01:12,606 --> 1:01:14,208
此外 如果你有任何其它问题

1302
01:01:14,274 --> 1:01:15,409
或增强请求

1303
01:01:15,742 --> 1:01:17,044
我们很乐意听取你的意见

1304
01:01:17,110 --> 1:01:19,413
请联系开发人员支持

1305
01:01:19,847 --> 1:01:20,781
或到访我们的实验室

1306
01:01:20,848 --> 1:01:24,518
午饭后两点我们有一个实验室

1307
01:01:25,853 --> 1:01:27,721
更多详细信息 请参阅此URL

1308
01:01:28,989 --> 1:01:31,792
别忘了明天早上和午餐后的实验室

1309
01:01:31,859 --> 1:01:34,428
非常感谢
