1
00:00:06,516 --> 0:00:15,500
[ 音乐 ]

2
00:00:20,516 --> 0:00:25,176
[ 掌声 ]

3
00:00:25,676 --> 0:00:26,356
&gt;&gt; 大家好

4
00:00:27,316 --> 0:00:29,336
欢迎来到 221 号讨论会 

5
00:00:29,336 --> 0:00:29,906
“TextKit Best Practices（最佳实践）”

6
00:00:29,906 --> 0:00:31,086
我是 Donna Tom

7
00:00:31,086 --> 0:00:32,826
一名 TextKit 工程师

8
00:00:32,826 --> 0:00:35,076
我的同事 Emily Van Haren

9
00:00:35,076 --> 0:00:36,116
今天也会和我一起介绍

10
00:00:36,116 --> 0:00:36,806
她来自创作工具组

11
00:00:37,036 --> 0:00:38,796
我们非常激动能够

12
00:00:38,796 --> 0:00:39,756
和大家分享

13
00:00:39,756 --> 0:00:41,286
运用 TextKit 的一些最佳实践

14
00:00:41,676 --> 0:00:42,746
让我们开始吧

15
00:00:43,416 --> 0:00:45,786
首先 我们将回顾一下

16
00:00:45,786 --> 0:00:47,616
运用 TextKit 的一些关键概念

17
00:00:48,466 --> 0:00:49,916
然后 我们会通过一些

18
00:00:49,916 --> 0:00:51,316
例子来说明如何

19
00:00:51,316 --> 0:00:52,596
把这些关键概念运用到

20
00:00:52,596 --> 0:00:52,663
你的 App 中

21
00:00:53,916 --> 0:00:55,316
最后 我们将以一些

22
00:00:55,316 --> 0:00:56,716
在正确性 性能 

23
00:00:56,716 --> 0:00:59,116
以及安全领域的最佳实践结束

24
00:01:00,496 --> 0:01:03,496
现在让我们从关键概念开始吧

25
00:01:03,496 --> 0:01:04,346
为了确保我们进度相同

26
00:01:04,385 --> 0:01:06,496
我们将从最基础的内容开始

27
00:01:07,526 --> 0:01:08,616
什么是 TextKit

28
00:01:09,126 --> 0:01:12,016
你的第一反应可能是

29
00:01:12,296 --> 0:01:13,626
去在 Xcode 中打开一个

30
00:01:13,626 --> 0:01:15,276
新的 Playground 并且输入

31
00:01:15,426 --> 0:01:17,716
“import TextKit” 

32
00:01:17,716 --> 0:01:19,116
除非你已经试过这样做

33
00:01:19,116 --> 0:01:19,796
并且发现没有用

34
00:01:20,216 --> 0:01:23,236
这是因为 TextKit

35
00:01:23,236 --> 0:01:24,456
与其他你可能已经用过的框架相比

36
00:01:24,456 --> 0:01:25,406
有些不同

37
00:01:26,306 --> 0:01:27,116
你不必导入任何东西

38
00:01:27,116 --> 0:01:28,336
就可以使用它

39
00:01:29,376 --> 0:01:30,776
UIKit 和 AppKit 中的

40
00:01:30,776 --> 0:01:32,866
文本控件都是建立在

41
00:01:32,866 --> 0:01:33,246
TextKit 上面的

42
00:01:33,806 --> 0:01:34,946
所以 如果你曾使用过

43
00:01:34,946 --> 0:01:37,026
label textField 或者 textView

44
00:01:37,066 --> 0:01:38,846
你其实已经使用过 TextKit 了

45
00:01:39,846 --> 0:01:40,796
TextKit 还集成了

46
00:01:40,796 --> 0:01:42,386
强大的底层技术

47
00:01:42,596 --> 0:01:44,146
比如 Core Text Core Graphics

48
00:01:44,296 --> 0:01:46,036
和 Foundation 来让你的 App

49
00:01:46,036 --> 0:01:47,756
能够轻松且完美地显示文本

50
00:01:49,176 --> 0:01:50,396
每次你使用这些

51
00:01:50,396 --> 0:01:51,806
内置控件之一的时候 你都是在

52
00:01:51,806 --> 0:01:53,416
使用 TextKit 的功能去

53
00:01:53,416 --> 0:01:55,156
显示或编辑文本 以一种完全 

54
00:01:55,156 --> 0:01:56,826
国际化 可本地化

55
00:01:56,826 --> 0:01:58,186
的方式 并且没有

56
00:01:58,186 --> 0:01:59,426
直接运用这些底层

57
00:01:59,426 --> 0:02:01,086
技术或者理解

58
00:01:59,426 --> 0:02:01,086
技术或者理解

59
00:02:01,086 --> 0:02:02,566
复杂的脚本

60
00:02:02,626 --> 0:02:04,356
还有很多

61
00:02:04,356 --> 0:02:05,706
你还能顺带获得很多额外的东西

62
00:02:05,706 --> 0:02:06,736
比如你在这里看到的

63
00:02:06,736 --> 0:02:07,146
这些显示特性

64
00:02:07,796 --> 0:02:10,346
至于编辑 你也会

65
00:02:10,346 --> 0:02:11,636
获得所有 OS 所支持的

66
00:02:11,636 --> 0:02:12,646
技术服务

67
00:02:12,766 --> 0:02:14,466
比如辅助功能

68
00:02:14,466 --> 0:02:15,186
拼写检查等等

69
00:02:15,886 --> 0:02:16,946
你可以充分利用

70
00:02:16,946 --> 0:02:18,276
所有这些出色的功能

71
00:02:18,406 --> 0:02:19,566
而无需编写

72
00:02:19,566 --> 0:02:21,486
一行代码 这真的很棒

73
00:02:22,486 --> 0:02:23,716
有了这么多触手可及的

74
00:02:23,716 --> 0:02:24,406
功能供你选择

75
00:02:24,406 --> 0:02:25,986
你怎么决定

76
00:02:25,986 --> 0:02:27,646
使用哪一个控件呢

77
00:02:28,196 --> 0:02:29,246
那我们就来讨论一下

78
00:02:29,756 --> 0:02:30,796
如何为你的情况选择

79
00:02:30,796 --> 0:02:31,636
合适的控件

80
00:02:31,946 --> 0:02:32,956
你可能会有

81
00:02:32,956 --> 0:02:33,926
不同的选择 取决于

82
00:02:33,926 --> 0:02:36,046
你是在使用 UIKit 还是 AppKit

83
00:02:36,436 --> 0:02:37,506
所以让我们分别讨论一下

84
00:02:37,506 --> 0:02:38,166
好的

85
00:02:38,696 --> 0:02:40,466
让我们从 UIKit 开始

86
00:02:41,006 --> 0:02:44,846
首先 你会考虑你是否需要文本输入

87
00:02:45,346 --> 0:02:47,476
如果你不需要文本输入 

88
00:02:47,476 --> 0:02:49,006
那接下来你考虑你是否

89
00:02:49,006 --> 0:02:50,406
需要选择或滚动

90
00:02:50,976 --> 0:02:53,376
如果你不需要这些

91
00:02:53,676 --> 0:02:54,916
那你应该使用 UILabel

92
00:02:55,666 --> 0:02:57,276
UILabels 适用于

93
00:02:57,276 --> 0:02:58,936
少量的文本 比如几个字

94
00:02:58,936 --> 0:02:59,656
或者几行字

95
00:03:01,136 --> 0:03:02,096
如果你有比这更多的文本

96
00:03:02,136 --> 0:03:03,696
或者你需要

97
00:03:03,826 --> 0:03:04,546
选择或者滚动的功能

98
00:03:04,546 --> 0:03:05,966
那你需要使用

99
00:03:05,966 --> 0:03:07,676
禁用编辑的 

100
00:03:07,676 --> 0:03:08,116
UITextView 

101
00:03:08,116 --> 0:03:10,286
现在我们回到顶端

102
00:03:10,286 --> 0:03:12,456
如果你需要文本输入 那么

103
00:03:12,456 --> 0:03:13,626
考虑你是否需要安全的

104
00:03:13,626 --> 0:03:14,186
文本输入

105
00:03:14,186 --> 0:03:15,336
这会像密码栏一样

106
00:03:15,336 --> 0:03:16,936
其中文本被隐藏起来

107
00:03:16,936 --> 0:03:18,666
复制被禁用

108
00:03:19,236 --> 0:03:21,806
如果你需要这样

109
00:03:21,806 --> 0:03:23,726
你就应该使用 UITextField 因为它是

110
00:03:23,726 --> 0:03:25,076
唯一支持安全文本

111
00:03:25,246 --> 0:03:26,026
输入的控件

112
00:03:26,476 --> 0:03:29,346
否则 想想你

113
00:03:29,456 --> 0:03:30,886
想输入的文本有多少

114
00:03:32,076 --> 0:03:33,016
如果你想要像表单栏输入那样

115
00:03:33,016 --> 0:03:34,466
只需要一行的

116
00:03:34,466 --> 0:03:36,076
那就使用

117
00:03:36,076 --> 0:03:36,836
UITextField

118
00:03:37,126 --> 0:03:38,686
UITextField 仅支持

119
00:03:38,766 --> 0:03:41,716
一行文本输入

120
00:03:41,936 --> 0:03:42,996
如果你需要比这更多的文本

121
00:03:43,176 --> 0:03:44,556
你可以使用 UITextView

122
00:03:45,106 --> 0:03:47,976
对于 AppKit 来说

123
00:03:47,976 --> 0:03:49,206
同样需要这样的决策过程

124
00:03:49,206 --> 0:03:51,006
这个过程和 UIKit 的很像

125
00:03:51,006 --> 0:03:52,656
但是有些小小的不同

126
00:03:53,406 --> 0:03:55,496
你也要从考虑是否

127
00:03:55,496 --> 0:03:57,036
需要文本输入开始

128
00:03:57,596 --> 0:04:00,526
AppKit 没有标签控件

129
00:03:57,596 --> 0:04:00,526
AppKit 没有标签控件

130
00:04:00,716 --> 0:04:02,106
所以 如果你需要展示文本

131
00:04:03,116 --> 0:04:04,546
那就使用 NSTextField

132
00:04:04,546 --> 0:04:05,546
你可以禁用编辑和选择

133
00:04:05,546 --> 0:04:07,036
来获得和标签一样的效果

134
00:04:07,036 --> 0:04:10,566
现在回到顶端

135
00:04:10,566 --> 0:04:12,286
如果你需要文本输入 

136
00:04:12,456 --> 0:04:13,526
问问自己是否需要

137
00:04:13,526 --> 0:04:13,806
安全文本输入

138
00:04:13,806 --> 0:04:15,856
如果需要 那你可以使用

139
00:04:15,986 --> 0:04:16,766
NSSecureTextField

140
00:04:17,176 --> 0:04:19,296
否则 我们会问

141
00:04:19,296 --> 0:04:20,596
我们最喜欢的问题

142
00:04:20,596 --> 0:04:22,346
你想要多少文本

143
00:04:23,176 --> 0:04:25,116
NSTextView 对展示

144
00:04:25,116 --> 0:04:26,556
大量文本进行了优化

145
00:04:26,946 --> 0:04:28,416
所以 如果你有大量文本要处理

146
00:04:28,416 --> 0:04:30,506
你应该使用 NSTextView

147
00:04:31,126 --> 0:04:32,556
否则 你可以使用

148
00:04:32,556 --> 0:04:33,216
NSTextField

149
00:04:33,946 --> 0:04:34,986
与 UIKit 不同

150
00:04:34,986 --> 0:04:36,926
NSTextField 

151
00:04:36,976 --> 0:04:38,136
支持多行文字 

152
00:04:39,056 --> 0:04:40,086
但是它更适用于

153
00:04:40,086 --> 0:04:41,556
短一些的字符串

154
00:04:41,556 --> 0:04:43,076
因此如果你有大量的文本的话 

155
00:04:43,076 --> 0:04:45,766
仍然应该使用 NSTextView

156
00:04:45,896 --> 0:04:47,616
好 你们中的和 TextKit 打过几次交道的人

157
00:04:47,616 --> 0:04:49,336
可能已经注意到

158
00:04:49,336 --> 0:04:50,266
这个流程图缺少了一个选项

159
00:04:50,266 --> 0:04:51,896
那就是字符串绘制优化

160
00:04:53,096 --> 0:04:54,416
你可以通过在你的

161
00:04:54,416 --> 0:04:56,016
NSString 或者 NSAttributedString 下

162
00:04:56,296 --> 0:04:58,396
直接调用 draw(at: CGPoint) 

163
00:04:58,466 --> 0:04:59,296
或 draw(in: CGRect) 

164
00:04:59,296 --> 0:05:00,236
来进行字符串绘制

165
00:04:59,296 --> 0:05:00,236
来进行字符串绘制

166
00:05:01,146 --> 0:05:02,366
你们中的一些人可能会为了

167
00:05:02,366 --> 0:05:03,696
避免在 Kit 层级上使用过多的

168
00:05:03,846 --> 0:05:05,236
视图对象所带来的性能收益

169
00:05:05,236 --> 0:05:06,276
来使用它

170
00:05:07,606 --> 0:05:08,446
因此 如果你想要用这个方法

171
00:05:08,446 --> 0:05:10,826
请务必记住下面的几点提示

172
00:05:11,696 --> 0:05:12,686
你应该用它来处理

173
00:05:12,686 --> 0:05:13,676
少量的静态文本

174
00:05:14,166 --> 0:05:14,926
并且你应该限制

175
00:05:14,926 --> 0:05:16,396
调用 draw() 方法的频率

176
00:05:17,236 --> 0:05:18,186
如果你频繁地调用字符串

177
00:05:18,186 --> 0:05:20,296
绘制方法 

178
00:05:20,296 --> 0:05:21,626
你获得的性能表现可能不如

179
00:05:21,896 --> 0:05:23,706
使用标签或文本栏

180
00:05:23,846 --> 0:05:25,006
因为这些控件能提供

181
00:05:25,006 --> 0:05:26,516
更好的缓存 特别是

182
00:05:26,516 --> 0:05:27,306
使用自动布局的情况下

183
00:05:27,306 --> 0:05:29,216
如果你正在绘制一个

184
00:05:29,216 --> 0:05:31,056
有很多自定义属性的

185
00:05:31,056 --> 0:05:33,176
属性文本字符串 这也会

186
00:05:33,176 --> 0:05:34,366
减慢你的字符串绘制

187
00:05:34,366 --> 0:05:35,756
因为文本系统

188
00:05:35,756 --> 0:05:36,936
需要在渲染之前

189
00:05:36,936 --> 0:05:38,966
验证所有的属性 

190
00:05:38,966 --> 0:05:40,386
因此 为了最佳性能表现

191
00:05:40,386 --> 0:05:41,326
你应该在绘制之前

192
00:05:41,326 --> 0:05:42,906
剥离额外的属性

193
00:05:42,906 --> 0:05:44,776
只保留那些

194
00:05:44,776 --> 0:05:46,706
需要去决定的视觉表现属性

195
00:05:46,706 --> 0:05:48,506
比如字体或颜色

196
00:05:49,076 --> 0:05:51,996
最后你要知道

197
00:05:51,996 --> 0:05:53,146
如果使用字符串绘制

198
00:05:53,146 --> 0:05:54,546
你会失去所有这些

199
00:05:54,546 --> 0:05:55,746
文本控件提供的额外功能

200
00:05:55,746 --> 0:05:57,286
因此只要可能的话

201
00:05:57,286 --> 0:05:59,166
你应该一直使用文本控件

202
00:05:59,726 --> 0:06:02,706
所以现在你知道

203
00:05:59,726 --> 0:06:02,706
所以现在你知道

204
00:06:02,706 --> 0:06:03,966
仅仅通过 TextKit 的内置控件

205
00:06:03,966 --> 0:06:04,796
你可以做些什么了

206
00:06:05,596 --> 0:06:06,686
但是如果你需要的

207
00:06:06,766 --> 0:06:07,716
比这些控件所提供的更多

208
00:06:08,206 --> 0:06:08,986
你需要文本堆栈中

209
00:06:08,986 --> 0:06:11,276
找到正确的定制点

210
00:06:12,376 --> 0:06:14,036
与 Cocoa 很像 TextKit

211
00:06:14,036 --> 0:06:16,766
是基于 MVC 设计模式的

212
00:06:17,316 --> 0:06:19,356
文本系统可以

213
00:06:19,356 --> 0:06:20,946
被分为三个阶段

214
00:06:20,946 --> 0:06:22,256
直接与 MVC 对应

215
00:06:22,386 --> 0:06:25,236
分别是存储 显示和布局

216
00:06:25,996 --> 0:06:27,446
我们现在来仔细看看

217
00:06:27,446 --> 0:06:28,916
构成了各个阶段

218
00:06:28,916 --> 0:06:29,946
的 TextKit 对象

219
00:06:30,346 --> 0:06:32,176
我们从存储开始

220
00:06:32,466 --> 0:06:35,746
它对应的是 Model（模型）

221
00:06:35,746 --> 0:06:36,866
NSTextStorage 存储着你的

222
00:06:36,866 --> 0:06:38,026
字符串数据和属性

223
00:06:38,746 --> 0:06:40,166
它是 NSMutableAttributedString 的

224
00:06:40,166 --> 0:06:41,806
一个子类 因此你可以用

225
00:06:41,806 --> 0:06:43,146
你已经熟悉的

226
00:06:43,146 --> 0:06:44,046
使用 attributedString 的方式

227
00:06:44,046 --> 0:06:45,046
来使用它

228
00:06:46,036 --> 0:06:47,256
我的同事 Emily 

229
00:06:47,256 --> 0:06:48,666
将会在稍后

230
00:06:48,666 --> 0:06:49,896
展示一些强大的方法

231
00:06:49,896 --> 0:06:51,246
来自定义 NSTextStorage

232
00:06:51,246 --> 0:06:52,146
期待一下吧

233
00:06:53,706 --> 0:06:55,716
NSTextContainer 会为

234
00:06:55,716 --> 0:06:56,906
你的文本将要被展示的几何区域

235
00:06:56,906 --> 0:06:57,866
建立模型

236
00:06:58,586 --> 0:07:00,006
默认情况下 它是一个矩形

237
00:06:58,586 --> 0:07:00,006
默认情况下 它是一个矩形

238
00:07:00,306 --> 0:07:01,596
但你也可以自定义

239
00:07:01,596 --> 0:07:02,746
文本布局的走向或者形状

240
00:07:02,876 --> 0:07:03,486
就像这里展示的一样

241
00:07:04,096 --> 0:07:06,186
要了解更多详细的

242
00:07:06,186 --> 0:07:07,216
关于存储对象的信息

243
00:07:07,266 --> 0:07:08,806
看看这些以往优秀的

244
00:07:08,806 --> 0:07:11,246
WWDC 讨论会内容和文件

245
00:07:11,246 --> 0:07:12,656
这些能在讨论会结束时的

246
00:07:12,656 --> 0:07:16,596
更多信息链接中找到

247
00:07:17,396 --> 0:07:18,676
接下来是显示阶段

248
00:07:18,966 --> 0:07:21,276
它对应着视图

249
00:07:21,276 --> 0:07:22,626
我们已经讨论了

250
00:07:22,626 --> 0:07:23,746
一些显示阶段的内容

251
00:07:23,746 --> 0:07:24,736
在我们讨论选择

252
00:07:24,736 --> 0:07:25,396
正确控件的时候

253
00:07:25,766 --> 0:07:26,436
因此为获得更多的信息

254
00:07:26,436 --> 0:07:27,876
你可以再一次查看

255
00:07:27,876 --> 0:07:29,186
这些文件和资源

256
00:07:29,186 --> 0:07:30,796
这些也可以

257
00:07:30,796 --> 0:07:31,986
在讨论会的结尾的

258
00:07:31,986 --> 0:07:35,166
更多信息链接中获得

259
00:07:35,426 --> 0:07:36,586
最后 我们讨论下布局阶段

260
00:07:36,586 --> 0:07:38,446
它对应着控件

261
00:07:39,026 --> 0:07:41,836
NSLayoutManager 是这个阶段中

262
00:07:41,836 --> 0:07:42,656
唯一的组成部分

263
00:07:42,656 --> 0:07:44,806
它是一头野兽

264
00:07:46,036 --> 0:07:47,386
这是个褒义词

265
00:07:47,726 --> 0:07:49,656
因为它的功能实在是太棒了

266
00:07:50,146 --> 0:07:52,056
因此它是整个运作的大脑

267
00:07:52,056 --> 0:07:53,296
它协调所有阶段中的

268
00:07:53,296 --> 0:07:55,996
变化 并且控制着布局过程

269
00:07:56,066 --> 0:07:59,296
所以这里简要介绍一下

270
00:07:59,296 --> 0:08:00,546
布局过程是怎样进行的

271
00:07:59,296 --> 0:08:00,546
布局过程是怎样进行的

272
00:08:01,426 --> 0:08:03,166
文字布局发生在

273
00:08:03,216 --> 0:08:04,596
系统修复文本存储的属性之后

274
00:08:04,596 --> 0:08:06,006
来消除不一致

275
00:08:06,006 --> 0:08:08,206
比如确定字符串中

276
00:08:08,206 --> 0:08:09,626
所有的字符

277
00:08:09,626 --> 0:08:11,206
都使用支持

278
00:08:11,246 --> 0:08:12,626
显示该字符的字体

279
00:08:13,086 --> 0:08:14,906
所以在这个例子中

280
00:08:14,906 --> 0:08:15,996
Times New Roman 被指定到

281
00:08:16,056 --> 0:08:17,566
整个字符串

282
00:08:18,096 --> 0:08:19,486
但是这个字体并不支持

283
00:08:19,936 --> 0:08:21,906
显示日文汉字或者表情符号

284
00:08:23,136 --> 0:08:24,536
因此在属性修正后

285
00:08:24,536 --> 0:08:25,446
你的文本存储

286
00:08:25,476 --> 0:08:26,876
看起来会像这样

287
00:08:26,876 --> 0:08:28,146
日文字符被

288
00:08:28,376 --> 0:08:29,346
分配了适当的日文字体

289
00:08:29,346 --> 0:08:31,186
表情符号被

290
00:08:31,186 --> 0:08:32,476
分配了的表情符号字体

291
00:08:32,476 --> 0:08:33,145
好的

292
00:08:33,856 --> 0:08:36,006
一旦属性被修正了

293
00:08:36,006 --> 0:08:37,666
布局过程就开始了

294
00:08:37,666 --> 0:08:39,606
我们可以认为布局

295
00:08:39,666 --> 0:08:42,866
分为两步 字形生成和字形布局

296
00:08:44,256 --> 0:08:45,366
一旦它们被布局好了

297
00:08:45,646 --> 0:08:46,456
就可以显示了

298
00:08:47,086 --> 0:08:48,606
但是 等一下

299
00:08:48,946 --> 0:08:49,356
什么是字形

300
00:08:50,206 --> 0:08:51,226
让我们回顾一下

301
00:08:52,146 --> 0:08:53,296
字形是一种代表一个

302
00:08:53,296 --> 0:08:54,536
或多个字符的

303
00:08:54,536 --> 0:08:55,046
视觉符号

304
00:08:55,536 --> 0:08:56,916
正如你在这里看到的那样

305
00:08:56,916 --> 0:08:58,056
字符与字形之间的映射

306
00:08:58,056 --> 0:09:00,066
并不总是一对一的

307
00:08:58,056 --> 0:09:00,066
并不总是一对一的

308
00:09:01,476 --> 0:09:03,286
字符串 “ffi” 有

309
00:09:03,386 --> 0:09:04,996
三个字符 但是它可以 

310
00:09:04,996 --> 0:09:06,476
由连起来的单个

311
00:09:06,556 --> 0:09:07,096
字形表示

312
00:09:07,096 --> 0:09:09,726
其实反过来也可以

313
00:09:10,456 --> 0:09:11,626
这里有一个 “ñ”

314
00:09:11,846 --> 0:09:13,436
这是一个单独的字符

315
00:09:13,436 --> 0:09:14,436
它可以由多个字形表示

316
00:09:14,436 --> 0:09:16,786
一个 “n”

317
00:09:16,786 --> 0:09:17,226
一个波浪号

318
00:09:18,836 --> 0:09:20,416
回到我们的图中

319
00:09:20,416 --> 0:09:22,456
我们的 NSLayoutManager

320
00:09:22,456 --> 0:09:24,726
执行字形生成和字形布局

321
00:09:25,486 --> 0:09:27,036
在字形生成这一步中

322
00:09:27,036 --> 0:09:28,096
布局管理器（Layout Manager）会

323
00:09:28,096 --> 0:09:29,446
获取字符并确定

324
00:09:29,476 --> 0:09:30,396
需要绘制的字形

325
00:09:31,276 --> 0:09:32,716
在字形布局这一步

326
00:09:32,716 --> 0:09:34,056
布局管理器会定位好这些字形

327
00:09:34,056 --> 0:09:35,646
以在你的视图中显示

328
00:09:36,116 --> 0:09:38,416
从以往 WWDC 讨论会和文档中

329
00:09:38,416 --> 0:09:39,876
还可以学到很多

330
00:09:39,876 --> 0:09:42,216
关于布局管理器的知识

331
00:09:42,596 --> 0:09:45,596
你可以在 没错

332
00:09:45,596 --> 0:09:46,936
讨论会结尾的更多

333
00:09:47,596 --> 0:09:49,416
信息链接中

334
00:09:49,576 --> 0:09:51,976
好的 现在你了解了

335
00:09:51,976 --> 0:09:53,096
文本系统的阶段

336
00:09:53,466 --> 0:09:54,296
并且你知道了 TextKit

337
00:09:54,296 --> 0:09:55,666
构成每个阶段的组件

338
00:09:57,276 --> 0:09:58,796
所以现在让我们来看看

339
00:09:58,796 --> 0:10:00,336
如何为这些组件选择正确的配置

340
00:09:58,796 --> 0:10:00,336
如何为这些组件选择正确的配置

341
00:10:00,336 --> 0:10:02,876
来创造不同的效果

342
00:10:03,376 --> 0:10:05,466
这是你的标准配置

343
00:10:05,466 --> 0:10:07,666
当你从 “界面构建器（界面构建器）”

344
00:10:07,746 --> 0:10:08,816
中拖放文本视图时

345
00:10:08,816 --> 0:10:10,116
你会自动获取

346
00:10:10,116 --> 0:10:11,896
每个组件中的一个

347
00:10:11,896 --> 0:10:12,306
像这里一样

348
00:10:13,216 --> 0:10:14,416
大多数时候 

349
00:10:14,416 --> 0:10:17,286
这对你来说就足够了

350
00:10:17,566 --> 0:10:19,046
如果你想要一个多页或一个

351
00:10:19,046 --> 0:10:20,776
多栏布局 你可以

352
00:10:20,776 --> 0:10:22,426
使用多对文本容器和

353
00:10:22,426 --> 0:10:24,076
文本视图

354
00:10:24,076 --> 0:10:24,756
每页或每列一对

355
00:10:25,656 --> 0:10:26,856
你可以将所有这些都绑定到

356
00:10:26,916 --> 0:10:28,166
相同的文本存储中的

357
00:10:28,166 --> 0:10:29,526
相同的布局管理器上

358
00:10:29,526 --> 0:10:30,866
这样它们就能在

359
00:10:30,866 --> 0:10:31,856
后台存储中 共享

360
00:10:31,936 --> 0:10:32,166
布局信息了

361
00:10:32,746 --> 0:10:35,016
如果你想要让每个视图

362
00:10:35,016 --> 0:10:36,156
呈现不同的视图 你也可以做到

363
00:10:36,156 --> 0:10:37,906
只要使用多个布局管理器

364
00:10:37,906 --> 0:10:38,576
就可以了

365
00:10:39,006 --> 0:10:40,416
再次说明 因为文本

366
00:10:40,416 --> 0:10:41,726
共享相同的后台存储

367
00:10:42,246 --> 0:10:43,626
更新该文本将更新

368
00:10:43,626 --> 0:10:44,186
所有视图

369
00:10:44,886 --> 0:10:47,796
我们现在不会讨论过多

370
00:10:47,796 --> 0:10:48,636
关于这些配置的细节

371
00:10:48,636 --> 0:10:49,986
因为之前已经有一个

372
00:10:49,986 --> 0:10:50,926
讨论会介绍过了

373
00:10:50,926 --> 0:10:52,496
你可以去看看

374
00:10:52,546 --> 0:10:54,686
WWDC 2010 讨论会中的 “Advanced Cocoa

375
00:10:54,686 --> 0:10:55,996
Text Tips and Tricks”

376
00:10:55,996 --> 0:10:57,836
你可以在讨论会结尾的

377
00:10:57,836 --> 0:11:02,476
更多信息链接中找到它

378
00:10:57,836 --> 0:11:02,476
更多信息链接中找到它

379
00:11:02,626 --> 0:11:02,946
好的

380
00:11:04,036 --> 0:11:04,946
我们已经看过了内置

381
00:11:04,946 --> 0:11:05,576
文本控件

382
00:11:06,296 --> 0:11:07,236
我们已经看过了

383
00:11:07,236 --> 0:11:07,766
TextKit 的组件

384
00:11:07,976 --> 0:11:09,016
我们已经讲过了如何

385
00:11:09,016 --> 0:11:10,336
配置这些组件

386
00:11:10,336 --> 0:11:11,066
以实现不同的效果

387
00:11:11,066 --> 0:11:12,956
在你了解了这些知识以后

388
00:11:12,956 --> 0:11:14,406
现在你已经可以做很多事情了

389
00:11:14,636 --> 0:11:15,586
但是如果你想要更多

390
00:11:16,196 --> 0:11:17,056
你需要自己扩展

391
00:11:17,056 --> 0:11:18,596
并自定义 TextKit 的某些部分

392
00:11:19,766 --> 0:11:21,076
所以现在我们会谈一谈

393
00:11:21,076 --> 0:11:22,166
选择正确的方式

394
00:11:22,166 --> 0:11:23,766
来做到这一点

395
00:11:24,826 --> 0:11:26,516
选择正确的方式

396
00:11:26,556 --> 0:11:28,036
就像构建文本工具箱一样

397
00:11:28,616 --> 0:11:29,806
这就像因为需要一把锤子

398
00:11:29,806 --> 0:11:30,606
所以你去了商店一样

399
00:11:30,606 --> 0:11:32,056
当你到了商店

400
00:11:32,056 --> 0:11:34,216
你发现有大量的锤子供选择

401
00:11:34,966 --> 0:11:36,086
但你想选择

402
00:11:36,216 --> 0:11:38,206
能够完成这项工作的锤子

403
00:11:38,286 --> 0:11:39,526
最理想的是能满足你需求的

404
00:11:39,526 --> 0:11:40,346
最便宜的锤子

405
00:11:40,896 --> 0:11:43,416
这些是我们可以

406
00:11:43,566 --> 0:11:44,456
得到的锤子

407
00:11:45,396 --> 0:11:46,836
委托就是一种

408
00:11:46,836 --> 0:11:48,866
标准的羊角锤可以用来

409
00:11:48,866 --> 0:11:49,626
完成各种任务

410
00:11:50,316 --> 0:11:51,466
委托们有很多

411
00:11:51,466 --> 0:11:52,566
不同的自定义钩子

412
00:11:52,706 --> 0:11:53,766
大多数时候它

413
00:11:53,766 --> 0:11:56,206
就能帮你完成任务

414
00:11:56,426 --> 0:11:58,446
通知就像是球头锤

415
00:11:58,596 --> 0:11:59,666
它的末端是一个球

416
00:11:59,666 --> 0:12:03,196
而不是羊角 所以它更专业化

417
00:11:59,666 --> 0:12:03,196
而不是羊角 所以它更专业化

418
00:12:03,296 --> 0:12:04,866
适合某些特定的任务

419
00:12:04,866 --> 0:12:06,466
但它并不像委托那样

420
00:12:06,466 --> 0:12:07,956
是一个全能的锤子

421
00:12:08,506 --> 0:12:12,106
最后 子类是你的大锤

422
00:12:13,496 --> 0:12:14,596
大锤非常强大

423
00:12:14,596 --> 0:12:16,096
你可以将它用于

424
00:12:16,096 --> 0:12:17,596
任何你需要锤子的任务

425
00:12:17,596 --> 0:12:19,136
但在很多时候

426
00:12:19,136 --> 0:12:20,756
使用它会有些大材小用

427
00:12:21,386 --> 0:12:23,396
接下来 我想

428
00:12:23,396 --> 0:12:24,606
邀请 Emily 向我们展示如何

429
00:12:24,606 --> 0:12:25,936
使用这些不同种类的锤子

430
00:12:26,326 --> 0:12:26,656
Emily

431
00:12:27,516 --> 0:12:32,166
[ 掌声 ]

432
00:12:32,666 --> 0:12:33,216
&gt;&gt; 谢谢你 Donna

433
00:12:34,396 --> 0:12:36,106
因此 作为开发人员

434
00:12:36,106 --> 0:12:37,506
我们有一系列控件

435
00:12:37,566 --> 0:12:39,676
各种配置

436
00:12:40,106 --> 0:12:41,036
以及大量的自定义选项供我们选择

437
00:12:41,036 --> 0:12:42,786
以实现我们

438
00:12:42,786 --> 0:12:43,266
所需的功能

439
00:12:44,156 --> 0:12:45,406
所以我们的工具箱

440
00:12:45,496 --> 0:12:47,656
储备充足 那么我们要

441
00:12:47,656 --> 0:12:48,346
如何选择工具呢

442
00:12:49,066 --> 0:12:51,696
我们一起来看看

443
00:12:51,696 --> 0:12:52,886
一些 App 示例

444
00:12:52,886 --> 0:12:54,326
它们套用了 TextKit 的强大功能

445
00:12:55,326 --> 0:12:56,326
这样的 App 示例并不难找

446
00:12:56,326 --> 0:12:58,436
因为几乎我们使用的每个 App

447
00:12:58,496 --> 0:13:00,536
都需要显示或

448
00:12:58,496 --> 0:13:00,536
都需要显示或

449
00:13:01,436 --> 0:13:01,586
编辑文本

450
00:13:03,336 --> 0:13:04,666
我们首先看看

451
00:13:04,666 --> 0:13:05,776
两个我们都熟悉的 App 

452
00:13:05,826 --> 0:13:07,826
然后一步一步

453
00:13:07,826 --> 0:13:08,846
构建我们

454
00:13:08,846 --> 0:13:09,136
自己的 App

455
00:13:09,706 --> 0:13:12,086
我们要看的第一个 App

456
00:13:12,086 --> 0:13:13,816
是 iOS 上的 “Apple News”

457
00:13:14,576 --> 0:13:15,906
这是一个漂亮的 App

458
00:13:15,906 --> 0:13:18,926
在个性化以及甄选的

459
00:13:18,926 --> 0:13:19,936
文章中显示文本

460
00:13:20,646 --> 0:13:23,586
下面这个例子

461
00:13:23,586 --> 0:13:25,326
是在 “Spotlight” 标签页中

462
00:13:25,366 --> 0:13:26,106
“Featured” 栏目中的一篇文章

463
00:13:27,186 --> 0:13:29,616
现在 App 的顶部显示了

464
00:13:29,616 --> 0:13:31,016
关于这篇文章的一些细节

465
00:13:32,046 --> 0:13:33,846
我们如何才能用 TextKit

466
00:13:33,846 --> 0:13:34,976
重现这个外观和风格呢

467
00:13:38,176 --> 0:13:39,356
所以让我们考虑一下

468
00:13:39,356 --> 0:13:41,156
早些时候 Donna 向我们展示的流程图

469
00:13:41,156 --> 0:13:42,386
以便选择最适合

470
00:13:42,386 --> 0:13:43,416
本示例的控件

471
00:13:43,986 --> 0:13:47,186
我们有不少文本控件

472
00:13:47,186 --> 0:13:49,506
可供选择

473
00:13:49,596 --> 0:13:50,946
但由于我们想要

474
00:13:50,946 --> 0:13:52,776
显示的文本很少

475
00:13:52,876 --> 0:13:54,946
所以我们将在每一行都使用标签

476
00:13:54,946 --> 0:13:58,806
我们可以看到

477
00:13:58,806 --> 0:14:00,446
在检查器面板中

478
00:13:58,806 --> 0:14:00,446
在检查器面板中

479
00:14:00,446 --> 0:14:01,256
有很多定制选项

480
00:14:01,846 --> 0:14:03,756
我们继续

481
00:14:03,756 --> 0:14:05,076
将文本更改为 “Spotlight”

482
00:14:05,716 --> 0:14:07,776
并把字体

483
00:14:08,226 --> 0:14:09,336
改为 “Body”

484
00:14:09,926 --> 0:14:12,616
我们还要勾选

485
00:14:12,616 --> 0:14:14,546
“Dynamic Type” 这可以让

486
00:14:14,546 --> 0:14:15,866
启用辅助功能设置的用户

487
00:14:15,866 --> 0:14:17,956
能以适合它们需要的

488
00:14:18,026 --> 0:14:19,236
字体大小和样式

489
00:14:19,236 --> 0:14:20,306
来查看文本

490
00:14:21,026 --> 0:14:23,266
现在我们可以在

491
00:14:23,266 --> 0:14:24,216
界面构建器中

492
00:14:24,216 --> 0:14:25,966
自定义这个标签 但我们也可以

493
00:14:25,966 --> 0:14:27,196
在 Swift 代码中

494
00:14:27,276 --> 0:14:27,596
看到所有这些属性

495
00:14:28,826 --> 0:14:30,616
我们可以在运行时

496
00:14:30,616 --> 0:14:31,626
动态设置文本和

497
00:14:31,846 --> 0:14:33,036
排版属性

498
00:14:33,036 --> 0:14:36,266
现在回到界面构建器

499
00:14:36,866 --> 0:14:38,646
我们将继续添加两个标签

500
00:14:40,206 --> 0:14:41,536
现在一切都很好

501
00:14:42,146 --> 0:14:44,786
但我们还需要做一件事

502
00:14:46,286 --> 0:14:47,586
所以回头看 Apple News

503
00:14:47,716 --> 0:14:48,876
我们可以看到右边的文字

504
00:14:48,876 --> 0:14:50,246
实际上显示

505
00:14:50,246 --> 0:14:51,416
以两种不同的颜色

506
00:14:51,516 --> 0:14:53,676
一部分是黑色的 一部分是白色的

507
00:14:55,006 --> 0:14:56,016
现在我们可以实现这一点

508
00:14:56,016 --> 0:14:57,876
用两个单独的标签 但如果我们

509
00:14:57,876 --> 0:15:00,066
只想使用一个标签

510
00:14:57,876 --> 0:15:00,066
只想使用一个标签

511
00:15:00,066 --> 0:15:01,486
在界面构建器中

512
00:15:01,486 --> 0:15:02,356
是无法实现的

513
00:15:02,836 --> 0:15:06,156
那么我们怎么做到这一点呢

514
00:15:06,546 --> 0:15:07,646
我们可以利用

515
00:15:07,646 --> 0:15:09,216
NSAttributedString 强大而

516
00:15:09,216 --> 0:15:10,056
灵活的功能

517
00:15:11,856 --> 0:15:13,556
attributedString 是

518
00:15:13,556 --> 0:15:15,026
一串字符 它可以将属性

519
00:15:15,026 --> 0:15:17,236
应用于一定范围内的字符

520
00:15:18,076 --> 0:15:19,246
你可以轻松地获取一些属性

521
00:15:19,246 --> 0:15:21,506
比如默认字体 

522
00:15:21,506 --> 0:15:23,766
和文本颜色一样 但我们可以

523
00:15:23,766 --> 0:15:24,796
用我们自己的值重写

524
00:15:24,796 --> 0:15:25,156
这些属性

525
00:15:25,956 --> 0:15:27,216
在这种情况下 我们将把

526
00:15:27,216 --> 0:15:28,426
字符串的部分文本颜色

527
00:15:28,426 --> 0:15:28,756
设置为白色

528
00:15:28,756 --> 0:15:32,796
要具体查看属性字符串

529
00:15:32,926 --> 0:15:34,386
我们将使用

530
00:15:34,556 --> 0:15:35,646
在 NSMutableAttributedString 中的

531
00:15:35,706 --> 0:15:37,606
addAttribute() 方法

532
00:15:37,606 --> 0:15:39,376
来讲我们想要的范围内的文本

533
00:15:39,376 --> 0:15:40,266
设置成白色

534
00:15:41,506 --> 0:15:42,816
这一次 我们将

535
00:15:42,816 --> 0:15:44,476
在我们的标签上设置

536
00:15:44,476 --> 0:15:44,796
属性文本属性

537
00:15:45,256 --> 0:15:49,586
在运行时 

538
00:15:50,066 --> 0:15:50,246
这看起来很酷

539
00:15:51,336 --> 0:15:53,516
UILabels 对这类文本来说

540
00:15:53,516 --> 0:15:55,846
是很棒的选择

541
00:15:55,846 --> 0:15:56,876
如果我们看看屏幕底部

542
00:15:56,876 --> 0:15:57,846
我们会看到

543
00:15:57,966 --> 0:15:58,366
一个标题

544
00:15:58,546 --> 0:15:59,666
这也是文本

545
00:15:59,666 --> 0:16:01,516
但它有比较大

546
00:15:59,666 --> 0:16:01,516
但它有比较大

547
00:16:01,516 --> 0:16:02,216
占了很多行

548
00:16:02,826 --> 0:16:05,956
使这个文本不同的另一点是

549
00:16:05,956 --> 0:16:06,976
它是可以

550
00:16:06,976 --> 0:16:07,616
被选中的

551
00:16:08,206 --> 0:16:10,676
那么这次我们应该使用

552
00:16:10,676 --> 0:16:11,166
哪种控件呢

553
00:16:12,376 --> 0:16:14,076
文本栏和文本视图

554
00:16:14,076 --> 0:16:16,246
都支持选择

555
00:16:16,246 --> 0:16:18,206
但文本栏通常

556
00:16:18,206 --> 0:16:18,706
仅用于一行

557
00:16:19,306 --> 0:16:21,596
因此 在这种情况下 由于我们的

558
00:16:21,596 --> 0:16:22,716
标题可以跨越多行

559
00:16:22,716 --> 0:16:25,206
因此我们将使用

560
00:16:26,386 --> 0:16:26,496
文本视图

561
00:16:26,716 --> 0:16:28,126
当我们将文本视图

562
00:16:28,126 --> 0:16:29,596
放到 Storyboard 上时 我们可以看到

563
00:16:29,596 --> 0:16:31,046
我们默认会得到

564
00:16:31,236 --> 0:16:31,706
大量的测试文本

565
00:16:32,606 --> 0:16:33,456
我们继续来

566
00:16:33,456 --> 0:16:35,286
检查器面板中

567
00:16:35,366 --> 0:16:35,626
更改文本

568
00:16:37,236 --> 0:16:38,096
我们还要改变字体

569
00:16:38,166 --> 0:16:39,396
使它看起来更

570
00:16:39,396 --> 0:16:40,166
像 “Apple News”

571
00:16:40,806 --> 0:16:43,276
我们希望禁用

572
00:16:43,276 --> 0:16:44,316
编辑功能 因为

573
00:16:44,316 --> 0:16:45,646
标题不应该被编辑

574
00:16:46,246 --> 0:16:49,386
UITextView 默认支持滚动

575
00:16:49,426 --> 0:16:51,336
因为它们是

576
00:16:51,336 --> 0:16:52,136
UIScrollView 的子类

577
00:16:53,156 --> 0:16:54,746
但是 如果我们希望我们的文本视图

578
00:16:54,746 --> 0:16:57,046
在自动布局中良好运行

579
00:16:57,046 --> 0:16:58,126
我们应该禁用滚动

580
00:16:59,066 --> 0:17:00,456
因此 这将允许

581
00:16:59,066 --> 0:17:00,456
因此 这将允许

582
00:17:00,456 --> 0:17:02,466
我们的文本视图的边界调整大小

583
00:17:03,256 --> 0:17:05,296
以适应文本

584
00:17:05,455 --> 0:17:07,465
最后 这个白色背景

585
00:17:07,496 --> 0:17:09,056
真的需要删去

586
00:17:09,906 --> 0:17:10,826
所以我们要把它

587
00:17:10,826 --> 0:17:11,506
设置为透明

588
00:17:12,675 --> 0:17:13,886
界面构建器使得

589
00:17:13,886 --> 0:17:15,205
自定这个文本视图非常容易

590
00:17:15,246 --> 0:17:16,695
但是和之前的标签一样

591
00:17:16,695 --> 0:17:18,596
我们可以在代码中

592
00:17:18,596 --> 0:17:19,076
设置所有这些

593
00:17:20,026 --> 0:17:21,586
因此 在 Swift 中我们可以

594
00:17:21,586 --> 0:17:23,036
在运行时动态设置

595
00:17:23,036 --> 0:17:24,906
文本和格式属性

596
00:17:26,386 --> 0:17:27,506
我们现在看过了 Apple News

597
00:17:27,506 --> 0:17:28,546
并选择了正确的控件

598
00:17:29,396 --> 0:17:30,196
现在我们要看看另一个

599
00:17:30,196 --> 0:17:32,096
我们都熟悉的 App

600
00:17:32,096 --> 0:17:33,216
并选择正确的配置

601
00:17:33,216 --> 0:17:36,786
那就是“文本编辑”

602
00:17:37,516 --> 0:17:39,476
“文本编辑” 是 macOS 上的一个 App

603
00:17:40,286 --> 0:17:42,136
用于处理显示和编辑

604
00:17:42,196 --> 0:17:43,406
富文本内容

605
00:17:44,946 --> 0:17:46,156
但大多数人不知道

606
00:17:46,346 --> 0:17:48,396
“文本编辑” 实际上是

607
00:17:48,396 --> 0:17:50,526
NSTextView 套上了一个壳子

608
00:17:51,826 --> 0:17:52,906
我想花一点时间

609
00:17:52,906 --> 0:17:54,646
感叹一下 TextKit 给我们带来了

610
00:17:54,646 --> 0:17:56,436
多少额外的好处

611
00:17:57,006 --> 0:17:59,156
所以这是检查器栏

612
00:17:59,526 --> 0:18:00,956
我们通过勾选

613
00:17:59,526 --> 0:18:00,956
我们通过勾选

614
00:18:00,986 --> 0:18:02,456
界面构建器中的复选框

615
00:18:02,456 --> 0:18:02,796
就可以轻松获得

616
00:18:03,396 --> 0:18:04,716
正下方是一个标尺视图

617
00:18:04,716 --> 0:18:06,456
我们也可以轻松获得它

618
00:18:06,696 --> 0:18:09,006
只要简单地启用它即可

619
00:18:09,006 --> 0:18:10,116
而下面的所有内容

620
00:18:10,206 --> 0:18:12,996
其实只是一个文本视图

621
00:18:13,206 --> 0:18:15,296
更准确地说 是一个文本视图

622
00:18:15,296 --> 0:18:17,346
加上文本容器 布局管理器

623
00:18:17,346 --> 0:18:18,066
还有文本存储

624
00:18:18,866 --> 0:18:19,756
这是 NSTextView 和

625
00:18:19,756 --> 0:18:21,216
UITextView 的

626
00:18:21,216 --> 0:18:24,966
标准配置

627
00:18:24,966 --> 0:18:27,056
但相似之处也就这些

628
00:18:27,646 --> 0:18:30,556
例如 表格

629
00:18:30,556 --> 0:18:31,896
只在 NSTextView 中受支持

630
00:18:32,696 --> 0:18:34,386
再次感叹一下 我们免费

631
00:18:34,636 --> 0:18:36,336
获得的强大功能

632
00:18:36,336 --> 0:18:37,576
TextKit 提供了一个表格编辑器

633
00:18:37,576 --> 0:18:38,746
为我们完成所有

634
00:18:39,556 --> 0:18:39,646
繁冗的工作

635
00:18:42,476 --> 0:18:44,026
当我们使用“文本编辑”时

636
00:18:44,026 --> 0:18:45,596
我们经常编辑大量的文本

637
00:18:46,686 --> 0:18:48,026
有时候我们会粘贴很多

638
00:18:48,026 --> 0:18:49,446
示例文本 来看看我们是否

639
00:18:49,446 --> 0:18:50,666
也免费获得了拼写检查器

640
00:18:51,396 --> 0:18:52,776
但我们真的想看到的是

641
00:18:52,936 --> 0:18:54,126
当我们使用格式菜单

642
00:18:54,126 --> 0:18:55,976
选择“按页面换行”时

643
00:18:56,466 --> 0:18:58,706
最终看起来会

644
00:18:58,706 --> 0:18:59,626
有点像一个页面

645
00:18:59,926 --> 0:19:00,716
我们可以看到文本容器

646
00:18:59,926 --> 0:19:00,716
我们可以看到文本容器

647
00:19:00,756 --> 0:19:02,956
已被调整大小

648
00:19:02,956 --> 0:19:06,056
以匹配一张纸的尺寸

649
00:19:06,176 --> 0:19:07,696
现在 如果我们向下滚动

650
00:19:07,696 --> 0:19:08,866
我们可以看到文本会

651
00:19:08,866 --> 0:19:09,946
从第一页跳到第二页

652
00:19:10,886 --> 0:19:12,116
标准配置

653
00:19:12,116 --> 0:19:13,266
并不真的支持

654
00:19:13,266 --> 0:19:13,636
这样的布局

655
00:19:15,066 --> 0:19:16,626
显然 这个布局使用了

656
00:19:16,626 --> 0:19:18,326
两个文本视图和文本容器

657
00:19:19,076 --> 0:19:20,006
但它们仍然

658
00:19:20,106 --> 0:19:21,276
由相同的布局管理器和文本存储管理

659
00:19:21,276 --> 0:19:22,626
这使得文本

660
00:19:22,626 --> 0:19:24,176
可以从一个页面跳到

661
00:19:25,016 --> 0:19:26,566
另一个页面

662
00:19:26,776 --> 0:19:27,926
现在 如果你想了解更多

663
00:19:27,926 --> 0:19:29,276
关于文本编辑是如何工作的信息

664
00:19:29,276 --> 0:19:31,136
你其实可以在指南和示例代码库中

665
00:19:31,136 --> 0:19:32,546
找到它的源代码

666
00:19:32,546 --> 0:19:36,046
所以我们选择了正确的控件

667
00:19:36,046 --> 0:19:37,666
我们选择了正确的配置

668
00:19:37,666 --> 0:19:39,716
但有时我们

669
00:19:39,716 --> 0:19:41,016
实际上需要使用锤子控件

670
00:19:41,096 --> 0:19:42,126
以达到我们想要的效果

671
00:19:43,346 --> 0:19:44,386
但是 我们如何决定

672
00:19:44,386 --> 0:19:45,076
使用哪个锤子呢

673
00:19:45,806 --> 0:19:49,006
我们将尝试为任务

674
00:19:49,006 --> 0:19:50,166
挑选合适的锤子

675
00:19:50,306 --> 0:19:51,526
在我们接下来一起

676
00:19:51,526 --> 0:19:53,146
构建一个日记 App 的过程中

677
00:19:54,516 --> 0:19:55,876
我们从把今天的日期

678
00:19:55,946 --> 0:19:57,056
放到窗口上开始

679
00:19:58,316 --> 0:19:59,546
我们在 AppKit 中没有 UILabels

680
00:19:59,546 --> 0:20:01,226
但是我们可以使文本栏

681
00:19:59,546 --> 0:20:01,226
但是我们可以使文本栏

682
00:20:01,226 --> 0:20:02,476
像标签一样工作

683
00:20:03,716 --> 0:20:05,766
我们所需要做的就是禁用编辑

684
00:20:06,366 --> 0:20:09,116
现在 对于窗口的日记内容部分

685
00:20:09,116 --> 0:20:10,976
我们将使用 textView

686
00:20:12,206 --> 0:20:13,676
所以在检查器中 我们可以确保

687
00:20:13,676 --> 0:20:16,916
文本视图是可编辑和可选的

688
00:20:16,916 --> 0:20:18,596
并支持富文本和撤销

689
00:20:18,596 --> 0:20:21,916
我们还要

690
00:20:21,916 --> 0:20:23,006
在窗口底部添加几个

691
00:20:23,006 --> 0:20:24,056
文本栏 来显示

692
00:20:24,056 --> 0:20:25,566
写了多少个单词

693
00:20:26,166 --> 0:20:29,746
现在 当我们运行我们的 App 时 我们希望

694
00:20:29,746 --> 0:20:30,766
底部的字数统计随之变化

695
00:20:30,766 --> 0:20:32,836
所以让我们来为这个任务

696
00:20:32,886 --> 0:20:33,676
找到合适的锤子

697
00:20:33,676 --> 0:20:39,266
我们可以选择委托通知或子类

698
00:20:39,266 --> 0:20:41,796
但在这种情况下 我们将

699
00:20:41,796 --> 0:20:42,636
使用小锤子

700
00:20:42,916 --> 0:20:43,756
我们将监听

701
00:20:43,756 --> 0:20:45,226
来自文本存储的通知

702
00:20:46,726 --> 0:20:47,886
我们可以从文本存储中

703
00:20:47,886 --> 0:20:49,496
获取单词的数量

704
00:20:50,686 --> 0:20:51,246
当我们收到通知时

705
00:20:51,246 --> 0:20:52,886
我们可以更新

706
00:20:52,886 --> 0:20:54,556
文本栏的

707
00:20:54,556 --> 0:20:55,026
字符串值属性

708
00:20:55,586 --> 0:20:58,726
当我们开始输入时 我们可以

709
00:20:58,756 --> 0:20:59,726
看到字数改变

710
00:21:00,326 --> 0:21:03,446
如果我们想强调部分文本

711
00:21:03,446 --> 0:21:05,806
我们可以使用键盘快捷键

712
00:21:05,806 --> 0:21:07,586
或菜单来应用

713
00:21:07,586 --> 0:21:08,616
格式 比如粗体

714
00:21:09,166 --> 0:21:11,846
但是如果我们能够支持

715
00:21:11,846 --> 0:21:13,946
现代文本排版工具会更好

716
00:21:13,946 --> 0:21:15,746
比如 Markdown 

717
00:21:15,746 --> 0:21:17,346
它使用命令字符

718
00:21:17,406 --> 0:21:18,406
来指定格式

719
00:21:19,206 --> 0:21:20,566
如果我们在一段内容前后

720
00:21:20,786 --> 0:21:22,536
分别添加两个星号

721
00:21:22,536 --> 0:21:23,366
我们希望结果是粗体的

722
00:21:24,216 --> 0:21:26,426
但我们应该使用

723
00:21:27,816 --> 0:21:28,216
哪种锤子呢

724
00:21:28,336 --> 0:21:29,276
我们想知道什么时候

725
00:21:29,276 --> 0:21:31,396
发生变化 并且我们想知道

726
00:21:31,396 --> 0:21:32,586
变化发生在哪里

727
00:21:32,616 --> 0:21:33,846
但通知并没有真正

728
00:21:33,846 --> 0:21:35,286
给我们提供很多关于

729
00:21:35,286 --> 0:21:35,896
这种改变的信息

730
00:21:37,416 --> 0:21:38,456
所以我们将使用更大的锤子

731
00:21:38,456 --> 0:21:40,076
并实现 textStorage() 委托

732
00:21:40,076 --> 0:21:44,286
具体是 _ didProcessEditing: 方法

733
00:21:45,226 --> 0:21:46,786
我们可以从现有的字体中

734
00:21:47,016 --> 0:21:47,946
创建一个新的粗体字体

735
00:21:48,646 --> 0:21:50,026
而且 我们可以将该字体

736
00:21:50,026 --> 0:21:51,426
直接添加到我们的 textStorage

737
00:21:51,426 --> 0:21:52,646
用于我们想要加粗的范围

738
00:21:53,176 --> 0:21:55,586
现在 当我们插入最后一个星号时

739
00:21:55,586 --> 0:21:57,696
我们可以将其加粗

740
00:21:58,346 --> 0:22:01,126
我们现在对这个

741
00:21:58,346 --> 0:22:01,126
我们现在对这个

742
00:22:01,126 --> 0:22:02,426
Markdown 功能非常满意

743
00:22:02,586 --> 0:22:04,856
那么如果我们尝试插入

744
00:22:04,856 --> 0:22:05,476
代码片段呢

745
00:22:06,756 --> 0:22:07,996
在 Markdown 中是这样的

746
00:22:09,256 --> 0:22:10,516
如果我们添加最后一个反引号

747
00:22:10,636 --> 0:22:12,766
我们希望它看起来像一个代码块

748
00:22:14,136 --> 0:22:15,156
它应该有一个背景和

749
00:22:15,156 --> 0:22:16,346
一个表示 Swift Code 的标头

750
00:22:17,716 --> 0:22:18,906
这实际上是一项复杂的任务

751
00:22:18,906 --> 0:22:22,006
所以我们需要两把大锤

752
00:22:23,386 --> 0:22:25,526
第一个是 NSTextStorage 子类

753
00:22:26,556 --> 0:22:27,946
当我们子类化 NSTextStorage 时

754
00:22:27,946 --> 0:22:30,706
我们需要实现四个必要的方法

755
00:22:31,236 --> 0:22:32,806
我们通过对一个可变字符串的

756
00:22:32,856 --> 0:22:34,946
局部实例进行操作来做到这一点

757
00:22:34,946 --> 0:22:37,996
我们需要注意

758
00:22:37,996 --> 0:22:39,056
replaceCharacters() 方法

759
00:22:39,836 --> 0:22:42,066
我们可以将 NSTextBlock 添加

760
00:22:42,066 --> 0:22:42,876
到我们的段落样式中

761
00:22:43,406 --> 0:22:46,046
然后我们将

762
00:22:46,046 --> 0:22:47,546
该段落样式添加到

763
00:22:47,546 --> 0:22:49,116
我们文本存储中

764
00:22:49,116 --> 0:22:49,496
代码块的范围内

765
00:22:50,256 --> 0:22:51,746
现在 NSTextBlock 本身

766
00:22:51,746 --> 0:22:53,906
不会自己做任何自定义绘制

767
00:22:54,596 --> 0:22:56,766
所以我们也需要对它

768
00:22:57,916 --> 0:22:57,996
进行子类化

769
00:22:58,226 --> 0:23:00,846
我们的 NSTextBlock 子类需要

770
00:22:58,226 --> 0:23:00,846
我们的 NSTextBlock 子类需要

771
00:23:00,846 --> 0:23:02,756
在顶部有一些

772
00:23:02,756 --> 0:23:04,626
额外的留白

773
00:23:04,626 --> 0:23:07,346
还需要一个浅灰色背景

774
00:23:07,546 --> 0:23:08,906
我们将重写 drawBackground()

775
00:23:09,566 --> 0:23:11,346
并使用字符串绘制来绘制

776
00:23:11,346 --> 0:23:12,666
标头 Swift Code

777
00:23:13,606 --> 0:23:14,836
实际上这些我们想

778
00:23:14,836 --> 0:23:16,386
让文本块看起来

779
00:23:16,386 --> 0:23:18,886
像一个代码片段所需要做的

780
00:23:18,986 --> 0:23:20,216
现在回到我们的 customTextStorage

781
00:23:20,216 --> 0:23:21,866
我们可以创建

782
00:23:21,866 --> 0:23:23,076
新代码块的实例

783
00:23:24,256 --> 0:23:27,286
而不是使用纯文本块

784
00:23:27,856 --> 0:23:31,476
最后 我们还要

785
00:23:31,476 --> 0:23:32,896
告诉我们的 textView 使用

786
00:23:32,896 --> 0:23:34,606
我们的 customTextStorage

787
00:23:34,606 --> 0:23:36,076
所以我们要在布局管理器中

788
00:23:36,116 --> 0:23:37,096
把原来的文本存储替换掉

789
00:23:37,706 --> 0:23:41,076
现在这变成了一个真正的

790
00:23:41,076 --> 0:23:42,266
所见即所得的 Markdown 编辑器了

791
00:23:43,126 --> 0:23:44,366
现在在大多数 Markdown 编辑器上

792
00:23:44,366 --> 0:23:45,556
都有的一个功能是

793
00:23:45,666 --> 0:23:47,726
并排视图

794
00:23:47,726 --> 0:23:49,046
左侧是编辑区域

795
00:23:49,046 --> 0:23:50,016
右侧是渲染版本

796
00:23:51,516 --> 0:23:52,996
我们可以通过使用

797
00:23:52,996 --> 0:23:54,426
两个文本视图来实现

798
00:23:55,936 --> 0:23:57,946
我们停用右侧视图的编辑功能

799
00:23:58,866 --> 0:24:00,376
现在我们有两个文本视图

800
00:23:58,866 --> 0:24:00,376
现在我们有两个文本视图

801
00:24:00,376 --> 0:24:01,596
虽然我们希望它们显示

802
00:24:01,696 --> 0:24:03,546
相同的内容 但我们还希望

803
00:24:03,546 --> 0:24:04,286
右边视图能够看起来不太一样

804
00:24:05,916 --> 0:24:07,176
所以我们需要一个像这样的配置

805
00:24:07,176 --> 0:24:08,806
两个视图的文本存储器相同

806
00:24:08,806 --> 0:24:11,666
而所有其他都不同

807
00:24:14,096 --> 0:24:16,506
为此 我们

808
00:24:16,506 --> 0:24:17,996
将用左侧的文本存储

809
00:24:18,066 --> 0:24:19,106
把右侧的替换掉

810
00:24:20,616 --> 0:24:21,506
现在让我们看看

811
00:24:21,536 --> 0:24:21,766
这是什么样子

812
00:24:22,286 --> 0:24:25,326
现在这真的很酷

813
00:24:25,526 --> 0:24:26,626
如果我们在左侧添加任何字符

814
00:24:26,626 --> 0:24:28,826
它们将立即显示在右侧

815
00:24:29,726 --> 0:24:31,056
现在通常右手边

816
00:24:31,906 --> 0:24:33,166
并没有真正显示 Markdown 字符

817
00:24:33,166 --> 0:24:35,406
但由于这是一个

818
00:24:35,406 --> 0:24:38,036
共享文本存储 这意味着我们

819
00:24:38,036 --> 0:24:39,196
必须隐藏字符

820
00:24:39,406 --> 0:24:40,486
在布局过程中

821
00:24:40,486 --> 0:24:44,236
因为我们需要这样做

822
00:24:44,236 --> 0:24:45,846
所以我们实际上只有一个选择

823
00:24:45,916 --> 0:24:48,486
那就是实现

824
00:24:49,016 --> 0:24:50,746
NSLayoutManager 委托上的

825
00:24:51,176 --> 0:24:52,746
shouldGenerateGlyphs() 方法

826
00:24:53,796 --> 0:24:55,196
这将允许我们介入

827
00:24:55,316 --> 0:24:57,446
字形生成过程

828
00:24:58,036 --> 0:24:59,776
因此 我们可以

829
00:24:59,776 --> 0:25:01,986
获取即将布局的字形

830
00:24:59,776 --> 0:25:01,986
获取即将布局的字形

831
00:25:01,986 --> 0:25:03,446
并且如果它们表示 Markdown

832
00:25:03,446 --> 0:25:05,446
命令字符 我们可以将

833
00:25:05,446 --> 0:25:07,356
.null 属性应用于该字形

834
00:25:08,096 --> 0:25:09,216
现在 这将让字形

835
00:25:09,216 --> 0:25:10,516
在布局过程中被

836
00:25:10,516 --> 0:25:12,526
彻底消除 而不会更改

837
00:25:12,526 --> 0:25:13,756
底层的文本存储

838
00:25:14,306 --> 0:25:19,096
然后 我们将使用新的字形

839
00:25:19,096 --> 0:25:20,686
并告诉布局管理器

840
00:25:20,686 --> 0:25:22,046
我们想要用这些新的属性

841
00:25:22,106 --> 0:25:23,116
来呈现这些字形

842
00:25:27,096 --> 0:25:29,106
这真的很酷

843
00:25:29,106 --> 0:25:30,416
所以左侧显示了

844
00:25:30,416 --> 0:25:31,436
可编辑版本

845
00:25:31,436 --> 0:25:32,626
包含所有 Markdown 字符

846
00:25:32,956 --> 0:25:34,576
而右侧没有显示

847
00:25:34,576 --> 0:25:36,306
任何 Markdown 字符

848
00:25:36,306 --> 0:25:37,686
全部使用相同的文本存储

849
00:25:38,286 --> 0:25:40,836
现在构建一个并排的

850
00:25:40,836 --> 0:25:42,046
Markdown 编辑器 并不是

851
00:25:42,096 --> 0:25:44,256
我们每天都在做的事情

852
00:25:44,256 --> 0:25:45,536
但是很开心看到

853
00:25:45,536 --> 0:25:47,856
TextKit 的可自定义度是多么高

854
00:25:47,856 --> 0:25:48,816
以及它是如何与现实的例子结合的

855
00:25:49,536 --> 0:25:51,626
如果你想了解更多

856
00:25:51,626 --> 0:25:53,026
关于如何使用和自定义

857
00:25:53,066 --> 0:25:54,816
TextKit 的信息 请查看我们出色的

858
00:25:54,816 --> 0:25:55,576
编程指南

859
00:25:56,286 --> 0:25:58,186
然后 我要把现场交给 Donna

860
00:25:59,516 --> 0:26:06,066
[ 掌声 ]

861
00:25:59,516 --> 0:26:06,066
[ 掌声 ]

862
00:26:06,566 --> 0:26:07,236
&gt;&gt; 谢谢 Emily

863
00:26:08,056 --> 0:26:09,056
这些例子真的

864
00:26:09,056 --> 0:26:09,536
非常酷

865
00:26:09,666 --> 0:26:10,786
我真的希望你能够

866
00:26:10,786 --> 0:26:11,706
采用她展示的一些技术

867
00:26:11,706 --> 0:26:13,876
并在你自己的 App 中使用它们

868
00:26:14,596 --> 0:26:16,086
但现在让我们稍微转换一下

869
00:26:16,416 --> 0:26:17,226
并讨论一些

870
00:26:17,266 --> 0:26:19,766
使用文本的最佳做法

871
00:26:21,756 --> 0:26:23,196
关于正确性

872
00:26:23,796 --> 0:26:24,996
如果你的文本没有

873
00:26:24,996 --> 0:26:26,716
按照你期望的方式呈现

874
00:26:26,716 --> 0:26:28,596
它可能与属性字符串上的

875
00:26:28,596 --> 0:26:29,806
不完整或不正确的

876
00:26:29,806 --> 0:26:30,556
属性有关

877
00:26:31,946 --> 0:26:33,636
所以我们来看看一个例子

878
00:26:33,636 --> 0:26:35,066
在实践中看到这一点

879
00:26:36,116 --> 0:26:37,466
假设我们有一个 UITextView

880
00:26:37,666 --> 0:26:39,536
它带有一些属性文本

881
00:26:39,536 --> 0:26:40,846
写着 “Don't hate.”

882
00:26:40,846 --> 0:26:42,636
这段文本的格式是

883
00:26:42,706 --> 0:26:44,266
Comic Sans 字体 24 号大小

884
00:26:44,766 --> 0:26:46,746
我们希望以编程的方式

885
00:26:46,746 --> 0:26:48,946
把它设置成粗体

886
00:26:48,946 --> 0:26:50,736
因为如果有

887
00:26:50,736 --> 0:26:52,396
任何比 Comic Sans 令人讨厌的字体

888
00:26:52,396 --> 0:26:54,396
那一定是 Comic Sans Bold

889
00:26:54,776 --> 0:26:58,316
所以乍一看

890
00:26:58,316 --> 0:26:59,696
编写这样的代码似乎是合理的

891
00:27:00,716 --> 0:27:02,746
现在 我们有我们的原始字体

892
00:27:03,386 --> 0:27:05,326
我们将使用一个 fontDescriptor

893
00:27:05,326 --> 0:27:06,796
来创建原始字体

894
00:27:06,796 --> 0:27:08,376
的粗体版本

895
00:27:09,936 --> 0:27:11,796
然后 我们要

896
00:27:11,796 --> 0:27:13,196
使用原始文本

897
00:27:13,526 --> 0:27:14,526
初始化可变属性字符串

898
00:27:14,526 --> 0:27:16,866
我们要将我们的

899
00:27:16,866 --> 0:27:18,876
新字体或新的粗体字体应用于

900
00:27:18,876 --> 0:27:20,586
单词 “Don't”

901
00:27:20,586 --> 0:27:21,496
这是前五个字符

902
00:27:21,496 --> 0:27:22,986
然后我们将设置

903
00:27:22,986 --> 0:27:24,386
我们的 UITextView 的属性文本属性

904
00:27:24,386 --> 0:27:25,996
来使用这个新的

905
00:27:25,996 --> 0:27:28,566
属性字符串 但是我们这样做时

906
00:27:28,606 --> 0:27:30,096
我们会看到

907
00:27:30,096 --> 0:27:32,186
应用于该单词的新的粗体字体

908
00:27:32,186 --> 0:27:34,416
确实像我们预期的那样

909
00:27:34,416 --> 0:27:35,676
但字符串其余的部分

910
00:27:35,676 --> 0:27:36,986
不知道为什么丢失了原始字体

911
00:27:37,506 --> 0:27:39,696
现在 那些不喜欢

912
00:27:39,696 --> 0:27:40,966
Comic Sans 的人可能会为此感到高兴

913
00:27:40,966 --> 0:27:43,676
但结果是错误的

914
00:27:43,806 --> 0:27:45,296
所以这是一个悲伤的故事

915
00:27:46,456 --> 0:27:47,926
那么为什么会这样呢

916
00:27:48,506 --> 0:27:51,046
为了回答这个问题 让我们

917
00:27:51,046 --> 0:27:52,196
仔细看看我们是如何

918
00:27:52,196 --> 0:27:53,476
初始化我们的

919
00:27:53,546 --> 0:27:53,856
属性字符串的

920
00:27:55,226 --> 0:27:56,806
所以请注意 我们要使用

921
00:27:56,966 --> 0:27:58,526
纯文本字符串来初始化它

922
00:27:58,526 --> 0:27:59,616
并且我们使用的

923
00:27:59,616 --> 0:28:01,516
初始化程序没有属性信息

924
00:27:59,616 --> 0:28:01,516
初始化程序没有属性信息

925
00:28:01,516 --> 0:28:04,046
当你创建一个新的

926
00:28:04,046 --> 0:28:05,646
属性字符串 并且你没有

927
00:28:05,646 --> 0:28:06,526
提供任何属性信息时

928
00:28:06,526 --> 0:28:08,626
新的属性字符串

929
00:28:08,626 --> 0:28:10,226
会使用默认的属性

930
00:28:11,026 --> 0:28:11,926
默认字体是

931
00:28:11,926 --> 0:28:13,136
Helvetica 12 号

932
00:28:13,686 --> 0:28:15,876
为了回顾发生了什么

933
00:28:16,166 --> 0:28:17,366
我们开始

934
00:28:17,366 --> 0:28:19,036
从这个原始的属性字符串

935
00:28:19,036 --> 0:28:20,566
将字体 Comic Sans 24 应用于

936
00:28:20,566 --> 0:28:21,356
整个范围

937
00:28:21,866 --> 0:28:24,986
然后我们创建了这个新的

938
00:28:24,986 --> 0:28:26,416
属性字符串

939
00:28:26,416 --> 0:28:27,506
并使用默认属性

940
00:28:27,506 --> 0:28:27,966
进行了初始化

941
00:28:28,856 --> 0:28:30,156
并且我们将粗字体应用于

942
00:28:30,156 --> 0:28:31,226
新字符串上的 “Don't”

943
00:28:31,276 --> 0:28:33,016
结果就是这里这个

944
00:28:33,016 --> 0:28:34,896
不正确的结果 其中

945
00:28:34,896 --> 0:28:36,296
“Don't” 以 Comic Sans 粗体 24 号显示

946
00:28:36,296 --> 0:28:37,886
但字符串的其余部分

947
00:28:37,886 --> 0:28:39,366
处于默认字体

948
00:28:39,366 --> 0:28:40,146
Helvetica 12

949
00:28:40,726 --> 0:28:43,916
有两种不同的方法

950
00:28:43,916 --> 0:28:44,776
可以让它们正确地显示

951
00:28:44,776 --> 0:28:46,826
一种方法是

952
00:28:46,826 --> 0:28:47,916
避免将纯文本

953
00:28:47,916 --> 0:28:49,086
和属性文本混合在一起

954
00:28:50,146 --> 0:28:51,416
因此 通过使用原始字符串

955
00:28:51,416 --> 0:28:52,446
来初始化我们的新属性字符串

956
00:28:52,446 --> 0:28:53,676
我们要把

957
00:28:53,676 --> 0:28:54,816
那些原始属性保留下来

958
00:28:55,296 --> 0:28:56,326
然后我们再应用我们的新属性

959
00:28:56,326 --> 0:28:57,606
而不会看到这个

960
00:28:57,606 --> 0:28:59,176
重设的默认效果

961
00:28:59,696 --> 0:29:03,746
但是 避免混合纯文本和属性文本

962
00:28:59,696 --> 0:29:03,746
但是 避免混合纯文本和属性文本

963
00:29:03,746 --> 0:29:04,256
并不总是可行的

964
00:29:04,576 --> 0:29:06,156
因此 如果你必须将其混合

965
00:29:06,736 --> 0:29:08,096
则可以在从纯文本字符串中

966
00:29:08,096 --> 0:29:09,876
创建新的属性字符串时

967
00:29:09,876 --> 0:29:11,846
明确提供属性

968
00:29:11,846 --> 0:29:13,596
如果我们确保

969
00:29:13,656 --> 0:29:14,526
从原始文本中应用相同的属性

970
00:29:14,526 --> 0:29:15,716
我们就会得到

971
00:29:15,716 --> 0:29:16,356
正确的结果

972
00:29:16,886 --> 0:29:19,816
但是你应该知道

973
00:29:19,816 --> 0:29:20,896
重设效果会发生

974
00:29:20,896 --> 0:29:22,126
在任何具有默认值

975
00:29:22,126 --> 0:29:23,736
而不仅仅是字体的属性的情况下

976
00:29:24,816 --> 0:29:26,106
如你所见

977
00:29:26,106 --> 0:29:27,676
有很多属性都具有默认值

978
00:29:27,676 --> 0:29:30,746
所以我想特别提醒一下

979
00:29:30,746 --> 0:29:31,986
这里的 “Paragraph style（段落风格）”

980
00:29:31,986 --> 0:29:33,506
因为它是一个隐蔽的

981
00:29:33,506 --> 0:29:34,096
重置点

982
00:29:35,056 --> 0:29:36,466
为了明白为什么

983
00:29:36,466 --> 0:29:37,256
我们将重新回顾一下前面的例子

984
00:29:37,406 --> 0:29:38,496
但不是改变字体

985
00:29:38,496 --> 0:29:39,826
我们将改变段落风格

986
00:29:39,826 --> 0:29:41,576
来屏蔽 “hate” 这个词

987
00:29:41,576 --> 0:29:43,746
因为没有人喜欢仇恨

988
00:29:44,376 --> 0:29:45,786
所以我们希望我们的文本看起来像这样

989
00:29:45,856 --> 0:29:47,886
但是当我们运行这段代码时

990
00:29:48,716 --> 0:29:49,836
我们将得到

991
00:29:50,686 --> 0:29:51,696
一个这样的结果

992
00:29:51,696 --> 0:29:53,526
所有文本的格式都是 Helvetica 12 

993
00:29:53,526 --> 0:29:55,136
使用默认的段落风格

994
00:29:55,136 --> 0:29:56,866
默认的换行模式 和默认的自动断词

995
00:29:57,566 --> 0:29:59,016
又一次 对于那些

996
00:29:59,016 --> 0:29:59,956
讨厌 Comic Sans 的人来说 真是太棒了

997
00:29:59,956 --> 0:30:01,056
因为它已经被完全地

998
00:29:59,956 --> 0:30:01,056
因为它已经被完全地

999
00:30:01,056 --> 0:30:02,136
从字符串中移除了

1000
00:30:02,226 --> 0:30:03,976
但它=这是错误的

1001
00:30:04,086 --> 0:30:05,446
但是这次错误的原因

1002
00:30:05,446 --> 0:30:06,276
与上次不同

1003
00:30:06,826 --> 0:30:08,586
为了更好地理解这不同

1004
00:30:08,586 --> 0:30:09,796
让我们回顾一下

1005
00:30:09,796 --> 0:30:11,686
属性修复发生在

1006
00:30:11,686 --> 0:30:13,296
布局之前 这时候

1007
00:30:13,296 --> 0:30:15,236
系统会修复不一致的属性

1008
00:30:16,216 --> 0:30:17,196
在我们的属性字符串中

1009
00:30:17,286 --> 0:30:18,546
我们有一个

1010
00:30:18,546 --> 0:30:19,906
包含多个段落样式的单个段落

1011
00:30:19,906 --> 0:30:22,646
这显然非常不一致

1012
00:30:23,496 --> 0:30:24,996
因此 当系统修复

1013
00:30:24,996 --> 0:30:26,426
此字符串的属性时

1014
00:30:26,426 --> 0:30:27,086
它将采用

1015
00:30:27,086 --> 0:30:28,976
它找到的第一段样式

1016
00:30:28,976 --> 0:30:30,206
并将其应用于整个段落

1017
00:30:31,236 --> 0:30:32,296
这就会导致

1018
00:30:32,296 --> 0:30:34,096
我们的属性字符串

1019
00:30:34,096 --> 0:30:35,386
以默认段落样式显示

1020
00:30:35,946 --> 0:30:39,906
关键是要明确你的属性

1021
00:30:39,906 --> 0:30:42,216
特别是在混合纯文本和

1022
00:30:42,216 --> 0:30:42,926
属性文本时

1023
00:30:43,836 --> 0:30:44,916
所以通过这样做

1024
00:30:44,916 --> 0:30:46,346
你就能避免它出现

1025
00:30:46,346 --> 0:30:47,216
默认属性的重置效果

1026
00:30:47,826 --> 0:30:49,406
对于 AppKit 开发人员来说

1027
00:30:49,406 --> 0:30:51,126
如果你正在为 App 更新

1028
00:30:51,126 --> 0:30:52,176
深色模式

1029
00:30:52,176 --> 0:30:52,696
这一点尤其重要

1030
00:30:53,286 --> 0:30:54,526
因此通过使用

1031
00:30:54,526 --> 0:30:56,056
带有动态颜色的显式属性

1032
00:30:56,056 --> 0:30:57,886
如 NSColor.textColor

1033
00:30:57,946 --> 0:30:59,216
可以确保你的文本

1034
00:30:59,216 --> 0:31:00,146
会根据环境用正确的

1035
00:30:59,216 --> 0:31:00,146
会根据环境用正确的

1036
00:31:00,316 --> 0:31:03,116
颜色绘制

1037
00:31:03,216 --> 0:31:03,786
继续

1038
00:31:04,316 --> 0:31:05,416
下一个话题是性能

1039
00:31:06,306 --> 0:31:07,116
如果你使用大量文本

1040
00:31:07,116 --> 0:31:08,656
一个提高 App 性能的

1041
00:31:08,656 --> 0:31:10,046
好方法是

1042
00:31:10,046 --> 0:31:11,636
使用非连续布局

1043
00:31:11,636 --> 0:31:14,076
为了明白这意味着什么

1044
00:31:14,076 --> 0:31:15,276
让我们重新回顾

1045
00:31:15,336 --> 0:31:16,766
布局过程

1046
00:31:17,826 --> 0:31:18,856
我们说过布局过程

1047
00:31:18,896 --> 0:31:20,436
包括字形生成

1048
00:31:20,526 --> 0:31:21,386
和字形布局

1049
00:31:22,806 --> 0:31:24,046
所以对于连续布局

1050
00:31:24,266 --> 0:31:25,416
布局管理器

1051
00:31:25,416 --> 0:31:26,716
在文本存储开头就开始

1052
00:31:26,716 --> 0:31:27,946
执行字形生成和

1053
00:31:27,986 --> 0:31:29,496
字形布局了

1054
00:31:30,286 --> 0:31:32,426
它以从头到尾的顺序进行

1055
00:31:33,786 --> 0:31:34,986
所以如果有人使用你的 App

1056
00:31:35,026 --> 0:31:37,556
滚动到文本视图中间的某个点

1057
00:31:37,556 --> 0:31:38,966
那么布局管理器

1058
00:31:38,966 --> 0:31:41,056
必须为红色矩形

1059
00:31:41,056 --> 0:31:42,316
所指示区域之前的所有字形

1060
00:31:42,316 --> 0:31:44,596
生成并布局字形

1061
00:31:45,166 --> 0:31:46,726
并且请注意

1062
00:31:46,726 --> 0:31:47,846
这还包括你从

1063
00:31:47,846 --> 0:31:49,016
屏幕顶部滚动回到

1064
00:31:49,016 --> 0:31:50,116
文本存储起点之间

1065
00:31:50,176 --> 0:31:51,596
所有你看不见的文本

1066
00:31:52,696 --> 0:31:54,186
所以如果你有很多文本

1067
00:31:54,236 --> 0:31:56,406
那么这个可怜的用户

1068
00:31:56,406 --> 0:31:57,756
可能需要等待你的 App 一段时间

1069
00:31:57,756 --> 0:31:59,946
让它完成布局

1070
00:31:59,946 --> 0:32:01,626
但幸运的是

1071
00:31:59,946 --> 0:32:01,626
但幸运的是

1072
00:32:01,626 --> 0:32:03,616
我们可以通过使用非连续布局

1073
00:32:03,616 --> 0:32:03,916
来避免这种情况

1074
00:32:04,966 --> 0:32:06,896
正如其名称所暗示的那样

1075
00:32:06,896 --> 0:32:08,286
使用非连续布局

1076
00:32:08,286 --> 0:32:10,216
布局管理器无需

1077
00:32:10,216 --> 0:32:11,656
从文本存储开始

1078
00:32:11,716 --> 0:32:12,896
顺序地进行字形

1079
00:32:12,896 --> 0:32:13,296
生成和布局

1080
00:32:14,166 --> 0:32:15,626
所以现在当这个使用你 App 的人

1081
00:32:15,626 --> 0:32:16,756
滚动到文本视图的中间时

1082
00:32:17,026 --> 0:32:18,956
布局管理器可以

1083
00:32:18,956 --> 0:32:20,016
立即为该中间部分

1084
00:32:20,016 --> 0:32:22,696
执行字形生成和布局

1085
00:32:23,346 --> 0:32:25,696
所以如果你的文本存储中

1086
00:32:25,696 --> 0:32:26,886
有很多文本

1087
00:32:26,886 --> 0:32:28,376
使用非连续布局可以

1088
00:32:28,376 --> 0:32:29,276
为你带来巨大的性能提升

1089
00:32:29,776 --> 0:32:32,476
那么你如何启用

1090
00:32:33,266 --> 0:32:33,366
这个功能呢

1091
00:32:33,836 --> 0:32:35,946
非连续布局是

1092
00:32:35,946 --> 0:32:37,366
NSLayoutManager 的一个属性

1093
00:32:37,366 --> 0:32:39,346
对于 NSTextView

1094
00:32:39,346 --> 0:32:41,346
你可以使用布局管理器

1095
00:32:41,346 --> 0:32:42,486
来访问文本

1096
00:32:42,486 --> 0:32:43,436
然后在其中设置该属性

1097
00:32:44,006 --> 0:32:46,896
对于 UITextView

1098
00:32:46,896 --> 0:32:47,786
你通常不需要做任何事情

1099
00:32:47,786 --> 0:32:48,756
因为这是默认开启的

1100
00:32:48,756 --> 0:32:51,946
但只需要记住一件重要的事情

1101
00:32:53,006 --> 0:32:54,926
由于 UITextView 是 UIScrollView 的子类

1102
00:32:55,416 --> 0:32:57,806
因此非连续布局

1103
00:32:57,846 --> 0:32:59,586
需要启用滚动

1104
00:32:59,586 --> 0:33:00,106
才能生效

1105
00:32:59,586 --> 0:33:00,106
才能生效

1106
00:33:01,266 --> 0:33:02,776
这是因为当你禁用滚动时

1107
00:33:02,776 --> 0:33:04,366
询求你的文本视图

1108
00:33:04,366 --> 0:33:06,086
所包含的内容大小

1109
00:33:06,086 --> 0:33:07,116
需要布局

1110
00:33:07,116 --> 0:33:08,376
所有的文本

1111
00:33:08,906 --> 0:33:09,776
所以你根本

1112
00:33:09,776 --> 0:33:10,716
不会获得

1113
00:33:10,716 --> 0:33:11,726
非连续布局的

1114
00:33:11,726 --> 0:33:12,156
性能优势

1115
00:33:12,816 --> 0:33:15,636
这把我们引导了一个

1116
00:33:15,636 --> 0:33:16,376
很重要的问题上

1117
00:33:17,186 --> 0:33:18,236
当你使用非连续布局时

1118
00:33:18,236 --> 0:33:19,696
你应该避免一次

1119
00:33:19,696 --> 0:33:20,916
请求全部或者大多数文本的布局

1120
00:33:20,916 --> 0:33:23,136
因为这样做

1121
00:33:23,136 --> 0:33:24,116
从根本上就

1122
00:33:24,116 --> 0:33:25,026
违背了我们的初衷

1123
00:33:25,086 --> 0:33:27,516
所以如果你只有一个文本容器

1124
00:33:27,516 --> 0:33:28,926
不要要求

1125
00:33:28,926 --> 0:33:29,956
整个容器的布局

1126
00:33:30,796 --> 0:33:31,866
并且不要要求

1127
00:33:31,866 --> 0:33:33,196
包含文本结尾的大范围字符

1128
00:33:33,196 --> 0:33:37,106
或字形的布局

1129
00:33:37,366 --> 0:33:38,526
我们并没有深入

1130
00:33:38,526 --> 0:33:39,406
研究文本性能的主题

1131
00:33:39,406 --> 0:33:42,076
因为 我在去年的 WWDC 2017 上针对这一点

1132
00:33:42,386 --> 0:33:44,826
进行了一次非常棒的演讲

1133
00:33:44,826 --> 0:33:45,766
那就是框架效率的不完整性

1134
00:33:46,186 --> 0:33:47,226
你可以在讨论会结束时

1135
00:33:47,226 --> 0:33:48,576
通过更多信息链接

1136
00:33:48,576 --> 0:33:49,306
访问该视频

1137
00:33:49,306 --> 0:33:50,026
好的

1138
00:33:51,396 --> 0:33:53,876
现在是时候谈论

1139
00:33:53,876 --> 0:33:55,006
每个人最喜欢的话题

1140
00:33:55,206 --> 0:33:55,666
安全

1141
00:33:56,406 --> 0:33:59,486
你可能已经注意到

1142
00:33:59,486 --> 0:34:00,526
最近有一些事件发生在互联网上

1143
00:33:59,486 --> 0:34:00,526
最近有一些事件发生在互联网上

1144
00:34:00,526 --> 0:34:02,456
某些人利用我们软件中的错误

1145
00:34:02,456 --> 0:34:07,346
来给使用我们产品的人们制造麻烦

1146
00:34:08,896 --> 0:34:10,016
作为回应

1147
00:34:10,016 --> 0:34:11,416
我们正在继续设计

1148
00:34:11,606 --> 0:34:12,956
抵御这类攻击的技术

1149
00:34:12,956 --> 0:34:16,036
但今天我想谈谈

1150
00:34:16,036 --> 0:34:17,326
我们如何共同努力

1151
00:34:17,326 --> 0:34:18,755
为这些攻击

1152
00:34:18,755 --> 0:34:20,025
提供更强大的防御

1153
00:34:20,815 --> 0:34:21,626
所以你可能已经听说过

1154
00:34:21,626 --> 0:34:24,126
纵深防御的概念

1155
00:34:24,706 --> 0:34:26,056
如果你不熟悉

1156
00:34:26,056 --> 0:34:27,856
这些术语的话 纵深防御

1157
00:34:27,856 --> 0:34:30,706
就是创建多层保护

1158
00:34:30,706 --> 0:34:31,226
来抵御威胁

1159
00:34:31,226 --> 0:34:33,926
这个概念已经存在了几个世纪了

1160
00:34:34,096 --> 0:34:35,556
你可以在中世纪城堡的设计中

1161
00:34:35,556 --> 0:34:36,275
看到它

1162
00:34:36,826 --> 0:34:38,056
城堡周围的地上没有树木

1163
00:34:38,085 --> 0:34:39,906
所以你可以看到袭击者来了

1164
00:34:39,906 --> 0:34:41,656
还有一个护城河

1165
00:34:41,656 --> 0:34:42,525
可以让城堡更加难以接近

1166
00:34:42,525 --> 0:34:43,545
并且可以防止敌人在

1167
00:34:43,545 --> 0:34:44,306
下面挖隧道

1168
00:34:44,306 --> 0:34:46,876
而墙壁是另一道防线

1169
00:34:47,076 --> 0:34:48,166
它们很高

1170
00:34:48,166 --> 0:34:49,096
所以很难攀爬

1171
00:34:49,956 --> 0:34:50,926
并且在墙壁和顶部

1172
00:34:50,926 --> 0:34:52,456
有很多垛口

1173
00:34:52,456 --> 0:34:54,255
让防御者能在

1174
00:34:54,255 --> 0:34:55,406
有防御的地方

1175
00:34:55,406 --> 0:34:55,886
向攻击者开火

1176
00:34:57,096 --> 0:34:58,796
这些保护中单独

1177
00:34:58,796 --> 0:35:00,176
任何一种都可能不足以

1178
00:34:58,796 --> 0:35:00,176
任何一种都可能不足以

1179
00:35:00,296 --> 0:35:01,836
抵御攻击

1180
00:35:01,836 --> 0:35:03,556
但它们组合在一起

1181
00:35:03,676 --> 0:35:04,356
就提供了强有力的防御

1182
00:35:05,066 --> 0:35:07,796
就像城堡一样

1183
00:35:07,796 --> 0:35:09,246
我们在这里为攻击

1184
00:35:09,246 --> 0:35:11,126
提供了多层防御

1185
00:35:11,126 --> 0:35:12,246
但没没有人会阻止

1186
00:35:12,316 --> 0:35:13,376
你在你的 App 或框架中

1187
00:35:13,376 --> 0:35:14,636
采取自己的

1188
00:35:14,636 --> 0:35:15,106
防御措施

1189
00:35:15,776 --> 0:35:17,266
通过这样做

1190
00:35:17,266 --> 0:35:18,596
你可以添加另一层保护

1191
00:35:18,596 --> 0:35:19,936
并提高产品安全性

1192
00:35:20,406 --> 0:35:21,066
这是共赢

1193
00:35:21,646 --> 0:35:23,216
那么让我们来谈谈

1194
00:35:23,866 --> 0:35:25,466
你可以在这里做什么

1195
00:35:25,676 --> 0:35:26,556
而我希望你考虑的是

1196
00:35:26,556 --> 0:35:28,626
在你的 App 或框架中

1197
00:35:28,626 --> 0:35:30,506
设置文本输入限制

1198
00:35:31,426 --> 0:35:32,766
现在我想强调

1199
00:35:32,766 --> 0:35:33,766
这可能并不总是

1200
00:35:33,816 --> 0:35:34,456
有意义的

1201
00:35:34,756 --> 0:35:36,106
因此举例来说

1202
00:35:36,106 --> 0:35:37,606
如果你的 App 是

1203
00:35:37,606 --> 0:35:38,736
Emily 之前展示的那种

1204
00:35:38,736 --> 0:35:40,336
日记 App 的创作工具

1205
00:35:40,336 --> 0:35:42,066
那么对该文本的长度设置限制

1206
00:35:42,066 --> 0:35:42,986
并没有任何意义

1207
00:35:43,296 --> 0:35:44,276
所以如果没有意义

1208
00:35:44,516 --> 0:35:45,626
你就不应该这样做

1209
00:35:46,416 --> 0:35:47,996
但相比之下

1210
00:35:47,996 --> 0:35:49,436
如果你的手机 App 有一个

1211
00:35:49,436 --> 0:35:50,886
用于为帐户分配昵称的

1212
00:35:50,886 --> 0:35:52,676
文本域 那么你可能会想

1213
00:35:52,676 --> 0:35:53,816
在这里应该设定怎样的限制

1214
00:35:53,816 --> 0:35:54,266
才合理

1215
00:35:54,846 --> 0:35:57,456
设置这些限制是个好主意

1216
00:35:57,456 --> 0:35:58,926
因为所有文本输入

1217
00:35:58,926 --> 0:36:00,916
都有潜在的风险

1218
00:35:58,926 --> 0:36:00,916
都有潜在的风险

1219
00:36:02,086 --> 0:36:03,926
当你允许文本输入时

1220
00:36:03,926 --> 0:36:05,906
你就允许了复制和粘贴

1221
00:36:05,906 --> 0:36:08,206
你不知道其中会被

1222
00:36:08,206 --> 0:36:08,986
粘贴哪种文本

1223
00:36:10,126 --> 0:36:10,926
它可能是任何东西

1224
00:36:10,926 --> 0:36:12,016
它可能是一个

1225
00:36:12,016 --> 0:36:12,766
带有恶意字符组合的字符串

1226
00:36:12,766 --> 0:36:14,436
或者它可能只是

1227
00:36:14,436 --> 0:36:15,816
一个非常

1228
00:36:16,126 --> 0:36:19,236
非常长的字符串

1229
00:36:20,566 --> 0:36:21,796
即使像这样的长字符串

1230
00:36:21,796 --> 0:36:23,116
本身可能不是恶意的

1231
00:36:23,116 --> 0:36:24,336
它也可能会导致你的 App

1232
00:36:24,336 --> 0:36:25,526
冻结或卡住

1233
00:36:26,296 --> 0:36:27,386
如果你有一个文本域

1234
00:36:27,676 --> 0:36:29,276
是为了一行输入设计的

1235
00:36:29,276 --> 0:36:30,816
但有人想将“战争与和平”的

1236
00:36:30,816 --> 0:36:32,126
全部内容粘贴进去

1237
00:36:32,126 --> 0:36:33,536
这大约有 310 万个

1238
00:36:33,856 --> 0:36:35,106
英文字符

1239
00:36:35,106 --> 0:36:37,576
这是否合理

1240
00:36:39,636 --> 0:36:41,226
可能并不

1241
00:36:42,316 --> 0:36:43,916
所以这是一个很好的例子

1242
00:36:43,916 --> 0:36:45,106
它可以让你能强制增加

1243
00:36:45,106 --> 0:36:46,656
你自己的限制

1244
00:36:47,926 --> 0:36:49,376
以下是

1245
00:36:49,376 --> 0:36:50,926
设定这些限制的推荐方法

1246
00:36:51,766 --> 0:36:52,856
你希望在输入字符串

1247
00:36:52,926 --> 0:36:54,756
在文本域上设置之前进行验证

1248
00:36:55,186 --> 0:36:56,846
对于 UITextFields

1249
00:36:56,846 --> 0:36:57,706
你可以通过

1250
00:36:57,986 --> 0:36:59,066
使用 UITextFieldDelegate 来完成此操作

1251
00:36:59,936 --> 0:37:01,356
对于 NSTextFields

1252
00:36:59,936 --> 0:37:01,356
对于 NSTextFields

1253
00:37:01,356 --> 0:37:03,126
你应该使用自定义的 NSFormatter

1254
00:37:03,126 --> 0:37:04,426
来实现你的验证逻辑

1255
00:37:04,426 --> 0:37:07,656
而且我们还有一些额外的

1256
00:37:07,796 --> 0:37:09,706
安全增强功能即将推出

1257
00:37:10,386 --> 0:37:11,396
因此请在发布说明中注意它们

1258
00:37:11,396 --> 0:37:12,816
如果你有任何问题

1259
00:37:12,816 --> 0:37:13,856
请在本周的实验室中

1260
00:37:13,856 --> 0:37:14,526
联系我们

1261
00:37:15,176 --> 0:37:16,666
好的

1262
00:37:16,876 --> 0:37:18,886
时间要到了

1263
00:37:18,886 --> 0:37:19,456
所以让我们回顾一下

1264
00:37:20,436 --> 0:37:21,516
你知道如何选择正确的控件

1265
00:37:21,516 --> 0:37:23,286
自定义点

1266
00:37:23,786 --> 0:37:25,466
和自定义方法

1267
00:37:25,466 --> 0:37:26,626
并了解在正确性

1268
00:37:26,626 --> 0:37:27,646
性能和安全性方面

1269
00:37:27,646 --> 0:37:29,876
遵循的最佳实践

1270
00:37:30,626 --> 0:37:32,066
使用这些知识和 TextKit

1271
00:37:32,066 --> 0:37:34,216
去创伟大的东西吧

1272
00:37:35,636 --> 0:37:36,946
等等

1273
00:37:36,946 --> 0:37:38,066
这里是超级重要的

1274
00:37:38,066 --> 0:37:39,346
更多信息链接

1275
00:37:39,346 --> 0:37:40,506
你可以在这里找到

1276
00:37:40,506 --> 0:37:41,766
我们今天引用的

1277
00:37:41,766 --> 0:37:42,596
所有过去的优秀讨论会和文档

1278
00:37:43,096 --> 0:37:44,326
请在星期四和星期五来

1279
00:37:44,326 --> 0:37:45,036
我们实验室参观

1280
00:37:45,596 --> 0:37:47,396
谢谢 希望你们可以享受讨论会的

1281
00:37:47,396 --> 0:37:47,976
其余部分

1282
00:37:48,016 --> 0:37:50,000
[ 掌声 ]
