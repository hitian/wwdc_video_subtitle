1
00:00:07,016 --> 0:00:15,500
[ 音乐 ]

2
00:00:21,416 --> 0:00:21,976
&gt;&gt; 大家下午好

3
00:00:22,516 --> 0:00:27,406
[ 掌声 ]

4
00:00:27,906 --> 0:00:29,096
欢迎来到

5
00:00:29,096 --> 0:00:29,806
核心数据最佳实践

6
00:00:29,926 --> 0:00:30,886
我叫 Scott Perry

7
00:00:30,886 --> 0:00:32,016
在核心数据工作

8
00:00:32,466 --> 0:00:33,776
一会儿也会请到我的同事

9
00:00:33,776 --> 0:00:35,016
Nick Gillett 加入

10
00:00:36,516 --> 0:00:39,286
今天我们计划 

11
00:00:39,286 --> 0:00:40,886
首先从核心数据是如何

12
00:00:40,886 --> 0:00:41,866
随着时间的推移

13
00:00:41,866 --> 0:00:43,216
进行优化开始讲起

14
00:00:43,956 --> 0:00:45,946
然后我们将讲到一些

15
00:00:45,946 --> 0:00:47,346
通过利用持久化容器

16
00:00:47,346 --> 0:00:48,706
里的扩展点

17
00:00:48,706 --> 0:00:49,886
来更简单地

18
00:00:49,886 --> 0:00:50,836
优化 App 的方法

19
00:00:51,486 --> 0:00:53,556
接着会介绍

20
00:00:53,556 --> 0:00:55,026
当 App 的要求发生变化

21
00:00:55,026 --> 0:00:56,676
以及数据量增大时

22
00:00:56,676 --> 0:00:57,236
该如何优化我们的 App

23
00:00:59,106 --> 0:01:00,666
随后 Nick 将谈到

24
00:00:59,106 --> 0:01:00,666
随后 Nick 将谈到

25
00:01:00,666 --> 0:01:01,946
几种使我们的 App 

26
00:01:01,946 --> 0:01:03,226
保持性能的方法

27
00:01:03,226 --> 0:01:04,726
即使它超过了我们的想象

28
00:01:04,726 --> 0:01:07,666
最后我们将用

29
00:01:08,406 --> 0:01:09,196
转换器

30
00:01:09,196 --> 0:01:11,046
调试和测试来收尾

31
00:01:11,586 --> 0:01:15,976
但是首先 我们先创建一个 App

32
00:01:15,976 --> 0:01:17,716
我很喜欢拍照 我们

33
00:01:17,716 --> 0:01:18,416
创建一个能让我

34
00:01:18,416 --> 0:01:19,486
和朋友们分享照片

35
00:01:19,486 --> 0:01:21,746
并得到反馈的 App

36
00:01:21,746 --> 0:01:22,946
即使只是 Nick 在问

37
00:01:22,946 --> 0:01:25,316
我的幻灯片放得怎么样

38
00:01:26,236 --> 0:01:28,406
我们该如何保留 App 的数据呢

39
00:01:28,586 --> 0:01:30,016
我们可以将它存在网上

40
00:01:30,016 --> 0:01:31,456
但是我通常都

41
00:01:31,456 --> 0:01:32,776
在旅行时拍照

42
00:01:32,776 --> 0:01:33,696
网络连接可能会不稳定

43
00:01:33,696 --> 0:01:35,756
我们需要存在本地

44
00:01:35,756 --> 0:01:37,736
将它整合进存储器里

45
00:01:40,296 --> 0:01:42,596
我们现在有贴文 评论

46
00:01:42,596 --> 0:01:44,006
以及它们的实例 

47
00:01:44,006 --> 0:01:45,606
二者之间的关系形成了一个

48
00:01:45,606 --> 0:01:47,386
对象图

49
00:01:47,386 --> 0:01:48,846
我们决定将它们保存在

50
00:01:48,846 --> 0:01:52,316
磁盘上

51
00:01:52,316 --> 0:01:53,096
这就该核心数据上场了

52
00:01:56,006 --> 0:01:57,236
我们将使用它

53
00:01:57,236 --> 0:01:59,166
将模型转化为

54
00:01:59,216 --> 0:02:01,006
存储器

55
00:01:59,216 --> 0:02:01,006
存储器

56
00:02:01,006 --> 0:02:02,606
能够理解的托管项目模型

57
00:02:03,616 --> 0:02:04,276
所有东西都需要字段

58
00:02:04,276 --> 0:02:05,816
比如图片的属性 

59
00:02:05,816 --> 0:02:07,406
比如图像数据

60
00:02:07,406 --> 0:02:08,606
和发布时间

61
00:02:09,076 --> 0:02:11,266
此外我们还需要

62
00:02:11,266 --> 0:02:12,236
贴文和评论间的关系

63
00:02:12,596 --> 0:02:14,066
我们已经定义了

64
00:02:14,066 --> 0:02:15,446
存储器的需求

65
00:02:15,446 --> 0:02:17,366
但是随着时间的推移

66
00:02:17,366 --> 0:02:18,156
数据的维护涉及到很多工作

67
00:02:19,056 --> 0:02:20,386
幸运的是核心数据提供了一个

68
00:02:20,386 --> 0:02:21,956
持久化存储协调器

69
00:02:21,956 --> 0:02:22,546
来进行管理

70
00:02:22,986 --> 0:02:24,836
这个协调器可以处理例如

71
00:02:24,836 --> 0:02:26,246
与存储器的模型版本

72
00:02:26,246 --> 0:02:27,806
对比 App 模型

73
00:02:27,806 --> 0:02:29,276
并随着 App 的优化

74
00:02:29,276 --> 0:02:30,306
进行自动迁移

75
00:02:30,786 --> 0:02:32,916
最终托管对象上下文 会对我们的数据

76
00:02:32,916 --> 0:02:34,436
提供安全快捷

77
00:02:34,436 --> 0:02:35,936
且可预测的访问权限

78
00:02:36,616 --> 0:02:37,826
即便我们

79
00:02:37,826 --> 0:02:39,426
同时使用很多功能

80
00:02:39,426 --> 0:02:40,636
例如查询生成

81
00:02:40,716 --> 0:02:41,896
连接池以及

82
00:02:41,896 --> 0:02:42,376
历史跟踪

83
00:02:44,236 --> 0:02:46,486
设置这些要求

84
00:02:46,566 --> 0:02:47,736
找到模型 进行加载

85
00:02:47,736 --> 0:02:49,236
然后决定如何保存存储器

86
00:02:49,236 --> 0:02:51,186
但是很多错误路径

87
00:02:51,186 --> 0:02:53,026
在你迁移 App 之后

88
00:02:53,026 --> 0:02:54,816
并不会失败

89
00:02:54,816 --> 0:02:56,246
因此核心数据提供了一个容器类型

90
00:02:56,576 --> 0:02:57,716
能极大的降低

91
00:02:57,716 --> 0:02:58,946
你在设置堆栈时所需的样板文件

92
00:02:58,946 --> 0:03:00,736
只需要按名称引用模型

93
00:02:58,946 --> 0:03:00,736
只需要按名称引用模型

94
00:03:00,736 --> 0:03:03,486
然后持久化容器将

95
00:03:03,486 --> 0:03:05,046
从主束中加载它 并将它

96
00:03:05,046 --> 0:03:06,766
储存在持久化的位置

97
00:03:07,306 --> 0:03:10,386
这种持久化容器类型

98
00:03:10,386 --> 0:03:11,926
囊括了一整个堆栈以及

99
00:03:11,926 --> 0:03:13,526
共享主队列视图上下文的

100
00:03:13,526 --> 0:03:15,256
便利构造函数和

101
00:03:15,806 --> 0:03:17,926
用于生成

102
00:03:18,246 --> 0:03:20,286
背景语上下文的工厂方法

103
00:03:20,286 --> 0:03:21,676
以及执行后台工作

104
00:03:22,426 --> 0:03:23,796
在我们的 App 扩展的同时

105
00:03:23,796 --> 0:03:25,366
它同样易于操作

106
00:03:25,776 --> 0:03:27,706
举个例子 要将我们的

107
00:03:27,706 --> 0:03:29,956
模型层纳入到它自己的框架中

108
00:03:30,836 --> 0:03:31,856
我们可以通过在 Xcode 里

109
00:03:31,856 --> 0:03:33,166
创建一个新的框架目标然后将

110
00:03:33,166 --> 0:03:34,116
我们的代码移动进去

111
00:03:34,446 --> 0:03:36,166
这都非常简单 但是当我们将

112
00:03:36,166 --> 0:03:37,116
我们的模型移动到新的目标时 

113
00:03:37,116 --> 0:03:38,836
在已构建的产品中

114
00:03:38,836 --> 0:03:40,836
目标从 App 移动到了新的框架

115
00:03:40,836 --> 0:03:42,736
本应如此

116
00:03:42,736 --> 0:03:43,806
但是现在

117
00:03:43,806 --> 0:03:45,246
NSPersistentContainer 不知道 

118
00:03:45,436 --> 0:03:46,896
在哪才能找到我们的模型

119
00:03:47,476 --> 0:03:48,566
这是因为 默认下

120
00:03:48,566 --> 0:03:49,846
它只会检查主束

121
00:03:50,416 --> 0:03:51,056
为什么停在那里呢

122
00:03:51,806 --> 0:03:53,296
因为检索 App 里所有束

123
00:03:53,296 --> 0:03:54,826
会非常缓慢

124
00:03:54,826 --> 0:03:56,526
你不会希望每次

125
00:03:56,526 --> 0:03:57,816
加速堆栈的时候

126
00:03:57,816 --> 0:03:58,866
都花好长时间

127
00:04:00,206 --> 0:04:01,506
如何修复呢

128
00:04:02,666 --> 0:04:03,926
我们可以自己

129
00:04:03,926 --> 0:04:05,206
在框架束外恢复这个模型

130
00:04:05,206 --> 0:04:06,766
然后使用

131
00:04:06,766 --> 0:04:07,456
容器的其他初始化 App

132
00:04:07,456 --> 0:04:08,666
比如那个使用

133
00:04:08,736 --> 0:04:10,606
显式托管对象模型的 App

134
00:04:10,606 --> 0:04:12,986
但是事实上 NSPersistentContainer

135
00:04:12,986 --> 0:04:14,486
提供了一种更改

136
00:04:14,486 --> 0:04:16,036
检索对象的方法

137
00:04:17,856 --> 0:04:19,856
看 NSPersistentContainer 知道

138
00:04:19,856 --> 0:04:21,086
它什么时候子类化

139
00:04:21,086 --> 0:04:24,106
然后在搜索模型时 将子类类型

140
00:04:24,106 --> 0:04:24,666
作为提示

141
00:04:25,156 --> 0:04:26,256
我们所要做的就是

142
00:04:26,256 --> 0:04:27,566
利用这个功能

143
00:04:27,566 --> 0:04:28,236
创建一个子类

144
00:04:28,756 --> 0:04:29,826
里面甚至可以

145
00:04:29,826 --> 0:04:30,466
什么都没有

146
00:04:31,916 --> 0:04:33,976
然后 任何通过容器设置

147
00:04:33,976 --> 0:04:35,816
并希望使用我们的模型的代码 

148
00:04:35,816 --> 0:04:37,466
可以采用那个子类

149
00:04:37,466 --> 0:04:38,646
然后持久化容器将

150
00:04:38,646 --> 0:04:40,586
替代它在框架束中检索模型

151
00:04:41,196 --> 0:04:45,856
这很有趣 但是因为我们需要努力

152
00:04:45,856 --> 0:04:47,286
分解我们 App 的资源

153
00:04:47,436 --> 0:04:48,486
如果我们能提升

154
00:04:48,486 --> 0:04:49,696
我们磁盘上数据的组织

155
00:04:49,696 --> 0:04:50,426
不是更好吗

156
00:04:51,146 --> 0:04:53,306
在默认情况下 

157
00:04:53,306 --> 0:04:54,276
新的持久化容器 

158
00:04:54,276 --> 0:04:55,986
带有一个 SQLite 存储的存储描述

159
00:04:56,116 --> 0:04:58,136
它的自动迁移功能在

160
00:04:58,136 --> 0:04:59,926
iOS 系统中存在我们的 App 的

161
00:04:59,926 --> 0:05:00,366
文件目录里

162
00:04:59,926 --> 0:05:00,366
文件目录里

163
00:05:00,796 --> 0:05:02,056
当我们的模型代码是 App 的一部分时

164
00:05:02,056 --> 0:05:04,066
这确实很好

165
00:05:04,066 --> 0:05:04,876
但我们需要避免让我们的

166
00:05:04,876 --> 0:05:06,116
新框架文件与 App

167
00:05:06,116 --> 0:05:07,286
过度混合

168
00:05:08,376 --> 0:05:09,566
既然我们已经将

169
00:05:09,566 --> 0:05:10,976
NSPersistentContainer 子类化

170
00:05:10,976 --> 0:05:12,706
以使搜索模型更加简单

171
00:05:12,706 --> 0:05:14,086
我们在这个基础上进行提升

172
00:05:16,476 --> 0:05:18,456
硬性更改储存位置的方法

173
00:05:18,456 --> 0:05:20,786
是在加载存储之前

174
00:05:20,786 --> 0:05:23,446
就在 persistentStoreDescription 里面

175
00:05:23,446 --> 0:05:26,716
更改 URL 有时候这就是你想要的

176
00:05:26,716 --> 0:05:27,826
我们可以在这里使用这种模式

177
00:05:27,826 --> 0:05:29,406
但是我们不需要这样做

178
00:05:29,716 --> 0:05:31,516
因为 NSPersistentContainer

179
00:05:31,516 --> 0:05:33,996
在创建持久化存储描述文件

180
00:05:33,996 --> 0:05:35,816
时会调用它自己默认的 

181
00:05:35,816 --> 0:05:37,086
目录 URL 方法

182
00:05:37,286 --> 0:05:38,626
它是用来被覆盖的

183
00:05:39,166 --> 0:05:40,516
在这种情况下 

184
00:05:40,516 --> 0:05:42,066
我们可以增加一个路径组件

185
00:05:42,066 --> 0:05:43,076
但是为了缓存

186
00:05:43,076 --> 0:05:45,776
或其他类型的堆栈

187
00:05:45,776 --> 0:05:46,826
比如说你的任务

188
00:05:46,826 --> 0:05:47,926
需要将它们的存储放在不同位置

189
00:05:47,926 --> 0:05:49,756
设置容器也是一种很好的方式

190
00:05:50,306 --> 0:05:53,046
现在我们已经搞清楚了

191
00:05:53,046 --> 0:05:54,256
核心数据的存量

192
00:05:54,386 --> 0:05:55,686
我们来看看我们的 App 以及

193
00:05:55,686 --> 0:05:57,706
一些我们所写的视图控制器

194
00:05:58,376 --> 0:06:00,896
看起来 我们有一些非常特别的

195
00:05:58,376 --> 0:06:00,896
看起来 我们有一些非常特别的

196
00:06:00,896 --> 0:06:01,606
视图控制器

197
00:06:02,296 --> 0:06:03,386
这里有一个可以显示我所有的帖子

198
00:06:03,386 --> 0:06:04,826
另一个可以显示

199
00:06:04,826 --> 0:06:06,746
所有作者发布的所有帖子

200
00:06:07,226 --> 0:06:08,226
甚至连详细评论都被

201
00:06:08,346 --> 0:06:09,166
复制了

202
00:06:09,306 --> 0:06:10,796
看起来

203
00:06:10,796 --> 0:06:13,386
我们只需要写一半的代码

204
00:06:13,776 --> 0:06:15,656
我们真正需要的

205
00:06:15,656 --> 0:06:16,916
是一个用来展示帖子列表的视图控制器 

206
00:06:16,916 --> 0:06:18,556
和另一个显示单个帖子的

207
00:06:18,556 --> 0:06:19,926
视图控制器

208
00:06:20,626 --> 0:06:21,656
我们可以通过

209
00:06:21,656 --> 0:06:23,526
在使用模型对象的 

210
00:06:23,526 --> 0:06:25,516
界面形式里

211
00:06:25,516 --> 0:06:26,916
在视图控制器之间

212
00:06:26,916 --> 0:06:27,786
定义良好边界

213
00:06:29,286 --> 0:06:30,576
每个控制器均由其

214
00:06:30,576 --> 0:06:33,026
模型参数配置

215
00:06:33,026 --> 0:06:34,136
可以基于

216
00:06:34,136 --> 0:06:35,306
是否展示我的帖子

217
00:06:35,306 --> 0:06:36,626
或别人的帖子

218
00:06:36,626 --> 0:06:37,386
来自定义单元格中的视图

219
00:06:37,906 --> 0:06:40,936
当使用核心数据 

220
00:06:40,936 --> 0:06:42,566
草拟视图控制器时

221
00:06:42,566 --> 0:06:44,016
列表视图应获得读取请求

222
00:06:44,016 --> 0:06:45,406
评论详情应获得

223
00:06:45,406 --> 0:06:46,096
托管对象

224
00:06:47,506 --> 0:06:48,776
视图控制器也需要一个

225
00:06:48,776 --> 0:06:50,446
托管对象上下文

226
00:06:50,446 --> 0:06:52,076
容器的评论上下文或者

227
00:06:52,076 --> 0:06:53,886
一些其它的主队列上下文

228
00:06:54,046 --> 0:06:55,536
这个用核心数据来

229
00:06:55,536 --> 0:06:56,806
生成视图控制器的模式

230
00:06:56,806 --> 0:06:58,176
不仅可以为 UI 服务

231
00:06:58,176 --> 0:06:59,596
也能很好地

232
00:06:59,596 --> 0:07:00,836
服务于实用 App 类型

233
00:06:59,596 --> 0:07:00,836
服务于实用 App 类型

234
00:07:01,806 --> 0:07:02,926
无需传递核心数据类型给演示文稿

235
00:07:02,926 --> 0:07:06,446
我们可以将 URL 或

236
00:07:06,446 --> 0:07:08,106
序列化数据等传递给

237
00:07:08,106 --> 0:07:10,496
后台工作控制器 

238
00:07:10,496 --> 0:07:11,896
然后用后台上下文代替

239
00:07:11,896 --> 0:07:13,446
视图上下文来完成我们的工作 

240
00:07:13,506 --> 0:07:14,876
将它们变为

241
00:07:14,876 --> 0:07:16,476
全新的升级的托管对象

242
00:07:18,016 --> 0:07:19,136
采用这种连接和工具类型

243
00:07:19,136 --> 0:07:20,616
非常简单

244
00:07:20,616 --> 0:07:22,146
因为我们拥有初始化器

245
00:07:22,146 --> 0:07:23,936
我们可以要求参数去创建一个

246
00:07:23,936 --> 0:07:24,466
控制器

247
00:07:24,566 --> 0:07:26,316
但我们如何将

248
00:07:26,316 --> 0:07:27,416
边缘变量放入

249
00:07:27,416 --> 0:07:28,086
视图控制器中呢

250
00:07:28,676 --> 0:07:31,946
如果我们使用 segues

251
00:07:31,946 --> 0:07:33,226
就可以覆盖 prepare method

252
00:07:34,636 --> 0:07:35,706
然后得到一个

253
00:07:35,706 --> 0:07:37,086
对 destinationViewController 的引用

254
00:07:37,086 --> 0:07:38,186
然后在那儿配置它

255
00:07:38,806 --> 0:07:40,636
如果我们使用故事板或者 nibs

256
00:07:40,636 --> 0:07:42,656
那么我们已经有可以汇成

257
00:07:42,656 --> 0:07:43,576
destinationViewController 的代码

258
00:07:43,576 --> 0:07:45,676
我们需要做的是

259
00:07:45,676 --> 0:07:47,976
在演示前设置属性

260
00:07:48,506 --> 0:07:50,586
如果我们在操纵杆

261
00:07:50,586 --> 0:07:51,676
我们可以写一个可以

262
00:07:51,676 --> 0:07:52,826
明确的定义边界条件的初始化 App

263
00:07:52,826 --> 0:07:54,256
就像我们在没有效用类型时

264
00:07:54,256 --> 0:07:55,676
所做的那样

265
00:07:56,276 --> 0:07:59,656
好了 现在我们已经有了一个读取请求

266
00:07:59,656 --> 0:08:01,056
和视图控制器的上下文

267
00:07:59,656 --> 0:08:01,056
和视图控制器的上下文

268
00:08:01,056 --> 0:08:02,656
但是在我们

269
00:08:02,656 --> 0:08:04,136
混合二者得到结果之前

270
00:08:04,136 --> 0:08:05,486
我们需要对 

271
00:08:05,486 --> 0:08:06,746
读取请求多做一些配置

272
00:08:06,746 --> 0:08:07,986
来确定我们的控制器

273
00:08:07,986 --> 0:08:09,136
会表现不错

274
00:08:10,856 --> 0:08:12,276
有时应该设置读取限制

275
00:08:12,276 --> 0:08:13,806
但按照列表视图的情况

276
00:08:13,806 --> 0:08:15,036
使用批处理更合适

277
00:08:15,036 --> 0:08:16,036
因为我们希望显示所有的数据

278
00:08:16,036 --> 0:08:18,596
我们也知道

279
00:08:18,596 --> 0:08:20,126
我们的视图控制器

280
00:08:20,126 --> 0:08:21,806
一次可以在屏幕上 显示多少个单元格

281
00:08:22,546 --> 0:08:24,306
总的来说 至少这些选项中的一个

282
00:08:24,306 --> 0:08:25,886
需要设置为读取请求

283
00:08:25,886 --> 0:08:27,156
它返回的结果

284
00:08:27,156 --> 0:08:29,276
可能是无限数量

285
00:08:29,956 --> 0:08:32,346
所以这时我们可以

286
00:08:32,346 --> 0:08:33,676
将读取请求更改为对象

287
00:08:33,676 --> 0:08:35,025
然后用返回结果填充列表视图

288
00:08:35,056 --> 0:08:37,196
但是如果我们想要

289
00:08:37,196 --> 0:08:39,155
让 UI 和发生的更改保持一致

290
00:08:39,155 --> 0:08:40,366
该怎么做

291
00:08:41,666 --> 0:08:42,846
我们在这里已经讲到了核心数据

292
00:08:42,846 --> 0:08:44,246
和读取结果控制器

293
00:08:44,726 --> 0:08:46,356
自 Sierra 系统以来

294
00:08:46,356 --> 0:08:47,976
读取结果控制器可用于所有平台

295
00:08:47,976 --> 0:08:49,366
要采用它只要求

296
00:08:49,366 --> 0:08:50,556
在委托协议和它驱动的视图之间

297
00:08:50,556 --> 0:08:52,536
写一个适配器

298
00:08:53,136 --> 0:08:54,556
要创建它 我们只需要

299
00:08:54,556 --> 0:08:55,836
一个读取请求和一个上下文

300
00:08:57,176 --> 0:08:58,136
读取结果控制器

301
00:08:58,136 --> 0:08:59,276
甚至可以支持对类似区段这样的

302
00:08:59,276 --> 0:09:01,316
更加高级的列表视图概念

303
00:08:59,276 --> 0:09:01,316
更加高级的列表视图概念

304
00:09:01,316 --> 0:09:02,026
进行驱动

305
00:09:03,066 --> 0:09:05,066
如果我们希望将帖子

306
00:09:05,066 --> 0:09:06,206
根据发布的日期分成区段

307
00:09:06,206 --> 0:09:07,596
我们可以

308
00:09:07,596 --> 0:09:09,046
通过使用计算属性

309
00:09:09,046 --> 0:09:10,696
将 Xcode 生成的帖子类型进行扩展

310
00:09:10,696 --> 0:09:12,436
然后将它的名称

311
00:09:12,436 --> 0:09:14,436
传递给读取结果控制器的

312
00:09:14,436 --> 0:09:15,076
初始化 App

313
00:09:16,336 --> 0:09:18,156
这样可以运行得很好

314
00:09:18,156 --> 0:09:19,226
但是如果我们有比

315
00:09:19,226 --> 0:09:20,596
仅有一个对象列表 更复杂的视图控制器时

316
00:09:20,596 --> 0:09:21,656
我们该怎么做

317
00:09:21,806 --> 0:09:22,786
如果我们希望

318
00:09:22,786 --> 0:09:24,686
在 App 上显示类似每日发帖图表的东西

319
00:09:24,686 --> 0:09:25,966
该怎么做

320
00:09:27,556 --> 0:09:28,776
我们需要做的第一件事就是

321
00:09:28,776 --> 0:09:31,266
不要低估了读取请求的能力

322
00:09:31,816 --> 0:09:33,126
我只是一个人

323
00:09:33,126 --> 0:09:34,326
所以在上个月

324
00:09:34,326 --> 0:09:36,576
我没能每天发布

325
00:09:36,576 --> 0:09:36,926
多于 40 张的照片

326
00:09:37,706 --> 0:09:39,196
在 30 天内

327
00:09:39,336 --> 0:09:40,646
这仍然是

328
00:09:40,646 --> 0:09:41,706
一次从存储中取出的

329
00:09:41,706 --> 0:09:42,566
合理的数据量

330
00:09:43,446 --> 0:09:45,466
如果我们先前定义的

331
00:09:45,466 --> 0:09:46,856
日期属性是

332
00:09:46,856 --> 0:09:48,236
模型中实体的一部分

333
00:09:48,646 --> 0:09:49,386
我们可以写一个读取请求

334
00:09:49,386 --> 0:09:50,506
能够将帖子数量

335
00:09:50,506 --> 0:09:52,916
根据发布的日期进行分组

336
00:09:53,456 --> 0:09:55,236
这个请求有三部分

337
00:09:55,616 --> 0:09:56,986
第一个是

338
00:09:56,986 --> 0:09:57,426
设置范围

339
00:09:57,596 --> 0:09:58,966
我们希望有

340
00:09:58,966 --> 0:09:59,316
至少 30 天的数据

341
00:09:59,316 --> 0:10:02,316
接下来 我们希望

342
00:09:59,316 --> 0:10:02,316
接下来 我们希望

343
00:10:02,316 --> 0:10:04,536
将所有日期属性的值相同的日期

344
00:10:04,536 --> 0:10:05,716
分到一组

345
00:10:06,316 --> 0:10:07,076
因为我们现在抓取的是

346
00:10:07,076 --> 0:10:08,566
总量而不是单个的对象

347
00:10:08,566 --> 0:10:09,796
我们也需要将结果类型修改得

348
00:10:09,796 --> 0:10:10,876
更加合理

349
00:10:10,876 --> 0:10:13,066
在这里是字典

350
00:10:14,726 --> 0:10:17,346
最后 我们要定义一个

351
00:10:17,346 --> 0:10:19,316
在每个组里代表对象数量的表达式

352
00:10:19,316 --> 0:10:20,976
然后告诉读取请求 

353
00:10:20,976 --> 0:10:23,616
返回它所代表的日期的计数

354
00:10:24,926 --> 0:10:26,996
这个读取请求返回了 30 个结果

355
00:10:26,996 --> 0:10:28,416
它们中的每一个都是

356
00:10:28,416 --> 0:10:29,876
图表中的一个点

357
00:10:31,216 --> 0:10:34,466
如果你进入数据库

358
00:10:34,466 --> 0:10:35,546
这是核心数据从

359
00:10:35,546 --> 0:10:36,686
读取请求里

360
00:10:36,686 --> 0:10:37,186
生成的 SQLite 查询

361
00:10:37,646 --> 0:10:38,846
如果你自己写查询语句

362
00:10:38,846 --> 0:10:39,516
那么这就是

363
00:10:39,516 --> 0:10:40,046
你要做的

364
00:10:40,496 --> 0:10:41,816
核心数据知道如何

365
00:10:41,816 --> 0:10:43,226
将许多表达功能

366
00:10:43,226 --> 0:10:45,196
转换成最佳的数据库查询

367
00:10:45,776 --> 0:10:46,856
一个通过查询得到的组

368
00:10:46,856 --> 0:10:48,066
可以聚合

369
00:10:48,066 --> 0:10:50,076
例如平均 求和 以及标量查询

370
00:10:50,076 --> 0:10:51,736
比如一般的读取请求

371
00:10:51,736 --> 0:10:53,336
可以使用标量计数以及日期功能

372
00:10:53,336 --> 0:10:54,926
就像 abs 之于绝对值

373
00:10:54,926 --> 0:10:57,026
now 之于当前时间一样

374
00:10:57,156 --> 0:10:59,366
如果你想知道

375
00:10:59,366 --> 0:11:00,236
更多的关于 NSExpression 的内容

376
00:10:59,366 --> 0:11:00,236
更多的关于 NSExpression 的内容

377
00:11:00,266 --> 0:11:01,306
你可以去了解一下

378
00:11:01,306 --> 0:11:03,286
功能列表的资料

379
00:11:03,356 --> 0:11:04,366
在核心数据里

380
00:11:04,366 --> 0:11:07,336
很多都受到读取请求的支持

381
00:11:08,366 --> 0:11:10,586
所以通过使用表达式

382
00:11:10,586 --> 0:11:12,566
读取请求可以完成很多事

383
00:11:12,566 --> 0:11:14,606
但是 SQLite 仍旧会在

384
00:11:14,606 --> 0:11:16,286
处理图表时

385
00:11:16,286 --> 0:11:18,636
读取每一个帖子

386
00:11:19,126 --> 0:11:20,976
用图表展示

387
00:11:20,976 --> 0:11:23,566
一个人的发帖数量时运行良好

388
00:11:23,566 --> 0:11:24,586
但是如果我们希望

389
00:11:24,586 --> 0:11:25,796
为更庞大的数据

390
00:11:25,796 --> 0:11:26,746
制作图表呢

391
00:11:27,086 --> 0:11:28,676
如果我们想展示一整年的数据

392
00:11:28,676 --> 0:11:30,536
或者我们的 App 

393
00:11:30,536 --> 0:11:32,136
要开始处理

394
00:11:32,136 --> 0:11:33,386
更大数量级的数据呢

395
00:11:34,706 --> 0:11:35,686
现在 读取请求至少可以

396
00:11:35,686 --> 0:11:37,566
一个一个地

397
00:11:37,566 --> 0:11:39,226
计算 50,000 个帖子

398
00:11:39,226 --> 0:11:41,956
只为显示 30 个点 这不够快

399
00:11:42,436 --> 0:11:44,076
视图与模型之间的不协调

400
00:11:44,076 --> 0:11:45,436
已经到了需要我们

401
00:11:45,436 --> 0:11:47,596
做一些 denormalization 了

402
00:11:50,226 --> 0:11:52,266
denormalization 是当我们

403
00:11:52,266 --> 0:11:53,596
增加冗余的数据副本

404
00:11:53,596 --> 0:11:55,266
或者元数据时

405
00:11:55,266 --> 0:11:56,556
以增加簿记为代价

406
00:11:56,556 --> 0:11:57,576
来提升读取性能

407
00:11:58,156 --> 0:11:59,546
数据库索引就是一个

408
00:11:59,546 --> 0:12:00,466
很好的例子

409
00:11:59,546 --> 0:12:00,466
很好的例子

410
00:12:01,396 --> 0:12:02,766
在我们的存储里加入计数元数据

411
00:12:02,766 --> 0:12:04,526
是为了使我们的图表 

412
00:12:04,526 --> 0:12:07,866
能够再次显示 而做出的牺牲

413
00:12:08,666 --> 0:12:10,676
让我们看看 我们的模型

414
00:12:10,676 --> 0:12:12,366
如何将帖子按照发布的

415
00:12:12,366 --> 0:12:12,736
日期分组

416
00:12:13,626 --> 0:12:15,556
我们将需要一个新的实体和两个属性

417
00:12:15,556 --> 0:12:17,246
加上一些额外的维护

418
00:12:17,246 --> 0:12:18,316
以保证其准确性

419
00:12:19,186 --> 0:12:20,796
按照日期分组很大地提升了

420
00:12:20,796 --> 0:12:22,396
读取请求 

421
00:12:22,396 --> 0:12:23,756
使它保证在覆盖好几年的数据时

422
00:12:23,756 --> 0:12:25,386
也能有好的表现

423
00:12:25,766 --> 0:12:26,776
我们只需要创建

424
00:12:26,776 --> 0:12:29,376
与我们向图表视图控制器

425
00:12:29,376 --> 0:12:30,516
传递的同样水平的 denormalization

426
00:12:30,516 --> 0:12:31,496
和读取请求即可

427
00:12:32,386 --> 0:12:33,446
这非常简单

428
00:12:34,416 --> 0:12:35,256
这和我们向其他列表视图

429
00:12:35,256 --> 0:12:36,336
传递的读取请求 

430
00:12:36,336 --> 0:12:37,576
没有多大不同

431
00:12:37,576 --> 0:12:39,386
事实上如果你看得够仔细

432
00:12:39,506 --> 0:12:40,636
会发现它

433
00:12:40,636 --> 0:12:42,176
有点像一种图表视图

434
00:12:43,766 --> 0:12:44,866
但是特殊维护

435
00:12:44,866 --> 0:12:45,396
该如何进行呢

436
00:12:46,186 --> 0:12:47,656
当帖子发布时

437
00:12:47,656 --> 0:12:48,986
我们需要增加计数

438
00:12:48,986 --> 0:12:50,236
当帖子被移除时

439
00:12:50,236 --> 0:12:50,846
我们需要减少计数

440
00:12:51,556 --> 0:12:53,016
我们可以使用

441
00:12:53,016 --> 0:12:54,296
更改帖子对象的相关状态的方法

442
00:12:54,296 --> 0:12:55,836
来实现它

443
00:12:55,836 --> 0:12:56,886
但一个更简单明了的方式是去

444
00:12:56,886 --> 0:12:58,046
根据响应上下文存储

445
00:12:58,046 --> 0:12:58,796
来更新计数

446
00:12:59,356 --> 0:13:04,546
我们可以为

447
00:12:59,356 --> 0:13:04,546
我们可以为

448
00:13:04,976 --> 0:13:07,156
托管对象 contextWillSave 提醒

449
00:13:07,156 --> 0:13:08,866
注册一个功能

450
00:13:09,296 --> 0:13:10,286
使它可以检查所有

451
00:13:10,286 --> 0:13:11,406
添加的帖子

452
00:13:11,696 --> 0:13:13,136
对所有相关的日期增加计数

453
00:13:13,136 --> 0:13:15,626
让另外一个循环

454
00:13:16,066 --> 0:13:18,186
检查所有被删除的对象

455
00:13:18,186 --> 0:13:18,956
为每天减少计数

456
00:13:19,646 --> 0:13:20,656
这样就可以在交付数据库之前

457
00:13:20,656 --> 0:13:22,106
影响上下文状态

458
00:13:22,106 --> 0:13:23,516
最后它们会在

459
00:13:23,516 --> 0:13:25,166
一次交付中完成

460
00:13:25,166 --> 0:13:27,236
这样做 延展性很好

461
00:13:27,236 --> 0:13:28,916
非常有用

462
00:13:28,916 --> 0:13:30,366
因为我的同事 Nick Gilett 将

463
00:13:30,366 --> 0:13:31,676
探讨当我们的 App 扩展到超出想象时

464
00:13:31,676 --> 0:13:33,296
核心数据

465
00:13:33,296 --> 0:13:34,186
将如何帮助我们

466
00:13:34,846 --> 0:13:34,976
Nick

467
00:13:35,271 --> 0:13:37,271
[ 掌声 ]

468
00:13:37,526 --> 0:13:37,976
&gt;&gt; 谢谢 Scott

469
00:13:38,416 --> 0:13:40,416
[ 掌声 ]

470
00:13:40,816 --> 0:13:42,296
就像 Scott 所说

471
00:13:42,296 --> 0:13:43,876
在你的 App 扩张时

472
00:13:43,876 --> 0:13:46,606
它们变得更加复杂

473
00:13:46,606 --> 0:13:48,196
对于核心数据而言

474
00:13:48,196 --> 0:13:50,656
很重要的一点是 你的 App 确实在扩张

475
00:13:50,656 --> 0:13:51,746
事实上 这是我们想要的

476
00:13:51,746 --> 0:13:53,336
这是我们出现

477
00:13:53,426 --> 0:13:54,626
并帮助你管理扩展的全部理由

478
00:13:54,626 --> 0:13:56,166
通过使用它

479
00:13:56,166 --> 0:13:58,026
使你的工作更有效率

480
00:13:58,026 --> 0:13:59,656
帮助你为顾客创造更多的价值

481
00:14:00,306 --> 0:14:03,046
但是这种方式

482
00:14:03,046 --> 0:14:04,936
对你的 App 来说 会非常特别

483
00:14:05,416 --> 0:14:06,976
高度匹配

484
00:14:06,976 --> 0:14:08,696
顾客的体验

485
00:14:08,696 --> 0:14:09,936
或者你希望顾客以何种方式

486
00:14:09,936 --> 0:14:11,266
体验你的 App

487
00:14:12,056 --> 0:14:13,816
不幸的是 

488
00:14:13,816 --> 0:14:15,696
就像所有的复杂系统一样

489
00:14:15,696 --> 0:14:18,516
它也会出现混乱

490
00:14:19,376 --> 0:14:20,716
所有我们今天将

491
00:14:20,716 --> 0:14:22,136
探讨核心数据如何帮助你

492
00:14:22,136 --> 0:14:23,876
管理这些混乱

493
00:14:23,876 --> 0:14:24,896
并且使系统更有条理

494
00:14:25,466 --> 0:14:26,536
我们将讨论构建

495
00:14:26,536 --> 0:14:28,996
可预测的行为

496
00:14:28,996 --> 0:14:30,436
并帮助你构建

497
00:14:30,436 --> 0:14:31,826
可调容器

498
00:14:31,826 --> 0:14:32,976
来与你的经验指标匹配

499
00:14:36,236 --> 0:14:37,346
这是什么意思呢

500
00:14:38,246 --> 0:14:39,996
当我们想到指标时

501
00:14:39,996 --> 0:14:42,946
我们有很多不同的方式去思考它

502
00:14:43,396 --> 0:14:45,696
第一个是 与用户保持一致

503
00:14:46,326 --> 0:14:48,586
我们一般会将它们定义为

504
00:14:48,586 --> 0:14:49,836
用户会体验的东西

505
00:14:49,836 --> 0:14:51,176
比如有持久化用户界面或者

506
00:14:51,176 --> 0:14:53,536
一个响应滚动视图

507
00:14:53,536 --> 0:14:57,786
或者顾客喜悦度

508
00:14:58,486 --> 0:15:01,106
但对于我们工程师来说

509
00:14:58,486 --> 0:15:01,106
但对于我们工程师来说

510
00:15:01,106 --> 0:15:02,476
这些都很难捕捉

511
00:15:03,256 --> 0:15:04,326
我们将它们

512
00:15:04,326 --> 0:15:06,186
翻译为工程指标

513
00:15:06,296 --> 0:15:08,276
比如运行时的峰值内存

514
00:15:08,276 --> 0:15:09,836
在运行一个任务时电池的消耗

515
00:15:09,836 --> 0:15:12,056
或者在运行一个任务时

516
00:15:12,436 --> 0:15:13,896
所需要的中央处理时间

517
00:15:14,316 --> 0:15:17,906
最后 我们在给予的任务中做了多少 IO

518
00:15:18,806 --> 0:15:19,656
为了让它更具体一些

519
00:15:19,656 --> 0:15:21,626
我们将使用这个 App

520
00:15:22,286 --> 0:15:23,236
你们中的有些人

521
00:15:23,236 --> 0:15:24,736
可能还记得去年的 WWDC

522
00:15:24,836 --> 0:15:26,886
我们介绍的历史演示 App

523
00:15:27,306 --> 0:15:28,536
为了这个演讲

524
00:15:28,536 --> 0:15:29,676
我对它进行了修改

525
00:15:30,506 --> 0:15:32,156
当用户用你的 App 时

526
00:15:32,156 --> 0:15:34,526
这里有一些它们可以做的事

527
00:15:35,036 --> 0:15:36,676
第一个是它们可以

528
00:15:36,676 --> 0:15:38,826
通过敲击 + 键

529
00:15:38,826 --> 0:15:39,746
将单个的帖子添加到你的数据库中去

530
00:15:40,786 --> 0:15:42,256
它们也可以

531
00:15:42,256 --> 0:15:44,546
通过点击下载

532
00:15:44,546 --> 0:15:45,406
从服务器下载未决数据

533
00:15:50,716 --> 0:15:53,966
最终 对那些还没有被上传到服务区的东西

534
00:15:53,966 --> 0:15:55,636
它们可以点击发布全部

535
00:15:56,596 --> 0:16:00,416
现在 这个 App 有少数几个

536
00:15:56,596 --> 0:16:00,416
现在 这个 App 有少数几个

537
00:16:00,416 --> 0:16:02,366
可供顾客使用的交互

538
00:16:02,366 --> 0:16:04,156
但是当这些功能同时发生时

539
00:16:04,156 --> 0:16:07,516
会产生混乱

540
00:16:08,306 --> 0:16:11,536
我们可以看到

541
00:16:11,536 --> 0:16:12,936
即便是这么少的系列动作

542
00:16:13,596 --> 0:16:14,806
它们同时发生也会导致

543
00:16:14,806 --> 0:16:15,676
很多不同 App 的状态变化

544
00:16:15,676 --> 0:16:18,776
对我们而言最糟糕的是

545
00:16:18,776 --> 0:16:21,826
出现像这样的用户体验

546
00:16:22,696 --> 0:16:25,336
这些部分完整性的概念

547
00:16:25,336 --> 0:16:26,196
对于用户没有意义

548
00:16:26,196 --> 0:16:28,156
事实上 这对我们也没有意义

549
00:16:29,816 --> 0:16:30,836
在这里 核心数据将帮助我们

550
00:16:30,886 --> 0:16:32,676
处理查询生成

551
00:16:33,066 --> 0:16:36,556
在 2016 年的核心数据新品介绍会议上

552
00:16:36,556 --> 0:16:37,656
我们介绍了查询生成

553
00:16:38,116 --> 0:16:39,076
如果你还不了解它

554
00:16:39,076 --> 0:16:40,286
我非常建议你

555
00:16:40,286 --> 0:16:41,516
了解一下那场会议

556
00:16:41,516 --> 0:16:42,806
并获得更多

557
00:16:42,806 --> 0:16:43,356
有关它如何工作的信息

558
00:16:43,996 --> 0:16:45,626
你需要知道的是

559
00:16:45,886 --> 0:16:47,506
它需要预写日志模式

560
00:16:47,606 --> 0:16:48,786
并且只能使用 SQLite

561
00:16:49,906 --> 0:16:51,746
查询生成的目标是

562
00:16:51,746 --> 0:16:53,186
将你的托管对象上下文 

563
00:16:53,186 --> 0:16:54,896
从相互矛盾的工作中隔离出来

564
00:16:55,346 --> 0:16:56,406
它可能直接作用于后台

565
00:16:56,406 --> 0:16:58,566
或者你还没有准备在

566
00:16:58,566 --> 0:17:00,176
给定文本中显示的

567
00:16:58,566 --> 0:17:00,176
给定文本中显示的

568
00:17:00,176 --> 0:17:03,006
用户正在进行的行为

569
00:17:04,026 --> 0:17:05,286
查询生成提供了一个 

570
00:17:05,286 --> 0:17:07,026
数据库的一致而长久的视图

571
00:17:07,026 --> 0:17:08,806
它将向读取返回同样的结果

572
00:17:08,806 --> 0:17:10,435
无论在给定时间内

573
00:17:10,435 --> 0:17:11,606
数据库被写入

574
00:17:11,606 --> 0:17:14,165
何种其它的上下文

575
00:17:17,415 --> 0:17:19,695
最好的是我们可以通过

576
00:17:19,695 --> 0:17:20,816
一行代码来实现它

577
00:17:21,715 --> 0:17:23,116
这里是重新加载一个表格视图的

578
00:17:23,116 --> 0:17:24,256
典型变化

579
00:17:24,675 --> 0:17:26,626
我们可以仅仅对 NSManagedObjectContext

580
00:17:26,626 --> 0:17:28,496
setQueryGenerationFrom

581
00:17:28,496 --> 0:17:31,276
增加一个带有现有查询生成

582
00:17:31,276 --> 0:17:31,966
的调用

583
00:17:33,456 --> 0:17:34,746
需要更新时

584
00:17:34,746 --> 0:17:37,206
我们可以像往常一样

585
00:17:37,206 --> 0:17:40,056
使用 NSMangedObjectContextDidSave 提醒

586
00:17:40,056 --> 0:17:40,766
来进行更新

587
00:17:41,236 --> 0:17:45,806
这使我们可以在对的时间 在 UI 里 

588
00:17:45,806 --> 0:17:48,876
对 App 的数据实现修改

589
00:17:52,096 --> 0:17:53,536
但是如果我们写的数据

590
00:17:53,536 --> 0:17:54,986
和 UI 没有关联呢

591
00:17:55,676 --> 0:17:56,716
例如下载之前

592
00:17:56,716 --> 0:17:58,466
Scott 提到的一些评论

593
00:17:59,556 --> 0:18:02,046
这种情况下

594
00:17:59,556 --> 0:18:02,046
这种情况下

595
00:18:02,046 --> 0:18:03,406
我们不希望数据出现在用户界面里

596
00:18:03,406 --> 0:18:05,716
或者对它产生更改

597
00:18:05,716 --> 0:18:06,776
因为所有的变化对用户

598
00:18:06,776 --> 0:18:07,996
都是不可视的

599
00:18:08,526 --> 0:18:09,876
我们需要通过使用

600
00:18:09,876 --> 0:18:11,976
历史追踪 来过滤掉这些更新

601
00:18:12,786 --> 0:18:14,276
持续历史追踪是

602
00:18:14,276 --> 0:18:17,456
iOS 11 和 macOS 10.13 的新功能

603
00:18:18,206 --> 0:18:19,996
我们在去年的全球开发者大会中的

604
00:18:19,996 --> 0:18:22,036
核心数据的新功能部分

605
00:18:22,116 --> 0:18:23,526
对它进行过介绍

606
00:18:23,526 --> 0:18:24,866
要想了解更多它如何工作

607
00:18:24,866 --> 0:18:26,626
或者它们重点功能是什么的信息

608
00:18:26,626 --> 0:18:27,866
你可以将这个会议

609
00:18:28,516 --> 0:18:29,566
作为参考

610
00:18:31,966 --> 0:18:33,406
持续历史追踪是一个

611
00:18:33,406 --> 0:18:35,526
获得每次与数据库相关的

612
00:18:35,526 --> 0:18:38,926
事务处理的记录的好方式

613
00:18:38,926 --> 0:18:40,026
对我们很有用

614
00:18:40,026 --> 0:18:41,186
有几点原因

615
00:18:41,756 --> 0:18:43,506
为了本次演讲

616
00:18:43,506 --> 0:18:45,626
我们将使用 NSPersistentHistoryChange

617
00:18:45,796 --> 0:18:47,926
它能给我们一个 changedObjectID 

618
00:18:48,576 --> 0:18:52,546
和一组 updatedProperties

619
00:18:53,036 --> 0:18:53,176
还有 NSPersistentHistoryTransaction

620
00:18:53,296 --> 0:18:55,036
它将给我们一组变化

621
00:18:55,686 --> 0:18:59,136
以及一个 objectIDNotification

622
00:19:01,396 --> 0:19:05,176
我们来想一下

623
00:19:05,176 --> 0:19:06,036
接下来的变化

624
00:19:06,776 --> 0:19:08,236
就像你所看到的

625
00:19:08,236 --> 0:19:09,376
有一些帖子被加入到了数据库中

626
00:19:09,376 --> 0:19:12,436
当这件事发生时

627
00:19:12,806 --> 0:19:14,206
用表格视图来说

628
00:19:14,206 --> 0:19:17,046
我们可以通过使用

629
00:19:17,046 --> 0:19:18,346
objectIDNotification

630
00:19:18,346 --> 0:19:19,726
来更新 UI

631
00:19:20,296 --> 0:19:21,356
这和 NSManageObjectContextDidSave 

632
00:19:21,486 --> 0:19:25,076
提醒相似 它可以通过使用同一的 API

633
00:19:25,076 --> 0:19:26,586
来进行合并

634
00:19:29,756 --> 0:19:31,186
如果我们下载了一个

635
00:19:31,186 --> 0:19:33,516
我们不希望在用户更新里显示的

636
00:19:33,516 --> 0:19:35,406
评论列表

637
00:19:35,976 --> 0:19:39,936
我们可以对它进行过滤

638
00:19:40,146 --> 0:19:41,556
用少量的代码

639
00:19:41,616 --> 0:19:42,826
我们可以从给定的事务处理中

640
00:19:42,826 --> 0:19:44,046
将变化过滤出去

641
00:19:44,046 --> 0:19:45,086
以决定它们中是否有与帖子实体有关的变化

642
00:19:45,086 --> 0:19:47,306
这样我们就不需要更新 UI

643
00:19:48,876 --> 0:19:50,916
从而为用户引起

644
00:19:50,916 --> 0:19:53,876
不必要的波动

645
00:19:53,976 --> 0:19:55,276
或断续

646
00:19:56,256 --> 0:19:57,436
就像你在这里看到的

647
00:19:57,436 --> 0:19:58,906
我们使用的是

648
00:19:58,906 --> 0:20:00,496
小部分的帖子内容

649
00:19:58,906 --> 0:20:00,496
小部分的帖子内容

650
00:20:01,246 --> 0:20:03,276
事实上 我们只使用了

651
00:20:03,276 --> 0:20:05,906
两个属性 图像和标题属性

652
00:20:07,406 --> 0:20:08,606
我们可以有比

653
00:20:08,606 --> 0:20:10,126
通过实体过滤更好的方式

654
00:20:10,416 --> 0:20:12,216
事实上我们可以通过使用

655
00:20:12,216 --> 0:20:13,606
历史变化来对更新的属性进行过滤

656
00:20:13,606 --> 0:20:17,416
这样 我们就可以针对 

657
00:20:17,416 --> 0:20:19,026
与用户可以看到的变化一致

658
00:20:19,476 --> 0:20:20,666
的用户体验

659
00:20:20,666 --> 0:20:21,916
创建目标性很强的更新

660
00:20:22,546 --> 0:20:27,526
核心数据还可以支持

661
00:20:28,146 --> 0:20:29,846
你与你的用户

662
00:20:29,846 --> 0:20:30,446
进行新的交互

663
00:20:31,336 --> 0:20:32,446
当你的数据逐渐变得

664
00:20:32,446 --> 0:20:35,216
更复杂更庞大

665
00:20:35,216 --> 0:20:36,756
有些编辑操作

666
00:20:36,756 --> 0:20:37,346
会变得更昂贵

667
00:20:37,346 --> 0:20:39,546
例如一个简单的

668
00:20:39,546 --> 0:20:40,466
图片浏览器

669
00:20:41,206 --> 0:20:42,796
一般来说

670
00:20:42,796 --> 0:20:44,386
当我们的 App 扩张时

671
00:20:44,386 --> 0:20:45,976
我们希望引进新的

672
00:20:45,976 --> 0:20:47,276
能让反复作业更加简单的功能

673
00:20:47,276 --> 0:20:50,136
比如 多项选择

674
00:20:50,506 --> 0:20:53,236
核心数据可以通过分批操作

675
00:20:53,266 --> 0:20:54,826
来支持这个功能

676
00:20:55,976 --> 0:20:57,946
事实上 通过几行代码

677
00:20:57,946 --> 0:20:59,436
我们就能对整组图片

678
00:20:59,436 --> 0:21:02,826
标记喜欢或不喜欢

679
00:20:59,436 --> 0:21:02,826
标记喜欢或不喜欢

680
00:21:03,596 --> 0:21:05,376
通过一行代码

681
00:21:05,376 --> 0:21:07,046
我们可以使用分批删除

682
00:21:07,046 --> 0:21:09,706
将记录从数据库里清除

683
00:21:09,976 --> 0:21:12,256
这种行为规模

684
00:21:12,256 --> 0:21:14,716
不可能将对象

685
00:21:14,716 --> 0:21:15,096
分解进内存

686
00:21:15,886 --> 0:21:19,556
举个例子 在删除过程中

687
00:21:19,556 --> 0:21:22,306
传统的调用 NSManagedObject.delete 将使

688
00:21:22,446 --> 0:21:24,836
数据库中记录的大小增加

689
00:21:24,906 --> 0:21:26,116
当你删除对象时

690
00:21:26,116 --> 0:21:27,336
你的内存被分解到上下文中

691
00:21:27,336 --> 0:21:29,436
你的数据库越大

692
00:21:29,436 --> 0:21:32,086
它就越贵

693
00:21:32,716 --> 0:21:34,036
但是通过分批操作

694
00:21:34,036 --> 0:21:36,106
我们可以在一小部分内存里

695
00:21:36,106 --> 0:21:37,706
进行同样的变化

696
00:21:38,276 --> 0:21:39,716
它有我们想要的曲线关系

697
00:21:39,716 --> 0:21:42,756
即当数据增加时

698
00:21:42,756 --> 0:21:44,626
数据集越大

699
00:21:44,626 --> 0:21:46,976
我们使用的内存越小

700
00:21:46,976 --> 0:21:48,696
删除 1000 万行

701
00:21:48,696 --> 0:21:50,606
我们只需用到

702
00:21:50,606 --> 0:21:51,156
传统内存的 7%

703
00:21:52,556 --> 0:21:54,076
这是一个

704
00:21:54,076 --> 0:21:55,296
节约你的用户设备内存的

705
00:21:55,296 --> 0:21:57,066
有力方式

706
00:21:57,956 --> 0:21:59,176
但是分批操作的

707
00:21:59,176 --> 0:22:00,976
一个传统问题是

708
00:21:59,176 --> 0:22:00,976
一个传统问题是

709
00:22:01,596 --> 0:22:02,776
很难操作

710
00:22:02,776 --> 0:22:03,926
因为它不生成

711
00:22:03,926 --> 0:22:05,606
存储提醒

712
00:22:06,376 --> 0:22:07,426
这里就是把历史追踪功能

713
00:22:07,426 --> 0:22:08,176
引回来的部分

714
00:22:09,026 --> 0:22:10,016
使用持续历史追踪

715
00:22:10,016 --> 0:22:11,306
我们可以将

716
00:22:11,306 --> 0:22:12,846
分组删除或者更新的处理

717
00:22:13,286 --> 0:22:14,266
从数据库中分离出来

718
00:22:14,266 --> 0:22:17,156
我们可以使用 objectIDNotification 方法

719
00:22:17,156 --> 0:22:18,996
来生成一个提醒

720
00:22:18,996 --> 0:22:21,676
让它像存储提醒

721
00:22:21,676 --> 0:22:22,866
那样工作

722
00:22:23,386 --> 0:22:24,786
这样 读取结果控制器或者

723
00:22:24,786 --> 0:22:26,666
其他在你的 App 中的上下文就可以

724
00:22:26,666 --> 0:22:29,846
渐增式地更新

725
00:22:29,846 --> 0:22:30,656
这些提醒了

726
00:22:31,226 --> 0:22:35,546
所以这些是你能

727
00:22:35,546 --> 0:22:37,016
管理逐渐增加的数据的方式

728
00:22:37,016 --> 0:22:40,586
但是工作流程自身呢

729
00:22:40,966 --> 0:22:43,396
核心数据可以为开发者和程序员

730
00:22:43,396 --> 0:22:45,426
做些什么

731
00:22:45,426 --> 0:22:46,886
来使构建和测试你的 App 变得

732
00:22:46,886 --> 0:22:47,726
更简单

733
00:22:49,166 --> 0:22:51,136
我们能做的第一件事就是

734
00:22:51,136 --> 0:22:52,286
帮助你感知未来

735
00:22:53,856 --> 0:22:55,576
你可能知道

736
00:22:55,576 --> 0:22:56,326
NSKeyedArchiver 是在变化的

737
00:22:57,056 --> 0:22:58,416
我们在所有平台上

738
00:22:58,416 --> 0:23:00,926
使用安全代码

739
00:22:58,416 --> 0:23:00,926
使用安全代码

740
00:23:01,016 --> 0:23:03,146
今年 KeyedArchiver API 

741
00:23:03,146 --> 0:23:04,596
的剧烈变化

742
00:23:04,596 --> 0:23:05,436
也证实了这一点

743
00:23:06,496 --> 0:23:07,786
对于核心数据来说

744
00:23:07,786 --> 0:23:09,586
这意味着数值转换器是变化的

745
00:23:09,586 --> 0:23:11,066
所以如果在你的托管对象模型中

746
00:23:11,066 --> 0:23:13,086
有一个可转换的属性

747
00:23:13,086 --> 0:23:14,916
而你今天没有发送数值转换器

748
00:23:14,916 --> 0:23:16,876
你将与默认的

749
00:23:16,876 --> 0:23:17,836
数值转换器一样

750
00:23:18,036 --> 0:23:20,696
从 DataTransformer 得到

751
00:23:20,936 --> 0:23:22,316
NSKeyedUnarchive

752
00:23:22,916 --> 0:23:25,616
在未来 你将从 DataTransformer 

753
00:23:25,736 --> 0:23:28,196
得到 NSSecureUnarchive

754
00:23:28,196 --> 0:23:29,496
它在内部执行安全代码

755
00:23:29,496 --> 0:23:31,576
各位应该在今天就采用它

756
00:23:32,176 --> 0:23:33,416
今天早上有一场非常棒的演讲

757
00:23:33,416 --> 0:23:35,496
名为可以信赖的数据

758
00:23:36,976 --> 0:23:38,216
我强烈建议各位

759
00:23:38,636 --> 0:23:40,006
看看这个演讲

760
00:23:40,006 --> 0:23:41,666
并对安全代码和

761
00:23:41,666 --> 0:23:43,496
如何将你的 App 的适应力

762
00:23:43,496 --> 0:23:44,706
变得更强

763
00:23:44,706 --> 0:23:45,146
有更多的了解

764
00:23:48,246 --> 0:23:49,356
你可以在数值转换器名称字段里

765
00:23:49,356 --> 0:23:50,266
通过使用

766
00:23:50,266 --> 0:23:52,976
带有可转换属性的模型编辑器

767
00:23:52,976 --> 0:23:54,766
来指定它

768
00:23:55,716 --> 0:23:59,676
今天 我希望各位可以自己执行它

769
00:24:00,146 --> 0:24:01,566
在未来的版本中

770
00:24:01,566 --> 0:24:03,506
它将成为默认项

771
00:24:03,506 --> 0:24:04,986
在未来的 Xcode 版本中

772
00:24:04,986 --> 0:24:06,266
它也将向使用

773
00:24:06,266 --> 0:24:07,886
默认转换器名称的用户

774
00:24:07,886 --> 0:24:08,706
发出警示

775
00:24:10,036 --> 0:24:10,956
如果你在用代码

776
00:24:10,956 --> 0:24:13,056
构建模型 你可以通过使用 NSAttribute

777
00:24:13,056 --> 0:24:15,996
介绍上的 valueTransformerName 属性

778
00:24:15,996 --> 0:24:16,416
来对它进行设置

779
00:24:17,726 --> 0:24:19,046
如果你不是在编码自定义类类型

780
00:24:19,046 --> 0:24:21,176
那么这对你来说

781
00:24:21,176 --> 0:24:22,256
是很显而易见的

782
00:24:22,296 --> 0:24:23,926
对于 plist 类型

783
00:24:23,926 --> 0:24:24,306
这是一个无指令操作

784
00:24:24,756 --> 0:24:25,806
你只需要简单的更改

785
00:24:25,806 --> 0:24:27,336
数值转换器名称

786
00:24:27,336 --> 0:24:28,726
就能得到新的安全编码行为

787
00:24:29,286 --> 0:24:30,856
但如果你使用了自定义类

788
00:24:30,856 --> 0:24:32,456
这些类则需要采用安全代码

789
00:24:32,456 --> 0:24:34,786
你可以到实验室来

790
00:24:34,846 --> 0:24:37,616
向我们寻求帮助

791
00:24:38,296 --> 0:24:40,486
但我们其实可以帮你更多

792
00:24:41,286 --> 0:24:42,866
在核心数据里

793
00:24:43,066 --> 0:24:44,726
多年来我们花时间

794
00:24:45,026 --> 0:24:46,566
构建新的调试工具

795
00:24:46,566 --> 0:24:47,796
能够帮助你理解

796
00:24:47,796 --> 0:24:48,236
在堆栈下发生的事

797
00:24:49,026 --> 0:24:52,536
这是我们更喜欢的 默认方案配置

798
00:24:52,866 --> 0:24:54,686
我们有一些过程参数

799
00:24:54,686 --> 0:24:56,396
能帮助你获得更多关于 SQLite 的

800
00:24:56,396 --> 0:24:57,386
调试信息

801
00:24:57,386 --> 0:25:00,746
但是 有一个你需要永远记得运行的

802
00:24:57,386 --> 0:25:00,746
但是 有一个你需要永远记得运行的

803
00:25:00,746 --> 0:25:02,566
是 com.Apple.Core 

804
00:25:02,566 --> 0:25:04,066
和 Data.ConcurrencyDebug.

805
00:25:04,616 --> 0:25:06,266
它将抓取你的 App 中

806
00:25:06,266 --> 0:25:07,746
任何的队列异常

807
00:25:07,746 --> 0:25:09,396
从主队列和后台队列上下文之间

808
00:25:09,396 --> 0:25:10,766
你可能进行

809
00:25:10,766 --> 0:25:14,066
传输的地方 或者

810
00:25:14,066 --> 0:25:15,566
不遵循托管对象的

811
00:25:15,566 --> 0:25:18,666
真实上下文的地方

812
00:25:18,746 --> 0:25:20,466
SQLite 也有很多

813
00:25:20,466 --> 0:25:21,506
有趣的环境变量

814
00:25:21,506 --> 0:25:23,206
所以它们的线程和

815
00:25:23,206 --> 0:25:24,756
文件的断言函数

816
00:25:24,756 --> 0:25:25,836
能很好地

817
00:25:25,836 --> 0:25:27,286
保证你的 App 中

818
00:25:27,286 --> 0:25:29,746
的 API 以及文件系统的正确率

819
00:25:30,576 --> 0:25:32,386
自动追踪是一种使你

820
00:25:32,386 --> 0:25:33,496
看到内部发生了什么的好方法

821
00:25:33,496 --> 0:25:34,826
是一个对调试日志的

822
00:25:34,826 --> 0:25:36,046
追加行程

823
00:25:36,856 --> 0:25:39,646
com.Apple.CoreData.SQLDebug

824
00:25:39,646 --> 0:25:40,676
有四个层级

825
00:25:41,106 --> 0:25:43,206
第一层级是最有趣的

826
00:25:43,206 --> 0:25:44,636
也是系统还原备份

827
00:25:44,636 --> 0:25:45,466
最少的

828
00:25:45,466 --> 0:25:47,826
第四层是最冗长的

829
00:25:47,826 --> 0:25:49,126
但是在运行过程中

830
00:25:49,126 --> 0:25:51,006
产生大量的

831
00:25:51,006 --> 0:25:53,726
系统还原备份

832
00:25:53,996 --> 0:25:55,696
当你启用 SQL 调试

833
00:25:55,806 --> 0:25:57,146
和多线程断言时

834
00:25:57,146 --> 0:25:58,476
你会在控制台中看到

835
00:25:58,506 --> 0:26:00,456
几个运行记录

836
00:25:58,506 --> 0:26:00,456
几个运行记录

837
00:26:00,456 --> 0:26:01,356
它们象征着

838
00:26:01,356 --> 0:26:02,526
断言函数能够

839
00:26:02,526 --> 0:26:03,366
正确运行

840
00:26:04,636 --> 0:26:06,076
当我们使用 SQL debugging 时

841
00:26:06,076 --> 0:26:07,456
你将可以看到例如

842
00:26:07,456 --> 0:26:08,656
读取请求的选择语句

843
00:26:08,656 --> 0:26:10,866
以及它需要花费多长时间

844
00:26:11,706 --> 0:26:13,016
如果你被设置为第四级

845
00:26:13,016 --> 0:26:14,766
你甚至会得到 explain

846
00:26:15,026 --> 0:26:16,056
向你展示

847
00:26:16,056 --> 0:26:17,836
给定的选择语句的

848
00:26:18,186 --> 0:26:19,016
查询计划

849
00:26:19,586 --> 0:26:20,936
在这里我们能看到

850
00:26:20,936 --> 0:26:23,786
我们的表格视图通过 

851
00:26:23,786 --> 0:26:25,856
表扫描进行筛选

852
00:26:25,856 --> 0:26:27,866
然后按照时间戳的顺序

853
00:26:27,866 --> 0:26:29,646
使用内存中的 B 树

854
00:26:30,536 --> 0:26:31,876
这是个潜在的性能问题

855
00:26:31,876 --> 0:26:33,766
当你在运行你的 App 时

856
00:26:33,766 --> 0:26:35,006
你可以使用这样的

857
00:26:35,006 --> 0:26:37,116
信息来看

858
00:26:37,116 --> 0:26:38,506
你是否做了比你所需要的做的

859
00:26:38,506 --> 0:26:39,086
更多的工作

860
00:26:40,346 --> 0:26:41,496
所以 我们该怎么修正它

861
00:26:42,946 --> 0:26:45,816
事实上我们发现 

862
00:26:45,816 --> 0:26:46,776
SQLite3 可以告诉我们

863
00:26:47,476 --> 0:26:49,166
如果我们打开一个数据库

864
00:26:49,166 --> 0:26:50,696
将我们的 SQL 日志里的选择查询传递给它

865
00:26:50,696 --> 0:26:52,926
我们就能够启动一个

866
00:26:52,926 --> 0:26:54,616
成为 Expert 的模式

867
00:26:54,616 --> 0:26:56,396
它能够对队列进行分析

868
00:26:56,436 --> 0:26:58,616
然后通过创建覆盖索引

869
00:26:58,616 --> 0:27:00,366
给出合适的优化方案

870
00:26:58,616 --> 0:27:00,366
给出合适的优化方案

871
00:27:01,366 --> 0:27:02,606
如果我们能通过

872
00:27:02,606 --> 0:27:05,256
对发布实体增加读取索引

873
00:27:05,576 --> 0:27:06,416
来在模型编辑器里做这件事

874
00:27:07,066 --> 0:27:10,216
这里我已经将它配置在时间戳上

875
00:27:10,216 --> 0:27:12,676
将它们以递减的顺序调出

876
00:27:12,676 --> 0:27:13,786
我们将最近的帖子

877
00:27:13,786 --> 0:27:15,526
展示在表格视图的最上端

878
00:27:17,676 --> 0:27:19,106
当我们再次运行 App 时

879
00:27:19,106 --> 0:27:20,976
我们会看到同样的选择日志

880
00:27:24,386 --> 0:27:26,546
除了这一次

881
00:27:26,546 --> 0:27:27,876
我们看到选择查询 

882
00:27:27,876 --> 0:27:29,616
在查询中达到了覆盖索引

883
00:27:30,126 --> 0:27:31,726
解释命令告诉我们

884
00:27:31,726 --> 0:27:38,296
查询将使用覆盖索引进行排序

885
00:27:38,536 --> 0:27:39,966
核心数据支持很多类型的索引

886
00:27:39,966 --> 0:27:43,356
包括使用 R 树的符合索引

887
00:27:43,906 --> 0:27:45,646
这对创建

888
00:27:45,646 --> 0:27:47,346
任何类型的查询

889
00:27:47,346 --> 0:27:49,806
或者在选择语句里 

890
00:27:50,406 --> 0:27:51,536
使用边界框的优化查询都很有用

891
00:27:52,196 --> 0:27:53,386
最常见的用途是为了定位

892
00:27:53,426 --> 0:27:55,216
我们可以通过向发布实体

893
00:27:55,216 --> 0:27:57,396
增加另一个索引来对它进行设置

894
00:27:57,396 --> 0:27:58,876
为了展示这张幻灯片

895
00:27:58,876 --> 0:28:00,396
我添加了

896
00:27:58,876 --> 0:28:00,396
我添加了

897
00:28:00,396 --> 0:28:02,536
经纬度属性

898
00:28:04,816 --> 0:28:06,836
我们通过选择 R 树

899
00:28:06,836 --> 0:28:08,246
更改了盒子里的查询类型

900
00:28:08,796 --> 0:28:10,836
我们可以在读取请求上

901
00:28:10,836 --> 0:28:12,556
设置谓词

902
00:28:13,206 --> 0:28:14,906
然后获得所有

903
00:28:14,906 --> 0:28:16,516
在中国大陆境内发布的帖子

904
00:28:18,406 --> 0:28:20,186
这种谓词比较高级

905
00:28:20,186 --> 0:28:21,656
因为它使用

906
00:28:21,716 --> 0:28:24,306
实际选择语句里的功能

907
00:28:24,306 --> 0:28:26,256
来找到 

908
00:28:26,256 --> 0:28:27,676
我们在托管对象模型里

909
00:28:27,676 --> 0:28:28,676
创建的索引

910
00:28:31,556 --> 0:28:33,266
我们在没有这个索引和谓词的情况下

911
00:28:33,266 --> 0:28:35,016
运行 App

912
00:28:35,016 --> 0:28:36,596
可以看到和我们之前

913
00:28:36,596 --> 0:28:38,266
仅使用时间戳索引

914
00:28:38,726 --> 0:28:41,826
得到的结果是相同的

915
00:28:42,366 --> 0:28:44,956
但是当我们在没有

916
00:28:44,956 --> 0:28:47,196
新的索引和谓词的情况下运行时

917
00:28:47,196 --> 0:28:48,956
SQLite 会使用索引来

918
00:28:48,956 --> 0:28:51,626
为两个语句

919
00:28:51,626 --> 0:28:53,056
生成更快速的结果

920
00:28:55,026 --> 0:28:56,806
不幸的是

921
00:28:56,806 --> 0:28:58,446
我们的时间戳索引没有

922
00:28:58,446 --> 0:28:59,656
任何的复合谓词

923
00:28:59,976 --> 0:29:01,566
SQLite 不能用它

924
00:28:59,976 --> 0:29:01,566
SQLite 不能用它

925
00:29:01,566 --> 0:29:02,006
来进行排序

926
00:29:02,556 --> 0:29:04,776
我们在这里选择的优化

927
00:29:04,776 --> 0:29:07,216
是使用复合索引

928
00:29:07,216 --> 0:29:08,636
首先过滤掉更小的对象组

929
00:29:08,636 --> 0:29:11,676
然后用内存中的 B 树

930
00:29:11,676 --> 0:29:13,736
来进行排序

931
00:29:14,336 --> 0:29:18,536
就像各位看到的

932
00:29:18,536 --> 0:29:20,186
这个索引将我们的读取性能

933
00:29:20,186 --> 0:29:22,286
提高了 25%

934
00:29:23,986 --> 0:29:25,256
这种情况下

935
00:29:25,256 --> 0:29:27,066
性能测试是运行大概 100,000 行

936
00:29:27,066 --> 0:29:29,726
我们看到

937
00:29:29,726 --> 0:29:31,616
仅对于读取函数而言

938
00:29:31,616 --> 0:29:33,036
就有了 130 毫秒的提高

939
00:29:34,476 --> 0:29:35,876
这就引出了我的下一个话题

940
00:29:36,196 --> 0:29:37,466
核心数据的测试

941
00:29:38,646 --> 0:29:40,716
正如各位所知

942
00:29:40,716 --> 0:29:41,086
我们非常喜欢测试

943
00:29:41,656 --> 0:29:42,476
测试很棒

944
00:29:43,026 --> 0:29:45,156
在核心数据里

945
00:29:45,156 --> 0:29:46,686
我们在内部既使用它们检测正确性

946
00:29:46,686 --> 0:29:48,476
又使用它们学习

947
00:29:48,906 --> 0:29:49,826
核心数据的功能

948
00:29:49,826 --> 0:29:51,026
以及 API 

949
00:29:51,026 --> 0:29:54,406
在给定的条件下的行为

950
00:29:55,316 --> 0:29:56,326
同时也能很好地

951
00:29:56,326 --> 0:29:58,876
验证你关于核心数据的工作

952
00:29:58,986 --> 0:30:00,806
以及它将如何在你的 App 中

953
00:29:58,986 --> 0:30:00,806
以及它将如何在你的 App 中

954
00:30:00,806 --> 0:30:02,916
帮助你的顾客获得

955
00:30:02,916 --> 0:30:03,716
更好的体验

956
00:30:04,266 --> 0:30:05,316
就像各位在前一个例子中看到的

957
00:30:05,316 --> 0:30:06,916
我们能够验证

958
00:30:06,916 --> 0:30:08,966
R 树索引可以

959
00:30:08,966 --> 0:30:10,456
优化性能

960
00:30:10,456 --> 0:30:11,466
虽然它使用的是内存里的

961
00:30:11,466 --> 0:30:12,186
B 树排序

962
00:30:14,276 --> 0:30:16,136
但同样能捕捉到你的产品需求

963
00:30:16,136 --> 0:30:17,686
在核心数据里

964
00:30:17,686 --> 0:30:19,456
这对我们十分重要

965
00:30:19,456 --> 0:30:20,896
因为它能帮助我们

966
00:30:20,896 --> 0:30:22,296
与你的期望沟通

967
00:30:22,786 --> 0:30:24,026
通过测试

968
00:30:24,026 --> 0:30:25,566
我们可以看到你在用代码做什么

969
00:30:25,566 --> 0:30:27,296
以及你希望这些代码

970
00:30:27,296 --> 0:30:28,546
如何服务你的顾客

971
00:30:29,686 --> 0:30:30,816
你可以设置一些重要的东西

972
00:30:30,816 --> 0:30:31,976
使你的工作更容易一些

973
00:30:31,976 --> 0:30:36,196
比如 能够生成持久化容器的

974
00:30:36,196 --> 0:30:37,236
基础类别

975
00:30:38,406 --> 0:30:39,926
屏幕上的基础类别

976
00:30:39,926 --> 0:30:41,856
为持久化存储使用了

977
00:30:41,856 --> 0:30:43,426
/dev/null 的文件 URL

978
00:30:43,426 --> 0:30:45,316
这是一种很好的测试方式

979
00:30:45,316 --> 0:30:48,506
它对一小部分的托管对象起作用

980
00:30:48,506 --> 0:30:50,446
且运行十分迅速

981
00:30:50,446 --> 0:30:52,076
因为它们将在整个内存里运行

982
00:30:52,776 --> 0:30:54,726
当你这样做时

983
00:30:54,726 --> 0:30:56,306
SQLite 实现了一个内存中的存储

984
00:30:56,306 --> 0:30:57,866
非常高效

985
00:30:57,866 --> 0:30:59,596
但是因为是在内存里

986
00:30:59,596 --> 0:31:00,756
如果你有很多数据

987
00:30:59,596 --> 0:31:00,756
如果你有很多数据

988
00:31:00,756 --> 0:31:03,536
会导致你的测试套件中

989
00:31:03,976 --> 0:31:04,146
内存大量增长

990
00:31:07,616 --> 0:31:11,676
不过 你需要完成至少一次测试

991
00:31:11,676 --> 0:31:13,506
在磁盘上将存储文件具体化

992
00:31:14,026 --> 0:31:15,746
这是因为

993
00:31:15,746 --> 0:31:16,806
如果不能为了

994
00:31:16,806 --> 0:31:18,316
你的测试打开存储

995
00:31:18,316 --> 0:31:19,436
那你的顾客也打不开

996
00:31:21,076 --> 0:31:22,546
如果持久化容器

997
00:31:22,546 --> 0:31:24,156
在 App 代理里

998
00:31:24,156 --> 0:31:25,506
你会有一个测试基类

999
00:31:25,506 --> 0:31:26,866
能将容器取出

1000
00:31:26,866 --> 0:31:28,506
然后直接写入内存

1001
00:31:29,296 --> 0:31:31,496
不过当你这样做时

1002
00:31:31,496 --> 0:31:33,086
我必须提醒你

1003
00:31:33,086 --> 0:31:34,106
因为这意味着

1004
00:31:34,106 --> 0:31:35,566
你在写入一个

1005
00:31:35,566 --> 0:31:37,776
被 App 使用的内存文件

1006
00:31:37,776 --> 0:31:38,916
所以如果你在个人设备上

1007
00:31:38,916 --> 0:31:40,646
运行测试

1008
00:31:40,646 --> 0:31:42,006
你将在下次打开 App 的时候

1009
00:31:42,006 --> 0:31:47,316
看到你单元测试的结果

1010
00:31:47,536 --> 0:31:48,446
如果我告诉你

1011
00:31:48,446 --> 0:31:50,316
我能用 7 行代码

1012
00:31:50,316 --> 0:31:51,236
添加 100,000 个记录呢

1013
00:31:53,806 --> 0:31:55,036
其实有一点作弊

1014
00:31:55,036 --> 0:31:56,356
我会把这个当做

1015
00:31:56,356 --> 0:31:58,556
留给观众的练习

1016
00:31:58,556 --> 0:31:59,946
但是这种方式的支架代码

1017
00:31:59,946 --> 0:32:01,306
可以帮助你构建一个

1018
00:31:59,946 --> 0:32:01,306
可以帮助你构建一个

1019
00:32:01,306 --> 0:32:02,556
测试套件

1020
00:32:02,556 --> 0:32:04,016
来评估你的数据的不变性

1021
00:32:04,976 --> 0:32:06,386
通过提前构建这些方法

1022
00:32:06,386 --> 0:32:08,496
当你的数据变化 或者你意识到 

1023
00:32:08,496 --> 0:32:09,876
你的 App 的新用例时

1024
00:32:09,876 --> 0:32:11,626
你可以通过迭代

1025
00:32:11,626 --> 0:32:13,486
来构建新的边界情况

1026
00:32:13,486 --> 0:32:14,756
来为对象图

1027
00:32:14,756 --> 0:32:15,826
构建新的结构

1028
00:32:15,826 --> 0:32:17,946
或者在内部

1029
00:32:17,946 --> 0:32:19,186
评估一些特定功能的行为

1030
00:32:19,186 --> 0:32:21,776
例如性能

1031
00:32:22,146 --> 0:32:25,606
这是我用来为

1032
00:32:25,606 --> 0:32:26,566
R 树查询

1033
00:32:26,566 --> 0:32:28,466
构建性能测试的单元测试支架

1034
00:32:29,176 --> 0:32:30,496
仅仅在几行代码中

1035
00:32:30,496 --> 0:32:32,456
我们可以对 

1036
00:32:32,456 --> 0:32:33,886
读取性能很有信心

1037
00:32:34,836 --> 0:32:36,286
这些类型的测试

1038
00:32:36,286 --> 0:32:37,466
信息量很大

1039
00:32:37,466 --> 0:32:38,996
当你尝试去评估

1040
00:32:38,996 --> 0:32:40,386
核心数据里

1041
00:32:40,386 --> 0:32:44,896
不一样的功能之间的权衡

1042
00:32:45,316 --> 0:32:46,576
这三行代码

1043
00:32:46,576 --> 0:32:47,936
生成了新的托管对象上下文

1044
00:32:47,936 --> 0:32:49,976
以及一个容器

1045
00:32:49,976 --> 0:32:50,946
供我们的测试使用

1046
00:32:51,756 --> 0:32:54,206
现在这点很重要

1047
00:32:54,206 --> 0:32:55,606
主要是因为在测试中

1048
00:32:55,606 --> 0:32:57,786
setup 和 teardown 方法的逻辑可以

1049
00:32:57,786 --> 0:32:59,066
对性能表现产生影响

1050
00:32:59,696 --> 0:33:01,196
所以需要注意分析

1051
00:32:59,696 --> 0:33:01,196
所以需要注意分析

1052
00:33:01,196 --> 0:33:02,836
你是否真的在测试

1053
00:33:02,836 --> 0:33:04,226
setup 方法

1054
00:33:04,226 --> 0:33:05,256
还是 teardown 方法

1055
00:33:05,256 --> 0:33:06,946
还是你在评估

1056
00:33:06,946 --> 0:33:08,216
查询命令的

1057
00:33:08,216 --> 0:33:09,626
实际运行性能

1058
00:33:10,556 --> 0:33:11,546
在你运行测试之后

1059
00:33:11,546 --> 0:33:14,046
你可以提交好的错误报告

1060
00:33:15,526 --> 0:33:17,346
我们喜欢错误

1061
00:33:17,346 --> 0:33:18,546
特别是从你们这里反馈的错误

1062
00:33:18,546 --> 0:33:19,796
因为我们在构建一个产品

1063
00:33:19,796 --> 0:33:20,606
希望它能帮助你构建你的 App 

1064
00:33:21,206 --> 0:33:26,486
但是 没有测试或示例 App

1065
00:33:26,486 --> 0:33:28,126
对我们而言是很难理解的

1066
00:33:28,126 --> 0:33:29,906
就像我前面提到的

1067
00:33:29,906 --> 0:33:30,696
它们不会

1068
00:33:30,696 --> 0:33:33,046
像结构良好的测试那样

1069
00:33:33,046 --> 0:33:35,206
捕捉你的产品需求和期待

1070
00:33:35,206 --> 0:33:37,366
事实上

1071
00:33:37,956 --> 0:33:39,716
一个连接到 Radar 的 App

1072
00:33:39,716 --> 0:33:41,756
如果有测试套装

1073
00:33:41,756 --> 0:33:43,526
哪怕是一个空的

1074
00:33:44,086 --> 0:33:46,186
带有一些 UI 的示例 App

1075
00:33:46,406 --> 0:33:48,436
能向我们解释你的问题

1076
00:33:48,436 --> 0:33:50,076
我们也能更快回复你

1077
00:33:50,236 --> 0:33:52,706
并告诉你该怎么做

1078
00:33:53,596 --> 0:33:55,106
它们同样能帮助我们分辨

1079
00:33:55,106 --> 0:33:56,616
我们后续修复的准确性

1080
00:33:57,066 --> 0:33:58,226
所以 如果你要填写一份错误报告

1081
00:33:58,226 --> 0:34:00,806
请花一点时间

1082
00:33:58,226 --> 0:34:00,806
请花一点时间

1083
00:34:00,806 --> 0:34:02,266
写一个测试给我们

1084
00:34:04,296 --> 0:34:05,476
这就是我今天要讲的所有内容

1085
00:34:05,956 --> 0:34:08,156
大家明天可以到实验室来找我们

1086
00:34:08,335 --> 0:34:10,946
我们会从下午 1:30 开始

1087
00:34:10,946 --> 0:34:13,315
在 7 号技术实验室

1088
00:34:13,315 --> 0:34:14,286
我也强烈建议大家

1089
00:34:14,286 --> 0:34:15,826
了解一下明天下午 3:20 在大厅 2 

1090
00:34:15,826 --> 0:34:17,585
举行的测试技巧与诀窍会议

1091
00:34:18,896 --> 0:34:19,906
谢谢

1092
00:34:20,507 --> 0:34:22,507
[ 掌声 ]
