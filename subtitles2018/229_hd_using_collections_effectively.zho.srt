1
00:00:17,451 --> 0:00:21,388
（高效使用集合 演讲229）

2
00:00:21,922 --> 0:00:22,923
早上好

3
00:00:23,991 --> 0:00:24,992
我叫Michael LeHew

4
00:00:25,092 --> 0:00:27,995
我在Apple Foundation团队

5
00:00:28,962 --> 0:00:31,465
今天我想谈一些

6
00:00:31,532 --> 0:00:34,268
你应该知道的事

7
00:00:34,334 --> 0:00:35,636
在Swift中使用集合

8
00:00:37,104 --> 0:00:39,006
今天我会讨论很多领域

9
00:00:39,339 --> 0:00:43,277
关于Swift中可用集合的

10
00:00:43,844 --> 0:00:45,812
我们将探索一些常见的误区

11
00:00:46,113 --> 0:00:48,048
以及如何避免它们

12
00:00:48,115 --> 0:00:50,250
我也将提供非常具体的建议

13
00:00:50,317 --> 0:00:52,553
关于何时该选择哪些特定集合

14
00:00:53,287 --> 0:00:54,288
让我们开始吧

15
00:00:54,988 --> 0:00:56,356
我想让你想象一个

16
00:00:57,758 --> 0:00:59,326
没有集合的世界

17
00:01:01,795 --> 0:01:03,797
在这个世界中

18
00:01:04,063 --> 0:01:05,432
但它仍然有熊

19
00:01:07,100 --> 0:01:08,702
但每次当我们需要另一只熊

20
00:01:09,870 --> 0:01:11,939
我们就需要定义另一个变量

21
00:01:12,005 --> 0:01:13,607
我们想对这些熊做些事情

22
00:01:13,674 --> 0:01:15,475
我们只能够重复自己

23
00:01:16,243 --> 0:01:17,311
很可怕 对吧

24
00:01:18,545 --> 0:01:21,448
但更糟的是

25
00:01:22,482 --> 0:01:24,451
但幸好我们是聪明的开发者

26
00:01:24,785 --> 0:01:26,520
我们可以用函数来解决这个问题

27
00:01:26,820 --> 0:01:29,690
我们煞费苦心地定义了

28
00:01:30,691 --> 0:01:33,427
使用这个函数与使用字典非常相似

29
00:01:33,627 --> 0:01:36,163
除了我们需要的那些动态功能

30
00:01:36,630 --> 0:01:37,965
但谁喜欢可变状态 对吧？

31
00:01:38,899 --> 0:01:41,268
但幸运的是

32
00:01:42,336 --> 0:01:44,805
值得庆幸的是

33
00:01:45,072 --> 0:01:47,741
以及用于定义它们的丰富的原生语法

34
00:01:49,576 --> 0:01:52,212
还有当我们迭代时

35
00:01:53,847 --> 0:01:55,949
或获取集合中的元素的API

36
00:01:57,584 --> 0:02:01,021
集合非常普遍并且共享如此多的

37
00:01:57,584 --> 0:02:01,021
集合非常普遍并且共享如此多的

38
00:02:01,088 --> 0:02:03,490
因此在Swift中

39
00:02:05,058 --> 0:02:07,027
毫不奇怪

40
00:02:08,161 --> 0:02:09,795
在Swift中 集合就是序列

41
00:02:09,863 --> 0:02:12,199
其中的元素可以以非破坏性的方式

42
00:02:12,366 --> 0:02:13,367
多次遍历

43
00:02:13,534 --> 0:02:15,802
并且其元素可以通过下标访问

44
00:02:16,103 --> 0:02:17,771
（COLLECTION协议）

45
00:02:17,838 --> 0:02:19,139
我们看看这是如何做到的

46
00:02:19,206 --> 0:02:21,808
考虑一下集合的抽象表示

47
00:02:21,875 --> 0:02:22,876
（集合存储元素）

48
00:02:22,943 --> 0:02:25,445
这可能是一个在连续内存中

49
00:02:25,646 --> 0:02:27,681
哈希表 红黑树

50
00:02:28,815 --> 0:02:30,918
链接、列表或你可以想象的

51
00:02:31,451 --> 0:02:34,154
重要的是它支持初始索引的概念

52
00:02:34,221 --> 0:02:35,489
其被称为起始索引

53
00:02:35,556 --> 0:02:36,723
（起始索引）

54
00:02:36,790 --> 0:02:39,726
它可以用来访问集合的初始元素

55
00:02:40,561 --> 0:02:41,562
它还有一个结束索引

56
00:02:41,628 --> 0:02:43,230
其标识集合的结束

57
00:02:43,297 --> 0:02:44,131
（结束索引）

58
00:02:44,198 --> 0:02:45,999
集合支持从其起始索引

59
00:02:46,133 --> 0:02:48,302
到结束索引之间遍历元素的能力

60
00:02:49,436 --> 0:02:51,038
它们可以多次进行这种遍历

61
00:02:51,438 --> 0:02:54,474
它们也支持使用下标来获取

62
00:02:54,541 --> 0:02:56,043
集合中的元素

63
00:02:56,109 --> 0:02:57,377
（SUBSCRIPT[INDEX]）

64
00:02:57,444 --> 0:02:58,812
我们看看它在代码中的样子

65
00:02:59,680 --> 0:03:01,715
的确 如果我们看一下集合的定义

66
00:02:59,680 --> 0:03:01,715
的确 如果我们看一下集合的定义

67
00:03:01,949 --> 0:03:03,750
它被声明为一个元素序列

68
00:03:04,852 --> 0:03:07,688
它还有一个关联类型称为Index

69
00:03:07,788 --> 0:03:08,989
其必须遵守

70
00:03:10,490 --> 0:03:12,659
它提供了一个下标来检索元素

71
00:03:12,793 --> 0:03:13,961
或使用该索引

72
00:03:14,695 --> 0:03:16,330
我们定义一个起始和结束索引

73
00:03:16,563 --> 0:03:18,498
以确定集合的范围

74
00:03:18,932 --> 0:03:22,202
最后 这里有一个

75
00:03:22,269 --> 0:03:24,638
可以让我们从一个索引

76
00:03:25,572 --> 0:03:27,508
最后这个函数非常重要

77
00:03:27,875 --> 0:03:30,077
因为它允许标准库

78
00:03:30,410 --> 0:03:32,679
通过强大的协议扩展来定义

79
00:03:32,946 --> 0:03:35,215
许多有用且强大的默认行为

80
00:03:35,415 --> 0:03:36,650
让我们看看其中的一些

81
00:03:37,518 --> 0:03:38,352
（协议扩展）

82
00:03:38,418 --> 0:03:39,820
当你遵守

83
00:03:39,887 --> 0:03:42,422
你可以访问各种丰富的功能

84
00:03:42,656 --> 0:03:46,059
如能够让你获取首尾元素的属性

85
00:03:46,360 --> 0:03:47,394
或识别集合大小

86
00:03:48,195 --> 0:03:49,963
或检查集合是否为空

87
00:03:50,397 --> 0:03:52,666
你还可以通过API

88
00:03:52,733 --> 0:03:54,234
来遍历集合元素

89
00:03:55,369 --> 0:03:58,172
及超有用的函数 如map

90
00:03:59,206 --> 0:04:01,108
我们还可以通过添加自己的扩展

91
00:03:59,206 --> 0:04:01,108
我们还可以通过添加自己的扩展

92
00:04:01,175 --> 0:04:02,576
来让集合更加强大

93
00:04:03,043 --> 0:04:03,911
（间隔元素）

94
00:04:03,977 --> 0:04:06,713
集合已经提供了遍历每个元素的方法

95
00:04:06,780 --> 0:04:10,584
但我想要一个函数

96
00:04:10,651 --> 0:04:12,519
即在遍历过程中跳过一些值

97
00:04:13,587 --> 0:04:15,989
我们将通过向集合添加扩展

98
00:04:16,055 --> 0:04:17,858
我们从方法签名开始

99
00:04:18,158 --> 0:04:19,793
我们称该函数为

100
00:04:19,860 --> 0:04:23,397
并且它将采用一个闭包

101
00:04:24,064 --> 0:04:25,766
我们得到迭代的边界

102
00:04:26,500 --> 0:04:29,403
并定义一个初始值为

103
00:04:29,469 --> 0:04:30,904
该变量值将随运行而改变

104
00:04:32,105 --> 0:04:34,174
我们在当前元素上调用闭包

105
00:04:34,441 --> 0:04:37,177
并递增我们的索引

106
00:04:37,911 --> 0:04:39,646
此时我们的索引可能已经无效

107
00:04:39,713 --> 0:04:40,848
即我们已到集合的最后

108
00:04:40,914 --> 0:04:42,916
因此我们需要确保检查它

109
00:04:43,250 --> 0:04:45,819
如果还没越界

110
00:04:46,353 --> 0:04:47,888
从而跳过间隔元素

111
00:04:48,355 --> 0:04:51,825
如果我们在1到10的封闭范围内

112
00:04:52,092 --> 0:04:54,261
可以看到我们跳过了偶数元素

113
00:04:55,929 --> 0:04:59,366
我们看到集合可以让我们

114
00:05:00,200 --> 0:05:02,102
但实际上集合并不孤单

115
00:05:02,436 --> 0:05:03,971
其实集合不是我们唯一的协议

116
00:05:04,037 --> 0:05:05,205
在Swift中 我们可以访问

117
00:05:05,272 --> 0:05:07,674
丰富的集合协议层次结构

118
00:05:07,741 --> 0:05:09,676
其中每个都对我们提供的类型假设

119
00:05:09,743 --> 0:05:11,345
做了极大改善

120
00:05:11,678 --> 0:05:13,247
让我们继续讨论其中一些协议

121
00:05:13,313 --> 0:05:14,615
（集合协议层次结构）

122
00:05:14,681 --> 0:05:18,318
我们知道集合可以让你

123
00:05:18,385 --> 0:05:19,586
（集合）

124
00:05:19,653 --> 0:05:21,455
但也存在双向集合

125
00:05:21,522 --> 0:05:23,323
它可以让你沿着另一个方向移动

126
00:05:23,390 --> 0:05:24,791
（双向集合）

127
00:05:24,858 --> 0:05:27,995
当然 双向集合也是集合

128
00:05:28,061 --> 0:05:29,997
所以我们仍然可以向前迭代

129
00:05:31,565 --> 0:05:33,367
下一个最灵活的集合形式

130
00:05:33,433 --> 0:05:35,302
就是所谓的随机访问集合

131
00:05:35,369 --> 0:05:39,239
它要求当根据某个索引计算另一个

132
00:05:39,306 --> 0:05:41,909
或计算两个索引之间的距离的时候

133
00:05:41,975 --> 0:05:44,111
所需的时间是常量

134
00:05:44,411 --> 0:05:46,346
编译器无法保证这一点

135
00:05:46,413 --> 0:05:48,515
所以当你使用随机访问集合时

136
00:05:48,582 --> 0:05:49,750
你正在作出一项承诺

137
00:05:50,517 --> 0:05:52,786
但如果你满足这个承诺

138
00:05:52,853 --> 0:05:54,021
这个协议就可以让你

139
00:05:54,087 --> 0:05:57,090
在常量时间内访问集合中的任何索引

140
00:05:57,991 --> 0:06:00,327
当然 随机访问集合仍然是集合

141
00:05:57,991 --> 0:06:00,327
当然 随机访问集合仍然是集合

142
00:06:00,394 --> 0:06:02,663
所以你仍然可以向前和向后迭代

143
00:06:02,729 --> 0:06:04,264
（随机访问集合）

144
00:06:04,331 --> 0:06:07,401
作为Swift开发人员

145
00:06:07,467 --> 0:06:08,702
许多有用的集合

146
00:06:10,237 --> 0:06:12,406
这类集合包括Array

147
00:06:12,506 --> 0:06:14,007
（SWIFT中的集合

148
00:06:14,074 --> 0:06:15,943
但由于这些协议的通用目的

149
00:06:16,009 --> 0:06:19,413
许多其它类型也遵守这些集合协议

150
00:06:19,479 --> 0:06:21,582
如Data

151
00:06:21,648 --> 0:06:22,783
（DATA - RANGE - STRING）

152
00:06:22,850 --> 0:06:24,051
或是索引集合

153
00:06:24,284 --> 0:06:26,553
它们都可以访问所有这些丰富的功能

154
00:06:26,620 --> 0:06:29,189
只要它们以自己的方式遵守集合协议

155
00:06:29,389 --> 0:06:31,959
确实 一旦你知道其中任意一种类型

156
00:06:32,025 --> 0:06:34,228
你就可以将该知识

157
00:06:34,795 --> 0:06:35,963
并且这些类型还不少

158
00:06:37,231 --> 0:06:40,667
我将谈谈类型如何

159
00:06:40,934 --> 0:06:44,171
这一切都从描述如何索引开始

160
00:06:44,838 --> 0:06:46,306
（索引）

161
00:06:46,373 --> 0:06:48,308
每个集合都有自己的索引

162
00:06:49,843 --> 0:06:51,378
该索引必须遵守

163
00:06:52,246 --> 0:06:56,483
在某些情况下 索引可能是整数

164
00:06:56,683 --> 0:06:58,819
但仅仅因为索引碰巧是一个整数

165
00:06:58,886 --> 0:07:00,854
并不意味着你只能这样用

166
00:06:58,886 --> 0:07:00,854
并不意味着你只能这样用

167
00:07:01,421 --> 0:07:04,458
现在我想问几个问题

168
00:07:05,125 --> 0:07:07,194
第一个是

169
00:07:08,595 --> 0:07:12,499
你可能马上会想“这个简单

170
00:07:12,966 --> 0:07:14,635
数组的索引恰好是整数

171
00:07:14,701 --> 0:07:17,604
所以你有时可以这样说

172
00:07:17,971 --> 0:07:19,540
但这不是最好的办法

173
00:07:19,640 --> 0:07:21,341
我要继续问同样的问题

174
00:07:21,408 --> 0:07:23,410
但这次是关于另一种集合

175
00:07:25,078 --> 0:07:26,547
Set的第一个元素是什么？

176
00:07:26,947 --> 0:07:29,416
听起来像一个很奇怪的问题 对吧？

177
00:07:29,483 --> 0:07:30,484
Set是无序的

178
00:07:30,984 --> 0:07:32,319
然而它们的确是集合

179
00:07:32,386 --> 0:07:34,388
并且作为集合 你可以遍历它们

180
00:07:34,454 --> 0:07:35,522
当遍历一个Set时

181
00:07:35,589 --> 0:07:37,724
你将首先遍历一个元素

182
00:07:37,791 --> 0:07:40,127
所以这正是我们刚才问的问题

183
00:07:40,827 --> 0:07:42,062
我能用set[0]吗？

184
00:07:42,896 --> 0:07:44,631
编译器会说不

185
00:07:45,132 --> 0:07:48,235
这是因为Set的索引类型不是整数

186
00:07:48,969 --> 0:07:51,471
类型系统希望我们

187
00:07:52,940 --> 0:07:54,675
幸运的是 我们已知如何做到这点

188
00:07:54,741 --> 0:07:57,778
我们知道集合协议告诉我们所有集合

189
00:07:57,845 --> 0:07:58,712
让我们继续并使用它

190
00:07:58,779 --> 0:07:59,646
如果我们这样做

191
00:07:59,713 --> 0:08:01,448
这实际上适用于所有集合

192
00:07:59,713 --> 0:08:01,448
这实际上适用于所有集合

193
00:08:01,515 --> 0:08:05,185
startIndex

194
00:08:05,252 --> 0:08:06,887
看到的第一个元素

195
00:08:06,954 --> 0:08:08,522
但在任何集合中使用下标索引时

196
00:08:08,589 --> 0:08:11,458
有一个细微之处需要注意

197
00:08:12,960 --> 0:08:15,095
那就是 它可能会崩溃

198
00:08:16,063 --> 0:08:18,565
我实际上还没有断言

199
00:08:18,632 --> 0:08:22,836
我直接使用了startIndex

200
00:08:23,570 --> 0:08:26,306
事实证明 访问集合中的第一个元素

201
00:08:26,373 --> 0:08:29,276
是一个很普遍的任务

202
00:08:29,343 --> 0:08:30,944
（致命错误：索引超出范围）

203
00:08:31,011 --> 0:08:32,246
即只需调用first

204
00:08:32,880 --> 0:08:35,015
如果你调用first

205
00:08:35,082 --> 0:08:37,116
因为其返回类型为可选的

206
00:08:37,417 --> 0:08:40,386
回忆一下并非所有集合

207
00:08:42,456 --> 0:08:43,724
我还有另一个问题

208
00:08:44,591 --> 0:08:48,028
集合的第二个元素是什么

209
00:08:48,262 --> 0:08:49,263
它可以是任何集合

210
00:08:49,329 --> 0:08:51,865
一个数组、一个Set

211
00:08:52,866 --> 0:08:55,636
我们通过协议扩展向集合

212
00:08:55,702 --> 0:08:56,870
我们称其为second

213
00:08:56,937 --> 0:08:58,739
和first一样

214
00:08:58,805 --> 0:09:00,908
因为并非所有集合都有两个元素

215
00:08:58,805 --> 0:09:00,908
因为并非所有集合都有两个元素

216
00:09:02,176 --> 0:09:06,547
我们试试这样写 self[1]

217
00:09:06,780 --> 0:09:10,017
但这里我们的基于0的索引直觉

218
00:09:10,317 --> 0:09:12,386
然后我们会再次被编译器抓个正着

219
00:09:13,854 --> 0:09:15,756
我们希望此代码能够适用于每种集合

220
00:09:15,822 --> 0:09:18,091
而不只是使用整数作为索引的集合

221
00:09:18,959 --> 0:09:20,561
所以我们尝试一种不同的方法

222
00:09:21,195 --> 0:09:23,864
我真正想要的是

223
00:09:23,931 --> 0:09:25,566
（找到一个集合的第二个元素）

224
00:09:25,632 --> 0:09:27,968
但编译器仍不依不饶

225
00:09:29,102 --> 0:09:31,471
你不能将对任意索引类型加一

226
00:09:31,572 --> 0:09:34,107
索引类型应该是不透明的

227
00:09:35,576 --> 0:09:36,777
我们在这里真正要做的

228
00:09:36,844 --> 0:09:39,513
是我们需要使用

229
00:09:39,580 --> 0:09:40,447
来做到这一点

230
00:09:40,514 --> 0:09:41,849
我们来试试

231
00:09:42,683 --> 0:09:45,519
我注释了为了找到第二个元素

232
00:09:45,586 --> 0:09:46,854
需要做的事情的框架

233
00:09:47,187 --> 0:09:48,422
我们需要做的第一件事是

234
00:09:48,488 --> 0:09:50,691
我们需要检查集合是否为空

235
00:09:51,024 --> 0:09:52,526
集合在其startIndex

236
00:09:52,593 --> 0:09:54,561
等于endIndex时为空

237
00:09:54,862 --> 0:09:56,763
所以我们来检查一下并返回nil

238
00:09:57,431 --> 0:10:00,901
因为这样的集合没有第二个元素

239
00:09:57,431 --> 0:10:00,901
因为这样的集合没有第二个元素

240
00:10:03,136 --> 0:10:06,139
现在可以假设我们的集合有一个元素

241
00:10:07,774 --> 0:10:11,144
我们可以使用index(after)函数

242
00:10:11,612 --> 0:10:13,714
但我们需要确保该索引是有效的

243
00:10:14,147 --> 0:10:15,182
我们直观地来看一下

244
00:10:15,282 --> 0:10:17,985
我们向前移动了一个元素

245
00:10:18,051 --> 0:10:19,786
我们现在的索引实际上是无效的

246
00:10:19,853 --> 0:10:21,288
如果我们试图用下标索引它

247
00:10:21,355 --> 0:10:23,557
我们就会得到刚才看到的严重错误

248
00:10:23,624 --> 0:10:24,691
所以我们检查它是否有效

249
00:10:24,758 --> 0:10:26,159
这与空链非常相似

250
00:10:26,226 --> 0:10:27,961
我们只需要确保我们的索引

251
00:10:28,028 --> 0:10:30,163
不等于endIndex

252
00:10:30,564 --> 0:10:35,102
同样 因为单元素集合

253
00:10:35,969 --> 0:10:37,838
这时我们确认了所有假设都成立

254
00:10:37,905 --> 0:10:40,107
并知道我们的集合至少有两个元素

255
00:10:40,407 --> 0:10:42,743
所以我们可以安全地

256
00:10:43,877 --> 0:10:45,279
从而检索我们想要的值

257
00:10:47,181 --> 0:10:49,883
这些代码看起来很多

258
00:10:50,150 --> 0:10:52,753
但值得指出的是

259
00:10:52,819 --> 0:10:55,322
将可以处理任何集合

260
00:10:55,889 --> 0:10:58,425
但其实Swift有更好的方法

261
00:10:58,859 --> 0:11:00,394
即一个叫做切片的东西

262
00:10:58,859 --> 0:11:00,394
即一个叫做切片的东西

263
00:11:00,627 --> 0:11:02,229
但在展示如何使用切片

264
00:11:02,296 --> 0:11:05,365
我想谈谈什么是切片

265
00:11:06,934 --> 0:11:08,202
（构造一个切片）

266
00:11:08,268 --> 0:11:11,872
切片是仅描述集合的一部分的类型

267
00:11:13,207 --> 0:11:16,376
每个切片都有自己的起始和结束索引

268
00:11:17,077 --> 0:11:20,881
并且切片与其原始集合分开存在

269
00:11:21,481 --> 0:11:24,484
切片如此高效的原因是

270
00:11:24,551 --> 0:11:26,854
它们只是引用原始集合

271
00:11:27,788 --> 0:11:31,592
当使用切片下标时

272
00:11:32,726 --> 0:11:33,994
它们可以这样做是因为

273
00:11:34,728 --> 0:11:37,264
它们与其原始集合共享同样的索引

274
00:11:37,497 --> 0:11:39,833
我们来看看这是如何工作的

275
00:11:40,133 --> 0:11:41,335
我们将从一个数组开始

276
00:11:41,869 --> 0:11:43,704
我们丢弃该数组的第一个元素

277
00:11:43,770 --> 0:11:46,273
以生成一个少了一个元素的切片

278
00:11:47,107 --> 0:11:49,309
由于我们想要证明索引

279
00:11:49,376 --> 0:11:51,411
我们需要得到数组的第二个索引

280
00:11:51,745 --> 0:11:54,281
即得到起始索引之后的一个索引

281
00:11:54,515 --> 0:11:55,415
然后比较它们

282
00:11:55,482 --> 0:11:57,184
它们的确是一样的

283
00:11:58,485 --> 0:11:59,620
这个dropFirst函数

284
00:11:59,686 --> 0:12:02,890
看起来就是我们得到集合中

285
00:11:59,686 --> 0:12:02,890
看起来就是我们得到集合中

286
00:12:03,724 --> 0:12:05,125
让我们回到之前的解决方案

287
00:12:05,192 --> 0:12:07,561
看看切片的表达能力有多强

288
00:12:08,629 --> 0:12:10,597
还记得我们之前写的复杂的

289
00:12:10,664 --> 0:12:11,765
索引检查代码吗

290
00:12:12,799 --> 0:12:15,235
通过使用dropFirst

291
00:12:15,302 --> 0:12:17,371
替我们处理那些复杂的

292
00:12:18,005 --> 0:12:19,706
由于第一个返回值是可选的

293
00:12:20,941 --> 0:12:24,444
这在集合为空或只有一个元素时

294
00:12:25,078 --> 0:12:26,880
让我们将发生的事情可视化出来

295
00:12:27,614 --> 0:12:28,615
我们从一个数组开始

296
00:12:28,682 --> 0:12:31,185
我们通过丢弃第一个元素

297
00:12:32,352 --> 0:12:37,624
然后我们使用first属性

298
00:12:37,691 --> 0:12:39,760
并从原始集合中获取元素

299
00:12:39,927 --> 0:12:42,863
我不知道你怎么想

300
00:12:44,898 --> 0:12:47,034
每种类型都可以

301
00:12:47,100 --> 0:12:48,101
很多也正是这样做的

302
00:12:48,669 --> 0:12:51,038
例如 Array

303
00:12:51,104 --> 0:12:53,240
它们是为了数组最经常处理的情况

304
00:12:53,307 --> 0:12:54,508
所特别定制的

305
00:12:54,908 --> 0:12:58,378
类似地 String定义了

306
00:12:58,946 --> 0:13:00,147
而Substring也是为了

307
00:12:58,946 --> 0:13:00,147
而Substring也是为了

308
00:13:00,214 --> 0:13:02,616
处理最常见的字符串行为而定制的

309
00:13:03,350 --> 0:13:04,785
一些类型 如Set

310
00:13:05,953 --> 0:13:07,855
将使用标准库中定义的

311
00:13:07,921 --> 0:13:09,189
广义切片类型

312
00:13:09,289 --> 0:13:10,390
因为Set是无序的

313
00:13:10,457 --> 0:13:11,758
它们能做的事情并不多

314
00:13:11,825 --> 0:13:14,161
它们基本上只需要维护

315
00:13:14,228 --> 0:13:16,230
以及一个指向原始集合的指针

316
00:13:16,864 --> 0:13:19,800
另一方面 Data和Range是

317
00:13:20,300 --> 0:13:22,469
所以这里有很多选项

318
00:13:22,970 --> 0:13:25,172
在继续之前我还想谈一件

319
00:13:25,239 --> 0:13:26,240
关于切片的事情

320
00:13:27,708 --> 0:13:29,743
假设我们有一个非常大的集合

321
00:13:29,810 --> 0:13:32,079
比如有上亿个元素

322
00:13:33,180 --> 0:13:35,816
然后我们为该集合的一部分

323
00:13:36,650 --> 0:13:38,418
重要的是要记住切片

324
00:13:38,485 --> 0:13:41,455
使整个原始集合保持活跃状态

325
00:13:41,688 --> 0:13:43,423
只要切片还存在

326
00:13:43,524 --> 0:13:45,092
而这可能导致令人惊讶的问题

327
00:13:45,158 --> 0:13:46,527
我们看看这在代码中是什么样的

328
00:13:48,095 --> 0:13:49,963
假设我在数组上有一个扩展

329
00:13:50,030 --> 0:13:51,465
允许我返回其前半部分

330
00:13:51,532 --> 0:13:55,269
我在这里使用dropLast函数

331
00:13:55,836 --> 0:13:57,504
我们有一个包含8个数字的数组

332
00:13:57,571 --> 0:13:58,739
我们调用扩展

333
00:13:59,773 --> 0:14:00,774
生成切片

334
00:13:59,773 --> 0:14:00,774
生成切片

335
00:14:01,008 --> 0:14:03,977
然后尝试释放这8个数字的

336
00:14:04,178 --> 0:14:06,346
我将该数组设为一个空数组

337
00:14:07,514 --> 0:14:10,050
第一件趣事的线索是

338
00:14:10,117 --> 0:14:12,786
发生在我们访问切片的第一个元素时

339
00:14:13,520 --> 0:14:14,788
我们竟然能够得到1

340
00:14:14,855 --> 0:14:19,126
尽管我们已经释放了

341
00:14:19,526 --> 0:14:22,229
要么它有一个副本

342
00:14:23,330 --> 0:14:26,533
如果我们想要消除那个缓冲区

343
00:14:27,100 --> 0:14:30,003
这里发生的神奇的事

344
00:14:30,103 --> 0:14:31,471
所以如果我们想清除它

345
00:14:31,538 --> 0:14:32,773
我们可以做的是

346
00:14:33,073 --> 0:14:35,042
从切片创建一个

347
00:14:35,809 --> 0:14:38,445
然后如果我们将该切片

348
00:14:39,079 --> 0:14:40,480
那个副本仍然有效

349
00:14:41,415 --> 0:14:43,050
让我们看看发生了什么

350
00:14:43,250 --> 0:14:44,384
我们从一个数组开始

351
00:14:45,018 --> 0:14:47,387
然后我们根据该数组的前半部分

352
00:14:47,454 --> 0:14:49,756
（复制切片）

353
00:14:49,823 --> 0:14:51,758
然后我们创建了它的一个副本

354
00:14:52,426 --> 0:14:54,928
将数组设置为空

355
00:14:54,995 --> 0:14:59,032
只有在我们这样做后

356
00:15:01,201 --> 0:15:03,837
就这点而言 切片有点像延迟拷贝

357
00:15:04,204 --> 0:15:05,205
你可以选择

358
00:15:05,572 --> 0:15:07,574
何时自己创建元素的副本

359
00:15:08,242 --> 0:15:11,478
事实证明 这种“懒”行为

360
00:15:12,179 --> 0:15:14,114
在其他情况下也非常有用

361
00:15:15,516 --> 0:15:17,684
其中一种情况是函数调用

362
00:15:17,751 --> 0:15:18,719
（“急切的”函数）

363
00:15:18,785 --> 0:15:21,321
默认情况下 Swift中的

364
00:15:22,022 --> 0:15:26,126
也就是说 它们接收了输入

365
00:15:27,261 --> 0:15:28,328
考虑这个例子

366
00:15:28,529 --> 0:15:30,397
我们从一个1到4,000

367
00:15:30,664 --> 0:15:33,767
Range是代表大量数字的

368
00:15:33,867 --> 0:15:36,637
它只需要首和尾

369
00:15:37,271 --> 0:15:39,706
我们将其映射为每个值乘以2

370
00:15:39,773 --> 0:15:42,543
所以我们现在已经分配了

371
00:15:42,743 --> 0:15:45,612
并在它们中的每一个上

372
00:15:46,413 --> 0:15:48,282
然后我们将过滤出四个元素

373
00:15:48,815 --> 0:15:50,317
迄今为止 我们已经

374
00:15:50,384 --> 0:15:54,988
分配了4,004个元素的空间

375
00:15:56,156 --> 0:15:57,991
但我们只需要最后四个

376
00:16:00,427 --> 0:16:02,529
这其中具有大量的中间计算

377
00:16:02,596 --> 0:16:04,198
而我们并不总是希望这样

378
00:16:04,731 --> 0:16:06,934
如果有办法不进行这些计算

379
00:16:07,000 --> 0:16:08,502
那就太好了

380
00:16:10,337 --> 0:16:13,440
Swift对此的回答称为“懒惰”

381
00:16:13,507 --> 0:16:14,675
（惰性函数）

382
00:16:14,741 --> 0:16:17,511
我们仍然从Range开始

383
00:16:17,978 --> 0:16:19,813
我们会告诉该Range

384
00:16:19,913 --> 0:16:21,582
当我们这样做时

385
00:16:21,648 --> 0:16:25,452
我们用LazyCollection

386
00:16:25,919 --> 0:16:28,455
当我们对这个LazyCollection

387
00:16:28,622 --> 0:16:30,824
所发生的事是

388
00:16:30,891 --> 0:16:34,127
所以当我们在它上面调用map时

389
00:16:34,328 --> 0:16:35,429
我们没对该闭包做任何事

390
00:16:35,495 --> 0:16:38,232
除了将其存储以便我们将来需要它

391
00:16:38,532 --> 0:16:41,068
如果我进一步过滤了

392
00:16:41,335 --> 0:16:43,470
过滤器只是简单地包装该映射集合

393
00:16:43,770 --> 0:16:45,639
请注意它会在将来按需过滤

394
00:16:45,706 --> 0:16:46,707
而不是现在

395
00:16:47,841 --> 0:16:49,176
现在让我们继续并请求

396
00:16:49,243 --> 0:16:51,478
LazyFilterCollection

397
00:16:55,516 --> 0:16:56,517
当我们这样做时

398
00:16:57,117 --> 0:16:59,253
我们将首先请求

399
00:16:59,319 --> 0:17:00,320
第一个元素

400
00:16:59,319 --> 0:17:00,320
第一个元素

401
00:17:00,687 --> 0:17:02,723
但LazyFilterCollection

402
00:17:02,956 --> 0:17:04,724
然而它包装了可能知道它的东西

403
00:17:05,025 --> 0:17:06,492
因此它将询问

404
00:17:06,627 --> 0:17:09,663
而MapCollection

405
00:17:10,163 --> 0:17:11,632
但它包装了一个可能知道的集合

406
00:17:11,832 --> 0:17:13,934
的确 Range知道

407
00:17:14,935 --> 0:17:17,171
Range的第一个元素是值1

408
00:17:17,538 --> 0:17:19,473
它被返回到

409
00:17:19,705 --> 0:17:23,109
现在LazyMapCollection

410
00:17:23,877 --> 0:17:25,012
计算出值为2

411
00:17:25,444 --> 0:17:27,214
该值被返回到

412
00:17:27,281 --> 0:17:28,782
并作为候选的第一个元素

413
00:17:29,283 --> 0:17:32,319
在这种情况下 我们很幸运

414
00:17:32,419 --> 0:17:35,656
所以LazyFilterCollection

415
00:17:36,256 --> 0:17:37,891
并将其返回给调用者

416
00:17:38,992 --> 0:17:40,961
这是很不同的计算方式

417
00:17:41,328 --> 0:17:45,499
我提到懒惰的目的是

418
00:17:46,033 --> 0:17:49,036
但它避免的另一件事是创建中间存储

419
00:17:49,203 --> 0:17:50,737
所以我想向你展示一个例子

420
00:17:52,339 --> 0:17:54,842
假设我们有一个

421
00:17:55,242 --> 0:17:58,879
然而我想指出的是

422
00:17:59,379 --> 0:18:00,914
我们已经知道他们是熊

423
00:17:59,379 --> 0:18:00,914
我们已经知道他们是熊

424
00:18:00,981 --> 0:18:02,449
它们不必再告诉我们

425
00:18:03,350 --> 0:18:06,119
所以让我们编写一些代码

426
00:18:06,286 --> 0:18:08,455
我们将像刚才一样用惰性过滤器

427
00:18:08,689 --> 0:18:09,690
在这个例子中

428
00:18:10,824 --> 0:18:14,261
所生成的惰性过滤器将是一个

429
00:18:14,494 --> 0:18:16,063
包装的一个字符串数组

430
00:18:16,697 --> 0:18:17,698
在我们的闭包中

431
00:18:17,764 --> 0:18:20,501
我们将在做断言检查之前

432
00:18:20,567 --> 0:18:22,069
正在迭代的那只熊

433
00:18:22,302 --> 0:18:23,637
这样做是因为我想

434
00:18:23,704 --> 0:18:26,273
更好理解过滤器工作原理

435
00:18:26,340 --> 0:18:29,142
当我们这样做时 执行过程将被交给

436
00:18:30,210 --> 0:18:34,515
随后LazyFilterCollection

437
00:18:36,450 --> 0:18:37,985
这时我们将打印出

438
00:18:40,621 --> 0:18:43,390
并检查断言

439
00:18:43,457 --> 0:18:44,892
因为“Grizzly”

440
00:18:44,958 --> 0:18:46,159
并移动到下一个“Panda”

441
00:18:47,294 --> 0:18:48,462
当我们到达“Panda”时…

442
00:18:50,764 --> 0:18:53,166
当我们到达“Panda”时

443
00:18:53,867 --> 0:18:55,769
检查它是否包含单词“Bear”

444
00:18:55,836 --> 0:18:57,304
并移动到“Spectacled”

445
00:18:57,938 --> 0:19:01,008
“Spectacled”被打印

446
00:18:57,938 --> 0:19:01,008
“Spectacled”被打印

447
00:19:01,074 --> 0:19:02,976
最后我们移动到

448
00:19:03,610 --> 0:19:05,612
它包含“Bear”这个词

449
00:19:06,680 --> 0:19:10,651
LazyFilterCollection

450
00:19:12,085 --> 0:19:14,154
若我们再次调用first

451
00:19:15,255 --> 0:19:18,492
其实还是一样的过程

452
00:19:18,892 --> 0:19:22,396
我们询问LazyFilterCollection

453
00:19:22,462 --> 0:19:25,866
底层集合重复刚才的计算

454
00:19:27,935 --> 0:19:29,970
现在这可能不是你想要的

455
00:19:30,237 --> 0:19:32,806
所以如果你发现自己需要

456
00:19:32,873 --> 0:19:34,107
来计算其结果

457
00:19:34,541 --> 0:19:36,910
有一种方法可以确保

458
00:19:37,911 --> 0:19:40,380
我们可以通过从惰性集合

459
00:19:40,447 --> 0:19:43,684
来确保惰性集合只迭代一次

460
00:19:44,384 --> 0:19:45,385
当你这样做时

461
00:19:45,752 --> 0:19:47,654
它仍然会将计算委托给惰性集合

462
00:19:47,721 --> 0:19:48,555
但现在迭代过程

463
00:19:48,622 --> 0:19:51,658
将处理完整个底层集合

464
00:19:53,760 --> 0:19:55,028
从而产生

465
00:19:55,095 --> 0:19:57,331
该惰性计算的非惰性版本

466
00:19:57,865 --> 0:20:00,934
这例子中 我们得到一个包含字符串

467
00:19:57,865 --> 0:20:00,934
这例子中 我们得到一个包含字符串

468
00:20:01,535 --> 0:20:03,570
如果我们打印该数组的第一个元素

469
00:20:03,637 --> 0:20:06,106
我们根本不需要咨询闭包

470
00:20:06,173 --> 0:20:09,276
我们基本消除了其惰性

471
00:20:11,879 --> 0:20:13,046
我们何时该懒惰呢？

472
00:20:14,081 --> 0:20:16,517
惰性集合是一种非常好的能够消除

473
00:20:16,583 --> 0:20:18,485
链式映射和过滤器的开销的方法

474
00:20:18,585 --> 0:20:19,786
当你发现你只需要

475
00:20:19,853 --> 0:20:22,556
集合运算的部分结果时

476
00:20:23,257 --> 0:20:27,027
但如果你的闭包有副作用

477
00:20:27,127 --> 0:20:29,396
你的闭包应该鲜有副作用

478
00:20:29,830 --> 0:20:31,765
并且记得一定要恢复…

479
00:20:31,832 --> 0:20:34,234
一定要考虑重新恢复到普通集合

480
00:20:34,301 --> 0:20:35,736
当你跨越API边界时

481
00:20:36,069 --> 0:20:38,172
惰性通常应该是一个实现细节

482
00:20:38,238 --> 0:20:39,940
（建议：何时使用惰性？）

483
00:20:40,007 --> 0:20:42,142
到目前为止 我们已经使用可变集合

484
00:20:42,209 --> 0:20:43,677
做了很多很酷的事情

485
00:20:44,978 --> 0:20:47,681
但Swift也允许我们

486
00:20:47,748 --> 0:20:48,982
（集合协议层次结构）

487
00:20:49,049 --> 0:20:50,751
让我们来谈谈

488
00:20:50,817 --> 0:20:52,319
这两种尚未讨论过的集合

489
00:20:53,187 --> 0:20:55,088
其中第一个是可变集合

490
00:20:55,989 --> 0:20:57,191
它为下标添加了一个setter

491
00:20:57,257 --> 0:20:59,092
以便你可以更改集合的内容

492
00:20:59,159 --> 0:21:00,160
但不能更改它的长度

493
00:20:59,159 --> 0:21:00,160
但不能更改它的长度

494
00:21:00,427 --> 0:21:02,596
你必须能够

495
00:21:02,663 --> 0:21:04,031
（可变集合）

496
00:21:05,632 --> 0:21:08,502
下一个被称为范围可替换集合

497
00:21:08,569 --> 0:21:10,504
你可以在这种集合中

498
00:21:10,571 --> 0:21:14,308
删除元素或插入元素

499
00:21:16,076 --> 0:21:18,779
现在我想谈谈

500
00:21:20,347 --> 0:21:22,916
为什么我的完全合理的

501
00:21:23,784 --> 0:21:25,185
像所有好问题的答案一样

502
00:21:25,252 --> 0:21:27,688
一般我会反问他们我自己的一些问题

503
00:21:28,355 --> 0:21:31,425
有时候我会从经典问题开始

504
00:21:31,692 --> 0:21:33,293
接下来我马上会问

505
00:21:33,360 --> 0:21:35,262
“你是怎么使用集合的？”

506
00:21:35,362 --> 0:21:36,363
“你在尝试改变它们吗？”

507
00:21:36,430 --> 0:21:38,866
“你确定没有从多个线程

508
00:21:38,932 --> 0:21:41,401
我问这些问题是因为其答案

509
00:21:42,436 --> 0:21:45,038
常常能引出导致问题的根本原因

510
00:21:46,039 --> 0:21:48,141
首先让我们先假设跟线程没关系

511
00:21:48,208 --> 0:21:50,878
我还没准备好考虑线程

512
00:21:50,944 --> 0:21:52,079
（崩溃的集合代码）

513
00:21:52,145 --> 0:21:53,280
假设我们有一个数组

514
00:21:53,780 --> 0:21:56,350
我们获取一个已知元素的索引

515
00:21:57,184 --> 0:21:58,418
这个例子中 值为“E”

516
00:21:58,652 --> 0:22:01,755
然后我们通过删除它的第一个元素

517
00:21:58,652 --> 0:22:01,755
然后我们通过删除它的第一个元素

518
00:22:02,656 --> 0:22:05,526
我们继续并打印与该索引关联的元素

519
00:22:06,360 --> 0:22:07,995
当我们这样做时

520
00:22:08,996 --> 0:22:10,430
这会产生一个严重错误

521
00:22:12,032 --> 0:22:13,166
索引不再有效

522
00:22:13,233 --> 0:22:16,904
实际上当我们改变集合时

523
00:22:18,939 --> 0:22:20,040
更安全的方法

524
00:22:20,340 --> 0:22:24,411
是首先改变我们的集合

525
00:22:24,511 --> 0:22:26,446
（避免索引失效）

526
00:22:26,513 --> 0:22:28,949
值得指出的是

527
00:22:29,016 --> 0:22:30,651
这不仅适用于数组

528
00:22:31,118 --> 0:22:34,321
我们来看看这个问题

529
00:22:34,988 --> 0:22:38,225
我们假设有一个字典

530
00:22:39,092 --> 0:22:41,195
我们获取熊最喜爱的食物的索引

531
00:22:41,361 --> 0:22:44,031
并打印出来

532
00:22:45,199 --> 0:22:47,835
接下来我们将添加更多

533
00:22:48,602 --> 0:22:50,938
然后我们会确保熊最喜欢的食物

534
00:22:51,104 --> 0:22:52,639
我们会看到…等一下

535
00:22:52,706 --> 0:22:55,209
熊最喜欢的食物不是“hibernation”

536
00:22:57,077 --> 0:22:58,078
就像数组一样

537
00:22:58,145 --> 0:23:00,948
在我们改变字典的那一刻

538
00:22:58,145 --> 0:23:00,948
在我们改变字典的那一刻

539
00:23:01,448 --> 0:23:03,851
值得指出的是

540
00:23:05,085 --> 0:23:06,553
我们该如何解决这个问题呢？

541
00:23:07,688 --> 0:23:10,524
其实这与我们在数组中

542
00:23:11,225 --> 0:23:13,493
我们只需要在发生改变后

543
00:23:14,328 --> 0:23:15,429
请记住一件事

544
00:23:15,562 --> 0:23:16,997
当你重新计算索引时

545
00:23:17,297 --> 0:23:18,899
这有时会造成很大的开销

546
00:23:18,966 --> 0:23:21,768
一些索引搜索方法需要线性时间

547
00:23:22,336 --> 0:23:25,205
而且你只关心你所需要的那个索引

548
00:23:26,874 --> 0:23:27,708
所以如果你想

549
00:23:27,774 --> 0:23:30,344
避免陷入这种情况

550
00:23:30,410 --> 0:23:33,580
请记住 改变集合几乎

551
00:23:33,914 --> 0:23:35,983
你有时可能会侥幸成功

552
00:23:36,049 --> 0:23:38,385
但最好将这视为一条硬性规则

553
00:23:38,585 --> 0:23:39,953
你最终会为此感到高兴

554
00:23:40,854 --> 0:23:42,422
还要记住切片依赖于

555
00:23:42,489 --> 0:23:45,058
其底层的原始集合的状态

556
00:23:45,125 --> 0:23:46,493
即使是在它发生了改变之后

557
00:23:46,894 --> 0:23:50,831
因此当底层集合是可变的时

558
00:23:51,164 --> 0:23:53,133
请务必三思而后行

559
00:23:53,767 --> 0:23:55,502
并记住索引计算

560
00:23:55,636 --> 0:23:57,771
有时可能花费大量的时间

561
00:23:57,838 --> 0:23:59,139
（建议：索引和切片）

562
00:23:59,206 --> 0:24:01,441
所以注意只在必要时才进行索引计算

563
00:23:59,206 --> 0:24:01,441
所以注意只在必要时才进行索引计算

564
00:24:02,910 --> 0:24:05,746
现在让我们来讨论一下线程

565
00:24:05,812 --> 0:24:07,481
我提到我问的其中一个问题是

566
00:24:07,548 --> 0:24:10,317
“你的线程是否可以

567
00:24:11,618 --> 0:24:12,853
我之所以这样问

568
00:24:13,053 --> 0:24:14,555
是因为我们的集合假设

569
00:24:14,621 --> 0:24:16,723
你将从单个线程访问它们

570
00:24:17,691 --> 0:24:20,294
这对性能来说是一件好事

571
00:24:20,694 --> 0:24:22,429
这是因为单线程用例

572
00:24:22,496 --> 0:24:26,300
不需要花费大量资源在锁

573
00:24:26,366 --> 0:24:29,069
确保互斥的原语上面

574
00:24:30,237 --> 0:24:33,140
当涉及到线程时

575
00:24:33,207 --> 0:24:35,375
才拥有以适当的锁或串行队列

576
00:24:35,442 --> 0:24:37,578
限制访问所需的所有信息

577
00:24:37,644 --> 0:24:38,912
这些信息的抽象层次要比

578
00:24:38,979 --> 0:24:41,381
我们这些底层框架开发人员

579
00:24:42,683 --> 0:24:45,285
我们看看这些问题会是什么样子的

580
00:24:45,385 --> 0:24:46,486
假设我们有一个数组

581
00:24:46,553 --> 0:24:48,488
我们想将睡着的熊添加进去

582
00:24:49,256 --> 0:24:51,892
为了模拟每只熊都是独立的

583
00:24:51,959 --> 0:24:52,793
并能够管理自己

584
00:24:52,860 --> 0:24:55,362
我们将访问并发调度队列

585
00:24:56,230 --> 0:24:58,232
我们将用它来告诉每只熊去睡觉

586
00:24:58,899 --> 0:25:00,534
并且由于这是一个并发调度队列

587
00:24:58,899 --> 0:25:00,534
并且由于这是一个并发调度队列

588
00:25:00,601 --> 0:25:03,637
想象代码同时运行是很有帮助的

589
00:25:03,904 --> 0:25:06,240
我将它们放在同一行上

590
00:25:07,007 --> 0:25:08,108
稍后在app中

591
00:25:08,175 --> 0:25:10,043
让我们检查一下那些睡觉的熊

592
00:25:11,245 --> 0:25:14,548
有时我们会看到Grandpa

593
00:25:15,048 --> 0:25:18,752
其他时候 Cub会先睡觉

594
00:25:19,419 --> 0:25:22,389
有时 非常神秘

595
00:25:23,790 --> 0:25:25,425
其他时候

596
00:25:26,560 --> 0:25:28,962
有时候 我们的程序崩溃了

597
00:25:29,029 --> 0:25:30,497
并且没有熊能够睡觉

598
00:25:32,132 --> 0:25:33,166
所有这些可能性

599
00:25:33,233 --> 0:25:35,068
表明存在可能的竞争条件

600
00:25:35,135 --> 0:25:36,770
其实考虑到这个例子中的线程

601
00:25:36,837 --> 0:25:40,140
这的确有可能发生

602
00:25:41,074 --> 0:25:42,176
我们可以使用Xcode中的

603
00:25:42,242 --> 0:25:45,179
ThreadSanitizer

604
00:25:45,646 --> 0:25:46,647
假设我们这样做的话

605
00:25:47,214 --> 0:25:49,216
我们将得到这样的输出

606
00:25:49,783 --> 0:25:51,585
TSan的确发现了竞争

607
00:25:51,652 --> 0:25:54,121
它告诉我们当前存在

608
00:25:54,655 --> 0:25:56,590
它会告诉我们涉及哪些线程

609
00:25:57,491 --> 0:25:58,625
并在最后给个总结

610
00:25:58,692 --> 0:26:01,695
告诉我们应该从哪一行代码开始

611
00:25:58,692 --> 0:26:01,695
告诉我们应该从哪一行代码开始

612
00:26:02,329 --> 0:26:06,700
所有这些证据对于我们发现错误

613
00:26:06,934 --> 0:26:08,268
我们已证明这里有一个漏洞

614
00:26:08,335 --> 0:26:11,238
在我的经历中

615
00:26:12,606 --> 0:26:13,607
我们可以

616
00:26:13,841 --> 0:26:16,710
通过解除熊的同时入睡能力

617
00:26:16,910 --> 0:26:18,979
我们将使用串行调度队列来实现这点

618
00:26:19,746 --> 0:26:21,715
现在一次只有一只熊可以入睡

619
00:26:21,949 --> 0:26:24,184
所以如果我们现在再次查看

620
00:26:24,885 --> 0:26:26,887
并在适当的队列上小心操作

621
00:26:27,988 --> 0:26:29,122
我们可以看到 果然

622
00:26:29,189 --> 0:26:31,959
Grandpa和Cub

623
00:26:34,194 --> 0:26:36,830
所以对于在多线程环境下使用集合

624
00:26:36,897 --> 0:26:40,133
尝试隔离你的数据

625
00:26:40,300 --> 0:26:41,635
当你不能这样做时

626
00:26:42,436 --> 0:26:44,705
确保你实现适当形式的互斥

627
00:26:44,771 --> 0:26:47,040
如串行调度队列或锁

628
00:26:47,741 --> 0:26:50,511
并总是使用ThreadSanitizer

629
00:26:50,844 --> 0:26:54,248
在app发布之前发现错误

630
00:26:54,314 --> 0:26:55,716
（建议：多线程）

631
00:26:55,782 --> 0:26:58,519
我对使用可变集合还有更多的建议

632
00:26:59,753 --> 0:27:03,490
第一个是如果你可以避免它

633
00:26:59,753 --> 0:27:03,490
第一个是如果你可以避免它

634
00:27:04,391 --> 0:27:06,193
到目前为止我所描述的所有困难

635
00:27:06,260 --> 0:27:08,562
都是因为我们一直在使用可变状态

636
00:27:08,862 --> 0:27:10,697
你可以通过避免使用可变集合

637
00:27:10,764 --> 0:27:13,133
来从一开始就杜绝各种可能的复杂性

638
00:27:13,834 --> 0:27:16,803
很多时候 你可以通过使用切片

639
00:27:17,004 --> 0:27:20,207
来模拟你想要执行的改变

640
00:27:20,641 --> 0:27:23,744
而且理解不可变数据几乎总是更容易

641
00:27:24,178 --> 0:27:26,380
多亏Swift内置的可变性

642
00:27:26,513 --> 0:27:27,648
若在你没有改变状态时

643
00:27:27,714 --> 0:27:30,551
却试图留下可变的状态

644
00:27:30,617 --> 0:27:32,619
（建议：首选不可变集合）

645
00:27:32,686 --> 0:27:34,288
现在我还有一条建议

646
00:27:34,788 --> 0:27:37,858
关于如何在必要时

647
00:27:38,825 --> 0:27:40,494
那就是当你正在构造新的集合时

648
00:27:40,561 --> 0:27:41,495
你可以改善性能

649
00:27:41,562 --> 0:27:43,964
如果你碰巧知道

650
00:27:44,531 --> 0:27:45,699
确切数量

651
00:27:45,766 --> 0:27:47,634
或者非常好的近似值的话

652
00:27:47,734 --> 0:27:50,804
大多数集合API都能够

653
00:27:51,171 --> 0:27:52,973
当你这样做时

654
00:27:53,040 --> 0:27:54,041
而且没有额外开销

655
00:27:54,441 --> 0:27:57,344
如果你不这样做

656
00:27:57,978 --> 0:27:59,713
它们可以在各种情况下工作

657
00:27:59,780 --> 0:28:01,448
随着你逐步添加元素

658
00:27:59,780 --> 0:28:01,448
随着你逐步添加元素

659
00:28:01,515 --> 0:28:05,319
你最终可能会分配比你所需要的

660
00:28:06,186 --> 0:28:09,289
但请注意 在提供此类提示时

661
00:28:09,489 --> 0:28:11,391
否则你会发现自己处于同样的情况

662
00:28:11,458 --> 0:28:14,061
即你使用的存储空间比实际需要的多

663
00:28:15,028 --> 0:28:17,364
现在我想继续今天的最后一个话题

664
00:28:18,832 --> 0:28:21,969
当你导入foundation

665
00:28:22,536 --> 0:28:25,472
各种各样的集合

666
00:28:27,307 --> 0:28:28,876
除了标准库集合之外

667
00:28:28,942 --> 0:28:30,143
当你导入foundation时

668
00:28:30,210 --> 0:28:32,513
你可以访问很棒的引用类型集合

669
00:28:32,579 --> 0:28:35,315
它们已被Objective-C

670
00:28:36,350 --> 0:28:39,253
其中许多都可以兼容Swift

671
00:28:39,319 --> 0:28:42,222
因此它们与我们一直在谈论的

672
00:28:42,289 --> 0:28:44,558
也就是说 有几件重要的事情

673
00:28:45,993 --> 0:28:49,296
首先要记住的是这些NS类集合

674
00:28:49,363 --> 0:28:50,464
是引用类型

675
00:28:50,564 --> 0:28:52,900
我们通过一个例子来更好的理解这点

676
00:28:53,634 --> 0:28:55,302
我们将定义值类型和引用类型

677
00:28:55,369 --> 0:28:57,604
并在两边对它们做同样的事情

678
00:28:58,338 --> 0:29:00,240
对于我们的值类型

679
00:28:58,338 --> 0:29:00,240
对于我们的值类型

680
00:29:00,307 --> 0:29:01,542
它将是一个字符串数组

681
00:29:02,409 --> 0:29:04,711
我们得到一个名为x的空数组

682
00:29:05,012 --> 0:29:07,047
对于引用类型

683
00:29:07,381 --> 0:29:08,549
但x只是指向它

684
00:29:09,983 --> 0:29:12,719
然后我们用数值类型来改变这个数组

685
00:29:12,886 --> 0:29:14,288
该数组内联地发生改变

686
00:29:14,755 --> 0:29:15,923
对于引用类型

687
00:29:16,123 --> 0:29:20,494
正在被引用的数组内联地发生改变

688
00:29:21,328 --> 0:29:22,496
我们创建另一个变量

689
00:29:23,130 --> 0:29:25,432
使用值类型时

690
00:29:25,499 --> 0:29:27,301
这时我们实际上并不复制存储

691
00:29:27,367 --> 0:29:31,471
y是一个数组

692
00:29:32,539 --> 0:29:34,208
并且y实际上不会进行复制

693
00:29:34,274 --> 0:29:36,343
除非这些集合中的任何一个发生变化

694
00:29:36,610 --> 0:29:38,679
引用类型有点不同

695
00:29:38,912 --> 0:29:41,782
y只是另一个

696
00:29:43,016 --> 0:29:46,019
所以让我们继续并改变y

697
00:29:46,086 --> 0:29:47,421
对于值类型 所发生的事是

698
00:29:47,487 --> 0:29:49,423
我们首先进行复制

699
00:29:49,489 --> 0:29:51,825
我们正在对y写入值

700
00:29:53,260 --> 0:29:54,895
然后我们就可以插入下一个熊

701
00:29:56,363 --> 0:29:57,931
对于引用 情况较为简单

702
00:29:57,998 --> 0:30:01,068
只存在一个数组

703
00:29:57,998 --> 0:30:01,068
只存在一个数组

704
00:30:01,134 --> 0:30:03,303
（值和引用集合）

705
00:30:03,537 --> 0:30:05,038
在Swift中

706
00:30:05,105 --> 0:30:08,675
你需要记住的第二件事

707
00:30:09,476 --> 0:30:12,446
是Swift中的所有

708
00:30:12,513 --> 0:30:14,581
都以Swift原生值类型出现

709
00:30:15,048 --> 0:30:17,951
这实际上非常棒

710
00:30:18,018 --> 0:30:20,554
自然而然使用它们各自最擅长的类型

711
00:30:20,988 --> 0:30:22,022
但是这如何实现呢？

712
00:30:22,155 --> 0:30:24,024
这两种语言对这些集合

713
00:30:24,091 --> 0:30:25,192
有完全不同的实现

714
00:30:25,259 --> 0:30:26,360
（SWIFT中的

715
00:30:26,426 --> 0:30:29,062
这能起作用的原因就是所谓的桥接

716
00:30:29,496 --> 0:30:33,033
桥接是我们如何在两种不同的

717
00:30:33,100 --> 0:30:36,203
这是必要的 因为Swift

718
00:30:36,270 --> 0:30:38,739
我相信你已经注意到

719
00:30:38,906 --> 0:30:41,208
它们具有完全不同的

720
00:30:41,275 --> 0:30:42,309
（桥接）

721
00:30:42,376 --> 0:30:46,213
尽管我们已经优化了桥接速度

722
00:30:46,480 --> 0:30:49,516
在两种语言之间桥接时总会产生开销

723
00:30:50,884 --> 0:30:52,252
当我们桥接时会发生什么？

724
00:30:52,920 --> 0:30:54,555
当我们在语言之间桥接时

725
00:30:54,621 --> 0:30:57,357
我们必须先建立新的存储空间

726
00:30:57,424 --> 0:30:59,059
如果你用一种语言占用N个单位

727
00:30:59,126 --> 0:31:00,827
在另一种语言中这也将占用N个

728
00:30:59,126 --> 0:31:00,827
在另一种语言中这也将占用N个

729
00:31:01,128 --> 0:31:05,032
然后我们需要逐个元素地

730
00:31:05,098 --> 0:31:07,568
并且这种按元素桥接

731
00:31:07,634 --> 0:31:09,536
比如我有一个字符串数组

732
00:31:09,603 --> 0:31:10,704
首先我们将桥接数组

733
00:31:10,771 --> 0:31:12,840
然后我们将桥接每个单独的字符串

734
00:31:13,941 --> 0:31:16,176
当这发生在两种语言的边界时

735
00:31:16,243 --> 0:31:17,411
称之为“急切桥接”

736
00:31:18,812 --> 0:31:20,681
当集合中的元素也需要桥接时

737
00:31:20,747 --> 0:31:23,584
集合本身将总是“急切”进行桥接

738
00:31:24,151 --> 0:31:27,321
这种情况最常出现在

739
00:31:28,789 --> 0:31:31,325
当集合桥接并不急切时

740
00:31:31,658 --> 0:31:33,627
当集合元素的类型并不是桥接时

741
00:31:33,694 --> 0:31:36,230
就会发生这种情况

742
00:31:36,463 --> 0:31:38,298
在这种情况下

743
00:31:38,365 --> 0:31:40,701
直到首次使用该集合

744
00:31:41,435 --> 0:31:43,437
让我们用一些例子来说明这个问题

745
00:31:43,637 --> 0:31:47,074
我们首先考虑一个Objective-C API

746
00:31:47,808 --> 0:31:49,643
NSArray被桥接到数组

747
00:31:49,710 --> 0:31:51,845
而NSData

748
00:31:51,979 --> 0:31:54,381
所以这样的集合将会被急切的桥接

749
00:31:54,448 --> 0:31:55,649
（桥接示例）

750
00:31:55,716 --> 0:31:58,352
我刚才提到NSView

751
00:31:58,418 --> 0:32:00,554
它们在Swift中仍然是引用类型

752
00:31:58,418 --> 0:32:00,554
它们在Swift中仍然是引用类型

753
00:32:00,621 --> 0:32:04,157
所以NSArray将被延迟桥接

754
00:32:04,258 --> 0:32:05,259
桥接不会发生

755
00:32:05,325 --> 0:32:08,228
直到你第一次访问或尝试使用该数组

756
00:32:10,831 --> 0:32:15,269
最后 键类型为NSString的

757
00:32:15,335 --> 0:32:16,537
将被急切桥接

758
00:32:17,070 --> 0:32:19,439
因为字符串需在Swift中转换为

759
00:32:19,506 --> 0:32:21,308
值类型的字符串

760
00:32:22,242 --> 0:32:25,312
现在我们知道了桥接是什么

761
00:32:25,579 --> 0:32:27,648
我们可以继续讨论最重要的问题

762
00:32:27,748 --> 0:32:29,550
即你何时应该关心它

763
00:32:29,716 --> 0:32:31,285
答案非常简单

764
00:32:31,351 --> 0:32:33,654
当你估计它会对你的app

765
00:32:35,889 --> 0:32:38,392
具体而言 当你使用时间分析器

766
00:32:38,559 --> 0:32:41,795
要特别注意你的代码

767
00:32:41,862 --> 0:32:44,097
特别是当这发生在循环内时

768
00:32:44,898 --> 0:32:47,434
少量的桥接完全没问题

769
00:32:47,501 --> 0:32:48,836
你所关心的是

770
00:32:48,902 --> 0:32:51,872
不成比例的时间

771
00:32:52,072 --> 0:32:55,042
被花费在不是你写的代码中

772
00:32:56,476 --> 0:32:57,978
我们来看一个具体的例子

773
00:32:58,846 --> 0:33:01,215
假设我正在写一本

774
00:32:58,846 --> 0:33:01,215
假设我正在写一本

775
00:33:01,515 --> 0:33:02,749
但它非常长

776
00:33:02,816 --> 0:33:04,351
所以我只会在这里展示一部分

777
00:33:04,418 --> 0:33:05,953
但为了让它受欢迎

778
00:33:07,154 --> 0:33:10,324
我想让每个单词“brown”

779
00:33:10,390 --> 0:33:11,725
都真的显示为棕色

780
00:33:12,092 --> 0:33:13,126
为了节省空间

781
00:33:13,193 --> 0:33:15,495
我将只突出显示第一个单词

782
00:33:16,330 --> 0:33:18,732
为此 我将使用

783
00:33:18,799 --> 0:33:20,067
我把我的故事传进去

784
00:33:20,968 --> 0:33:24,738
然后使用属性字符串的

785
00:33:25,005 --> 0:33:27,274
我要得到Swift字符串

786
00:33:27,541 --> 0:33:30,077
这将产生一个

787
00:33:31,311 --> 0:33:32,980
因为可变字符串

788
00:33:33,046 --> 0:33:34,515
所以我会使用我们去年

789
00:33:34,581 --> 0:33:35,816
推出的便捷初始化器

790
00:33:36,216 --> 0:33:38,151
来将其转换为NSRange

791
00:33:38,218 --> 0:33:42,489
在这里我再次调用

792
00:33:43,090 --> 0:33:44,091
来进行转换

793
00:33:44,391 --> 0:33:47,060
然后我们将为“brown”

794
00:33:47,194 --> 0:33:49,696
当我运行这段代码时

795
00:33:50,898 --> 0:33:51,899
所以我对其进行分析

796
00:33:52,266 --> 0:33:54,468
我看到 令我惊讶的是

797
00:33:54,535 --> 0:33:56,336
我以为大部分时间都会花在

798
00:33:56,403 --> 0:33:57,938
但它实际上是在计算索引

799
00:33:58,005 --> 0:33:59,006
为什么会这样

800
00:34:00,707 --> 0:34:02,509
其中的原因是我们实际上正在

801
00:34:02,576 --> 0:34:04,244
两种语言间多次桥接字符串

802
00:34:04,511 --> 0:34:08,014
MutableAttributedString是一个

803
00:34:08,081 --> 0:34:10,284
所以当我们访问string属性时

804
00:34:10,350 --> 0:34:13,120
我们实际上需要从NSString

805
00:34:13,554 --> 0:34:16,657
当我们计算第一个范围时

806
00:34:16,956 --> 0:34:19,659
我们在转换为NSRange时

807
00:34:20,694 --> 0:34:22,329
你可以想象这样的开销有多大

808
00:34:22,396 --> 0:34:24,864
如果我们在一个循环中

809
00:34:25,465 --> 0:34:27,367
现在我们来看看为什么

810
00:34:27,434 --> 0:34:31,071
每次调用text.string时

811
00:34:31,737 --> 0:34:34,908
然而NSMutableAttributedString

812
00:34:34,975 --> 0:34:36,577
所以为了提供结果

813
00:34:36,643 --> 0:34:39,279
我们实际上必须咨询其原始实现

814
00:34:39,346 --> 0:34:40,614
（桥接发生时）

815
00:34:40,681 --> 0:34:44,284
原始实现返回NSString

816
00:34:44,451 --> 0:34:46,820
所以当返回到字符串时

817
00:34:47,521 --> 0:34:49,755
逐个图像集

818
00:34:50,824 --> 0:34:51,992
逐个字符

819
00:34:52,826 --> 0:34:58,098
无论是返回类型还是参数

820
00:35:01,268 --> 0:35:03,237
现在我们知道了这些细节

821
00:35:03,470 --> 0:35:06,306
我们可以做得更好一些

822
00:35:06,373 --> 0:35:07,474
我们只需桥接一次

823
00:35:08,709 --> 0:35:10,010
让我们重新测量代码

824
00:35:10,944 --> 0:35:13,614
并看到我们的确已将性能提高了一半

825
00:35:13,680 --> 0:35:15,949
但今年我们可以做得更好一点

826
00:35:16,650 --> 0:35:18,986
哦 现在我们在这里不再进行桥接

827
00:35:19,486 --> 0:35:21,421
但今年我们可以做得更好一点

828
00:35:21,722 --> 0:35:23,991
今年当我们获取

829
00:35:24,057 --> 0:35:25,659
如果我们使用as语法

830
00:35:25,726 --> 0:35:29,263
当我们得到变量时

831
00:35:30,564 --> 0:35:34,868
并且通过这样做

832
00:35:35,035 --> 0:35:36,336
当我们调用

833
00:35:36,403 --> 0:35:39,873
我们实际上

834
00:35:39,940 --> 0:35:41,642
我们不需要在Swift原生类型

835
00:35:41,708 --> 0:35:45,379
和NSRange之间

836
00:35:45,612 --> 0:35:46,613
这非常棒

837
00:35:46,680 --> 0:35:49,082
我们来看看这段代码的效率

838
00:35:49,149 --> 0:35:50,150
这看起来很不错

839
00:35:50,217 --> 0:35:52,686
这比我们刚才耗费的

840
00:35:52,753 --> 0:35:54,354
几乎800毫秒的时间要快得多

841
00:35:55,489 --> 0:35:57,658
然而我想指出的是

842
00:35:57,724 --> 0:35:59,026
这是很小的桥

843
00:35:59,660 --> 0:36:00,827
但我们仍进行了桥接

844
00:35:59,660 --> 0:36:00,827
但我们仍进行了桥接

845
00:36:01,328 --> 0:36:03,830
这里的“brown”是一个

846
00:36:05,032 --> 0:36:10,938
每当我们调用Objective-C API

847
00:36:11,004 --> 0:36:13,774
我们实际上会将这个小小的

848
00:36:14,908 --> 0:36:17,144
在这种情况下它的开销不大

849
00:36:17,211 --> 0:36:18,946
但你可以想象

850
00:36:19,079 --> 0:36:20,948
随着时间推移

851
00:36:21,014 --> 0:36:22,549
所以你要注意

852
00:36:22,616 --> 0:36:25,219
避免重复桥接相同的小字符串

853
00:36:25,485 --> 0:36:28,222
但在你做这样的优化之前

854
00:36:29,723 --> 0:36:31,258
现在我们看过了桥接的细节

855
00:36:31,358 --> 0:36:34,294
我想提供些关于何时使用

856
00:36:35,662 --> 0:36:37,564
当你需要具有引用语义的集合时

857
00:36:37,631 --> 0:36:39,800
你应该考虑明确使用它们

858
00:36:40,467 --> 0:36:42,102
你不需要自己写一个

859
00:36:42,169 --> 0:36:43,637
我们已经有很多很棒的集合了

860
00:36:44,238 --> 0:36:45,706
当你知道你在处理引用类型时

861
00:36:45,772 --> 0:36:46,974
也应该使用它

862
00:36:47,040 --> 0:36:49,743
像NS代理或核心数据托管对象

863
00:36:51,078 --> 0:36:52,679
最后应该考虑使用它们的情景是

864
00:36:52,746 --> 0:36:54,848
当你在与Objective-C

865
00:36:55,148 --> 0:36:56,884
但我强烈建议你

866
00:36:57,351 --> 0:37:00,053
桥接确实是性能问题的罪魁祸首后

867
00:36:57,351 --> 0:37:00,053
桥接确实是性能问题的罪魁祸首后

868
00:37:00,120 --> 0:37:02,556
你才这样做

869
00:37:03,690 --> 0:37:06,026
现在我们对Swift中强大的

870
00:37:06,093 --> 0:37:08,929
集合世界的探索已经接近尾声

871
00:37:09,630 --> 0:37:11,598
我希望你能够使用这种新视角

872
00:37:11,698 --> 0:37:13,667
来检视你现有的集合使用情况

873
00:37:13,967 --> 0:37:15,903
寻找可以通过更有效地

874
00:37:15,969 --> 0:37:18,272
使用索引和切片来改进代码的地方

875
00:37:18,839 --> 0:37:19,840
测量你的代码

876
00:37:20,574 --> 0:37:23,110
寻找你可以因惰性

877
00:37:24,411 --> 0:37:25,779
而受益的地方

878
00:37:26,947 --> 0:37:29,616
用ThreadSanitizer

879
00:37:30,517 --> 0:37:32,252
并通过应用今天讨论的所有概念

880
00:37:32,319 --> 0:37:34,054
在Playground

881
00:37:34,121 --> 0:37:36,623
进一步锻炼你对集合的掌握

882
00:37:37,824 --> 0:37:39,326
如果你对集合有任何疑问

883
00:37:39,393 --> 0:37:41,094
请到访我们今天最后几个实验室

884
00:37:41,161 --> 0:37:42,162
我们将在那里提供帮助

885
00:37:42,629 --> 0:37:45,232
非常感谢
