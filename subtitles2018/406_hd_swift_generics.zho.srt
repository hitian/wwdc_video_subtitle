1
00:00:17,251 --> 0:00:22,055
（SWIFT通用型）

2
00:00:34,535 --> 0:00:35,369
大家好

3
00:00:36,436 --> 0:00:38,505
我是Ben 我是Swift

4
00:00:38,805 --> 0:00:41,141
今天我要和来自编译团队的同事

5
00:00:41,208 --> 0:00:43,310
跟大家分享关于

6
00:00:45,112 --> 0:00:48,415
Swift最近发布的版本

7
00:00:48,782 --> 0:00:52,553
包括条件一致性和递归协议约束条件

8
00:00:53,887 --> 0:00:57,758
其实在Swift发布的每个版本中

9
00:00:58,091 --> 0:00:59,459
让它变得更有表现性

10
00:01:00,460 --> 0:01:03,297
我们觉得4.2版本是一个重要节点

11
00:01:04,230 --> 0:01:07,100
从这个节点开始

12
00:01:07,434 --> 0:01:09,570
许多期待应用到

13
00:01:09,636 --> 0:01:12,439
这在达到Swift中

14
00:01:12,506 --> 0:01:15,275
ABI的稳定性的目标方面

15
00:01:17,044 --> 0:01:19,179
因此我们之前也针对通用型

16
00:01:19,246 --> 0:01:20,814
但我们一直没有往后退一步

17
00:01:20,881 --> 0:01:22,850
将通用型作为一个整体来讲

18
00:01:23,450 --> 0:01:26,453
今天我们要给大家

19
00:01:26,520 --> 0:01:28,856
关于通用型系统

20
00:01:29,323 --> 0:01:31,191
以便帮你们理解它们如何共同协作

21
00:01:32,626 --> 0:01:35,462
我要快速回顾一下通用型的动机

22
00:01:36,964 --> 0:01:39,066
我们会谈到设计协议

23
00:01:39,132 --> 0:01:40,734
给出一系列具体类型

24
00:01:40,801 --> 0:01:42,970
通过从标准程序库中获取的示例

25
00:01:44,471 --> 0:01:46,473
我们会回顾一下协议继承

26
00:01:46,540 --> 0:01:49,109
并谈谈条件一致性的新功能

27
00:01:49,176 --> 0:01:51,178
以及它如何与协议继承相互作用

28
00:01:51,945 --> 0:01:56,183
最后我们会通过对类和通用型的讨论

29
00:01:58,452 --> 0:02:00,954
为何通用型对于Swift

30
00:01:58,452 --> 0:02:00,954
为何通用型对于Swift

31
00:02:01,755 --> 0:02:06,860
了解它们之间相互影响的一个方式

32
00:02:08,195 --> 0:02:09,263
我们把它叫做缓冲器

33
00:02:09,596 --> 0:02:12,366
它类似于标准程序库中的数组类型

34
00:02:12,799 --> 0:02:15,802
现在对于缓冲器的可读部分来说

35
00:02:15,869 --> 0:02:18,105
可能包括元素的一个计数

36
00:02:18,405 --> 0:02:21,508
以及把每个元素

37
00:02:21,975 --> 0:02:24,211
但我们怎么让它返回类型呢？

38
00:02:25,112 --> 0:02:27,481
现在如果我们没有通用型

39
00:02:27,548 --> 0:02:29,750
有些类型可以表达

40
00:02:29,816 --> 0:02:31,552
我们想在缓冲器内放置的一切东西

41
00:02:32,052 --> 0:02:35,155
你可以调用那个类型ID

42
00:02:35,455 --> 0:02:37,124
Swift中

43
00:02:37,791 --> 0:02:41,395
它是一个可以在Swift中

44
00:02:43,864 --> 0:02:45,866
因此若你想在缓冲器中

45
00:02:45,933 --> 0:02:47,701
你可以让自定义下标返回Any

46
00:02:47,968 --> 0:02:49,436
但是当然了 你很可能知道

47
00:02:49,503 --> 0:02:52,039
那会营造一种令用户愉悦的体验

48
00:02:52,105 --> 0:02:55,576
在某个点上

49
00:02:56,043 --> 0:02:58,045
以便能实际使用它

50
00:03:00,814 --> 0:03:04,484
这不仅烦人 还容易出错

51
00:03:04,751 --> 0:03:06,987
如果你代码中的某个位置

52
00:03:07,221 --> 0:03:10,424
你在被认为是字符串的缓冲器中

53
00:03:12,292 --> 0:03:14,094
但那不仅仅关系到易用性

54
00:03:14,161 --> 0:03:15,863
我们还想解决一些问题

55
00:03:15,929 --> 0:03:19,032
关于如何在内存中表达这些值

56
00:03:21,235 --> 0:03:24,404
现在对于字符串的缓冲器来说

57
00:03:24,771 --> 0:03:26,773
就是内存的连续块

58
00:03:27,074 --> 0:03:29,743
每个元素之间用线隔开

59
00:03:31,278 --> 0:03:34,248
但如果是无类型方法

60
00:03:34,314 --> 0:03:38,685
因为缓冲器不会提前知道

61
00:03:38,752 --> 0:03:40,888
它得使用一种像Any一样的类型

62
00:03:40,954 --> 0:03:43,023
那可以涵盖任意一个可能性

63
00:03:43,457 --> 0:03:45,826
并且在那个Any中

64
00:03:45,893 --> 0:03:48,028
和把类型从箱中取出方面

65
00:03:50,597 --> 0:03:53,133
在这里 我可能只想要

66
00:03:53,200 --> 0:03:56,036
但我不能在编译器中表达它

67
00:03:56,103 --> 0:04:00,073
因此我必须为灵活性付出代价

68
00:03:56,103 --> 0:04:00,073
因此我必须为灵活性付出代价

69
00:04:01,508 --> 0:04:04,978
另外 因为Any得解释

70
00:04:05,412 --> 0:04:09,783
包括那些太大以至于

71
00:04:10,284 --> 0:04:11,985
它有时候不得不使用间接存储

72
00:04:12,252 --> 0:04:13,987
它得给值保留一个指针

73
00:04:14,054 --> 0:04:16,757
那个值可以在整个内存中定位找到

74
00:04:17,824 --> 0:04:19,293
我们真的想要解决这些问题

75
00:04:19,358 --> 0:04:23,564
不仅仅是为了易用性和正确性

76
00:04:24,731 --> 0:04:28,735
并且我们通过一种叫做

77
00:04:29,303 --> 0:04:33,507
它就是Swift中

78
00:04:35,175 --> 0:04:38,278
通过通用型方法

79
00:04:38,345 --> 0:04:40,814
用于表达缓冲器即将要包含的类型

80
00:04:41,682 --> 0:04:43,016
我们那个类型叫做元素

81
00:04:44,151 --> 0:04:46,420
元素是类型的一个通用型参数

82
00:04:46,753 --> 0:04:48,956
这就是术语参数多态性

83
00:04:49,690 --> 0:04:52,359
你可以把它看作

84
00:04:52,426 --> 0:04:54,595
它会告诉缓冲器即将要包含什么

85
00:04:55,662 --> 0:04:57,865
现在它有一种方式

86
00:04:57,931 --> 0:05:00,400
它可以使用那个元素类型

87
00:04:57,931 --> 0:05:00,400
它可以使用那个元素类型

88
00:05:03,237 --> 0:05:05,272
那意味着不再需要任何转换

89
00:05:05,339 --> 0:05:06,874
当你从缓冲器中获取类型时

90
00:05:07,341 --> 0:05:10,611
如果你意外分配了错误的类型

91
00:05:10,677 --> 0:05:13,580
或者类似的情况 编译器会捕捉你

92
00:05:15,148 --> 0:05:20,220
现在并没有这种不带相关联的

93
00:05:21,021 --> 0:05:24,458
如果你尝试声明一个那样的类型

94
00:05:26,059 --> 0:05:29,062
你可能会感觉有点吃惊

95
00:05:29,129 --> 0:05:32,499
你可以声明不带任何元素类型的类型

96
00:05:33,133 --> 0:05:34,434
但那仅仅是因为编译器

97
00:05:34,501 --> 0:05:38,172
可以根据情境推断

98
00:05:38,438 --> 0:05:40,774
在本例中

99
00:05:41,942 --> 0:05:44,745
元素仍然还在那里 就是有点含蓄

100
00:05:46,313 --> 0:05:48,515
到底包含哪种类型

101
00:05:49,383 --> 0:05:51,318
诸如缓冲器一样的类型

102
00:05:51,385 --> 0:05:55,022
可以应用在

103
00:05:56,523 --> 0:06:00,227
这意味着我们可以实现在内存的

104
00:05:56,523 --> 0:06:00,227
这意味着我们可以实现在内存的

105
00:06:00,460 --> 0:06:03,096
而不会超前

106
00:06:03,931 --> 0:06:06,600
即使那些类型任意大

107
00:06:08,468 --> 0:06:12,272
因为编译器始终能直接了解

108
00:06:12,339 --> 0:06:15,442
关于缓冲器具体包含哪种元素类型

109
00:06:15,876 --> 0:06:18,445
它就有机会进行优化

110
00:06:18,512 --> 0:06:19,980
而其它时候却没有

111
00:06:20,514 --> 0:06:23,483
那么在本例中

112
00:06:24,318 --> 0:06:27,287
一个类似这样的循环

113
00:06:27,354 --> 0:06:29,523
仅仅应用于

114
00:06:31,892 --> 0:06:36,196
现在如果你正在一个常规基础上

115
00:06:36,496 --> 0:06:37,931
用于总计整型缓冲器

116
00:06:37,998 --> 0:06:40,901
把它提取到一个方法中可能会有意义

117
00:06:41,368 --> 0:06:45,072
缓冲器上的扩展单位-可测试性更好

118
00:06:45,138 --> 0:06:47,107
当你实际调用它时也可读性也更强

119
00:06:48,208 --> 0:06:50,577
但你很可能知道如果你像这样写代码

120
00:06:50,644 --> 0:06:52,079
你会出现编译问题

121
00:06:52,446 --> 0:06:56,416
因为并不是所有的元素类型

122
00:06:57,618 --> 0:06:59,019
我们需要告诉编译器

123
00:06:59,086 --> 0:07:02,990
更多关于元素

124
00:06:59,086 --> 0:07:02,990
更多关于元素

125
00:07:03,290 --> 0:07:06,026
以便让这个方法在缓冲器上可用

126
00:07:07,394 --> 0:07:10,998
现在最简单的方式就是

127
00:07:11,064 --> 0:07:13,901
为指定类型实现

128
00:07:16,803 --> 0:07:20,007
如果你采用这种简单的方法来实现

129
00:07:20,073 --> 0:07:22,009
那么稍后的推广会很简单

130
00:07:22,075 --> 0:07:23,610
当你发现你需要

131
00:07:23,677 --> 0:07:25,946
比如总计双精度浮点型缓冲器

132
00:07:26,914 --> 0:07:29,316
请看看你所限制的类型

133
00:07:30,017 --> 0:07:31,785
查看它所遵循的协议

134
00:07:31,852 --> 0:07:34,388
并保持追踪直到你获得最通用的协议

135
00:07:34,655 --> 0:07:37,024
那你就万事俱备了

136
00:07:37,624 --> 0:07:39,726
在本例中 数字协议

137
00:07:39,793 --> 0:07:42,062
给我们提供了

138
00:07:42,429 --> 0:07:46,533
创建值为0的新元素的能力

139
00:07:46,600 --> 0:07:48,535
以及添加新元素的能力

140
00:07:48,969 --> 0:07:50,871
这是数字协议的一部分

141
00:07:53,607 --> 0:07:55,142
现在让我们谈谈

142
00:07:55,209 --> 0:07:58,445
从不同类型中析出协议的过程

143
00:08:00,180 --> 0:08:01,882
那么我们一直在谈这个缓冲器类型

144
00:08:01,949 --> 0:08:04,885
我们可以让它在不同的元素之间通用

145
00:08:05,085 --> 0:08:08,689
但是要在不同用法中通用的通用代码

146
00:08:09,122 --> 0:08:11,892
一段可以在任意不同种类的集合中

147
00:08:13,193 --> 0:08:16,230
比如数组

148
00:08:16,830 --> 0:08:18,398
但拥有更多不同种类的类型

149
00:08:18,465 --> 0:08:21,568
比如字典 它是关键值对的一个集合

150
00:08:23,136 --> 0:08:24,972
或者也许是不通用的类型

151
00:08:25,038 --> 0:08:27,975
或者不同的元素类型

152
00:08:28,041 --> 0:08:29,776
返回特定的元素类型

153
00:08:31,845 --> 0:08:36,250
我们想要创建一个协议

154
00:08:37,116 --> 0:08:39,886
我们要创建一个简化版本

155
00:08:39,953 --> 0:08:42,322
标准程序库自己的集合协议

156
00:08:45,058 --> 0:08:49,863
那么请注意 我们首先要考虑到

157
00:08:50,297 --> 0:08:52,733
现在我们正在思考一种协议

158
00:08:53,000 --> 0:08:54,601
可以把它们全部结合在一起

159
00:08:54,668 --> 0:08:57,171
有必要以这种方式进行思考

160
00:08:57,237 --> 0:08:59,072
我们要从一些具体类型开始

161
00:08:59,373 --> 0:09:01,909
然后尝试通过一个协议

162
00:08:59,373 --> 0:09:01,909
然后尝试通过一个协议

163
00:09:03,277 --> 0:09:04,811
那些类型共同拥有什么？

164
00:09:05,145 --> 0:09:06,547
它们不共同拥有什么？

165
00:09:07,681 --> 0:09:09,183
当你正设计一个这样的协议时

166
00:09:09,249 --> 0:09:11,919
你可以把它看作是一种

167
00:09:13,287 --> 0:09:14,922
这里有一个很常见的拉锯战

168
00:09:14,988 --> 0:09:17,124
在一致性类型之间 一方面

169
00:09:17,724 --> 0:09:21,528
在执行那个约束方面

170
00:09:22,596 --> 0:09:24,264
而协议的用户

171
00:09:24,531 --> 0:09:27,134
想要一个漂亮、紧凑、简单的协议

172
00:09:27,568 --> 0:09:29,369
以便实现他们的扩展

173
00:09:30,704 --> 0:09:32,206
这就是为什么非常重要的原因

174
00:09:32,272 --> 0:09:35,409
同时考虑到

175
00:09:35,843 --> 0:09:38,045
和一系列不同用例

176
00:09:38,312 --> 0:09:41,582
当你正在设计协议时

177
00:09:44,251 --> 0:09:46,653
那么让我们开始具体化集合协议吧

178
00:09:46,720 --> 0:09:48,689
那么首先我们需要表达元素类型

179
00:09:49,122 --> 0:09:51,758
现在在协议中

180
00:09:52,893 --> 0:09:56,530
每个一致性类型

181
00:09:57,364 --> 0:09:59,166
在缓冲器或数组的例子中

182
00:09:59,533 --> 0:10:02,636
对于Swift 4.2来说

183
00:09:59,533 --> 0:10:02,636
对于Swift 4.2来说

184
00:10:03,203 --> 0:10:06,440
因为我们也把它们的通用参数

185
00:10:07,641 --> 0:10:08,842
这是一很棒的附带利益

186
00:10:08,909 --> 0:10:11,345
可以赋予你的通用参数

187
00:10:11,411 --> 0:10:14,281
遵循共同的惯例

188
00:10:15,616 --> 0:10:17,985
而不是随意给它们一个名字

189
00:10:18,051 --> 0:10:20,587
你要分别陈述的是元素类型

190
00:10:21,955 --> 0:10:24,825
对于其它数据类型

191
00:10:24,892 --> 0:10:27,194
比如字典 需要把元素类型设置为

192
00:10:27,261 --> 0:10:29,429
它的关键值对和值类型

193
00:10:32,065 --> 0:10:34,835
接下来让我们谈谈添加自定义下标

194
00:10:35,836 --> 0:10:39,039
现在如果我们只谈

195
00:10:39,306 --> 0:10:43,277
我们可能会让自定义下标

196
00:10:45,312 --> 0:10:49,716
但是让自定义下标用整型

197
00:10:50,884 --> 0:10:53,954
每个一致性类型都要提供

198
00:10:54,021 --> 0:10:57,491
把元素取到

199
00:10:58,425 --> 0:11:00,761
那对于像数组一样的类型来说没问题

200
00:10:58,425 --> 0:11:00,761
那对于像数组一样的类型来说没问题

201
00:11:01,562 --> 0:11:05,132
对于协议的用户来说也非常容易理解

202
00:11:06,066 --> 0:11:08,569
但它对于稍微有些复杂的

203
00:11:08,635 --> 0:11:09,603
比如字典？

204
00:11:11,738 --> 0:11:13,774
现在无论你如何处理它

205
00:11:13,841 --> 0:11:15,475
字典很可能会被阻碍

206
00:11:15,542 --> 0:11:18,245
被一些非常复杂的内部数据结构

207
00:11:18,612 --> 0:11:21,882
在从一个元素移动到下一个元素方面

208
00:11:22,850 --> 0:11:26,420
比如它可能会被某种内部缓冲器阻碍

209
00:11:26,620 --> 0:11:31,291
它可以使用在那个缓冲器中

210
00:11:31,925 --> 0:11:34,228
然后它会把参数作为自定义下标

211
00:11:34,294 --> 0:11:37,464
以便把元素获取到那个位置

212
00:11:38,432 --> 0:11:41,168
但有一点很重要 字典的索引类型

213
00:11:41,235 --> 0:11:44,371
是一个隐含类型 只有字典可以控制

214
00:11:45,138 --> 0:11:48,208
你不希望别人在你的位移中添加1

215
00:11:48,275 --> 0:11:50,944
那未必会在字典中移动到下一个元素

216
00:11:51,011 --> 0:11:52,412
它可能会移动到任意元素

217
00:11:52,479 --> 0:11:55,716
也许会移动到字典的内部存储器中

218
00:11:56,984 --> 0:12:01,021
因此我们希望字典能控制

219
00:11:56,984 --> 0:12:01,021
因此我们希望字典能控制

220
00:12:01,221 --> 0:12:03,323
通过集合 通过改善索引实现

221
00:12:04,191 --> 0:12:08,028
那么为此我们添加了另一个

222
00:12:08,395 --> 0:12:10,931
为你提供一个

223
00:12:12,399 --> 0:12:14,401
一旦你采取了这个步骤

224
00:12:14,468 --> 0:12:17,771
你需一个startIndex属性

225
00:12:18,172 --> 0:12:20,040
因为简单的计数不再起作用了

226
00:12:20,107 --> 0:12:22,109
不能再告诉我们是否已经到达末端

227
00:12:22,643 --> 0:12:24,778
现在我们不再在索引类型中

228
00:12:26,513 --> 0:12:28,949
那么让我们把这些带回到集合协议中

229
00:12:29,950 --> 0:12:32,986
那么我们得到了一个自定义下标

230
00:12:33,053 --> 0:12:35,522
表示一个位置并给你提供一个元素

231
00:12:35,589 --> 0:12:38,091
我们还有一种

232
00:12:39,026 --> 0:12:41,828
但我们还需要类型提供

233
00:12:41,895 --> 0:12:43,530
它们即将在索引中使用的类型

234
00:12:43,764 --> 0:12:45,999
我们通过另一个相关联类型实现

235
00:12:47,835 --> 0:12:50,637
一致性类型可以提供适当的类型

236
00:12:50,704 --> 0:12:54,608
因此数组或数据可以提供一个整型

237
00:12:54,908 --> 0:12:58,045
然而字典可以提供

238
00:12:58,111 --> 0:12:59,847
处理它自己的内部逻辑

239
00:13:04,218 --> 0:13:07,054
那么让我们返回到一分钟之前

240
00:13:07,120 --> 0:13:09,456
以便推广我们的索引模型

241
00:13:09,523 --> 0:13:11,325
它仍然是一个非常有用的属性

242
00:13:11,391 --> 0:13:15,896
因此我们很想把它重新添加到集合中

243
00:13:16,663 --> 0:13:20,801
可以跨过集合 让索引向前移动

244
00:13:21,201 --> 0:13:23,804
让计数器增长然后就返回

245
00:13:26,440 --> 0:13:29,576
现在如果我们尝试实施它

246
00:13:30,511 --> 0:13:33,013
因为我们把整型

247
00:13:33,347 --> 0:13:36,650
我们再也不能假定索引类型

248
00:13:37,484 --> 0:13:40,354
整型是 但任意索引类型却没有必要

249
00:13:40,787 --> 0:13:44,024
并且我们需要它

250
00:13:45,526 --> 0:13:48,595
现在我们可以用之前所采用过的

251
00:13:48,662 --> 0:13:50,697
约束我们的扩展

252
00:13:50,764 --> 0:13:53,467
比如它只能在索引类型是等同时使用

253
00:13:54,668 --> 0:13:56,103
但感觉似乎不对劲

254
00:13:57,437 --> 0:13:59,473
我们想要一个易用的协议

255
00:13:59,673 --> 0:14:02,142
但看起来非常非常烦人

256
00:13:59,673 --> 0:14:02,142
但看起来非常非常烦人

257
00:14:02,209 --> 0:14:04,645
如果我们不得不经常

258
00:14:05,712 --> 0:14:06,813
应用这个约束

259
00:14:06,880 --> 0:14:09,883
因为我们几乎总是需要比较两个索引

260
00:14:10,250 --> 0:14:14,221
相反 它作为协议的要求

261
00:14:16,089 --> 0:14:19,092
作为我们索引相关联类型的约束

262
00:14:20,294 --> 0:14:22,095
把这个约束应用到协议上

263
00:14:22,162 --> 0:14:24,131
意味着遵循协议的全部类型

264
00:14:24,198 --> 0:14:27,301
都需要向它们的索引提供一个

265
00:14:28,569 --> 0:14:32,039
那样你就不需要

266
00:14:34,641 --> 0:14:37,444
这是协商协议约束的另一个例子

267
00:14:38,779 --> 0:14:40,647
协议的用户有一个要求

268
00:14:40,714 --> 0:14:43,083
他们需要能比较索引

269
00:14:43,650 --> 0:14:47,688
一致性协议 他们查看了一下

270
00:14:47,754 --> 0:14:49,590
而不需要放弃太多的灵活性

271
00:14:51,024 --> 0:14:52,559
在本例中他们当然可以

272
00:14:53,460 --> 0:14:56,196
数据和数组所使用的整型

273
00:14:56,630 --> 0:15:00,300
并且通过Swift 4.2的

274
00:14:56,630 --> 0:15:00,300
并且通过Swift 4.2的

275
00:15:01,301 --> 0:15:04,204
字典可以很简单地把它的索引类型

276
00:15:07,074 --> 0:15:10,344
接下来让我们谈谈优化这个计数操作

277
00:15:10,410 --> 0:15:12,312
通过一个自定义点

278
00:15:14,348 --> 0:15:16,884
那么我们已经写了一个版本的计数

279
00:15:17,384 --> 0:15:20,487
计算集合中元素的数量

280
00:15:20,554 --> 0:15:22,256
通过跨过整个集合

281
00:15:22,322 --> 0:15:25,792
但很明显 许多集合很可能做得更快

282
00:15:26,593 --> 0:15:29,496
比如 假如字典在内部保留

283
00:15:29,563 --> 0:15:31,465
它所持有的元素数量

284
00:15:31,532 --> 0:15:32,633
用于实现自己的目的

285
00:15:33,467 --> 0:15:34,735
如果它拥有这个信息

286
00:15:34,801 --> 0:15:37,504
它就可以在它自己的计数实施中

287
00:15:38,605 --> 0:15:41,408
那意味着当人们在字典上调用计数时

288
00:15:41,975 --> 0:15:43,677
他们会获得快速、恒定的时间

289
00:15:44,044 --> 0:15:45,212
而不是线性时间

290
00:15:45,279 --> 0:15:48,215
是指那个适用于任意集合的原始版本

291
00:15:49,816 --> 0:15:52,686
但当添加这样的优化时

292
00:15:52,753 --> 0:15:56,290
即旅行协议的要求之间的不同点

293
00:15:56,857 --> 0:16:00,060
和仅在指定类型上添加大量负载

294
00:15:56,857 --> 0:16:00,060
和仅在指定类型上添加大量负载

295
00:16:01,128 --> 0:16:05,799
直到现在 这个字典上的计数新版本

296
00:16:06,533 --> 0:16:08,435
那意味着当你有一个字典时

297
00:16:08,836 --> 0:16:10,204
你知道它是一个字典

298
00:16:10,437 --> 0:16:12,506
你将会获得更新、更好的计数版本

299
00:16:13,440 --> 0:16:16,009
但如果在通用算法内部调用它

300
00:16:18,545 --> 0:16:20,180
那么假如我们希望 比如说

301
00:16:20,247 --> 0:16:22,649
写一个标准程序库的地图版本？

302
00:16:23,116 --> 0:16:26,253
如果你还不熟悉它

303
00:16:26,653 --> 0:16:29,556
可以转换集合中的每一个元素

304
00:16:29,623 --> 0:16:31,592
并给你返回一个新数组

305
00:16:33,126 --> 0:16:34,928
这个实施非常简单

306
00:16:34,995 --> 0:16:36,730
它只是创建一个新数组

307
00:16:37,364 --> 0:16:38,565
在集合内部移动

308
00:16:38,999 --> 0:16:41,668
转换每一个元素

309
00:16:42,936 --> 0:16:45,539
现在随着你在像这样的数组中

310
00:16:45,606 --> 0:16:47,841
数组会自动增长

311
00:16:48,575 --> 0:16:53,080
它随着需要增长

312
00:16:53,146 --> 0:16:55,749
以便拥有更多的空间来容纳新元素

313
00:16:56,517 --> 0:16:59,453
在一个这样的循环中

314
00:16:59,520 --> 0:17:00,787
取决于它要变得多大

315
00:16:59,520 --> 0:17:00,787
取决于它要变得多大

316
00:17:01,455 --> 0:17:02,856
那么这个过程需要时间

317
00:17:03,056 --> 0:17:05,492
分配内存的消耗非常大

318
00:17:06,727 --> 0:17:09,863
有一个很棒的优化小技巧

319
00:17:10,564 --> 0:17:14,001
我们已经了解

320
00:17:14,501 --> 0:17:17,471
它会跟我们原始集合的尺寸一样大

321
00:17:18,605 --> 0:17:23,510
那么我们可以

322
00:17:23,577 --> 0:17:26,914
在我们开始添加之前

323
00:17:27,580 --> 0:17:29,650
为此我们要调用计数

324
00:17:30,984 --> 0:17:32,452
但我们在这里调用计数

325
00:17:32,519 --> 0:17:35,489
在通用情境中

326
00:17:35,822 --> 0:17:40,727
也就是集合类型是完全通用的情境

327
00:17:40,794 --> 0:17:43,764
可以是一个数组或字典或链表或任意

328
00:17:44,731 --> 0:17:47,301
那么我们不知道有一个

329
00:17:47,568 --> 0:17:50,137
更好的计数实施可用

330
00:17:50,204 --> 0:17:52,039
当编译器编译这段代码时

331
00:17:52,973 --> 0:17:56,877
那么在这种情况下

332
00:17:57,344 --> 0:18:00,614
实际上是计数的通用版本

333
00:17:57,344 --> 0:18:00,614
实际上是计数的通用版本

334
00:18:00,814 --> 0:18:02,883
并会在整个集合上进行迭代

335
00:18:03,617 --> 0:18:05,052
如果你在字典上调用地图

336
00:18:05,118 --> 0:18:08,655
就不会调用我们刚写的计数的新版本

337
00:18:11,124 --> 0:18:14,728
为了在通用情境中调用

338
00:18:15,195 --> 0:18:18,131
像这样的自定义方法或属性

339
00:18:18,632 --> 0:18:22,002
它需要在协议上

340
00:18:23,504 --> 0:18:26,106
我们已经确定一定有一种方式

341
00:18:26,173 --> 0:18:29,209
可以让某些集合提供计数的优化版本

342
00:18:29,576 --> 0:18:33,213
这样它在协议上

343
00:18:34,348 --> 0:18:38,085
现在即便我们把它作为

344
00:18:39,786 --> 0:18:42,756
所有集合

345
00:18:42,823 --> 0:18:45,559
因为我们已经通过我们的扩展

346
00:18:45,626 --> 0:18:47,094
可以应用在任意集合上

347
00:18:48,695 --> 0:18:51,798
向协议中添加一个要求

348
00:18:51,865 --> 0:18:54,902
通过一个扩展添加一个默认实施

349
00:18:55,169 --> 0:18:58,238
这就是我们称为自定义点的东西

350
00:19:00,207 --> 0:19:02,609
通过自定义点 编译器可以了解

351
00:19:02,809 --> 0:19:05,812
有一个可用的方法

352
00:19:05,879 --> 0:19:09,716
因此在通用情境中

353
00:19:09,783 --> 0:19:13,987
它会在协议中动态地调遣那个实施

354
00:19:15,489 --> 0:19:18,025
那么现在如果你在字典上调用地图

355
00:19:18,292 --> 0:19:20,294
即便是一个完全通用的函数

356
00:19:20,494 --> 0:19:22,663
你将会得到计数的更好的实施

357
00:19:24,531 --> 0:19:26,466
添加这样的自定义点

358
00:19:26,800 --> 0:19:29,403
同时通过扩展添加默认实施

359
00:19:30,337 --> 0:19:33,106
是一种很强大的方式

360
00:19:33,340 --> 0:19:35,175
跟你用类获得的好处一样

361
00:19:35,242 --> 0:19:37,744
实施继承和方法重写

362
00:19:38,212 --> 0:19:42,416
但这个技巧可以用在

363
00:19:45,252 --> 0:19:48,455
现在并不是每一个方法

364
00:19:49,122 --> 0:19:54,161
并且自定义点在你的二进制尺寸上

365
00:19:54,228 --> 0:19:55,929
你的编译器运行时间的性能

366
00:19:56,363 --> 0:19:58,732
那么只有当明确有机会自定义时

367
00:19:59,132 --> 0:20:01,835
添加自定义点才有意义

368
00:19:59,132 --> 0:20:01,835
添加自定义点才有意义

369
00:20:02,503 --> 0:20:05,105
比如在我们刚写的地图操作中

370
00:20:05,405 --> 0:20:08,509
并没有合理的方式让任意种类的集合

371
00:20:08,842 --> 0:20:11,578
提供更好的实施

372
00:20:12,012 --> 0:20:14,815
因此把它添加为一个自定义点

373
00:20:15,048 --> 0:20:16,984
仅仅保持为一个扩展就可以了

374
00:20:18,585 --> 0:20:20,554
那么我们已经创建了这个集合类型

375
00:20:20,621 --> 0:20:22,089
且它其实已拥有了完整的功能

376
00:20:22,155 --> 0:20:25,058
它有尽可能多的不同的一致性类型

377
00:20:25,125 --> 0:20:27,895
你可以为它写许多不同但有用的算法

378
00:20:28,562 --> 0:20:31,298
但有时候

379
00:20:31,532 --> 0:20:33,700
为了将各种类型进行分类

380
00:20:34,601 --> 0:20:36,336
你需要协议继承

381
00:20:36,870 --> 0:20:39,006
为了让大家了解更多信息

382
00:20:40,774 --> 0:20:45,913
（协议继承）

383
00:20:45,979 --> 0:20:46,813
谢谢Ben

384
00:20:48,549 --> 0:20:51,718
那么协议继承

385
00:20:52,286 --> 0:20:54,922
为了考虑我们在哪里需要协议继承

386
00:20:54,988 --> 0:20:57,925
让我们看一下

387
00:20:57,991 --> 0:21:00,027
它是一个很好的协议 设计很棒

388
00:20:57,991 --> 0:21:00,027
它是一个很好的协议 设计很棒

389
00:21:00,527 --> 0:21:02,563
它描述了一组一致性类型

390
00:21:02,963 --> 0:21:06,300
可以让你在类型上写一些

391
00:21:06,700 --> 0:21:10,704
但我们不用做太多

392
00:21:10,771 --> 0:21:14,608
依据目前的集合协议 我们不能实施

393
00:21:15,142 --> 0:21:19,046
比如如果我们想在集合中找到

394
00:21:19,379 --> 0:21:20,714
匹配某谓语的最后一个元素索引

395
00:21:20,781 --> 0:21:24,451
最佳方式就是从末端开始

396
00:21:24,985 --> 0:21:26,954
集合协议不允许我们这样做

397
00:21:27,888 --> 0:21:30,090
或者加入我们想创建一个洗牌操作

398
00:21:30,157 --> 0:21:32,626
以便在集合中的元素之间随机洗牌

399
00:21:32,826 --> 0:21:35,662
嗯 那需要突变 而集合不允许这样

400
00:21:35,729 --> 0:21:38,432
现在并不是因为集合协议错了

401
00:21:39,833 --> 0:21:41,668
而是我们需要更多的东西

402
00:21:41,735 --> 0:21:44,204
来描述这些额外的通用算法

403
00:21:44,605 --> 0:21:46,940
这就需要协议继承

404
00:21:47,274 --> 0:21:49,776
这是BidirectionalCollection协议

405
00:21:49,977 --> 0:21:52,846
继承自集合或者继承集合

406
00:21:53,614 --> 0:21:54,982
意思就是

407
00:21:55,048 --> 0:21:57,851
遵循BidirectionalCollection协议的

408
00:21:58,285 --> 0:21:59,620
同样也会遵循集合

409
00:21:59,686 --> 0:22:01,688
你可以使用那些集合算法

410
00:21:59,686 --> 0:22:01,688
你可以使用那些集合算法

411
00:22:02,122 --> 0:22:04,758
但是BidirectionalCollection

412
00:22:04,825 --> 0:22:07,861
就是能在集合中倒着操作

413
00:22:08,695 --> 0:22:09,897
有一个重点需要注意

414
00:22:09,963 --> 0:22:13,500
并不是每个集合都可以实施

415
00:22:13,901 --> 0:22:18,005
思考一下SinglyLinkedList

416
00:22:18,071 --> 0:22:19,973
从一个位置跳到下一个位置

417
00:22:20,040 --> 0:22:22,843
并没有一种有效的方式

418
00:22:22,910 --> 0:22:25,379
因此它不能是

419
00:22:25,679 --> 0:22:27,281
那么一旦我们引入了继承

420
00:22:27,347 --> 0:22:29,449
你就已经限制了一致性类型

421
00:22:30,050 --> 0:22:33,987
但你也允许你自己

422
00:22:34,221 --> 0:22:37,090
那么这是这个lastIndex(where:)

423
00:22:37,357 --> 0:22:40,661
非常简单

424
00:22:40,961 --> 0:22:44,598
使用这个来自BidirectionalCollection

425
00:22:46,567 --> 0:22:48,535
让我们看一个更有意思的算法

426
00:22:48,836 --> 0:22:50,337
那么这是一个洗牌操作

427
00:22:50,404 --> 0:22:53,607
那么它在Swift 4.2中

428
00:22:53,674 --> 0:22:55,108
你不需要自己实施它

429
00:22:55,175 --> 0:22:56,643
我们会查看算法自身

430
00:22:56,710 --> 0:22:59,079
了解它引入了哪些要求

431
00:22:59,146 --> 0:23:02,616
从而算出如何有意义地将那些

432
00:22:59,146 --> 0:23:02,616
从而算出如何有意义地将那些

433
00:23:03,283 --> 0:23:06,086
Fisher-Yates洗牌算法

434
00:23:06,153 --> 0:23:07,254
它也非常简单

435
00:23:07,487 --> 0:23:10,691
你从集合中第一个元素的索引开始

436
00:23:11,525 --> 0:23:13,861
然后随机选择

437
00:23:14,161 --> 0:23:17,197
集合中另一个元素

438
00:23:18,498 --> 0:23:22,703
在下一次迭代中

439
00:23:23,470 --> 0:23:26,507
在那个和最后一个之间随机选择

440
00:23:26,807 --> 0:23:28,408
那么算法非常简单

441
00:23:28,475 --> 0:23:31,044
只是集合中的线性移动

442
00:23:31,879 --> 0:23:34,281
随机选择另一个元素进行交换

443
00:23:34,681 --> 0:23:38,452
在最后你会得到一个

444
00:23:39,486 --> 0:23:41,288
那么我们可以看一下代码

445
00:23:41,355 --> 0:23:43,557
有一点复杂 但不要担心

446
00:23:43,624 --> 0:23:46,560
我们要在某个集合上实施它

447
00:23:46,827 --> 0:23:48,829
那么让我们看一下这里的核心操作

448
00:23:48,896 --> 0:23:50,430
那么首先我们需要能获取

449
00:23:50,497 --> 0:23:53,033
随机编号

450
00:23:53,100 --> 0:23:56,103
和集合末端之间 通过这个随机功能

451
00:23:56,336 --> 0:23:57,304
但那儿有一个整型

452
00:23:57,371 --> 0:23:59,239
我们需要的是集合中的索引

453
00:23:59,306 --> 0:24:00,474
我们知道那是不同的

454
00:23:59,306 --> 0:24:00,474
我们知道那是不同的

455
00:24:00,541 --> 0:24:02,042
所以我们需要一些操作

456
00:24:02,109 --> 0:24:03,744
让我们把它叫做

457
00:24:04,478 --> 0:24:06,113
从startIndex迅速跳到

458
00:24:06,480 --> 0:24:08,749
我们所选择的任意位置

459
00:24:10,050 --> 0:24:13,854
我们所需要的另一个操作是

460
00:24:14,888 --> 0:24:17,891
很棒 我们有两个操作

461
00:24:17,958 --> 0:24:20,994
到集合的概念中 以便可以实施洗牌

462
00:24:21,295 --> 0:24:23,764
因此我们有一个

463
00:24:26,633 --> 0:24:27,801
请不要这样做

464
00:24:28,068 --> 0:24:30,037
那么这是一个反面模式

465
00:24:30,504 --> 0:24:33,140
这里的反面模式是我们有一个算法

466
00:24:33,207 --> 0:24:34,408
我们找到它的要求

467
00:24:34,808 --> 0:24:38,412
然后我们把它打包到一个协议中

468
00:24:39,246 --> 0:24:40,814
描述那一个算法

469
00:24:41,048 --> 0:24:44,651
如果你这样做了

470
00:24:44,952 --> 0:24:46,553
但并没有任何意义

471
00:24:46,620 --> 0:24:48,956
你并不是在从那些协议中学习什么

472
00:24:49,022 --> 0:24:51,358
因此你应该做的是注意

473
00:24:51,425 --> 0:24:53,927
我们实际上在这里有不同的功能

474
00:24:54,394 --> 0:24:57,497
那么洗牌使用的是随机存取

475
00:24:57,898 --> 0:25:01,702
但这些是不同的 并且我们可以

476
00:24:57,898 --> 0:25:01,702
但这些是不同的 并且我们可以

477
00:25:01,768 --> 0:25:04,571
比如

478
00:25:04,938 --> 0:25:08,475
就是可以让我们在集合中

479
00:25:08,542 --> 0:25:09,743
可以迅速移动索引

480
00:25:10,410 --> 0:25:12,513
还有像UnsafeBufferPointer的类型

481
00:25:12,579 --> 0:25:16,650
可以给你提供随机存取

482
00:25:16,717 --> 0:25:18,118
这是不同的功能

483
00:25:18,986 --> 0:25:21,522
我们这里还有

484
00:25:22,256 --> 0:25:24,525
我们可以认为这里的类型允许突变

485
00:25:24,591 --> 0:25:25,626
但不允许随机获取

486
00:25:25,692 --> 0:25:28,195
就像我们刚讲过的

487
00:25:28,529 --> 0:25:32,032
现在请注意我们已经从根本上

488
00:25:33,233 --> 0:25:36,537
我们有用于随机存取

489
00:25:36,603 --> 0:25:38,338
然后我们有这个突变端

490
00:25:38,705 --> 0:25:42,543
非常完美

491
00:25:42,843 --> 0:25:45,245
用来实施他们所写的通用算法

492
00:25:45,612 --> 0:25:47,514
那么让我们返回到我们的洗牌算法

493
00:25:47,581 --> 0:25:51,752
它可以在RandomAccessCollection上

494
00:25:51,818 --> 0:25:52,653
带有自类型

495
00:25:52,719 --> 0:25:55,422
所以这是一个既遵循

496
00:25:55,656 --> 0:25:58,058
又遵循MutableCollection协议的类型

497
00:25:58,592 --> 0:26:01,295
现在我们把这两个协议的功能

498
00:25:58,592 --> 0:26:01,295
现在我们把这两个协议的功能

499
00:26:02,429 --> 0:26:05,532
现在当你拥有许多一致性类型时

500
00:26:05,599 --> 0:26:07,301
以及许多通用算法时

501
00:26:07,367 --> 0:26:10,237
你常常会形成协议等级

502
00:26:10,671 --> 0:26:13,073
这些等级不应该太长

503
00:26:13,140 --> 0:26:15,042
不应该太深入

504
00:26:15,809 --> 0:26:17,711
因为你其实是希望要少量的协议

505
00:26:17,778 --> 0:26:21,381
只要能描述在域名中出现的类型即可

506
00:26:22,583 --> 0:26:24,318
现在你一定注意到了

507
00:26:24,384 --> 0:26:26,553
当你着手创建这些协议等级时

508
00:26:26,620 --> 0:26:29,056
那么随着你从等级的底层到顶层

509
00:26:29,489 --> 0:26:32,893
你得到的协议会拥有较少的要求

510
00:26:32,960 --> 0:26:36,630
因此有更多的一致性类型

511
00:26:37,464 --> 0:26:40,100
现在从另一方面说

512
00:26:40,801 --> 0:26:43,370
并结合等级中不同的协议

513
00:26:43,437 --> 0:26:46,640
你就要实施更复杂、更专业的算法

514
00:26:46,707 --> 0:26:48,775
要求更高级的功能

515
00:26:48,842 --> 0:26:51,011
但实际上只能用于

516
00:26:53,213 --> 0:26:54,047
好的

517
00:26:55,582 --> 0:26:57,217
让我们谈谈条件一致性

518
00:26:57,284 --> 0:26:59,820
这是 当然了

519
00:27:00,654 --> 0:27:02,990
让我们首先从切片开始看

520
00:27:03,524 --> 0:27:07,961
对于你所拥有的任意一个集合

521
00:27:08,161 --> 0:27:12,833
通过带有指定

522
00:27:13,300 --> 0:27:16,770
并且那个切片

523
00:27:17,971 --> 0:27:21,909
现在你在切片集合中

524
00:27:22,209 --> 0:27:23,677
叫做切片

525
00:27:24,444 --> 0:27:26,513
并且切片是一个通用的适配器类型

526
00:27:27,314 --> 0:27:30,951
那么它在基础集合类型上参数化了

527
00:27:31,552 --> 0:27:33,187
它自己就是一个集合

528
00:27:33,954 --> 0:27:37,891
所以我们对于切片的期待就是

529
00:27:37,958 --> 0:27:40,027
你能对下面的集合所做的事

530
00:27:40,093 --> 0:27:41,528
这个要求很合理

531
00:27:41,929 --> 0:27:44,932
我们当然可以使用向前搜索操作

532
00:27:44,998 --> 0:27:47,701
比如index(where:)

533
00:27:47,768 --> 0:27:50,671
那适用于集合

534
00:27:51,505 --> 0:27:54,141
我们想用向后搜索来做同样的事

535
00:27:54,208 --> 0:27:55,809
但在这里我们会产生一个问题

536
00:27:55,876 --> 0:27:58,512
即便缓冲器是一个

537
00:27:59,346 --> 0:28:02,149
并没说切片也是一个

538
00:27:59,346 --> 0:28:02,149
并没说切片也是一个

539
00:28:04,685 --> 0:28:05,619
我们可以修复这个问题

540
00:28:05,886 --> 0:28:09,623
让我们把切片扩展一下

541
00:28:10,457 --> 0:28:12,526
我们需要实施这个

542
00:28:12,593 --> 0:28:16,163
这样我们可以按照下面的基础集合

543
00:28:17,064 --> 0:28:18,966
除非编译器会在这里进行约束

544
00:28:19,700 --> 0:28:22,236
关于基础集合

545
00:28:22,302 --> 0:28:23,570
它是一个集合

546
00:28:23,637 --> 0:28:26,273
它并没有

547
00:28:27,808 --> 0:28:28,942
我们知道如何修复这个问题

548
00:28:29,476 --> 0:28:32,579
我们所需要做的就是

549
00:28:32,646 --> 0:28:35,282
换句话说就是基础集合需要是

550
00:28:35,716 --> 0:28:37,251
这是条件一致性

551
00:28:38,085 --> 0:28:42,356
其实就是扩展声明遵循某个协议

552
00:28:42,723 --> 0:28:46,159
然后那个协议下的约束条件

553
00:28:46,994 --> 0:28:48,829
关于条件一致性的最棒的事就是

554
00:28:48,896 --> 0:28:51,732
当你拥有这些协议等级时

555
00:28:51,798 --> 0:28:55,636
所以我们还可以说切片是一个

556
00:28:55,969 --> 0:28:59,306
当它下面的基础类型是

557
00:29:00,374 --> 0:29:03,010
现在请注意

558
00:29:03,744 --> 0:29:05,579
它是常见的Swift样式

559
00:29:06,013 --> 0:29:08,348
写扩展 让它遵循某个协议

560
00:29:08,415 --> 0:29:11,051
这样你就知道该扩展是干什么的

561
00:29:11,418 --> 0:29:16,223
它有条件一致性特别重要

562
00:29:16,290 --> 0:29:19,793
因为你在这些扩展上有不同的要求

563
00:29:21,261 --> 0:29:22,829
这就允许有可组合性

564
00:29:22,896 --> 0:29:25,299
无论下面的基层集合可以做什么

565
00:29:25,832 --> 0:29:27,367
切片类型同样也可以做

566
00:29:30,470 --> 0:29:33,040
那么让我们看看

567
00:29:33,106 --> 0:29:35,409
也是在标准程序库中 这些是范围

568
00:29:35,475 --> 0:29:37,611
那么范围永远存在于Swift中

569
00:29:37,678 --> 0:29:40,948
你可以形成一个范围

570
00:29:41,415 --> 0:29:45,352
因此你可以形成双精度浮点型范围

571
00:29:45,886 --> 0:29:48,155
但有些范围比另外一些更强大

572
00:29:48,355 --> 0:29:52,326
那么你可以在整型范围内迭代元素

573
00:29:52,860 --> 0:29:53,827
为什么你能这样做呢？

574
00:29:53,894 --> 0:29:56,797
那是因为intRange遵循集合

575
00:29:58,198 --> 0:29:59,833
现在如果你查看一下类型

576
00:29:59,900 --> 0:30:01,969
由那个运算符创建的类型

577
00:29:59,900 --> 0:30:01,969
由那个运算符创建的类型

578
00:30:02,302 --> 0:30:04,738
它适当地命名了范围类型

579
00:30:05,305 --> 0:30:08,075
它相对于下面的绑定类型来说

580
00:30:08,141 --> 0:30:10,043
这种情况下

581
00:30:10,110 --> 0:30:12,513
它仅仅存储较低和较高的绑定型

582
00:30:12,579 --> 0:30:13,580
非常简单

583
00:30:14,248 --> 0:30:18,819
但在Swift 4.2之前

584
00:30:18,886 --> 0:30:20,320
实际上是一个不同的类型

585
00:30:20,387 --> 0:30:22,289
这是CountableRange类型

586
00:30:23,090 --> 0:30:25,993
现在请注意

587
00:30:26,059 --> 0:30:27,160
它有一个类型参数

588
00:30:27,227 --> 0:30:28,729
它有较低和较高绑定型

589
00:30:29,329 --> 0:30:33,066
但它在那个绑定型上

590
00:30:33,300 --> 0:30:35,369
那个绑定型是可跨过的 对吧？

591
00:30:35,435 --> 0:30:37,771
意思是你可以枚举全部元素

592
00:30:37,838 --> 0:30:40,007
现在这是你所需要的功能 从而可以

593
00:30:40,073 --> 0:30:42,709
让CountableRange遵循

594
00:30:43,777 --> 0:30:46,813
那就启用了forEach迭代循环

595
00:30:47,981 --> 0:30:50,851
但是通过条件一致性 当然了

596
00:30:51,518 --> 0:30:56,089
让我们把基础范围类型

597
00:30:56,890 --> 0:31:01,395
当绑定类型

598
00:30:56,890 --> 0:31:01,395
当绑定类型

599
00:31:01,662 --> 0:31:04,064
它是条件一致性的简单app

600
00:31:04,131 --> 0:31:09,236
但它让范围类型变得更强大

601
00:31:10,737 --> 0:31:14,842
现在请注意我只是遵循

602
00:31:15,442 --> 0:31:19,279
我其实没有提到集合

603
00:31:20,113 --> 0:31:22,683
这是无条件顺应 没问题

604
00:31:22,983 --> 0:31:25,652
声明遵循

605
00:31:25,719 --> 0:31:29,523
暗示着遵循它所继承的任何协议

606
00:31:29,590 --> 0:31:32,125
在本例中是

607
00:31:32,693 --> 0:31:35,696
然而对于条件一致性

608
00:31:36,563 --> 0:31:38,632
现在如果你回想一下切片例子

609
00:31:38,699 --> 0:31:40,968
我们需要有不同的约束

610
00:31:41,235 --> 0:31:43,637
来处理那些不同的等级

611
00:31:43,704 --> 0:31:45,639
针对集合与

612
00:31:45,706 --> 0:31:47,241
与RandomAccessCollection

613
00:31:47,708 --> 0:31:50,577
因此编译器会强制执行

614
00:31:50,644 --> 0:31:53,180
并确保你拥有正确的约束条件

615
00:31:53,247 --> 0:31:54,781
对于条件一致性来说

616
00:31:55,849 --> 0:31:59,052
在本例中

617
00:31:59,353 --> 0:32:02,856
我们可以只明确写出集合

618
00:31:59,353 --> 0:32:02,856
我们可以只明确写出集合

619
00:32:03,290 --> 0:32:06,026
以宣称这就是全部一致性的位置

620
00:32:06,426 --> 0:32:08,495
或者我们可以做得更好

621
00:32:08,695 --> 0:32:10,597
分离不同的一致性

622
00:32:12,432 --> 0:32:15,269
现在这点上

623
00:32:15,335 --> 0:32:17,137
它会做一切CountableRange

624
00:32:17,204 --> 0:32:19,106
我们应该如何使用

625
00:32:19,506 --> 0:32:20,541
我们可以把它丢到一边去

626
00:32:20,607 --> 0:32:22,576
在本例中我们讲的是标准程序库

627
00:32:22,643 --> 0:32:25,679
有许多代码实际上使用了

628
00:32:25,946 --> 0:32:29,583
因此我们可以把它作为通用类型别名

629
00:32:30,951 --> 0:32:32,419
这是一个很棒的方案

630
00:32:32,486 --> 0:32:36,256
那么通用类型别名添加了

631
00:32:36,523 --> 0:32:37,791
让范围可计数所需要的全部额外要求

632
00:32:38,025 --> 0:32:40,794
你需要把这些要求放在集合中

633
00:32:41,395 --> 0:32:44,865
但它只是下面范围类型的

634
00:32:46,700 --> 0:32:48,235
这对于源兼容性来说很棒

635
00:32:48,302 --> 0:32:50,804
因为代码仍可使用

636
00:32:51,071 --> 0:32:54,107
从另一方面说 它还可以

637
00:32:54,308 --> 0:32:57,311
给那些拥有额外功能的范围

638
00:32:57,377 --> 0:32:59,213
额外功能只是成为

639
00:32:59,880 --> 0:33:02,149
事实上我们可以用此来清理其它代码

640
00:32:59,880 --> 0:33:02,149
事实上我们可以用此来清理其它代码

641
00:33:02,216 --> 0:33:04,518
比如 我们知道什么是

642
00:33:04,818 --> 0:33:08,055
它是带有这种额外跨越功能的范围

643
00:33:08,589 --> 0:33:10,591
因此我们可以扩展

644
00:33:10,858 --> 0:33:14,995
这就是我们拥有RandomAccessCollection

645
00:33:16,430 --> 0:33:18,198
Swift 4.2中引入了这个

646
00:33:18,632 --> 0:33:21,068
用于帮助简化我们要处理的类型

647
00:33:21,134 --> 0:33:23,303
并让现有核心类型 比如范围

648
00:33:23,570 --> 0:33:25,339
组合性更强 也更灵活

649
00:33:27,608 --> 0:33:28,442
好的

650
00:33:29,476 --> 0:33:30,477
最后一个话题

651
00:33:31,411 --> 0:33:33,413
那么Swift是一个多范式语言

652
00:33:33,480 --> 0:33:36,016
现在我们一直在专心讲通用型

653
00:33:36,083 --> 0:33:39,152
但是当然了

654
00:33:40,087 --> 0:33:41,622
那么我想花一些时间

655
00:33:41,688 --> 0:33:44,758
谈谈这两个功能之间的相互影响

656
00:33:44,825 --> 0:33:47,060
以及它们如何在Swift语言中

657
00:33:47,594 --> 0:33:51,465
那么对于类继承

658
00:33:51,532 --> 0:33:52,432
非常简单

659
00:33:52,799 --> 0:33:54,868
你可以声明一个超类 比如汽车

660
00:33:54,935 --> 0:33:57,871
你可以声明某些子类

661
00:33:57,938 --> 0:33:59,373
它们都继承自汽车

662
00:34:00,007 --> 0:34:02,910
一旦你这么做了

663
00:34:03,343 --> 0:34:06,947
你期望那些子类可以在哪里使用

664
00:34:07,381 --> 0:34:10,150
那么如果我要用一个新方法扩展汽车

665
00:34:10,217 --> 0:34:11,251
让它变成驱动器

666
00:34:11,918 --> 0:34:16,556
我非常期待我可以在我的一个子类上

667
00:34:17,925 --> 0:34:21,862
那么这是面向对象编程中的一个

668
00:34:22,161 --> 0:34:25,065
Barbara Liskov其实

669
00:34:25,132 --> 0:34:26,567
在80年代的一场演讲中

670
00:34:27,234 --> 0:34:30,571
自那时起 我们就把这个叫做

671
00:34:30,904 --> 0:34:32,773
理念其实很简单

672
00:34:33,273 --> 0:34:35,876
那么如果你的程序中有一些地方

673
00:34:35,943 --> 0:34:41,348
引用了一个超类型或超类 比如汽车

674
00:34:42,349 --> 0:34:46,420
你就应该可以获取它的子类型

675
00:34:47,286 --> 0:34:50,858
比如出租车或汽车子类 并使用它

676
00:34:51,257 --> 0:34:54,494
程序应该仍然继续监测类型

677
00:34:55,062 --> 0:34:57,397
那么这里的替换是作为子类的实例

678
00:34:57,464 --> 0:35:00,734
应该可以去到

679
00:34:57,464 --> 0:35:00,734
应该可以去到

680
00:35:01,768 --> 0:35:03,270
这是一个很简单的原则

681
00:35:03,337 --> 0:35:06,473
我们把它内在化了 但它仍然很强大

682
00:35:06,840 --> 0:35:08,108
如果你思考一下的话

683
00:35:08,342 --> 0:35:09,910
请考虑你程序中的任何一点

684
00:35:09,977 --> 0:35:12,079
如果我得到一个不同的子类

685
00:35:12,145 --> 0:35:14,214
也许是一个我没有想到的子类？

686
00:35:15,516 --> 0:35:18,185
那么返回到通用型

687
00:35:19,353 --> 0:35:22,823
当在通用型系统上应用

688
00:35:23,156 --> 0:35:24,725
Liskov替换原则时

689
00:35:25,392 --> 0:35:28,195
也许我们添加了一个新协议

690
00:35:28,762 --> 0:35:31,665
并把汽车扩展为可驾驶

691
00:35:31,899 --> 0:35:33,166
我们期待发生什么呢？

692
00:35:33,233 --> 0:35:36,503
我们期待你可以使用协议一致性

693
00:35:36,570 --> 0:35:40,073
把汽车的一致性用于可驾驶的一致性

694
00:35:41,041 --> 0:35:45,179
比如你在可驾驶协议中

695
00:35:45,245 --> 0:35:46,713
比如sundayDrive

696
00:35:46,780 --> 0:35:50,884
现在你应该可以在警车上使用

697
00:35:51,351 --> 0:35:53,220
即使这并不是最好的方式

698
00:35:54,721 --> 0:36:00,260
那么子类有效地继承了协议一致性

699
00:35:54,721 --> 0:36:00,260
那么子类有效地继承了协议一致性

700
00:36:01,195 --> 0:36:03,197
并且这在一致性上添加了约束

701
00:36:03,263 --> 0:36:04,865
你所写的那个一致性

702
00:36:04,932 --> 0:36:07,401
就是让汽车可驾驶的东西

703
00:36:07,668 --> 0:36:10,637
现在必须适用于汽车的全部子类

704
00:36:10,938 --> 0:36:13,307
以及稍后出现的子类

705
00:36:14,274 --> 0:36:16,710
大部分时候就是有用

706
00:36:17,711 --> 0:36:19,046
然而在某些情况下

707
00:36:19,112 --> 0:36:22,482
它会在子类上添加一些新要求

708
00:36:23,116 --> 0:36:27,487
最常见的就是

709
00:36:28,555 --> 0:36:30,757
那么如果你查看了可解协议

710
00:36:30,824 --> 0:36:34,461
它有一个有趣的要求

711
00:36:34,795 --> 0:36:39,099
从解码器中创建符合型的新实例

712
00:36:40,667 --> 0:36:41,602
我们要如何使用它呢？

713
00:36:41,869 --> 0:36:44,838
让我们继续向可解协议中

714
00:36:45,138 --> 0:36:48,542
它是一个静态方法解码

715
00:36:48,742 --> 0:36:51,612
其实就是初始化程序的一个包装

716
00:36:52,379 --> 0:36:56,884
关于这个特定的方法

717
00:36:57,284 --> 0:36:59,820
首先它是否一个

718
00:36:59,887 --> 0:37:01,588
请记住这是一致性类型

719
00:36:59,887 --> 0:37:01,588
请记住这是一致性类型

720
00:37:01,889 --> 0:37:04,992
它与你在静态方法上调用的类型相同

721
00:37:06,560 --> 0:37:10,163
现在第二件有意思的事是

722
00:37:10,230 --> 0:37:12,833
我们调用上边那个初始化程序

723
00:37:12,900 --> 0:37:14,601
来创建一个全新的实例

724
00:37:14,902 --> 0:37:19,406
是我们所拥有的可解码类型的实例

725
00:37:21,208 --> 0:37:22,042
很公平

726
00:37:22,543 --> 0:37:24,945
我们可以继续并让汽车类型可解码

727
00:37:25,812 --> 0:37:27,748
然后我们期待

728
00:37:27,814 --> 0:37:29,716
当应用Liskov替换原理时

729
00:37:29,783 --> 0:37:32,886
我们可以使用汽车的任意子类

730
00:37:33,487 --> 0:37:36,156
带有我们通过协议一致性

731
00:37:36,223 --> 0:37:39,226
那么我们可以在出租车子类上

732
00:37:39,893 --> 0:37:41,495
而我们得到的不是汽车

733
00:37:41,562 --> 0:37:45,465
也不是任意汽车实例 而是出租车

734
00:37:47,100 --> 0:37:48,635
很棒 但应该如何使用它？

735
00:37:49,503 --> 0:37:52,639
让我们看看出租车会包含什么？

736
00:37:52,706 --> 0:37:54,241
也许这里有一个按小时计费的工具

737
00:37:54,308 --> 0:37:56,643
当我们调用

738
00:37:57,511 --> 0:37:58,679
我们就会通过协议

739
00:37:58,745 --> 0:38:01,181
通过协议初始化程序要求

740
00:37:58,745 --> 0:38:01,181
通过协议初始化程序要求

741
00:38:01,582 --> 0:38:03,951
它其实只能调用一个初始化程序

742
00:38:04,218 --> 0:38:10,224
就是在汽车类内部声明的初始化程序

743
00:38:10,290 --> 0:38:11,458
在这里的超类中

744
00:38:12,893 --> 0:38:17,130
那么那个初始化工具

745
00:38:17,598 --> 0:38:19,867
但它并不了解出租车子类

746
00:38:20,734 --> 0:38:23,003
那么如果我们要直接使用这个

747
00:38:23,070 --> 0:38:24,271
我们会产生一个问题

748
00:38:24,338 --> 0:38:26,940
hourlyRate

749
00:38:27,140 --> 0:38:29,543
那会导致一些更不幸的误解

750
00:38:29,610 --> 0:38:31,044
当你在最后得到账单时

751
00:38:32,746 --> 0:38:34,014
我们该如何解决这个？

752
00:38:34,081 --> 0:38:37,150
看起来Swift

753
00:38:37,818 --> 0:38:41,722
它会在你尝试让汽车遵循

754
00:38:41,788 --> 0:38:45,192
是指那个初始化程序中

755
00:38:45,259 --> 0:38:47,427
它应该被标记为必需

756
00:38:49,329 --> 0:38:53,634
现在必须在全部超类中实施

757
00:38:53,901 --> 0:38:55,736
不仅仅是直接的超类

758
00:38:56,003 --> 0:38:58,405
而是任意一个超类

759
00:38:58,472 --> 0:39:00,941
以及你现在还不知道的

760
00:38:58,472 --> 0:39:00,941
以及你现在还不知道的

761
00:39:02,209 --> 0:39:03,677
现在通过添加那个要求

762
00:39:03,911 --> 0:39:07,414
意味着当出租车从汽车中继承时

763
00:39:07,614 --> 0:39:12,286
它还需要引入一个

764
00:39:13,020 --> 0:39:15,989
现在这非常重要

765
00:39:16,223 --> 0:39:17,958
解码hourlyRate

766
00:39:18,192 --> 0:39:20,561
然后锁住超类初始化程序

767
00:39:20,627 --> 0:39:22,829
以便解码剩余的汽车类型

768
00:39:25,365 --> 0:39:26,200
好的

769
00:39:26,667 --> 0:39:29,236
现在如果你快速阅读了那些红色方框

770
00:39:29,303 --> 0:39:32,573
你可能会注意到子短语并不是最终

771
00:39:33,240 --> 0:39:36,944
那么从定义上说 最终类没有子类

772
00:39:37,344 --> 0:39:40,280
因此从本质上说

773
00:39:42,516 --> 0:39:45,419
意思是拥有一个必需初始化程序

774
00:39:45,485 --> 0:39:47,421
因为你知道那儿没有子类

775
00:39:47,487 --> 0:39:50,457
因此最终类用起来稍微简单点儿

776
00:39:50,524 --> 0:39:53,827
当处理诸如可解码

777
00:39:53,894 --> 0:39:55,229
因为它们不需遵循这些规则

778
00:39:55,295 --> 0:39:57,097
即拥有必需初始化程序

779
00:39:58,365 --> 0:40:01,368
那么当你用类引用语义时

780
00:39:58,365 --> 0:40:01,368
那么当你用类引用语义时

781
00:40:02,436 --> 0:40:06,206
考虑使用最终类

782
00:40:06,540 --> 0:40:08,275
通过集成机制

783
00:40:08,575 --> 0:40:12,145
现在这并不意味着

784
00:40:12,212 --> 0:40:13,947
你仍然可以在类上写扩展

785
00:40:14,014 --> 0:40:16,216
与你扩展结构或枚举的方式一样

786
00:40:17,017 --> 0:40:20,153
你还可以给它添加一致性

787
00:40:21,321 --> 0:40:24,091
但最终类可以通过通用系统

788
00:40:24,157 --> 0:40:27,427
也会解锁在运行时间内

789
00:40:30,731 --> 0:40:32,900
我们今天谈了谈Swift的通用型

790
00:40:32,966 --> 0:40:36,970
Swift通用型背后的理念

791
00:40:37,237 --> 0:40:39,273
同时保持静态类型信息

792
00:40:39,606 --> 0:40:41,742
使得写正确的程序变得较为简单

793
00:40:41,808 --> 0:40:45,479
并把这些有效地编译到执行程序中

794
00:40:46,180 --> 0:40:47,714
当你设计协议时

795
00:40:48,048 --> 0:40:49,816
让这个进行拉锯战

796
00:40:49,883 --> 0:40:52,986
在你想要写的协议的通用算法之间

797
00:40:53,053 --> 0:40:55,956
并且一致性类型需要实施那个协议

798
00:40:56,023 --> 0:40:58,959
以便指导你的设计成为一个

799
00:41:00,027 --> 0:41:01,762
引入协议继承

800
00:41:01,828 --> 0:41:04,464
当你需要更多特定功能

801
00:41:04,531 --> 0:41:08,135
来实施新的通用算法时

802
00:41:08,202 --> 0:41:10,103
只有一致性类型的子集支持那些算法

803
00:41:11,071 --> 0:41:14,675
还有条件一致性 当你写通用类型时

804
00:41:14,975 --> 0:41:18,111
以便它们可以编写得很漂亮

805
00:41:18,178 --> 0:41:20,280
尤其是当与协议继承一起使用时

806
00:41:20,781 --> 0:41:23,784
最后当你针对棘手的相互作用

807
00:41:23,851 --> 0:41:26,386
在类继承和通用系统之间

808
00:41:27,020 --> 0:41:29,489
返回到Liskov替换原理

809
00:41:29,556 --> 0:41:31,825
思考一下这里发生了什么

810
00:41:32,259 --> 0:41:35,429
如果我引入子类而不是超类

811
00:41:35,495 --> 0:41:36,964
我在子类而非超类上

812
00:41:39,933 --> 0:41:41,168
非常感谢

813
00:41:41,235 --> 0:41:43,904
还有一些关于拥抱算法的相关演讲

814
00:41:43,971 --> 0:41:46,306
你可以了解它们会如何帮助你

815
00:41:46,373 --> 0:41:50,611
以及如何在你的日常编程中

816
00:41:51,411 --> 0:41:52,246
谢谢
