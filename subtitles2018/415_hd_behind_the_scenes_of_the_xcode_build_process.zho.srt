1
00:00:17,284 --> 00:00:24,291
（Xcode构建过程的后台工作

2
00:00:36,303 --> 00:00:37,571
大家下午好

3
00:00:38,172 --> 00:00:41,508
欢迎来到

4
00:00:41,742 --> 00:00:43,243
我是Jake Petroules

5
00:00:43,310 --> 00:00:45,612
我是Xcode构建系统团队的

6
00:00:45,913 --> 00:00:47,548
今天我们要讨论

7
00:00:47,915 --> 00:00:49,416
Xcode构建过程

8
00:00:51,185 --> 00:00:54,054
首先我要讲讲

9
00:00:54,121 --> 00:00:55,756
用Swift的scratch编写

10
00:00:55,822 --> 00:00:58,525
提供更好的性能和可靠度

11
00:00:58,959 --> 00:01:00,194
我们要解答如下问题

12
00:00:58,959 --> 00:01:00,194
我们要解答如下问题

13
00:01:00,260 --> 00:01:02,496
按住Command + B

14
00:01:02,563 --> 00:01:04,197
如何架构构建过程

15
00:01:04,263 --> 00:01:06,900
Xcode如何用

16
00:01:06,967 --> 00:01:09,937
决定构建过程的模型和流程

17
00:01:11,438 --> 00:01:13,907
然后是编译器领域

18
00:01:14,541 --> 00:01:16,376
看看Clang和Swift

19
00:01:16,443 --> 00:01:18,679
怎样将源代码加入目标文件

20
00:01:19,179 --> 00:01:21,481
我们会展示

21
00:01:21,582 --> 00:01:24,218
编译器如何在代码中查找声明

22
00:01:24,284 --> 00:01:26,820
以及Swift编译模型如何不同于

23
00:01:26,887 --> 00:01:29,489
C、C++

24
00:01:30,724 --> 00:01:32,593
最后是连接器

25
00:01:32,893 --> 00:01:35,863
构建过程的最后一步

26
00:01:36,330 --> 00:01:39,499
我们会解释什么是符号

27
00:01:39,566 --> 00:01:42,536
还有连接器如何将

28
00:01:42,603 --> 00:01:44,805
整合成最终的可执行文件

29
00:01:44,872 --> 00:01:46,607
提供给app或框架

30
00:01:48,141 --> 00:01:49,276
我们会使用

31
00:01:49,343 --> 00:01:51,078
叫PetWall的小app样本

32
00:01:51,144 --> 00:01:52,980
作为这次演讲的示例

33
00:01:53,146 --> 00:01:56,016
它只是一个很小的iOS app

34
00:01:59,119 --> 00:02:02,189
首先来了解

35
00:01:59,119 --> 00:02:02,189
首先来了解

36
00:02:02,256 --> 00:02:05,592
以及如何用Xcode

37
00:02:06,126 --> 00:02:08,595
这里你看到app对象、框架

38
00:02:08,662 --> 00:02:11,698
不同的代码文件 都是Swift

39
00:02:11,899 --> 00:02:14,134
看起来可能很像你自己的项目

40
00:02:15,669 --> 00:02:18,105
在构建app的时候

41
00:02:19,106 --> 00:02:22,009
要经过很多步骤 从源代码

42
00:02:22,075 --> 00:02:23,610
和项目资源开始

43
00:02:24,044 --> 00:02:25,679
到提供给客户的打包文件

44
00:02:25,746 --> 00:02:28,248
或上传到App Store发布

45
00:02:29,049 --> 00:02:31,785
你要编译和连接源代码

46
00:02:31,885 --> 00:02:36,924
复制和处理资源 比如头文件

47
00:02:37,224 --> 00:02:39,927
最后是代码签名以及自定义

48
00:02:39,993 --> 00:02:41,595
shell脚本或make文件

49
00:02:41,662 --> 00:02:44,398
比如给框架构建API文件

50
00:02:44,531 --> 00:02:47,267
运行代码检查和验证工具等

51
00:02:48,402 --> 00:02:49,703
大多数任务

52
00:02:49,770 --> 00:02:52,339
在构建过程中

53
00:02:52,406 --> 00:02:56,910
比如Clang、LD、AC工具

54
00:02:57,444 --> 00:02:59,112
这些工具的执行

55
00:02:59,179 --> 00:03:00,948
需要一组特定的实参

56
00:02:59,179 --> 00:03:00,948
需要一组特定的实参

57
00:03:01,181 --> 00:03:02,616
以特定的顺序

58
00:03:02,683 --> 00:03:05,018
基于Xcode项目的配置

59
00:03:06,620 --> 00:03:08,188
构建系统的用处

60
00:03:08,255 --> 00:03:11,258
就是将任务的执行部署自动化

61
00:03:11,358 --> 00:03:12,926
在每次构建的时候

62
00:03:13,460 --> 00:03:16,096
由于任务数量成千上万

63
00:03:16,163 --> 00:03:18,232
构建过程更是数不胜数

64
00:03:18,298 --> 00:03:20,534
依赖关系十分复杂

65
00:03:20,701 --> 00:03:22,302
你肯定不想手动输入

66
00:03:22,369 --> 00:03:24,304
1天敲100遍命令

67
00:03:25,472 --> 00:03:27,508
那就让构建系统来做

68
00:03:29,409 --> 00:03:32,079
我说过

69
00:03:32,145 --> 00:03:34,181
按照特定的顺序进行

70
00:03:34,381 --> 00:03:37,718
因此我们谈谈这个顺序

71
00:03:38,785 --> 00:03:40,654
构建任务的执行顺序

72
00:03:40,721 --> 00:03:43,223
取决于信息的依赖关系

73
00:03:43,290 --> 00:03:44,424
就是任务

74
00:03:44,725 --> 00:03:46,460
任务需要的输入

75
00:03:46,693 --> 00:03:48,428
和任务生成的输出

76
00:03:49,329 --> 00:03:51,164
以编译任务为例

77
00:03:51,231 --> 00:03:55,402
它需要输入源代码文件

78
00:03:55,469 --> 00:03:59,373
然后输出目标文件

79
00:04:00,340 --> 00:04:01,942
同样 连接器任务

80
00:04:02,009 --> 00:04:03,911
需要几个目标文件

81
00:04:03,977 --> 00:04:06,146
由编译器在上个任务中生成

82
00:04:06,380 --> 00:04:08,949
再生成可执行或lib文件

83
00:04:09,016 --> 00:04:11,852
比如PetWall运行文件

84
00:04:12,219 --> 00:04:15,322
希望大家已经看出些许端倪

85
00:04:15,989 --> 00:04:19,726
你能看到信息的依赖关系

86
00:04:19,793 --> 00:04:22,529
最终形成执行顺序

87
00:04:22,963 --> 00:04:25,933
现在大家关注下

88
00:04:25,999 --> 00:04:28,468
很像川流不息的马路

89
00:04:28,569 --> 00:04:30,237
你看得到编译任务

90
00:04:30,504 --> 00:04:34,474
在各自的路上互不干涉

91
00:04:35,375 --> 00:04:37,911
因为连接器任务

92
00:04:38,011 --> 00:04:39,413
它要在最后一位

93
00:04:41,348 --> 00:04:44,017
构建系统通过依赖关系

94
00:04:44,084 --> 00:04:46,653
决定任务执行的顺序

95
00:04:46,720 --> 00:04:49,089
以及平行运行的任务

96
00:04:49,156 --> 00:04:51,091
我们叫做依赖顺序

97
00:04:51,658 --> 00:04:53,861
知道了构建过程的定义后

98
00:04:53,961 --> 00:04:57,097
我们具体讲讲怎么操作

99
00:04:57,164 --> 00:04:59,700
点击“构建”会发生什么？

100
00:05:00,434 --> 00:05:03,570
构建系统的第一步是获取构建描述

101
00:05:03,637 --> 00:05:05,138
Xcode项目文件

102
00:05:05,239 --> 00:05:08,742
解析项目中的所有文件

103
00:05:08,809 --> 00:05:11,178
目标app和依赖关系

104
00:05:11,245 --> 00:05:12,246
构建设置

105
00:05:12,779 --> 00:05:15,816
转换成一个树形结构叫做定向图

106
00:05:16,283 --> 00:05:17,985
它显示了所有依赖关系

107
00:05:18,051 --> 00:05:20,821
项目中的输入和输出文件

108
00:05:20,954 --> 00:05:23,957
以及处理它们的执行任务

109
00:05:26,159 --> 00:05:29,596
然后低级执行引擎会处理这张图

110
00:05:29,663 --> 00:05:34,368
研究依赖关系 决定执行哪个任务

111
00:05:34,601 --> 00:05:36,770
执行顺序是什么

112
00:05:36,837 --> 00:05:39,206
以及哪些可以平行运行

113
00:05:39,273 --> 00:05:41,742
然后继续执行任务

114
00:05:42,609 --> 00:05:44,711
我说的低级执行引擎

115
00:05:44,778 --> 00:05:46,380
是新构建系统的

116
00:05:46,446 --> 00:05:48,615
它是开源资源 用GitHub开发

117
00:05:48,715 --> 00:05:50,517
如果对构建系统开发感兴趣

118
00:05:50,584 --> 00:05:52,619
请随意研究 看看它如何工作

119
00:05:52,819 --> 00:05:54,821
它的链接和另一个关于构建系统的

120
00:05:54,888 --> 00:05:57,124
开源模块 会在演讲最后提到

121
00:05:58,292 --> 00:06:01,161
现在讲讲已知的依赖关系

122
00:05:58,292 --> 00:06:01,161
现在讲讲已知的依赖关系

123
00:06:01,495 --> 00:06:04,331
由于你无法获取过多的依赖关系信息

124
00:06:04,531 --> 00:06:07,167
构建系统可能会找到更多

125
00:06:07,234 --> 00:06:09,203
在任务的执行过程中

126
00:06:09,703 --> 00:06:12,906
比如Clang编译

127
00:06:12,973 --> 00:06:15,209
如你所料 会生成目标文件

128
00:06:15,576 --> 00:06:17,778
但是它也会生成另一个文件

129
00:06:18,445 --> 00:06:19,646
其中包含一个列表

130
00:06:19,713 --> 00:06:22,249
列出源文件中的头文件

131
00:06:22,749 --> 00:06:24,351
那么下次构建时

132
00:06:24,418 --> 00:06:27,020
构建系统会使用这个文件中的信息

133
00:06:27,087 --> 00:06:29,323
以保证再次编译源文件

134
00:06:29,389 --> 00:06:32,292
如果你更改了其中任何头文件的话

135
00:06:32,559 --> 00:06:35,629
这里的关系路径是

136
00:06:35,696 --> 00:06:39,066
PetController.d

137
00:06:40,300 --> 00:06:42,970
我们已经讲了很多

138
00:06:43,170 --> 00:06:47,140
构建系统的主要工作就是执行任务

139
00:06:47,908 --> 00:06:51,778
当然项目越大 构建时间越长

140
00:06:52,012 --> 00:06:53,981
你肯定不想把所有任务都运行一遍

141
00:06:54,047 --> 00:06:55,549
在每次构建的时候

142
00:06:56,049 --> 00:06:58,418
构建系统实际上可以只执行

143
00:06:58,485 --> 00:07:00,954
定向图上的任务子集

144
00:06:58,485 --> 00:07:00,954
定向图上的任务子集

145
00:07:02,789 --> 00:07:04,992
基于你对项目做出的更改

146
00:07:05,192 --> 00:07:06,527
对比上次构建过程

147
00:07:07,127 --> 00:07:09,663
我们称之为累加构建

148
00:07:09,863 --> 00:07:12,766
准确的依赖关系十分重要

149
00:07:12,833 --> 00:07:16,069
这样累加构建才能正确高效地工作

150
00:07:17,971 --> 00:07:20,174
下面看看哪些更改

151
00:07:20,240 --> 00:07:22,009
以及与累加构建的关系

152
00:07:22,075 --> 00:07:24,778
构建系统如何检测更改呢？

153
00:07:26,013 --> 00:07:28,949
构建过程中的每个任务

154
00:07:29,116 --> 00:07:30,751
类似于Hash

155
00:07:30,817 --> 00:07:33,120
多个任务相关信息而得出

156
00:07:34,755 --> 00:07:37,691
这些信息包括

157
00:07:37,758 --> 00:07:40,327
比如文件路径

158
00:07:40,494 --> 00:07:43,797
运行命令的命令行指示

159
00:07:43,864 --> 00:07:45,465
以及其他有关任务的元数据

160
00:07:45,532 --> 00:07:48,035
比如编译器版本

161
00:07:49,503 --> 00:07:52,072
构建系统会追踪任务签名

162
00:07:52,139 --> 00:07:54,074
包括当前和之前的构建

163
00:07:54,141 --> 00:07:57,911
所以它知道每次构建时

164
00:07:59,046 --> 00:08:00,447
如果某个任务的签名

165
00:07:59,046 --> 00:08:00,447
如果某个任务的签名

166
00:08:00,514 --> 00:08:03,350
与上次构建时不同

167
00:08:03,417 --> 00:08:05,619
它就会重新运行这个任务

168
00:08:06,019 --> 00:08:08,288
如果相同就会跳过

169
00:08:08,922 --> 00:08:11,792
这就是累加构建的概念

170
00:08:12,893 --> 00:08:14,595
我们大概了解了

171
00:08:14,661 --> 00:08:17,164
构建过程的定义和流程

172
00:08:17,431 --> 00:08:19,566
如何利用构建系统呢？

173
00:08:21,134 --> 00:08:22,769
先回顾下基本知识

174
00:08:23,036 --> 00:08:27,574
构建系统按照一定顺序

175
00:08:27,641 --> 00:08:30,477
但要记得

176
00:08:31,879 --> 00:08:35,315
我们不要担心

177
00:08:35,381 --> 00:08:37,150
这是构建系统的工作

178
00:08:37,717 --> 00:08:39,419
作为开发者

179
00:08:39,486 --> 00:08:42,155
我们要考虑的是

180
00:08:42,389 --> 00:08:44,691
让构建系统决定

181
00:08:44,758 --> 00:08:46,360
根据定向图结构

182
00:08:46,894 --> 00:08:49,329
这样构建系统

183
00:08:49,396 --> 00:08:50,931
可能的时候并排运行

184
00:08:50,998 --> 00:08:53,800
以完全利用多核硬件

185
00:08:54,968 --> 00:08:56,937
依赖关系源自哪里呢？

186
00:08:57,271 --> 00:08:58,238
对某些任务

187
00:08:58,305 --> 00:09:00,240
依赖关系

188
00:08:58,305 --> 00:09:00,240
依赖关系

189
00:09:00,307 --> 00:09:01,608
来自构建系统自带的数据

190
00:09:01,842 --> 00:09:05,179
构建系统自带一些规则

191
00:09:05,245 --> 00:09:08,315
资源目录

192
00:09:08,549 --> 00:09:11,618
这些规则定义了

193
00:09:11,685 --> 00:09:13,720
和哪些是输出文件

194
00:09:15,422 --> 00:09:17,157
还有目标依赖关系

195
00:09:17,224 --> 00:09:19,993
大致决定了

196
00:09:20,160 --> 00:09:21,395
有些时候

197
00:09:21,461 --> 00:09:24,498
构建系统可以编译

198
00:09:24,798 --> 00:09:27,034
之前的Xcode

199
00:09:27,100 --> 00:09:29,403
就要完成整个app的构建

200
00:09:29,469 --> 00:09:31,605
然后才能使用

201
00:09:32,072 --> 00:09:35,609
Xcode X的新构建系统

202
00:09:35,776 --> 00:09:38,345
编译源阶段会提前开始

203
00:09:38,412 --> 00:09:40,881
免费提供并行

204
00:09:41,114 --> 00:09:44,117
但是如果含有

205
00:09:44,184 --> 00:09:45,686
这些阶段完成后

206
00:09:45,752 --> 00:09:48,155
并行才能开始

207
00:09:49,389 --> 00:09:52,826
有关依赖的还有隐性依赖关系

208
00:09:53,293 --> 00:09:55,495
比如在链接库里

209
00:09:55,562 --> 00:09:56,864
用二进制构建阶段

210
00:09:57,331 --> 00:10:00,033
隐性依赖关系

211
00:09:57,331 --> 00:10:00,033
隐性依赖关系

212
00:10:00,100 --> 00:10:01,502
默认为开启

213
00:10:01,635 --> 00:10:04,571
构建系统会为这个目标

214
00:10:04,638 --> 00:10:06,840
即便它不在目标依赖关系之列

215
00:10:08,442 --> 00:10:10,577
接下来是构建阶段依赖

216
00:10:10,911 --> 00:10:11,812
在目标编辑器里

217
00:10:11,879 --> 00:10:13,881
你会看到几个构建阶段

218
00:10:14,014 --> 00:10:18,652
复制头文件、编译源

219
00:10:19,086 --> 00:10:21,154
这些任务与每个阶段相关

220
00:10:21,221 --> 00:10:22,489
通常按组运行

221
00:10:22,556 --> 00:10:24,892
根据阶段的排列顺序

222
00:10:25,025 --> 00:10:27,494
构建系统也会忽略它

223
00:10:27,561 --> 00:10:30,797
比如第三方静态库阶段

224
00:10:30,864 --> 00:10:32,533
在编译源之前

225
00:10:33,033 --> 00:10:35,435
注意有的时候

226
00:10:35,502 --> 00:10:37,137
会导致问题或构建失败

227
00:10:37,204 --> 00:10:38,705
因此为了解依赖关系

228
00:10:38,772 --> 00:10:41,575
验证构建阶段的顺序

229
00:10:42,943 --> 00:10:45,112
还有scheme顺序依赖

230
00:10:45,345 --> 00:10:47,347
如果开启了

231
00:10:47,414 --> 00:10:48,615
在方案设置里

232
00:10:48,682 --> 00:10:50,250
构建性能会更好

233
00:10:50,317 --> 00:10:52,886
不用担心目标顺序

234
00:10:52,953 --> 00:10:55,489
但如果关闭

235
00:10:55,556 --> 00:10:59,026
Xcode构建目标时

236
00:10:59,092 --> 00:11:01,461
构建行动顺序

237
00:10:59,092 --> 00:11:01,461
构建行动顺序

238
00:11:01,962 --> 00:11:04,131
目标依赖关系

239
00:11:04,198 --> 00:11:05,866
优先决定

240
00:11:05,933 --> 00:11:08,235
但Xcode会遵从这个排列

241
00:11:08,569 --> 00:11:12,272
这个让人跃跃欲试

242
00:11:12,339 --> 00:11:14,575
即使依赖关系有误

243
00:11:14,708 --> 00:11:17,511
但这样会牺牲

244
00:11:17,711 --> 00:11:19,012
延缓构建速度

245
00:11:19,179 --> 00:11:22,216
所以我们推荐

246
00:11:22,282 --> 00:11:25,519
正确设置依赖关系

247
00:11:27,521 --> 00:11:30,224
最后 依赖关系在于你自己

248
00:11:30,290 --> 00:11:31,291
开发者

249
00:11:32,759 --> 00:11:35,863
你可以自定义shell脚本

250
00:11:35,929 --> 00:11:38,866
明确告诉构建系统

251
00:11:39,032 --> 00:11:42,536
以避免重复运行

252
00:11:42,603 --> 00:11:45,472
保证正确执行顺序

253
00:11:45,739 --> 00:11:48,942
你可以用运行脚本阶段编辑器

254
00:11:49,009 --> 00:11:50,077
这些文件的路径

255
00:11:50,143 --> 00:11:53,113
将作为环境变量

256
00:11:54,681 --> 00:11:58,252
不要依赖项目里

257
00:11:58,652 --> 00:12:00,687
Clang编译器

258
00:11:58,652 --> 00:12:00,687
Clang编译器

259
00:12:00,754 --> 00:12:04,324
在构建设置中

260
00:12:04,525 --> 00:12:07,327
让编译器自动连接框架

261
00:12:07,394 --> 00:12:09,329
对应导入的模块

262
00:12:09,396 --> 00:12:13,166
不用在连接库的

263
00:12:13,333 --> 00:12:14,501
但是要注意

264
00:12:14,568 --> 00:12:16,770
自动关联

265
00:12:16,837 --> 00:12:18,805
在构建系统层级

266
00:12:18,939 --> 00:12:20,974
所以它不能保证

267
00:12:21,041 --> 00:12:24,011
在关联之前已经建好

268
00:12:25,312 --> 00:12:29,216
所以它只能用于平台STK的框架

269
00:12:29,283 --> 00:12:31,084
比如

270
00:12:31,151 --> 00:12:34,354
因为我们知道

271
00:12:34,721 --> 00:12:36,256
你自己项目里的目标

272
00:12:36,323 --> 00:12:38,559
要保证明确的库依赖关系

273
00:12:40,460 --> 00:12:42,296
你也许需要创建项目引用

274
00:12:42,362 --> 00:12:44,398
将另一个Xcode项目拖放到

275
00:12:44,464 --> 00:12:46,200
项目文件导航

276
00:12:46,700 --> 00:12:49,503
说明与其他项目的

277
00:12:51,772 --> 00:12:54,508
总结来说

278
00:12:54,575 --> 00:12:56,944
构建系统就能

279
00:12:57,077 --> 00:12:59,746
保证每次构建的结果一致

280
00:12:59,980 --> 00:13:03,450
这样就能减少构建用时

281
00:12:59,980 --> 00:13:03,450
这样就能减少构建用时

282
00:13:04,218 --> 00:13:06,086
想知道更多快速构建的内容

283
00:13:06,153 --> 00:13:08,922
如何最大化利用

284
00:13:08,989 --> 00:13:12,159
推荐观看演讲

285
00:13:12,559 --> 00:13:14,561
现在

286
00:13:14,628 --> 00:13:16,997
他会带大家

287
00:13:23,270 --> 00:13:24,204
谢谢 Jake

288
00:13:26,240 --> 00:13:29,276
现在我们要看看

289
00:13:29,710 --> 00:13:32,846
当Xcode构建系统

290
00:13:34,281 --> 00:13:35,148
大家好

291
00:13:35,215 --> 00:13:36,283
我是Jurgen

292
00:13:36,617 --> 00:13:39,253
我是Clang前端团队的

293
00:13:40,087 --> 00:13:43,690
今天我要讲两个功能

294
00:13:44,291 --> 00:13:46,860
第一个是头文件映射

295
00:13:47,427 --> 00:13:49,997
我们用它传递信息

296
00:13:50,197 --> 00:13:52,966
从Xcode构建系统

297
00:13:54,067 --> 00:13:56,803
第二个是Clang模块

298
00:13:57,204 --> 00:13:59,706
我们用它加快构建的速度

299
00:14:01,041 --> 00:14:04,144
在坐有些人可能只用Swift

300
00:14:04,645 --> 00:14:05,812
我想告诉你

301
00:14:06,246 --> 00:14:08,448
Swift在后台也用Clang

302
00:14:08,849 --> 00:14:11,485
所以你们应该也会感兴趣

303
00:14:14,621 --> 00:14:15,722
什么Clang？

304
00:14:16,990 --> 00:14:19,560
Clang是Apple的

305
00:14:20,027 --> 00:14:23,764
用于所有C语言

306
00:14:24,264 --> 00:14:28,035
比如C、C++

307
00:14:28,135 --> 00:14:30,838
大部分框架都在用的语言

308
00:14:32,472 --> 00:14:34,107
Jake刚才提过

309
00:14:35,342 --> 00:14:38,078
编译器一次性

310
00:14:38,145 --> 00:14:40,414
生成仅一个输出文件

311
00:14:40,581 --> 00:14:42,482
之后被连接器使用

312
00:14:43,417 --> 00:14:47,354
如果要从OS访问API

313
00:14:47,888 --> 00:14:53,060
或从自己的代码

314
00:14:53,427 --> 00:14:56,430
就需要一个叫做

315
00:14:57,531 --> 00:14:59,733
头文件是一种承诺

316
00:15:00,434 --> 00:15:04,638
承诺在其他地方

317
00:15:04,805 --> 00:15:06,173
它们通常可以匹配

318
00:15:07,207 --> 00:15:10,611
如果你只更新实现文件

319
00:15:10,911 --> 00:15:13,413
而忘记头文件

320
00:15:14,381 --> 00:15:17,718
通常这个问题

321
00:15:17,885 --> 00:15:19,987
因为编译器相信你的承诺

322
00:15:20,387 --> 00:15:23,090
问题出在链接过程

323
00:15:24,791 --> 00:15:28,095
编译器通常包含

324
00:15:28,495 --> 00:15:31,798
而且所有编译器

325
00:15:32,366 --> 00:15:35,769
以样本app为例

326
00:15:35,836 --> 00:15:38,105
看看怎么处理头文件

327
00:15:40,507 --> 00:15:41,475
这个PetWall

328
00:15:42,242 --> 00:15:44,311
是多语言app

329
00:15:44,945 --> 00:15:47,648
app本身

330
00:15:48,649 --> 00:15:52,553
框架的语言是

331
00:15:52,953 --> 00:15:55,422
它有个兼容库

332
00:15:55,789 --> 00:15:58,325
是C++语言

333
00:16:00,160 --> 00:16:02,896
时间越长

334
00:16:02,963 --> 00:16:07,801
所以要重新组织

335
00:16:08,135 --> 00:16:09,069
比如

336
00:16:09,336 --> 00:16:12,806
将所有跟猫有关的文件

337
00:16:16,243 --> 00:16:20,147
不要改变任何实现文件

338
00:16:20,681 --> 00:16:22,249
也是可以的

339
00:16:22,983 --> 00:16:25,252
那么你想

340
00:16:26,353 --> 00:16:29,590
Clang是如何找到头文件的

341
00:16:32,492 --> 00:16:34,094
举个简单的例子

342
00:16:34,628 --> 00:16:36,697
这是一个实现文件

343
00:16:37,497 --> 00:16:38,665
在这个代码里

344
00:16:38,966 --> 00:16:41,902
包含一个头文件

345
00:16:43,103 --> 00:16:46,306
怎么知道Clang做了什么

346
00:16:46,874 --> 00:16:49,643
一是查看构建日志

347
00:16:50,711 --> 00:16:56,049
看看Xcode构建系统

348
00:16:56,283 --> 00:16:58,252
复制粘贴这个调用代码

349
00:16:59,119 --> 00:17:02,956
打开命令窗口

350
00:16:59,119 --> 00:17:02,956
打开命令窗口

351
00:17:03,790 --> 00:17:05,492
-v代表显示

352
00:17:05,858 --> 00:17:08,795
然后Clang会返回很多信息

353
00:17:09,396 --> 00:17:12,165
我们只要关注一个

354
00:17:12,598 --> 00:17:13,567
搜索路径

355
00:17:15,202 --> 00:17:16,537
我说搜索路径

356
00:17:17,069 --> 00:17:19,806
大家想到的可能是

357
00:17:20,107 --> 00:17:23,710
指向源代码的搜索路径

358
00:17:24,877 --> 00:17:26,713
不是这样的

359
00:17:27,347 --> 00:17:28,182
相反

360
00:17:28,615 --> 00:17:30,684
你会看到这个

361
00:17:30,751 --> 00:17:32,252
（寻找猫咪）

362
00:17:32,319 --> 00:17:36,356
Headermaps

363
00:17:36,690 --> 00:17:39,493
说明头文件的位置

364
00:17:40,494 --> 00:17:41,595
仔细看下

365
00:17:41,662 --> 00:17:45,599
这是最重要的两个

366
00:17:47,868 --> 00:17:50,637
前两行只是

367
00:17:51,605 --> 00:17:53,874
插入了框架名称

368
00:17:54,808 --> 00:17:55,742
给头文件

369
00:17:56,210 --> 00:17:59,112
这两个头文件

370
00:18:02,349 --> 00:18:05,018
我建议

371
00:18:05,385 --> 00:18:06,220
原因是…

372
00:18:07,487 --> 00:18:10,891
把它放在这里

373
00:18:11,625 --> 00:18:15,095
但之后使用Clang模块时

374
00:18:15,462 --> 00:18:20,701
所以我们建议

375
00:18:20,934 --> 00:18:23,871
在将公共或私有头文件

376
00:18:23,937 --> 00:18:25,606
从自己的框架中导入时

377
00:18:27,341 --> 00:18:29,776
第三行是项目头文件

378
00:18:30,110 --> 00:18:32,145
这个例子中并不需要

379
00:18:32,746 --> 00:18:33,580
而且…

380
00:18:33,647 --> 00:18:38,519
headermap是为了

381
00:18:39,887 --> 00:18:40,754
如你所见

382
00:18:40,821 --> 00:18:43,524
公共和私有头文件的操作一样

383
00:18:44,224 --> 00:18:46,693
总是回归源代码

384
00:18:46,760 --> 00:18:50,430
这是为了让Clang生成

385
00:18:50,797 --> 00:18:52,799
有用的报错信息

386
00:18:53,100 --> 00:18:55,536
用于源目录文件

387
00:18:55,936 --> 00:18:58,772
而不是从构建目录

388
00:18:58,839 --> 00:19:00,107
其他内容

389
00:18:58,839 --> 00:19:00,107
其他内容

390
00:19:03,210 --> 00:19:06,613
很多人不知道

391
00:19:06,680 --> 00:19:08,182
就会遇到某些问题

392
00:19:08,348 --> 00:19:09,683
最常见的是

393
00:19:10,284 --> 00:19:14,221
忘记将头文件

394
00:19:15,055 --> 00:19:19,059
它在源目录

395
00:19:19,259 --> 00:19:22,329
一定保证将头文件

396
00:19:23,030 --> 00:19:24,865
另一个问题是

397
00:19:26,400 --> 00:19:29,937
如果头文件命名一样

398
00:19:31,138 --> 00:19:34,007
所以头文件的名称

399
00:19:34,741 --> 00:19:37,377
这对系统头文件也一样

400
00:19:37,744 --> 00:19:41,915
如果项目里的本地头文件

401
00:19:42,149 --> 00:19:43,984
它会叠加到系统头文件上

402
00:19:44,418 --> 00:19:46,320
要注意避免

403
00:19:47,020 --> 00:19:48,388
提到系统头文件

404
00:19:48,622 --> 00:19:49,923
怎么查找？

405
00:19:53,093 --> 00:19:55,062
再用PetWall演示下

406
00:19:56,029 --> 00:19:59,099
这里导入

407
00:19:59,166 --> 00:20:00,601
在SDK里

408
00:19:59,166 --> 00:20:00,601
在SDK里

409
00:20:01,869 --> 00:20:03,704
我们可以像之前一样

410
00:20:04,638 --> 00:20:06,273
就像查找自己项目的头文件

411
00:20:06,340 --> 00:20:07,975
但现在是系统头文件

412
00:20:08,809 --> 00:20:13,580
我说过头文件映射

413
00:20:13,881 --> 00:20:15,249
所以可以忽略

414
00:20:15,983 --> 00:20:18,318
现在关注导入路径

415
00:20:18,685 --> 00:20:19,520
那么

416
00:20:19,820 --> 00:20:23,590
默认的SDK里有两个目录

417
00:20:23,891 --> 00:20:25,926
第一个是用户的

418
00:20:26,460 --> 00:20:29,329
第二个是系统库框架

419
00:20:30,297 --> 00:20:31,698
先看第一个

420
00:20:33,433 --> 00:20:35,235
这是正常的包含目录

421
00:20:35,302 --> 00:20:38,672
我们只要输入搜索关键词

422
00:20:38,739 --> 00:20:41,642
这里是

423
00:20:42,276 --> 00:20:44,711
头文件没找到

424
00:20:45,479 --> 00:20:47,614
没关系

425
00:20:48,549 --> 00:20:50,851
系统库框架

426
00:20:52,119 --> 00:20:54,555
这是框架目录

427
00:20:54,888 --> 00:20:57,324
所以Clang的做法会有些不同

428
00:20:57,391 --> 00:20:58,225
首先…

429
00:20:58,825 --> 00:21:03,730
它要确定框架的定义

430
00:20:58,825 --> 00:21:03,730
它要确定框架的定义

431
00:21:05,465 --> 00:21:06,300
然后

432
00:21:06,667 --> 00:21:10,003
从头文件目录中

433
00:21:10,637 --> 00:21:12,840
这里找到了

434
00:21:13,674 --> 00:21:16,844
但如果没找到呢？

435
00:21:17,010 --> 00:21:20,314
比如输入不存在的假冒头文件

436
00:21:21,648 --> 00:21:24,418
显然不会在头文件目录中找到

437
00:21:25,819 --> 00:21:28,922
但之后它会查找

438
00:21:30,424 --> 00:21:34,428
Apple的SDK中

439
00:21:34,962 --> 00:21:36,430
但是你的项目

440
00:21:36,496 --> 00:21:39,366
和框架中可能公共和私有头文件都有

441
00:21:39,733 --> 00:21:41,568
所以也会检查

442
00:21:42,402 --> 00:21:45,005
但这是个假的头文件

443
00:21:46,707 --> 00:21:50,010
现在就有意思了

444
00:21:50,377 --> 00:21:53,113
我们不会再查找其他目录

445
00:21:53,413 --> 00:21:54,248
这是因为

446
00:21:54,715 --> 00:21:58,352
框架已经被找到了

447
00:21:59,019 --> 00:22:00,120
一旦框架被找到

448
00:21:59,019 --> 00:22:00,120
一旦框架被找到

449
00:22:00,187 --> 00:22:02,956
一般框架目录里

450
00:22:03,357 --> 00:22:05,592
如果找不到

451
00:22:07,928 --> 00:22:11,198
如果好奇

452
00:22:11,632 --> 00:22:14,668
当所有头文件

453
00:22:15,169 --> 00:22:16,770
你可以让Xcode

454
00:22:17,271 --> 00:22:22,242
创建预处理文件

455
00:22:24,912 --> 00:22:27,214
这会生成一个

456
00:22:28,582 --> 00:22:30,684
有多大呢？

457
00:22:32,853 --> 00:22:34,888
举个简单的例子

458
00:22:35,923 --> 00:22:37,925
Foundation.h是…

459
00:22:38,759 --> 00:22:42,229
系统最基本的头文件

460
00:22:43,463 --> 00:22:45,799
这个头文件很可能被

461
00:22:45,866 --> 00:22:49,203
直接或间接地

462
00:22:49,269 --> 00:22:50,103
就是说…

463
00:22:50,437 --> 00:22:51,872
每次调用编译器

464
00:22:51,939 --> 00:22:54,441
都要查找这个头文件

465
00:22:55,742 --> 00:22:56,910
一天之内

466
00:22:57,911 --> 00:23:02,049
Clang要查找并处理

467
00:22:57,911 --> 00:23:02,049
Clang要查找并处理

468
00:23:02,282 --> 00:23:04,318
只为一个导入声明

469
00:23:05,519 --> 00:23:10,891
也就是要解析和验证

470
00:23:11,792 --> 00:23:15,062
每次调用编译器

471
00:23:15,495 --> 00:23:18,131
这个工作量很大

472
00:23:18,999 --> 00:23:19,833
所以

473
00:23:20,901 --> 00:23:21,835
怎么改善？

474
00:23:23,971 --> 00:23:27,875
这里有个功能叫做

475
00:23:27,941 --> 00:23:29,910
这是个好办法

476
00:23:30,544 --> 00:23:31,812
但还有更好的

477
00:23:32,145 --> 00:23:35,048
几年前

478
00:23:36,283 --> 00:23:40,020
Clang模块只允许我们

479
00:23:40,087 --> 00:23:41,955
一次

480
00:23:42,322 --> 00:23:47,528
然后储存到硬盘

481
00:23:48,295 --> 00:23:51,031
这可以提升构建速度

482
00:23:53,867 --> 00:23:54,801
要实现它

483
00:23:55,369 --> 00:23:57,905
Clang模块

484
00:23:59,406 --> 00:24:02,943
最重要的一点是

485
00:23:59,406 --> 00:24:02,943
最重要的一点是

486
00:24:03,510 --> 00:24:05,045
什么是上下文无关？

487
00:24:06,947 --> 00:24:08,982
这有两个代码片段

488
00:24:09,216 --> 00:24:13,053
两个都导入了PetKit模块

489
00:24:13,887 --> 00:24:18,025
但两个宏观定义不同

490
00:24:19,693 --> 00:24:22,863
如果用传统方法

491
00:24:22,930 --> 00:24:24,798
文本也会被导入

492
00:24:25,299 --> 00:24:26,233
预处理器…

493
00:24:26,700 --> 00:24:30,304
会遵从这个定义

494
00:24:31,205 --> 00:24:32,239
如果这样做

495
00:24:32,306 --> 00:24:34,441
每个案例的模块

496
00:24:34,508 --> 00:24:37,044
就不一样

497
00:24:37,644 --> 00:24:38,478
所以…

498
00:24:39,012 --> 00:24:41,481
如果要使用模块

499
00:24:41,849 --> 00:24:46,753
模块会忽略

500
00:24:47,120 --> 00:24:51,692
这样就能被

501
00:24:54,027 --> 00:24:55,229
另一个要求是

502
00:24:56,630 --> 00:24:58,465
模块各自独立

503
00:24:58,932 --> 00:25:03,036
也就是说

504
00:24:58,932 --> 00:25:03,036
也就是说

505
00:25:04,104 --> 00:25:06,440
这对你有好处

506
00:25:06,840 --> 00:25:09,877
就是只要你导入一个模块

507
00:25:10,511 --> 00:25:11,478
它就能工作

508
00:25:11,545 --> 00:25:14,314
不用考虑还要

509
00:25:14,381 --> 00:25:15,816
才能运行

510
00:25:19,186 --> 00:25:22,890
我们怎么知道

511
00:25:22,956 --> 00:25:24,791
要不要创建模块呢？

512
00:25:25,993 --> 00:25:29,329
看个简单的例子

513
00:25:30,531 --> 00:25:33,200
首先Clang要找到框架里的

514
00:25:33,467 --> 00:25:34,735
这个头文件

515
00:25:37,037 --> 00:25:38,472
你们知道怎么做了

516
00:25:38,705 --> 00:25:41,275
这是Foundation.framework

517
00:25:42,109 --> 00:25:44,111
然后Clang编译器

518
00:25:44,511 --> 00:25:46,947
会查找模块目录

519
00:25:47,181 --> 00:25:48,782
它与头文件目录相关

520
00:25:49,483 --> 00:25:50,317
找到了

521
00:25:51,552 --> 00:25:53,086
什么是模块映射？

522
00:25:53,420 --> 00:25:57,524
模块映射描述了

523
00:25:57,724 --> 00:25:59,760
翻译到模块中

524
00:26:00,961 --> 00:26:01,962
具体讲下

525
00:26:04,264 --> 00:26:06,066
模块映射很简单

526
00:26:06,133 --> 00:26:08,502
这是Foundation的

527
00:26:08,569 --> 00:26:09,403
就这些

528
00:26:10,437 --> 00:26:11,805
显然它描述了

529
00:26:11,939 --> 00:26:14,074
模块的名称

530
00:26:14,875 --> 00:26:19,813
它还说明了

531
00:26:20,614 --> 00:26:23,617
这里只有一个头文件

532
00:26:23,684 --> 00:26:25,052
Foundation.h

533
00:26:25,752 --> 00:26:28,922
但这个头文件很特殊

534
00:26:28,989 --> 00:26:31,792
用特殊关键词

535
00:26:32,426 --> 00:26:33,260
这是说…

536
00:26:33,493 --> 00:26:36,830
Clang要查找

537
00:26:37,164 --> 00:26:41,034
来确定NSString.h

538
00:26:42,269 --> 00:26:43,704
耶 找到了！

539
00:26:44,271 --> 00:26:45,105
好了

540
00:26:45,172 --> 00:26:46,940
我们已经确定

541
00:26:47,007 --> 00:26:50,010
NSString.h是

542
00:26:50,577 --> 00:26:54,181
Clang可以升级文本输入

543
00:26:54,248 --> 00:26:55,649
到模块输入

544
00:26:56,283 --> 00:26:59,152
为此我们要创建

545
00:27:01,021 --> 00:27:03,090
如何创建

546
00:27:03,957 --> 00:27:04,858
首先

547
00:27:05,292 --> 00:27:07,594
为Clang单独创建位置

548
00:27:08,462 --> 00:27:11,698
Clang位置里

549
00:27:11,765 --> 00:27:13,267
都属于foundation模块

550
00:27:15,135 --> 00:27:18,839
我们不会转移任何现有的上下文

551
00:27:19,173 --> 00:27:21,275
来自原始的编译器调用

552
00:27:21,508 --> 00:27:23,076
所以说是上下文无关

553
00:27:24,044 --> 00:27:25,846
实际上我们转移的

554
00:27:25,913 --> 00:27:28,315
是传递给Clang的命令行实参

555
00:27:28,382 --> 00:27:29,583
随后继续传递

556
00:27:32,152 --> 00:27:34,188
在创建foundation模块时

557
00:27:36,023 --> 00:27:37,624
模块本身或框架

558
00:27:37,691 --> 00:27:38,692
框架本身…

559
00:27:39,393 --> 00:27:41,795
会导入其他框架

560
00:27:41,995 --> 00:27:42,863
也就是说…

561
00:27:43,130 --> 00:27:45,032
我们也要构建那些模块

562
00:27:46,633 --> 00:27:48,001
我们不能停顿

563
00:27:48,068 --> 00:27:51,438
因为它可能还包含

564
00:27:52,272 --> 00:27:54,575
但是我们已经能看到

565
00:27:55,175 --> 00:27:57,344
某些导入可能是一样的

566
00:27:57,644 --> 00:28:00,414
所以总能重复使用那个模块

567
00:27:57,644 --> 00:28:00,414
所以总能重复使用那个模块

568
00:28:02,883 --> 00:28:07,054
所有模块要序列化

569
00:28:09,323 --> 00:28:10,224
我说过…

570
00:28:11,391 --> 00:28:15,128
命令行实参会向后传递

571
00:28:15,729 --> 00:28:16,597
就是说…

572
00:28:17,364 --> 00:28:20,133
这些实参会影响

573
00:28:20,601 --> 00:28:22,102
模块的内容

574
00:28:22,636 --> 00:28:24,638
所以我们要散列

575
00:28:25,038 --> 00:28:26,139
这些实参

576
00:28:26,607 --> 00:28:30,644
再保存这些

577
00:28:30,811 --> 00:28:32,846
到散列匹配的目录里

578
00:28:34,548 --> 00:28:37,284
如果修改编译器实参

579
00:28:37,351 --> 00:28:38,752
用不同的限制文件

580
00:28:39,186 --> 00:28:41,822
比如写入

581
00:28:42,823 --> 00:28:44,224
这是不同的散列

582
00:28:44,491 --> 00:28:47,494
要求Clang重新创建

583
00:28:47,628 --> 00:28:50,597
所有模块

584
00:28:51,164 --> 00:28:52,132
匹配那个散列

585
00:28:53,300 --> 00:28:57,304
为了更多重复利用模块缓存

586
00:28:57,638 --> 00:29:02,209
你要保证实参的一致性

587
00:28:57,638 --> 00:29:02,209
你要保证实参的一致性

588
00:29:05,245 --> 00:29:09,516
以上就是如何查找

589
00:29:10,350 --> 00:29:12,553
但是你的框架呢？

590
00:29:12,853 --> 00:29:14,888
如何为它们创建模块？

591
00:29:16,924 --> 00:29:18,959
回到刚才猫的例子

592
00:29:19,393 --> 00:29:21,261
这时打开模块

593
00:29:23,397 --> 00:29:25,399
如果要用头文件映射

594
00:29:26,033 --> 00:29:30,070
它会映射到源目录

595
00:29:31,805 --> 00:29:34,508
看看这个源文件

596
00:29:35,409 --> 00:29:37,244
这里没有模块目录

597
00:29:38,412 --> 00:29:40,013
看上去根本不是框架

598
00:29:41,248 --> 00:29:44,852
Clang现在不知所措

599
00:29:45,452 --> 00:29:48,455
答案是一个新的概念

600
00:29:49,256 --> 00:29:51,825
叫做

601
00:29:52,526 --> 00:29:55,896
它会创建一个

602
00:29:56,830 --> 00:29:59,366
方便Clang创建模块

603
00:29:59,933 --> 00:30:00,767
但是…

604
00:29:59,933 --> 00:30:00,767
但是…

605
00:30:01,168 --> 00:30:04,838
抽象框架只能映射到目录文件

606
00:30:05,372 --> 00:30:06,507
这样

607
00:30:06,740 --> 00:30:10,210
Clang就能在源代码中报错

608
00:30:11,812 --> 00:30:13,380
这就是创建模块的方法

609
00:30:13,881 --> 00:30:15,749
在使用框架的情况下

610
00:30:18,352 --> 00:30:20,187
大家记得

611
00:30:20,721 --> 00:30:25,025
如果不确定框架名字

612
00:30:25,959 --> 00:30:28,562
我们就来举个例子

613
00:30:30,564 --> 00:30:33,934
这是很简单的代码样本

614
00:30:34,001 --> 00:30:37,671
第一个输入

615
00:30:39,106 --> 00:30:40,541
第二个输入

616
00:30:41,208 --> 00:30:44,411
我们都知道

617
00:30:45,012 --> 00:30:47,614
但Clang可能不知道

618
00:30:47,981 --> 00:30:50,284
因为你没有写明

619
00:30:51,785 --> 00:30:52,686
这样一来

620
00:30:53,253 --> 00:30:57,357
你可能会收到

621
00:30:57,925 --> 00:31:01,195
这种情况常见于

622
00:30:57,925 --> 00:31:01,195
这种情况常见于

623
00:31:03,163 --> 00:31:05,799
Clang在后台辛苦工作

624
00:31:05,866 --> 00:31:09,336
就为了解决

625
00:31:10,537 --> 00:31:12,339
但它不可能全部解决

626
00:31:13,240 --> 00:31:14,842
这只是个简单的例子

627
00:31:15,442 --> 00:31:16,777
稍微调整一下

628
00:31:18,545 --> 00:31:20,047
修改一下上下文

629
00:31:21,315 --> 00:31:25,419
模块的导入

630
00:31:25,485 --> 00:31:28,055
因为我说过

631
00:31:29,756 --> 00:31:30,724
cat导入

632
00:31:30,924 --> 00:31:33,727
还是头文件的文本导入

633
00:31:33,894 --> 00:31:35,729
它会遵循这个修改

634
00:31:36,330 --> 00:31:39,867
这时可能就不是双重定义了

635
00:31:39,933 --> 00:31:42,269
而是矛盾定义

636
00:31:42,469 --> 00:31:44,137
无法解决

637
00:31:44,771 --> 00:31:46,306
Clang解决不了

638
00:31:46,974 --> 00:31:47,808
那么…

639
00:31:47,941 --> 00:31:49,743
记住我的建议

640
00:31:49,810 --> 00:31:52,145
永远明确框架名称

641
00:31:52,513 --> 00:31:55,516
无论是导入公共的

642
00:31:56,683 --> 00:31:58,218
现在有请Devin

643
00:31:58,285 --> 00:32:02,256
他为大家讲解Swift和

644
00:31:58,285 --> 00:32:02,256
他为大家讲解Swift和

645
00:32:09,096 --> 00:32:09,963
谢谢 Jurgen

646
00:32:11,331 --> 00:32:13,300
我们现在要具体讲解

647
00:32:13,767 --> 00:32:16,770
Swift和构建系统

648
00:32:17,037 --> 00:32:19,506
在项目中查找声明

649
00:32:21,475 --> 00:32:23,377
先总结下

650
00:32:23,844 --> 00:32:26,914
Clang单独编译

651
00:32:27,781 --> 00:32:31,652
如果你要在另一个文件夹

652
00:32:32,419 --> 00:32:35,789
你要导入声明那个类的头文件

653
00:32:37,457 --> 00:32:41,061
Swift的设计不需要写入头文件

654
00:32:41,562 --> 00:32:44,598
为了方便初学者上手应用

655
00:32:44,865 --> 00:32:49,036
避免了在不同文件里

656
00:32:50,370 --> 00:32:52,039
但这就意味着编译器

657
00:32:52,105 --> 00:32:54,408
要做些额外的记录工作

658
00:32:54,975 --> 00:32:57,211
下面就讲讲

659
00:32:59,713 --> 00:33:01,949
回到PetWall app

660
00:32:59,713 --> 00:33:01,949
回到PetWall app

661
00:33:02,883 --> 00:33:05,919
在界面控制器里

662
00:33:07,020 --> 00:33:08,622
Objective-C

663
00:33:09,022 --> 00:33:10,524
和Swift单元测试

664
00:33:11,625 --> 00:33:12,559
为了编译

665
00:33:12,626 --> 00:33:15,762
哪怕只是上面这个

666
00:33:16,430 --> 00:33:19,266
编译器也要

667
00:33:20,400 --> 00:33:22,803
首先要找到声明

668
00:33:23,337 --> 00:33:27,641
Swift目标里的

669
00:33:29,243 --> 00:33:33,180
它还要生成接口

670
00:33:33,480 --> 00:33:36,250
以便声明可以

671
00:33:36,316 --> 00:33:39,520
Objective-C

672
00:33:40,754 --> 00:33:42,189
接下来的部分

673
00:33:42,256 --> 00:33:46,760
我会演示这个例子

674
00:33:47,694 --> 00:33:50,898
首先是在Swift目标里查找声明

675
00:33:55,469 --> 00:33:58,138
要编译

676
00:33:58,705 --> 00:34:02,075
编译器会查找

677
00:33:58,705 --> 00:34:02,075
编译器会查找

678
00:34:02,609 --> 00:34:04,111
以便检查调用

679
00:34:05,379 --> 00:34:06,947
但在此之前

680
00:34:07,281 --> 00:34:09,650
它要解析

681
00:34:10,117 --> 00:34:11,217
并验证

682
00:34:11,618 --> 00:34:14,922
以保证初始程序的声明

683
00:34:15,755 --> 00:34:17,824
编译器很聪明

684
00:34:18,091 --> 00:34:21,360
不需要检查

685
00:34:22,094 --> 00:34:23,931
但它还要做些工作

686
00:34:23,996 --> 00:34:26,632
处理文件的接口部分

687
00:34:29,803 --> 00:34:32,339
这与Clang不同

688
00:34:32,840 --> 00:34:34,908
编译一个Swift文件

689
00:34:35,576 --> 00:34:39,313
编译器也要解析

690
00:34:39,379 --> 00:34:42,815
以检查与接口有关的部分

691
00:34:48,255 --> 00:34:51,190
在Xcode 9

692
00:34:51,391 --> 00:34:53,960
在增量调试构建中

693
00:34:54,027 --> 00:34:57,564
因为编译器单独编译每个文件

694
00:34:58,332 --> 00:35:00,834
文件的编译可以并行

695
00:34:58,332 --> 00:35:00,834
文件的编译可以并行

696
00:35:01,168 --> 00:35:04,438
但它强制编译器

697
00:35:05,305 --> 00:35:07,875
解析一次

698
00:35:08,242 --> 00:35:10,711
解析多次是作为接口

699
00:35:11,144 --> 00:35:12,646
查找声明

700
00:35:14,181 --> 00:35:16,817
Xcode 10减少了这种消耗

701
00:35:17,451 --> 00:35:20,554
通过将文件合并成组

702
00:35:20,821 --> 00:35:23,190
尽可能多得分担工作

703
00:35:24,858 --> 00:35:27,094
在依旧最大化并行的同时

704
00:35:27,861 --> 00:35:30,197
在组中重复利用解析

705
00:35:31,164 --> 00:35:33,834
只在跨组处理时重复

706
00:35:34,535 --> 00:35:37,971
由于组的数量相对较少

707
00:35:38,372 --> 00:35:42,709
就能大幅提升

708
00:35:46,146 --> 00:35:49,716
Swift代码

709
00:35:50,083 --> 00:35:51,818
还能调用Objective-C

710
00:35:53,587 --> 00:35:55,455
回到PetWall样本app

711
00:35:55,522 --> 00:35:58,358
我们看到它很重要

712
00:35:58,458 --> 00:35:59,993
因为它是系统框架

713
00:36:00,227 --> 00:36:02,896
比如 UIKit

714
00:36:06,633 --> 00:36:10,204
Swift与其他语言不一样

715
00:36:10,270 --> 00:36:14,408
它不需要外部功能接口

716
00:36:15,809 --> 00:36:17,611
这里你一般要

717
00:36:17,678 --> 00:36:21,915
编写Swift声明给每个

718
00:36:22,983 --> 00:36:23,817
但是

719
00:36:23,884 --> 00:36:28,055
编译器内置了

720
00:36:28,121 --> 00:36:29,756
用作库

721
00:36:30,490 --> 00:36:34,361
这就可以直接导入

722
00:36:37,164 --> 00:36:39,533
Objective-C声明

723
00:36:40,300 --> 00:36:44,071
导入器会查看头文件

724
00:36:45,806 --> 00:36:49,076
任何目标在导入

725
00:36:49,943 --> 00:36:52,412
导入器在头文件中

726
00:36:52,479 --> 00:36:55,449
显示的是

727
00:36:56,950 --> 00:36:59,953
用Swift和Objective-C

728
00:37:00,454 --> 00:37:03,457
导入器在umbrella头文件中

729
00:37:04,591 --> 00:37:07,294
这个头文件定义了公共接口

730
00:37:08,262 --> 00:37:10,898
这样 框架内的Swift代码

731
00:37:10,964 --> 00:37:14,635
就可以调用同一框架内的

732
00:37:16,870 --> 00:37:19,173
最后

733
00:37:19,473 --> 00:37:21,975
可以导入目标的桥接头文件

734
00:37:22,176 --> 00:37:25,612
允许其中的声明

735
00:37:28,348 --> 00:37:29,183
现在…

736
00:37:29,650 --> 00:37:31,618
导入器找到声明后

737
00:37:31,885 --> 00:37:34,788
通常会修改它们

738
00:37:35,589 --> 00:37:37,891
比如它会导入

739
00:37:37,958 --> 00:37:39,593
用NSError惯用语

740
00:37:40,027 --> 00:37:41,662
作为throwing函数

741
00:37:42,062 --> 00:37:44,798
使用Swift内置的

742
00:37:47,835 --> 00:37:50,537
具体来说

743
00:37:50,804 --> 00:37:52,673
后跟动词和介词

744
00:37:53,907 --> 00:37:56,443
比如函数

745
00:37:56,777 --> 00:37:58,045
带有宠物这个词

746
00:37:58,579 --> 00:38:00,380
对于参数类型

747
00:37:58,579 --> 00:38:00,380
对于参数类型

748
00:38:00,747 --> 00:38:02,149
后跟一个动词

749
00:38:03,016 --> 00:38:05,853
同样单词point

750
00:38:06,186 --> 00:38:08,388
代表参数类型

751
00:38:08,722 --> 00:38:10,257
后跟介词at

752
00:38:11,992 --> 00:38:14,094
Swift删除了这些词

753
00:38:14,161 --> 00:38:17,664
只导入函数

754
00:38:19,399 --> 00:38:20,567
怎么做到的？

755
00:38:21,068 --> 00:38:23,036
你可能不知道

756
00:38:23,804 --> 00:38:28,008
编译器带有一组

757
00:38:29,643 --> 00:38:33,113
因为它们很难编码

758
00:38:33,447 --> 00:38:34,982
有时会缺词

759
00:38:35,716 --> 00:38:38,719
另外为了

760
00:38:38,952 --> 00:38:41,255
导入器会重命名函数

761
00:38:41,455 --> 00:38:44,057
根据词性删除单词

762
00:38:45,192 --> 00:38:47,895
比如

763
00:38:47,961 --> 00:38:52,266
所以feedPet导入后

764
00:38:53,467 --> 00:38:54,535
这个时候

765
00:38:54,601 --> 00:38:57,104
可以用注解

766
00:38:57,337 --> 00:39:01,508
让编译器导入

767
00:38:57,337 --> 00:39:01,508
让编译器导入

768
00:39:05,779 --> 00:39:08,315
如果你要看看

769
00:39:08,382 --> 00:39:09,917
如何导入Swift

770
00:39:10,317 --> 00:39:13,187
你可以到

771
00:39:13,487 --> 00:39:15,989
它在源编辑器的左上角

772
00:39:16,523 --> 00:39:18,592
选择生成的接口

773
00:39:18,759 --> 00:39:21,128
就能看到接口的样子

774
00:39:21,261 --> 00:39:22,863
和不同的Swift版本

775
00:39:25,465 --> 00:39:27,768
以上就是用Swift

776
00:39:28,302 --> 00:39:29,803
反过来呢？

777
00:39:30,170 --> 00:39:33,173
Objective-C

778
00:39:35,309 --> 00:39:37,878
答案是

779
00:39:37,945 --> 00:39:39,313
可以进行导入

780
00:39:39,913 --> 00:39:44,484
这样你可以用Swift编写类

781
00:39:45,619 --> 00:39:46,854
看看工作原理

782
00:39:48,355 --> 00:39:51,225
编译器生成

783
00:39:51,291 --> 00:39:55,963
给Swift类

784
00:39:57,397 --> 00:39:58,665
单元测试的app

785
00:39:58,899 --> 00:40:02,503
头文件会包含

786
00:39:58,899 --> 00:40:02,503
头文件会包含

787
00:40:03,003 --> 00:40:07,140
就能在app的Objective-C部分

788
00:40:08,642 --> 00:40:09,810
但是对于框架

789
00:40:10,110 --> 00:40:13,180
生成的头文件只包含公共声明

790
00:40:13,380 --> 00:40:15,549
因为它包含于构建的产品

791
00:40:15,616 --> 00:40:18,085
是框架公共接口的一部分

792
00:40:20,521 --> 00:40:21,355
右边

793
00:40:21,421 --> 00:40:24,491
你看到编译器

794
00:40:24,892 --> 00:40:27,227
名字变形的Swift类

795
00:40:27,728 --> 00:40:30,464
包含模块名称

796
00:40:31,865 --> 00:40:34,101
现在我讲一讲模块

797
00:40:34,668 --> 00:40:36,436
之后Louis会讲解

798
00:40:36,904 --> 00:40:38,305
现在大家要知道

799
00:40:38,505 --> 00:40:41,175
它能防止

800
00:40:41,375 --> 00:40:44,478
不让两个模块定义

801
00:40:46,180 --> 00:40:50,017
你可以让Swift重命名

802
00:40:50,284 --> 00:40:53,520
通过传递识别符

803
00:40:54,188 --> 00:40:55,189
如果这样做

804
00:40:55,389 --> 00:40:58,692
你要保证两个名字不冲突

805
00:40:59,893 --> 00:41:04,998
我用了PWL前缀

806
00:40:59,893 --> 00:41:04,998
我用了PWL前缀

807
00:41:05,632 --> 00:41:11,271
这样就能在Objective-C中

808
00:41:14,107 --> 00:41:15,909
编译器用类似的方法

809
00:41:15,976 --> 00:41:19,413
生成其他Swift目标的接口

810
00:41:21,248 --> 00:41:22,082
为此

811
00:41:22,416 --> 00:41:25,285
Swift基于Clang的

812
00:41:25,352 --> 00:41:26,720
就像Jurgen说的

813
00:41:27,321 --> 00:41:29,489
然后更深层的融入语言

814
00:41:30,624 --> 00:41:31,458
Swift里

815
00:41:31,525 --> 00:41:34,561
模块是可分布的声明单元

816
00:41:34,828 --> 00:41:39,299
为了使用这些声明

817
00:41:40,334 --> 00:41:42,703
你可以导入

818
00:41:42,936 --> 00:41:44,571
比如XEtest

819
00:41:45,305 --> 00:41:46,440
Xcode里

820
00:41:46,507 --> 00:41:49,610
每个Swift目标

821
00:41:50,043 --> 00:41:51,378
包括目标app

822
00:41:52,479 --> 00:41:55,115
所以要导入

823
00:41:55,182 --> 00:41:57,551
以便进行单元测试

824
00:42:00,621 --> 00:42:02,022
导入模块时

825
00:42:02,089 --> 00:42:05,792
编译器反序列化

826
00:42:06,360 --> 00:42:08,128
在使用时

827
00:42:09,129 --> 00:42:10,697
例如在单元测试中

828
00:42:10,764 --> 00:42:13,333
编译器加载

829
00:42:14,001 --> 00:42:15,736
从PetWall Swift模块里

830
00:42:16,103 --> 00:42:18,672
以保证控制器的创建

831
00:42:19,773 --> 00:42:22,643
这类似于编译器在目标里查找声明

832
00:42:22,843 --> 00:42:25,012
我之前展示过的

833
00:42:25,913 --> 00:42:27,014
除此之外

834
00:42:27,080 --> 00:42:29,917
编译器会加载一个

835
00:42:30,384 --> 00:42:33,220
而不是直接解析Swift文件

836
00:42:36,323 --> 00:42:38,759
编译器生成的

837
00:42:38,959 --> 00:42:41,762
很多就像

838
00:42:42,296 --> 00:42:45,199
但它不是文本模式

839
00:42:46,033 --> 00:42:48,202
它包括内联函数的主体

840
00:42:48,535 --> 00:42:50,971
很像Objective-C

841
00:42:51,238 --> 00:42:53,974
C++头文件实现

842
00:42:54,842 --> 00:42:55,676
但是

843
00:42:55,742 --> 00:42:56,844
要注意一点

844
00:42:56,910 --> 00:43:01,381
就是它包含

845
00:42:56,910 --> 00:43:01,381
就是它包含

846
00:43:02,115 --> 00:43:04,218
这让你可以

847
00:43:04,284 --> 00:43:05,619
很方便

848
00:43:06,253 --> 00:43:07,988
但也意味着

849
00:43:08,388 --> 00:43:12,359
你不能用私人秘密

850
00:43:15,829 --> 00:43:16,964
对累加构建

851
00:43:17,331 --> 00:43:19,933
编译器生成

852
00:43:20,434 --> 00:43:23,270
然后合并为一个文件

853
00:43:23,470 --> 00:43:25,939
代表整个模块的内容

854
00:43:26,974 --> 00:43:29,443
合并过程可能会

855
00:43:29,510 --> 00:43:32,913
生成一个

856
00:43:34,515 --> 00:43:35,382
很多时候

857
00:43:35,449 --> 00:43:37,251
这类似于连接器的操作

858
00:43:37,317 --> 00:43:39,486
把目标文件整合成

859
00:43:39,853 --> 00:43:41,855
一个执行文件

860
00:43:42,322 --> 00:43:43,724
更多关于它的内容

861
00:43:43,790 --> 00:43:46,393
有请Louis讲讲连接器

862
00:43:46,827 --> 00:43:47,694
Louis

863
00:43:48,161 --> 00:43:49,129
谢谢 Devin

864
00:43:54,835 --> 00:43:57,371
我是Louis Gerbarg

865
00:43:57,871 --> 00:44:00,274
这是完成Xcode构建的最后一步

866
00:43:57,871 --> 00:44:00,274
这是完成Xcode构建的最后一步

867
00:44:00,607 --> 00:44:01,642
开始吧

868
00:44:03,076 --> 00:44:06,113
首先浏览一下我要讲的内容

869
00:44:06,680 --> 00:44:08,782
我会讲什么是连接器

870
00:44:09,650 --> 00:44:11,251
还有它用做输入的

871
00:44:11,318 --> 00:44:13,921
dylibs和目标文件及其定义

872
00:44:14,688 --> 00:44:16,190
还会讲到符号

873
00:44:16,757 --> 00:44:18,058
及其内容

874
00:44:18,926 --> 00:44:21,061
最后我会总结一遍

875
00:44:21,128 --> 00:44:24,298
通过举例

876
00:44:25,098 --> 00:44:27,067
如果感到疑惑

877
00:44:27,501 --> 00:44:29,169
坚持住

878
00:44:31,438 --> 00:44:32,272
那么…

879
00:44:32,639 --> 00:44:33,473
什么是连接器？

880
00:44:33,540 --> 00:44:36,009
我说过

881
00:44:36,443 --> 00:44:37,344
构建阶段

882
00:44:38,145 --> 00:44:40,914
我们要合并

883
00:44:41,381 --> 00:44:45,819
是两个编译器之前生成的

884
00:44:47,054 --> 00:44:49,256
全部内容就是

885
00:44:49,323 --> 00:44:51,458
它不能生成代码

886
00:44:51,525 --> 00:44:54,061
我来举例说明

887
00:44:55,629 --> 00:44:57,931
我们有两种输入文件

888
00:44:58,265 --> 00:45:01,268
第一种是dylibs

889
00:44:58,265 --> 00:45:01,268
第一种是dylibs

890
00:45:01,468 --> 00:45:02,336
有多个…

891
00:45:03,036 --> 00:45:04,671
第一个应该是

892
00:45:05,539 --> 00:45:06,840
产生于构建过程

893
00:45:06,907 --> 00:45:08,408
第二种是库

894
00:45:08,809 --> 00:45:11,178
由多种类型组成

895
00:45:11,245 --> 00:45:14,581
tbd

896
00:45:15,983 --> 00:45:17,918
符号是什么？

897
00:45:18,485 --> 00:45:22,256
符号是名称

898
00:45:24,625 --> 00:45:27,528
这些片段可能会

899
00:45:28,295 --> 00:45:29,796
当一个函数

900
00:45:29,863 --> 00:45:31,098
调用另一个函数

901
00:45:33,634 --> 00:45:36,904
符号具有属性

902
00:45:36,970 --> 00:45:38,338
这有很多

903
00:45:38,405 --> 00:45:41,909
我只举一个例子

904
00:45:42,242 --> 00:45:45,145
弱符号的注释是指

905
00:45:45,779 --> 00:45:51,552
它可能会消失

906
00:45:51,818 --> 00:45:52,886
执行文件时

907
00:45:53,320 --> 00:45:58,859
这都是可用性标记

908
00:45:58,926 --> 00:46:00,961
那个API可用于iOS 11

909
00:45:58,926 --> 00:46:00,961
那个API可用于iOS 11

910
00:46:01,628 --> 00:46:05,232
这就引到了

911
00:46:05,299 --> 00:46:07,768
连接器决定哪些符号

912
00:46:07,835 --> 00:46:13,006
和哪些符号

913
00:46:14,975 --> 00:46:18,378
语言可以将数据编码成符号

914
00:46:18,445 --> 00:46:19,947
Devin已经提到过

915
00:46:21,181 --> 00:46:22,015
而且…

916
00:46:22,583 --> 00:46:25,052
C++和Swift中

917
00:46:27,254 --> 00:46:28,088
那么…

918
00:46:28,155 --> 00:46:29,623
符号就是这些

919
00:46:30,424 --> 00:46:32,626
代码和数据的名字

920
00:46:33,360 --> 00:46:34,194
那么…

921
00:46:34,561 --> 00:46:35,929
编译器生成目标文件

922
00:46:35,996 --> 00:46:38,265
目标文件就是

923
00:46:38,732 --> 00:46:41,602
代码和数据的集合

924
00:46:42,703 --> 00:46:43,871
它们不可执行

925
00:46:43,937 --> 00:46:47,474
因为是编译的代码

926
00:46:47,774 --> 00:46:49,142
还有缺失

927
00:46:49,209 --> 00:46:51,512
就需要linke整合和修复

928
00:46:54,114 --> 00:46:57,284
每个文件的片段

929
00:46:57,351 --> 00:46:58,185
那么…

930
00:46:58,418 --> 00:47:00,654
print f函数

931
00:46:58,418 --> 00:47:00,654
print f函数

932
00:47:01,321 --> 00:47:03,257
就以符号代替代码

933
00:47:03,790 --> 00:47:06,426
对于其他PetKit函数

934
00:47:06,827 --> 00:47:07,828
也是一样

935
00:47:09,863 --> 00:47:12,299
片段可能引用未定义符号

936
00:47:12,366 --> 00:47:14,701
如果.o文件

937
00:47:15,802 --> 00:47:18,272
引用另一个

938
00:47:18,639 --> 00:47:20,707
这个.o文件就是未定义的

939
00:47:20,874 --> 00:47:24,144
连接器会查找未定义符号

940
00:47:26,346 --> 00:47:27,181
那么…

941
00:47:27,381 --> 00:47:30,551
我说过目标文件是编译器的输出

942
00:47:30,617 --> 00:47:31,852
什么是库？

943
00:47:32,486 --> 00:47:34,821
库是定义符号的文件

944
00:47:34,888 --> 00:47:37,524
但不属于构建的目标

945
00:47:38,392 --> 00:47:40,961
我们有动态库

946
00:47:41,595 --> 00:47:42,496
而且…

947
00:47:42,729 --> 00:47:46,567
这些Mach-O文件

948
00:47:46,633 --> 00:47:48,702
供可执行文件使用

949
00:47:49,536 --> 00:47:52,506
它们是系统的一部分

950
00:47:52,573 --> 00:47:54,741
这是我们用的框架

951
00:47:54,808 --> 00:47:56,109
自己的框架

952
00:47:58,212 --> 00:48:02,049
还有TBD文件

953
00:47:58,212 --> 00:48:02,049
还有TBD文件

954
00:48:02,115 --> 00:48:03,250
这是什么呢？

955
00:48:03,984 --> 00:48:04,818
就是…

956
00:48:05,853 --> 00:48:09,289
在给iOS和macOS

957
00:48:09,623 --> 00:48:11,758
会有所有这些动态库和函数

958
00:48:11,825 --> 00:48:14,428
例如MapKit和WebKit

959
00:48:14,728 --> 00:48:17,731
但我们不想把

960
00:48:17,798 --> 00:48:19,299
这样体积太大

961
00:48:19,900 --> 00:48:21,735
编译器和连接器

962
00:48:21,802 --> 00:48:23,070
它只要运行程序

963
00:48:23,136 --> 00:48:24,905
因此我们创建了

964
00:48:24,972 --> 00:48:27,307
删除了所有符号的主体

965
00:48:27,374 --> 00:48:28,742
只保留名字

966
00:48:29,376 --> 00:48:30,644
完成之后

967
00:48:30,844 --> 00:48:33,814
转用文本表示

968
00:48:33,881 --> 00:48:39,052
目前它们只用于

969
00:48:40,187 --> 00:48:43,323
如果在项目中看见它们

970
00:48:43,690 --> 00:48:44,992
它们只是符号

971
00:48:46,159 --> 00:48:48,161
最后是静态库

972
00:48:48,428 --> 00:48:49,263
那么…

973
00:48:50,030 --> 00:48:52,266
静态库是…

974
00:48:52,332 --> 00:48:56,603
之前用AR工具创建的

975
00:48:56,670 --> 00:49:00,541
也可能是lib

976
00:48:56,670 --> 00:49:00,541
也可能是lib

977
00:49:00,941 --> 00:49:02,910
根据AR操作文档

978
00:49:03,410 --> 00:49:06,680
AR创建并维护文件组

979
00:49:06,747 --> 00:49:08,382
将它们合并为一个库

980
00:49:09,316 --> 00:49:12,853
听上去像是

981
00:49:12,920 --> 00:49:13,954
的确是这样

982
00:49:14,021 --> 00:49:14,855
事实上…

983
00:49:14,922 --> 00:49:17,024
.a格式是原始的库格式

984
00:49:17,090 --> 00:49:20,327
在更好的工具产生之前

985
00:49:21,795 --> 00:49:24,364
但现在的编译器和连接器

986
00:49:24,431 --> 00:49:26,567
可以完全理解它们

987
00:49:26,934 --> 00:49:28,936
它就只是个档案文件

988
00:49:31,872 --> 00:49:35,209
值得注意的是

989
00:49:35,275 --> 00:49:36,143
在过去

990
00:49:36,210 --> 00:49:39,313
所有代码都被存档

991
00:49:39,780 --> 00:49:40,881
因此

992
00:49:41,181 --> 00:49:44,184
不能涵盖所有C库

993
00:49:44,251 --> 00:49:45,786
只用一个函数

994
00:49:46,019 --> 00:49:47,421
因此 行为是…

995
00:49:48,388 --> 00:49:50,591
如果.o文件含有符号

996
00:49:50,657 --> 00:49:53,026
我们会把整个.o文件

997
00:49:53,093 --> 00:49:55,429
但不会带入其他.o文件

998
00:49:56,230 --> 00:49:57,965
如果在之间引用符号

999
00:49:58,031 --> 00:49:59,800
只要带入即可

1000
00:49:59,867 --> 00:50:01,935
如果是非符号行为

1001
00:49:59,867 --> 00:50:01,935
如果是非符号行为

1002
00:50:02,002 --> 00:50:03,837
比如静态初始程序

1003
00:50:04,004 --> 00:50:06,006
或将它们以你个人

1004
00:50:06,073 --> 00:50:08,408
你要明确地用到

1005
00:50:09,076 --> 00:50:13,146
强制加载或制定加载

1006
00:50:13,213 --> 00:50:15,115
或这些文件

1007
00:50:17,284 --> 00:50:20,954
我们通过一个例子

1008
00:50:23,457 --> 00:50:27,961
台上是playSound函数样本

1009
00:50:28,028 --> 00:50:30,797
只看宠物不听声音

1010
00:50:32,199 --> 00:50:33,066
那么…

1011
00:50:33,767 --> 00:50:35,636
调用playSound

1012
00:50:35,702 --> 00:50:37,804
这个Cat函数

1013
00:50:37,871 --> 00:50:39,173
很简单吧

1014
00:50:39,573 --> 00:50:41,575
来看看生成的程序集

1015
00:50:42,876 --> 00:50:43,810
那么…

1016
00:50:44,144 --> 00:50:46,146
输出文件是cat.o

1017
00:50:46,813 --> 00:50:47,648
现在…

1018
00:50:48,315 --> 00:50:50,150
我们可以看到

1019
00:50:51,218 --> 00:50:55,155
字符串purr.aac

1020
00:50:55,656 --> 00:50:57,257
它被复制到cat.o

1021
00:50:57,324 --> 00:51:00,794
你会看到

1022
00:50:57,324 --> 00:51:00,794
你会看到

1023
00:51:01,094 --> 00:51:03,030
因为它是静态的

1024
00:51:03,096 --> 00:51:06,033
如果你熟悉C语言

1025
00:51:06,099 --> 00:51:07,534
没有人能引用它

1026
00:51:07,768 --> 00:51:09,837
既然如此

1027
00:51:09,903 --> 00:51:10,938
排除掉

1028
00:51:14,208 --> 00:51:15,275
然后可以看到

1029
00:51:15,976 --> 00:51:18,212
Cat purr变成了符号

1030
00:51:18,579 --> 00:51:21,481
-[Cat purr]

1031
00:51:23,550 --> 00:51:24,952
跟预想的差不多

1032
00:51:26,253 --> 00:51:28,989
然后我们要把这个变量

1033
00:51:29,056 --> 00:51:30,858
传递到playSound

1034
00:51:31,291 --> 00:51:33,794
这里出现了两个指令

1035
00:51:33,861 --> 00:51:34,862
这是因为…

1036
00:51:35,362 --> 00:51:38,298
我们不知道

1037
00:51:38,365 --> 00:51:39,266
执行文件的位置

1038
00:51:39,333 --> 00:51:41,301
没有具体的位置

1039
00:51:41,602 --> 00:51:44,838
但我们知道RM64

1040
00:51:45,506 --> 00:51:46,807
它最多接收两个指令

1041
00:51:46,874 --> 00:51:49,076
编译器留下两个指令

1042
00:51:49,343 --> 00:51:53,146
留下了符号偏离

1043
00:51:53,213 --> 00:51:55,349
连接器之后回来修复

1044
00:51:56,149 --> 00:52:00,687
既然已经

1045
00:51:56,149 --> 00:52:00,687
既然已经

1046
00:52:01,855 --> 00:52:05,692
就可以调用playSound

1047
00:52:05,759 --> 00:52:10,430
我们写入

1048
00:52:11,498 --> 00:52:12,599
这是什么？

1049
00:52:12,666 --> 00:52:13,734
这是变形的符号

1050
00:52:13,800 --> 00:52:16,136
如果仔细看

1051
00:52:16,203 --> 00:52:17,804
这是Objective-C++

1052
00:52:18,405 --> 00:52:21,542
playSound实际是

1053
00:52:22,042 --> 00:52:22,876
那么…

1054
00:52:22,943 --> 00:52:24,344
如果你不熟悉

1055
00:52:25,979 --> 00:52:28,715
可以在命令窗口

1056
00:52:28,782 --> 00:52:31,151
如果运行

1057
00:52:31,385 --> 00:52:33,554
传递符号

1058
00:52:33,720 --> 00:52:35,856
没有用

1059
00:52:36,456 --> 00:52:39,092
但C++filt

1060
00:52:39,226 --> 00:52:40,427
告诉我们它实际上是

1061
00:52:41,328 --> 00:52:42,529
playSound的符号

1062
00:52:42,596 --> 00:52:44,932
除了playSound

1063
00:52:44,998 --> 00:52:47,534
就是const char*

1064
00:52:47,601 --> 00:52:52,139
因为C++会将更多信息

1065
00:52:53,640 --> 00:52:55,108
现在有了.o文件

1066
00:52:55,509 --> 00:52:57,811
实际构建中会有更多

1067
00:52:58,946 --> 00:53:01,048
那怎么办呢？

1068
00:52:58,946 --> 00:53:01,048
那怎么办呢？

1069
00:53:02,082 --> 00:53:03,717
首先

1070
00:53:03,784 --> 00:53:06,653
会将所有的.o

1071
00:53:06,720 --> 00:53:09,323
连接器会创建文件夹

1072
00:53:09,756 --> 00:53:11,058
这里构建的PetKit

1073
00:53:11,124 --> 00:53:13,360
是PetWall的内嵌框架

1074
00:53:14,962 --> 00:53:16,463
所以我们只要复制

1075
00:53:16,530 --> 00:53:18,665
创建一个文本片段

1076
00:53:19,299 --> 00:53:22,069
用来保存

1077
00:53:22,703 --> 00:53:24,905
然后复制cat.o到这里

1078
00:53:24,972 --> 00:53:26,673
但是要分成两个部分

1079
00:53:26,907 --> 00:53:29,443
一个给字符串

1080
00:53:30,410 --> 00:53:33,514
现在已知它们的文件位置

1081
00:53:33,580 --> 00:53:36,984
连接器就能复写cat.o

1082
00:53:37,584 --> 00:53:40,287
基于特定的偏移值

1083
00:53:40,754 --> 00:53:43,624
你看到第二个指令消失了

1084
00:53:43,690 --> 00:53:47,361
它被一个null指令代替

1085
00:53:47,961 --> 00:53:52,666
但是它不能被删除

1086
00:53:52,733 --> 00:53:56,370
这会打乱所有已经完成的工作

1087
00:53:56,503 --> 00:53:58,739
所以与其删除

1088
00:53:59,273 --> 00:54:02,142
不如用零行动替代

1089
00:53:59,273 --> 00:54:02,142
不如用零行动替代

1090
00:54:02,609 --> 00:54:03,777
最后是分支

1091
00:54:04,845 --> 00:54:06,246
那么分支指令…

1092
00:54:07,581 --> 00:54:08,415
然后…

1093
00:54:09,850 --> 00:54:11,218
要怎么做？

1094
00:54:11,285 --> 00:54:12,886
因为这个未定义符号？

1095
00:54:13,120 --> 00:54:14,855
我们要继续浏览

1096
00:54:14,922 --> 00:54:17,124
所有已经导入的.o文件

1097
00:54:18,325 --> 00:54:20,127
首先是过去的静态库

1098
00:54:20,194 --> 00:54:22,496
这是PetSupport.a

1099
00:54:22,963 --> 00:54:24,865
PetSupport.a里面

1100
00:54:25,566 --> 00:54:28,468
有一些文件

1101
00:54:29,503 --> 00:54:33,574
大家能看到

1102
00:54:34,741 --> 00:54:35,642
把它拉入

1103
00:54:38,378 --> 00:54:41,048
PetCare.o

1104
00:54:41,381 --> 00:54:43,851
因为这个.o文件没有符号

1105
00:54:43,917 --> 00:54:45,953
能被app的其他部分

1106
00:54:46,019 --> 00:54:46,987
引用

1107
00:54:48,555 --> 00:54:50,624
所有我们把它拉入

1108
00:54:51,859 --> 00:54:53,193
_open

1109
00:54:53,260 --> 00:54:54,895
你看到

1110
00:54:56,096 --> 00:54:57,664
拉入的对话已变成

1111
00:54:57,731 --> 00:54:59,466
open$stub

1112
00:54:59,766 --> 00:55:01,001
为什么呢？

1113
00:54:59,766 --> 00:55:01,001
为什么呢？

1114
00:55:01,768 --> 00:55:04,638
因为我们发现open的复制

1115
00:55:05,806 --> 00:55:09,877
在lib系统的

1116
00:55:11,178 --> 00:55:14,281
我知道

1117
00:55:14,348 --> 00:55:16,016
我不会复制到

1118
00:55:16,083 --> 00:55:17,217
但我需要…

1119
00:55:17,784 --> 00:55:21,255
在app里放入足够的信息

1120
00:55:21,455 --> 00:55:24,858
所以我们创建假函数

1121
00:55:25,259 --> 00:55:26,426
用来代替

1122
00:55:26,493 --> 00:55:27,928
从lib系统

1123
00:55:27,995 --> 00:55:29,196
这里就是open

1124
00:55:29,630 --> 00:55:31,064
观察这个函数

1125
00:55:31,665 --> 00:55:35,269
它实际是来自指针

1126
00:55:36,103 --> 00:55:37,137
然后跳过来

1127
00:55:37,304 --> 00:55:40,774
这需要一个函数指针

1128
00:55:42,609 --> 00:55:43,877
然后创建它

1129
00:55:44,144 --> 00:55:45,212
在数据片段中

1130
00:55:45,579 --> 00:55:48,549
如果有全局变量

1131
00:55:49,349 --> 00:55:51,084
但这里是0

1132
00:55:51,351 --> 00:55:54,721
如果空引用就会导致崩溃

1133
00:55:55,956 --> 00:55:58,458
所以添加一个

1134
00:55:58,525 --> 00:56:00,294
LINKEDIT是元数据

1135
00:55:58,525 --> 00:56:00,294
LINKEDIT是元数据

1136
00:56:00,661 --> 00:56:03,263
连接器会用它

1137
00:56:03,764 --> 00:56:06,433
给操作系统留下信息

1138
00:56:06,500 --> 00:56:09,870
这就是动态连接器

1139
00:56:10,103 --> 00:56:11,538
了解更多信息

1140
00:56:12,105 --> 00:56:16,443
请观看2016年的演讲

1141
00:56:19,246 --> 00:56:20,080
那么…

1142
00:56:21,048 --> 00:56:23,417
简单回顾下今天的内容

1143
00:56:23,483 --> 00:56:27,287
Jake讲述了构建系统

1144
00:56:27,688 --> 00:56:30,624
优化多核构建过程

1145
00:56:33,026 --> 00:56:36,763
Jurgen展示了Clang

1146
00:56:36,830 --> 00:56:39,299
以及如何优化模块构建

1147
00:56:41,001 --> 00:56:42,135
Devin简述了

1148
00:56:42,436 --> 00:56:44,872
Swift对模块的扩展

1149
00:56:45,005 --> 00:56:46,840
所有这些今年的新实施

1150
00:56:46,907 --> 00:56:49,443
比如BF处理

1151
00:56:49,810 --> 00:56:51,645
最后连接器接收

1152
00:56:51,712 --> 00:56:52,913
两个编译器的输出

1153
00:56:53,146 --> 00:56:55,015
将它们带入app

1154
00:56:55,249 --> 00:56:57,951
这时Xcode会

1155
00:56:58,018 --> 00:56:58,852
与其他…

1156
00:57:00,387 --> 00:57:02,789
app部分糅合

1157
00:57:03,957 --> 00:57:04,791
那么…

1158
00:57:05,926 --> 00:57:07,861
这些基本都是开源的

1159
00:57:07,928 --> 00:57:09,329
如果感兴趣

1160
00:57:09,396 --> 00:57:13,433
可以研究Swift或Clang

1161
00:57:14,801 --> 00:57:16,036
对这些URL

1162
00:57:16,904 --> 00:57:18,805
谢谢大家的到来

1163
00:57:19,206 --> 00:57:20,040
而且…

1164
00:57:20,641 --> 00:57:23,310
希望你们享受本次WWDC

1165
00:57:23,377 --> 00:57:24,278
谢谢
