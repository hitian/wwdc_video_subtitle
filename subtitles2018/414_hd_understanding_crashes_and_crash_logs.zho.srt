1
00:00:17,818 --> 0:00:19,753
（理解崩溃和崩溃日志

2
00:00:19,820 --> 0:00:23,790
大家早上好

3
00:00:26,860 --> 0:00:29,496
稍后一些非常聪明的人会到台上来

4
00:00:29,563 --> 0:00:32,399
今天我们为你准备了一些很酷的东西

5
00:00:34,201 --> 0:00:37,638
首先声明

6
00:00:37,704 --> 0:00:42,843
如果你从未编写过会崩溃的代码

7
00:00:43,810 --> 0:00:48,048
这次演讲是为我们中那些

8
00:00:49,449 --> 0:00:53,120
今天我们将讨论

9
00:00:53,387 --> 0:00:55,989
来更好处理你的崩溃代码

10
00:00:56,223 --> 0:00:57,758
若这些崩溃会影响到你的用户

11
00:00:58,825 --> 0:01:01,762
具体来说 我将介绍崩溃的基本原理

12
00:00:58,825 --> 0:01:01,762
具体来说 我将介绍崩溃的基本原理

13
00:01:02,229 --> 0:01:04,531
它们为什么会发生

14
00:01:05,799 --> 0:01:08,402
然后我将向你展示我们的一些工具

15
00:01:08,468 --> 0:01:11,305
它们可以用来访问崩溃日志

16
00:01:12,339 --> 0:01:15,609
然后Greg将上台并介绍

17
00:01:15,676 --> 0:01:18,178
关于如何阅读崩溃日志内容的

18
00:01:18,879 --> 0:01:21,315
然后他会深入探讨

19
00:01:21,381 --> 0:01:24,051
如何使用崩溃日志分析

20
00:01:24,985 --> 0:01:28,288
接下来Kuba将向你展示

21
00:01:28,355 --> 0:01:30,257
这些线程竞争常常导致崩溃

22
00:01:30,324 --> 0:01:32,192
并且这种崩溃非常难以重现

23
00:01:33,794 --> 0:01:37,531
首先我们应该给它一个定义

24
00:01:38,732 --> 0:01:42,102
崩溃是当你的app

25
00:01:42,603 --> 0:01:45,305
突然终止

26
00:01:46,240 --> 0:01:47,374
那么不允许的是什么？

27
00:01:47,741 --> 0:01:51,044
有时CPU无法执行某些代码

28
00:01:51,411 --> 0:01:53,080
CPU不会除以零

29
00:01:54,047 --> 0:01:57,518
或者有时是操作系统

30
00:01:59,052 --> 0:02:01,588
操作系统将通过终止你的app

31
00:01:59,052 --> 0:02:01,588
操作系统将通过终止你的app

32
00:02:01,655 --> 0:02:04,758
这种情况会发生在

33
00:02:04,825 --> 0:02:06,293
或它使用了太多内存时

34
00:02:08,027 --> 0:02:10,364
有时 你正在使用的编程语言

35
00:02:10,430 --> 0:02:14,001
会试图阻止失败并将触发崩溃

36
00:02:14,334 --> 0:02:17,538
Swift中的Array

37
00:02:17,604 --> 0:02:19,840
如果你正试图越界访问数组

38
00:02:20,874 --> 0:02:24,311
或者有时是你

39
00:02:24,745 --> 0:02:28,582
你可能有一个API

40
00:02:29,082 --> 0:02:30,517
这完全没问题

41
00:02:32,486 --> 0:02:34,388
大家以前应该都见过这个

42
00:02:34,888 --> 0:02:38,158
这就是Xcode中调试器的样子

43
00:02:38,225 --> 0:02:40,327
其被绑定到你的app上

44
00:02:40,827 --> 0:02:43,964
并在你的app终止之前

45
00:02:45,332 --> 0:02:48,235
让我们仔细看看左边的这个回溯

46
00:02:48,836 --> 0:02:52,973
你可以在此处看到该app

47
00:02:53,974 --> 0:02:57,477
当我们暂停时

48
00:02:57,544 --> 0:03:00,380
以及函数之间的互相调用

49
00:02:57,544 --> 0:03:00,380
以及函数之间的互相调用

50
00:03:00,547 --> 0:03:04,618
最终我们到达了你的代码中的这一点

51
00:03:04,685 --> 0:03:08,355
在该处app除了崩溃别无他法

52
00:03:09,022 --> 0:03:11,525
最后调试器收到一个信号

53
00:03:11,592 --> 0:03:14,428
即此app即将崩溃并暂停app

54
00:03:16,263 --> 0:03:17,598
有时候

55
00:03:17,664 --> 0:03:21,034
你并不总能很方便地绑定调试器

56
00:03:21,835 --> 0:03:23,737
当你没有绑定调试器时

57
00:03:24,104 --> 0:03:28,041
操作系统将以纯文本格式捕获此回溯

58
00:03:28,208 --> 0:03:31,044
并将其保存到磁盘中的

59
00:03:32,813 --> 0:03:36,149
实际上如果是你的app的

60
00:03:36,216 --> 0:03:37,951
其崩溃日志看来并不这么清晰明了

61
00:03:38,385 --> 0:03:42,155
其中实际包含的是

62
00:03:42,256 --> 0:03:44,892
这是一个非符号化崩溃日志的片段

63
00:03:45,993 --> 0:03:48,896
幸运的是 Xcode负责

64
00:03:48,962 --> 0:03:51,431
所以你会看到那些你熟悉的函数名

65
00:03:51,498 --> 0:03:54,334
文件名和行号

66
00:03:56,837 --> 0:04:00,474
有很多方法可以访问这些崩溃日志

67
00:03:56,837 --> 0:04:00,474
有很多方法可以访问这些崩溃日志

68
00:04:00,941 --> 0:04:03,777
我想首先谈谈如何访问这些崩溃日志

69
00:04:03,844 --> 0:04:07,614
其可能来自TestFlight中的测试人员

70
00:04:08,782 --> 0:04:10,651
你可以使用Xcode中

71
00:04:10,717 --> 0:04:14,254
被称为Crashes Organizer的功能

72
00:04:14,421 --> 0:04:17,124
这就是它的样子

73
00:04:18,158 --> 0:04:20,093
让我们来浏览一下它的界面

74
00:04:20,928 --> 0:04:23,497
你可以在左侧看到你在

75
00:04:23,564 --> 0:04:25,599
TestFlight和

76
00:04:26,066 --> 0:04:30,370
它支持我们的所有平台

77
00:04:31,805 --> 0:04:34,041
在右边 对于给定的崩溃点

78
00:04:34,241 --> 0:04:36,810
你可以看到受影响的各种设备的数量

79
00:04:37,878 --> 0:04:42,015
我们按类似问题 即类似崩溃点

80
00:04:42,216 --> 0:04:45,752
并按受影响的设备数量在源列表中

81
00:04:46,854 --> 0:04:50,524
你可以在下方翻阅各个日志的样本

82
00:04:51,692 --> 0:04:56,330
当你单击此按钮时

83
00:04:56,396 --> 0:04:59,032
打开崩溃日志并与源代码一起查看

84
00:04:59,099 --> 0:05:02,636
如果你以前没见过这个

85
00:04:59,099 --> 0:05:02,636
如果你以前没见过这个

86
00:05:03,270 --> 0:05:07,207
在详细视图中 我们会向你展示

87
00:05:07,474 --> 0:05:09,176
并突出显示崩溃点

88
00:05:09,610 --> 0:05:12,546
既然我们已经熟悉了这个界面

89
00:05:13,447 --> 0:05:15,682
我在这里打开了Xcode

90
00:05:16,483 --> 0:05:19,286
我将打开Organizer窗口

91
00:05:20,754 --> 0:05:22,723
你可以看到

92
00:05:22,789 --> 0:05:24,358
即第二个标签

93
00:05:24,424 --> 0:05:28,095
我选中了Kuba和我正研发的

94
00:05:28,896 --> 0:05:32,232
我已将此构建版本

95
00:05:32,299 --> 0:05:34,835
你可以看到这是第五个构建版本

96
00:05:35,002 --> 0:05:37,237
并且许多测试人员报告了崩溃现象

97
00:05:37,304 --> 0:05:38,438
所以这不太好

98
00:05:38,505 --> 0:05:41,508
你可以看到我已经处理过几起崩溃

99
00:05:41,575 --> 0:05:43,277
但我还没有处理过第一个

100
00:05:43,343 --> 0:05:44,778
所以让我们试着解决这问题

101
00:05:46,113 --> 0:05:48,749
这影响了242个设备

102
00:05:49,016 --> 0:05:51,018
我可以看到

103
00:05:51,084 --> 0:05:54,121
并且崩溃点被突出显示了

104
00:05:54,988 --> 0:05:56,590
现在我还不太清楚发生了什么

105
00:05:56,657 --> 0:06:00,360
但我确信如果我在源代码中

106
00:05:56,657 --> 0:06:00,360
但我确信如果我在源代码中

107
00:06:00,427 --> 0:06:02,229
我就能知道发生了什么

108
00:06:02,296 --> 0:06:04,531
所以我要点击

109
00:06:04,965 --> 0:06:08,035
选择与app的第五次构建版本

110
00:06:08,635 --> 0:06:12,039
你能看到的是这个崩溃日志

111
00:06:12,105 --> 0:06:15,809
已在调试导航器中打开

112
00:06:16,810 --> 0:06:19,446
而且我们现在暂停在

113
00:06:20,414 --> 0:06:24,318
这时该问自己这里该使用

114
00:06:24,384 --> 0:06:27,054
我只想在绝对必要的情况下崩溃

115
00:06:28,222 --> 0:06:34,461
这是一个Int类型枚举的

116
00:06:35,128 --> 0:06:39,800
并且枚举值只能是0或1

117
00:06:40,167 --> 0:06:41,435
我认为这是合理的

118
00:06:41,502 --> 0:06:45,405
这个崩溃只有在程序员误用时

119
00:06:45,706 --> 0:06:49,409
如果我在这里向上查看调用堆栈

120
00:06:49,476 --> 0:06:51,612
我可以看到这个初始化函数的调用者

121
00:06:52,112 --> 0:06:54,748
即这个tableView委托方法

122
00:06:54,815 --> 0:06:59,052
此方法要获取给定块编号中的

123
00:06:59,520 --> 0:07:02,022
因此该块编号不能是0或1

124
00:06:59,520 --> 0:07:02,022
因此该块编号不能是0或1

125
00:07:02,656 --> 0:07:05,225
现在我想我知道发生了什么事了

126
00:07:05,292 --> 0:07:08,829
但让我们尝试在app中重现此问题

127
00:07:09,196 --> 0:07:10,364
我点击开始

128
00:07:11,698 --> 0:07:15,369
Chocolate Chip是食谱app

129
00:07:15,736 --> 0:07:18,872
我一直在测试这种生奶油食谱

130
00:07:19,039 --> 0:07:20,274
你可以看到一切正常

131
00:07:20,340 --> 0:07:22,776
我可以看到我的食材列表

132
00:07:22,843 --> 0:07:24,178
这是食谱的两个部分

133
00:07:24,244 --> 0:07:27,948
食材是第0部分 步骤是第1部分

134
00:07:28,549 --> 0:07:30,584
如果我点击另一个食谱

135
00:07:31,285 --> 0:07:32,352
我们崩溃了

136
00:07:32,719 --> 0:07:36,423
我能看到的是

137
00:07:36,590 --> 0:07:38,792
并且回溯看起来与们一直在关注的

138
00:07:38,859 --> 0:07:40,594
崩溃日志非常相似

139
00:07:40,661 --> 0:07:42,963
这个信号表明

140
00:07:43,397 --> 0:07:46,033
我通过点击删除来清除此崩溃日志

141
00:07:46,600 --> 0:07:49,102
我们来看看这个调试会话

142
00:07:50,037 --> 0:07:51,338
在这个严重错误中

143
00:07:51,405 --> 0:07:54,041
我可以看到提示消息被打印出来

144
00:07:54,107 --> 0:07:56,043
即块编号为8

145
00:07:56,109 --> 0:07:58,545
这就是我们崩溃的原因

146
00:07:59,513 --> 0:08:01,915
现在看起来这都是我的错

147
00:07:59,513 --> 0:08:01,915
现在看起来这都是我的错

148
00:08:02,482 --> 0:08:04,751
当我实现这个类时

149
00:08:04,818 --> 0:08:08,088
我实现了另一个

150
00:08:08,789 --> 0:08:12,693
numberOfSections

151
00:08:12,893 --> 0:08:15,462
然而我在这里返回的却是食材的数量

152
00:08:15,662 --> 0:08:17,464
而ingredients.count的值为8

153
00:08:18,332 --> 0:08:20,567
信不信由你 我有个好方法

154
00:08:21,068 --> 0:08:22,970
我知道我想要返回的是

155
00:08:23,036 --> 0:08:25,572
此RecipeSection

156
00:08:25,906 --> 0:08:28,075
并且在Swift 4.2中

157
00:08:28,141 --> 0:08:31,912
Swift开源社区

158
00:08:31,979 --> 0:08:35,315
非常感谢 这是一个名为

159
00:08:35,616 --> 0:08:39,486
若我的RecipeSection

160
00:08:40,254 --> 0:08:42,121
我可以重新实现

161
00:08:42,188 --> 0:08:47,194
返回该RecipeSection

162
00:08:47,461 --> 0:08:51,231
这样我返回的值就为2

163
00:08:51,532 --> 0:08:53,634
我将返回块的准确数量

164
00:08:53,700 --> 0:08:55,202
这样就对了

165
00:08:57,004 --> 0:09:00,707
现在如果我查看这个

166
00:08:57,004 --> 0:09:00,707
现在如果我查看这个

167
00:09:00,774 --> 0:09:04,077
app没有崩溃

168
00:09:04,678 --> 0:09:07,147
我做得很好 我对自己很满意

169
00:09:08,081 --> 0:09:12,819
我可以回到Organizer

170
00:09:12,886 --> 0:09:15,622
离开电脑并回去继续烘焙

171
00:09:23,130 --> 0:09:26,533
你刚看到的是如何使用

172
00:09:26,900 --> 0:09:29,403
从TestFlight

173
00:09:29,970 --> 0:09:32,873
在源代码中打开日志

174
00:09:34,408 --> 0:09:36,243
那你怎样才能开始呢？

175
00:09:36,710 --> 0:09:37,811
很简单

176
00:09:39,112 --> 0:09:42,149
对于你的用户

177
00:09:42,216 --> 0:09:44,952
这就可以了

178
00:09:46,220 --> 0:09:49,389
你需要做的就是使用

179
00:09:51,124 --> 0:09:53,460
在上传app时 你应该包含符号表

180
00:09:53,527 --> 0:09:56,830
以便你能够得到崩溃日志的

181
00:09:58,065 --> 0:10:00,734
打开Organizer窗口中

182
00:09:58,065 --> 0:10:00,734
打开Organizer窗口中

183
00:10:00,801 --> 0:10:02,135
来查看这些崩溃

184
00:10:05,005 --> 0:10:08,175
我们已经讲完了如何在

185
00:10:09,743 --> 0:10:12,713
但若你没通过TestFlight

186
00:10:12,779 --> 0:10:14,581
你还有其它几种选择

187
00:10:15,983 --> 0:10:17,417
比如Devices窗口

188
00:10:18,418 --> 0:10:22,055
当你连接了设备时

189
00:10:22,289 --> 0:10:25,092
这将显示该设备上保存的所有日志

190
00:10:25,158 --> 0:10:26,560
并且这些日志

191
00:10:26,627 --> 0:10:29,129
是使用Mac上的本地符号信息

192
00:10:31,031 --> 0:10:35,836
当你使用Xcode、Xcode Server

193
00:10:36,870 --> 0:10:41,108
测试结果包将包含

194
00:10:41,341 --> 0:10:43,710
它们是在该测试运行期间写出的

195
00:10:43,977 --> 0:10:46,146
这非常方便

196
00:10:46,213 --> 0:10:47,481
也是符号化的

197
00:10:49,049 --> 0:10:50,651
你可以使用Mac控制台app

198
00:10:50,717 --> 0:10:54,421
在Mac或模拟器中

199
00:10:55,822 --> 0:11:00,994
在设备上选择Settings-&gt;Privacy-&gt;

200
00:10:55,822 --> 0:11:00,994
在设备上选择Settings-&gt;Privacy-&gt;

201
00:11:01,061 --> 0:11:03,030
你可以看到保存到磁盘的所有日志

202
00:11:03,096 --> 0:11:06,033
你的用户可以直接

203
00:11:08,535 --> 0:11:09,369
好的

204
00:11:09,770 --> 0:11:12,673
为了确保符号化能够正常工作

205
00:11:12,739 --> 0:11:15,175
我想谈三个重要的最佳实践

206
00:11:16,009 --> 0:11:17,010
第一

207
00:11:18,145 --> 0:11:21,982
若你用Crashes Organizer

208
00:11:22,049 --> 0:11:23,150
这是默认行为

209
00:11:23,517 --> 0:11:27,354
这将确保服务器端符号化

210
00:11:28,689 --> 0:11:32,559
第二 请务必保存你的app档案

211
00:11:33,026 --> 0:11:37,097
你的档案包含调试符号的副本

212
00:11:37,564 --> 0:11:40,100
Xcode用Spotlight

213
00:11:40,167 --> 0:11:43,537
并在必要时自动执行本地符号化

214
00:11:45,305 --> 0:11:48,609
如果你上传包含位码的app

215
00:11:49,243 --> 0:11:53,146
你应该使用“Archives Organizer

216
00:11:53,213 --> 0:11:56,917
来下载位码编译生成的任何dSYM

217
00:11:58,819 --> 0:12:02,022
我们已经涵盖了我们提供的所有工具

218
00:11:58,819 --> 0:12:02,022
我们已经涵盖了我们提供的所有工具

219
00:12:02,089 --> 0:12:04,591
用于在发生崩溃时通过日志访问它们

220
00:12:05,292 --> 0:12:09,229
现在为了向你提供

221
00:12:09,296 --> 0:12:12,366
请热烈欢迎Greg Parker

222
00:12:13,467 --> 0:12:15,002
（分析崩溃日志）

223
00:12:17,938 --> 0:12:19,072
谢谢你 Chris

224
00:12:19,273 --> 0:12:23,510
我们刚刚看到了

225
00:12:23,577 --> 0:12:27,080
以及如何在调试器的

226
00:12:28,015 --> 0:12:31,685
但崩溃日志文件包含更多信息

227
00:12:31,752 --> 0:12:34,788
它包含的信息远不止堆栈跟踪

228
00:12:35,088 --> 0:12:38,725
在调试你的问题的过程中

229
00:12:38,892 --> 0:12:40,627
查看这些额外信息通常很有用

230
00:12:41,361 --> 0:12:44,398
那么你如何得到崩溃日志的全文呢？

231
00:12:44,965 --> 0:12:46,567
这是我们的

232
00:12:46,900 --> 0:12:51,104
如果我们调出上下文菜单

233
00:12:51,839 --> 0:12:54,408
“Show In Finder”

234
00:12:54,474 --> 0:12:58,345
我们可以在控制台app

235
00:12:58,579 --> 0:13:00,080
它看起来像这样

236
00:12:58,579 --> 0:13:00,080
它看起来像这样

237
00:13:00,914 --> 0:13:03,116
那么这个文件里有什么呢？

238
00:13:03,750 --> 0:13:07,254
文件顶部以一些摘要信息开始

239
00:13:07,621 --> 0:13:10,524
这包含你的app名称、版本号

240
00:13:10,824 --> 0:13:13,460
运行它的操作系统版本

241
00:13:13,527 --> 0:13:15,395
以及崩溃的日期和时间

242
00:13:16,597 --> 0:13:19,399
在它下面是崩溃的原因

243
00:13:19,700 --> 0:13:23,070
这是操作系统发送的

244
00:13:23,136 --> 0:13:25,939
具体错误或特定信号

245
00:13:27,307 --> 0:13:30,677
我们还可以看到一些日志信息

246
00:13:30,744 --> 0:13:33,614
它位于“Application Specific

247
00:13:34,248 --> 0:13:37,885
在某些情况下

248
00:13:37,951 --> 0:13:41,822
如果你有未处理的异常

249
00:13:42,956 --> 0:13:45,292
此部分并非始终可用

250
00:13:45,359 --> 0:13:50,697
在iOS设备上 出于个人隐私原因

251
00:13:51,064 --> 0:13:53,000
但是在macOS的模拟器中

252
00:13:53,066 --> 0:13:55,769
此部分可以包含有用的信息

253
00:13:57,504 --> 0:13:59,706
在它下面 我们可以看到线程堆栈

254
00:13:59,773 --> 0:14:02,075
这些是在崩溃时运行的

255
00:13:59,773 --> 0:14:02,075
这些是在崩溃时运行的

256
00:14:02,142 --> 0:14:04,011
所有线程的回溯

257
00:14:04,411 --> 0:14:06,780
其中一个被标记为崩溃线程

258
00:14:07,414 --> 0:14:09,249
其它的是

259
00:14:09,316 --> 0:14:12,052
在进程终止时正在运行的所有线程

260
00:14:13,820 --> 0:14:16,823
在它下面是一些低级信息

261
00:14:16,890 --> 0:14:20,594
我们有崩溃线程的寄存器状态

262
00:14:21,228 --> 0:14:24,865
还有加载到进程中的二进制数据镜像

263
00:14:25,265 --> 0:14:29,670
这是app可执行文件

264
00:14:30,237 --> 0:14:36,376
Xcode使用它进行符号化

265
00:14:36,443 --> 0:14:39,813
以查找符号 文件和行号信息

266
00:14:41,081 --> 0:14:43,350
以上就是崩溃日志文件的内容

267
00:14:43,917 --> 0:14:47,521
那么我们如何调试它

268
00:14:48,388 --> 0:14:52,426
我们从崩溃原因开始

269
00:14:53,093 --> 0:14:57,664
在这个例子中

270
00:14:58,065 --> 0:15:02,536
SIGILL信号指的是

271
00:14:58,065 --> 0:15:02,536
SIGILL信号指的是

272
00:15:03,303 --> 0:15:05,806
这意味着CPU正在尝试执行

273
00:15:05,873 --> 0:15:10,143
由于某种原因不存在或无效的指令

274
00:15:10,210 --> 0:15:12,012
这就是这个进程终止的原因

275
00:15:14,081 --> 0:15:17,684
我们还可以查看崩溃的线程

276
00:15:17,751 --> 0:15:20,320
崩溃时正在运行的代码是什么

277
00:15:20,821 --> 0:15:25,526
这里我们在Swift运行时中

278
00:15:25,893 --> 0:15:29,563
我们并不清楚

279
00:15:30,864 --> 0:15:36,103
此案例中的错误消息被包含在 “Application

280
00:15:36,370 --> 0:15:40,841
所以我们可以看到当进程退出时

281
00:15:45,345 --> 0:15:48,015
让我们仔细看看这个堆栈跟踪

282
00:15:48,482 --> 0:15:50,817
我们看到了

283
00:15:51,618 --> 0:15:55,055
并且是我们代码中的

284
00:15:55,122 --> 0:16:00,494
我们有一个Recipe类

285
00:15:55,122 --> 0:16:00,494
我们有一个Recipe类

286
00:16:00,928 --> 0:16:03,764
并且该函数由于某些错误又调用了

287
00:16:03,830 --> 0:16:05,666
fatalErrorMessage函数

288
00:16:06,934 --> 0:16:11,271
因为这是带有完整调试信息的

289
00:16:11,338 --> 0:16:15,576
我们可以看到一个文件和代码行号

290
00:16:16,710 --> 0:16:20,214
所以我们可以看看那段代码

291
00:16:20,280 --> 0:16:22,516
这是RecipeImage.swift

292
00:16:22,916 --> 0:16:25,819
第26行是在崩溃中标记的那一行

293
00:16:26,653 --> 0:16:29,323
你们中那些经验丰富的

294
00:16:29,389 --> 0:16:32,893
应该容易猜出

295
00:16:33,827 --> 0:16:36,830
这是一个强制解包运算符

296
00:16:37,664 --> 0:16:40,634
我们有一个函数

297
00:16:40,701 --> 0:16:42,736
它返回一个可选值

298
00:16:43,470 --> 0:16:45,339
如果可选值为nil

299
00:16:45,506 --> 0:16:49,376
强制解包运算符将停止进程

300
00:16:49,743 --> 0:16:52,246
生成崩溃日志并退出

301
00:16:53,714 --> 0:16:56,917
若我们还记得刚才的app特定信息

302
00:16:57,117 --> 0:17:00,721
它包含当这个错误检查失败时

303
00:16:57,117 --> 0:17:00,721
它包含当这个错误检查失败时

304
00:17:00,787 --> 0:17:03,724
Swift运行时所打印的错误消息

305
00:17:03,790 --> 0:17:07,227
即“在解包可选值时

306
00:17:08,729 --> 0:17:12,766
这很好 因为它与代码一致

307
00:17:12,833 --> 0:17:16,136
我们在第26行有一个

308
00:17:16,203 --> 0:17:19,106
我们在崩溃日志中有一条错误消息

309
00:17:19,173 --> 0:17:21,575
该消息说我们正在解包一个可选值

310
00:17:21,974 --> 0:17:25,878
造成这次崩溃的原因

311
00:17:29,049 --> 0:17:31,885
强制解包失败

312
00:17:31,952 --> 0:17:35,589
是代码中的前提条件或断言的

313
00:17:36,290 --> 0:17:38,725
前提条件和断言是一种错误检查

314
00:17:38,792 --> 0:17:42,362
它在发现错误时主动停止进程

315
00:17:43,730 --> 0:17:47,367
它们的一些例子包括

316
00:17:47,434 --> 0:17:48,435
强制解包可选值

317
00:17:48,802 --> 0:17:50,737
Swift运行时将断言

318
00:17:50,971 --> 0:17:52,339
可选值不是nil

319
00:17:53,273 --> 0:17:54,374
否则就会崩溃

320
00:17:55,609 --> 0:17:59,046
另一个例子是

321
00:17:59,980 --> 0:18:03,383
如果你访问一个数组且索引超出范围

322
00:17:59,980 --> 0:18:03,383
如果你访问一个数组且索引超出范围

323
00:18:03,650 --> 0:18:05,419
Swift运行时将失败

324
00:18:05,485 --> 0:18:08,822
检查到它不满足该前提条件

325
00:18:10,023 --> 0:18:13,327
Swift算术溢出也包含断言

326
00:18:13,794 --> 0:18:15,696
如果将两个数字加在一起

327
00:18:15,762 --> 0:18:18,131
并且其结果对于整数变量来说太大了

328
00:18:18,465 --> 0:18:21,335
这将无法满足一个前提条件

329
00:18:22,803 --> 0:18:28,242
未捕获的异常通常是由

330
00:18:28,675 --> 0:18:32,312
系统中存在许多错误检查

331
00:18:32,379 --> 0:18:36,283
它会抛出异常 如果没有捕获该异常

332
00:18:36,583 --> 0:18:39,520
未捕获的异常将写入崩溃日志

333
00:18:40,587 --> 0:18:44,958
当然你也可以在自己的代码中

334
00:18:45,192 --> 0:18:48,295
如果你有一些错误

335
00:18:48,362 --> 0:18:50,564
并生成崩溃日志作为响应

336
00:18:52,900 --> 0:18:54,601
崩溃日志的另一个例子

337
00:18:54,668 --> 0:19:00,140
是操作系统从外部杀死进程的情况

338
00:18:54,668 --> 0:19:00,140
是操作系统从外部杀死进程的情况

339
00:19:01,441 --> 0:19:05,846
这方面的一个例子是监视程序事件

340
00:19:06,180 --> 0:19:09,116
如果你的app

341
00:19:09,416 --> 0:19:11,752
操作系统可能会检测到它

342
00:19:11,985 --> 0:19:15,822
并会终止进程并生成特定的崩溃日志

343
00:19:17,124 --> 0:19:18,692
环境条件

344
00:19:18,759 --> 0:19:21,795
也可能导致操作系统终止进程

345
00:19:22,162 --> 0:19:23,897
如果设备过热

346
00:19:24,064 --> 0:19:27,734
操作系统将终止

347
00:19:28,101 --> 0:19:30,137
如果设备内存不足

348
00:19:30,204 --> 0:19:33,507
操作系统将终止使用大量内存的进程

349
00:19:34,842 --> 0:19:37,377
另一种情况是无效的代码签名

350
00:19:37,678 --> 0:19:41,348
操作系统强制要求代码需要被签名

351
00:19:41,481 --> 0:19:44,585
如果签名无效或代码未签名

352
00:19:44,818 --> 0:19:46,820
操作系统将终止进程

353
00:19:46,987 --> 0:19:49,289
并生成特定类型的崩溃日志

354
00:19:50,991 --> 0:19:53,026
操作系统的这些终止行为

355
00:19:53,093 --> 0:19:55,562
可以在Xcode的

356
00:19:55,629 --> 0:19:57,764
你也可以在macOS控制台中

357
00:19:58,065 --> 0:20:01,335
但它们并不总是出现在

358
00:19:58,065 --> 0:20:01,335
但它们并不总是出现在

359
00:20:01,401 --> 0:20:02,970
所以要小心这点

360
00:20:05,172 --> 0:20:09,076
在Apple开发者文档中

361
00:20:09,142 --> 0:20:13,814
它描述了崩溃日志的

362
00:20:13,881 --> 0:20:16,884
就像这个例子一样

363
00:20:16,950 --> 0:20:18,418
你如何识别它们

364
00:20:19,086 --> 0:20:21,688
它比我们在这里讲的更详细

365
00:20:23,257 --> 0:20:24,825
但是让我们看一个例子

366
00:20:25,692 --> 0:20:27,361
这是另一个崩溃日志文件

367
00:20:27,761 --> 0:20:30,397
同样 为了解崩溃日志

368
00:20:30,464 --> 0:20:32,232
我们从崩溃原因开始

369
00:20:32,766 --> 0:20:36,670
在这个例子中 崩溃的原因

370
00:20:36,837 --> 0:20:38,906
其带有SIGKILL信号

371
00:20:39,740 --> 0:20:42,442
通常SIGKILL信号被用在

372
00:20:42,509 --> 0:20:45,479
当操作系统想要终止你的进程时

373
00:20:45,946 --> 0:20:47,848
它会发送SIGKILL信号

374
00:20:47,915 --> 0:20:52,619
SIGKILL信号无法被处理

375
00:20:52,686 --> 0:20:54,855
作为对该信号的响应

376
00:20:56,657 --> 0:20:58,258
我们也可以在崩溃日志中看到

377
00:20:58,325 --> 0:21:00,994
操作系统发送该信号的原因

378
00:20:58,325 --> 0:21:00,994
操作系统发送该信号的原因

379
00:21:01,328 --> 0:21:05,966
在这个例子中

380
00:21:06,433 --> 0:21:09,736
如果你查看我之前提到的

381
00:21:09,803 --> 0:21:12,573
它将描述8badf00d的含义

382
00:21:13,106 --> 0:21:15,576
我们有一个文本描述说

383
00:21:15,642 --> 0:21:20,514
“耗尽实际时钟时间19.95秒”

384
00:21:21,181 --> 0:21:24,551
所以如果我们将这些信息

385
00:21:24,618 --> 0:21:29,089
它会告诉我们

386
00:21:29,323 --> 0:21:33,026
我们有20秒钟启动

387
00:21:33,327 --> 0:21:35,429
操作系统终止了该进程

388
00:21:36,597 --> 0:21:40,801
在下方我们可以看到

389
00:21:41,101 --> 0:21:44,938
这些崩溃日志可能是说

390
00:21:45,005 --> 0:21:46,940
它可能陷入死循环

391
00:21:47,608 --> 0:21:51,578
可能卡在等待网络I/O

392
00:21:52,179 --> 0:21:55,215
或者 另一方面

393
00:21:55,282 --> 0:21:57,818
并且在启动过程之前

394
00:21:57,885 --> 0:22:00,521
这也可能是这个进程终止的原因

395
00:21:57,885 --> 0:22:00,521
这也可能是这个进程终止的原因

396
00:22:04,057 --> 0:22:06,860
启动超时 你如何能避免呢

397
00:22:07,261 --> 0:22:10,864
我们希望你能避免它们

398
00:22:10,931 --> 0:22:14,535
Apple app审核流程的

399
00:22:16,003 --> 0:22:17,171
那你该怎么避免它呢？

400
00:22:17,237 --> 0:22:19,173
首先当然是请测试你的app

401
00:22:19,573 --> 0:22:21,175
但是有一个问题

402
00:22:22,342 --> 0:22:26,880
即模拟器中禁用了启动超时监视程序

403
00:22:26,947 --> 0:22:28,815
并且它在调试器中也被禁用了

404
00:22:29,316 --> 0:22:31,919
所以如果你在模拟器和调试器中

405
00:22:31,985 --> 0:22:33,987
你永远不会看到超时警报

406
00:22:35,122 --> 0:22:39,893
因此在测试app时

407
00:22:40,260 --> 0:22:43,397
如果是macOS app

408
00:22:43,664 --> 0:22:47,367
如果是iOS app

409
00:22:47,434 --> 0:22:50,737
或使用iOS app启动器来启动

410
00:22:51,004 --> 0:22:54,007
所有这些方法都将在调试器外

411
00:22:54,074 --> 0:22:57,010
并会启用且强制执行

412
00:22:58,312 --> 0:23:02,382
当你测试时 请在真实设备上进行

413
00:22:58,312 --> 0:23:02,382
当你测试时 请在真实设备上进行

414
00:23:02,883 --> 0:23:06,587
并尝试使用较旧的硬件

415
00:23:06,653 --> 0:23:10,457
即你希望app所支持的最旧的硬件

416
00:23:10,958 --> 0:23:13,160
如果你只在较新的硬件上测试

417
00:23:13,227 --> 0:23:17,431
你可能会发现你的app

418
00:23:17,831 --> 0:23:20,634
但较慢的设备可能会花费太多时间

419
00:23:24,171 --> 0:23:26,673
让我们谈谈另一类错误

420
00:23:26,740 --> 0:23:31,144
让我们来谈谈内存错误

421
00:23:32,379 --> 0:23:33,714
当我说内存错误时

422
00:23:33,780 --> 0:23:39,686
我指的是像过早释放对象的引用计数

423
00:23:39,987 --> 0:23:43,357
或使用已经被释放的对象

424
00:23:43,624 --> 0:23:47,828
或缓冲区溢出

425
00:23:47,895 --> 0:23:51,932
或一个C数组

426
00:23:53,600 --> 0:23:55,669
让我们看看另一个崩溃日志

427
00:23:55,903 --> 0:23:58,739
剧透一下 这是一个内存错误

428
00:23:59,773 --> 0:24:03,010
我们再次从异常类型开始

429
00:23:59,773 --> 0:24:03,010
我们再次从异常类型开始

430
00:24:03,343 --> 0:24:09,616
这是EXC_BAD_ACCESS

431
00:24:10,150 --> 0:24:13,253
这通常是由内存错误引起的

432
00:24:13,587 --> 0:24:16,623
错误访问异常意味着两件事之一

433
00:24:16,690 --> 0:24:20,327
我们要么写入只读的内存

434
00:24:20,761 --> 0:24:23,830
要么我们尝试从内存中读取

435
00:24:24,231 --> 0:24:27,134
其中任何一个都会导致错误访问异常

436
00:24:27,201 --> 0:24:28,769
并且该进程将终止

437
00:24:29,736 --> 0:24:30,804
我们在这里可以看到

438
00:24:31,104 --> 0:24:34,775
我们在崩溃时试图访问的地址

439
00:24:36,610 --> 0:24:38,278
我们可以查看这些堆栈跟踪

440
00:24:38,345 --> 0:24:41,448
这就是执行错误访问的函数

441
00:24:41,782 --> 0:24:45,886
这是objc_release函数

442
00:24:45,953 --> 0:24:50,390
它是Objective-C和

443
00:24:50,891 --> 0:24:52,025
再者

444
00:24:52,092 --> 0:24:55,662
这听起来很可能是

445
00:24:57,331 --> 0:25:00,501
那么是什么代码调用了

446
00:24:57,331 --> 0:25:00,501
那么是什么代码调用了

447
00:25:00,868 --> 0:25:02,903
我们可以查看堆栈跟踪的其余部分

448
00:25:03,103 --> 0:25:05,906
我们看到

449
00:25:06,373 --> 0:25:08,942
这是Objective-C

450
00:25:09,009 --> 0:25:11,311
它用于释放对象

451
00:25:12,513 --> 0:25:13,981
object_dispose函数

452
00:25:14,047 --> 0:25:18,585
在我们的一个类上调用了

453
00:25:18,652 --> 0:25:20,954
我们的LoginViewController类

454
00:25:21,855 --> 0:25:25,792
__ivar_destroyer

455
00:25:25,859 --> 0:25:28,295
这个函数用来清理属性

456
00:25:28,362 --> 0:25:32,699
即在一个对象被释放时

457
00:25:34,001 --> 0:25:37,437
所以这告诉我们

458
00:25:37,971 --> 0:25:42,543
我们当时正在释放

459
00:25:43,544 --> 0:25:49,249
这个类在其初始化代码中

460
00:25:49,583 --> 0:25:53,253
并且在释放其中一个属性时

461
00:25:54,521 --> 0:25:57,157
所以这给了我们

462
00:25:57,224 --> 0:26:00,160
我们可以做得更好吗

463
00:25:57,224 --> 0:26:00,160
我们可以做得更好吗

464
00:26:00,227 --> 0:26:01,962
可以告诉我们发生了什么的信息？

465
00:26:03,463 --> 0:26:06,633
我们可以看一下无效地址本身

466
00:26:07,167 --> 0:26:13,207
有时实际的错误地址值

467
00:26:13,874 --> 0:26:15,809
这个发生错误的地址

468
00:26:15,876 --> 0:26:19,546
我可以告诉你

469
00:26:20,414 --> 0:26:21,548
我是怎么知道的呢？

470
00:26:21,615 --> 0:26:25,018
部分是因为长期的经验

471
00:26:25,252 --> 0:26:28,722
你就能够开始找出错误值的一些模式

472
00:26:29,790 --> 0:26:31,725
这个错误值

473
00:26:32,526 --> 0:26:37,898
看起来非常像malloc

474
00:26:38,131 --> 0:26:40,968
我们碰巧在此崩溃日志中可以看到它

475
00:26:41,869 --> 0:26:45,205
我们有了内存分配器使用的地址范围

476
00:26:45,506 --> 0:26:50,677
我们的无效地址看起来

477
00:26:51,311 --> 0:26:55,382
但它被偏移了4位

478
00:26:55,816 --> 0:26:59,686
所以看起来它是一个经过旋转的

479
00:27:01,355 --> 0:27:05,092
这是内存分配器本身提供的线索

480
00:27:05,158 --> 0:27:06,760
让我告诉你为什么是这样

481
00:27:07,394 --> 0:27:10,831
这是我们的对象

482
00:27:11,398 --> 0:27:13,934
一个对象以isa字段开始

483
00:27:14,001 --> 0:27:16,970
isa字段指向对象的类

484
00:27:17,237 --> 0:27:19,840
这就是

485
00:27:19,907 --> 0:27:22,442
这也是一些Swift对象的结构

486
00:27:23,043 --> 0:27:25,479
objc_release函数

487
00:27:26,113 --> 0:27:30,384
它读取isa字段

488
00:27:30,450 --> 0:27:33,820
从而可以到该类对象中查找其方法

489
00:27:35,122 --> 0:27:38,392
通常这当然是有效的

490
00:27:39,259 --> 0:27:42,396
但若我们的对象已被释放会怎样呢？

491
00:27:44,331 --> 0:27:47,267
当释放函数删除一个对象时

492
00:27:48,302 --> 0:27:52,573
它将其插入到一个

493
00:27:53,106 --> 0:27:57,978
它会将一个释放列表指针

494
00:27:58,245 --> 0:28:00,047
写入位置

495
00:27:58,245 --> 0:28:00,047
写入位置

496
00:28:01,281 --> 0:28:05,485
但是以一种稍微扭曲的方式

497
00:28:05,552 --> 0:28:08,989
而是将旋转后的指针写入该字段

498
00:28:09,489 --> 0:28:12,159
它想确保写在那里的值

499
00:28:12,226 --> 0:28:15,062
不是有效的内存地址

500
00:28:15,262 --> 0:28:18,765
这正是错误使用该对象

501
00:28:20,133 --> 0:28:23,537
所以当objc_release

502
00:28:23,604 --> 0:28:26,807
它得到的是一个

503
00:28:27,274 --> 0:28:30,911
当它解引用旋转后的释放列表指针时

504
00:28:31,912 --> 0:28:35,782
内存分配器为我们做了这件事

505
00:28:35,849 --> 0:28:38,619
以确保如果我们再次尝试使用它

506
00:28:40,120 --> 0:28:43,190
这就是我们在此崩溃日志中

507
00:28:43,557 --> 0:28:49,463
我们的无效地址字段看起来

508
00:28:49,530 --> 0:28:53,567
但旋转的方式与malloc

509
00:28:54,201 --> 0:28:55,769
这是一个明显的信号

510
00:28:55,836 --> 0:29:00,507
即我们在代码中尝试释放的对象

511
00:28:55,836 --> 0:29:00,507
即我们在代码中尝试释放的对象

512
00:29:00,641 --> 0:29:04,478
已被释放了 这就是发生的内存错误

513
00:29:06,079 --> 0:29:09,416
这就是该漏洞的更多细节

514
00:29:09,483 --> 0:29:13,287
我们的对象正被释放

515
00:29:13,453 --> 0:29:16,957
其中一个ivar已经是一个

516
00:29:17,024 --> 0:29:18,425
这就是造成我们崩溃的原因

517
00:29:19,393 --> 0:29:20,794
我们可以做得更好吗？

518
00:29:21,595 --> 0:29:26,567
我们可以找出是哪个对象

519
00:29:27,534 --> 0:29:30,737
通常 调用

520
00:29:30,804 --> 0:29:32,940
会给我们一个关于那是什么的线索

521
00:29:33,407 --> 0:29:36,310
但__ivar_destroyer函数的问题是

522
00:29:36,510 --> 0:29:39,313
它是由编译器生成的函数

523
00:29:39,813 --> 0:29:42,482
我们没有写过一个叫做

524
00:29:42,549 --> 0:29:45,385
这表示将没有文件名或行号

525
00:29:45,586 --> 0:29:47,588
会被关联到崩溃中的这一点

526
00:29:47,654 --> 0:29:52,426
我们不知道那时

527
00:29:53,460 --> 0:29:56,496
这是我们的类

528
00:29:56,563 --> 0:29:59,967
它们分别是username

529
00:30:00,601 --> 0:30:02,503
这个时候

530
00:30:02,569 --> 0:30:06,139
我们不知道哪个对象

531
00:30:06,206 --> 0:30:07,407
它可能是其中任何一个

532
00:30:08,408 --> 0:30:09,676
我们可以做得更好吗？

533
00:30:09,743 --> 0:30:14,448
我们能够从崩溃日志中

534
00:30:14,515 --> 0:30:16,483
正在被释放的对象吗？

535
00:30:16,817 --> 0:30:19,653
因为如果我们无法在调试器中重现它

536
00:30:19,720 --> 0:30:21,655
我们将只能从崩溃日志着手

537
00:30:22,523 --> 0:30:24,691
在这种情况下

538
00:30:25,526 --> 0:30:31,098
我们可以看到文件和行号

539
00:30:31,832 --> 0:30:34,768
这个“+42”就是我们的线索

540
00:30:34,968 --> 0:30:39,439
因为“+42”是函数的

541
00:30:40,140 --> 0:30:43,043
我们可以反汇编

542
00:30:43,210 --> 0:30:44,545
查看其代码

543
00:30:44,711 --> 0:30:49,216
确定在偏移量为42处所访问的属性

544
00:30:50,284 --> 0:30:51,652
该怎么做呢？

545
00:30:51,852 --> 0:30:55,088
我们进入调试器控制台

546
00:30:55,689 --> 0:30:58,025
我们可以在终端上运行lldb

547
00:30:58,358 --> 0:31:02,896
我们可以在Xcode

548
00:30:58,358 --> 0:31:02,896
我们可以在Xcode

549
00:31:04,665 --> 0:31:09,002
调试器具有导入崩溃日志的命令

550
00:31:09,069 --> 0:31:14,041
就像它在调试器内崩溃了一样

551
00:31:14,541 --> 0:31:18,946
我们运行此命令

552
00:31:20,013 --> 0:31:24,384
然后我们运行另一个命令

553
00:31:25,452 --> 0:31:27,921
我们需要三件东西来完成这项工作

554
00:31:27,988 --> 0:31:31,058
我们需要在Mac上获得

555
00:31:31,491 --> 0:31:34,394
我们还需要一份我们的app的副本

556
00:31:34,695 --> 0:31:38,799
以及该app对应的

557
00:31:39,132 --> 0:31:43,670
所有这些都与此崩溃日志相匹配

558
00:31:43,837 --> 0:31:47,608
这就是我们希望你

559
00:31:48,242 --> 0:31:52,379
如果我们在Mac上有了这些文件

560
00:31:53,146 --> 0:31:56,717
lldb使用Spotlight

561
00:31:56,783 --> 0:31:59,953
找到匹配的符号表

562
00:32:00,954 --> 0:32:03,490
我们在这里可以看到

563
00:32:03,790 --> 0:32:06,960
我们可以看到文件和行号信息

564
00:32:07,261 --> 0:32:08,595
现在我们可以开始工作了

565
00:32:09,029 --> 0:32:12,466
现在我们可以找到

566
00:32:12,866 --> 0:32:14,301
并对其进行反汇编

567
00:32:15,402 --> 0:32:18,639
这向我们展示了该函数的汇编代码

568
00:32:20,007 --> 0:32:23,277
我没有时间教你如何阅读汇编代码

569
00:32:23,343 --> 0:32:26,847
但幸运的是 对于崩溃日志

570
00:32:26,914 --> 0:32:30,484
能够完全流利地阅读汇编代码

571
00:32:30,551 --> 0:32:33,921
通常只需要简单浏览汇编代码

572
00:32:33,987 --> 0:32:36,456
并大致了解发生了什么就足够了

573
00:32:36,523 --> 0:32:39,159
你不必理解每一条指令

574
00:32:39,226 --> 0:32:42,296
来从崩溃日志中获取有用的信息

575
00:32:44,031 --> 0:32:45,866
如果我们浏览这个函数

576
00:32:45,933 --> 0:32:50,771
并且我们知道调用指令和跳转指令

577
00:32:50,838 --> 0:32:56,610
它们是你调用函数的方式

578
00:32:57,377 --> 0:33:00,214
这是顶部

579
00:32:57,377 --> 0:33:00,214
这是顶部

580
00:33:00,280 --> 0:33:05,385
它正在执行一个

581
00:33:05,719 --> 0:33:08,655
这部分代码正在释放

582
00:33:10,324 --> 0:33:13,694
下一部分正在释放

583
00:33:14,094 --> 0:33:17,865
再下一个部分正在释放

584
00:33:18,899 --> 0:33:22,469
我们不明白所有这些指令的含义

585
00:33:22,536 --> 0:33:26,306
但我们大概知道每一部分代码的功能

586
00:33:26,373 --> 0:33:30,544
这有点像有一个与代码相关联的行号

587
00:33:32,079 --> 0:33:35,115
现在我们回到崩溃日志中的信息

588
00:33:35,449 --> 0:33:42,022
即__ivar_destroyer函数加42

589
00:33:43,657 --> 0:33:48,962
在+42处有一个指令

590
00:33:49,429 --> 0:33:51,732
那就是在堆栈跟踪中

591
00:33:52,065 --> 0:33:57,104
大多数堆栈帧的汇编级别偏移量

592
00:33:57,271 --> 0:34:00,240
它是函数调用之后的指令

593
00:33:57,271 --> 0:34:00,240
它是函数调用之后的指令

594
00:34:00,908 --> 0:34:04,845
所以调用objc_release

595
00:34:04,912 --> 0:34:06,180
即这条指令

596
00:34:07,347 --> 0:34:11,752
如果我们读到这个 就说明它是对

597
00:34:11,818 --> 0:34:15,789
这与我们在崩溃日志的堆栈跟踪中

598
00:34:15,856 --> 0:34:19,293
即在此偏移量的

599
00:34:20,127 --> 0:34:24,931
这个释放函数正在释放

600
00:34:25,799 --> 0:34:29,136
现在我们有了关于崩溃时

601
00:34:29,670 --> 0:34:33,040
我们释放了username属性

602
00:34:33,739 --> 0:34:36,577
我们尚未运行到views属性

603
00:34:36,643 --> 0:34:39,413
它可能有效 可能无效

604
00:34:39,813 --> 0:34:43,684
我们知道的是我们试图

605
00:34:44,083 --> 0:34:48,688
并且根据malloc释放列表指针

606
00:34:48,755 --> 0:34:51,091
已经被释放过的对象

607
00:34:52,259 --> 0:34:55,429
所以这告诉了我们

608
00:34:56,029 --> 0:34:59,032
我们正在释放一个

609
00:34:59,399 --> 0:35:02,035
而其中的database属性

610
00:34:59,399 --> 0:35:02,035
而其中的database属性

611
00:35:04,404 --> 0:35:08,609
我们目前为止还没有发现漏洞

612
00:35:08,675 --> 0:35:13,714
__ivar_destroyer函数没有错

613
00:35:14,281 --> 0:35:15,516
但是从崩溃日志中

614
00:35:15,582 --> 0:35:19,453
我们已经能够缩小测试的范围

615
00:35:19,720 --> 0:35:22,489
以及我们应该在何处

616
00:35:22,556 --> 0:35:25,158
我们应该检验这个类

617
00:35:25,225 --> 0:35:27,261
我们应该检验database字段

618
00:35:27,327 --> 0:35:31,598
我们应该阅读

619
00:35:31,665 --> 0:35:32,866
并尝试找到错误

620
00:35:35,135 --> 0:35:36,436
那我们刚刚做了什么？

621
00:35:37,037 --> 0:35:38,839
我们从头开始阅读崩溃日志

622
00:35:38,906 --> 0:35:42,609
从崩溃原因开始

623
00:35:42,676 --> 0:35:45,045
我们了解了异常类型的含义

624
00:35:45,913 --> 0:35:50,083
我们检查了崩溃线程的堆栈跟踪

625
00:35:50,150 --> 0:35:55,122
了解它正在做什么

626
00:35:55,889 --> 0:35:59,092
并且我们在崩溃日志的其它地方

627
00:35:59,259 --> 0:36:02,729
在这个例子中

628
00:35:59,259 --> 0:36:02,729
在这个例子中

629
00:36:02,863 --> 0:36:06,033
我们使用了崩溃函数的反汇编代码

630
00:36:08,669 --> 0:36:14,208
内存错误能导致类型广泛的崩溃

631
00:36:14,274 --> 0:36:17,110
崩溃日志中有许多不同的签名

632
00:36:17,177 --> 0:36:19,046
都可能是由内存错误引起的

633
00:36:20,180 --> 0:36:21,949
以下是一些例子

634
00:36:22,716 --> 0:36:25,886
在Objective-C的objc_msgSend函数中

635
00:36:26,186 --> 0:36:28,188
或在引用计数机制中

636
00:36:28,255 --> 0:36:32,092
或Swift和

637
00:36:32,392 --> 0:36:35,495
它们所发生的崩溃

638
00:36:37,064 --> 0:36:42,269
另一种常见的内存错误症状是

639
00:36:43,136 --> 0:36:47,508
这通常发生在

640
00:36:47,574 --> 0:36:49,943
一段代码正在使用该对象

641
00:36:50,410 --> 0:36:53,580
然后对象被释放并再次被使用

642
00:36:54,314 --> 0:36:57,451
但与我们在前一个崩溃日志中看到的

643
00:36:57,518 --> 0:36:59,820
malloc释放列表签名不同

644
00:36:59,887 --> 0:37:04,591
这次是在同一地址分配了一个新对象

645
00:36:59,887 --> 0:37:04,591
这次是在同一地址分配了一个新对象

646
00:37:04,658 --> 0:37:06,326
取代了以前旧对象所在的位置

647
00:37:06,860 --> 0:37:10,163
所以当代码尝试使用旧对象时

648
00:37:10,230 --> 0:37:12,332
调用旧对象上的函数

649
00:37:12,533 --> 0:37:16,703
我们在该地址处却有一个

650
00:37:16,937 --> 0:37:19,740
并且它根本无法识别该函数

651
00:37:19,940 --> 0:37:22,342
因此我们得到一个

652
00:37:24,945 --> 0:37:27,481
内存错误的另一个常见症状

653
00:37:27,548 --> 0:37:31,585
是内存分配器本身的终止

654
00:37:31,652 --> 0:37:34,121
即在malloc和free函数内

655
00:37:34,888 --> 0:37:38,358
这是我们之前看到的

656
00:37:38,425 --> 0:37:41,361
这是内存分配器内部的前提条件

657
00:37:41,862 --> 0:37:44,198
它可能识别到这样的情况

658
00:37:44,264 --> 0:37:49,303
即malloc内存

659
00:37:49,369 --> 0:37:53,540
已被内存错误破坏

660
00:37:53,974 --> 0:37:59,046
或者它可能检测到

661
00:37:59,413 --> 0:38:02,816
例如 如果你在一行代码中

662
00:37:59,413 --> 0:38:02,816
例如 如果你在一行代码中

663
00:38:03,116 --> 0:38:05,619
malloc分配器有时可以识别出

664
00:38:05,686 --> 0:38:09,056
这是一个双重释放

665
00:38:11,725 --> 0:38:13,393
让我给你一些最后的提示

666
00:38:13,460 --> 0:38:18,498
以用于分析崩溃日志

667
00:38:20,667 --> 0:38:22,069
在刚才看到的崩溃中

668
00:38:22,135 --> 0:38:24,972
我们大部分时间在

669
00:38:25,038 --> 0:38:28,742
即崩溃的特定代码行和崩溃的线程

670
00:38:29,209 --> 0:38:33,514
查看进程中其它

671
00:38:33,580 --> 0:38:35,549
非常重要

672
00:38:36,016 --> 0:38:41,021
例如 在这次崩溃中

673
00:38:41,088 --> 0:38:42,656
漏洞不在这里

674
00:38:42,923 --> 0:38:47,494
该漏洞位于其它地方

675
00:38:49,229 --> 0:38:52,699
除了崩溃线程之外

676
00:38:52,866 --> 0:38:54,835
崩溃日志中的堆栈跟踪

677
00:38:56,236 --> 0:38:59,540
崩溃日志包含进程中的所有堆栈跟踪

678
00:38:59,606 --> 0:39:02,843
并且可能包含有用的信息和线索

679
00:38:59,606 --> 0:39:02,843
并且可能包含有用的信息和线索

680
00:39:02,910 --> 0:39:05,579
可以用来帮助你弄清楚

681
00:39:05,979 --> 0:39:08,949
也许其它线程会显示更多

682
00:39:09,016 --> 0:39:11,718
关于当时app运行到何处的细节

683
00:39:11,785 --> 0:39:13,554
也许它当时正在执行网络代码

684
00:39:13,620 --> 0:39:16,557
这在其它某个堆栈跟踪上可以看到

685
00:39:17,057 --> 0:39:19,593
或者可能存在多线程错误

686
00:39:19,826 --> 0:39:25,132
并且其它线程可能可以提供

687
00:39:27,367 --> 0:39:30,571
你还应该查看多个崩溃日志

688
00:39:30,637 --> 0:39:32,806
以找出特定的崩溃原因

689
00:39:33,574 --> 0:39:37,144
Xcode Organizer

690
00:39:37,211 --> 0:39:39,479
来帮助你对崩溃进行分组

691
00:39:40,280 --> 0:39:42,015
有时候

692
00:39:43,016 --> 0:39:46,186
在同一个崩溃点会发生多次崩溃

693
00:39:46,486 --> 0:39:50,424
但有些日志可能会包含

694
00:39:50,691 --> 0:39:54,294
例如 我们刚看到的

695
00:39:54,795 --> 0:39:58,465
它可能出现在某些崩溃日志中

696
00:39:58,699 --> 0:40:02,202
因此在同一个崩溃集中

697
00:39:58,699 --> 0:40:02,202
因此在同一个崩溃集中

698
00:40:02,269 --> 0:40:04,037
浏览多个崩溃

699
00:40:04,104 --> 0:40:07,441
是否比其它的信息更有用

700
00:40:08,675 --> 0:40:13,046
此外 能够将

701
00:40:13,447 --> 0:40:17,351
有时会将不同原因的崩溃

702
00:40:17,417 --> 0:40:18,919
分到同一组中

703
00:40:19,686 --> 0:40:21,088
可能是其它线程

704
00:40:21,154 --> 0:40:25,492
或崩溃线程的回溯

705
00:40:25,726 --> 0:40:28,228
对人眼来说

706
00:40:28,295 --> 0:40:31,365
这组崩溃有多种原因

707
00:40:31,598 --> 0:40:34,401
尽管Xcode Organizer

708
00:40:34,801 --> 0:40:36,870
如果你只查看一个崩溃日志

709
00:40:37,070 --> 0:40:40,440
你甚至可能不知道

710
00:40:40,674 --> 0:40:43,510
直到你修复第一个崩溃并发布它

711
00:40:43,677 --> 0:40:45,979
而你的用户开始

712
00:40:48,582 --> 0:40:50,617
一旦你对崩溃做了一些分析

713
00:40:50,684 --> 0:40:54,755
一旦你缩小了

714
00:40:54,821 --> 0:40:57,090
或者它可能正在使用的对象

715
00:40:57,424 --> 0:41:00,160
你可以使用

716
00:40:57,424 --> 0:41:00,160
你可以使用

717
00:41:00,227 --> 0:41:01,862
和Zombies等工具

718
00:41:01,929 --> 0:41:03,830
来尝试重现崩溃

719
00:41:04,231 --> 0:41:08,836
因为尽管我们在

720
00:41:08,902 --> 0:41:10,838
缩小问题范围时做得很好

721
00:41:10,904 --> 0:41:14,741
但调试在调试器中发生的崩溃

722
00:41:14,808 --> 0:41:19,546
你可以在测试中使用Sanitization

723
00:41:21,515 --> 0:41:25,085
刚才我提到

724
00:41:25,152 --> 0:41:26,920
多个线程堆栈

725
00:41:26,987 --> 0:41:29,523
以诊断多线程错误

726
00:41:29,957 --> 0:41:33,694
为了详细讨论调试多线程错误

727
00:41:33,760 --> 0:41:35,329
有请Kuba

728
00:41:35,395 --> 0:41:40,567
（多线程问题）

729
00:41:41,134 --> 0:41:42,135
谢谢

730
00:41:43,537 --> 0:41:44,371
谢谢！

731
00:41:45,138 --> 0:41:46,607
正如Greg所说

732
00:41:46,673 --> 0:41:50,110
多线程问题可能导致一些内存损坏

733
00:41:51,044 --> 0:41:54,581
多线程错误通常是最难诊断和重现的

734
00:41:54,648 --> 0:41:56,250
错误类型之一

735
00:41:57,117 --> 0:41:58,819
它们特别难以重现

736
00:41:58,886 --> 0:42:01,488
因为它们只是偶尔会导致崩溃

737
00:41:58,886 --> 0:42:01,488
因为它们只是偶尔会导致崩溃

738
00:42:01,555 --> 0:42:05,559
因此你的代码似乎在99%的情况下

739
00:42:05,926 --> 0:42:08,996
并且这些漏洞在很长一段时间内

740
00:42:11,231 --> 0:42:14,034
通常多线程错误会导致内存损坏

741
00:42:14,101 --> 0:42:17,838
并且你在崩溃日志中看到的内容

742
00:42:17,905 --> 0:42:20,841
我们已经看到了上一节中的例子

743
00:42:21,241 --> 0:42:23,443
当你处理malloc内部的崩溃时

744
00:42:23,510 --> 0:42:26,246
或在释放或保留计数操作时

745
00:42:26,580 --> 0:42:29,183
这些都是内存损坏的典型症状

746
00:42:30,350 --> 0:42:33,754
多线程错误也有一些特有的症状

747
00:42:33,854 --> 0:42:36,957
崩溃的线程通常包含 抱歉

748
00:42:37,024 --> 0:42:39,359
崩溃日志通常包含

749
00:42:39,493 --> 0:42:41,962
多个正在执行彼此相关的代码的线程

750
00:42:42,262 --> 0:42:44,531
所以如果某个特定的类或方法

751
00:42:44,765 --> 0:42:47,201
出现在多个线程的崩溃日志中

752
00:42:47,601 --> 0:42:50,470
这表示可能存在多线程错误

753
00:42:51,438 --> 0:42:55,042
多线程问题导致的内存损坏

754
00:42:55,108 --> 0:42:56,443
通常非常随机

755
00:42:56,543 --> 0:43:00,981
因此你可能会发现崩溃发生在

756
00:42:56,543 --> 0:43:00,981
因此你可能会发现崩溃发生在

757
00:43:01,048 --> 0:43:02,683
或稍微不同的地址

758
00:43:02,749 --> 0:43:04,051
正如Greg所说

759
00:43:04,117 --> 0:43:09,323
你可以看到它们在Xcode中

760
00:43:09,389 --> 0:43:11,058
尽管它们属于同一个漏洞

761
00:43:11,925 --> 0:43:15,562
并且崩溃的线程可能并不是

762
00:43:15,629 --> 0:43:18,232
所以查看崩溃日志中其它线程的

763
00:43:18,298 --> 0:43:20,234
堆栈跟踪很重要

764
00:43:20,634 --> 0:43:24,271
现在让我们看一下

765
00:43:24,338 --> 0:43:26,340
并且我会向你展示

766
00:43:26,406 --> 0:43:29,877
通过使用名为Thread Sanitizer的工具

767
00:43:38,852 --> 0:43:42,789
让我们再看看Chris和我写的

768
00:43:42,856 --> 0:43:46,193
这里有从用户那里收到的

769
00:43:46,994 --> 0:43:50,531
我们关注一下排名第二的崩溃

770
00:43:51,999 --> 0:43:54,601
此崩溃日志显示

771
00:43:54,668 --> 0:43:57,638
当我们使用一个名为LazyImageView的类时

772
00:43:57,704 --> 0:44:01,141
这是我写的一个类 我们稍后再看它

773
00:43:57,704 --> 0:44:01,141
这是我写的一个类 我们稍后再看它

774
00:44:01,441 --> 0:44:04,244
但我们先看看能否从崩溃日志中

775
00:44:05,279 --> 0:44:07,481
我们看一下这个线程的整个堆栈

776
00:44:07,548 --> 0:44:09,816
我可以通过点击这个按钮来做到这点

777
00:44:09,883 --> 0:44:11,652
它也会显示所有其他线程

778
00:44:12,920 --> 0:44:15,589
如果我们注意最顶层的帧

779
00:44:15,923 --> 0:44:17,724
我们会看到真正发生的事情

780
00:44:17,791 --> 0:44:20,327
是free函数

781
00:44:20,694 --> 0:44:23,597
这表示堆损坏 它是一种内存错误

782
00:44:25,265 --> 0:44:27,467
如果我们查看其它线程的堆栈跟踪

783
00:44:27,534 --> 0:44:28,836
比如这里的第5个线程

784
00:44:29,603 --> 0:44:33,240
我们会看到它还在LazyImageView中

785
00:44:35,075 --> 0:44:37,778
我们来看看这组崩溃中的另一次崩溃

786
00:44:39,179 --> 0:44:42,249
我们会发现所有这些崩溃日志

787
00:44:42,316 --> 0:44:46,587
当free函数调用abort时

788
00:44:47,254 --> 0:44:52,593
而另一个线程正在处理

789
00:44:52,659 --> 0:44:55,462
实际上是在同一个类中

790
00:44:55,929 --> 0:44:57,898
这很可能不是巧合

791
00:44:58,098 --> 0:45:00,767
我非常怀疑这是一个多线程问题

792
00:44:58,098 --> 0:45:00,767
我非常怀疑这是一个多线程问题

793
00:45:02,002 --> 0:45:05,105
所以我们来看看

794
00:45:05,172 --> 0:45:07,608
我点击此按钮

795
00:45:07,941 --> 0:45:10,511
来在我们的项目中打开它

796
00:45:11,778 --> 0:45:14,815
你可以在这里看到

797
00:45:15,249 --> 0:45:18,986
它是UIImageView的子类

798
00:45:19,052 --> 0:45:22,122
即它可以惰性地并且异步地加载图像

799
00:45:22,689 --> 0:45:25,692
我们可以看下初始化函数的逻辑

800
00:45:25,759 --> 0:45:29,196
我们所做的是将作业分配到后台队列

801
00:45:29,730 --> 0:45:32,366
我们将在后台线程上创建图像

802
00:45:32,766 --> 0:45:35,936
一旦完成 我们将调度回主队列

803
00:45:36,336 --> 0:45:38,472
来在屏幕上实际显示图像

804
00:45:39,406 --> 0:45:41,975
崩溃日志指向这行代码

805
00:45:42,509 --> 0:45:45,445
我们这里正在访问

806
00:45:45,646 --> 0:45:49,149
我们使用它来确保

807
00:45:49,283 --> 0:45:50,817
相同的图像

808
00:45:51,251 --> 0:45:54,488
所以我的缓存实现方式可能存在漏洞

809
00:45:54,788 --> 0:45:58,759
让我们试着避免猜测

810
00:45:58,825 --> 0:46:00,494
并尝试重现此崩溃

811
00:45:58,825 --> 0:46:00,494
并尝试重现此崩溃

812
00:46:00,928 --> 0:46:03,096
让我先关闭崩溃日志会话

813
00:46:04,798 --> 0:46:06,967
好的 这是我们的饼干配方app

814
00:46:07,034 --> 0:46:10,304
你会注意到 如果我尝试

815
00:46:10,370 --> 0:46:12,272
来添加新食谱

816
00:46:13,073 --> 0:46:16,543
我们将需要为我们的新食谱

817
00:46:17,211 --> 0:46:19,847
现在屏幕上的这个控制器

818
00:46:20,147 --> 0:46:23,050
使用LazyImageView

819
00:46:23,784 --> 0:46:27,554
因此只是在屏幕上显示它们

820
00:46:27,621 --> 0:46:31,291
就已经运行了

821
00:46:31,425 --> 0:46:32,926
但我没有看到任何崩溃

822
00:46:33,460 --> 0:46:36,463
不幸的是

823
00:46:36,930 --> 0:46:38,532
众所周知 它们难以重现

824
00:46:38,599 --> 0:46:42,769
所以即使你反复测试

825
00:46:42,836 --> 0:46:44,571
你可能也无法看到一次崩溃

826
00:46:45,272 --> 0:46:46,440
让我们试着这样做

827
00:46:46,507 --> 0:46:50,410
我们多次尝试关闭并打开此控制器

828
00:46:50,477 --> 0:46:53,146
并看看我们最终是否会

829
00:46:53,213 --> 0:46:55,449
幸运的触发此崩溃

830
00:47:00,487 --> 0:47:01,588
果然如此

831
00:47:01,755 --> 0:47:05,025
调试器已终止app

832
00:47:05,225 --> 0:47:08,262
但即使你的确在调试器中

833
00:47:08,328 --> 0:47:09,596
这也并没有什么用

834
00:47:10,163 --> 0:47:11,331
调试器所提供的信息

835
00:47:11,398 --> 0:47:14,168
只是说存在某种

836
00:47:14,501 --> 0:47:16,970
但它没有解释导致崩溃的原因

837
00:47:17,037 --> 0:47:19,039
或者这为什么会发生

838
00:47:19,640 --> 0:47:23,243
幸运的是 Xcode中有一个

839
00:47:23,310 --> 0:47:26,547
它被称为Thread Sanitizer

840
00:47:26,613 --> 0:47:28,849
让我们打开项目的方案编辑器

841
00:47:28,916 --> 0:47:31,084
我点击此处的app名称

842
00:47:31,151 --> 0:47:32,553
来做到这点

843
00:47:33,854 --> 0:47:36,957
然后我切换到

844
00:47:37,357 --> 0:47:41,094
你会看到我们这里有

845
00:47:41,161 --> 0:47:44,464
比如Address Sanitizer

846
00:47:45,399 --> 0:47:48,936
让我选中Thread Sanitizer

847
00:47:49,002 --> 0:47:53,006
这意味着每次Sanitizer

848
00:47:54,541 --> 0:47:57,811
让我们在启用了Thread Sanitizer的

849
00:47:57,878 --> 0:48:00,981
我们看看如果我尝试

850
00:47:57,878 --> 0:48:00,981
我们看看如果我尝试

851
00:48:03,483 --> 0:48:07,454
如果我现在点击“+”按钮

852
00:48:07,521 --> 0:48:09,489
因为Thread Sanitizer

853
00:48:09,556 --> 0:48:12,259
请注意 我没有进行多次尝试

854
00:48:12,526 --> 0:48:16,230
Thread Sanitizer

855
00:48:17,464 --> 0:48:19,633
让我们看一下这个漏洞的一些细节

856
00:48:19,967 --> 0:48:22,469
我们看到它是一个

857
00:48:23,437 --> 0:48:26,673
如果我们查看左侧的调试导航器

858
00:48:26,740 --> 0:48:29,076
我们甚至可以得到

859
00:48:29,409 --> 0:48:33,480
我们看到两个不同的线程

860
00:48:33,547 --> 0:48:37,551
这里是线程2和线程4

861
00:48:37,618 --> 0:48:39,887
同时访问同一个内存位置

862
00:48:40,020 --> 0:48:41,221
这是不允许的

863
00:48:42,756 --> 0:48:46,927
如果我们查看正在构成竞争的

864
00:48:47,261 --> 0:48:50,531
我们发现它们都在访问

865
00:48:51,298 --> 0:48:55,369
由于这是一个在多个线程之间

866
00:48:55,435 --> 0:48:58,138
就像我们在此看到的一样

867
00:48:58,872 --> 0:49:00,607
我们来看看它是如何实现的

868
00:48:58,872 --> 0:49:00,607
我们来看看它是如何实现的

869
00:49:00,674 --> 0:49:03,210
让我们跳到这里的storage

870
00:49:03,277 --> 0:49:05,345
让我们看看它是否真的是线程安全的

871
00:49:06,313 --> 0:49:10,217
这是ImageCache的源码

872
00:49:10,284 --> 0:49:12,519
我们可以立即发现错误

873
00:49:12,586 --> 0:49:16,290
这只是一个普通的Swift字典

874
00:49:16,356 --> 0:49:19,159
Swift字典默认不是线程安全的

875
00:49:19,526 --> 0:49:23,730
所以如果我们想在多个线程之间

876
00:49:24,398 --> 0:49:26,834
我们必须使用同步来保护它

877
00:49:27,234 --> 0:49:28,635
这意味着我们必须确保

878
00:49:28,702 --> 0:49:31,004
一次只能有一个线程访问它

879
00:49:31,805 --> 0:49:34,107
现在让我们真正解决这个问题

880
00:49:34,174 --> 0:49:35,776
从而使该类成为线程安全的类

881
00:49:36,543 --> 0:49:37,978
我将分两步完成

882
00:49:38,045 --> 0:49:41,615
首先我将稍微重构一下这段代码

883
00:49:42,015 --> 0:49:44,251
以便我们可以更好地

884
00:49:44,318 --> 0:49:46,954
然后在第二步中

885
00:49:47,020 --> 0:49:48,922
来使这个类线程安全

886
00:49:50,324 --> 0:49:52,492
首先我不喜欢的是

887
00:49:52,559 --> 0:49:54,928
storage被声明为公有变量

888
00:49:55,295 --> 0:49:59,166
这意味着我的app中的任何代码

889
00:49:59,466 --> 0:50:01,301
而且很难确保

890
00:49:59,466 --> 0:50:01,301
而且很难确保

891
00:50:01,368 --> 0:50:03,737
app中的所有代码

892
00:50:04,238 --> 0:50:06,673
所以让我们将其改为私有

893
00:50:07,140 --> 0:50:11,111
我还要引入另一种

894
00:50:11,512 --> 0:50:13,914
我将通过引入subscript

895
00:50:15,048 --> 0:50:16,984
这意味着

896
00:50:17,050 --> 0:50:20,220
可以使用括号

897
00:50:21,421 --> 0:50:27,094
创建下标需一个这样的getter

898
00:50:28,328 --> 0:50:30,197
现在暂时让我们通过

899
00:50:30,264 --> 0:50:32,900
直接访问底层存储来实现它

900
00:50:34,501 --> 0:50:37,471
为了让这个文件的其它部分

901
00:50:37,538 --> 0:50:38,839
我还需要更新其用户

902
00:50:38,906 --> 0:50:41,942
这里不能再直接访问

903
00:50:42,009 --> 0:50:43,477
我们该在imageCache上

904
00:50:43,544 --> 0:50:45,779
直接使用括号和索引

905
00:50:47,381 --> 0:50:49,249
如果我点击“Build Now”

906
00:50:49,583 --> 0:50:52,319
你会看到代码现在能够正常编译

907
00:50:52,386 --> 0:50:54,421
但我目前还没有修复任何漏洞

908
00:50:54,888 --> 0:50:56,423
但我确实取得了一些成就

909
00:50:56,490 --> 0:51:00,961
我现在可以直接控制

910
00:50:56,490 --> 0:51:00,961
我现在可以直接控制

911
00:51:01,028 --> 0:51:04,131
即要么通过getter中的代码

912
00:51:04,198 --> 0:51:06,333
我的app中没其他代码可以访问它

913
00:51:06,533 --> 0:51:10,437
因此这对我实际修复

914
00:51:11,805 --> 0:51:13,941
让我通过使用调度队列来做到这一点

915
00:51:14,007 --> 0:51:17,244
我们创建一个名为queue的

916
00:51:17,311 --> 0:51:20,080
并让我们为其分配一个新的调度队列

917
00:51:21,215 --> 0:51:24,852
调度队列默认是串行的

918
00:51:24,918 --> 0:51:27,921
这意味着在该队列中

919
00:51:27,988 --> 0:51:30,724
一次只允许一段代码执行

920
00:51:31,725 --> 0:51:33,927
这很完美

921
00:51:34,528 --> 0:51:37,397
我们如何在调度队列中执行代码呢？

922
00:51:37,698 --> 0:51:43,003
我们可以使用queue.sync

923
00:51:44,771 --> 0:51:48,141
都将在该串行队列中执行

924
00:51:48,575 --> 0:51:50,244
我可以在这里返回一个值

925
00:51:50,310 --> 0:51:52,479
因为我需要从getter中

926
00:51:53,380 --> 0:51:56,116
我也可以在setter中

927
00:51:57,417 --> 0:52:00,854
如果我将这行代码移到

928
00:51:57,417 --> 0:52:00,854
如果我将这行代码移到

929
00:52:00,921 --> 0:52:03,390
它将作为该调度队列的一部分执行

930
00:52:04,291 --> 0:52:06,627
通过这种方式

931
00:52:06,693 --> 0:52:09,997
因为访问storage的

932
00:52:10,330 --> 0:52:13,433
都将在串行调度队列中执行

933
00:52:13,500 --> 0:52:16,303
这意味着它一次只能执行一个

934
00:52:16,370 --> 0:52:17,905
而这对线程安全来说是正确的

935
00:52:18,272 --> 0:52:22,242
现在你可能很想

936
00:52:22,309 --> 0:52:25,445
仅在更改storage变量的

937
00:52:25,512 --> 0:52:27,548
并在getter中避免使用它

938
00:52:28,448 --> 0:52:29,449
但这并不正确

939
00:52:29,516 --> 0:52:32,452
这仍然可能导致内存损坏

940
00:52:32,519 --> 0:52:34,121
我通过在模拟器中运行

941
00:52:34,354 --> 0:52:37,157
此版本的代码来向你证明这一点

942
00:52:37,291 --> 0:52:40,827
让我们看看Sanitizer

943
00:52:43,530 --> 0:52:45,065
如我所料 它的确发现了

944
00:52:45,132 --> 0:52:48,468
我们必须使用同步

945
00:52:48,769 --> 0:52:49,870
同时保护

946
00:52:49,937 --> 0:52:53,273
让我最后一次

947
00:52:53,340 --> 0:52:56,577
你会看到如果我这次尝试添加新配方

948
00:52:56,977 --> 0:53:00,113
控制器加载正常

949
00:52:56,977 --> 0:53:00,113
控制器加载正常

950
00:53:00,180 --> 0:53:02,382
因为该类现在是线程安全的

951
00:53:02,749 --> 0:53:05,452
现在我可以回到

952
00:53:05,519 --> 0:53:08,322
并将此崩溃标记为已解决

953
00:53:08,388 --> 0:53:11,391
因为我们已经找到和

954
00:53:21,235 --> 0:53:23,637
我们刚看到的是

955
00:53:23,704 --> 0:53:26,840
我从一组具有多线程错误症状的

956
00:53:26,907 --> 0:53:29,009
崩溃日志开始

957
00:53:29,376 --> 0:53:31,912
然后我使用这个

958
00:53:31,979 --> 0:53:34,448
来识别并最终修复此漏洞

959
00:53:35,516 --> 0:53:38,318
Thread Sanitizer

960
00:53:38,385 --> 0:53:41,622
还可以使它们更可靠地重现

961
00:53:42,189 --> 0:53:46,260
请注意 在演示中

962
00:53:47,227 --> 0:53:50,163
该工具适用于macOS和模拟器

963
00:53:50,998 --> 0:53:53,367
但就像所有其他运行时诊断工具一样

964
00:53:53,433 --> 0:53:57,905
它只能通过实际运行代码

965
00:53:58,405 --> 0:54:00,707
因此你应该牢记这一点并确保

966
00:53:58,405 --> 0:54:00,707
因此你应该牢记这一点并确保

967
00:54:00,774 --> 0:54:04,545
你的自动或手动测试程序使用了

968
00:54:04,611 --> 0:54:07,714
特别是在使用线程或GCD的代码上

969
00:54:09,249 --> 0:54:10,617
如果你想了解更多

970
00:54:10,684 --> 0:54:14,855
我建议你观看我在2016年

971
00:54:15,122 --> 0:54:17,591
其标题为

972
00:54:17,658 --> 0:54:19,560
我们在其中介绍了这个工具

973
00:54:19,626 --> 0:54:22,496
并谈到了它的工作原理

974
00:54:23,830 --> 0:54:27,201
提醒一下 Thread Sanitizer

975
00:54:27,668 --> 0:54:30,871
你可以点击Product-&gt;

976
00:54:31,371 --> 0:54:32,906
来调出方案编辑器

977
00:54:32,973 --> 0:54:35,576
然后你可以切换到

978
00:54:35,642 --> 0:54:39,980
你可以从中找到Thread Sanitizer

979
00:54:41,815 --> 0:54:44,484
我还想与你分享一个调试技巧

980
00:54:44,551 --> 0:54:46,987
它在处理多线程时很有用

981
00:54:47,955 --> 0:54:50,157
在创建调度队列时

982
00:54:50,557 --> 0:54:53,227
你可以在初始化函数中

983
00:54:54,494 --> 0:54:57,364
你可以为操作队列指定自定义名称

984
00:54:58,131 --> 0:54:59,566
并且如果你正在使用线程

985
00:54:59,633 --> 0:55:01,869
你也可以在线程中使用自定义名称

986
00:54:59,633 --> 0:55:01,869
你也可以在线程中使用自定义名称

987
00:55:03,036 --> 0:55:05,405
这些名称和标签将显示在调试器中

988
00:55:05,472 --> 0:55:08,342
但它们也出现在

989
00:55:08,809 --> 0:55:12,880
这可以帮助你缩小

990
00:55:15,482 --> 0:55:19,786
对于崩溃 我这里准备了三个要点

991
00:55:20,487 --> 0:55:24,858
第一 在将你的app

992
00:55:24,925 --> 0:55:26,960
总是在真实设备上对其进行测试

993
00:55:27,227 --> 0:55:30,497
这可以帮助你避免

994
00:55:31,698 --> 0:55:35,135
第二 当你的用户崩溃时

995
00:55:35,202 --> 0:55:37,271
你应该总是尝试重现它们

996
00:55:37,437 --> 0:55:39,773
查看崩溃日志和堆栈跟踪

997
00:55:39,840 --> 0:55:42,009
并尝试找出你需要执行

998
00:55:42,075 --> 0:55:44,711
app中的哪些部分

999
00:55:44,778 --> 0:55:46,613
或尝试重现崩溃

1000
00:55:46,680 --> 0:55:50,417
最后 对于难以重现的崩溃

1001
00:55:50,717 --> 0:55:52,719
我建议使用漏洞查找工具

1002
00:55:52,786 --> 0:55:55,355
比如Address Sanitizer

1003
00:55:55,856 --> 0:55:58,392
它们分别可用于处理

1004
00:55:58,458 --> 0:55:59,893
和多线程问题

1005
00:56:02,095 --> 0:56:04,698
现在让我们回顾一下

1006
00:56:05,699 --> 0:56:06,900
Chris向我们展示了

1007
00:56:06,967 --> 0:56:09,937
如何使用Xcode中的

1008
00:56:10,370 --> 0:56:13,273
来获取统计信息

1009
00:56:14,274 --> 0:56:18,011
Greg向我们展示了

1010
00:56:18,712 --> 0:56:20,414
在许多情况下 它们可以被重现

1011
00:56:20,480 --> 0:56:23,183
比如当你处理

1012
00:56:24,651 --> 0:56:27,688
然后我们提到了难以重现的崩溃

1013
00:56:27,754 --> 0:56:30,324
因为它们是随机发生的

1014
00:56:30,390 --> 0:56:34,061
我们还提到了它们

1015
00:56:34,728 --> 0:56:37,097
最后 我展示了漏洞寻找工具

1016
00:56:37,164 --> 0:56:38,432
比如Sanitizer

1017
00:56:38,498 --> 0:56:40,334
如何帮助你重现

1018
00:56:40,400 --> 0:56:42,870
内存损坏和线程问题

1019
00:56:42,936 --> 0:56:45,205
我建议你也使用这些工具

1020
00:56:46,373 --> 0:56:49,376
如需了解更多信息

1021
00:56:49,443 --> 0:56:52,412
其中还将包含我们提到的

1022
00:56:52,479 --> 0:56:55,015
以及提供调试技巧的其他文档

1023
00:56:55,082 --> 0:56:57,351
它们在处理崩溃时很有帮助

1024
00:56:57,417 --> 0:57:00,120
我还想提醒你

1025
00:56:57,417 --> 0:57:00,120
我还想提醒你

1026
00:57:00,187 --> 0:57:03,957
就在本场演讲结束后

1027
00:57:04,024 --> 0:57:06,026
所以如果你有任何

1028
00:57:06,093 --> 0:57:07,494
请到实验室与我们讨论

1029
00:57:07,561 --> 0:57:10,731
请享受WWDC的其余部分
