1
00:00:17,484 --> 0:00:21,822
（在SwiftShot内

2
00:00:21,889 --> 0:00:23,123
（演讲605）

3
00:00:29,530 --> 0:00:33,233
大家好 我是Alex 我是

4
00:00:33,300 --> 0:00:36,403
通常我们会做一些有意思的东西

5
00:00:36,803 --> 0:00:38,739
但今年我们做了一些不同的东西

6
00:00:38,972 --> 0:00:40,641
我们创建了一个叫做

7
00:00:41,041 --> 0:00:45,179
有些人可能在今天早些时候见过它了

8
00:00:46,213 --> 0:00:48,849
但重要的部分是SwiftShot

9
00:00:48,916 --> 0:00:52,352
是ARKit中一些新功能的

10
00:00:53,053 --> 0:00:56,990
ARKit 2现在可在

11
00:00:57,558 --> 0:01:00,727
提供了一个增强AR体验的平台

12
00:00:57,558 --> 0:01:00,727
提供了一个增强AR体验的平台

13
00:01:01,161 --> 0:01:04,197
你可以通过它实现尽可能多的观众

14
00:01:04,864 --> 0:01:06,033
并没有什么特别的设置

15
00:01:06,533 --> 0:01:10,003
只是把设备的摄像头指向

16
00:01:12,072 --> 0:01:13,841
它已经集成到iOS中

17
00:01:14,875 --> 0:01:17,945
第一方和第三方引擎 比如

18
00:01:18,278 --> 0:01:21,481
以及第三方

19
00:01:22,115 --> 0:01:23,884
在这点上都是完全集成

20
00:01:28,689 --> 0:01:29,756
这是一个演讲概述

21
00:01:30,123 --> 0:01:32,492
首先我们要讲一些游戏设计原则

22
00:01:32,559 --> 0:01:35,762
针对增强现实

23
00:01:36,864 --> 0:01:40,601
我们要深入到内部 特别是

24
00:01:40,667 --> 0:01:43,837
要讲到WorldMap分享

25
00:01:44,505 --> 0:01:47,875
我们还要讲网络和物理

26
00:01:49,109 --> 0:01:52,145
首先让我们 你知道的

27
00:02:25,879 --> 0:02:30,918
（胜利！）

28
00:02:31,685 --> 0:02:32,519
好的

29
00:02:34,488 --> 0:02:37,724
让我们稍微讲一下

30
00:02:40,460 --> 0:02:43,163
游戏设置高于一切

31
00:02:45,032 --> 0:02:46,900
你该问自己

32
00:02:46,967 --> 0:02:51,939
如果它只是70年代的图形

33
00:02:52,005 --> 0:02:55,475
这个游戏会有意思和令人兴奋吗？

34
00:02:56,343 --> 0:02:59,513
值得用那种插图来设计原型

35
00:03:00,180 --> 0:03:02,082
搞定游戏设置

36
00:03:02,149 --> 0:03:04,551
因为如果那些无聊的灰色方框

37
00:03:04,852 --> 0:03:07,454
那么当你稍后添加这些图形

38
00:03:08,922 --> 0:03:10,724
你应该花点时间改良一下

39
00:03:10,791 --> 0:03:14,928
不要说服你自己说

40
00:03:14,995 --> 0:03:17,798
或者哪一个功能

41
00:03:18,465 --> 0:03:20,734
因为你知道的有许多被遗弃的游戏

42
00:03:20,801 --> 0:03:22,803
从一开始就一点儿意思都没有

43
00:03:22,870 --> 0:03:24,938
因此请不要尝试愚弄你自己

44
00:03:27,040 --> 0:03:28,242
让我们从游戏设置开始

45
00:03:31,445 --> 0:03:32,613
保持游戏简短

46
00:03:34,014 --> 0:03:36,650
你正在寻找一个典型的移动设备体验

47
00:03:37,284 --> 0:03:38,552
轻松进入 轻松退出

48
00:03:41,455 --> 0:03:46,293
你想保留各种各样的内容

49
00:03:46,360 --> 0:03:49,196
就游戏玩家而言

50
00:03:52,332 --> 0:03:54,701
我们所了解到的其中一件事就是

51
00:03:54,768 --> 0:03:56,203
跟玩游戏一样有意思

52
00:03:56,503 --> 0:03:59,106
坐在场外并观看游戏

53
00:03:59,173 --> 0:04:00,340
从这边到那边

54
00:03:59,173 --> 0:04:00,340
从这边到那边

55
00:04:00,974 --> 0:04:03,510
那就是一种很愉悦的体验

56
00:04:03,977 --> 0:04:04,978
你们需要思考这一点

57
00:04:07,814 --> 0:04:10,717
游戏是社交和私人互动的关键形式

58
00:04:12,619 --> 0:04:16,055
增强现实可以提供一种私人触碰

59
00:04:16,490 --> 0:04:19,793
你以前可能有过这种感觉

60
00:04:19,860 --> 0:04:21,562
和家里的长辈一起围在桌子旁边

61
00:04:22,029 --> 0:04:25,666
但现在有一种技术

62
00:04:29,036 --> 0:04:33,707
做一个3D游戏并把它放在

63
00:04:34,374 --> 0:04:37,077
通过增强现实

64
00:04:37,644 --> 0:04:40,514
你还对用户的环境有了一些了解

65
00:04:40,881 --> 0:04:43,116
你应该尝试在游戏中利用这一点

66
00:04:43,183 --> 0:04:46,620
并营造一种

67
00:04:52,192 --> 0:04:56,163
你的设备可以用作一个摄像头

68
00:04:57,064 --> 0:04:59,600
在本例中 这是一个3D解谜游戏

69
00:04:59,666 --> 0:05:02,135
我们想修复一个坏掉的花瓶

70
00:04:59,666 --> 0:05:02,135
我们想修复一个坏掉的花瓶

71
00:05:02,202 --> 0:05:03,370
我们可以四处查看

72
00:05:03,670 --> 0:05:06,607
了解哪个碎片在哪里

73
00:05:07,574 --> 0:05:09,676
在SwiftShot中

74
00:05:10,010 --> 0:05:13,380
重点是你正在玩游戏的桌子

75
00:05:13,947 --> 0:05:17,384
但桌子并不只是用于

76
00:05:17,451 --> 0:05:18,952
它是游戏设置不可分割的部分

77
00:05:19,920 --> 0:05:23,891
桌子的高度实际上很重要

78
00:05:23,957 --> 0:05:26,994
因此你会在游戏中

79
00:05:27,060 --> 0:05:31,465
在砖堆顶部

80
00:05:31,532 --> 0:05:34,735
或稍微利用一下玩家的闪避和穿梭

81
00:05:37,771 --> 0:05:41,408
另一个原则是你的设备即是

82
00:05:43,343 --> 0:05:44,211
在本例中

83
00:05:46,246 --> 0:05:48,115
我们要寻找藏在荒野中的独角兽

84
00:05:48,348 --> 0:05:50,817
并且我们会给它们拍照片

85
00:05:53,387 --> 0:05:55,622
它们就在你周围而非里面

86
00:06:00,060 --> 0:06:02,729
设备还可以是

87
00:06:02,963 --> 0:06:05,332
你不需要直接看摄像机所看到的东西

88
00:06:06,333 --> 0:06:08,168
可以彻底替换你所处的环境

89
00:06:08,535 --> 0:06:11,538
可能会打破或完全修改物理定律

90
00:06:12,272 --> 0:06:13,740
无论你需做什么

91
00:06:14,208 --> 0:06:16,977
在本例中 我们可以看到星星

92
00:06:21,381 --> 0:06:23,450
同时 你的设备自身就可以是控制器

93
00:06:26,019 --> 0:06:28,355
你可以让自己融合到虚拟世界中

94
00:06:29,022 --> 0:06:30,591
把设备作为控制器

95
00:06:30,858 --> 0:06:34,494
在这个例子中 我们用磁力拿起砖头

96
00:06:34,561 --> 0:06:35,896
并把它们放在立方体中

97
00:06:36,663 --> 0:06:38,632
这就是SwiftShot中

98
00:06:39,766 --> 0:06:42,102
你想鼓励设备进行缓慢的移动

99
00:06:42,903 --> 0:06:45,606
那就会给相机提供最佳图像

100
00:06:45,672 --> 0:06:47,274
然后就能在追踪时做到最好

101
00:06:48,709 --> 0:06:51,211
不管这些设备有多么细、多么轻

102
00:06:51,879 --> 0:06:54,681
用手臂的力量四处摇晃它们

103
00:06:54,748 --> 0:06:56,917
因此你要寻找慢并且从容的动作

104
00:06:59,786 --> 0:07:02,089
你想鼓励玩家在场地四周移动

105
00:06:59,786 --> 0:07:02,089
你想鼓励玩家在场地四周移动

106
00:07:02,623 --> 0:07:05,526
在本例中 我们对敌人的弹弓射击

107
00:07:05,592 --> 0:07:07,394
被那些砖块阻碍了

108
00:07:07,995 --> 0:07:10,397
所以我们要移动到另一个弹弓处

109
00:07:10,631 --> 0:07:11,865
清除障碍

110
00:07:19,339 --> 0:07:21,275
控制反馈对于沉浸式体验来说很重要

111
00:07:22,943 --> 0:07:26,613
在SwiftShot中

112
00:07:27,548 --> 0:07:31,818
有各种各样的动态行为

113
00:07:32,452 --> 0:07:36,957
和触觉效果

114
00:07:37,391 --> 0:07:40,127
我们稍后再具体讲动态音频

115
00:07:43,263 --> 0:07:45,832
接下来我要邀请

116
00:07:45,899 --> 0:07:48,235
他会深入讲解SwiftShot

117
00:07:50,237 --> 0:07:51,071
David？

118
00:07:54,074 --> 0:07:55,542
谢谢Alex 大家好

119
00:07:56,977 --> 0:08:00,347
我只是想重复一下

120
00:07:56,977 --> 0:08:00,347
我只是想重复一下

121
00:08:00,414 --> 0:08:02,983
我们从参加SwiftShot演讲的人那儿

122
00:08:03,050 --> 0:08:06,386
我们看到有些人已经下载它

123
00:08:06,453 --> 0:08:08,488
创建它和用示例代码替换它

124
00:08:08,555 --> 0:08:10,991
那么谢谢大家 我们真的非常激动

125
00:08:11,925 --> 0:08:15,162
我首先想要谈谈

126
00:08:15,229 --> 0:08:16,230
用于创建SwiftShot的技术

127
00:08:17,064 --> 0:08:18,799
第一个也是最重要的一个

128
00:08:19,132 --> 0:08:21,869
可以让我们把内容

129
00:08:21,935 --> 0:08:24,571
让他们沉浸到游戏体验中

130
00:08:26,640 --> 0:08:31,612
我们用SceneKit来管理

131
00:08:31,678 --> 0:08:33,580
和现实物理来实现有趣的游戏设置

132
00:08:35,148 --> 0:08:39,586
Metal可以让我们更好地利用

133
00:08:39,653 --> 0:08:43,924
它在SceneKit内

134
00:08:43,991 --> 0:08:47,361
也用于旗子模拟 我稍后会讲到

135
00:08:48,829 --> 0:08:51,465
GameplayKit

136
00:08:51,865 --> 0:08:52,699
提供了组件架构实体

137
00:08:52,766 --> 0:08:55,869
它让我们在游戏的对象之间

138
00:08:57,671 --> 0:09:00,541
多点连通提供了网络层

139
00:08:57,671 --> 0:09:00,541
多点连通提供了网络层

140
00:09:01,208 --> 0:09:04,144
包括发现周围的设备和同步

141
00:09:04,711 --> 0:09:06,113
以及加密

142
00:09:07,581 --> 0:09:10,684
AV Foundation

143
00:09:10,751 --> 0:09:13,020
又给设备提供声音效果

144
00:09:13,086 --> 0:09:15,022
真的给你营造了那种沉浸式体验

145
00:09:16,089 --> 0:09:18,959
最后我们在Swift中

146
00:09:19,393 --> 0:09:22,329
Swift的键入安全性、性能

147
00:09:24,031 --> 0:09:26,466
和高级功能 比如协议扩展

148
00:09:26,533 --> 0:09:28,235
可以让我们更多地关注游戏设置

149
00:09:28,302 --> 0:09:29,903
不那么担心崩溃

150
00:09:29,970 --> 0:09:32,239
和代码层之间的界面不匹配

151
00:09:35,309 --> 0:09:37,177
那就是我们所使用的iOS技术

152
00:09:37,578 --> 0:09:38,946
谈谈我们如何使用这些技术

153
00:09:39,012 --> 0:09:41,348
帮助我们实施游戏中的某些功能

154
00:09:41,782 --> 0:09:44,051
建立共享坐标空间、

155
00:09:44,751 --> 0:09:48,922
网络、物理、资产重要性和管理

156
00:09:49,756 --> 0:09:52,125
旗子模拟和动态音频

157
00:09:55,162 --> 0:09:58,098
我们要从设置共享坐标空间开始讲

158
00:09:59,466 --> 0:10:02,569
游戏体验的关键因素是让玩家

159
00:09:59,466 --> 0:10:02,569
游戏体验的关键因素是让玩家

160
00:10:02,636 --> 0:10:04,471
在各自的设备上

161
00:10:04,838 --> 0:10:07,374
为此我们需要一个共享坐标空间

162
00:10:07,975 --> 0:10:11,445
允许他们以跟现实世界中

163
00:10:13,647 --> 0:10:16,750
ARKit提供了一系列

164
00:10:17,384 --> 0:10:20,854
在iOS 11.3中

165
00:10:20,921 --> 0:10:23,423
允许你的app识别你周围的图像

166
00:10:24,758 --> 0:10:28,262
现在在iOS 12中

167
00:10:28,529 --> 0:10:31,031
对象检测和世界地图共享

168
00:10:32,332 --> 0:10:34,768
图像检测和对象检测

169
00:10:34,835 --> 0:10:37,871
都可以让你针对用户在现实世界中

170
00:10:37,938 --> 0:10:41,208
但它们要求你必须对这些对象

171
00:10:41,675 --> 0:10:43,777
你可在Lego演示的演讲稿中看到

172
00:10:43,844 --> 0:10:46,046
识别建造模型和添加内容

173
00:10:48,015 --> 0:10:50,851
对于这款游戏 我们想让用户

174
00:10:50,918 --> 0:10:52,853
比如咖啡馆、他们的厨房等等

175
00:10:53,120 --> 0:10:54,588
我们的实现方式是

176
00:10:55,689 --> 0:10:58,492
你还可以在游戏以外的app中

177
00:10:58,559 --> 0:11:01,728
比如在零售环境

178
00:10:58,559 --> 0:11:01,728
比如在零售环境

179
00:11:02,763 --> 0:11:06,400
楼下游戏室内 我们用了

180
00:11:06,466 --> 0:11:11,772
它们相邻的桌子是哪个并为该区域

181
00:11:12,272 --> 0:11:14,007
那真的会让体验变得很魔幻

182
00:11:16,577 --> 0:11:17,911
SwiftShot的一个特性

183
00:11:17,978 --> 0:11:19,746
你可能用过

184
00:11:19,813 --> 0:11:24,451
即允许玩家把游戏板

185
00:11:24,885 --> 0:11:27,354
在楼下的桌子上

186
00:11:27,421 --> 0:11:29,756
但这里有一个例子

187
00:11:29,823 --> 0:11:31,425
并把它放在虚拟世界中

188
00:11:33,894 --> 0:11:35,028
这是如何创建

189
00:11:36,029 --> 0:11:38,799
正如你在视频中所看到的

190
00:11:38,866 --> 0:11:40,934
让ARKit创建该区域的地图

191
00:11:42,603 --> 0:11:44,872
然后你可以把那个地图序列化为数据

192
00:11:44,938 --> 0:11:46,507
并把它转换到另一台设备上

193
00:11:47,975 --> 0:11:51,178
目标设备就会把地图加载到

194
00:11:51,245 --> 0:11:52,880
来识别同一个表面

195
00:11:53,247 --> 0:11:56,416
在那点上

196
00:11:56,483 --> 0:12:00,687
两台设备都可以把游戏板

197
00:11:56,483 --> 0:12:00,687
两台设备都可以把游戏板

198
00:12:02,856 --> 0:12:04,458
实施的第一个步骤

199
00:12:04,525 --> 0:12:07,294
从第一台设备上的

200
00:12:08,161 --> 0:12:12,866
这就是iOS 12在ARSession中

201
00:12:13,367 --> 0:12:15,135
它创建了一个

202
00:12:15,202 --> 0:12:17,771
根据会话当前对你周围世界的了解

203
00:12:18,172 --> 0:12:20,340
然后把它返回到一个异步回调中

204
00:12:20,941 --> 0:12:22,776
然后我们使用

205
00:12:23,677 --> 0:12:25,879
把它序列化为数据对象

206
00:12:26,380 --> 0:12:28,882
然后你可以保存数据

207
00:12:31,585 --> 0:12:33,187
一旦你拥有那个数据对象

208
00:12:33,520 --> 0:12:36,056
然后你要决定如何把它

209
00:12:36,557 --> 0:12:39,026
对于特设游戏

210
00:12:39,459 --> 0:12:41,595
SwiftShot使用

211
00:12:41,662 --> 0:12:43,497
我们会在立刻获得更多细节

212
00:12:44,565 --> 0:12:46,567
当第二胎设备连接到网络会话中时

213
00:12:47,000 --> 0:12:50,370
第一台设备序列化WorldMap

214
00:12:50,838 --> 0:12:52,806
这对于博弈游戏的情况来说很棒

215
00:12:52,873 --> 0:12:56,243
用户在任何拥有一个表面的地方

216
00:12:58,846 --> 0:13:01,615
对于楼下的游戏桌而言

217
00:12:58,846 --> 0:13:01,615
对于楼下的游戏桌而言

218
00:13:01,682 --> 0:13:04,384
我们在设置期间花了一些时间

219
00:13:04,451 --> 0:13:06,520
让大会录制每张桌子的

220
00:13:06,954 --> 0:13:08,322
确保我们从多角度本地化

221
00:13:08,388 --> 0:13:10,591
那个共享坐标空间

222
00:13:11,191 --> 0:13:13,327
每张桌子都有自己的唯一特性

223
00:13:13,393 --> 0:13:16,063
并且灯光和位置都稍微有点不一样

224
00:13:17,030 --> 0:13:19,833
然后我们把文件保存到

225
00:13:20,634 --> 0:13:23,270
因为使用中的设备

226
00:13:23,337 --> 0:13:25,405
我们可以使用移动设备管理

227
00:13:25,472 --> 0:13:30,878
来确保同样的文件

228
00:13:32,546 --> 0:13:36,450
要让方案更加流畅

229
00:13:36,717 --> 0:13:40,721
通过用特定的WorldMap

230
00:13:40,787 --> 0:13:42,890
SwiftShot app

231
00:13:42,956 --> 0:13:44,858
都可自动加载正确的

232
00:13:45,626 --> 0:13:49,463
现在如果你正在创建一个消费者app

233
00:13:49,763 --> 0:13:52,966
像iOS的按需资源一样的东西

234
00:13:53,033 --> 0:13:56,770
或你自己的云共享方案

235
00:13:57,171 --> 0:14:00,474
这将允许你

236
00:13:57,171 --> 0:14:00,474
这将允许你

237
00:14:00,541 --> 0:14:03,477
针对世界上的某个特定的零售位置

238
00:14:04,311 --> 0:14:06,213
这里真的有很多的可能性

239
00:14:06,280 --> 0:14:08,982
可以剪裁用户的体验

240
00:14:12,152 --> 0:14:14,521
那些是获取

241
00:14:14,588 --> 0:14:15,856
从一台设备到另一台设备

242
00:14:16,356 --> 0:14:19,259
让我们谈谈

243
00:14:19,860 --> 0:14:21,995
在本例中 我们使用了

244
00:14:22,496 --> 0:14:27,034
来重新加载WorldMap

245
00:14:28,202 --> 0:14:30,838
然后我们创建了一个

246
00:14:31,171 --> 0:14:34,074
并把WorldMap

247
00:14:34,141 --> 0:14:35,576
按照我们希望的方式设置

248
00:14:36,777 --> 0:14:39,046
最后 我们请求ARSession

249
00:14:39,112 --> 0:14:43,750
运行那个配置

250
00:14:44,918 --> 0:14:48,755
然后目标设备上的ARKit

251
00:14:48,822 --> 0:14:51,592
从原始地图中关联这些功能点

252
00:14:52,659 --> 0:14:53,994
通过它在那看到的那些东西

253
00:14:54,061 --> 0:14:55,562
一旦可以这么做了

254
00:14:55,629 --> 0:14:57,397
你就得到了那个共享坐标空间

255
00:14:57,664 --> 0:15:01,235
两台设备上的000

256
00:14:57,664 --> 0:15:01,235
两台设备上的000

257
00:15:04,137 --> 0:15:06,240
快速提一下WorldMap隐私权

258
00:15:06,807 --> 0:15:08,475
在录制WorldMap的过程中

259
00:15:08,942 --> 0:15:11,311
我们考虑到了你周围世界的特征

260
00:15:11,378 --> 0:15:13,881
对象的物理排列等等

261
00:15:14,982 --> 0:15:17,217
因为它的确包含地理信息

262
00:15:17,284 --> 0:15:20,654
比如经度和纬度 因此

263
00:15:20,721 --> 0:15:22,856
位置允许使用ARKit

264
00:15:23,824 --> 0:15:26,326
它可能包括可识别的私人信息

265
00:15:26,393 --> 0:15:27,828
关于用户所处的环境

266
00:15:28,662 --> 0:15:31,431
因此我们建议你处理

267
00:15:31,498 --> 0:15:34,935
与处理其它

268
00:15:36,136 --> 0:15:39,773
这意味着你要确保你加密了数据

269
00:15:40,541 --> 0:15:42,943
无论是休息时或是当在网络中移动时

270
00:15:43,644 --> 0:15:45,245
你可能还想让用户知道

271
00:15:45,312 --> 0:15:48,081
你是否计划保存

272
00:15:48,148 --> 0:15:52,019
在app的单一会话

273
00:15:53,253 --> 0:15:57,691
在SwiftShot中

274
00:15:58,058 --> 0:16:00,794
在玩家休息时加密数据

275
00:15:58,058 --> 0:16:00,794
在玩家休息时加密数据

276
00:16:01,361 --> 0:16:06,633
我要谈一下

277
00:16:09,236 --> 0:16:13,240
现在除了针对SwiftShot

278
00:16:13,307 --> 0:16:14,508
我们还需告诉另台设备

279
00:16:14,575 --> 0:16:16,910
用户选择在哪里定位游戏板

280
00:16:17,711 --> 0:16:19,346
为此我们使用了

281
00:16:20,280 --> 0:16:22,749
当你创建ARAnchor时

282
00:16:22,816 --> 0:16:25,452
以及位置和旋转信息

283
00:16:25,519 --> 0:16:26,987
作为4 x 4转换

284
00:16:28,722 --> 0:16:32,693
然后ARKit就会在我们生成的

285
00:16:32,759 --> 0:16:36,296
并将其序列化 然后我们就可把那个

286
00:16:36,363 --> 0:16:37,598
另一台设备上

287
00:16:39,499 --> 0:16:40,834
系统ARAnchor类

288
00:16:40,901 --> 0:16:43,871
只有我们所创建的名称和定向

289
00:16:44,171 --> 0:16:46,340
我们可以查询我们感兴趣的锚点

290
00:16:46,406 --> 0:16:47,541
通过名称 在另一方面

291
00:16:48,208 --> 0:16:51,378
对于我们的app来说

292
00:16:51,445 --> 0:16:56,049
针对另一台设备

293
00:16:56,283 --> 0:17:00,287
决定他们是否在 你知道的

294
00:16:56,283 --> 0:17:00,287
决定他们是否在 你知道的

295
00:17:00,354 --> 0:17:03,757
或者他们想把游戏板

296
00:17:06,627 --> 0:17:09,096
我们思考了一下

297
00:17:09,162 --> 0:17:12,266
和WorldMap一起

298
00:17:13,200 --> 0:17:17,171
我们创建了ARAnchor

299
00:17:17,871 --> 0:17:21,040
并把那个信息添加到那个类中

300
00:17:22,175 --> 0:17:25,546
然后我们确保我们实施了

301
00:17:25,945 --> 0:17:28,916
NSCoding所需的类

302
00:17:29,183 --> 0:17:32,819
当对象被序列化时

303
00:17:33,387 --> 0:17:36,590
现在信息被直接包含在

304
00:17:36,790 --> 0:17:38,825
当我们把它迁移到另一台设备上时

305
00:17:39,193 --> 0:17:40,861
这样很简单 也很直截了当

306
00:17:42,095 --> 0:17:44,998
有一件事需要记住

307
00:17:45,465 --> 0:17:51,305
当你用Swift来做这样的子类时

308
00:17:51,672 --> 0:17:52,773
模块的名称

309
00:17:52,840 --> 0:17:55,609
或app的名称会包含在类的名称之中

310
00:17:55,976 --> 0:17:57,244
你要引起注意

311
00:17:57,311 --> 0:18:00,681
如果你计划在不同app之间

312
00:17:57,311 --> 0:18:00,681
如果你计划在不同app之间

313
00:18:01,048 --> 0:18:03,517
NSKeyedArchiver

314
00:18:05,185 --> 0:18:09,056
那么这是WorldMap共享

315
00:18:09,122 --> 0:18:11,992
我们真的期待看到你们大家

316
00:18:14,494 --> 0:18:16,763
接下来让我们谈谈

317
00:18:17,798 --> 0:18:20,701
我们使用了iOS的

318
00:18:20,767 --> 0:18:23,837
自从iOS 7开始就存在于

319
00:18:24,638 --> 0:18:25,806
多点连通性

320
00:18:25,873 --> 0:18:29,276
允许我们在本地网络上设置一个

321
00:18:29,543 --> 0:18:31,812
允许会话中的设备进行通讯

322
00:18:31,879 --> 0:18:33,647
而无需通过专用服务器

323
00:18:34,481 --> 0:18:37,851
现在在我们的app中

324
00:18:38,051 --> 0:18:40,187
但是我们为我们的app所做的事

325
00:18:40,254 --> 0:18:41,688
它并不是协议所固有的

326
00:18:43,023 --> 0:18:46,326
加密和验证内嵌到多点连通性中

327
00:18:46,860 --> 0:18:48,695
在我们的例子中 我们没有使用验证

328
00:18:48,762 --> 0:18:51,465
因为我们想得到非常迅速地

329
00:18:51,532 --> 0:18:53,066
但我们使用了加密

330
00:18:53,767 --> 0:18:57,604
我们发现打开加密真的不会影响性能

331
00:18:57,671 --> 0:19:01,542
无论是在网络数据尺寸还是计算方面

332
00:18:57,671 --> 0:19:01,542
无论是在网络数据尺寸还是计算方面

333
00:19:01,608 --> 0:19:03,277
因此没有什么原因让我们不使用它

334
00:19:05,078 --> 0:19:09,483
多点连通性

335
00:19:10,217 --> 0:19:12,052
我们用它来推广可用的游戏

336
00:19:12,119 --> 0:19:13,854
并允许玩家选择一个游戏加入

337
00:19:15,255 --> 0:19:16,790
这就是我们如何设置会话的

338
00:19:17,524 --> 0:19:18,725
首先在一台设备上

339
00:19:18,792 --> 0:19:22,162
用户决定把自己设置为app的主机

340
00:19:23,330 --> 0:19:26,033
他们可以扫描世界

341
00:19:27,234 --> 0:19:31,538
然后设备就开启一个新会话

342
00:19:31,605 --> 0:19:34,374
并开始在本地网络上

343
00:19:36,109 --> 0:19:39,179
另一台设备上的用户

344
00:19:39,980 --> 0:19:43,817
当他选择了某个游戏时 他的设备

345
00:19:45,552 --> 0:19:47,888
一旦第一台设备接受请求

346
00:19:47,955 --> 0:19:50,657
多点连通性就设置一个

347
00:19:51,058 --> 0:19:52,993
网络中的任何设备

348
00:19:53,060 --> 0:19:55,229
都可以向网络中的任意设备发送信息

349
00:19:55,929 --> 0:19:59,499
在SwiftShot中

350
00:19:59,566 --> 0:20:01,468
作为游戏状态的事实来源

351
00:19:59,566 --> 0:20:01,468
作为游戏状态的事实来源

352
00:20:01,702 --> 0:20:05,172
这是我们在网络协议顶层

353
00:20:05,239 --> 0:20:07,274
它并不是多点连通性所固有的

354
00:20:10,077 --> 0:20:11,578
一旦设置好会话

355
00:20:11,645 --> 0:20:15,482
多点连通性就让我们以三种方式

356
00:20:15,916 --> 0:20:17,117
作为数据包

357
00:20:17,651 --> 0:20:20,654
作为资源

358
00:20:21,054 --> 0:20:22,155
以及作为数据流

359
00:20:22,723 --> 0:20:25,659
你可以发送数据对象

360
00:20:25,993 --> 0:20:28,795
而资源和数据流是设备对设备的操作

361
00:20:29,730 --> 0:20:35,102
在SwiftShot中

362
00:20:35,169 --> 0:20:37,671
以及物理状态 我们稍后再谈

363
00:20:38,839 --> 0:20:41,108
然后我们使用资源

364
00:20:42,176 --> 0:20:44,111
然后它就结束了

365
00:20:46,079 --> 0:20:48,015
在底层 多点连通性

366
00:20:48,081 --> 0:20:50,617
依赖于UDP

367
00:20:51,285 --> 0:20:55,656
这就提供了低延迟

368
00:20:56,490 --> 0:20:58,825
现在固有的UDP并不能保证交付

369
00:20:59,259 --> 0:21:02,763
因此多点连通性

370
00:20:59,259 --> 0:21:02,763
因此多点连通性

371
00:21:02,829 --> 0:21:06,767
可靠或不可靠地发送特定数据包

372
00:21:07,434 --> 0:21:08,735
如果你选择可靠地发送

373
00:21:09,203 --> 0:21:11,972
多点连通性会替你不断重试

374
00:21:12,039 --> 0:21:14,441
因此你不需要在代码中担忧这个问题

375
00:21:15,843 --> 0:21:18,712
即使当你向会话中的所有成员推广时

376
00:21:21,648 --> 0:21:23,350
现在我们有一个网络层

377
00:21:23,417 --> 0:21:25,619
我们要在网络层顶部

378
00:21:26,386 --> 0:21:29,823
带相关联类型SwiftEnums

379
00:21:30,757 --> 0:21:32,759
每个例子中都有一个数据结构

380
00:21:33,126 --> 0:21:36,196
确保类型的安全性

381
00:21:37,464 --> 0:21:39,600
其中有些可以进一步枚举

382
00:21:39,833 --> 0:21:42,636
比如在本例中

383
00:21:42,703 --> 0:21:46,440
像玩家抓取弹弓

384
00:21:47,307 --> 0:21:49,810
PhysicsSyncData

385
00:21:49,877 --> 0:21:51,645
我们是如何进行编码的

386
00:21:53,480 --> 0:21:55,449
Swift让这个过程变得很简单

387
00:21:55,516 --> 0:21:58,552
对于结构 如果结构中的全部成员

388
00:21:58,919 --> 0:22:01,822
你所要做的就是把那个结构

389
00:21:58,919 --> 0:22:01,822
你所要做的就是把那个结构

390
00:22:01,889 --> 0:22:03,624
然后Swift编译器

391
00:22:04,057 --> 0:22:06,426
创建全部基础结构用于序列化

392
00:22:07,995 --> 0:22:09,863
Swift并不会针对枚举这样做

393
00:22:09,930 --> 0:22:12,132
因此我们得自己来实施

394
00:22:12,466 --> 0:22:16,436
实施初始化和编码方法

395
00:22:16,503 --> 0:22:18,805
从可编码协议中

396
00:22:20,908 --> 0:22:22,709
然后序列化就非常简单了

397
00:22:22,776 --> 0:22:26,280
只需要创建一个属性列表编码器

398
00:22:27,314 --> 0:22:30,984
然后我们可以在多点连通性会话内

399
00:22:32,486 --> 0:22:34,188
现在这里有一个合乎情理的提问

400
00:22:34,254 --> 0:22:37,224
它对尺寸和性能会有什么影响？

401
00:22:38,592 --> 0:22:42,663
二进制属性列表非常紧凑

402
00:22:43,664 --> 0:22:44,998
但有时候 你知道的

403
00:22:45,332 --> 0:22:49,269
温和的实施在许多方面

404
00:22:49,336 --> 0:22:51,805
有时候是你在对象上的最宝贵的资源

405
00:22:54,074 --> 0:22:55,776
现在我们遇到了一些限制

406
00:22:55,843 --> 0:22:59,179
当我们开始创建下一个功能时

407
00:23:01,882 --> 0:23:04,318
接下来让我们谈谈游戏中的物理模拟

408
00:23:04,952 --> 0:23:07,688
像SwiftShot一样的游戏

409
00:23:07,754 --> 0:23:11,158
对于创建

410
00:23:11,225 --> 0:23:14,027
在对象和游戏之间

411
00:23:14,094 --> 0:23:17,130
拉动弹弓

412
00:23:17,197 --> 0:23:18,532
并缴获对手的弹弓

413
00:23:19,700 --> 0:23:21,368
那其实是源自物理模拟

414
00:23:23,670 --> 0:23:25,672
我们用了SceneKit

415
00:23:26,039 --> 0:23:27,641
它集成了渲染引擎

416
00:23:27,708 --> 0:23:30,444
在场景中自动更新对象的位置

417
00:23:30,911 --> 0:23:33,113
如果发生碰撞就通过委托提醒我们

418
00:23:34,581 --> 0:23:37,050
在我们的实施中

419
00:23:37,117 --> 0:23:41,722
让会话中的一台设备

420
00:23:42,256 --> 0:23:46,260
它会把物理状态的定期更新

421
00:23:46,326 --> 0:23:50,931
通过多点连通性推送方法

422
00:23:52,699 --> 0:23:56,970
现在其它设备也拥有物理模拟了

423
00:23:57,704 --> 0:24:00,741
这是因为我们并不是发送

424
00:23:57,704 --> 0:24:00,741
这是因为我们并不是发送

425
00:24:01,074 --> 0:24:04,511
只发送那些与游戏设置相关的

426
00:24:04,578 --> 0:24:06,413
落弹数和弹弩

427
00:24:06,914 --> 0:24:11,018
还有一些东西

428
00:24:11,084 --> 0:24:16,089
微粒等等

429
00:24:16,156 --> 0:24:19,660
因为它对于游戏来说并不是关键因素

430
00:24:24,031 --> 0:24:26,867
现在在我们的实现过程中

431
00:24:26,934 --> 0:24:29,870
物理引擎的响应很不一样

432
00:24:29,937 --> 0:24:31,572
取决于对象的比例

433
00:24:32,206 --> 0:24:34,107
那么物理模拟认为

434
00:24:34,174 --> 0:24:37,678
对象比你在现实世界中看到的尺寸

435
00:24:38,278 --> 0:24:41,181
我们发现

436
00:24:41,248 --> 0:24:42,416
和最好的性能

437
00:24:43,150 --> 0:24:44,685
我们需要改善一些物理定律

438
00:24:44,751 --> 0:24:47,988
让一切看起来都正常 但是你知道的

439
00:24:48,055 --> 0:24:50,357
若看起来还不错 感觉也不错

440
00:24:50,691 --> 0:24:51,558
那就对了

441
00:24:53,760 --> 0:24:56,930
现在要共享那个物理状态

442
00:24:56,997 --> 0:24:59,166
我们需要共享四个信息：

443
00:24:59,633 --> 0:25:00,501
位置

444
00:24:59,633 --> 0:25:00,501
位置

445
00:25:02,269 --> 0:25:03,203
速度

446
00:25:04,638 --> 0:25:07,541
角速度和定向

447
00:25:08,342 --> 0:25:10,711
对于游戏中的每一个对象来说

448
00:25:11,144 --> 0:25:14,348
因此我们最小化实际要用到的位数

449
00:25:14,982 --> 0:25:17,417
我会以位置作为例子具体讲一下

450
00:25:18,886 --> 0:25:22,356
SceneKit把位置表示为

451
00:25:23,257 --> 0:25:24,725
这是原生格式

452
00:25:24,791 --> 0:25:27,895
在运行时间给计算提供了最好的性能

453
00:25:30,163 --> 0:25:32,766
然而 其实还有更多不必要的位数

454
00:25:32,833 --> 0:25:34,401
用于指定对象的位置

455
00:25:35,169 --> 0:25:39,273
一个30位的浮点有8位指数

456
00:25:39,740 --> 0:25:42,442
对于正负十的范围 相对于38米

457
00:25:43,043 --> 0:25:44,912
这比我们需要在游戏中使用的长度

458
00:25:47,347 --> 0:25:51,385
那么因为物理模拟认为

459
00:25:51,985 --> 0:25:55,055
我们说过你知道的

460
00:25:55,122 --> 0:25:56,523
在桌子周围

461
00:25:58,625 --> 0:26:03,096
当我们写代码时

462
00:25:58,625 --> 0:26:03,096
当我们写代码时

463
00:26:03,530 --> 0:26:06,867
通过把那个正常化到0和80米之间

464
00:26:06,934 --> 0:26:08,669
即使我们的原始位置在桌子的中心

465
00:26:09,403 --> 0:26:10,704
现在所有值都是正值

466
00:26:12,172 --> 0:26:15,108
然后我们把那个值削减到0和1之间

467
00:26:15,676 --> 0:26:17,578
那样我们就不需要指数信息

468
00:26:17,644 --> 0:26:20,747
协议内固有的指数信息

469
00:26:22,649 --> 0:26:24,484
最后 我们把这个数

470
00:26:24,551 --> 0:26:26,453
按比例缩减为可用的位数

471
00:26:26,954 --> 0:26:32,926
从而所有值都是一个浮点值

472
00:26:34,094 --> 0:26:38,532
这就给我们提供了毫米比例精度

473
00:26:38,966 --> 0:26:41,735
用于实现游戏中流畅、同步的体验

474
00:26:43,403 --> 0:26:46,607
现在我们对你所看到的其它值

475
00:26:46,673 --> 0:26:49,543
速度、角速度和定向

476
00:26:51,078 --> 0:26:53,680
缩减范围和位数

477
00:26:53,747 --> 0:26:56,183
以便确保我们对信息的传输

478
00:26:56,250 --> 0:26:57,551
保持了最小的数据量

479
00:26:58,051 --> 0:27:02,589
总之 我们对每个对象

480
00:26:58,051 --> 0:27:02,589
总之 我们对每个对象

481
00:27:04,658 --> 0:27:06,793
现在即使我们压缩了位数

482
00:27:07,761 --> 0:27:10,330
属性列表仍然有大量的超额负载

483
00:27:10,397 --> 0:27:11,865
对于它的元数据而言

484
00:27:12,633 --> 0:27:13,834
按名称发送每一个字段

485
00:27:14,801 --> 0:27:18,238
我们说过那是无缘无故的

486
00:27:18,572 --> 0:27:19,940
这不是我们需要的信息

487
00:27:20,707 --> 0:27:25,746
为此我们实施了一个新的序列化策略

488
00:27:26,146 --> 0:27:27,181
称之为BitStream

489
00:27:28,382 --> 0:27:30,417
BitStream

490
00:27:30,484 --> 0:27:31,952
尽可能少的字节中

491
00:27:32,319 --> 0:27:35,022
同时提供快速的序列化和反序列化

492
00:27:35,856 --> 0:27:37,925
现在我们的实施是为特定目的创建的

493
00:27:37,991 --> 0:27:39,560
用于传递二进制数据

494
00:27:40,093 --> 0:27:42,162
以低延迟 在一个类似这样的app中

495
00:27:42,896 --> 0:27:47,568
这样的策略对于需要持久的数据来说

496
00:27:48,001 --> 0:27:50,270
或者是你需要追踪架构

497
00:27:50,337 --> 0:27:51,772
并随时间观察它的变化的数据

498
00:27:52,439 --> 0:27:55,676
但对于类似这样的短暂的app来说

499
00:27:58,178 --> 0:28:01,114
要实施它 我们创建了两个协议

500
00:27:58,178 --> 0:28:01,114
要实施它 我们创建了两个协议

501
00:28:01,181 --> 0:28:03,951
BitStream Encodable

502
00:28:04,651 --> 0:28:06,520
把两个结合起来就能得到

503
00:28:07,387 --> 0:28:11,124
然后我们用它标记

504
00:28:11,191 --> 0:28:13,594
使用那个协议 帮助我们获得实施

505
00:28:14,027 --> 0:28:17,898
那既包括我们自己的数据对象

506
00:28:17,965 --> 0:28:22,269
比如simD浮点矢量类型

507
00:28:25,272 --> 0:28:27,908
那么这是压缩浮点的实施

508
00:28:28,509 --> 0:28:31,578
压缩器配置了最小和最大范围

509
00:28:31,645 --> 0:28:33,347
以及我们想要使用的位数

510
00:28:35,115 --> 0:28:39,253
它把值压缩到那个范围

511
00:28:39,319 --> 0:28:41,722
用于编码 使用指定位数

512
00:28:42,823 --> 0:28:45,859
场景中每个对象的每个组件

513
00:28:46,593 --> 0:28:48,829
我们之前还使用额外位数

514
00:28:48,896 --> 0:28:51,298
来表示对象自上次更新后

515
00:28:51,999 --> 0:28:54,735
如果它没有移动过

516
00:28:57,271 --> 0:28:59,940
那么让我们返回我们的行动枚举

517
00:29:00,007 --> 0:29:02,042
谈谈如何通过

518
00:29:03,844 --> 0:29:07,514
对于常规的codable

519
00:29:07,581 --> 0:29:11,385
你要在枚举中的不同情况下

520
00:29:12,186 --> 0:29:16,857
对于BitStream

521
00:29:18,525 --> 0:29:23,330
然后再我们的编码方法中

522
00:29:23,397 --> 0:29:27,601
接着是与那个枚举情况

523
00:29:28,468 --> 0:29:31,205
现在 如果你查找这个代码

524
00:29:31,805 --> 0:29:36,577
我们知道这个例子有三种不同的情况

525
00:29:37,211 --> 0:29:39,213
我们只需要两个位元来编码它

526
00:29:40,681 --> 0:29:45,452
但当我们添加另一情况后会怎样呢？

527
00:29:45,752 --> 0:29:49,923
我们添加了第五种情况

528
00:29:49,990 --> 0:29:53,427
我们每次这样做时

529
00:29:54,061 --> 0:29:57,197
现在这就有点乏味了

530
00:29:57,264 --> 0:29:59,666
并且你知道的

531
00:29:59,733 --> 0:30:02,703
如果我们不记得这个

532
00:29:59,733 --> 0:30:02,703
如果我们不记得这个

533
00:30:03,804 --> 0:30:05,339
那么让我们查看一下

534
00:30:05,405 --> 0:30:08,909
想想Swift是否可以提供帮助

535
00:30:11,078 --> 0:30:15,482
我们用了Swift 4.2新特性

536
00:30:16,450 --> 0:30:21,688
我们在我们的枚举类型中

537
00:30:22,489 --> 0:30:26,827
当你这样做时 Swift

538
00:30:26,894 --> 0:30:29,897
叫做全部情况

539
00:30:30,664 --> 0:30:34,034
让就让我们自动获得情况数量

540
00:30:34,968 --> 0:30:38,772
然后我们添加了另一个扩展

541
00:30:38,839 --> 0:30:42,543
所有带数字类型的枚举都会遵循它

542
00:30:43,110 --> 0:30:46,346
这种情况可迭代 并且数字是整数

543
00:30:47,047 --> 0:30:50,117
为此我们要自动获取情况的数量

544
00:30:50,184 --> 0:30:54,254
并算出表达全部那些情况

545
00:30:56,356 --> 0:31:01,128
最后我们添加了通用方法

546
00:30:56,356 --> 0:31:01,128
最后我们添加了通用方法

547
00:31:01,195 --> 0:31:02,763
允许我们编码那个枚举

548
00:31:03,397 --> 0:31:07,467
它会附加那个类型的东西

549
00:31:07,534 --> 0:31:09,736
所需要使用的位元数

550
00:31:11,705 --> 0:31:13,740
现在我们的编码方法变得更简单了

551
00:31:14,208 --> 0:31:17,845
在适当的代码键上

552
00:31:17,911 --> 0:31:19,346
Swift会替我们完成剩下的事

553
00:31:19,980 --> 0:31:23,717
当我们向枚举中添加更多情况时

554
00:31:23,984 --> 0:31:26,286
如果我们移除情况 它会自动缩小

555
00:31:26,520 --> 0:31:27,754
我们不用担心它

556
00:31:31,658 --> 0:31:34,695
BitStreamCodable

557
00:31:35,028 --> 0:31:38,298
我们运行一些测试

558
00:31:38,665 --> 0:31:42,503
使用代表性的信息

559
00:31:44,004 --> 0:31:47,841
结果令人印象深刻：十分之一的尺寸

560
00:31:47,908 --> 0:31:49,376
十倍速度的解码

561
00:31:50,177 --> 0:31:54,581
现在当我们谈到从75毫秒

562
00:31:54,648 --> 0:31:56,116
看起来微不足道

563
00:31:56,917 --> 0:32:00,254
但游戏中有大约200个对象

564
00:31:56,917 --> 0:32:00,254
但游戏中有大约200个对象

565
00:32:00,320 --> 0:32:03,023
从而确保每一个参与者

566
00:32:03,524 --> 0:32:04,992
通过使用这个编码格式

567
00:32:05,058 --> 0:32:08,495
我们就能以60帧/秒

568
00:32:08,562 --> 0:32:11,164
确保游戏中的每一个人

569
00:32:13,400 --> 0:32:16,737
现在 我已经讲过了

570
00:32:16,803 --> 0:32:20,174
还有BitStream Codable

571
00:32:20,240 --> 0:32:22,075
因为我们用了两种不同的方式来编码

572
00:32:22,309 --> 0:32:24,077
那意味着需要两种不同的代码路径

573
00:32:24,144 --> 0:32:25,012
在我们的app中

574
00:32:26,113 --> 0:32:29,149
Swift再次给我们提供了帮助

575
00:32:30,117 --> 0:32:33,086
然后我们添加了受约束的扩展

576
00:32:33,153 --> 0:32:36,390
因此BitStream Codable中

577
00:32:36,657 --> 0:32:39,860
我们提供了BitStream

578
00:32:40,460 --> 0:32:45,199
然后我们只需要继续

579
00:32:45,832 --> 0:32:48,168
来编码数据并把它放在

580
00:32:49,236 --> 0:32:52,105
然后任何对象

581
00:32:52,172 --> 0:32:54,575
我们只需要添加它并把它标记为

582
00:32:54,908 --> 0:32:58,011
现在这个实施并不是那么快速和紧凑

583
00:32:58,078 --> 0:33:01,315
如果我们继续并让一切对象都直接

584
00:32:58,078 --> 0:33:01,315
如果我们继续并让一切对象都直接

585
00:33:01,849 --> 0:33:04,651
但我们发现我们不需要针对

586
00:33:04,718 --> 0:33:06,587
只针对最频繁的信息即可

587
00:33:06,653 --> 0:33:10,691
这让我们的移动非常快速

588
00:33:12,526 --> 0:33:13,961
那么这是我们如何处理物理

589
00:33:14,228 --> 0:33:17,097
接下来我想谈谈如何针对游戏等级

590
00:33:17,164 --> 0:33:20,033
楼下有很多人提到了这个问题

591
00:33:22,002 --> 0:33:24,404
你知道的 资产包括3D模块、纹理

592
00:33:24,471 --> 0:33:25,772
动画等等

593
00:33:26,406 --> 0:33:28,342
Apple中有些文本角度的

594
00:33:28,709 --> 0:33:31,445
并且它们使用了一些商业工具

595
00:33:31,512 --> 0:33:33,280
砖块、弹弩等等

596
00:33:34,047 --> 0:33:38,185
然后他们把资产导出为

597
00:33:38,252 --> 0:33:40,921
我们想要让商业工具支持USDZ

598
00:33:41,255 --> 0:33:42,789
但对于这个游戏

599
00:33:44,424 --> 0:33:49,162
在Swift中创建了命令行工具

600
00:33:49,229 --> 0:33:52,733
将对象从DAE转换为

601
00:33:53,133 --> 0:33:56,937
因为SceneKit在iOS

602
00:33:57,337 --> 0:34:01,241
我们可以把这个工具

603
00:33:57,337 --> 0:34:01,241
我们可以把这个工具

604
00:34:01,308 --> 0:34:04,945
并在app的iOS创建中直接包括

605
00:34:06,780 --> 0:34:09,949
我们把数据结构化

606
00:34:10,016 --> 0:34:11,518
都在自己的文件中

607
00:34:12,018 --> 0:34:14,521
然后对于每个等级

608
00:34:15,455 --> 0:34:18,492
这就允许我们迭代外观和物理行为

609
00:34:18,559 --> 0:34:21,628
每一个单一组块的

610
00:34:21,695 --> 0:34:24,097
针对那些等级 并迭代游戏设置设计

611
00:34:24,364 --> 0:34:26,333
尝试些不同等级 你会看到

612
00:34:26,400 --> 0:34:28,135
app的源代码的话

613
00:34:30,370 --> 0:34:33,639
要进一步优化不同的距离

614
00:34:33,907 --> 0:34:38,045
根据所需要的等级细节

615
00:34:39,079 --> 0:34:42,149
附近的对象使用较多的多边形

616
00:34:42,216 --> 0:34:45,652
而远处的对象使用较少的多边形

617
00:34:45,985 --> 0:34:48,388
这样就真正优化了场景的渲染

618
00:34:51,190 --> 0:34:54,027
然而 我们仍然希望游戏设置

619
00:34:54,460 --> 0:34:56,929
因此我们分别制定了物理实体

620
00:34:57,865 --> 0:35:00,234
SceneKit提供一系列

621
00:34:57,865 --> 0:35:00,234
SceneKit提供一系列

622
00:35:00,300 --> 0:35:02,603
比如立方体、球体、圆柱体

623
00:35:03,303 --> 0:35:06,073
如果你使用这些

624
00:35:06,807 --> 0:35:08,475
如果你不指定其中一个

625
00:35:08,542 --> 0:35:12,579
SceneKit将自动为你创建

626
00:35:12,913 --> 0:35:16,850
但可能会得到较慢的性能实施

627
00:35:17,150 --> 0:35:19,953
通过添加这些对象 当它们可用

628
00:35:20,020 --> 0:35:23,023
并且当它们的存在有意义时

629
00:35:25,959 --> 0:35:28,762
那么这是一些关于物理成品的示例

630
00:35:29,329 --> 0:35:30,898
第一个是游戏中的一个组块

631
00:35:30,964 --> 0:35:34,034
在本例中 一个带纹理的圆柱体

632
00:35:35,068 --> 0:35:37,237
接下来是弹弓 悬带是松弛的

633
00:35:37,905 --> 0:35:40,474
我们在RunTime时

634
00:35:40,541 --> 0:35:43,477
并针对弹弓在游戏设置中的动作

635
00:35:44,912 --> 0:35:48,415
最后我们引入了一些额外的资产

636
00:35:48,749 --> 0:35:50,284
即便我们要牺牲掉它们

637
00:35:50,350 --> 0:35:53,153
我们希望你拥有它们

638
00:35:56,190 --> 0:35:59,493
因此我们包括在内的另一个

639
00:35:59,726 --> 0:36:01,828
它很好地改善了

640
00:35:59,726 --> 0:36:01,828
它很好地改善了

641
00:36:02,596 --> 0:36:04,831
我们想要一个真实的刮风的效果

642
00:36:05,165 --> 0:36:08,168
现在我们可以在物理引擎外部

643
00:36:09,469 --> 0:36:13,040
但相反 我们决定使用GPU

644
00:36:15,275 --> 0:36:18,011
我们从由技术设计师创建的

645
00:36:18,478 --> 0:36:22,449
要在旗子上获取Apple标识

646
00:36:23,684 --> 0:36:26,253
然后在Metal设备周围

647
00:36:26,787 --> 0:36:30,424
Swift代码创建了metal

648
00:36:30,490 --> 0:36:33,193
从游戏状态中获取的信息 比如风向

649
00:36:34,561 --> 0:36:37,164
那个命令队列运行的是

650
00:36:37,798 --> 0:36:39,900
它来自用C创建的老程序

651
00:36:40,133 --> 0:36:44,805
但因Metal基于现代的C++

652
00:36:45,772 --> 0:36:49,776
然后我们还运行了另一个计算着色器

653
00:36:49,843 --> 0:36:52,346
这样我们就得到了一个很棒

654
00:36:52,579 --> 0:36:54,915
而不需要在场景中有大量的多边形

655
00:36:55,582 --> 0:36:57,251
旗子效果看起来真的很棒

656
00:36:58,252 --> 0:37:01,722
每一帧 着色器都会把

657
00:36:58,252 --> 0:37:01,722
每一帧 着色器都会把

658
00:37:01,788 --> 0:37:02,789
它的新位置

659
00:37:03,257 --> 0:37:05,459
通过以这种方式利用GPU

660
00:37:05,526 --> 0:37:09,730
我们得到了一个很棒的效果

661
00:37:12,399 --> 0:37:15,769
最后我想谈谈

662
00:37:16,670 --> 0:37:19,806
音频可以让任何游戏变得

663
00:37:20,674 --> 0:37:23,443
我们知道我们想提供真实的声音效果

664
00:37:23,510 --> 0:37:26,813
并在虚拟世界中适当地投放

665
00:37:26,880 --> 0:37:28,315
并给用户提供很好的反馈

666
00:37:28,382 --> 0:37:30,017
关于他们要如何与那个世界交互

667
00:37:30,884 --> 0:37:33,453
我们还想确保这个速度够快并关注

668
00:37:33,520 --> 0:37:36,390
添加多少音频会增加我们app的大小

669
00:37:37,057 --> 0:37:39,326
那么我们遇到了一个

670
00:37:40,294 --> 0:37:42,963
我们创建了一些代表性的声音示例

671
00:37:43,030 --> 0:37:46,099
通过我们从团队员工的孩子们那儿

672
00:37:47,301 --> 0:37:52,439
然后我们录制了那些声音

673
00:37:52,739 --> 0:37:56,343
并用这些声音在AV Foundation中

674
00:37:56,677 --> 0:37:58,712
使用AV Audio Unit

675
00:37:59,413 --> 0:38:02,115
那样就能在合适的时候

676
00:37:59,413 --> 0:38:02,115
那样就能在合适的时候

677
00:38:02,182 --> 0:38:04,551
以响应用户在游戏中的输入和碰撞

678
00:38:06,987 --> 0:38:08,655
我们并不只是播放原声音

679
00:38:09,122 --> 0:38:11,992
为了给用户提供良好的反馈

680
00:38:12,059 --> 0:38:14,194
我们用多种方式区分了声音

681
00:38:14,795 --> 0:38:18,398
我们修改了音高

682
00:38:21,702 --> 0:38:24,705
并且我们区分了音量

683
00:38:24,771 --> 0:38:27,708
且在RunTime时实现

684
00:38:27,774 --> 0:38:30,310
然后使用一些额外的Midi命令

685
00:38:30,377 --> 0:38:31,879
在播放那个声音之前进行替换

686
00:38:32,379 --> 0:38:34,815
那么让我们听一下这个是…很安静

687
00:38:53,700 --> 0:38:57,604
现在我们还想确保当你使用弹弓时

688
00:38:57,671 --> 0:39:01,208
我们还向用户提供一些音频反馈

689
00:38:57,671 --> 0:39:01,208
我们还向用户提供一些音频反馈

690
00:39:01,275 --> 0:39:03,377
关于他们是否在弹弓的射程范围内

691
00:39:03,443 --> 0:39:04,845
以及他们是否捕获了东西

692
00:39:04,912 --> 0:39:06,747
这是你在一开始听到的哔哔声

693
00:39:07,347 --> 0:39:09,783
因为那些对于用户来说

694
00:39:10,217 --> 0:39:12,119
设备才会发出那些声音

695
00:39:12,186 --> 0:39:14,488
仅当用户与弹弓进行交互时

696
00:39:14,922 --> 0:39:18,158
然而我们还希望

697
00:39:18,225 --> 0:39:21,028
弹弓那儿发生了什么

698
00:39:21,094 --> 0:39:23,297
或做出类似操作

699
00:39:23,797 --> 0:39:27,334
那么我们使用了位置性音频

700
00:39:27,401 --> 0:39:30,571
正在拉动他们的弹弓

701
00:39:30,637 --> 0:39:32,840
但音量较小

702
00:39:35,175 --> 0:39:38,679
对于碰撞砖块

703
00:39:39,112 --> 0:39:43,917
我们真的想要一个刺耳的效果

704
00:39:43,984 --> 0:39:46,887
砖块通常不会出现在

705
00:39:46,954 --> 0:39:51,091
所以SceneKit位置性支持

706
00:39:52,092 --> 0:39:53,727
每台设备都会独立发声

707
00:39:54,628 --> 0:39:56,797
你不用担心设备之间的同步性

708
00:39:56,864 --> 0:39:59,766
因为我们希望它是个刺耳的声音

709
00:40:00,434 --> 0:40:02,469
我们使用了自定义Midi乐器

710
00:40:03,003 --> 0:40:05,005
采用了少量声音 然后把它们区分开

711
00:40:05,339 --> 0:40:07,841
在本例中是按照碰撞冲量的力量

712
00:40:07,908 --> 0:40:10,878
碰撞冲量

713
00:40:13,614 --> 0:40:15,883
这些声音在3D坐标中进行了本地化

714
00:40:15,949 --> 0:40:17,885
根据设备在场景中的位置

715
00:40:17,951 --> 0:40:20,921
因此桌子最远处的碰撞

716
00:40:21,522 --> 0:40:22,689
让我们来听一下

717
00:40:38,572 --> 0:40:39,406
再发射一次

718
00:40:40,574 --> 0:40:41,408
好了

719
00:40:42,376 --> 0:40:43,210
很棒

720
00:40:46,346 --> 0:40:48,282
那么我们想分享另一个小技巧

721
00:40:48,348 --> 0:40:50,117
是我们在实现这个的过程中发现的

722
00:40:50,784 --> 0:40:52,352
在设置声音的过程中

723
00:40:52,419 --> 0:40:55,389
我们发现我们需要

724
00:40:55,455 --> 0:40:59,159
用于在属性列表上做一些

725
00:41:00,260 --> 0:41:02,563
我们发现我们可以用Swift

726
00:41:02,896 --> 0:41:04,798
但却把它设置为一个命令行工具

727
00:41:05,532 --> 0:41:06,967
你注意到顶部了吗

728
00:41:07,034 --> 0:41:10,304
脚本顶部传统的Unix shebang

729
00:41:10,671 --> 0:41:14,374
会告诉你的shell

730
00:41:15,509 --> 0:41:18,679
这样我们就可以将Swift

731
00:41:19,947 --> 0:41:22,282
你可以通过Swift Playground

732
00:41:22,749 --> 0:41:26,053
可以交互地编写代码

733
00:41:26,920 --> 0:41:31,058
写好后 你只需要保存到一个文件中

734
00:41:31,491 --> 0:41:34,228
并让文件在文件系统中可执行

735
00:41:35,229 --> 0:41:38,966
现在你得到了一个命令行工具

736
00:41:39,032 --> 0:41:42,803
在app外使用或在Xcode中

737
00:41:43,770 --> 0:41:48,242
很简单 它会让你获取全部系统框架

738
00:41:48,308 --> 0:41:50,544
在本例中 我们可直接编辑属性列表

739
00:41:51,044 --> 0:41:51,979
这是一个非常棒的技巧

740
00:41:52,045 --> 0:41:54,515
我们希望你们能好好利用它

741
00:41:57,417 --> 0:42:00,754
那么今天 我希望你们了解了

742
00:41:57,417 --> 0:42:00,754
那么今天 我希望你们了解了

743
00:42:00,821 --> 0:42:02,789
给迷人的游戏和其它体验

744
00:42:03,657 --> 0:42:06,026
我们鼓励你们从一开始设计

745
00:42:06,493 --> 0:42:08,662
请记住对于游戏来说 玩才是重点

746
00:42:08,729 --> 0:42:11,198
你不能在最后才体验游戏的趣味性

747
00:42:13,100 --> 0:42:16,904
我们真心希望你会下载SwiftShot

748
00:42:16,970 --> 0:42:19,206
并使用它来指导你创建你自己的app

749
00:42:19,506 --> 0:42:23,277
我们计划在iOS 12的

750
00:42:23,343 --> 0:42:24,478
只要我们发布新版本

751
00:42:25,045 --> 0:42:28,081
最后如果你还没有机会这么做

752
00:42:28,148 --> 0:42:30,851
希望你去楼下游戏室

753
00:42:32,486 --> 0:42:35,923
要获取更多信息 这场演讲之后

754
00:42:35,989 --> 0:42:37,257
今晚还有一次聚会

755
00:42:37,858 --> 0:42:40,727
我也很开心地宣布

756
00:42:41,061 --> 0:42:44,097
我们在本周五的中午到下午两点

757
00:42:44,164 --> 0:42:47,267
我们希望你们能来参加 非常感谢
