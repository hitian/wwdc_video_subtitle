1
00:00:16,750 --> 00:00:21,755
（自动化App Store Connect演讲303）

2
00:00:34,701 --> 00:00:38,405
下午好 我是Geoff Coffey

3
00:00:38,805 --> 00:00:41,742
我今天要跟大家谈谈自动化

4
00:00:42,276 --> 00:00:44,278
老实说我现在非常激动

5
00:00:44,344 --> 00:00:45,779
想到今天要跟大家分享的内容

6
00:00:46,947 --> 00:00:48,348
让我们首先谈谈

7
00:00:48,415 --> 00:00:51,118
我们在自动App Store Connect的进度

8
00:00:51,685 --> 00:00:53,987
我知道你们都了解

9
00:00:54,054 --> 00:00:56,156
把你所创建的app上传到

10
00:00:56,490 --> 00:00:58,158
并下载崩溃报告

11
00:00:58,725 --> 00:01:00,160
我们有一个 Transporter 工具

12
00:00:58,725 --> 00:01:00,160
我们有一个 Transporter 工具

13
00:01:00,227 --> 00:01:03,430
可以帮助你自动上传

14
00:01:03,664 --> 00:01:05,566
也会自动上传你所创建的构建版本

15
00:01:06,133 --> 00:01:07,201
我们还有Reporter

16
00:01:07,267 --> 00:01:10,838
它是一个命令行工具

17
00:01:11,605 --> 00:01:14,007
这些工具都很棒

18
00:01:14,241 --> 00:01:16,210
但我听你们说你们想要更多功能

19
00:01:16,376 --> 00:01:19,513
你希望能查看App Store Connect中的更多区域

20
00:01:19,746 --> 00:01:22,182
并希望集成更多不同的工作流程

21
00:01:22,883 --> 00:01:26,620
我们真的非常高兴引入了一个新的

22
00:01:33,961 --> 00:01:35,062
我们自己也感到非常激动

23
00:01:35,128 --> 00:01:39,700
这是一个App Store

24
00:01:40,300 --> 00:01:42,536
如果你问我 这是它最棒的一点

25
00:01:42,603 --> 00:01:46,139
它是一个库存标准的

26
00:01:46,206 --> 00:01:48,909
所以你们一定会感到很熟悉

27
00:01:49,476 --> 00:01:52,379
那也意味着

28
00:01:52,446 --> 00:01:54,147
它几乎支持任何一种编码语言

29
00:01:54,214 --> 00:01:57,050
你可以使用

30
00:01:58,352 --> 00:02:00,254
当然了 这个API需要保持安全

31
00:01:58,352 --> 00:02:00,254
当然了 这个API需要保持安全

32
00:02:00,320 --> 00:02:04,691
因此我们使用了工业级的JSON

33
00:02:05,125 --> 00:02:08,095
那仅仅意味着

34
00:02:08,562 --> 00:02:12,499
而且你不需要把代码

35
00:02:12,866 --> 00:02:16,503
但你仍然可以控制谁可以获取

36
00:02:18,639 --> 00:02:19,740
从简单易用方面考虑

37
00:02:19,806 --> 00:02:22,943
我们十分关注这个API的一致性

38
00:02:23,243 --> 00:02:27,080
我们有一个独立、统一

39
00:02:27,281 --> 00:02:29,983
你可以把你所了解到的东西

40
00:02:30,217 --> 00:02:31,785
并把它用到其它部分中去

41
00:02:32,286 --> 00:02:35,455
我们还以一种简单的方式

42
00:02:35,923 --> 00:02:38,659
在API自身嵌入了可暴露性

43
00:02:38,725 --> 00:02:40,494
它的格式和缩进会非常整齐

44
00:02:40,561 --> 00:02:42,930
所以如果需要

45
00:02:42,996 --> 00:02:44,498
并在屏幕上读取它

46
00:02:44,765 --> 00:02:48,035
并且我们在那些响应中

47
00:02:48,101 --> 00:02:50,337
用于帮助你们了解

48
00:02:51,738 --> 00:02:54,274
当然了

49
00:02:54,508 --> 00:02:57,077
如果你还没有看到文档

50
00:02:57,144 --> 00:03:00,747
developer.apple.com中的

51
00:02:57,144 --> 00:03:00,747
developer.apple.com中的

52
00:03:00,814 --> 00:03:04,284
今年进行了扩展 其中就包含了

53
00:03:04,551 --> 00:03:08,255
因此与你所熟悉的框架文档格式相同

54
00:03:08,322 --> 00:03:10,290
同样适用于App Store Connect API

55
00:03:12,326 --> 00:03:15,796
我们开始关注App Store Connect中

56
00:03:16,096 --> 00:03:19,066
还没有自动化的区域

57
00:03:19,233 --> 00:03:21,201
你得时不时地关注一下

58
00:03:21,268 --> 00:03:24,471
尤其是我们已经开始进行

59
00:03:24,538 --> 00:03:26,473
让我们看看都包含什么

60
00:03:27,174 --> 00:03:29,276
首先我们有TestFlight的

61
00:03:29,610 --> 00:03:33,180
你可以管理测试人员和团队

62
00:03:33,580 --> 00:03:34,882
并且如果你观看了昨天的演讲

63
00:03:34,948 --> 00:03:36,617
“App Store Connect新特性”演讲

64
00:03:36,683 --> 00:03:39,119
你就知道我们刚发布了

65
00:03:39,186 --> 00:03:40,521
有助于收集测试人员

66
00:03:40,854 --> 00:03:42,923
这个功能要和API一起使用

67
00:03:43,323 --> 00:03:45,859
你可以用API来管理你的公共链接

68
00:03:46,093 --> 00:03:49,062
你可以同时使用公共连接和API

69
00:03:49,129 --> 00:03:51,198
你可以随心所欲选择一种方式

70
00:03:52,966 --> 00:03:55,602
在用户和职能方面

71
00:03:55,669 --> 00:03:59,506
并保持你用户的权限

72
00:04:00,073 --> 00:04:01,375
正如我们昨天所发布的那样

73
00:04:01,441 --> 00:04:03,877
这包括完整、统一的用户基础

74
00:04:04,044 --> 00:04:06,947
在开发者网站上

75
00:04:07,014 --> 00:04:09,883
所以你拥有一套用户和一套职能

76
00:04:16,055 --> 00:04:19,125
我们有配置API

77
00:04:19,192 --> 00:04:22,863
和批量注册ID

78
00:04:23,597 --> 00:04:25,065
然后我们还有报告API

79
00:04:25,132 --> 00:04:27,935
你可以下载销售和财务报告文件

80
00:04:28,268 --> 00:04:30,137
如果你用过Reporter

81
00:04:30,204 --> 00:04:32,206
那么你一定会对这个API感到熟悉

82
00:04:32,272 --> 00:04:35,676
因为你发送给Reporter的参数

83
00:04:35,742 --> 00:04:37,544
因此在这两者之间切换

84
00:04:38,879 --> 00:04:41,048
我说过一共有四件事 那么最后一件

85
00:04:41,114 --> 00:04:43,717
其实并不是API自身的一部分

86
00:04:43,784 --> 00:04:46,086
因为它对于我们的自动化来说

87
00:04:46,486 --> 00:04:48,088
我们已在 Transporter 工具中

88
00:04:48,155 --> 00:04:50,390
用于帮助你们更好地使用它

89
00:04:50,858 --> 00:04:53,794
首先 Linux将开始支持

90
00:04:54,461 --> 00:04:56,663
同时你能把在新API上

91
00:04:56,864 --> 00:05:00,234
发送给 Transporter 工具

92
00:04:56,864 --> 00:05:00,234
发送给 Transporter 工具

93
00:05:00,300 --> 00:05:02,402
那么 Transporter 工具可以用它们进行认证

94
00:05:02,636 --> 00:05:04,972
它只是把进程变得更简单了

95
00:05:07,107 --> 00:05:08,442
我们还有很多内容要讲

96
00:05:08,509 --> 00:05:10,043
今天我们要加快进度了

97
00:05:10,110 --> 00:05:12,045
我很抱歉 但我们还有很多内容要讲

98
00:05:12,112 --> 00:05:15,148
我们要谈谈

99
00:05:15,349 --> 00:05:17,551
我们要谈谈关系

100
00:05:17,618 --> 00:05:20,387
是如何协同合作的

101
00:05:20,721 --> 00:05:22,289
我们要谈谈如何处理报错

102
00:05:22,356 --> 00:05:24,958
如何获取API并验证请求

103
00:05:25,192 --> 00:05:27,261
然后我们会展示一些最佳范例

104
00:05:28,695 --> 00:05:29,696
你们准备好了吗？

105
00:05:34,001 --> 00:05:36,470
正如我所说的

106
00:05:36,537 --> 00:05:41,041
那意味着我们要从这里开始

107
00:05:41,275 --> 00:05:45,679
这是API的大本营

108
00:05:46,313 --> 00:05:48,182
首先我们要添加一个版本号

109
00:05:48,882 --> 00:05:52,519
现在所有API终端都有一个版本号

110
00:05:52,986 --> 00:05:56,290
但不可避免 随App Store

111
00:05:56,557 --> 00:05:58,125
我们要对API进行修改

112
00:05:58,192 --> 00:06:00,127
那可能会导致你的代码停止运行

113
00:05:58,192 --> 00:06:00,127
那可能会导致你的代码停止运行

114
00:06:00,561 --> 00:06:01,762
如果发生了这种情况

115
00:06:01,828 --> 00:06:04,698
我们会修改这个版本号

116
00:06:04,765 --> 00:06:07,968
因此你就有时间进行调整

117
00:06:08,735 --> 00:06:12,973
在这个版本之后 我们会添加

118
00:06:13,340 --> 00:06:15,576
这在API中是一个极其重要的概念

119
00:06:15,809 --> 00:06:19,446
源就像是API的基本单位

120
00:06:19,813 --> 00:06:21,582
从概念上讲

121
00:06:21,648 --> 00:06:24,852
你正在操作的源的一个大集合

122
00:06:25,552 --> 00:06:27,855
在API中我们有一大群源

123
00:06:28,255 --> 00:06:30,791
其中大部分都映射为你在

124
00:06:30,858 --> 00:06:32,860
今天我们不会都谈到

125
00:06:32,926 --> 00:06:36,363
我们只重点谈其中一些

126
00:06:37,030 --> 00:06:39,666
我们有一个完整的API URL：

127
00:06:39,733 --> 00:06:44,972
api.appstoreconnect.apple.com

128
00:06:45,038 --> 00:06:47,941
这个URL代表你团队中的全部用户

129
00:06:48,575 --> 00:06:52,913
当然 你可以获取这个URL

130
00:06:53,547 --> 00:06:57,284
对此你首先要注意到的是

131
00:06:57,784 --> 00:07:00,521
任何时候当我们成功发送给你一个

132
00:06:57,784 --> 00:07:00,521
任何时候当我们成功发送给你一个

133
00:07:00,888 --> 00:07:02,356
都包含这个数据属性

134
00:07:02,856 --> 00:07:06,159
在本例中 它是一个用户源的数组

135
00:07:06,693 --> 00:07:08,829
现在你在屏幕上只能看到一个用户

136
00:07:08,896 --> 00:07:10,697
但如果屏幕再高点

137
00:07:10,764 --> 00:07:13,433
你就可以在这个数组中看到

138
00:07:14,468 --> 00:07:17,337
现在我想谈谈

139
00:07:17,404 --> 00:07:19,540
带有每一个这样的源响应

140
00:07:20,073 --> 00:07:22,910
每个源都有一个类型

141
00:07:23,243 --> 00:07:26,113
并且一个ID会唯一识别这个源

142
00:07:26,213 --> 00:07:27,981
在整个App Store Connect中

143
00:07:28,849 --> 00:07:30,150
然后我们有属性

144
00:07:30,517 --> 00:07:32,686
这很可能是你最感兴趣的地方

145
00:07:32,920 --> 00:07:35,556
对于用户 它就是像姓、名

146
00:07:35,756 --> 00:07:36,823
和邮箱地址一样

147
00:07:37,591 --> 00:07:41,862
这些参数的值通常是简单的类型

148
00:07:42,029 --> 00:07:43,397
日期和时间或布尔值

149
00:07:43,764 --> 00:07:47,034
但有时它们也可以是复杂的类型

150
00:07:48,068 --> 00:07:50,170
参数之后 我们有关系

151
00:07:50,704 --> 00:07:53,140
现在我们先跳过这个话题

152
00:07:53,674 --> 00:07:58,145
然后我们有链接

153
00:07:58,612 --> 00:08:01,982
现在这个URL唯一识别

154
00:07:58,612 --> 00:08:01,982
现在这个URL唯一识别

155
00:08:02,182 --> 00:08:04,818
在这种情况下

156
00:08:04,885 --> 00:08:08,488
我们返回给你的每一个源

157
00:08:09,723 --> 00:08:13,493
它看起来总是这个样子的：

158
00:08:13,727 --> 00:08:15,495
然后版本号是v1

159
00:08:15,562 --> 00:08:19,867
然后源类型是用户

160
00:08:20,234 --> 00:08:21,368
你可以获取它

161
00:08:21,735 --> 00:08:24,872
并获得返回的数据

162
00:08:25,038 --> 00:08:28,242
这里的唯一不同点就是

163
00:08:28,308 --> 00:08:30,310
而不是你团队中的全部用户

164
00:08:32,613 --> 00:08:34,280
所以这是获取数据的两种方式

165
00:08:34,748 --> 00:08:37,551
你可以获取源列表或某一个源

166
00:08:37,683 --> 00:08:40,354
但当然了 你也希望能修改数据

167
00:08:40,554 --> 00:08:43,823
为此我们要使用通用的REST惯例

168
00:08:43,890 --> 00:08:46,226
那么你们中的很多人

169
00:08:46,860 --> 00:08:48,695
你们已经了解如何获取源

170
00:08:49,062 --> 00:08:52,833
要创建一个新的源

171
00:08:53,267 --> 00:08:55,702
要修改源 你要使用PATCH

172
00:08:55,769 --> 00:08:58,805
要删除一个源

173
00:08:59,273 --> 00:09:00,340
那么让我们来试试

174
00:08:59,273 --> 00:09:00,340
那么让我们来试试

175
00:09:00,407 --> 00:09:03,076
假如我们想向你的团队中

176
00:09:03,810 --> 00:09:06,513
现在我们不能直接添加用户

177
00:09:06,780 --> 00:09:08,749
就像App Store Connect自身

178
00:09:08,815 --> 00:09:13,020
你必须邀请用户到你的团队

179
00:09:13,220 --> 00:09:17,124
那么我们要创建一个用户邀请源

180
00:09:17,658 --> 00:09:20,694
看似如此 我们用一个POST

181
00:09:21,228 --> 00:09:24,631
而URL是用户邀请源URL

182
00:09:25,032 --> 00:09:27,968
然后我们需要发送这个用户的数据

183
00:09:28,569 --> 00:09:30,604
现在这个数据看来

184
00:09:30,671 --> 00:09:32,639
就是我们之前获取用户时的数据

185
00:09:32,706 --> 00:09:34,808
但我想指出其中一个重要的不同点

186
00:09:35,275 --> 00:09:39,213
我们有一个类型是用户邀请

187
00:09:39,913 --> 00:09:43,083
Apple会给你所创建的每一个源

188
00:09:43,150 --> 00:09:45,419
因此你不需要在POST中包含它

189
00:09:45,853 --> 00:09:48,856
我们还丢掉了链接

190
00:09:49,089 --> 00:09:50,257
并且我们还丢掉了关系

191
00:09:50,324 --> 00:09:52,693
因为它在本例中并不相关

192
00:09:53,227 --> 00:09:55,562
如果我们运行这个请求

193
00:09:56,063 --> 00:09:59,800
特别是这是一个

194
00:10:00,067 --> 00:10:01,635
这只是一个标准的REST行为

195
00:10:01,702 --> 00:10:04,137
用于告诉你们源已成功创建

196
00:10:05,272 --> 00:10:08,141
我们还包含了完整的源信息

197
00:10:08,208 --> 00:10:11,478
在响应数据中 这个信息很重要

198
00:10:11,612 --> 00:10:15,382
第一 它给你提供了

199
00:10:15,449 --> 00:10:18,218
你很可能稍后会用到它们

200
00:10:18,285 --> 00:10:21,755
因此你可以再返回来操作这个源

201
00:10:22,356 --> 00:10:24,725
同时如果你看一下属性

202
00:10:24,791 --> 00:10:28,829
你可能看到这个响应中的属性

203
00:10:29,630 --> 00:10:33,100
比如 对于用户邀请来说

204
00:10:33,400 --> 00:10:35,302
创建的每一个用户邀请

205
00:10:35,502 --> 00:10:38,438
现在你没有设置它

206
00:10:38,672 --> 00:10:41,175
这就是为什么这个响应数据

207
00:10:41,341 --> 00:10:45,445
它给你展示了

208
00:10:45,512 --> 00:10:47,648
以及适用于这个源的全部规则

209
00:10:49,183 --> 00:10:52,186
现在如果这个用户接受

210
00:10:52,486 --> 00:10:55,956
假如我们稍后要返回

211
00:10:56,323 --> 00:10:58,292
比如 你可以从这里的属性中看到

212
00:10:58,358 --> 00:10:59,993
这个用户有开发者职能

213
00:11:00,661 --> 00:11:03,597
那么让我们修改一下

214
00:11:04,598 --> 00:11:07,868
我们正在修改一个现有的源

215
00:11:08,335 --> 00:11:13,040
这次的URL是

216
00:11:13,774 --> 00:11:17,744
如果你看一下属性

217
00:11:17,811 --> 00:11:19,780
这个请求的意思是修改这个用户

218
00:11:19,847 --> 00:11:22,850
这样他就有开发者和营销人员的职能

219
00:11:23,050 --> 00:11:25,652
我们并不想修改这个用户的其它信息

220
00:11:25,719 --> 00:11:27,888
所以我们就不需要包含其它属性

221
00:11:28,789 --> 00:11:31,658
如果我们运行这个请求

222
00:11:32,426 --> 00:11:34,561
并且我们获得了完整的源陈述

223
00:11:34,795 --> 00:11:37,064
该源包含我们所进行的修改

224
00:11:38,699 --> 00:11:41,235
对于源来说 你最不想做的事

225
00:11:41,301 --> 00:11:43,303
这是其中最简单的操作了

226
00:11:43,370 --> 00:11:46,507
我们只需要对源自链接执行

227
00:11:46,840 --> 00:11:49,343
然后就会获得

228
00:11:49,810 --> 00:11:50,911
如果你熟悉REST

229
00:11:50,978 --> 00:11:54,648
你就会知道编号200系列的

230
00:11:54,882 --> 00:11:56,216
所以API就是在告诉你

231
00:11:56,283 --> 00:11:58,619
用户已经被成功删除了

232
00:11:58,919 --> 00:12:01,588
这次我们不需要包含任意额外数据

233
00:11:58,919 --> 00:12:01,588
这次我们不需要包含任意额外数据

234
00:12:01,655 --> 00:12:04,691
所以我们使用成功响应的

235
00:12:07,060 --> 00:12:09,429
在我们进入下一章节之前

236
00:12:09,496 --> 00:12:11,765
Sehoon Shon上台

237
00:12:11,832 --> 00:12:15,068
如何在现实场景中使用

238
00:12:21,909 --> 00:12:22,910
大家好 谢谢Geoff

239
00:12:24,278 --> 00:12:25,946
大家好

240
00:12:26,013 --> 00:12:28,882
我是TestFlight团队的

241
00:12:28,949 --> 00:12:32,019
给大家做一个

242
00:12:33,287 --> 00:12:37,357
我们会用一个实例来了解

243
00:12:38,292 --> 00:12:40,794
假如我们团队中的某个人

244
00:12:40,861 --> 00:12:42,362
我想找到这个用户

245
00:12:42,429 --> 00:12:44,965
并把这个用户

246
00:12:45,599 --> 00:12:46,633
让我们看一个演示

247
00:13:02,216 --> 00:13:05,285
我们首先要获取团队的全部用户列表

248
00:13:05,352 --> 00:13:08,188
通过向用户源发送GET请求实现

249
00:13:08,255 --> 00:13:10,190
即GET v1/users

250
00:13:10,991 --> 00:13:14,027
这将返回我们团队中全部可用的用户

251
00:13:15,162 --> 00:13:17,297
现在让我们尝试查找我们要找的用户

252
00:13:17,364 --> 00:13:20,934
我们可以通过使用筛选参数

253
00:13:21,235 --> 00:13:24,771
那么这个邮箱地址的筛选参数

254
00:13:24,838 --> 00:13:28,175
匹配JohnAppleseed@mac.com的用户

255
00:13:28,375 --> 00:13:29,643
那么让我们发送这个请求

256
00:13:30,944 --> 00:13:34,448
我们获得了一个响应 其中是邮箱为

257
00:13:36,149 --> 00:13:41,488
现在让我们使用这个用户的ID

258
00:13:42,456 --> 00:13:45,459
即users/ID

259
00:13:46,326 --> 00:13:49,796
这应该会返回用户的实例

260
00:13:51,498 --> 00:13:54,601
我们获得了一个用户名为

261
00:13:55,502 --> 00:13:57,237
因此我们找到了想要查找的用户

262
00:13:57,504 --> 00:13:59,139
让我们尝试移除这个用户

263
00:13:59,206 --> 00:14:02,409
通过向这个用户的自链接

264
00:13:59,206 --> 00:14:02,409
通过向这个用户的自链接

265
00:14:03,410 --> 00:14:05,946
我们会用DELETE替换GET

266
00:14:07,114 --> 00:14:09,483
这应该会移除所匹配ID的用户

267
00:14:13,120 --> 00:14:17,090
我们就得到了204 意味着

268
00:14:17,157 --> 00:14:19,393
因为用户的相关内容已经不存在了

269
00:14:20,294 --> 00:14:24,398
最后 让我们确认一下

270
00:14:24,464 --> 00:14:25,999
通过向自链接

271
00:14:27,267 --> 00:14:29,136
得到了404 NOT FOUND

272
00:14:29,203 --> 00:14:31,371
看来用户确实被移除了

273
00:14:34,575 --> 00:14:37,311
在这个演示中

274
00:14:37,377 --> 00:14:41,949
如何查找用户实例

275
00:14:42,416 --> 00:14:45,118
以及如何通过发送

276
00:14:45,786 --> 00:14:48,755
这也就总结了

277
00:14:49,022 --> 00:14:50,057
使用app源连接API

278
00:14:50,457 --> 00:14:52,626
我把舞台交还给Geoff

279
00:14:59,499 --> 00:15:00,334
谢谢Sehoon

280
00:14:59,499 --> 00:15:00,334
谢谢Sehoon

281
00:15:02,436 --> 00:15:06,773
现在你们了解了如何创建

282
00:15:06,840 --> 00:15:09,076
全部这些不同的源了 感觉像是

283
00:15:09,142 --> 00:15:11,645
全部内容就这些了

284
00:15:11,912 --> 00:15:15,649
但这并不是全部

285
00:15:16,049 --> 00:15:18,051
有时候你并不是对单一源

286
00:15:18,118 --> 00:15:19,453
最感兴趣

287
00:15:19,520 --> 00:15:21,288
而是对它们之间的连接感兴趣

288
00:15:21,889 --> 00:15:25,626
给大家个例子 一定会有帮助

289
00:15:25,726 --> 00:15:27,928
表示你在TestFlight中的

290
00:15:28,428 --> 00:15:30,163
我们还有一个源

291
00:15:30,230 --> 00:15:33,467
它表示可以测试

292
00:15:33,934 --> 00:15:37,037
正如你所了解的

293
00:15:37,671 --> 00:15:40,641
我们如何在API中

294
00:15:41,441 --> 00:15:43,010
我们首先要从获取

295
00:15:43,410 --> 00:15:47,614
执行一个GET v1/beta Groups

296
00:15:48,015 --> 00:15:49,183
若我们看下第一个小组

297
00:15:49,683 --> 00:15:51,852
特别是关系部分

298
00:15:52,252 --> 00:15:54,488
我们可以看到这个小组有三个关系：

299
00:15:54,555 --> 00:15:57,124
app、beta测试人员和构建版本

300
00:15:57,558 --> 00:15:59,493
今天只谈Beta测试人员

301
00:15:59,726 --> 00:16:00,928
所以我们要打开它

302
00:15:59,726 --> 00:16:00,928
所以我们要打开它

303
00:16:01,728 --> 00:16:03,931
我们再次看到了另一个链接部分

304
00:16:04,531 --> 00:16:07,768
这些是与这个beta测试人员关系

305
00:16:07,835 --> 00:16:09,803
在列表中的第一个小组

306
00:16:09,970 --> 00:16:12,773
数组中的每一个小组

307
00:16:13,574 --> 00:16:17,778
这里有两个链接

308
00:16:18,078 --> 00:16:21,548
它是一个URL 表示关系自身

309
00:16:22,649 --> 00:16:26,854
我们用这个URL来操作这个关系

310
00:16:27,754 --> 00:16:28,789
现在让我来解释一下

311
00:16:29,089 --> 00:16:31,658
我们刚才说想在这个小组中

312
00:16:32,092 --> 00:16:34,494
明确下 测试人员

313
00:16:34,862 --> 00:16:36,630
该组已在TestFlight中

314
00:16:36,864 --> 00:16:41,034
我们希望把这些现有测试人员

315
00:16:41,535 --> 00:16:44,271
这个操作以我们现在所掌握的技术

316
00:16:44,338 --> 00:16:46,406
如果你仔细想一下的话 对吧

317
00:16:46,473 --> 00:16:49,009
就像我们并不创建或编辑

318
00:16:49,076 --> 00:16:51,512
并且我们也不会真正编辑这个小组

319
00:16:51,578 --> 00:16:53,514
至少不会编辑小组的属性

320
00:16:53,947 --> 00:16:57,217
那么从概念上说

321
00:16:57,284 --> 00:17:00,087
在这个小组及其相关

322
00:16:57,284 --> 00:17:00,087
在这个小组及其相关

323
00:17:00,287 --> 00:17:02,823
这就需要用到关系自链接

324
00:17:03,457 --> 00:17:04,290
看起来是这样的

325
00:17:04,358 --> 00:17:07,294
我们对关系自链接

326
00:17:08,161 --> 00:17:11,365
若你看一下我们所发送的数据

327
00:17:11,531 --> 00:17:14,501
在本例中是指我们要添加到

328
00:17:15,068 --> 00:17:18,271
那么这个请求的意思是

329
00:17:18,338 --> 00:17:20,007
我们无需包含更多测试人员的信息

330
00:17:20,073 --> 00:17:22,009
因为测试人员已存在于

331
00:17:22,476 --> 00:17:26,313
如果我们运行它 我们就再次获得

332
00:17:26,480 --> 00:17:29,383
也就是API在告诉你

333
00:17:30,217 --> 00:17:31,418
你们中有些人会想

334
00:17:31,485 --> 00:17:33,887
“如果我想把测试人员

335
00:17:33,954 --> 00:17:35,822
答案是以完全相同的方式来实现

336
00:17:35,889 --> 00:17:38,525
要用到同一个URL

337
00:17:38,759 --> 00:17:41,461
你只需要用DELETE方法

338
00:17:43,564 --> 00:17:47,067
再看一下Beta小组

339
00:17:47,734 --> 00:17:51,104
我们把它叫做相关链接

340
00:17:51,505 --> 00:17:54,174
这个URL表示实际的相关数据

341
00:17:54,241 --> 00:17:56,176
在本例中是指这个小组中的测试人员

342
00:17:56,476 --> 00:17:59,913
如果我们执行并获取这个数据

343
00:18:00,180 --> 00:18:01,481
这里的格式

344
00:18:01,548 --> 00:18:05,752
与对v1/betaTesters

345
00:18:05,886 --> 00:18:08,222
唯一不同是我们获得的是

346
00:18:08,655 --> 00:18:10,891
而非TestFlight中的

347
00:18:12,359 --> 00:18:14,795
我想在这里暂停一下

348
00:18:15,229 --> 00:18:16,730
我们得到了该小组的测试人员

349
00:18:16,797 --> 00:18:20,801
当我说“该小组”时 我是指标识符

350
00:18:21,235 --> 00:18:23,303
这个URL会获取

351
00:18:23,604 --> 00:18:25,973
如果我想批量获取

352
00:18:26,039 --> 00:18:29,042
可以使用这个机制

353
00:18:29,376 --> 00:18:31,011
有时候会有些不方便

354
00:18:31,478 --> 00:18:33,614
所以我们还有一种方式获得相关数据

355
00:18:33,680 --> 00:18:36,283
这种方式叫做包含参数

356
00:18:36,350 --> 00:18:39,119
我们对v1/betaGroups

357
00:18:39,520 --> 00:18:43,490
然后我们添加这个查询参数：

358
00:18:43,724 --> 00:18:46,193
这就告诉API

359
00:18:46,260 --> 00:18:50,964
同时也包含每个小组中

360
00:18:53,200 --> 00:18:54,101
它看起来是这样的

361
00:18:54,735 --> 00:18:57,771
我们获得了beta测试人员数组…

362
00:18:58,038 --> 00:19:00,307
如果你查看一下第一个小组中

363
00:18:58,038 --> 00:19:00,307
如果你查看一下第一个小组中

364
00:19:00,374 --> 00:19:03,610
你就会看到一个叫做数据的新部分

365
00:19:04,611 --> 00:19:08,549
包含这个小组中

366
00:19:08,615 --> 00:19:10,217
现在如果你可以看到这里的整个响应

367
00:19:10,284 --> 00:19:14,087
你会在每一个beta测试人员

368
00:19:14,354 --> 00:19:17,624
在这个数组中的每个小组的内部

369
00:19:18,192 --> 00:19:19,726
这只是包含类型和ID

370
00:19:19,793 --> 00:19:22,095
我相信你一定在想

371
00:19:22,362 --> 00:19:25,232
如果我们一直向下

372
00:19:25,499 --> 00:19:27,568
我们还会看到一个叫做包含的新部分

373
00:19:28,135 --> 00:19:31,705
这是一个beta测试人员的数组

374
00:19:32,072 --> 00:19:36,610
再通俗一点说

375
00:19:36,677 --> 00:19:40,514
你通过关系所包含的

376
00:19:41,081 --> 00:19:43,183
然后我们按照类型和ID进行匹配

377
00:19:43,417 --> 00:19:46,186
从而了解哪个测试人员

378
00:19:48,021 --> 00:19:49,523
你可能在想我们为何要这么做

379
00:19:49,590 --> 00:19:52,025
我们有数据部分

380
00:19:52,092 --> 00:19:54,895
我们还有包含部分

381
00:19:55,162 --> 00:19:57,464
这么做是出于很重要的原因

382
00:19:57,531 --> 00:20:01,134
John Appleseed

383
00:19:57,531 --> 00:20:01,134
John Appleseed

384
00:20:01,368 --> 00:20:04,037
我们构建这个的方式是让

385
00:20:04,104 --> 00:20:05,873
在每次响应中只出现一次

386
00:20:05,939 --> 00:20:09,376
无论他出现在多少个小组中

387
00:20:11,311 --> 00:20:13,614
好的 Sehoon现在要回到台上

388
00:20:13,680 --> 00:20:16,717
给大家演示一些

389
00:20:16,783 --> 00:20:17,618
Sehoon

390
00:20:23,457 --> 00:20:24,291
谢谢Geoff

391
00:20:26,627 --> 00:20:29,296
对于这部分的演示

392
00:20:29,363 --> 00:20:32,866
了解如何创建新的beta小组

393
00:20:32,933 --> 00:20:35,636
并了解一下测试人员

394
00:20:35,903 --> 00:20:37,137
让我们看演示吧

395
00:20:46,446 --> 00:20:50,817
我们从创建新的beta小组开始

396
00:20:50,884 --> 00:20:53,587
即v1/betaGroups

397
00:20:54,254 --> 00:20:55,489
当我们创建源时

398
00:20:55,556 --> 00:20:58,125
我们还需要提供有效负载

399
00:20:58,358 --> 00:21:00,260
我们的数据包含beta小组的类型

400
00:20:58,358 --> 00:21:00,260
我们的数据包含beta小组的类型

401
00:21:00,327 --> 00:21:01,595
和一系列属性

402
00:21:01,995 --> 00:21:03,931
因为名称是唯一需要填写的字段

403
00:21:03,997 --> 00:21:05,032
当我们创建小组时

404
00:21:05,899 --> 00:21:09,770
让我们给它取个名字

405
00:21:10,604 --> 00:21:11,772
我现在要发送请求了

406
00:21:13,574 --> 00:21:17,244
我们得到409 CONFLICT

407
00:21:18,579 --> 00:21:22,449
“在本次请求中

408
00:21:22,716 --> 00:21:23,617
在TestFlight中

409
00:21:23,684 --> 00:21:27,421
你不能创建

410
00:21:27,487 --> 00:21:30,524
因此当我们创建beta小组时

411
00:21:31,091 --> 00:21:32,125
我们该如何做呢？

412
00:21:32,192 --> 00:21:34,428
我们可以在有效负载中包含关系…

413
00:21:36,997 --> 00:21:38,732
就像这样 我们现在某个app中的

414
00:21:38,799 --> 00:21:42,102
附带app的数据类型

415
00:21:42,369 --> 00:21:46,206
并且ID识别了beta小组

416
00:21:46,707 --> 00:21:49,343
这就会创建名为

417
00:21:49,409 --> 00:21:51,011
并按照ID链接到某app

418
00:21:52,613 --> 00:21:53,981
让我们重新发送这个请求

419
00:21:54,948 --> 00:21:56,984
得到了201 CREATED响应

420
00:21:57,351 --> 00:21:59,720
在响应中 我们有所生成的ID

421
00:21:59,786 --> 00:22:00,988
让我们复制这个ID

422
00:21:59,786 --> 00:22:00,988
让我们复制这个ID

423
00:22:04,157 --> 00:22:05,993
我们刚创建了名为测试小组的小组

424
00:22:06,159 --> 00:22:08,695
但若你不喜欢我们刚创建的小组

425
00:22:09,463 --> 00:22:11,098
我们可以修改现有小组

426
00:22:11,164 --> 00:22:13,867
通过向这个小组的自链接

427
00:22:15,502 --> 00:22:19,540
我们要发送PATCH

428
00:22:21,909 --> 00:22:25,412
我们还需提供有效负载

429
00:22:25,846 --> 00:22:30,184
看来更像posting的有效负载

430
00:22:30,651 --> 00:22:32,653
以确保我们修改的是正确数据

431
00:22:34,221 --> 00:22:36,290
让我们粘贴beta小组的ID

432
00:22:36,990 --> 00:22:39,526
我们唯一需要修改的信息就是名称

433
00:22:39,893 --> 00:22:42,262
让我们把它重命名为WWDC小组

434
00:22:44,498 --> 00:22:46,366
我要发送请求

435
00:22:46,433 --> 00:22:49,469
现在我们得到了一个200响应

436
00:22:50,737 --> 00:22:54,608
现在我们有了想要的小组

437
00:22:55,242 --> 00:22:59,146
要创建测试人员 得向beta

438
00:23:00,747 --> 00:23:03,684
即v1/betaTesters

439
00:23:05,285 --> 00:23:08,488
我们还需要提供这样的有效负载

440
00:23:09,256 --> 00:23:12,259
它的类型是beta测试人员

441
00:23:12,326 --> 00:23:14,862
我们要创建一名为

442
00:23:15,762 --> 00:23:19,099
同时有一个关系是属于beta小组

443
00:23:19,166 --> 00:23:20,901
这将创建beta测试人员

444
00:23:20,968 --> 00:23:23,270
同时也会分配到beta小组中

445
00:23:24,104 --> 00:23:26,640
那么如果你粘贴

446
00:23:27,174 --> 00:23:30,043
这会把测试人员分配到

447
00:23:32,346 --> 00:23:36,116
得到201 CREATED响应

448
00:23:36,183 --> 00:23:38,118
同时也被分配到了小组中

449
00:23:39,119 --> 00:23:41,288
既然我们已在此

450
00:23:41,688 --> 00:23:44,758
我们需要做的是替换这个属性部分

451
00:23:45,425 --> 00:23:46,660
替换为另一个人的名字

452
00:23:48,061 --> 00:23:51,265
这将会在同一个小组中创建

453
00:23:54,601 --> 00:23:57,504
我们再次获得了

454
00:23:58,238 --> 00:24:00,207
我们刚向小组中添加了两名测试人员

455
00:23:58,238 --> 00:24:00,207
我们刚向小组中添加了两名测试人员

456
00:24:00,807 --> 00:24:04,344
现在让我们确认这两名测试人员

457
00:24:04,411 --> 00:24:05,812
通过发送GET请求实现

458
00:24:07,047 --> 00:24:10,584
我们要发送到beta小组

459
00:24:11,852 --> 00:24:16,423
这个链接/小组ID/betaTesters

460
00:24:17,457 --> 00:24:21,195
这将返回分配给beta小组

461
00:24:21,261 --> 00:24:22,863
并附带指定ID

462
00:24:24,865 --> 00:24:28,135
你可以看到我们刚才添加的

463
00:24:29,236 --> 00:24:31,405
这个响应包含许多信息

464
00:24:31,471 --> 00:24:34,541
包括属性列表以及关系列表

465
00:24:34,875 --> 00:24:37,911
但如果你只关心 比如

466
00:24:38,912 --> 00:24:42,649
我们可以通过使用一个叫做

467
00:24:42,916 --> 00:24:45,018
这将允许我们削减内容主体

468
00:24:45,085 --> 00:24:47,421
我们可以只查看我们想要看到的内容

469
00:24:48,322 --> 00:24:53,293
如果你执行beta测试人员的

470
00:24:55,028 --> 00:24:58,565
正如你所看到的

471
00:24:58,632 --> 00:24:59,533
没有其它内容

472
00:25:00,300 --> 00:25:03,437
我们在这个beta小组中

473
00:25:10,010 --> 00:25:14,181
在这个演示中 我们了解了如何创建

474
00:25:14,248 --> 00:25:16,783
也了解了测试人员和小组间的关系

475
00:25:17,251 --> 00:25:18,385
这就总结了演示

476
00:25:18,452 --> 00:25:21,088
如何通过TestFlight

477
00:25:21,154 --> 00:25:23,257
我要把舞台交还给Geoff 谢谢

478
00:25:29,897 --> 00:25:31,732
再次感谢Sehoon 非常棒

479
00:25:32,633 --> 00:25:33,467
那么…

480
00:25:34,902 --> 00:25:37,905
这就是获取数据、修改数据和关系

481
00:25:37,971 --> 00:25:40,174
这就是API的基本功能

482
00:25:40,507 --> 00:25:42,509
但正如你在Sehoon的

483
00:25:42,876 --> 00:25:46,013
有时候你会犯错误

484
00:25:46,213 --> 00:25:47,281
我们现在要谈点别的

485
00:25:47,347 --> 00:25:51,084
谈谈API如何把这些报错传回给你

486
00:25:52,152 --> 00:25:55,222
任何时候当请求失败时

487
00:25:56,523 --> 00:25:57,958
现在要注意的第一件事

488
00:25:58,358 --> 00:26:01,595
就是我们会发送一个

489
00:25:58,358 --> 00:26:01,595
就是我们会发送一个

490
00:26:01,895 --> 00:26:05,065
表明发生了什么错误

491
00:26:05,132 --> 00:26:06,500
一般来说你只需要得到这个

492
00:26:06,567 --> 00:26:10,771
大部分REST客户端函数库都有

493
00:26:10,838 --> 00:26:11,805
你可以调用它

494
00:26:11,872 --> 00:26:15,242
它会准确地告诉你请求是否成功

495
00:26:15,909 --> 00:26:17,644
但若你想了解更多关于报错的信息

496
00:26:17,711 --> 00:26:19,813
你可以分析一下响应

497
00:26:19,880 --> 00:26:22,382
请求失败后 不会看到那个

498
00:26:22,449 --> 00:26:25,452
而会看到一个报错的属性

499
00:26:25,519 --> 00:26:29,323
它是报错对象的一个数组

500
00:26:29,389 --> 00:26:32,526
每一个都代表

501
00:26:33,427 --> 00:26:35,662
每个报错对象

502
00:26:35,729 --> 00:26:38,632
这个特定的报错

503
00:26:38,699 --> 00:26:41,668
你可能会把它存起来

504
00:26:41,735 --> 00:26:43,737
请把它发送给我们

505
00:26:44,438 --> 00:26:47,074
对你来说更有用的是标题和详情

506
00:26:47,474 --> 00:26:50,310
这两者给你提供了一个英文语言解释

507
00:26:50,377 --> 00:26:53,347
关于发生了什么错误

508
00:26:53,413 --> 00:26:54,515
参数出了一些问题

509
00:26:54,948 --> 00:26:58,485
从详情中我了解到

510
00:26:58,552 --> 00:27:00,787
然后立即看到了

511
00:26:58,552 --> 00:27:00,787
然后立即看到了

512
00:27:01,255 --> 00:27:04,691
这些都是很棒的值

513
00:27:04,758 --> 00:27:05,993
和学习API过程中使用

514
00:27:06,994 --> 00:27:08,896
但你一定不想在代码中用到它们

515
00:27:08,962 --> 00:27:10,898
你不想用这些来中断你的编码

516
00:27:11,164 --> 00:27:13,200
我并不能做出任何承诺说未经允许

517
00:27:13,267 --> 00:27:15,736
我们不会修改这些信息中的文字

518
00:27:17,037 --> 00:27:21,008
对于程序性报错处理

519
00:27:21,341 --> 00:27:24,978
这是一个稳定的机器可读字符串

520
00:27:25,345 --> 00:27:29,550
它有一个分层的值

521
00:27:29,616 --> 00:27:32,753
那么在本例中

522
00:27:32,819 --> 00:27:35,822
通常更具体地说

523
00:27:36,557 --> 00:27:39,059
现在这些代码可以变得很长、很精确

524
00:27:39,593 --> 00:27:41,929
有时候你并不关心精确度

525
00:27:41,995 --> 00:27:44,598
事实上你通常不会这样做

526
00:27:44,665 --> 00:27:47,668
从而你可以在代码中执行前缀匹配

527
00:27:47,734 --> 00:27:51,205
或是精确匹配 取决于你自己的用例

528
00:27:51,772 --> 00:27:53,106
但如果你需要精确匹配

529
00:27:53,173 --> 00:27:55,375
比如 你可以报告返回你自己的用户

530
00:27:55,442 --> 00:27:57,010
并附带发生了哪些错误的清晰说明

531
00:27:57,077 --> 00:27:59,346
我们尽量给你们足够的信息

532
00:28:00,013 --> 00:28:02,950
我们还通过源参数来提供帮助

533
00:28:03,884 --> 00:28:07,087
无论何时只要可能

534
00:28:07,154 --> 00:28:08,555
导致问题发生的报错所在的位置

535
00:28:08,622 --> 00:28:11,325
在这里我可以看到

536
00:28:11,391 --> 00:28:13,460
就是它产生了这个报错

537
00:28:13,994 --> 00:28:17,364
源可以是这样的一个参数

538
00:28:17,431 --> 00:28:21,702
在你发送给我们的JSON数据中

539
00:28:23,403 --> 00:28:25,472
这就是你所要了解的

540
00:28:25,539 --> 00:28:29,209
关于App Store Connect API

541
00:28:29,276 --> 00:28:30,777
和成功发送请求外的全部信息

542
00:28:30,844 --> 00:28:34,715
Julie Richards

543
00:28:35,749 --> 00:28:36,583
Julie

544
00:28:42,089 --> 00:28:42,923
谢谢

545
00:28:45,425 --> 00:28:47,127
大家好 我是Julie

546
00:28:47,194 --> 00:28:49,630
我是App Store Connect团队

547
00:28:50,197 --> 00:28:53,534
今天我在这里要跟大家谈谈

548
00:28:54,501 --> 00:28:59,006
在这点上 你们已经看到了许多

549
00:28:59,072 --> 00:29:00,140
可用的终端的例子

550
00:28:59,072 --> 00:29:00,140
可用的终端的例子

551
00:29:00,674 --> 00:29:03,844
当你准备好测试你的某些新功能时

552
00:29:04,344 --> 00:29:07,881
你首先可能会发送一个

553
00:29:08,882 --> 00:29:12,085
然而 如果你只是要

554
00:29:12,152 --> 00:29:13,954
或把它键入到你的浏览器中

555
00:29:14,354 --> 00:29:17,124
你最终将得到一个这样的响应

556
00:29:18,425 --> 00:29:22,863
正如Geoff所提到的

557
00:29:23,197 --> 00:29:25,933
那就是验证证书

558
00:29:27,568 --> 00:29:30,737
现在这个步骤很有必要 原因有两点

559
00:29:31,505 --> 00:29:36,009
第一 验证证书

560
00:29:36,143 --> 00:29:39,947
毕竟你并不想要全部app

561
00:29:40,514 --> 00:29:44,718
最重要的是这些证书

562
00:29:45,185 --> 00:29:48,822
并确保除你之外

563
00:29:50,924 --> 00:29:54,127
要在你的请求中添加这些证书

564
00:29:54,194 --> 00:29:57,231
你首先需要创建一个API钥匙

565
00:29:57,731 --> 00:29:59,733
然后你要使用那个钥匙

566
00:29:59,800 --> 00:30:05,138
生成令牌

567
00:29:59,800 --> 00:30:05,138
生成令牌

568
00:30:05,873 --> 00:30:08,008
让我们从API钥匙开始说

569
00:30:09,943 --> 00:30:13,447
每个钥匙实际上是一个

570
00:30:14,982 --> 00:30:17,084
私人密钥属于你

571
00:30:17,150 --> 00:30:20,287
用于向令牌中添加唯一署名

572
00:30:22,256 --> 00:30:27,461
公共钥匙将用于

573
00:30:27,528 --> 00:30:30,964
它是由相关联的私人密钥所签署

574
00:30:33,567 --> 00:30:37,971
要创建一个钥匙 你需登录

575
00:30:38,038 --> 00:30:41,742
并导航到一个新的API钥匙标签

576
00:30:42,809 --> 00:30:47,514
你的管理员用户

577
00:30:47,915 --> 00:30:51,919
你可以创建新钥匙 若有些钥匙

578
00:30:53,720 --> 00:30:58,959
每个钥匙都需要被分配

579
00:30:59,026 --> 00:31:01,828
钥匙可以用于哪种API服务

580
00:30:59,026 --> 00:31:01,828
钥匙可以用于哪种API服务

581
00:31:03,697 --> 00:31:08,769
一旦创建 新钥匙会出现在此列表中

582
00:31:08,836 --> 00:31:12,406
这是属于你的部分 也可以下载了

583
00:31:13,674 --> 00:31:15,342
有一个重点需要注意

584
00:31:15,409 --> 00:31:19,046
每个私人密钥只能下载一次

585
00:31:19,980 --> 00:31:22,850
因为Apple不会存储这些钥匙

586
00:31:23,317 --> 00:31:26,253
事实上 你的钥匙

587
00:31:26,320 --> 00:31:29,122
甚至在你决定下载它之前还没有生成

588
00:31:30,190 --> 00:31:32,960
因此你可以认为

589
00:31:33,460 --> 00:31:37,731
它们属于你

590
00:31:39,366 --> 00:31:41,468
同样跟实际的钥匙一样

591
00:31:42,536 --> 00:31:44,338
这些钥匙不会过期

592
00:31:44,771 --> 00:31:48,709
因此如果钥匙丢了或被盗了

593
00:31:48,775 --> 00:31:52,913
对数据的权限 除非通过

594
00:31:53,480 --> 00:31:57,784
为此 保证钥匙的安全

595
00:31:59,186 --> 00:32:01,522
一旦你获得了私人密钥文件

596
00:31:59,186 --> 00:32:01,522
一旦你获得了私人密钥文件

597
00:32:02,089 --> 00:32:04,992
你就可以立即开始生成

598
00:32:05,893 --> 00:32:09,730
现在每一个令牌都需要包含一些信息

599
00:32:10,898 --> 00:32:15,669
首先 你需要添加发行者ID

600
00:32:15,969 --> 00:32:19,473
你可以从新页面的顶部找到这个ID

601
00:32:21,241 --> 00:32:25,145
你还需要添加钥匙的ID

602
00:32:25,746 --> 00:32:29,850
你也可以从这个新页面上

603
00:32:30,350 --> 00:32:33,320
它只针对你所使用的钥匙

604
00:32:36,256 --> 00:32:39,259
每个令牌还将需要一个到期时间戳

605
00:32:39,493 --> 00:32:40,961
正如我之前所提到的那样

606
00:32:41,028 --> 00:32:46,366
你的钥匙不会过期

607
00:32:47,334 --> 00:32:51,405
最后这两个信息都是常量

608
00:32:52,105 --> 00:32:55,843
我的意思是在全部令牌

609
00:32:55,909 --> 00:32:58,846
它们会保持一样的值

610
00:32:59,146 --> 00:33:03,951
第一个是令牌的观众

611
00:32:59,146 --> 00:33:03,951
第一个是令牌的观众

612
00:33:05,419 --> 00:33:11,058
最后 你需要分配或添加算法

613
00:33:11,124 --> 00:33:12,793
用于签署令牌

614
00:33:13,126 --> 00:33:16,563
为此我们选择使用ES256

615
00:33:17,431 --> 00:33:21,301
现在这个算法相对应的是一个

616
00:33:21,602 --> 00:33:23,604
这是我们选择让你们使用的一个算法

617
00:33:23,904 --> 00:33:27,508
但不用担心 你不需要实施这个算法

618
00:33:28,242 --> 00:33:31,945
很幸运的是 JWT提供多个函数库

619
00:33:32,012 --> 00:33:34,281
事实上涵盖了任何一种语言

620
00:33:34,348 --> 00:33:37,885
使得创建和签署这些令牌

621
00:33:39,319 --> 00:33:44,057
我后面的这个例子是用Ruby写的

622
00:33:44,124 --> 00:33:48,662
我要做的就是传递私人密钥的同时

623
00:33:48,729 --> 00:33:52,533
这个编码方法会返回给我

624
00:33:53,967 --> 00:33:57,504
然后你就可以把那个令牌

625
00:33:57,571 --> 00:34:01,074
只需要把它放在一个验证标题内即可

626
00:33:57,571 --> 00:34:01,074
只需要把它放在一个验证标题内即可

627
00:34:03,911 --> 00:34:09,149
现在我们了解了如何创建这些钥匙

628
00:34:09,216 --> 00:34:13,654
向我们的请求中添加令牌

629
00:34:23,130 --> 00:34:25,831
好的 这是那个新API钥匙的页面

630
00:34:26,266 --> 00:34:28,034
我还没有钥匙

631
00:34:28,534 --> 00:34:30,103
那么我要继续并创建一个钥匙

632
00:34:31,471 --> 00:34:34,908
我把它命名为演示

633
00:34:35,576 --> 00:34:38,045
在这里 如果我要选择 比如财务

634
00:34:38,679 --> 00:34:43,116
我就会得到拥有诸如财务报告

635
00:34:43,183 --> 00:34:47,754
但它不会有诸如beta测试人员

636
00:34:48,155 --> 00:34:52,391
我可以添加权限等级或选择管理员

637
00:34:52,525 --> 00:34:55,161
那样我就得到一个

638
00:34:55,629 --> 00:34:58,665
所以我坚持分配给它一个管理员权限

639
00:34:59,566 --> 00:35:03,136
我可以看到

640
00:34:59,566 --> 00:35:03,136
我可以看到

641
00:35:04,271 --> 00:35:08,509
正如我刚才提到的那样

642
00:35:09,109 --> 00:35:11,345
如果我丢了钥匙或意外删除了它

643
00:35:11,411 --> 00:35:13,480
我不能再从这里重新下载它

644
00:35:13,947 --> 00:35:15,015
那么为此

645
00:35:15,082 --> 00:35:18,318
我一定要确保

646
00:35:19,253 --> 00:35:21,488
我准备好了 那么让我们继续并下载

647
00:35:23,223 --> 00:35:26,059
现在我的下载文件夹中已经有了

648
00:35:26,827 --> 00:35:29,029
我可以拉动我们刚才看到的那个脚本

649
00:35:29,863 --> 00:35:33,166
我需要复制发行者ID

650
00:35:37,871 --> 00:35:40,674
这是在你的API钥匙中

651
00:35:41,041 --> 00:35:45,679
并且我还需要复制

652
00:35:49,816 --> 00:35:51,685
一旦搞好这些ID

653
00:35:51,752 --> 00:35:55,422
就会从我的下载文件夹中

654
00:35:55,489 --> 00:35:57,124
我要生成一个新令牌

655
00:35:58,458 --> 00:36:01,361
如果我拉起终端

656
00:35:58,458 --> 00:36:01,361
如果我拉起终端

657
00:36:02,296 --> 00:36:04,331
我可以curl那个app终端

658
00:36:06,133 --> 00:36:09,603
正如我们预计的那样

659
00:36:10,237 --> 00:36:12,139
因此让我们调用我的脚本

660
00:36:18,078 --> 00:36:19,379
我得到了一个新令牌

661
00:36:20,113 --> 00:36:25,419
因此我可以把那个令牌

662
00:36:29,256 --> 00:36:33,727
通过把它放在一个验证标题中

663
00:36:38,332 --> 00:36:40,200
然后我得到了app列表

664
00:36:45,672 --> 00:36:49,042
正如你所看到的

665
00:36:49,109 --> 00:36:53,447
我就能获取API的权限

666
00:36:54,047 --> 00:36:55,482
谢谢 舞台交给Geoff

667
00:37:02,589 --> 00:37:03,590
好的 谢谢Julie

668
00:37:04,591 --> 00:37:05,492
很酷 对吗？

669
00:37:06,460 --> 00:37:08,729
这就是权限和验证

670
00:37:08,996 --> 00:37:10,631
现在还剩下几分钟时间

671
00:37:10,697 --> 00:37:13,367
我想谈谈API的一些最佳使用范例

672
00:37:14,368 --> 00:37:17,237
我们要从那些钥匙说起

673
00:37:17,304 --> 00:37:20,474
那些钥匙属于你

674
00:37:20,541 --> 00:37:23,143
无论是谁 只要拥有钥匙

675
00:37:23,477 --> 00:37:27,314
因此理想地说 你要把钥匙

676
00:37:27,381 --> 00:37:29,116
你的代码要在外面进行查看

677
00:37:29,183 --> 00:37:33,320
并在存储器中使用 永远不要把它们

678
00:37:33,654 --> 00:37:35,455
如果你必须把钥匙存储在磁盘上

679
00:37:35,789 --> 00:37:38,559
请确保你非常认真地检查了

680
00:37:39,026 --> 00:37:41,929
当然 如果你有任何理由认为

681
00:37:41,995 --> 00:37:46,033
请立即登录App Store Connect

682
00:37:47,467 --> 00:37:50,904
我还想谈谈你从钥匙中创建的令牌

683
00:37:50,971 --> 00:37:53,073
现在没有任何理由

684
00:37:53,140 --> 00:37:54,308
要求你在每次请求时

685
00:37:54,374 --> 00:37:57,578
事实上 你会在代码中和我们这端

686
00:37:57,644 --> 00:38:00,113
如果你不断重复使用那些令牌

687
00:37:57,644 --> 00:38:00,113
如果你不断重复使用那些令牌

688
00:38:00,514 --> 00:38:02,182
通常这是一件很简单的事 对吧

689
00:38:02,249 --> 00:38:04,718
你只需要在脚本顶部生成一个令牌

690
00:38:04,785 --> 00:38:06,954
在每次请求时发送令牌 直到完成

691
00:38:07,287 --> 00:38:11,258
我们可以让你控制到期时间

692
00:38:11,325 --> 00:38:14,294
它应该持续多久的人

693
00:38:14,361 --> 00:38:16,530
并且不会比所需要的时间长太多

694
00:38:17,865 --> 00:38:20,667
当然 有些进程的执行

695
00:38:20,734 --> 00:38:22,736
或需要连续不断地运行

696
00:38:22,803 --> 00:38:24,638
你在编码结构上要有一点不一样了

697
00:38:25,205 --> 00:38:28,509
也许你会生成一个20分钟的令牌

698
00:38:28,942 --> 00:38:31,912
然后把它丢掉并在旧令牌到期之前

699
00:38:31,979 --> 00:38:33,247
比如 每18分钟换一次

700
00:38:33,547 --> 00:38:35,382
那样你会最大程度上重复使用令牌

701
00:38:35,449 --> 00:38:38,685
从而获得最佳性能

702
00:38:40,721 --> 00:38:41,989
接下来我要谈的是

703
00:38:42,055 --> 00:38:43,824
响应中所包含的链接

704
00:38:44,224 --> 00:38:45,559
今天我们谈到了这些

705
00:38:45,626 --> 00:38:48,128
作为自文档的一种漂亮的形式

706
00:38:48,195 --> 00:38:51,231
一种可以让你查看数据并了解

707
00:38:51,298 --> 00:38:52,799
但这并不是唯一原因

708
00:38:52,933 --> 00:38:55,903
实际上你的代码可以使用它们

709
00:38:56,303 --> 00:38:59,540
当你执行多步骤进程时

710
00:38:59,606 --> 00:39:01,675
请把我提供的链接从响应中拿出来

711
00:38:59,606 --> 00:39:01,675
请把我提供的链接从响应中拿出来

712
00:39:01,742 --> 00:39:04,011
并把它用在进程的下一个部分

713
00:39:04,244 --> 00:39:06,980
这有两个好处 一是它会让你的代码

714
00:39:07,047 --> 00:39:10,117
对于API的不同部分变得更加通用

715
00:39:10,350 --> 00:39:13,453
二是当v2 API

716
00:39:13,520 --> 00:39:17,224
会减少你调整和修改代码的工作量

717
00:39:18,392 --> 00:39:20,694
最后我想谈谈文档

718
00:39:22,029 --> 00:39:24,631
我们今天提到过这个API的一致性

719
00:39:24,698 --> 00:39:27,134
我们非常关心这个问题

720
00:39:27,201 --> 00:39:31,104
可以做些什么

721
00:39:31,505 --> 00:39:34,241
但是 当然了

722
00:39:34,575 --> 00:39:36,310
你已看到一个例子

723
00:39:36,376 --> 00:39:39,479
我们必须创建一个邀请

724
00:39:39,847 --> 00:39:41,782
因此文档是你了解这些信息的资源

725
00:39:41,849 --> 00:39:44,084
它会告诉你源可以做什么

726
00:39:44,151 --> 00:39:47,654
有哪些可用的操作

727
00:39:49,256 --> 00:39:50,924
这就是App Store Connect API

728
00:39:51,325 --> 00:39:53,727
它是一致的标准REST API

729
00:39:54,027 --> 00:39:58,031
我们对此感到非常激动

730
00:39:58,098 --> 00:40:00,267
就是我们对它的设计非常灵活

731
00:39:58,098 --> 00:40:00,267
就是我们对它的设计非常灵活

732
00:40:00,334 --> 00:40:04,271
你可以把App Store Connect

733
00:40:04,338 --> 00:40:07,641
放到你的工作流程中

734
00:40:07,875 --> 00:40:09,743
我们真的非常期待你们的成果

735
00:40:10,143 --> 00:40:12,579
这个夏天所有app开发者都能用到它

736
00:40:13,747 --> 00:40:15,716
我知道你们大家一定会有问题

737
00:40:15,782 --> 00:40:18,252
请到我们的App Store Connect

738
00:40:18,318 --> 00:40:20,220
演讲结束后 我就会去那里

739
00:40:20,287 --> 00:40:21,522
我们可以回答你们的问题

740
00:40:21,588 --> 00:40:23,891
我们明天下午1点也有一个实验室

741
00:40:24,258 --> 00:40:26,593
请大家同时了解一下

742
00:40:26,660 --> 00:40:27,694
如果你昨天没去参加

743
00:40:28,095 --> 00:40:31,465
它讲了更多关于API

744
00:40:31,932 --> 00:40:34,635
请收藏这个链接

745
00:40:34,701 --> 00:40:35,903
会在这里发布文档

746
00:40:36,436 --> 00:40:38,305
谢谢大家 稍后在实验室见
