1
00:00:06,039 --> 0:00:09,910
（App内购买项目

2
00:00:10,377 --> 0:00:11,211
早上好！

3
00:00:14,615 --> 0:00:18,519
欢迎参加App内购买项目

4
00:00:18,852 --> 0:00:22,055
我是Dana DuBois

5
00:00:24,057 --> 0:00:25,726
我们今天要谈很多内容

6
00:00:26,126 --> 0:00:29,930
首先从StoreKit的新功能

7
00:00:30,330 --> 0:00:32,366
自去年的演讲起

8
00:00:33,600 --> 0:00:35,536
然后我要把舞台交给

9
00:00:35,602 --> 0:00:37,638
她将跟大家具体介绍

10
00:00:37,704 --> 0:00:39,940
服务器到服务器通知

11
00:00:40,007 --> 0:00:43,544
以及如何确保你在后台

12
00:00:43,610 --> 0:00:47,080
拥有订阅客户的最新信息？

13
00:00:49,149 --> 0:00:52,386
接着Manjeet会上台介绍

14
00:00:52,452 --> 0:00:54,288
即订阅周期中的计费事件

15
00:00:55,322 --> 0:00:56,156
最后

16
00:00:56,590 --> 0:00:58,358
他会跟大家介绍

17
00:00:58,425 --> 0:01:00,060
如何减少无意识流失

18
00:00:58,425 --> 0:01:00,060
如何减少无意识流失

19
00:01:00,127 --> 0:01:03,497
并把订阅客户留在你的服务中

20
00:01:05,432 --> 0:01:06,266
那么首先

21
00:01:07,668 --> 0:01:08,769
StoreKit中有哪些新功能？

22
00:01:10,270 --> 0:01:13,073
嗯 今年春季我们引入了订阅优惠

23
00:01:14,541 --> 0:01:18,078
订阅优惠是我们引入的一个新功能

24
00:01:19,246 --> 0:01:23,450
为你提供了一个工具

25
00:01:23,750 --> 0:01:27,921
以及重获曾使用过此服务的订阅者

26
00:01:29,056 --> 0:01:30,357
你可以通过给每个订阅

27
00:01:31,124 --> 0:01:36,663
设置最多十个不同的激活的优惠实现

28
00:01:36,730 --> 0:01:39,833
那将会打折或免费获得服务

29
00:01:39,900 --> 0:01:41,635
你可以提供给你的客户们

30
00:01:43,370 --> 0:01:46,340
你的app要决定

31
00:01:46,707 --> 0:01:47,975
完全由你做主

32
00:01:48,709 --> 0:01:51,178
这是一个很棒的功能

33
00:01:51,245 --> 0:01:54,114
实际上今天稍后会有一场

34
00:01:54,181 --> 0:01:55,516
就在这里 下午两点

35
00:01:56,016 --> 0:02:00,621
如果你的服务中有订阅功能

36
00:01:56,016 --> 0:02:00,621
如果你的服务中有订阅功能

37
00:02:02,122 --> 0:02:03,123
（SKStoreFront）

38
00:02:03,190 --> 0:02:04,925
StoreKit中还有哪些

39
00:02:05,459 --> 0:02:09,162
今年夏季我们要宣布

40
00:02:09,863 --> 0:02:14,668
SKStorefront是我们

41
00:02:15,035 --> 0:02:18,105
用户会在这里设置

42
00:02:21,175 --> 0:02:25,112
从而向客户呈现正确的内容

43
00:02:25,179 --> 0:02:27,881
你想向全世界的客户们推销什么？

44
00:02:27,948 --> 0:02:32,519
你可以用SKStorefront

45
00:02:32,586 --> 0:02:34,588
在他们的设备上获取特定的范围

46
00:02:35,856 --> 0:02:39,459
这与App Store内容的

47
00:02:39,526 --> 0:02:44,965
并且这个API为你提供的是当前

48
00:02:46,667 --> 0:02:47,634
有一件事你要记住

49
00:02:47,701 --> 0:02:53,574
就是这个API会为那个商店

50
00:02:53,974 --> 0:02:55,409
并且它可以随时间发生变更

51
00:02:55,475 --> 0:02:57,444
因此你需要思考一些东西

52
00:02:57,511 --> 0:02:59,813
当你与

53
00:03:00,380 --> 0:03:03,016
那么让我们打开代码

54
00:03:06,119 --> 0:03:08,689
如果你现正在连接StoreKit

55
00:03:08,755 --> 0:03:11,925
SKPaymentQueue上

56
00:03:12,593 --> 0:03:15,696
我们给那个增加了一个功能

57
00:03:16,196 --> 0:03:20,033
即给商店获取一个

58
00:03:20,100 --> 0:03:22,603
即.storefront

59
00:03:23,504 --> 0:03:25,839
因为它会发生变更

60
00:03:25,906 --> 0:03:28,976
它可以是空值 虽然不太可能

61
00:03:29,042 --> 0:03:31,011
那么你需要在你的app中检查一下

62
00:03:31,078 --> 0:03:32,646
并确保没问题

63
00:03:34,548 --> 0:03:38,952
一旦你拥有那个商店

64
00:03:39,019 --> 0:03:43,323
它是三个字母的代码 ISO标准值

65
00:03:43,390 --> 0:03:44,758
适用于全世界的地区及国家

66
00:03:44,825 --> 0:03:47,461
并且那将准确地告诉你

67
00:03:47,528 --> 0:03:48,562
那台设备上的App Store

68
00:03:49,129 --> 0:03:50,097
这是真的

69
00:03:50,163 --> 0:03:53,000
然后那将允许你获取国家代码

70
00:03:53,066 --> 0:03:56,703
并向客户们推销正确的内容

71
00:03:57,237 --> 0:03:59,406
但正如我所说过的

72
00:03:59,706 --> 0:04:01,508
那么让我们再深入查看代码

73
00:03:59,706 --> 0:04:01,508
那么让我们再深入查看代码

74
00:04:01,575 --> 0:04:03,110
了解你还需要思考什么东西

75
00:04:05,846 --> 0:04:07,681
在这里我们有一段示例代码

76
00:04:07,748 --> 0:04:10,784
在这里你会获取

77
00:04:11,118 --> 0:04:13,787
把它传进来

78
00:04:13,854 --> 0:04:17,791
然后尝试决定是否应该取出元数据

79
00:04:18,058 --> 0:04:19,793
执行一个SKProduct请求

80
00:04:19,860 --> 0:04:22,362
以决定是否应该显示那个内容

81
00:04:22,896 --> 0:04:23,730
那么…

82
00:04:23,997 --> 0:04:29,102
开发人员所要做的就是

83
00:04:29,703 --> 0:04:34,641
并执行一个调用

84
00:04:35,142 --> 0:04:38,178
然后你可以在这里看到

85
00:04:38,245 --> 0:04:40,080
你要调用shouldShow

86
00:04:40,147 --> 0:04:41,381
如果它返回真

87
00:04:42,149 --> 0:04:44,585
把那个标识符添加到

88
00:04:44,651 --> 0:04:46,787
你即将做出SKProduct

89
00:04:47,154 --> 0:04:49,857
你应该在执行SKProduct

90
00:04:49,923 --> 0:04:52,626
因为如果你不推销那个产品

91
00:04:52,693 --> 0:04:57,197
那么不提取产品元数据会更有效率

92
00:05:00,133 --> 0:05:02,436
但正如我刚说过的那样

93
00:05:02,503 --> 0:05:05,305
实际上用户可以切换账户

94
00:05:05,372 --> 0:05:08,141
或甚至可能会在同一个账户内

95
00:05:08,208 --> 0:05:10,844
进入App Store

96
00:05:10,911 --> 0:05:12,513
开发人员们总是会这样做

97
00:05:12,846 --> 0:05:16,517
因为他们真的想了解世界不同地区中

98
00:05:16,583 --> 0:05:18,151
了解它看起来是什么样子

99
00:05:18,218 --> 0:05:19,953
在App Store中

100
00:05:20,020 --> 0:05:22,489
因此我们向确保你在运行的app中

101
00:05:22,556 --> 0:05:23,757
拥有最新的信息

102
00:05:23,824 --> 0:05:30,163
因此在SKPayment

103
00:05:30,230 --> 0:05:32,699
新的paymentQueueDidChange事件

104
00:05:33,300 --> 0:05:34,835
它会传入付款队列

105
00:05:35,202 --> 0:05:37,271
当你得到它之后 进入

106
00:05:37,337 --> 0:05:39,706
并获得一个新值 关于那是哪个商店

107
00:05:40,073 --> 0:05:40,908
然后再一次…

108
00:05:41,508 --> 0:05:42,342
它是一个新商店

109
00:05:42,409 --> 0:05:44,344
那么你想重新加载

110
00:05:45,245 --> 0:05:46,647
特定于那个新商店的全部内容

111
00:05:46,713 --> 0:05:48,282
实际上你可能拥有不同的内容

112
00:05:48,348 --> 0:05:51,285
你想根据用户所在的位置进行推销

113
00:05:54,488 --> 0:05:55,989
那么再一次调用

114
00:05:56,056 --> 0:05:59,593
决定你是否应该为它提取产品信息

115
00:06:00,661 --> 0:06:03,597
那么当你正在执行购买时

116
00:06:04,398 --> 0:06:07,935
你推销了一些内容 用户即将购买它

117
00:06:08,202 --> 0:06:09,536
然后通常一切都很顺利

118
00:06:09,603 --> 0:06:12,306
但是如果用户实际上在一个

119
00:06:12,372 --> 0:06:13,740
与他们的设备所设定的地区

120
00:06:13,807 --> 0:06:18,178
付款队列可能会改变商店

121
00:06:18,245 --> 0:06:19,546
在交易中间

122
00:06:20,280 --> 0:06:22,416
那么我们为你提供了一个

123
00:06:22,749 --> 0:06:25,485
它可以让你监测

124
00:06:25,853 --> 0:06:27,988
shouldContinue:

125
00:06:28,355 --> 0:06:30,123
这是你进行复查的机会

126
00:06:30,624 --> 0:06:33,560
我是否应该允许这次购买

127
00:06:33,961 --> 0:06:36,864
再一次使用那个

128
00:06:36,930 --> 0:06:39,633
在那里你监测了全部产品标识符

129
00:06:39,700 --> 0:06:42,870
并且你明白那些产品

130
00:06:43,537 --> 0:06:46,640
如果它返回真 就允许付款继续

131
00:06:47,407 --> 0:06:50,310
为了确保实现最佳用户体验

132
00:06:51,078 --> 0:06:55,115
我们希望它的返回速度要快

133
00:06:55,182 --> 0:06:58,252
在paymentQueue:

134
00:06:58,685 --> 0:07:01,288
你应该把这个信息缓存到你的设备上

135
00:06:58,685 --> 0:07:01,288
你应该把这个信息缓存到你的设备上

136
00:07:01,355 --> 0:07:05,592
地区内可用的产品

137
00:07:05,659 --> 0:07:09,796
那样你可以很快地返回

138
00:07:09,863 --> 0:07:11,798
或者如果你返回否

139
00:07:11,865 --> 0:07:16,303
实际上你可以通知用户

140
00:07:17,337 --> 0:07:20,807
那么正如我所说过的

141
00:07:22,142 --> 0:07:23,076
那么你该怎么做呢？

142
00:07:23,377 --> 0:07:25,045
嗯 如果发生这种情况

143
00:07:25,112 --> 0:07:28,282
在你的paymentQueue:

144
00:07:28,749 --> 0:07:32,219
我们将返回一个

145
00:07:32,553 --> 0:07:35,289
它会通知你说你刚刚告诉我们

146
00:07:35,355 --> 0:07:38,292
你不应该允许此交易

147
00:07:38,358 --> 0:07:41,161
并且在这里你有机会呈现一个对话框

148
00:07:41,495 --> 0:07:42,329
或者…

149
00:07:42,696 --> 0:07:44,364
推销一些其它

150
00:07:44,431 --> 0:07:46,400
可能与新商店中的内容相等值的内容

151
00:07:46,767 --> 0:07:48,936
显示一个警告 更新UI

152
00:07:49,002 --> 0:07:50,771
做一些此时此刻你需要做的操作

153
00:07:52,739 --> 0:07:54,541
那么这就是

154
00:07:55,008 --> 0:07:56,376
（App预定）

155
00:07:56,443 --> 0:07:57,711
我们还引入了什么新功能？

156
00:07:58,278 --> 0:07:59,112
嗯…

157
00:08:01,048 --> 0:08:06,887
在iOS 11/11.2以及tvOS 11.2

158
00:08:06,954 --> 0:08:08,789
我们引入了app预定

159
00:08:10,224 --> 0:08:13,660
这是一个所有开发人员都会使用的

160
00:08:13,727 --> 0:08:14,628
世界各地

161
00:08:14,695 --> 0:08:18,065
以便在app在商店内上线之前

162
00:08:18,732 --> 0:08:19,666
我们要很激动地宣布

163
00:08:19,733 --> 0:08:22,636
今年我们引入了

164
00:08:22,703 --> 0:08:25,439
因此你可以直接在Watch中

165
00:08:25,506 --> 0:08:27,040
并提前引起用户们的兴趣

166
00:08:27,107 --> 0:08:30,077
比如可以让他们进行预订

167
00:08:30,811 --> 0:08:32,980
但我们今年还做了另一件事

168
00:08:33,380 --> 0:08:34,248
即将发布

169
00:08:34,313 --> 0:08:37,083
我们将在app收据内暗示

170
00:08:37,618 --> 0:08:40,254
app是否是作为预订所进行的购买

171
00:08:40,320 --> 0:08:45,259
因此你会了解哪些客户预订了app

172
00:08:45,592 --> 0:08:46,927
并且你可以用于…

173
00:08:48,562 --> 0:08:51,398
给他们发送很棒的信息

174
00:08:51,465 --> 0:08:53,767
或者如果你想解锁一些附加内容

175
00:08:53,834 --> 0:08:56,036
作为对某些最佳客户的回馈

176
00:08:56,103 --> 0:08:58,772
你也可以使用收据中的那个信息

177
00:08:59,039 --> 0:09:04,378
还有一件关于收据的信息 即它将

178
00:08:59,039 --> 0:09:04,378
还有一件关于收据的信息 即它将

179
00:09:04,444 --> 0:09:06,480
时光倒流 收据中都可以使用此功能

180
00:09:09,583 --> 0:09:12,319
那么这些是自去年演讲以来

181
00:09:12,386 --> 0:09:14,454
关于StoreKit和

182
00:09:15,022 --> 0:09:17,858
接下来我要把舞台

183
00:09:17,925 --> 0:09:20,794
她将为大家谈谈

184
00:09:21,395 --> 0:09:22,229
Tori？

185
00:09:22,296 --> 0:09:27,568
（服务器到服务器通知）

186
00:09:30,737 --> 0:09:31,572
大家好

187
00:09:31,638 --> 0:09:34,474
我叫Tori 今天能来到这里

188
00:09:34,541 --> 0:09:37,110
我要跟大家分享服务器到服务器通知

189
00:09:38,145 --> 0:09:39,346
我们有一些新功能

190
00:09:39,413 --> 0:09:42,149
我们想引入服务器到服务器通知中

191
00:09:42,216 --> 0:09:45,519
并且我想做一次深入的沟通

192
00:09:45,586 --> 0:09:48,155
来有效地监控你的订阅事件

193
00:09:48,589 --> 0:09:50,858
但在此之前

194
00:09:50,924 --> 0:09:51,992
首先让我们来看看

195
00:09:52,059 --> 0:09:54,528
什么是服务器到服务器通知

196
00:09:54,595 --> 0:09:57,331
以及如何设置服务器来接收这些通知

197
00:09:58,532 --> 0:10:00,834
（什么是服务器到服务器通知？）

198
00:09:58,532 --> 0:10:00,834
（什么是服务器到服务器通知？）

199
00:10:01,635 --> 0:10:05,205
那么服务器到服务器通知

200
00:10:05,272 --> 0:10:09,042
是我们通过JSON串从服务器

201
00:10:09,510 --> 0:10:11,812
你可以通过它们的曾用名识别它们

202
00:10:11,879 --> 0:10:13,814
statusUpdateNotifications

203
00:10:14,314 --> 0:10:17,651
服务器到服务器通知对于

204
00:10:17,718 --> 0:10:20,721
在你的订阅事件上

205
00:10:20,988 --> 0:10:25,526
用于重获客户 比如订阅优惠

206
00:10:26,460 --> 0:10:28,028
一旦你决定了你想在那个终端

207
00:10:28,095 --> 0:10:31,064
接收服务器到服务器通知

208
00:10:31,131 --> 0:10:34,301
你所要做的就是从那个终端

209
00:10:34,368 --> 0:10:38,472
表明已成功接收信息

210
00:10:39,139 --> 0:10:42,509
然而如果你不返回200响应

211
00:10:42,576 --> 0:10:46,947
我们将最多重试三次

212
00:10:48,815 --> 0:10:50,784
一旦你已经确定了这个终端

213
00:10:50,851 --> 0:10:53,220
你首先要在App Store

214
00:10:53,587 --> 0:10:56,757
你可以在你app的app信息页上

215
00:10:57,024 --> 0:10:59,660
在订阅状态URL部分

216
00:10:59,726 --> 0:11:01,895
（设置你的终端）

217
00:10:59,726 --> 0:11:01,895
（设置你的终端）

218
00:11:03,096 --> 0:11:06,099
除了在App Store

219
00:11:06,166 --> 0:11:10,237
当然还有连接必须遵从的安全性要求

220
00:11:10,304 --> 0:11:13,473
便于你成功地接收这些通知

221
00:11:13,807 --> 0:11:16,043
基本上 总的来说就是

222
00:11:16,109 --> 0:11:18,579
连接必须遵守app传输安全条款

223
00:11:18,645 --> 0:11:21,014
或ATS

224
00:11:21,515 --> 0:11:22,983
它意味着很多事

225
00:11:23,550 --> 0:11:27,921
首先必须由一个受信任的认证机构

226
00:11:27,988 --> 0:11:29,156
（设置服务器）

227
00:11:29,223 --> 0:11:34,661
Transport Layer Securit版本

228
00:11:35,529 --> 0:11:38,365
你必须使用

229
00:11:38,866 --> 0:11:41,702
并且证书必须通过

230
00:11:41,768 --> 0:11:45,372
SHA-256及以上的算法

231
00:11:46,573 --> 0:11:48,141
我希望通过全部这些信息

232
00:11:48,208 --> 0:11:49,309
你会更好地理解

233
00:11:49,376 --> 0:11:51,778
什么是服务器到服务器通知

234
00:11:51,845 --> 0:11:53,280
以及如何设置它们

235
00:11:53,947 --> 0:11:55,349
如果要了解更多信息

236
00:11:55,415 --> 0:11:58,919
请在developer.apple.com上

237
00:11:58,986 --> 0:12:00,954
查询statusUpdateNotifications

238
00:11:58,986 --> 0:12:00,954
查询statusUpdateNotifications

239
00:12:05,125 --> 0:12:08,362
现在我们已经了解了

240
00:12:08,428 --> 0:12:09,763
以及如何接收它们

241
00:12:09,830 --> 0:12:12,399
现在我要很激动地分享一些

242
00:12:12,466 --> 0:12:14,101
我们引入到服务器到服务器通知中的

243
00:12:14,168 --> 0:12:16,770
新功能和新通知类型

244
00:12:17,504 --> 0:12:19,740
那么当我们考虑

245
00:12:19,806 --> 0:12:21,642
要添加到通知中的一些新功能时

246
00:12:21,708 --> 0:12:23,911
我们查看了一下

247
00:12:23,977 --> 0:12:25,479
当前通知中的收据字段

248
00:12:25,846 --> 0:12:28,148
最新收据和最新收据信息

249
00:12:28,749 --> 0:12:31,518
我们注意到这些收据 虽然有用

250
00:12:31,585 --> 0:12:35,088
但仅提供了app内最新购买的信息

251
00:12:35,389 --> 0:12:38,158
因此我们就思考如何让它变的更有用

252
00:12:38,225 --> 0:12:40,827
如果我们可以提供完整的订阅历史

253
00:12:40,894 --> 0:12:43,697
当我们给你发送

254
00:12:44,231 --> 0:12:47,401
为此 我们对服务器到服务器通知

255
00:12:47,467 --> 0:12:49,369
引入了统一收据

256
00:12:52,639 --> 0:12:56,677
（统一收据）

257
00:12:56,743 --> 0:12:59,746
那么回顾一下 统一收据包含

258
00:12:59,813 --> 0:13:02,282
从订阅服务中进行订阅购买的历史

259
00:12:59,813 --> 0:13:02,282
从订阅服务中进行订阅购买的历史

260
00:13:02,649 --> 0:13:05,719
以前 这个非常有价值的信息

261
00:13:05,786 --> 0:13:08,422
只能通过点击

262
00:13:09,356 --> 0:13:11,892
目前通知中的两个收据字段

263
00:13:11,959 --> 0:13:14,228
最新收据和最新收据信息

264
00:13:14,294 --> 0:13:17,064
提供一个加密和解密交易型收据

265
00:13:17,130 --> 0:13:18,799
关于app内的最新购买

266
00:13:19,233 --> 0:13:20,200
从秋季开始

267
00:13:20,267 --> 0:13:23,937
你将会在服务器到服务器通知中

268
00:13:24,605 --> 0:13:27,441
我们决定把它叫做统一收据

269
00:13:27,508 --> 0:13:29,343
它将包含几乎全部

270
00:13:29,409 --> 0:13:31,678
你期待从统一收据中获取的一切信息

271
00:13:33,947 --> 0:13:37,518
通过在服务器到服务器通知中

272
00:13:37,584 --> 0:13:38,519
在大多数情况下

273
00:13:38,585 --> 0:13:42,456
这将使最新收据和最新收据信息

274
00:13:43,857 --> 0:13:47,895
然而有一个重要警告

275
00:13:48,395 --> 0:13:50,364
我们为你生成的这个收据

276
00:13:50,430 --> 0:13:54,735
并没有绑定设备上安装的特定app

277
00:13:54,801 --> 0:13:56,904
就和你平时

278
00:13:56,970 --> 0:13:58,205
购买之后收到的收据一样

279
00:13:58,739 --> 0:14:02,743
为此 收据应该要一直保存在

280
00:13:58,739 --> 0:14:02,743
为此 收据应该要一直保存在

281
00:14:02,809 --> 0:14:05,379
永远不要保存在本地设备上

282
00:14:05,445 --> 0:14:07,080
（未绑定app的特定安装

283
00:14:08,348 --> 0:14:09,416
那么 把它放在一边

284
00:14:09,483 --> 0:14:11,518
让我们看看你可以从

285
00:14:11,585 --> 0:14:14,688
服务器到服务器通知中的统一收据中

286
00:14:15,422 --> 0:14:18,759
你从这个JSON对象中

287
00:14:19,159 --> 0:14:22,796
这是一个加密统一收据

288
00:14:22,863 --> 0:14:25,966
稍后你可以用它点击验证收据

289
00:14:26,033 --> 0:14:27,000
如果你需要的话

290
00:14:27,868 --> 0:14:30,103
你还将发现最新收据信息

291
00:14:30,671 --> 0:14:34,474
它包含针对你的订阅服务

292
00:14:34,541 --> 0:14:36,009
其中含有与之相关的元数据

293
00:14:36,076 --> 0:14:38,679
用于帮助你追踪你的订阅者身上

294
00:14:38,745 --> 0:14:39,646
（统一收据）

295
00:14:39,713 --> 0:14:41,849
你还将发现待决续订信息

296
00:14:42,115 --> 0:14:43,517
它包含

297
00:14:43,584 --> 0:14:46,086
针对你的订阅的即将到来的续订信息

298
00:14:46,153 --> 0:14:48,922
比如客户是否处于价格上涨的流程中

299
00:14:48,989 --> 0:14:51,091
或者他们是否进入了计费重试周期

300
00:14:51,892 --> 0:14:54,161
我们还将包含收据状态

301
00:14:54,228 --> 0:14:56,396
以及收据所生成的环境

302
00:14:56,463 --> 0:14:58,465
要么是沙盒 要么是生成

303
00:14:59,433 --> 0:15:01,235
我们选择以此方式命名字段

304
00:14:59,433 --> 0:15:01,235
我们选择以此方式命名字段

305
00:15:01,301 --> 0:15:04,438
因为这反映了你可以从验证收据中

306
00:15:04,771 --> 0:15:07,641
希望你可以在那里

307
00:15:07,708 --> 0:15:10,377
从而让交易变得更简单

308
00:15:11,712 --> 0:15:12,546
然而…

309
00:15:12,980 --> 0:15:17,751
最新收据信息将仅限于

310
00:15:17,818 --> 0:15:20,053
那么如果你需要更多信息

311
00:15:20,120 --> 0:15:24,157
你可以通过所提供的加密收据

312
00:15:25,459 --> 0:15:28,095
让我们看看当前有哪些通知类型

313
00:15:28,462 --> 0:15:30,797
目前有四种现有的通知类型

314
00:15:30,864 --> 0:15:33,133
初次购买 交互式续订

315
00:15:33,200 --> 0:15:35,903
变更续订偏好以及取消

316
00:15:35,969 --> 0:15:37,538
我们又增加了四个

317
00:15:38,405 --> 0:15:42,743
变更续订状态 续订失败 追回

318
00:15:43,043 --> 0:15:44,511
以及涨价同意

319
00:15:52,252 --> 0:15:53,387
现在让我们快速看看

320
00:15:53,453 --> 0:15:55,289
每一个新通知类型

321
00:15:55,355 --> 0:15:57,791
以便我们了解为什么要发送它们

322
00:15:59,059 --> 0:16:01,862
首先让我们看看变更续订状态

323
00:15:59,059 --> 0:16:01,862
首先让我们看看变更续订状态

324
00:16:01,929 --> 0:16:05,365
当用户变更是否自动续订时发送

325
00:16:05,799 --> 0:16:08,402
实际上你应该立即收到这个通知

326
00:16:08,468 --> 0:16:09,803
从而确保你正在查找它

327
00:16:09,870 --> 0:16:12,539
如果你目前正在使用我们的

328
00:16:12,606 --> 0:16:13,507
（新通知类型）

329
00:16:13,574 --> 0:16:16,844
我们即将添加一个

330
00:16:17,144 --> 0:16:20,247
当用户在订阅周期中

331
00:16:20,314 --> 0:16:23,050
首次尝试续订而自动续订失败时发送

332
00:16:23,984 --> 0:16:26,486
你将在秋季看到这个通知

333
00:16:28,322 --> 0:16:31,225
和续订失败一起添加的还有追回

334
00:16:31,692 --> 0:16:32,926
当我们在账单重新发送周期中

335
00:16:32,993 --> 0:16:35,629
追回订阅计费时

336
00:16:35,696 --> 0:16:37,464
发送追回通知

337
00:16:37,898 --> 0:16:40,200
这也将在秋季上线

338
00:16:40,601 --> 0:16:42,336
如果你收到了追回通知

339
00:16:42,402 --> 0:16:45,038
你最近一定收到过续订失败通知

340
00:16:45,105 --> 0:16:47,508
并且你可以了解订阅计费

341
00:16:47,574 --> 0:16:48,942
已被成功追回

342
00:16:49,676 --> 0:16:52,779
如果你当前使用了我们的

343
00:16:52,846 --> 0:16:55,282
你可能注意到我们将发送追回通知

344
00:16:55,349 --> 0:16:58,318
当我们当前发送续订通知类型时

345
00:16:59,753 --> 0:17:02,923
我们计划让追回通知最终取代

346
00:16:59,753 --> 0:17:02,923
我们计划让追回通知最终取代

347
00:17:02,990 --> 0:17:04,858
因为它的命名更恰当

348
00:17:05,192 --> 0:17:07,493
但在过渡阶段

349
00:17:07,560 --> 0:17:10,531
我们会同时发送追回和续订通知

350
00:17:10,597 --> 0:17:12,598
给你一点适应时间

351
00:17:14,734 --> 0:17:17,337
最后 我们添加了第四个通知类型

352
00:17:17,404 --> 0:17:18,739
涨价同意

353
00:17:19,205 --> 0:17:21,441
当我们检测到你的某个订阅者

354
00:17:21,508 --> 0:17:23,877
已经进入涨价流程时

355
00:17:23,944 --> 0:17:27,347
给你发送涨价同意

356
00:17:27,414 --> 0:17:30,017
以便他们能继续续订

357
00:17:30,717 --> 0:17:34,188
针对这个通知 我们在JSON

358
00:17:34,254 --> 0:17:35,956
涨价有效日期

359
00:17:36,390 --> 0:17:40,127
这是客户必须同意涨价的日期

360
00:17:40,194 --> 0:17:41,929
以便他们可以继续续订

361
00:17:42,429 --> 0:17:45,098
你也会在秋季看到这个通知

362
00:17:49,636 --> 0:17:51,038
那么现在我们已经了解了

363
00:17:51,104 --> 0:17:53,907
服务器到服务器通知中的新功能

364
00:17:54,174 --> 0:17:55,642
我要很激动地跟大家分享

365
00:17:55,709 --> 0:17:58,612
如何处理全部八个通知类型

366
00:17:58,879 --> 0:18:01,481
从而最大限度地利用每一种通知

367
00:17:58,879 --> 0:18:01,481
从而最大限度地利用每一种通知

368
00:18:01,548 --> 0:18:02,516
当你收到它时

369
00:18:02,583 --> 0:18:03,517
（处理通知）

370
00:18:03,584 --> 0:18:08,288
那么首先 让我们快速回顾一下

371
00:18:08,622 --> 0:18:11,124
初次购买 交互式续订

372
00:18:11,191 --> 0:18:13,460
（现有通知类型概览）

373
00:18:13,527 --> 0:18:16,096
变更续订偏好以及取消

374
00:18:17,064 --> 0:18:17,998
我们要花点儿时间

375
00:18:18,065 --> 0:18:21,235
深入了解每一种通知类型

376
00:18:21,301 --> 0:18:22,536
但在此之前

377
00:18:22,603 --> 0:18:27,307
我想让你注意一下

378
00:18:27,774 --> 0:18:30,544
你会注意到

379
00:18:30,611 --> 0:18:33,380
我们要求你针对每一种通知类型

380
00:18:33,447 --> 0:18:35,082
查找原始交易id

381
00:18:35,649 --> 0:18:38,018
这是因为原始交易id

382
00:18:38,085 --> 0:18:41,321
被看作是订阅的唯一标识符

383
00:18:41,388 --> 0:18:45,158
并且持续追踪这个信息

384
00:18:45,225 --> 0:18:47,628
订阅的初始购买

385
00:18:49,563 --> 0:18:52,766
现在让我们想象一下

386
00:18:53,066 --> 0:18:54,201
让我们叫他John

387
00:18:54,268 --> 0:18:57,104
并且他有兴趣购买你的订阅服务

388
00:18:57,738 --> 0:18:59,506
让我们具体操作一下

389
00:18:59,573 --> 0:19:01,975
John关于订阅所做出的决定

390
00:18:59,573 --> 0:19:01,975
John关于订阅所做出的决定

391
00:19:02,042 --> 0:19:04,845
以及在此过程中你会收到哪些通知

392
00:19:05,946 --> 0:19:08,782
（当前通知类型概览）

393
00:19:08,849 --> 0:19:09,816
（首次购买订阅）

394
00:19:09,883 --> 0:19:12,553
那么你期待收到的第一个通知类型

395
00:19:12,619 --> 0:19:14,588
是首次购买

396
00:19:15,155 --> 0:19:17,457
当John首次购买订阅服务时

397
00:19:17,524 --> 0:19:19,626
我们会给你发送初次购买通知

398
00:19:20,027 --> 0:19:24,865
收到这个通知之后

399
00:19:24,932 --> 0:19:28,001
把客户状态更新为

400
00:19:28,068 --> 0:19:30,604
并为新购买的订阅提供服务

401
00:19:31,271 --> 0:19:34,174
在这个通知类型中

402
00:19:34,241 --> 0:19:36,543
让你在JSON payload中

403
00:19:37,277 --> 0:19:39,213
第一个是购买日期

404
00:19:39,680 --> 0:19:41,548
它可以精确到毫秒

405
00:19:41,615 --> 0:19:43,750
它会告诉你

406
00:19:43,817 --> 0:19:46,186
客户购买订阅服务的具体日期和时间

407
00:19:46,954 --> 0:19:49,723
接下来你应该查找原始交易id

408
00:19:49,790 --> 0:19:50,657
正如我所提到的那样

409
00:19:50,724 --> 0:19:53,727
这是订阅服务的唯一标识符

410
00:19:53,794 --> 0:19:55,262
持续追踪它

411
00:19:55,329 --> 0:19:58,966
会让你把随后的通知

412
00:20:00,434 --> 0:20:03,437
你还应该查找网络订单行排列项id

413
00:20:03,704 --> 0:20:07,708
这是每个订阅周期的唯一标识符

414
00:20:07,774 --> 0:20:11,545
并且如果你在收到这个通知后

415
00:20:11,612 --> 0:20:15,716
它将把这个通知链接到

416
00:20:16,884 --> 0:20:19,520
最后你应该查找产品id

417
00:20:19,920 --> 0:20:22,055
产品id会准确地告诉你

418
00:20:22,122 --> 0:20:25,192
你的新客户订阅了哪个产品

419
00:20:26,827 --> 0:20:29,863
因此在John使用订阅服务

420
00:20:29,930 --> 0:20:33,267
他决定把服务升级到一个更高的等级

421
00:20:33,934 --> 0:20:36,403
我们提前考虑到了这种续订

422
00:20:36,470 --> 0:20:39,673
因此我们会给你发送一个

423
00:20:39,740 --> 0:20:40,974
（潜在的续订）

424
00:20:41,041 --> 0:20:42,276
因为升级…

425
00:20:43,043 --> 0:20:46,747
会立即为客户提供更高等级的权限

426
00:20:46,813 --> 0:20:49,416
我们还将针对

427
00:20:49,483 --> 0:20:52,352
给你发送一个取消通知类型

428
00:20:53,086 --> 0:20:56,456
然而 如果客户在流失了一段时间后

429
00:20:56,523 --> 0:21:00,260
你只会收到交互式续订通知类型

430
00:20:56,523 --> 0:21:00,260
你只会收到交互式续订通知类型

431
00:21:01,962 --> 0:21:04,364
在这个通知中

432
00:21:04,431 --> 0:21:06,667
你该在JSON payload中

433
00:21:09,203 --> 0:21:11,405
第一个是购买日期

434
00:21:11,471 --> 0:21:13,874
这会告诉你

435
00:21:13,941 --> 0:21:17,010
客户重新订购这个订阅服务

436
00:21:17,077 --> 0:21:18,612
或升级服务的具体日期和时间

437
00:21:19,479 --> 0:21:22,616
你应该再一次查找原始交易id

438
00:21:22,883 --> 0:21:25,185
从而把它链接回原始订阅

439
00:21:26,720 --> 0:21:28,989
以及网络订单行排列项id

440
00:21:29,456 --> 0:21:32,292
这对于每个订阅周期来说

441
00:21:32,359 --> 0:21:34,661
它会帮助你把这个通知链接到

442
00:21:34,728 --> 0:21:36,964
verifyReceipt

443
00:21:38,298 --> 0:21:40,434
最后查找产品id

444
00:21:40,801 --> 0:21:44,805
这会告诉你

445
00:21:44,872 --> 0:21:46,406
或升级到了哪个等级的产品

446
00:21:47,474 --> 0:21:48,942
不久之后

447
00:21:49,009 --> 0:21:53,413
John决定把订阅的等级

448
00:21:53,881 --> 0:21:55,282
在这种情况下 我们会给你发送

449
00:21:55,349 --> 0:21:58,285
变更续订偏好通知类型

450
00:21:59,086 --> 0:22:00,921
收到这个通知之后

451
00:21:59,086 --> 0:22:00,921
收到这个通知之后

452
00:22:00,988 --> 0:22:03,323
你可以在你的服务器上

453
00:22:03,390 --> 0:22:05,659
更新为一个更基础的等级

454
00:22:06,393 --> 0:22:07,761
在这个通知类型中

455
00:22:07,828 --> 0:22:10,531
我希望你查找两个字段

456
00:22:10,597 --> 0:22:11,999
（订阅降级）

457
00:22:12,065 --> 0:22:14,701
第一个是自动续订产品id

458
00:22:15,169 --> 0:22:17,804
因为续订降级不会发生

459
00:22:17,871 --> 0:22:20,040
除非订阅周期结束

460
00:22:20,374 --> 0:22:24,211
这会准确地告诉你续订时

461
00:22:24,278 --> 0:22:25,846
客户将自动续订哪个产品

462
00:22:27,581 --> 0:22:30,717
你应该再次查找原始交易id

463
00:22:30,784 --> 0:22:34,121
以便把这个通知链接回原始订阅

464
00:22:36,490 --> 0:22:38,025
（客户服务部执行退款）

465
00:22:38,091 --> 0:22:40,227
现在很遗憾 不久之后

466
00:22:40,294 --> 0:22:42,396
John拨打了客服电话

467
00:22:42,462 --> 0:22:44,665
并决定取消订阅

468
00:22:45,465 --> 0:22:48,936
在这种情况下 我们会给你发送一个

469
00:22:49,603 --> 0:22:50,804
正如我之前所提到的那样

470
00:22:50,871 --> 0:22:53,106
当客户升级订阅时

471
00:22:53,173 --> 0:22:56,343
你将收到一个取消

472
00:22:56,610 --> 0:22:59,546
而取消意味着

473
00:22:59,613 --> 0:23:00,614
取消较低等级的订阅

474
00:22:59,613 --> 0:23:00,614
取消较低等级的订阅

475
00:23:01,682 --> 0:23:04,685
在这个通知类型中

476
00:23:05,385 --> 0:23:08,355
首先你应该查找取消日期

477
00:23:08,422 --> 0:23:10,357
这会告诉你

478
00:23:10,424 --> 0:23:13,293
客户决定取消订阅的具体日期和时间

479
00:23:14,261 --> 0:23:16,864
你仍然要查找原始交易id

480
00:23:16,930 --> 0:23:19,466
从而把它链接回原始交易购买

481
00:23:20,767 --> 0:23:22,002
以及产品id

482
00:23:22,069 --> 0:23:25,506
从而精确地了解

483
00:23:30,878 --> 0:23:33,647
那么现在我们已经了解了

484
00:23:33,714 --> 0:23:37,718
让我们同样地来了解一下

485
00:23:37,784 --> 0:23:39,152
我刚才介绍的四种新通知类型

486
00:23:40,053 --> 0:23:40,888
它们分别是…

487
00:23:42,523 --> 0:23:46,493
变更续订状态 续订失败 追回

488
00:23:46,894 --> 0:23:48,295
以及涨价同意

489
00:23:48,362 --> 0:23:49,396
（新通知类型概览）

490
00:23:49,463 --> 0:23:50,764
在这些通知类型中

491
00:23:50,831 --> 0:23:53,934
你仍然想在

492
00:23:54,001 --> 0:23:56,036
查找原始交易id

493
00:23:56,770 --> 0:23:57,905
正如我刚才所提到的那样

494
00:23:57,971 --> 0:24:01,542
这是因为它是订阅的唯一标识符

495
00:23:57,971 --> 0:24:01,542
这是因为它是订阅的唯一标识符

496
00:24:01,608 --> 0:24:04,778
它会帮助你把所有的通知

497
00:24:06,246 --> 0:24:07,648
现在让我们再次访问John

498
00:24:07,714 --> 0:24:08,682
（自动续订状态变更）

499
00:24:08,749 --> 0:24:11,852
有一天他正在滚动浏览

500
00:24:11,919 --> 0:24:15,322
并决定再次自动续订

501
00:24:15,923 --> 0:24:17,457
在这种情况下 我们会给你发送

502
00:24:17,524 --> 0:24:20,561
一个变更续订状态通知类型

503
00:24:21,261 --> 0:24:23,297
你还将在客户决定

504
00:24:23,363 --> 0:24:26,300
关闭自动续订时收到这个通知

505
00:24:27,234 --> 0:24:29,102
收到这个通知后

506
00:24:29,703 --> 0:24:31,972
你可以在你那端更新客户的订阅状态

507
00:24:32,039 --> 0:24:34,741
从而响应此次变更

508
00:24:35,776 --> 0:24:39,746
或者你还可以部署保留政策

509
00:24:39,813 --> 0:24:42,015
如果你看到他们已经关闭

510
00:24:43,183 --> 0:24:45,786
在这个通知类型中

511
00:24:45,853 --> 0:24:47,621
你应该查找并记下另外四个字段

512
00:24:48,455 --> 0:24:51,458
第一个是自动续订状态变更日期

513
00:24:51,525 --> 0:24:53,560
它会告诉你客户自动续订状态

514
00:24:53,627 --> 0:24:55,896
发生变更的具体日期和时间

515
00:24:57,130 --> 0:24:59,032
你应该查找自动续订状态

516
00:24:59,399 --> 0:25:02,269
它会告诉你是否开启自动续订

517
00:24:59,399 --> 0:25:02,269
它会告诉你是否开启自动续订

518
00:25:02,769 --> 0:25:06,273
如果你知道自动续订状态

519
00:25:06,340 --> 0:25:09,977
你就可以了解

520
00:25:10,277 --> 0:25:13,280
并打算继续购买你的订阅服务

521
00:25:14,581 --> 0:25:17,618
你应该再次查找原始交易id

522
00:25:17,684 --> 0:25:20,420
从而把它链接回原始订阅购买

523
00:25:21,288 --> 0:25:24,191
以及产品id

524
00:25:24,258 --> 0:25:27,995
开启或关闭了自动续订

525
00:25:31,598 --> 0:25:34,301
当我们在自动续订阶段

526
00:25:34,368 --> 0:25:35,903
尝试对John的订阅计费时

527
00:25:35,969 --> 0:25:38,338
我们很遗憾地遇到了计费报错

528
00:25:38,739 --> 0:25:41,241
在这种情况下 我们将在

529
00:25:41,308 --> 0:25:44,611
那个订阅周期中的首次续订尝试时

530
00:25:45,345 --> 0:25:47,347
收到这个通知后

531
00:25:47,414 --> 0:25:50,984
你可以选择推迟对客户的服务

532
00:25:51,852 --> 0:25:54,388
你还可以把客户的订阅状态更新为

533
00:25:54,454 --> 0:25:56,990
比如“活跃”或“计费重试”

534
00:25:57,057 --> 0:26:00,160
取决于JSON payload中

535
00:25:57,057 --> 0:26:00,160
取决于JSON payload中

536
00:26:00,694 --> 0:26:02,129
那么现在 让我们具体看一下

537
00:26:02,696 --> 0:26:04,498
在这里你要查找的第一个字段

538
00:26:04,565 --> 0:26:06,967
在计费重试周期中

539
00:26:07,367 --> 0:26:10,003
它的值为0或1 它会告诉你

540
00:26:10,070 --> 0:26:12,372
我们是否正在积极尝试

541
00:26:12,439 --> 0:26:13,974
追回订阅计费

542
00:26:14,474 --> 0:26:17,144
如果你看到这个字段的值为1

543
00:26:17,211 --> 0:26:20,480
你就会了解我们正在尝试

544
00:26:20,547 --> 0:26:22,149
在计费重试周期中

545
00:26:23,417 --> 0:26:26,653
你仍然要查找原始交易id

546
00:26:26,720 --> 0:26:29,022
从而把它链接回原始订阅

547
00:26:29,957 --> 0:26:31,758
以及截止日期

548
00:26:31,825 --> 0:26:34,361
这会表明我们尝试自动续订的

549
00:26:34,695 --> 0:26:37,564
具体日期和时间

550
00:26:37,631 --> 0:26:38,465
并且它已经失败了

551
00:26:39,099 --> 0:26:40,100
（计费重试中的订阅追回）

552
00:26:40,167 --> 0:26:42,736
很幸运的是在计费重试阶段

553
00:26:43,270 --> 0:26:46,139
John的订阅计费问题已经解决了

554
00:26:46,206 --> 0:26:48,809
并且我们可以追回

555
00:26:49,142 --> 0:26:49,977
在这种情况下

556
00:26:50,043 --> 0:26:52,813
我们会给你发送一个追回通知类型

557
00:26:54,014 --> 0:26:55,682
提醒一下 追回通知

558
00:26:55,749 --> 0:26:58,418
正在取代我们目前

559
00:26:58,485 --> 0:27:00,587
正在发送的续订通知类型

560
00:26:58,485 --> 0:27:00,587
正在发送的续订通知类型

561
00:27:01,688 --> 0:27:03,624
收到这个通知类型后

562
00:27:03,690 --> 0:27:06,727
你可以追回要追回的订阅

563
00:27:07,461 --> 0:27:08,929
并把客户状态更新为

564
00:27:08,996 --> 0:27:11,098
比如“活跃”或“已订阅”

565
00:27:11,164 --> 0:27:14,168
或任何表明是活跃的订阅者的表述

566
00:27:15,068 --> 0:27:17,638
在这种通知类型中

567
00:27:17,704 --> 0:27:19,573
查找其它几个字段

568
00:27:20,807 --> 0:27:22,476
首先你应该查找购买日期

569
00:27:22,543 --> 0:27:25,879
这会告诉你具体何时

570
00:27:25,946 --> 0:27:27,114
我们会追回对这个订阅的计费

571
00:27:28,182 --> 0:27:31,318
你应该再次查找原始交易id

572
00:27:31,752 --> 0:27:34,521
因为它会告诉你

573
00:27:34,588 --> 0:27:35,923
我们到底追回了对哪个订阅的计费

574
00:27:35,989 --> 0:27:38,959
因为它是订阅的唯一标识符

575
00:27:40,160 --> 0:27:42,496
最后查找到期日期

576
00:27:42,563 --> 0:27:44,565
它会告诉你

577
00:27:44,631 --> 0:27:47,334
新订阅周期的到期日期和时间

578
00:27:47,601 --> 0:27:50,437
你可以期待我们再次尝试自动续订

579
00:27:52,706 --> 0:27:54,241
（客户进入涨价流程）

580
00:27:54,308 --> 0:27:56,977
现在让我们假设你们开发人员

581
00:27:57,044 --> 0:27:59,613
决定增加订阅服务的价格

582
00:28:00,047 --> 0:28:02,516
我们何时检查某个订阅服务是否涨价

583
00:28:02,583 --> 0:28:05,219
在周订阅续订之前七天

584
00:28:05,285 --> 0:28:07,788
在月订阅续订之前十天

585
00:28:07,855 --> 0:28:10,757
在年订阅续订之前30天

586
00:28:10,824 --> 0:28:12,960
我们发现你希望涨价

587
00:28:13,026 --> 0:28:16,630
我们将给你发送一个

588
00:28:16,697 --> 0:28:17,831
涨价同意通知

589
00:28:18,799 --> 0:28:20,667
收到这个通知后

590
00:28:20,734 --> 0:28:24,872
你可以在你那端

591
00:28:25,339 --> 0:28:28,008
或者你可以部署app内消息

592
00:28:28,075 --> 0:28:31,078
提醒你的客户同意涨价

593
00:28:31,712 --> 0:28:35,282
请注意我们还会给客户发送邮件

594
00:28:35,349 --> 0:28:38,485
提醒他们同意涨价

595
00:28:40,053 --> 0:28:41,321
在这个通知类型内

596
00:28:41,388 --> 0:28:43,524
我还希望你查找其它字段

597
00:28:44,224 --> 0:28:46,827
首先你应该查找价格同意状态

598
00:28:46,894 --> 0:28:50,230
它将告诉你

599
00:28:50,297 --> 0:28:51,532
客户是否已经同意涨价

600
00:28:51,899 --> 0:28:55,269
然而因为我们会给你发送这个通知

601
00:28:55,335 --> 0:28:58,172
几乎是一检测到涨价就发送通知

602
00:28:58,438 --> 0:29:01,708
在绝大部分情况下

603
00:28:58,438 --> 0:29:01,708
在绝大部分情况下

604
00:29:01,775 --> 0:29:03,911
否则就是客户尚未同意

605
00:29:05,712 --> 0:29:08,615
你应该再次查找原始交易id

606
00:29:08,682 --> 0:29:12,019
从而把这个通知链接回原始订阅

607
00:29:12,819 --> 0:29:15,422
最后我希望你查找截止日期

608
00:29:15,756 --> 0:29:20,060
这会告诉你这个订阅周期

609
00:29:20,394 --> 0:29:21,595
到那时候

610
00:29:21,662 --> 0:29:25,399
你的客户将不得不同意涨价

611
00:29:28,669 --> 0:29:29,837
（订阅周期）

612
00:29:29,903 --> 0:29:31,872
那么现在我们已经了解了

613
00:29:31,939 --> 0:29:33,607
服务器到服务器通知相关的新功能

614
00:29:33,674 --> 0:29:36,143
以及你要如何处理这些通知

615
00:29:36,210 --> 0:29:37,344
当你收到它们之后

616
00:29:37,644 --> 0:29:40,247
我要邀请

617
00:29:40,314 --> 0:29:42,482
为大家谈谈订阅周期

618
00:29:42,549 --> 0:29:43,717
以及减少流失

619
00:29:54,962 --> 0:29:55,796
早上好

620
00:29:56,063 --> 0:29:59,733
我是Manjeet Chawla

621
00:30:00,667 --> 0:30:03,837
今天能与大家一起分享

622
00:30:03,904 --> 0:30:09,543
关于如何使用服务器到服务器通知

623
00:30:09,877 --> 0:30:15,649
来识别订阅周期中的计费事件

624
00:30:15,716 --> 0:30:18,919
那可能会影响你客户的订阅状态

625
00:30:20,187 --> 0:30:23,123
那么订阅周期是什么样的呢？

626
00:30:25,392 --> 0:30:30,264
现在你可能通过提供免费试用

627
00:30:30,330 --> 0:30:34,168
或通过推广价吸引他们关注你的服务

628
00:30:34,234 --> 0:30:38,172
并允许用户在支付全款之前

629
00:30:40,641 --> 0:30:43,477
接下来你要保持用户

630
00:30:43,544 --> 0:30:46,680
通过为他们提供持续更新的内容

631
00:30:49,516 --> 0:30:55,822
最后你尝试通过最小化流失

632
00:30:59,193 --> 0:31:02,729
现在我们都知道在这个周期中

633
00:30:59,193 --> 0:31:02,729
现在我们都知道在这个周期中

634
00:31:02,796 --> 0:31:04,865
对于绝大多数订阅者来说

635
00:31:04,932 --> 0:31:07,434
会出现各种各样的计费事件

636
00:31:09,236 --> 0:31:13,340
你现在很可能是通过调用

637
00:31:13,807 --> 0:31:17,978
来让订阅者获取这些计费事件变更

638
00:31:19,580 --> 0:31:23,150
现在我们知道这样效率不高

639
00:31:23,817 --> 0:31:26,186
随着订阅业务的增长

640
00:31:27,688 --> 0:31:31,658
但是我们之前对服务器到服务器

641
00:31:31,725 --> 0:31:37,631
你不再需要依赖于收据

642
00:31:38,599 --> 0:31:43,203
因此让我们更多地谈谈

643
00:31:43,470 --> 0:31:45,339
来检测这些计费事件

644
00:31:45,906 --> 0:31:48,942
并为你的客户创建最佳订阅体验

645
00:31:51,845 --> 0:31:54,648
让我们从初次购买订阅服务开始

646
00:31:55,282 --> 0:31:58,185
现在我们都知道这个初次购买

647
00:31:58,252 --> 0:32:02,089
是客户可以在某段时间内浏览内容

648
00:31:58,252 --> 0:32:02,089
是客户可以在某段时间内浏览内容

649
00:32:04,091 --> 0:32:07,261
当客户在你的app中

650
00:32:07,694 --> 0:32:11,765
你将通过设备上的StoreKit

651
00:32:12,366 --> 0:32:14,735
以及与那个交易相关的收据

652
00:32:17,004 --> 0:32:19,206
与此同时 你将收到

653
00:32:20,073 --> 0:32:25,245
关于新购买的一个新通知

654
00:32:25,746 --> 0:32:27,481
使用这个通知

655
00:32:27,548 --> 0:32:30,918
你可以识别新购买的订阅者

656
00:32:30,984 --> 0:32:33,353
之前从未购买过你的订阅服务

657
00:32:36,123 --> 0:32:39,993
现在你抓住那个

658
00:32:40,060 --> 0:32:43,397
与此同时你会从设备上发送一张收据

659
00:32:44,097 --> 0:32:46,300
到你的服务器上 通过安全连接

660
00:32:46,366 --> 0:32:50,671
发送到verifyReceipt

661
00:32:54,041 --> 0:32:56,710
在App Store返回的响应中

662
00:32:56,977 --> 0:33:00,414
你要检查JSON的内容

663
00:32:56,977 --> 0:33:00,414
你要检查JSON的内容

664
00:33:00,480 --> 0:33:05,152
并更新用户数据库 通过查找

665
00:33:05,219 --> 0:33:07,654
用户所做出的最后一次购买

666
00:33:09,389 --> 0:33:12,626
最后你之前保存的那个通知

667
00:33:12,693 --> 0:33:16,463
你可以通过这个

668
00:33:16,530 --> 0:33:17,731
把来自App Store的

669
00:33:18,131 --> 0:33:21,301
初次购买通知

670
00:33:21,368 --> 0:33:26,139
通过使用原始交易id

671
00:33:31,144 --> 0:33:33,847
现在当订阅服务已经准备好

672
00:33:34,281 --> 0:33:37,217
App Store会在后台

673
00:33:37,284 --> 0:33:38,252
自动为你续订

674
00:33:39,086 --> 0:33:42,456
当用户下一次在设备上打开app时

675
00:33:42,990 --> 0:33:44,892
你将收到一个新交易通知

676
00:33:44,958 --> 0:33:47,928
以及一个与该交易相关的收据

677
00:33:50,864 --> 0:33:56,336
你再次以base64加密那个收据

678
00:33:58,572 --> 0:34:01,208
假如你的用户正在一个不同的平台上

679
00:33:58,572 --> 0:34:01,208
假如你的用户正在一个不同的平台上

680
00:34:01,275 --> 0:34:02,276
使用他们的服务

681
00:34:02,342 --> 0:34:07,047
并且你不希望依赖于

682
00:34:07,447 --> 0:34:11,284
你还可以使用你之前

683
00:34:11,351 --> 0:34:14,688
并将其发送到你的服务器上

684
00:34:20,092 --> 0:34:23,096
接下来你要把它发送到

685
00:34:23,163 --> 0:34:26,766
并在JSON响应中检查续订交易

686
00:34:26,833 --> 0:34:28,467
（续订）

687
00:34:28,534 --> 0:34:29,503
在响应中

688
00:34:29,570 --> 0:34:32,572
你可以验证该用户的最新续订

689
00:34:32,639 --> 0:34:36,810
并根据那个续订更新最新到期日期

690
00:34:39,279 --> 0:34:41,949
最后你要保持对客户的服务

691
00:34:42,014 --> 0:34:44,184
因为订阅已成功续订

692
00:34:45,786 --> 0:34:49,755
请注意对于这个事件来说

693
00:34:49,822 --> 0:34:54,862
因此你必须根据

694
00:34:54,928 --> 0:34:56,096
来调用verifyReceipt

695
00:34:56,763 --> 0:34:58,899
从而检查续订交易

696
00:35:02,135 --> 0:35:04,872
现在假如客户一直喜欢你的服务

697
00:35:04,938 --> 0:35:08,442
并且他们觉得基础订阅很不错

698
00:35:08,509 --> 0:35:12,112
并且他们决定升级到高级产品

699
00:35:12,179 --> 0:35:13,881
也许是高等级的服务

700
00:35:13,947 --> 0:35:15,849
（升级）

701
00:35:15,916 --> 0:35:19,920
现在对于这个升级

702
00:35:20,187 --> 0:35:22,089
来自于App Store

703
00:35:23,857 --> 0:35:29,162
并且JSON内容中

704
00:35:29,463 --> 0:35:31,832
通知你App Store

705
00:35:31,899 --> 0:35:34,701
取消之前的订阅

706
00:35:37,938 --> 0:35:40,507
取消通知之后

707
00:35:40,574 --> 0:35:43,310
一个交互式续订通知

708
00:35:45,212 --> 0:35:49,016
这个通知用于更新用户的数据库

709
00:35:50,417 --> 0:35:51,618
更新升级日期

710
00:35:51,685 --> 0:35:55,756
那么现在你知道这个用户已经把订阅

711
00:35:55,822 --> 0:35:58,458
升级成了一个高等级的服务

712
00:36:02,963 --> 0:36:05,933
最后你要在app中

713
00:36:05,999 --> 0:36:07,367
为用户解锁高级内容

714
00:36:10,571 --> 0:36:11,738
（取消）

715
00:36:11,805 --> 0:36:12,639
现在…

716
00:36:13,073 --> 0:36:14,041
在某种情况下

717
00:36:14,508 --> 0:36:17,678
客户觉得这个内容并不适合他

718
00:36:18,011 --> 0:36:19,813
并且他想取消订阅

719
00:36:20,681 --> 0:36:25,752
他们可以通过

720
00:36:25,819 --> 0:36:26,954
关闭自动续订来实现

721
00:36:28,589 --> 0:36:29,590
现在…

722
00:36:30,190 --> 0:36:32,392
你可能想依赖于收据

723
00:36:32,860 --> 0:36:35,329
来反映最新续订状态

724
00:36:36,163 --> 0:36:39,867
你甚至可能调用全部客户的

725
00:36:40,133 --> 0:36:43,203
仅仅是为了获取

726
00:36:45,472 --> 0:36:47,508
我们刚刚讲过了

727
00:36:47,574 --> 0:36:50,043
Tori刚刚提到了新通知

728
00:36:50,110 --> 0:36:51,245
通过使用新通知

729
00:36:51,311 --> 0:36:54,348
你就不需要再依赖于

730
00:36:54,414 --> 0:36:56,149
来获取续订状态变更了

731
00:36:58,218 --> 0:37:01,421
现在每当用户

732
00:36:58,218 --> 0:37:01,421
现在每当用户

733
00:37:01,688 --> 0:37:05,459
从管理订阅设置中

734
00:37:05,526 --> 0:37:07,261
你就会获得变更续订状态通知

735
00:37:12,065 --> 0:37:15,502
你使用这个事件把续订状态

736
00:37:15,802 --> 0:37:17,471
更新为假

737
00:37:17,538 --> 0:37:20,274
因为在这个情况下

738
00:37:21,642 --> 0:37:24,077
并且你还要更新他们的订阅状态

739
00:37:25,812 --> 0:37:30,751
现在假如你没有收到

740
00:37:31,185 --> 0:37:33,086
直到订阅周期结束

741
00:37:34,188 --> 0:37:38,125
你就可以假设

742
00:37:38,592 --> 0:37:40,761
在当前订阅周期结束后

743
00:37:43,397 --> 0:37:48,969
因此你可以把用户的订阅状态

744
00:37:51,672 --> 0:37:52,873
随着时间流逝

745
00:37:53,807 --> 0:37:56,343
因为你的订阅者会流失

746
00:37:56,410 --> 0:38:00,514
你一定希望试着把他们重新拉回来

747
00:37:56,410 --> 0:38:00,514
你一定希望试着把他们重新拉回来

748
00:38:00,581 --> 0:38:03,917
要么是折扣价格

749
00:38:06,320 --> 0:38:09,890
我们最近发布了一个新功能

750
00:38:09,957 --> 0:38:14,127
它允许你提供折扣价格或免费试用

751
00:38:14,194 --> 0:38:16,263
从而保留现有订阅者

752
00:38:16,330 --> 0:38:19,166
或重获之前流失的订阅者

753
00:38:19,233 --> 0:38:20,234
（重获）

754
00:38:20,300 --> 0:38:22,769
今天稍后有一场关于

755
00:38:22,836 --> 0:38:25,339
我的同事们将分享一些最佳范例

756
00:38:25,405 --> 0:38:27,241
关于实施订阅优惠

757
00:38:27,608 --> 0:38:31,345
以及关于如何使用订阅优惠

758
00:38:31,411 --> 0:38:32,713
来增加客户保留数量的不同的用例

759
00:38:36,950 --> 0:38:38,886
现在让我们看一个

760
00:38:38,952 --> 0:38:41,688
用户没有取消订阅的意图

761
00:38:42,122 --> 0:38:45,459
但App Store不能代表用户

762
00:38:45,526 --> 0:38:47,895
追回或续订

763
00:38:47,961 --> 0:38:48,896
（计费错误）

764
00:38:48,962 --> 0:38:51,064
也许是用户的信用卡过期了

765
00:38:51,131 --> 0:38:54,301
或也许是他们的账户中资金不足

766
00:38:56,003 --> 0:38:57,004
对于这个事件

767
00:38:57,738 --> 0:39:01,575
App Store现在会给你发送

768
00:38:57,738 --> 0:39:01,575
App Store现在会给你发送

769
00:39:02,376 --> 0:39:04,011
使用这个通知

770
00:39:04,578 --> 0:39:09,416
你会了解用户的订阅

771
00:39:10,217 --> 0:39:12,686
并且你可以把客户的订阅状态

772
00:39:12,753 --> 0:39:15,756
更新为“不活跃”或“已流失”

773
00:39:17,925 --> 0:39:19,359
你可以使用这个通知

774
00:39:19,993 --> 0:39:22,029
在app内给他们显示一条消息

775
00:39:22,095 --> 0:39:24,731
让他们知道他们的订阅已经到期

776
00:39:27,367 --> 0:39:28,202
（计费重试）

777
00:39:28,268 --> 0:39:30,470
现在对于计费相关的问题

778
00:39:31,138 --> 0:39:33,941
App Store

779
00:39:34,374 --> 0:39:36,710
尝试续订

780
00:39:37,611 --> 0:39:39,146
如果某次尝试成功

781
00:39:39,213 --> 0:39:42,683
并且如果你允许客户订阅该服务

782
00:39:43,617 --> 0:39:46,186
你将收到一个恢复通知

783
00:39:46,587 --> 0:39:48,222
那么使用这个通知

784
00:39:48,822 --> 0:39:51,325
你可以把那个客户的用户数据库

785
00:39:52,159 --> 0:39:53,193
更新为“已订阅”

786
00:39:54,127 --> 0:39:58,332
并且你会注意到那个新续订

787
00:40:01,134 --> 0:40:03,670
然后你就可以为该客户重新启动服务

788
00:40:06,907 --> 0:40:08,442
（减少无意识流失）

789
00:40:08,509 --> 0:40:12,813
那么现在我们在上一个例子中看到

790
00:40:12,880 --> 0:40:15,249
数次尝试续订

791
00:40:15,949 --> 0:40:18,919
现在这是自动发生的了

792
00:40:20,821 --> 0:40:22,422
但你作为开发人员要如何

793
00:40:23,223 --> 0:40:25,058
响应这些尝试

794
00:40:25,125 --> 0:40:28,795
以及要采取什么措施来减少

795
00:40:32,566 --> 0:40:35,035
去年 关于订阅的实施

796
00:40:35,102 --> 0:40:38,305
我们谈到了我们扩展的计费重试逻辑

797
00:40:38,372 --> 0:40:42,276
那会在一段时间内尝试续订

798
00:40:44,511 --> 0:40:48,582
当由于计费问题导致续订失败时

799
00:40:51,084 --> 0:40:54,221
自发布之后 我们一直在持续地更新

800
00:40:54,288 --> 0:40:58,192
并使它与优化追回策略相协调

801
00:40:59,159 --> 0:41:02,596
我们还查看了先进的机器学习模型

802
00:40:59,159 --> 0:41:02,596
我们还查看了先进的机器学习模型

803
00:41:02,896 --> 0:41:06,900
用于改进在整个平台内

804
00:41:09,536 --> 0:41:12,039
我们查看了一下它自发布之后的性能

805
00:41:12,372 --> 0:41:16,844
你可以看到我们可以追回

806
00:41:16,910 --> 0:41:19,746
由于计费问题

807
00:41:19,813 --> 0:41:21,448
（计费重试性能）

808
00:41:21,515 --> 0:41:24,785
通过追回这些订阅

809
00:41:24,852 --> 0:41:29,656
我们能把整个平台无意识流失率

810
00:41:37,130 --> 0:41:38,665
通过我们对计费重试策略

811
00:41:38,932 --> 0:41:42,336
所做出的更新和改进

812
00:41:44,137 --> 0:41:48,842
我们可以追回4600万次订阅

813
00:41:51,478 --> 0:41:54,748
（追回4600万次订阅）

814
00:41:54,815 --> 0:41:57,684
否则这些订阅就会流失

815
00:41:57,951 --> 0:42:00,988
但是用户却没有要取消服务的意图

816
00:41:57,951 --> 0:42:00,988
但是用户却没有要取消服务的意图

817
00:42:01,054 --> 0:42:03,457
用户会续订并享受他们的服务

818
00:42:03,524 --> 0:42:05,759
并且他们不想取消订阅

819
00:42:06,360 --> 0:42:07,928
并且我们看到在整个平台上

820
00:42:07,995 --> 0:42:11,265
一半以上的这种订阅仍然是活跃的

821
00:42:13,967 --> 0:42:17,905
现在因为我们了解了

822
00:42:17,971 --> 0:42:19,606
在一个为期60天的时间段内

823
00:42:19,673 --> 0:42:21,208
（追回率）

824
00:42:21,275 --> 0:42:25,179
你可以看到

825
00:42:25,245 --> 0:42:28,182
追回了由于计费问题

826
00:42:31,051 --> 0:42:35,856
其中80%以上的追回

827
00:42:38,258 --> 0:42:41,228
当我们追回这些订阅时会发生什么？

828
00:42:43,297 --> 0:42:46,567
首先你要再允许服务

829
00:42:46,633 --> 0:42:48,135
通过新通知

830
00:42:48,202 --> 0:42:50,404
你可以对该客户重新启动服务

831
00:42:50,704 --> 0:42:53,240
当他们下一次尝试获取服务时

832
00:42:55,008 --> 0:42:57,811
我们就为那个订阅开始了一个

833
00:42:57,878 --> 0:42:59,646
自执行追回操作之日起

834
00:43:02,282 --> 0:43:06,019
并且客户朝着

835
00:43:06,086 --> 0:43:11,325
所累积的付费服务的天数将从

836
00:43:13,093 --> 0:43:13,927
那么…

837
00:43:14,261 --> 0:43:17,764
如果你在此期间为客户提供服务

838
00:43:17,831 --> 0:43:22,603
从他们开始计费重试到追回之日

839
00:43:23,070 --> 0:43:26,039
你很可能会漏掉这些天的收益

840
00:43:28,575 --> 0:43:29,877
我们该如何改进呢？

841
00:43:32,379 --> 0:43:36,116
那么今年秋季 我要非常激动地宣布

842
00:43:36,183 --> 0:43:39,720
那会允许你提供一个计费宽限期

843
00:43:40,187 --> 0:43:42,823
给客户们一些额外时间

844
00:43:43,524 --> 0:43:47,561
当他们享受他们的服务时

845
00:43:48,428 --> 0:43:51,498
并且它允许开发人员获得额外的收益

846
00:43:51,565 --> 0:43:54,468
针对你在这些天内所提供的所有服务

847
00:43:54,535 --> 0:43:59,873
（计费宽限期概览）

848
00:44:01,341 --> 0:44:04,645
这为你的所有客户创建了一个

849
00:44:04,711 --> 0:44:07,714
他们在一段时间内自然而然地被追回

850
00:44:08,215 --> 0:44:10,484
因为他们从未表达过取消服务的意图

851
00:44:11,485 --> 0:44:12,920
这还会追回

852
00:44:12,986 --> 0:44:16,790
也许账户中有临时信用卡的客户

853
00:44:19,826 --> 0:44:22,696
现在让我们看看要如何实施这个功能

854
00:44:23,163 --> 0:44:24,398
嗯 非常简单

855
00:44:24,831 --> 0:44:28,669
实施计费宽限期需要三个简单的步骤

856
00:44:29,903 --> 0:44:33,040
首先通过App Store连接

857
00:44:33,106 --> 0:44:36,643
以便提供宽限期的预配置持续时间

858
00:44:37,711 --> 0:44:40,347
根据我们之前看到过的追回数据

859
00:44:40,714 --> 0:44:44,518
我们要针对周订阅

860
00:44:44,585 --> 0:44:47,421
而其它是16天的宽限期

861
00:44:50,257 --> 0:44:54,361
接着在verifyReceipt

862
00:44:54,428 --> 0:44:55,963
或在通知中

863
00:44:56,029 --> 0:44:59,933
这将允许你了解

864
00:45:00,000 --> 0:45:01,235
服务的最新到期日期

865
00:45:01,301 --> 0:45:04,004
（账单宽限期的实施）

866
00:45:04,071 --> 0:45:07,674
并且你在这段时间内

867
00:45:13,146 --> 0:45:14,481
现在你可能会想

868
00:45:15,482 --> 0:45:16,550
作为开发人员

869
00:45:16,617 --> 0:45:19,853
为什么要选择提供计费宽限期？

870
00:45:22,723 --> 0:45:24,091
嗯 有许多好处

871
00:45:24,157 --> 0:45:24,992
首先…

872
00:45:25,359 --> 0:45:28,562
客户从未有过取消订阅的意图

873
00:45:28,629 --> 0:45:32,633
因此他们喜欢一直获得你的服务

874
00:45:35,669 --> 0:45:37,037
这就允许你

875
00:45:37,471 --> 0:45:40,774
或你的客户维持现有的计费周期

876
00:45:40,841 --> 0:45:44,311
当我们在这个计费宽限期内

877
00:45:46,780 --> 0:45:48,549
并且它可以让你 作为开发人员

878
00:45:48,916 --> 0:45:49,750
可以…

879
00:45:51,318 --> 0:45:54,054
赚取额外的收益

880
00:45:54,121 --> 0:45:55,789
对于你在计费宽限期内所提供的服务

881
00:45:56,423 --> 0:45:59,993
（计费宽限期的好处）

882
00:46:00,060 --> 0:46:01,328
并且正如我们之前所看到的那样

883
00:46:01,795 --> 0:46:03,931
它允许客户以更快的比率累积

884
00:46:03,997 --> 0:46:08,902
成为那些较高的85/15

885
00:46:11,038 --> 0:46:12,406
我非常鼓励你们

886
00:46:12,472 --> 0:46:15,209
了解订阅的宽限期

887
00:46:15,275 --> 0:46:17,144
当我们稍后在今年秋季发布后

888
00:46:19,513 --> 0:46:20,480
现在…

889
00:46:20,547 --> 0:46:22,282
除了提供宽限期

890
00:46:22,349 --> 0:46:24,284
你还可以做哪些操作

891
00:46:24,351 --> 0:46:28,488
减少整体无意识流失和增加追回？

892
00:46:29,523 --> 0:46:33,093
在这里让我们看一个例子

893
00:46:33,160 --> 0:46:36,496
通过给计费重试状态的客户

894
00:46:37,064 --> 0:46:38,899
显示情境消息

895
00:46:38,966 --> 0:46:40,701
你可以让他们了解他们的订阅

896
00:46:40,767 --> 0:46:43,370
失败了 因为计费问题

897
00:46:43,437 --> 0:46:46,073
（计费重试客户消息）

898
00:46:48,442 --> 0:46:50,444
并且如果你提供宽限期

899
00:46:50,511 --> 0:46:52,179
你可以让消息侧重于

900
00:46:52,246 --> 0:46:56,283
你为客户提供的宽限期服务

901
00:46:56,650 --> 0:47:00,888
你可以在设计这条消息方面

902
00:46:56,650 --> 0:47:00,888
你可以在设计这条消息方面

903
00:47:01,355 --> 0:47:03,223
它要发生在宽限期结束之前

904
00:47:03,290 --> 0:47:05,359
也许你正在提供高级内容

905
00:47:05,425 --> 0:47:07,628
并且他们会在宽限期结束后

906
00:47:07,694 --> 0:47:08,695
那么 突出这一点…

907
00:47:10,097 --> 0:47:12,699
宽限期结束后

908
00:47:12,766 --> 0:47:13,967
他们会失去对高级内容的权限

909
00:47:14,501 --> 0:47:16,403
这将帮助你追回那些订阅

910
00:47:19,806 --> 0:47:22,009
在这里让我们看一个app

911
00:47:22,342 --> 0:47:25,412
给计费重试阶段的用户

912
00:47:25,812 --> 0:47:29,283
并为他们显示

913
00:47:32,419 --> 0:47:34,121
在这条消息中

914
00:47:34,821 --> 0:47:38,692
你还可以嵌入一个

915
00:47:39,126 --> 0:47:42,663
然后客户就会去解决计费问题

916
00:47:46,233 --> 0:47:48,702
正如你所看到的

917
00:47:49,636 --> 0:47:52,105
这个付款详情页面 允许客户

918
00:47:52,172 --> 0:47:56,076
在账户中拥有最多十种

919
00:47:57,611 --> 0:47:58,879
除了为客户提供

920
00:47:58,946 --> 0:48:02,015
更简单的付款管理选项

921
00:47:58,946 --> 0:48:02,015
更简单的付款管理选项

922
00:48:02,282 --> 0:48:04,218
这还帮助App Store

923
00:48:04,818 --> 0:48:08,055
减少整体的无意识流失率

924
00:48:08,822 --> 0:48:11,491
通过用存档的可替换的付款方式收费

925
00:48:18,565 --> 0:48:21,301
我们在这场演讲中涵盖了许多话题

926
00:48:22,035 --> 0:48:23,403
但总结一下

927
00:48:24,738 --> 0:48:29,877
我们谈到了订阅优惠

928
00:48:30,143 --> 0:48:36,083
帮助你减少自发流失率

929
00:48:36,149 --> 0:48:38,719
或免费试用 从而保留他们的订阅

930
00:48:39,419 --> 0:48:44,091
Dona给我们详细介绍了实施

931
00:48:44,157 --> 0:48:47,060
用于给世界各地的客户

932
00:48:47,127 --> 0:48:49,029
显示正确内容

933
00:48:49,096 --> 0:48:51,298
（总结）

934
00:48:52,566 --> 0:48:55,569
我们谈了即将发布的一些收据变更

935
00:48:55,636 --> 0:48:58,272
允许你回馈

936
00:48:58,338 --> 0:48:59,406
预订app的忠实客户

937
00:48:59,473 --> 0:49:02,543
也许是给他们提供游戏的初始余额

938
00:48:59,473 --> 0:49:02,543
也许是给他们提供游戏的初始余额

939
00:49:02,843 --> 0:49:05,612
并且如果你还没有这样做 请查看

940
00:49:06,280 --> 0:49:08,415
服务器到服务器通知

941
00:49:08,982 --> 0:49:12,419
并在App Store连接中

942
00:49:12,486 --> 0:49:14,521
以便获得来自App Store

943
00:49:15,656 --> 0:49:17,124
我们讲了宽限期

944
00:49:17,191 --> 0:49:19,793
以及如何提供宽限期

945
00:49:19,860 --> 0:49:24,198
以便增加由于计费问题

946
00:49:24,264 --> 0:49:25,632
导致续订失败的客户的追回率

947
00:49:28,368 --> 0:49:30,404
并且我们讲了情境消息

948
00:49:30,470 --> 0:49:34,541
你可以在app内显示

949
00:49:36,076 --> 0:49:40,380
要获取关于本演讲的更多信息

950
00:49:40,747 --> 0:49:42,482
请查看演讲302

951
00:49:43,050 --> 0:49:44,651
并且今天下午

952
00:49:44,718 --> 0:49:48,188
我的同事们将分享

953
00:49:48,255 --> 0:49:50,657
他们将告诉你如何实施订阅优惠

954
00:49:50,724 --> 0:49:54,061
以及使用订阅优惠

955
00:49:54,127 --> 0:49:56,129
减少自发流失率的不同用例

956
00:49:57,364 --> 0:49:58,899
并且我们会在讨论会中

957
00:49:58,966 --> 0:50:02,402
解答关于这些功能的任何疑问

958
00:49:58,966 --> 0:50:02,402
解答关于这些功能的任何疑问

959
00:50:04,905 --> 0:50:07,774
谢谢大家 祝大家下午愉快
