1
00:00:06,640 --> 0:00:11,512
（关于APP后台执行的改进）

2
00:00:13,280 --> 0:00:16,082
我是Roberto

3
00:00:16,149 --> 0:00:17,017
来自Apple的软件电量团队

4
00:00:17,084 --> 0:00:18,886
今天能来到这里 我感到万分激动

5
00:00:19,186 --> 0:00:21,355
我要与大家分享

6
00:00:21,421 --> 0:00:22,890
（关于APP后台执行的改进）

7
00:00:23,590 --> 0:00:25,259
用户们喜欢用app

8
00:00:25,659 --> 0:00:28,896
他们喜欢用app的原因是因为

9
00:00:29,596 --> 0:00:32,766
有些是在前台

10
00:00:33,467 --> 0:00:35,269
而有些是在后台

11
00:00:35,335 --> 0:00:38,038
要求后台执行才能实现

12
00:00:38,705 --> 0:00:41,408
如果我们提出可能需要后台执行的

13
00:00:41,742 --> 0:00:43,343
我们可能会提出类似这样的东西

14
00:00:43,844 --> 0:00:47,214
比如导航或配件通讯

15
00:00:47,548 --> 0:00:49,550
或也许是定期更新和下载

16
00:00:50,117 --> 0:00:53,620
在Apple我们设计了

17
00:00:53,687 --> 0:00:55,923
用于处理这些用例和提供此类体验

18
00:00:57,591 --> 0:01:00,060
今天我们要讲的是后台执行

19
00:00:57,591 --> 0:01:00,060
今天我们要讲的是后台执行

20
00:01:00,394 --> 0:01:01,461
先概述一下

21
00:01:01,762 --> 0:01:04,096
然后接着讲一些最佳实践

22
00:01:04,631 --> 0:01:06,767
最后我同事Thomas会上台来

23
00:01:06,834 --> 0:01:08,869
介绍一个新的后台任务框架

24
00:01:08,936 --> 0:01:11,338
提供新的后台执行的机会

25
00:01:13,340 --> 0:01:15,509
让我们先简单了解一下后台执行

26
00:01:15,576 --> 0:01:16,910
（后台执行概述）

27
00:01:16,977 --> 0:01:20,581
我们可以先回答这个问题

28
00:01:20,647 --> 0:01:21,715
我们是指什么？

29
00:01:21,782 --> 0:01:24,585
当我们提到后台时

30
00:01:24,651 --> 0:01:26,920
后台线程或后台队列

31
00:01:27,421 --> 0:01:29,156
但当我们讲后台执行时

32
00:01:29,223 --> 0:01:32,292
我们指的是当app不处于前台时

33
00:01:32,593 --> 0:01:34,161
运行我们的执行代码

34
00:01:35,062 --> 0:01:36,663
请看这个图表

35
00:01:37,030 --> 0:01:39,032
我们指的是第三个方框

36
00:01:39,366 --> 0:01:41,468
app在后台运行

37
00:01:41,535 --> 0:01:43,437
但用户不一定能看到它运行

38
00:01:45,372 --> 0:01:47,474
我们为什么要进入这种状态呢？

39
00:01:47,908 --> 0:01:49,843
这可以归结为两种途径

40
00:01:50,677 --> 0:01:52,446
第一种是app发出请求

41
00:01:53,080 --> 0:01:55,816
这应用于更通用的后台执行

42
00:01:56,083 --> 0:01:59,953
当app想实施一些工作时

43
00:02:00,721 --> 0:02:03,790
你可以思考一下

44
00:02:04,124 --> 0:02:05,893
或也许是完成一些后台工作

45
00:02:06,960 --> 0:02:09,830
第二种是通过特定的事件触发器

46
00:02:10,497 --> 0:02:13,834
app获得后台时间

47
00:02:13,901 --> 0:02:16,170
以响应某件事

48
00:02:16,970 --> 0:02:19,873
比如也许用户去了国外

49
00:02:20,340 --> 0:02:22,075
或也许有一些新的健康数据

50
00:02:22,142 --> 0:02:23,677
App需要引起注意

51
00:02:25,946 --> 0:02:29,583
当在后台运行时

52
00:02:29,917 --> 0:02:32,019
因此当我们设计API来支持

53
00:02:32,085 --> 0:02:34,254
我们有许多重要因素要考虑

54
00:02:34,988 --> 0:02:35,989
我想强调其中三个因素

55
00:02:36,056 --> 0:02:37,758
（关于后台执行的重要因素）

56
00:02:37,824 --> 0:02:41,562
电源、性能和隐私

57
00:02:44,031 --> 0:02:45,065
先讲电源

58
00:02:45,732 --> 0:02:48,802
无论何时当你的app在前台或后台

59
00:02:49,236 --> 0:02:50,470
都需要使用电源

60
00:02:50,838 --> 0:02:54,074
随时间流逝 这会消耗能量

61
00:02:55,475 --> 0:02:57,244
为了可视化这种消耗

62
00:02:57,678 --> 0:03:00,280
左侧可能是一天的开始

63
00:02:57,678 --> 0:03:00,280
左侧可能是一天的开始

64
00:03:00,347 --> 0:03:02,149
而右侧可能是一天的结束

65
00:03:02,516 --> 0:03:05,419
也许在一天结束时用户决定

66
00:03:06,486 --> 0:03:08,789
我们用那个绿色充电区来代表它

67
00:03:09,556 --> 0:03:12,326
我们用这些浅阴影矩形

68
00:03:12,392 --> 0:03:13,861
来标绘app在前台运行的时间

69
00:03:14,695 --> 0:03:16,797
我们用这些深阴影矩形

70
00:03:16,864 --> 0:03:18,265
来标绘app在后台运行的时间

71
00:03:19,233 --> 0:03:20,434
如果运行时间越长

72
00:03:20,767 --> 0:03:22,402
我们就会越消耗电量

73
00:03:22,970 --> 0:03:25,272
如果我们运行时间越短

74
00:03:26,473 --> 0:03:28,475
因此 当我们设计API时

75
00:03:28,542 --> 0:03:31,845
我们主要关注为了支持特定用例

76
00:03:31,912 --> 0:03:33,413
同时保持良好的电量

77
00:03:33,747 --> 0:03:36,583
当使用这些API时

78
00:03:36,850 --> 0:03:40,554
当你完成后

79
00:03:41,088 --> 0:03:43,290
那样 如果系统为你的app提供了

80
00:03:43,624 --> 0:03:45,726
你可以告诉系统说

81
00:03:46,026 --> 0:03:49,096
系统可以挂起你的app

82
00:03:50,531 --> 0:03:52,099
接下来是性能

83
00:03:52,733 --> 0:03:55,435
我们希望系统能尽可能流畅地运行

84
00:03:56,136 --> 0:03:59,640
这意味着我们希望能快速启动app

85
00:04:00,107 --> 0:04:02,809
当我们在后台运行时 这尤其重要

86
00:04:03,043 --> 0:04:06,413
原因是虽然我们可能会认为

87
00:04:06,480 --> 0:04:10,517
一天之中只有一个app在运行

88
00:04:11,552 --> 0:04:14,688
但实际上一天中不同的时间点

89
00:04:14,755 --> 0:04:16,322
在前台和后台

90
00:04:17,658 --> 0:04:18,692
当我们遮掩这件事时

91
00:04:18,759 --> 0:04:20,827
我们可以看到我们的app可能正在

92
00:04:20,894 --> 0:04:22,796
而同时另一个app正在前台运行

93
00:04:23,330 --> 0:04:25,199
或者当一个app正在前台运行时

94
00:04:25,265 --> 0:04:26,800
有多个app正在后台运行

95
00:04:27,234 --> 0:04:28,669
因此当我们设计API时

96
00:04:29,269 --> 0:04:32,339
我们要考虑设置智能

97
00:04:32,406 --> 0:04:34,541
从而最小化对其它用途的影响

98
00:04:35,042 --> 0:04:36,410
当使用这些API时

99
00:04:36,777 --> 0:04:38,645
你应该注意这些限制是多少

100
00:04:38,712 --> 0:04:40,814
从而不会影响用户正在积极去做的事

101
00:04:41,048 --> 0:04:43,617
但更重要的是那样系统

102
00:04:44,084 --> 0:04:45,619
然后当你的app以后再启动时

103
00:04:45,686 --> 0:04:46,820
它的启动速度可能会变慢

104
00:04:48,755 --> 0:04:51,024
最后一个重要因素是隐私

105
00:04:51,592 --> 0:04:55,195
用户非常敏感

106
00:04:55,796 --> 0:04:58,465
他们也许了解

107
00:04:58,532 --> 0:05:00,033
app每一次在前台的运行

108
00:04:58,532 --> 0:05:00,033
app每一次在前台的运行

109
00:05:00,100 --> 0:05:02,970
并期待能访问某些信息

110
00:05:03,537 --> 0:05:07,207
他们可能没有意识到app每一次

111
00:05:08,275 --> 0:05:09,776
因此当我们设计API时

112
00:05:09,843 --> 0:05:12,846
这意味着我们要使用不同的API

113
00:05:13,180 --> 0:05:15,983
每个API都要访问

114
00:05:16,049 --> 0:05:17,251
它需要支持那些数据

115
00:05:17,718 --> 0:05:18,919
当使用这些API时

116
00:05:18,986 --> 0:05:20,888
考虑一下对用户的透明度该有多大

117
00:05:21,722 --> 0:05:24,424
并让他们了解你正在使用哪些数据

118
00:05:25,692 --> 0:05:27,594
这些是关于后台执行

119
00:05:27,661 --> 0:05:29,396
要考虑的三个重要因素

120
00:05:29,796 --> 0:05:32,099
电源、性能和隐私

121
00:05:33,033 --> 0:05:34,868
当我们返回到用例列表时

122
00:05:35,335 --> 0:05:38,405
这些不同的用例

123
00:05:39,173 --> 0:05:42,609
每个API都要有不同的要求

124
00:05:42,910 --> 0:05:45,112
同时保持优秀的用户体验

125
00:05:47,281 --> 0:05:48,916
现在我们已经有了个大概的了解

126
00:05:48,982 --> 0:05:52,386
让我们深入一些最佳实践

127
00:05:52,853 --> 0:05:54,555
了解一下API发生了哪些变更

128
00:05:56,390 --> 0:05:59,426
为此 让我们以一款消息app为例

129
00:05:59,760 --> 0:06:01,528
它可能有核心功能 比如

130
00:05:59,760 --> 0:06:01,528
它可能有核心功能 比如

131
00:06:01,929 --> 0:06:04,531
发消息或接打电话

132
00:06:05,098 --> 0:06:06,967
然后它可能还有一些额外功能 比如

133
00:06:07,034 --> 0:06:11,572
可以让用户设置消息免打扰

134
00:06:12,306 --> 0:06:14,241
现在我们要看一下这四个步骤

135
00:06:14,508 --> 0:06:16,977
讲一下我们要使用哪个API来实现

136
00:06:18,412 --> 0:06:19,847
第一个功能是发消息

137
00:06:20,681 --> 0:06:23,250
发消息是app的核心功能

138
00:06:23,817 --> 0:06:25,352
如果我给我朋友发消息

139
00:06:25,419 --> 0:06:28,655
我希望它能马上送达

140
00:06:29,823 --> 0:06:32,326
因此用户期待这个功能可以立即完成

141
00:06:33,293 --> 0:06:35,963
虽然这通常很快

142
00:06:36,396 --> 0:06:38,031
但有时候情况并非如此

143
00:06:38,532 --> 0:06:41,535
也许网络拥挤或也许后台服务器慢

144
00:06:42,035 --> 0:06:44,137
可能需要一些额外的时间

145
00:06:44,972 --> 0:06:46,039
在这段额外的时间内

146
00:06:46,106 --> 0:06:49,209
用户可能甚至会离开app

147
00:06:49,910 --> 0:06:53,113
因此我们需要一种方式来保护

148
00:06:53,814 --> 0:06:55,415
我们要确定我们的消息已成功发送

149
00:06:55,482 --> 0:06:58,585
从而当用户返回app时不会发生

150
00:06:58,952 --> 0:07:01,088
“嘿 为什么我的消息没有发送给

151
00:06:58,952 --> 0:07:01,088
“嘿 为什么我的消息没有发送给

152
00:07:02,389 --> 0:07:04,892
这个功能要使用的API是

153
00:07:06,093 --> 0:07:07,694
它会为app

154
00:07:08,128 --> 0:07:10,163
在app被挂起之前在后台运行

155
00:07:11,031 --> 0:07:14,067
要使用这个API你要调用

156
00:07:14,134 --> 0:07:17,004
或调用

157
00:07:17,271 --> 0:07:18,672
如果app是在扩展中运行的话

158
00:07:19,006 --> 0:07:22,543
再说一次 这是为了要完成

159
00:07:22,809 --> 0:07:25,913
其它例子可能包括把文件保存到磁盘

160
00:07:26,246 --> 0:07:28,782
或完成任意用户发起的请求

161
00:07:29,616 --> 0:07:31,618
让我们在代码中看一下

162
00:07:31,685 --> 0:07:33,153
我们那个发消息的例子

163
00:07:34,354 --> 0:07:36,156
这是发送消息函数

164
00:07:37,858 --> 0:07:40,394
在函数中 当我们创建发送操作之后

165
00:07:40,794 --> 0:07:42,329
我们调用

166
00:07:42,729 --> 0:07:44,164
这就让系统了解

167
00:07:44,231 --> 0:07:47,301
“嘿 我们正在执行任务

168
00:07:47,668 --> 0:07:49,203
也让我们继续完成它”

169
00:07:51,205 --> 0:07:53,073
然后当我们发送完成后

170
00:07:53,574 --> 0:07:55,042
我们…在完成代码块中

171
00:07:55,108 --> 0:07:58,245
我们会告诉系统结束后台任务

172
00:07:58,312 --> 0:07:59,346
我们不再需要时间了

173
00:07:59,847 --> 0:08:01,682
这是为了以下情况

174
00:07:59,847 --> 0:08:01,682
这是为了以下情况

175
00:08:01,748 --> 0:08:03,283
用户把app放到后台

176
00:08:03,350 --> 0:08:04,985
我们要告诉系统把app挂起来

177
00:08:05,285 --> 0:08:06,887
因此我们就不再消耗用户的电量了

178
00:08:06,954 --> 0:08:08,622
或不再潜在地影响他们的性能了

179
00:08:09,456 --> 0:08:10,624
我还要强调最后一件事

180
00:08:11,158 --> 0:08:14,595
有些情况是也许系统给了你一些

181
00:08:14,661 --> 0:08:17,364
但情况太糟糕了 也许网络特别拥挤

182
00:08:17,798 --> 0:08:20,200
我们甚至在额外的时间内也不能

183
00:08:20,601 --> 0:08:22,836
为此 我们有一个过期处理器

184
00:08:23,237 --> 0:08:25,839
系统可以在这个时候调用过期处理器

185
00:08:26,373 --> 0:08:29,343
在这个例子中

186
00:08:29,409 --> 0:08:30,677
一则本地通知

187
00:08:30,744 --> 0:08:33,746
内容是“嘿 请回到app中

188
00:08:35,482 --> 0:08:37,417
那么回顾一下 当我们发送消息时

189
00:08:37,717 --> 0:08:41,154
我们用BackgroundTaskCompletions

190
00:08:42,155 --> 0:08:45,125
我们想确保我们根据用户的动作

191
00:08:45,492 --> 0:08:47,461
我们不想等到我们进入后台

192
00:08:47,528 --> 0:08:48,896
才能调用

193
00:08:49,263 --> 0:08:50,397
因为如果我们这样做了

194
00:08:50,464 --> 0:08:53,333
会限制在系统挂起app之前

195
00:08:53,400 --> 0:08:55,002
我们积极尝试发送消息的时间

196
00:08:56,970 --> 0:08:59,039
现在我们讲了发消息

197
00:08:59,239 --> 0:09:00,307
接下来让我们讲接打电话

198
00:08:59,239 --> 0:09:00,307
接下来让我们讲接打电话

199
00:09:00,374 --> 0:09:01,708
（接打电话）

200
00:09:01,775 --> 0:09:06,013
我可能一直想给我的朋友们发消息

201
00:09:06,079 --> 0:09:07,881
但有时你只想接通电话

202
00:09:07,948 --> 0:09:10,150
快速接听电话

203
00:09:10,484 --> 0:09:12,819
告诉他们一些事

204
00:09:13,520 --> 0:09:17,124
有个API能实现这个功能

205
00:09:17,791 --> 0:09:20,460
这是一种特殊的推送类型

206
00:09:20,794 --> 0:09:21,762
并为它提供一些运行时间

207
00:09:21,828 --> 0:09:24,831
那样你可以向用户呈现

208
00:09:24,898 --> 0:09:26,333
然后用户可以接电话

209
00:09:27,935 --> 0:09:28,936
为了实现这个功能

210
00:09:29,303 --> 0:09:30,938
你只需要在注册VoIP推送时

211
00:09:32,206 --> 0:09:36,310
在PK推送注册中

212
00:09:39,646 --> 0:09:41,114
今年有个新改进

213
00:09:41,448 --> 0:09:45,152
你必须在didReceiveIncomingPush

214
00:09:45,752 --> 0:09:48,589
使用CallKit报告来电

215
00:09:49,223 --> 0:09:50,624
否则你的app将被终止

216
00:09:51,191 --> 0:09:53,060
并且如果你反复这样做

217
00:09:53,393 --> 0:09:56,129
或如果导入来电反复失败

218
00:09:56,430 --> 0:09:59,533
系统可能会完全停止启动app

219
00:10:00,968 --> 0:10:04,004
让我们看一下如何在代码中

220
00:10:05,239 --> 0:10:08,175
这是我们的didReceiveIncomingPush

221
00:10:08,909 --> 0:10:12,613
在回调内我们看到如果推送类型

222
00:10:12,679 --> 0:10:14,748
我们将使用来自推送有效载荷的信息

223
00:10:14,815 --> 0:10:17,017
来填充CX呼叫更新对象

224
00:10:17,451 --> 0:10:21,555
然后使用CX提供器报告新来电

225
00:10:25,125 --> 0:10:27,661
你需要确保在那个方法返回之前

226
00:10:27,728 --> 0:10:29,129
报告来电

227
00:10:29,796 --> 0:10:32,199
否则系统…系统将终止app的运行

228
00:10:33,166 --> 0:10:35,402
还有一些其它小技巧

229
00:10:35,836 --> 0:10:38,872
如果你在推送有效载荷中包含

230
00:10:38,939 --> 0:10:41,375
然后你将拥有快速呈现

231
00:10:41,441 --> 0:10:42,643
那个来电UI所需要的全部信息

232
00:10:42,943 --> 0:10:45,078
因此请尝试包含尽可能多的信息

233
00:10:45,379 --> 0:10:47,948
从而你可以呈现尽可能丰富的UI

234
00:10:49,583 --> 0:10:53,153
第二 确保你把推送的

235
00:10:53,420 --> 0:10:55,055
设置为零或一些很小的值

236
00:10:56,056 --> 0:10:58,492
这样用户将不会在来电几分钟后

237
00:10:58,559 --> 0:11:00,928
而此时已经停止拨打电话了

238
00:10:58,559 --> 0:11:00,928
而此时已经停止拨打电话了

239
00:11:01,862 --> 0:11:02,930
比如说

240
00:11:02,996 --> 0:11:06,767
如果某人给我打电话了

241
00:11:07,100 --> 0:11:09,203
然后一旦推送在两分钟之后才送达

242
00:11:09,269 --> 0:11:11,071
我不想报告来电

243
00:11:11,371 --> 0:11:13,707
因为那个人很可能已经不再

244
00:11:14,174 --> 0:11:16,343
因此如果我们把过期时间设置为零

245
00:11:16,410 --> 0:11:18,378
那意味着要立即提交或提交失败

246
00:11:18,445 --> 0:11:20,147
或几秒之内完成

247
00:11:20,447 --> 0:11:22,850
然后我们就知道

248
00:11:22,916 --> 0:11:24,585
这仍然是一个相关的来电

249
00:11:25,986 --> 0:11:29,022
重点是要注意如果你想发送通知

250
00:11:29,089 --> 0:11:32,359
你总是可以使用标准推送

251
00:11:32,426 --> 0:11:34,928
那样你就不需要在呼叫UI中

252
00:11:35,295 --> 0:11:37,564
并且你可以使用通知服务扩展

253
00:11:37,631 --> 0:11:39,533
如果你需要修改推送内容的话

254
00:11:39,600 --> 0:11:41,268
比如 如果你需要解密推送内容的话

255
00:11:42,836 --> 0:11:44,938
那么这就是VoIP推送和接打电话

256
00:11:45,405 --> 0:11:47,007
现在让我们讲一下静音线程

257
00:11:47,074 --> 0:11:48,275
（静音线程）

258
00:11:48,675 --> 0:11:50,677
当用户有个消息app时

259
00:11:50,744 --> 0:11:52,479
他们可能会给许多不同的朋友

260
00:11:52,546 --> 0:11:54,047
或许多不同的朋友群发送消息

261
00:11:54,248 --> 0:11:57,150
其中有些线程可能会很繁忙

262
00:11:57,217 --> 0:11:59,920
用户可能不想收到

263
00:12:00,621 --> 0:12:03,257
但内容仍然可能是相关内容

264
00:12:03,323 --> 0:12:04,591
内容可能仍然不错

265
00:12:05,158 --> 0:12:06,560
当用户返回到app中时

266
00:12:06,627 --> 0:12:07,961
他们想查看消息

267
00:12:08,028 --> 0:12:10,831
他们只是不想当每次接收消息时

268
00:12:11,098 --> 0:12:12,332
都要震动设备并收到通知

269
00:12:13,233 --> 0:12:16,570
因此我们需要一种方式可以警告设备

270
00:12:16,937 --> 0:12:18,739
关于有可用的新内容了

271
00:12:20,107 --> 0:12:22,342
为此你应该使用后台推送

272
00:12:23,710 --> 0:12:26,213
后台推送是一种机制 告诉设备

273
00:12:26,280 --> 0:12:29,049
有新数据可用 而不警告用户

274
00:12:30,717 --> 0:12:31,652
要使用这些

275
00:12:31,718 --> 0:12:34,588
你只需要把内容可用标志设置为一

276
00:12:34,955 --> 0:12:37,157
不需要警告 不需要声音

277
00:12:37,958 --> 0:12:39,893
然后系统将决定

278
00:12:39,960 --> 0:12:41,929
何时启动app下载内容

279
00:12:42,596 --> 0:12:46,099
根据电量和性能影响

280
00:12:46,633 --> 0:12:48,168
我们可以在时间线上看一下这个过程

281
00:12:48,635 --> 0:12:49,770
看起来类似这样

282
00:12:50,771 --> 0:12:52,239
用户可能正在使用app

283
00:12:52,506 --> 0:12:54,174
并决定静音某个线程

284
00:12:54,708 --> 0:12:56,610
然后在将来的某个时间点

285
00:12:56,677 --> 0:12:58,278
某人可能在那个线程上发了消息

286
00:12:58,345 --> 0:13:00,314
设备将收到后台推送

287
00:12:58,345 --> 0:13:00,314
设备将收到后台推送

288
00:13:01,548 --> 0:13:03,750
在此之后的某个时间app将被启动

289
00:13:04,017 --> 0:13:05,919
并获得一些运行时间来取回那个内容

290
00:13:07,020 --> 0:13:09,923
然后当用户稍后返回到app中时

291
00:13:10,290 --> 0:13:12,559
打开app 用户可以打开线程

292
00:13:12,626 --> 0:13:14,428
并看到已经收到内容了

293
00:13:14,962 --> 0:13:17,865
对于后台推送也有一些非常重要的

294
00:13:17,931 --> 0:13:19,132
（后台推送）

295
00:13:19,199 --> 0:13:23,837
你必须把APN优先级设置为五

296
00:13:25,405 --> 0:13:28,509
并且你还应该把APNS推送类型

297
00:13:28,842 --> 0:13:30,544
这是watchOS所必需的

298
00:13:30,911 --> 0:13:33,480
但我们强烈建议在所有平台上

299
00:13:34,214 --> 0:13:36,817
如果你想获得关于在

300
00:13:37,251 --> 0:13:40,287
昨天有场单独的Watch app

301
00:13:42,656 --> 0:13:44,591
回顾一下 对于静音线程

302
00:13:45,325 --> 0:13:48,328
使用后台推送

303
00:13:48,729 --> 0:13:52,366
如果app没有获得运行时间

304
00:13:52,432 --> 0:13:54,401
在收到后台推送后

305
00:13:54,668 --> 0:13:58,138
你总是可以在app重新进入前台时

306
00:14:00,574 --> 0:14:02,709
现在让我们谈谈下载以前的附件

307
00:14:04,845 --> 0:14:06,413
假如用户登录了他们的账户

308
00:14:07,347 --> 0:14:09,149
他们在一台新设备上登录了

309
00:14:09,783 --> 0:14:12,753
他们可能想立即从账户中

310
00:14:12,819 --> 0:14:15,389
比如对话列表或某些最近的消息

311
00:14:16,723 --> 0:14:18,859
但可能有一批比较老的内容

312
00:14:18,926 --> 0:14:21,061
如果你不在用户进入app时

313
00:14:21,328 --> 0:14:22,596
那非常好

314
00:14:23,697 --> 0:14:24,765
想象一下

315
00:14:25,132 --> 0:14:28,869
如果我们可以在设备充电时和闲置时

316
00:14:28,936 --> 0:14:30,637
我们为什么要在用户处于前台时

317
00:14:31,205 --> 0:14:34,508
那可能会潜在地

318
00:14:35,943 --> 0:14:39,179
实现方式是使用

319
00:14:40,147 --> 0:14:43,483
这可以让系统推迟下载

320
00:14:44,184 --> 0:14:47,588
这个API可以让你传递更多信息

321
00:14:47,955 --> 0:14:49,690
从而它可以更智能地安排时间

322
00:14:50,490 --> 0:14:51,491
要使用它

323
00:14:51,792 --> 0:14:54,561
你需要像往常那样

324
00:14:55,295 --> 0:14:57,798
然后把任意标志设为真

325
00:14:59,666 --> 0:15:01,735
让我们看一下你可以传入的一些

326
00:14:59,666 --> 0:15:01,735
让我们看一下你可以传入的一些

327
00:15:01,802 --> 0:15:04,271
从而使系统变得更智能

328
00:15:05,606 --> 0:15:07,274
你可以传入超时间隔

329
00:15:07,608 --> 0:15:10,277
也许你不希望系统一直尝试下载

330
00:15:10,344 --> 0:15:11,745
因此你希望可以界定系统可以下载

331
00:15:13,280 --> 0:15:15,082
你可以传入一个最早开始时间

332
00:15:15,415 --> 0:15:17,251
也许你不想执行上传或下载

333
00:15:17,317 --> 0:15:18,719
直到将来的某个时间点

334
00:15:19,353 --> 0:15:22,256
并且你可以传入所预期的工作量大小

335
00:15:22,523 --> 0:15:26,393
从而系统了解当运行下载时

336
00:15:26,460 --> 0:15:27,561
有多少工作要做

337
00:15:30,430 --> 0:15:32,566
当你正在下载以前的附件时

338
00:15:32,833 --> 0:15:36,370
如果可能的话 你希望推迟这个操作

339
00:15:36,837 --> 0:15:40,707
我们可以对任意可推迟的下载或上传

340
00:15:41,141 --> 0:15:43,644
也许你有一些分析

341
00:15:43,710 --> 0:15:44,912
你想在一个更合适的时间批量上传

342
00:15:45,179 --> 0:15:46,813
或也许有一些用户拍摄的照片

343
00:15:47,080 --> 0:15:48,282
你想稍后再进行备份

344
00:15:49,850 --> 0:15:51,952
回顾一下 我们有一款消息app

345
00:15:52,019 --> 0:15:53,687
它有一些核心功能

346
00:15:54,054 --> 0:15:56,089
你可以发消息、接打电话

347
00:15:56,757 --> 0:15:59,393
允许用户设置消息免打扰

348
00:16:00,093 --> 0:16:02,663
我们使用了不同的API

349
00:16:03,030 --> 0:16:04,598
我们使用

350
00:16:04,865 --> 0:16:07,401
保障即使用户离开app

351
00:16:07,868 --> 0:16:10,204
我们使用VoIP推送

352
00:16:10,704 --> 0:16:13,507
我们使用后台推送

353
00:16:13,574 --> 0:16:16,443
作为给app提供运行时间

354
00:16:16,777 --> 0:16:20,380
并且我们使用任意URL会话

355
00:16:21,682 --> 0:16:23,317
但还有许多其它用例

356
00:16:23,383 --> 0:16:25,519
我们现有的模式目前还没有覆盖到

357
00:16:25,819 --> 0:16:27,421
因此我想邀请我同事

358
00:16:27,487 --> 0:16:30,023
介绍一种新的后台模式和框架

359
00:16:30,090 --> 0:16:31,758
是特别针对这些用例设计的

360
00:16:32,092 --> 0:16:32,926
谢谢大家

361
00:16:35,229 --> 0:16:36,063
谢谢Roberto

362
00:16:36,830 --> 0:16:38,465
让我们讲一下这些用例

363
00:16:38,532 --> 0:16:39,733
（新的后台任务框架）

364
00:16:39,800 --> 0:16:43,170
这些是比如主动与服务器同步状态

365
00:16:43,637 --> 0:16:44,972
清理数据库

366
00:16:45,305 --> 0:16:46,773
或把数据备份到Cloud

367
00:16:47,274 --> 0:16:49,776
这些是可推迟的维护型任务

368
00:16:50,177 --> 0:16:52,513
你最好在后台执行

369
00:16:52,779 --> 0:16:55,549
从而不影响前台用户活动

370
00:16:56,416 --> 0:16:57,618
如今我们看到的是

371
00:16:57,684 --> 0:17:01,288
app在进入后台后就立即执行

372
00:16:57,684 --> 0:17:01,288
app在进入后台后就立即执行

373
00:17:01,655 --> 0:17:03,423
在一整天之中

374
00:17:03,757 --> 0:17:05,092
这些任务其实可以累计起来一起执行

375
00:17:06,326 --> 0:17:08,462
如果你可以把全部那种任务都推迟到

376
00:17:08,795 --> 0:17:11,999
也许是当设备充电时或闲置时？

377
00:17:13,032 --> 0:17:15,135
这就是我们今年引入的新功能

378
00:17:15,202 --> 0:17:18,505
一个全新的后台模式和与之匹配的

379
00:17:18,571 --> 0:17:20,040
我们叫做后台任务

380
00:17:20,773 --> 0:17:21,775
后台任务

381
00:17:21,842 --> 0:17:25,045
可以让你稍后在后台执行任务

382
00:17:26,413 --> 0:17:29,550
它在iOS、iPadOS、

383
00:17:30,017 --> 0:17:32,819
tvOS上可用 对Mac上的

384
00:17:34,054 --> 0:17:37,124
我们不仅引入了这个新后台模式

385
00:17:37,191 --> 0:17:38,892
我们调用后台处理任务

386
00:17:39,560 --> 0:17:43,063
我们还利用这个机会

387
00:17:43,330 --> 0:17:44,831
在后台刷新app的功能

388
00:17:46,733 --> 0:17:48,669
先讲一下新后台模式

389
00:17:49,369 --> 0:17:50,737
后台处理任务

390
00:17:51,104 --> 0:17:54,575
可以在系统友好时间为你的app

391
00:17:55,242 --> 0:17:58,278
从而你可以执行我之前提到的

392
00:17:58,345 --> 0:18:01,215
可推迟的维护级任务以及新任务

393
00:17:58,345 --> 0:18:01,215
可推迟的维护级任务以及新任务

394
00:18:01,481 --> 0:18:02,850
比如设备上、

395
00:18:02,916 --> 0:18:05,519
Core ML、在后台训练和推断

396
00:18:05,586 --> 0:18:07,254
你可以从它们各自的演讲中

397
00:18:07,321 --> 0:18:08,589
（后台处理任务）

398
00:18:09,356 --> 0:18:11,391
CPU监控是系统的一个功能

399
00:18:11,725 --> 0:18:15,062
自动终止在后台使用了太多

400
00:18:15,128 --> 0:18:18,398
以保护用户的电量

401
00:18:19,132 --> 0:18:20,434
有史以来我们首次

402
00:18:20,501 --> 0:18:22,903
可以让你在任务处理过程中

403
00:18:22,970 --> 0:18:24,838
关闭CPU监控

404
00:18:25,138 --> 0:18:27,274
从而你可以在设备充电时

405
00:18:27,341 --> 0:18:28,876
充分利用硬件

406
00:18:30,677 --> 0:18:33,247
最后我们会确保你有资格

407
00:18:33,313 --> 0:18:36,149
运行这些任务

408
00:18:36,216 --> 0:18:37,651
只要你在app处于前台时

409
00:18:37,718 --> 0:18:40,521
或如果你的app最近在前台使用过

410
00:18:42,189 --> 0:18:43,390
（后台APP刷新任务）

411
00:18:43,457 --> 0:18:47,628
接下来我要讲用于后台app刷新的

412
00:18:48,762 --> 0:18:50,063
这是个新API

413
00:18:50,130 --> 0:18:52,566
但它的政策与当前API一模一样

414
00:18:53,000 --> 0:18:56,770
这意味着app每次启动时将获得

415
00:18:57,104 --> 0:19:00,307
用于获取新内容并在一天内保持

416
00:18:57,104 --> 0:19:00,307
用于获取新内容并在一天内保持

417
00:19:02,409 --> 0:19:05,279
app的启动频率以及何时启动

418
00:19:05,345 --> 0:19:07,881
取决于用户在过于使用app的方式

419
00:19:09,016 --> 0:19:12,452
因此如果用户一般在早上、

420
00:19:12,753 --> 0:19:14,555
下午和晚上使用你的app

421
00:19:15,022 --> 0:19:17,724
系统将会了解这种模式

422
00:19:17,791 --> 0:19:19,259
启动你的app

423
00:19:19,326 --> 0:19:21,929
因此你就有机会获得你所需要的内容

424
00:19:23,030 --> 0:19:26,233
这也意味着

425
00:19:26,300 --> 0:19:27,935
启动频率可能也不高

426
00:19:30,137 --> 0:19:33,674
正如我所提到过的

427
00:19:33,740 --> 0:19:37,211
因此我们不推荐使用你在这里看到的

428
00:19:38,212 --> 0:19:40,013
但这些API可以继续使用

429
00:19:40,080 --> 0:19:44,952
它们在iOS、iPadOS

430
00:19:45,385 --> 0:19:46,987
但Mac上不支持它们

431
00:19:47,054 --> 0:19:49,223
因此一定要采用后台任务

432
00:19:49,289 --> 0:19:50,958
在Mac上执行后台app刷新

433
00:19:53,760 --> 0:19:55,729
让我们看看这个API是如何运作的

434
00:19:56,930 --> 0:20:00,267
假如我们有一款app

435
00:19:56,930 --> 0:20:00,267
假如我们有一款app

436
00:20:01,635 --> 0:20:03,937
你将与之交互的原始对象是

437
00:20:04,304 --> 0:20:06,139
后台任务调度程序

438
00:20:07,508 --> 0:20:09,076
后台任务调度程序

439
00:20:09,142 --> 0:20:13,680
是系统智能的、

440
00:20:13,981 --> 0:20:16,617
它持续监控各种系统情况

441
00:20:17,050 --> 0:20:21,455
包括电量等级、app的使用、

442
00:20:23,323 --> 0:20:24,758
当app正在运行时

443
00:20:24,825 --> 0:20:28,061
你可以请求它稍后在后台唤醒它

444
00:20:28,829 --> 0:20:33,267
为此 你要创建一个后台任务

445
00:20:34,334 --> 0:20:36,970
响应你要实施的任务的类型

446
00:20:37,437 --> 0:20:40,440
在这个例子中

447
00:20:40,707 --> 0:20:43,377
因此我发起了一个

448
00:20:44,378 --> 0:20:45,746
我们把它提交给调度程序

449
00:20:47,447 --> 0:20:49,750
如果你想执行多种类型的任务

450
00:20:49,816 --> 0:20:51,351
你可以提交多个请求

451
00:20:51,718 --> 0:20:54,188
在这个例子中

452
00:20:54,488 --> 0:20:58,358
因此我也要发起一个

453
00:21:00,661 --> 0:21:03,964
你还可以当扩展正在运行时

454
00:21:05,165 --> 0:21:08,302
因此如果你的键盘扩展

455
00:21:08,368 --> 0:21:09,736
想根据用户的键入习惯进行学习

456
00:21:10,070 --> 0:21:13,240
它也可以创建一个后台处理任务请求

457
00:21:14,174 --> 0:21:15,175
你可以看到

458
00:21:15,242 --> 0:21:18,345
你有多个等待处理的

459
00:21:18,879 --> 0:21:22,783
每个都代表你希望app执行的

460
00:21:24,418 --> 0:21:27,387
现在调度程序知道我们的app

461
00:21:28,722 --> 0:21:30,991
当满足所有必要的系统条件

462
00:21:31,058 --> 0:21:32,492
和政策时

463
00:21:33,060 --> 0:21:34,528
它将执行那个任务

464
00:21:34,962 --> 0:21:37,598
唤醒你的app并在后台启动它

465
00:21:38,498 --> 0:21:40,968
给它提交一个

466
00:21:41,034 --> 0:21:43,036
响应你应该实施的那个任务的

467
00:21:43,770 --> 0:21:46,273
在这个例子中

468
00:21:46,640 --> 0:21:50,577
因此我们现在可以实施

469
00:21:50,644 --> 0:21:51,645
并更新我们的UI

470
00:21:52,880 --> 0:21:55,582
当我们完成后 我们要调用

471
00:21:55,949 --> 0:21:59,319
它会把任务标记为完成并挂起app

472
00:22:01,054 --> 0:22:03,957
根据你对后台任务请求的配置方式

473
00:22:04,024 --> 0:22:05,926
以及各种系统情况和政策

474
00:22:06,627 --> 0:22:10,130
我们可能选择同时启动app执行

475
00:22:11,031 --> 0:22:14,401
在这个例子中

476
00:22:14,701 --> 0:22:17,171
系统向app同时提交了之前请求的

477
00:22:18,572 --> 0:22:19,540
当app启动时

478
00:22:19,606 --> 0:22:22,609
系统就为它提供一段有限的时间

479
00:22:23,010 --> 0:22:26,113
那个时间是按启动来分配的

480
00:22:26,513 --> 0:22:30,317
因此你应该准备好

481
00:22:30,584 --> 0:22:31,518
同时地处理分配给你的全部任务

482
00:22:32,252 --> 0:22:36,590
同时请注意键盘扩展发起的

483
00:22:36,890 --> 0:22:38,392
会提交到主app中

484
00:22:38,926 --> 0:22:42,329
那是因为始终是启动主app

485
00:22:42,396 --> 0:22:45,532
来处理后台任务 而不是启动扩展

486
00:22:47,935 --> 0:22:49,970
当app完成执行必要的任务之后

487
00:22:50,037 --> 0:22:53,273
在系统分配给它的全部后台任务

488
00:22:53,774 --> 0:22:54,675
然后就会挂起app

489
00:22:55,409 --> 0:22:58,779
这就是关于如何使用

490
00:22:59,379 --> 0:23:01,849
你创建后台任务请求

491
00:22:59,379 --> 0:23:01,849
你创建后台任务请求

492
00:23:02,182 --> 0:23:03,517
并提交给后台任务调度程序

493
00:23:04,051 --> 0:23:06,453
等待系统在后台启动你的app

494
00:23:06,920 --> 0:23:08,255
执行必要的任务

495
00:23:08,522 --> 0:23:11,859
然后在BG任务对象上调用

496
00:23:12,926 --> 0:23:15,462
为了让你了解如何在你的app中

497
00:23:15,729 --> 0:23:17,030
我要给你做一个演示

498
00:23:24,771 --> 0:23:25,873
这是我们的app

499
00:23:25,939 --> 0:23:29,009
它叫做Color Feed

500
00:23:29,343 --> 0:23:31,845
除了照片信息

501
00:23:31,912 --> 0:23:33,814
你还可以获得最近流行颜色的信息

502
00:23:34,448 --> 0:23:36,116
你可以看到

503
00:23:36,183 --> 0:23:38,819
我可以滚动并查看

504
00:23:39,086 --> 0:23:40,320
不同的时间点的最新颜色

505
00:23:41,421 --> 0:23:42,689
我其实想做的是

506
00:23:42,956 --> 0:23:45,259
确保我的app在一天的时间里

507
00:23:45,325 --> 0:23:47,060
并进行自我刷新

508
00:23:47,127 --> 0:23:49,196
而不需要用户进入app并手动操作

509
00:23:49,830 --> 0:23:52,466
处理这个问题最完美的工具是

510
00:23:52,533 --> 0:23:54,401
我要通过后台任务实施这个操作

511
00:23:55,903 --> 0:23:57,437
你要做的第一件事就是

512
00:23:57,804 --> 0:24:00,741
向info.plist中

513
00:23:57,804 --> 0:24:00,741
向info.plist中

514
00:24:00,807 --> 0:24:02,843
声明你对后台任务

515
00:24:03,243 --> 0:24:04,311
和后台app刷新的支持

516
00:24:04,978 --> 0:24:07,748
因此我要进入我的项目设置

517
00:24:09,783 --> 0:24:11,351
点击我app的目标

518
00:24:13,020 --> 0:24:15,122
并进入“签名和功能”选项卡

519
00:24:16,990 --> 0:24:19,393
我要点击加号并为后台模式

520
00:24:20,327 --> 0:24:21,361
添加新功能

521
00:24:23,964 --> 0:24:26,099
你可以看到 它增加了这个新的部分

522
00:24:26,166 --> 0:24:29,069
我们需要给这种类型的任务

523
00:24:29,603 --> 0:24:31,338
在这个例子中 对于后台app刷新

524
00:24:31,672 --> 0:24:34,675
该框标记为后台提取

525
00:24:34,942 --> 0:24:36,210
因此我要继续并查看一下

526
00:24:38,045 --> 0:24:40,914
接下来我要进入我的

527
00:24:41,348 --> 0:24:42,316
就在这里…

528
00:24:43,884 --> 0:24:46,854
我要点击加号并添加一个新键

529
00:24:48,789 --> 0:24:52,392
这个键叫做PermittedBackground

530
00:24:52,993 --> 0:24:54,795
它是一个字符串的数组

531
00:24:55,462 --> 0:24:57,397
这个数组中的每个字符串

532
00:24:57,464 --> 0:25:00,634
都唯一标识你的app要执行的

533
00:24:57,464 --> 0:25:00,634
都唯一标识你的app要执行的

534
00:25:01,034 --> 0:25:02,803
并且它在你的app内应该是唯一的

535
00:25:03,270 --> 0:25:05,472
我们推荐使用反向DNS表示法

536
00:25:05,539 --> 0:25:08,308
避免与你可能使用的任何第三方框架

537
00:25:09,977 --> 0:25:12,279
在这里我要扩展那个数组

538
00:25:12,346 --> 0:25:14,114
并点击加号来添加新字符串

539
00:25:15,282 --> 0:25:18,752
我要把它命名为

540
00:25:20,554 --> 0:25:21,555
并点击保存

541
00:25:22,389 --> 0:25:24,825
接下来当我的app启动时

542
00:25:25,092 --> 0:25:26,493
我需要实际实施要处理的代码

543
00:25:26,960 --> 0:25:28,662
我要在app委托中实现

544
00:25:31,732 --> 0:25:33,333
我要进入app委托文件

545
00:25:33,400 --> 0:25:35,702
我要做的第一件事是导入后台任务

546
00:25:39,673 --> 0:25:40,507
好吧

547
00:25:41,175 --> 0:25:42,409
下一步

548
00:25:42,876 --> 0:25:45,479
就是告诉系统当你启动时你想做什么

549
00:25:45,546 --> 0:25:48,415
你可以通过在app完成启动之前

550
00:25:48,482 --> 0:25:50,417
就注册启动处理器来实现

551
00:25:51,285 --> 0:25:54,788
didFinishLaunching

552
00:25:55,556 --> 0:25:56,657
我要调用…

553
00:25:58,892 --> 0:26:01,061
共享后台任务调度程序

554
00:25:58,892 --> 0:26:01,061
共享后台任务调度程序

555
00:26:01,128 --> 0:26:03,130
用标识符注册任务

556
00:26:03,530 --> 0:26:07,434
传入我刚放在info.plist

557
00:26:08,702 --> 0:26:10,771
下一个参数是一个分派队列

558
00:26:10,838 --> 0:26:12,873
我的处理器将调用分派队列

559
00:26:12,940 --> 0:26:14,775
并且如果我想在app中

560
00:26:14,842 --> 0:26:16,810
我可以指定我要使用的队列

561
00:26:17,411 --> 0:26:19,012
或我可以传入无

562
00:26:19,079 --> 0:26:21,949
系统将替我创建一个后台串行队列

563
00:26:23,483 --> 0:26:24,585
下一个参数是

564
00:26:24,651 --> 0:26:25,986
启动处理器

565
00:26:26,053 --> 0:26:28,755
当在后台启动app执行后台任务时

566
00:26:29,523 --> 0:26:30,390
你可以看到

567
00:26:30,457 --> 0:26:32,693
它接受后台任务的一个参数

568
00:26:34,094 --> 0:26:35,195
我要做的是

569
00:26:35,629 --> 0:26:40,767
调用一个方法…我要编写一个名为

570
00:26:41,068 --> 0:26:45,506
把那个后台任务对象向下转换为

571
00:26:45,839 --> 0:26:47,708
因为这是用于后台app刷新的参数

572
00:26:48,842 --> 0:26:51,345
现在我要继续并编写那个

573
00:26:55,015 --> 0:26:56,850
我在这里编写了

574
00:26:56,917 --> 0:26:58,986
所需要的全部代码

575
00:26:59,286 --> 0:27:01,722
它将从服务器获取最新内容

576
00:26:59,286 --> 0:27:01,722
它将从服务器获取最新内容

577
00:27:01,788 --> 0:27:03,991
更新数据库并更新UI

578
00:27:04,658 --> 0:27:06,660
为了把这个与后台任务集成到一起

579
00:27:07,127 --> 0:27:08,896
我需要做两件事

580
00:27:09,663 --> 0:27:11,832
第一件是处理过期

581
00:27:12,566 --> 0:27:15,969
系统为你的任务分配了有限的

582
00:27:16,570 --> 0:27:18,805
当你的时间差不多要用完时

583
00:27:18,872 --> 0:27:21,475
我们会警告你并给你提供一个机会

584
00:27:21,542 --> 0:27:22,676
让你快速完成全部工作

585
00:27:23,010 --> 0:27:26,480
系统可能还选择提早终止你的任务

586
00:27:26,747 --> 0:27:29,950
如果系统决定当前情况

587
00:27:30,017 --> 0:27:31,084
不足以运行你的任务的话

588
00:27:32,186 --> 0:27:35,289
我要做的就是在任务上设置一个

589
00:27:36,690 --> 0:27:39,126
在过期处理器中

590
00:27:39,693 --> 0:27:42,596
我要在我的操作队列上调用

591
00:27:42,663 --> 0:27:44,965
这会停止我正在做的全部工作

592
00:27:45,032 --> 0:27:47,000
并取消我甚至还没开始的任何工作

593
00:27:48,569 --> 0:27:49,903
我要做的下一件事是

594
00:27:50,404 --> 0:27:55,008
完成之后在任务上调用

595
00:27:56,410 --> 0:27:59,580
即使在系统调用过期处理器之后

596
00:28:01,081 --> 0:28:02,816
如果我不这样做

597
00:28:02,883 --> 0:28:04,651
系统实际上可能会终止我的app

598
00:28:05,052 --> 0:28:07,020
那会影响稍后的启动性能

599
00:28:07,087 --> 0:28:08,188
你绝对不想那样做

600
00:28:08,722 --> 0:28:10,858
我要做的是

601
00:28:10,924 --> 0:28:12,059
我要…

602
00:28:13,227 --> 0:28:16,964
在那个队列中的最后一个操作

603
00:28:17,397 --> 0:28:18,966
调用

604
00:28:19,333 --> 0:28:20,868
我要充分利用这一点

605
00:28:21,101 --> 0:28:23,203
即操作总是会调用它们的完成代码块

606
00:28:23,537 --> 0:28:26,373
无论操作是被提早取消或是正常完成

607
00:28:26,640 --> 0:28:29,910
并且我通过这一点来决定

608
00:28:31,144 --> 0:28:32,913
好吧 最后一步…

609
00:28:33,347 --> 0:28:36,016
是安排后台任务请求

610
00:28:36,617 --> 0:28:39,286
并且我要当app进入后台时再安排

611
00:28:39,353 --> 0:28:41,421
因为那时用户会停止使用app

612
00:28:41,655 --> 0:28:42,990
因此我要继续并编写这个功能

613
00:28:47,494 --> 0:28:48,495
你可以看到

614
00:28:48,562 --> 0:28:51,498
我正在调用我刚才编写的那个

615
00:28:51,565 --> 0:28:53,467
而我的app确实进入了后台方法

616
00:28:53,834 --> 0:28:57,437
在这里我要创建一个后台app

617
00:28:58,005 --> 0:29:00,307
并给它传入那个相同的标识符

618
00:28:58,005 --> 0:29:00,307
并给它传入那个相同的标识符

619
00:29:01,341 --> 0:29:04,945
然后我把那个请求提交到

620
00:29:06,480 --> 0:29:08,916
有一个额外属性

621
00:29:08,982 --> 0:29:10,484
我想在任务请求对象上调用

622
00:29:11,151 --> 0:29:12,920
即最早开始时间

623
00:29:13,453 --> 0:29:16,056
你可以通过这个给任务指定开始推迟

624
00:29:16,590 --> 0:29:19,826
在这个例子中

625
00:29:19,893 --> 0:29:24,264
不要开始刷新app 除非在我安排

626
00:29:24,565 --> 0:29:26,300
这让我获得了与老的

627
00:29:26,366 --> 0:29:29,369
SetMinimumBackgroundFetchInterval

628
00:29:31,071 --> 0:29:32,739
我安排我的任务

629
00:29:32,806 --> 0:29:35,642
但实际上我很可能还想做另一件事

630
00:29:36,677 --> 0:29:39,780
因为每个单个后台任务请求对象

631
00:29:39,847 --> 0:29:41,682
恰好响应一次启动

632
00:29:42,182 --> 0:29:45,219
现在如果系统启动了我的app

633
00:29:45,285 --> 0:29:48,488
系统将不会再次启动它

634
00:29:48,889 --> 0:29:51,592
但我并不希望这样

635
00:29:51,992 --> 0:29:55,462
因此我要做的就是

636
00:29:55,529 --> 0:29:56,396
调用

637
00:29:57,297 --> 0:30:00,434
我会在系统启动app执行

638
00:29:57,297 --> 0:30:00,434
我会在系统启动app执行

639
00:30:01,835 --> 0:30:03,971
就是这个

640
00:30:04,037 --> 0:30:05,839
后台app刷新

641
00:30:07,241 --> 0:30:09,543
但因为我正在使用app

642
00:30:10,644 --> 0:30:14,314
我看到那有许多很久之前的内容

643
00:30:14,381 --> 0:30:16,750
那可能是不再与用户相关的内容

644
00:30:16,817 --> 0:30:18,085
只是占用磁盘空间

645
00:30:18,552 --> 0:30:21,788
如果我们可以为用户清理数据库

646
00:30:22,289 --> 0:30:25,459
最好的工具就是后台处理任务

647
00:30:25,526 --> 0:30:27,294
我要继续并实施它

648
00:30:28,595 --> 0:30:31,031
跟以前一样 我要进入我的项目设置

649
00:30:32,132 --> 0:30:33,567
进入“签名和功能”选项卡

650
00:30:34,468 --> 0:30:36,503
这一次 在后台模式中

651
00:30:36,803 --> 0:30:39,706
我要确保勾选后台处理复选框

652
00:30:43,644 --> 0:30:44,945
我要进入

653
00:30:47,080 --> 0:30:49,183
并点击加号添加新标识符

654
00:30:49,783 --> 0:30:53,420
我把它命名为

655
00:30:56,089 --> 0:30:56,957
并点击保存

656
00:30:58,091 --> 0:30:59,226
然后跟以前一样

657
00:30:59,526 --> 0:31:00,928
我要进入app委托…

658
00:30:59,526 --> 0:31:00,928
我要进入app委托…

659
00:31:01,762 --> 0:31:03,197
并再次调用注册

660
00:31:07,000 --> 0:31:09,269
这跟我之前的调用相同

661
00:31:09,336 --> 0:31:11,238
除非我传入了新标识符

662
00:31:12,039 --> 0:31:15,175
并且我要调用

663
00:31:15,242 --> 0:31:17,611
并向下转换为后台处理任务

664
00:31:18,979 --> 0:31:20,981
现在我要继续并实施

665
00:31:27,254 --> 0:31:29,823
我已经把这段代码与后台任务集成了

666
00:31:30,257 --> 0:31:33,427
它的功能是删除昨天之前的一切数据

667
00:31:34,294 --> 0:31:37,097
你可以看到 我设置了过期处理器

668
00:31:37,164 --> 0:31:38,565
和取消我的全部操作

669
00:31:39,099 --> 0:31:43,270
并且当我完成后成功调用了

670
00:31:44,071 --> 0:31:45,672
有一点不同

671
00:31:45,739 --> 0:31:49,142
就是我一直追踪我上次成功清理

672
00:31:50,844 --> 0:31:53,780
这是因为当我安排任务时

673
00:31:53,847 --> 0:31:56,884
我想谨慎地使用系统的资源

674
00:31:57,351 --> 0:31:59,586
我不想当用户每次离开app时

675
00:31:59,653 --> 0:32:01,154
都安排数据库清理任务

676
00:31:59,653 --> 0:32:01,154
都安排数据库清理任务

677
00:32:01,221 --> 0:32:03,156
如果我的数据库

678
00:32:03,991 --> 0:32:06,760
我要做的就是编写一个

679
00:32:07,027 --> 0:32:08,996
ScheduleDatabaseCleaning方法

680
00:32:11,265 --> 0:32:12,900
我会检查

681
00:32:12,966 --> 0:32:16,103
是否距离上次清理已经过去了

682
00:32:16,436 --> 0:32:18,372
如果不是 我就不采取任何措施

683
00:32:19,339 --> 0:32:21,475
反之我将继续并安排那个请求

684
00:32:22,242 --> 0:32:24,144
我要创建一个后台处理任务请求

685
00:32:24,511 --> 0:32:26,747
并给它传递我之前传递过的同一个

686
00:32:28,715 --> 0:32:31,552
在后台处理任务请求上有一些

687
00:32:31,618 --> 0:32:32,653
你可能要引起注意

688
00:32:33,387 --> 0:32:36,089
第一个是要求网络连接

689
00:32:36,356 --> 0:32:37,891
实际上它默认设为假

690
00:32:38,525 --> 0:32:40,327
你应该确保把它设为真

691
00:32:40,394 --> 0:32:43,297
如果执行你的任务真的需要

692
00:32:43,564 --> 0:32:45,566
否则我们可能会在没有网络连接时

693
00:32:45,632 --> 0:32:48,335
那样你就不能完成很多工作

694
00:32:49,203 --> 0:32:51,305
在我们的例子中

695
00:32:51,605 --> 0:32:52,906
因此我们可以把它保留为假

696
00:32:54,007 --> 0:32:56,610
下一个是要求外部电源

697
00:32:57,911 --> 0:33:00,514
根据设备的特定类型

698
00:32:57,911 --> 0:33:00,514
根据设备的特定类型

699
00:33:00,848 --> 0:33:02,716
和各种系统情况和政策

700
00:33:03,083 --> 0:33:06,887
我们可能倾向于当设备充电时

701
00:33:07,654 --> 0:33:09,523
然而如果你请求

702
00:33:09,590 --> 0:33:13,060
如果你请求你自己执行密集的任务

703
00:33:13,126 --> 0:33:14,494
并使用大量资源

704
00:33:14,561 --> 0:33:16,864
我们强烈建议你把这个设为真

705
00:33:17,297 --> 0:33:19,032
那样有助于保存用户的电量

706
00:33:19,766 --> 0:33:23,170
把这个设为真

707
00:33:23,237 --> 0:33:24,471
禁用CPU监控的方式

708
00:33:26,373 --> 0:33:28,709
就是这么多了 我要继续

709
00:33:28,775 --> 0:33:32,079
如果需要的话

710
00:33:32,379 --> 0:33:34,081
我会在app进入后台时再执行

711
00:33:35,616 --> 0:33:38,552
这是我要处理后台app刷新

712
00:33:38,819 --> 0:33:40,254
和后台处理任务所需要编写的

713
00:33:41,088 --> 0:33:42,456
但我如何知道这些代码没问题呢？

714
00:33:43,524 --> 0:33:45,192
我想我是个完美的程序员 但是

715
00:33:45,959 --> 0:33:47,728
显然情况并非总是如此

716
00:33:48,262 --> 0:33:51,532
端对端测试的最好方式是

717
00:33:51,598 --> 0:33:54,034
把它放在设备上

718
00:33:54,301 --> 0:33:56,937
那会确保你可以获得

719
00:33:57,004 --> 0:33:58,505
用于执行特定任务所需要的

720
00:33:59,573 --> 0:34:02,309
但我们还知道当你编码时

721
00:33:59,573 --> 0:34:02,309
但我们还知道当你编码时

722
00:34:02,376 --> 0:34:03,410
你没有时间坐在那儿等着

723
00:34:03,477 --> 0:34:06,613
因此我们添加了一些方法

724
00:34:06,680 --> 0:34:08,849
用于调试后台任务的使用

725
00:34:09,149 --> 0:34:10,350
现在让我来演示一下

726
00:34:11,618 --> 0:34:13,453
我要创建并在我的iPhone上

727
00:34:13,754 --> 0:34:15,522
运行这个新版后台任务

728
00:34:21,261 --> 0:34:22,696
你可以看到 它启动了

729
00:34:22,763 --> 0:34:24,697
现在我要把它放到后台去

730
00:34:25,966 --> 0:34:27,601
从而确保安排我的任务请求

731
00:34:28,635 --> 0:34:30,437
我再把它放到前台来 在这里

732
00:34:30,704 --> 0:34:33,739
我要点击底部的暂停按钮

733
00:34:35,576 --> 0:34:36,710
这将会进入调试器

734
00:34:38,110 --> 0:34:39,446
我可以看到控制台

735
00:34:40,447 --> 0:34:41,481
我要做的就是

736
00:34:41,547 --> 0:34:42,949
粘贴命令

737
00:34:43,016 --> 0:34:46,018
你可以从文档中找到命令

738
00:34:47,353 --> 0:34:48,688
在这里我要做的就是

739
00:34:49,121 --> 0:34:51,225
用我想要模拟的任务的标识符

740
00:34:51,291 --> 0:34:53,226
替换这个

741
00:34:53,726 --> 0:34:55,362
我想测试后台app刷新

742
00:34:55,661 --> 0:34:58,165
因此我要键入

743
00:34:59,266 --> 0:35:01,401
但步骤与我的处理任务一样

744
00:34:59,266 --> 0:35:01,401
但步骤与我的处理任务一样

745
00:35:02,269 --> 0:35:03,303
我要按回车…

746
00:35:04,271 --> 0:35:05,138
你可以看到

747
00:35:05,205 --> 0:35:07,274
系统已经识别我想模拟一次启动

748
00:35:07,574 --> 0:35:08,942
执行后台app刷新任务

749
00:35:10,511 --> 0:35:11,979
我要点击这里的播放按钮

750
00:35:15,382 --> 0:35:16,617
你可以看到

751
00:35:17,084 --> 0:35:18,819
系统开始执行我的app刷新任务

752
00:35:18,886 --> 0:35:20,621
我的app主动地进行了刷新

753
00:35:20,687 --> 0:35:22,089
我可以看到代码起作用了

754
00:35:23,457 --> 0:35:24,558
我要再次点击暂停

755
00:35:25,025 --> 0:35:28,195
这一次我要确保过期也没问题

756
00:35:28,262 --> 0:35:29,630
因为它也同等重要

757
00:35:30,631 --> 0:35:33,467
我要做的就是输入同一个命令

758
00:35:34,101 --> 0:35:36,570
但这一次我要用过期替换“启动”

759
00:35:36,837 --> 0:35:39,273
并按回车

760
00:35:40,641 --> 0:35:43,076
你可以看到

761
00:35:43,710 --> 0:35:44,678
当我点击播放时

762
00:35:44,945 --> 0:35:47,614
你应该可以看到我的app会成功地

763
00:35:47,915 --> 0:35:50,584
识别到那个任务已过期

764
00:35:51,251 --> 0:35:54,922
现在我知道对于后台任务

765
00:35:54,988 --> 0:35:58,659
我的app已经成功地实施并测试了

766
00:35:59,059 --> 0:36:00,260
后台app刷新和后台处理任务

767
00:35:59,059 --> 0:36:00,260
后台app刷新和后台处理任务

768
00:36:05,899 --> 0:36:06,900
谢谢

769
00:36:07,601 --> 0:36:09,036
当你使用我们的框架时

770
00:36:09,102 --> 0:36:11,471
你可能要引起注意

771
00:36:12,573 --> 0:36:15,642
第一 请注意对最早开始时间的设置

772
00:36:15,709 --> 0:36:17,244
不要把时间设置得太远

773
00:36:17,978 --> 0:36:19,446
如果你把它设置得太远

774
00:36:19,513 --> 0:36:22,082
并且在此期间用户也没有返回到

775
00:36:22,416 --> 0:36:24,351
我们可能会选择完全不启动你的任务

776
00:36:24,818 --> 0:36:28,355
那只是为了保护用户的预期和隐私

777
00:36:28,789 --> 0:36:31,091
几个月都不使用你app的用户

778
00:36:31,158 --> 0:36:33,727
不会期待它突然开始在后台运行

779
00:36:34,228 --> 0:36:36,997
因此我们建议你把最早开始时间

780
00:36:37,464 --> 0:36:40,701
把你推迟的最早开始时间设置为

781
00:36:42,970 --> 0:36:46,874
接下来请确保在处理任务过程中

782
00:36:47,441 --> 0:36:49,243
当设备被锁定时可访问

783
00:36:49,576 --> 0:36:51,979
因为我们一般会在那时启动你的任务

784
00:36:53,046 --> 0:36:55,215
我们保证我们不会开始你的任务

785
00:36:55,282 --> 0:36:57,217
直到用户第一次锁定他们的设备

786
00:36:57,518 --> 0:36:59,386
因此请确保你要访问的任何文件

787
00:36:59,453 --> 0:37:04,291
大部分文件保护类型都是完整的

788
00:36:59,453 --> 0:37:04,291
大部分文件保护类型都是完整的

789
00:37:07,060 --> 0:37:08,929
我们在传统的单个窗口的

790
00:37:08,996 --> 0:37:11,431
演示了如何实施后台app刷新

791
00:37:11,765 --> 0:37:14,801
但你知道的 今年我们通过

792
00:37:15,068 --> 0:37:16,503
引入了多窗口app

793
00:37:16,970 --> 0:37:18,472
如果你采用那个API

794
00:37:18,839 --> 0:37:23,644
可以在合适的时间调用UIApplication

795
00:37:23,710 --> 0:37:26,280
从而告诉系统

796
00:37:26,346 --> 0:37:28,849
App切换器中的快照需要更新

797
00:37:29,383 --> 0:37:32,085
你可以在它们各自的文档中找到

798
00:37:34,188 --> 0:37:35,088
最后

799
00:37:35,389 --> 0:37:39,059
BGTaskScheduler.submit

800
00:37:39,426 --> 0:37:42,029
我们之所以那样设计它是因为

801
00:37:42,095 --> 0:37:44,198
当你进行调度时 当你进入后台时

802
00:37:44,398 --> 0:37:45,499
这是常见的情况

803
00:37:46,200 --> 0:37:48,101
然而如果你计划

804
00:37:48,468 --> 0:37:51,104
在更具性能敏感性的情境中进行调度

805
00:37:51,605 --> 0:37:53,307
比如当app启动时

806
00:37:53,807 --> 0:37:55,976
你要确保在后台队列上调用它

807
00:37:56,243 --> 0:37:59,613
从而不会阻塞主线程并妨碍启动性能

808
00:38:02,182 --> 0:38:04,918
好吧 总结一下我们今天讲过的内容

809
00:38:06,486 --> 0:38:09,756
但请认真考虑

810
00:38:10,090 --> 0:38:13,227
请谨记我们在设计我们的API时

811
00:38:13,627 --> 0:38:16,730
比如电源、性能和隐私

812
00:38:18,932 --> 0:38:21,235
请一定使用合适的后台模式

813
00:38:21,301 --> 0:38:23,303
来完成你要执行的任务

814
00:38:23,370 --> 0:38:25,806
并获得你想要的用户体验

815
00:38:28,475 --> 0:38:31,378
最后请使用新后台任务API

816
00:38:31,445 --> 0:38:33,247
来安排稍后在后台中要执行的任务

817
00:38:33,714 --> 0:38:35,349
请使用后台app刷新任务

818
00:38:35,616 --> 0:38:37,784
保持app拥有最新内容

819
00:38:38,118 --> 0:38:41,588
并使用后台处理任务来执行

820
00:38:42,122 --> 0:38:44,691
当设备闲置时和充电时

821
00:38:46,760 --> 0:38:51,465
要获取更多信息 请参加我们的演讲

822
00:38:51,532 --> 0:38:53,767
查看文档连接和示例代码

823
00:38:54,234 --> 0:38:55,269
谢谢
