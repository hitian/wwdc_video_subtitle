1
00:00:00,506 --> 0:00:04,500
[音乐]

2
00:00:08,016 --> 0:00:09,156
[掌声]

3
00:00:09,156 --> 0:00:12,186
&gt;&gt; 上午好 欢迎

4
00:00:12,186 --> 0:00:13,526
大家来到 SwiftUI 中的数据流

5
00:00:13,526 --> 0:00:15,986
我叫 Luca Bernardi 

6
00:00:15,986 --> 0:00:17,096
稍后会有一位我的朋友 也是我的同事

7
00:00:17,096 --> 0:00:18,096
Raj Ramamaurthy

8
00:00:18,096 --> 0:00:18,686
加入讲演

9
00:00:18,906 --> 0:00:20,486
大家对 SwiftUI 感到兴奋吗

10
00:00:20,486 --> 0:00:21,836
&gt;&gt; [齐声回答] 兴奋

11
00:00:21,836 --> 0:00:25,276
&gt;&gt; 很好 今天来到这儿

12
00:00:25,276 --> 0:00:25,996
我感到非常高兴

13
00:00:25,996 --> 0:00:28,476
SwiftUI 是制作一个优秀 App 的

14
00:00:28,476 --> 0:00:30,226
最便捷的途径

15
00:00:30,226 --> 0:00:31,896
但是我们也从头开始设计

16
00:00:32,006 --> 0:00:33,526
目标是降低

17
00:00:33,526 --> 0:00:35,096
UI 开发的复杂程度

18
00:00:35,096 --> 0:00:37,876
这就意味着数据在 SwiftUI 中

19
00:00:37,876 --> 0:00:39,376
是第一类对象

20
00:00:40,056 --> 0:00:42,856
在这次讲演中

21
00:00:42,856 --> 0:00:44,646
我们将向大家展示一个

22
00:00:44,646 --> 0:00:45,776
简单却有用的工具

23
00:00:45,776 --> 0:00:47,706
你可以用它

24
00:00:47,706 --> 0:00:48,506
使数据在视图层级中流动

25
00:00:49,306 --> 0:00:50,706
这个工具可以帮助你

26
00:00:50,706 --> 0:00:53,506
设计美观且好用的 App

27
00:00:56,046 --> 0:00:57,386
我们也将会深入内部机制

28
00:00:57,386 --> 0:00:59,526
看看 SwiftUI 如何更新视图层级

29
00:00:59,526 --> 0:01:01,166
来确保

30
00:00:59,526 --> 0:01:01,166
来确保

31
00:01:01,166 --> 0:01:02,956
你可以正确而又持续地

32
00:01:02,956 --> 0:01:04,575
呈现你的数据

33
00:01:05,916 --> 0:01:07,856
最后我们将为你

34
00:01:07,986 --> 0:01:09,376
在脑海中建立一个框架

35
00:01:09,376 --> 0:01:10,996
去理解你的数据

36
00:01:10,996 --> 0:01:12,256
和可用工具

37
00:01:13,836 --> 0:01:16,176
在继续说明之前 我们必须要问

38
00:01:16,176 --> 0:01:16,906
数据是什么意思

39
00:01:18,196 --> 0:01:19,746
数据是所有

40
00:01:19,746 --> 0:01:20,666
驱动你 UI 的信息

41
00:01:21,296 --> 0:01:23,746
数据的形态结构多种多样

42
00:01:24,356 --> 0:01:25,806
一个例子是

43
00:01:25,806 --> 0:01:27,886
像 Toggle 中的状态一样

44
00:01:29,036 --> 0:01:30,766
数据还代表模型数据

45
00:01:31,306 --> 0:01:32,976
比如驱动一列信息的对象

46
00:01:36,096 --> 0:01:37,716
我们有许多工具

47
00:01:37,716 --> 0:01:39,166
供你选择

48
00:01:39,166 --> 0:01:39,746
取决于你想做什么

49
00:01:40,656 --> 0:01:41,586
你也许已经在之前的讲解中

50
00:01:41,586 --> 0:01:42,926
看到了这些工具

51
00:01:42,926 --> 0:01:44,756
如果你对它们并不熟悉

52
00:01:44,756 --> 0:01:47,206
不必担心

53
00:01:47,206 --> 0:01:48,786
我们会解释它们是什么

54
00:01:48,786 --> 0:01:49,256
以及什么时候用得到

55
00:01:50,236 --> 0:01:51,836
听完讲解后

56
00:01:51,836 --> 0:01:54,186
你就会清楚地知道使用哪个工具

57
00:01:54,306 --> 0:01:54,826
以及什么时候使用

58
00:01:55,486 --> 0:01:57,736
但是在展示工具之前

59
00:01:57,736 --> 0:01:59,316
我想先阐释

60
00:01:59,316 --> 0:02:00,866
两个指导性原则

61
00:01:59,316 --> 0:02:00,866
两个指导性原则

62
00:02:00,866 --> 0:02:03,136
这两个原则启发了我们的设计

63
00:02:03,936 --> 0:02:05,266
第一个原则是

64
00:02:05,266 --> 0:02:06,996
每次你在视图中

65
00:02:06,996 --> 0:02:08,166
读取数据时

66
00:02:08,166 --> 0:02:09,776
你都在为那个视图创建一个依赖

67
00:02:10,616 --> 0:02:11,806
这是一个依赖

68
00:02:11,806 --> 0:02:13,116
因为每当数据发生变化

69
00:02:13,466 --> 0:02:14,736
你的视图也要变化

70
00:02:14,736 --> 0:02:15,576
去反映一个新的值

71
00:02:17,156 --> 0:02:18,776
举个例子

72
00:02:18,776 --> 0:02:19,876
这里蓝色的是播放控制的视图

73
00:02:19,876 --> 0:02:21,856
这个视图需要

74
00:02:21,856 --> 0:02:23,006
读取紫色的数据

75
00:02:23,806 --> 0:02:25,116
每当这个值变化时

76
00:02:25,116 --> 0:02:25,976
我们都要更新视图

77
00:02:28,666 --> 0:02:31,686
所以 定义这个依赖

78
00:02:31,686 --> 0:02:33,126
是个手动的过程

79
00:02:33,126 --> 0:02:34,696
很快就会变得复杂起来

80
00:02:35,266 --> 0:02:38,206
正如查看 SwiftUI

81
00:02:38,206 --> 0:02:40,096
数据依赖

82
00:02:40,096 --> 0:02:40,596
也是声明式的

83
00:02:40,596 --> 0:02:41,956
并不是手动

84
00:02:41,956 --> 0:02:43,696
同步或失效

85
00:02:43,696 --> 0:02:46,756
通过 SwiftUI 

86
00:02:46,756 --> 0:02:48,056
你只需用很少的工具

87
00:02:48,056 --> 0:02:50,056
把依赖描述给框架

88
00:02:50,056 --> 0:02:51,566
框架就会处理剩下的

89
00:02:51,596 --> 0:02:54,006
这就意味着你可以

90
00:02:54,056 --> 0:02:55,456
将你的注意力集中在

91
00:02:55,456 --> 0:02:57,316
为用户提供最佳体验上

92
00:03:00,096 --> 0:03:01,516
第二条原则是

93
00:03:01,516 --> 0:03:03,446
在视图层级中

94
00:03:03,446 --> 0:03:04,696
你读取的每一条数据

95
00:03:04,846 --> 0:03:05,806
都有一个数据源

96
00:03:07,016 --> 0:03:08,166
数据源存在

97
00:03:08,166 --> 0:03:08,816
在视图层级里

98
00:03:09,216 --> 0:03:10,576
比如说你有状态

99
00:03:10,576 --> 0:03:13,366
要折叠

100
00:03:13,426 --> 0:03:14,986
或者不折叠

101
00:03:14,986 --> 0:03:16,866
它也可以是外部的

102
00:03:16,916 --> 0:03:18,396
比如当你显示一个

103
00:03:18,396 --> 0:03:18,976
来自不变模型的信息时

104
00:03:21,696 --> 0:03:22,836
不论数据源在哪里

105
00:03:22,836 --> 0:03:24,876
你应该一直有一个

106
00:03:24,876 --> 0:03:27,266
单一数据源

107
00:03:29,096 --> 0:03:31,196
重复数据源会

108
00:03:31,196 --> 0:03:32,766
会产生 Bug 和不一致

109
00:03:32,986 --> 0:03:34,256
你要一直很小心

110
00:03:34,256 --> 0:03:35,766
让它们保持同步

111
00:03:36,776 --> 0:03:38,286
想一想你一直重复

112
00:03:38,286 --> 0:03:39,786
同一条数据

113
00:03:39,866 --> 0:03:42,626
比如在同级视图里重复同一条数据

114
00:03:42,626 --> 0:03:44,876
想一想消息传递

115
00:03:44,876 --> 0:03:46,186
是多么复杂

116
00:03:46,276 --> 0:03:47,626
KV 观察

117
00:03:47,626 --> 0:03:48,796
或响应一个不同的

118
00:03:48,796 --> 0:03:50,326
事件顺序

119
00:03:50,326 --> 0:03:50,876
会产生 Bug

120
00:03:52,086 --> 0:03:53,386
很容易就出错了

121
00:03:54,046 --> 0:03:55,036
它们会重复同一个错误

122
00:03:55,036 --> 0:03:56,286
很多次

123
00:03:56,866 --> 0:03:59,936
反而 你需要做的是

124
00:03:59,936 --> 0:04:01,456
把数据提取到一个

125
00:03:59,936 --> 0:04:01,456
把数据提取到一个

126
00:04:01,456 --> 0:04:03,386
共同的父级节点

127
00:04:03,386 --> 0:04:05,546
让两个子节点链接到父节点

128
00:04:06,836 --> 0:04:08,426
当你有一个单一数据源时

129
00:04:08,426 --> 0:04:10,066
你就消除了这种

130
00:04:10,276 --> 0:04:11,946
视图和数据

131
00:04:11,946 --> 0:04:12,596
不一致的 Bug

132
00:04:13,206 --> 0:04:14,176
你就可以用

133
00:04:14,426 --> 0:04:15,786
语言有的工具

134
00:04:15,786 --> 0:04:17,255
在你的数据中执行变量

135
00:04:17,866 --> 0:04:20,586
记住这个原则

136
00:04:20,966 --> 0:04:22,846
退一步 看看

137
00:04:22,846 --> 0:04:23,856
你代码里的所有数据源

138
00:04:23,856 --> 0:04:25,466
用这个原则

139
00:04:25,466 --> 0:04:27,376
去决定

140
00:04:27,376 --> 0:04:33,126
数据的结构

141
00:04:33,276 --> 0:04:35,696
在我来 Apple 总部

142
00:04:35,696 --> 0:04:37,016
上班的路上

143
00:04:37,016 --> 0:04:37,746
我特别喜欢听一个很棒的播客

144
00:04:37,746 --> 0:04:39,386
我觉得用 SwiftUI 

145
00:04:39,386 --> 0:04:41,646
做一个播放器是个好主意

146
00:04:41,646 --> 0:04:44,616
在这次讲解中

147
00:04:44,616 --> 0:04:45,596
我会用这个做例子

148
00:04:45,736 --> 0:04:46,926
展示所有的

149
00:04:46,926 --> 0:04:47,676
可用工具

150
00:04:48,676 --> 0:04:50,256
这是我们将要建构的 UI

151
00:04:51,506 --> 0:04:52,556
这是播放器的界面

152
00:04:52,556 --> 0:04:53,826
我们需要它显示

153
00:04:53,826 --> 0:04:55,236
节目和剧集的名字

154
00:04:55,276 --> 0:04:57,836
播放按钮

155
00:04:57,836 --> 0:04:58,496
和当前时间

156
00:04:59,096 --> 0:05:01,916
我们将一步一步

157
00:04:59,096 --> 0:05:01,916
我们将一步一步

158
00:05:01,916 --> 0:05:02,796
建构这个 UI

159
00:05:03,686 --> 0:05:04,846
首先创建一个视图

160
00:05:04,846 --> 0:05:05,976
显示当前剧集的视图

161
00:05:09,386 --> 0:05:10,506
第一步是创建一个新视图

162
00:05:10,506 --> 0:05:12,536
PlayerView 

163
00:05:12,536 --> 0:05:13,636
这个视图有一个属性

164
00:05:13,636 --> 0:05:15,296
存储着当前播放剧集

165
00:05:15,936 --> 0:05:17,836
我们还想要显示

166
00:05:17,836 --> 0:05:19,466
剧集和标题

167
00:05:19,926 --> 0:05:20,986
所以在主体中

168
00:05:20,986 --> 0:05:22,956
我们会做一个 VStack 包含两个文本

169
00:05:22,956 --> 0:05:23,966
这样它们会纵向排列

170
00:05:24,536 --> 0:05:27,946
基本的 Swift 属性

171
00:05:27,946 --> 0:05:28,846
是你的第一个工具

172
00:05:29,276 --> 0:05:30,206
当你有一个视图

173
00:05:30,206 --> 0:05:31,506
需要读取所有的派生数据访问时

174
00:05:31,506 --> 0:05:33,446
它是很好用的

175
00:05:34,406 --> 0:05:35,346
这条数据会被它的父节点

176
00:05:35,346 --> 0:05:37,206
提供给视图

177
00:05:38,556 --> 0:05:40,386
现在我想让它有

178
00:05:40,386 --> 0:05:42,246
播放和暂停的功能

179
00:05:42,936 --> 0:05:46,676
我们有一个新的属性

180
00:05:46,676 --> 0:05:48,546
表明当前剧集是否在播放

181
00:05:48,546 --> 0:05:50,896
现在 显示不同片段的图像

182
00:05:50,896 --> 0:05:52,266
取决于

183
00:05:52,266 --> 0:05:53,236
isPlaying 这个值

184
00:05:53,856 --> 0:05:56,176
但是现在我想让播放键

185
00:05:56,176 --> 0:05:58,196
有交互功能

186
00:05:58,196 --> 0:05:59,556
用户按播放键时

187
00:05:59,586 --> 0:06:01,146
播放状态会切换

188
00:05:59,586 --> 0:06:01,146
播放状态会切换

189
00:06:01,146 --> 0:06:02,226
图片也会随之改变

190
00:06:02,816 --> 0:06:07,636
我们可以用 Button （按钮）

191
00:06:07,786 --> 0:06:09,636
Button 包含一些内容

192
00:06:09,636 --> 0:06:10,756
运行一个动作

193
00:06:10,756 --> 0:06:11,646
当用户点击这个它时

194
00:06:12,726 --> 0:06:13,906
我们只是切换

195
00:06:13,906 --> 0:06:14,446
isPlaying

196
00:06:15,086 --> 0:06:18,726
但如果我们运行一下

197
00:06:18,726 --> 0:06:19,676
就会出现编译错误

198
00:06:20,686 --> 0:06:21,876
这是个好事情

199
00:06:21,876 --> 0:06:23,736
通过 UI 的

200
00:06:23,736 --> 0:06:24,766
其中一条普遍原则

201
00:06:24,766 --> 0:06:25,726
把我们引上正确的道路

202
00:06:25,726 --> 0:06:28,366
我们不改写视图层级

203
00:06:28,916 --> 0:06:31,606
你的 UI 每次更新

204
00:06:31,606 --> 0:06:33,536
都是因为某个视图主体

205
00:06:33,536 --> 0:06:34,726
在生成新的值

206
00:06:34,726 --> 0:06:37,266
为了处理这种情况

207
00:06:37,306 --> 0:06:38,616
我们有一个工具

208
00:06:38,616 --> 0:06:38,976
叫作 State （状态）

209
00:06:42,146 --> 0:06:43,676
我们在这个视图里创建一个主状态

210
00:06:44,256 --> 0:06:46,726
通过 isPlaying 属性上的 

211
00:06:46,726 --> 0:06:48,226
State Property Wrapper

212
00:06:48,226 --> 0:06:49,106
我们可以实现这一点

213
00:06:49,716 --> 0:06:51,006
这么做相当于

214
00:06:51,006 --> 0:06:52,106
告诉系统

215
00:06:52,186 --> 0:06:53,566
isPlaying 是个值

216
00:06:53,566 --> 0:06:55,286
它可以变化

217
00:06:55,286 --> 0:06:56,656
播放器视图会随它变化

218
00:06:58,086 --> 0:06:59,716
现在再运行一下

219
00:06:59,716 --> 0:07:00,666
就不会出现编辑错误了

220
00:06:59,716 --> 0:07:00,666
就不会出现编辑错误了

221
00:07:01,106 --> 0:07:02,146
用户每轻点一次按钮

222
00:07:02,146 --> 0:07:05,196
状态值都会变化

223
00:07:05,786 --> 0:07:06,756
框架就会为这个视图

224
00:07:06,756 --> 0:07:07,846
生成一个新主体

225
00:07:08,776 --> 0:07:09,726
如果你不了解

226
00:07:09,966 --> 0:07:11,716
Property Wrapper

227
00:07:11,716 --> 0:07:14,026
它是 Swift 5.1 里非常有用的一点

228
00:07:14,606 --> 0:07:17,136
至于它们是如何运作的

229
00:07:17,136 --> 0:07:18,296
我们不再细说

230
00:07:18,776 --> 0:07:19,826
如果你想了解更多的话

231
00:07:20,026 --> 0:07:21,366
可以去看这两个很好的分会议

232
00:07:21,966 --> 0:07:24,796
在今天这个讲演中

233
00:07:24,796 --> 0:07:25,836
你只需要知道

234
00:07:25,836 --> 0:07:27,196
当你添加 Property Wrapper 时

235
00:07:27,196 --> 0:07:28,596
你就是在打包这个属性

236
00:07:28,596 --> 0:07:29,916
并当它读写时

237
00:07:29,916 --> 0:07:32,146
为它增加一些额外操作

238
00:07:32,666 --> 0:07:35,036
你可能想知道

239
00:07:35,036 --> 0:07:35,596
这是怎么实现的

240
00:07:36,216 --> 0:07:38,076
这个额外操作

241
00:07:38,646 --> 0:07:40,626
是什么

242
00:07:40,836 --> 0:07:42,836
当你声明框架

243
00:07:42,836 --> 0:07:44,206
为视图上的变量 

244
00:07:44,206 --> 0:07:45,596
分配永久存储时

245
00:07:45,596 --> 0:07:46,936
我们会追踪它为一个依赖

246
00:07:46,936 --> 0:07:49,526
因为如果系统给你

247
00:07:49,526 --> 0:07:51,936
创建了一个存储

248
00:07:51,936 --> 0:07:53,316
你必须总是明确规定

249
00:07:53,316 --> 0:07:54,376
一个初始常量值

250
00:07:54,926 --> 0:07:57,466
视图经常会被系统重建

251
00:07:57,466 --> 0:07:59,636
但是对于 State 来说

252
00:07:59,636 --> 0:08:01,436
尽管视图同样有很多次更新

253
00:07:59,636 --> 0:08:01,436
尽管视图同样有很多次更新

254
00:08:01,436 --> 0:08:03,016
框架知道它需要

255
00:08:03,016 --> 0:08:04,686
永久存储

256
00:08:05,166 --> 0:08:08,256
这是个很好的操作

257
00:08:08,256 --> 0:08:10,006
清楚地声明状态属性

258
00:08:10,006 --> 0:08:12,296
是私有变量 

259
00:08:12,296 --> 0:08:14,366
真正实现

260
00:08:14,366 --> 0:08:16,076
状态由视图所有和管理

261
00:08:16,646 --> 0:08:19,106
但是我想深入内部结构

262
00:08:19,106 --> 0:08:20,766
让你们看看

263
00:08:20,766 --> 0:08:21,556
当用户点击按钮时

264
00:08:21,556 --> 0:08:21,976
会发生什么

265
00:08:25,346 --> 0:08:26,636
从我们刚才展示的

266
00:08:26,636 --> 0:08:27,276
视图层级开始

267
00:08:28,466 --> 0:08:30,346
我们刚才说

268
00:08:30,346 --> 0:08:31,976
当我们定义了一个状态时

269
00:08:31,976 --> 0:08:33,086
框架会为你

270
00:08:33,086 --> 0:08:34,256
分配永久存储

271
00:08:35,535 --> 0:08:36,736
状态变量的一个特殊属性是

272
00:08:36,736 --> 0:08:38,376
当它们变化时 

273
00:08:38,376 --> 0:08:40,176
SwiftUI 就开始了

274
00:08:40,176 --> 0:08:43,226
因为 SwiftUI 知道

275
00:08:43,226 --> 0:08:44,466
状态变量正在写主体

276
00:08:44,466 --> 0:08:46,506
它知道视图渲染

277
00:08:46,506 --> 0:08:47,976
取决于状态变量

278
00:08:50,586 --> 0:08:51,666
当用户和按钮互动时

279
00:08:51,666 --> 0:08:53,786
框架就会运行动作

280
00:08:53,786 --> 0:08:55,346
这个动作继而

281
00:08:55,346 --> 0:08:56,236
会和某个状态关联

282
00:08:58,476 --> 0:09:00,196
运行时数据

283
00:08:58,476 --> 0:09:00,196
运行时数据

284
00:09:00,196 --> 0:09:01,386
状态确实会变化

285
00:09:01,386 --> 0:09:02,736
并验证状态的视图

286
00:09:02,736 --> 0:09:05,636
这也就是说

287
00:09:05,636 --> 0:09:07,166
它会重新计算那个视图的主体

288
00:09:07,306 --> 0:09:08,396
以及它所有的子类

289
00:09:09,006 --> 0:09:12,056
在这种意义上

290
00:09:12,056 --> 0:09:13,356
所有的变化都会一直

291
00:09:13,356 --> 0:09:14,046
贯穿你的视图层级 

292
00:09:14,836 --> 0:09:16,486
这样效率很高

293
00:09:16,486 --> 0:09:17,716
这是因为

294
00:09:17,716 --> 0:09:19,366
框架会比较视图

295
00:09:19,736 --> 0:09:21,766
而且只会重新渲染改变了的地方

296
00:09:22,346 --> 0:09:25,016
这正是我们

297
00:09:25,016 --> 0:09:26,306
之前提到的

298
00:09:26,306 --> 0:09:27,596
框架可以

299
00:09:27,596 --> 0:09:28,396
为你管理依赖

300
00:09:30,116 --> 0:09:32,266
我们刚才还提到数据源

301
00:09:32,266 --> 0:09:34,276
要记住

302
00:09:34,276 --> 0:09:35,856
每次你

303
00:09:35,856 --> 0:09:38,146
声明一个状态

304
00:09:38,146 --> 0:09:39,886
你就定义了一个数据源

305
00:09:39,886 --> 0:09:40,746
这个数据源是属于视图的

306
00:09:40,746 --> 0:09:43,406
这点很重要

307
00:09:43,786 --> 0:09:45,106
我用了更大的字母来强调

308
00:09:45,106 --> 0:09:47,576
另一个重要的点是

309
00:09:47,576 --> 0:09:49,426
视图是状态的

310
00:09:49,426 --> 0:09:50,896
一个函数

311
00:09:50,896 --> 0:09:53,446
而非事件顺序

312
00:09:53,576 --> 0:09:55,496
传统方法是

313
00:09:55,496 --> 0:09:57,296
通过直接修改视图层级

314
00:09:57,296 --> 0:09:58,016
响应某个事件

315
00:09:58,836 --> 0:09:59,966
比如 通过添加或者删除

316
00:09:59,966 --> 0:10:01,756
一个 subview 

317
00:09:59,966 --> 0:10:01,756
一个 subview 

318
00:10:01,756 --> 0:10:02,296
或改变 alpha

319
00:10:03,356 --> 0:10:05,806
但是在 SwiftUI 里

320
00:10:05,806 --> 0:10:08,056
你修改某个状态

321
00:10:08,056 --> 0:10:09,366
这个状态就是数据源的函数

322
00:10:09,366 --> 0:10:10,056
通过这个就可以生成视图

323
00:10:10,056 --> 0:10:12,536
这就是 SwiftUI

324
00:10:12,666 --> 0:10:15,096
声明式语法出色的地方

325
00:10:15,566 --> 0:10:17,336
你鉴于当前状态

326
00:10:17,336 --> 0:10:18,076
描述视图

327
00:10:18,076 --> 0:10:21,196
SwiftUI 就是这样

328
00:10:21,196 --> 0:10:22,786
降低了 UI 开发的复杂程度

329
00:10:22,786 --> 0:10:24,866
让你可以写一个

330
00:10:24,866 --> 0:10:26,966
好看又准确的交互界面

331
00:10:30,656 --> 0:10:31,886
你可以把 App 看作

332
00:10:31,886 --> 0:10:33,706
一个用户和设备之间的

333
00:10:33,706 --> 0:10:34,976
持续反馈循环

334
00:10:37,666 --> 0:10:38,896
一切都从用户开始

335
00:10:40,396 --> 0:10:42,246
用户和 App 交互

336
00:10:42,246 --> 0:10:46,716
生成一个动作

337
00:10:46,896 --> 0:10:48,056
动作被框架执行

338
00:10:48,056 --> 0:10:49,716
修改某个状态

339
00:10:51,126 --> 0:10:52,346
系统发现状态发生了变化

340
00:10:52,346 --> 0:10:54,146
所以它就知道

341
00:10:54,146 --> 0:10:55,676
它需要根据状态

342
00:10:55,676 --> 0:10:57,426
刷新视图

343
00:10:59,496 --> 0:11:01,436
这个刷新给了 UI 

344
00:10:59,496 --> 0:11:01,436
这个刷新给了 UI 

345
00:11:01,436 --> 0:11:03,166
一个新的形式

346
00:11:03,166 --> 0:11:05,216
用户继续和新形式互动

347
00:11:06,436 --> 0:11:09,016
在这个模型中

348
00:11:09,016 --> 0:11:10,726
数据流向是单一向的

349
00:11:11,116 --> 0:11:13,276
它是所有变化的

350
00:11:13,276 --> 0:11:15,796
单一终点

351
00:11:15,796 --> 0:11:18,296
让视图刷新变得

352
00:11:18,296 --> 0:11:19,356
可预测且易理解

353
00:11:19,956 --> 0:11:22,026
现在我们弄明白了状态

354
00:11:22,116 --> 0:11:23,826
我想回到 AppWare 构建

355
00:11:23,826 --> 0:11:25,586
并做一些优化

356
00:11:26,126 --> 0:11:30,186
我想做的第一件事是

357
00:11:30,186 --> 0:11:31,916
每次用户按下

358
00:11:31,986 --> 0:11:33,996
暂停键 剧集名

359
00:11:33,996 --> 0:11:34,946
都会变成灰色

360
00:11:34,946 --> 0:11:37,516
我们已经知道怎么做了

361
00:11:38,236 --> 0:11:39,526
我们只需要用 isPlaying 状态

362
00:11:39,526 --> 0:11:41,586
选择正确的文字颜色

363
00:11:42,106 --> 0:11:45,816
接下来我想做一些重构

364
00:11:46,316 --> 0:11:47,866
如果你已经看过 SwiftUI 的

365
00:11:47,866 --> 0:11:49,646
你就已经知道

366
00:11:49,646 --> 0:11:51,186
视图在 SwiftUI 里

367
00:11:51,186 --> 0:11:52,666
是一个 Locust 阻塞

368
00:11:53,726 --> 0:11:55,636
不必害怕

369
00:11:55,636 --> 0:11:56,886
将视图中有意义的数据

370
00:11:57,316 --> 0:11:59,336
合并为可以被一起编写的 

371
00:11:59,336 --> 0:12:00,886
更小的

372
00:11:59,336 --> 0:12:00,886
更小的

373
00:12:00,886 --> 0:12:01,826
可重复使用的组件

374
00:12:01,906 --> 0:12:04,196
正好可以以此为例

375
00:12:04,776 --> 0:12:07,386
这是播放按钮和暂停按钮

376
00:12:07,386 --> 0:12:08,006
的代码

377
00:12:08,606 --> 0:12:10,976
封装这个逻辑

378
00:12:10,976 --> 0:12:11,956
到它自己的视图

379
00:12:12,526 --> 0:12:13,906
命名为 PlayButton

380
00:12:15,246 --> 0:12:16,296
现在看一下

381
00:12:16,296 --> 0:12:17,676
PlayButton 的实现

382
00:12:17,816 --> 0:12:22,086
代码还是一样的

383
00:12:22,586 --> 0:12:24,196
只是封装到了一个新视图

384
00:12:25,046 --> 0:12:26,296
但是注意这里我们做了一个新状态

385
00:12:26,296 --> 0:12:29,776
但是状态不是正确的工具

386
00:12:30,856 --> 0:12:32,806
使用状态

387
00:12:32,806 --> 0:12:34,516
我们就为 isPlaying 建立了一个新数据源

388
00:12:34,516 --> 0:12:36,206
这样我们必须

389
00:12:36,206 --> 0:12:37,556
和父级 PlayerView 的状态

390
00:12:37,556 --> 0:12:38,326
保持同步

391
00:12:38,326 --> 0:12:40,096
这不是我们想要的效果

392
00:12:40,746 --> 0:12:43,406
我们想做的是

393
00:12:43,406 --> 0:12:44,636
让它成为可重复使用的组件

394
00:12:45,236 --> 0:12:46,396
所以这个视图不会拥有

395
00:12:46,396 --> 0:12:48,956
一个数据源

396
00:12:48,956 --> 0:12:50,286
它只能读取一个值

397
00:12:50,286 --> 0:12:50,896
然后改写它

398
00:12:52,006 --> 0:12:53,206
但是它不需要拥有状态

399
00:12:53,206 --> 0:12:55,476
我们有处理这种情况的工具

400
00:12:55,816 --> 0:12:56,666
这个工具叫作 Binding（绑定）

401
00:12:56,666 --> 0:13:00,466
通过 Binding Property Wrapper

402
00:12:56,666 --> 0:13:00,466
通过 Binding Property Wrapper

403
00:13:00,506 --> 0:13:02,436
给数据源

404
00:13:02,436 --> 0:13:04,016
定义一个清楚的依赖

405
00:13:04,016 --> 0:13:05,316
而不拥有它

406
00:13:06,656 --> 0:13:07,936
而且 你不需要

407
00:13:07,936 --> 0:13:09,676
提供初始值

408
00:13:09,676 --> 0:13:11,566
因为绑定可以从状态中生成

409
00:13:12,886 --> 0:13:14,256
看一下效果如何

410
00:13:14,256 --> 0:13:15,136
是不是很适合我们的例子

411
00:13:15,746 --> 0:13:17,846
我们唯一要做的就是

412
00:13:17,846 --> 0:13:19,616
用 Binding Property Wrapper

413
00:13:19,616 --> 0:13:21,936
删除初始值

414
00:13:22,256 --> 0:13:23,086
就是这么简单

415
00:13:23,706 --> 0:13:26,216
现在来看一下

416
00:13:26,216 --> 0:13:27,936
如何通过返回 PlayerView

417
00:13:27,936 --> 0:13:29,196
为 PlayButton 提供一个绑定

418
00:13:31,756 --> 0:13:33,696
PlayerView 依旧持有状态

419
00:13:33,906 --> 0:13:35,076
这是你的数据源

420
00:13:35,686 --> 0:13:38,866
在属性名字上 

421
00:13:38,866 --> 0:13:40,296
使用美元符号

422
00:13:40,296 --> 0:13:41,826
你就可以从状态生成一个绑定

423
00:13:42,386 --> 0:13:44,936
这是你让组件

424
00:13:44,936 --> 0:13:48,436
通过绑定访问状态的方法

425
00:13:49,056 --> 0:13:51,696
美元符号是 Property Wrapper 的

426
00:13:51,696 --> 0:13:53,206
另一个特色

427
00:13:53,416 --> 0:13:54,796
如果你想了解更多

428
00:13:55,096 --> 0:13:57,486
请看现代 Swift API 设计讲演

429
00:14:00,216 --> 0:14:01,466
我想我们可以暂停一秒

430
00:14:01,466 --> 0:14:04,076
欣赏一下这是多么

431
00:14:04,476 --> 0:14:05,456
简单却有效

432
00:14:06,536 --> 0:14:08,326
PlayButton 不包含

433
00:14:08,326 --> 0:14:09,736
isPlaying 值的主体

434
00:14:10,826 --> 0:14:12,046
只是通过绑定

435
00:14:12,276 --> 0:14:14,046
作为它的引用

436
00:14:14,046 --> 0:14:16,186
所以没有必要

437
00:14:16,186 --> 0:14:17,976
让数据和视图保持同步

438
00:14:20,046 --> 0:14:21,696
我想把这个

439
00:14:21,696 --> 0:14:23,066
和我们现在使用的 UIKit GraphKit

440
00:14:23,066 --> 0:14:23,976
对比一下

441
00:14:26,256 --> 0:14:28,376
我们有一个 View Controller

442
00:14:28,376 --> 0:14:30,276
有多个视图 

443
00:14:30,276 --> 0:14:32,256
需要响应我们用户的交互

444
00:14:32,256 --> 0:14:34,106
要非常麻烦地设定目标 动作

445
00:14:34,106 --> 0:14:35,876
或者定义委托

446
00:14:36,946 --> 0:14:38,366
你需要观察模型变化

447
00:14:38,366 --> 0:14:40,486
并且也要响应事件

448
00:14:41,626 --> 0:14:43,536
每次有值变化时

449
00:14:43,826 --> 0:14:45,466
你都需要读取值

450
00:14:45,466 --> 0:14:46,796
把它设置在任何需要它的地方

451
00:14:47,416 --> 0:14:50,246
一旦你的 App 复杂起来

452
00:14:50,276 --> 0:14:52,596
这就成了大问题

453
00:14:52,596 --> 0:14:55,216
我确信

454
00:14:55,216 --> 0:14:56,606
在座诸位都知道

455
00:14:56,606 --> 0:14:57,266
我说的这种情况

456
00:14:58,086 --> 0:14:59,396
View Controller 的整体目标

457
00:14:59,396 --> 0:15:01,376
就是让你的数据

458
00:14:59,396 --> 0:15:01,376
就是让你的数据

459
00:15:01,376 --> 0:15:02,866
和你的视图保持同步

460
00:15:03,746 --> 0:15:05,436
这是你我要处理的复杂难题

461
00:15:05,816 --> 0:15:08,796
但是在 SwiftUI 中不存在

462
00:15:09,476 --> 0:15:12,496
你有一个简单的工具

463
00:15:12,496 --> 0:15:14,186
来定义数据依赖

464
00:15:14,186 --> 0:15:16,146
框架会处理其他的

465
00:15:16,846 --> 0:15:18,186
你再也不需要

466
00:15:18,186 --> 0:15:19,146
View Controller 了

467
00:15:20,516 --> 0:15:27,806
[掌声 欢呼]

468
00:15:28,306 --> 0:15:30,396
这个想法非常有用

469
00:15:30,496 --> 0:15:32,906
这应用在整个框架中

470
00:15:35,806 --> 0:15:37,046
如果你看一下组件的 API

471
00:15:37,046 --> 0:15:38,376
如 Toggle

472
00:15:38,686 --> 0:15:40,946
TextField 和 Slider

473
00:15:40,946 --> 0:15:42,056
它们都需要一个绑定框架

474
00:15:42,906 --> 0:15:44,736
让你控制

475
00:15:44,736 --> 0:15:46,756
数据源在的地方

476
00:15:46,756 --> 0:15:51,056
你创建数据 

477
00:15:51,056 --> 0:15:52,106
把它给组件

478
00:15:52,106 --> 0:15:53,906
只是作为一个引用

479
00:15:53,906 --> 0:15:55,976
而不需要重复信息

480
00:15:55,976 --> 0:15:57,306
或者费力保持同步

481
00:15:57,306 --> 0:15:58,846
这真是太棒了

482
00:16:00,096 --> 0:16:02,256
在 SwiftUI 视图中

483
00:16:02,706 --> 0:16:03,886
有很多 App 可以查看

484
00:16:04,376 --> 0:16:06,626
布局 导航等

485
00:16:07,176 --> 0:16:09,106
实际上它们是你的

486
00:16:09,246 --> 0:16:10,296
单一原生组件

487
00:16:11,016 --> 0:16:12,516
它们也是好工具

488
00:16:12,516 --> 0:16:14,226
用来为单一数据 

489
00:16:14,456 --> 0:16:15,686
封装表示逻辑

490
00:16:16,866 --> 0:16:18,306
框架使你能够

491
00:16:18,306 --> 0:16:20,296
并鼓励你创建小的视图

492
00:16:20,296 --> 0:16:22,436
去呈现一条

493
00:16:22,436 --> 0:16:24,596
可以被一起编写的

494
00:16:25,856 --> 0:16:27,036
单个数据

495
00:16:27,036 --> 0:16:28,726
再一次 框架带领你

496
00:16:29,166 --> 0:16:31,006
编写小单元

497
00:16:31,006 --> 0:16:31,906
让你更清楚明白

498
00:16:31,906 --> 0:16:35,766
现在回到我们的例子

499
00:16:38,046 --> 0:16:39,056
我把这个 UI 给我的设计师看了

500
00:16:39,056 --> 0:16:40,776
她非常惊讶

501
00:16:40,776 --> 0:16:42,156
没想到这么少的代码

502
00:16:42,156 --> 0:16:42,836
就能有这些效果

503
00:16:44,256 --> 0:16:45,806
她也提出了一些优化的建议

504
00:16:47,066 --> 0:16:48,386
我们应该把播放和暂停的

505
00:16:48,386 --> 0:16:49,416
过渡变化动画化

506
00:16:50,746 --> 0:16:52,606
幸运的是

507
00:16:52,606 --> 0:16:54,926
这很简单

508
00:16:54,926 --> 0:16:56,536
因为框架追踪了

509
00:16:56,536 --> 0:16:57,736
所有变化了的东西

510
00:16:58,006 --> 0:16:59,426
难以置信

511
00:16:59,426 --> 0:17:01,776
用状态驱动动画

512
00:16:59,426 --> 0:17:01,776
用状态驱动动画

513
00:17:01,906 --> 0:17:03,026
是多么简单强大

514
00:17:05,336 --> 0:17:06,976
用一个动画模块

515
00:17:06,976 --> 0:17:08,646
通过打包改写给绑定

516
00:17:09,165 --> 0:17:10,646
当值改变时

517
00:17:10,646 --> 0:17:12,906
框架会动画这个过渡变化

518
00:17:13,526 --> 0:17:15,056
直到最后的状态 

519
00:17:15,056 --> 0:17:17,415
你都会一直得到正确的动画

520
00:17:18,965 --> 0:17:20,656
如果你想了解更多

521
00:17:20,656 --> 0:17:22,746
关于 SwiftUI 强大的动画和布局系统

522
00:17:22,746 --> 0:17:24,896
以及如何制作优秀 App 的信息

523
00:17:24,896 --> 0:17:26,715
我建议大家看一下

524
00:17:26,715 --> 0:17:29,616
在 SwiftUI 中构建自定义视图这个分会

525
00:17:30,166 --> 0:17:32,496
现在我们已经了解了 State 和 Binding

526
00:17:32,496 --> 0:17:35,386
但是 SwiftUI 还有一些绝活

527
00:17:35,386 --> 0:17:36,716
大家没有看到

528
00:17:37,136 --> 0:17:38,586
为了让大家了解得更多

529
00:17:38,586 --> 0:17:39,826
我现在要请 Raj 上台

530
00:17:40,276 --> 0:17:40,596
Raj

531
00:17:41,516 --> 0:17:47,500
[掌声]

532
00:17:50,316 --> 0:17:51,026
&gt;&gt; 谢谢你 Luca

533
00:17:51,026 --> 0:17:53,846
接下来我会介绍

534
00:17:53,846 --> 0:17:55,466
一些其他工具

535
00:17:56,056 --> 0:17:57,706
在 SwiftUI 中它们可以用来管理数据

536
00:17:58,816 --> 0:18:00,376
听了这个讲演

537
00:17:58,816 --> 0:18:00,376
听了这个讲演

538
00:18:00,796 --> 0:18:02,306
你就可以设计和构建

539
00:18:02,306 --> 0:18:05,246
稳固的可重复使用的组件

540
00:18:05,336 --> 0:18:09,716
可以应用在各种数据上

541
00:18:09,866 --> 0:18:11,556
大家刚才也看到了

542
00:18:11,556 --> 0:18:13,986
我们有很多有用的工具

543
00:18:13,986 --> 0:18:15,166
可以在 SwiftUI 中处理数据

544
00:18:15,956 --> 0:18:17,776
Luca 已经介绍了一些

545
00:18:17,776 --> 0:18:19,896
比如使用 State

546
00:18:20,666 --> 0:18:22,536
Binding 

547
00:18:22,536 --> 0:18:23,346
甚至只用 Swift Property

548
00:18:23,346 --> 0:18:25,816
我会介绍

549
00:18:25,816 --> 0:18:27,446
剩下的工具

550
00:18:28,146 --> 0:18:30,036
以 SwiftUI 中的外部变化

551
00:18:30,036 --> 0:18:30,546
作为开始

552
00:18:30,546 --> 0:18:33,496
我们现在回到

553
00:18:33,496 --> 0:18:35,096
Luca 刚才为大家展示的图解

554
00:18:36,206 --> 0:18:38,266
在这个图解中

555
00:18:38,376 --> 0:18:39,886
用户和 App 互动

556
00:18:40,766 --> 0:18:42,616
这形成了一个动作

557
00:18:42,616 --> 0:18:44,176
结果是改写了状态

558
00:18:44,176 --> 0:18:48,346
这就生成了

559
00:18:48,346 --> 0:18:49,946
视图的新主体

560
00:18:49,946 --> 0:18:50,936
提供给用户

561
00:18:52,436 --> 0:18:55,506
一些事件从外部被初始化

562
00:18:55,506 --> 0:18:59,296
比如计时器和通知

563
00:19:00,756 --> 0:19:03,016
但是记住 在 SwiftUI 中

564
00:19:03,016 --> 0:19:04,896
你的视图是状态的函数

565
00:19:06,296 --> 0:19:07,926
所有的改变

566
00:19:08,106 --> 0:19:09,366
只有一个单一漏斗点

567
00:19:10,866 --> 0:19:12,666
这意味着

568
00:19:12,666 --> 0:19:14,706
SwiftUI 

569
00:19:14,706 --> 0:19:17,106
用响应用户操作的方法

570
00:19:17,146 --> 0:19:17,976
响应外部更改

571
00:19:20,556 --> 0:19:22,846
所以当计时器启动

572
00:19:22,846 --> 0:19:24,906
或者接收到通知时

573
00:19:24,906 --> 0:19:26,926
过程看起来是差不多的

574
00:19:27,876 --> 0:19:30,126
我们创建了一个动作

575
00:19:30,126 --> 0:19:33,226
执行一些状态改写

576
00:19:33,226 --> 0:19:35,486
生成视图的新副本

577
00:19:35,526 --> 0:19:36,606
重新提供给用户

578
00:19:37,196 --> 0:19:40,276
在 SwiftUI 中 

579
00:19:40,276 --> 0:19:41,766
为表述这些外部事件

580
00:19:41,766 --> 0:19:42,916
我们有单一抽象化

581
00:19:44,046 --> 0:19:45,006
它被成为 Publisher

582
00:19:45,596 --> 0:19:48,876
Publisher 来自一个新的

583
00:19:48,876 --> 0:19:49,926
组合框架

584
00:19:50,876 --> 0:19:53,456
Combine 是一个统一声明式 API

585
00:19:53,456 --> 0:19:56,186
随时间处理数据

586
00:19:57,506 --> 0:19:58,646
今天我们

587
00:19:58,646 --> 0:20:00,106
不会细说 Combine

588
00:19:58,646 --> 0:20:00,106
不会细说 Combine

589
00:20:00,326 --> 0:20:01,966
但是大家一定要去看

590
00:20:01,966 --> 0:20:03,416
一些相关的讲解

591
00:20:03,416 --> 0:20:04,876
这样可以了解更多

592
00:20:06,486 --> 0:20:08,156
要达到我们的目的

593
00:20:08,156 --> 0:20:09,706
需记住一点

594
00:20:09,706 --> 0:20:11,316
在 SwiftUI 里用 Publisher 时

595
00:20:12,186 --> 0:20:13,606
它们应该删除主线程

596
00:20:14,576 --> 0:20:16,606
Combine 提供了一种用操作符的简单方法

597
00:20:16,606 --> 0:20:19,136
被称为 Receive On 

598
00:20:19,746 --> 0:20:21,366
想知道更多的话

599
00:20:21,366 --> 0:20:22,706
可以去看 

600
00:20:22,706 --> 0:20:25,666
Combine and Practice 分会

601
00:20:25,816 --> 0:20:28,346
现在我们通过例子来看一下

602
00:20:28,346 --> 0:20:28,866
它是如何运行的

603
00:20:29,996 --> 0:20:32,566
有时候用户

604
00:20:32,566 --> 0:20:35,026
不知道自己听播客听到了哪儿

605
00:20:35,236 --> 0:20:36,676
他们厌倦听年轻的一代

606
00:20:36,676 --> 0:20:38,966
接连好几个小时

607
00:20:38,966 --> 0:20:41,366
大谈特谈牛油果吐司

608
00:20:42,576 --> 0:20:44,976
所以我们要为播客播放器

609
00:20:44,976 --> 0:20:46,856
加一个时间戳

610
00:20:46,856 --> 0:20:48,356
这样用户就知道

611
00:20:48,356 --> 0:20:48,986
自己听到了哪儿

612
00:20:50,696 --> 0:20:53,596
要实现这个效果

613
00:20:53,886 --> 0:20:55,236
我们要加 State 表现当前时间

614
00:20:56,116 --> 0:21:00,486
和描绘该值的文本 

615
00:20:56,116 --> 0:21:00,486
和描绘该值的文本 

616
00:21:00,636 --> 0:21:04,366
接下来我们会使用 onReceive 修饰符

617
00:21:05,296 --> 0:21:06,906
很方便 我已经构建了一个 publisher 

618
00:21:06,906 --> 0:21:09,246
当前时间一改变

619
00:21:09,246 --> 0:21:10,346
它就会启动

620
00:21:11,256 --> 0:21:12,746
我会使用那个 publisher 

621
00:21:12,746 --> 0:21:14,936
传递给 onReceive 修饰符

622
00:21:15,776 --> 0:21:17,836
另外 我还会给一个闭包

623
00:21:17,836 --> 0:21:20,216
当 publisher 删除时

624
00:21:20,216 --> 0:21:21,306
这个闭包会运行

625
00:21:22,596 --> 0:21:24,686
就是这样

626
00:21:24,686 --> 0:21:26,416
这么做 我们已经给 SwiftUI 

627
00:21:26,416 --> 0:21:27,806
描述了依赖

628
00:21:28,966 --> 0:21:30,996
现在当 currentTime 刷新时

629
00:21:30,996 --> 0:21:33,226
我们会刷新状态

630
00:21:34,016 --> 0:21:35,876
SwiftUI 就会知道

631
00:21:35,876 --> 0:21:36,666
那儿有一个依赖

632
00:21:37,136 --> 0:21:39,466
标签就会自动刷新

633
00:21:40,056 --> 0:21:42,236
就无需费力

634
00:21:42,316 --> 0:21:43,186
去做失效或管理了

635
00:21:44,516 --> 0:21:50,516
[掌声]

636
00:21:51,016 --> 0:21:52,706
我们已经简单说明了

637
00:21:52,706 --> 0:21:53,796
SwiftUI 里的外部变化

638
00:21:55,006 --> 0:21:56,386
接下来我会介绍

639
00:21:56,386 --> 0:21:57,506
外部数据

640
00:22:00,416 --> 0:22:01,856
对于外部数据

641
00:22:01,936 --> 0:22:03,196
我们有 BindableObject 协议

642
00:22:04,566 --> 0:22:06,406
BindableObject 是

643
00:22:06,406 --> 0:22:08,516
使用封装了的 测试过的 

644
00:22:08,856 --> 0:22:10,706
你已有的“true”模型的

645
00:22:10,766 --> 0:22:11,486
简便方法

646
00:22:13,106 --> 0:22:14,966
这对教 SwiftUI

647
00:22:15,456 --> 0:22:17,146
你已经架构的引用类型模型

648
00:22:17,146 --> 0:22:17,936
是非常有用的

649
00:22:19,326 --> 0:22:22,146
这是你拥有并需要管理的数据

650
00:22:23,106 --> 0:22:25,436
SwiftUI 只需要知道

651
00:22:25,436 --> 0:22:28,916
如何在这个数据中响应改变

652
00:22:29,096 --> 0:22:30,876
我们换个例子

653
00:22:32,116 --> 0:22:34,376
用户希望

654
00:22:34,376 --> 0:22:36,366
播客可以在他们

655
00:22:36,366 --> 0:22:38,016
所有的设备上同步

656
00:22:38,016 --> 0:22:39,666
我负责添加这个功能

657
00:22:39,666 --> 0:22:41,696
所以我已经开始了

658
00:22:41,846 --> 0:22:44,116
我已经建立了一个模型

659
00:22:44,116 --> 0:22:45,476
现在是时候使用 

660
00:22:45,476 --> 0:22:47,246
我在视图层级里做好的模型

661
00:22:47,246 --> 0:22:48,636
把它带到

662
00:22:48,636 --> 0:22:49,356
我们的播客播放器

663
00:22:50,306 --> 0:22:52,206
看看多么简单

664
00:22:53,066 --> 0:22:54,776
这里是我们搭建的

665
00:22:54,776 --> 0:22:57,426
模型的一个草图

666
00:22:57,616 --> 0:22:59,406
要通过 SwiftUI 用这个模型

667
00:22:59,406 --> 0:23:01,936
我要做的只是

668
00:22:59,406 --> 0:23:01,936
我要做的只是

669
00:23:01,976 --> 0:23:04,726
确认它到 BindableObject 协议

670
00:23:10,056 --> 0:23:12,556
用 BindableObject

671
00:23:12,556 --> 0:23:13,956
我们需要提供的只是一个 publisher

672
00:23:14,856 --> 0:23:17,096
这个 publisher 显示

673
00:23:17,096 --> 0:23:18,386
对数据的更改

674
00:23:19,196 --> 0:23:20,696
记住组合 publisher

675
00:23:20,696 --> 0:23:22,516
是我们为表现

676
00:23:22,516 --> 0:23:23,886
对 SwiftUI 外部更改的

677
00:23:23,886 --> 0:23:25,756
单一抽象化

678
00:23:26,716 --> 0:23:28,186
这里 我们会在 didChange property

679
00:23:28,186 --> 0:23:29,956
提供一个 publisher

680
00:23:30,516 --> 0:23:32,446
PassthroughSubject 是一个 publisher

681
00:23:33,016 --> 0:23:35,966
接着 SwiftUI 会订阅这个 publisher

682
00:23:36,226 --> 0:23:37,786
所以它知道什么时候

683
00:23:37,786 --> 0:23:39,636
更新我们的视图层级

684
00:23:40,186 --> 0:23:43,076
在高级操作中

685
00:23:44,246 --> 0:23:46,796
当我们改写模型时

686
00:23:46,796 --> 0:23:48,666
我们只是简单地发送 publisher 请求

687
00:23:50,086 --> 0:23:52,326
现在 注意 为保证正确

688
00:23:52,676 --> 0:23:54,326
不管什么时候 模型一变化

689
00:23:54,326 --> 0:23:55,766
我们就需要这样做

690
00:23:55,766 --> 0:23:56,986
这样视图层级才能保持刷新

691
00:23:57,826 --> 0:24:00,286
幸好 SwiftUI 可以帮助我们

692
00:23:57,826 --> 0:24:00,286
幸好 SwiftUI 可以帮助我们

693
00:24:00,286 --> 0:24:01,336
它优雅地应对这些数据

694
00:24:01,436 --> 0:24:03,936
帮我们很好且正确地

695
00:24:04,106 --> 0:24:05,806
实现这个效果

696
00:24:07,496 --> 0:24:09,346
现在我们已经搭建了模型

697
00:24:09,346 --> 0:24:12,146
以及它对 BindableObject 协议的确认

698
00:24:13,326 --> 0:24:14,796
接下来我将向大家展示

699
00:24:14,796 --> 0:24:16,386
如何在视图层级中用模型

700
00:24:17,466 --> 0:24:19,466
还记得之前说的两大原则吗

701
00:24:20,026 --> 0:24:21,546
每一条数据都有一个数据源

702
00:24:21,546 --> 0:24:23,916
当你访问那个数据时

703
00:24:23,956 --> 0:24:25,986
你在上面创建了一个依赖

704
00:24:26,626 --> 0:24:28,306
我们已经创建了数据源

705
00:24:28,306 --> 0:24:30,676
但是我们还没有一个依赖

706
00:24:31,636 --> 0:24:33,066
幸运的是

707
00:24:33,066 --> 0:24:35,126
在你的可绑定对象上创建依赖

708
00:24:35,126 --> 0:24:36,006
是非常简单的

709
00:24:36,576 --> 0:24:41,526
这里有一个非常基础的图解

710
00:24:41,856 --> 0:24:43,576
可以看到我们的视图层级在右侧

711
00:24:43,576 --> 0:24:45,486
是蓝色的

712
00:24:46,106 --> 0:24:47,466
我们的模型在左侧

713
00:24:47,466 --> 0:24:47,906
是绿色的

714
00:24:49,456 --> 0:24:51,076
现在我们连接二者

715
00:24:51,126 --> 0:24:53,276
用 ObjectBinding Property Wrapper

716
00:24:53,326 --> 0:24:55,236
创建一个依赖

717
00:24:56,756 --> 0:24:58,986
我们这么做时

718
00:24:58,986 --> 0:25:00,506
每一个有那个 Property Wrapper 的视图

719
00:24:58,986 --> 0:25:00,506
每一个有那个 Property Wrapper 的视图

720
00:25:00,716 --> 0:25:03,216
都取决于我们之前写的模型

721
00:25:05,296 --> 0:25:07,866
就像用 State 一样

722
00:25:07,866 --> 0:25:09,526
当你用 ObjectBinding Property Wrapper

723
00:25:09,526 --> 0:25:10,916
将它添加到视图中时

724
00:25:10,916 --> 0:25:13,296
框架会识别出

725
00:25:13,296 --> 0:25:14,546
那儿有一个依赖

726
00:25:14,916 --> 0:25:16,786
所以在主体中

727
00:25:16,786 --> 0:25:18,756
当你访问那个数据时

728
00:25:18,836 --> 0:25:21,336
我们自动明白什么时候刷新视图

729
00:25:21,896 --> 0:25:27,236
在代码里看起来就像这样

730
00:25:27,446 --> 0:25:28,936
你创建视图时

731
00:25:28,936 --> 0:25:30,486
添加 ObjectBinding Property Wrapper

732
00:25:30,486 --> 0:25:32,526
到你视图里的一个 Property

733
00:25:33,076 --> 0:25:36,006
当你实例化视图时

734
00:25:36,006 --> 0:25:38,446
你只是将引用传递给

735
00:25:38,446 --> 0:25:40,576
你已有的模型

736
00:25:41,306 --> 0:25:43,996
注意 这在视图的实例中 

737
00:25:43,996 --> 0:25:45,716
创建了一个

738
00:25:45,716 --> 0:25:47,436
清楚的依赖

739
00:25:47,436 --> 0:25:48,976
这样很棒

740
00:25:49,016 --> 0:25:50,666
因为每次我要实例化视图时

741
00:25:50,666 --> 0:25:52,246
我都知道模型上

742
00:25:52,246 --> 0:25:53,946
有个依赖

743
00:25:58,076 --> 0:25:58,936
就是这样

744
00:26:00,336 --> 0:26:02,676
我们这么做时

745
00:26:02,676 --> 0:26:04,026
每个有 Property Wrapper 的视图

746
00:26:04,146 --> 0:26:05,806
都会自动订阅

747
00:26:05,806 --> 0:26:07,596
BindableObject 的变化

748
00:26:08,566 --> 0:26:09,936
也就意味着我们实现了

749
00:26:09,936 --> 0:26:10,806
依赖自动追踪

750
00:26:11,156 --> 0:26:13,596
又不需要

751
00:26:13,596 --> 0:26:15,346
失效和同步了

752
00:26:16,516 --> 0:26:22,736
[掌声]

753
00:26:23,236 --> 0:26:24,416
这里我想停一下

754
00:26:24,456 --> 0:26:26,756
有一点需要强调 

755
00:26:26,756 --> 0:26:28,826
因为如果用 SwiftUI 

756
00:26:29,376 --> 0:26:30,536
是值类型的话

757
00:26:30,536 --> 0:26:32,026
每次你使用引用类型时

758
00:26:32,026 --> 0:26:34,066
你都应该用 ObjectBinding Property Wrapper

759
00:26:34,736 --> 0:26:36,486
这样当数据改变时 

760
00:26:36,536 --> 0:26:38,276
框架就会知道

761
00:26:38,376 --> 0:26:40,106
然后让你的视图层级随之改变

762
00:26:40,646 --> 0:26:43,166
这就是如何在 BindableObject 上

763
00:26:43,166 --> 0:26:45,176
如何使用 ObjectBinding

764
00:26:45,426 --> 0:26:46,486
创建一个依赖

765
00:26:47,446 --> 0:26:48,976
其实我们还有一个工具

766
00:26:48,976 --> 0:26:49,966
也可以创建

767
00:26:49,966 --> 0:26:51,106
这些依赖

768
00:26:52,566 --> 0:26:54,726
我们可以创建间接依赖

769
00:26:56,156 --> 0:26:57,756
所以我带了一个

770
00:26:57,756 --> 0:26:58,976
和刚才大家看到的图解

771
00:26:58,976 --> 0:27:01,266
很相似的一个图解 

772
00:26:58,976 --> 0:27:01,266
很相似的一个图解 

773
00:27:01,266 --> 0:27:02,146
但是这次我们的视图中多了些子类

774
00:27:02,656 --> 0:27:06,946
接下来 我想要引入 Environment 

775
00:27:08,066 --> 0:27:09,586
如果你看了 SwiftUI Essentials 讲解

776
00:27:09,636 --> 0:27:11,636
你就知道

777
00:27:11,636 --> 0:27:12,936
Environment 是非常好的封装

778
00:27:12,936 --> 0:27:15,316
它可以推动数据

779
00:27:15,316 --> 0:27:17,046
一路向下流过视图层级 

780
00:27:18,196 --> 0:27:19,936
使用 Environment Object Modifier

781
00:27:19,936 --> 0:27:22,766
我们可以真正地

782
00:27:22,766 --> 0:27:28,116
把 BindableObject 写入 Environment 

783
00:27:28,116 --> 0:27:30,166
现在 我们的模型在 Environment 里

784
00:27:30,836 --> 0:27:34,276
我们可以用

785
00:27:34,276 --> 0:27:35,736
EnvironmentObject Property Wrapper

786
00:27:35,736 --> 0:27:37,396
在模型上

787
00:27:39,936 --> 0:27:40,096
创建依赖

788
00:27:40,266 --> 0:27:41,706
现在 通过使用这个 

789
00:27:41,706 --> 0:27:43,086
Property Wrapper

790
00:27:43,086 --> 0:27:44,426
我们可以在那个模型上创建依赖

791
00:27:46,976 --> 0:27:48,376
但是不止这样

792
00:27:49,156 --> 0:27:50,526
你可以在很多地方

793
00:27:50,526 --> 0:27:51,776
用到它

794
00:27:52,756 --> 0:27:55,376
所以你可以

795
00:27:55,376 --> 0:27:56,406
在整个层级的

796
00:27:56,406 --> 0:27:57,896
各种视图中使用它 

797
00:27:57,896 --> 0:27:59,506
它们都依赖于同一个模型

798
00:28:00,106 --> 0:28:03,166
当然 数据变化

799
00:28:03,166 --> 0:28:05,706
一切都会自动

800
00:28:05,706 --> 0:28:07,206
随之更新

801
00:28:08,586 --> 0:28:09,906
你获得了

802
00:28:09,906 --> 0:28:11,636
和 ObjectBinding 相同的 

803
00:28:11,636 --> 0:28:12,546
依赖追踪

804
00:28:13,066 --> 0:28:15,676
你用这些工具 

805
00:28:15,676 --> 0:28:18,186
把依赖描述给 SwiftUI

806
00:28:18,186 --> 0:28:19,516
框架会处理其他的部分

807
00:28:20,056 --> 0:28:20,596
这很棒

808
00:28:21,516 --> 0:28:27,036
[掌声]

809
00:28:27,536 --> 0:28:29,066
这个便捷的方法

810
00:28:29,066 --> 0:28:30,156
就可以更新我们的播客播放器

811
00:28:31,306 --> 0:28:33,796
就像这样

812
00:28:34,656 --> 0:28:35,766
你只需要添加

813
00:28:35,766 --> 0:28:37,086
EnvironmentObject Property Wrapper 到视图

814
00:28:37,086 --> 0:28:40,126
然后在视图

815
00:28:40,126 --> 0:28:41,486
上方的父类中 

816
00:28:41,486 --> 0:28:43,366
只用 EnvironmentObject Modifier 

817
00:28:43,366 --> 0:28:45,106
提供模型

818
00:28:46,426 --> 0:28:48,466
现在 不论什么时候

819
00:28:48,466 --> 0:28:50,426
只要我们在主体中使用播放器

820
00:28:50,526 --> 0:28:53,346
SwiftUI 就会自动替我们更新数据

821
00:28:53,976 --> 0:28:55,346
你可能会想

822
00:28:56,026 --> 0:28:56,866
什么时候用

823
00:28:56,866 --> 0:28:58,836
EnvironmentObject 

824
00:28:58,836 --> 0:28:59,566
什么时候用 ObjectBinding

825
00:29:00,556 --> 0:29:02,966
实际上你可以使用 ObjectBinding

826
00:29:02,966 --> 0:29:04,246
构建整个 App

827
00:29:04,246 --> 0:29:06,796
但是从出栈到进栈

828
00:29:06,796 --> 0:29:08,006
传递模型

829
00:29:08,006 --> 0:29:10,006
会比较冗长

830
00:29:11,286 --> 0:29:11,846
这时候就需要

831
00:29:11,846 --> 0:29:13,126
EnvironmentObject 了

832
00:29:14,136 --> 0:29:16,366
这真的很方便

833
00:29:16,696 --> 0:29:18,446
不直接在层级间 

834
00:29:18,446 --> 0:29:19,866
传输数据

835
00:29:21,316 --> 0:29:23,626
这里 你可以看到

836
00:29:23,626 --> 0:29:25,686
通过 EnvironmentObject

837
00:29:25,686 --> 0:29:27,156
我们可以间接传送模型

838
00:29:27,156 --> 0:29:29,026
通过视图层级 

839
00:29:29,026 --> 0:29:30,566
也就是说我们不需要

840
00:29:30,566 --> 0:29:32,006
用模型实例化所有的即时视图

841
00:29:32,006 --> 0:29:33,846
到视图层级

842
00:29:37,816 --> 0:29:39,616
所以 Environment 真的是一个很好的方式

843
00:29:39,616 --> 0:29:41,186
用来间接传送各种数据

844
00:29:41,186 --> 0:29:42,876
一路通过

845
00:29:42,876 --> 0:29:43,626
你的视图层级

846
00:29:44,366 --> 0:29:46,126
你可能已经看过

847
00:29:46,396 --> 0:29:48,956
它在重点色

848
00:29:48,956 --> 0:29:51,356
或布局方向等方面的应用

849
00:29:52,446 --> 0:29:55,036
正如 Luca 刚才所说 

850
00:29:55,036 --> 0:29:57,106
数据的形态结构多种多样

851
00:29:58,276 --> 0:30:00,616
值 像是重点色

852
00:29:58,276 --> 0:30:00,616
值 像是重点色

853
00:30:00,726 --> 0:30:02,746
布局方向

854
00:30:02,746 --> 0:30:03,226
它们只是数据

855
00:30:04,276 --> 0:30:06,006
当你在视图中使用它们时

856
00:30:06,006 --> 0:30:07,506
你就是在它们上面

857
00:30:07,506 --> 0:30:08,406
创建依赖

858
00:30:09,726 --> 0:30:11,906
实际上 Environment 是一个

859
00:30:12,016 --> 0:30:13,416
通用集装箱 

860
00:30:13,416 --> 0:30:15,186
可以用来处理各种

861
00:30:15,256 --> 0:30:16,376
间接数据和依赖

862
00:30:16,776 --> 0:30:17,956
框架自由使用它

863
00:30:17,956 --> 0:30:20,066
为你带来各种特色功能

864
00:30:20,066 --> 0:30:22,606
比如动态类型

865
00:30:22,606 --> 0:30:23,176
和深色模式

866
00:30:24,156 --> 0:30:25,566
你还可以

867
00:30:25,686 --> 0:30:27,546
在预览中使用 Environment  

868
00:30:27,546 --> 0:30:29,066
给重点色或主题等

869
00:30:29,066 --> 0:30:31,486
赋新值

870
00:30:35,756 --> 0:30:37,406
我们已经快速过了一遍

871
00:30:37,406 --> 0:30:39,646
SwiftUI 里

872
00:30:39,646 --> 0:30:41,226
处理数据的强大工具

873
00:30:42,466 --> 0:30:43,916
现在我让大家

874
00:30:43,916 --> 0:30:46,496
对如何使用正确的工具

875
00:30:46,496 --> 0:30:48,276
和如何调配它们

876
00:30:48,276 --> 0:30:48,836
有一个概念

877
00:30:49,386 --> 0:30:53,276
这里主题之一是

878
00:30:53,526 --> 0:30:55,446
每一条数据

879
00:30:55,446 --> 0:30:57,006
都有单一数据源

880
00:30:57,646 --> 0:30:59,516
在 SwiftUI 中 

881
00:30:59,606 --> 0:31:01,746
我们有两种选择 

882
00:30:59,606 --> 0:31:01,746
我们有两种选择 

883
00:31:01,746 --> 0:31:03,936
去处理这些数据源

884
00:31:04,126 --> 0:31:05,586
第一种是 State

885
00:31:06,606 --> 0:31:08,236
State 适合本地视图的数据

886
00:31:08,386 --> 0:31:10,766
一个值类型

887
00:31:11,766 --> 0:31:14,506
由框架 

888
00:31:14,506 --> 0:31:15,106
处理 分配 和创建 

889
00:31:15,776 --> 0:31:19,836
BindableObject 适合

890
00:31:19,836 --> 0:31:20,916
你控制的数据

891
00:31:22,286 --> 0:31:23,396
它适用于给 SwiftUI 展现

892
00:31:23,526 --> 0:31:25,746
外部数据

893
00:31:25,746 --> 0:31:29,576
比如在 onDevice 数据库

894
00:31:29,786 --> 0:31:32,756
这里有你处理的内存

895
00:31:32,756 --> 0:31:34,306
对你已有的模型

896
00:31:34,306 --> 0:31:35,296
很有帮助

897
00:31:35,926 --> 0:31:38,756
现在我们已经了解了

898
00:31:38,756 --> 0:31:40,866
数据源 接下来

899
00:31:40,866 --> 0:31:42,306
我想介绍一下

900
00:31:42,306 --> 0:31:43,486
构建可重复使用的组件

901
00:31:44,056 --> 0:31:46,456
SwiftUI 的一个优点是

902
00:31:46,456 --> 0:31:48,866
视图是

903
00:31:48,866 --> 0:31:49,976
低成本阻塞

904
00:31:49,976 --> 0:31:52,786
这意味着

905
00:31:52,946 --> 0:31:54,466
我们不需要

906
00:31:54,756 --> 0:31:57,576
在架构和性能之间做折中

907
00:31:58,246 --> 0:31:59,566
你可以搭建

908
00:31:59,566 --> 0:32:00,996
你想搭建的架构

909
00:31:59,566 --> 0:32:00,996
你想搭建的架构

910
00:32:01,206 --> 0:32:03,466
同时也能获得很好的性能

911
00:32:03,626 --> 0:32:04,566
你不需要

912
00:32:04,566 --> 0:32:05,666
权衡折中

913
00:32:06,826 --> 0:32:09,316
通过 SwiftUI 你可以集中精力于

914
00:32:09,436 --> 0:32:10,786
让你的视图成为

915
00:32:10,786 --> 0:32:11,906
可重复使用的组件

916
00:32:12,446 --> 0:32:14,606
当你这么做时

917
00:32:14,816 --> 0:32:16,646
你可能会注意到

918
00:32:16,646 --> 0:32:17,966
在视图中使用数据时

919
00:32:17,966 --> 0:32:19,896
你也许不需要

920
00:32:19,896 --> 0:32:20,666
改写它

921
00:32:21,326 --> 0:32:24,106
所以当你可以不管它时

922
00:32:24,686 --> 0:32:27,106
只读路径是更好的选择

923
00:32:28,236 --> 0:32:30,336
在这一点上 我们有 Swift Property

924
00:32:30,336 --> 0:32:31,826
和 Environment 

925
00:32:32,766 --> 0:32:34,566
因为视图在 SwiftUI 中是

926
00:32:34,566 --> 0:32:36,396
值类型

927
00:32:36,566 --> 0:32:37,606
框架可以自动确定

928
00:32:37,606 --> 0:32:39,126
数据什么时候改变

929
00:32:39,126 --> 0:32:43,146
视图也会随之变化

930
00:32:43,146 --> 0:32:44,596
总的来说 你应该倾向于选择

931
00:32:44,596 --> 0:32:46,896
不可改写访问

932
00:32:46,956 --> 0:32:48,306
但是有时你确实需要改写值

933
00:32:49,626 --> 0:32:51,596
这时我们有 Binding

934
00:32:52,256 --> 0:32:55,756
正如 Luca 刚才告诉大家的

935
00:32:55,756 --> 0:32:58,186
Binding 是数据的第一类对象

936
00:32:59,126 --> 0:33:00,976
它可以让你的组件

937
00:32:59,126 --> 0:33:00,976
它可以让你的组件

938
00:33:00,976 --> 0:33:03,756
在不拥有的情况下

939
00:33:03,756 --> 0:33:05,276
读写数据

940
00:33:05,276 --> 0:33:07,256
这对于可重复使用来说很有利

941
00:33:08,226 --> 0:33:09,576
实际上 你可以

942
00:33:09,576 --> 0:33:10,586
绑定到很多不同的

943
00:33:10,586 --> 0:33:11,596
数据表现

944
00:33:12,566 --> 0:33:13,836
今天我们将展示如何

945
00:33:13,836 --> 0:33:15,476
绑定到 State

946
00:33:15,476 --> 0:33:16,796
和如何绑定到

947
00:33:16,796 --> 0:33:17,486
ObjectBinding

948
00:33:18,096 --> 0:33:20,616
实际上 你也可以

949
00:33:20,616 --> 0:33:21,756
绑定另一个绑定

950
00:33:22,926 --> 0:33:24,266
你只需要用

951
00:33:24,266 --> 0:33:25,846
我们之前展示的

952
00:33:25,846 --> 0:33:26,406
美元符号前缀

953
00:33:26,406 --> 0:33:28,266
它可以让你

954
00:33:28,266 --> 0:33:29,596
从其他工具之一里

955
00:33:29,596 --> 0:33:30,346
生成一个绑定

956
00:33:30,346 --> 0:33:33,716
我想停一下让大家欣赏

957
00:33:33,716 --> 0:33:35,066
这是多么有用

958
00:33:35,946 --> 0:33:37,926
刚才 Luca 展示了

959
00:33:37,926 --> 0:33:39,316
我们在 SwiftUI 里提供的组件

960
00:33:39,376 --> 0:33:41,386
它们运行在 Binding 上

961
00:33:42,436 --> 0:33:44,286
接下来以 Toggle 为例

962
00:33:45,296 --> 0:33:47,256
Toggle 把绑定给到 Boolean

963
00:33:48,456 --> 0:33:49,856
但是 SwiftUI 中数据的美观性在于

964
00:33:49,856 --> 0:33:51,906
Toggle 不需要知道

965
00:33:51,906 --> 0:33:55,036
或不需要在意

966
00:33:55,036 --> 0:33:56,736
Boolean 在哪儿或来自哪儿

967
00:33:57,476 --> 0:33:59,446
它要做的只是

968
00:33:59,446 --> 0:34:01,906
知道如何读取和改变值

969
00:33:59,446 --> 0:34:01,906
知道如何读取和改变值

970
00:34:02,916 --> 0:34:04,106
Binding 是一个工具 

971
00:34:04,106 --> 0:34:05,926
它可以封装这些操作

972
00:34:06,246 --> 0:34:08,576
而且同时

973
00:34:08,576 --> 0:34:09,856
不需要考虑 Toggle

974
00:34:10,456 --> 0:34:14,255
这是在 SwiftUI 中使用数据的

975
00:34:14,255 --> 0:34:15,466
真正魅力所在

976
00:34:16,286 --> 0:34:17,996
你可以做到非常准确

977
00:34:18,866 --> 0:34:20,835
而且不需要担心其他的

978
00:34:23,876 --> 0:34:25,346
你会发现

979
00:34:25,346 --> 0:34:26,826
在我讲解

980
00:34:26,826 --> 0:34:28,076
搭建可重复使用组件的时候

981
00:34:28,076 --> 0:34:29,036
我实际并没怎么提及 State

982
00:34:29,356 --> 0:34:32,416
State 被卡在你的

983
00:34:32,416 --> 0:34:33,706
视图以及它的子类里

984
00:34:34,696 --> 0:34:36,846
所以如果你的组件需要

985
00:34:36,846 --> 0:34:38,045
操作一个值

986
00:34:38,156 --> 0:34:40,146
一个来自外部或其他地方的值

987
00:34:40,795 --> 0:34:43,426
State 也许不合适

988
00:34:44,235 --> 0:34:46,356
对于原型开发第一步来说

989
00:34:46,356 --> 0:34:47,366
State 是一个很好的工具

990
00:34:47,366 --> 0:34:49,386
正如你今天看到的

991
00:34:49,386 --> 0:34:50,116
它在我们播客播放器上的表现一样

992
00:34:51,196 --> 0:34:53,126
但是大部分情况下

993
00:34:53,346 --> 0:34:55,036
你的数据是存在于

994
00:34:55,226 --> 0:34:55,666
SwiftUI 之外的

995
00:34:57,386 --> 0:34:59,096
比如数据可能

996
00:34:59,096 --> 0:35:00,936
在一个数据库里 

997
00:34:59,096 --> 0:35:00,936
在一个数据库里 

998
00:35:00,936 --> 0:35:02,266
这可能就需要其他东西来展现它

999
00:35:02,586 --> 0:35:04,036
比如 BindableObject

1000
00:35:04,726 --> 0:35:07,266
所以如果你要用 State 的话

1001
00:35:07,266 --> 0:35:09,376
请退一步

1002
00:35:09,376 --> 0:35:12,066
考虑一下

1003
00:35:12,106 --> 0:35:13,886
数据真的需要

1004
00:35:13,886 --> 0:35:14,346
被视图拥有吗

1005
00:35:15,526 --> 0:35:17,806
也许数据 状态

1006
00:35:17,856 --> 0:35:19,166
需要被提到父类

1007
00:35:19,166 --> 0:35:20,616
就像刚才 Loca 展示的那样

1008
00:35:20,616 --> 0:35:23,206
或者数据可以

1009
00:35:23,206 --> 0:35:24,736
被外部源

1010
00:35:24,956 --> 0:35:27,486
通过 BindableObject 展现

1011
00:35:27,966 --> 0:35:31,076
所以使用数据时

1012
00:35:31,076 --> 0:35:33,546
需要非常小心

1013
00:35:33,546 --> 0:35:34,306
但它确实有它的优点

1014
00:35:35,566 --> 0:35:37,196
State 的一大用途是

1015
00:35:37,436 --> 0:35:40,066
我们框架里有按钮

1016
00:35:41,486 --> 0:35:43,286
按钮用 State 追踪

1017
00:35:43,576 --> 0:35:44,916
用户是否按下了按钮

1018
00:35:44,916 --> 0:35:46,656
然后以合适的方式高亮它

1019
00:35:47,676 --> 0:35:48,796
通过 State 处理按钮的好处是

1020
00:35:48,796 --> 0:35:51,286
当你创建了一个按钮

1021
00:35:51,286 --> 0:35:52,626
你不需要再考虑

1022
00:35:52,626 --> 0:35:54,656
高亮状态

1023
00:35:55,726 --> 0:35:58,366
数据真正

1024
00:35:58,606 --> 0:36:01,336
归按钮所有

1025
00:35:58,606 --> 0:36:01,336
归按钮所有

1026
00:36:01,506 --> 0:36:02,566
所以当你要用 State 时

1027
00:36:02,566 --> 0:36:04,816
你需要考虑的是

1028
00:36:04,816 --> 0:36:05,556
情况是否和按钮一样

1029
00:36:06,256 --> 0:36:07,516
如果一样的话

1030
00:36:07,516 --> 0:36:08,036
State 或许是个很好的工具

1031
00:36:08,906 --> 0:36:10,776
如果情况不一样

1032
00:36:10,776 --> 0:36:12,066
那你就要考虑使用其他工具了

1033
00:36:12,066 --> 0:36:13,656
我们刚才也为大家展示了

1034
00:36:13,656 --> 0:36:14,236
这些 SwiftUI 中的工具

1035
00:36:17,536 --> 0:36:18,946
这就是如何用 SwiftUI 

1036
00:36:18,946 --> 0:36:20,016
构建可重复使用组件

1037
00:36:20,686 --> 0:36:23,196
我们在这里向大家展示的是

1038
00:36:23,196 --> 0:36:25,246
对所有类型的软件都适用的

1039
00:36:25,246 --> 0:36:26,386
普遍情况

1040
00:36:27,606 --> 0:36:29,156
每个软件都有数据

1041
00:36:30,076 --> 0:36:32,126
而且每个软件都有

1042
00:36:32,176 --> 0:36:33,126
数据访问

1043
00:36:34,296 --> 0:36:36,036
仔细了解你的数据

1044
00:36:36,036 --> 0:36:38,196
尽量减少

1045
00:36:38,196 --> 0:36:40,396
数据源

1046
00:36:40,396 --> 0:36:42,356
构建可重复使用组件

1047
00:36:42,356 --> 0:36:44,986
你可以消除一整级的 Bug 

1048
00:36:45,646 --> 0:36:48,426
使用 SwiftUI 时

1049
00:36:49,016 --> 0:36:50,526
应用这些观念

1050
00:36:50,526 --> 0:36:52,596
会非常简单

1051
00:36:52,676 --> 0:36:54,096
因为我们已经把它们

1052
00:36:54,146 --> 0:36:54,556
应用在框架里了

1053
00:36:57,436 --> 0:36:58,686
我们还有很多关于

1054
00:36:58,686 --> 0:37:00,766
SwiftUI 的讲解

1055
00:36:58,686 --> 0:37:00,766
SwiftUI 的讲解

1056
00:37:00,766 --> 0:37:04,106
我建议大家去看一下所有的相关介绍

1057
00:37:04,306 --> 0:37:07,146
这将会改变你搭建 App 的方式

1058
00:37:08,096 --> 0:37:08,746
谢谢大家

1059
00:37:09,516 --> 0:37:15,500
[掌声]
