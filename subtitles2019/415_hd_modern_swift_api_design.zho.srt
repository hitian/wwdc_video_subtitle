1
00:00:00,516 --> 0:00:05,000
[音乐]

2
00:00:07,516 --> 0:00:11,500
[掌声]

3
00:00:12,786 --> 0:00:13,366
&gt;&gt; 大家好

4
00:00:14,736 --> 0:00:15,946
我是 Ben 跟我一起的

5
00:00:15,946 --> 0:00:17,066
是我的同事 Doug

6
00:00:17,066 --> 0:00:19,496
我们将要跟你们讲讲 Swift 里的 API 设计

7
00:00:20,326 --> 0:00:21,786
那么 在有了关于

8
00:00:21,786 --> 0:00:24,136
二进制和模块稳定性的介绍后

9
00:00:24,536 --> 0:00:26,096
我们感到非常兴奋

10
00:00:26,096 --> 0:00:27,746
这是我们第一次能够介绍框架

11
00:00:28,126 --> 0:00:29,586
这个框架很好地利用

12
00:00:29,586 --> 0:00:31,176
Swift 来提供丰富

13
00:00:31,436 --> 0:00:33,406
有效且便于使用的 API

14
00:00:33,406 --> 0:00:36,006
作为 Apple SDK 的一部分

15
00:00:36,556 --> 0:00:37,956
现在 我们已经知道了

16
00:00:38,076 --> 0:00:39,566
设计这些 API 的一部分内容

17
00:00:39,566 --> 0:00:40,986
也就是我们今天要跟你们聊的

18
00:00:40,986 --> 0:00:43,116
那么 我们将要涉及到

19
00:00:43,116 --> 0:00:44,746
一些基本的概念

20
00:00:45,606 --> 0:00:47,396
并且理解它们是如何影响

21
00:00:47,396 --> 0:00:48,306
你的 API 设计的

22
00:00:48,746 --> 0:00:49,516
然后我们需要

23
00:00:49,516 --> 0:00:51,066
深入了解一些

24
00:00:51,066 --> 0:00:53,516
Swift 5.1 的新功能

25
00:00:53,516 --> 0:00:54,996
来看看它们是如何提供帮助

26
00:00:54,996 --> 0:00:56,476
使你的 API 表现更出色

27
00:00:57,406 --> 0:00:58,246
同时我们也将向

28
00:00:58,246 --> 0:00:59,976
你们展示一些例子

29
00:00:59,976 --> 0:01:01,486
源自我们最新的 Swift 框架

30
00:00:59,976 --> 0:01:01,486
源自我们最新的 Swift 框架

31
00:01:01,756 --> 0:01:04,686
包括 SwiftUI 以及 RealityKit

32
00:01:06,496 --> 0:01:08,926
那么 我们之前已经讲过了 API 设计

33
00:01:09,116 --> 0:01:11,096
尤其在 2016 年我们

34
00:01:11,096 --> 0:01:13,856
介绍了 Swift API 设计指南

35
00:01:14,546 --> 0:01:15,926
你们现在仍可以在

36
00:01:15,926 --> 0:01:17,106
Swift.org 网站对这些进行查看

37
00:01:17,466 --> 0:01:18,626
它们包含了一些

38
00:01:18,626 --> 0:01:21,076
很有用的建议 围绕着如何命名

39
00:01:21,166 --> 0:01:22,046
以及为你的 API 写文档

40
00:01:22,086 --> 0:01:24,256
但是我现在不会重复这些

41
00:01:24,786 --> 0:01:26,186
但是有一点

42
00:01:26,186 --> 0:01:27,306
我们今天需要去解决

43
00:01:27,306 --> 0:01:30,466
这就是

44
00:01:30,466 --> 0:01:32,406
使用时的清晰明确

45
00:01:32,406 --> 0:01:34,606
是作为 API 设计师的最大目标

46
00:01:35,166 --> 0:01:37,096
你想要做到这一点 这样一来

47
00:01:37,096 --> 0:01:39,116
在阅读使用你的 API 的代码时

48
00:01:39,736 --> 0:01:40,886
它所做的就会一目了然

49
00:01:41,756 --> 0:01:43,506
同时 你想要做到这一点

50
00:01:43,626 --> 0:01:45,146
使你的 API 可以得到正确使用

51
00:01:46,136 --> 0:01:48,696
好的命名和可读性

52
00:01:48,696 --> 0:01:50,016
对此至关重要

53
00:01:50,756 --> 0:01:53,036
还有一个新的东西

54
00:01:53,036 --> 0:01:53,886
是关于命名的

55
00:01:53,886 --> 0:01:55,366
就是接下来

56
00:01:55,366 --> 0:01:57,146
我们将不在

57
00:01:57,146 --> 0:01:59,366
我们仅限 Swift 使用的 API

58
00:01:59,366 --> 0:02:00,986
中使用 Swift 类型的前缀

59
00:01:59,366 --> 0:02:00,986
中使用 Swift 类型的前缀

60
00:02:00,986 --> 0:02:04,136
现在 这会为

61
00:02:04,266 --> 0:02:06,956
这些 API 带来更整洁

62
00:02:07,016 --> 0:02:07,766
更可读的体验

63
00:02:07,766 --> 0:02:11,756
目前 在 C 和 Objective-C 语言中我们

64
00:02:11,756 --> 0:02:13,866
不得不使用前缀 因为

65
00:02:14,026 --> 0:02:15,816
每个符号都处在全球

66
00:02:15,816 --> 0:02:17,546
命名空间里 没有一个好的方法

67
00:02:17,546 --> 0:02:18,346
来消除歧义

68
00:02:19,376 --> 0:02:20,766
基于这一原因 Apple

69
00:02:21,036 --> 0:02:22,966
和开发人员必须遵循一套

70
00:02:22,966 --> 0:02:24,946
非常严格的前缀惯例

71
00:02:25,736 --> 0:02:27,386
为了统一 我们将

72
00:02:27,386 --> 0:02:29,406
继续使用前缀

73
00:02:29,406 --> 0:02:31,536
在那些 Swift 版本的 API 同时

74
00:02:31,536 --> 0:02:33,446
在 Objective-C 语言有对应的情况下

75
00:02:35,516 --> 0:02:37,626
但是 Swift 的模块系统

76
00:02:37,626 --> 0:02:40,106
可以消除歧义 通过

77
00:02:40,106 --> 0:02:41,556
在类型前面加上

78
00:02:41,556 --> 0:02:42,256
模块名称

79
00:02:42,256 --> 0:02:44,046
由于这个原因

80
00:02:44,046 --> 0:02:46,076
标准库也从来没有前缀

81
00:02:46,356 --> 0:02:47,816
你们中的很多人已经发现了

82
00:02:47,876 --> 0:02:48,986
你们也可以将其从你们的

83
00:02:48,986 --> 0:02:49,926
Swift 框架上去除

84
00:02:50,496 --> 0:02:53,886
但是请记住

85
00:02:53,886 --> 0:02:55,326
即便如此 你们也需要

86
00:02:55,326 --> 0:02:56,986
小心谨慎一点

87
00:02:57,996 --> 0:02:59,966
一个非常笼统的名称会让

88
00:02:59,966 --> 0:03:01,776
你的用户必须手动

89
00:02:59,966 --> 0:03:01,776
你的用户必须手动

90
00:03:01,776 --> 0:03:03,336
区分产生歧义的状况

91
00:03:03,336 --> 0:03:04,046
一旦有冲突的话

92
00:03:04,926 --> 0:03:06,846
而且请始终记住

93
00:03:06,846 --> 0:03:07,776
使用时的清晰明确

94
00:03:08,736 --> 0:03:10,266
某个特定框架的一个笼统名称

95
00:03:10,266 --> 0:03:11,856
可能看上去会有点儿

96
00:03:11,856 --> 0:03:13,496
让人困惑

97
00:03:13,536 --> 0:03:14,166
当你没有上下文的时候

98
00:03:14,626 --> 0:03:17,686
现在 我们要讲几个主题

99
00:03:17,686 --> 0:03:19,116
值 引用

100
00:03:19,116 --> 0:03:21,476
协议和泛型

101
00:03:21,926 --> 0:03:23,216
这之后我们将要讲到

102
00:03:23,216 --> 0:03:24,656
我们的两个新功能

103
00:03:24,656 --> 0:03:27,126
关键路径成员查找和属性包装器

104
00:03:28,096 --> 0:03:29,356
那么 让我们先来讲一下

105
00:03:29,356 --> 0:03:30,896
值和引用

106
00:03:31,016 --> 0:03:32,416
首先快速回顾一下

107
00:03:32,666 --> 0:03:34,616
Swift 有三个创建类型的基本概念

108
00:03:34,616 --> 0:03:38,426
类 结构和枚举

109
00:03:39,776 --> 0:03:41,456
类是引用类型

110
00:03:41,456 --> 0:03:42,236
那代表着当你有一个变量

111
00:03:42,236 --> 0:03:44,076
它就指向

112
00:03:44,076 --> 0:03:46,006
有着实际值的对象

113
00:03:46,796 --> 0:03:48,266
当你对它进行复制

114
00:03:48,266 --> 0:03:50,006
就是在复制引用

115
00:03:50,466 --> 0:03:51,726
那代表着当你

116
00:03:51,726 --> 0:03:53,066
通过引用改变一个值

117
00:03:53,066 --> 0:03:55,416
你实际上在改变

118
00:03:55,416 --> 0:03:57,086
同一个对象

119
00:03:57,086 --> 0:03:57,976
而两个变量都指向这个对象

120
00:03:59,436 --> 0:04:00,756
所以它们都能看到变化

121
00:03:59,436 --> 0:04:00,756
所以它们都能看到变化

122
00:04:01,296 --> 0:04:04,926
在另一方面 结构和枚举

123
00:04:04,926 --> 0:04:06,446
是值类型

124
00:04:06,446 --> 0:04:07,356
当你复制它们

125
00:04:07,476 --> 0:04:09,556
就会复制其所有内容

126
00:04:09,946 --> 0:04:11,196
那代表着当你

127
00:04:11,196 --> 0:04:12,626
做出一个改变 你只是在

128
00:04:12,626 --> 0:04:14,036
改变那一个拷贝

129
00:04:15,086 --> 0:04:16,866
现在 在你的 API 里使用值类型

130
00:04:16,866 --> 0:04:18,416
能带来很多好处

131
00:04:18,486 --> 0:04:20,555
在使用的清晰明确方面

132
00:04:20,995 --> 0:04:21,846
如果你知道你每次都在

133
00:04:21,846 --> 0:04:24,166
获得一个全新的 独一无二的拷贝

134
00:04:24,556 --> 0:04:25,746
那么你就不需要担心

135
00:04:25,746 --> 0:04:27,206
值来自哪里

136
00:04:27,436 --> 0:04:29,006
是否有人对其设有引用

137
00:04:29,006 --> 0:04:30,126
或者是在

138
00:04:30,126 --> 0:04:31,556
你不知情的情况下

139
00:04:31,246 --> 0:04:31,556
进行修改

140
00:04:32,426 --> 0:04:34,426
你不需要 比如

141
00:04:34,426 --> 0:04:36,346
做一个防御性的拷贝

142
00:04:36,346 --> 0:04:37,686
现在 有了这个

143
00:04:37,686 --> 0:04:38,866
出现了一个常见问题 就是

144
00:04:39,066 --> 0:04:40,966
我是否应该将引用或者

145
00:04:40,966 --> 0:04:43,336
一个值的类型用于我某一段

146
00:04:43,336 --> 0:04:43,956
特定的代码

147
00:04:44,276 --> 0:04:45,986
而每种使用情况是不同的

148
00:04:45,986 --> 0:04:47,646
所以没有一个硬性规定

149
00:04:48,036 --> 0:04:49,006
但是有一些笼统的指南

150
00:04:49,006 --> 0:04:50,686
也就是总的来说

151
00:04:50,686 --> 0:04:52,856
你应该倾向使用

152
00:04:52,856 --> 0:04:54,716
结构而不是类 除非你

153
00:04:54,716 --> 0:04:56,496
有一个使用类的很好的理由

154
00:04:57,216 --> 0:04:58,736
如果你默认使用一个类

155
00:04:58,736 --> 0:04:59,996
当每次在创建类型时

156
00:04:59,996 --> 0:05:01,086
试着将这一默认从你

157
00:04:59,996 --> 0:05:01,086
试着将这一默认从你

158
00:05:01,086 --> 0:05:02,386
运行的代码中移开

159
00:05:02,386 --> 0:05:02,886
看看会怎么样

160
00:05:03,956 --> 0:05:05,496
目前 类

161
00:05:05,496 --> 0:05:06,896
在 Swift 中还很重要

162
00:05:07,426 --> 0:05:08,956
它们很关键 如果你需要

163
00:05:09,076 --> 0:05:10,786
通过引用计数

164
00:05:10,786 --> 0:05:11,656
管理资源

165
00:05:12,146 --> 0:05:13,316
虽然 你可能常常想要将

166
00:05:13,536 --> 0:05:14,976
那个类包含在一个结构里

167
00:05:14,976 --> 0:05:15,706
像我们马上会看到的那样

168
00:05:16,896 --> 0:05:18,816
它们也是有用的结构体

169
00:05:18,816 --> 0:05:20,316
如果有东西需要被基础性地

170
00:05:20,316 --> 0:05:22,046
存储和分享

171
00:05:22,836 --> 0:05:24,826
很重要的一点 如果你的类型

172
00:05:24,826 --> 0:05:26,046
具有标识

173
00:05:26,196 --> 0:05:28,316
标识的概念

174
00:05:28,316 --> 0:05:29,656
与值分离

175
00:05:30,386 --> 0:05:32,106
这通常标记着某个类

176
00:05:32,106 --> 0:05:33,566
是合理的

177
00:05:34,766 --> 0:05:36,796
现在 有时我们

178
00:05:36,796 --> 0:05:38,806
必须进行判断

179
00:05:38,876 --> 0:05:39,646
那就是在 RealityKit

180
00:05:40,526 --> 0:05:42,506
RealityKit 的 API 围绕着

181
00:05:42,506 --> 0:05:44,016
这些称为实体的东西

182
00:05:44,636 --> 0:05:46,896
这些代表着

183
00:05:46,896 --> 0:05:48,276
出现在场景的对象

184
00:05:48,686 --> 0:05:50,656
它们被存储在

185
00:05:50,656 --> 0:05:52,156
RealityKit 引擎的中心

186
00:05:52,156 --> 0:05:53,356
它们具有标识

187
00:05:54,086 --> 0:05:55,776
当你需要操控一个场景

188
00:05:55,836 --> 0:05:57,956
通过改变对象的

189
00:05:57,956 --> 0:06:00,336
外表或者将它们移动

190
00:05:57,956 --> 0:06:00,336
外表或者将它们移动

191
00:06:00,336 --> 0:06:01,946
然后你就直接

192
00:06:01,946 --> 0:06:04,126
在那个引擎里操控对象了

193
00:06:04,546 --> 0:06:05,666
你可以把引用类型看作是

194
00:06:05,666 --> 0:06:08,706
把手

195
00:06:08,706 --> 0:06:11,076
可以处理 RealityKit 中的实际对象

196
00:06:11,556 --> 0:06:13,106
所以这对于引用类型来说

197
00:06:13,106 --> 0:06:13,846
有着完美用途

198
00:06:14,536 --> 0:06:17,446
但是 这些实体的属性

199
00:06:17,446 --> 0:06:19,546
比如它们的定位

200
00:06:19,546 --> 0:06:21,676
或综合某一场景中的方向

201
00:06:21,676 --> 0:06:23,636
被建模成为值的类型

202
00:06:24,396 --> 0:06:25,276
现在 让我们来看看它们

203
00:06:25,276 --> 0:06:26,096
在代码里看上去如何

204
00:06:26,896 --> 0:06:28,416
假设我们想在

205
00:06:28,776 --> 0:06:30,546
这里创建场景

206
00:06:31,146 --> 0:06:33,646
那么我们首先要创建一个

207
00:06:33,646 --> 0:06:34,406
material 类型

208
00:06:34,916 --> 0:06:36,906
然后我们在外面创建

209
00:06:36,906 --> 0:06:38,286
两个盒子

210
00:06:38,416 --> 0:06:39,576
然后我们需要把它们

211
00:06:39,576 --> 0:06:40,426
固定在场景中

212
00:06:41,196 --> 0:06:42,476
接下来 一旦完成这个

213
00:06:42,576 --> 0:06:43,796
我们就可以操控场景

214
00:06:43,836 --> 0:06:45,896
通过直接使用代码我们可以

215
00:06:46,086 --> 0:06:47,486
将小一点盒子在

216
00:06:47,486 --> 0:06:48,286
Y 轴上移动

217
00:06:48,336 --> 0:06:51,426
或者将大一点的盒子旋转 45 度

218
00:06:51,836 --> 0:06:53,096
当我们在

219
00:06:53,096 --> 0:06:54,776
这些引用类型上进行这些操作时

220
00:06:54,776 --> 0:06:56,096
我们正在直接

221
00:06:56,096 --> 0:06:57,296
操控场景

222
00:06:57,296 --> 0:06:59,056
这是很直观的

223
00:07:00,376 --> 0:07:02,676
现在 假设我们想要

224
00:07:02,676 --> 0:07:03,786
像这里一样 也就是

225
00:07:03,786 --> 0:07:04,616
使得每个盒子都是

226
00:07:04,616 --> 0:07:05,276
不同的颜色

227
00:07:05,816 --> 0:07:07,006
我们会使用的一种方法也许是

228
00:07:07,046 --> 0:07:10,526
是将 material.tintColor 

229
00:07:10,526 --> 0:07:11,066
设置成红色

230
00:07:11,886 --> 0:07:14,576
现在 我会期待什么结果呢

231
00:07:14,576 --> 0:07:16,056
这个 API 的用户在这个时候

232
00:07:16,056 --> 0:07:16,366
会发生什么呢

233
00:07:17,206 --> 0:07:19,556
这两个盒子都要变吗

234
00:07:19,776 --> 0:07:21,026
因为我改变了同时

235
00:07:21,026 --> 0:07:22,186
创建出这两个的变量

236
00:07:23,066 --> 0:07:24,516
或者只要

237
00:07:24,516 --> 0:07:26,706
后创建的盒子会适用

238
00:07:26,706 --> 0:07:27,396
这一新变化

239
00:07:27,796 --> 0:07:29,526
也就是说 material 应该

240
00:07:29,836 --> 0:07:32,446
作为引用类型还是值类型

241
00:07:33,216 --> 0:07:35,666
这两个中的任一模型都有可能

242
00:07:35,736 --> 0:07:37,166
成为一个 API 的合理设计

243
00:07:37,166 --> 0:07:39,636
虽然 在这里使用

244
00:07:39,636 --> 0:07:40,766
值类型的好处在于 如果

245
00:07:40,766 --> 0:07:41,966
在你的代码里有一段很长的距离

246
00:07:42,036 --> 0:07:43,776
在你一开始

247
00:07:43,776 --> 0:07:45,176
创建和使用 material

248
00:07:45,176 --> 0:07:46,666
类型并进行更改之间

249
00:07:47,226 --> 0:07:48,536
然后你忘记自己

250
00:07:48,536 --> 0:07:49,526
之前使用过它

251
00:07:49,526 --> 0:07:50,976
最后你可能更改了

252
00:07:50,976 --> 0:07:51,816
一部分场景

253
00:07:51,816 --> 0:07:52,766
而你并不想这么做

254
00:07:53,596 --> 0:07:54,726
基于这一理由

255
00:07:54,726 --> 0:07:56,086
RealityKit 选择将

256
00:07:56,116 --> 0:07:57,946
material 作为一个值类型

257
00:07:58,926 --> 0:08:00,316
但是引用语义

258
00:07:58,926 --> 0:08:00,316
但是引用语义

259
00:08:00,316 --> 0:08:01,956
对于其他 API 来说也合理

260
00:08:01,956 --> 0:08:03,246
就如我们在实体中看到的一样

261
00:08:04,236 --> 0:08:06,666
重要的一点在于你的

262
00:08:06,666 --> 0:08:09,906
API 有一个容易解释的模型

263
00:08:10,066 --> 0:08:12,536
解释事物如何以及为何运作

264
00:08:13,246 --> 0:08:16,006
最重要的一点是 

265
00:08:16,006 --> 0:08:17,636
那一行为如何运作不应该

266
00:08:17,636 --> 0:08:19,676
被类型的偶发

267
00:08:19,676 --> 0:08:22,056
执行细节所驱动

268
00:08:22,296 --> 0:08:22,896
相反 应该是一个

269
00:08:22,896 --> 0:08:25,296
有意识的选择 是基于用例的

270
00:08:26,626 --> 0:08:27,736
那么 我说的

271
00:08:27,736 --> 0:08:28,896
偶发执行细节

272
00:08:28,896 --> 0:08:29,236
是指什么呢

273
00:08:29,236 --> 0:08:30,966
好吧 让我们来看一个

274
00:08:30,966 --> 0:08:32,096
示例类型

275
00:08:32,426 --> 0:08:33,765
比如一个 material 类型

276
00:08:33,996 --> 0:08:36,836
我希望它像一个值

277
00:08:36,836 --> 0:08:38,296
所以我将它设置成一个结构

278
00:08:38,506 --> 0:08:39,635
我赋予它一些简单的属性

279
00:08:39,635 --> 0:08:41,106
比如 roughness

280
00:08:41,106 --> 0:08:43,476
然后我给它一个 textture 属性

281
00:08:43,856 --> 0:08:45,376
让我们假设纹 texture

282
00:08:45,376 --> 0:08:46,536
属性需要去通过

283
00:08:46,536 --> 0:08:48,486
引用计数来管理资源

284
00:08:48,486 --> 0:08:50,816
所以我决定将它设置成一个类

285
00:08:52,106 --> 0:08:53,906
现在 我们之前说过

286
00:08:53,906 --> 0:08:55,246
当你对一个值类型进行复制

287
00:08:55,246 --> 0:08:56,936
你将会复制其所有存储

288
00:08:56,936 --> 0:08:57,426
的属性

289
00:08:58,086 --> 0:08:59,196
但是当你复制一个

290
00:08:59,196 --> 0:09:00,926
引用类型时 你只是在

291
00:08:59,196 --> 0:09:00,926
引用类型时 你只是在

292
00:09:00,926 --> 0:09:02,376
复制那一个引用

293
00:09:03,226 --> 0:09:04,936
所以当你在复制

294
00:09:04,936 --> 0:09:06,776
这个 material 类型时 

295
00:09:06,776 --> 0:09:08,296
最后会发生的情况就是

296
00:09:08,296 --> 0:09:09,656
创建了引用副本

297
00:09:09,686 --> 0:09:10,996
所以两个类型最后

298
00:09:11,226 --> 0:09:13,186
共享了同一个纹理对象

299
00:09:14,576 --> 0:09:16,096
现在 是否可以

300
00:09:16,626 --> 0:09:17,356
实际上取决于

301
00:09:17,356 --> 0:09:18,726
纹理的实现

302
00:09:19,106 --> 0:09:21,016
如果纹理不可变 那么

303
00:09:21,016 --> 0:09:21,966
就非常完美

304
00:09:21,966 --> 0:09:23,576
事实上 这是很理想的

305
00:09:23,576 --> 0:09:24,696
从一个共享的角度考虑

306
00:09:26,066 --> 0:09:27,326
但是如果纹理

307
00:09:27,326 --> 0:09:28,996
在根本上是易变类型

308
00:09:29,806 --> 0:09:30,876
那么我这里所创建的

309
00:09:30,876 --> 0:09:32,116
实际上就有点奇怪了

310
00:09:32,116 --> 0:09:33,256
它的运作既不像

311
00:09:33,256 --> 0:09:35,016
一个引用 也不像一个值

312
00:09:35,426 --> 0:09:37,076
我可以对结构上的属性

313
00:09:37,236 --> 0:09:37,886
做出改变

314
00:09:38,936 --> 0:09:40,826
而且它只影响其中一个变量

315
00:09:40,856 --> 0:09:43,086
但是如果我作出更改

316
00:09:43,086 --> 0:09:46,286
从纹理引用到

317
00:09:46,286 --> 0:09:48,846
对象 那么它将影响两个变量

318
00:09:49,066 --> 0:09:49,936
而这是非常令人惊奇的

319
00:09:49,936 --> 0:09:51,736
对于你 API 的用户来说

320
00:09:51,736 --> 0:09:53,336
也许甚至比

321
00:09:53,336 --> 0:09:54,296
你一直受困于

322
00:09:54,356 --> 0:09:56,356
引用语义还要让人困惑

323
00:09:56,936 --> 0:09:59,466
所以在这儿我们需要做一个

324
00:09:59,466 --> 0:10:01,896
真正的关键区分

325
00:09:59,466 --> 0:10:01,896
真正的关键区分

326
00:10:01,896 --> 0:10:03,906
在值和引用类型之间

327
00:10:04,306 --> 0:10:06,856
结构与类相比

328
00:10:06,856 --> 0:10:08,836
以及值和引用语义

329
00:10:09,116 --> 0:10:10,836
和类型的表现

330
00:10:12,376 --> 0:10:13,916
仅仅因为一些东西是

331
00:10:13,916 --> 0:10:15,146
值类型 比如结构

332
00:10:15,286 --> 0:10:16,856
未必代表着

333
00:10:16,856 --> 0:10:18,826
你会自动从中获得

334
00:10:18,826 --> 0:10:20,266
值操作

335
00:10:20,496 --> 0:10:22,006
有一种方式 不是

336
00:10:22,006 --> 0:10:23,386
唯一的方式 但是普遍的方式

337
00:10:23,866 --> 0:10:25,966
就是当你将一个可变

338
00:10:26,376 --> 0:10:27,826
的引用类型作为

339
00:10:27,866 --> 0:10:28,616
公共 API 的一部分

340
00:10:28,616 --> 0:10:31,086
所以第一个问题 如果你

341
00:10:31,086 --> 0:10:32,176
想让一些东西表现的像一个值

342
00:10:32,176 --> 0:10:33,456
那么任何

343
00:10:33,456 --> 0:10:35,486
它显示的引用是可变的吗

344
00:10:36,686 --> 0:10:38,416
请记住 这并不

345
00:10:38,416 --> 0:10:39,466
总是很明显

346
00:10:40,056 --> 0:10:41,446
如果我们在处理一个

347
00:10:41,446 --> 0:10:43,696
非最终类 那么你

348
00:10:43,696 --> 0:10:47,036
实际上可能得到的可能是一个可变的子类

349
00:10:47,436 --> 0:10:49,536
幸运的是 我们

350
00:10:49,536 --> 0:10:51,436
有很多技术来避免

351
00:10:51,436 --> 0:10:52,496
类似这样的问题

352
00:10:53,616 --> 0:10:55,986
所以最早的一个就是去做

353
00:10:55,986 --> 0:10:56,946
我们经常针对引用类型

354
00:10:56,946 --> 0:10:58,956
所做的 也就是做一个防御性拷贝

355
00:10:59,316 --> 0:11:00,846
这样我们就可以将 texture

356
00:10:59,316 --> 0:11:00,846
这样我们就可以将 texture

357
00:11:00,846 --> 0:11:02,396
存储属性转为 private

358
00:11:03,476 --> 0:11:05,966
然后创建一个计算后的属性

359
00:11:06,296 --> 0:11:08,816
在设置中

360
00:11:08,816 --> 0:11:10,726
我们复制 texture 对象

361
00:11:11,286 --> 0:11:12,996
这就避免了可变的

362
00:11:12,996 --> 0:11:14,226
子类问题

363
00:11:15,176 --> 0:11:16,396
但是 问题没有解决

364
00:11:16,396 --> 0:11:17,566
如果纹理在

365
00:11:17,566 --> 0:11:19,506
根本上是可变类型

366
00:11:20,036 --> 0:11:21,366
因为你仍然可以改变它

367
00:11:21,366 --> 0:11:22,916
只需要通过 get 方法

368
00:11:22,976 --> 0:11:24,166
这就是引用的工作原理

369
00:11:25,036 --> 0:11:26,806
那么让我们来考虑一下

370
00:11:26,806 --> 0:11:29,886
另一种方式

371
00:11:29,886 --> 0:11:31,436
完全不显示引用类型

372
00:11:31,766 --> 0:11:34,326
相反 只是显示了

373
00:11:34,326 --> 0:11:36,346
我们希望反应在对象上的属性

374
00:11:36,866 --> 0:11:38,526
作为计算生成的属性在我们的

375
00:11:38,526 --> 0:11:40,046
material 值类型上

376
00:11:41,006 --> 0:11:42,676
所以我们可以创建一个通过计算

377
00:11:42,676 --> 0:11:43,156
产生的属性

378
00:11:43,156 --> 0:11:44,496
在 get 方法中

379
00:11:44,496 --> 0:11:45,916
转到相关的

380
00:11:45,916 --> 0:11:46,846
对象的属性

381
00:11:47,486 --> 0:11:50,196
但是在 set 方法中

382
00:11:50,196 --> 0:11:53,106
首先检查对象是否被

383
00:11:53,106 --> 0:11:54,226
唯一引用

384
00:11:54,476 --> 0:11:56,836
如果不是 那么这个时候

385
00:11:57,006 --> 0:11:59,026
我们可以在继续之前

386
00:11:59,026 --> 0:12:01,226
完全复制 texture 对象

387
00:11:59,026 --> 0:12:01,226
完全复制 texture 对象

388
00:12:01,226 --> 0:12:02,446
并作出更改

389
00:12:03,556 --> 0:12:05,516
通过添加这一行来检查

390
00:12:05,516 --> 0:12:06,756
唯一性 我们已经

391
00:12:06,756 --> 0:12:09,216
执行了完整的写时复制

392
00:12:09,396 --> 0:12:10,906
语义

393
00:12:10,906 --> 0:12:12,276
同时仍显示我们希望出现

394
00:12:12,566 --> 0:12:14,326
在我们的引用类型上的属性

395
00:12:16,556 --> 0:12:17,996
那么接下来 我们来讲讲

396
00:12:17,996 --> 0:12:19,546
协议和泛型

397
00:12:20,276 --> 0:12:21,976
那么 我们已经看过了值类型是如何

398
00:12:22,166 --> 0:12:24,676
使用户清晰明确的

399
00:12:24,676 --> 0:12:25,856
使用你的 API

400
00:12:26,686 --> 0:12:28,356
但是 值类型并不是一个新东西

401
00:12:28,356 --> 0:12:30,306
我们在 Objective-C 语言中一直有

402
00:12:30,376 --> 0:12:32,366
CGPoint 或 CGrect 之类的

403
00:12:33,036 --> 0:12:33,786
那么区别是什么呢

404
00:12:33,836 --> 0:12:35,646
Swift 中的区别

405
00:12:36,036 --> 0:12:37,236
在于可以向

406
00:12:37,436 --> 0:12:39,896
结构和枚举添加协议

407
00:12:40,506 --> 0:12:41,966
同样也包括类

408
00:12:42,506 --> 0:12:43,976
这意味着你可以共享代码

409
00:12:43,976 --> 0:12:45,726
通过使用泛型可以

410
00:12:46,036 --> 0:12:47,016
跨越很多值类型

411
00:12:47,816 --> 0:12:49,376
所以当你觉得你需要

412
00:12:49,376 --> 0:12:50,406
共享一些

413
00:12:50,406 --> 0:12:51,586
不同类型的代码

414
00:12:51,586 --> 0:12:53,576
并不是一定要创建类继承关系

415
00:12:53,576 --> 0:12:55,466
使其中的父类

416
00:12:55,466 --> 0:12:57,106
有共享功能

417
00:12:58,286 --> 0:13:00,756
而是 就像老话说的那样

418
00:12:58,286 --> 0:13:00,756
而是 就像老话说的那样

419
00:13:00,756 --> 0:13:02,876
在 Swift 中 一切从协议开始

420
00:13:04,176 --> 0:13:06,906
但是 那并不意味着当

421
00:13:06,906 --> 0:13:08,596
你打开 XCode 时你会得到

422
00:13:08,596 --> 0:13:09,816
一个空的源文件 你要做的

423
00:13:09,816 --> 0:13:12,356
第一件事是用键盘输入协议

424
00:13:12,986 --> 0:13:14,766
在 Swift API 设计中

425
00:13:14,766 --> 0:13:16,606
就像任何的 Swift 设计一样

426
00:13:16,606 --> 0:13:18,546
首先通过具体的类型探索用例

427
00:13:18,546 --> 0:13:20,376
并且理解

428
00:13:20,376 --> 0:13:21,466
你想要共享的代码是什么

429
00:13:21,466 --> 0:13:23,686
当你发现自己在不同类型上

430
00:13:23,686 --> 0:13:25,086
重复多个功能时

431
00:13:25,706 --> 0:13:27,516
然后通过泛型将代码

432
00:13:27,516 --> 0:13:29,196
共享出去

433
00:13:30,106 --> 0:13:32,906
那么 那可能意味着创建新的协议

434
00:13:33,336 --> 0:13:35,616
但是首先 想一想

435
00:13:35,616 --> 0:13:37,516
通过现存的协议组成

436
00:13:37,516 --> 0:13:38,186
你需要的东西

437
00:13:38,296 --> 0:13:39,096
而且当你在设计

438
00:13:39,096 --> 0:13:40,446
协议时 请确保它们是

439
00:13:40,446 --> 0:13:41,426
可组合的

440
00:13:42,106 --> 0:13:44,876
作为创建协议的

441
00:13:44,876 --> 0:13:46,866
一种替代 你可以考虑

442
00:13:47,376 --> 0:13:49,506
创建一个泛型

443
00:13:50,456 --> 0:13:51,896
那么 让我们来看一些例子

444
00:13:51,896 --> 0:13:53,256
这些例子展示了刚刚提到的

445
00:13:53,256 --> 0:13:53,816
不同的东西

446
00:13:54,466 --> 0:13:56,316
那么 假设我想要创建

447
00:13:56,316 --> 0:13:57,236
一个几何 API

448
00:13:57,546 --> 0:13:59,206
作为其中的一部分 我想要

449
00:13:59,206 --> 0:14:02,036
创建几何向量上的操作

450
00:13:59,206 --> 0:14:02,036
创建几何向量上的操作

451
00:14:02,036 --> 0:14:05,186
我可能会从为一个

452
00:14:05,186 --> 0:14:06,706
GeometricVector 创建协议开始

453
00:14:07,086 --> 0:14:08,096
我可以赋予其

454
00:14:08,096 --> 0:14:09,156
我想要定义的操作

455
00:14:09,156 --> 0:14:11,816
比如坐标或者

456
00:14:11,816 --> 0:14:13,356
向量间的距离

457
00:14:15,726 --> 0:14:17,556
现在 我需要存储

458
00:14:17,556 --> 0:14:18,636
向量的维度

459
00:14:18,636 --> 0:14:21,176
那么我可能会使我的几何

460
00:14:21,176 --> 0:14:23,656
向量继承自 SIMD 协议

461
00:14:23,956 --> 0:14:25,226
如果你还不熟悉

462
00:14:25,226 --> 0:14:26,326
SIMD 类型 它们

463
00:14:26,326 --> 0:14:27,466
基本上有点像

464
00:14:27,466 --> 0:14:28,616
同质元组

465
00:14:28,616 --> 0:14:30,016
能够很有效地

466
00:14:30,016 --> 0:14:32,256
一次性在每个元素上

467
00:14:32,256 --> 0:14:32,816
执行计算

468
00:14:33,656 --> 0:14:34,836
而且它们还在

469
00:14:34,836 --> 0:14:36,246
Swift 5.1 中有很多了不起的新功能

470
00:14:36,676 --> 0:14:38,186
它们完美地适用于

471
00:14:38,276 --> 0:14:39,346
几何运算

472
00:14:39,776 --> 0:14:40,696
那么 我们要将我们的维度

473
00:14:40,696 --> 0:14:42,656
存储在基础 SIMD 类型中

474
00:14:42,656 --> 0:14:44,086
而且我们还想要对它进行限制

475
00:14:44,086 --> 0:14:46,636
使它只能在标量 SIMD 上工作

476
00:14:46,896 --> 0:14:47,526
这样一来我们就可以

477
00:14:47,526 --> 0:14:49,716
进行我们想要的计算

478
00:14:49,926 --> 0:14:50,896
现在 一旦我们定义了这个协议

479
00:14:50,896 --> 0:14:52,476
我们就可以继续

480
00:14:52,476 --> 0:14:53,396
进行默认的

481
00:14:53,396 --> 0:14:55,066
执行操作 进行所有

482
00:14:55,066 --> 0:14:56,816
我们想在向量上进行的操作

483
00:14:57,706 --> 0:14:59,796
然后我们希望给予

484
00:14:59,796 --> 0:15:02,716
这个协议一致性

485
00:14:59,796 --> 0:15:02,716
这个协议一致性

486
00:15:02,946 --> 0:15:04,046
针对每一个我们想要其获得

487
00:15:04,046 --> 0:15:05,616
这些新功能的类型

488
00:15:06,286 --> 0:15:08,586
这个三步

489
00:15:08,826 --> 0:15:10,666
定义协议的过程

490
00:15:10,666 --> 0:15:12,346
赋予了它一个默认的执行 

491
00:15:12,346 --> 0:15:13,696
然后为多种类型增添了一致性

492
00:15:13,696 --> 0:15:15,906
事实上这有点乏味

493
00:15:16,316 --> 0:15:17,436
我们有必要后退

494
00:15:17,436 --> 0:15:18,516
一步想一想

495
00:15:19,076 --> 0:15:21,296
协议真的是必要的吗

496
00:15:22,136 --> 0:15:23,756
事实上

497
00:15:23,756 --> 0:15:25,276
这些一致性实际上没有它们的

498
00:15:25,276 --> 0:15:27,476
自定义执行

499
00:15:27,476 --> 0:15:28,986
这实际上是一个警告的信号

500
00:15:29,086 --> 0:15:30,786
说明协议是没用的

501
00:15:30,966 --> 0:15:31,946
不是每个类型

502
00:15:31,976 --> 0:15:33,186
都有自定义

503
00:15:33,586 --> 0:15:34,916
而且实际上 这一操作

504
00:15:34,916 --> 0:15:36,456
在每个不同种类的

505
00:15:36,456 --> 0:15:37,136
SIMD 类型上都存在

506
00:15:38,156 --> 0:15:39,906
那么 协议真的有在

507
00:15:39,906 --> 0:15:40,696
带给我们什么东西吗

508
00:15:42,146 --> 0:15:43,506
如果我们退一步

509
00:15:43,506 --> 0:15:45,116
不在我们的新协议上

510
00:15:45,116 --> 0:15:46,116
编写默认执行

511
00:15:46,116 --> 0:15:48,856
相反 我们只是将其编写成

512
00:15:48,856 --> 0:15:51,296
直接在 SIMD 协议上的扩展

513
00:15:51,296 --> 0:15:52,136
有着相同的限制

514
00:15:52,136 --> 0:15:54,316
这样我们就完成了

515
00:15:54,366 --> 0:15:55,836
在这个单页的代码中

516
00:15:56,056 --> 0:15:57,746
我们已经自动将所有

517
00:15:57,746 --> 0:15:59,776
我们需要的功能赋给所有的

518
00:15:59,776 --> 0:16:01,616
包含浮点数的 SIMD 类型 

519
00:15:59,776 --> 0:16:01,616
包含浮点数的 SIMD 类型 

520
00:16:03,406 --> 0:16:04,846
要创建这个协议的

521
00:16:04,846 --> 0:16:06,236
继承式关系

522
00:16:06,236 --> 0:16:08,046
并且将不同类型

523
00:16:08,046 --> 0:16:09,796
划分进继承关系

524
00:16:09,866 --> 0:16:10,916
听上去很吸引人

525
00:16:11,416 --> 0:16:12,986
但是这有点太过于形式

526
00:16:12,986 --> 0:16:14,536
就是让人感觉很满意

527
00:16:14,536 --> 0:16:16,106
但并不总是必要

528
00:16:17,186 --> 0:16:19,226
而且这里总是会涉及到

529
00:16:19,226 --> 0:16:20,076
一个现实的问题

530
00:16:20,706 --> 0:16:22,646
这个没有协议的 更简单的

531
00:16:22,646 --> 0:16:24,246
基于扩展的方式

532
00:16:24,246 --> 0:16:26,566
让编译过程简单很多

533
00:16:27,186 --> 0:16:28,276
如果没有这一串

534
00:16:28,276 --> 0:16:29,486
不必要的协议见证表

535
00:16:29,486 --> 0:16:31,436
你的二进制文件会小很多

536
00:16:32,746 --> 0:16:34,056
事实上 我们发现在

537
00:16:34,146 --> 0:16:36,006
很大的项目上

538
00:16:36,006 --> 0:16:38,186
有着大量的复杂协议类型

539
00:16:38,186 --> 0:16:40,686
通过这个

540
00:16:40,686 --> 0:16:42,296
简化方式并减少

541
00:16:42,296 --> 0:16:45,306
协议的数量

542
00:16:45,306 --> 0:16:46,636
我们可以极大地缩短

543
00:16:46,636 --> 0:16:48,056
编译这些 App 的时间

544
00:16:50,186 --> 0:16:52,856
目前 这个方式

545
00:16:52,856 --> 0:16:54,576
对一小部分项目有用

546
00:16:54,946 --> 0:16:56,296
但是当你在设计

547
00:16:56,296 --> 0:16:57,596
一个更完全的 API 时 就涉及

548
00:16:57,596 --> 0:16:58,416
一个可扩展问题

549
00:16:58,416 --> 0:17:01,516
早些时候 我们想着

550
00:16:58,416 --> 0:17:01,516
早些时候 我们想着

551
00:17:01,516 --> 0:17:03,676
创建一个协议

552
00:17:03,676 --> 0:17:05,636
我们说了我们要定义几何向量

553
00:17:05,636 --> 0:17:07,836
并用它继承 SIMD

554
00:17:08,136 --> 0:17:09,636
用于我们的存储

555
00:17:10,455 --> 0:17:11,846
但是这真的是正确的吗

556
00:17:11,976 --> 0:17:14,336
这是一种承继关系吗

557
00:17:14,336 --> 0:17:16,046
我们真的可以说几何

558
00:17:16,046 --> 0:17:18,415
向量是 SIMD 类型吗

559
00:17:18,415 --> 0:17:21,096
我的意思是说 一些操作是合理的

560
00:17:21,096 --> 0:17:23,326
你可以添加或者移除向量

561
00:17:23,965 --> 0:17:24,776
但是有一些不行

562
00:17:24,776 --> 0:17:26,546
你不能将两个

563
00:17:26,546 --> 0:17:27,296
向量相互乘起来

564
00:17:27,296 --> 0:17:29,826
或者将数字 1 添加至向量

565
00:17:29,826 --> 0:17:31,886
但是这些操作在

566
00:17:31,886 --> 0:17:33,736
所有的 SIMD 类型都是可行的

567
00:17:33,946 --> 0:17:35,266
在其他的条件下要有

568
00:17:35,266 --> 0:17:37,276
其他合理的定义

569
00:17:37,276 --> 0:17:39,206
只是不是在几何的情况下

570
00:17:40,326 --> 0:17:41,986
如果我们正在设计一个

571
00:17:41,986 --> 0:17:43,856
便于使用的 API

572
00:17:44,126 --> 0:17:45,316
那么我们也许应该考虑另一个选项

573
00:17:45,316 --> 0:17:48,906
这个选项不是承继关系

574
00:17:48,906 --> 0:17:50,366
而是执行一种组合关系

575
00:17:50,856 --> 0:17:53,236
就是将一个 SIMD 值包含在

576
00:17:53,676 --> 0:17:55,256
一个泛型结构里

577
00:17:55,866 --> 0:17:57,666
这样我们就可以创建一个

578
00:17:57,666 --> 0:17:59,506
几何向量的结构

579
00:17:59,786 --> 0:18:02,096
而且我们将其设定为

580
00:17:59,786 --> 0:18:02,096
而且我们将其设定为

581
00:18:02,096 --> 0:18:03,936
SIMD 存储类型的泛型

582
00:18:03,936 --> 0:18:05,816
这样它就可以处理浮点类型

583
00:18:06,086 --> 0:18:07,736
以及任何不同数量的维度

584
00:18:08,366 --> 0:18:11,166
然后 一旦我们完成了这个操作

585
00:18:11,166 --> 0:18:13,086
对于在我们的

586
00:18:13,086 --> 0:18:15,116
新类型上显示什么 API 就有了

587
00:18:15,116 --> 0:18:16,586
更精细的控制

588
00:18:17,566 --> 0:18:19,956
所以我们就可以定义两个

589
00:18:19,956 --> 0:18:20,926
向量的相加

590
00:18:21,296 --> 0:18:23,096
而不是某一向量

591
00:18:23,096 --> 0:18:24,126
单个数字的相加

592
00:18:24,416 --> 0:18:26,556
又或者 我们可以依照标量

593
00:18:27,056 --> 0:18:29,156
定义向量的相乘

594
00:18:29,156 --> 0:18:31,386
而不是两个向量

595
00:18:31,386 --> 0:18:33,196
彼此相乘

596
00:18:35,286 --> 0:18:37,546
而且我们仍然可以使用泛型扩展

597
00:18:37,546 --> 0:18:39,376
这样一来 我们执行的

598
00:18:39,426 --> 0:18:41,226
坐标和距离

599
00:18:41,226 --> 0:18:42,676
就和它们之前的是一样的

600
00:18:43,306 --> 0:18:45,876
现在 我们已经在

601
00:18:45,876 --> 0:18:47,796
标准库使用了这一技术

602
00:18:47,796 --> 0:18:49,906
例如 我们就有了一个

603
00:18:49,906 --> 0:18:50,966
SIMD 协议

604
00:18:51,166 --> 0:18:53,406
而且然后我们有了

605
00:18:53,406 --> 0:18:54,766
泛型结构 其代表了

606
00:18:54,766 --> 0:18:56,996
不同尺寸的 SIMD 类型

607
00:18:57,466 --> 0:19:00,676
请注意 这里并没有 SIMD2 或者

608
00:18:57,466 --> 0:19:00,676
请注意 这里并没有 SIMD2 或者

609
00:19:00,716 --> 0:19:02,016
SIMD3 协议

610
00:19:02,016 --> 0:19:03,616
它们不必添加很多值

611
00:19:04,626 --> 0:19:06,166
用户仍可以通过

612
00:19:06,166 --> 0:19:08,216
扩展来为特定尺寸的 SIMD

613
00:19:08,756 --> 0:19:11,136
编写泛型代码 比如

614
00:19:11,136 --> 0:19:12,846
对于一个跨产品操作的 SIMD3 类型

615
00:19:12,846 --> 0:19:14,146
你仅仅想要

616
00:19:14,146 --> 0:19:17,176
定义一个三维的 SIMD 类型

617
00:19:17,856 --> 0:19:19,486
希望这些能让你知道

618
00:19:19,486 --> 0:19:21,376
泛型是如何

619
00:19:21,376 --> 0:19:22,966
像协议一样

620
00:19:22,966 --> 0:19:25,096
强大又具扩展性

621
00:19:25,906 --> 0:19:27,236
现在 我们在这里还是在

622
00:19:27,236 --> 0:19:28,006
借助协议的力量

623
00:19:28,976 --> 0:19:30,106
我们在泛型 SIMD 上

624
00:19:30,106 --> 0:19:31,896
有限制标量类型的浮点

625
00:19:31,896 --> 0:19:33,666
它为我们

626
00:19:33,666 --> 0:19:34,776
提供了基本代码块

627
00:19:34,776 --> 0:19:38,726
可以用于写代码

628
00:19:39,276 --> 0:19:40,796
现在 在我们的

629
00:19:40,796 --> 0:19:42,656
GeometricVector 类型上 我们可以

630
00:19:42,656 --> 0:19:43,856
编写同样的跨产品操作

631
00:19:44,426 --> 0:19:45,706
但是当我们这样做

632
00:19:45,706 --> 0:19:47,276
执行操作看上去

633
00:19:47,276 --> 0:19:48,116
会有点丑陋

634
00:19:48,606 --> 0:19:49,486
因为我们必须保持

635
00:19:49,536 --> 0:19:51,006
间接通过值存储

636
00:19:51,006 --> 0:19:52,356
来获取

637
00:19:52,356 --> 0:19:54,156
X Y 和 Z 坐标

638
00:19:54,496 --> 0:19:56,046
所以 如果我们可以

639
00:19:56,046 --> 0:19:56,806
解决这个问题 会很棒

640
00:19:57,246 --> 0:19:58,616
现在 很显然我们可以

641
00:19:58,616 --> 0:19:59,946
的向量类型上为

642
00:19:59,946 --> 0:20:01,516
X Y 和 Z 编写计算出的属性

643
00:19:59,946 --> 0:20:01,516
X Y 和 Z 编写计算出的属性

644
00:20:01,576 --> 0:20:02,896
但是实际上在

645
00:20:02,896 --> 0:20:05,846
Swift 5.1 有一个新功能叫做

646
00:20:05,846 --> 0:20:07,876
关键路径成员查找 

647
00:20:07,876 --> 0:20:09,696
你可以编写单个下标操作

648
00:20:09,696 --> 0:20:11,446
同时显示

649
00:20:11,636 --> 0:20:13,766
一个类型中的多个

650
00:20:13,766 --> 0:20:15,286
不同的计算属性

651
00:20:15,286 --> 0:20:18,096
这样一来 我们就可以根据选择

652
00:20:18,096 --> 0:20:20,426
来使用它 如果可行

653
00:20:20,426 --> 0:20:22,256
就一次性将

654
00:20:22,256 --> 0:20:25,266
SIMD 上的所有属性显示在

655
00:20:25,266 --> 0:20:25,836
我们的几何向量上

656
00:20:26,396 --> 0:20:27,536
让我们来看看我们是如何做的

657
00:20:28,506 --> 0:20:31,296
那么首先 我们将我们的 GeometricVector

658
00:20:31,296 --> 0:20:33,886
标记为 dynamicMemberLookup 属性

659
00:20:34,686 --> 0:20:37,936
紧接着 编译器

660
00:20:37,936 --> 0:20:39,146
会提醒我们写一个特殊的

661
00:20:39,236 --> 0:20:40,546
动态成员下标

662
00:20:41,136 --> 0:20:44,966
这个下标采取关键路径

663
00:20:44,966 --> 0:20:46,206
执行这一下标

664
00:20:46,206 --> 0:20:47,746
的影响是任何

665
00:20:47,806 --> 0:20:49,606
可通过该关键路径

666
00:20:49,606 --> 0:20:52,096
自动访问的属性

667
00:20:52,096 --> 0:20:53,826
都会在我们的 GeometricVector 类型上

668
00:20:54,256 --> 0:20:56,436
显示为计算属性

669
00:20:56,946 --> 0:20:58,336
在这个例子中 我们想要

670
00:20:58,386 --> 0:21:00,556
关键路径是进入 SIMD 存储类型

671
00:20:58,386 --> 0:21:00,556
关键路径是进入 SIMD 存储类型

672
00:21:00,556 --> 0:21:02,496
并返回一个标量

673
00:21:02,956 --> 0:21:04,336
然后我们使用那个关键路径

674
00:21:04,336 --> 0:21:05,766
继续并获取

675
00:21:05,766 --> 0:21:08,516
来自值存储的值并返回

676
00:21:08,516 --> 0:21:11,076
一旦我们完成了这些

677
00:21:11,156 --> 0:21:12,946
我们的几何向量

678
00:21:12,946 --> 0:21:13,826
就会自动获得所有

679
00:21:13,826 --> 0:21:15,216
SIMD 拥有的属性

680
00:21:16,036 --> 0:21:17,806
举个例子

681
00:21:17,806 --> 0:21:18,816
可以获取 X Y 和 Z 坐标

682
00:21:18,996 --> 0:21:20,036
而且它们甚至出现在

683
00:21:20,036 --> 0:21:21,646
Xcode 的自动补全里

684
00:21:22,646 --> 0:21:24,386
如果你想在 Swift 5 里尝试这一功能

685
00:21:24,386 --> 0:21:25,446
当它是基于字符串时

686
00:21:25,446 --> 0:21:27,066
这里的区别在于

687
00:21:27,066 --> 0:21:28,526
这个版本是

688
00:21:28,526 --> 0:21:29,876
完全类型安全的

689
00:21:30,556 --> 0:21:31,586
而且更多的东西是在

690
00:21:31,586 --> 0:21:34,806
编译时完成

691
00:21:35,046 --> 0:21:36,016
既然我们可以访问

692
00:21:36,016 --> 0:21:37,306
X Y 和 Z 属性 那么

693
00:21:37,306 --> 0:21:38,916
我们就可以很大程度上

694
00:21:39,346 --> 0:21:41,936
简化我们的跨产品操作了

695
00:21:42,436 --> 0:21:44,466
就是这样 看上去好多了

696
00:21:44,756 --> 0:21:45,996
目前 这个动态成员

697
00:21:46,296 --> 0:21:48,266
的功能不仅对于

698
00:21:48,266 --> 0:21:49,606
发送属性有用

699
00:21:49,606 --> 0:21:52,436
你还可以将复杂的逻辑放进下标

700
00:21:52,436 --> 0:21:54,376
那么我们再来看一个例子

701
00:21:54,986 --> 0:21:57,536
让我们回到早前的例子

702
00:21:57,536 --> 0:21:59,576
在这个例子中 我们

703
00:21:59,576 --> 0:22:01,296
通过写时复制语义

704
00:21:59,576 --> 0:22:01,296
通过写时复制语义

705
00:22:01,636 --> 0:22:03,616
显示了 texture 的特定属性

706
00:22:04,146 --> 0:22:05,746
这对于一个属性是有效的

707
00:22:05,746 --> 0:22:07,106
但是会很不幸

708
00:22:07,106 --> 0:22:08,646
如果我们需要每次都编写

709
00:22:08,646 --> 0:22:09,566
相同的代码

710
00:22:10,606 --> 0:22:11,846
如果它想要将

711
00:22:11,846 --> 0:22:13,726
texture 上的所有属性

712
00:22:13,926 --> 0:22:15,476
使用写时复制语义属性

713
00:22:15,786 --> 0:22:16,996
作为 material 类型的属性怎么办

714
00:22:16,996 --> 0:22:18,296
那么 我们可以通过动态

715
00:22:18,296 --> 0:22:18,896
成员查找来实现

716
00:22:19,766 --> 0:22:21,696
那么首先 我们要将

717
00:22:21,696 --> 0:22:23,456
dynamicMemberLookup 添加至我们的类型

718
00:22:24,986 --> 0:22:26,926
然后我们执行

719
00:22:26,926 --> 0:22:27,946
下标操作

720
00:22:27,946 --> 0:22:29,496
而且我们要使它采取

721
00:22:29,666 --> 0:22:30,926
一个可写的关键路径

722
00:22:30,926 --> 0:22:32,846
因为我们希望可以同时获取

723
00:22:32,846 --> 0:22:33,856
并设定属性

724
00:22:34,816 --> 0:22:37,346
再将泛型作为返回值

725
00:22:37,616 --> 0:22:38,636
因为我们想要在 texture 中

726
00:22:38,636 --> 0:22:40,806
获取不同的类型

727
00:22:41,376 --> 0:22:44,526
然后我们执行 get 和 set 方法

728
00:22:44,666 --> 0:22:45,896
在 get 方法中我们只需要

729
00:22:45,896 --> 0:22:46,956
进行之前的操作

730
00:22:47,576 --> 0:22:49,506
但是在 set 方法中 在我们做出

731
00:22:49,506 --> 0:22:51,696
更改前 我们要添加唯一

732
00:22:51,696 --> 0:22:54,256
引用检查和 texture 的完整拷贝

733
00:22:55,036 --> 0:22:57,056
通过这样的做法

734
00:22:57,056 --> 0:22:58,606
在这个简洁的下标中

735
00:22:58,606 --> 0:23:00,416
我们显示了

736
00:22:58,606 --> 0:23:00,416
我们显示了

737
00:23:00,416 --> 0:23:02,726
texture 上的每一个属性

738
00:23:02,726 --> 0:23:04,606
同时在我们的 texture 类型上有

739
00:23:04,606 --> 0:23:05,416
写时复制语义

740
00:23:06,036 --> 0:23:07,526
这是一个非常有用的方式

741
00:23:07,526 --> 0:23:09,996
以此来从你的类型中获取值语义

742
00:23:11,916 --> 0:23:14,286
这个新的功能有很多

743
00:23:14,286 --> 0:23:15,126
不同的应用

744
00:23:15,126 --> 0:23:16,616
事实上它和 5.1 中的

745
00:23:16,616 --> 0:23:18,856
一个新功能很好地组合在了一起

746
00:23:19,126 --> 0:23:20,436
那就是属性包装器

747
00:23:20,436 --> 0:23:21,826
接下来 Doug 会聊一聊这个话题

748
00:23:22,366 --> 0:23:30,356
Doug [掌声]

749
00:23:30,856 --> 0:23:31,446
&gt;&gt; 谢谢你 Ben

750
00:23:32,926 --> 0:23:36,416
那么 Swift 是为了清晰

751
00:23:36,416 --> 0:23:38,566
简洁的代码设计的

752
00:23:38,566 --> 0:23:40,846
也是为了构建表现力优异的 API 对吗

753
00:23:40,886 --> 0:23:42,066
也是为了代码的重新利用

754
00:23:42,066 --> 0:23:42,826
我们已经谈过了

755
00:23:42,896 --> 0:23:44,956
泛型和协议

756
00:23:44,956 --> 0:23:46,106
有了它们你才可以

757
00:23:46,406 --> 0:23:48,766
创建泛型代码

758
00:23:48,766 --> 0:23:50,636
所以为了你的功能和类型

759
00:23:50,636 --> 0:23:51,476
那是可以被再利用的

760
00:23:51,866 --> 0:23:54,026
所以属性包装器

761
00:23:54,026 --> 0:23:55,766
是 Swift 5.1 的新功能

762
00:23:56,486 --> 0:23:58,066
属性包装器背后的想法

763
00:23:58,066 --> 0:23:59,796
是有效地从你编写的

764
00:23:59,796 --> 0:24:01,566
计算属性中获取

765
00:23:59,796 --> 0:24:01,566
计算属性中获取

766
00:24:01,566 --> 0:24:02,456
代码的重新利用

767
00:24:03,456 --> 0:24:06,376
像这样 这儿有一堆代码

768
00:24:07,486 --> 0:24:10,266
那么这里发生了什么呢

769
00:24:10,266 --> 0:24:12,936
所以 我们尝试去做的就是

770
00:24:13,356 --> 0:24:15,526
显示一个 public 属性 对吗

771
00:24:16,276 --> 0:24:16,946
然后我们得到了这个

772
00:24:16,946 --> 0:24:17,976
我们只是想要一个 image 属性

773
00:24:17,976 --> 0:24:18,526
并且是 public

774
00:24:18,916 --> 0:24:20,256
但是我们并不希望

775
00:24:20,606 --> 0:24:22,236
所有的用户 我们的客户

776
00:24:22,236 --> 0:24:23,966
可以那里编写任意值

777
00:24:24,226 --> 0:24:25,676
我们想要描述一些策略

778
00:24:25,746 --> 0:24:27,016
那么这就变成计算过的属性

779
00:24:27,326 --> 0:24:29,616
我们实际的存储回到

780
00:24:29,616 --> 0:24:31,116
这里 在内部的

781
00:24:31,116 --> 0:24:32,056
imageStorage 属性中

782
00:24:32,646 --> 0:24:34,106
所以通向那存储的访问权限

783
00:24:34,366 --> 0:24:36,926
都是通过 get 和 set 方法建立的

784
00:24:37,636 --> 0:24:39,566
这有很多代码

785
00:24:39,706 --> 0:24:40,926
你们可以先看一看

786
00:24:41,396 --> 0:24:42,256
你们中的一些人也许

787
00:24:42,256 --> 0:24:43,556
认出了这是什么

788
00:24:44,446 --> 0:24:45,966
它真的是一种很冗长的方式

789
00:24:45,966 --> 0:24:49,176
来描述这只是一个惰性变量 image

790
00:24:50,616 --> 0:24:52,446
现在这样就好多了

791
00:24:53,696 --> 0:24:55,216
这是一行代码而不是

792
00:24:55,276 --> 0:24:57,316
有着杂乱访问策略逻辑的

793
00:24:57,456 --> 0:24:59,436
两个属性

794
00:24:59,936 --> 0:25:02,256
我们有这个很好的修饰语

795
00:24:59,936 --> 0:25:02,256
我们有这个很好的修饰语

796
00:25:02,376 --> 0:25:04,626
lazy 来告诉你

797
00:25:04,626 --> 0:25:06,146
这里真实的语义是什么

798
00:25:07,266 --> 0:25:07,996
这很重要

799
00:25:07,996 --> 0:25:08,936
能更好的写文档

800
00:25:08,936 --> 0:25:09,866
也更便于阅读

801
00:25:10,776 --> 0:25:11,826
这就是为什么 lazy

802
00:25:11,826 --> 0:25:13,376
自 Swift 1 就在语言中存在了

803
00:25:14,136 --> 0:25:18,856
现在问题是

804
00:25:19,256 --> 0:25:21,226
这是一个更笼统问题的例子

805
00:25:21,346 --> 0:25:23,306
那么 让我们来看看这里的

806
00:25:23,306 --> 0:25:24,996
另一个例子 也就是代码结构

807
00:25:25,716 --> 0:25:26,856
基本上是相似的

808
00:25:28,006 --> 0:25:29,746
但是策略以及实际

809
00:25:29,746 --> 0:25:30,986
在 get 和 set 中

810
00:25:30,986 --> 0:25:32,556
的执行不一样

811
00:25:32,856 --> 0:25:33,956
那么如果你在看

812
00:25:33,956 --> 0:25:35,646
这里的逻辑

813
00:25:35,646 --> 0:25:37,836
你看到这是一个延迟初始化模式

814
00:25:37,836 --> 0:25:39,476
你必须设置过这个

815
00:25:40,236 --> 0:25:41,956
或者在你可以读取之前

816
00:25:41,956 --> 0:25:42,436
曾初始化过

817
00:25:42,436 --> 0:25:43,456
否则你就会失败

818
00:25:43,456 --> 0:25:45,006
这是非常常见的事情

819
00:25:46,206 --> 0:25:47,196
这类的代码出现在

820
00:25:47,196 --> 0:25:47,916
很多地方

821
00:25:48,456 --> 0:25:50,816
我们不会通过

822
00:25:50,816 --> 0:25:52,676
为 Swift 提供另一种语言的扩展

823
00:25:53,226 --> 0:25:55,296
来解决这个问题

824
00:25:56,266 --> 0:25:57,326
但是事实上 我们想要

825
00:25:57,326 --> 0:25:58,476
更宏观地解决这个

826
00:25:58,476 --> 0:25:59,606
因为我们希望人们可以构建

827
00:25:59,606 --> 0:26:00,906
这些东西的库

828
00:25:59,606 --> 0:26:00,906
这些东西的库

829
00:26:00,906 --> 0:26:02,026
在这个库中

830
00:26:02,026 --> 0:26:03,476
他们能够分离出

831
00:26:03,476 --> 0:26:05,356
访问单个值的策略

832
00:26:05,986 --> 0:26:07,716
所以这就是

833
00:26:07,716 --> 0:26:09,076
属性包装器背后的想法

834
00:26:09,076 --> 0:26:10,936
就是去消除这种样板

835
00:26:10,936 --> 0:26:12,356
并获得表现更加优异的 API

836
00:26:13,556 --> 0:26:15,006
那么 它们看上去有点像这样

837
00:26:15,716 --> 0:26:17,706
这里的想法就是我们希望

838
00:26:17,706 --> 0:26:19,296
当你在声明一个属性时能

839
00:26:19,296 --> 0:26:20,206
使用标记

840
00:26:20,206 --> 0:26:22,236
所以在这里它就是 public 文本变量

841
00:26:22,236 --> 0:26:26,316
并运用延迟

842
00:26:26,316 --> 0:26:28,136
初始化属性包装器来

843
00:26:28,136 --> 0:26:29,876
给予它特别的语义

844
00:26:29,876 --> 0:26:30,936
来给予它

845
00:26:30,936 --> 0:26:32,176
特别的策略

846
00:26:33,696 --> 0:26:35,266
现在这个 @LateInitialized

847
00:26:35,266 --> 0:26:36,686
这是一个自定义属性

848
00:26:36,686 --> 0:26:37,906
这是一个新的标记

849
00:26:37,906 --> 0:26:38,986
我们在 Swift 中会稍微用到

850
00:26:39,406 --> 0:26:41,496
最根本的 它就是在说

851
00:26:41,686 --> 0:26:42,836
应用这个延迟初始化模式

852
00:26:42,836 --> 0:26:43,686
无论它是什么

853
00:26:43,686 --> 0:26:44,876
我们之后会回到这个来

854
00:26:45,516 --> 0:26:47,316
但是仅仅从代码角度看

855
00:26:47,316 --> 0:26:49,726
这整个都像是惰性的

856
00:26:49,726 --> 0:26:51,046
它为我们带来的好处和

857
00:26:51,106 --> 0:26:52,166
惰性是完全一样的

858
00:26:52,736 --> 0:26:54,506
我们已经完全摆脱了样板文件

859
00:26:55,516 --> 0:26:57,796
但是同时 我们也在

860
00:26:57,886 --> 0:26:58,866
声明的位置就说明了

861
00:26:58,866 --> 0:27:00,426
实际上的语义

862
00:26:58,866 --> 0:27:00,426
实际上的语义

863
00:27:00,426 --> 0:27:01,996
比起那些混乱的代码

864
00:27:01,996 --> 0:27:04,406
这更容易阅读和理解

865
00:27:05,386 --> 0:27:07,626
好的 关于这一行小小的代码

866
00:27:07,626 --> 0:27:08,466
已经讲得够多了

867
00:27:08,636 --> 0:27:09,916
让我们来看看那延迟初始化

868
00:27:09,916 --> 0:27:10,866
实际上看起来是怎么样的

869
00:27:11,776 --> 0:27:13,206
你在这里将会看到

870
00:27:13,206 --> 0:27:13,816
它是一些代码

871
00:27:13,816 --> 0:27:15,976
但是就跟我们刚刚看到的代码一样

872
00:27:15,976 --> 0:27:17,936
延迟初始化背后的

873
00:27:18,276 --> 0:27:20,076
策略模版是一样的

874
00:27:21,136 --> 0:27:22,776
在这里你有 get 和 set

875
00:27:22,956 --> 0:27:24,846
set 是更新存储

876
00:27:24,876 --> 0:27:25,876
get 是检查以确保

877
00:27:25,876 --> 0:27:27,376
至少将其设置过一次

878
00:27:27,376 --> 0:27:28,276
并且当我们有设置时

879
00:27:28,276 --> 0:27:30,416
返回值 这非常直接

880
00:27:31,176 --> 0:27:33,476
现在使这个简单的

881
00:27:33,476 --> 0:27:35,716
泛型变得有意思的点在于

882
00:27:35,756 --> 0:27:37,216
它是一个属性包装器

883
00:27:37,686 --> 0:27:39,196
它由这里

884
00:27:39,306 --> 0:27:40,786
顶部的 propertyWrapper 属性

885
00:27:40,786 --> 0:27:41,256
指出是什么样

886
00:27:42,376 --> 0:27:43,606
那么 它所做的就是

887
00:27:43,606 --> 0:27:45,396
允许自定义属性句法

888
00:27:45,396 --> 0:27:47,086
也就是说我们能将这个东西

889
00:27:47,086 --> 0:27:49,086
运用到其他一些属性上

890
00:27:49,936 --> 0:27:50,986
现在 有了 propertyWrapper 属性

891
00:27:50,986 --> 0:27:52,936
就出现了一些要求

892
00:27:53,096 --> 0:27:55,036
主要的一个问题要有

893
00:27:55,286 --> 0:27:56,406
value 属性

894
00:27:57,056 --> 0:27:59,336
这是所有策略执行的地方

895
00:27:59,386 --> 0:28:01,146
所以所有访问

896
00:27:59,386 --> 0:28:01,146
所以所有访问

897
00:28:01,146 --> 0:28:02,686
延迟初始化属性的权限都经过这里

898
00:28:03,876 --> 0:28:05,386
而且我们看到实际的

899
00:28:05,386 --> 0:28:06,836
标记是找到一些

900
00:28:06,836 --> 0:28:08,356
提取的概念关于什么是

901
00:28:08,356 --> 0:28:09,416
延迟初始化

902
00:28:10,156 --> 0:28:11,166
在这个特殊的例子中

903
00:28:11,166 --> 0:28:12,756
另一个有趣的事情是

904
00:28:12,756 --> 0:28:14,706
我们已经声明了一个

905
00:28:14,706 --> 0:28:15,956
没有参数的初始化

906
00:28:17,716 --> 0:28:19,016
现在 在属性包装器里

907
00:28:19,016 --> 0:28:19,756
这是可选的

908
00:28:19,906 --> 0:28:21,506
但是当你使用时

909
00:28:21,506 --> 0:28:22,756
它想说明的就是

910
00:28:22,756 --> 0:28:24,516
应用该包装器属性

911
00:28:25,036 --> 0:28:26,806
免费获得了

912
00:28:26,806 --> 0:28:28,056
隐式初始化

913
00:28:28,056 --> 0:28:29,136
在这个特殊的初始化中

914
00:28:32,076 --> 0:28:32,166
&gt;&gt; 好的

915
00:28:33,986 --> 0:28:35,116
让我们来实际运用这个东西

916
00:28:35,426 --> 0:28:37,006
所以 当你通过将其

917
00:28:37,006 --> 0:28:38,176
应用至一个特定的属性

918
00:28:38,176 --> 0:28:39,886
来使用属性包装器时

919
00:28:39,886 --> 0:28:41,546
编译器要将

920
00:28:41,546 --> 0:28:44,856
那个代码翻译成两个分开的属性

921
00:28:44,856 --> 0:28:46,876
基本上 我们正在

922
00:28:46,876 --> 0:28:48,076
扩展成为我们一开始

923
00:28:48,076 --> 0:28:48,716
看到的模式

924
00:28:49,426 --> 0:28:51,416
所以你有一个带 $ 前缀的

925
00:28:51,416 --> 0:28:53,346
备份存储属性

926
00:28:53,346 --> 0:28:55,826
所以 $text 的类型

927
00:28:56,116 --> 0:28:58,396
是属性包装器类型的一个实例

928
00:28:58,456 --> 0:28:59,276
所以我们现在有一个

929
00:28:59,276 --> 0:29:00,806
LateInitialized 字符串

930
00:28:59,276 --> 0:29:00,806
LateInitialized 字符串

931
00:29:01,826 --> 0:29:03,246
它提供存储

932
00:29:04,616 --> 0:29:05,976
通过调用无参数初始化

933
00:29:06,256 --> 0:29:09,646
它将由编译器进行隐式初始化

934
00:29:09,646 --> 0:29:11,256
就是我们刚刚提到的

935
00:29:11,586 --> 0:29:12,836
因为它在那儿 现在我们

936
00:29:12,836 --> 0:29:13,996
获得了隐式初始化

937
00:29:14,546 --> 0:29:16,586
而延迟初始化随时可以进行

938
00:29:16,866 --> 0:29:18,706
你也许能想起来

939
00:29:18,706 --> 0:29:19,666
存储被设成了 nil

940
00:29:21,136 --> 0:29:21,966
编译器在这里

941
00:29:21,966 --> 0:29:23,596
还做了一件事 就是

942
00:29:23,596 --> 0:29:26,526
将文本翻译成计算属性

943
00:29:27,286 --> 0:29:28,706
所以 get 要

944
00:29:28,706 --> 0:29:31,066
创建一个对 $text 的访问

945
00:29:31,506 --> 0:29:33,776
然后通过

946
00:29:33,776 --> 0:29:36,056
调用 get 值来获取

947
00:29:36,056 --> 0:29:36,926
$text 的值

948
00:29:36,976 --> 0:29:39,346
在 set 里我们也进行同样的操作

949
00:29:39,346 --> 0:29:42,686
在 $text.value 中写下新的值

950
00:29:43,026 --> 0:29:44,756
所以就是这个

951
00:29:44,756 --> 0:29:46,356
属性包装器能有

952
00:29:46,356 --> 0:29:47,496
其自己的存储

953
00:29:47,496 --> 0:29:48,296
无论它想要怎么存储

954
00:29:48,296 --> 0:29:49,416
无论是本地或者其他地方

955
00:29:49,986 --> 0:29:52,796
然后无论执行什么

956
00:29:52,796 --> 0:29:54,886
你指定的策略

957
00:29:54,886 --> 0:29:57,386
通过 get 和 set 访问数据

958
00:29:58,756 --> 0:30:00,656
所以总的来说 这是很好的

959
00:29:58,756 --> 0:30:00,656
所以总的来说 这是很好的

960
00:30:00,656 --> 0:30:02,576
我们已经将策略和它的应用分离

961
00:30:02,736 --> 0:30:04,236
将其放在

962
00:30:04,236 --> 0:30:07,736
延迟初始化包装器中

963
00:30:07,966 --> 0:30:10,156
无论我们想要什么类型

964
00:30:10,156 --> 0:30:11,466
我们都可以对任意数量的

965
00:30:11,466 --> 0:30:14,006
不同属性进行操作

966
00:30:14,006 --> 0:30:15,506
在简单很多同时有更少的样板文件

967
00:30:17,196 --> 0:30:19,316
那么 让我们来看看另一个例子

968
00:30:20,236 --> 0:30:21,546
Ben 有提到过关于

969
00:30:21,546 --> 0:30:23,276
值和引用语义的东西

970
00:30:23,866 --> 0:30:24,606
现在 当你在处理

971
00:30:24,606 --> 0:30:26,196
引用语义和可变状态时

972
00:30:26,196 --> 0:30:27,516
你会发现在

973
00:30:27,516 --> 0:30:28,866
在某些时候进行着

974
00:30:28,866 --> 0:30:29,436
防御性拷贝

975
00:30:30,046 --> 0:30:31,486
当然 我们可以手动在任何

976
00:30:31,486 --> 0:30:32,866
需要的地方做这件事

977
00:30:32,866 --> 0:30:34,086
但是为什么不为此

978
00:30:34,086 --> 0:30:35,036
构建一个属性包装器呢

979
00:30:35,506 --> 0:30:38,506
所以 这就是属性包装器

980
00:30:38,506 --> 0:30:40,146
它的样子基本上

981
00:30:40,146 --> 0:30:41,526
和我们之前看到的一样

982
00:30:41,526 --> 0:30:42,546
它有存储能力

983
00:30:42,546 --> 0:30:43,786
它有一个值属性

984
00:30:44,306 --> 0:30:45,636
这个属性包装器的

985
00:30:45,676 --> 0:30:48,276
所有策略都在 set里

986
00:30:48,536 --> 0:30:49,766
当我们有了一个新的值

987
00:30:49,766 --> 0:30:50,836
继续并复制这个值

988
00:30:51,216 --> 0:30:52,876
而且由于我们正在使用 NSCopying

989
00:30:52,876 --> 0:30:54,906
来进行复制

990
00:30:54,906 --> 0:30:56,436
它就会继续并调用复制方法

991
00:30:56,436 --> 0:30:57,166
然后进行投射

992
00:30:58,516 --> 0:30:59,736
关于防御性拷贝的

993
00:30:59,736 --> 0:31:02,246
另一件有趣的事情在于

994
00:30:59,736 --> 0:31:02,246
另一件有趣的事情在于

995
00:31:02,246 --> 0:31:04,196
它提供一个初始值的初始化

996
00:31:04,816 --> 0:31:06,746
这就像那个没有参数的初始化

997
00:31:06,746 --> 0:31:08,086
在你的属性包装器里

998
00:31:08,086 --> 0:31:08,996
它并不是必须的

999
00:31:09,436 --> 0:31:11,546
但是如果它在那里

1000
00:31:11,546 --> 0:31:13,976
就会让你在属性包装其中的

1001
00:31:13,976 --> 0:31:15,076
所有属性

1002
00:31:15,076 --> 0:31:15,926
都被赋为默认值

1003
00:31:16,336 --> 0:31:18,776
那个默认值会被填入这个初始化

1004
00:31:19,106 --> 0:31:20,406
我们可以在

1005
00:31:20,406 --> 0:31:21,376
初始化上实行任何我们

1006
00:31:21,376 --> 0:31:22,206
希望的策略

1007
00:31:22,826 --> 0:31:24,116
在我们的这个例子中

1008
00:31:24,116 --> 0:31:25,076
就跟 set 策略一样

1009
00:31:25,356 --> 0:31:27,766
我们想要继续并创建一个

1010
00:31:27,766 --> 0:31:30,926
防御性拷贝

1011
00:31:33,296 --> 0:31:34,376
之后为它分配一个结果

1012
00:31:35,206 --> 0:31:35,946
让我们来看一下

1013
00:31:36,436 --> 0:31:38,636
那么 如果我们要定义一些

1014
00:31:38,636 --> 0:31:40,116
防御性拷贝 UIBezierPath

1015
00:31:40,956 --> 0:31:41,716
会发生什么呢

1016
00:31:41,716 --> 0:31:43,036
好吧 编译器会

1017
00:31:43,306 --> 0:31:44,956
将其编译成两个

1018
00:31:44,956 --> 0:31:45,896
不同的定义

1019
00:31:46,256 --> 0:31:46,976
首先 在这里我们将会

1020
00:31:46,976 --> 0:31:48,756
有一个初始化

1021
00:31:49,386 --> 0:31:51,256
所以这里 无论何时我们创建这个路径

1022
00:31:51,256 --> 0:31:53,006
它有一个默认的

1023
00:31:53,006 --> 0:31:54,366
UIBezierPath

1024
00:31:54,886 --> 0:31:56,536
只是创建了空白的实例

1025
00:31:56,956 --> 0:31:58,366
然后当我们继续并

1026
00:31:58,366 --> 0:32:00,056
将其变成多个属性时

1027
00:31:58,366 --> 0:32:00,056
将其变成多个属性时

1028
00:32:00,056 --> 0:32:01,826
就有了备份

1029
00:32:01,826 --> 0:32:03,186
存储属性 $path

1030
00:32:03,856 --> 0:32:05,326
请注意我们是如何将它初始化的

1031
00:32:05,406 --> 0:32:06,936
我们将用户提供的

1032
00:32:06,936 --> 0:32:09,026
初始值传输至

1033
00:32:09,026 --> 0:32:11,576
初始值初始化 这样它

1034
00:32:11,576 --> 0:32:12,756
就可以被防御性复制了

1035
00:32:13,566 --> 0:32:14,556
get 和 set 方法

1036
00:32:14,556 --> 0:32:15,376
看上去完全一样

1037
00:32:15,376 --> 0:32:16,376
get 和 set

1038
00:32:16,376 --> 0:32:18,686
都需要 $path.value

1039
00:32:19,836 --> 0:32:21,666
现在 当然在默认情况下

1040
00:32:21,666 --> 0:32:22,616
是正确的语义

1041
00:32:22,616 --> 0:32:24,106
防御性拷贝应该

1042
00:32:24,106 --> 0:32:24,846
继续并进行复制

1043
00:32:25,486 --> 0:32:26,786
在这个例子中我们了解了

1044
00:32:26,786 --> 0:32:28,356
有关默认值的知识

1045
00:32:28,516 --> 0:32:29,546
就是创建一个新的对象

1046
00:32:29,716 --> 0:32:31,086
为什么我们要操作并复制呢

1047
00:32:31,486 --> 0:32:33,606
所以 让我们来稍微优化一下

1048
00:32:33,606 --> 0:32:34,766
因为我们可以做到

1049
00:32:35,796 --> 0:32:37,286
所以我们能够扩展防御拷贝

1050
00:32:37,326 --> 0:32:37,956
它只是一个类型

1051
00:32:38,046 --> 0:32:39,066
关于这个类型

1052
00:32:39,066 --> 0:32:39,966
没有什么神奇的

1053
00:32:39,966 --> 0:32:40,906
除了在使用时它表现得像

1054
00:32:40,906 --> 0:32:42,466
一个属性包装器

1055
00:32:42,946 --> 0:32:44,176
而且我们可以添加

1056
00:32:44,246 --> 0:32:45,686
withoutCopying 初始化

1057
00:32:46,286 --> 0:32:49,516
当我们这么使用时 

1058
00:32:49,516 --> 0:32:50,936
我们可以进行并为我们的类型

1059
00:32:50,936 --> 0:32:52,246
编写一个初始化程序

1060
00:32:53,256 --> 0:32:54,796
在这里我们在做的就是

1061
00:32:54,796 --> 0:32:57,666
我们正在为 $path 赋值

1062
00:32:57,666 --> 0:32:59,586
让它调用防御性 withoutCopying

1063
00:32:59,586 --> 0:33:01,416
初始化程序 这样我们就可以避免

1064
00:32:59,586 --> 0:33:01,416
初始化程序 这样我们就可以避免

1065
00:33:01,416 --> 0:33:02,056
出现多余的拷贝

1066
00:33:03,146 --> 0:33:04,256
所以这里没有更多

1067
00:33:04,256 --> 0:33:06,076
神奇的事情了

1068
00:33:06,266 --> 0:33:08,206
$path 只是一个存储属性

1069
00:33:08,256 --> 0:33:09,516
它唯一神奇的点在于

1070
00:33:09,516 --> 0:33:11,136
它是编译器作为将其应用到

1071
00:33:11,246 --> 0:33:13,586
属性包装器模式的一部分

1072
00:33:13,586 --> 0:33:14,896
而生成的

1073
00:33:15,456 --> 0:33:16,766
但是你可以

1074
00:33:16,766 --> 0:33:18,766
将它作为一个普通变量对待

1075
00:33:18,766 --> 0:33:20,436
包括设定

1076
00:33:20,436 --> 0:33:21,256
自己的初始化

1077
00:33:21,866 --> 0:33:24,056
现在 这还是

1078
00:33:24,256 --> 0:33:25,396
有点像样板文件

1079
00:33:25,396 --> 0:33:26,476
很不幸的是 我们不得不

1080
00:33:26,476 --> 0:33:27,446
编写那个初始化程序

1081
00:33:27,516 --> 0:33:28,256
所以你要看到

1082
00:33:28,256 --> 0:33:29,816
其他的初始化格式了

1083
00:33:30,546 --> 0:33:32,786
当你在

1084
00:33:32,786 --> 0:33:34,926
声明自定义属性时

1085
00:33:34,926 --> 0:33:36,446
使用 @DefensiveCopying

1086
00:33:36,446 --> 0:33:37,826
你可以就在属性声明里

1087
00:33:37,826 --> 0:33:39,056
进行初始化

1088
00:33:39,206 --> 0:33:40,266
按照你的想法来

1089
00:33:40,686 --> 0:33:42,636
所以这里我们就可以继续并调用

1090
00:33:42,636 --> 0:33:44,186
withoutCopying 初始化程序

1091
00:33:44,186 --> 0:33:45,446
来用我们想要的值

1092
00:33:45,446 --> 0:33:47,606
初始化备份存储属性

1093
00:33:47,966 --> 0:33:49,536
这个一个很好的小声明

1094
00:33:49,936 --> 0:33:51,236
而你还是获得了在

1095
00:33:51,236 --> 0:33:52,386
记忆初始化

1096
00:33:52,386 --> 0:33:54,326
获取默认设定的好处

1097
00:33:56,436 --> 0:34:00,016
好吧 所以 属性包装器事实上

1098
00:33:56,436 --> 0:34:00,016
好吧 所以 属性包装器事实上

1099
00:34:00,016 --> 0:34:01,576
还是很强大的

1100
00:34:01,836 --> 0:34:03,756
它们将访问数据的

1101
00:34:03,756 --> 0:34:06,326
这个策略概念抽象化了

1102
00:34:06,536 --> 0:34:08,416
所以你可以决定如何存储你的数据

1103
00:34:08,656 --> 0:34:10,626
而且你也可以决定如何访问你的数据

1104
00:34:11,106 --> 0:34:12,766
针对你的属性包装器 

1105
00:34:12,766 --> 0:34:14,016
你的用户要做的就是

1106
00:34:14,156 --> 0:34:15,846
使用那个自定义属性句法

1107
00:34:16,266 --> 0:34:17,366
来联系进你的系统

1108
00:34:17,616 --> 0:34:19,616
所以在我们开发

1109
00:34:19,616 --> 0:34:20,906
属性包装器时 我们发现了

1110
00:34:20,906 --> 0:34:22,755
针对它们的很多不同使用

1111
00:34:23,335 --> 0:34:24,716
都是围绕这类数据访问

1112
00:34:24,716 --> 0:34:26,496
的大致概念的

1113
00:34:27,246 --> 0:34:28,525
所以举个例子 你也许已经

1114
00:34:28,525 --> 0:34:29,886
看到用户默认示例

1115
00:34:30,306 --> 0:34:31,525
这里就是我们

1116
00:34:31,525 --> 0:34:32,626
建立的一个关系 这个关系在

1117
00:34:32,626 --> 0:34:34,246
你刚刚作为 Bool 引用的

1118
00:34:34,246 --> 0:34:35,795
Swift 中类型良好的属性

1119
00:34:35,795 --> 0:34:37,466
和一些字符串

1120
00:34:37,466 --> 0:34:38,726
类型实体之间

1121
00:34:39,045 --> 0:34:40,085
所以我们在结构参数中

1122
00:34:40,085 --> 0:34:41,636
明确描述了

1123
00:34:41,815 --> 0:34:43,815
如何继续并获取数据

1124
00:34:44,246 --> 0:34:46,255
处理用户默认的

1125
00:34:46,255 --> 0:34:47,926
所有逻辑 就在这个

1126
00:34:47,926 --> 0:34:50,136
用户默认属性包装器中完成了

1127
00:34:51,076 --> 0:34:53,196
所以我们构建 @ThreadSpecific

1128
00:34:53,196 --> 0:34:54,446
如果你想要以本地线程存储

1129
00:34:55,356 --> 0:34:55,966
你可以应用

1130
00:34:55,966 --> 0:34:57,206
ThreadSpecific 属性包装器

1131
00:34:57,296 --> 0:34:58,426
处理系统的线程相关

1132
00:34:58,426 --> 0:35:00,176
存储的所有细节

1133
00:34:58,426 --> 0:35:00,176
存储的所有细节

1134
00:35:00,176 --> 0:35:02,376
就都在属性包装器里面

1135
00:35:02,556 --> 0:35:03,796
你可以就把这个东西想成

1136
00:35:03,906 --> 0:35:05,766
一个本地的记忆池

1137
00:35:06,756 --> 0:35:08,326
还有 在 Swift 社区

1138
00:35:08,326 --> 0:35:09,106
正如我们已经

1139
00:35:09,106 --> 0:35:10,636
构建的这个功能 我们发现

1140
00:35:11,376 --> 0:35:13,026
在描述命令行参数时

1141
00:35:13,026 --> 0:35:14,696
它实现得非常好

1142
00:35:14,696 --> 0:35:15,496
如果你通过一个

1143
00:35:15,496 --> 0:35:17,376
库构建了一个命令行工具

1144
00:35:17,376 --> 0:35:18,906
用于记录

1145
00:35:19,256 --> 0:35:20,476
简写语法

1146
00:35:20,476 --> 0:35:21,926
意思是我想要 Minimum value

1147
00:35:22,106 --> 0:35:23,426
这就是 @Option 的描述

1148
00:35:24,156 --> 0:35:25,276
这就是用户传递的

1149
00:35:25,276 --> 0:35:26,406
缩写字符串

1150
00:35:26,406 --> 0:35:27,516
以及含义是什么

1151
00:35:27,596 --> 0:35:28,776
以及所有其他的东西

1152
00:35:28,776 --> 0:35:31,026
你需要非常非常简洁地

1153
00:35:31,026 --> 0:35:32,936
说明你的命令行选项

1154
00:35:33,636 --> 0:35:34,666
有很多真的非常酷

1155
00:35:34,666 --> 0:35:35,916
的东西我们可以通过

1156
00:35:35,916 --> 0:35:37,046
属性包装器完成

1157
00:35:37,046 --> 0:35:38,756
因为这个良好 干净的句法

1158
00:35:38,756 --> 0:35:39,616
可以生产一些东西

1159
00:35:40,816 --> 0:35:42,456
也许你在

1160
00:35:42,456 --> 0:35:44,386
另一场会议中已经了解了

1161
00:35:44,386 --> 0:35:46,086
我们在 SwiftUI 中广泛地

1162
00:35:46,386 --> 0:35:48,636
使用了属性包装器来描述

1163
00:35:48,636 --> 0:35:50,906
视图的数据依赖

1164
00:35:52,016 --> 0:35:54,116
在 Swift UI 中

1165
00:35:54,116 --> 0:35:55,326
有几个不同的

1166
00:35:55,326 --> 0:35:56,896
属性包装器存在

1167
00:35:57,036 --> 0:35:58,556
那么这里我们有一个 @State

1168
00:35:58,556 --> 0:35:59,806
来引入查看本地状态

1169
00:36:00,186 --> 0:36:01,716
对于一些高级引用

1170
00:36:01,716 --> 0:36:02,986
我们有 @Binding 来

1171
00:36:02,986 --> 0:36:04,236
声明它是来自其他地方的

1172
00:36:04,516 --> 0:36:05,036
你也许已经看到了

1173
00:36:05,036 --> 0:36:06,586
@Environment 一个环境对象

1174
00:36:07,676 --> 0:36:09,206
所有的这些都是属性包装器

1175
00:36:09,206 --> 0:36:10,636
在 Swift 中以那种方式

1176
00:36:10,636 --> 0:36:12,196
描述它们的一个好处在于

1177
00:36:12,196 --> 0:36:15,216
你在明确你的策略

1178
00:36:15,216 --> 0:36:17,216
数据在哪里

1179
00:36:17,216 --> 0:36:19,326
它是如何被访问的

1180
00:36:19,326 --> 0:36:20,506
都可以在声明中给出

1181
00:36:21,106 --> 0:36:22,306
但是当你继续并构建你的视图时

1182
00:36:22,306 --> 0:36:24,586
你并不在意那个

1183
00:36:24,716 --> 0:36:26,386
你不在乎数据在哪里

1184
00:36:26,556 --> 0:36:28,136
系统为你管理好了

1185
00:36:28,926 --> 0:36:30,536
你就可以查看

1186
00:36:30,536 --> 0:36:32,216
Keynote 讲演的

1187
00:36:32,216 --> 0:36:32,806
特定的一页

1188
00:36:33,536 --> 0:36:34,266
输入数字

1189
00:36:34,716 --> 0:36:35,696
如果你想要继续并编辑

1190
00:36:35,696 --> 0:36:38,426
一些东西 那么你可以使

1191
00:36:39,376 --> 0:36:41,726
找到实际捆绑的幻灯片

1192
00:36:42,776 --> 0:36:45,996
所以 处理数据的

1193
00:36:45,996 --> 0:36:47,736
所有逻辑 以及观察

1194
00:36:47,776 --> 0:36:49,096
变化更新 或者甚至是

1195
00:36:49,096 --> 0:36:50,256
在存储数据

1196
00:36:50,476 --> 0:36:51,946
在属性包装器类型中

1197
00:36:51,946 --> 0:36:53,696
的策略里都解决了

1198
00:36:53,976 --> 0:36:55,116
你不需要考虑

1199
00:36:55,336 --> 0:36:56,766
你只需要考虑处理

1200
00:36:56,766 --> 0:36:57,626
你实际的数据

1201
00:36:58,306 --> 0:37:00,136
现在 在这页幻灯片上

1202
00:36:58,306 --> 0:37:00,136
现在 在这页幻灯片上

1203
00:37:00,136 --> 0:37:01,796
有一个东西有点意思

1204
00:37:02,436 --> 0:37:04,906
那么这是 $slide.title

1205
00:37:05,546 --> 0:37:06,736
我们将其传递 这样就可以

1206
00:37:06,876 --> 0:37:08,506
在文本框编辑页标题

1207
00:37:09,986 --> 0:37:12,566
$slide 我们之前已经看到过了

1208
00:37:12,646 --> 0:37:14,486
那是备份存储属性

1209
00:37:14,486 --> 0:37:15,356
那就是编译器

1210
00:37:15,356 --> 0:37:16,836
为我们进行合成

1211
00:37:17,176 --> 0:37:19,546
因为我们在这里应用了

1212
00:37:19,546 --> 0:37:20,436
Binding 属性包装器

1213
00:37:21,826 --> 0:37:23,236
但在 Binding 中

1214
00:37:23,686 --> 0:37:24,676
是没有标题的

1215
00:37:26,066 --> 0:37:28,096
标题是我的数据模型的一部分

1216
00:37:28,096 --> 0:37:29,096
我一个幻灯片的数据模型

1217
00:37:29,186 --> 0:37:29,646
那么这给了我们什么呢

1218
00:37:30,086 --> 0:37:32,426
所以 实际上这是一个

1219
00:37:32,426 --> 0:37:34,446
属性包装器和

1220
00:37:34,446 --> 0:37:36,716
先前 Ben 讲到的关键路径成员

1221
00:37:36,716 --> 0:37:39,226
查找功能的结合

1222
00:37:39,806 --> 0:37:42,256
那么这样的话 让我们实际来

1223
00:37:42,306 --> 0:37:43,896
关注 @Binding

1224
00:37:43,896 --> 0:37:45,526
也就是在 Swift UI 里的东西 并且提供了

1225
00:37:45,526 --> 0:37:46,816
这个高级引用

1226
00:37:47,136 --> 0:37:49,646
首先也是最重要的 Binding

1227
00:37:49,646 --> 0:37:50,416
是一个属性包装器

1228
00:37:50,946 --> 0:37:53,736
所以它有 value

1229
00:37:53,736 --> 0:37:55,166
可以以任何类型的参数存在

1230
00:37:55,166 --> 0:37:56,786
因为你可以对任何东西进行捆绑

1231
00:37:57,096 --> 0:37:59,416
它有着任何样式的访问权限

1232
00:37:59,416 --> 0:38:00,106
这并不重要

1233
00:37:59,416 --> 0:38:00,106
这并不重要

1234
00:38:00,276 --> 0:38:02,456
我们并不知道这是什么

1235
00:38:02,456 --> 0:38:04,426
因为是由框架为我们处理的

1236
00:38:04,536 --> 0:38:07,646
通过泛型下标

1237
00:38:07,646 --> 0:38:09,306
捆绑也是支持关键

1238
00:38:09,346 --> 0:38:12,716
路径成员查找的泛型下标

1239
00:38:12,766 --> 0:38:13,506
有点儿拗口

1240
00:38:13,566 --> 0:38:14,486
我们不需要知道

1241
00:38:14,486 --> 0:38:15,756
是怎么实现的

1242
00:38:15,756 --> 0:38:16,466
但是我们应该更加仔细地

1243
00:38:16,466 --> 0:38:17,606
看一看类型签名

1244
00:38:17,606 --> 0:38:18,676
因为它很有趣

1245
00:38:19,096 --> 0:38:21,476
那么 我们已经讲过了关键路径

1246
00:38:21,986 --> 0:38:24,966
它与特定的值类型紧密联系

1247
00:38:24,966 --> 0:38:26,766
所以我们在进行捆绑的东西

1248
00:38:27,006 --> 0:38:30,656
比如幻灯片页

1249
00:38:30,656 --> 0:38:33,466
以及在那个特定实体里访问任何属性

1250
00:38:34,186 --> 0:38:36,076
这里返回的不是一个值

1251
00:38:36,076 --> 0:38:39,146
不是引用一些东西

1252
00:38:39,396 --> 0:38:41,256
我们返回的是一个新的捆绑

1253
00:38:41,666 --> 0:38:43,426
它的焦点在于外部捆绑的

1254
00:38:43,426 --> 0:38:45,976
某一个特定的属性

1255
00:38:45,976 --> 0:38:48,936
仍然保持着数据依赖

1256
00:38:52,806 --> 0:38:54,356
那么 在实际操作中这是怎么样的呢

1257
00:38:54,356 --> 0:38:56,556
好吧 我们有 slide

1258
00:38:56,556 --> 0:38:58,206
捆绑在我们的 Slide 类型上

1259
00:38:58,916 --> 0:39:00,696
基本上 我们将其

1260
00:38:58,916 --> 0:39:00,696
基本上 我们将其

1261
00:39:00,696 --> 0:39:01,526
视作是一个值

1262
00:39:01,526 --> 0:39:02,636
所以我们可以引用 slide

1263
00:39:02,636 --> 0:39:03,496
我们得到了一个 slide 实例

1264
00:39:03,496 --> 0:39:04,986
我们可以引用 slide.title 并且

1265
00:39:04,986 --> 0:39:06,406
获得那个字符串的实例

1266
00:39:06,676 --> 0:39:07,626
同时在后台

1267
00:39:08,186 --> 0:39:10,176
追踪所有修改

1268
00:39:10,756 --> 0:39:13,376
如果我们输入 $Slide 好的

1269
00:39:13,436 --> 0:39:15,336
我们将那个捆绑的实例放到了 slide 中

1270
00:39:15,946 --> 0:39:19,506
当我们输入 $slide.title 好的

1271
00:39:19,506 --> 0:39:20,626
现在我们在查找一个属性

1272
00:39:20,626 --> 0:39:22,316
它并不在捆绑中

1273
00:39:22,316 --> 0:39:24,056
所以编译器将其进行了重写

1274
00:39:24,126 --> 0:39:26,266
将其变成使用动态数字下标

1275
00:39:26,266 --> 0:39:28,696
将一个关键路径

1276
00:39:29,216 --> 0:39:30,276
放进 slide.title

1277
00:39:31,536 --> 0:39:33,126
这解析的方式是

1278
00:39:33,126 --> 0:39:34,586
将一个焦点捆绑点

1279
00:39:34,866 --> 0:39:37,846
变成字符串属性

1280
00:39:37,956 --> 0:39:39,776
它位于之前的捆绑中

1281
00:39:39,806 --> 0:39:40,826
并且遵循所有的

1282
00:39:40,826 --> 0:39:41,706
数据依赖

1283
00:39:42,656 --> 0:39:44,946
那么 如果我们抛开

1284
00:39:44,946 --> 0:39:46,246
之前我们一直在关注的

1285
00:39:46,246 --> 0:39:48,136
语言机制然后

1286
00:39:48,136 --> 0:39:49,286
看一看我们在这里进行的

1287
00:39:49,286 --> 0:39:51,246
高级代码 会非常好

1288
00:39:51,246 --> 0:39:52,416
在属性包装器里

1289
00:39:52,416 --> 0:39:54,096
使用这个自定义属性

1290
00:39:54,096 --> 0:39:55,216
我们建立了数据依赖

1291
00:39:55,976 --> 0:39:57,086
我们有访问我们数据的

1292
00:39:57,086 --> 0:39:59,276
基础权限 很容易读取

1293
00:39:59,276 --> 0:39:59,906
或者进行修改

1294
00:39:59,906 --> 0:40:01,546
如果我们想要通过

1295
00:39:59,906 --> 0:40:01,546
如果我们想要通过

1296
00:40:01,546 --> 0:40:02,536
我们的捆绑传递一个

1297
00:40:02,536 --> 0:40:04,506
高级引用 我们把这个前缀 $

1298
00:40:04,506 --> 0:40:05,796
放在它的前面

1299
00:40:05,876 --> 0:40:06,806
我们获得的影响是

1300
00:40:06,806 --> 0:40:07,836
我们总是可以向

1301
00:40:07,836 --> 0:40:09,886
一些其他视图传递一个捆绑

1302
00:40:11,616 --> 0:40:15,416
那么 我们已经讲到了一些

1303
00:40:15,416 --> 0:40:16,146
不同的主题

1304
00:40:16,146 --> 0:40:17,586
我们讲到了值语义

1305
00:40:17,646 --> 0:40:19,556
和引用语义

1306
00:40:19,556 --> 0:40:21,096
何时去使用两者以及如何

1307
00:40:21,096 --> 0:40:21,936
让它们协作运行

1308
00:40:23,076 --> 0:40:24,116
我们也谈到了

1309
00:40:24,116 --> 0:40:25,596
泛型和协议的使用

1310
00:40:26,336 --> 0:40:28,476
请记住 协议是极其强大的

1311
00:40:28,596 --> 0:40:30,686
但是用它们来进行代码重用

1312
00:40:30,686 --> 0:40:31,716
这就是它们的作用

1313
00:40:32,086 --> 0:40:33,606
而不是用来分类或者

1314
00:40:33,606 --> 0:40:34,966
构建庞大的继承结构

1315
00:40:34,966 --> 0:40:35,906
因为它们会阻碍你

1316
00:40:35,986 --> 0:40:37,706
你不需要这么做

1317
00:40:37,996 --> 0:40:41,326
最后 我们深入讲了讲

1318
00:40:41,326 --> 0:40:43,526
属性包装器语言功能

1319
00:40:43,526 --> 0:40:45,746
以及如何用它来

1320
00:40:45,796 --> 0:40:47,186
抽象访问数据

1321
00:40:48,476 --> 0:40:48,776
好的

1322
00:40:48,876 --> 0:40:49,846
非常感谢你们

1323
00:40:50,416 --> 0:40:51,816
如果你想要就任何这些话题进行讨论

1324
00:40:51,816 --> 0:40:53,466
欢迎来我们的实验室

1325
00:40:54,516 --> 0:40:59,500
[掌声]
