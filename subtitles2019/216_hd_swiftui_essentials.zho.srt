1
00:00:01,176 --> 0:00:04,500
[音乐]

2
00:00:08,321 --> 0:00:10,321
[掌声]

3
00:00:10,626 --> 0:00:15,736
&gt;&gt; 早上好 [掌声]

4
00:00:16,236 --> 0:00:18,316
早上好 欢迎来到 SwiftUI

5
00:00:18,436 --> 0:00:19,136
Essentials 项目

6
00:00:19,696 --> 0:00:21,376
我是 Matt Ricketson

7
00:00:21,376 --> 0:00:23,276
我目前在做 SwiftUI 项目 稍后

8
00:00:23,276 --> 0:00:24,676
我的同事 Taylor 也会为大家讲解

9
00:00:25,276 --> 0:00:26,906
那么目前大家觉得 SwiftUI 怎么样呢

10
00:00:27,516 --> 0:00:32,396
[掌声]

11
00:00:32,896 --> 0:00:34,566
我也是 今天我非常激动

12
00:00:34,566 --> 0:00:36,436
能和各位聊一聊 SwiftUI

13
00:00:37,266 --> 0:00:38,126
我们要讲很多内容

14
00:00:38,126 --> 0:00:39,846
所以让我们开始吧

15
00:00:42,036 --> 0:00:44,606
SwiftUI 是一个新框架

16
00:00:45,066 --> 0:00:46,876
旨在为大家构建优秀

17
00:00:46,876 --> 0:00:49,686
App 提供最优捷径

18
00:00:50,456 --> 0:00:51,736
这意味着为你提供构建

19
00:00:51,736 --> 0:00:55,026
优秀用户界面的最短路径

20
00:00:55,886 --> 0:00:57,876
虽然 SwiftUI 是一个

21
00:00:57,876 --> 0:00:59,846
新框架 但其中的很多内容

22
00:00:59,846 --> 0:01:01,156
对你来说已经很熟悉了

23
00:00:59,846 --> 0:01:01,156
对你来说已经很熟悉了

24
00:01:01,766 --> 0:01:04,056
这是因为它包含了

25
00:01:04,056 --> 0:01:05,626
UI 框架的

26
00:01:05,626 --> 0:01:06,916
所有基本组件

27
00:01:07,846 --> 0:01:10,966
它有按钮和文本字段等控件

28
00:01:11,856 --> 0:01:13,896
它有像栈和列表

29
00:01:13,896 --> 0:01:15,236
这样的布局容器

30
00:01:15,886 --> 0:01:19,106
它有绘图 动画和手势

31
00:01:19,476 --> 0:01:21,236
SwiftUI 甚至支持

32
00:01:21,536 --> 0:01:23,586
特定于平台的概念

33
00:01:23,586 --> 0:01:25,756
比如 Mac 上的菜单

34
00:01:25,756 --> 0:01:27,946
Apple Watch 上的数字表冠

35
00:01:27,946 --> 0:01:29,596
和 Apple TV 上的 Siri Remote 遥控器

36
00:01:29,596 --> 0:01:33,066
因此 我们要记住的是

37
00:01:33,066 --> 0:01:34,596
我们并非试图利用

38
00:01:34,596 --> 0:01:35,546
SwiftUI 重新发明轮子

39
00:01:36,776 --> 0:01:39,196
但我们都知道 事实是

40
00:01:39,196 --> 0:01:40,666
仅仅知道如何使用

41
00:01:40,666 --> 0:01:42,906
这些组件并不足以构建

42
00:01:42,906 --> 0:01:45,026
一个出色的 App

43
00:01:45,916 --> 0:01:48,186
因为一个出色的 App

44
00:01:48,186 --> 0:01:50,636
也需要考虑以下这些因素

45
00:01:51,346 --> 0:01:53,326
它必须要易于使用

46
00:01:53,326 --> 0:01:55,246
并且支持动态类型

47
00:01:56,366 --> 0:01:57,546
它需要适用于不同设备

48
00:01:57,546 --> 0:02:00,936
屏幕大小和输入类型

49
00:01:57,546 --> 0:02:00,936
屏幕大小和输入类型

50
00:02:01,366 --> 0:02:03,216
它还需要像交互式动画

51
00:02:03,466 --> 0:02:08,066
这样的东西和对深色模式和拖放等

52
00:02:08,526 --> 0:02:09,256
系统功能的支持

53
00:02:10,795 --> 0:02:12,216
这些可以让

54
00:02:12,646 --> 0:02:14,386
你的 App 接触到

55
00:02:14,386 --> 0:02:16,146
尽可能多的用户

56
00:02:16,146 --> 0:02:18,436
并让它紧跟潮流

57
00:02:19,046 --> 0:02:23,206
我们都知道这

58
00:02:23,206 --> 0:02:24,916
不是全部的内容

59
00:02:26,056 --> 0:02:27,516
因为你当然也添加了

60
00:02:27,516 --> 0:02:29,346
你自己独特的功能

61
00:02:29,346 --> 0:02:31,416
让你的 App 脱颖而出

62
00:02:32,476 --> 0:02:34,206
所以我想花点

63
00:02:34,206 --> 0:02:35,756
时间重申一下

64
00:02:36,546 --> 0:02:38,756
我们还有很多东西需要学习

65
00:02:39,796 --> 0:02:40,706
需要编写的代码和维护的

66
00:02:40,706 --> 0:02:43,116
东西很多 那么 SwiftUI

67
00:02:43,116 --> 0:02:45,496
是如何帮你完成这些工作呢

68
00:02:48,036 --> 0:02:49,586
请各位先想一下自己的 App

69
00:02:50,606 --> 0:02:51,636
首先 你有大家希望

70
00:02:51,636 --> 0:02:53,546
从你的 App 中获得的

71
00:02:53,546 --> 0:02:55,596
基本功能 比如控制和导航

72
00:02:55,596 --> 0:02:57,576
易于使用并根据不同

73
00:02:57,696 --> 0:02:59,536
的设备调整布局

74
00:03:00,856 --> 0:03:02,956
我们需要做这些事情

75
00:03:02,956 --> 0:03:04,596
我们需要它们来构建

76
00:03:04,596 --> 0:03:06,206
一个真正出色的 App

77
00:03:08,606 --> 0:03:09,296
但还有一些对于你的

78
00:03:09,296 --> 0:03:11,636
App 来说令人激动的

79
00:03:11,636 --> 0:03:12,476
独一无二的自定义功能

80
00:03:12,476 --> 0:03:14,776
这些也是有趣的功能

81
00:03:14,776 --> 0:03:16,996
我们为这些有趣的

82
00:03:16,996 --> 0:03:19,046
功能倾注了热情

83
00:03:19,046 --> 0:03:21,606
我们也为能构建出它们而感到骄傲

84
00:03:22,856 --> 0:03:24,816
所以 SwiftUI 的目标

85
00:03:24,896 --> 0:03:27,376
非常简单 我们希望

86
00:03:27,376 --> 0:03:28,736
你把尽可能多的时间

87
00:03:28,736 --> 0:03:30,966
花在有趣的功能上

88
00:03:30,966 --> 0:03:32,666
而不是花在基本功能上

89
00:03:32,756 --> 0:03:35,746
在不用牺牲质量前提下

90
00:03:36,856 --> 0:03:38,986
这就是我们所说的

91
00:03:38,986 --> 0:03:41,956
构建优秀 App 的最短路径

92
00:03:42,176 --> 0:03:43,346
因为各位都已经在

93
00:03:43,346 --> 0:03:44,346
构建优秀的 App 了

94
00:03:45,116 --> 0:03:47,956
我们只是想让大家更快地达成目标

95
00:03:50,056 --> 0:03:51,536
本次演讲是为了让大家

96
00:03:51,576 --> 0:03:53,206
更好地了解 SwiftUI

97
00:03:53,206 --> 0:03:54,986
我们会看一些代码

98
00:03:54,986 --> 0:03:56,736
但我们也会讨论

99
00:03:56,736 --> 0:03:58,796
SwiftUI 的设计以及

100
00:03:58,796 --> 0:04:00,746
它如何能帮你构建更好的 App

101
00:03:58,796 --> 0:04:00,746
它如何能帮你构建更好的 App

102
00:04:01,846 --> 0:04:02,816
本次演讲过后

103
00:04:03,586 --> 0:04:04,916
你就能够使用 SwiftUI

104
00:04:04,916 --> 0:04:07,176
构建一个完整的用户界面

105
00:04:07,916 --> 0:04:10,886
我们首先从视图和

106
00:04:10,886 --> 0:04:13,646
修饰符的基本内容讲起

107
00:04:14,636 --> 0:04:16,796
那么我们将需要一个例子

108
00:04:17,055 --> 0:04:18,166
我总是试着选择

109
00:04:18,166 --> 0:04:21,546
一个我关心的例子来激励我

110
00:04:22,896 --> 0:04:24,726
如果大家最近上网

111
00:04:24,726 --> 0:04:26,416
可能会看到千禧一代

112
00:04:26,416 --> 0:04:27,446
比如像我自己

113
00:04:27,506 --> 0:04:30,576
把这个东西当成我们

114
00:04:30,756 --> 0:04:34,266
生活中最重要的部分

115
00:04:35,956 --> 0:04:38,876
没错 牛油果吐司

116
00:04:39,016 --> 0:04:41,016
[笑声]

117
00:04:41,516 --> 0:04:44,566
[掌声]

118
00:04:45,066 --> 0:04:46,806
看来我们的观众里有千禧一代

119
00:04:47,116 --> 0:04:49,196
所以今天我们要做一个

120
00:04:49,196 --> 0:04:51,306
App 来点牛油果吐司

121
00:04:51,896 --> 0:04:53,136
我已经做了一些内容

122
00:04:53,136 --> 0:04:54,416
所以它现在看起来

123
00:04:54,416 --> 0:04:55,496
是这样的

124
00:04:56,616 --> 0:04:58,596
这是一个简单的形式

125
00:04:58,596 --> 0:04:59,896
让我能立刻从手机上

126
00:04:59,896 --> 0:05:01,066
点我想要的食物

127
00:04:59,896 --> 0:05:01,066
点我想要的食物

128
00:05:02,096 --> 0:05:03,536
显然 它目前为止还没有

129
00:05:03,536 --> 0:05:04,876
很多内容 但我们会在

130
00:05:04,876 --> 0:05:06,016
整个演讲中继续构建

131
00:05:07,026 --> 0:05:09,456
但在深入研究代码之前 我想先

132
00:05:09,456 --> 0:05:11,016
谈一下视图

133
00:05:11,586 --> 0:05:15,346
这是因为视图是用户

134
00:05:15,346 --> 0:05:17,746
界面的基本构建块

135
00:05:18,636 --> 0:05:19,856
它对我们构建 SwiftUI

136
00:05:19,856 --> 0:05:21,996
每一环节都非常重要

137
00:05:23,776 --> 0:05:25,586
如果你之前使用过其他

138
00:05:25,586 --> 0:05:27,806
UI 框架 比如 UIKit 或

139
00:05:27,806 --> 0:05:30,066
AppKit 你可能已经

140
00:05:30,136 --> 0:05:31,196
听说过视图这一术语

141
00:05:32,676 --> 0:05:34,756
SwiftUI 也有视图

142
00:05:34,756 --> 0:05:36,726
它们的主要作用与它们在

143
00:05:36,726 --> 0:05:38,146
这些框架中的作用相同

144
00:05:39,676 --> 0:05:42,146
从高层级来讲

145
00:05:42,146 --> 0:05:47,306
视图只是定义 UI 的一部分

146
00:05:47,566 --> 0:05:49,146
当你看一个 App 时

147
00:05:49,146 --> 0:05:50,826
你看到的一切都是

148
00:05:50,826 --> 0:05:52,096
由视图定义的

149
00:05:53,656 --> 0:05:55,116
单独的控件是视图

150
00:05:56,426 --> 0:05:59,306
容纳它们的容器也是视图

151
00:05:59,656 --> 0:06:02,026
事实上 你在屏幕上

152
00:05:59,656 --> 0:06:02,026
事实上 你在屏幕上

153
00:06:02,026 --> 0:06:03,616
看到的每一个像素都可以

154
00:06:03,616 --> 0:06:05,606
以某种方式追溯为视图

155
00:06:06,206 --> 0:06:09,306
我们通过将这些

156
00:06:09,306 --> 0:06:11,226
视图组合成控制架构

157
00:06:11,226 --> 0:06:12,826
来构建用户界面

158
00:06:13,306 --> 0:06:16,026
从底部的容器

159
00:06:16,866 --> 0:06:21,776
到底部的文本 图像和形状

160
00:06:24,076 --> 0:06:25,446
如果你以前用过

161
00:06:25,446 --> 0:06:26,826
UIKit 或 AppKit

162
00:06:26,826 --> 0:06:28,176
应该很熟悉这幅图

163
00:06:28,316 --> 0:06:29,526
重要的是要理解

164
00:06:29,526 --> 0:06:33,706
SwiftUI 的视图也是如此

165
00:06:33,706 --> 0:06:36,636
SwiftUI 可能与你

166
00:06:36,636 --> 0:06:38,316
习惯的不同之处在于

167
00:06:38,316 --> 0:06:41,166
视图在代码中的表达方式

168
00:06:42,116 --> 0:06:44,966
我们来看一些代码

169
00:06:45,516 --> 0:06:47,356
在我们的示例 App 中

170
00:06:47,356 --> 0:06:49,676
我们只有一个垂直栈包括控件和文本

171
00:06:50,276 --> 0:06:52,656
通过代码很容易看出这一点

172
00:06:55,186 --> 0:06:56,236
但实际上 你会注意到

173
00:06:56,286 --> 0:06:57,886
左边的代码与右边的

174
00:06:58,776 --> 0:07:00,086
等价视图层次关系

175
00:06:58,776 --> 0:07:00,086
等价视图层次关系

176
00:07:00,086 --> 0:07:01,666
视图非常匹配

177
00:07:03,276 --> 0:07:04,586
在栈的根目录中

178
00:07:04,586 --> 0:07:09,506
栈包含了文本和控件

179
00:07:10,276 --> 0:07:12,316
指向每个控件中

180
00:07:12,646 --> 0:07:14,306
包含的单个文本标签

181
00:07:18,046 --> 0:07:19,816
现在你看不到的是对函数的调用

182
00:07:19,816 --> 0:07:21,526
比如添加子视图

183
00:07:23,146 --> 0:07:24,356
因为我们不是

184
00:07:24,356 --> 0:07:25,426
一点一点地构建视图层次

185
00:07:25,426 --> 0:07:27,636
而是将它初始化为

186
00:07:27,636 --> 0:07:29,976
一个完整的组合结构

187
00:07:31,626 --> 0:07:34,006
这是因为 SwiftUI

188
00:07:34,006 --> 0:07:36,926
以声明的方式定义

189
00:07:36,926 --> 0:07:38,266
其视图 而非强制

190
00:07:39,136 --> 0:07:41,126
我想不出比

191
00:07:41,126 --> 0:07:42,286
牛油果吐司更好的

192
00:07:42,286 --> 0:07:45,526
类比来解释这些概念了

193
00:07:45,776 --> 0:07:47,976
所以让我们试着用命令式代码做牛油果吐司

194
00:07:50,556 --> 0:07:51,956
命令式代码包括

195
00:07:51,956 --> 0:07:54,826
通过发送显式命令来构建结果

196
00:07:55,966 --> 0:07:57,116
这有点像在电话里

197
00:07:57,116 --> 0:07:59,686
教朋友做牛油果吐司

198
00:08:01,186 --> 0:08:02,186
你开始告诉他们

199
00:08:02,186 --> 0:08:03,766
需要什么原料

200
00:08:03,766 --> 0:08:06,496
什么设备 然后开始

201
00:08:06,496 --> 0:08:08,876
指导他们做吐司和切牛油果

202
00:08:08,876 --> 0:08:10,506
所有这些指导

203
00:08:10,506 --> 0:08:13,366
开始变得有啰嗦

204
00:08:13,666 --> 0:08:16,126
如果你的朋友

205
00:08:16,126 --> 0:08:17,956
搞砸了任何一个小步骤

206
00:08:17,956 --> 0:08:20,146
比如忘记烤面包 那么

207
00:08:20,206 --> 0:08:21,686
最后的结果就毁了

208
00:08:24,216 --> 0:08:25,626
现在让我们把它和

209
00:08:25,626 --> 0:08:27,606
牛油果吐司做个比较

210
00:08:29,466 --> 0:08:30,526
声明代码包括通过

211
00:08:30,526 --> 0:08:32,546
描述你想要的内容

212
00:08:32,546 --> 0:08:36,126
然后让其他人来想办法如何为你构建结果

213
00:08:36,696 --> 0:08:39,476
这有点像从牛油果师傅

214
00:08:39,476 --> 0:08:42,655
那里点牛油果吐司

215
00:08:45,596 --> 0:08:47,766
幸运的是 加州有很多这样的面包店

216
00:08:49,726 --> 0:08:50,936
现在你要做的就是

217
00:08:50,936 --> 0:08:51,886
说出你想要的

218
00:08:52,416 --> 0:08:55,336
你甚至可以插入自定义指令

219
00:08:55,936 --> 0:08:58,156
就是这样

220
00:08:58,416 --> 0:08:59,826
因为有专家为我们制作

221
00:08:59,826 --> 0:09:01,326
所以我们能保证

222
00:08:59,826 --> 0:09:01,326
所以我们能保证

223
00:09:01,326 --> 0:09:02,766
得到高质量的结果

224
00:09:03,446 --> 0:09:06,006
现在让我们继续看一下代码

225
00:09:06,176 --> 0:09:08,476
SwiftUI 将充当专家的角色

226
00:09:08,476 --> 0:09:10,426
随时为您提供帮助

227
00:09:11,376 --> 0:09:13,506
在代码中 我们通过

228
00:09:13,506 --> 0:09:17,136
初始化编码这些关系的结构

229
00:09:17,136 --> 0:09:20,976
来声明视图之间的架构关系

230
00:09:23,416 --> 0:09:25,726
SwiftUI 会将你的

231
00:09:26,086 --> 0:09:29,326
视图转换为屏幕上

232
00:09:29,326 --> 0:09:30,736
呈现的结果

233
00:09:33,166 --> 0:09:34,186
关于这个还有很多要讲

234
00:09:34,186 --> 0:09:35,776
但是现在让我们先

235
00:09:35,776 --> 0:09:37,876
习惯一下代码中的语法

236
00:09:38,326 --> 0:09:40,326
我们将从容器视图开始

237
00:09:43,356 --> 0:09:44,706
容器视图声明为

238
00:09:44,706 --> 0:09:46,686
作为其内容的

239
00:09:46,746 --> 0:09:47,816
其他视图的组合

240
00:09:49,806 --> 0:09:51,096
这些内容视图是在一种

241
00:09:51,096 --> 0:09:53,066
称为视图构建器的特殊

242
00:09:53,146 --> 0:09:54,366
类型的闭包中声明

243
00:09:55,946 --> 0:09:57,156
比如 我们已经看到了

244
00:09:57,156 --> 0:09:59,916
VStack 或垂直栈

245
00:09:59,916 --> 0:10:01,686
这是其中一个容器的例子

246
00:09:59,916 --> 0:10:01,686
这是其中一个容器的例子

247
00:10:02,206 --> 0:10:04,586
视图构建器允许我们

248
00:10:04,586 --> 0:10:07,206
在闭包中编写声明代码

249
00:10:08,186 --> 0:10:09,466
我们可以在闭包中

250
00:10:09,466 --> 0:10:11,446
列出我们的内容 不是调用

251
00:10:11,446 --> 0:10:13,726
像 AddSubViews 这样的函数

252
00:10:14,476 --> 0:10:16,716
为了进一步了解

253
00:10:16,716 --> 0:10:17,916
它的工作原理 让我们

254
00:10:17,916 --> 0:10:19,876
看一下 VStack 的实际 API

255
00:10:20,366 --> 0:10:23,306
你可以看到内容参数

256
00:10:23,306 --> 0:10:25,776
被定义为一个闭包

257
00:10:26,296 --> 0:10:27,706
但使用这个 ViewBuilder

258
00:10:27,706 --> 0:10:28,176
属性进行了标记

259
00:10:29,446 --> 0:10:31,426
Swift Compiler 知道如何

260
00:10:31,426 --> 0:10:33,196
将此属性标记的闭包

261
00:10:33,236 --> 0:10:35,076
转换为一个新的闭包

262
00:10:35,076 --> 0:10:37,166
该闭包返回一个

263
00:10:37,166 --> 0:10:40,576
表示栈中所有内容的视图

264
00:10:42,106 --> 0:10:43,636
这是 SwiftUI 使用

265
00:10:44,256 --> 0:10:46,046
Swift 功能帮你编写

266
00:10:46,046 --> 0:10:47,966
更少代码的一个例子

267
00:10:51,416 --> 0:10:53,066
像 VStack 这样的视图

268
00:10:53,066 --> 0:10:55,006
还可以接受除内容之外的其他参数

269
00:10:55,426 --> 0:10:57,136
例如 我们可以配置

270
00:10:57,136 --> 0:10:59,136
我们的 VStack

271
00:10:59,136 --> 0:11:00,856
使其内容沿着前缘对齐

272
00:10:59,136 --> 0:11:00,856
使其内容沿着前缘对齐

273
00:11:00,856 --> 0:11:02,696
而不是使用默认的中心对齐

274
00:11:06,486 --> 0:11:08,356
总之 这是一种

275
00:11:08,356 --> 0:11:10,986
非常好的自然语法

276
00:11:10,986 --> 0:11:12,676
允许我们使用大括号

277
00:11:12,676 --> 0:11:15,416
和缩进来区分

278
00:11:15,416 --> 0:11:17,336
容器视图及其

279
00:11:17,336 --> 0:11:21,076
配置和其中的内容

280
00:11:24,046 --> 0:11:24,966
我们也遵循许多控件的语法

281
00:11:24,966 --> 0:11:26,506
因为 SwiftUI

282
00:11:26,506 --> 0:11:28,976
里的大多数控件也是容器

283
00:11:31,046 --> 0:11:32,476
这在我们的实例 App 中可以看到

284
00:11:32,476 --> 0:11:34,566
在每种情况下 我们的控件

285
00:11:34,566 --> 0:11:36,776
都定义了一段文本作为

286
00:11:36,776 --> 0:11:39,396
它们的标签 用于描述它们的用途

287
00:11:42,046 --> 0:11:43,516
现在我们在这不仅可以放文本

288
00:11:43,516 --> 0:11:44,516
我们可以放任何一种视图

289
00:11:45,396 --> 0:11:46,886
我们将在稍后对此

290
00:11:46,886 --> 0:11:47,716
进行更深入的讨论

291
00:11:49,636 --> 0:11:51,466
这里看到的另一种

292
00:11:51,466 --> 0:11:53,266
语法是 Toggles 和

293
00:11:53,676 --> 0:11:55,976
Stepper 命令中的美元符号

294
00:11:57,426 --> 0:11:58,466
前面的美元符号

295
00:11:58,546 --> 0:12:00,206
表示我们正在向

296
00:11:58,546 --> 0:12:00,206
表示我们正在向

297
00:12:00,316 --> 0:12:02,166
控件传递一个绑定

298
00:12:02,166 --> 0:12:03,366
而非一个普通的值

299
00:12:04,796 --> 0:12:05,886
那么什么是绑定呢

300
00:12:06,356 --> 0:12:09,366
在我们的示例 App 中

301
00:12:09,366 --> 0:12:11,106
Stepper 包含在一个视图中

302
00:12:11,106 --> 0:12:12,606
该视图依赖于持续

303
00:12:12,606 --> 0:12:13,676
追踪当前订单的状态

304
00:12:13,966 --> 0:12:15,786
它使用 @State 属性

305
00:12:15,786 --> 0:12:18,386
来定义订单的特性

306
00:12:19,536 --> 0:12:21,116
当 SwiftUI 看到用

307
00:12:21,116 --> 0:12:22,926
该属性标记的特性时

308
00:12:22,926 --> 0:12:24,346
它会自动在后台创建

309
00:12:24,346 --> 0:12:26,226
并持续管理状态

310
00:12:26,226 --> 0:12:28,336
然后通过该属性

311
00:12:28,336 --> 0:12:30,976
公开该状态的值

312
00:12:34,106 --> 0:12:36,096
在本例中 它包含

313
00:12:36,096 --> 0:12:37,656
一个我自己定义的 struct

314
00:12:38,746 --> 0:12:40,696
它表示我们所有的订单信息

315
00:12:43,096 --> 0:12:45,276
如果我们只想读写

316
00:12:45,336 --> 0:12:47,616
@State 的数据是很简单的

317
00:12:47,806 --> 0:12:50,116
我们可以直接读写属性

318
00:12:51,316 --> 0:12:52,376
当我们为 Stepper 做

319
00:12:52,376 --> 0:12:53,806
标签时 我们就这样做了

320
00:12:56,136 --> 0:12:58,016
然而 Stepper 还需要

321
00:12:58,016 --> 0:12:59,896
在按钮被轻点时的状态

322
00:12:59,896 --> 0:13:01,056
能够编辑 State

323
00:12:59,896 --> 0:13:01,056
能够编辑 State

324
00:13:02,306 --> 0:13:05,886
我们使用这个美元符号前缀来表示

325
00:13:05,886 --> 0:13:08,306
我们应该传递一个绑定到

326
00:13:08,306 --> 0:13:09,846
Quantity 属性中

327
00:13:10,656 --> 0:13:13,296
而非只传递一个只读值

328
00:13:14,836 --> 0:13:17,056
绑定是一种托管参考

329
00:13:17,136 --> 0:13:19,106
允许一个视图编辑

330
00:13:19,506 --> 0:13:21,456
另一个视图的状态

331
00:13:24,456 --> 0:13:26,016
现在 要了解更多关于状态

332
00:13:26,016 --> 0:13:27,976
和绑定以及如何管理

333
00:13:28,146 --> 0:13:29,196
App 中使用的所有

334
00:13:29,196 --> 0:13:31,056
其他类型的数据依赖

335
00:13:31,056 --> 0:13:32,796
我强烈建议

336
00:13:32,796 --> 0:13:34,216
大家看一下视频

337
00:13:34,216 --> 0:13:35,296
《Data Flow Through SwiftUI》

338
00:13:35,906 --> 0:13:38,066
但是现在 重点是

339
00:13:38,066 --> 0:13:40,496
要记住如果你曾经

340
00:13:40,496 --> 0:13:41,866
看到过一个属性 比如

341
00:13:41,866 --> 0:13:44,536
@State 它通常表示

342
00:13:44,986 --> 0:13:48,806
SwiftUI 在幕后代你管理的某种

343
00:13:48,806 --> 0:13:50,546
数据依赖关系

344
00:13:52,156 --> 0:13:53,726
如果你看到一个美元符号前缀

345
00:13:53,726 --> 0:13:55,876
那通常表示我们在

346
00:13:55,876 --> 0:13:57,596
传递一个被绑定的参数

347
00:13:57,676 --> 0:13:57,976
到另一个视图

348
00:14:03,046 --> 0:14:04,106
回到我们的实例 App

349
00:14:04,106 --> 0:14:06,256
还有一个更重要的

350
00:14:06,256 --> 0:14:08,236
语法我们还没有讨论

351
00:14:08,516 --> 0:14:09,556
你可以看到我们在上面

352
00:14:09,556 --> 0:14:12,476
为标题设置字体

353
00:14:14,016 --> 0:14:19,676
让我们把它放大 首先初始化文本

354
00:14:21,106 --> 0:14:22,476
这也是 SwiftUI

355
00:14:22,476 --> 0:14:23,466
另一种视图

356
00:14:26,046 --> 0:14:27,556
然后 我们在 Text

357
00:14:27,556 --> 0:14:29,906
文本上调用一个方法 并将

358
00:14:29,906 --> 0:14:32,296
系统定义的文本传递给它

359
00:14:32,936 --> 0:14:35,116
这种方法在 SwiftUI

360
00:14:35,116 --> 0:14:36,736
中称为修饰语句

361
00:14:37,526 --> 0:14:39,626
修饰语句只是一个

362
00:14:40,076 --> 0:14:42,076
从现有视图创建

363
00:14:42,076 --> 0:14:42,766
新视图的方法

364
00:14:45,086 --> 0:14:46,406
我的意思就是

365
00:14:47,516 --> 0:14:48,846
这是没有 font

366
00:14:48,846 --> 0:14:49,976
修饰语句时 UI 的样子

367
00:14:49,976 --> 0:14:52,046
在这种情况下

368
00:14:52,046 --> 0:14:55,146
只呈现默认的主体字体

369
00:14:56,356 --> 0:14:57,966
这就是视图架构

370
00:14:57,966 --> 0:14:58,746
关系图的样子

371
00:14:59,536 --> 0:15:01,226
我们看到 VStack

372
00:14:59,536 --> 0:15:01,226
我们看到 VStack

373
00:15:01,446 --> 0:15:02,806
中包含了我们的文本

374
00:15:06,076 --> 0:15:07,766
当文本被修改时

375
00:15:07,766 --> 0:15:10,826
将插入一个新视图 来包装现有的文本

376
00:15:11,656 --> 0:15:13,616
新视图指示 SwiftUI

377
00:15:13,616 --> 0:15:15,586
用新的 front 来呈现文本

378
00:15:17,396 --> 0:15:18,436
这些修饰符甚至

379
00:15:18,436 --> 0:15:18,996
可以链接在一起

380
00:15:20,076 --> 0:15:21,356
例如 我们可以通过

381
00:15:21,356 --> 0:15:22,886
添加前景颜色修饰语句

382
00:15:22,886 --> 0:15:24,506
来更改标题的文本颜色

383
00:15:25,986 --> 0:15:27,436
这将为视图架构中添加

384
00:15:27,436 --> 0:15:29,556
另一个视图 该视图将包装

385
00:15:29,686 --> 0:15:30,386
修饰语句视图

386
00:15:34,286 --> 0:15:35,866
显然 我们的视图架构

387
00:15:36,426 --> 0:15:38,236
很快就会变大

388
00:15:38,236 --> 0:15:40,546
对于经验丰富的 UI

389
00:15:40,546 --> 0:15:42,236
程序员来说 这可能

390
00:15:42,236 --> 0:15:43,506
会为他们做内部

391
00:15:43,596 --> 0:15:44,186
控件时提个醒

392
00:15:45,006 --> 0:15:46,586
因为多年来 我们

393
00:15:46,716 --> 0:15:48,606
训练自己通过让

394
00:15:48,606 --> 0:15:50,396
视图层级架构尽可能

395
00:15:50,396 --> 0:15:52,046
保持小和轻从而来

396
00:15:52,046 --> 0:15:54,506
优化 App 的性能

397
00:15:55,046 --> 0:15:58,366
但请记住 我们是在写

398
00:15:58,506 --> 0:15:59,556
定义代码

399
00:16:00,976 --> 0:16:03,486
SwiftUI 是我们的专业指导

400
00:16:03,876 --> 0:16:05,786
它会根据我们的意见

401
00:16:05,786 --> 0:16:07,366
根据我们点的菜

402
00:16:07,766 --> 0:16:09,426
熟练地编写出代码

403
00:16:10,326 --> 0:16:11,326
因此 即使我们必须将

404
00:16:11,326 --> 0:16:13,236
文本包装在多个封装器

405
00:16:13,236 --> 0:16:16,026
视图中 SwiftUI 也会

406
00:16:16,026 --> 0:16:17,916
在后台将其重叠成

407
00:16:17,966 --> 0:16:20,376
一个高效的数据结构

408
00:16:20,376 --> 0:16:22,236
然后供渲染系统使用

409
00:16:23,786 --> 0:16:25,066
你无需担心会

410
00:16:25,066 --> 0:16:26,506
影响性能 你会

411
00:16:27,376 --> 0:16:29,526
发现这种链接

412
00:16:29,526 --> 0:16:31,596
修饰语句实际上

413
00:16:31,596 --> 0:16:33,236
提供了很多好处

414
00:16:34,836 --> 0:16:37,406
比如 修饰符链能够

415
00:16:37,686 --> 0:16:41,476
强制执行视觉效果的确定顺序

416
00:16:43,586 --> 0:16:44,856
现在我们看到的是一段

417
00:16:44,856 --> 0:16:45,796
以绿色为背景的文字

418
00:16:46,736 --> 0:16:48,726
但是文本看起来有些过多

419
00:16:48,726 --> 0:16:50,446
所以让我们试着

420
00:16:50,446 --> 0:16:51,906
通过在文本周围添加一些

421
00:16:52,226 --> 0:16:53,496
间隔来扩展背景

422
00:16:56,046 --> 0:16:57,436
我们添加了间隔修饰符

423
00:16:57,436 --> 0:16:59,606
你可以看到它在视图层级中

424
00:16:59,606 --> 0:17:00,766
添加了一个新视图

425
00:16:59,606 --> 0:17:00,766
添加了一个新视图

426
00:17:01,896 --> 0:17:02,976
但屏幕上没有任何变化

427
00:17:06,046 --> 0:17:07,406
实际上间隔就在这里

428
00:17:07,406 --> 0:17:08,415
只是我们看不见而已

429
00:17:09,996 --> 0:17:11,195
我们来看一下代码

430
00:17:11,195 --> 0:17:12,876
我们的背景修饰符只是把

431
00:17:12,876 --> 0:17:15,036
文本包了起来 而没有改变间隔

432
00:17:15,586 --> 0:17:16,935
这表示间隔被

433
00:17:16,935 --> 0:17:18,786
应用到了背景之外

434
00:17:21,046 --> 0:17:22,646
幸运的是 通过移动

435
00:17:22,646 --> 0:17:23,976
背景修饰符来

436
00:17:23,976 --> 0:17:25,656
包装文本和添加间隔

437
00:17:25,656 --> 0:17:27,455
能轻易解决这个问题

438
00:17:32,046 --> 0:17:32,856
现在让我们再来看一下

439
00:17:32,856 --> 0:17:34,026
我们刚才做的事情

440
00:17:35,466 --> 0:17:36,716
想象一下 如果间隔

441
00:17:36,716 --> 0:17:38,116
和背景是文本上的属性

442
00:17:38,116 --> 0:17:40,226
而不是单独的修饰符

443
00:17:42,206 --> 0:17:43,726
这种情况下 如果没有

444
00:17:43,726 --> 0:17:45,416
反复试验或阅读过文档

445
00:17:45,416 --> 0:17:47,366
我们将无法知道

446
00:17:47,366 --> 0:17:49,246
他们的申请顺序

447
00:17:50,416 --> 0:17:52,566
相反 通过像这样将修饰符

448
00:17:52,566 --> 0:17:54,656
链接在一起 我们可以

449
00:17:54,656 --> 0:17:55,646
直接显示顺序

450
00:17:56,686 --> 0:17:57,976
我们也把它设计的很易于

451
00:17:57,976 --> 0:17:59,966
自定义 就像刚才那样

452
00:18:02,096 --> 0:18:03,036
现在 这些修饰符的

453
00:18:03,036 --> 0:18:04,476
另一个好处是它们可以

454
00:18:04,476 --> 0:18:06,056
在视图之间共享

455
00:18:06,486 --> 0:18:08,686
例如 这里我们对多种

456
00:18:08,796 --> 0:18:11,256
不同类型的控件

457
00:18:11,256 --> 0:18:12,566
应用了不透明效果

458
00:18:13,836 --> 0:18:14,846
我们甚至可以将

459
00:18:14,846 --> 0:18:16,376
不透明度应用于整个栈

460
00:18:17,356 --> 0:18:18,786
而不是每个单独的控件

461
00:18:19,906 --> 0:18:21,466
这些视图都不需要定义

462
00:18:21,466 --> 0:18:23,476
自己的不透明度属性

463
00:18:24,146 --> 0:18:25,766
这意味着它们

464
00:18:25,766 --> 0:18:28,156
可以拥有更简单

465
00:18:28,416 --> 0:18:29,526
更集中的接口

466
00:18:30,576 --> 0:18:33,316
这些就构成了 SwiftUI 的整体原理

467
00:18:36,046 --> 0:18:37,196
即倾向使用较小的

468
00:18:37,936 --> 0:18:39,216
单一用途的视图

469
00:18:40,446 --> 0:18:42,106
这些更简单的视图

470
00:18:42,106 --> 0:18:44,296
更容易理解

471
00:18:44,296 --> 0:18:45,966
也更容易在更长的时间内维护

472
00:18:47,436 --> 0:18:48,296
一旦你得到了所有

473
00:18:48,296 --> 0:18:50,076
这些小视图 你就可以把它们

474
00:18:50,076 --> 0:18:51,376
组合在一起来创建更大

475
00:18:51,476 --> 0:18:52,556
更复杂的视图

476
00:18:54,016 --> 0:18:56,986
SwiftUI 的整个框架

477
00:18:57,086 --> 0:18:59,336
都是围绕着小的代码段的

478
00:18:59,336 --> 0:19:01,466
的组合而设计 你应该用同样

479
00:18:59,336 --> 0:19:01,466
的组合而设计 你应该用同样

480
00:19:01,466 --> 0:19:02,976
的方式来组织你的代码

481
00:19:05,246 --> 0:19:06,446
所以你可以从

482
00:19:06,446 --> 0:19:07,636
简单的文本开始

483
00:19:09,086 --> 0:19:10,786
你可以把它修改的更好

484
00:19:10,896 --> 0:19:12,666
你可以把它们组合在一起

485
00:19:12,666 --> 0:19:14,316
来创建一些优秀的程序

486
00:19:15,406 --> 0:19:17,066
比如像这个

487
00:19:17,066 --> 0:19:18,766
牛油果吐司 App

488
00:19:18,766 --> 0:19:20,216
就我个人而言

489
00:19:20,216 --> 0:19:21,966
我迫不及待地想看到大家

490
00:19:22,046 --> 0:19:23,226
都来使用 SwiftUI

491
00:19:23,226 --> 0:19:23,976
构建用户界面

492
00:19:26,466 --> 0:19:27,506
但在此之前

493
00:19:27,506 --> 0:19:28,366
我们首先需要知道如何

494
00:19:28,366 --> 0:19:31,056
构建我们的自定义视图

495
00:19:31,056 --> 0:19:32,456
现在让我们来创建一些新内容

496
00:19:35,616 --> 0:19:37,296
来看一下我们的 App

497
00:19:37,296 --> 0:19:39,666
我很想看一下我以前的订单历史

498
00:19:40,856 --> 0:19:42,266
我已经草拟了一个设计方案

499
00:19:42,896 --> 0:19:44,346
它只是一个简单的列表

500
00:19:44,346 --> 0:19:46,186
显示了每个订单的摘要

501
00:19:46,186 --> 0:19:48,446
以及我选择的配料的一些图标

502
00:19:50,136 --> 0:19:51,516
我已经写了一些代码

503
00:19:51,516 --> 0:19:53,306
让我们一步一步

504
00:19:53,306 --> 0:19:54,566
快速地来看一下

505
00:19:55,926 --> 0:19:58,286
首先 我定义了一个

506
00:19:58,896 --> 0:20:01,296
名为 OrderHistory 的

507
00:19:58,896 --> 0:20:01,296
名为 OrderHistory 的

508
00:20:01,366 --> 0:20:02,926
新视图为一个符合视图协议的结构

509
00:20:04,176 --> 0:20:05,436
我们接下来还会讲到

510
00:20:06,466 --> 0:20:07,716
我的视图只有一个

511
00:20:07,716 --> 0:20:09,956
输入属性 即 previousOrders

512
00:20:09,956 --> 0:20:12,066
它只是我所有订单信息的集合

513
00:20:14,726 --> 0:20:16,136
我的视图有一个计算属性

514
00:20:16,136 --> 0:20:18,856
名为 body  它能够传回视图的内容

515
00:20:19,936 --> 0:20:21,246
这里我们使用的 sum

516
00:20:21,246 --> 0:20:22,956
关键词是 Swift 功能

517
00:20:22,956 --> 0:20:26,306
它允许 Swift 自动推断传回类型

518
00:20:30,046 --> 0:20:32,216
body 属性会传回一个列表

519
00:20:32,466 --> 0:20:34,676
该列表通过将之前的

520
00:20:34,676 --> 0:20:36,056
每个订单标记到一个

521
00:20:36,056 --> 0:20:39,036
新视图集合来生成

522
00:20:39,036 --> 0:20:41,736
其内容 每个订单使用

523
00:20:41,956 --> 0:20:43,976
另一个进行追踪的视图构建器

524
00:20:48,046 --> 0:20:49,566
现在我们已经理解了

525
00:20:49,726 --> 0:20:51,316
这段代码 让我们回过头来

526
00:20:51,316 --> 0:20:52,786
深入了解一下 SwiftUI

527
00:20:52,786 --> 0:20:55,766
为什么以这种方式定义自定义视图

528
00:20:57,286 --> 0:20:58,736
让我们从视图是如何能

529
00:20:58,796 --> 0:21:01,716
遵循视图协议的结构开始讲

530
00:20:58,796 --> 0:21:01,716
遵循视图协议的结构开始讲

531
00:21:02,466 --> 0:21:04,066
如果你用过 UIKit 或者

532
00:21:04,066 --> 0:21:06,456
AppKit 你可能已经

533
00:21:06,456 --> 0:21:07,786
习惯于将视图定义为

534
00:21:07,786 --> 0:21:09,696
用于将视图定义为继承

535
00:21:09,696 --> 0:21:12,176
公共视图超类的类

536
00:21:12,256 --> 0:21:14,076
而不是符合协议的结构

537
00:21:14,546 --> 0:21:17,686
例如 UIKit 中的自定义

538
00:21:17,686 --> 0:21:21,546
视图继承了 UIView 超类

539
00:21:22,556 --> 0:21:24,736
UIView 为 alpha 和

540
00:21:24,736 --> 0:21:26,076
backgroundColor 等常见

541
00:21:26,076 --> 0:21:27,356
视图属性定义了存储位置

542
00:21:27,906 --> 0:21:30,886
假设我们不用 SwiftUI

543
00:21:30,886 --> 0:21:33,636
而用 UIKit 来构建 OrderHistory

544
00:21:33,636 --> 0:21:36,586
我们的自定义视图将

545
00:21:36,586 --> 0:21:38,316
继承 UIView 的存储属性

546
00:21:38,556 --> 0:21:39,856
并为它自己的自定义

547
00:21:39,856 --> 0:21:41,506
行为添加更多的属性

548
00:21:43,116 --> 0:21:46,346
那么 SwiftUI 和这个有什么不同呢

549
00:21:46,676 --> 0:21:47,736
请记住 在 SwiftUI 中

550
00:21:48,486 --> 0:21:50,146
我们将这些相同类型的

551
00:21:50,146 --> 0:21:51,816
公共视图属性表示为单独的修饰符

552
00:21:51,816 --> 0:21:53,836
就像我们对不透明度

553
00:21:53,836 --> 0:21:55,416
和背景所做的那样

554
00:21:55,986 --> 0:21:59,286
每个修饰符都创建了自己的视图

555
00:22:00,536 --> 0:22:02,216
这意味着这些属性的

556
00:22:02,546 --> 0:22:03,856
存储位置 分布在我们的

557
00:22:03,906 --> 0:22:05,456
视图层级架构中

558
00:22:05,456 --> 0:22:07,206
的每个修饰符视图中

559
00:22:07,206 --> 0:22:09,416
而不是被每个

560
00:22:09,416 --> 0:22:12,046
单独的视图继承

561
00:22:13,576 --> 0:22:14,936
现在 这能让我们的视图

562
00:22:14,936 --> 0:22:16,856
变得更小 优化其存储空间

563
00:22:16,856 --> 0:22:19,636
以满足其各自的用途

564
00:22:22,046 --> 0:22:23,366
在这个世界上

565
00:22:23,366 --> 0:22:25,336
让视图成为协议是非常

566
00:22:25,336 --> 0:22:27,126
有意义的 因为它不再

567
00:22:27,126 --> 0:22:28,956
需要为所有视图

568
00:22:28,956 --> 0:22:31,066
提供公共存储模板

569
00:22:31,176 --> 0:22:34,126
但这个视图协议实际的用途是什么呢

570
00:22:34,626 --> 0:22:35,976
让我们记住

571
00:22:35,976 --> 0:22:37,796
视图的概念定义

572
00:22:38,946 --> 0:22:41,296
视图定义了 UI 的一部分

573
00:22:41,356 --> 0:22:45,076
我们通过组合小视图来

574
00:22:45,076 --> 0:22:46,716
构建更大的视图

575
00:22:47,216 --> 0:22:50,506
这就是视图协议的作用

576
00:22:51,306 --> 0:22:52,716
它定义了一个视图架构

577
00:22:52,716 --> 0:22:54,446
给了它一个名称

578
00:22:54,446 --> 0:22:55,986
这样就可以组合

579
00:22:55,986 --> 0:22:58,366
并重用你的整个 App

580
00:22:59,026 --> 0:23:00,956
每个具体类型的视图

581
00:22:59,026 --> 0:23:00,956
每个具体类型的视图

582
00:23:01,266 --> 0:23:03,506
只是一个封装的其他视图

583
00:23:03,506 --> 0:23:04,886
代表其内容在其

584
00:23:04,886 --> 0:23:06,616
主体属性和所有

585
00:23:07,776 --> 0:23:09,516
必需的输入来创建

586
00:23:09,666 --> 0:23:12,386
这一由其属性呈现的视图

587
00:23:15,116 --> 0:23:16,916
现在实际协议

588
00:23:16,916 --> 0:23:18,906
只定义了传回另一种

589
00:23:19,176 --> 0:23:20,916
视图的主体属性

590
00:23:23,076 --> 0:23:24,736
但是仔细看一下

591
00:23:24,736 --> 0:23:26,416
这个定义 有些人

592
00:23:26,416 --> 0:23:29,726
可能会问这不是递归的吗

593
00:23:31,336 --> 0:23:33,246
如果我有一个视图

594
00:23:33,246 --> 0:23:35,186
它将 body 定义为

595
00:23:35,186 --> 0:23:38,256
另一种视图 那么这个视图

596
00:23:38,256 --> 0:23:39,306
将把它的 body

597
00:23:39,306 --> 0:23:41,976
定义为另一种视图

598
00:23:42,196 --> 0:23:44,686
它必须要结束 对吧

599
00:23:44,686 --> 0:23:47,746
它不能永远进行下去

600
00:23:50,046 --> 0:23:51,176
这样做的原因是

601
00:23:51,176 --> 0:23:54,746
SwiftUI 提供了多种原始视图

602
00:23:55,616 --> 0:23:56,756
即没有任何

603
00:23:56,756 --> 0:23:59,756
内容的视图

604
00:23:59,756 --> 0:24:01,736
这些视图表示所有其他

605
00:23:59,756 --> 0:24:01,736
这些视图表示所有其他

606
00:24:01,736 --> 0:24:03,676
视图都构建在这些

607
00:24:03,676 --> 0:24:04,976
原子构建块之上

608
00:24:07,046 --> 0:24:09,046
我们已经看到了文本

609
00:24:09,046 --> 0:24:10,626
图像是原始视图的

610
00:24:10,626 --> 0:24:11,876
另一个例子

611
00:24:13,336 --> 0:24:15,426
SwiftUI 还提供了

612
00:24:15,586 --> 0:24:16,596
用于绘制颜色和

613
00:24:16,596 --> 0:24:18,246
形状等基本元素和像

614
00:24:18,246 --> 0:24:19,276
Spacer 一样的基元

615
00:24:19,676 --> 0:24:23,096
实际上 你可以用

616
00:24:23,096 --> 0:24:25,196
SwiftUI 中的原始视图

617
00:24:25,196 --> 0:24:26,736
来绘制一些非常复杂的图形

618
00:24:27,766 --> 0:24:28,936
要了解更多这方面的内容

619
00:24:29,206 --> 0:24:30,166
请大家看一下演讲

620
00:24:30,366 --> 0:24:31,976
《Building Custom Views in SwiftUI》

621
00:24:35,066 --> 0:24:36,156
我们的示例使用了文本

622
00:24:37,256 --> 0:24:38,866
但是我们的列表实际上

623
00:24:38,866 --> 0:24:40,836
添加了它自己的原始视图

624
00:24:40,836 --> 0:24:42,326
可以把它视为我们

625
00:24:42,326 --> 0:24:42,976
每一行之间的分隔符

626
00:24:46,066 --> 0:24:46,976
现在我们还可以看到

627
00:24:46,976 --> 0:24:48,246
自定义视图被定义为

628
00:24:48,446 --> 0:24:49,416
struct 而不是类

629
00:24:49,496 --> 0:24:51,166
这又回到了 SwiftUI

630
00:24:51,166 --> 0:24:53,176
中定义视图的方式

631
00:24:54,346 --> 0:24:55,606
在本例中 这表示

632
00:24:55,606 --> 0:24:58,106
视图不是我们使用

633
00:24:58,356 --> 0:25:00,346
基于命令事件的代码

634
00:24:58,356 --> 0:25:00,346
基于命令事件的代码

635
00:25:00,346 --> 0:25:02,976
随时间更新的永久目的

636
00:25:05,556 --> 0:25:07,756
相反 我们的视图被

637
00:25:07,886 --> 0:25:10,876
定义为其输入的函数

638
00:25:13,046 --> 0:25:14,096
因此 无论何时我们的输入

639
00:25:14,096 --> 0:25:16,506
发生了变化 SwiftUI

640
00:25:16,506 --> 0:25:18,746
都会再次调用主体属性

641
00:25:18,746 --> 0:25:19,976
来获取视图的更新版本

642
00:25:23,096 --> 0:25:24,766
我们这里用的 List

643
00:25:25,536 --> 0:25:26,896
是定义代码强大功能

644
00:25:26,896 --> 0:25:29,576
的一个很好的例子

645
00:25:29,766 --> 0:25:31,126
如果我们的 previousOrders 集合

646
00:25:31,126 --> 0:25:33,716
改变了 SwiftUI 将

647
00:25:33,876 --> 0:25:35,116
比较列表的新旧版本

648
00:25:35,116 --> 0:25:37,096
并根据更改内容

649
00:25:37,096 --> 0:25:39,506
高效地更新屏幕上

650
00:25:39,546 --> 0:25:40,646
呈现的结果

651
00:25:42,066 --> 0:25:43,996
比如 我一直在为

652
00:25:43,996 --> 0:25:45,416
我的 App 开发云同步

653
00:25:45,736 --> 0:25:47,196
对我来说 能够在我所有的

654
00:25:47,196 --> 0:25:48,776
设备上都能使用牛油果吐司

655
00:25:48,776 --> 0:25:51,536
的相关数据至关重要

656
00:25:52,586 --> 0:25:53,486
让我们看看如果另一个

657
00:25:53,486 --> 0:25:55,586
设备从我们的历史记录中

658
00:25:55,586 --> 0:25:56,916
添加和删除订单会发生什么

659
00:25:59,356 --> 0:26:00,946
大家看到在右边的是

660
00:25:59,356 --> 0:26:00,946
大家看到在右边的是

661
00:26:00,946 --> 0:26:03,056
SwiftUI 自动区分

662
00:26:03,306 --> 0:26:04,506
集合中的更改

663
00:26:05,086 --> 0:26:07,036
并合成插入和删除操作

664
00:26:07,036 --> 0:26:08,636
然后把它们用默认

665
00:26:08,636 --> 0:26:11,216
动画呈现出来

666
00:26:12,126 --> 0:26:13,676
这些都是无需编写

667
00:26:13,676 --> 0:26:15,426
任何额外代码就可以

668
00:26:15,426 --> 0:26:16,956
免费获得的功能

669
00:26:17,516 --> 0:26:25,546
[掌声]

670
00:26:26,046 --> 0:26:26,566
这个功能真的很赞

671
00:26:26,966 --> 0:26:29,556
这个功能很实用的原因在于

672
00:26:29,556 --> 0:26:31,306
你不需要自己一直

673
00:26:31,306 --> 0:26:33,076
亲自管理呈现状态

674
00:26:34,136 --> 0:26:36,086
现在你可以根据主体属性

675
00:26:36,146 --> 0:26:38,426
中的当前数据为

676
00:26:38,426 --> 0:26:40,896
视图生成新值

677
00:26:43,046 --> 0:26:44,666
你可以让 SwiftUI

678
00:26:44,666 --> 0:26:46,646
为你在这两个版本之间

679
00:26:46,646 --> 0:26:47,966
生成必要的更改

680
00:26:50,066 --> 0:26:51,706
这就是定义代码的强大之处

681
00:26:54,236 --> 0:26:55,126
那么让我们继续来构建

682
00:26:55,126 --> 0:26:55,946
orderHistory 视图的剩余部分

683
00:26:56,156 --> 0:26:57,536
如果大家回想一下 我们最初

684
00:26:57,536 --> 0:26:59,466
的设计就包含了这些图标

685
00:26:59,466 --> 0:27:00,776
用来在订单中

686
00:26:59,466 --> 0:27:00,776
用来在订单中

687
00:27:01,206 --> 0:27:02,956
添加额外的配料

688
00:27:03,096 --> 0:27:04,166
比如盐和红辣椒片

689
00:27:05,136 --> 0:27:07,026
让我们从盐的图标开始

690
00:27:07,906 --> 0:27:09,396
首先 我们将在文本后面添加

691
00:27:09,396 --> 0:27:11,266
一个带有 Spacer 的水平栈

692
00:27:12,826 --> 0:27:14,826
然后我会在订单中

693
00:27:14,826 --> 0:27:16,746
需要盐时给大家展示我的

694
00:27:16,826 --> 0:27:17,536
SaltIcon 视图

695
00:27:20,176 --> 0:27:21,306
正如你在这段代码中所看到的

696
00:27:22,166 --> 0:27:23,406
我们前面讨论过的 ViewBuilder

697
00:27:23,406 --> 0:27:25,316
语法允许我们

698
00:27:25,316 --> 0:27:27,676
使用自然控制流

699
00:27:27,676 --> 0:27:29,426
比如 if 语句在视图

700
00:27:29,426 --> 0:27:31,356
应该包含在栈中时

701
00:27:31,356 --> 0:27:32,316
以定义的方式来定义视图

702
00:27:35,476 --> 0:27:36,656
在定义性代码中

703
00:27:36,686 --> 0:27:38,616
使用这样的 if 语法

704
00:27:38,956 --> 0:27:39,946
非常自然

705
00:27:40,666 --> 0:27:42,296
但是也还有其他方法

706
00:27:42,296 --> 0:27:43,976
可以在视图中编写条件代码

707
00:27:44,386 --> 0:27:45,686
重点是要选择正确的工具才能

708
00:27:45,686 --> 0:27:48,006
在屏幕上得到正确的结果

709
00:27:48,316 --> 0:27:49,986
让我们看一个简单的例子

710
00:27:49,986 --> 0:27:50,696
来理解一下我的意思

711
00:27:51,286 --> 0:27:53,976
我为我们的 App 新建了

712
00:27:53,976 --> 0:27:55,486
另一个屏幕 你可以选择

713
00:27:55,486 --> 0:27:57,976
正常和倒装的 AppIcon

714
00:27:59,726 --> 0:28:01,676
我的第一步是编写

715
00:27:59,726 --> 0:28:01,676
我的第一步是编写

716
00:28:01,676 --> 0:28:04,066
一个自定义视图

717
00:28:04,066 --> 0:28:05,846
它接受倒装状态作为输入

718
00:28:05,846 --> 0:28:07,466
并根据我的状态应用

719
00:28:07,466 --> 0:28:11,246
一个旋转修饰符

720
00:28:13,386 --> 0:28:15,186
然而 当我们试图翻转这个

721
00:28:15,186 --> 0:28:16,556
图标时 会看到一个不太

722
00:28:16,556 --> 0:28:19,886
美观的交叉淡入动画

723
00:28:20,116 --> 0:28:21,686
这是因为我们的代码

724
00:28:21,736 --> 0:28:23,546
让 SwiftUI 在两种

725
00:28:23,546 --> 0:28:25,606
不同的视图之间切换

726
00:28:26,716 --> 0:28:28,816
包含在旋转修饰符中的视图

727
00:28:28,816 --> 0:28:32,756
相对于 AppIcon 其本身

728
00:28:33,326 --> 0:28:37,426
默认情况下 SwiftUI 会在

729
00:28:37,426 --> 0:28:40,676
添加和删除视图时淡入和淡出视图

730
00:28:41,596 --> 0:28:42,506
这就是为什么我们会得到

731
00:28:42,506 --> 0:28:43,966
这种交叉淡入效果

732
00:28:46,156 --> 0:28:47,426
现在我想让图标

733
00:28:47,426 --> 0:28:49,156
在翻转时旋转

734
00:28:50,136 --> 0:28:52,556
为了达到这一效果

735
00:28:52,556 --> 0:28:54,096
我要用一个 rotationEffect

736
00:28:54,096 --> 0:28:56,786
修饰语句来定义一个视图

737
00:28:57,126 --> 0:28:59,526
并根据自身状态来对它的输入进行配置

738
00:29:00,116 --> 0:29:02,986
通过在修饰语句中

739
00:29:02,986 --> 0:29:05,026
定义我们的条件

740
00:29:05,026 --> 0:29:06,136
SwiftUI 可以提供

741
00:29:06,136 --> 0:29:08,266
更好的默认动画

742
00:29:08,266 --> 0:29:09,186
将图标旋转到新的方向

743
00:29:10,396 --> 0:29:11,856
这里需要学习的是

744
00:29:11,856 --> 0:29:12,736
你应该尽可能地

745
00:29:12,736 --> 0:29:15,066
把你的条件添加到

746
00:29:15,066 --> 0:29:16,306
修改语句中

747
00:29:16,996 --> 0:29:18,286
因为这可以帮助 SwiftUI

748
00:29:19,126 --> 0:29:20,476
检测这些变化并为你提供

749
00:29:20,476 --> 0:29:21,566
更好的动画效果

750
00:29:23,116 --> 0:29:24,926
如果你的目的是在层级

751
00:29:24,926 --> 0:29:26,806
架构中添加或删除视图

752
00:29:27,106 --> 0:29:28,666
那我们之前看到的

753
00:29:28,706 --> 0:29:31,316
if 语法就十分有用了

754
00:29:36,046 --> 0:29:37,136
回到我们的示例 App

755
00:29:37,316 --> 0:29:39,886
我们的 OrderHistory 

756
00:29:40,006 --> 0:29:41,166
视图开始变大了

757
00:29:41,526 --> 0:29:42,686
所以最好能把它

758
00:29:42,686 --> 0:29:44,446
分解成更小的部分

759
00:29:45,226 --> 0:29:46,346
那么让我们试着将每个

760
00:29:46,346 --> 0:29:48,096
列表行的代码分解到它

761
00:29:48,096 --> 0:29:48,936
自己的自定义视图中

762
00:29:51,116 --> 0:29:52,166
首先 我将创建一个名为

763
00:29:52,166 --> 0:29:53,506
OrderCell 的新自定义视图

764
00:29:53,506 --> 0:29:56,356
现在这个视图需要一个

765
00:29:56,356 --> 0:29:58,436
body 部分 幸运的是

766
00:29:58,436 --> 0:30:00,326
我们已经在 OrderHistory

767
00:29:58,436 --> 0:30:00,326
我们已经在 OrderHistory

768
00:30:00,326 --> 0:30:02,296
视图的列表中构建了它

769
00:30:02,366 --> 0:30:03,936
下面我们把这段代码移过来

770
00:30:06,316 --> 0:30:09,176
为了生成 OrderCell 的主体

771
00:30:09,176 --> 0:30:10,836
我们需要为其输入数据

772
00:30:11,416 --> 0:30:12,616
我们还需要添加

773
00:30:12,616 --> 0:30:14,976
一个属性来表示它

774
00:30:16,156 --> 0:30:18,096
最后 我们将为

775
00:30:18,096 --> 0:30:19,396
列表中的每一行创建

776
00:30:19,396 --> 0:30:21,736
一个新视图实例

777
00:30:24,076 --> 0:30:25,746
这里的重点是我们能

778
00:30:25,746 --> 0:30:27,896
很容易地将 UI 分解成

779
00:30:27,896 --> 0:30:29,406
更小的部分并将代码

780
00:30:29,406 --> 0:30:31,466
分解成新的视图

781
00:30:32,106 --> 0:30:34,056
请记住 使用定义性代码

782
00:30:34,056 --> 0:30:36,046
来添加新的封装器视图

783
00:30:36,306 --> 0:30:38,436
实际上是可自由操作的

784
00:30:38,436 --> 0:30:40,526
因为 SwiftUI 会在后台

785
00:30:40,926 --> 0:30:41,766
对它进行优化

786
00:30:42,366 --> 0:30:44,656
所以重要的是

787
00:30:44,856 --> 0:30:46,136
你不需要再为

788
00:30:46,136 --> 0:30:48,096
得到更多成果并

789
00:30:48,096 --> 0:30:49,416
让 App 表现得更好

790
00:30:49,416 --> 0:30:51,566
和组织你的视图

791
00:30:51,566 --> 0:30:53,796
代码之间妥协

792
00:30:54,516 --> 0:31:01,736
[掌声]

793
00:30:54,516 --> 0:31:01,736
[掌声]

794
00:31:02,236 --> 0:31:03,386
所以 让我们以添加

795
00:31:03,386 --> 0:31:05,526
红辣椒粉图标来作为结束

796
00:31:06,126 --> 0:31:07,486
只要像之前那样加上

797
00:31:07,486 --> 0:31:09,446
另一个条件就可以了

798
00:31:10,616 --> 0:31:12,476
这是可行的 但它的

799
00:31:12,476 --> 0:31:13,396
可扩展性不是很好

800
00:31:13,896 --> 0:31:15,286
如果我们以后添加新的佐料

801
00:31:15,286 --> 0:31:17,306
我们将不得不在代码中添加

802
00:31:17,306 --> 0:31:18,726
带有新条件的佐料

803
00:31:18,726 --> 0:31:20,686
最棒的是可以

804
00:31:20,686 --> 0:31:24,406
有条件地从订单数据来

805
00:31:24,406 --> 0:31:26,716
生成一组图标

806
00:31:29,306 --> 0:31:30,226
要生成视图集合 可以

807
00:31:30,226 --> 0:31:32,576
使用 ForEach 视图

808
00:31:34,086 --> 0:31:35,976
就像我们的列表一样 ForEach

809
00:31:36,376 --> 0:31:38,316
会接受一组数据和一个 ViewBuilder

810
00:31:38,316 --> 0:31:40,266
后者将每个数据项显示到中

811
00:31:40,316 --> 0:31:42,076
它自己的视图

812
00:31:43,366 --> 0:31:46,056
但与列表不同的是 ForEach

813
00:31:46,056 --> 0:31:47,976
不添加任何自己的视觉效果

814
00:31:49,056 --> 0:31:51,116
而是将自己的

815
00:31:51,116 --> 0:31:53,076
内容添加到容器中

816
00:31:56,106 --> 0:31:57,206
所以这段代码要好得多

817
00:31:57,476 --> 0:31:58,626
因为现在我们订单的

818
00:31:58,746 --> 0:32:00,046
历史记录将在未来自动

819
00:31:58,746 --> 0:32:00,046
历史记录将在未来自动

820
00:32:00,046 --> 0:32:01,446
支持新的佐料

821
00:32:01,486 --> 0:32:03,776
而无需向视图添加任何代码

822
00:32:06,066 --> 0:32:07,116
比如 我们可以把鸡蛋

823
00:32:07,116 --> 0:32:08,686
添加为第三个图标

824
00:32:11,286 --> 0:32:13,236
退一步讲 我们

825
00:32:13,236 --> 0:32:14,806
只用十几行代码

826
00:32:14,806 --> 0:32:16,096
就能构建出

827
00:32:16,096 --> 0:32:18,066
这么多的功能

828
00:32:18,066 --> 0:32:19,306
是非常惊人的

829
00:32:20,476 --> 0:32:22,386
更了不起的是

830
00:32:22,456 --> 0:32:24,346
还有很多代码我们

831
00:32:24,346 --> 0:32:25,226
都不需要写了

832
00:32:26,776 --> 0:32:28,026
我们已经看到了 SwiftUI

833
00:32:28,256 --> 0:32:29,866
是如何自动处理数据

834
00:32:29,866 --> 0:32:31,956
的更改 它甚至能在

835
00:32:31,956 --> 0:32:33,476
添加和删除数据时

836
00:32:33,476 --> 0:32:34,396
插入默认动画

837
00:32:37,046 --> 0:32:38,736
但我还没有提到我们的

838
00:32:38,736 --> 0:32:40,496
App 也能适应动态类型

839
00:32:41,686 --> 0:32:43,066
它甚至还支持深色模式

840
00:32:43,266 --> 0:32:44,896
这些技术支持都是免费的

841
00:32:44,896 --> 0:32:46,976
而且我们不需要编写任何额外的代码

842
00:32:48,516 --> 0:32:55,226
[掌声]

843
00:32:55,726 --> 0:32:57,566
这非常棒 这就是我们所说的

844
00:32:57,566 --> 0:32:59,566
SwiftUI 能为你提供一条

845
00:32:59,566 --> 0:33:01,886
创建 App 的捷径的意思

846
00:32:59,566 --> 0:33:01,886
创建 App 的捷径的意思

847
00:33:04,106 --> 0:33:05,716
以上就是用 SwiftUI

848
00:33:05,716 --> 0:33:07,426
创建自定义视图的方法

849
00:33:08,786 --> 0:33:10,256
现在我想邀请

850
00:33:10,256 --> 0:33:12,116
我的同事 Taylor

851
00:33:12,306 --> 0:33:13,716
来和各位谈谈如何

852
00:33:13,996 --> 0:33:15,416
充分利用 SwiftUI 

853
00:33:15,416 --> 0:33:18,596
为大家提供更有用的功能

854
00:33:19,516 --> 0:33:24,656
[掌声]

855
00:33:25,156 --> 0:33:28,646
&gt;&gt; 感谢 Matt 大家好

856
00:33:29,396 --> 0:33:31,376
现在 我们对自己的 App

857
00:33:31,376 --> 0:33:33,216
都有了一个良好开端

858
00:33:33,216 --> 0:33:34,276
Matt 构建了初始订单

859
00:33:34,276 --> 0:33:35,586
表单和历史屏的显示页面

860
00:33:35,586 --> 0:33:37,516
但有一个明显的问题就是

861
00:33:37,516 --> 0:33:38,746
它看起来不太像我们

862
00:33:39,006 --> 0:33:40,536
习惯的 iOS App

863
00:33:40,886 --> 0:33:41,986
它们一般不是这些简单的

864
00:33:41,986 --> 0:33:43,866
垂直控件栈

865
00:33:44,756 --> 0:33:46,246
通常 这种类型的 UI

866
00:33:46,246 --> 0:33:47,616
会更像大家在右边看到的那样

867
00:33:47,796 --> 0:33:49,456
最大的区别之一是

868
00:33:49,456 --> 0:33:51,126
控件周围的容器

869
00:33:51,206 --> 0:33:52,796
本身具有这种标准化

870
00:33:54,006 --> 0:33:56,176
的组列表样式

871
00:33:57,056 --> 0:33:59,816
在 SwiftUI 里我们称它为 Form

872
00:33:59,816 --> 0:34:02,406
Form 是一个容器

873
00:33:59,816 --> 0:34:02,406
Form 是一个容器

874
00:34:02,406 --> 0:34:03,926
就像 VStack 一样

875
00:34:03,926 --> 0:34:05,536
但是它是专门为构建

876
00:34:05,596 --> 0:34:06,696
异构控件的这些部分

877
00:34:06,726 --> 0:34:08,616
而构建的 无论在什么

878
00:34:08,616 --> 0:34:10,436
平台上它都提供

879
00:34:10,786 --> 0:34:11,956
标准的外观和体验

880
00:34:14,045 --> 0:34:15,916
现在我们已经定义了

881
00:34:15,916 --> 0:34:17,476
我们想要在自己的

882
00:34:17,476 --> 0:34:18,376
App 中的功能集

883
00:34:19,025 --> 0:34:21,726
标题 Toggle Stepper 还有 Button

884
00:34:23,036 --> 0:34:24,616
我们所做的就是将

885
00:34:24,616 --> 0:34:26,186
容器本身从现有的

886
00:34:26,186 --> 0:34:29,005
VStack 更改为一个 Form

887
00:34:29,005 --> 0:34:30,936
然后我们就可以很容易地

888
00:34:30,936 --> 0:34:33,255
添加一些部分来划分内容

889
00:34:34,565 --> 0:34:35,596
正如 Matt 前面所讨论的

890
00:34:35,596 --> 0:34:37,596
我们的代码会继续

891
00:34:37,596 --> 0:34:39,206
显示反映生成的 UI

892
00:34:40,346 --> 0:34:41,646
由于我们控件的核心定义

893
00:34:41,646 --> 0:34:43,696
没有改变 我们的代码

894
00:34:43,696 --> 0:34:44,946
实际上也不需要改变

895
00:34:45,985 --> 0:34:47,106
只要将容器从

896
00:34:47,106 --> 0:34:49,356
VStack 更改为

897
00:34:49,356 --> 0:34:50,596
Form 控件就会

898
00:34:50,596 --> 0:34:52,156
自动适应该上下文

899
00:34:52,966 --> 0:34:54,045
从整体背景和

900
00:34:54,045 --> 0:34:55,666
可滚动性到分隔每

901
00:34:55,806 --> 0:34:57,256
个控件的行 甚至是

902
00:34:57,566 --> 0:34:59,196
按钮之类的样式

903
00:35:00,316 --> 0:35:02,316
这是 SwiftUI

904
00:35:02,316 --> 0:35:03,816
再次关注渲染

905
00:35:03,816 --> 0:35:05,626
这些元素的细节

906
00:35:05,626 --> 0:35:07,786
并能让我们专注

907
00:35:07,786 --> 0:35:09,846
于 App 的功能

908
00:35:11,676 --> 0:35:12,986
还有一个从屏幕快照

909
00:35:12,986 --> 0:35:15,546
上看不见的细微的变化

910
00:35:16,556 --> 0:35:17,966
让我们仔细看一下按钮

911
00:35:17,966 --> 0:35:19,216
你可以看到对齐 填充

912
00:35:19,216 --> 0:35:20,486
和按钮周围的装饰都改变了

913
00:35:20,486 --> 0:35:24,436
点按状态也展示出了

914
00:35:24,436 --> 0:35:25,996
你从这样的 UI 中

915
00:35:25,996 --> 0:35:27,346
所期待高亮效果

916
00:35:27,346 --> 0:35:32,546
同时显示了相同的按钮定义

917
00:35:34,116 --> 0:35:35,536
正如你可能期望的那样

918
00:35:35,536 --> 0:35:36,516
这个相同的定义在其他

919
00:35:36,516 --> 0:35:37,936
上下文中或其他平台上

920
00:35:38,306 --> 0:35:39,316
也适用而且具有多种

921
00:35:39,316 --> 0:35:41,896
可能的外观和体验

922
00:35:42,126 --> 0:35:43,076
按钮还具有我们

923
00:35:43,076 --> 0:35:44,556
在其他视图中看到的相同的

924
00:35:44,556 --> 0:35:46,816
可组合性的固有能力

925
00:35:47,396 --> 0:35:48,286
标签当然不限于

926
00:35:48,286 --> 0:35:51,016
文本 它也可以是图像形式

927
00:35:51,016 --> 0:35:52,696
它可以是我们定义的

928
00:35:52,696 --> 0:35:54,996
任何类型的视图

929
00:35:54,996 --> 0:35:56,656
甚至可以是图像和文本

930
00:35:56,656 --> 0:35:58,876
的显式垂直栈

931
00:35:59,516 --> 0:36:05,846
[掌声]

932
00:35:59,516 --> 0:36:05,846
[掌声]

933
00:36:06,346 --> 0:36:07,856
这种继承的可组合性

934
00:36:07,856 --> 0:36:08,946
带来了各种可能性

935
00:36:08,946 --> 0:36:12,186
并同时使按钮能够被简化为

936
00:36:12,186 --> 0:36:14,556
两个基本属性

937
00:36:15,576 --> 0:36:16,556
即它在激活时

938
00:36:16,556 --> 0:36:18,036
执行的操作和

939
00:36:18,176 --> 0:36:19,256
描述该操作的标签

940
00:36:20,596 --> 0:36:21,756
这就是按钮的

941
00:36:21,756 --> 0:36:22,886
整个 API 表面

942
00:36:24,046 --> 0:36:25,176
当然 这并不是说

943
00:36:25,176 --> 0:36:26,496
只有这两种方法

944
00:36:26,546 --> 0:36:27,996
可以自定义按钮

945
00:36:28,736 --> 0:36:29,556
就像我们之前看到的

946
00:36:29,556 --> 0:36:31,426
并且将继续看到的

947
00:36:31,476 --> 0:36:33,346
上下文和修饰符都支持

948
00:36:33,346 --> 0:36:35,036
在 macOS 上添加更多

949
00:36:35,036 --> 0:36:36,716
丰富的行为 从禁用状态

950
00:36:36,716 --> 0:36:38,446
到按钮 样式甚至

951
00:36:38,446 --> 0:36:39,196
控制的大小

952
00:36:40,016 --> 0:36:41,826
但是这个核心定义加上

953
00:36:41,826 --> 0:36:44,336
适应行为可以支持任何类型的按钮

954
00:36:45,196 --> 0:36:46,366
随着时间的推移

955
00:36:46,366 --> 0:36:48,186
在不同的平台上 我们看到了

956
00:36:48,186 --> 0:36:49,166
很多不同的按钮

957
00:36:49,956 --> 0:36:51,006
它们的变化不仅

958
00:36:51,006 --> 0:36:52,756
取决于外观 还取决于

959
00:36:52,756 --> 0:36:54,686
我们与它们的互动方式

960
00:36:54,686 --> 0:36:56,376
从点按到轻点 到通过

961
00:36:56,376 --> 0:36:57,726
开关控制或 Siri Remote 遥控器

962
00:36:57,726 --> 0:37:00,206
来进行选择 但它们

963
00:36:57,726 --> 0:37:00,206
来进行选择 但它们

964
00:37:00,206 --> 0:37:02,016
都可以归结为一个

965
00:37:02,016 --> 0:37:03,296
操作和一个标签

966
00:37:05,096 --> 0:37:08,736
就像按钮一样 其中的

967
00:37:08,736 --> 0:37:10,666
每个控件都具有相同的

968
00:37:10,666 --> 0:37:11,966
适应行为能力

969
00:37:13,276 --> 0:37:15,066
控件描述的是它们

970
00:37:15,066 --> 0:37:17,126
所服务的目的或角色 而不是它们的外观

971
00:37:17,126 --> 0:37:18,816
这使得它们可以

972
00:37:18,816 --> 0:37:19,896
在不同的环境

973
00:37:19,896 --> 0:37:21,886
和平台上重用并适应

974
00:37:21,886 --> 0:37:22,716
这些情况

975
00:37:23,696 --> 0:37:24,606
这也使得他们有

976
00:37:24,606 --> 0:37:26,716
更小的 API 表面来满足

977
00:37:26,716 --> 0:37:27,606
这个确切的角色

978
00:37:27,606 --> 0:37:29,726
不过我们同时还需要

979
00:37:29,726 --> 0:37:31,426
减少控件 而不是为可能

980
00:37:31,426 --> 0:37:32,746
需要在其中使用的每个

981
00:37:32,746 --> 0:37:34,206
上下文都配置一个控件

982
00:37:35,726 --> 0:37:37,386
同时仍然支持非常

983
00:37:37,386 --> 0:37:38,766
强大的自定义功能

984
00:37:39,046 --> 0:37:40,356
比如完全重新定义

985
00:37:40,356 --> 0:37:42,826
App 中按钮的外观

986
00:37:43,756 --> 0:37:46,016
现在我们看到了这种

987
00:37:46,016 --> 0:37:47,406
适应功能如何让我们

988
00:37:47,406 --> 0:37:49,206
快速地从一堆简单的控件

989
00:37:49,486 --> 0:37:51,546
转换为系统表单的标准外观和体验

990
00:37:52,416 --> 0:37:54,516
但同样的适应性也使我们能够将

991
00:37:54,516 --> 0:37:55,996
这些控制带到其他平台上

992
00:37:56,446 --> 0:37:58,126
比如 watchOS 这样我们就可以

993
00:37:58,126 --> 0:37:59,316
在忙碌中快速点到吐司

994
00:38:01,596 --> 0:38:02,456
现在我们已经在使用的

995
00:38:02,456 --> 0:38:04,236
另一个控件是 Toggle

996
00:38:04,956 --> 0:38:06,126
各位已经看到了 SwiftUI

997
00:38:06,126 --> 0:38:07,916
中的 Toggle 不仅仅

998
00:38:07,916 --> 0:38:09,006
只是一个字面上的转换

999
00:38:09,696 --> 0:38:11,586
不管它在什么

1000
00:38:11,586 --> 0:38:12,686
平台上都是这样的

1001
00:38:13,616 --> 0:38:15,086
就像按钮一样

1002
00:38:15,086 --> 0:38:16,926
Toggle 有两个基本属性

1003
00:38:16,926 --> 0:38:18,486
即开或关 以及描述

1004
00:38:18,486 --> 0:38:20,596
Toggle 整体目的的标签

1005
00:38:21,656 --> 0:38:22,736
同样 这也在结构

1006
00:38:22,876 --> 0:38:26,916
本身有所呈现与按钮的一个明显

1007
00:38:26,916 --> 0:38:28,226
区别是 它不执行操作

1008
00:38:28,226 --> 0:38:31,816
而是执行与 Boolean 值的绑定

1009
00:38:32,336 --> 0:38:33,876
这个绑定是到

1010
00:38:33,916 --> 0:38:35,176
App 中某个状态

1011
00:38:35,176 --> 0:38:36,706
或模型的直接

1012
00:38:36,706 --> 0:38:38,176
读写连接 允许

1013
00:38:38,176 --> 0:38:39,706
显示 Toggle 和

1014
00:38:39,706 --> 0:38:41,366
更新该状态或模型

1015
00:38:41,366 --> 0:38:42,966
无需手动响应某个操作

1016
00:38:42,966 --> 0:38:44,636
去提取值并在模型中设置它

1017
00:38:45,246 --> 0:38:46,956
它会为你把一切搞定

1018
00:38:48,516 --> 0:38:54,566
[掌声]

1019
00:38:55,066 --> 0:38:56,446
现在 Toggle 和其他的

1020
00:38:56,446 --> 0:38:58,426
控件在另一个非常重要的

1021
00:38:58,426 --> 0:38:59,616
方面也有一定适应性

1022
00:39:00,606 --> 0:39:01,986
对于一些人来说 UI

1023
00:39:01,986 --> 0:39:03,816
是一种视觉体验

1024
00:39:03,816 --> 0:39:04,906
而其他人可能主要使用

1025
00:39:04,906 --> 0:39:06,736
其他感官来体验

1026
00:39:06,736 --> 0:39:07,846
相同的 UI

1027
00:39:07,846 --> 0:39:10,436
例如 视力受损的人

1028
00:39:10,436 --> 0:39:11,926
可以使用旁白

1029
00:39:11,926 --> 0:39:13,306
进行导航 并使用音频

1030
00:39:13,306 --> 0:39:15,106
与 App 进行互动

1031
00:39:15,106 --> 0:39:16,996
对于没使用的人

1032
00:39:16,996 --> 0:39:18,116
这就是开始使用

1033
00:39:18,116 --> 0:39:19,566
旁白的样子

1034
00:39:19,956 --> 0:39:21,016
&gt;&gt; 打开旁白 

1035
00:39:22,406 --> 0:39:23,876
&gt;&gt; 目前旁白只是

1036
00:39:23,876 --> 0:39:25,196
系统范围内的功能之一

1037
00:39:25,196 --> 0:39:26,896
它能将你的 UI 以这些

1038
00:39:26,896 --> 0:39:28,706
替代形式呈现出来

1039
00:39:29,326 --> 0:39:30,766
而且 由于 Toggle 和

1040
00:39:30,766 --> 0:39:32,056
其他控件是根据

1041
00:39:32,056 --> 0:39:34,216
它们的用途定义的 并且包含了

1042
00:39:34,216 --> 0:39:35,816
我们可解释的标签

1043
00:39:35,816 --> 0:39:38,206
所以它们可以自动适应这些功能

1044
00:39:39,216 --> 0:39:40,176
所以当我们使用旁白

1045
00:39:40,176 --> 0:39:41,236
导航到这个切换时会听到

1046
00:39:41,946 --> 0:39:44,126
&gt;&gt; 加盐 开关按钮

1047
00:39:44,516 --> 0:39:48,236
双击以切换设置

1048
00:39:48,806 --> 0:39:50,846
&gt;&gt; 能够显示相同的标签

1049
00:39:50,846 --> 0:39:52,766
即使标签不是

1050
00:39:52,766 --> 0:39:53,716
文本也是如此

1051
00:39:54,606 --> 0:39:56,166
下面关于图像 如果图像

1052
00:39:56,166 --> 0:39:57,476
名称不够具备描述性

1053
00:39:57,696 --> 0:39:58,806
你可以直接在图像旁

1054
00:39:58,806 --> 0:40:00,886
直接提供一个标签

1055
00:39:58,806 --> 0:40:00,886
直接提供一个标签

1056
00:40:03,046 --> 0:40:04,746
当然也可以全部自定义

1057
00:40:05,151 --> 0:40:07,151
[掌声]

1058
00:40:07,286 --> 0:40:08,216
这的确非常激动人心

1059
00:40:09,041 --> 0:40:11,041
[掌声]

1060
00:40:11,066 --> 0:40:13,386
当然 即使是完全自定义的视图

1061
00:40:13,386 --> 0:40:14,426
你也总是可以使用辅助功能

1062
00:40:14,426 --> 0:40:16,706
标签修饰符直接地提供标签

1063
00:40:18,086 --> 0:40:19,176
现在 除了旁白

1064
00:40:19,376 --> 0:40:20,706
这些信息还可以

1065
00:40:20,706 --> 0:40:22,186
用于其他功能 比如

1066
00:40:22,186 --> 0:40:24,276
iOS 和 macOS 上新的语音

1067
00:40:24,736 --> 0:40:26,096
这样我们就可以说“Tap Include Salt”

1068
00:40:26,146 --> 0:40:28,416
我们的 UI 就像预期的那样执行操作

1069
00:40:29,676 --> 0:40:30,646
确保你的 App 是

1070
00:40:30,646 --> 0:40:32,016
易于使用的 意味着它能和

1071
00:40:32,016 --> 0:40:32,906
所有这些不同的技术兼容

1072
00:40:32,906 --> 0:40:36,026
意味着每个人都可以使用你的 App

1073
00:40:36,026 --> 0:40:38,086
而且 SwiftUI 是有一定作用的

1074
00:40:39,676 --> 0:40:40,666
今年有一个很棒的演讲

1075
00:40:40,666 --> 0:40:41,626
将会详细介绍如何

1076
00:40:41,626 --> 0:40:43,116
确保 SwiftUI 的 App

1077
00:40:43,116 --> 0:40:45,976
是完全可访问的

1078
00:40:48,656 --> 0:40:49,766
现在 我们已经能够快速

1079
00:40:49,766 --> 0:40:50,916
构建这个初始基本接口

1080
00:40:50,916 --> 0:40:52,566
它具备所有我们

1081
00:40:52,566 --> 0:40:53,636
所期望的操作

1082
00:40:54,466 --> 0:40:57,066
动态类型 暗色模式和辅助功能

1083
00:40:57,066 --> 0:40:58,956
但是我们实际上

1084
00:40:58,956 --> 0:41:00,576
只为吐司本身添加了

1085
00:40:58,956 --> 0:41:00,576
只为吐司本身添加了

1086
00:41:00,576 --> 0:41:01,466
一些自定义选项

1087
00:41:02,476 --> 0:41:04,256
当然 大家都知道

1088
00:41:04,316 --> 0:41:05,636
专业的手工吐司

1089
00:41:05,636 --> 0:41:08,026
会有各种不同的面包类型

1090
00:41:08,026 --> 0:41:09,716
制作牛油果的方法

1091
00:41:09,716 --> 0:41:11,676
当然还有各种

1092
00:41:11,676 --> 0:41:13,056
酱料和辅料

1093
00:41:13,786 --> 0:41:15,826
要添加这些更高级

1094
00:41:15,826 --> 0:41:17,986
的配置选项 我们可以

1095
00:41:17,986 --> 0:41:19,386
从 macOS 的灵活性中

1096
00:41:19,386 --> 0:41:21,786
寻找一些灵感

1097
00:41:22,016 --> 0:41:23,026
或者我们可能想要

1098
00:41:23,026 --> 0:41:24,496
一个小的实用窗口让我们能

1099
00:41:24,496 --> 0:41:26,546
直接从我们的桌面上点吐司

1100
00:41:28,276 --> 0:41:29,576
你可以在这里看到

1101
00:41:29,576 --> 0:41:30,706
我们已经使用的

1102
00:41:30,706 --> 0:41:32,396
现有控件呈现了

1103
00:41:32,586 --> 0:41:34,376
macOS 的预期外观 即 Toggle 

1104
00:41:34,376 --> 0:41:35,446
Stepper 和按钮

1105
00:41:35,446 --> 0:41:37,036
但我们也有一些

1106
00:41:37,036 --> 0:41:38,666
额外的控件 可以让

1107
00:41:38,666 --> 0:41:39,646
我们选择面包的类型

1108
00:41:39,686 --> 0:41:42,676
添加的酱汁 以及

1109
00:41:42,706 --> 0:41:43,976
如何准备牛油果

1110
00:41:46,436 --> 0:41:49,436
这些都是 SwiftUI 中 Picker 控件的例子

1111
00:41:50,206 --> 0:41:51,906
Picker 是为了从

1112
00:41:51,906 --> 0:41:54,316
一组选项中选择一个值而设计的

1113
00:41:55,606 --> 0:41:56,796
Picker 显然比

1114
00:41:56,796 --> 0:41:58,206
其它控件复杂一些

1115
00:41:58,206 --> 0:42:00,196
它有三个核心属性

1116
00:41:58,206 --> 0:42:00,196
它有三个核心属性

1117
00:42:00,196 --> 0:42:01,416
而不是两个

1118
00:42:02,596 --> 0:42:03,456
即你可以从中选择的选项

1119
00:42:03,456 --> 0:42:05,356
当前从这些选项中

1120
00:42:05,356 --> 0:42:06,816
选择的选项以及描述

1121
00:42:06,946 --> 0:42:11,006
Picker 总体用途的标签

1122
00:42:11,186 --> 0:42:13,216
现在的选择是绑定

1123
00:42:13,796 --> 0:42:15,276
就像属性上的 Toggle 一样

1124
00:42:15,856 --> 0:42:17,016
这允许我们再次将其

1125
00:42:17,016 --> 0:42:19,256
直接连接到 Modeler 的状态

1126
00:42:19,346 --> 0:42:21,416
这种绑定的类型

1127
00:42:21,656 --> 0:42:23,376
对应于与每个选项

1128
00:42:23,456 --> 0:42:24,886
相关联的标记值

1129
00:42:25,926 --> 0:42:26,746
当其中一个选项被选中时

1130
00:42:26,746 --> 0:42:28,636
该标记值将被重新

1131
00:42:28,636 --> 0:42:29,826
写入选择并返回到

1132
00:42:30,096 --> 0:42:31,556
我们的模型中 所有这些

1133
00:42:31,556 --> 0:42:32,946
都是自动完成的

1134
00:42:35,046 --> 0:42:36,676
当然 macOS 上的

1135
00:42:36,776 --> 0:42:38,656
Picker 并不总是显示为弹出按钮

1136
00:42:39,416 --> 0:42:40,736
在这个单独的窗口中

1137
00:42:40,736 --> 0:42:41,766
我们可以看到两种不同风格的

1138
00:42:41,766 --> 0:42:44,356
Picker 一个是弹出按钮

1139
00:42:44,356 --> 0:42:45,726
和一个 radioGroup

1140
00:42:46,396 --> 0:42:47,926
虽然 SwiftUI 自动

1141
00:42:47,926 --> 0:42:49,476
提供了一种默认样式

1142
00:42:49,476 --> 0:42:50,686
能够适应控件的使用位置

1143
00:42:50,686 --> 0:42:53,176
但是控件本身也具有

1144
00:42:53,176 --> 0:42:54,756
自定义样式的能力

1145
00:42:54,756 --> 0:42:56,486
既可以自定义系统

1146
00:42:56,486 --> 0:42:58,136
提供的样式 也可以自定义

1147
00:42:58,136 --> 0:42:59,246
构建的样式

1148
00:43:00,336 --> 0:43:01,436
在本例中 我们希望

1149
00:43:01,436 --> 0:43:02,996
重写默认样式并

1150
00:43:02,996 --> 0:43:04,636
强制直接使用 radioGroup

1151
00:43:04,976 --> 0:43:05,946
因为我们知道我们

1152
00:43:05,946 --> 0:43:07,106
只从两个选项中进行选择

1153
00:43:08,986 --> 0:43:10,336
现在我们可以考虑对

1154
00:43:10,336 --> 0:43:11,386
Spread 也进行同样的调整

1155
00:43:12,566 --> 0:43:13,636
但一开始可能只是

1156
00:43:13,636 --> 0:43:14,786
四种可能的简单组合

1157
00:43:14,786 --> 0:43:16,916
很快就能发展成

1158
00:43:16,916 --> 0:43:17,716
各式各样的组合

1159
00:43:18,466 --> 0:43:20,486
所以说到构建 Picker

1160
00:43:20,486 --> 0:43:22,826
我们显然不希望它

1161
00:43:22,826 --> 0:43:23,716
一个一个地展开这些选项

1162
00:43:23,716 --> 0:43:26,236
就像我们不希望

1163
00:43:26,236 --> 0:43:27,516
构建一个 UI 将它们

1164
00:43:27,516 --> 0:43:29,356
全部显示为单选按钮一样

1165
00:43:31,006 --> 0:43:32,406
我们已经看过使用 ForEach

1166
00:43:32,406 --> 0:43:33,826
构建数据驱动视图

1167
00:43:34,476 --> 0:43:35,666
因为每个选项都是

1168
00:43:35,776 --> 0:43:37,576
视图本身 我们也可以

1169
00:43:37,576 --> 0:43:40,546
在这里使用它 这样就好多了

1170
00:43:41,876 --> 0:43:42,846
下面我们将详细了解

1171
00:43:42,846 --> 0:43:44,406
Spread 的每一种情况

1172
00:43:44,406 --> 0:43:45,666
并创建一个新选项 其中

1173
00:43:45,666 --> 0:43:47,836
使用 Spread 的名称和其本身作为标记

1174
00:43:50,236 --> 0:43:56,676
现在 [掌声]

1175
00:43:57,176 --> 0:43:58,946
显然 Pickers 不仅仅

1176
00:43:58,946 --> 0:43:59,906
存在于 macOS 上

1177
00:44:00,306 --> 0:44:02,066
接下来是选择

1178
00:44:02,066 --> 0:44:03,096
iOS 上的 Picker 看起来

1179
00:44:03,096 --> 0:44:04,456
像传统的轮状 Picker

1180
00:44:05,446 --> 0:44:06,806
但是 由于我们正在构建

1181
00:44:06,806 --> 0:44:08,406
一个表单 SwiftUI 会

1182
00:44:08,406 --> 0:44:09,816
自动调整 Picker 以采用

1183
00:44:09,816 --> 0:44:11,226
这种类型的 UI 的

1184
00:44:11,226 --> 0:44:12,696
另一种非常常见的形式

1185
00:44:14,686 --> 0:44:16,276
这里我们可以看到

1186
00:44:16,276 --> 0:44:18,006
Spread Picker 现在

1187
00:44:18,006 --> 0:44:19,866
由一个导航行表示 该行同时

1188
00:44:19,866 --> 0:44:21,786
显示其标签和当前选定的值

1189
00:44:22,936 --> 0:44:24,266
轻点这一行 就会出现

1190
00:44:24,266 --> 0:44:25,636
一个包含所有选项的列表

1191
00:44:26,076 --> 0:44:27,326
轻点选择其中一个

1192
00:44:27,326 --> 0:44:28,146
然后就会回到上一界面

1193
00:44:29,516 --> 0:44:36,646
[掌声]

1194
00:44:37,146 --> 0:44:38,096
不要抢我的台词

1195
00:44:38,286 --> 0:44:39,856
这就是 SwiftUI 通过创建一个

1196
00:44:39,856 --> 0:44:41,266
简单的 Picker 来处理

1197
00:44:41,526 --> 0:44:43,726
和创建整个交互设计

1198
00:44:44,516 --> 0:44:49,646
[掌声]

1199
00:44:50,146 --> 0:44:51,246
这让我们剩下的三个

1200
00:44:51,246 --> 0:44:52,306
Picker 显得微不足道

1201
00:44:53,196 --> 0:44:54,666
就像在 macOS 中一样

1202
00:44:54,666 --> 0:44:56,206
我们仍然对最终样式

1203
00:44:56,206 --> 0:44:56,866
有明确的控制

1204
00:44:57,406 --> 0:44:58,426
如果我们想要一个轮状

1205
00:44:58,426 --> 0:45:00,976
Picker 我们可以把它加进去

1206
00:44:58,426 --> 0:45:00,976
Picker 我们可以把它加进去

1207
00:45:04,046 --> 0:45:07,086
现在我们有了一组很好的 App

1208
00:45:07,836 --> 0:45:08,906
但在我们工作或忙碌时

1209
00:45:08,906 --> 0:45:10,866
点吐司是一回事

1210
00:45:10,866 --> 0:45:12,946
而与朋友和家人

1211
00:45:12,946 --> 0:45:14,526
就什么是最好的

1212
00:45:14,696 --> 0:45:16,096
牛油果吐司进行激烈的

1213
00:45:16,096 --> 0:45:18,366
争论则完全是另一回事

1214
00:45:21,066 --> 0:45:21,736
右边的表单由我们在

1215
00:45:21,736 --> 0:45:23,026
其他 App 中看到的

1216
00:45:23,026 --> 0:45:24,556
相同内容组成

1217
00:45:25,136 --> 0:45:26,186
来看一下用于

1218
00:45:26,186 --> 0:45:27,846
构建它的代码

1219
00:45:27,846 --> 0:45:28,896
它使用了与我们之前

1220
00:45:28,896 --> 0:45:30,296
使用的相同的结构和控件

1221
00:45:30,296 --> 0:45:31,666
进行创建 这并不奇怪

1222
00:45:32,406 --> 0:45:33,556
不同之处在于

1223
00:45:33,556 --> 0:45:34,726
自动适应的能力

1224
00:45:35,436 --> 0:45:36,536
例如 使用开关按钮

1225
00:45:36,536 --> 0:45:37,916
而不用开关来

1226
00:45:38,266 --> 0:45:38,976
表示 Toggle 

1227
00:45:41,286 --> 0:45:42,146
这就涉及到了

1228
00:45:42,146 --> 0:45:44,266
SwiftUI 的核心问题

1229
00:45:44,266 --> 0:45:46,886
你可以一次性学习一个概念

1230
00:45:46,886 --> 0:45:49,136
并将其应用到任何地方

1231
00:45:50,456 --> 0:45:51,986
SwiftUI 不仅仅是一种

1232
00:45:51,986 --> 0:45:53,676
一次性编写并在任何地方

1233
00:45:53,676 --> 0:45:54,726
运行的方法 它还是一个框架

1234
00:45:54,726 --> 0:45:56,086
让你能够学习这些核心概念

1235
00:45:56,376 --> 0:45:57,376
并在各种不同的上下文中

1236
00:45:57,376 --> 0:45:58,866
和平台上使用它们

1237
00:45:59,966 --> 0:46:01,386
这是从修饰符和 ViewBuilder

1238
00:45:59,966 --> 0:46:01,386
这是从修饰符和 ViewBuilder

1239
00:46:01,386 --> 0:46:02,906
语法扩展到共享的

1240
00:46:02,906 --> 0:46:04,686
核心类型 如color

1241
00:46:04,686 --> 0:46:06,776
image 和 ForEach

1242
00:46:06,836 --> 0:46:07,886
甚至扩展到这些高级控件

1243
00:46:08,476 --> 0:46:11,056
对我来说 一个真正能

1244
00:46:11,056 --> 0:46:12,366
说明这种知识重用的例子

1245
00:46:12,366 --> 0:46:14,096
是构建 contextMenu

1246
00:46:14,096 --> 0:46:16,726
的一个稍微特定于

1247
00:46:16,726 --> 0:46:17,786
平台的例子

1248
00:46:18,376 --> 0:46:20,696
contextMenu 本身可以

1249
00:46:20,696 --> 0:46:23,326
使用修饰符附加到关联视图

1250
00:46:23,416 --> 0:46:25,446
这个修饰语句使用

1251
00:46:25,446 --> 0:46:27,816
ViewBuilder 语法来定义它的菜单内容

1252
00:46:28,586 --> 0:46:29,516
现在 如果我们看一下菜单

1253
00:46:29,516 --> 0:46:31,746
我们可以看到一些熟悉的概念

1254
00:46:32,636 --> 0:46:33,806
有些元素在点按时

1255
00:46:34,136 --> 0:46:35,456
执行一个操作 并有一个描述

1256
00:46:35,456 --> 0:46:36,656
该操作的标签

1257
00:46:37,356 --> 0:46:38,946
而另一些元素则专门负责

1258
00:46:38,946 --> 0:46:39,756
打开和关闭

1259
00:46:39,756 --> 0:46:42,186
因此 内容本身去使用

1260
00:46:42,186 --> 0:46:43,896
我们已经学会如何

1261
00:46:43,996 --> 0:46:45,456
使用的相同控件来进行

1262
00:46:45,456 --> 0:46:46,406
进行构建 这并不奇怪

1263
00:46:47,026 --> 0:46:48,576
按钮 分频器和 Toggle 

1264
00:46:49,636 --> 0:46:51,516
不过 我们的 macOS

1265
00:46:51,516 --> 0:46:52,766
菜单仍然会自动呈现

1266
00:46:53,066 --> 0:46:54,906
预期的外观和体验

1267
00:46:54,906 --> 0:46:56,316
从悬停和加速手势处理

1268
00:46:56,316 --> 0:46:57,506
到特殊的高亮

1269
00:46:57,506 --> 0:46:58,976
显示和选择样式

1270
00:47:01,516 --> 0:47:03,016
从这几个例子中 你可以

1271
00:47:03,016 --> 0:47:04,266
看出 SwiftUI

1272
00:47:04,266 --> 0:47:05,936
中的控件有点特殊

1273
00:47:06,796 --> 0:47:07,556
它们的定义是基于

1274
00:47:07,556 --> 0:47:08,836
其目的 所服务的角色

1275
00:47:08,836 --> 0:47:10,506
与 App 模型的连接

1276
00:47:10,506 --> 0:47:11,936
而不是特定于

1277
00:47:11,936 --> 0:47:13,266
它们的视觉外观

1278
00:47:14,236 --> 0:47:14,866
这意味着它们本质上

1279
00:47:14,866 --> 0:47:16,506
是可以跨多种历史

1280
00:47:16,506 --> 0:47:17,746
上下文重用的

1281
00:47:18,236 --> 0:47:19,076
并且可以根据上下文

1282
00:47:19,076 --> 0:47:20,466
平台或其他信息确定

1283
00:47:20,466 --> 0:47:23,016
适当的外观和体验

1284
00:47:23,936 --> 0:47:25,306
与此同时 它们是

1285
00:47:25,426 --> 0:47:27,636
可自定义的 既可以使用

1286
00:47:27,636 --> 0:47:29,546
视图作为标签和选项

1287
00:47:29,626 --> 0:47:30,506
也可以在系统

1288
00:47:30,506 --> 0:47:32,386
样式中任意设置这些控件

1289
00:47:32,696 --> 0:47:33,856
的样式 就像你在 Picker

1290
00:47:33,856 --> 0:47:35,066
中看到的那样 我们甚至

1291
00:47:35,066 --> 0:47:36,406
可以完全自定义这些样式

1292
00:47:37,216 --> 0:47:38,176
无论哪一种 仍然有

1293
00:47:38,616 --> 0:47:40,976
内置来支持辅助功能

1294
00:47:44,046 --> 0:47:45,236
刚才 Matt 展示了一些

1295
00:47:45,236 --> 0:47:47,126
使用修饰符对视图强制

1296
00:47:47,126 --> 0:47:49,846
执行附加行为的例子

1297
00:47:50,296 --> 0:47:52,746
对控件来说也是如此

1298
00:47:54,606 --> 0:47:55,846
iOS 上的用户可能

1299
00:47:55,846 --> 0:47:56,776
已经熟悉的一个

1300
00:47:56,776 --> 0:48:00,556
例子是改变 UI 的色调或强调色

1301
00:47:56,776 --> 0:48:00,556
例子是改变 UI 的色调或强调色

1302
00:48:00,556 --> 0:48:01,356
这会影响出现不同

1303
00:48:01,356 --> 0:48:02,236
系统控件的数量

1304
00:48:03,016 --> 0:48:04,346
如果我们想把这个应用

1305
00:48:04,346 --> 0:48:06,156
到整个 App 中 我们可以

1306
00:48:06,156 --> 0:48:07,696
把 accentColor 修饰语句

1307
00:48:07,696 --> 0:48:09,126
应用到最外层的视图

1308
00:48:09,126 --> 0:48:10,106
这样它就会像这个按钮

1309
00:48:10,106 --> 0:48:11,666
一样被整个层级结构继承

1310
00:48:11,666 --> 0:48:14,486
现在 当涉及到禁用

1311
00:48:14,486 --> 0:48:15,956
控件时 我们可以使用

1312
00:48:15,956 --> 0:48:16,846
禁用修饰符

1313
00:48:17,686 --> 0:48:18,736
比如说在可能 

1314
00:48:18,736 --> 0:48:19,846
没有点吐司时

1315
00:48:19,846 --> 0:48:21,086
禁用“Order”按钮

1316
00:48:21,086 --> 0:48:23,016
但是 当我们需要

1317
00:48:23,016 --> 0:48:24,106
禁用整个控件组时

1318
00:48:24,106 --> 0:48:25,836
也可能会出现这种情况

1319
00:48:26,536 --> 0:48:27,616
例如 当我们无法

1320
00:48:27,616 --> 0:48:28,646
连接到购买吐司网络

1321
00:48:28,876 --> 0:48:30,606
甚至无法下单时

1322
00:48:30,606 --> 0:48:32,146
我们会希望禁用

1323
00:48:32,146 --> 0:48:33,596
表单中的每个控件

1324
00:48:34,726 --> 0:48:36,046
但是如果我们添加额外

1325
00:48:36,046 --> 0:48:37,566
的控件 其实没什么意思

1326
00:48:37,566 --> 0:48:38,456
而且容易出错

1327
00:48:39,066 --> 0:48:40,146
但是正如你在一般的

1328
00:48:40,146 --> 0:48:41,986
修饰符中看到的那样

1329
00:48:41,986 --> 0:48:43,696
我们可以将这个修饰符

1330
00:48:43,696 --> 0:48:45,126
移除再应用到整个表单中

1331
00:48:45,536 --> 0:48:46,226
就像我们在使用 accentColor

1332
00:48:46,226 --> 0:48:47,226
修饰符时所做的那样

1333
00:48:48,516 --> 0:48:54,546
[掌声]

1334
00:48:55,046 --> 0:48:56,226
现在我们表单中的所有

1335
00:48:56,226 --> 0:48:58,126
控件都将基于这条语法禁用

1336
00:48:59,156 --> 0:49:01,286
所有这些适应性

1337
00:48:59,156 --> 0:49:01,286
所有这些适应性

1338
00:49:01,286 --> 0:49:03,176
和继承操作都非常

1339
00:49:03,176 --> 0:49:04,976
强大 令人惊叹

1340
00:49:04,976 --> 0:49:06,516
因为我们使用的是

1341
00:49:06,516 --> 0:49:08,686
这些简单的值类型视图

1342
00:49:09,316 --> 0:49:10,286
但让我们来看看

1343
00:49:10,336 --> 0:49:12,336
hood 的工作原理

1344
00:49:12,866 --> 0:49:15,116
这些例子是建立在

1345
00:49:15,116 --> 0:49:16,686
environment 之上的

1346
00:49:17,706 --> 0:49:18,976
environment 由视图

1347
00:49:18,976 --> 0:49:21,056
出现的所有上下文组成

1348
00:49:22,486 --> 0:49:23,256
这些都是大家以前

1349
00:49:23,256 --> 0:49:24,276
可能认为是共享

1350
00:49:24,276 --> 0:49:26,066
全局状态的东西

1351
00:49:26,066 --> 0:49:26,936
是你的视图上的

1352
00:49:26,936 --> 0:49:28,256
集合或属性的一部分

1353
00:49:28,256 --> 0:49:29,346
或者需要访问之前的

1354
00:49:29,346 --> 0:49:31,326
历史才能取出值

1355
00:49:32,376 --> 0:49:33,866
但是现在这些都被打包

1356
00:49:34,026 --> 0:49:34,796
到 environment 中

1357
00:49:35,326 --> 0:49:36,916
任何想要访问它的人

1358
00:49:36,916 --> 0:49:38,276
都可以对其进行访问

1359
00:49:39,246 --> 0:49:40,286
每个视图都继承

1360
00:49:40,286 --> 0:49:41,696
其原有的 environment

1361
00:49:43,076 --> 0:49:44,826
现在举个例子 当在

1362
00:49:44,826 --> 0:49:46,196
阿拉伯语环境中运行时

1363
00:49:46,196 --> 0:49:47,476
我们的 App 的根本环境

1364
00:49:47,476 --> 0:49:49,166
有一个从右到左的布局方向

1365
00:49:49,886 --> 0:49:51,746
每个视图都继承这个布局方向

1366
00:49:52,716 --> 0:49:54,136
但是在任何给定的位点

1367
00:49:54,136 --> 0:49:55,086
都可以为视图的

1368
00:49:55,086 --> 0:49:57,016
子树重写环境

1369
00:49:58,176 --> 0:49:59,046
如果我们要创建

1370
00:49:59,046 --> 0:50:00,526
媒体播放控制

1371
00:49:59,046 --> 0:50:00,526
媒体播放控制

1372
00:50:00,526 --> 0:50:01,616
我们想要确保它们是

1373
00:50:01,616 --> 0:50:02,686
从左到右排列的

1374
00:50:03,546 --> 0:50:04,636
通过使用环境修饰语句

1375
00:50:04,636 --> 0:50:06,976
我们可以把它添加到层级结构上

1376
00:50:10,046 --> 0:50:11,666
现在 environment

1377
00:50:11,666 --> 0:50:12,776
也是使预览功能如此强大

1378
00:50:12,956 --> 0:50:15,156
的重要技术之一

1379
00:50:15,756 --> 0:50:16,836
它能够在各种不同的

1380
00:50:16,836 --> 0:50:18,466
上下文中显示相同的 UI

1381
00:50:18,466 --> 0:50:19,936
因此我们可以根据人们

1382
00:50:19,936 --> 0:50:21,206
可能使用它们的所有方式

1383
00:50:21,206 --> 0:50:22,976
来预览我们的 App

1384
00:50:25,276 --> 0:50:26,196
现在各位已经了解了

1385
00:50:26,196 --> 0:50:26,986
环境是如何自动影响

1386
00:50:26,986 --> 0:50:28,416
各种系统视图的

1387
00:50:28,416 --> 0:50:29,696
并且自定义视图也能

1388
00:50:29,696 --> 0:50:30,986
使用 environment

1389
00:50:31,746 --> 0:50:32,516
所以我一直在为我们的

1390
00:50:32,516 --> 0:50:33,886
下一个更新做一个小控件

1391
00:50:34,696 --> 0:50:36,406
它能选择鸡蛋放在

1392
00:50:36,406 --> 0:50:38,766
吐司上的确切位置

1393
00:50:39,646 --> 0:50:41,156
大家可以看到它是使用两个

1394
00:50:41,156 --> 0:50:43,116
简单的 ZStack 图像构建的

1395
00:50:43,116 --> 0:50:44,676
底部的 Toast 和顶部

1396
00:50:44,676 --> 0:50:46,666
带有 dragGesture 的定位图像

1397
00:50:47,526 --> 0:50:48,686
这样 我们就可以轻点

1398
00:50:48,686 --> 0:50:50,426
并拖动鸡蛋到正确的位置

1399
00:50:51,756 --> 0:50:53,466
现在如果我们要使用

1400
00:50:53,466 --> 0:50:56,246
Egg 视图 可能在某些情况下 就需要禁用它

1401
00:50:56,466 --> 0:50:57,766
也许商店的鸡蛋卖完了

1402
00:50:58,986 --> 0:51:00,106
但由于我们使用的是系统

1403
00:50:58,986 --> 0:51:00,106
但由于我们使用的是系统

1404
00:51:00,106 --> 0:51:01,416
dragGesture 它会被

1405
00:51:01,466 --> 0:51:04,036
禁用的修饰符自动禁用

1406
00:51:04,036 --> 0:51:05,316
所以如果有人想

1407
00:51:05,316 --> 0:51:07,306
拖动这个鸡蛋是不会成功的

1408
00:51:08,496 --> 0:51:09,826
当然 我们还应该

1409
00:51:09,826 --> 0:51:10,956
提供一些视觉反馈

1410
00:51:10,986 --> 0:51:12,526
来说明它也被禁用了

1411
00:51:12,526 --> 0:51:13,206
还好这个操作很简单

1412
00:51:14,606 --> 0:51:15,706
我们可以添加一个

1413
00:51:15,706 --> 0:51:17,506
环境属性 该属性

1414
00:51:17,506 --> 0:51:18,586
会连接到环境中的

1415
00:51:18,586 --> 0:51:19,036
isEnabled值

1416
00:51:19,886 --> 0:51:21,276
我们可以像使用其他属性

1417
00:51:21,276 --> 0:51:22,146
一样使用它的值

1418
00:51:22,966 --> 0:51:24,206
例如 当它被禁用时

1419
00:51:24,206 --> 0:51:25,276
降低我们整个

1420
00:51:25,276 --> 0:51:26,976
结构的饱和度

1421
00:51:30,066 --> 0:51:32,126
如果放置鸡蛋的视图不再被禁用

1422
00:51:32,446 --> 0:51:33,816
SwiftUI 将自动

1423
00:51:33,816 --> 0:51:35,286
恢复视图的主体并将其

1424
00:51:35,286 --> 0:51:37,896
重新呈现为未禁用状态

1425
00:51:37,976 --> 0:51:41,126
同样 这是 SwiftUI

1426
00:51:41,126 --> 0:51:42,026
在自动管理我们

1427
00:51:42,026 --> 0:51:43,106
对环境的依赖关系

1428
00:51:43,106 --> 0:51:44,276
这样我们就可以表达

1429
00:51:44,276 --> 0:51:45,676
视图与环境之间的关系

1430
00:51:45,676 --> 0:51:46,846
而不必担心什么

1431
00:51:46,846 --> 0:51:48,416
时候会发生变化

1432
00:51:51,436 --> 0:51:53,236
目前我们已经介绍了

1433
00:51:53,236 --> 0:51:54,396
一些控件以及将它们组合

1434
00:51:54,396 --> 0:51:55,096
在一起的方法

1435
00:51:55,096 --> 0:51:56,766
但我们仍然遗漏了

1436
00:51:56,766 --> 0:51:58,376
每个 App 中非常

1437
00:51:58,376 --> 0:52:00,286
重要的部分 那就是

1438
00:51:58,376 --> 0:52:00,286
重要的部分 那就是

1439
00:52:00,286 --> 0:52:02,246
在这些屏幕之间导航

1440
00:52:02,246 --> 0:52:03,896
从订单表单到鸡蛋放置的

1441
00:52:03,896 --> 0:52:05,496
Picker 再到订单历史记录

1442
00:52:06,236 --> 0:52:07,456
现在让我们从订单开始讲起

1443
00:52:07,456 --> 0:52:09,166
有些人可能已经

1444
00:52:09,166 --> 0:52:10,186
注意到了表单中

1445
00:52:10,186 --> 0:52:11,606
标题的外观

1446
00:52:12,196 --> 0:52:13,086
它不使用标准的

1447
00:52:13,086 --> 0:52:14,106
导航栏样式

1448
00:52:14,106 --> 0:52:16,286
因此我们可以首先将

1449
00:52:16,286 --> 0:52:17,976
OrderForm 包装在 NavigationView

1450
00:52:17,976 --> 0:52:18,836
中作为 App 的内容

1451
00:52:19,606 --> 0:52:20,596
NavigationView 可以

1452
00:52:20,596 --> 0:52:21,776
在 App 屏幕中导航

1453
00:52:21,776 --> 0:52:23,326
显示更多嵌套

1454
00:52:23,326 --> 0:52:24,946
或详细信息

1455
00:52:25,696 --> 0:52:27,646
在 iOS 系统中 NavigationView

1456
00:52:27,646 --> 0:52:29,146
还添加了标准的导航栏 Chrome

1457
00:52:29,146 --> 0:52:31,096
然后我们可以使用

1458
00:52:31,096 --> 0:52:32,846
NavigationBarTitle 修饰语句

1459
00:52:32,846 --> 0:52:34,056
来为表单生成一个

1460
00:52:34,056 --> 0:52:35,156
漂亮的标题

1461
00:52:35,976 --> 0:52:37,706
这个修饰语句有点特殊

1462
00:52:38,306 --> 0:52:39,336
它提供了能够被

1463
00:52:39,336 --> 0:52:40,716
源始 NavigationView

1464
00:52:40,716 --> 0:52:41,976
解释的信息

1465
00:52:43,006 --> 0:52:44,056
我们之前看到过

1466
00:52:44,056 --> 0:52:46,136
一些修饰符的例子

1467
00:52:46,136 --> 0:52:47,316
它们用环境使信息沿着

1468
00:52:47,516 --> 0:52:49,066
视图层级架构向下流动

1469
00:52:49,066 --> 0:52:50,386
这是一个使用

1470
00:52:50,386 --> 0:52:52,696
首选项向上流动信息的例子

1471
00:52:52,696 --> 0:52:54,576
现在我们不打算对此

1472
00:52:54,576 --> 0:52:55,646
进行过多的详细讨论

1473
00:52:55,646 --> 0:52:56,456
但是稍后你会看到

1474
00:52:56,456 --> 0:52:57,596
其他类似的例子

1475
00:52:59,336 --> 0:53:00,816
关注一下表单

1476
00:52:59,336 --> 0:53:00,816
关注一下表单

1477
00:53:00,816 --> 0:53:01,726
我们要做的下一件事

1478
00:53:01,726 --> 0:53:03,656
是添加支持点鸡蛋的功能

1479
00:53:04,276 --> 0:53:05,476
我们可以在这里

1480
00:53:05,476 --> 0:53:06,966
添加一个 Toggle 

1481
00:53:06,966 --> 0:53:08,946
当有人选择加鸡蛋时

1482
00:53:08,946 --> 0:53:10,426
我们可以添加一个导航行

1483
00:53:10,426 --> 0:53:12,466
它会转向 EggLocationPicker

1484
00:53:13,156 --> 0:53:14,456
我们把它展开看看

1485
00:53:14,456 --> 0:53:15,396
它是如何工作的

1486
00:53:16,506 --> 0:53:18,226
它是使用一个绑定到

1487
00:53:18,226 --> 0:53:19,246
我们订单是否包含一个

1488
00:53:19,246 --> 0:53:19,856
鸡蛋的切换来构建的

1489
00:53:19,856 --> 0:53:21,546
然后它使用与 Matt

1490
00:53:21,546 --> 0:53:22,456
之前展示的相同的

1491
00:53:22,456 --> 0:53:23,756
ViewBuilder 条件

1492
00:53:23,756 --> 0:53:25,506
来选择性地包含导航行

1493
00:53:26,446 --> 0:53:28,516
现在 最酷的事情是

1494
00:53:28,516 --> 0:53:29,926
我们为 Toggle 提供了

1495
00:53:29,926 --> 0:53:31,196
一个动画绑定

1496
00:53:31,796 --> 0:53:32,936
所以每当有人轻点

1497
00:53:32,936 --> 0:53:34,836
这个开关 我们的导航行

1498
00:53:34,836 --> 0:53:36,336
就会被动态地

1499
00:53:36,336 --> 0:53:37,976
插入到 FormList 中

1500
00:53:40,046 --> 0:53:42,536
表示导航行也非常简单

1501
00:53:43,246 --> 0:53:44,556
它使用一个名为

1502
00:53:44,556 --> 0:53:46,776
Navigationbutton 的专门控件

1503
00:53:47,116 --> 0:53:48,346
允许我们在交互时

1504
00:53:48,346 --> 0:53:50,816
提供一些目标内容来导航

1505
00:53:51,636 --> 0:53:52,786
Navigationbutton 自动

1506
00:53:52,786 --> 0:53:53,826
提供了所有出色的外观

1507
00:53:53,826 --> 0:53:55,366
和体验 比如尾部边缘的

1508
00:53:55,366 --> 0:53:56,866
显示指示器

1509
00:53:57,446 --> 0:53:58,966
由于视图是轻量级的

1510
00:53:58,966 --> 0:54:00,156
我们不必担心

1511
00:53:58,966 --> 0:54:00,156
我们不必担心

1512
00:54:00,156 --> 0:54:01,276
在这里创建了

1513
00:54:01,276 --> 0:54:02,416
EggLocationPicker

1514
00:54:03,106 --> 0:54:04,426
SwiftUI 只在

1515
00:54:04,426 --> 0:54:06,046
实际呈现这些视图时

1516
00:54:06,046 --> 0:54:07,446
才会呈现它们

1517
00:54:08,596 --> 0:54:10,256
现在在 EggLocationPicker 中

1518
00:54:10,256 --> 0:54:11,516
我们可以使用 PlacementView

1519
00:54:12,146 --> 0:54:13,526
自定义导航栏

1520
00:54:13,526 --> 0:54:14,546
这样一旦它被显示

1521
00:54:14,546 --> 0:54:16,346
标题就会反映它的当前状态

1522
00:54:16,966 --> 0:54:17,936
我们还可以添加一个追踪的

1523
00:54:17,936 --> 0:54:19,416
BarItem 来快速地将

1524
00:54:19,416 --> 0:54:20,756
egg 重置回初始状态

1525
00:54:21,726 --> 0:54:22,686
正如大家所希望的那样

1526
00:54:22,686 --> 0:54:24,176
这里的项与我们

1527
00:54:24,176 --> 0:54:25,176
已经学会如何使用

1528
00:54:25,176 --> 0:54:26,466
的视图是相同的 因此我们

1529
00:54:26,466 --> 0:54:27,326
只需要提供一个按钮

1530
00:54:28,346 --> 0:54:29,046
这就是创建完整导航

1531
00:54:29,046 --> 0:54:30,976
体验所需要的全部

1532
00:54:33,096 --> 0:54:34,376
现在我们可以把注意力

1533
00:54:34,376 --> 0:54:35,176
转向 OrderHistory

1534
00:54:36,116 --> 0:54:37,346
现在我们想导航到这里

1535
00:54:37,456 --> 0:54:38,646
但它不是表单的更详细

1536
00:54:38,646 --> 0:54:39,966
或嵌套的信息

1537
00:54:40,436 --> 0:54:41,756
而是 App 的一个

1538
00:54:41,756 --> 0:54:43,316
完全不同的部分

1539
00:54:44,556 --> 0:54:46,576
这更适合使用 TabbedView

1540
00:54:47,796 --> 0:54:49,186
因此 我们可以像处理

1541
00:54:49,186 --> 0:54:50,596
NavigationView 一样

1542
00:54:50,596 --> 0:54:52,856
将表单封装在 TabbedView 中 然后将

1543
00:54:52,856 --> 0:54:54,436
OrderHistory 添加为另一个子元素

1544
00:54:55,616 --> 0:54:56,976
两者都有 tabItemLabel 修饰符

1545
00:54:56,976 --> 0:54:57,896
它负责向 TabbedView

1546
00:54:57,896 --> 0:55:00,096
描述如何在选项卡栏中标记它们

1547
00:54:57,896 --> 0:55:00,096
描述如何在选项卡栏中标记它们

1548
00:55:03,046 --> 0:55:04,746
现在我们可以快速跳转到 OrderHistory

1549
00:55:04,916 --> 0:55:06,196
但是现在我们已经对

1550
00:55:06,196 --> 0:55:07,596
OrderHistory 有了一个简单的细节了解

1551
00:55:07,596 --> 0:55:09,226
我们可能想要将其

1552
00:55:09,226 --> 0:55:10,316
扩展为更详细的信息集

1553
00:55:10,316 --> 0:55:12,046
以便从历史列表

1554
00:55:12,046 --> 0:55:13,736
导航到这些信息

1555
00:55:14,646 --> 0:55:15,796
这是嵌套或显示

1556
00:55:15,796 --> 0:55:16,676
更详细信息的另一种情况

1557
00:55:16,676 --> 0:55:18,236
就像我们前面在 NavigationView

1558
00:55:18,236 --> 0:55:19,626
和按钮 中看到的那样

1559
00:55:19,626 --> 0:55:22,156
因此我们可以替换

1560
00:55:22,156 --> 0:55:23,356
OrderHistory 列表的内容

1561
00:55:23,646 --> 0:55:24,896
因此我们可以使用这个

1562
00:55:24,896 --> 0:55:25,896
新的 OrderDetail 作为

1563
00:55:25,896 --> 0:55:27,646
NavigationButtons 的目标

1564
00:55:27,646 --> 0:55:28,926
而不是将它以内联

1565
00:55:28,926 --> 0:55:30,856
方式显示在列表中

1566
00:55:31,786 --> 0:55:32,986
构建一个数据驱动

1567
00:55:32,986 --> 0:55:34,516
列表非常简单

1568
00:55:34,516 --> 0:55:36,336
它可以导航到其他内容

1569
00:55:37,606 --> 0:55:38,796
这在 iPhone 上

1570
00:55:38,796 --> 0:55:40,206
很好用 但如果是

1571
00:55:40,206 --> 0:55:41,736
iPad 我们希望这个设置

1572
00:55:41,736 --> 0:55:43,176
使用主细节和 SplitView

1573
00:55:44,486 --> 0:55:45,926
不像 iPhone 上的 navigationStack

1574
00:55:45,926 --> 0:55:47,456
会推送到单个 RootView

1575
00:55:47,456 --> 0:55:49,226
在这里我们知道

1576
00:55:49,226 --> 0:55:50,966
我们有 RootView 的

1577
00:55:50,966 --> 0:55:52,336
两个导航 即能够将内容

1578
00:55:52,336 --> 0:55:55,476
推送到细节的 Master

1579
00:55:55,646 --> 0:55:56,716
因此 虽然我们的 NavigationView

1580
00:55:56,716 --> 0:55:57,626
仅对 iPhone 上的单个

1581
00:55:57,626 --> 0:55:59,776
RootContent 执行

1582
00:55:59,776 --> 0:56:00,606
正确操作 但我们希望

1583
00:55:59,776 --> 0:56:00,606
正确操作 但我们希望

1584
00:56:00,606 --> 0:56:01,826
指出它本质上

1585
00:56:01,826 --> 0:56:03,656
包含这两部分内容

1586
00:56:03,656 --> 0:56:05,936
OrderHistory Master 和 DetailView

1587
00:56:06,696 --> 0:56:07,636
这里 我们可以使用

1588
00:56:07,636 --> 0:56:09,276
OrderDetailPlaceholder 视图

1589
00:56:09,276 --> 0:56:10,456
作为占位符 以便在没有选择

1590
00:56:10,456 --> 0:56:11,276
任何内容时充当占位符

1591
00:56:12,196 --> 0:56:12,956
现在 当在 OrderHistory

1592
00:56:12,956 --> 0:56:14,516
中与 Navigationbutton

1593
00:56:14,516 --> 0:56:15,566
交互时它将自动被

1594
00:56:15,746 --> 0:56:18,286
推送到 OrderDetail

1595
00:56:18,286 --> 0:56:20,196
这将像我们在 iPad

1596
00:56:20,196 --> 0:56:21,406
和其他使用 SplitView的

1597
00:56:21,436 --> 0:56:23,306
大类上所期望的那样

1598
00:56:23,776 --> 0:56:24,966
而对于小尺寸类

1599
00:56:25,276 --> 0:56:26,566
则会自动折叠成

1600
00:56:26,566 --> 0:56:27,606
单个 NavigationStack

1601
00:56:28,176 --> 0:56:30,656
当然 这在 macOS

1602
00:56:30,656 --> 0:56:32,946
上也能操作 创建出一个 SplitView

1603
00:56:32,946 --> 0:56:35,606
这不是写一次

1604
00:56:35,606 --> 0:56:36,596
就能运行的 还需要

1605
00:56:36,596 --> 0:56:37,706
一些额外的设计考虑

1606
00:56:37,706 --> 0:56:38,906
比如 macOS 上

1607
00:56:38,906 --> 0:56:41,276
信息密度的增加

1608
00:56:42,656 --> 0:56:43,936
但是 SwiftUI 会自动

1609
00:56:43,936 --> 0:56:45,606
处理平台的底层外观

1610
00:56:45,606 --> 0:56:47,206
从 SplitView

1611
00:56:47,206 --> 0:56:48,656
的操作到表行

1612
00:56:48,656 --> 0:56:50,396
的高度等等

1613
00:56:51,426 --> 0:56:52,436
这样我们就可以学习

1614
00:56:52,436 --> 0:56:53,526
如何使用这些不同的概念

1615
00:56:53,526 --> 0:56:55,306
后把它们应用到任意地方

1616
00:56:56,406 --> 0:56:57,556
然后我们可以把时间集中在

1617
00:56:57,826 --> 0:56:59,206
一些令人兴奋的自定义功能上

1618
00:56:59,206 --> 0:57:00,706
这些功能会使你的每个

1619
00:56:59,206 --> 0:57:00,706
这些功能会使你的每个

1620
00:57:00,706 --> 0:57:00,976
App 都变得很棒

1621
00:57:03,256 --> 0:57:04,436
在这最后的一个小时里

1622
00:57:04,436 --> 0:57:05,516
我们已经讲了相当多的内容

1623
00:57:05,516 --> 0:57:06,966
还有一些其他的讲座

1624
00:57:06,966 --> 0:57:08,486
会展现更多的细节

1625
00:57:09,366 --> 0:57:10,456
我们展示了状态和绑定

1626
00:57:10,456 --> 0:57:11,426
将如何改变你和控件

1627
00:57:11,426 --> 0:57:12,926
的交互方式 但是

1628
00:57:12,926 --> 0:57:14,266
SwiftUI 中的数据流将使你

1629
00:57:14,266 --> 0:57:16,226
重新考虑数据驱动

1630
00:57:16,226 --> 0:57:16,506
的 UI 更新

1631
00:57:17,916 --> 0:57:19,056
我们使用布局调整器

1632
00:57:19,056 --> 0:57:20,346
建立了一些自定义视图

1633
00:57:20,346 --> 0:57:21,636
但是 SwiftUI 中的自定义控件

1634
00:57:21,636 --> 0:57:23,266
将深入研究布局 图形

1635
00:57:23,266 --> 0:57:24,826
和动画的高级应用

1636
00:57:24,826 --> 0:57:26,886
并做一个出色的演示

1637
00:57:28,256 --> 0:57:29,116
我们知道 很多人会

1638
00:57:29,116 --> 0:57:30,116
迫不及待地使用

1639
00:57:30,116 --> 0:57:31,546
SwiftUI 并且可能想知道

1640
00:57:31,546 --> 0:57:32,486
是否可以将其集成到

1641
00:57:32,486 --> 0:57:33,426
现有的 App 中

1642
00:57:33,426 --> 0:57:34,706
好的方面是 SwiftUI

1643
00:57:35,036 --> 0:57:36,106
的设计可以与

1644
00:57:36,106 --> 0:57:37,616
现有的视图和

1645
00:57:37,616 --> 0:57:39,116
模型无缝融合

1646
00:57:39,766 --> 0:57:40,686
我们有一个完整的讲座

1647
00:57:40,776 --> 0:57:41,626
向大家展示如何做到这一点

1648
00:57:43,026 --> 0:57:44,036
我们谈到了 SwiftUI

1649
00:57:44,036 --> 0:57:44,906
是如何设计的 来让你的

1650
00:57:44,906 --> 0:57:46,926
App 能让所有人都可以访问

1651
00:57:47,446 --> 0:57:48,166
当然 总会有一些

1652
00:57:48,166 --> 0:57:49,236
额外的考量 这次演讲

1653
00:57:49,346 --> 0:57:51,186
将会涉及更多的细节

1654
00:57:52,086 --> 0:57:53,096
最后 但最重要的是

1655
00:57:53,096 --> 0:57:54,446
我们展示了 SwiftUI

1656
00:57:54,446 --> 0:57:56,066
是如何提高跨平台

1657
00:57:56,066 --> 0:57:57,746
共享的门槛的

1658
00:57:58,616 --> 0:57:59,986
所有设备上的 SwiftUI 

1659
00:57:59,986 --> 0:58:01,426
将这一点作为基准

1660
00:57:59,986 --> 0:58:01,426
将这一点作为基准

1661
00:58:01,426 --> 0:58:02,786
并详细介绍了如何在任意

1662
00:58:02,786 --> 0:58:04,646
平台上开发出优秀的 App

1663
00:58:05,606 --> 0:58:06,756
还有一些额外的演讲

1664
00:58:06,756 --> 0:58:08,526
比如驱动 watchOS

1665
00:58:08,526 --> 0:58:09,706
和《What's New in Swift》

1666
00:58:09,706 --> 0:58:11,416
中关于 watchOS 的详细内容

1667
00:58:12,266 --> 0:58:14,216
最后 感谢大家的收看

1668
00:58:14,566 --> 0:58:15,526
我们对此十分感激

1669
00:58:16,516 --> 0:58:23,500
[掌声]
