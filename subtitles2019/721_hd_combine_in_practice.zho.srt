1
00:00:01,176 --> 0:00:04,500
[音乐]

2
00:00:10,286 --> 0:00:10,636
&gt;&gt; 大家好

3
00:00:11,516 --> 0:00:16,546
[掌声]

4
00:00:17,046 --> 0:00:18,896
大家好 我是 Michael LeHew

5
00:00:19,376 --> 0:00:21,046
在 Apple Foundation 团队工作

6
00:00:21,326 --> 0:00:23,286
今天 我很激动地

7
00:00:23,286 --> 0:00:24,656
向大家介绍

8
00:00:24,656 --> 0:00:25,756
今年即将发布的

9
00:00:25,756 --> 0:00:26,776
Combine 框架

10
00:00:27,686 --> 0:00:28,796
先澄清一点

11
00:00:28,796 --> 0:00:29,976
我们要说的不是联合收割机

12
00:00:32,136 --> 0:00:33,336
深入探讨之前 我想

13
00:00:33,336 --> 0:00:35,056
先总体简单介绍一下

14
00:00:35,166 --> 0:00:36,606
Combine 是什么

15
00:00:36,606 --> 0:00:40,446
代码中 常见的

16
00:00:40,476 --> 0:00:41,536
情况是 我们有

17
00:00:41,536 --> 0:00:44,866
值或事件的发布者

18
00:00:44,866 --> 0:00:46,236
还有想要从发布者处

19
00:00:46,236 --> 0:00:49,796
接收值的订阅者

20
00:00:50,386 --> 0:00:51,946
有一些相关方

21
00:00:51,946 --> 0:00:52,956
会在这两者

22
00:00:52,956 --> 0:00:54,706
之间建立连接

23
00:00:56,336 --> 0:00:58,626
连接建立后 订阅者

24
00:00:59,006 --> 0:01:00,676
会声明

25
00:00:59,006 --> 0:01:00,676
会声明

26
00:01:00,676 --> 0:01:02,176
想要从发布者处

27
00:01:02,176 --> 0:01:05,135
接收值 之后

28
00:01:05,135 --> 0:01:06,946
发布者便可以

29
00:01:07,276 --> 0:01:08,736
向下游发送值

30
00:01:09,726 --> 0:01:12,196
这一过程会持续下去

31
00:01:12,196 --> 0:01:13,546
直到发布者因为值发送完毕

32
00:01:13,546 --> 0:01:15,326
或出现发送失败

33
00:01:15,326 --> 0:01:16,826
决定停止发送值

34
00:01:16,826 --> 0:01:18,826
或者有人

35
00:01:18,826 --> 0:01:20,726
选择取消订阅

36
00:01:22,276 --> 0:01:23,916
如大家所见

37
00:01:23,916 --> 0:01:26,006
这样的通信模式在我们的

38
00:01:26,006 --> 0:01:27,826
软件中随处可见

39
00:01:27,826 --> 0:01:30,126
形式可以是回调 闭包

40
00:01:30,126 --> 0:01:31,976
或者其他出现异步通信的情况

41
00:01:34,046 --> 0:01:35,266
Combine 正与这种模式

42
00:01:35,266 --> 0:01:36,676
密切相关

43
00:01:39,046 --> 0:01:41,166
Combine 定义了一个

44
00:01:41,166 --> 0:01:42,856
统一的抽象

45
00:01:42,856 --> 0:01:44,316
用来描述 API

46
00:01:44,316 --> 0:01:45,326
这类 API 可以在一段时间内处理值

47
00:01:45,986 --> 0:01:48,476
我们来看看

48
00:01:48,476 --> 0:01:50,736
值发布者有哪些具体特征

49
00:01:53,046 --> 0:01:53,876
我们已经在介绍会议中

50
00:01:53,876 --> 0:01:55,096
谈论过这方面的内容

51
00:01:55,096 --> 0:01:58,286
但我们再回顾一下

52
00:01:58,286 --> 0:02:00,296
Combine 中的值发布者遵循

53
00:01:58,286 --> 0:02:00,296
Combine 中的值发布者遵循

54
00:02:01,376 --> 0:02:02,426
Publisher 协议

55
00:02:02,986 --> 0:02:06,586
协议规定了两种 associatedtype

56
00:02:06,586 --> 0:02:09,606
即发布者

57
00:02:09,606 --> 0:02:10,716
发布的值

58
00:02:10,716 --> 0:02:13,166
以及发布能否失败

59
00:02:13,756 --> 0:02:15,976
稍后 我会详细介绍失败

60
00:02:18,156 --> 0:02:20,626
Publisher 也要描述

61
00:02:20,626 --> 0:02:22,326
如何将 Subscriber

62
00:02:22,846 --> 0:02:23,736
附加于自身

63
00:02:23,736 --> 0:02:25,346
限制条件是 associatedtype 必须匹配

64
00:02:26,766 --> 0:02:28,706
就是这样

65
00:02:28,946 --> 0:02:31,506
好了 我觉得理论部分足够了

66
00:02:31,806 --> 0:02:34,556
此次会议名为 Combine in Practice

67
00:02:34,556 --> 0:02:39,076
我们就来关注实践 我有一个巫师朋友

68
00:02:39,296 --> 0:02:41,596
他非常酷

69
00:02:41,706 --> 0:02:43,786
想跟我一起

70
00:02:43,966 --> 0:02:45,516
为他正在筹办的新巫师学校开发一款 App

71
00:02:45,516 --> 0:02:49,986
App 中有一项功能是

72
00:02:49,986 --> 0:02:51,446
提供法术下载

73
00:02:51,446 --> 0:02:52,366
这些法术

74
00:02:52,366 --> 0:02:54,046
是由和他一样的巫师分享的

75
00:02:54,436 --> 0:02:55,526
他不是 App 开发者

76
00:02:55,526 --> 0:02:57,346
他是个巫师 所以他给了我

77
00:02:57,346 --> 0:03:00,376
一张草图 这就是我要使用的 UI 组件

78
00:02:57,346 --> 0:03:00,376
一张草图 这就是我要使用的 UI 组件

79
00:03:01,826 --> 0:03:03,496
虽然他是个巫师

80
00:03:03,496 --> 0:03:04,566
但他确实会写代码

81
00:03:04,566 --> 0:03:07,396
起码足够帮我下载法术

82
00:03:07,396 --> 0:03:08,586
于是 他就开始忙自己的

83
00:03:08,586 --> 0:03:09,546
我要做的则是

84
00:03:09,546 --> 0:03:10,716
讨论我们要如何

85
00:03:10,716 --> 0:03:13,596
使用 Combine 获取

86
00:03:13,596 --> 0:03:15,076
必要的 App 值

87
00:03:15,426 --> 0:03:17,976
在这个标签中填充法术名

88
00:03:21,366 --> 0:03:23,166
Combine 中 NotificationCenter

89
00:03:23,166 --> 0:03:24,646
支持将通知

90
00:03:24,646 --> 0:03:26,316
提供给发布者

91
00:03:26,606 --> 0:03:28,166
我们就来创建

92
00:03:28,166 --> 0:03:29,976
一个 Publisher

93
00:03:29,976 --> 0:03:31,806
让我的巫师朋友传递通知

94
00:03:32,396 --> 0:03:35,056
这个函数的

95
00:03:35,056 --> 0:03:36,096
返回类型将是 Publisher

96
00:03:36,096 --> 0:03:38,426
但 Combine 中

97
00:03:38,426 --> 0:03:39,716
对发布者重要的是

98
00:03:39,936 --> 0:03:41,876
它的输出和失败类型

99
00:03:44,046 --> 0:03:45,596
NotificationCenter Publisher

100
00:03:45,656 --> 0:03:47,436
传递通知

101
00:03:47,436 --> 0:03:48,166
并且不可以失败

102
00:03:48,166 --> 0:03:50,046
既然我们要

103
00:03:50,046 --> 0:03:51,876
详细探讨发布者

104
00:03:52,286 --> 0:03:53,446
接下来的讨论中 

105
00:03:53,446 --> 0:03:54,536
我就会一直

106
00:03:54,536 --> 0:03:56,516
把发布者的输出

107
00:03:56,516 --> 0:03:57,836
放在上面

108
00:03:57,836 --> 0:04:01,726
把失败放在下面 那么我们就有了一个

109
00:03:57,836 --> 0:04:01,726
把失败放在下面 那么我们就有了一个

110
00:04:01,726 --> 0:04:04,056
通知发布者

111
00:04:04,056 --> 0:04:06,096
但我们真正想要的是

112
00:04:06,096 --> 0:04:07,976
其中描述刚刚下载的法术的数据

113
00:04:10,216 --> 0:04:11,836
我的朋友告诉我

114
00:04:11,836 --> 0:04:13,296
他把数据放在了 userInfo 字典中

115
00:04:13,496 --> 0:04:15,536
幸运的是 Combine 提供了

116
00:04:15,536 --> 0:04:17,016
很有帮助的 map 函数

117
00:04:17,016 --> 0:04:19,206
让我们可以深入内部

118
00:04:19,866 --> 0:04:21,866
将通知转换为我们需要的形式

119
00:04:22,096 --> 0:04:23,246
这与 Sequence 中

120
00:04:23,246 --> 0:04:25,946
已有的操作很相似

121
00:04:26,766 --> 0:04:28,906
可以看到 我们使用的发布者

122
00:04:28,906 --> 0:04:30,606
输出是数据

123
00:04:30,606 --> 0:04:36,956
不会产生错误 我们调用 map 这样的函数

124
00:04:36,956 --> 0:04:38,936
作用于 Publisher 且返回

125
00:04:38,936 --> 0:04:40,426
新 Publisher 操作符

126
00:04:40,956 --> 0:04:42,526
它们在 Combine 中会经常那个出现

127
00:04:43,186 --> 0:04:45,866
我的朋友还告诉我

128
00:04:45,866 --> 0:04:47,826
JSON 负载 或者将要

129
00:04:47,826 --> 0:04:49,926
成为 JSON 负载类型的数据

130
00:04:49,926 --> 0:04:51,706
已经在我们的 App 中定义了

131
00:04:52,256 --> 0:04:53,656
所以 我就可以用另一个 Combine 操作符

132
00:04:53,656 --> 0:04:55,196
尝试解码数据

133
00:04:55,196 --> 0:04:56,746
我们调用这个

134
00:04:56,746 --> 0:04:57,596
tryMap 操作符

135
00:04:58,626 --> 0:05:00,716
它和 map 很类似

136
00:04:58,626 --> 0:05:00,716
它和 map 很类似

137
00:05:00,716 --> 0:05:02,106
但它多了一个功能

138
00:05:02,156 --> 0:05:05,116
可以将错误抛出转换为流中的失败

139
00:05:06,146 --> 0:05:07,926
确实 这个操作符的输出

140
00:05:08,016 --> 0:05:09,926
是 MagicTrick 的发布者

141
00:05:09,926 --> 0:05:12,246
它的失败

142
00:05:12,246 --> 0:05:13,976
遵循 Swift Error 协议

143
00:05:16,566 --> 0:05:18,476
从数据中解码自定义类型

144
00:05:18,476 --> 0:05:20,246
是常见任务

145
00:05:20,286 --> 0:05:21,606
我们也提供了一个操作符

146
00:05:21,606 --> 0:05:22,836
专门帮你处理

147
00:05:23,966 --> 0:05:25,356
仅需要简单的调用 .decode

148
00:05:28,076 --> 0:05:28,736
发布者的输出

149
00:05:29,516 --> 0:05:32,546
[掌声]

150
00:05:33,046 --> 0:05:33,916
发布者的输出和

151
00:05:33,916 --> 0:05:35,856
失败类型没有变化

152
00:05:36,916 --> 0:05:38,246
既然我们有了可以

153
00:05:38,246 --> 0:05:39,546
失败的发布者

154
00:05:39,546 --> 0:05:40,576
我想多谈一谈我们

155
00:05:40,576 --> 0:05:43,116
能做的事情

156
00:05:43,356 --> 0:05:45,616
Combine 中 对潜在的失败

157
00:05:45,616 --> 0:05:48,326
作出反应至关重要

158
00:05:48,886 --> 0:05:50,536
每个发布者和订阅者

159
00:05:50,536 --> 0:05:51,836
都有机会描述

160
00:05:51,836 --> 0:05:53,096
它们生成或允许的

161
00:05:53,096 --> 0:05:54,486
失败类型

162
00:05:55,096 --> 0:05:56,896
我们将其内置于 Combine

163
00:05:57,456 --> 0:05:58,986
因为就像 Swift 一样

164
00:05:58,986 --> 0:06:00,176
我们不想让错误处理

165
00:05:58,986 --> 0:06:00,176
我们不想让错误处理

166
00:06:00,176 --> 0:06:01,116
成为一件完全

167
00:06:01,116 --> 0:06:02,666
基于惯例的事情

168
00:06:03,636 --> 0:06:05,216
我们在其他语言中进行了尝试

169
00:06:05,216 --> 0:06:06,236
效果不太好

170
00:06:06,986 --> 0:06:08,846
所以 许多类型会将其

171
00:06:08,846 --> 0:06:10,256
失败类型描述为 never

172
00:06:10,256 --> 0:06:11,496
这就表明

173
00:06:11,496 --> 0:06:12,966
它们可能失败

174
00:06:12,966 --> 0:06:15,166
或预期失败在上游得到解决

175
00:06:15,686 --> 0:06:18,546
但除此之外

176
00:06:18,546 --> 0:06:20,906
我们还提供了许多操作符

177
00:06:20,906 --> 0:06:23,456
失败发生时

178
00:06:23,456 --> 0:06:24,836
你可以借助它们作出反应或恢复

179
00:06:25,336 --> 0:06:28,186
其中最简单的 就是

180
00:06:28,186 --> 0:06:29,726
预设失败永远不会发生

181
00:06:30,816 --> 0:06:32,646
自然 此时返回的发布者

182
00:06:32,646 --> 0:06:33,816
失败类型

183
00:06:33,816 --> 0:06:34,696
就是 never

184
00:06:35,426 --> 0:06:38,006
但我们来看看为什么

185
00:06:38,226 --> 0:06:39,426
想象一下

186
00:06:39,426 --> 0:06:40,576
我们有一个上游的发布者

187
00:06:41,216 --> 0:06:42,686
它与下游的

188
00:06:42,856 --> 0:06:44,906
订阅者通过中间的

189
00:06:44,906 --> 0:06:46,766
assertNoFailure 这一操作符连接

190
00:06:47,706 --> 0:06:49,496
这个操作符只会

191
00:06:49,496 --> 0:06:51,576
在收到值时直接将其向下传递

192
00:06:52,616 --> 0:06:54,676
但假如上游

193
00:06:54,676 --> 0:06:56,766
传来错误 我们的程序

194
00:06:56,766 --> 0:06:58,636
就会卡住

195
00:06:58,636 --> 0:07:00,956
这对于我们的巫师用户来说 不是理想中的结果

196
00:06:58,636 --> 0:07:00,956
这对于我们的巫师用户来说 不是理想中的结果

197
00:07:04,046 --> 0:07:05,666
幸运的是 我们在 Combine 中

198
00:07:05,666 --> 0:07:06,906
有许多其他操作符

199
00:07:06,906 --> 0:07:07,736
来处理失败

200
00:07:08,586 --> 0:07:10,256
除了预设之外

201
00:07:10,256 --> 0:07:11,506
你还可以尝试

202
00:07:11,506 --> 0:07:13,626
重新连接至上游

203
00:07:13,626 --> 0:07:15,086
发布者或将错误

204
00:07:15,086 --> 0:07:16,276
转换为其他类型

205
00:07:16,276 --> 0:07:19,476
有一个操作符特别有用

206
00:07:19,476 --> 0:07:20,146
那就是 catch

207
00:07:20,756 --> 0:07:23,126
catch 允许你提供一个闭包

208
00:07:23,126 --> 0:07:24,386
其中定义一个恢复性

209
00:07:24,386 --> 0:07:26,476
发布者 它适用于

210
00:07:26,476 --> 0:07:29,506
原先的上游发布者发生失败的情形

211
00:07:29,926 --> 0:07:32,146
我们来看看它如何生效

212
00:07:32,966 --> 0:07:33,806
我们先来看看与之前

213
00:07:33,806 --> 0:07:35,176
类似的情形

214
00:07:35,176 --> 0:07:36,806
这次我们不用 assertNoFailure 而是

215
00:07:36,806 --> 0:07:37,916
使用 catch 操作符

216
00:07:38,876 --> 0:07:41,326
和先前一样

217
00:07:41,326 --> 0:07:42,406
值会无障碍转发至

218
00:07:42,406 --> 0:07:43,586
下游的订阅者

219
00:07:44,096 --> 0:07:46,756
但错误抵达时

220
00:07:47,516 --> 0:07:50,206
现有的上游连接将被终止

221
00:07:52,266 --> 0:07:53,286
我们之后会调用提供的

222
00:07:53,286 --> 0:07:54,716
恢复性闭包 它可以

223
00:07:54,716 --> 0:07:56,566
产生一个新的发布者

224
00:07:56,566 --> 0:07:58,446
供我们订阅 之后也可以

225
00:07:58,446 --> 0:07:59,866
从它那里接收值

226
00:08:01,076 --> 0:08:03,146
这样一来 catch 这个操作符

227
00:08:03,146 --> 0:08:04,406
就可以用新的发布者

228
00:08:04,406 --> 0:08:05,846
替换原有的发布者

229
00:08:05,846 --> 0:08:06,476
让我们从错误中恢复

230
00:08:07,436 --> 0:08:08,386
我们这就把它用在

231
00:08:08,386 --> 0:08:09,596
我们的代码里

232
00:08:11,046 --> 0:08:12,256
catch 的使用和

233
00:08:12,256 --> 0:08:13,516
其他操作符很类似

234
00:08:13,916 --> 0:08:14,736
但这里的闭包

235
00:08:14,736 --> 0:08:16,266
希望我们返回一个发布者

236
00:08:17,636 --> 0:08:19,136
Combine 定义了一种特殊

237
00:08:19,136 --> 0:08:20,656
发布者供已有

238
00:08:20,656 --> 0:08:22,116
想要发布的值时使用

239
00:08:22,426 --> 0:08:25,576
我们称其为 Just 意为直接发布这个值

240
00:08:25,706 --> 0:08:26,466
这是 Combine 初始

241
00:08:26,466 --> 0:08:28,346
自带的诸多发布者

242
00:08:28,346 --> 0:08:31,186
中的一个例子

243
00:08:32,626 --> 0:08:34,395
使用它的时候 

244
00:08:34,395 --> 0:08:36,336
返回的发布者类型不能失败

245
00:08:39,046 --> 0:08:40,616
现在 我来回顾一下我们

246
00:08:40,616 --> 0:08:41,936
执行过的各种转换

247
00:08:42,486 --> 0:08:45,016
最开始 我们有通知发布者

248
00:08:45,016 --> 0:08:47,536
之后 我们对其映射

249
00:08:47,536 --> 0:08:49,206
获取我们

250
00:08:49,206 --> 0:08:50,786
想要解码的数据

251
00:08:52,136 --> 0:08:53,786
之后 我们利用

252
00:08:53,786 --> 0:08:56,346
.decode 操作符将数据

253
00:08:56,346 --> 0:08:57,996
转换成用户定义的类型

254
00:08:59,366 --> 0:09:00,756
但由于各种原因

255
00:08:59,366 --> 0:09:00,756
但由于各种原因

256
00:09:00,876 --> 0:09:03,926
解码可能失败

257
00:09:03,926 --> 0:09:05,086
我们就要在失败发生时

258
00:09:05,086 --> 0:09:06,576
将上游替换成占位符

259
00:09:06,736 --> 0:09:07,966
来解决问题

260
00:09:10,276 --> 0:09:13,496
但等一下 如果我们改用

261
00:09:13,496 --> 0:09:15,106
恢复性发布者的话

262
00:09:15,106 --> 0:09:15,696
我们就再也看不到

263
00:09:15,696 --> 0:09:16,606
另一个通知了

264
00:09:16,976 --> 0:09:18,416
我们终止了订阅

265
00:09:18,416 --> 0:09:20,916
我们真正想要的

266
00:09:20,916 --> 0:09:22,456
是能够尝试解码

267
00:09:22,456 --> 0:09:23,786
并在失败时使用占位符

268
00:09:23,946 --> 0:09:25,086
且同时与先前的上游

269
00:09:25,086 --> 0:09:26,236
保持联系

270
00:09:26,716 --> 0:09:29,586
自然 Combine 为此

271
00:09:29,586 --> 0:09:30,916
也提供了一个操作符

272
00:09:30,996 --> 0:09:32,046
它叫做 flatMap

273
00:09:33,836 --> 0:09:35,626
flatMap 和 map 原理很像

274
00:09:36,076 --> 0:09:36,666
名称也类似

275
00:09:37,696 --> 0:09:38,646
你从上游发布者

276
00:09:38,646 --> 0:09:40,226
获得值

277
00:09:40,226 --> 0:09:41,376
但同时预期为获得的值

278
00:09:41,376 --> 0:09:44,196
生成新的发布者

279
00:09:45,226 --> 0:09:46,356
flatMap 便可处理

280
00:09:46,356 --> 0:09:47,876
订阅这个嵌套

281
00:09:47,876 --> 0:09:49,866
发布者的细节

282
00:09:49,866 --> 0:09:50,896
并将值传递给下游

283
00:09:52,346 --> 0:09:53,366
我们先来看看它的工作原理

284
00:09:53,366 --> 0:09:55,926
之后再看代码

285
00:09:58,176 --> 0:09:59,656
和以前一样

286
00:09:59,656 --> 0:10:00,906
值从上游进入我们的

287
00:09:59,656 --> 0:10:00,906
值从上游进入我们的

288
00:10:00,906 --> 0:10:01,936
flatMap 操作符

289
00:10:03,246 --> 0:10:04,856
值到达后 flatMap 会调用

290
00:10:04,856 --> 0:10:07,136
一个闭包 将值转换为

291
00:10:07,466 --> 0:10:09,416
一个新的发布者

292
00:10:09,416 --> 0:10:10,896
此时 这个新的发布者是

293
00:10:10,896 --> 0:10:14,886
一个 Just 一个 decode 以及一个 catch

294
00:10:15,176 --> 0:10:16,056
和之前相似

295
00:10:17,206 --> 0:10:18,946
flatMap 之后会订阅

296
00:10:18,946 --> 0:10:20,576
这个新发布者将

297
00:10:20,576 --> 0:10:21,906
结果值传到下游

298
00:10:25,046 --> 0:10:25,686
我想在这个 flatMap 中

299
00:10:25,686 --> 0:10:27,356
追溯另一个值

300
00:10:27,866 --> 0:10:31,116
但这次 请想象

301
00:10:31,116 --> 0:10:32,706
解码在运行中生成

302
00:10:32,706 --> 0:10:33,326
一个错误

303
00:10:33,906 --> 0:10:35,926
当失败抵达

304
00:10:35,926 --> 0:10:37,656
catch 时 它会被

305
00:10:37,656 --> 0:10:38,656
恢复性发布者取代

306
00:10:39,466 --> 0:10:41,086
这个发布者

307
00:10:41,086 --> 0:10:42,206
会被返回至 flatMap

308
00:10:43,276 --> 0:10:44,976
这就可以确保

309
00:10:44,976 --> 0:10:45,976
该操作永远不会失败

310
00:10:49,046 --> 0:10:50,116
现在我们来看看

311
00:10:50,116 --> 0:10:51,046
代码中该怎么用

312
00:10:51,426 --> 0:10:52,706
我们从先前停下的地方继续

313
00:10:53,566 --> 0:10:56,246
也就是我们处理

314
00:10:56,246 --> 0:10:57,186
流中第一个错误的地方

315
00:10:57,666 --> 0:10:59,506
但现在 我们来使用

316
00:10:59,506 --> 0:11:00,356
flatMap 操作符

317
00:10:59,506 --> 0:11:00,356
flatMap 操作符

318
00:11:00,476 --> 0:11:02,276
更改真的很容易

319
00:11:03,326 --> 0:11:04,766
和用 catch 一样

320
00:11:04,766 --> 0:11:06,296
我们用 Just 从收到的数据

321
00:11:06,296 --> 0:11:08,376
创建新的发布者

322
00:11:08,376 --> 0:11:09,356
这就是我们刚从

323
00:11:09,356 --> 0:11:10,476
map 操作符中解码的数据

324
00:11:11,176 --> 0:11:12,666
借助 flatMap 操作符的

325
00:11:12,666 --> 0:11:15,096
嵌套域 我们就可以

326
00:11:15,096 --> 0:11:16,596
依次 return .decode

327
00:11:16,596 --> 0:11:18,276
.catch 并将结果返回给 flatMap

328
00:11:18,276 --> 0:11:19,606
此时 flatMap 会

329
00:11:19,606 --> 0:11:21,666
订阅这个发布者

330
00:11:21,666 --> 0:11:24,106
产生的发布者就会是

331
00:11:24,106 --> 0:11:25,846
MagicTrick 的发布者

332
00:11:25,846 --> 0:11:30,256
且不会失败 我们处理完

333
00:11:30,256 --> 0:11:31,736
上游失败后

334
00:11:31,736 --> 0:11:33,086
需要继续完成

335
00:11:33,086 --> 0:11:34,846
既定目标 也就是尝试

336
00:11:34,846 --> 0:11:36,926
发布法术的名字

337
00:11:37,416 --> 0:11:40,266
有了 Combine 这非常简单

338
00:11:40,266 --> 0:11:42,146
使用另一个操作符

339
00:11:42,146 --> 0:11:43,376
publisher(for:) 操作符即可

340
00:11:44,136 --> 0:11:45,366
我们用它来进入

341
00:11:45,366 --> 0:11:46,686
MagicTrick

342
00:11:46,736 --> 0:11:48,976
通过一个类型安全的关键路径

343
00:11:48,976 --> 0:11:50,516
并生成一个新的发布者 本例中是

344
00:11:50,556 --> 0:11:51,706
发布者返回的类型为字符串

345
00:11:55,046 --> 0:11:56,636
现在 我想谈谈  

346
00:11:56,636 --> 0:11:58,166
最后一种操作符

347
00:11:58,256 --> 0:11:59,166
它能提供一些

348
00:11:59,166 --> 0:12:00,206
强大的功能

349
00:11:59,166 --> 0:12:00,206
强大的功能

350
00:12:00,766 --> 0:12:03,476
我们称其为定时操作符

351
00:12:03,896 --> 0:12:05,106
就像在现实生活中

352
00:12:05,106 --> 0:12:06,576
给东西定时一样

353
00:12:06,576 --> 0:12:08,726
定时操作符可以描述

354
00:12:08,726 --> 0:12:10,766
特定事件何时何地传递

355
00:12:13,196 --> 0:12:14,326
这类操作符受到

356
00:12:14,326 --> 0:12:15,866
RunLoop 和 DispatchQueues 的

357
00:12:15,866 --> 0:12:18,016
原生支持 定时操作符的

358
00:12:18,016 --> 0:12:19,406
例子包括

359
00:12:20,466 --> 0:12:22,616
delay 操作符 可以将

360
00:12:22,616 --> 0:12:24,976
事件传递延后至未来时间

361
00:12:27,066 --> 0:12:28,066
还有 throttle 可以

362
00:12:28,066 --> 0:12:29,376
确保事件传递

363
00:12:29,376 --> 0:12:30,536
不超过某个

364
00:12:30,536 --> 0:12:31,496
特定速率

365
00:12:33,026 --> 0:12:34,186
其他操作符 包括

366
00:12:34,186 --> 0:12:35,676
receive(on:) 可以确保

367
00:12:35,676 --> 0:12:37,456
下游接收的事件

368
00:12:37,456 --> 0:12:38,216
可按照特定的

369
00:12:38,216 --> 0:12:39,686
线程或队列传递

370
00:12:39,686 --> 0:12:42,936
我们就来使用这个操作符

371
00:12:42,936 --> 0:12:44,506
确保法术的名字

372
00:12:44,506 --> 0:12:46,586
始终在主队列中传递

373
00:12:47,746 --> 0:12:48,986
可以看到输出

374
00:12:48,986 --> 0:12:50,636
和失败的类型没有变化

375
00:12:51,146 --> 0:12:52,116
这其实对定时操作符

376
00:12:52,116 --> 0:12:53,476
来说很常见

377
00:12:54,436 --> 0:12:55,836
我们再来研究一下

378
00:12:55,836 --> 0:12:56,616
发布者链剩下的代码

379
00:12:58,056 --> 0:12:59,686
我们之前说到 flatMap

380
00:13:01,356 --> 0:13:03,206
这里我们用 publisher(for:)

381
00:13:03,206 --> 0:13:04,726
深入 MagicTrick 内部

382
00:13:04,726 --> 0:13:06,426
提取法术的名称

383
00:13:07,796 --> 0:13:10,646
最后 我们把工作

384
00:13:10,646 --> 0:13:11,446
转移到主线程上 用的是

385
00:13:11,446 --> 0:13:13,376
receive(on:) 操作符

386
00:13:13,816 --> 0:13:14,806
如果我们使用的是

387
00:13:14,806 --> 0:13:16,156
AppKit 或 UIKit

388
00:13:16,156 --> 0:13:17,646
其中 UI 依据主线程上下文更新

389
00:13:17,646 --> 0:13:18,966
那现在就实现了

390
00:13:18,966 --> 0:13:21,306
发布的值已经处在

391
00:13:21,306 --> 0:13:22,546
正确的线程上了

392
00:13:24,036 --> 0:13:25,576
如你所见 我们现在

393
00:13:25,576 --> 0:13:26,626
已经能用发布者和

394
00:13:26,626 --> 0:13:28,236
其操作符做很多事情了

395
00:13:29,206 --> 0:13:30,446
我们在最初的

396
00:13:30,446 --> 0:13:32,546
方案上 不断添加操作符

397
00:13:32,546 --> 0:13:34,516
依次进行修改

398
00:13:34,626 --> 0:13:36,856
最终循序渐进 产生了强类型值

399
00:13:37,396 --> 0:13:39,736
我们看到发布者

400
00:13:39,736 --> 0:13:40,606
能同步产生值

401
00:13:40,606 --> 0:13:42,806
正如在 Just 的例子中

402
00:13:43,156 --> 0:13:45,226
同时 它还能异步运作 例如使用

403
00:13:45,226 --> 0:13:46,126
NotificationCenter

404
00:13:46,676 --> 0:13:48,936
但现在 我想关注

405
00:13:48,936 --> 0:13:49,856
值发布的

406
00:13:49,856 --> 0:13:50,846
另一面

407
00:13:51,336 --> 0:13:52,996
也就是值的接收

408
00:13:54,306 --> 0:13:55,836
现在我想谈谈订阅者

409
00:13:58,246 --> 0:13:59,306
和发布者一样

410
00:13:59,586 --> 0:14:01,166
Combine 中的订阅者有两个

411
00:13:59,586 --> 0:14:01,166
Combine 中的订阅者有两个

412
00:14:01,166 --> 0:14:03,326
associatedtype 即它们的输入

413
00:14:04,106 --> 0:14:05,836
和它们容许的失败

414
00:14:07,576 --> 0:14:09,416
它们也描述了三个

415
00:14:09,416 --> 0:14:10,596
事件函数 分别对应

416
00:14:10,596 --> 0:14:13,606
接收订阅 接收值 以及结束

417
00:14:14,176 --> 0:14:16,516
这三个函数调用的

418
00:14:16,516 --> 0:14:18,186
顺序经过严格定义

419
00:14:18,416 --> 0:14:19,486
总结起来 遵循

420
00:14:19,576 --> 0:14:20,416
三条规则

421
00:14:20,906 --> 0:14:24,426
规则一 回应

422
00:14:24,426 --> 0:14:26,246
订阅调用时 发布者

423
00:14:26,246 --> 0:14:28,476
只会调用一次 receive(subscription:)

424
00:14:28,566 --> 0:14:29,696
不多不少

425
00:14:33,066 --> 0:14:36,216
规则二 发布者之后

426
00:14:36,216 --> 0:14:38,246
可以提供零个或更多值

427
00:14:38,246 --> 0:14:39,786
传递给下游的订阅者

428
00:14:39,786 --> 0:14:41,766
以回应订阅者的请求

429
00:14:44,346 --> 0:14:46,196
规则三 发布者

430
00:14:46,196 --> 0:14:47,596
至多只能发送一个结束信号

431
00:14:47,596 --> 0:14:49,356
这个结束

432
00:14:49,356 --> 0:14:50,566
可以表明发布者

433
00:14:50,566 --> 0:14:52,946
已经完成 或者

434
00:14:52,946 --> 0:14:53,526
发生了失败

435
00:14:54,476 --> 0:14:55,646
这个结束信号一旦发出

436
00:14:55,646 --> 0:14:58,826
便不会有其他值被传出

437
00:14:59,406 --> 0:15:01,406
这三条规则可以

438
00:14:59,406 --> 0:15:01,406
这三条规则可以

439
00:15:01,406 --> 0:15:02,656
归纳如下

440
00:15:03,176 --> 0:15:05,806
订阅者只会收到

441
00:15:05,806 --> 0:15:08,956
一个订阅 之后是

442
00:15:09,116 --> 0:15:11,606
零个或多个值

443
00:15:11,606 --> 0:15:12,616
可能由一个结束终止

444
00:15:12,616 --> 0:15:16,146
表明发布完成或失败

445
00:15:17,306 --> 0:15:19,086
我之所以说 可能

446
00:15:19,086 --> 0:15:20,276
是因为结束是可选的

447
00:15:20,866 --> 0:15:22,366
许多特定流理论上

448
00:15:22,366 --> 0:15:23,576
可以无限进行

449
00:15:23,576 --> 0:15:25,346
例如先前的 NotificationCenter 示例

450
00:15:28,356 --> 0:15:30,476
Combine 中 我们支持

451
00:15:30,476 --> 0:15:31,856
各种各样的订阅者

452
00:15:32,176 --> 0:15:33,856
我想向大家展示一下它们如何工作

453
00:15:36,516 --> 0:15:37,596
我们回到之前的发布者示例

454
00:15:37,596 --> 0:15:40,046
但我们现在

455
00:15:40,046 --> 0:15:42,006
想要了解的是

456
00:15:42,006 --> 0:15:43,486
我们正在使用的发布者

457
00:15:44,096 --> 0:15:45,316
我们就先腾出点儿地方来

458
00:15:47,316 --> 0:15:48,676
然后添加一个订阅者

459
00:15:50,206 --> 0:15:52,336
这里 我添加了 Combine 中最简单的订阅类型

460
00:15:52,336 --> 0:15:55,376
关键路径赋值

461
00:15:56,216 --> 0:15:58,406
使用的是 assign(to: on:)这个操作符

462
00:15:58,826 --> 0:16:00,766
它可以确保

463
00:15:58,826 --> 0:16:00,766
它可以确保

464
00:16:00,766 --> 0:16:02,226
上游发布者释放的

465
00:16:02,226 --> 0:16:03,466
任何值都会赋值给

466
00:16:03,466 --> 0:16:04,846
特定关键路径

467
00:16:04,846 --> 0:16:05,876
下的特定对象

468
00:16:06,316 --> 0:16:08,266
而就是从现在起

469
00:16:08,266 --> 0:16:09,636
我们几乎可以随意

470
00:16:09,636 --> 0:16:10,716
使用任何发布者并为

471
00:16:10,716 --> 0:16:11,886
任何属性赋值

472
00:16:11,926 --> 0:16:12,656
功能非常强大

473
00:16:13,106 --> 0:16:15,886
这个操作符还会产生一个

474
00:16:15,886 --> 0:16:17,386
取消令牌

475
00:16:17,386 --> 0:16:18,656
你可以之后调用它

476
00:16:18,656 --> 0:16:19,256
从而终止订阅

477
00:16:19,256 --> 0:16:23,356
我想多谈谈取消

478
00:16:23,856 --> 0:16:26,386
我们在 Combine 中

479
00:16:26,386 --> 0:16:28,196
构建了取消

480
00:16:28,196 --> 0:16:29,836
因为它便于在发布者

481
00:16:29,836 --> 0:16:31,666
结束传递事件之前

482
00:16:31,666 --> 0:16:34,096
终止订阅

483
00:16:35,156 --> 0:16:36,336
如果你想释放

484
00:16:36,336 --> 0:16:37,366
与此订阅相关的资源

485
00:16:37,366 --> 0:16:38,816
这一点尤其有用

486
00:16:39,996 --> 0:16:41,796
当然 取消是一种

487
00:16:41,796 --> 0:16:43,646
尽力服务

488
00:16:43,646 --> 0:16:44,686
但它可以满足你的需求

489
00:16:44,686 --> 0:16:45,976
为订阅者取消订阅

490
00:16:48,236 --> 0:16:49,546
我们引入了新协议

491
00:16:49,546 --> 0:16:50,566
用以描述

492
00:16:50,566 --> 0:16:52,546
可以取消或被取消的事物

493
00:16:53,326 --> 0:16:55,306
我们引入了

494
00:16:55,306 --> 0:16:56,926
一个极为便利的类

495
00:16:57,086 --> 0:16:58,866
叫做 AnyCancellable

496
00:16:58,866 --> 0:17:00,146
它带来的好处是

497
00:16:58,866 --> 0:17:00,146
它带来的好处是

498
00:17:00,356 --> 0:17:01,476
它可以自动

499
00:17:01,476 --> 0:17:02,706
在清理阶段时调用 cancel

500
00:17:04,036 --> 0:17:05,465
这可以显著减少

501
00:17:05,465 --> 0:17:06,376
你需要专门调用

502
00:17:06,376 --> 0:17:08,246
cancel 的次数

503
00:17:09,056 --> 0:17:10,586
你只需要依靠 Swift

504
00:17:10,586 --> 0:17:12,136
提供的强大

505
00:17:12,136 --> 0:17:13,646
内存管理能力即可

506
00:17:15,296 --> 0:17:16,846
我们接下来看看

507
00:17:16,846 --> 0:17:18,336
第二种订阅形式

508
00:17:18,846 --> 0:17:21,366
这里用到了 sink 操作符

509
00:17:21,796 --> 0:17:23,445
这种方法很棒

510
00:17:23,445 --> 0:17:24,906
你只要提供一个闭包

511
00:17:24,906 --> 0:17:26,236
对收到的任何值

512
00:17:26,236 --> 0:17:27,316
这个闭包都会被调用

513
00:17:27,316 --> 0:17:28,465
你就可以对它进行

514
00:17:28,465 --> 0:17:30,476
你想要的任何额外修改

515
00:17:31,236 --> 0:17:34,366
和 assign 一样 sink 会返回

516
00:17:34,436 --> 0:17:36,476
一个 canceller

517
00:17:36,476 --> 0:17:37,856
之后你可以用它来终止订阅

518
00:17:41,046 --> 0:17:42,076
第三种订阅方式是

519
00:17:42,116 --> 0:17:43,276
两者的结合

520
00:17:43,956 --> 0:17:45,996
我们称它们为主题

521
00:17:45,996 --> 0:17:46,826
它们的行为既有点像

522
00:17:46,826 --> 0:17:48,756
发布者也有点儿像订阅者

523
00:17:50,096 --> 0:17:50,966
它们一般支持

524
00:17:50,966 --> 0:17:52,466
将收到的值发送给多个目标

525
00:17:52,466 --> 0:17:54,326
格外重要的是

526
00:17:54,326 --> 0:17:56,316
你可以用它们

527
00:17:56,316 --> 0:17:57,406
命令式的发送值

528
00:17:57,776 --> 0:17:59,156
这一点极其重要

529
00:17:59,156 --> 0:18:00,596
特别是当你在已有的

530
00:17:59,156 --> 0:18:00,596
特别是当你在已有的

531
00:18:00,596 --> 0:18:01,926
代码基础上工作的时候

532
00:18:03,396 --> 0:18:04,356
我们来看看它们是

533
00:18:04,356 --> 0:18:06,556
如何工作的 之后再展示

534
00:18:06,556 --> 0:18:07,416
如何在实践中运用

535
00:18:07,936 --> 0:18:10,536
我之前提到 使用主题

536
00:18:10,706 --> 0:18:12,276
便可以向多个

537
00:18:12,276 --> 0:18:13,326
下游订阅者广播

538
00:18:13,326 --> 0:18:15,686
也可以

539
00:18:15,906 --> 0:18:17,196
命令式发送值

540
00:18:18,276 --> 0:18:20,196
任何收到的值都会

541
00:18:20,196 --> 0:18:21,976
广播给所有下游订阅者

542
00:18:24,156 --> 0:18:25,916
如果值都是由上游

543
00:18:25,916 --> 0:18:26,976
发布者产生的 也会如此广播

544
00:18:30,046 --> 0:18:31,616
Combine 中 我们支持两种主题

545
00:18:31,916 --> 0:18:34,046
一种是 Passthrough

546
00:18:34,046 --> 0:18:36,156
其中不存储值

547
00:18:36,466 --> 0:18:37,716
只有你订阅这个主题的时候

548
00:18:37,716 --> 0:18:38,976
你才能看到值

549
00:18:41,616 --> 0:18:43,716
我们还支持 CurrentValue 主题

550
00:18:44,526 --> 0:18:46,016
它保留了收到的

551
00:18:46,016 --> 0:18:47,186
最后一个值的历史记录

552
00:18:47,766 --> 0:18:49,056
这样新的订阅者

553
00:18:49,056 --> 0:18:50,906
就能很好的交接

554
00:18:53,066 --> 0:18:54,306
现在 来看看它们在实际操作中的样子

555
00:18:54,306 --> 0:18:55,706
和之前一样 我们先来看发布者

556
00:18:57,256 --> 0:18:58,986
创建主题非常简单

557
00:18:58,986 --> 0:19:00,326
只需选取你需要的主题

558
00:18:58,986 --> 0:19:00,326
只需选取你需要的主题

559
00:19:00,606 --> 0:19:01,826
指明输出和

560
00:19:01,826 --> 0:19:03,956
失败类型并调用构造函数

561
00:19:08,336 --> 0:19:09,916
主题的行为和订阅者类似

562
00:19:10,126 --> 0:19:11,416
因为它们都要订阅

563
00:19:11,416 --> 0:19:12,346
上游发布者

564
00:19:12,926 --> 0:19:15,906
同时 它也类似发布者

565
00:19:15,906 --> 0:19:17,126
需要调用我今天

566
00:19:17,126 --> 0:19:18,356
提到过的操作符

567
00:19:18,576 --> 0:19:20,276
比如 sink 等

568
00:19:20,276 --> 0:19:22,076
来形成订阅自己的订阅者

569
00:19:22,596 --> 0:19:24,876
你甚至还可以命令式的发送值

570
00:19:24,876 --> 0:19:26,896
比如这个有魔力的词语

571
00:19:28,516 --> 0:19:30,586
事实上 主题非常常用

572
00:19:30,586 --> 0:19:32,016
我们甚至定义了

573
00:19:32,016 --> 0:19:33,456
操作符 来向流中

574
00:19:33,456 --> 0:19:35,176
注入主题 例如 Share

575
00:19:35,516 --> 0:19:36,636
它可以将 Passthrough 主题

576
00:19:36,636 --> 0:19:39,666
注入流中

577
00:19:39,856 --> 0:19:41,256
主题的功能非常非常强大

578
00:19:41,256 --> 0:19:43,796
你会发现很多

579
00:19:43,796 --> 0:19:44,776
有趣的使用方法

580
00:19:44,776 --> 0:19:46,846
接下来 我想

581
00:19:46,846 --> 0:19:47,876
换个话题 谈谈

582
00:19:47,876 --> 0:19:49,236
第四种 也是最后一种订阅者

583
00:19:49,236 --> 0:19:53,396
就是与 SwiftUI 集成

584
00:19:55,156 --> 0:19:56,876
SwiftUI 了不起的一点

585
00:19:56,876 --> 0:19:58,656
就是你只需要

586
00:19:58,656 --> 0:20:00,526
在 App 中

587
00:19:58,656 --> 0:20:00,526
在 App 中

588
00:20:00,526 --> 0:20:01,656
描述依赖

589
00:20:01,656 --> 0:20:03,226
剩下的就可交给框架代劳

590
00:20:04,526 --> 0:20:05,866
就 Combine 而言

591
00:20:06,146 --> 0:20:07,266
这意味着你只需要

592
00:20:07,266 --> 0:20:08,786
提供发布者

593
00:20:08,786 --> 0:20:11,526
描述数据何时改变 如何改变

594
00:20:13,056 --> 0:20:15,306
为此 你只需要

595
00:20:15,306 --> 0:20:16,626
让自定义类型遵从

596
00:20:16,626 --> 0:20:18,016
BindableObject 协议

597
00:20:19,406 --> 0:20:21,176
SwiftUI 中的 BindableObjects

598
00:20:21,176 --> 0:20:22,286
只有一个 associatedtype

599
00:20:22,976 --> 0:20:26,596
这个发布者

600
00:20:26,596 --> 0:20:27,926
限制为永远不失败

601
00:20:27,926 --> 0:20:29,566
这可以与 UI 框架

602
00:20:29,566 --> 0:20:31,436
配合得天衣无缝

603
00:20:31,466 --> 0:20:32,786
因为这种语言的

604
00:20:32,786 --> 0:20:34,076
类型系统强制要求你

605
00:20:34,076 --> 0:20:35,826
先处理上游错误

606
00:20:35,986 --> 0:20:37,766
再接触发布者

607
00:20:40,096 --> 0:20:41,456
最后 你指定

608
00:20:41,456 --> 0:20:43,156
一个名为

609
00:20:43,446 --> 0:20:45,026
didChange 的属性

610
00:20:45,026 --> 0:20:46,536
产生实际发布者来通知你

611
00:20:46,536 --> 0:20:48,226
你的类型何时改变

612
00:20:48,226 --> 0:20:49,196
就这样

613
00:20:50,476 --> 0:20:52,096
要想进一步了解 SwiftUI 中

614
00:20:52,176 --> 0:20:53,736
数据流的工作原理 我强烈建议

615
00:20:53,736 --> 0:20:54,876
大家观看 Data Flow Through SwiftUI 会议

616
00:20:54,876 --> 0:20:56,606
我们在其中

617
00:20:56,606 --> 0:20:57,816
深入探讨了许多

618
00:20:57,816 --> 0:20:59,416
可以实现的细节

619
00:21:00,386 --> 0:21:02,176
但为了让大家体验一下

620
00:21:02,176 --> 0:21:03,676
我来向大家展示它的实际表现

621
00:21:05,166 --> 0:21:06,426
首先 我们从

622
00:21:06,426 --> 0:21:08,146
巫师学校 App 中的

623
00:21:08,146 --> 0:21:09,216
现有模型开始

624
00:21:09,866 --> 0:21:12,176
之后 我们添加

625
00:21:12,176 --> 0:21:12,986
遵循 BindableObject

626
00:21:13,326 --> 0:21:14,326
现在 我们用

627
00:21:14,326 --> 0:21:15,676
主题来描述我们的

628
00:21:15,676 --> 0:21:17,066
模型对象如何改变

629
00:21:18,146 --> 0:21:19,006
我们真的不需要

630
00:21:19,006 --> 0:21:20,656
主题传递任何

631
00:21:20,656 --> 0:21:23,806
特定种类的值

632
00:21:23,806 --> 0:21:25,146
因为这个框架可以根据我们

633
00:21:25,146 --> 0:21:26,266
对主体方法的调用

634
00:21:26,266 --> 0:21:26,586
自行处理

635
00:21:26,586 --> 0:21:27,936
我们就选 void 作为

636
00:21:27,936 --> 0:21:29,506
主题输出的类型

637
00:21:32,296 --> 0:21:33,666
像这样使用主题

638
00:21:33,666 --> 0:21:35,636
十分灵活 因为现在

639
00:21:35,636 --> 0:21:36,716
我们可以在对象变化时

640
00:21:36,716 --> 0:21:38,976
命令式发送信息

641
00:21:41,256 --> 0:21:43,546
但现在 我们就先使用一些

642
00:21:43,546 --> 0:21:45,346
属性观察器

643
00:21:45,346 --> 0:21:47,326
直接在主题中调用 send

644
00:21:47,326 --> 0:21:48,796
当任一属性变化时

645
00:21:48,796 --> 0:21:49,966
表明我们的

646
00:21:49,966 --> 0:21:51,226
模型对象也变化了

647
00:21:51,646 --> 0:21:54,616
接下来 我们要将这个模型

648
00:21:54,616 --> 0:21:57,326
与 SwiftUI 视图挂钩

649
00:21:57,326 --> 0:22:00,486
操作如下 我们声明一个

650
00:21:57,326 --> 0:22:00,486
操作如下 我们声明一个

651
00:22:00,486 --> 0:22:02,036
ObjectBinding 类型的模型 这样

652
00:22:02,036 --> 0:22:03,346
SwiftUI 就能自动

653
00:22:03,346 --> 0:22:05,206
发现并订阅我们的发布者

654
00:22:05,936 --> 0:22:10,336
之后 我们在 body 属性引用

655
00:22:10,336 --> 0:22:12,796
模型的属性 就这样

656
00:22:13,886 --> 0:22:15,346
SwiftUI 会自动

657
00:22:15,346 --> 0:22:17,166
在你表明模型发生变化时

658
00:22:17,166 --> 0:22:18,686
生成新的主体

659
00:22:22,046 --> 0:22:22,876
我想大家展示了 Combine

660
00:22:22,876 --> 0:22:24,036
有非常多的内置

661
00:22:24,036 --> 0:22:25,186
功能 大家可以

662
00:22:25,186 --> 0:22:26,696
自己组织 合成许多

663
00:22:26,696 --> 0:22:27,436
强大的功能

664
00:22:28,536 --> 0:22:30,146
我们非常兴奋 

665
00:22:30,246 --> 0:22:31,576
因为有了新框架

666
00:22:31,576 --> 0:22:32,686
你就能够大幅

667
00:22:32,686 --> 0:22:34,376
简化异步数据流

668
00:22:34,916 --> 0:22:36,876
要展示这一点

669
00:22:36,876 --> 0:22:37,946
我的同事 Ben 会上台

670
00:22:37,946 --> 0:22:38,826
告诉大家 如何

671
00:22:38,826 --> 0:22:40,226
进一步将这些

672
00:22:40,226 --> 0:22:41,546
强大功能整合进

673
00:22:41,546 --> 0:22:43,686
你现有的 App 中 谢谢大家

674
00:22:44,516 --> 0:22:50,316
[掌声]

675
00:22:50,816 --> 0:22:51,346
&gt;&gt; 谢谢 Michael

676
00:22:51,456 --> 0:22:52,806
我很高兴今天在这里

677
00:22:52,806 --> 0:22:53,976
见到大家

678
00:22:56,066 --> 0:22:57,646
设计 Combine 时

679
00:22:57,646 --> 0:22:58,746
我们高度重视构成

680
00:22:59,166 --> 0:23:00,126
如大家在 Michael 的

681
00:22:59,166 --> 0:23:00,126
如大家在 Michael 的

682
00:23:00,126 --> 0:23:02,696
示例中所见 我们从一个

683
00:23:02,696 --> 0:23:04,646
简单的发布者开始 经过

684
00:23:04,646 --> 0:23:05,776
各种转换后

685
00:23:06,206 --> 0:23:08,736
创造了最终的发布者实现了目标

686
00:23:08,736 --> 0:23:12,346
我们来看个例子

687
00:23:12,956 --> 0:23:14,936
我们要在

688
00:23:14,936 --> 0:23:16,326
App 中提供注册功能

689
00:23:16,326 --> 0:23:17,856
这样 巫师就能在我们的

690
00:23:17,856 --> 0:23:18,446
巫师学校注册了

691
00:23:18,446 --> 0:23:20,676
我们有一些要求

692
00:23:22,116 --> 0:23:23,236
首先 我们要保证

693
00:23:23,236 --> 0:23:25,266
用户名通过服务器验证

694
00:23:25,766 --> 0:23:30,076
第二 我们有密码字段

695
00:23:30,146 --> 0:23:31,636
和密码验证

696
00:23:31,676 --> 0:23:33,136
我们要保证二者相同

697
00:23:33,936 --> 0:23:34,976
且长度都大于八个字符

698
00:23:37,046 --> 0:23:38,176
最后 我们要保证

699
00:23:38,176 --> 0:23:39,836
如果这些条件

700
00:23:39,836 --> 0:23:41,926
都满足 我们就能启用或禁用 UI

701
00:23:43,306 --> 0:23:44,966
所以 这个例子中 我们有

702
00:23:44,966 --> 0:23:46,636
异步行为

703
00:23:46,636 --> 0:23:48,076
有一些设备本地的

704
00:23:48,076 --> 0:23:49,646
同步行为 我们

705
00:23:49,646 --> 0:23:50,506
还要能够把它们

706
00:23:50,506 --> 0:23:51,016
组合起来

707
00:23:51,016 --> 0:23:52,616
我们来看看 Combine 能

708
00:23:52,616 --> 0:23:53,806
提供什么帮助

709
00:23:56,106 --> 0:23:58,156
首先 我要用 Interface

710
00:23:58,156 --> 0:23:59,606
Builder 为密码字段

711
00:23:59,606 --> 0:24:00,996
在值变化属性上

712
00:23:59,606 --> 0:24:00,996
在值变化属性上

713
00:24:00,996 --> 0:24:02,466
创建目标动作

714
00:24:05,046 --> 0:24:06,246
在代码中使用后

715
00:24:07,126 --> 0:24:08,536
只要用户在这些字段中输入

716
00:24:08,536 --> 0:24:10,146
我们就能收到信号

717
00:24:10,676 --> 0:24:12,076
我们会获取当前值的

718
00:24:12,076 --> 0:24:14,116
文本属性

719
00:24:14,116 --> 0:24:15,836
并将其存入实例变量

720
00:24:16,876 --> 0:24:18,456
但我们想把它们

721
00:24:18,456 --> 0:24:19,816
和其他行为组合

722
00:24:19,816 --> 0:24:20,676
特别是我们先前

723
00:24:20,676 --> 0:24:23,376
提到的同步行为该怎么做

724
00:24:24,676 --> 0:24:27,776
很简单 只要将 Published

725
00:24:27,776 --> 0:24:29,266
添加至每个属性 我们就能

726
00:24:29,266 --> 0:24:30,946
对他们添加发布者

727
00:24:34,066 --> 0:24:35,536
Published 是一个属性包装器

728
00:24:35,536 --> 0:24:37,206
它使用 Swift 5.1

729
00:24:37,206 --> 0:24:39,706
中的新特性 将发布者添加到

730
00:24:39,706 --> 0:24:40,546
任何给定属性

731
00:24:42,106 --> 0:24:43,376
我们通过几个简单例子

732
00:24:43,376 --> 0:24:44,516
来看看如何使用它

733
00:24:47,216 --> 0:24:48,946
Published 属性包装器

734
00:24:48,946 --> 0:24:50,546
按你的需求

735
00:24:50,546 --> 0:24:51,936
添加在属性前

736
00:24:53,326 --> 0:24:54,926
在代码中使用时

737
00:24:54,926 --> 0:24:55,966
就和以前一样

738
00:24:56,556 --> 0:25:00,056
我们也可以储存它

739
00:24:56,556 --> 0:25:00,056
我们也可以储存它

740
00:25:00,056 --> 0:25:00,886
得到字符串值

741
00:25:00,886 --> 0:25:02,196
这个例子中 currentPassword

742
00:25:02,196 --> 0:25:03,976
现在是字符串 1234

743
00:25:06,166 --> 0:25:07,486
它的特殊之处在于

744
00:25:07,486 --> 0:25:08,776
我们要用 $

745
00:25:08,776 --> 0:25:09,426
作前缀引用它

746
00:25:09,786 --> 0:25:11,096
这样 我们就在访问

747
00:25:11,096 --> 0:25:11,916
被包装的值

748
00:25:12,616 --> 0:25:14,966
我们之后就能使用

749
00:25:14,966 --> 0:25:16,426
平常对发布者

750
00:25:16,426 --> 0:25:18,186
使用的操作符或订阅它

751
00:25:18,186 --> 0:25:20,216
此时要用 sink

752
00:25:20,216 --> 0:25:23,756
之后 如果我们要

753
00:25:23,756 --> 0:25:25,826
再将属性设定成另一个

754
00:25:25,826 --> 0:25:27,436
伟大的密码 password

755
00:25:28,136 --> 0:25:30,726
我们的订阅者就会在变化时收到值

756
00:25:31,626 --> 0:25:32,796
显然 这个人没有

757
00:25:32,796 --> 0:25:33,966
关注密码安全

758
00:25:37,196 --> 0:25:38,366
我们谈到 要对

759
00:25:38,366 --> 0:25:40,436
我们的两个发布者

760
00:25:40,436 --> 0:25:41,776
同时进行判断

761
00:25:44,086 --> 0:25:45,506
我们为它们添加了

762
00:25:45,586 --> 0:25:46,866
Published 属性 并添加了

763
00:25:46,866 --> 0:25:47,946
两个发布者也就是

764
00:25:47,946 --> 0:25:49,186
被发布的字符串 不会失败

765
00:25:49,906 --> 0:25:52,506
我们想要的结果是

766
00:25:52,506 --> 0:25:54,216
只发布一个

767
00:25:54,216 --> 0:25:56,306
验证过的密码

768
00:25:58,116 --> 0:25:59,726
我们为此有一个操作符

769
00:25:59,726 --> 0:26:01,496
叫做 CombineLatest

770
00:25:59,726 --> 0:26:01,496
叫做 CombineLatest

771
00:26:05,046 --> 0:26:06,106
这里是我们之前

772
00:26:06,386 --> 0:26:07,446
提到的两个属性

773
00:26:08,096 --> 0:26:09,766
借助 CombineLatest 我们就能

774
00:26:09,766 --> 0:26:11,366
引用带美元符号

775
00:26:11,456 --> 0:26:13,486
前缀的属性包装器

776
00:26:14,176 --> 0:26:16,096
之后 当任何一个改变时

777
00:26:16,166 --> 0:26:17,476
我们就能收到信号

778
00:26:17,856 --> 0:26:19,176
比方说 如果用户

779
00:26:19,176 --> 0:26:21,066
已经在密码字段输入了

780
00:26:21,136 --> 0:26:22,486
现在开始在

781
00:26:22,486 --> 0:26:24,166
密码确认字段中输入内容

782
00:26:24,686 --> 0:26:25,976
PasswordAgain 就会改变

783
00:26:25,976 --> 0:26:27,016
而 Password 仍是

784
00:26:27,016 --> 0:26:29,166
原先输入第一个字段的值

785
00:26:29,656 --> 0:26:32,156
之后 我们就能用闭包

786
00:26:32,156 --> 0:26:33,636
确保我们符合

787
00:26:33,636 --> 0:26:34,716
行业要求 也就是

788
00:26:34,716 --> 0:26:36,246
二者要相同 且长度

789
00:26:36,246 --> 0:26:38,856
都大于八个字符

790
00:26:38,896 --> 0:26:40,496
否则 我们就返回 nil

791
00:26:40,496 --> 0:26:41,496
因为我们要将

792
00:26:41,496 --> 0:26:42,676
这个信号与其他信号

793
00:26:42,676 --> 0:26:43,886
共同使用 判断我们的

794
00:26:43,886 --> 0:26:44,816
表单是否有效

795
00:26:45,616 --> 0:26:47,636
为此 我们将 nil 作为我们的信号

796
00:26:50,206 --> 0:26:52,596
所以 和类型一样

797
00:26:52,716 --> 0:26:54,946
类型反映了我们采取的措施

798
00:26:55,716 --> 0:26:56,726
我们可以直接在

799
00:26:56,726 --> 0:26:57,726
代码中读出

800
00:26:58,226 --> 0:27:00,106
我们有两个 Pulished 的字符串

801
00:26:58,226 --> 0:27:00,106
我们有两个 Pulished 的字符串

802
00:27:00,616 --> 0:27:02,116
我们组合了它们最新的值

803
00:27:02,376 --> 0:27:04,276
最后获得了可选字符串

804
00:27:07,076 --> 0:27:08,216
但如果我们的要求是

805
00:27:08,216 --> 0:27:09,146
想要确保

806
00:27:09,146 --> 0:27:10,046
人们不去用那些糟糕的密码

807
00:27:10,046 --> 0:27:12,206
并添加一个 Map 呢

808
00:27:13,256 --> 0:27:14,586
可以看到 类型在这里发生了变化

809
00:27:15,206 --> 0:27:16,846
可以看出 我们组合了

810
00:27:16,846 --> 0:27:18,156
两个 Published 字符串的

811
00:27:18,156 --> 0:27:20,076
最新值

812
00:27:20,076 --> 0:27:21,536
用 map 处理 得到可选字符串

813
00:27:23,006 --> 0:27:24,596
这很棒 可以在

814
00:27:24,596 --> 0:27:25,896
几乎所有用例中

815
00:27:25,896 --> 0:27:26,676
帮助调试

816
00:27:27,076 --> 0:27:28,406
但这个例子中 我们就

817
00:27:28,516 --> 0:27:29,706
把它作为 API 边界

818
00:27:29,826 --> 0:27:31,256
希望将它

819
00:27:31,256 --> 0:27:32,106
与其他发布者组合

820
00:27:32,106 --> 0:27:33,996
所以 如果我们

821
00:27:33,996 --> 0:27:35,626
能只关注重点的话 岂不美哉

822
00:27:35,626 --> 0:27:37,236
这里的重点是 这是一个

823
00:27:37,236 --> 0:27:39,126
可选字符串发布者不会失败

824
00:27:40,576 --> 0:27:43,416
为此 我们有一个操作符

825
00:27:43,416 --> 0:27:45,466
叫做 eraseToAnyPublisher

826
00:27:45,466 --> 0:27:47,226
可以返回可选字符串或 never 的

827
00:27:47,226 --> 0:27:48,856
AnyPublisher

828
00:27:49,346 --> 0:27:51,556
可以看到 类型

829
00:27:51,556 --> 0:27:53,016
并没有变化 但

830
00:27:53,016 --> 0:27:54,366
我们确实可以把它

831
00:27:54,366 --> 0:27:55,706
当作我们想要的 API

832
00:27:55,836 --> 0:27:57,306
边界推广 还能顺便

833
00:27:57,306 --> 0:27:58,856
隐藏所有的实现细节

834
00:28:01,056 --> 0:28:02,246
来回顾一下我们

835
00:28:02,246 --> 0:28:04,376
都做了什么 我们的

836
00:28:04,376 --> 0:28:05,816
初始属性是字符串

837
00:28:05,816 --> 0:28:07,386
为它添加了字符串发布者

838
00:28:07,676 --> 0:28:09,506
其中使用了 Published 属性包装器

839
00:28:10,056 --> 0:28:12,486
我们之后使用了 CombineLatest

840
00:28:12,486 --> 0:28:13,606
组合了这两个发布者的

841
00:28:13,606 --> 0:28:15,986
的最新值 并添加了

842
00:28:15,986 --> 0:28:16,926
我们的业务逻辑

843
00:28:17,436 --> 0:28:21,376
之后我们使用 map 来过滤

844
00:28:21,376 --> 0:28:24,696
糟糕的密码 最后

845
00:28:24,696 --> 0:28:26,046
我们用了 eraseToAnyPublishser

846
00:28:26,166 --> 0:28:27,566
因为这是 API 边界

847
00:28:27,566 --> 0:28:28,976
我们要将它和别的东西组合起来

848
00:28:32,276 --> 0:28:33,756
真了不起 我们有了第一个发布者

849
00:28:38,046 --> 0:28:40,716
接下来 我们还想

850
00:28:40,716 --> 0:28:42,146
为一些异步活动

851
00:28:42,146 --> 0:28:43,056
构建模型

852
00:28:43,626 --> 0:28:45,606
我们要保证用户名通过

853
00:28:45,606 --> 0:28:46,926
服务器验证 这需要

854
00:28:46,926 --> 0:28:48,546
快速处理用户输入

855
00:28:49,176 --> 0:28:51,706
和之前一样 我们给

856
00:28:52,296 --> 0:28:54,096
字符串属性存储添加 Pulished 属性

857
00:28:54,356 --> 0:28:55,706
再给 valueChanged

858
00:28:55,706 --> 0:28:58,336
属性挂上一个目标动作

859
00:28:58,796 --> 0:28:59,726
但这里有点特殊

860
00:28:59,726 --> 0:29:01,846
因为我们不想

861
00:28:59,726 --> 0:29:01,846
因为我们不想

862
00:29:01,846 --> 0:29:02,906
用户每输入

863
00:29:02,906 --> 0:29:04,296
一个字符 就

864
00:29:04,296 --> 0:29:05,576
发起一次网络运行

865
00:29:05,976 --> 0:29:07,276
不然 服务器会被挤爆的

866
00:29:07,276 --> 0:29:08,986
我们要让信号

867
00:29:08,986 --> 0:29:10,706
发送更顺畅

868
00:29:11,516 --> 0:29:13,066
为此 我们有函数防抖

869
00:29:13,826 --> 0:29:16,326
你可以用函数防抖

870
00:29:16,326 --> 0:29:17,786
制定你想接收值的窗口

871
00:29:17,786 --> 0:29:19,056
且接收值

872
00:29:19,056 --> 0:29:20,926
不早于这个窗口

873
00:29:20,926 --> 0:29:23,126
我们来看个实例

874
00:29:24,486 --> 0:29:25,986
这是我们的上游发布者

875
00:29:26,536 --> 0:29:27,496
这个例子中 这是一个

876
00:29:27,496 --> 0:29:29,596
文本字段 中间

877
00:29:29,596 --> 0:29:30,526
是函数防抖

878
00:29:30,856 --> 0:29:32,396
如果用户打字很快

879
00:29:33,436 --> 0:29:34,646
你就会看到 信号发送很快

880
00:29:35,566 --> 0:29:36,616
但我们可以使信号发送平滑

881
00:29:36,616 --> 0:29:38,136
在窗口中只传递一个信号

882
00:29:41,096 --> 0:29:42,456
这很好 但我们还能

883
00:29:42,456 --> 0:29:43,416
做得更好

884
00:29:45,026 --> 0:29:46,286
如果用户在窗口中打字

885
00:29:46,286 --> 0:29:48,516
而值最终

886
00:29:48,516 --> 0:29:49,576
一直都是相同的

887
00:29:49,576 --> 0:29:50,606
就没有理由再

888
00:29:50,606 --> 0:29:51,546
呼叫服务器

889
00:29:51,546 --> 0:29:53,116
看用户名是否有效

890
00:29:53,116 --> 0:29:55,786
所以 如果用户输入 Merlin

891
00:29:55,786 --> 0:29:58,806
我们会获取值 如果删除最后的 n

892
00:29:58,806 --> 0:30:00,726
再输入 n 就又成了 Merlin

893
00:29:58,806 --> 0:30:00,726
再输入 n 就又成了 Merlin

894
00:30:00,726 --> 0:30:01,626
但我们也不用再次

895
00:30:01,626 --> 0:30:02,206
呼叫服务器

896
00:30:02,836 --> 0:30:04,276
removeDuplicates 操作符就是

897
00:30:04,276 --> 0:30:04,536
实现这个的

898
00:30:05,206 --> 0:30:06,356
它可以确保我们不用

899
00:30:06,356 --> 0:30:07,746
在窗口内一遍

900
00:30:07,746 --> 0:30:11,296
又一遍地发布同一个值

901
00:30:11,426 --> 0:30:12,986
再来看代码 我们给

902
00:30:12,986 --> 0:30:14,656
用户名属性添加了

903
00:30:14,656 --> 0:30:15,236
Published

904
00:30:15,816 --> 0:30:18,126
之后我们使用函数防抖

905
00:30:18,126 --> 0:30:19,206
消除信号传输抖动

906
00:30:20,546 --> 0:30:22,176
最后 我们移除了重复项

907
00:30:22,706 --> 0:30:25,506
但我们还没有处理完

908
00:30:25,506 --> 0:30:26,586
异步操作

909
00:30:26,586 --> 0:30:27,756
我们刚刚平滑了信号

910
00:30:28,656 --> 0:30:29,646
我们真正想要的是

911
00:30:29,646 --> 0:30:30,586
查询服务器 看看

912
00:30:30,586 --> 0:30:31,566
用户名是否有效

913
00:30:32,136 --> 0:30:34,546
我们的 App 中

914
00:30:34,546 --> 0:30:35,786
已经有了一个函数

915
00:30:35,886 --> 0:30:37,026
叫做 usernameAvailable

916
00:30:38,106 --> 0:30:39,726
接下来 我要将它作为

917
00:30:39,726 --> 0:30:40,916
发布者引入

918
00:30:42,346 --> 0:30:44,226
从 Michael 的例子中 我们

919
00:30:44,226 --> 0:30:45,496
了解到 flatMap 能让你

920
00:30:45,496 --> 0:30:47,336
从流中获取值

921
00:30:47,536 --> 0:30:48,836
并返回新的发布者

922
00:30:49,416 --> 0:30:52,466
我们该如何调用它呢

923
00:30:53,696 --> 0:30:55,296
为此 我们有一个叫

924
00:30:55,296 --> 0:30:58,026
Future 的东西 当你

925
00:30:58,026 --> 0:30:58,966
构造的时候 你为它提供一个

926
00:30:58,966 --> 0:31:00,256
闭包 其中包括一个 promise

927
00:30:58,966 --> 0:31:00,256
闭包 其中包括一个 promise

928
00:31:01,006 --> 0:31:02,266
promise 就是一个

929
00:31:02,266 --> 0:31:04,046
闭包 其中包含结果

930
00:31:04,046 --> 0:31:05,936
可能是成功或失败

931
00:31:09,046 --> 0:31:10,686
它的使用非常直观

932
00:31:11,666 --> 0:31:13,466
我们调用 usernameAvailable 函数

933
00:31:13,466 --> 0:31:14,916
当它异步完成 我们

934
00:31:14,916 --> 0:31:17,026
获得值之后 我们在

935
00:31:17,026 --> 0:31:18,996
promise 中填充结果 这个例子里是 success

936
00:31:19,506 --> 0:31:21,006
和之前一样 我们表明

937
00:31:21,006 --> 0:31:22,946
如果不可用 结果是 nil

938
00:31:26,056 --> 0:31:28,146
我们来回顾一下步骤 最初

939
00:31:28,146 --> 0:31:29,126
我们有一个很简单的发布者

940
00:31:29,126 --> 0:31:31,136
也就是用户名发布者

941
00:31:31,536 --> 0:31:32,466
我们采用函数防抖

942
00:31:32,466 --> 0:31:34,286
平滑信号 并移除了

943
00:31:34,286 --> 0:31:35,936
窗口中的全部重复项

944
00:31:37,346 --> 0:31:39,236
之后 我们使用 Future 包装

945
00:31:39,236 --> 0:31:41,006
现有 API 来构造

946
00:31:41,006 --> 0:31:42,176
异步网络调用

947
00:31:42,176 --> 0:31:45,426
我们使用了 flatMap 来

948
00:31:45,426 --> 0:31:46,376
构造流分支

949
00:31:47,846 --> 0:31:49,556
之后 我们将它添加至任一

950
00:31:49,556 --> 0:31:51,196
发布者因为它是 API 边界

951
00:31:52,076 --> 0:31:53,276
现在我们就创造了

952
00:31:53,276 --> 0:31:54,696
两个自定义发布者

953
00:31:54,696 --> 0:31:57,066
分别是 validatedPassword 和

954
00:31:57,066 --> 0:31:58,036
validatedUsername

955
00:31:58,576 --> 0:32:01,566
接下来我们要组合它们

956
00:31:58,576 --> 0:32:01,566
接下来我们要组合它们

957
00:32:06,046 --> 0:32:07,086
现在 我们要做的是

958
00:32:07,086 --> 0:32:08,436
利用两个信号 一个是

959
00:32:08,436 --> 0:32:10,326
设备本地信号

960
00:32:10,326 --> 0:32:11,406
另一个是异步

961
00:32:11,406 --> 0:32:13,496
网络调用 并使用它们

962
00:32:13,496 --> 0:32:14,536
启用或禁用 UI

963
00:32:14,536 --> 0:32:16,876
我们已经知道该怎么做了

964
00:32:18,276 --> 0:32:19,896
我们使用 CombineLatest 操作符

965
00:32:20,386 --> 0:32:21,726
我们要获取之前

966
00:32:21,726 --> 0:32:22,476
创造的两个发布者

967
00:32:23,836 --> 0:32:24,796
我们要检查它们是否可用

968
00:32:25,696 --> 0:32:26,886
这个例子中 我们只

969
00:32:26,886 --> 0:32:29,026
返回一个元组 其中以可选

970
00:32:29,026 --> 0:32:32,956
包含全部证书 如果没有 则返回 nil

971
00:32:36,166 --> 0:32:37,236
将这些与你的 UI

972
00:32:37,236 --> 0:32:38,436
连接起来其实非常简单

973
00:32:39,636 --> 0:32:41,266
我们为登录按钮编写一个

974
00:32:41,836 --> 0:32:43,496
输出口

975
00:32:43,656 --> 0:32:46,666
我们创建一个实例变量来储存

976
00:32:46,666 --> 0:32:48,416
这个订阅 这样我们

977
00:32:48,416 --> 0:32:49,796
就能在这个视图控制器的

978
00:32:49,846 --> 0:32:50,746
全生命周期保留它

979
00:32:51,056 --> 0:32:52,036
因为我们想要

980
00:32:52,036 --> 0:32:53,856
在展示表单的全过程中

981
00:32:53,856 --> 0:32:54,706
启用或禁用这个按钮

982
00:32:57,056 --> 0:32:57,746
所以我们就存储它

983
00:32:58,546 --> 0:32:59,966
我们将它映射到一个布尔值

984
00:33:00,716 --> 0:33:02,216
因为我们想要把它

985
00:33:02,216 --> 0:33:03,756
赋值给按钮的 isEnabled 属性

986
00:33:06,156 --> 0:33:08,076
最后 我们使用 receive(on:)

987
00:33:08,076 --> 0:33:09,006
来切换到主线程

988
00:33:09,006 --> 0:33:10,206
这是我们需要对

989
00:33:10,206 --> 0:33:11,296
任何 UI 代码做的

990
00:33:11,296 --> 0:33:13,716
之后 我们使用 assign

991
00:33:13,716 --> 0:33:15,146
操作符 将它赋值给

992
00:33:15,146 --> 0:33:16,766
给定关键路径的

993
00:33:16,766 --> 0:33:22,486
signupButton 很了不起

994
00:33:22,486 --> 0:33:23,976
我们有了一切需要的东西

995
00:33:26,046 --> 0:33:26,906
总体来看 我们最初只有

996
00:33:26,906 --> 0:33:28,246
三个非常简单的发布者

997
00:33:28,246 --> 0:33:30,746
它们只能发布字符串

998
00:33:33,086 --> 0:33:35,386
之后 我们使用组合

999
00:33:35,386 --> 0:33:37,036
不断采取小改动

1000
00:33:37,036 --> 0:33:38,706
组建起了这些 创建了

1001
00:33:38,706 --> 0:33:40,696
最终的链条 之后

1002
00:33:40,696 --> 0:33:42,446
我们将它们组合起来 将它们赋值给按钮

1003
00:33:43,456 --> 0:33:44,976
这就是 Combine 的意义所在

1004
00:33:48,076 --> 0:33:49,956
所以 我建议大家马上上手

1005
00:33:50,296 --> 0:33:52,576
将你 App 的小部分

1006
00:33:52,576 --> 0:33:53,606
组合成自定义

1007
00:33:53,606 --> 0:33:55,046
发布者 找出

1008
00:33:55,046 --> 0:33:56,526
可以拆分成小型

1009
00:33:56,576 --> 0:33:58,416
发布者的小块逻辑 然后

1010
00:33:58,416 --> 0:34:00,026
不断使用组合 将它们

1011
00:33:58,416 --> 0:34:00,026
不断使用组合 将它们

1012
00:34:00,196 --> 0:34:01,836
全部连接起来

1013
00:34:02,656 --> 0:34:04,046
你完全可以逐渐采用

1014
00:34:04,046 --> 0:34:05,266
你不需要马上

1015
00:34:05,266 --> 0:34:07,276
改变所有东西

1016
00:34:07,276 --> 0:34:08,306
可以有所选择

1017
00:34:08,306 --> 0:34:09,346
我们认为 你可以使用 Future

1018
00:34:09,346 --> 0:34:14,085
实现现在已有的功能

1019
00:34:14,266 --> 0:34:15,596
你可以使用 Future

1020
00:34:15,596 --> 0:34:17,226
组合回调和其他内容 如我们刚才所见

1021
00:34:20,146 --> 0:34:21,676
欲知更多信息 请观看

1022
00:34:21,676 --> 0:34:24,176
我们的介绍 Combine 会议

1023
00:34:24,176 --> 0:34:26,456
以及 SwiftUI 的数据流会议

1024
00:34:26,456 --> 0:34:27,656
今天晚些时候 我们 

1025
00:34:27,656 --> 0:34:29,966
也会在 AppKit 实验室 谢谢大家

1026
00:34:30,516 --> 0:34:36,500
[掌声]
