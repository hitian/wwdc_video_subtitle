1
00:00:00,506 --> 0:00:04,500
[音乐]

2
00:00:09,516 --> 0:00:13,766
[掌声]

3
00:00:14,266 --> 0:00:16,026
&gt;&gt; 早上好 欢迎来到

4
00:00:16,026 --> 0:00:17,326
Instruments 入门指南

5
00:00:17,936 --> 0:00:19,356
我的名字叫 Tibet Rooney-Rabdau

6
00:00:19,356 --> 0:00:20,296
今天和我一起的是我的同事

7
00:00:20,436 --> 0:00:21,976
Ben Mitchell 和 Anand Subramanian

8
00:00:25,926 --> 0:00:27,376
要打造优秀的

9
00:00:27,376 --> 0:00:29,266
用户体验

10
00:00:29,266 --> 0:00:30,966
我第一个想到的就是性能

11
00:00:32,106 --> 0:00:33,786
灵敏的响应能让你的用户

12
00:00:34,436 --> 0:00:37,466
更加信任你的 App

13
00:00:37,656 --> 0:00:39,056
无论我多么喜欢某个 App 的 UI

14
00:00:39,056 --> 0:00:40,616
如果我不断看到加载动画

15
00:00:40,616 --> 0:00:43,126
或是电量掉得很快

16
00:00:43,126 --> 0:00:45,476
我获得的体验

17
00:00:45,476 --> 0:00:46,616
都变得不理想了

18
00:00:47,526 --> 0:00:49,156
如果你想在你的 App 中创造

19
00:00:49,156 --> 0:00:50,566
很棒的用户体验

20
00:00:50,566 --> 0:00:54,206
就要时刻注意这些问题

21
00:00:54,206 --> 0:00:55,256
在今天的会议中

22
00:00:55,256 --> 0:00:56,886
我们会与你分享我们

23
00:00:56,886 --> 0:00:58,016
最爱的性能分析工具

24
00:00:58,746 --> 0:00:59,366
Instruments

25
00:00:59,996 --> 0:01:01,956
这对于刚刚接触 Instruments

26
00:00:59,996 --> 0:01:01,956
这对于刚刚接触 Instruments

27
00:01:01,956 --> 0:01:03,226
并且想要在他们的

28
00:01:03,226 --> 0:01:04,096
工作流程中集成

29
00:01:04,096 --> 0:01:05,406
更好的 Instruments 的开发者来说

30
00:01:05,446 --> 0:01:06,456
是非常有帮助的

31
00:01:07,786 --> 0:01:08,916
性能分析不仅要趁早

32
00:01:08,916 --> 0:01:10,836
还要经常进行

33
00:01:11,046 --> 0:01:12,226
因为在开发过程中的

34
00:01:12,226 --> 0:01:13,166
任意阶段都可能

35
00:01:13,166 --> 0:01:14,486
引入回归 并且产生

36
00:01:14,486 --> 0:01:17,036
复合作用

37
00:01:17,036 --> 0:01:18,046
事实上 我把 Xcode Instruments

38
00:01:18,046 --> 0:01:19,616
当成我最好的帮手

39
00:01:19,616 --> 0:01:21,396
所以我会把它放在程序坞

40
00:01:21,396 --> 0:01:23,386
Xcode 的旁边

41
00:01:23,386 --> 0:01:25,076
提醒我从编程早期开始

42
00:01:25,076 --> 0:01:27,786
就要经常进行性能分析

43
00:01:28,516 --> 0:01:30,336
今天我们会从一个简单的介绍开始

44
00:01:30,336 --> 0:01:32,216
了解一下 Instruments 的功能与特性

45
00:01:32,216 --> 0:01:34,366
以及它的用户界面

46
00:01:35,286 --> 0:01:36,176
然后我们会向你展示

47
00:01:36,176 --> 0:01:37,816
如何用多种方式剖析你的 App

48
00:01:37,816 --> 0:01:39,836
来分析它的运行耗时

49
00:01:40,546 --> 0:01:41,786
我们会用一个

50
00:01:41,786 --> 0:01:43,586
叫做 Time Profiler 的工具

51
00:01:43,586 --> 0:01:45,586
来分析你的 App 在做什么

52
00:01:45,586 --> 0:01:46,506
以及做了多少

53
00:01:46,506 --> 0:01:49,126
最后 我们会讨论

54
00:01:49,126 --> 0:01:50,576
在你 App 中添加 Signpost

55
00:01:50,576 --> 0:01:53,486
来获取 App 行为的深度信息

56
00:01:54,136 --> 0:01:55,556
让我们先简要地

57
00:01:55,556 --> 0:01:57,146
了解一下 Instruments

58
00:01:57,686 --> 0:02:00,596
Instruments 是在 Xcode 工具集中的

59
00:01:57,686 --> 0:02:00,596
Instruments 是在 Xcode 工具集中的

60
00:02:00,596 --> 0:02:02,336
一个强大的性能分析

61
00:02:02,336 --> 0:02:04,596
与测试工具

62
00:02:05,306 --> 0:02:06,616
Instruments 可以帮助你

63
00:02:06,616 --> 0:02:08,166
在所有平台上分析你的 App

64
00:02:08,566 --> 0:02:10,866
包括 iOS macOS watchOS 和 tvOS

65
00:02:11,516 --> 0:02:13,326
这能让你更好地理解

66
00:02:13,326 --> 0:02:15,006
并优化它们的行为和性能

67
00:02:16,156 --> 0:02:17,356
你可以在开发 测试和调试

68
00:02:17,356 --> 0:02:19,216
过程中使用 Instruments

69
00:02:19,966 --> 0:02:21,176
另外 我有个好消息

70
00:02:21,646 --> 0:02:23,366
如果你有 Xcode 那么你就已经

71
00:02:23,416 --> 0:02:24,816
有 Instruments 了

72
00:02:25,426 --> 0:02:28,096
在 Xcode 的“Product”菜单中选择“Profile”

73
00:02:28,096 --> 0:02:30,406
尽管 Instruments 是内嵌在 Xcode 中

74
00:02:30,436 --> 0:02:32,306
且经常和 Xcode 一起使用的

75
00:02:32,546 --> 0:02:33,856
它还是一个单独的 App

76
00:02:34,046 --> 0:02:34,756
可以在有需要的时候

77
00:02:34,756 --> 0:02:35,956
单独使用

78
00:02:36,496 --> 0:02:37,716
你可以自由选择

79
00:02:37,776 --> 0:02:40,586
如何开始性能分析工作

80
00:02:40,896 --> 0:02:43,196
现在开始 我所说的“Instruments”

81
00:02:43,376 --> 0:02:45,026
会有两种不同的含义

82
00:02:45,886 --> 0:02:48,226
我们已经讨论过 Instruments App 了

83
00:02:48,226 --> 0:02:49,706
为什么取了个这样的名字呢

84
00:02:49,986 --> 0:02:51,576
因为它提供了一系列

85
00:02:51,576 --> 0:02:52,856
被称为 Instrument 的工具

86
00:02:52,856 --> 0:02:54,726
帮助你分析 App 中的错误

87
00:02:55,546 --> 0:02:56,826
在不容易理解

88
00:02:56,826 --> 0:02:58,046
我指的到底是什么的地方

89
00:02:58,046 --> 0:02:59,516
我会用“Instruments App”

90
00:02:59,516 --> 0:03:01,563
来指代这个 App

91
00:02:59,516 --> 0:03:01,563
来指代这个 App

92
00:03:02,486 --> 0:03:03,846
Instrument 会从插入在

93
00:03:03,846 --> 0:03:05,356
App 进程和操作系统的

94
00:03:05,356 --> 0:03:06,656
重要内部架构中

95
00:03:06,656 --> 0:03:10,596
收集时间序列追踪数据

96
00:03:11,466 --> 0:03:12,766
我们有时候会称

97
00:03:12,766 --> 0:03:14,606
Instrument 收集到的数据为“Treat”

98
00:03:15,766 --> 0:03:17,836
这里展示的是我最喜欢的几个 Instrument

99
00:03:18,436 --> 0:03:19,746
左边的 Time Profiler Instrument

100
00:03:19,746 --> 0:03:21,506
使用操作系统提供的内部架构

101
00:03:21,506 --> 0:03:23,156
以固定的时间间隔

102
00:03:23,156 --> 0:03:24,656
来收集相关线程的

103
00:03:24,656 --> 0:03:26,406
所有呼叫栈

104
00:03:27,276 --> 0:03:28,186
右边的 Points of Interest Instrument

105
00:03:28,186 --> 0:03:29,656
从你 App 中重要的区域收集数据

106
00:03:29,686 --> 0:03:30,886
让你能用多种 API

107
00:03:30,886 --> 0:03:32,406
对其加以强调

108
00:03:32,766 --> 0:03:37,056
比如 Signpost API

109
00:03:37,376 --> 0:03:38,986
当你一开始打开 Instruments 的时候

110
00:03:38,986 --> 0:03:40,196
你会看到一个模板列表

111
00:03:40,196 --> 0:03:41,896
就像在“Pages 文稿”或

112
00:03:41,896 --> 0:03:44,246
“Numbers 表格”中一样

113
00:03:44,646 --> 0:03:46,086
模板会提供一个

114
00:03:46,156 --> 0:03:47,526
预配置的 Instrument 集合

115
00:03:47,526 --> 0:03:49,186
帮你解决特定的性能问题

116
00:03:49,186 --> 0:03:51,536
就像“Pages 文稿”中的

117
00:03:51,536 --> 0:03:52,826
生日贺卡模板一样

118
00:03:52,826 --> 0:03:54,166
它会提供一个文档结构

119
00:03:54,166 --> 0:03:55,786
来帮助你创建生日贺卡

120
00:03:56,106 --> 0:03:57,846
Instruments 中有海量的模板

121
00:03:57,846 --> 0:03:59,336
我们无法再这个短暂的会议中一一介绍

122
00:03:59,336 --> 0:04:00,446
所以我们今天会着重讲讲

123
00:03:59,336 --> 0:04:00,446
所以我们今天会着重讲讲

124
00:04:00,446 --> 0:04:01,986
Time Profiler 这个模板

125
00:04:01,986 --> 0:04:03,066
它包括我刚刚提到的

126
00:04:03,066 --> 0:04:04,666
Time Profiler 和 Points of Interest

127
00:04:04,666 --> 0:04:06,216
这两个 Instrument 以及其他

128
00:04:07,296 --> 0:04:08,546
这些 Instrument 是

129
00:04:08,546 --> 0:04:09,466
了解响应程度和

130
00:04:09,466 --> 0:04:12,476
你 App 的占用程度的绝佳工具

131
00:04:12,476 --> 0:04:15,106
当你第一次打开 Time Profiler 模板的时候

132
00:04:15,106 --> 0:04:16,586
你会看到这样的

133
00:04:16,586 --> 0:04:17,916
一个空白文档

134
00:04:17,916 --> 0:04:19,586
等着你去进行分析工作

135
00:04:19,646 --> 0:04:22,136
你可以通过点按

136
00:04:22,136 --> 0:04:23,336
右上角的添加 Instrument 按钮

137
00:04:23,336 --> 0:04:26,106
来为你的文档添加额外的 Instrument

138
00:04:27,186 --> 0:04:28,286
然后 Instruments App 就会

139
00:04:28,286 --> 0:04:29,236
展现它的资源库面板

140
00:04:29,236 --> 0:04:30,446
包括了可用 Instrument

141
00:04:30,446 --> 0:04:32,436
的完整清单

142
00:04:33,706 --> 0:04:35,216
从这里 你可以找到新的 Instrument

143
00:04:35,216 --> 0:04:36,506
并将其拖到文档中

144
00:04:36,506 --> 0:04:37,976
来获取更多数据

145
00:04:39,356 --> 0:04:40,916
界面的左上角是

146
00:04:40,916 --> 0:04:42,036
分析控件

147
00:04:42,496 --> 0:04:43,816
这让你能够记录

148
00:04:43,816 --> 0:04:45,746
暂停 或者停止数据收集

149
00:04:46,516 --> 0:04:48,746
分析控件旁边是目标区域

150
00:04:49,416 --> 0:04:50,506
左边的目标设备列表

151
00:04:50,506 --> 0:04:52,166
让你能够选择

152
00:04:52,166 --> 0:04:53,716
你在分析时想用的设备

153
00:04:54,446 --> 0:04:56,216
这与 Xcode 中的目标区域很像

154
00:04:56,216 --> 0:04:57,426
你在那里可以选择

155
00:04:57,426 --> 0:04:59,326
在设备上进行分析时

156
00:04:59,326 --> 0:05:00,226
所用的设备和进程

157
00:04:59,326 --> 0:05:00,226
所用的设备和进程

158
00:05:01,316 --> 0:05:02,666
通常来说 你都会选择

159
00:05:02,666 --> 0:05:04,046
你 App 的进程做为目标进程

160
00:05:04,046 --> 0:05:05,846
但是 举个例子

161
00:05:05,846 --> 0:05:06,836
如果你在分析一个共享的扩展

162
00:05:06,836 --> 0:05:08,236
你可能会选择扩展进程

163
00:05:08,236 --> 0:05:09,846
作为目标进程 

164
00:05:09,846 --> 0:05:12,146
而它和你的 App 是相互独立的

165
00:05:12,406 --> 0:05:13,786
当我在 Time Profiler 模板中

166
00:05:13,786 --> 0:05:15,306
开始记录的时候

167
00:05:15,306 --> 0:05:16,226
文档会逐渐被

168
00:05:16,226 --> 0:05:18,326
追踪数据填充

169
00:05:18,326 --> 0:05:20,036
另外 使用 Instruments 记录

170
00:05:20,036 --> 0:05:21,136
会占用系统资源

171
00:05:21,136 --> 0:05:23,086
像你的 App 一样

172
00:05:23,826 --> 0:05:25,386
为了最小化对你的 App 的影响

173
00:05:25,696 --> 0:05:26,956
Instruments 还提供了一个叫做

174
00:05:26,956 --> 0:05:28,346
Last Few Seconds Mode（最后几秒模式）的功能

175
00:05:28,406 --> 0:05:30,586
有时候也叫做 Windowed Mode（窗口模式）

176
00:05:31,836 --> 0:05:33,436
Windowed Mode 会在记录结束之前

177
00:05:33,436 --> 0:05:34,886
阻止 Instruments 

178
00:05:34,886 --> 0:05:36,566
分析或显示结果

179
00:05:36,916 --> 0:05:38,326
它还会无视记录最后几秒之前

180
00:05:38,366 --> 0:05:39,466
发生的事件

181
00:05:40,256 --> 0:05:41,176
在你想要记录数据

182
00:05:41,176 --> 0:05:42,416
并在发现问题时停止时

183
00:05:42,466 --> 0:05:43,966
这个模式十分实用

184
00:05:44,676 --> 0:05:45,956
有些模板默认使用这个模式

185
00:05:45,956 --> 0:05:47,286
因为它们会在短时间内

186
00:05:47,286 --> 0:05:49,866
收集大量的数据

187
00:05:51,426 --> 0:05:52,406
现在我已经在 Time Profiler 模板中

188
00:05:52,406 --> 0:05:53,576
完成了一次记录

189
00:05:53,676 --> 0:05:55,336
大量的追踪数据

190
00:05:55,336 --> 0:05:56,686
布满了这个窗口的

191
00:05:56,686 --> 0:05:57,416
各个角落

192
00:05:58,096 --> 0:05:59,656
这可能看起来很复杂

193
00:05:59,656 --> 0:06:00,736
所以我们来分别看看

194
00:05:59,656 --> 0:06:00,736
所以我们来分别看看

195
00:06:00,736 --> 0:06:01,866
每个部分都在做什么

196
00:06:03,226 --> 0:06:04,786
在窗口顶端的部分

197
00:06:04,786 --> 0:06:06,266
包含了 Track Viewer（轨道查看器）

198
00:06:06,836 --> 0:06:08,516
一个 Track 会展示与某个事件源相关的

199
00:06:08,516 --> 0:06:10,166
时间序列追踪数据

200
00:06:10,166 --> 0:06:13,496
比如进程 线程 或者 CPU 核心

201
00:06:14,126 --> 0:06:15,696
单个的 Instrument

202
00:06:15,696 --> 0:06:16,716
可能会为多个轨道

203
00:06:16,816 --> 0:06:17,896
提供追踪数据

204
00:06:18,396 --> 0:06:20,806
在这个例子中 我们可以看到三个轨道

205
00:06:21,476 --> 0:06:22,846
最上面的轨道是

206
00:06:22,846 --> 0:06:23,846
Time Profiler Instrument 提供的

207
00:06:23,846 --> 0:06:26,796
一份关于我们 App 系统占用的总结

208
00:06:27,626 --> 0:06:29,166
第二个轨道展示了

209
00:06:29,166 --> 0:06:30,376
从 Points of Interest Instrument

210
00:06:30,456 --> 0:06:31,996
收集来的信息 这一点 Anand 稍后

211
00:06:31,996 --> 0:06:32,956
会为大家讲解

212
00:06:33,266 --> 0:06:34,406
下面的额外轨道

213
00:06:34,406 --> 0:06:36,006
把数据进行进一步的细分

214
00:06:36,726 --> 0:06:39,236
一个 Instrument 的追踪会生成

215
00:06:39,236 --> 0:06:40,466
数十个轨道

216
00:06:41,326 --> 0:06:42,876
你可以用 Track Filter

217
00:06:42,876 --> 0:06:44,296
来让它只显示 Instrument

218
00:06:44,296 --> 0:06:46,576
或者按线程或 CPU 核心细分

219
00:06:47,356 --> 0:06:48,636
你也可以获得更详细的数据

220
00:06:48,636 --> 0:06:51,646
或者按名称来搜索轨道

221
00:06:51,646 --> 0:06:52,886
在窗口的底部

222
00:06:52,886 --> 0:06:54,186
详细视图让你能够

223
00:06:54,286 --> 0:06:56,376
探索选定轨道的追踪信息

224
00:06:56,896 --> 0:06:58,546
在这个例子中

225
00:06:58,546 --> 0:07:00,436
我们选中了 Time Profiler 轨道

226
00:06:58,546 --> 0:07:00,436
我们选中了 Time Profiler 轨道

227
00:07:00,436 --> 0:07:01,826
我们可以探索追踪过程中

228
00:07:01,826 --> 0:07:02,986
每个线程调用的函数

229
00:07:03,726 --> 0:07:06,026
详细视图的右半部分

230
00:07:06,026 --> 0:07:07,526
你可以在检视器中

231
00:07:07,526 --> 0:07:09,016
找到扩展的详细视图

232
00:07:09,836 --> 0:07:11,506
这个视图可能会提供

233
00:07:11,506 --> 0:07:12,586
来自正在使用的 Instrument 的

234
00:07:12,586 --> 0:07:14,186
更详细的信息

235
00:07:14,186 --> 0:07:15,716
取决于当前情境以及所选项

236
00:07:16,416 --> 0:07:17,886
在这个例子中 由于我

237
00:07:17,886 --> 0:07:19,386
在使用 Time Profiler

238
00:07:19,386 --> 0:07:22,266
我会获得一个最“厚”调用栈的总结

239
00:07:22,746 --> 0:07:24,046
另一个及时监控

240
00:07:24,046 --> 0:07:25,806
当前情况的方式是

241
00:07:25,806 --> 0:07:26,886
通过 Inspection Head（探头）

242
00:07:27,686 --> 0:07:28,586
Inspection Head 是一个

243
00:07:28,586 --> 0:07:30,416
可以被放置在追踪中的

244
00:07:30,556 --> 0:07:32,616
一个特定时间点上的选择器

245
00:07:32,616 --> 0:07:33,646
以此来选中所有

246
00:07:33,646 --> 0:07:36,916
在那个时刻正在发生的事件或间隔

247
00:07:37,256 --> 0:07:38,486
被选中事件的额外细节

248
00:07:38,486 --> 0:07:40,686
会在悬浮标签上显示

249
00:07:41,116 --> 0:07:42,976
详细视图和额外详细视图

250
00:07:42,976 --> 0:07:44,856
会持续更新

251
00:07:44,856 --> 0:07:46,156
来在可用时跟踪

252
00:07:46,156 --> 0:07:47,406
选定事件的信息

253
00:07:48,566 --> 0:07:49,976
我们已经把每个部分过了一遍

254
00:07:49,976 --> 0:07:51,296
现在我们对 Instruments 的

255
00:07:51,296 --> 0:07:53,286
用户界面更加了解了

256
00:07:53,336 --> 0:07:54,866
窗口中展示的所有内容都是

257
00:07:55,116 --> 0:07:56,566
追踪文档的一部分

258
00:07:57,286 --> 0:07:59,046
追踪文档包括

259
00:07:59,046 --> 0:08:00,196
任何为分析工作配置好的 Instruments 

260
00:07:59,046 --> 0:08:00,196
任何为分析工作配置好的 Instruments 

261
00:08:00,196 --> 0:08:01,786
也包括收集到的数据

262
00:08:01,786 --> 0:08:04,656
以及你用于分析结果的视图

263
00:08:05,616 --> 0:08:07,746
Instruments App 能存储

264
00:08:07,746 --> 0:08:08,976
并重新打开这些追踪文档

265
00:08:09,226 --> 0:08:10,536
让你能够探索之前的结果

266
00:08:10,536 --> 0:08:12,216
或者把它们分享给同事

267
00:08:12,216 --> 0:08:13,446
以供研究

268
00:08:13,446 --> 0:08:15,926
接下来 我想邀请

269
00:08:15,926 --> 0:08:16,896
我的同事 Ben Mitchell

270
00:08:16,896 --> 0:08:18,056
来到舞台 他会通过实际操作

271
00:08:18,056 --> 0:08:19,616
来向各位展示一下

272
00:08:19,966 --> 0:08:25,416
谢谢 [掌声]

273
00:08:25,916 --> 0:08:26,446
&gt;&gt; 谢谢 Tibet

274
00:08:26,946 --> 0:08:27,536
Hello World

275
00:08:27,536 --> 0:08:29,036
我的名字是 Ben Mitchell

276
00:08:29,036 --> 0:08:29,926
正如 Tibet 所说 我会

277
00:08:29,926 --> 0:08:31,006
向各位展示如何使用

278
00:08:31,006 --> 0:08:32,405
Instruments 来分析你的 App

279
00:08:33,015 --> 0:08:33,686
我们开始吧

280
00:08:37,275 --> 0:08:38,506
对于你们中部分

281
00:08:38,506 --> 0:08:39,666
看过去年的大会

282
00:08:39,666 --> 0:08:42,176
WWDC2018 的人来说

283
00:08:42,176 --> 0:08:43,496
可能会觉得《Solar System》App 很熟悉

284
00:08:44,145 --> 0:08:45,286
我们大概在一年前上架了它

285
00:08:45,286 --> 0:08:46,036
并从我们的顾客那里收获了

286
00:08:46,036 --> 0:08:47,096
一些正面的反馈

287
00:08:47,636 --> 0:08:49,356
但是 也有一些没那么好的反馈

288
00:08:49,356 --> 0:08:51,606
具体来说 是在性能方面的

289
00:08:51,916 --> 0:08:53,676
我们的顾客报告了一些

290
00:08:53,676 --> 0:08:54,716
响应问题

291
00:08:55,436 --> 0:08:57,086
尤其是在较早的设备上

292
00:08:57,406 --> 0:08:59,036
在会议前 我重现了

293
00:08:59,036 --> 0:09:00,376
其中的一个问题

294
00:08:59,036 --> 0:09:00,376
其中的一个问题

295
00:09:00,376 --> 0:09:01,606
我想要用 Instruments 向各位展示一下

296
00:09:01,606 --> 0:09:02,716
来看看我们是不是

297
00:09:02,756 --> 0:09:03,466
能够修复它

298
00:09:04,096 --> 0:09:04,846
我们现在就开始吧

299
00:09:06,266 --> 0:09:07,166
现在 App 已经在运行了

300
00:09:07,166 --> 0:09:08,676
我们就直接打开 Instruments 吧

301
00:09:10,616 --> 0:09:11,756
Instruments 的模板选择器

302
00:09:11,756 --> 0:09:13,056
默认选中了 Time Profiler

303
00:09:13,056 --> 0:09:15,406
因为我在之前用过它

304
00:09:15,776 --> 0:09:17,006
Time Profiler 是一个

305
00:09:17,076 --> 0:09:18,336
分析在某个时间窗

306
00:09:18,336 --> 0:09:20,166
发生的问题的绝佳工具

307
00:09:20,596 --> 0:09:22,476
我选择 Time Profiler

308
00:09:22,476 --> 0:09:23,916
然后点按“Choose”按钮

309
00:09:23,916 --> 0:09:24,876
打开一个新的追踪文档

310
00:09:25,406 --> 0:09:27,366
由于我没有从 Xcode 打开它

311
00:09:27,366 --> 0:09:28,326
我要做的第一件事情就是

312
00:09:28,326 --> 0:09:30,826
选择我要追踪的进程

313
00:09:31,656 --> 0:09:32,906
使用目标选取区域

314
00:09:33,436 --> 0:09:36,046
我选择“All Processes”

315
00:09:36,046 --> 0:09:37,146
然后选择正在运行的

316
00:09:37,146 --> 0:09:38,286
“Solar System Mac”App

317
00:09:39,076 --> 0:09:40,796
你可以在右边看到一个数字

318
00:09:40,796 --> 0:09:42,136
那是进程标识符

319
00:09:42,136 --> 0:09:44,006
它会在“活动监视器”中显示

320
00:09:44,176 --> 0:09:47,426
我们已经选中了 App

321
00:09:47,426 --> 0:09:49,356
现在我们点按窗口左上角的

322
00:09:49,356 --> 0:09:50,246
记录按钮

323
00:09:52,336 --> 0:09:53,586
来吧 Instruments 开始记录了

324
00:09:54,606 --> 0:09:55,646
切换到 App 界面

325
00:09:56,796 --> 0:09:58,566
《Solar System》App 支持一系列

326
00:09:58,566 --> 0:10:00,516
触控板上的手势

327
00:09:58,566 --> 0:10:00,516
触控板上的手势

328
00:10:00,606 --> 0:10:01,986
包括点按拖动

329
00:10:02,346 --> 0:10:04,676
平移 缩放 等等

330
00:10:04,676 --> 0:10:06,696
我们的顾客报告说

331
00:10:06,696 --> 0:10:07,406
他们在使用这些操作时

332
00:10:07,406 --> 0:10:09,156
或者使用 Command-R 

333
00:10:09,156 --> 0:10:11,086
重载数据时

334
00:10:11,286 --> 0:10:12,666
用户界面会卡住

335
00:10:12,666 --> 0:10:14,436
并且会出现一个加载动画

336
00:10:15,036 --> 0:10:16,316
它或者有别的叫法

337
00:10:16,646 --> 0:10:17,616
这并不理想

338
00:10:18,126 --> 0:10:20,576
我们能再现这个问题

339
00:10:20,576 --> 0:10:21,666
所以我们切换回 Instruments

340
00:10:21,726 --> 0:10:22,566
然后看看我们能找到什么

341
00:10:23,416 --> 0:10:24,686
当我退出 App

342
00:10:24,686 --> 0:10:26,426
Instruments 会自动停止记录

343
00:10:26,656 --> 0:10:30,416
我们可以看到这里的追踪数据

344
00:10:30,416 --> 0:10:31,576
我要做的第一件事就是

345
00:10:31,576 --> 0:10:33,046
让它变大一点

346
00:10:33,046 --> 0:10:33,946
这样我们就能看到更多细节了

347
00:10:35,236 --> 0:10:36,296
当光标在跟踪区域上时

348
00:10:36,296 --> 0:10:37,816
用一个缩放手势

349
00:10:37,816 --> 0:10:39,736
就可以放大它

350
00:10:39,736 --> 0:10:40,926
让我们更清楚地看到细节

351
00:10:42,376 --> 0:10:43,786
在跟踪区域的左侧

352
00:10:43,786 --> 0:10:45,386
我们能看到几个 Instrument

353
00:10:45,386 --> 0:10:47,546
向我们提供了轨道

354
00:10:47,956 --> 0:10:49,046
Time Profiler 显示着

355
00:10:49,046 --> 0:10:50,626
CPU 占用的总结

356
00:10:50,986 --> 0:10:51,716
Points of Interest Instrument

357
00:10:51,716 --> 0:10:53,076
目前是空的

358
00:10:53,246 --> 0:10:54,256
Anand 稍后会为你展示这一点

359
00:10:54,366 --> 0:10:55,566
还有很多其他的 Instrument

360
00:10:55,566 --> 0:10:56,796
包括 Thermal State

361
00:10:56,796 --> 0:10:58,436
其他细分信息可以在滚动视图

362
00:10:58,436 --> 0:10:59,066
下方看到 

363
00:11:00,426 --> 0:11:01,986
如果我们把光标移动到

364
00:11:01,986 --> 0:11:04,146
CPU 用量总结轨道

365
00:11:04,146 --> 0:11:05,566
我们可以看到一个悬浮的标签

366
00:11:05,566 --> 0:11:07,126
展示当前的占用状态

367
00:11:08,196 --> 0:11:09,716
当我移动到这个大区域时

368
00:11:09,746 --> 0:11:12,526
会发现占用率超过了 100%

369
00:11:13,206 --> 0:11:13,956
这看起来很可疑

370
00:11:13,956 --> 0:11:15,956
我怀疑这就是重新加载操作

371
00:11:15,956 --> 0:11:17,516
发生的时间

372
00:11:18,076 --> 0:11:19,946
我想把它和一些其他的轨道

373
00:11:19,946 --> 0:11:20,806
放到一起比较

374
00:11:21,026 --> 0:11:21,976
我们要用到一个叫做

375
00:11:21,976 --> 0:11:22,786
Track Pinning 的功能

376
00:11:23,336 --> 0:11:25,956
在窗口左侧

377
00:11:25,956 --> 0:11:27,436
当我把鼠标移动到

378
00:11:27,436 --> 0:11:29,516
某个轨道条目上方时

379
00:11:29,516 --> 0:11:30,666
会出现一个加号按钮

380
00:11:31,956 --> 0:11:34,586
点按它 就可以把它固定到

381
00:11:34,586 --> 0:11:35,866
轨道区域底部

382
00:11:36,646 --> 0:11:37,956
现在我们可以

383
00:11:37,956 --> 0:11:39,536
滚动其他轨道

384
00:11:39,536 --> 0:11:41,016
并排看着我们感兴趣的这条轨道

385
00:11:41,496 --> 0:11:42,846
你可以固定多条轨道

386
00:11:44,246 --> 0:11:45,706
在我们向下滚动的同时

387
00:11:45,706 --> 0:11:46,956
我们可以看到系统中的

388
00:11:46,956 --> 0:11:47,746
每个 CPU 核心都在这里出问题了

389
00:11:48,236 --> 0:11:50,716
我们在这里还有一个

390
00:11:51,046 --> 0:11:52,566
针对进程本身的轨道条目

391
00:11:52,566 --> 0:11:54,006
Solar System Mac

392
00:11:54,006 --> 0:11:55,236
除了 CPU 用量总结

393
00:11:55,236 --> 0:11:56,576
这也向我们展示了

394
00:11:56,576 --> 0:11:57,486
App 生命周期事件

395
00:11:57,816 --> 0:11:58,616
我们可以看到在这里

396
00:11:58,616 --> 0:11:59,486
App 来到了前台

397
00:11:59,486 --> 0:12:01,646
因为那时我在程序坞点按了它

398
00:11:59,486 --> 0:12:01,646
因为那时我在程序坞点按了它

399
00:12:02,516 --> 0:12:04,266
还有一个可疑的红色区域

400
00:12:04,266 --> 0:12:06,926
就在 CPU 用量峰值附近这里

401
00:12:07,836 --> 0:12:09,026
把鼠标移动到上面

402
00:12:09,026 --> 0:12:10,416
可以看到标签上写着“Spinning”

403
00:12:11,756 --> 0:12:12,876
“Spinning”在 Instruments 中

404
00:12:12,876 --> 0:12:14,946
指的是 你的主线程卡住了

405
00:12:15,246 --> 0:12:16,266
在 Mac 上 这就是导致出现

406
00:12:16,266 --> 0:12:17,406
加载动画的原因

407
00:12:17,726 --> 0:12:19,496
主线程只有几个

408
00:12:19,496 --> 0:12:20,626
特别的用处

409
00:12:20,886 --> 0:12:21,806
它应该被用来处理

410
00:12:21,806 --> 0:12:24,316
用户的输入或者更新用户界面

411
00:12:24,766 --> 0:12:25,946
显然 这里有点不太对劲

412
00:12:29,186 --> 0:12:30,896
我想看看主线程

413
00:12:32,286 --> 0:12:35,026
我把 Solar System Mac 这个线程展开

414
00:12:35,866 --> 0:12:37,036
现在可以看到 有好多

415
00:12:37,036 --> 0:12:38,846
其他的轨道

416
00:12:38,846 --> 0:12:40,346
分别代表 App 中的每个线程

417
00:12:40,816 --> 0:12:42,776
一直向下滚动

418
00:12:43,406 --> 0:12:44,196
这就是主线程

419
00:12:44,196 --> 0:12:46,856
主线程出现了一个峰

420
00:12:47,466 --> 0:12:51,746
这看起来就是我想要仔细看看的事件

421
00:12:51,746 --> 0:12:52,886
接下来我们要用到的

422
00:12:52,886 --> 0:12:54,296
Instruments 的功能让我们能够

423
00:12:54,296 --> 0:12:56,166
通过在轨道区域点按和拖动

424
00:12:56,166 --> 0:12:57,616
来过滤事件

425
00:12:58,726 --> 0:12:59,576
现在 底部的详细视图

426
00:12:59,576 --> 0:13:00,826
只显示选定时间窗中

427
00:12:59,576 --> 0:13:00,826
只显示选定时间窗中

428
00:13:00,866 --> 0:13:02,016
发生的事件

429
00:13:02,896 --> 0:13:03,936
我们来深入看看详细视图

430
00:13:04,066 --> 0:13:05,286
来了解更多

431
00:13:05,856 --> 0:13:09,186
详细视图为我们展现了一个调用图

432
00:13:09,186 --> 0:13:10,266
这些都是我们在

433
00:13:10,266 --> 0:13:12,476
分析时所调用的函数

434
00:13:12,636 --> 0:13:13,586
或者 在这个例子中

435
00:13:13,586 --> 0:13:15,106
是在我们从过滤器选中的时间中

436
00:13:15,796 --> 0:13:18,316
理解这是在做什么很重要

437
00:13:18,316 --> 0:13:21,326
我们并不是在追踪

438
00:13:21,326 --> 0:13:22,776
每个函数的进入和推出

439
00:13:23,366 --> 0:13:24,946
其实 Time Profiler 每秒

440
00:13:24,946 --> 0:13:26,526
会捕获许多次快照

441
00:13:26,706 --> 0:13:28,336
并且记录你的进程中

442
00:13:28,336 --> 0:13:29,726
所有正在运行的函数

443
00:13:30,886 --> 0:13:32,536
所以在左侧

444
00:13:32,536 --> 0:13:33,216
我们有一个等待列

445
00:13:34,476 --> 0:13:37,126
Solar System Mac 在 100% 时间都有出现

446
00:13:37,406 --> 0:13:38,726
这意味着 在每次采样中

447
00:13:38,726 --> 0:13:40,016
Solar System Mac 都出现了

448
00:13:40,356 --> 0:13:41,276
这很好 因为这正是我们

449
00:13:41,276 --> 0:13:42,406
要分析的 App

450
00:13:43,266 --> 0:13:44,336
我们向下继续看

451
00:13:44,336 --> 0:13:47,376
可以看到主线程的出现率为 96.7% 等等

452
00:13:47,826 --> 0:13:49,126
我们继续展开这些线程

453
00:13:49,126 --> 0:13:50,476
来看看我们调用的

454
00:13:50,476 --> 0:13:51,436
更深的函数

455
00:13:52,376 --> 0:13:53,356
但是这里有很多函数

456
00:13:53,596 --> 0:13:54,966
我必须点按很多次

457
00:13:54,966 --> 0:13:56,186
才能找到一些有趣的东西

458
00:13:56,726 --> 0:13:58,736
为此 Instruments 提供了另一个实用的技巧

459
00:13:58,736 --> 0:14:00,606
如果你按住 Option 键

460
00:13:58,736 --> 0:14:00,606
如果你按住 Option 键

461
00:14:00,846 --> 0:14:01,646
在点按关闭三角形

462
00:14:01,646 --> 0:14:03,096
Instruments 就会自动

463
00:14:03,096 --> 0:14:04,696
展开轨道列表

464
00:14:04,696 --> 0:14:06,166
知道出现控制流分支

465
00:14:06,236 --> 0:14:08,506
因为这可能会是我们想要找的事件

466
00:14:08,506 --> 0:14:10,956
可以看到 这里有非常多

467
00:14:10,956 --> 0:14:12,696
要一直深挖并且精确地

468
00:14:12,696 --> 0:14:14,706
找到你的问题 会十分困难

469
00:14:15,016 --> 0:14:16,866
所以 Instruments 也在

470
00:14:17,216 --> 0:14:18,676
Time Profiler 的扩展详细视图

471
00:14:18,676 --> 0:14:20,466
提供了最厚栈追踪

472
00:14:21,746 --> 0:14:23,266
最厚栈追踪是一个

473
00:14:23,676 --> 0:14:24,496
我们在分析过程中

474
00:14:24,496 --> 0:14:26,836
最常调用的函数集合

475
00:14:27,706 --> 0:14:28,756
所以 在最上方

476
00:14:28,756 --> 0:14:30,396
我们可以看到 Solar System Mac

477
00:14:30,396 --> 0:14:31,536
并且部分帧被

478
00:14:31,536 --> 0:14:32,506
高亮为白色了

479
00:14:33,466 --> 0:14:35,606
这些就是你自己的进程的帧

480
00:14:37,636 --> 0:14:38,616
系统框架或库中的帧

481
00:14:38,616 --> 0:14:40,656
会显示为灰色

482
00:14:41,686 --> 0:14:43,186
所以 主线程执行主函数

483
00:14:43,186 --> 0:14:44,506
然后这里有一块是

484
00:14:44,506 --> 0:14:46,706
系统框架提供的函数

485
00:14:47,276 --> 0:14:50,356
在更下面的这里 我们发现了

486
00:14:50,356 --> 0:14:52,636
另一个高亮函数区域

487
00:14:53,656 --> 0:14:55,416
这里的第一项被标记为“thunk”

488
00:14:56,526 --> 0:14:57,206
那么“thunk”是什么呢

489
00:14:58,136 --> 0:15:00,396
这是一段由编译器生成的帮助代码

490
00:14:58,136 --> 0:15:00,396
这是一段由编译器生成的帮助代码

491
00:15:00,706 --> 0:15:01,876
它与你 App 中的任何代码

492
00:15:01,876 --> 0:15:03,206
都没有关联

493
00:15:03,656 --> 0:15:05,536
所以在这个例子中 我们可以无视它

494
00:15:06,036 --> 0:15:07,666
我们想要看的是这一个

495
00:15:07,666 --> 0:15:09,466
在网络请求调度程序中的

496
00:15:09,466 --> 0:15:10,906
某个方法中的第一个闭包

497
00:15:12,346 --> 0:15:13,996
如果我点按这一行

498
00:15:13,996 --> 0:15:15,046
它就在详细视图中杯选中了

499
00:15:15,966 --> 0:15:17,576
双击它就会直接在这里

500
00:15:17,576 --> 0:15:18,486
显示它的源代码

501
00:15:19,836 --> 0:15:20,586
所以 可以看到我们有

502
00:15:20,586 --> 0:15:22,226
一个方法叫做 scheduleParsingTask

503
00:15:22,766 --> 0:15:24,056
它在主分发队列中做一些事情

504
00:15:24,056 --> 0:15:26,506
包括数据解析 

505
00:15:26,506 --> 0:15:29,506
它看起来很有问题

506
00:15:29,506 --> 0:15:30,576
之前我们提到过

507
00:15:30,576 --> 0:15:31,516
主线程只应该在

508
00:15:31,516 --> 0:15:33,936
用户输入或更新用户界面的时候使用

509
00:15:34,366 --> 0:15:35,476
所以 我想要修复一下这里

510
00:15:36,006 --> 0:15:37,586
在详细视图的右上角

511
00:15:37,586 --> 0:15:39,636
有一个“在 Xcode 中打开”的按钮

512
00:15:40,286 --> 0:15:40,926
我来点一下

513
00:15:45,576 --> 0:15:47,096
然后 Xcode 就出现了

514
00:15:48,126 --> 0:15:49,976
我想要把这个移动到

515
00:15:49,976 --> 0:15:51,226
它自己的分发队列中

516
00:15:51,226 --> 0:15:52,276
这样它就不会阻碍主线程了

517
00:15:53,276 --> 0:15:54,056
我们首先要做的事情是

518
00:15:54,056 --> 0:15:55,226
创建这个分发队列

519
00:15:55,766 --> 0:15:58,406
我们称之为 parsingQueue

520
00:15:58,616 --> 0:16:00,766
然后 我们把工作移到 parsingQueue 中

521
00:15:58,616 --> 0:16:00,766
然后 我们把工作移到 parsingQueue 中

522
00:16:00,766 --> 0:16:04,106
通过一个异步闭包来实现

523
00:16:05,226 --> 0:16:06,646
把 workItem() 移上来

524
00:16:07,486 --> 0:16:08,536
我们还想在解析完成之后

525
00:16:08,536 --> 0:16:11,406
通知用户界面

526
00:16:11,886 --> 0:16:13,256
所以 我们把这个调用后面接上

527
00:16:13,256 --> 0:16:16,286
DispatchQueue.main

528
00:16:16,836 --> 0:16:18,486
存储 然后试试再一次

529
00:16:18,486 --> 0:16:19,766
复现我们的 Bug

530
00:16:20,606 --> 0:16:22,256
这一次 我在“Product”菜单中

531
00:16:22,256 --> 0:16:24,576
选择“Profile” 就像 Tibet 之前演示的那样

532
00:16:25,136 --> 0:16:28,726
Xcode 开始构建 App

533
00:16:28,726 --> 0:16:29,776
并唤起 Instruments

534
00:16:30,706 --> 0:16:31,466
模板选择器再一次弹出来了

535
00:16:31,466 --> 0:16:33,036
因为这一次我们不是在测试

536
00:16:33,066 --> 0:16:34,196
这个 App 的下载好的副本

537
00:16:34,196 --> 0:16:35,636
我们在测试

538
00:16:35,636 --> 0:16:36,796
Xcode 已经放到硬盘的

539
00:16:36,846 --> 0:16:38,226
数据路径里的那个

540
00:16:39,526 --> 0:16:41,176
选择“Time Profiler” 

541
00:16:41,326 --> 0:16:42,076
然后点按“Choose”

542
00:16:42,586 --> 0:16:45,956
这一次 我们不用选取目标

543
00:16:45,956 --> 0:16:47,536
因为 Xcode 已经通知了 Instruments

544
00:16:47,536 --> 0:16:48,696
我们想要测试的 App

545
00:16:48,696 --> 0:16:50,116
是哪一个

546
00:16:51,306 --> 0:16:52,976
然后 点按左上角的记录按钮

547
00:16:52,976 --> 0:16:58,756
会让它自动开始运行

548
00:16:58,786 --> 0:17:00,426
切换到 App 我们来试试

549
00:16:58,786 --> 0:17:00,426
切换到 App 我们来试试

550
00:17:00,426 --> 0:17:02,856
那个有问题的用户输入序列

551
00:17:03,716 --> 0:17:07,036
点按 拖动 Command-R

552
00:17:07,386 --> 0:17:10,226
看 这一次没有加载动画了

553
00:17:10,945 --> 0:17:12,366
我们再试一次来确认一下

554
00:17:13,356 --> 0:17:15,425
点按 拖动 Command-R

555
00:17:16,106 --> 0:17:17,996
没有加载动画

556
00:17:18,476 --> 0:17:20,266
所以 我们已经处理了响应问题

557
00:17:21,205 --> 0:17:23,986
停止记录 再次用缩放手势

558
00:17:23,986 --> 0:17:25,626
来展开轨道视图

559
00:17:26,376 --> 0:17:27,746
我想要确认这个工作

560
00:17:27,786 --> 0:17:28,766
已经从主线程移除了

561
00:17:28,766 --> 0:17:30,456
所以我会用轨道过滤器区域

562
00:17:30,456 --> 0:17:32,646
在界面的左上角

563
00:17:33,306 --> 0:17:35,436
然后我们搜索主线程

564
00:17:36,956 --> 0:17:37,896
只出现了一个条目

565
00:17:37,896 --> 0:17:39,706
是 Solar System Mac 的

566
00:17:39,706 --> 0:17:41,516
如果我展开它

567
00:17:41,516 --> 0:17:42,366
可以看到主线程是可见的

568
00:17:43,836 --> 0:17:45,716
在这里 我们 CPU 用量到达峰值的地方

569
00:17:45,716 --> 0:17:47,486
主线程做的事情相对较少

570
00:17:47,486 --> 0:17:48,826
并且在第二个时间区间

571
00:17:49,316 --> 0:17:51,966
也是相同的情况

572
00:17:52,806 --> 0:17:54,076
这样看来 我们似乎已经解决了

573
00:17:54,076 --> 0:17:55,206
响应问题 并且把这个工作

574
00:17:55,206 --> 0:17:56,496
从主线程移除了

575
00:17:57,516 --> 0:18:02,026
[掌声]

576
00:17:57,516 --> 0:18:02,026
[掌声]

577
00:18:02,526 --> 0:18:04,956
我想再谈谈几个分析注意事项

578
00:18:05,616 --> 0:18:07,086
首先 Time Profiler 是一个

579
00:18:07,086 --> 0:18:08,376
理解你的 App 是如何使用时间的

580
00:18:08,376 --> 0:18:09,406
绝佳工具

581
00:18:10,456 --> 0:18:11,846
可能会在有响应问题的时候用的上

582
00:18:11,846 --> 0:18:13,216
比如 加载动画

583
00:18:13,486 --> 0:18:14,566
也可能在你想要

584
00:18:14,566 --> 0:18:15,756
加速 App 的启动

585
00:18:15,806 --> 0:18:16,836
来让它更快地显示在

586
00:18:16,836 --> 0:18:18,156
用户眼前的时候用得上

587
00:18:18,756 --> 0:18:20,266
在这些情况中 请使用 Time Profiler

588
00:18:22,296 --> 0:18:23,386
第二点 如果你遇到了响应问题

589
00:18:23,386 --> 0:18:25,086
看看你的主线程

590
00:18:25,646 --> 0:18:26,636
主线程真的只应该被用来

591
00:18:26,636 --> 0:18:27,936
更新用户界面

592
00:18:27,936 --> 0:18:29,366
或者处理用户输入事件

593
00:18:29,616 --> 0:18:31,656
比如 Mac 上的鼠标点按

594
00:18:31,656 --> 0:18:32,996
或是 iOS 设备上的屏幕轻点

595
00:18:34,516 --> 0:18:36,566
第三点 是我之前没有提到过的

596
00:18:37,286 --> 0:18:38,766
你应该在发布模式中进行分析

597
00:18:39,676 --> 0:18:40,846
编译器支持一系列

598
00:18:40,846 --> 0:18:42,156
不同的优化等级

599
00:18:42,286 --> 0:18:43,116
当你在 Xcode 中进行

600
00:18:43,116 --> 0:18:45,436
构建-运行循环的时候

601
00:18:45,436 --> 0:18:46,766
我们会用一个低等级的优化

602
00:18:46,766 --> 0:18:47,866
来让这个过程更快一些

603
00:18:48,446 --> 0:18:49,666
但这个优化等级

604
00:18:49,666 --> 0:18:50,686
并不是当你用 App Store

605
00:18:50,686 --> 0:18:52,526
或 Xcode 的存档功能

606
00:18:52,526 --> 0:18:54,316
把 App 递交给用户时所用的

607
00:18:54,766 --> 0:18:57,736
如果你在使用 Xcode 的默认配置

608
00:18:57,736 --> 0:18:59,756
在你的方法下的分析 

609
00:18:59,756 --> 0:19:02,646
会被设置为发布配置

610
00:18:59,756 --> 0:19:02,646
会被设置为发布配置

611
00:19:03,286 --> 0:19:04,316
然而 如果你在用

612
00:19:04,316 --> 0:19:05,936
自定义编译选项 请确保

613
00:19:05,936 --> 0:19:07,476
你在分析的 App 正在使用

614
00:19:07,476 --> 0:19:08,916
编译选项的发布工具集

615
00:19:10,596 --> 0:19:12,116
最后 使用不同负荷

616
00:19:12,116 --> 0:19:13,426
或在较早设备上进行分析

617
00:19:13,426 --> 0:19:14,416
十分重要

618
00:19:14,876 --> 0:19:16,236
在这个例子中

619
00:19:16,236 --> 0:19:18,566
我们没有在我们的设备上发现这个 Bug

620
00:19:18,566 --> 0:19:19,766
但是拥有不同性能特征设备的用户

621
00:19:19,766 --> 0:19:22,226
确实遇到了这个 Bug

622
00:19:22,866 --> 0:19:24,216
所以 如果你有较早的设备

623
00:19:24,216 --> 0:19:27,226
请确保在它们上面也进行测试

624
00:19:27,916 --> 0:19:29,696
Tibet 之前提到过

625
00:19:29,816 --> 0:19:31,456
Instruments 支持所有平台

626
00:19:31,776 --> 0:19:33,396
我们用 Mac 进行了展示

627
00:19:33,396 --> 0:19:35,496
但是在 iOS watchOS 和 tvOS 上

628
00:19:35,626 --> 0:19:37,016
也同样可以使用它

629
00:19:37,766 --> 0:19:39,496
它也支持模拟器

630
00:19:39,686 --> 0:19:41,116
但是说到模拟器

631
00:19:41,116 --> 0:19:42,256
有一点请大家务必了解

632
00:19:43,266 --> 0:19:45,596
它是在你的 Mac 上运行的

633
00:19:45,596 --> 0:19:47,906
这意味着它有着你的 Mac 的资源

634
00:19:48,856 --> 0:19:51,636
它有你 Mac 的 CPU 和内存的性能特征

635
00:19:51,926 --> 0:19:54,876
它有着你 Mac 的文件系统行为和硬盘行为

636
00:19:55,216 --> 0:19:56,776
它还有这你 Mac 的散热限制

637
00:19:57,046 --> 0:19:58,186
这一点当然会和

638
00:19:58,186 --> 0:19:59,326
轻巧的一体化设备

639
00:19:59,326 --> 0:20:00,996
有重大差异

640
00:19:59,326 --> 0:20:00,996
有重大差异

641
00:20:01,956 --> 0:20:03,066
在这个例子中 Instruments 非常适合用来

642
00:20:03,066 --> 0:20:04,276
观测趋势 比如

643
00:20:04,366 --> 0:20:06,256
有没有什么东西变快了或者变慢了

644
00:20:06,876 --> 0:20:08,306
但是它不会给你提供

645
00:20:08,306 --> 0:20:10,106
精确到秒的模拟

646
00:20:10,106 --> 0:20:11,836
来告诉你 App 会怎样运行

647
00:20:12,366 --> 0:20:13,626
在把 App 递交到你顾客手上之前

648
00:20:13,626 --> 0:20:15,406
请确保在实体硬件上进行测试

649
00:20:16,516 --> 0:20:17,866
所以 我们刚刚解决了响应问题

650
00:20:17,866 --> 0:20:20,206
但是这并不是全部的问题

651
00:20:20,526 --> 0:20:21,646
我们的 CPU 用量还有一个很大的峰

652
00:20:21,686 --> 0:20:24,326
看起来是我们应该能削减它

653
00:20:25,536 --> 0:20:27,186
CPU 用量会榨干电池容量

654
00:20:27,526 --> 0:20:29,106
它会升高设备的温度

655
00:20:29,106 --> 0:20:30,766
在很多 Mac 上 会导致

656
00:20:30,766 --> 0:20:32,406
风扇加速运转 让你的用户感到烦躁

657
00:20:33,206 --> 0:20:34,856
所以 现在我想邀请

658
00:20:34,956 --> 0:20:36,836
Anand 用 Signpost 功能

659
00:20:36,836 --> 0:20:38,206
来帮助我们深入了解

660
00:20:38,206 --> 0:20:39,326
我们的 App 到底在做什么

661
00:20:41,516 --> 0:20:44,376
[掌声]

662
00:20:44,876 --> 0:20:45,376
&gt;&gt; 谢谢 Ben

663
00:20:46,446 --> 0:20:47,186
大家早上好

664
00:20:48,236 --> 0:20:49,786
今天我想向你们展示如何在

665
00:20:49,786 --> 0:20:52,496
代码中使用 Signpost 

666
00:20:52,496 --> 0:20:53,786
来增强 Instruments

667
00:20:53,786 --> 0:20:55,706
从中收集的追踪 并更好地理解

668
00:20:55,816 --> 0:20:58,626
你的代码时如何使用系统资源的

669
00:21:01,016 --> 0:21:03,206
我们首先通过与

670
00:21:03,206 --> 0:21:05,776
我们用 Time Profiler 所做的事情

671
00:21:05,806 --> 0:21:07,916
进行对比 来更好地理解 Signpost

672
00:21:08,836 --> 0:21:10,176
Time Profiler 构建了一个

673
00:21:10,506 --> 0:21:12,686
你的代码的统计分析

674
00:21:12,686 --> 0:21:15,396
它是通过在一个固定时间间隔内

675
00:21:15,396 --> 0:21:16,786
观测你的 App 中所有的线程

676
00:21:16,786 --> 0:21:18,756
并且构建出时间和调用栈的相关分析

677
00:21:18,756 --> 0:21:21,526
来实现这一点的

678
00:21:22,336 --> 0:21:23,796
但是 相关分析并不能

679
00:21:23,796 --> 0:21:25,636
取代精准评估

680
00:21:25,746 --> 0:21:26,876
告诉你你的代码

681
00:21:26,986 --> 0:21:28,946
是怎样执行的 以及为什么会执行

682
00:21:30,116 --> 0:21:31,326
可能会有一块代码

683
00:21:31,636 --> 0:21:33,746
在几个时间点爆发性地执行

684
00:21:34,456 --> 0:21:37,066
或者 它在几个更长的时间段内

685
00:21:37,066 --> 0:21:37,916
持续执行

686
00:21:38,736 --> 0:21:39,986
在某些特定 Argument 上

687
00:21:39,986 --> 0:21:41,636
调用的某个函数

688
00:21:42,056 --> 0:21:44,096
也可能会让 CPU 持续繁忙

689
00:21:45,136 --> 0:21:46,386
为了区分这几种

690
00:21:46,386 --> 0:21:48,326
执行模式 你需要记录

691
00:21:48,326 --> 0:21:50,686
代码的精确评估

692
00:21:50,896 --> 0:21:53,316
这就引出了一个问题

693
00:21:53,856 --> 0:21:55,276
你能操作的

694
00:21:55,276 --> 0:21:57,156
记录性能测量的最好方式是什么

695
00:21:58,236 --> 0:21:59,946
我很开心地告诉你

696
00:21:59,946 --> 0:22:00,906
你不需要担心

697
00:21:59,946 --> 0:22:00,906
你不需要担心

698
00:22:00,906 --> 0:22:02,496
要去打印代码

699
00:22:02,496 --> 0:22:04,506
并教会 Instruments 如何读取你的打印命令

700
00:22:05,096 --> 0:22:06,736
你只需要使用 Signpost

701
00:22:08,236 --> 0:22:10,036
Signpost 有大量在这个用例下

702
00:22:10,036 --> 0:22:12,166
十分理想的功能

703
00:22:12,646 --> 0:22:17,346
它是专门为记录有结构的性能数据打造的

704
00:22:17,766 --> 0:22:19,286
所以 在这种情况下

705
00:22:19,286 --> 0:22:21,136
它甚至比打印还要简单高效

706
00:22:21,716 --> 0:22:25,706
它提供了对评估时间的内建支持

707
00:22:26,036 --> 0:22:26,966
所以 你不需要担心

708
00:22:26,966 --> 0:22:28,516
你在读取的时钟源

709
00:22:28,516 --> 0:22:30,016
或是你正在使用什么时钟基准

710
00:22:30,016 --> 0:22:30,596
来进行评估

711
00:22:31,546 --> 0:22:33,666
关于 Signpost 我最喜欢的部分是

712
00:22:33,776 --> 0:22:36,656
Instruments 知道如何追踪它

713
00:22:37,056 --> 0:22:38,186
让我来给你一个简单的预览

714
00:22:38,186 --> 0:22:39,706
看看在代码中加入 Signpost 间隔后

715
00:22:39,706 --> 0:22:41,666
我收集到的 Instruments 的追踪

716
00:22:41,666 --> 0:22:44,756
是什么样子的

717
00:22:44,946 --> 0:22:46,236
这里高亮的是

718
00:22:46,236 --> 0:22:47,836
“Points of Interest”轨道

719
00:22:47,836 --> 0:22:49,516
它展示了与某个

720
00:22:49,516 --> 0:22:52,076
我在代码中加入的 Signpost

721
00:22:52,076 --> 0:22:53,226
相关的重点区域

722
00:22:54,226 --> 0:22:55,736
让我来给你们

723
00:22:55,736 --> 0:22:57,996
具体演示一下 接着刚刚

724
00:22:57,996 --> 0:23:03,686
Ben 对《Solar System》App 的研究

725
00:22:57,996 --> 0:23:03,686
Ben 对《Solar System》App 的研究

726
00:23:04,056 --> 0:23:06,996
这是刚才的 Instruments 追踪

727
00:23:06,996 --> 0:23:11,036
我们看到了这一块

728
00:23:14,176 --> 0:23:17,086
熟悉的高 CPU 占用区域

729
00:23:17,656 --> 0:23:20,536
我们想弄清楚为什么

730
00:23:20,596 --> 0:23:22,566
我们用了这么多 CPU 时间

731
00:23:22,566 --> 0:23:23,976
所以我们来向代码中使用最多

732
00:23:24,056 --> 0:23:26,066
CPU 时间的部分添加一些 Signpost

733
00:23:26,856 --> 0:23:28,726
让我来看看厚栈的追踪

734
00:23:32,576 --> 0:23:34,676
之前 Ben 从上往下

735
00:23:34,676 --> 0:23:36,676
看了这个厚栈

736
00:23:36,676 --> 0:23:39,746
所以我们发现了

737
00:23:39,746 --> 0:23:41,896
代码是如何在主线程开始执行的

738
00:23:42,826 --> 0:23:44,276
这一次 我想要从

739
00:23:44,276 --> 0:23:45,716
叶级函数开始

740
00:23:45,716 --> 0:23:51,046
来了解这个负载中最耗资源

741
00:23:51,046 --> 0:23:53,416
或是最常被调用的函数是什么

742
00:23:54,366 --> 0:23:55,366
这里有一个叫做 setupScene() 的东西

743
00:23:55,366 --> 0:23:58,416
看起来在处理很多数组

744
00:23:58,736 --> 0:24:00,236
它是这个重新加载的操作中的一部分

745
00:23:58,736 --> 0:24:00,236
它是这个重新加载的操作中的一部分

746
00:24:00,566 --> 0:24:02,636
我想要看看

747
00:24:02,636 --> 0:24:05,246
它究竟使用了多少时间

748
00:24:05,926 --> 0:24:11,906
所以我们去 Xcode 里看看这段代码吧

749
00:24:12,086 --> 0:24:13,306
这里是 setupScene() 函数

750
00:24:13,956 --> 0:24:15,466
你可以在这里看到

751
00:24:15,466 --> 0:24:17,326
我之前尝试记录

752
00:24:17,326 --> 0:24:18,456
性能评估的痕迹

753
00:24:18,786 --> 0:24:19,806
这里有一个打印命令

754
00:24:20,056 --> 0:24:21,606
在函数的开始发出

755
00:24:21,606 --> 0:24:22,816
mach_absolute_time()

756
00:24:23,376 --> 0:24:24,806
我们滚动到函数底部

757
00:24:24,806 --> 0:24:25,796
可以看到另一个打印命令

758
00:24:26,546 --> 0:24:28,086
在结束的时候

759
00:24:28,086 --> 0:24:30,836
再一次显示 mach_absolute_time()

760
00:24:31,526 --> 0:24:32,726
正如我之前提到过的

761
00:24:33,416 --> 0:24:35,366
Instruments 并不知道如何

762
00:24:35,366 --> 0:24:36,156
读取打印命令

763
00:24:36,346 --> 0:24:40,136
所以我们首先需要创建一个

764
00:24:40,136 --> 0:24:41,226
记录句柄 让我们能够

765
00:24:41,226 --> 0:24:42,386
与 Instruments 进行通讯

766
00:24:43,106 --> 0:24:45,046
我们来创建吧

767
00:24:46,316 --> 0:24:48,026
我用一个叫做

768
00:24:48,026 --> 0:24:49,326
pointsOfInterest 的类别

769
00:24:49,326 --> 0:24:49,726
创建这个记录句柄

770
00:24:50,186 --> 0:24:51,826
这个名字与

771
00:24:51,826 --> 0:24:53,546
Points of Interest 这个 Instrument 相关

772
00:24:55,166 --> 0:24:58,306
我们来用一个对

773
00:24:58,306 --> 0:25:00,046
os_signpost API 的调用

774
00:24:58,306 --> 0:25:00,046
os_signpost API 的调用

775
00:25:00,046 --> 0:25:03,106
来取代我们的第一个打印命令

776
00:25:03,106 --> 0:25:03,536
它会开启一个间隔

777
00:25:04,556 --> 0:25:05,616
每次你开启一个间隔的时候

778
00:25:05,616 --> 0:25:07,686
都要记得结束它

779
00:25:08,876 --> 0:25:10,196
与其一直向下滚动到

780
00:25:10,196 --> 0:25:11,706
函数的结尾

781
00:25:11,986 --> 0:25:13,376
我会选择利用 Swift 的 defer 代码块

782
00:25:13,486 --> 0:25:16,166
来结束这个间隔

783
00:25:16,756 --> 0:25:17,876
defer 代码块中的内容

784
00:25:17,876 --> 0:25:23,026
会在当前函数结尾执行

785
00:25:23,226 --> 0:25:24,716
在进行了这些修改之后

786
00:25:24,716 --> 0:25:26,196
我们来构建我们的 App

787
00:25:26,196 --> 0:25:27,606
并在菜单中使用“Profile”命令

788
00:25:27,606 --> 0:25:28,466
在 Instruments 中对它进行分析

789
00:25:33,056 --> 0:25:34,666
我们再一次选择

790
00:25:34,666 --> 0:25:37,736
Time Profiler 模板

791
00:25:37,896 --> 0:25:39,096
目标选择区域

792
00:25:39,096 --> 0:25:40,726
已经被 Xcode 用当前的

793
00:25:40,726 --> 0:25:41,486
《Solar System》App 的

794
00:25:41,486 --> 0:25:42,826
构建版本填充了

795
00:25:43,106 --> 0:25:43,966
我们开始记录吧

796
00:25:48,856 --> 0:25:51,256
我会和 App 进行交互

797
00:25:51,476 --> 0:25:52,716
并且再一次采用那个

798
00:25:52,716 --> 0:25:54,236
会引发问题的操作序列

799
00:25:54,236 --> 0:25:54,826
重新加载

800
00:25:57,766 --> 0:25:59,646
然后我们收集到了一些数据

801
00:25:59,686 --> 0:26:00,746
停止记录

802
00:25:59,686 --> 0:26:00,746
停止记录

803
00:26:01,266 --> 0:26:04,676
我们来放大看看那个

804
00:26:04,676 --> 0:26:06,856
高 CPU 占用区域

805
00:26:10,186 --> 0:26:11,756
在 Time Profiler 下面

806
00:26:12,136 --> 0:26:13,656
Points of Interest 轨道

807
00:26:13,956 --> 0:26:16,156
现在已经被

808
00:26:16,156 --> 0:26:17,546
我们在代码中加入的

809
00:26:17,546 --> 0:26:18,346
重点区域填充了

810
00:26:18,856 --> 0:26:20,096
有一行叫做 setupScene

811
00:26:20,096 --> 0:26:21,836
这与我们的 Signpost 间隔相关

812
00:26:21,836 --> 0:26:23,596
并且这里还有几个

813
00:26:23,596 --> 0:26:25,976
相邻的重点区域

814
00:26:25,976 --> 0:26:28,286
在轨道中被记录了下来

815
00:26:29,486 --> 0:26:32,016
我预期不会有这么多 而是几个

816
00:26:32,886 --> 0:26:34,926
我可以把鼠标悬浮在它们上面

817
00:26:34,926 --> 0:26:37,086
并且数一数有多少个重点区域

818
00:26:37,456 --> 0:26:39,486
或者我可以利用详细视图

819
00:26:40,876 --> 0:26:41,966
让我来点按并拖动来

820
00:26:41,966 --> 0:26:43,836
选择这一个区域

821
00:26:44,656 --> 0:26:45,906
然后在 Points of Interest 轨道中

822
00:26:45,906 --> 0:26:47,766
点按来重新以

823
00:26:47,766 --> 0:26:50,646
Points of Interest 轨道的总结

824
00:26:50,646 --> 0:26:54,186
填充详细视图

825
00:26:54,376 --> 0:26:55,966
仔细看看 我发现

826
00:26:55,966 --> 0:26:57,406
setupScene 在这个区域

827
00:26:57,406 --> 0:26:59,596
一共发生了 8 次

828
00:27:00,156 --> 0:27:05,606
每次耗时大概 200 毫秒

829
00:27:05,806 --> 0:27:07,726
详细视图中有更多可用的信息

830
00:27:08,006 --> 0:27:09,956
我们来点按跳转栏

831
00:27:09,956 --> 0:27:12,226
并选择一个重点区域的列表

832
00:27:12,226 --> 0:27:13,946
来看看在这个追踪中

833
00:27:13,946 --> 0:27:15,706
录制的每个重点区域的

834
00:27:15,706 --> 0:27:17,466
完整时间序列

835
00:27:18,016 --> 0:27:21,446
“Duration”列展示了

836
00:27:21,446 --> 0:27:24,216
它们中每一个的持续时间

837
00:27:24,216 --> 0:27:27,776
我可以看到每一个间隔

838
00:27:27,776 --> 0:27:28,986
都花费了差不多的时间来完成

839
00:27:28,986 --> 0:27:34,756
大概 210 到 220 毫秒

840
00:27:35,576 --> 0:27:37,046
这有些让人头大

841
00:27:37,196 --> 0:27:39,306
难道我们在不断重复一个

842
00:27:39,306 --> 0:27:43,336
工作量差不多的事情

843
00:27:43,526 --> 0:27:45,306
我们看看是谁在调用 setupScene

844
00:27:45,306 --> 0:27:46,596
判断一下是不是出于某种原因

845
00:27:46,596 --> 0:27:48,296
它被多余地调用了

846
00:27:48,436 --> 0:27:50,726
做这件事情最好的方式就是

847
00:27:50,726 --> 0:27:51,926
查看 Time Profiler

848
00:27:51,926 --> 0:27:53,716
记录的调用图中的信息

849
00:27:54,266 --> 0:27:57,216
我们再来看看窗口右下角的

850
00:27:57,216 --> 0:27:59,476
厚栈的视图

851
00:27:59,476 --> 0:28:01,446
这一次我们要关注

852
00:27:59,476 --> 0:28:01,446
这一次我们要关注

853
00:28:01,446 --> 0:28:03,156
setupScene() 的调用者

854
00:28:03,156 --> 0:28:04,476
是一个叫做 prepareScene() 的函数

855
00:28:05,486 --> 0:28:07,536
双击它来显示源代码

856
00:28:08,946 --> 0:28:10,946
看起来 prepareScene()

857
00:28:10,946 --> 0:28:12,776
Scene called Setup Scene

858
00:28:12,776 --> 0:28:13,276
只调用了 setupScene() 一次

859
00:28:13,476 --> 0:28:15,786
所以这不是造成重复调用的根本原因

860
00:28:16,626 --> 0:28:17,996
要复现完成的调用图

861
00:28:17,996 --> 0:28:20,746
我们来点按跳转区域的“Root”

862
00:28:20,746 --> 0:28:22,956
这会把我们带到调用图的根

863
00:28:24,326 --> 0:28:28,506
我们继续在厚栈上向上看

864
00:28:29,096 --> 0:28:34,086
选择下一个调用者

865
00:28:34,266 --> 0:28:35,766
这里我们可以看到一个 for 循环

866
00:28:35,766 --> 0:28:37,136
它很可能就是我们看到的

867
00:28:37,136 --> 0:28:38,336
重复调用的罪魁祸首

868
00:28:39,176 --> 0:28:40,296
我们在 Xcode 中打开这段代码

869
00:28:40,326 --> 0:28:43,176
仔细看看

870
00:28:43,526 --> 0:28:47,006
点按这个按钮来跳转到 Xcode 中的文件

871
00:28:51,716 --> 0:28:55,366
现在我们能在 Xcode 中看到这个 for 循环了

872
00:28:56,486 --> 0:28:57,526
我记得这个函数

873
00:28:58,116 --> 0:28:59,306
updateWithPlanets() 的目的是

874
00:28:59,366 --> 0:29:03,166
接受服务器发送给我们的数据

875
00:28:59,366 --> 0:29:03,166
接受服务器发送给我们的数据

876
00:29:03,166 --> 0:29:04,516
它是重新加载操作的一部分

877
00:29:05,156 --> 0:29:07,516
然后 当有更新需求的时候

878
00:29:07,516 --> 0:29:12,246
对于每个有新数据的行星

879
00:29:12,246 --> 0:29:14,026
在 App 中更新它的内部模型

880
00:29:15,486 --> 0:29:17,816
然而 我们可能会收到

881
00:29:17,816 --> 0:29:19,246
一包对于多个行星的

882
00:29:19,246 --> 0:29:20,526
更新信息数据

883
00:29:20,526 --> 0:29:22,596
看起来我们在

884
00:29:22,596 --> 0:29:24,266
遇到每个需要更新的行星时

885
00:29:24,266 --> 0:29:26,156
都会调用 prepareScene()

886
00:29:26,156 --> 0:29:28,726
来重绘整个视图

887
00:29:30,256 --> 0:29:32,586
追踪向我们展示了

888
00:29:32,776 --> 0:29:35,316
如果我们只更新

889
00:29:35,316 --> 0:29:39,326
行星的内部模型

890
00:29:39,326 --> 0:29:40,576
那么消耗的资源会大大降低

891
00:29:40,986 --> 0:29:42,606
所以 我们在这里应该做的事情是

892
00:29:42,866 --> 0:29:44,316
把我们所有的更新打包

893
00:29:44,316 --> 0:29:46,806
放到内部模型中

894
00:29:47,136 --> 0:29:49,016
并且只在所有更新完成后

895
00:29:49,206 --> 0:29:50,846
重绘一次场景

896
00:29:51,976 --> 0:29:53,266
这看起来是一个非常简单的修复

897
00:29:53,266 --> 0:29:56,076
但是以我们的经验来看

898
00:29:56,076 --> 0:29:57,616
在我们添加新功能

899
00:29:57,616 --> 0:29:59,166
或者修复不相关的 Bug 的时候

900
00:29:59,376 --> 0:30:01,166
大量这种类型的性能问题

901
00:29:59,376 --> 0:30:01,166
大量这种类型的性能问题

902
00:30:01,166 --> 0:30:03,146
都可能会溜进我们的代码中

903
00:30:03,606 --> 0:30:05,536
要避免这种 Bug

904
00:30:05,536 --> 0:30:07,016
呈现在我们的顾客面前

905
00:30:07,016 --> 0:30:09,156
一个很好的办法是写一个

906
00:30:09,156 --> 0:30:10,856
能够周期性地检查它们的功能的测试

907
00:30:11,846 --> 0:30:12,836
为了节约时间

908
00:30:12,836 --> 0:30:15,406
我已经写好了一个 XCTest

909
00:30:15,406 --> 0:30:17,206
它会检查 App 的重新加载功能

910
00:30:18,666 --> 0:30:19,926
如果我们点按测试左边的这个按钮

911
00:30:19,926 --> 0:30:23,296
通常它会直接运行测试

912
00:30:23,416 --> 0:30:24,886
但是我想通过辅助点按

913
00:30:24,886 --> 0:30:26,526
来显示 Profile 动作

914
00:30:27,266 --> 0:30:29,106
这会命令 Xcode 去在

915
00:30:29,106 --> 0:30:31,326
Instruments 中构建并运行测试

916
00:30:36,256 --> 0:30:37,746
我们来选择 Time Profiler 模板

917
00:30:37,746 --> 0:30:40,456
并开始记录追踪

918
00:30:41,016 --> 0:30:45,706
在这个测试中 我已经把重新加载操作

919
00:30:45,706 --> 0:30:48,946
放到了一个对 Measure API 的调用各种

920
00:30:49,706 --> 0:30:51,566
Measure API 会多次运行工作负载

921
00:30:51,566 --> 0:30:55,376
来收集一些重复的评估

922
00:30:56,186 --> 0:30:57,356
这非常有帮助

923
00:30:57,356 --> 0:30:58,866
可以让你知道你的评估

924
00:30:58,866 --> 0:31:00,296
是可重复且一致的

925
00:30:58,866 --> 0:31:00,296
是可重复且一致的

926
00:31:00,296 --> 0:31:02,996
还是每次运行都会得到不同的结果

927
00:31:04,466 --> 0:31:05,496
看起来所有的重复都停止了

928
00:31:05,496 --> 0:31:08,396
所以我可以停止追踪了

929
00:31:08,936 --> 0:31:11,926
我来放大看看

930
00:31:11,926 --> 0:31:13,616
重点轨道的内容

931
00:31:14,256 --> 0:31:17,446
我们可以看到这里有一个额外的行

932
00:31:21,046 --> 0:31:21,976
最底下是我之前在代码中加入的

933
00:31:21,976 --> 0:31:24,056
setupScene 间隔

934
00:31:24,106 --> 0:31:27,386
在它上面是

935
00:31:27,386 --> 0:31:28,516
另一个我们感兴趣的部分

936
00:31:28,516 --> 0:31:30,056
由 Measure API 提供

937
00:31:30,676 --> 0:31:32,976
这向我们展示了

938
00:31:32,976 --> 0:31:34,526
与每次运行工作负载的迭代

939
00:31:34,906 --> 0:31:36,106
相关联的间隔

940
00:31:38,146 --> 0:31:39,246
一眼扫过去

941
00:31:39,246 --> 0:31:41,606
我觉得工作负载

942
00:31:41,606 --> 0:31:42,976
在每次运行时的行为

943
00:31:42,976 --> 0:31:44,226
都差不多

944
00:31:44,626 --> 0:31:45,806
所以 我只想知道

945
00:31:45,806 --> 0:31:49,136
每次测试的迭代都发生了什么

946
00:31:50,146 --> 0:31:51,186
除了点按并拖动

947
00:31:51,186 --> 0:31:52,616
其实还有一个方便的快捷键

948
00:31:52,616 --> 0:31:53,746
让你能够精确地选中

949
00:31:53,746 --> 0:31:55,606
与一个轨道中的事件或间隔

950
00:31:55,606 --> 0:31:58,246
相关的区域

951
00:31:58,716 --> 0:31:59,546
只需要三次点按即可

952
00:32:00,106 --> 0:32:02,456
这会把详细视图

953
00:32:02,456 --> 0:32:04,396
用选中的特定信息填充

954
00:32:06,156 --> 0:32:09,336
仔细看看 现在似乎

955
00:32:09,936 --> 0:32:13,566
只有一次对 setupScene() 的调用了

956
00:32:13,566 --> 0:32:14,256
这意味着什么呢？

957
00:32:14,726 --> 0:32:19,276
我们使用从 Signpost 获取的信息

958
00:32:19,276 --> 0:32:21,876
把我们所用的 CPU 时间减少了几个数量级

959
00:32:23,516 --> 0:32:27,500
[掌声]

960
00:32:31,796 --> 0:32:32,926
让我们来复习一下

961
00:32:32,926 --> 0:32:34,176
我们刚刚遇到的概念

962
00:32:34,766 --> 0:32:38,496
从 Time Profiler 或者其他地方

963
00:32:38,496 --> 0:32:41,556
收集到的统计分析十分有用

964
00:32:41,556 --> 0:32:43,936
它能展示那些代码被最频繁地执行

965
00:32:44,496 --> 0:32:46,286
但是这并不能替代

966
00:32:46,286 --> 0:32:48,756
类似我们用 Signpost API 记录的评估

967
00:32:48,756 --> 0:32:51,746
因为它能告诉你 你的代码

968
00:32:51,746 --> 0:32:53,756
是怎样被执行的 以及为什么会被执行

969
00:32:54,946 --> 0:32:56,546
我们还看到了

970
00:32:56,546 --> 0:32:59,456
运行测试是多么有帮助

971
00:32:59,456 --> 0:33:00,906
它能稳定且反复地复现

972
00:32:59,456 --> 0:33:00,906
它能稳定且反复地复现

973
00:33:00,906 --> 0:33:03,156
我们的工作负载

974
00:33:03,446 --> 0:33:04,646
并在开发循环的早期

975
00:33:04,646 --> 0:33:05,456
就经常分析它

976
00:33:07,256 --> 0:33:09,076
今天 我们深入探索了

977
00:33:09,076 --> 0:33:10,656
会导致很高

978
00:33:10,656 --> 0:33:12,036
或不合理的系统占用的

979
00:33:12,036 --> 0:33:15,276
性能问题

980
00:33:16,016 --> 0:33:17,506
Instruments 还有大量的模板

981
00:33:17,506 --> 0:33:19,276
可以解决其他

982
00:33:19,276 --> 0:33:20,516
关于资源占用的

983
00:33:20,516 --> 0:33:22,016
性能问题

984
00:33:22,746 --> 0:33:25,456
我们有为文件和磁盘占用而设计的模板

985
00:33:26,286 --> 0:33:29,106
我们还有为网络占用设计的模板

986
00:33:29,306 --> 0:33:30,336
还有一个模板

987
00:33:30,826 --> 0:33:32,036
可以帮助你理解

988
00:33:32,036 --> 0:33:33,006
你的 App 和操作系统或

989
00:33:33,006 --> 0:33:34,506
其他系统中运行的进程

990
00:33:34,506 --> 0:33:37,136
之间的关系

991
00:33:37,796 --> 0:33:38,876
这还不是全部

992
00:33:39,806 --> 0:33:40,776
Instruments 还有一些

993
00:33:40,776 --> 0:33:42,726
十分高级的功能

994
00:33:42,726 --> 0:33:43,176
自定义 Instruments

995
00:33:43,426 --> 0:33:45,076
如果你是一个框架开发者

996
00:33:45,076 --> 0:33:46,386
想要你使用你 API 的客户

997
00:33:46,956 --> 0:33:49,006
能够解决关于性能问题

998
00:33:49,006 --> 0:33:50,116
他们使用你的框架时的

999
00:33:50,116 --> 0:33:51,126
性能问题

1000
00:33:51,126 --> 0:33:53,946
那么你可以向他们

1001
00:33:53,946 --> 0:33:57,176
提供一个自定义 Instruments 包

1002
00:33:57,716 --> 0:34:00,566
你也可以创建自定义 Instruments 模板

1003
00:33:57,716 --> 0:34:00,566
你也可以创建自定义 Instruments 模板

1004
00:34:00,606 --> 0:34:03,806
来在 Instruments App 中构造

1005
00:34:03,806 --> 0:34:08,436
一个独特的 Instruments 集合

1006
00:34:08,436 --> 0:34:10,326
来帮助解决某个特定的性能问题

1007
00:34:12,456 --> 0:34:13,966
在这个演示之后

1008
00:34:14,326 --> 0:34:15,556
我真的希望你们开始

1009
00:34:15,556 --> 0:34:17,676
在开发循环的早期

1010
00:34:17,676 --> 0:34:19,176
就经常分析你的代码

1011
00:34:19,716 --> 0:34:22,476
请在今天就去试试我们的 Instruments 11 吧

1012
00:34:22,835 --> 0:34:24,235
它附带了一些很棒的新功能

1013
00:34:24,235 --> 0:34:26,496
比如轨道固定

1014
00:34:26,775 --> 0:34:28,255
和结构视图

1015
00:34:28,255 --> 0:34:29,835
我相信它们用起来会十分有趣

1016
00:34:30,416 --> 0:34:33,306
在会议笔记中

1017
00:34:33,306 --> 0:34:34,516
我们有关于进阶功能和

1018
00:34:34,516 --> 0:34:36,025
针对特定事件的

1019
00:34:36,025 --> 0:34:38,116
Instruments 工作流的详细文档

1020
00:34:38,116 --> 0:34:39,706
还有一些前几年大会中的

1021
00:34:39,706 --> 0:34:42,735
很棒的讲解 非常感谢

1022
00:34:43,516 --> 0:34:49,505
[掌声]
