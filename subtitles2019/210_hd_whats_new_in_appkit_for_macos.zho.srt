1
00:00:06,406 --> 0:00:10,110
（MAC OS的

2
00:00:16,550 --> 0:00:18,118
大家下午好

3
00:00:19,119 --> 0:00:19,987
我是Chris Dreessen

4
00:00:20,254 --> 0:00:21,655
我从事的工作是Cocoa框架

5
00:00:22,189 --> 0:00:24,958
今天我们来谈谈

6
00:00:26,126 --> 0:00:27,694
我们开始吧

7
00:00:28,262 --> 0:00:30,797
我们有很多功能

8
00:00:30,864 --> 0:00:32,900
我们对NSColor

9
00:00:33,433 --> 0:00:34,568
对NSScreen也进行了补充

10
00:00:35,102 --> 0:00:36,403
我们还有一整套

11
00:00:36,703 --> 0:00:39,606
帮助您处理文字和字体的功能

12
00:00:40,374 --> 0:00:43,610
我们在此次演讲都会略微提到

13
00:00:43,977 --> 0:00:46,380
我们也会讲到工具栏和触控栏

14
00:00:46,446 --> 0:00:47,414
还有边栏

15
00:00:47,481 --> 0:00:48,949
（色彩 显示屏 文本 工具栏

16
00:00:49,016 --> 0:00:50,450
我们也会讲到

17
00:00:50,817 --> 0:00:54,154
AppKit macOS 10.15

18
00:00:54,855 --> 0:00:57,858
我们会通过NSEvent的介绍

19
00:00:58,992 --> 0:01:00,227
我们稍微跳一下

20
00:00:58,992 --> 0:01:00,227
我们稍微跳一下

21
00:01:00,661 --> 0:01:02,129
讲解一些基础功能

22
00:01:02,462 --> 0:01:05,165
包括一些几何增强功能

23
00:01:05,232 --> 0:01:07,034
这些功能能够使本地化更加简单

24
00:01:07,668 --> 0:01:08,802
最后再对macOS 10.15的

25
00:01:09,203 --> 0:01:12,105
系统扩展注释进行总结

26
00:01:13,173 --> 0:01:14,107
（新框架）

27
00:01:14,174 --> 0:01:16,043
在我们开始之前

28
00:01:16,777 --> 0:01:19,012
我们先来讲讲重头戏

29
00:01:19,780 --> 0:01:21,315
在macOS 10.15

30
00:01:21,648 --> 0:01:24,451
AppKit并不是

31
00:01:25,018 --> 0:01:27,254
我们还有其他两个UI框架

32
00:01:28,355 --> 0:01:30,958
你们可能听说过其中一个

33
00:01:31,024 --> 0:01:31,859
那就是UIKit

34
00:01:33,293 --> 0:01:34,628
在macOS 10.15中

35
00:01:34,928 --> 0:01:38,532
你可以重新编译你的app

36
00:01:39,233 --> 0:01:42,135
如果你的AppKit app

37
00:01:42,202 --> 0:01:45,172
那你对这个可能就不那么感兴趣

38
00:01:46,073 --> 0:01:49,676
但如果你的iPad app

39
00:01:49,743 --> 0:01:52,813
或者过去你在这个

40
00:01:52,880 --> 0:01:53,981
但没有怎么研究过Mac

41
00:01:54,047 --> 0:01:55,449
那就很有用了

42
00:01:56,350 --> 0:01:59,119
你可以仍旧用AppKit为你的

43
00:01:59,186 --> 0:02:01,955
UIKit app进行润色

44
00:01:59,186 --> 0:02:01,955
UIKit app进行润色

45
00:02:04,191 --> 0:02:05,759
我们认为会很有用

46
00:02:06,660 --> 0:02:07,861
另一个新的框架

47
00:02:07,928 --> 0:02:09,496
我们都非常激动

48
00:02:09,562 --> 0:02:10,531
就是SwiftUI

49
00:02:11,231 --> 0:02:14,401
SwiftUI用简洁的方式

50
00:02:14,468 --> 0:02:16,270
来描述你的用户界面

51
00:02:16,336 --> 0:02:17,671
和它们之间的过渡

52
00:02:18,071 --> 0:02:19,940
也是将它们整合到数据模型的方法

53
00:02:21,175 --> 0:02:23,544
我认为这是制作UI的好方法

54
00:02:23,610 --> 0:02:26,446
它是原装Swift

55
00:02:26,513 --> 0:02:27,548
我们很喜欢这一点

56
00:02:28,215 --> 0:02:30,617
再次强调 这要与AppKit

57
00:02:30,684 --> 0:02:34,054
你要把它嵌入视图层次结构中

58
00:02:34,121 --> 0:02:36,657
一整个星期都有关于

59
00:02:36,723 --> 0:02:37,724
这些框架的演讲

60
00:02:37,791 --> 0:02:39,026
你们都可以参加

61
00:02:39,593 --> 0:02:40,794
（色彩）

62
00:02:40,861 --> 0:02:41,828
回到AppKit

63
00:02:42,362 --> 0:02:44,765
在macOS 10.15中

64
00:02:45,465 --> 0:02:47,568
我们在NSColor中

65
00:02:47,634 --> 0:02:49,469
有青色和靛蓝

66
00:02:50,671 --> 0:02:53,106
这些是系统颜色

67
00:02:53,173 --> 0:02:55,075
根据你使用的外观

68
00:02:55,542 --> 0:02:56,577
它们也会进行相应的变化

69
00:02:59,012 --> 0:03:00,147
我觉得这都是很好看的颜色

70
00:02:59,012 --> 0:03:00,147
我觉得这都是很好看的颜色

71
00:03:00,214 --> 0:03:01,682
在你的app中都可以用到

72
00:03:03,050 --> 0:03:05,485
NSColor也有根本性的变化

73
00:03:05,552 --> 0:03:06,486
我们稍后会讲到

74
00:03:06,787 --> 0:03:10,424
在NSColor中 我们用的是

75
00:03:10,691 --> 0:03:13,760
NSNumber和

76
00:03:14,394 --> 0:03:15,462
什么是

77
00:03:16,029 --> 0:03:17,564
一般来说 在NSColor

78
00:03:18,098 --> 0:03:20,033
我们将各种组件值或其他信息

79
00:03:20,100 --> 0:03:23,036
作为iBar存储在已配置的对象中

80
00:03:23,971 --> 0:03:25,038
而在tagged pointer

81
00:03:25,105 --> 0:03:28,175
我们将该信息压缩到较小的位数

82
00:03:28,542 --> 0:03:29,910
并将它们储存在pointer中

83
00:03:30,410 --> 0:03:32,079
所以不需要单独配置

84
00:03:32,946 --> 0:03:36,917
如果你的代码大量配置

85
00:03:36,984 --> 0:03:38,819
你就能够注意到这一点

86
00:03:38,886 --> 0:03:39,753
我们对此也很兴奋

87
00:03:41,522 --> 0:03:44,491
一般情况下这种变化是不可见的

88
00:03:44,958 --> 0:03:46,460
但我想强调一点

89
00:03:47,494 --> 0:03:49,696
如果你要访问颜色的派生属性

90
00:03:49,763 --> 0:03:51,265
例如CGColor

91
00:03:52,332 --> 0:03:53,867
而这是未标记的版本

92
00:03:53,934 --> 0:03:56,003
它可以在色彩中缓存为iBar

93
00:03:56,069 --> 0:03:59,439
而CGColor也可以和

94
00:04:00,574 --> 0:04:02,276
在显示屏上的这段代码

95
00:04:02,609 --> 0:04:05,112
我们将CGColor传递至

96
00:04:05,179 --> 0:04:07,447
以色彩填充context设置调用

97
00:04:08,015 --> 0:04:09,650
这在以前是没有问题的

98
00:04:10,217 --> 0:04:11,451
但在tagged pointer

99
00:04:11,518 --> 0:04:14,254
在自动释放池外使用

100
00:04:14,321 --> 0:04:16,557
所以最好还是不这样用

101
00:04:16,857 --> 0:04:18,492
有些事情我们还是要注意 以防万一

102
00:04:22,429 --> 0:04:25,132
很多人都会使用面板取色

103
00:04:25,999 --> 0:04:29,036
还有我们心爱的吸管工具

104
00:04:29,336 --> 0:04:33,207
在面板取色中

105
00:04:33,273 --> 0:04:36,910
再在显示屏上拾取特定颜色

106
00:04:38,412 --> 0:04:39,613
在macOS 10.15中

107
00:04:39,980 --> 0:04:42,182
我们也会向你展示这项功能

108
00:04:42,482 --> 0:04:44,685
我们有一项新类

109
00:04:45,385 --> 0:04:47,621
NSColorSampler

110
00:04:47,688 --> 0:04:50,190
它有一个单类方法叫Show

111
00:04:50,791 --> 0:04:53,060
你可以向Show传递一个色块

112
00:04:53,126 --> 0:04:56,463
它就会返回所选颜色或是零

113
00:04:57,631 --> 0:05:00,200
我们也很高兴向你们介绍我们的实施

114
00:04:57,631 --> 0:05:00,200
我们也很高兴向你们介绍我们的实施

115
00:05:01,068 --> 0:05:02,369
如果你有自己的实施

116
00:05:02,436 --> 0:05:04,638
那么在macOS 10.15中

117
00:05:05,372 --> 0:05:08,842
在显示屏录制的时候

118
00:05:10,010 --> 0:05:13,614
如果你用的是

119
00:05:16,884 --> 0:05:19,786
接下来是另一个

120
00:05:19,853 --> 0:05:21,922
我们叫它动态色彩提供程序

121
00:05:22,389 --> 0:05:25,192
它其实只是NSColor

122
00:05:26,093 --> 0:05:27,227
它包括两项内容

123
00:05:27,694 --> 0:05:29,196
第一是色块

124
00:05:29,763 --> 0:05:31,665
且该色块可访问

125
00:05:32,833 --> 0:05:34,268
如果我们要用到色彩

126
00:05:34,535 --> 0:05:36,603
要不然就是我们要在

127
00:05:36,670 --> 0:05:39,439
要不然就是要写进文件

128
00:05:40,274 --> 0:05:41,542
我们将该色块命名为

129
00:05:41,608 --> 0:05:43,744
适合当时外观的名字

130
00:05:44,444 --> 0:05:45,646
在显示屏上

131
00:05:46,013 --> 0:05:48,182
我们使用的是NSAppearance

132
00:05:48,248 --> 0:05:50,284
来告诉我们 我们要求的外观

133
00:05:50,350 --> 0:05:52,719
是浅绿色更好还是深一点的绿色更好

134
00:05:53,687 --> 0:05:55,989
我们为每种情况也准备了硬编码颜色

135
00:05:57,157 --> 0:06:00,160
这在你要做出一些

136
00:05:57,157 --> 0:06:00,160
这在你要做出一些

137
00:06:00,227 --> 0:06:03,330
对你在NSColor中

138
00:06:03,797 --> 0:06:05,899
这比在更改外观时对视图层次结构

139
00:06:05,966 --> 0:06:09,203
硬编码文字颜色进行更改要简单得多

140
00:06:11,205 --> 0:06:12,739
我刚刚也说到了该程序包含两项内容

141
00:06:13,073 --> 0:06:14,575
另一项就是名称

142
00:06:15,242 --> 0:06:18,312
而在编码时 名称也是非常重要的

143
00:06:18,779 --> 0:06:21,114
如果你想通过

144
00:06:21,381 --> 0:06:22,416
也就是

145
00:06:22,916 --> 0:06:24,718
当你要解码的时候

146
00:06:25,419 --> 0:06:27,454
所以在连接的两段

147
00:06:27,521 --> 0:06:28,856
都要给该颜色颜色命名 这很重要

148
00:06:31,992 --> 0:06:34,094
这些色彩都很棒

149
00:06:34,161 --> 0:06:36,129
他们在好显示屏上看起来就更棒了

150
00:06:36,196 --> 0:06:37,030
（显示屏）

151
00:06:37,097 --> 0:06:38,932
现在我们来讲讲

152
00:06:40,000 --> 0:06:42,536
如果你以前要实现显示屏选择器控件

153
00:06:42,603 --> 0:06:45,205
你就要一串面对用户的字符串

154
00:06:45,272 --> 0:06:46,940
来识别NSScreen

155
00:06:47,708 --> 0:06:49,943
如果你使用的是NSObject的

156
00:06:50,010 --> 0:06:51,245
继承描述方法

157
00:06:51,311 --> 0:06:53,046
那么你的用户可能就会对

158
00:06:53,280 --> 0:06:57,351
NSScreen 0x60000261e460

159
00:06:58,952 --> 0:07:00,888
而在macOS 10.15中

160
00:06:58,952 --> 0:07:00,888
而在macOS 10.15中

161
00:07:01,154 --> 0:07:02,823
NSScreen.localizedName

162
00:07:02,890 --> 0:07:06,660
会给显示屏一个更好更可读的描述

163
00:07:10,097 --> 0:07:11,999
好了 我们再来谈谈显示屏

164
00:07:12,633 --> 0:07:13,567
在过去多年间

165
00:07:13,934 --> 0:07:16,803
显示屏变得越来越亮

166
00:07:17,304 --> 0:07:18,906
也没有什么人

167
00:07:19,339 --> 0:07:21,742
会把他们的显示屏调到最亮

168
00:07:23,844 --> 0:07:25,546
如果我们放一张图片

169
00:07:25,846 --> 0:07:28,849
我们可以把黑色想象成0分量值

170
00:07:29,149 --> 0:07:31,051
白色是1

171
00:07:31,585 --> 0:07:33,153
如果我们把显示屏调暗

172
00:07:33,453 --> 0:07:36,156
我们就有点像压缩了

173
00:07:36,223 --> 0:07:39,426
软件中每单位值发出的光子更少了

174
00:07:40,794 --> 0:07:44,031
但是显示器依旧可以显示鲜艳的色彩

175
00:07:44,731 --> 0:07:47,901
我们可以允许扩展动态范围内容显示

176
00:07:48,435 --> 0:07:50,537
而该内容并不止是限制在

177
00:07:50,904 --> 0:07:53,640
这样我们依旧可以使用

178
00:07:54,208 --> 0:07:55,042
这样对于一些图片

179
00:07:55,342 --> 0:07:58,111
它们的色彩相对于

180
00:07:59,413 --> 0:08:01,081
这其实不是什么新功能

181
00:07:59,413 --> 0:08:01,081
这其实不是什么新功能

182
00:08:01,148 --> 0:08:03,550
在Mac的许多版本中就有这一功能

183
00:08:03,851 --> 0:08:05,252
从macOS 10.11开始

184
00:08:06,119 --> 0:08:07,988
有两个API可以帮助你做到这一点

185
00:08:09,156 --> 0:08:10,157
其中一个

186
00:08:10,224 --> 0:08:14,428
是NSScreen

187
00:08:15,662 --> 0:08:16,563
它实际上很有用

188
00:08:16,630 --> 0:08:19,666
它不仅是你见过的最长

189
00:08:21,535 --> 0:08:23,170
而且它能在你的系统

190
00:08:23,237 --> 0:08:25,172
处于扩展动态范围模式时

191
00:08:25,239 --> 0:08:27,708
它会告诉你剪裁前

192
00:08:27,774 --> 0:08:29,476
你可以使用的组件最大值

193
00:08:29,543 --> 0:08:31,745
比如说1.3

194
00:08:33,280 --> 0:08:34,847
如果系统不在该模式下

195
00:08:34,914 --> 0:08:36,416
它就会返回1.0

196
00:08:37,351 --> 0:08:40,020
所以我们将该模式应用于系统

197
00:08:40,419 --> 0:08:42,289
也就是CAMetalLayer

198
00:08:42,356 --> 0:08:43,557
动态范围内容

199
00:08:44,191 --> 0:08:46,660
这也是NSOpenGLView

200
00:08:46,727 --> 0:08:49,062
叫需要动态范围

201
00:08:49,530 --> 0:08:50,931
当你把其中一项设为真

202
00:08:50,998 --> 0:08:53,066
你就能通过此API

203
00:08:55,135 --> 0:08:57,371
所以我们对macOS 10.15

204
00:08:57,437 --> 0:08:59,640
是一项更长的

205
00:09:01,041 --> 0:09:02,843
但重要的部分其实更短了

206
00:09:02,910 --> 0:09:04,811
叫最大潜力

207
00:09:05,445 --> 0:09:08,348
它会告诉你动态余量 告诉你最大值

208
00:09:08,415 --> 0:09:11,552
即使系统未处于扩展动态范围模式

209
00:09:12,419 --> 0:09:13,587
这很有用

210
00:09:14,087 --> 0:09:16,390
如果你在处理扩展动态范围内容

211
00:09:16,456 --> 0:09:18,458
你可能会有多条

212
00:09:18,525 --> 0:09:20,027
发送图像数据的通道

213
00:09:20,561 --> 0:09:23,030
比如用于扩展内容的浮点通道

214
00:09:23,096 --> 0:09:26,533
就要比BJRA通道更贵

215
00:09:26,967 --> 0:09:29,636
所以提前知道你有足够的

216
00:09:30,003 --> 0:09:31,705
可以为你的支持提供条件

217
00:09:34,208 --> 0:09:35,876
我还想谈谈另一个API

218
00:09:36,276 --> 0:09:39,146
具体来说是用于

219
00:09:39,847 --> 0:09:41,949
这台新的显示器很了不起

220
00:09:42,416 --> 0:09:43,817
因为它真的很亮

221
00:09:43,884 --> 0:09:45,886
它可以一直保持1000尼特

222
00:09:46,620 --> 0:09:48,355
因此

223
00:09:48,422 --> 0:09:50,557
我们可以将它看做参考质量

224
00:09:50,624 --> 0:09:53,560
对于特定的组件值可以这样认为

225
00:09:53,627 --> 0:09:56,230
该像素有一个绝对亮度

226
00:09:58,232 --> 0:10:00,767
它很亮 但也不是无限亮

227
00:09:58,232 --> 0:10:00,767
它很亮 但也不是无限亮

228
00:10:01,168 --> 0:10:04,204
如果你继续生成足够量的像素值

229
00:10:04,271 --> 0:10:05,973
它实际上是无法表示的

230
00:10:06,039 --> 0:10:08,308
我们刚刚所说的参考质量

231
00:10:08,609 --> 0:10:09,610
就会有所下降

232
00:10:09,676 --> 0:10:11,712
我们必须缩小图像内容

233
00:10:11,979 --> 0:10:13,680
以适应可用的亮度范围

234
00:10:14,114 --> 0:10:16,917
这也是NSScreen

235
00:10:17,217 --> 0:10:18,385
如果超过该值

236
00:10:18,685 --> 0:10:21,121
就无法再使用绝对尼特了

237
00:10:21,588 --> 0:10:23,023
（扩展动态范围）

238
00:10:24,358 --> 0:10:27,561
好 我刚刚提到了

239
00:10:27,628 --> 0:10:29,963
这也是获取扩展动态内容的方式之一

240
00:10:30,464 --> 0:10:32,299
我要强调几点

241
00:10:32,366 --> 0:10:34,668
现在如果你要在Mac上

242
00:10:35,002 --> 0:10:36,036
你要做的事情

243
00:10:36,503 --> 0:10:38,005
你要注意

244
00:10:38,071 --> 0:10:40,140
你的CAMetalLayer要在

245
00:10:40,741 --> 0:10:42,609
哪个屏幕和

246
00:10:43,644 --> 0:10:44,711
这有点费解

247
00:10:44,778 --> 0:10:47,414
你要先获取窗口和窗口显示屏

248
00:10:47,481 --> 0:10:48,882
还有显示屏的设备描述

249
00:10:49,349 --> 0:10:52,052
你还要请求你在文件中

250
00:10:52,119 --> 0:10:53,387
找到的硬编码字符串

251
00:10:53,453 --> 0:10:55,389
但我们不从标题中导出

252
00:10:56,523 --> 0:10:58,625
最后 你还要传递

253
00:10:59,026 --> 0:11:00,294
来确定使用的设备

254
00:10:59,026 --> 0:11:00,294
来确定使用的设备

255
00:11:00,994 --> 0:11:03,330
这些功夫是值得的

256
00:11:03,397 --> 0:11:06,433
通过系统总线在GPU之间移动数据

257
00:11:07,768 --> 0:11:09,469
我们在macOS 10.15中

258
00:11:10,304 --> 0:11:12,139
CAMetalLayer

259
00:11:12,206 --> 0:11:15,242
有一个新的首选设备属性

260
00:11:16,577 --> 0:11:18,178
它精简了你的代码

261
00:11:18,846 --> 0:11:21,014
我们很高兴你今年就能使用这项功能

262
00:11:23,383 --> 0:11:25,118
这也就涵盖了

263
00:11:25,185 --> 0:11:26,320
（文本）

264
00:11:26,620 --> 0:11:29,423
现在我们来介绍各种各样的文本功能

265
00:11:30,190 --> 0:11:31,291
首先

266
00:11:31,358 --> 0:11:32,492
我想说的是

267
00:11:32,926 --> 0:11:36,430
NSTextView对较暗外观

268
00:11:37,097 --> 0:11:39,700
你可以在文本编辑中

269
00:11:39,766 --> 0:11:43,003
这里浅色和深色都有快照

270
00:11:43,403 --> 0:11:45,706
都是系统蜡笔选择器中的颜色

271
00:11:46,206 --> 0:11:48,208
你可以看到 当此功能激活时

272
00:11:48,675 --> 0:11:51,011
黑色和白色都几乎颠倒过来了

273
00:11:51,612 --> 0:11:55,082
同时更为饱和鲜艳的颜色

274
00:11:55,449 --> 0:11:58,085
还是同样的颜色 但是亮度不同了

275
00:11:58,619 --> 0:12:00,153
这使它们能够更好地与背景外观匹配

276
00:11:58,619 --> 0:12:00,153
这使它们能够更好地与背景外观匹配

277
00:12:01,355 --> 0:12:04,157
所以这在你制作文本内容

278
00:12:04,224 --> 0:12:06,393
而想要它们的颜色

279
00:12:06,693 --> 0:12:08,729
这对富文本文件尤其有用

280
00:12:09,062 --> 0:12:10,898
比如让它们的颜色更适合页面

281
00:12:10,964 --> 0:12:12,866
比单纯让它们在打印页面上

282
00:12:13,467 --> 0:12:15,702
显示固定颜色要重要得多

283
00:12:16,770 --> 0:12:18,605
一般来说这是我们想要的

284
00:12:18,939 --> 0:12:19,973
但如果你有一款app

285
00:12:20,040 --> 0:12:22,176
是用于创作富文本内容的

286
00:12:22,876 --> 0:12:24,811
你可能就要关闭该功能

287
00:12:24,878 --> 0:12:26,980
或是让用户能选择关闭该功能

288
00:12:27,247 --> 0:12:30,984
这样他们就能自己决定

289
00:12:31,585 --> 0:12:32,553
而不是屏幕显示

290
00:12:34,021 --> 0:12:37,324
在场的各位应该都很熟悉

291
00:12:37,591 --> 0:12:39,593
如果你作为开发者不熟悉的话

292
00:12:40,460 --> 0:12:42,129
在macOS 10.15中

293
00:12:42,196 --> 0:12:44,898
很高兴地宣布

294
00:12:45,766 --> 0:12:48,468
后继者就是

295
00:12:49,670 --> 0:12:52,773
NSSpellChecker

296
00:12:53,273 --> 0:12:56,276
而NSTextCheckingController

297
00:12:56,343 --> 0:12:59,179
可在UIKit WebKit

298
00:12:59,513 --> 0:13:01,081
你也可以通过使用

299
00:12:59,513 --> 0:13:01,081
你也可以通过使用

300
00:13:01,148 --> 0:13:02,749
来自己使用它

301
00:13:03,984 --> 0:13:06,253
除了检查拼写 它还有其他功能

302
00:13:06,320 --> 0:13:07,321
还可以检查语法

303
00:13:07,588 --> 0:13:11,258
它可以进行数据检测

304
00:13:11,959 --> 0:13:14,094
你可以控制它们

305
00:13:14,795 --> 0:13:17,698
可以设置是让错误拼写高亮显示

306
00:13:17,764 --> 0:13:18,999
还是自动纠正

307
00:13:19,566 --> 0:13:21,235
所以我认为这是一项

308
00:13:21,301 --> 0:13:22,503
如果你要进行大量文本输入

309
00:13:23,136 --> 0:13:24,471
那么这绝对值得一试

310
00:13:26,139 --> 0:13:28,242
我们对文本还进行了一些小小的添加

311
00:13:28,542 --> 0:13:32,212
几乎所有与NSText相关的类

312
00:13:32,946 --> 0:13:35,983
所以如果你想将这些作为

313
00:13:36,049 --> 0:13:37,584
词汇表的一部分

314
00:13:38,619 --> 0:13:39,820
它们也能良好运行

315
00:13:40,721 --> 0:13:41,955
（安全编码支持）

316
00:13:42,656 --> 0:13:43,924
（NSFONTDESCRIPTOR

317
00:13:44,324 --> 0:13:46,260
大家可能很熟悉NSFont

318
00:13:46,326 --> 0:13:49,329
有些朋友可能对

319
00:13:50,697 --> 0:13:54,501
NSFontDescriptor

320
00:13:54,568 --> 0:13:57,671
它允许我们使用它们的

321
00:13:58,372 --> 0:13:59,940
我在这里做了一些样本

322
00:14:00,974 --> 0:14:04,378
顶行是我在Interface Builder

323
00:14:04,845 --> 0:14:06,046
但是下面几行

324
00:14:06,380 --> 0:14:09,550
我用的是NSFontDescriptor

325
00:14:09,616 --> 0:14:10,851
是macOS 10.15中的

326
00:14:11,451 --> 0:14:13,353
如果我说

327
00:14:13,420 --> 0:14:15,889
我想让字体更圆一点

328
00:14:16,290 --> 0:14:17,157
或是等宽字体

329
00:14:18,292 --> 0:14:19,493
我们会有另一场演讲

330
00:14:19,560 --> 0:14:21,595
会进行更加详细的介绍

331
00:14:21,662 --> 0:14:24,565
但我认为这是让你的app

332
00:14:29,303 --> 0:14:32,272
如果你有一款编写

333
00:14:32,673 --> 0:14:34,474
富文本文件的跨平台app

334
00:14:34,741 --> 0:14:36,243
在Mac OS和iOS上同时运行

335
00:14:36,310 --> 0:14:39,446
或者是一款不跨平台 只从其他平台

336
00:14:39,513 --> 0:14:40,480
读取文件的app

337
00:14:41,014 --> 0:14:42,449
你可能会遇到这样的问题

338
00:14:42,749 --> 0:14:46,153
即使文档指定的是相同的字体大小

339
00:14:46,620 --> 0:14:48,021
但是看起来还是十分不同

340
00:14:48,789 --> 0:14:50,858
这是因为iOS设备和Mac设备

341
00:14:50,924 --> 0:14:52,826
屏幕密度十分不同

342
00:14:54,561 --> 0:14:55,863
在macOS 10.15

343
00:14:56,463 --> 0:14:58,532
我们有新属性字符串API

344
00:14:59,132 --> 0:15:00,801
你可以在读取和写入富文本文件中的

345
00:14:59,132 --> 0:15:00,801
你可以在读取和写入富文本文件中的

346
00:15:01,101 --> 0:15:03,170
属性字符串时使用

347
00:15:03,770 --> 0:15:07,875
您可以告诉我们源和

348
00:15:08,308 --> 0:15:10,944
我们会自动调整字体大小

349
00:15:11,512 --> 0:15:13,113
让它们视觉上看起来一样

350
00:15:13,881 --> 0:15:17,084
在这种情况下

351
00:15:17,584 --> 0:15:19,753
这样它们视觉上看起来就是一样的了

352
00:15:22,556 --> 0:15:23,690
（NSLAYOUTmanAGER

353
00:15:23,757 --> 0:15:25,659
最后一点关于文字的功能 我想谈谈

354
00:15:26,326 --> 0:15:28,028
对NSLayoutManager

355
00:15:28,929 --> 0:15:30,264
叫做使用默认断字

356
00:15:31,064 --> 0:15:32,065
过去

357
00:15:32,432 --> 0:15:35,102
NSText类可以

358
00:15:35,402 --> 0:15:37,371
通过NSParagraphStyle

359
00:15:37,671 --> 0:15:39,373
以此来控制断字

360
00:15:40,274 --> 0:15:42,743
LayoutManager

361
00:15:43,177 --> 0:15:45,512
它默认是关闭的

362
00:15:45,579 --> 0:15:46,680
像左边这样

363
00:15:46,747 --> 0:15:49,383
你若设置

364
00:15:49,683 --> 0:15:52,619
而右边

365
00:15:52,920 --> 0:15:54,121
internationalization

366
00:15:55,756 --> 0:15:57,357
所以 该文本API

367
00:15:57,658 --> 0:16:00,060
可以润色你文本系统的

368
00:15:57,658 --> 0:16:00,060
可以润色你文本系统的

369
00:16:00,127 --> 0:16:01,228
角落和边缘

370
00:16:03,530 --> 0:16:04,398
（工具栏）

371
00:16:04,464 --> 0:16:06,533
NSToolbar也有一些新功能

372
00:16:07,534 --> 0:16:08,635
首先

373
00:16:09,002 --> 0:16:11,071
是NSToolbarItem的

374
00:16:11,672 --> 0:16:12,739
叫isBordered

375
00:16:14,241 --> 0:16:15,175
过去

376
00:16:15,242 --> 0:16:19,046
如果你想在NSToolbar中

377
00:16:19,546 --> 0:16:21,315
你必须要配置自己的

378
00:16:21,381 --> 0:16:22,749
NSButton实例

379
00:16:22,816 --> 0:16:23,984
自己设置

380
00:16:24,051 --> 0:16:26,954
然后将其用作工具栏项目的

381
00:16:27,855 --> 0:16:30,023
这可以实现 但是花费太多精力了

382
00:16:30,357 --> 0:16:33,160
而且你也不能使用

383
00:16:33,694 --> 0:16:36,864
对自动启用和禁用提供内置支持

384
00:16:38,265 --> 0:16:40,334
但如果你将其用作边界属性

385
00:16:40,601 --> 0:16:41,768
那你就可以自由使用了

386
00:16:42,870 --> 0:16:43,937
还有

387
00:16:44,438 --> 0:16:46,540
NSToolbarItem

388
00:16:46,974 --> 0:16:48,809
可以将工具栏项目配置为

389
00:16:49,343 --> 0:16:52,246
字符串按钮 而不是图标按钮

390
00:16:52,946 --> 0:16:55,015
这与标签属性也有所不同

391
00:16:55,082 --> 0:16:56,783
如果我们已将工具栏配置为显示标签

392
00:16:57,217 --> 0:16:59,353
它会在按钮下方出现

393
00:17:01,722 --> 0:17:05,925
这并不是macOS 10.15功能

394
00:17:07,060 --> 0:17:10,364
我们还在NSToolbarItemGroup中

395
00:17:10,631 --> 0:17:12,398
让它们更多功能和更实用

396
00:17:12,965 --> 0:17:14,134
首先

397
00:17:14,201 --> 0:17:16,537
就是一些方便的构造函数

398
00:17:16,936 --> 0:17:18,204
它们可以让你

399
00:17:18,271 --> 0:17:21,974
同更少的代码创建出一样好的UI

400
00:17:22,976 --> 0:17:25,811
而NSToolbarItemGroup

401
00:17:26,613 --> 0:17:28,682
看看屏幕右方的图片

402
00:17:29,116 --> 0:17:31,919
你可以看到 它的支持项目

403
00:17:31,985 --> 0:17:33,220
表示为分段控件

404
00:17:33,720 --> 0:17:37,257
也能通过下拉菜单和

405
00:17:38,158 --> 0:17:40,227
所以它是一个多功能的工具栏控件

406
00:17:41,161 --> 0:17:44,198
因为它将其他工具栏项目用作词汇

407
00:17:44,264 --> 0:17:46,967
我们还可以自动创建折叠表示

408
00:17:47,467 --> 0:17:50,037
当窗口有太多工具栏时可以用到

409
00:17:50,103 --> 0:17:50,938
（NSTOOLBARITEMGROUP

410
00:17:51,004 --> 0:17:51,839
（分段控件

411
00:17:54,808 --> 0:17:57,578
在新NSMenuToolbarItem类中

412
00:17:57,644 --> 0:17:59,046
也有一个非常相似的效果

413
00:18:00,013 --> 0:18:02,850
这很像

414
00:18:03,250 --> 0:18:04,484
菜单项表示

415
00:18:05,519 --> 0:18:07,721
但将NSMenu

416
00:18:08,589 --> 0:18:11,525
这很棒

417
00:18:11,592 --> 0:18:13,560
比如子菜单或分隔符项

418
00:18:14,228 --> 0:18:16,597
甚至可以对菜单项使用自定义视图

419
00:18:16,964 --> 0:18:18,899
所以这是一项很强大的工具

420
00:18:19,399 --> 0:18:22,569
如果你想让工具栏有一些更复杂

421
00:18:24,638 --> 0:18:28,175
NSTouchBar在

422
00:18:28,876 --> 0:18:30,244
我想说的第一点

423
00:18:30,310 --> 0:18:33,247
是NSTouchBar

424
00:18:33,313 --> 0:18:35,382
那就是自动自定义TouchBar

425
00:18:35,449 --> 0:18:36,450
菜单项已启用

426
00:18:36,950 --> 0:18:38,218
这听起来可能很熟悉

427
00:18:38,285 --> 0:18:40,621
在NSApplication

428
00:18:41,488 --> 0:18:43,023
如果你在代码中

429
00:18:43,490 --> 0:18:45,359
想以不引用NSApplication的

430
00:18:45,425 --> 0:18:47,361
那么你就可以使用触控栏的这一功能

431
00:18:47,728 --> 0:18:50,731
一个例子是

432
00:18:50,797 --> 0:18:53,700
也并不会有

433
00:18:56,170 --> 0:18:57,471
一个更重要的控件

434
00:18:57,771 --> 0:19:00,474
是新的

435
00:18:57,771 --> 0:19:00,474
是新的

436
00:19:01,341 --> 0:19:03,210
就像屏幕上的步进器

437
00:19:03,577 --> 0:19:06,180
这对于日期和数字等的

438
00:19:06,246 --> 0:19:08,115
离散输入非常有用

439
00:19:08,916 --> 0:19:12,186
但考虑到触控栏布局较大

440
00:19:12,252 --> 0:19:13,954
你可以在新app中使用这项功能

441
00:19:14,021 --> 0:19:16,790
比如在绘图app中直观地选择工具

442
00:19:17,491 --> 0:19:19,927
我们对于这项

443
00:19:19,993 --> 0:19:22,896
我认为你们可以在app中好好利用

444
00:19:25,065 --> 0:19:26,366
NSSlider触控栏项目

445
00:19:26,433 --> 0:19:27,734
也有一些小提升

446
00:19:29,002 --> 0:19:31,805
你可能用过

447
00:19:31,872 --> 0:19:33,841
你可能会觉得太小

448
00:19:34,908 --> 0:19:38,779
那么可以通过TouchBarItem实例

449
00:19:39,112 --> 0:19:41,014
再为其添加自动布局约束

450
00:19:41,982 --> 0:19:43,317
在macOS 10.15中

451
00:19:43,851 --> 0:19:46,386
你可以直接在项目上

452
00:19:46,453 --> 0:19:47,788
接下来的事情我们会帮你解决

453
00:19:48,488 --> 0:19:51,592
同样的 如果你想放大滑块

454
00:19:51,992 --> 0:19:54,862
你可以通过

455
00:19:57,998 --> 0:20:00,701
最后我想说说边栏软件度量

456
00:19:57,998 --> 0:20:00,701
最后我想说说边栏软件度量

457
00:20:01,134 --> 0:20:02,436
在macOS 10.15

458
00:20:02,503 --> 0:20:04,404
你可以切换补充工具栏的大小

459
00:20:04,471 --> 0:20:07,174
可以通过设置或者

460
00:20:08,909 --> 0:20:11,478
默认是中 你也可以设为小或大

461
00:20:12,579 --> 0:20:15,616
我把它调出来是因为

462
00:20:15,682 --> 0:20:18,118
你可能就没有办法查看

463
00:20:18,185 --> 0:20:19,386
这些或大或小规格的原图

464
00:20:20,020 --> 0:20:21,388
所以如果你使用的是位图

465
00:20:21,455 --> 0:20:23,090
那么继续使用 再为其添加表述

466
00:20:23,457 --> 0:20:25,292
或者使用独立分辨率版本

467
00:20:26,159 --> 0:20:28,595
同样的 macOS 10.15中

468
00:20:29,062 --> 0:20:31,999
也可以自动选择明或者暗的外观

469
00:20:32,065 --> 0:20:34,535
这也可以在常规pref窗格中找到

470
00:20:36,837 --> 0:20:40,307
好了 我们介绍了

471
00:20:40,374 --> 0:20:43,911
让我们来谈谈广泛适用的控件

472
00:20:43,977 --> 0:20:45,212
（控件）

473
00:20:45,279 --> 0:20:46,346
首先

474
00:20:46,647 --> 0:20:48,348
我们非常开心

475
00:20:48,882 --> 0:20:51,285
NSSwitch是

476
00:20:51,652 --> 0:20:53,754
它支持绑定 支持格式化

477
00:20:55,689 --> 0:20:59,092
但它与现有的复选框功能一起存在

478
00:20:59,626 --> 0:21:01,495
所以你可能有这样一个问题

479
00:20:59,626 --> 0:21:01,495
所以你可能有这样一个问题

480
00:21:01,562 --> 0:21:02,829
我什么时候该用NSSwitch

481
00:21:02,896 --> 0:21:04,198
什么时候又用复选框呢

482
00:21:04,865 --> 0:21:06,867
如果你已经在用复选框

483
00:21:07,201 --> 0:21:09,069
你就继续用

484
00:21:09,136 --> 0:21:10,804
它通常都是正确的控件

485
00:21:11,805 --> 0:21:13,340
我们认为NSSwitch

486
00:21:13,407 --> 0:21:15,776
在你进行很多切换时更好用

487
00:21:16,043 --> 0:21:18,412
比如你要关闭和开启很多功能时

488
00:21:19,379 --> 0:21:20,747
在这个例子中

489
00:21:21,281 --> 0:21:22,883
左边是主切换

490
00:21:22,950 --> 0:21:25,185
它可以启用右边

491
00:21:25,752 --> 0:21:27,387
所有的共享服务

492
00:21:27,454 --> 0:21:28,722
（NSSWITCH

493
00:21:28,789 --> 0:21:30,457
（不要在小型活动中使用NSSWITCH

494
00:21:30,524 --> 0:21:31,692
（收集视图组成布局）

495
00:21:32,392 --> 0:21:33,760
在macOS 10.15

496
00:21:33,827 --> 0:21:36,029
我们在NSCollectionView

497
00:21:36,864 --> 0:21:39,333
我们要说的一点

498
00:21:39,700 --> 0:21:40,767
是构图布局

499
00:21:41,401 --> 0:21:42,436
在此

500
00:21:42,703 --> 0:21:45,539
你不需要再通过添加

501
00:21:46,006 --> 0:21:46,840
来修改它

502
00:21:47,441 --> 0:21:50,377
你还可以使用很多有趣的功能

503
00:21:51,111 --> 0:21:53,046
比如容量相关尺寸

504
00:21:53,547 --> 0:21:54,815
布局中断和部分

505
00:21:54,882 --> 0:21:55,949
以及可嵌套组合

506
00:21:56,483 --> 0:21:58,519
并使各个部分可以滚动

507
00:21:58,952 --> 0:22:01,421
当然 所有都适用于从左到右

508
00:21:58,952 --> 0:22:01,421
当然 所有都适用于从左到右

509
00:22:01,488 --> 0:22:02,723
和从右到左的语言

510
00:22:04,324 --> 0:22:06,460
还有一项新

511
00:22:06,760 --> 0:22:07,961
称为可扩展数据源

512
00:22:09,062 --> 0:22:11,832
这些是基于标识符的数据源

513
00:22:11,899 --> 0:22:14,535
让我们能跟踪添加或删除项目等内容

514
00:22:14,601 --> 0:22:16,703
或者是项目在两个地点间的移动

515
00:22:17,237 --> 0:22:19,973
它可以自动推断出要使用的模块

516
00:22:20,474 --> 0:22:22,943
也就是说你不用再用

517
00:22:23,277 --> 0:22:24,211
或是reloadData了

518
00:22:26,647 --> 0:22:28,048
（使用IB Storyboard的

519
00:22:28,115 --> 0:22:30,684
好了 从app控件

520
00:22:31,418 --> 0:22:32,286
回到IB功能

521
00:22:33,253 --> 0:22:35,722
IB是一个很好的方法

522
00:22:36,089 --> 0:22:38,659
来连接app中的各种视图控制器

523
00:22:40,327 --> 0:22:42,095
曾经

524
00:22:42,529 --> 0:22:45,132
视图控制器会通过编码器进行初始化

525
00:22:45,199 --> 0:22:47,034
你就需要不同的方法

526
00:22:47,434 --> 0:22:49,870
将不同的信息输入视图控制器

527
00:22:51,138 --> 0:22:52,372
这没有那么难

528
00:22:52,439 --> 0:22:53,974
但同时也意味着你的代码

529
00:22:54,041 --> 0:22:55,542
可能比你想象的要多

530
00:22:56,410 --> 0:22:57,511
看看我的代码

531
00:22:57,578 --> 0:23:00,147
你可以看到一项叫

532
00:22:57,578 --> 0:23:00,147
你可以看到一项叫

533
00:23:01,181 --> 0:23:05,085
它会返回一个新的视图控制器

534
00:23:06,053 --> 0:23:08,722
还对选定的pet名

535
00:23:10,357 --> 0:23:12,926
所以这是将单独的初始化

536
00:23:12,993 --> 0:23:14,228
和配置步骤

537
00:23:14,995 --> 0:23:17,197
还有一件事

538
00:23:17,564 --> 0:23:21,134
这个函数附带了

539
00:23:21,835 --> 0:23:23,103
因此

540
00:23:23,170 --> 0:23:26,039
我们可以为Segueway转到

541
00:23:26,106 --> 0:23:29,042
并将其直接连接

542
00:23:30,477 --> 0:23:33,313
所以我们认为这对于在视图控制器

543
00:23:33,380 --> 0:23:35,282
添加额外配置非常有用

544
00:23:40,787 --> 0:23:43,957
对于所有AppKit控件而言

545
00:23:44,291 --> 0:23:45,692
它们支持自动布局

546
00:23:46,159 --> 0:23:48,795
它们知道如何处理内容

547
00:23:48,862 --> 0:23:50,497
并将其输入自动布局引擎

548
00:23:51,498 --> 0:23:54,034
也就是说你可以做一些例如

549
00:23:54,101 --> 0:23:55,402
改变文本字段和按钮字符串的事

550
00:23:55,836 --> 0:23:58,972
并且自动布局将自动

551
00:23:59,039 --> 0:24:00,507
让它们更好看

552
00:23:59,039 --> 0:24:00,507
让它们更好看

553
00:24:03,243 --> 0:24:04,378
但有时候

554
00:24:04,645 --> 0:24:05,779
它们是UI

555
00:24:06,180 --> 0:24:07,614
是一些不太重要的部分

556
00:24:07,915 --> 0:24:09,116
所以在这个网格视图中

557
00:24:09,383 --> 0:24:12,686
网格决定了其他东西的大小

558
00:24:13,220 --> 0:24:15,923
内部标签的大小其实不重要

559
00:24:16,990 --> 0:24:20,060
但通常 AppKit还是会

560
00:24:20,127 --> 0:24:21,595
并将它们输入自动布局引擎

561
00:24:21,662 --> 0:24:23,564
虽然这并不会影响最终效果

562
00:24:25,666 --> 0:24:26,867
在macOS 10.15中

563
00:24:27,668 --> 0:24:28,602
你可以把它关掉

564
00:24:29,403 --> 0:24:31,104
NSView有两项新属性

565
00:24:31,805 --> 0:24:33,307
来关闭对垂直轴

566
00:24:33,373 --> 0:24:35,409
和水平轴的测量行为

567
00:24:35,976 --> 0:24:39,646
我认为这是减少UI内行为的好方法

568
00:24:39,913 --> 0:24:42,616
因为你知道内部控件的大小影响不大

569
00:24:47,287 --> 0:24:49,456
关于控件我还想讲一点

570
00:24:49,523 --> 0:24:51,158
比NSControl更宽泛一点

571
00:24:51,758 --> 0:24:52,726
就是NSResponder

572
00:24:53,360 --> 0:24:56,563
及其模块捕获有关行为

573
00:24:57,397 --> 0:24:59,366
来看屏幕上的代码

574
00:25:00,000 --> 0:25:01,101
你可以看到两部分

575
00:25:01,168 --> 0:25:02,603
一个是外面的部分

576
00:25:02,669 --> 0:25:04,671
这将在后台线程上执行

577
00:25:05,405 --> 0:25:06,540
还有是里面的部分

578
00:25:06,807 --> 0:25:08,575
将在主线程上执行

579
00:25:09,176 --> 0:25:10,511
这是一种相当普遍的模式

580
00:25:10,577 --> 0:25:12,079
我们在后台开展工作

581
00:25:12,579 --> 0:25:14,815
然后继续将该工作的结果

582
00:25:14,882 --> 0:25:16,216
分配给主线程上的UI

583
00:25:17,651 --> 0:25:19,653
但是这段代码是在

584
00:25:20,153 --> 0:25:22,122
可能会导致崩溃

585
00:25:22,823 --> 0:25:25,926
保留文本字段的唯一方式

586
00:25:25,993 --> 0:25:26,960
是这些模块

587
00:25:27,494 --> 0:25:29,563
而这些模块的破坏顺序又没有被定义

588
00:25:30,397 --> 0:25:32,299
如果外部块最后解除分配

589
00:25:32,599 --> 0:25:34,835
则文本字段将在后台线程上解除分配

590
00:25:35,903 --> 0:25:38,138
文本字段作为应答器

591
00:25:38,205 --> 0:25:39,573
是应答器链的一部分

592
00:25:39,873 --> 0:25:42,543
它可以是视图层次结构

593
00:25:42,976 --> 0:25:44,811
所有数据结构都是如此

594
00:25:44,878 --> 0:25:46,914
从后台做修改是不安全的

595
00:25:46,980 --> 0:25:48,182
因为这是dealloc要做的

596
00:25:50,150 --> 0:25:51,418
在macOS 10.15中

597
00:25:51,885 --> 0:25:52,719
这不是问题

598
00:25:53,220 --> 0:25:56,356
NSResponder会自动将

599
00:25:56,423 --> 0:25:58,725
移动到主线程

600
00:25:59,593 --> 0:26:01,495
所以在模块中做捕捉就很安全了

601
00:25:59,593 --> 0:26:01,495
所以在模块中做捕捉就很安全了

602
00:26:01,562 --> 0:26:04,097
而不用担心这些模块在哪里会被释放

603
00:26:04,531 --> 0:26:07,367
所以我认为这在你的app中

604
00:26:07,434 --> 0:26:08,635
可以去除许多复杂的事故

605
00:26:09,169 --> 0:26:11,638
因为这些后台上的崩溃

606
00:26:11,905 --> 0:26:14,541
在几秒甚至几分钟后才会显现出来

607
00:26:21,682 --> 0:26:24,484
我还想谈谈打开和保存面板

608
00:26:24,551 --> 0:26:25,419
（面板和工作区）

609
00:26:25,485 --> 0:26:28,956
我们在macOS 10.15中

610
00:26:29,890 --> 0:26:32,359
那就是打开和保存面板

611
00:26:32,826 --> 0:26:34,561
现在是两个不同的过程

612
00:26:35,462 --> 0:26:39,499
这在沙盒app中已经实施了

613
00:26:40,000 --> 0:26:42,102
我们只是把它用于所有app而已

614
00:26:43,136 --> 0:26:45,038
这应该不会有什么太大影响

615
00:26:45,105 --> 0:26:47,241
你应该不会注意到

616
00:26:47,841 --> 0:26:49,810
除了一些性能和安全性问题

617
00:26:50,477 --> 0:26:53,280
但是 如果要对打开和

618
00:26:53,347 --> 0:26:55,983
且依赖于特定的

619
00:26:56,350 --> 0:26:57,451
那你就会遇到问题了

620
00:26:57,918 --> 0:26:59,419
我们希望能在实验室看到你们

621
00:26:59,486 --> 0:27:01,488
讨论这些问题并解决这些问题

622
00:26:59,486 --> 0:27:01,488
讨论这些问题并解决这些问题

623
00:27:02,222 --> 0:27:03,524
（面板）

624
00:27:03,590 --> 0:27:04,858
（新NSWORKSPACE方法）

625
00:27:05,325 --> 0:27:08,395
我们在macOS 10.15中

626
00:27:10,264 --> 0:27:14,001
这些方法可用于打开一或多个URL

627
00:27:14,601 --> 0:27:16,904
这听起来很熟悉

628
00:27:16,970 --> 0:27:18,305
已经有了这样的方法

629
00:27:18,939 --> 0:27:19,907
是的

630
00:27:20,307 --> 0:27:21,708
但新方法是异步的

631
00:27:22,042 --> 0:27:24,011
因此它们根本不会阻止主要威胁

632
00:27:24,444 --> 0:27:27,581
当app完成启动或取消操作时

633
00:27:27,648 --> 0:27:29,516
我们将以完成处理程序进行回调

634
00:27:30,551 --> 0:27:32,085
除了异步之外

635
00:27:32,452 --> 0:27:35,222
这些方法还可以高度控制

636
00:27:35,289 --> 0:27:37,791
我们启动这些URL和app的方式

637
00:27:39,326 --> 0:27:40,627
而该控制通过

638
00:27:40,928 --> 0:27:43,764
新NSWorkspace.OpenConfiguration对象

639
00:27:45,566 --> 0:27:48,235
这只是一个告诉你如何操作的例子

640
00:27:48,602 --> 0:27:51,805
但你可以控制用户是否参与此过程

641
00:27:51,872 --> 0:27:53,006
比如

642
00:27:53,073 --> 0:27:54,408
如果你要请求服务器安装

643
00:27:54,474 --> 0:27:56,210
或是不知道要用哪个app

644
00:27:56,276 --> 0:27:58,145
用户就要选择一个app

645
00:27:58,879 --> 0:28:01,849
这时你就可以压制这种行为

646
00:27:58,879 --> 0:28:01,849
这时你就可以压制这种行为

647
00:28:02,783 --> 0:28:05,219
你也可以控制一项程序或是文件

648
00:28:05,285 --> 0:28:06,587
是否要添加进最近访问菜单

649
00:28:07,321 --> 0:28:09,122
有很多东西可以控制

650
00:28:09,189 --> 0:28:11,859
哪些app可以在启动时隐藏

651
00:28:11,925 --> 0:28:14,027
哪些app可以在启动时隐藏

652
00:28:14,628 --> 0:28:17,531
所以 不管你的url

653
00:28:18,031 --> 0:28:20,901
NSWorkspace在

654
00:28:23,370 --> 0:28:24,505
（活动）

655
00:28:26,039 --> 0:28:27,941
我们来简单谈谈活动

656
00:28:29,409 --> 0:28:31,078
这是我想要展示的功能

657
00:28:31,879 --> 0:28:35,115
如果你将鼠标停在绿色按钮上

658
00:28:35,983 --> 0:28:37,117
在窗口标题栏上

659
00:28:37,551 --> 0:28:38,819
你就会得到新菜单

660
00:28:39,286 --> 0:28:40,487
第一组选项

661
00:28:40,821 --> 0:28:43,156
就是将窗口全屏显示

662
00:28:43,223 --> 0:28:45,592
或将其放置在共享全屏空间中

663
00:28:46,360 --> 0:28:47,427
这很实用

664
00:28:47,761 --> 0:28:50,564
但还有一项更实用的功能

665
00:28:50,898 --> 0:28:53,467
就是可以将窗口移至另一显示器

666
00:28:55,068 --> 0:28:57,070
这对于经常将电脑

667
00:28:57,137 --> 0:28:58,539
连到另一个扩展屏幕的人来说

668
00:28:58,605 --> 0:29:00,207
我觉得尤其实用

669
00:28:58,605 --> 0:29:00,207
我觉得尤其实用

670
00:29:00,974 --> 0:29:03,377
但你不需要用传统意义上的显示器

671
00:29:04,244 --> 0:29:07,080
有附加显示器功能的

672
00:29:08,715 --> 0:29:10,017
你们可以看到

673
00:29:10,083 --> 0:29:12,352
这是一个叫Pencil Draw

674
00:29:12,419 --> 0:29:14,688
上面有美丽的草书

675
00:29:15,656 --> 0:29:16,757
该app支持

676
00:29:17,024 --> 0:29:20,894
所以iPad现在可以

677
00:29:22,129 --> 0:29:25,232
所以在macOS 10.15中

678
00:29:26,099 --> 0:29:29,169
如果你在过去几年中一直在想

679
00:29:29,236 --> 0:29:31,371
为你的app增加平板支持

680
00:29:31,438 --> 0:29:33,473
现在正是时候

681
00:29:34,341 --> 0:29:36,376
现在我来告诉你怎么做

682
00:29:37,244 --> 0:29:38,545
（平板活动回顾）

683
00:29:38,979 --> 0:29:41,849
平板活动基本上是正常的鼠标活动

684
00:29:43,750 --> 0:29:45,886
但它们也有不同 如果你注意到

685
00:29:45,953 --> 0:29:47,654
NSEvent SubType

686
00:29:48,188 --> 0:29:50,123
这里有一个

687
00:29:51,091 --> 0:29:53,460
如果你注意到来自平板的

688
00:29:53,527 --> 0:29:54,461
tabletPoint活动

689
00:29:54,895 --> 0:29:57,865
它同时还有附加的压力信息

690
00:29:58,599 --> 0:30:00,934
注意到这些压力信息

691
00:29:58,599 --> 0:30:00,934
注意到这些压力信息

692
00:30:01,001 --> 0:30:02,870
对于做一些漂亮的草书是非常重要的

693
00:30:03,337 --> 0:30:05,405
因为会有不同笔宽的地方

694
00:30:07,508 --> 0:30:10,377
如果你过去在iOS中

695
00:30:11,879 --> 0:30:13,914
通过注册处理程序

696
00:30:13,981 --> 0:30:17,050
对压力进行更新

697
00:30:17,951 --> 0:30:19,152
但这在Mac中没有表现出来

698
00:30:19,219 --> 0:30:21,822
你可以只关注

699
00:30:25,492 --> 0:30:27,961
有一个和Apple Pencil

700
00:30:28,028 --> 0:30:28,962
我想提一提

701
00:30:29,429 --> 0:30:32,399
就是如果你双击笔的侧面

702
00:30:33,000 --> 0:30:34,301
它就会切换

703
00:30:34,368 --> 0:30:36,637
比如画图app中的画图工具

704
00:30:37,204 --> 0:30:38,672
我们叫它

705
00:30:39,306 --> 0:30:40,974
此项活动中有一个

706
00:30:41,308 --> 0:30:42,843
也有新的响应器方法

707
00:30:42,910 --> 0:30:45,646
通过响应器链进行直接处理

708
00:30:48,148 --> 0:30:49,082
在许多情况下

709
00:30:49,349 --> 0:30:51,185
你可能想要平板功能

710
00:30:51,251 --> 0:30:54,688
但它并没有像View一样

711
00:30:55,489 --> 0:30:57,791
但你还是想直接处理该活动

712
00:30:57,858 --> 0:30:59,626
有一个方法可以做到

713
00:30:59,693 --> 0:31:01,995
就是使用现有的

714
00:30:59,693 --> 0:31:01,995
就是使用现有的

715
00:31:03,363 --> 0:31:05,632
看看屏幕底端的代码

716
00:31:06,867 --> 0:31:09,536
你可以看到

717
00:31:09,603 --> 0:31:13,173
用来使活动函数

718
00:31:13,640 --> 0:31:15,309
然后循环使用工具

719
00:31:15,375 --> 0:31:16,510
最后回到活动

720
00:31:16,810 --> 0:31:19,046
让它流经响应者链的其余部分

721
00:31:19,847 --> 0:31:23,884
所以 这是分解代码的好方法

722
00:31:27,187 --> 0:31:28,021
（几何）

723
00:31:28,088 --> 0:31:28,989
好

724
00:31:29,957 --> 0:31:31,725
我们来谈谈基础功能

725
00:31:32,359 --> 0:31:33,894
我们有一些新的几何数据类型

726
00:31:33,961 --> 0:31:35,696
通常进入基础功能

727
00:31:35,963 --> 0:31:37,364
大家都很紧张

728
00:31:37,798 --> 0:31:40,400
今年你可以选怎么个紧张法

729
00:31:43,003 --> 0:31:45,739
数据类型是

730
00:31:46,440 --> 0:31:48,008
NSDirectionalEdgeInsets

731
00:31:48,308 --> 0:31:49,376
和NSRectAlignment

732
00:31:50,344 --> 0:31:52,946
它不在像Min X或Max S

733
00:31:53,013 --> 0:31:53,847
也不是左右

734
00:31:54,314 --> 0:31:57,017
而是用前导和尾后标识符

735
00:31:57,651 --> 0:31:59,987
所以 他们会根据从左到右

736
00:32:00,053 --> 0:32:01,955
上下文自动翻转

737
00:32:03,023 --> 0:32:05,659
NSCollectionView

738
00:32:05,993 --> 0:32:08,962
你也可以在你的app种直接运用

739
00:32:11,999 --> 0:32:13,233
（格式化）

740
00:32:13,300 --> 0:32:15,269
我还想说说另一个基础功能

741
00:32:15,335 --> 0:32:17,638
有助你进行本地化

742
00:32:18,906 --> 0:32:21,909
首先是

743
00:32:23,477 --> 0:32:26,180
NSRelativeDateFormatter

744
00:32:26,246 --> 0:32:27,514
dateTimeStyle

745
00:32:27,581 --> 0:32:30,417
允许你选择是否以绝对单位

746
00:32:30,484 --> 0:32:31,685
或是更口语化的术语工作

747
00:32:31,752 --> 0:32:33,220
是一星期前或是上周

748
00:32:33,854 --> 0:32:35,122
还有unitsStyle

749
00:32:35,189 --> 0:32:39,459
控制了语言是冗长或是简洁

750
00:32:42,563 --> 0:32:44,598
还有新的

751
00:32:45,499 --> 0:32:48,335
NSListFormatter

752
00:32:49,036 --> 0:32:50,237
标量对象

753
00:32:50,504 --> 0:32:52,472
而是格式化一个对象数组

754
00:32:53,841 --> 0:32:56,577
而它对每一个对象

755
00:32:56,643 --> 0:32:57,811
都使用一个单独的格式化程序

756
00:32:58,645 --> 0:33:00,380
列表格式化程序添加的值

757
00:32:58,645 --> 0:33:00,380
列表格式化程序添加的值

758
00:33:01,315 --> 0:33:03,150
是了解在各个格式化字符串之间

759
00:33:03,217 --> 0:33:05,252
在哪里添加逗号

760
00:33:05,786 --> 0:33:08,555
以及是否需要牛津逗号

761
00:33:09,556 --> 0:33:12,326
之后会有关于这方面更详细的演讲

762
00:33:12,392 --> 0:33:14,294
我建议你也听听

763
00:33:17,998 --> 0:33:20,834
关于基础功能

764
00:33:20,901 --> 0:33:22,002
叫Combine

765
00:33:22,436 --> 0:33:24,271
Combine

766
00:33:24,738 --> 0:33:27,574
用于将app中对象的属性

767
00:33:27,875 --> 0:33:30,344
连接到另一个属性

768
00:33:31,311 --> 0:33:33,680
所以我这里展示了具体的例子

769
00:33:34,248 --> 0:33:36,350
这是我们实施的

770
00:33:36,850 --> 0:33:40,354
继续并从模型对象绑定名称属性

771
00:33:40,721 --> 0:33:42,122
至NSText字段值

772
00:33:42,723 --> 0:33:44,258
不管该名称何时改变

773
00:33:44,324 --> 0:33:46,293
该文本字段都会更新其字符串

774
00:33:47,327 --> 0:33:48,662
所以这真的很强大

775
00:33:49,129 --> 0:33:51,164
它app不仅仅是UI绑定

776
00:33:51,565 --> 0:33:54,168
我们也有专门对此进行的演讲

777
00:33:54,234 --> 0:33:55,669
也非常棒

778
00:33:56,436 --> 0:33:58,272
所以这周也去看看

779
00:34:00,340 --> 0:34:01,575
（扩展）

780
00:34:02,409 --> 0:34:03,410
最后

781
00:34:03,477 --> 0:34:06,246
我想说说macOS

782
00:34:07,481 --> 0:34:10,150
我们在系统扩展系列中

783
00:34:10,884 --> 0:34:13,987
以非UI文件提供程序

784
00:34:14,688 --> 0:34:17,791
如果您熟悉基于UI的文件或行为

785
00:34:18,192 --> 0:34:19,525
文件提供者动作扩展

786
00:34:19,826 --> 0:34:20,960
都是一样的

787
00:34:21,027 --> 0:34:23,362
但有时 你并不需要额外的UI

788
00:34:23,429 --> 0:34:25,732
你可以不用 这也满足了这种需要

789
00:34:26,366 --> 0:34:27,501
（新扩展类型）

790
00:34:28,467 --> 0:34:30,571
还有一些我们觉得更有趣的事情

791
00:34:31,438 --> 0:34:33,507
在过去 有一些功能

792
00:34:33,574 --> 0:34:35,909
在OS层面上

793
00:34:36,476 --> 0:34:39,379
我们现在让系统扩展

794
00:34:40,179 --> 0:34:41,547
我们有新的网络扩展

795
00:34:41,982 --> 0:34:45,452
有DriverKit来帮助编写

796
00:34:46,119 --> 0:34:48,088
我们还有新的端点安全系统

797
00:34:48,155 --> 0:34:49,755
有助于编写杀毒软件

798
00:34:50,524 --> 0:34:52,993
所以如果你这些年来

799
00:34:53,060 --> 0:34:54,795
那这些对你就非常有用

800
00:34:55,295 --> 0:34:57,531
我们对此进行了安全提升

801
00:34:57,598 --> 0:34:58,532
我们也感到十分兴奋

802
00:34:58,599 --> 0:35:01,535
你不用再对内核模式调试

803
00:34:58,599 --> 0:35:01,535
你不用再对内核模式调试

804
00:35:03,871 --> 0:35:04,972
所以

805
00:35:05,239 --> 0:35:06,507
这也就包含了我们的补充

806
00:35:06,573 --> 0:35:07,674
（总结）

807
00:35:07,741 --> 0:35:09,676
我想再次提醒你们今天说到的

808
00:35:10,043 --> 0:35:10,944
很棒的东西

809
00:35:11,545 --> 0:35:14,448
我们补充了NSColor

810
00:35:14,781 --> 0:35:17,584
将自己的动态程序

811
00:35:17,651 --> 0:35:18,952
嵌入NSColor系统的新方法

812
00:35:19,353 --> 0:35:21,822
以及你可以自己使用的颜色取样器类

813
00:35:22,122 --> 0:35:23,857
可以直接从屏幕上拾取颜色

814
00:35:25,559 --> 0:35:27,895
我们也说到了NSScreen里的

815
00:35:27,961 --> 0:35:31,465
包括那些让你充分利用

816
00:35:33,033 --> 0:35:35,369
我们说到了各种各样的文本增强功能

817
00:35:37,271 --> 0:35:39,339
如果你想让你的app在较暗主题下

818
00:35:39,406 --> 0:35:41,375
或是呈现简单或富文本

819
00:35:41,875 --> 0:35:44,011
黑暗模式增强功能都会很棒

820
00:35:44,278 --> 0:35:46,914
文本检查控制器将让你

821
00:35:46,980 --> 0:35:47,915
而且是以前所未有的方式

822
00:35:48,582 --> 0:35:52,052
我们兼容iOS和macOS

823
00:35:52,119 --> 0:35:54,188
关于文本大小的调整非常有用

824
00:35:54,521 --> 0:35:57,090
尤其是考虑到今年

825
00:35:59,059 --> 0:36:01,461
我们也说到了像

826
00:35:59,059 --> 0:36:01,461
我们也说到了像

827
00:36:01,795 --> 0:36:02,863
还有CollectionView

828
00:36:03,497 --> 0:36:05,832
你们一定要去听听

829
00:36:05,899 --> 0:36:07,868
因为CollectionView

830
00:36:07,935 --> 0:36:09,036
非常重要的一部分

831
00:36:10,437 --> 0:36:12,406
我们也说到了NSToolbar

832
00:36:12,706 --> 0:36:15,075
让您更轻松地制作按钮

833
00:36:15,142 --> 0:36:18,645
还有使用ToolbarItem组

834
00:36:20,747 --> 0:36:24,418
我们介绍了在NSEvent中

835
00:36:24,484 --> 0:36:27,054
如何处理平板活动及对

836
00:36:27,621 --> 0:36:29,389
再次强调 现在有许多平板用户

837
00:36:29,456 --> 0:36:30,891
在未来会转向使用Mac

838
00:36:31,158 --> 0:36:32,826
我认为你的app可以使用平板功能

839
00:36:33,126 --> 0:36:34,361
加上去会是很棒的功能

840
00:36:35,996 --> 0:36:38,131
最后以对NS的一些本地化提升结束

841
00:36:38,565 --> 0:36:40,567
或者说是对基础几何数据类型的提升

842
00:36:40,934 --> 0:36:41,902
以及新的格式化程序

843
00:36:43,437 --> 0:36:45,472
希望你们都能够喜欢

844
00:36:46,240 --> 0:36:47,541
祝你拥有美好的一周

845
00:36:48,408 --> 0:36:49,443
非常感谢

846
00:36:49,910 --> 0:36:51,979
（欲知更多信息 请登录
