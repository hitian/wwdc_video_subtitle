1
00:00:00,506 --> 0:00:04,500
[ Music ]

2
00:00:07,626 --> 0:00:10,016
&gt;&gt; Hello, my name is Davide and

3
00:00:10,016 --> 0:00:11,066
I am an engineer on the

4
00:00:11,066 --> 0:00:12,826
Debugging Technologies Team at

5
00:00:12,826 --> 0:00:13,126
Apple.

6
00:00:13,866 --> 0:00:15,166
I'm here with my colleague

7
00:00:15,166 --> 0:00:15,686
Jonas.

8
00:00:16,306 --> 0:00:18,326
You might be familiar with po, a

9
00:00:18,476 --> 0:00:20,576
way to print variables in LLDB.

10
00:00:21,286 --> 0:00:23,426
Today, we will talk about it and

11
00:00:23,426 --> 0:00:24,696
how it works.

12
00:00:24,846 --> 0:00:26,846
We will also present other ways

13
00:00:26,846 --> 0:00:28,286
to look at the variables in your

14
00:00:28,286 --> 0:00:30,006
source code together with

15
00:00:30,006 --> 0:00:32,906
powerful mechanisms to format

16
00:00:33,786 --> 0:00:34,286
the output.

17
00:00:34,286 --> 0:00:36,726
LLDB is the debugger that powers

18
00:00:36,726 --> 0:00:38,256
the variable view in Xcode.

19
00:00:39,426 --> 0:00:40,816
You can see the variables you

20
00:00:40,816 --> 0:00:42,466
define and their types there.

21
00:00:43,236 --> 0:00:45,086
While debugging in Xcode, you

22
00:00:45,086 --> 0:00:47,016
can also directly send commands

23
00:00:47,076 --> 0:00:49,156
and interact with LLDB through

24
00:00:49,156 --> 0:00:50,866
the console in the bottom right

25
00:00:50,866 --> 0:00:51,526
of the window.

26
00:00:52,416 --> 0:00:53,946
This includes the ability to

27
00:00:53,946 --> 0:00:55,176
print the values of the

28
00:00:55,176 --> 0:00:56,516
variables to defining your

29
00:00:56,516 --> 0:00:58,026
source code while you're

30
00:00:58,026 --> 0:00:59,386
investigating a bug in your

31
00:00:59,386 --> 0:01:00,076
application.

32
00:00:59,386 --> 0:01:00,076
application.

33
00:01:00,576 --> 0:01:02,926
LLDB offer several ways to

34
00:01:02,926 --> 0:01:04,025
accomplish this task.

35
00:01:04,426 --> 0:01:05,756
Each of which comes with a

36
00:01:05,756 --> 0:01:07,306
different set of trade-offs.

37
00:01:07,596 --> 0:01:08,516
Let's look at them.

38
00:01:09,236 --> 0:01:11,456
As an example, suppose we have a

39
00:01:11,456 --> 0:01:13,266
struct that represents a Trip,

40
00:01:13,736 --> 0:01:15,616
consisting of a name and a list

41
00:01:15,616 --> 0:01:16,576
of destinations.

42
00:01:17,126 --> 0:01:18,516
Let's go on a cruise around the

43
00:01:18,516 --> 0:01:19,336
Mediterranean.

44
00:01:20,886 --> 0:01:22,236
The first command we are going

45
00:01:22,236 --> 0:01:25,296
to explore is po, which you can

46
00:01:25,296 --> 0:01:27,266
think as of standing for print

47
00:01:27,266 --> 0:01:28,306
object description.

48
00:01:28,476 --> 0:01:30,316
When we use this command, what

49
00:01:30,316 --> 0:01:32,276
we get in return is the object

50
00:01:32,276 --> 0:01:34,366
description which is a textual

51
00:01:34,366 --> 0:01:36,266
representation of an instance of

52
00:01:36,266 --> 0:01:36,816
your type.

53
00:01:37,496 --> 0:01:39,106
The system runtime provides a

54
00:01:39,106 --> 0:01:41,426
default one but it's possible to

55
00:01:41,426 --> 0:01:42,246
customize it.

56
00:01:43,126 --> 0:01:44,766
We can do this by adding a

57
00:01:44,766 --> 0:01:46,116
conformance to the

58
00:01:46,116 --> 0:01:48,096
CustomDebugStringConvertible

59
00:01:48,096 --> 0:01:48,726
protocol.

60
00:01:48,726 --> 0:01:51,426
This requires having a single

61
00:01:51,426 --> 0:01:52,706
property called the

62
00:01:52,706 --> 0:01:53,806
debugDescription.

63
00:01:54,996 --> 0:01:57,056
Now, if we print the object

64
00:01:57,056 --> 0:01:58,586
description in the debugger,

65
00:01:59,076 --> 0:02:00,356
we'll see the description we

66
00:01:59,076 --> 0:02:00,356
we'll see the description we

67
00:02:00,356 --> 0:02:02,356
provided instead of the default

68
00:02:02,356 --> 0:02:02,616
one.

69
00:02:03,556 --> 0:02:04,786
The change only affects the

70
00:02:04,786 --> 0:02:06,086
top-level description.

71
00:02:06,086 --> 0:02:08,996
If you need to modify the

72
00:02:08,996 --> 0:02:10,596
substructure, check the

73
00:02:10,596 --> 0:02:11,796
documentation for the

74
00:02:11,796 --> 0:02:13,586
CustomerReflectable protocol.

75
00:02:14,406 --> 0:02:15,716
This can also be done for

76
00:02:15,716 --> 0:02:17,496
Objective-C objects by

77
00:02:17,496 --> 0:02:18,896
implementing the description

78
00:02:18,896 --> 0:02:19,406
method.

79
00:02:20,856 --> 0:02:23,306
But po does more than just print

80
00:02:23,306 --> 0:02:23,976
variables.

81
00:02:24,246 --> 0:02:26,406
For example, you can take the

82
00:02:26,406 --> 0:02:28,226
name of our cruise and compute

83
00:02:28,226 --> 0:02:30,606
an uppercase version of it or

84
00:02:30,606 --> 0:02:32,396
get an alphabetically sorted

85
00:02:32,396 --> 0:02:33,396
array of the cruise

86
00:02:33,396 --> 0:02:34,236
destinations.

87
00:02:35,216 --> 0:02:37,496
In general, it can evaluate

88
00:02:37,496 --> 0:02:38,996
arbitrary expressions.

89
00:02:39,376 --> 0:02:41,076
So, anything that would compile

90
00:02:41,076 --> 0:02:42,876
at a given prompt in the program

91
00:02:43,286 --> 0:02:44,826
can be passed as an argument to

92
00:02:44,826 --> 0:02:45,456
the comment.

93
00:02:46,836 --> 0:02:49,356
In fact, po is actually an alias

94
00:02:49,356 --> 0:02:51,156
for a command called expression

95
00:02:51,626 --> 0:02:53,216
with an argument for printing

96
00:02:53,216 --> 0:02:54,256
the object description.

97
00:02:54,316 --> 0:02:57,566
LECC and LLDB are a convenient

98
00:02:57,566 --> 0:02:59,686
way to save keystrokes.

99
00:02:59,746 --> 0:03:01,776
If you wanted to implement po

100
00:02:59,746 --> 0:03:01,776
If you wanted to implement po

101
00:03:01,776 --> 0:03:04,006
yourself, for example, you could

102
00:03:04,006 --> 0:03:05,126
use command alias.

103
00:03:05,306 --> 0:03:07,256
Specify your own command name as

104
00:03:07,256 --> 0:03:08,946
the first argument, and then

105
00:03:08,946 --> 0:03:10,336
follow with the command you want

106
00:03:10,336 --> 0:03:10,976
to alias.

107
00:03:11,306 --> 0:03:13,476
Once that's defined, you can use

108
00:03:13,476 --> 0:03:15,096
it like any other commands in

109
00:03:15,096 --> 0:03:15,636
LLDB.

110
00:03:17,186 --> 0:03:18,996
Now that we know what po can do,

111
00:03:19,236 --> 0:03:20,726
let's take a deeper look at how

112
00:03:20,726 --> 0:03:21,306
it works.

113
00:03:22,256 --> 0:03:24,026
Let's go through the steps that

114
00:03:24,026 --> 0:03:25,626
po has to perform to deliver a

115
00:03:25,626 --> 0:03:25,976
value.

116
00:03:26,486 --> 0:03:28,406
To provide the full expressivity

117
00:03:28,406 --> 0:03:29,696
of the language you are using

118
00:03:30,076 --> 0:03:32,306
LLDB doesn't parse and evaluate

119
00:03:32,306 --> 0:03:33,916
the expression itself.

120
00:03:34,146 --> 0:03:36,566
Instead, it starts by generating

121
00:03:36,566 --> 0:03:38,156
a piece of source code that can

122
00:03:38,156 --> 0:03:39,886
be compiled from the expression

123
00:03:39,886 --> 0:03:41,716
you gave it, similar to the

124
00:03:41,716 --> 0:03:42,946
snippet shown here.

125
00:03:43,396 --> 0:03:45,456
Then it uses the embedded Swift

126
00:03:45,456 --> 0:03:47,306
and claim compilers to compile

127
00:03:47,306 --> 0:03:50,016
the code which gets executed in

128
00:03:50,016 --> 0:03:51,376
the context of your debugged

129
00:03:51,376 --> 0:03:51,896
program.

130
00:03:52,616 --> 0:03:54,636
Once the execution is complete,

131
00:03:55,146 --> 0:03:57,196
LLDB has to access the resulting

132
00:03:57,196 --> 0:03:57,536
value.

133
00:03:59,716 --> 0:04:01,266
From there you need to get the

134
00:03:59,716 --> 0:04:01,266
From there you need to get the

135
00:04:01,266 --> 0:04:02,256
object description.

136
00:04:02,616 --> 0:04:04,636
To do this, LLDB wraps the

137
00:04:04,636 --> 0:04:06,606
previous result in another piece

138
00:04:06,606 --> 0:04:07,366
of source code.

139
00:04:08,026 --> 0:04:09,986
This also gets compiled and

140
00:04:09,986 --> 0:04:11,656
executed in the context of your

141
00:04:11,656 --> 0:04:13,316
debug process.

142
00:04:13,316 --> 0:04:15,056
The result of this execution is

143
00:04:15,056 --> 0:04:17,646
a string that LLDB will display

144
00:04:17,646 --> 0:04:19,435
as the result of the po command.

145
00:04:19,796 --> 0:04:21,435
Po is only the first of the

146
00:04:21,435 --> 0:04:22,956
three ways we are presenting to

147
00:04:22,956 --> 0:04:24,526
print variables in LLDB.

148
00:04:24,926 --> 0:04:26,166
Let's look at the others.

149
00:04:26,606 --> 0:04:28,176
The second way to print

150
00:04:28,176 --> 0:04:30,026
variables in an LLDB is the

151
00:04:30,026 --> 0:04:30,706
p-command.

152
00:04:31,316 --> 0:04:32,896
You can think of it as print

153
00:04:33,116 --> 0:04:34,746
without the object description.

154
00:04:35,356 --> 0:04:36,746
Let's look at its output.

155
00:04:37,576 --> 0:04:38,986
The first thing to notice is

156
00:04:38,986 --> 0:04:40,356
that the representation is

157
00:04:40,356 --> 0:04:41,946
slightly different from the one

158
00:04:41,946 --> 0:04:44,006
provided by po, but it is

159
00:04:44,006 --> 0:04:45,926
equivalent in that it contains

160
00:04:45,926 --> 0:04:47,006
the same information.

161
00:04:47,766 --> 0:04:49,176
The second thing to notice is

162
00:04:49,176 --> 0:04:50,776
that the resulting value has

163
00:04:50,776 --> 0:04:53,716
been given a name, $R0.

164
00:04:53,866 --> 0:04:55,396
This is a special convention in

165
00:04:55,396 --> 0:04:55,976
LLDB.

166
00:04:56,686 --> 0:04:58,576
The result of each expression is

167
00:04:58,576 --> 0:05:00,476
given an incrementing name, such

168
00:04:58,576 --> 0:05:00,476
given an incrementing name, such

169
00:05:00,476 --> 0:05:02,726
as $R1 and $R2.

170
00:05:02,726 --> 0:05:05,156
And this name can be used in

171
00:05:05,156 --> 0:05:06,786
later expressions in LLDB.

172
00:05:07,516 --> 0:05:10,576
You can refer to $R0 the same

173
00:05:10,576 --> 0:05:12,196
way as any other variable in

174
00:05:12,196 --> 0:05:12,976
your project.

175
00:05:13,496 --> 0:05:15,256
You can, for example, print the

176
00:05:15,256 --> 0:05:16,376
fields of destruction.

177
00:05:17,156 --> 0:05:19,316
Similar to po, p is not a

178
00:05:19,316 --> 0:05:21,156
first-class command in LLDB.

179
00:05:21,606 --> 0:05:22,966
It's just an alias for the

180
00:05:22,966 --> 0:05:25,356
expression command, but without

181
00:05:25,356 --> 0:05:27,686
the -- object description after

182
00:05:28,586 --> 0:05:28,756
it.

183
00:05:28,756 --> 0:05:30,386
As we previously did with po,

184
00:05:30,756 --> 0:05:32,586
let's look at how po works under

185
00:05:32,586 --> 0:05:33,056
the hood.

186
00:05:35,166 --> 0:05:36,736
Since p doesn't have to get the

187
00:05:36,736 --> 0:05:38,306
description, it doesn't have to

188
00:05:38,306 --> 0:05:39,176
do as much work.

189
00:05:39,846 --> 0:05:41,936
You may recall this diagram from

190
00:05:41,936 --> 0:05:43,396
the earlier description of po.

191
00:05:43,966 --> 0:05:45,746
In fact, the first part

192
00:05:46,086 --> 0:05:47,636
compiling and evaluating the

193
00:05:47,636 --> 0:05:49,656
expression is exactly the same

194
00:05:49,656 --> 0:05:50,636
for both commands.

195
00:05:51,266 --> 0:05:52,826
But once it gets the results

196
00:05:53,266 --> 0:05:55,436
LLDB perform a step name dynamic

197
00:05:55,436 --> 0:05:56,726
type resolution on it.

198
00:05:57,486 --> 0:05:58,856
Let's describe it with more

199
00:05:58,856 --> 0:05:59,436
details.

200
00:06:00,146 --> 0:06:01,896
In order to do that, we have to

201
00:06:01,896 --> 0:06:04,066
modify our code example a bit.

202
00:06:04,446 --> 0:06:05,176
Let's see how.

203
00:06:06,356 --> 0:06:08,096
We change our Trip struct to

204
00:06:08,296 --> 0:06:09,916
conform to a protocol name

205
00:06:09,916 --> 0:06:10,566
activity.

206
00:06:11,666 --> 0:06:12,956
In Swift, the static

207
00:06:12,956 --> 0:06:14,466
representation of a type in the

208
00:06:14,466 --> 0:06:16,326
source code and the dynamic type

209
00:06:16,326 --> 0:06:17,726
at the runtime, aren't

210
00:06:17,726 --> 0:06:18,896
necessarily the same.

211
00:06:18,986 --> 0:06:21,796
For example, a variable might be

212
00:06:21,796 --> 0:06:23,396
declared using a protocol of

213
00:06:23,396 --> 0:06:24,066
this type.

214
00:06:25,006 --> 0:06:27,386
In this example, the static type

215
00:06:27,386 --> 0:06:28,486
of cruise's Activity.

216
00:06:29,156 --> 0:06:31,216
But at runtime, the variable

217
00:06:31,216 --> 0:06:32,986
will have an instance of type

218
00:06:32,986 --> 0:06:35,126
Trip which is the dynamic time.

219
00:06:35,126 --> 0:06:38,046
If we print the value of cruise,

220
00:06:38,046 --> 0:06:39,856
we get back an object of type

221
00:06:39,856 --> 0:06:42,446
Trip because LLDB retell results

222
00:06:42,446 --> 0:06:44,176
metadata to display the most

223
00:06:44,176 --> 0:06:45,616
accurate type for a given

224
00:06:45,616 --> 0:06:47,116
variable at a given program

225
00:06:47,116 --> 0:06:47,466
point.

226
00:06:47,466 --> 0:06:49,626
This is what we call dynamic

227
00:06:49,626 --> 0:06:50,586
type resolution.

228
00:06:51,096 --> 0:06:53,466
With the p-command, dynamic type

229
00:06:53,466 --> 0:06:55,796
resolution is only performed on

230
00:06:55,796 --> 0:06:57,146
the result of the expression.

231
00:06:57,826 --> 0:06:59,346
Let's say we want to access one

232
00:06:59,346 --> 0:07:00,386
of the field of cruise.

233
00:06:59,346 --> 0:07:00,386
of the field of cruise.

234
00:07:01,006 --> 0:07:02,966
When LLDB tries to evaluate this

235
00:07:02,966 --> 0:07:05,016
expression through p, it sees

236
00:07:05,016 --> 0:07:06,676
that cruise is an object of type

237
00:07:06,676 --> 0:07:08,536
Activity and doesn't have a

238
00:07:08,536 --> 0:07:09,506
member called name.

239
00:07:09,776 --> 0:07:11,596
The evaluation fails with an

240
00:07:11,596 --> 0:07:11,886
error.

241
00:07:12,576 --> 0:07:14,476
This happens because if you

242
00:07:14,476 --> 0:07:16,936
remember, LLDB compiles code

243
00:07:16,936 --> 0:07:18,736
where running p and the only

244
00:07:18,736 --> 0:07:20,616
type it sees is the one in your

245
00:07:20,616 --> 0:07:22,326
source code, the static one.

246
00:07:23,196 --> 0:07:24,616
It's the same thing as typing

247
00:07:24,616 --> 0:07:26,506
the expression cruise.name in

248
00:07:26,506 --> 0:07:27,406
your source code.

249
00:07:27,836 --> 0:07:29,536
The static compiler will reject

250
00:07:29,536 --> 0:07:30,336
it with an error.

251
00:07:30,696 --> 0:07:32,956
If you want to evaluate the

252
00:07:32,956 --> 0:07:34,846
expression without errors, you

253
00:07:34,846 --> 0:07:36,536
need to first cast the object

254
00:07:36,536 --> 0:07:39,136
explicitly to its dynamic type

255
00:07:39,136 --> 0:07:40,596
and then access the field on the

256
00:07:40,596 --> 0:07:41,116
result.

257
00:07:41,586 --> 0:07:42,916
This is true both for the

258
00:07:42,916 --> 0:07:44,626
debugger and your source code.

259
00:07:46,526 --> 0:07:48,636
P is not yet done with its work.

260
00:07:48,636 --> 0:07:50,936
After it performed dynamic type

261
00:07:50,936 --> 0:07:53,516
resolution on the result, LLDB

262
00:07:53,516 --> 0:07:55,236
passes the resulting object to

263
00:07:55,236 --> 0:07:57,396
the formatter subsystem which is

264
00:07:57,396 --> 0:07:59,306
the part of LLDB responsible for

265
00:07:59,306 --> 0:08:01,286
printing a human readable

266
00:07:59,306 --> 0:08:01,286
printing a human readable

267
00:08:01,286 --> 0:08:02,556
description of objects.

268
00:08:02,916 --> 0:08:04,026
Let's dive into it.

269
00:08:05,096 --> 0:08:06,986
To show how formatters work,

270
00:08:07,226 --> 0:08:08,626
we're going to display their

271
00:08:08,626 --> 0:08:09,666
input and output.

272
00:08:10,196 --> 0:08:12,056
Here's what that string looks

273
00:08:12,056 --> 0:08:13,916
like if there was no formatter

274
00:08:13,916 --> 0:08:14,676
for the type.

275
00:08:15,586 --> 0:08:17,386
If you want to try yourself, you

276
00:08:17,386 --> 0:08:19,616
can pass the -- raw option to p.

277
00:08:19,616 --> 0:08:22,406
Standard library types even

278
00:08:22,406 --> 0:08:23,996
simple ones like strings and

279
00:08:23,996 --> 0:08:25,446
integers have complex

280
00:08:25,446 --> 0:08:27,286
representation because they are

281
00:08:27,286 --> 0:08:28,956
highly optimized for speed and

282
00:08:28,956 --> 0:08:29,426
size.

283
00:08:29,526 --> 0:08:32,176
After the formatter operates in

284
00:08:32,176 --> 0:08:34,336
it a string looks exactly as you

285
00:08:34,336 --> 0:08:35,696
expect, a sequence of

286
00:08:35,696 --> 0:08:37,606
characters.

287
00:08:37,606 --> 0:08:40,025
LLDB knows about a bunch of

288
00:08:40,025 --> 0:08:41,936
commonly used types and provides

289
00:08:41,936 --> 0:08:43,145
formatters for them.

290
00:08:43,796 --> 0:08:45,766
You can also write for customize

291
00:08:45,766 --> 0:08:46,416
formatters.

292
00:08:46,676 --> 0:08:48,166
We'll talk about it shortly.

293
00:08:49,236 --> 0:08:51,466
We talk about p and po.

294
00:08:52,226 --> 0:08:53,986
We are now going to describe the

295
00:08:53,986 --> 0:08:55,676
third way to print variables in

296
00:08:55,676 --> 0:08:57,636
LLDB, the v-command.

297
00:08:59,126 --> 0:09:01,506
The output of v is exactly the

298
00:08:59,126 --> 0:09:01,506
The output of v is exactly the

299
00:09:01,506 --> 0:09:03,916
same as p as it also relies on

300
00:09:03,916 --> 0:09:05,626
the formatter we just described.

301
00:09:06,866 --> 0:09:08,516
As with the other two commands,

302
00:09:08,616 --> 0:09:10,846
v is just an alias we introduced

303
00:09:10,846 --> 0:09:13,596
in Xcode 10.2 for the frame

304
00:09:13,596 --> 0:09:14,566
variable command.

305
00:09:14,926 --> 0:09:16,716
Unlike the other two mechanisms,

306
00:09:16,966 --> 0:09:18,696
the v-command doesn't compile

307
00:09:18,696 --> 0:09:20,476
and execute code at all which

308
00:09:20,476 --> 0:09:22,246
makes it very fast.

309
00:09:22,246 --> 0:09:24,726
Since v is not compiling code,

310
00:09:24,726 --> 0:09:26,816
it does its own syntax which

311
00:09:26,816 --> 0:09:28,636
will not necessarily be the same

312
00:09:28,636 --> 0:09:29,486
as the language you are

313
00:09:29,486 --> 0:09:30,096
debugging.

314
00:09:30,666 --> 0:09:33,096
For example, it used the dot and

315
00:09:33,096 --> 0:09:35,316
subscript operators to access

316
00:09:35,316 --> 0:09:36,106
fields over time.

317
00:09:36,646 --> 0:09:38,156
But it won't perform overload

318
00:09:38,156 --> 0:09:39,906
the resolution and computed

319
00:09:39,906 --> 0:09:41,906
properties cannot be evaluated

320
00:09:42,526 --> 0:09:44,316
since that would require code to

321
00:09:44,316 --> 0:09:45,266
be executed.

322
00:09:46,026 --> 0:09:48,866
You can use p or po if you need

323
00:09:48,866 --> 0:09:49,226
those.

324
00:09:49,696 --> 0:09:52,206
As you can guess, v works fairly

325
00:09:52,206 --> 0:09:53,716
differently from the other two

326
00:09:53,716 --> 0:09:55,026
mechanisms for printing

327
00:09:55,026 --> 0:09:55,726
variables.

328
00:09:56,196 --> 0:09:58,016
Let's go ahead and clarify some

329
00:09:58,016 --> 0:09:58,646
details.

330
00:09:59,286 --> 0:10:00,746
In our grand tradition of

331
00:09:59,286 --> 0:10:00,746
In our grand tradition of

332
00:10:00,746 --> 0:10:02,766
diagrams here is one for v.

333
00:10:03,446 --> 0:10:04,926
We want to print a variable.

334
00:10:05,336 --> 0:10:07,816
To do so, v first consults the

335
00:10:07,816 --> 0:10:09,376
program state to locate the

336
00:10:09,376 --> 0:10:10,356
variable in memory.

337
00:10:10,836 --> 0:10:12,886
Then it reads the value of the

338
00:10:12,886 --> 0:10:13,996
variable from memory.

339
00:10:14,376 --> 0:10:16,146
Then it performs dynamic type

340
00:10:16,146 --> 0:10:17,156
resolution on it.

341
00:10:17,506 --> 0:10:19,306
If the user asked to access

342
00:10:19,306 --> 0:10:21,646
subfields, it repeats the step

343
00:10:21,786 --> 0:10:23,176
for each of the subfields

344
00:10:23,416 --> 0:10:24,846
performing dynamic type

345
00:10:24,846 --> 0:10:26,226
resolution at each round.

346
00:10:26,786 --> 0:10:29,176
Once it's done, it passes the

347
00:10:29,176 --> 0:10:30,866
result to the data formatter

348
00:10:30,866 --> 0:10:31,616
subsystem.

349
00:10:32,356 --> 0:10:34,336
The fact that v performs dynamic

350
00:10:34,336 --> 0:10:35,956
type resolution potentially

351
00:10:35,956 --> 0:10:38,206
multiple times is an important

352
00:10:38,206 --> 0:10:40,176
detail to remember and the big

353
00:10:40,176 --> 0:10:42,286
difference in the way p and v

354
00:10:42,286 --> 0:10:43,226
operates.

355
00:10:43,226 --> 0:10:44,826
The formatter indeed performs

356
00:10:44,826 --> 0:10:46,416
dynamic type resolution only

357
00:10:46,416 --> 0:10:46,846
once.

358
00:10:46,846 --> 0:10:48,796
Let's look at the scenario where

359
00:10:48,796 --> 0:10:49,726
these matters.

360
00:10:51,146 --> 0:10:53,146
We are back to our example where

361
00:10:53,146 --> 0:10:54,666
p was failing to access the

362
00:10:54,666 --> 0:10:55,546
member of cruise.

363
00:10:56,266 --> 0:10:57,766
By performing dynamic type

364
00:10:57,766 --> 0:10:59,396
resolution at each step of the

365
00:10:59,396 --> 0:11:01,716
interpretation, v is able to

366
00:10:59,396 --> 0:11:01,716
interpretation, v is able to

367
00:11:01,716 --> 0:11:03,136
understand that cruise is an

368
00:11:03,136 --> 0:11:05,576
object of type Trip and access

369
00:11:05,576 --> 0:11:06,696
its field in memory.

370
00:11:06,946 --> 0:11:09,516
This is a scenario where v is

371
00:11:09,516 --> 0:11:11,206
strictly more powerful than p

372
00:11:11,366 --> 0:11:13,016
and allows you to look at your

373
00:11:13,016 --> 0:11:14,796
types where p doesn't or without

374
00:11:14,796 --> 0:11:15,886
an explicit cast.

375
00:11:17,126 --> 0:11:18,606
We are done describing the three

376
00:11:18,606 --> 0:11:20,226
different ways for printing

377
00:11:20,226 --> 0:11:21,506
variables in LLDB.

378
00:11:23,356 --> 0:11:24,986
Let's have a recap and the

379
00:11:24,986 --> 0:11:27,046
side-by-side comparison of how

380
00:11:27,046 --> 0:11:29,556
the po, p and v commands differ.

381
00:11:30,466 --> 0:11:32,116
The first point we want to make

382
00:11:32,116 --> 0:11:33,856
is about how objects are

383
00:11:33,856 --> 0:11:34,556
presented.

384
00:11:35,326 --> 0:11:37,366
The po command uses the object

385
00:11:37,366 --> 0:11:39,636
description, whereas the p and v

386
00:11:39,636 --> 0:11:42,066
commands use the data formatters

387
00:11:42,066 --> 0:11:43,226
to display the object.

388
00:11:43,916 --> 0:11:45,476
We also want to remember how our

389
00:11:45,476 --> 0:11:46,686
results are computed.

390
00:11:47,376 --> 0:11:48,886
Both po and p compile

391
00:11:48,886 --> 0:11:50,676
expressions and have access to

392
00:11:50,676 --> 0:11:51,546
the full language.

393
00:11:52,136 --> 0:11:54,276
V instead has its own syntax

394
00:11:54,366 --> 0:11:56,436
interprets the expression and

395
00:11:56,436 --> 0:11:58,366
performs dynamic type resolution

396
00:11:58,366 --> 0:11:59,346
for each step of the

397
00:11:59,346 --> 0:12:00,216
interpretation.

398
00:11:59,346 --> 0:12:00,216
interpretation.

399
00:12:02,176 --> 0:12:04,516
We mentioned earlier that LLDB

400
00:12:04,516 --> 0:12:06,336
formatting can be customized.

401
00:12:06,686 --> 0:12:08,706
To talk more about that, here is

402
00:12:08,706 --> 0:12:09,786
my colleague Jonas.

403
00:12:10,236 --> 0:12:12,996
&gt;&gt; Hi, I'm Jonas, and I'm also

404
00:12:12,996 --> 0:12:14,266
an engineer on the Debugging

405
00:12:14,266 --> 0:12:15,186
Technologies Team.

406
00:12:16,026 --> 0:12:18,096
In LLDB, data formatter is

407
00:12:18,096 --> 0:12:19,556
defined how variables are

408
00:12:19,556 --> 0:12:20,856
displayed in the debugger.

409
00:12:22,436 --> 0:12:24,086
There are building formatters

410
00:12:24,086 --> 0:12:25,086
for common types.

411
00:12:25,476 --> 0:12:27,456
For instance, when using the

412
00:12:27,456 --> 0:12:28,906
v-commands, we can print the

413
00:12:28,906 --> 0:12:30,866
destinations of our cruise and

414
00:12:30,866 --> 0:12:32,396
the array elements are displayed

415
00:12:32,396 --> 0:12:33,376
in a readable format.

416
00:12:34,336 --> 0:12:36,136
Usually, the default formatter

417
00:12:36,136 --> 0:12:37,816
works great for both the user

418
00:12:37,816 --> 0:12:39,586
defined types and for types

419
00:12:39,586 --> 0:12:40,516
coming from the standard

420
00:12:40,516 --> 0:12:40,936
library.

421
00:12:41,676 --> 0:12:43,256
But sometimes you might want to

422
00:12:43,256 --> 0:12:45,196
tweak an existing formatter or

423
00:12:45,196 --> 0:12:46,126
to find one yourself.

424
00:12:47,836 --> 0:12:49,636
And you can, because data

425
00:12:49,636 --> 0:12:51,836
formatters in LLDB are fully

426
00:12:51,836 --> 0:12:52,536
extensible.

427
00:12:53,216 --> 0:12:54,596
Every type can have its own

428
00:12:54,596 --> 0:12:55,446
representation.

429
00:12:56,096 --> 0:12:57,106
To help you customize that

430
00:12:57,106 --> 0:12:59,376
representation, LLDB offers

431
00:12:59,376 --> 0:13:01,996
filters, summaries and synthetic

432
00:12:59,376 --> 0:13:01,996
filters, summaries and synthetic

433
00:13:01,996 --> 0:13:02,416
children.

434
00:13:04,266 --> 0:13:05,826
Filters are used to limit the

435
00:13:05,826 --> 0:13:07,616
output of existing formatters.

436
00:13:08,166 --> 0:13:09,676
Right now, our Trip only has a

437
00:13:09,676 --> 0:13:11,476
few destinations but as the

438
00:13:11,476 --> 0:13:13,216
number increases, the output

439
00:13:13,256 --> 0:13:14,186
could become cluttered.

440
00:13:15,626 --> 0:13:17,236
By adding a filter, we can

441
00:13:17,236 --> 0:13:19,026
specify that we only want to see

442
00:13:19,026 --> 0:13:19,766
the Trips name.

443
00:13:20,786 --> 0:13:22,246
This not only affects the output

444
00:13:22,246 --> 0:13:23,536
of the formatter in the console,

445
00:13:23,536 --> 0:13:25,196
but also the variables here in

446
00:13:25,196 --> 0:13:25,626
Xcode.

447
00:13:26,546 --> 0:13:27,896
Let's remove the filter again

448
00:13:27,986 --> 0:13:29,026
before moving on.

449
00:13:30,616 --> 0:13:32,136
Summaries provide a string

450
00:13:32,136 --> 0:13:33,296
representation of a type.

451
00:13:33,656 --> 0:13:34,996
To give information about that

452
00:13:34,996 --> 0:13:36,976
type at a glance, their data

453
00:13:36,976 --> 0:13:38,476
formatter equivalent of the

454
00:13:38,476 --> 0:13:39,756
description that you would

455
00:13:39,756 --> 0:13:41,186
implement for use with po.

456
00:13:41,716 --> 0:13:43,646
As with filters, they also

457
00:13:43,646 --> 0:13:44,766
affect the variables view in

458
00:13:44,766 --> 0:13:45,166
Xcode.

459
00:13:46,166 --> 0:13:47,406
While the members of our Trip

460
00:13:47,406 --> 0:13:48,906
all have summaries, the Trip

461
00:13:48,906 --> 0:13:49,676
itself does not.

462
00:13:50,006 --> 0:13:50,936
Let's change that.

463
00:13:52,536 --> 0:13:53,856
A good summary would be the

464
00:13:53,856 --> 0:13:55,416
first and last destination.

465
00:13:56,216 --> 0:13:57,616
The summary string can contain

466
00:13:57,616 --> 0:13:59,346
regular text and special

467
00:13:59,346 --> 0:14:01,346
variables that access fields of

468
00:13:59,346 --> 0:14:01,346
variables that access fields of

469
00:14:01,346 --> 0:14:02,336
the time being printed.

470
00:14:03,086 --> 0:14:04,236
These variables start with a

471
00:14:04,236 --> 0:14:05,796
dollar sign and are wrapped in

472
00:14:05,796 --> 0:14:06,676
curly braces.

473
00:14:07,276 --> 0:14:08,746
They use the same syntax as the

474
00:14:08,746 --> 0:14:09,456
v-commands.

475
00:14:10,186 --> 0:14:11,646
The current type for which the

476
00:14:11,646 --> 0:14:13,836
summary is defined is access as

477
00:14:13,836 --> 0:14:14,186
var.

478
00:14:14,966 --> 0:14:17,176
The summary uses var.name to

479
00:14:17,176 --> 0:14:18,726
access the Trips name and

480
00:14:18,726 --> 0:14:20,546
var.destinations to access its

481
00:14:20,546 --> 0:14:21,326
destinations.

482
00:14:22,526 --> 0:14:23,626
But there's a problem with the

483
00:14:23,626 --> 0:14:24,136
summary.

484
00:14:24,556 --> 0:14:26,126
It only works for Trips that

485
00:14:26,126 --> 0:14:27,156
contain exactly three

486
00:14:27,156 --> 0:14:27,946
destinations.

487
00:14:28,636 --> 0:14:29,936
Because formatters can't access

488
00:14:29,936 --> 0:14:31,306
computed variables like the

489
00:14:31,306 --> 0:14:32,896
count of an array, we have to

490
00:14:32,896 --> 0:14:34,346
hard-code the index of the last

491
00:14:34,346 --> 0:14:34,696
element.

492
00:14:36,416 --> 0:14:37,836
Fortunately, there's another

493
00:14:37,836 --> 0:14:39,556
powerful tool available to us.

494
00:14:40,046 --> 0:14:41,686
We can also define summaries in

495
00:14:41,686 --> 0:14:42,176
Python.

496
00:14:43,046 --> 0:14:44,286
Python formatters can do

497
00:14:44,286 --> 0:14:46,336
arbitrary computations and they

498
00:14:46,336 --> 0:14:48,056
have full access to LLDB's

499
00:14:48,146 --> 0:14:50,376
scripting bridge API which

500
00:14:50,376 --> 0:14:52,006
provides several objects for

501
00:14:52,006 --> 0:14:53,296
accessing the state of the

502
00:14:53,296 --> 0:14:54,316
current debug session.

503
00:14:54,596 --> 0:14:58,026
The target is the program that's

504
00:14:58,026 --> 0:14:59,136
currently being debugged.

505
00:14:59,696 --> 0:15:02,326
The process, thread, and frame

506
00:14:59,696 --> 0:15:02,326
The process, thread, and frame

507
00:15:02,326 --> 0:15:03,496
provides access to the

508
00:15:03,496 --> 0:15:04,566
corresponding runtime

509
00:15:04,566 --> 0:15:05,296
information.

510
00:15:06,266 --> 0:15:08,946
Values of variables, registers,

511
00:15:09,036 --> 0:15:11,176
or expressions are represented

512
00:15:11,176 --> 0:15:12,856
by the SB value class.

513
00:15:13,346 --> 0:15:14,316
These are particularly

514
00:15:14,316 --> 0:15:15,606
interesting to the data

515
00:15:15,606 --> 0:15:17,426
formatters because they are used

516
00:15:17,426 --> 0:15:18,906
to navigate types and their

517
00:15:18,906 --> 0:15:19,656
values.

518
00:15:20,306 --> 0:15:21,086
Check out the online

519
00:15:21,086 --> 0:15:22,986
documentation for more details.

520
00:15:25,016 --> 0:15:26,636
Starting with Xcode 11,

521
00:15:26,786 --> 0:15:28,196
scripting uses Python 3.

522
00:15:28,926 --> 0:15:30,216
If you have existing Python 2

523
00:15:30,216 --> 0:15:31,836
scripts, check out the Xcode

524
00:15:31,836 --> 0:15:33,046
release notes for more

525
00:15:33,046 --> 0:15:34,426
information on transitioning to

526
00:15:34,426 --> 0:15:35,006
Python 3.

527
00:15:35,546 --> 0:15:39,586
Let's explore the LLDB API.

528
00:15:40,746 --> 0:15:42,306
Executing the script commands

529
00:15:42,436 --> 0:15:43,876
drops this into an interactive

530
00:15:43,906 --> 0:15:45,106
Python interpreter.

531
00:15:45,976 --> 0:15:47,696
The current frame is accessible

532
00:15:47,696 --> 0:15:49,526
to the lldb.frame variable.

533
00:15:50,096 --> 0:15:51,466
This returns an SBFrame

534
00:15:51,466 --> 0:15:52,056
instance.

535
00:15:52,746 --> 0:15:53,876
We know that the current frame

536
00:15:53,876 --> 0:15:54,996
contains a variable named

537
00:15:54,996 --> 0:15:55,506
cruise.

538
00:15:56,046 --> 0:15:58,096
So, we can go ahead and use find

539
00:15:58,096 --> 0:16:00,056
variable to obtain its SB value.

540
00:15:58,096 --> 0:16:00,056
variable to obtain its SB value.

541
00:16:01,006 --> 0:16:02,396
Since these objects power the

542
00:16:02,396 --> 0:16:03,806
data formatters under the hood,

543
00:16:04,326 --> 0:16:05,766
it is no surprise that printing

544
00:16:05,766 --> 0:16:07,256
them looks identical to the

545
00:16:07,256 --> 0:16:08,726
corresponding data formatter

546
00:16:08,766 --> 0:16:09,276
outputs.

547
00:16:11,366 --> 0:16:13,126
We also know that cruise has

548
00:16:13,126 --> 0:16:14,636
member named destinations.

549
00:16:14,926 --> 0:16:16,486
We can access it by calling

550
00:16:16,486 --> 0:16:17,686
GetChildMemberWithName.

551
00:16:18,736 --> 0:16:20,646
The result is another SB value

552
00:16:20,906 --> 0:16:22,416
that represents the destinations

553
00:16:22,416 --> 0:16:22,696
array.

554
00:16:23,136 --> 0:16:25,936
Let's try to mimic our earlier

555
00:16:25,936 --> 0:16:28,146
formatter using Python, this

556
00:16:28,146 --> 0:16:29,316
time without hard coding the

557
00:16:29,316 --> 0:16:30,566
index of the last element.

558
00:16:31,396 --> 0:16:33,166
We can use GetNumChildren on the

559
00:16:33,166 --> 0:16:35,166
destinations SB value to get the

560
00:16:35,166 --> 0:16:36,106
number of elements.

561
00:16:36,836 --> 0:16:38,606
With GetChildAtIndex, we can

562
00:16:38,606 --> 0:16:40,616
access the first element and the

563
00:16:40,616 --> 0:16:41,376
last element.

564
00:16:42,336 --> 0:16:43,756
Notice that the printed values

565
00:16:43,756 --> 0:16:44,766
are context sensitive.

566
00:16:45,356 --> 0:16:46,646
They contain the index in the

567
00:16:46,646 --> 0:16:46,976
array.

568
00:16:47,726 --> 0:16:49,406
SB value instances maintain the

569
00:16:49,406 --> 0:16:50,726
context of their parent

570
00:16:50,726 --> 0:16:51,186
relation.

571
00:16:52,556 --> 0:16:53,876
Now, we can put everything

572
00:16:53,876 --> 0:16:55,296
together in a single string.

573
00:16:55,796 --> 0:16:57,486
The results, however, it's not

574
00:16:57,486 --> 0:16:59,236
exactly what we want, by

575
00:16:59,236 --> 0:17:01,596
printing, begin and end, we get

576
00:16:59,236 --> 0:17:01,596
printing, begin and end, we get

577
00:17:01,596 --> 0:17:03,096
descriptions of the SB value

578
00:17:03,096 --> 0:17:03,746
objects.

579
00:17:04,146 --> 0:17:05,695
What we really want here are

580
00:17:05,695 --> 0:17:06,465
their summaries.

581
00:17:07,096 --> 0:17:08,915
We can use GetSummary to

582
00:17:08,915 --> 0:17:10,756
retrieve the formatted value and

583
00:17:10,756 --> 0:17:11,476
use that instead.

584
00:17:12,106 --> 0:17:13,886
Now, the result is place only

585
00:17:13,886 --> 0:17:14,876
the destination strings

586
00:17:14,876 --> 0:17:15,476
themselves.

587
00:17:15,886 --> 0:17:18,276
Let's put everything together.

588
00:17:18,586 --> 0:17:20,026
Formatters can be defined

589
00:17:20,026 --> 0:17:21,726
directly in the debugger console

590
00:17:22,116 --> 0:17:23,695
or you can use a file and load

591
00:17:23,695 --> 0:17:24,546
it into LLDB.

592
00:17:25,226 --> 0:17:26,516
In this case, we'll create a

593
00:17:26,516 --> 0:17:27,986
file called Trip.py.

594
00:17:28,926 --> 0:17:30,066
When defining a provider in a

595
00:17:30,066 --> 0:17:31,646
file instead of using the

596
00:17:31,646 --> 0:17:32,706
current frame to access the

597
00:17:32,706 --> 0:17:34,556
variable we want to display the

598
00:17:34,556 --> 0:17:36,256
SB value is passed as an input

599
00:17:36,256 --> 0:17:37,526
parameter to a function.

600
00:17:38,606 --> 0:17:40,006
The rest of the implementation

601
00:17:40,096 --> 0:17:41,836
is pretty much identical to what

602
00:17:41,836 --> 0:17:42,566
we did before.

603
00:17:43,576 --> 0:17:44,866
Another advantage of using

604
00:17:44,866 --> 0:17:46,546
Python to define the formatter

605
00:17:46,826 --> 0:17:47,976
is that we have control flow.

606
00:17:48,706 --> 0:17:50,356
If the trip has no destinations,

607
00:17:50,576 --> 0:17:51,876
we can just sprint that it's an

608
00:17:51,876 --> 0:17:52,356
empty trip.

609
00:17:53,286 --> 0:17:54,586
We get the summary for the first

610
00:17:54,586 --> 0:17:56,476
and last destination and return

611
00:17:56,476 --> 0:17:57,166
to summary string.

612
00:17:58,846 --> 0:18:00,136
Now, we need to load our new

613
00:17:58,846 --> 0:18:00,136
Now, we need to load our new

614
00:18:00,136 --> 0:18:02,086
summary provider into LLDB.

615
00:18:02,646 --> 0:18:04,166
This is done using the command

616
00:18:04,166 --> 0:18:05,396
script import command.

617
00:18:06,266 --> 0:18:08,166
Next, we need to specify that

618
00:18:08,166 --> 0:18:09,616
our new formatter is the one to

619
00:18:09,616 --> 0:18:11,106
use for the Trip type.

620
00:18:11,586 --> 0:18:13,346
Using type summary add and

621
00:18:13,346 --> 0:18:14,406
providing the type to be

622
00:18:14,406 --> 0:18:15,976
formatted, and the provider

623
00:18:15,976 --> 0:18:16,856
function to use.

624
00:18:17,676 --> 0:18:18,946
It's important to use the fully

625
00:18:18,946 --> 0:18:20,016
qualified type here.

626
00:18:20,746 --> 0:18:22,456
With everything hooked up v now

627
00:18:22,456 --> 0:18:24,136
uses the Python summary provider

628
00:18:24,286 --> 0:18:25,416
to print a cruise object.

629
00:18:27,066 --> 0:18:28,396
Not only does the summary show

630
00:18:28,396 --> 0:18:29,926
up in the console, it is also

631
00:18:29,926 --> 0:18:31,446
displayed in Xcode's Variable

632
00:18:31,446 --> 0:18:31,686
View.

633
00:18:32,126 --> 0:18:34,316
We've talked about filters and

634
00:18:34,316 --> 0:18:34,946
summaries.

635
00:18:35,256 --> 0:18:36,536
The final way to customize the

636
00:18:36,536 --> 0:18:38,086
display of your type is with

637
00:18:38,086 --> 0:18:39,016
synthetic children.

638
00:18:39,776 --> 0:18:41,006
These make it possible to

639
00:18:41,006 --> 0:18:42,706
customize what kind of children

640
00:18:42,706 --> 0:18:44,826
your type exposes, such as when

641
00:18:44,826 --> 0:18:45,946
you expend to type in the

642
00:18:45,946 --> 0:18:47,356
variables view in Xcode.

643
00:18:48,146 --> 0:18:49,996
In Python, each child has an SB

644
00:18:49,996 --> 0:18:51,796
value, and each can have its own

645
00:18:51,796 --> 0:18:52,246
summary.

646
00:18:54,386 --> 0:18:55,676
Defining your own synthetic

647
00:18:55,676 --> 0:18:57,326
child provider is similar to

648
00:18:57,326 --> 0:18:58,726
defining a summary provider.

649
00:18:59,056 --> 0:19:00,476
But instead of a function you

650
00:18:59,056 --> 0:19:00,476
But instead of a function you

651
00:19:00,476 --> 0:19:01,926
define a class that implements

652
00:19:01,926 --> 0:19:02,756
certain methods.

653
00:19:03,446 --> 0:19:05,306
In addition to init, you provide

654
00:19:05,306 --> 0:19:06,576
a method to get the total number

655
00:19:06,576 --> 0:19:08,266
of children, the synthetic

656
00:19:08,266 --> 0:19:09,736
children themselves, and an

657
00:19:09,736 --> 0:19:10,856
index for a given name.

658
00:19:11,616 --> 0:19:12,686
A full example of this is

659
00:19:12,686 --> 0:19:14,376
available in the resources link

660
00:19:14,376 --> 0:19:15,076
from this session.

661
00:19:17,996 --> 0:19:19,596
Just like before, use command

662
00:19:19,596 --> 0:19:21,156
script import to load the Python

663
00:19:21,156 --> 0:19:22,666
source code into LLDB.

664
00:19:23,336 --> 0:19:24,966
In this case, we already loaded

665
00:19:24,966 --> 0:19:26,576
this file earlier and running

666
00:19:26,576 --> 0:19:27,936
the command again will reload

667
00:19:27,936 --> 0:19:28,366
the file.

668
00:19:29,956 --> 0:19:31,746
To specify the formatter, to use

669
00:19:31,746 --> 0:19:33,706
for synthetic children use type

670
00:19:33,706 --> 0:19:35,396
synthetic add and provide the

671
00:19:35,396 --> 0:19:36,926
type to be formatted and the

672
00:19:36,926 --> 0:19:37,796
class to use.

673
00:19:39,486 --> 0:19:40,786
After going through the effort

674
00:19:40,856 --> 0:19:42,096
of defining our own custom

675
00:19:42,096 --> 0:19:43,766
providers, we don't want to lose

676
00:19:43,766 --> 0:19:45,016
them at the end of our debug

677
00:19:45,016 --> 0:19:45,376
session.

678
00:19:46,206 --> 0:19:47,266
Any command you type in the

679
00:19:47,266 --> 0:19:49,666
console can be persisted in the

680
00:19:49,666 --> 0:19:51,406
.lldbinit file in your home

681
00:19:51,406 --> 0:19:51,926
directory.

682
00:19:52,706 --> 0:19:53,936
This file gets automatically

683
00:19:53,936 --> 0:19:55,276
loaded at the beginning of your

684
00:19:55,276 --> 0:19:55,986
debug session.

685
00:19:58,636 --> 0:20:00,716
LLDB has a variety of features

686
00:19:58,636 --> 0:20:00,716
LLDB has a variety of features

687
00:20:00,716 --> 0:20:02,096
to help you see the state of

688
00:20:02,096 --> 0:20:03,376
your program while debugging.

689
00:20:03,956 --> 0:20:06,716
Use v, p, or po to print

690
00:20:06,716 --> 0:20:08,236
variables, depending on whether

691
00:20:08,236 --> 0:20:09,456
you just need to display its

692
00:20:09,456 --> 0:20:11,406
value, execute code or get the

693
00:20:11,406 --> 0:20:12,676
object description.

694
00:20:13,536 --> 0:20:14,906
Customize or define your own

695
00:20:14,906 --> 0:20:16,926
data formatters, using filters,

696
00:20:17,096 --> 0:20:18,806
string summaries, and synthetic

697
00:20:18,806 --> 0:20:19,246
children.

698
00:20:19,986 --> 0:20:21,746
Finally, if you have scripts

699
00:20:21,746 --> 0:20:23,686
written in Python 2, update them

700
00:20:23,686 --> 0:20:25,306
to be compatible with Python 3.

701
00:20:25,696 --> 0:20:27,116
The version used by LLDB

702
00:20:27,336 --> 0:20:28,766
starting in Xcode 11.

703
00:20:30,826 --> 0:20:32,446
For more information, check out

704
00:20:32,446 --> 0:20:33,786
the page for this session on

705
00:20:33,786 --> 0:20:35,186
developer.apple.com.
