1
00:00:06,039 --> 0:00:09,443
（Xcode测试）

2
00:00:14,248 --> 0:00:16,583
早上好 欢迎参加

3
00:00:17,217 --> 0:00:18,552
我是Ana Calinov

4
00:00:18,619 --> 0:00:20,687
我将与我的同事

5
00:00:20,988 --> 0:00:22,689
Stuart Montgomery

6
00:00:24,124 --> 0:00:25,359
在今天的演讲中

7
00:00:25,425 --> 0:00:28,729
我们先介绍用XCTest

8
00:00:29,396 --> 0:00:32,299
然后Stuart会讲测试计划功能

9
00:00:32,966 --> 0:00:38,005
最后Ethan会讲

10
00:00:38,071 --> 0:00:39,373
（XCTEST入门）

11
00:00:39,439 --> 0:00:41,108
让我们先讲XCTest

12
00:00:42,643 --> 0:00:47,147
XCTest是Xcode提供的

13
00:00:47,447 --> 0:00:51,251
配备内置支持可以帮助你

14
00:00:52,286 --> 0:00:55,389
测试对于开发任何项目来说

15
00:00:55,789 --> 0:00:58,325
测试可以帮助你找到源代码中的错误

16
00:00:59,359 --> 0:01:01,795
你还可以使用测试来编纂需求

17
00:00:59,359 --> 0:01:01,795
你还可以使用测试来编纂需求

18
00:01:02,262 --> 0:01:05,933
意思是测试你所预期的行为

19
00:01:06,400 --> 0:01:08,569
并且你和你的团队之后的工作

20
00:01:08,936 --> 0:01:10,904
也可以通过这些预期得到保证

21
00:01:12,673 --> 0:01:14,041
我们先看一个概述

22
00:01:14,308 --> 0:01:17,344
关于你应该如何考虑规划

23
00:01:17,411 --> 0:01:18,245
任意项目的自动化测试套件

24
00:01:19,146 --> 0:01:21,448
用于测试的金字塔模型

25
00:01:21,849 --> 0:01:24,218
有助于在彻底性、

26
00:01:24,785 --> 0:01:26,720
质量和执行速度之间取得平衡

27
00:01:26,787 --> 0:01:28,188
（测试金字塔）

28
00:01:28,255 --> 0:01:30,224
单元测试是金字塔的基础

29
00:01:31,325 --> 0:01:33,994
单元测试用于验证某一段代码

30
00:01:34,328 --> 0:01:35,395
通常是个函数

31
00:01:36,496 --> 0:01:39,333
这是通过给函数输入变量

32
00:01:39,833 --> 0:01:42,002
并检查它们是否返回预期的输出

33
00:01:43,003 --> 0:01:45,472
单元测试很短 很简单

34
00:01:45,839 --> 0:01:46,974
并且运行速度也很快

35
00:01:47,975 --> 0:01:49,977
这是我们所有测试的基础

36
00:01:50,277 --> 0:01:53,113
因此你要写很多单元测试

37
00:01:55,015 --> 0:01:56,683
接下来我们有集成测试

38
00:01:57,518 --> 0:02:01,221
集成测试用于验证较大的一部分代码

39
00:01:57,518 --> 0:02:01,221
集成测试用于验证较大的一部分代码

40
00:02:02,122 --> 0:02:06,226
这些测试的目标是

41
00:02:06,660 --> 0:02:09,963
用于确保不同组件可以在一起

42
00:02:11,832 --> 0:02:14,334
集成测试位于单元测试之上

43
00:02:14,401 --> 0:02:17,971
因为你要确保

44
00:02:18,038 --> 0:02:20,140
先确保单一函数正常运行

45
00:02:21,275 --> 0:02:24,845
一般来说 你不需要有与单元测试

46
00:02:25,546 --> 0:02:27,181
集成测试的运行时间稍长

47
00:02:27,514 --> 0:02:29,683
但它们却可以一次测试很多东西

48
00:02:31,118 --> 0:02:34,188
最后是用户界面或UI测试

49
00:02:34,621 --> 0:02:37,291
用于观察app的用户端行为

50
00:02:38,158 --> 0:02:41,628
这会确保你的app

51
00:02:42,596 --> 0:02:44,665
UI测试的运行时间最长

52
00:02:45,065 --> 0:02:48,035
但它们对于表明

53
00:02:49,536 --> 0:02:51,939
UI测试还要求更多的维护

54
00:02:52,005 --> 0:02:54,641
因为你app的UI可能会发生

55
00:02:55,576 --> 0:02:58,745
完整的测试金字塔可以帮助你

56
00:02:58,812 --> 0:03:00,747
在三种不同的测试类型之间进行平衡

57
00:02:58,812 --> 0:03:00,747
在三种不同的测试类型之间进行平衡

58
00:03:01,114 --> 0:03:04,151
并确保测试套件

59
00:03:05,686 --> 0:03:08,155
那么我们刚讲了如何平衡测试套件

60
00:03:08,655 --> 0:03:11,491
现在让我们讲一下XCTest

61
00:03:11,558 --> 0:03:12,659
用于帮助你实施测试

62
00:03:15,362 --> 0:03:17,030
XCTest中的单元测试

63
00:03:17,798 --> 0:03:20,067
是针对源代码的所有测试

64
00:03:21,001 --> 0:03:23,170
这包含标准单元测试

65
00:03:23,504 --> 0:03:25,038
以及集成测试

66
00:03:26,907 --> 0:03:29,543
UI测试在app的UI上执行

67
00:03:29,843 --> 0:03:32,479
用于提供app的端对端认证

68
00:03:33,647 --> 0:03:35,916
UI测试也是黑箱测试

69
00:03:35,983 --> 0:03:38,819
因为它们不依赖于

70
00:03:38,886 --> 0:03:40,921
实际支撑你app的任何函数或类

71
00:03:41,989 --> 0:03:44,758
UI测试可以确保

72
00:03:44,825 --> 0:03:47,094
一切都在最末端正常运行

73
00:03:48,695 --> 0:03:51,865
最后性能测试在指定测试中多次运行

74
00:03:51,932 --> 0:03:55,035
用于查看平均时间、

75
00:03:55,369 --> 0:03:58,172
内存使用或给定的其它度量

76
00:03:58,539 --> 0:04:01,241
从而确保你不会在这些区域引入回归

77
00:03:58,539 --> 0:04:01,241
从而确保你不会在这些区域引入回归

78
00:04:02,142 --> 0:04:05,112
今天我们主要讲单元测试和UI测试

79
00:04:06,513 --> 0:04:09,716
开始测试Xcode项目的

80
00:04:10,150 --> 0:04:14,755
当开始新项目时选择既包含单元测试

81
00:04:16,490 --> 0:04:17,724
在我们的全新的项目中

82
00:04:18,225 --> 0:04:20,594
你可以看到单元测试的目标类

83
00:04:20,961 --> 0:04:22,796
和UI测试的目标类

84
00:04:23,130 --> 0:04:26,400
都在项目导航器中自动创建和显示

85
00:04:28,001 --> 0:04:29,970
还为你提供了模板

86
00:04:30,437 --> 0:04:32,673
用于编写每个测试类

87
00:04:32,739 --> 0:04:34,274
以及其中的测试用例

88
00:04:35,709 --> 0:04:39,580
现在让我们具体看一下

89
00:04:40,647 --> 0:04:44,618
类导入XCTest框架时也导入了

90
00:04:45,953 --> 0:04:48,956
类自身是XCTest用例的

91
00:04:49,389 --> 0:04:53,093
从而Xcode可以使用类的方法

92
00:04:54,528 --> 0:04:56,930
我们想用作测试用例的每个方法

93
00:04:57,197 --> 0:05:00,367
都必须以测试这个词开头

94
00:04:57,197 --> 0:05:00,367
都必须以测试这个词开头

95
00:05:00,434 --> 0:05:02,002
然后命名最好是暗示它的功能

96
00:05:03,904 --> 0:05:06,740
你还将看到测试左侧有测试菱形

97
00:05:07,407 --> 0:05:09,409
用于显示Xcode可以执行它

98
00:05:10,644 --> 0:05:11,745
在测试内部

99
00:05:12,479 --> 0:05:16,283
断言API用于评估和验证源代码

100
00:05:17,184 --> 0:05:19,453
在这个例子中

101
00:05:19,720 --> 0:05:21,955
会比较给定它的前两个值

102
00:05:22,022 --> 0:05:23,257
并确保它们相等

103
00:05:23,891 --> 0:05:26,627
如果不等 将导致测试失败

104
00:05:27,961 --> 0:05:29,630
现在一旦我们运行这个测试

105
00:05:30,497 --> 0:05:31,798
我们希望测试通过

106
00:05:31,865 --> 0:05:34,568
那样测试菱形会变成绿色

107
00:05:35,569 --> 0:05:37,437
我们知道情况并非总是如此

108
00:05:38,272 --> 0:05:41,775
如果测试失败 测试菱形将变成一个

109
00:05:42,109 --> 0:05:43,710
并且会凸显相关代码行

110
00:05:44,778 --> 0:05:48,015
我们还会得到一个报错信息

111
00:05:49,183 --> 0:05:51,618
我们传给

112
00:05:51,685 --> 0:05:55,422
也会显示出来 为我们提供

113
00:05:56,523 --> 0:06:00,294
在这个例子中

114
00:05:56,523 --> 0:06:00,294
在这个例子中

115
00:06:00,794 --> 0:06:03,530
或你可能初始化为一个错误的值

116
00:06:04,498 --> 0:06:07,234
我们可以返回源代码 修复这个问题

117
00:06:07,768 --> 0:06:10,070
并再次运行我们的测试

118
00:06:12,739 --> 0:06:16,810
每个测试类模板包含一个setUp

119
00:06:17,711 --> 0:06:20,981
这些代码块可以让你围绕测试

120
00:06:21,048 --> 0:06:24,885
从而保持测试的特定目的

121
00:06:26,520 --> 0:06:29,556
SetUp在每个测试用例

122
00:06:30,324 --> 0:06:33,260
在UI测试中 它用于确保

123
00:06:33,327 --> 0:06:34,761
在尝试与app交互

124
00:06:36,129 --> 0:06:38,098
然后XCTest

125
00:06:38,599 --> 0:06:41,034
然后tearDown用于

126
00:06:41,101 --> 0:06:43,770
清理你对app的数据

127
00:06:44,137 --> 0:06:45,973
或全局状态所做的任何修改

128
00:06:46,406 --> 0:06:50,010
从而确保测试不会留下任何可能影响

129
00:06:51,411 --> 0:06:55,315
现在让我们看一个演示

130
00:06:55,582 --> 0:06:56,717
编写单元测试和UI测试

131
00:06:56,783 --> 0:06:57,985
（演示）

132
00:07:03,423 --> 0:07:05,392
我们一直在开发一款旅游app

133
00:07:05,993 --> 0:07:08,295
这显示了世界各地不同的目的地

134
00:07:08,362 --> 0:07:09,763
可以帮助你制定度假计划

135
00:07:10,764 --> 0:07:12,866
我想给app添加一个新功能

136
00:07:13,200 --> 0:07:16,136
显示每个目的地

137
00:07:16,203 --> 0:07:18,172
距离我们当前所在的圣何塞有多远

138
00:07:19,339 --> 0:07:22,843
为此我写了一个新类

139
00:07:23,944 --> 0:07:25,679
这个类定义一个城市结构

140
00:07:26,079 --> 0:07:28,549
包含一个带有城市名称的字符串

141
00:07:28,949 --> 0:07:30,384
和一个城市坐标的元组

142
00:07:32,252 --> 0:07:35,122
我当前在字典中存储了城市列表

143
00:07:35,522 --> 0:07:37,758
我计划稍后再迁移这两个数据库

144
00:07:39,193 --> 0:07:40,627
我有一个函数叫做city

145
00:07:40,961 --> 0:07:43,230
它会返回一个可选的城市结构类型

146
00:07:43,931 --> 0:07:46,633
用于在字典中搜索城市

147
00:07:48,135 --> 0:07:50,804
我打算从这个类中使用的主函数

148
00:07:50,871 --> 0:07:52,172
是distanceInMiles

149
00:07:53,006 --> 0:07:55,509
它接受两个城市名称的字符串

150
00:07:55,576 --> 0:07:58,078
并以double返回

151
00:07:58,879 --> 0:08:01,415
如果词典中找不到其中任意一个城市

152
00:07:58,879 --> 0:08:01,415
如果词典中找不到其中任意一个城市

153
00:08:01,949 --> 0:08:03,483
将引发报错

154
00:08:05,219 --> 0:08:08,989
最后我有另一个帮助函数

155
00:08:09,857 --> 0:08:12,960
它接受城市结构

156
00:08:13,927 --> 0:08:16,330
这个函数使用核心位置框架

157
00:08:16,797 --> 0:08:18,599
因此它替我分担了大部分繁重的工作

158
00:08:20,033 --> 0:08:22,269
要开始编写这个类的单元测试

159
00:08:22,736 --> 0:08:26,340
我已经创建了一个新的测试类

160
00:08:27,574 --> 0:08:28,909
当我开始编写测试时

161
00:08:28,976 --> 0:08:30,544
我希望看到我的源代码

162
00:08:30,611 --> 0:08:32,880
因此我要在下边打开另一个编辑器

163
00:08:33,547 --> 0:08:36,149
然后导航到我的

164
00:08:39,620 --> 0:08:42,688
我要编写的第一个测试是

165
00:08:44,358 --> 0:08:46,326
因此我要开始编写一个单元测试

166
00:08:47,261 --> 0:08:49,429
并把它命名为

167
00:08:50,497 --> 0:08:52,299
对于每个单元测试类

168
00:08:52,366 --> 0:08:54,735
我都将选择一个特定的测试用例

169
00:08:54,801 --> 0:08:56,236
从而确保函数能用

170
00:08:57,337 --> 0:09:00,674
在这个例子中 我要在city

171
00:08:57,337 --> 0:09:00,674
在这个例子中 我要在city

172
00:09:00,974 --> 0:09:03,243
并确保返回了它的正确坐标

173
00:09:04,378 --> 0:09:05,579
我要做的第一件事

174
00:09:05,646 --> 0:09:09,516
就是通过初始化我的

175
00:09:11,285 --> 0:09:15,589
现在我可以开始编写并调用函数了

176
00:09:16,623 --> 0:09:21,428
但有一点要记住

177
00:09:22,296 --> 0:09:25,566
因此我想确保我得到的返回值不是无

178
00:09:26,667 --> 0:09:28,936
为此 我可以使用这个API

179
00:09:29,536 --> 0:09:34,274
并尝试使用XCTUnwrap

180
00:09:39,146 --> 0:09:41,481
然后我可以对

181
00:09:42,683 --> 0:09:44,685
现在我得到了一个报错信息

182
00:09:45,018 --> 0:09:47,154
因为看起来出现了一个报错

183
00:09:47,454 --> 0:09:48,889
但没有被处理

184
00:09:50,057 --> 0:09:51,959
如果city的返回值为无

185
00:09:52,659 --> 0:09:55,696
然后我必须确保我的测试用例

186
00:09:55,762 --> 0:09:57,931
也适当地显示出了这个问题

187
00:10:00,100 --> 0:10:01,969
现在我的city变量

188
00:10:02,503 --> 0:10:04,404
用于返回Seattle的值

189
00:10:05,038 --> 0:10:09,176
我可以使用我的断言API来确保

190
00:10:09,243 --> 0:10:11,111
经度和维度值都正确

191
00:10:12,646 --> 0:10:15,215
现在我要点击测试菱形运行测试

192
00:10:17,484 --> 0:10:18,619
这将会启动app

193
00:10:18,952 --> 0:10:21,188
运行测试 并告诉我们发生了什么

194
00:10:23,223 --> 0:10:25,359
看起来测试成功了 太棒了

195
00:10:27,661 --> 0:10:29,796
我现在可以给类编写另一个测试了

196
00:10:30,063 --> 0:10:32,399
我要测试我的

197
00:10:35,302 --> 0:10:38,372
我要把函数命名为

198
00:10:38,772 --> 0:10:42,242
具体看看我的功能性返回

199
00:10:43,510 --> 0:10:45,546
在这里我要做的第一件事

200
00:10:45,612 --> 0:10:48,916
就是通过初始化DistanceCalculator

201
00:10:50,017 --> 0:10:51,985
但在这一点上 我的代码产生了重复

202
00:10:52,052 --> 0:10:55,255
因为我必须在每个测试用例的开始

203
00:10:56,390 --> 0:10:57,491
因此

204
00:10:57,558 --> 0:10:59,526
我要声明一个类变量…

205
00:11:00,894 --> 0:11:05,332
叫做calculator

206
00:11:05,399 --> 0:11:06,834
我的setUp函数

207
00:11:13,006 --> 0:11:14,441
现在我可以开始编写我的测试了

208
00:11:19,413 --> 0:11:22,816
我要以英里为单位定义距离

209
00:11:22,883 --> 0:11:25,219
调用distanceInMiles

210
00:11:26,620 --> 0:11:30,724
然后我要使用我的断言API来确保

211
00:11:32,492 --> 0:11:34,294
我要运行从测试菱形中运行测试

212
00:11:37,865 --> 0:11:39,700
看起来这个测试失败了

213
00:11:41,034 --> 0:11:42,569
我可以查看报错信息

214
00:11:43,303 --> 0:11:45,806
从问题导航器中查看失败信息

215
00:11:49,776 --> 0:11:52,513
这一次我们的测试运行了

216
00:11:52,579 --> 0:11:53,881
实际测试失败了

217
00:11:55,115 --> 0:11:59,052
看起来我们所期待的和用于对比的值

218
00:11:59,119 --> 0:12:02,422
比我们实际上所查找的值要精确得多

219
00:11:59,119 --> 0:12:02,422
比我们实际上所查找的值要精确得多

220
00:12:04,291 --> 0:12:06,793
在这个例子中 我不关心这个精确度

221
00:12:07,160 --> 0:12:10,464
因为我只想给用户显示

222
00:12:10,531 --> 0:12:11,498
两个城市之间的距离的整数

223
00:12:12,266 --> 0:12:14,635
因此我可以添加一个精确度参数…

224
00:12:17,804 --> 0:12:19,106
替换等于一

225
00:12:19,773 --> 0:12:21,975
这将允许

226
00:12:22,042 --> 0:12:26,547
宽松处理并允许数值加减一

227
00:12:27,748 --> 0:12:30,050
我要再次编写我的测试

228
00:12:33,120 --> 0:12:33,954
太棒了

229
00:12:38,959 --> 0:12:42,062
目前我已经给单元测试类

230
00:12:42,496 --> 0:12:45,933
但这两个测试都接受

231
00:12:46,600 --> 0:12:48,335
并检查是否返回了有效输出

232
00:12:49,069 --> 0:12:51,905
但我还想检查函数的一些

233
00:12:52,673 --> 0:12:56,577
我还想确保在我的类中

234
00:12:57,711 --> 0:13:01,215
因此我要编写的下一个函数

235
00:12:57,711 --> 0:13:01,215
因此我要编写的下一个函数

236
00:13:02,249 --> 0:13:05,252
我不希望Cupertino

237
00:13:05,319 --> 0:13:07,521
因为我只考虑大城市

238
00:13:07,888 --> 0:13:09,723
而Cupertino并不是大城市

239
00:13:12,693 --> 0:13:14,561
因此当我调用Cupertino时

240
00:13:14,628 --> 0:13:16,230
我希望能产生报错

241
00:13:16,763 --> 0:13:19,166
表明城市在数据库中未知

242
00:13:22,469 --> 0:13:25,572
我可以使用XCTAssertThrowsError

243
00:13:27,241 --> 0:13:30,744
然后我可以使用一个闭包

244
00:13:31,945 --> 0:13:35,349
并把它与XCTAssertEqual

245
00:13:36,617 --> 0:13:38,385
现在我已经编写了三个测试

246
00:13:38,819 --> 0:13:40,420
我想一次运行三个测试

247
00:13:40,487 --> 0:13:42,523
从而确保一切都运行无误

248
00:13:43,323 --> 0:13:45,058
我可以进入测试导航器

249
00:13:45,692 --> 0:13:49,830
这将给我按行显示我项目中的

250
00:13:49,897 --> 0:13:52,699
测试类和测试用例

251
00:13:53,767 --> 0:13:57,237
我可以任意选择一个级别

252
00:13:58,071 --> 0:14:01,608
因此如果点击DistanceCalculatorTest

253
00:13:58,071 --> 0:14:01,608
因此如果点击DistanceCalculatorTest

254
00:14:01,909 --> 0:14:03,644
它将运行全部三个测试

255
00:14:04,611 --> 0:14:08,182
我的Apple启动运行它们

256
00:14:08,248 --> 0:14:09,349
意味着测试都通过了

257
00:14:10,918 --> 0:14:13,687
我还可以命令点击不同的行

258
00:14:15,289 --> 0:14:17,424
从而选择运行不同的值

259
00:14:18,091 --> 0:14:19,960
或运行不同的测试类别

260
00:14:20,794 --> 0:14:22,496
如果你不想一次运行所有测试的话

261
00:14:23,497 --> 0:14:24,531
通过情景点击

262
00:14:24,598 --> 0:14:25,632
我可以选择运行它们

263
00:14:27,568 --> 0:14:29,469
如果我选择运行一个子集

264
00:14:29,736 --> 0:14:33,073
然后稍后在我修复一些问题之后

265
00:14:33,607 --> 0:14:35,442
我还可以进入产品菜单

266
00:14:35,976 --> 0:14:37,244
点击实施动作

267
00:14:37,544 --> 0:14:40,147
并选择重新运行上一次运行的测试

268
00:14:41,148 --> 0:14:43,951
现在我已经给我的类编写了一些

269
00:14:44,318 --> 0:14:45,986
我想在UI中实施它

270
00:14:46,854 --> 0:14:48,956
我要通过显示

271
00:14:49,823 --> 0:14:50,824
并运行我的类来实现

272
00:14:52,726 --> 0:14:54,294
在城市名称下面

273
00:14:54,361 --> 0:14:57,097
我们有用于显示这些城市

274
00:14:57,164 --> 0:14:58,332
距离我们当前位置有多远的距离

275
00:15:01,001 --> 0:15:06,106
我们创建了一个新的UITest类

276
00:15:07,274 --> 0:15:10,544
我们的UITest类

277
00:15:11,512 --> 0:15:13,347
失败后继续被设为假

278
00:15:14,047 --> 0:15:15,682
一旦UI测试失败

279
00:15:16,016 --> 0:15:18,986
通常意味着我们进入了一个

280
00:15:19,820 --> 0:15:23,357
我们有可能不能再与任何东西

281
00:15:23,423 --> 0:15:25,158
因为我们不知道屏幕上

282
00:15:26,860 --> 0:15:29,096
我们还想确保app

283
00:15:29,162 --> 0:15:30,497
在我们尝试与之进行交互之前

284
00:15:32,232 --> 0:15:35,836
我们可以开始编写我们的UI测试了

285
00:15:37,070 --> 0:15:39,139
我要编写

286
00:15:39,573 --> 0:15:41,742
目标是打开app

287
00:15:42,342 --> 0:15:44,611
滑动到Paris图标…

288
00:15:45,012 --> 0:15:47,781
然后确保所显示的距离是正确的

289
00:15:50,484 --> 0:15:52,019
我要做的第一件事

290
00:15:52,286 --> 0:15:55,622
是实际确保当我们开始测试时

291
00:15:56,557 --> 0:16:00,194
我可以通过查找app的

292
00:15:56,557 --> 0:16:00,194
我可以通过查找app的

293
00:16:00,260 --> 0:16:01,428
并与之进行交互来编写UI测试

294
00:16:01,995 --> 0:16:06,366
在这个例子中我要查找一个叫做

295
00:16:07,701 --> 0:16:09,136
然后我要轻触它

296
00:16:09,536 --> 0:16:10,838
从而确保我们处于正确的标签上

297
00:16:12,039 --> 0:16:14,107
在我们执行的每个UI动作之后

298
00:16:14,641 --> 0:16:17,878
我们想验证现在显示正确的屏幕

299
00:16:18,478 --> 0:16:20,480
因此我要确保

300
00:16:20,547 --> 0:16:23,016
San Francisco在屏幕上可见

301
00:16:23,083 --> 0:16:25,319
从而确保我们处于所预期的状态中

302
00:16:28,822 --> 0:16:32,492
我要使用XCTAssert语句

303
00:16:32,759 --> 0:16:34,661
一个静态文本

304
00:16:35,362 --> 0:16:38,165
isHittable

305
00:16:38,599 --> 0:16:40,968
并确保它在屏幕上显示

306
00:16:42,836 --> 0:16:46,139
现在我要做的下一件事就是向左滑动

307
00:16:46,206 --> 0:16:47,708
到达Paris

308
00:16:49,276 --> 0:16:52,179
我实际上不确定如何与这张图片

309
00:16:52,479 --> 0:16:55,649
因为它们可能有一个自定义标签

310
00:16:56,416 --> 0:17:00,120
因此我可以使用调试器来获得

311
00:16:56,416 --> 0:17:00,120
因此我可以使用调试器来获得

312
00:17:01,288 --> 0:17:04,958
我要在第26行设置一个断点

313
00:17:05,025 --> 0:17:06,093
然后从测试菱形运行我的测试

314
00:17:07,794 --> 0:17:09,930
Apple启动点击

315
00:17:10,263 --> 0:17:13,700
确保San Francisco可见

316
00:17:18,939 --> 0:17:19,940
在调试器中

317
00:17:20,007 --> 0:17:22,009
我们可以获取关于app的更多信息

318
00:17:22,876 --> 0:17:27,114
我们可以通过使用po app

319
00:17:27,580 --> 0:17:28,649
从而获得这些信息

320
00:17:31,185 --> 0:17:34,188
在这里我们有一个app中的

321
00:17:35,055 --> 0:17:36,623
但是这有点多

322
00:17:36,890 --> 0:17:39,993
因此我要进一步指明我只想打印

323
00:17:40,594 --> 0:17:42,462
我app中的所有图片

324
00:17:44,331 --> 0:17:46,667
太棒了 现在我们有一个

325
00:17:47,134 --> 0:17:49,269
看起来San Francisco

326
00:17:50,170 --> 0:17:53,473
我要复制字符串并关闭调试器

327
00:17:57,744 --> 0:18:02,883
然后把我的sfImage定义为

328
00:17:57,744 --> 0:18:02,883
然后把我的sfImage定义为

329
00:18:07,688 --> 0:18:11,191
现在我可以调用这个查询

330
00:18:12,593 --> 0:18:16,129
一旦我完成这个操作

331
00:18:16,196 --> 0:18:20,000
从而UI中没有任何变更

332
00:18:23,470 --> 0:18:26,773
因此我可以使用XCTAssert

333
00:18:27,941 --> 0:18:31,612
最后我想确保显示了正确的距离

334
00:18:32,012 --> 0:18:38,051
因此我要使用另一个

335
00:18:38,385 --> 0:18:39,920
一个静态文本 可见

336
00:18:40,954 --> 0:18:44,258
现在我们可以从测试菱形

337
00:18:45,626 --> 0:18:48,962
我们会看到一旦我移除断点之后

338
00:18:51,832 --> 0:18:52,933
app启动并执行每一个步骤

339
00:18:59,239 --> 0:19:02,009
我们将看到app启动

340
00:18:59,239 --> 0:19:02,009
我们将看到app启动

341
00:19:02,309 --> 0:19:04,545
查找文本 向左滑动

342
00:19:04,845 --> 0:19:07,381
然后确保正确显示了所有字符串

343
00:19:13,921 --> 0:19:15,822
在这个测试中还有另一件事要考虑

344
00:19:15,889 --> 0:19:17,991
即我们正在查找一个静态文本

345
00:19:18,058 --> 0:19:21,361
恰好是5586英里

346
00:19:22,095 --> 0:19:24,731
无论何时当你运行这个测试时

347
00:19:24,798 --> 0:19:27,935
你可能要假装或模拟你的位置

348
00:19:28,001 --> 0:19:29,303
正好位于San Jose

349
00:19:29,736 --> 0:19:33,006
否则距离会根据你的实际位置

350
00:19:34,274 --> 0:19:37,444
现在我们要返回到幻灯片中

351
00:19:37,511 --> 0:19:38,679
讲一下项目中的测试组织

352
00:19:49,156 --> 0:19:51,024
当开始编写测试类时

353
00:19:51,658 --> 0:19:53,527
你要从两个测试目标开始

354
00:19:53,994 --> 0:19:57,030
一般来说 一个用于单元测试

355
00:19:58,065 --> 0:20:01,235
单元测试和UI测试必须按类型分开

356
00:19:58,065 --> 0:20:01,235
单元测试和UI测试必须按类型分开

357
00:20:01,535 --> 0:20:04,471
因为它们在app上的执行方式不同

358
00:20:05,472 --> 0:20:06,840
每个测试类…

359
00:20:07,274 --> 0:20:09,943
测试目标将包含测试类

360
00:20:11,111 --> 0:20:15,182
你的测试目标可以拥有许多

361
00:20:16,750 --> 0:20:20,320
然后你的测试类包含每个测试用例

362
00:20:21,288 --> 0:20:23,557
同时你的单元测试目标

363
00:20:23,624 --> 0:20:25,993
和UI测试目标

364
00:20:27,127 --> 0:20:29,863
但有一些情况你需要更多的测试目标

365
00:20:30,731 --> 0:20:32,666
你的项目变得越来越复杂

366
00:20:33,133 --> 0:20:35,769
你可能想要一个新…

367
00:20:36,470 --> 0:20:40,040
这个框架应该有自己的单元测试目标

368
00:20:41,375 --> 0:20:45,679
此外 你用于在Xcode中创建

369
00:20:46,113 --> 0:20:47,514
已经定义了测试目标

370
00:20:48,448 --> 0:20:51,718
这些测试目标在Xcode中

371
00:20:51,785 --> 0:20:53,654
与任何其它单元测试目标的用法一样

372
00:20:55,122 --> 0:20:58,125
最后 一旦你对每个测试目标

373
00:20:58,192 --> 0:20:59,593
都重写了一个完整的测试

374
00:21:00,093 --> 0:21:03,964
你可能会考虑测试实际上是否

375
00:21:04,865 --> 0:21:06,667
为此你可以使用代码覆盖率

376
00:21:06,733 --> 0:21:07,701
（代码覆盖率）

377
00:21:07,768 --> 0:21:10,904
代码覆盖率是Xcode

378
00:21:11,305 --> 0:21:14,308
它会测量并显示在测试运行过程中

379
00:21:14,374 --> 0:21:18,145
每行源代码被执行的次数

380
00:21:19,680 --> 0:21:22,316
在启动这个功能并运行测试后

381
00:21:22,983 --> 0:21:26,386
你可以进入报告导航器并选择

382
00:21:26,453 --> 0:21:27,454
所运行测试的覆盖率数据

383
00:21:29,489 --> 0:21:33,393
你可以在那里看到一个列表

384
00:21:33,827 --> 0:21:37,798
以及表示该部分

385
00:21:37,865 --> 0:21:40,434
实际执行了多少源代码的百分比

386
00:21:41,435 --> 0:21:44,571
你可以选择每个测试类切换到文件

387
00:21:45,906 --> 0:21:48,108
当在源文件中打开覆盖率数据时

388
00:21:48,642 --> 0:21:50,477
源代码编辑器槽位于右侧

389
00:21:51,078 --> 0:21:55,282
显示当你运行测试时

390
00:21:55,349 --> 0:21:56,483
表示该行被执行了多少次的一个数字

391
00:21:57,451 --> 0:21:59,219
你还可以悬浮在数字上

392
00:21:59,486 --> 0:22:01,788
直接在源代码编辑器中查看信息

393
00:21:59,486 --> 0:22:01,788
直接在源代码编辑器中查看信息

394
00:22:03,257 --> 0:22:05,325
被执行了的代码行将变成绿色

395
00:22:06,293 --> 0:22:09,329
在测试过程中没有被击中的代码部分

396
00:22:10,464 --> 0:22:12,566
你还可以查看综合信息

397
00:22:12,900 --> 0:22:17,204
显示在测试过程中

398
00:22:17,571 --> 0:22:19,573
比如从未被选中的条件句

399
00:22:20,507 --> 0:22:21,909
代码覆盖率工具

400
00:22:21,975 --> 0:22:24,745
总的来说给你提供关于测试的

401
00:22:25,145 --> 0:22:28,749
可以帮助你识别你可能想为之编写

402
00:22:30,617 --> 0:22:32,753
当向版本库提交新工作时

403
00:22:33,187 --> 0:22:35,422
请包含代码以及对代码的测试

404
00:22:35,956 --> 0:22:38,258
确保一切都有品质保障

405
00:22:38,892 --> 0:22:42,529
并检查代码覆盖率

406
00:22:43,797 --> 0:22:46,400
如果你感觉测试没有完全覆盖

407
00:22:46,867 --> 0:22:49,636
可能是时候返回并编写更多的测试了

408
00:22:51,371 --> 0:22:54,608
你将通过提早编写测试来最大化地

409
00:22:55,342 --> 0:22:58,378
通过拥有与你的源代码配套的

410
00:22:58,946 --> 0:23:02,449
你可以确保你所编写的每个新功能

411
00:22:58,946 --> 0:23:02,449
你可以确保你所编写的每个新功能

412
00:23:02,516 --> 0:23:03,817
并且按预期的那样实现功能

413
00:23:04,718 --> 0:23:07,621
请记住 测试是一个持续的过程

414
00:23:07,955 --> 0:23:09,556
对于维持app的正常运行来说

415
00:23:10,524 --> 0:23:12,893
现在我要邀请Stuart上台来

416
00:23:13,260 --> 0:23:16,930
讲一下如何充分利用

417
00:23:26,507 --> 0:23:27,407
谢谢Ana

418
00:23:27,674 --> 0:23:30,544
现在你已经了解了Xcode中的

419
00:23:30,978 --> 0:23:34,548
我想讲一下Xcode 11中的

420
00:23:34,615 --> 0:23:36,583
它会帮助你最大限度地利用测试

421
00:23:38,785 --> 0:23:40,921
无论你是否刚开始编写测试

422
00:23:41,522 --> 0:23:44,458
或如果你的项目已经有一套很大

423
00:23:45,058 --> 0:23:46,860
我们要跟你们分享一个建议

424
00:23:46,927 --> 0:23:48,462
可以帮助你们最大限度地利用测试

425
00:23:49,363 --> 0:23:52,432
我们实际上推荐你们以不同方式

426
00:23:53,834 --> 0:23:55,702
现在即使你没有对测试进行任何修改

427
00:23:56,236 --> 0:23:59,406
如果你在测试选项中更多地利用

428
00:23:59,473 --> 0:24:00,874
及其高级功能

429
00:23:59,473 --> 0:24:00,874
及其高级功能

430
00:24:01,441 --> 0:24:04,111
你可以获得从测试中得到更多信息

431
00:24:05,179 --> 0:24:06,680
让我们一起来看一个例子

432
00:24:08,382 --> 0:24:10,384
假如我们一直在开发的app

433
00:24:10,651 --> 0:24:12,920
针对许多不同语种进行了本地化

434
00:24:13,954 --> 0:24:15,088
现在我们已经了解了

435
00:24:15,556 --> 0:24:17,591
如何给app编写UI测试

436
00:24:18,992 --> 0:24:20,294
现在一旦我们进行UI测试

437
00:24:21,061 --> 0:24:22,829
当我们以我们开发app的语言

438
00:24:22,896 --> 0:24:24,665
测试很有可能会成功

439
00:24:24,932 --> 0:24:26,266
在这个例子中是英语

440
00:24:27,668 --> 0:24:29,970
但想象一下有一天我们发现了一个

441
00:24:30,270 --> 0:24:32,539
只存在于特定语种之中

442
00:24:33,140 --> 0:24:35,609
那个语种的本地化字符串丢失了

443
00:24:36,443 --> 0:24:38,278
并使用了一个占位符字符串替代

444
00:24:38,345 --> 0:24:39,580
那就破坏了UI布局

445
00:24:40,948 --> 0:24:42,449
现在一旦我们意识到这个问题

446
00:24:42,916 --> 0:24:44,451
我们可以调整Xcode设置

447
00:24:44,785 --> 0:24:47,321
从而手动运行该语种的UI测试

448
00:24:47,821 --> 0:24:50,424
如果我们这样做了

449
00:24:51,391 --> 0:24:52,593
当然 如果我们没有那么做

450
00:24:52,659 --> 0:24:55,028
我们就有一个很好的机会

451
00:24:55,095 --> 0:24:58,098
用于重现问题和失败

452
00:24:59,566 --> 0:25:02,035
但一旦我们修复了那个问题

453
00:24:59,566 --> 0:25:02,035
但一旦我们修复了那个问题

454
00:25:02,636 --> 0:25:05,405
理想情况下 我们应该总能运行

455
00:25:05,772 --> 0:25:08,709
除我们开发app的语言之外

456
00:25:11,111 --> 0:25:12,579
这只是其中一个例子

457
00:25:12,646 --> 0:25:16,216
但还有其它情况

458
00:25:16,483 --> 0:25:19,486
运行测试时才可能捕捉到那些报错

459
00:25:20,821 --> 0:25:23,423
比如你可能选择按字母顺序

460
00:25:23,490 --> 0:25:25,459
和随机顺序运行测试

461
00:25:26,026 --> 0:25:27,895
因为按字母顺序运行测试

462
00:25:27,961 --> 0:25:31,131
对于查找测试方法之间

463
00:25:32,599 --> 0:25:35,435
或你可能想使用一个以上的

464
00:25:36,003 --> 0:25:39,106
比如Address Sanitizer

465
00:25:40,107 --> 0:25:41,942
如果你不熟悉的话

466
00:25:42,009 --> 0:25:42,943
我稍后会解释这些是什么东西

467
00:25:43,977 --> 0:25:47,014
或你甚至可以在每次测试时

468
00:25:47,381 --> 0:25:49,249
或环境变量

469
00:25:50,050 --> 0:25:52,085
如果测试时你要测试的代码

470
00:25:52,486 --> 0:25:55,355
需要修改或模拟特定的东西的话

471
00:25:55,422 --> 0:25:58,225
比如使用网络服务器的测试版

472
00:25:58,559 --> 0:25:59,893
或也许模拟数据集

473
00:26:02,062 --> 0:26:04,698
Xcode允许你配置各种选项

474
00:26:04,765 --> 0:26:07,067
关于app如何使用方案编辑器运行

475
00:26:08,302 --> 0:26:09,536
你可以访问参数

476
00:26:09,603 --> 0:26:11,605
选项或诊断标签

477
00:26:11,672 --> 0:26:14,308
从而控制如何启动app的各种东西

478
00:26:15,776 --> 0:26:18,312
但这只允许你使用你所选择的

479
00:26:18,378 --> 0:26:20,514
设置来交互性的运行一次app

480
00:26:21,882 --> 0:26:23,917
我们真正想要的并且我们一直在讲的

481
00:26:23,984 --> 0:26:26,453
是能多次运行测试的能力

482
00:26:27,354 --> 0:26:30,357
为此 我们在Xcode 11中

483
00:26:30,424 --> 0:26:31,491
叫做测试计划

484
00:26:31,558 --> 0:26:32,860
（测试计划）

485
00:26:32,926 --> 0:26:35,395
测试计划允许你以不同设置

486
00:26:35,462 --> 0:26:37,097
多次运行测试

487
00:26:38,599 --> 0:26:42,202
使用测试计划 你可以在一个地方

488
00:26:43,036 --> 0:26:45,072
然后你可以在多个方案中进行共享

489
00:26:46,340 --> 0:26:48,509
现在如果你之前复制了方案

490
00:26:48,909 --> 0:26:51,044
从而你可以多次运行测试

491
00:26:51,678 --> 0:26:53,080
你可能想撤销它

492
00:26:53,447 --> 0:26:56,950
并使用一个测试计划

493
00:26:58,552 --> 0:27:01,622
Xcode中以及xcodebuild中

494
00:26:58,552 --> 0:27:01,622
Xcode中以及xcodebuild中

495
00:27:01,922 --> 0:27:05,359
可以在持续集成服务器

496
00:27:06,326 --> 0:27:08,662
在现有项目中采用测试计划非常简单

497
00:27:09,897 --> 0:27:11,431
我们别一直讲这么多了

498
00:27:11,498 --> 0:27:13,867
让我们返回到演示项目中

499
00:27:17,704 --> 0:27:19,006
（演示

500
00:27:27,814 --> 0:27:28,649
好的

501
00:27:29,116 --> 0:27:30,884
返回到我一直在做的项目中

502
00:27:31,618 --> 0:27:33,053
我先给你展示一下测试计划

503
00:27:33,120 --> 0:27:35,656
点击我项目中的新测试计划文件

504
00:27:36,657 --> 0:27:39,126
在这里我可以看到

505
00:27:40,294 --> 0:27:41,962
我可以看到所有的测试

506
00:27:42,429 --> 0:27:44,064
首先是测试目标

507
00:27:44,998 --> 0:27:46,200
然后是测试类

508
00:27:46,767 --> 0:27:49,069
然后是每个类中所包含的

509
00:27:50,504 --> 0:27:52,639
现在使用这个视图

510
00:27:53,140 --> 0:27:55,542
我可以看到包含所有测试的完整列表

511
00:27:56,276 --> 0:27:58,078
或如果我想查找特定的测试

512
00:27:58,145 --> 0:27:59,880
我可以使用它…

513
00:28:01,114 --> 0:28:04,184
或如果我出于某种原因

514
00:28:04,818 --> 0:28:06,787
比如说 如果这个测试目前不起作用

515
00:28:06,854 --> 0:28:08,822
我只需要在已启用栏中

516
00:28:10,657 --> 0:28:13,193
我还可以修改与测试目标相关的设置

517
00:28:14,094 --> 0:28:15,596
点击右侧的选项按钮即可实现

518
00:28:17,197 --> 0:28:19,766
在这个例子中

519
00:28:20,167 --> 0:28:21,468
是我的UI测试目标

520
00:28:21,535 --> 0:28:24,304
并且它确实会受益于

521
00:28:24,371 --> 0:28:27,641
并行运行它的所有测试

522
00:28:28,141 --> 0:28:29,943
我要在这里启用它

523
00:28:31,879 --> 0:28:34,448
接下来我要进入测试计划的配置标签

524
00:28:35,349 --> 0:28:36,650
我可以在这里控制

525
00:28:36,917 --> 0:28:39,019
测试如何运行以及运行多少次

526
00:28:40,220 --> 0:28:43,056
左侧有一个列表 叫作测试配置列表

527
00:28:43,957 --> 0:28:46,560
顶部还有一个标签叫做共享设置

528
00:28:47,761 --> 0:28:50,430
我可以在共享设置中控制…

529
00:28:50,697 --> 0:28:52,900
测试运行中每次测试都通用的选项

530
00:28:54,268 --> 0:28:57,571
如果我们看一下

531
00:28:57,638 --> 0:28:58,805
我可以设置许多东西

532
00:29:00,007 --> 0:29:03,277
我可以修改不同参数

533
00:29:04,344 --> 0:29:06,346
我可以修改关于本地化的设置

534
00:29:07,481 --> 0:29:11,552
或改变UI测试截图要保存多长时间

535
00:29:12,719 --> 0:29:14,755
我可以修改测试执行顺序

536
00:29:15,189 --> 0:29:16,256
启用代码覆盖率

537
00:29:16,823 --> 0:29:20,260
或启动比如运行时间Sanitizer

538
00:29:22,062 --> 0:29:25,132
现在你可能注意到这里其中某些是

539
00:29:25,799 --> 0:29:27,367
比如环境变量这一行

540
00:29:28,268 --> 0:29:30,037
那表示我已经给定它一个自定义值

541
00:29:30,904 --> 0:29:33,640
在这里我提供了一个运行测试时的

542
00:29:35,008 --> 0:29:38,312
我把测试自定义为

543
00:29:38,846 --> 0:29:40,247
而不是按字母顺序

544
00:29:42,049 --> 0:29:45,586
在这个测试计划中

545
00:29:45,652 --> 0:29:48,488
使它像我刚才提供的例子那样运行

546
00:29:48,922 --> 0:29:51,191
从而它会使用不同语种运行两次

547
00:29:52,426 --> 0:29:54,561
我可以通过添加第二个配置实现

548
00:29:55,529 --> 0:29:57,064
因为我要以不同语种运行它

549
00:29:57,130 --> 0:29:59,733
我要给我所要使用的语言提供一个

550
00:30:01,535 --> 0:30:03,904
既然到这儿了

551
00:30:04,304 --> 0:30:05,672
自定义为美语

552
00:30:07,541 --> 0:30:09,543
在美语配置中

553
00:30:09,943 --> 0:30:11,411
我实际上不修改任何东西

554
00:30:11,478 --> 0:30:14,214
它拥有所有默认值外加共享设置

555
00:30:15,282 --> 0:30:16,917
但在德语配置中

556
00:30:16,984 --> 0:30:20,754
我要自定义语种和地区

557
00:30:23,924 --> 0:30:26,460
我想指出因为我刚才编辑了

558
00:30:26,760 --> 0:30:28,161
配置

559
00:30:29,029 --> 0:30:30,030
在弹出菜单中

560
00:30:30,097 --> 0:30:33,600
我在顶部看到了一个额外的标签

561
00:30:34,568 --> 0:30:37,871
这个标签表示

562
00:30:37,938 --> 0:30:39,473
它要从测试计划的共享设置层级

563
00:30:40,174 --> 0:30:42,209
因此如果我想恢复这个自定义

564
00:30:42,276 --> 0:30:43,944
并返回到它所继承的值

565
00:30:44,011 --> 0:30:45,012
我只需要选中这个即可

566
00:30:47,181 --> 0:30:49,049
好的 现在我按我的意愿

567
00:30:49,116 --> 0:30:49,983
配置好了测试计划

568
00:30:50,317 --> 0:30:52,753
接下来我要介绍

569
00:30:52,819 --> 0:30:54,021
使用测试计划的几种方式

570
00:30:56,023 --> 0:30:58,258
我要进入我一直在做的一个事件…

571
00:30:58,325 --> 0:31:00,360
一个单元测试文件

572
00:30:58,325 --> 0:31:00,360
一个单元测试文件

573
00:31:00,694 --> 0:31:02,462
它测试我app中的事件结构

574
00:31:03,697 --> 0:31:06,400
它只对结构进行几次小的单元测试

575
00:31:07,601 --> 0:31:12,306
如果我点击这个测试文件中的

576
00:31:13,106 --> 0:31:15,742
因为我已经给测试计划

577
00:31:16,376 --> 0:31:18,579
那将总共运行两次测试

578
00:31:19,513 --> 0:31:22,549
如果我想运行所有测试的话

579
00:31:22,616 --> 0:31:25,719
特别是在我的持续继承服务器上

580
00:31:26,553 --> 0:31:28,255
但当我开发测试时

581
00:31:28,322 --> 0:31:30,457
我可能不运行…不运行这么多次

582
00:31:31,258 --> 0:31:33,994
因此我可以选择只运行一个配置

583
00:31:34,328 --> 0:31:36,230
通过选择点击测试菱形即可实现

584
00:31:36,530 --> 0:31:39,766
在这里我看到一个菜单只有…

585
00:31:41,802 --> 0:31:43,003
我可以…是的 谢谢

586
00:31:46,607 --> 0:31:48,742
我还可以在测试导航器中实现

587
00:31:49,409 --> 0:31:52,179
如果我在测试导航器中控制点击

588
00:31:52,446 --> 0:31:56,884
我可以看到一个类似的菜单 可让我

589
00:31:58,685 --> 0:32:00,654
既然到这儿了 我还想提一下

590
00:31:58,685 --> 0:32:00,654
既然到这儿了 我还想提一下

591
00:32:00,721 --> 0:32:03,090
测试导航器现在显示…

592
00:32:03,156 --> 0:32:05,893
当前哪个测试计划是活跃的

593
00:32:06,593 --> 0:32:08,795
我的方案中只有一个测试计划

594
00:32:09,196 --> 0:32:10,430
但你可以有许多测试计划

595
00:32:10,497 --> 0:32:12,900
我们稍后再讲

596
00:32:14,902 --> 0:32:17,404
好的 现在我只想运行

597
00:32:17,471 --> 0:32:18,772
全部配置的单元测试

598
00:32:20,207 --> 0:32:23,343
现在我们看到Xcode快速创建了

599
00:32:23,877 --> 0:32:26,680
然后在模拟器中两次运行我的测试

600
00:32:27,548 --> 0:32:28,515
已经完成了

601
00:32:29,383 --> 0:32:31,752
看起来至少存在一个问题

602
00:32:32,286 --> 0:32:34,021
让我们去看看具体信息

603
00:32:35,389 --> 0:32:37,691
我可以通过点击报告导航器

604
00:32:38,792 --> 0:32:40,527
并进入最新测试动作查看测试详情

605
00:32:41,828 --> 0:32:45,732
在这里我们可以看到大部分测试

606
00:32:46,166 --> 0:32:47,434
因此它们有绿色对勾标记…

607
00:32:48,702 --> 0:32:51,672
其中一个测试出现了某种问题

608
00:32:51,738 --> 0:32:53,674
它有一个红色图标 图标上有横杠

609
00:32:54,942 --> 0:32:57,544
测试报告给我显示了所有详情

610
00:32:57,611 --> 0:33:00,113
关于测试会话中发生的一切

611
00:32:57,611 --> 0:33:00,113
关于测试会话中发生的一切

612
00:33:00,614 --> 0:33:02,216
如果我展开这个 我可以看到…

613
00:33:03,083 --> 0:33:06,119
看起来这个测试方法

614
00:33:06,186 --> 0:33:07,254
而在另一个配置中失败了

615
00:33:08,422 --> 0:33:09,389
如果我进一步打开它

616
00:33:09,456 --> 0:33:10,824
我可以看到具体问题

617
00:33:11,658 --> 0:33:12,693
看起来这个测试方法

618
00:33:13,293 --> 0:33:15,896
接收了英语文本

619
00:33:16,797 --> 0:33:19,633
看起来这是个问题

620
00:33:19,700 --> 0:33:22,903
app代码或测试中

621
00:33:23,971 --> 0:33:24,805
在我完成之前

622
00:33:25,072 --> 0:33:28,175
我想讲一下我们对这里的测试报告

623
00:33:29,042 --> 0:33:31,812
如果我只想查看在两个配置中

624
00:33:32,145 --> 0:33:35,215
拥有混合状态的测试方法 比如这个

625
00:33:35,682 --> 0:33:39,019
我只需要点击

626
00:33:40,721 --> 0:33:44,825
或如果我只想查看特定配置中的结果

627
00:33:45,292 --> 0:33:47,861
我只需要点击测试配置弹出框

628
00:33:48,295 --> 0:33:49,730
并选择其中一个配置即可

629
00:33:53,867 --> 0:33:56,236
好的

630
00:33:56,537 --> 0:33:57,938
现在让我们返回到幻灯片中

631
00:34:07,281 --> 0:34:09,416
现在你已经实际了解了测试计划

632
00:34:09,716 --> 0:34:11,618
我想提一下关于测试计划

633
00:34:13,020 --> 0:34:15,589
测试计划文件实际上就是个

634
00:34:16,023 --> 0:34:18,158
以.xctestplan

635
00:34:19,359 --> 0:34:21,328
它包含你要运行的所有测试

636
00:34:21,862 --> 0:34:25,699
以及描述测试如何运行的

637
00:34:27,367 --> 0:34:30,170
测试计划文件包含在你的常规项目

638
00:34:30,704 --> 0:34:32,940
并且它可以被一个或多个方案引用

639
00:34:36,976 --> 0:34:38,911
现在测试配置

640
00:34:38,978 --> 0:34:41,949
还描述整个测试计划的测试的

641
00:34:43,183 --> 0:34:46,053
每个测试配置都有一个

642
00:34:46,652 --> 0:34:49,356
给项目中的每个测试配置

643
00:34:49,422 --> 0:34:50,891
都命名一个有意义的名称

644
00:34:51,358 --> 0:34:54,460
因为我们将在比如我们之前看到过的

645
00:34:55,094 --> 0:34:56,463
和测试报告这样的地方看到那个名称

646
00:34:58,398 --> 0:35:00,934
现在每个测试配置都包含

647
00:34:58,398 --> 0:35:00,934
现在每个测试配置都包含

648
00:35:01,001 --> 0:35:02,769
关于如何创建并运行测试的所有选项

649
00:35:03,670 --> 0:35:06,006
它们可以从测试计划的共享设置层级

650
00:35:06,073 --> 0:35:07,808
继承任意通用选项

651
00:35:08,542 --> 0:35:10,577
因此如果任何设置

652
00:35:10,644 --> 0:35:11,812
在每次运行测试时设置都相同

653
00:35:12,112 --> 0:35:14,648
你可以在一个地方定义它们

654
00:35:17,518 --> 0:35:18,385
因此如果你好奇的话

655
00:35:18,452 --> 0:35:20,888
这是你可以在每个测试配置上

656
00:35:20,954 --> 0:35:22,389
进行设置的所有选项的完整列表

657
00:35:23,490 --> 0:35:24,458
你可以从我刚才所展示的

658
00:35:24,525 --> 0:35:27,327
测试计划编辑器的配置标签中

659
00:35:29,630 --> 0:35:30,697
那么你可能在想

660
00:35:30,964 --> 0:35:32,399
我要如何开始使用测试计划呢

661
00:35:33,834 --> 0:35:34,968
如果你有现有项目

662
00:35:35,035 --> 0:35:36,203
你首先需要把它转换为…

663
00:35:36,837 --> 0:35:38,572
把方案转换为使用测试计划

664
00:35:39,640 --> 0:35:41,642
为此 首先要编辑方案

665
00:35:43,577 --> 0:35:45,445
然后进入方案测试动作

666
00:35:47,147 --> 0:35:49,883
在那里你可以看到一个按钮是

667
00:35:51,518 --> 0:35:53,053
点击这个按钮将显示一个表单

668
00:35:53,487 --> 0:35:55,856
提供你可以转换方案的不同方式

669
00:35:57,758 --> 0:36:00,294
第一个选项是从方案的现有设置中

670
00:35:57,758 --> 0:36:00,294
第一个选项是从方案的现有设置中

671
00:36:00,661 --> 0:36:02,296
创建一个全新的测试计划文件

672
00:36:03,397 --> 0:36:05,732
如果这是你要转换的第一个

673
00:36:05,999 --> 0:36:07,234
你很可能会选择这个方式

674
00:36:09,069 --> 0:36:11,772
但另一个选项是选择项目中的

675
00:36:13,040 --> 0:36:14,074
如果你选择这个

676
00:36:14,141 --> 0:36:16,743
它会给你显示一个表单

677
00:36:16,810 --> 0:36:17,811
选择一个现有测试计划

678
00:36:18,579 --> 0:36:22,449
如果你正在转换的方案…

679
00:36:22,816 --> 0:36:25,085
如果你已经把一个方案转换为

680
00:36:25,152 --> 0:36:27,588
并且你想以不同方案分享同一个计划

681
00:36:28,722 --> 0:36:31,325
且如果你已经从零开始创建了一个

682
00:36:34,428 --> 0:36:36,797
好的现在我们已经了解了

683
00:36:37,231 --> 0:36:38,632
并且你已经了解如何开始使用

684
00:36:39,132 --> 0:36:40,868
我想提供一些你可以在自己的项目中

685
00:36:40,934 --> 0:36:42,736
使用测试计划的潜在方式

686
00:36:44,838 --> 0:36:47,174
这是一个你可以创建的测试计划的

687
00:36:47,241 --> 0:36:48,609
（潜在用例）

688
00:36:48,675 --> 0:36:51,578
每个红色方框代表计划中的一个配置

689
00:36:52,546 --> 0:36:54,681
第一个启用了

690
00:36:55,048 --> 0:36:56,416
另一个启用了

691
00:36:57,551 --> 0:36:59,052
现在如果你不熟悉这些的话

692
00:36:59,119 --> 0:37:01,221
Sanitizer

693
00:36:59,119 --> 0:37:01,221
Sanitizer

694
00:37:01,688 --> 0:37:02,823
用于输入你的代码

695
00:37:02,890 --> 0:37:05,792
并帮助你识别手动难以重现的错误

696
00:37:06,827 --> 0:37:08,729
有些sanitizer

697
00:37:09,129 --> 0:37:10,430
可以合并使用

698
00:37:10,898 --> 0:37:13,333
如果你以这样的方式构造测试计划

699
00:37:13,734 --> 0:37:16,670
你仍可用这两个sanitizer

700
00:37:19,373 --> 0:37:21,475
要从这个测试计划中获得更多价值

701
00:37:22,075 --> 0:37:24,411
如果你的项目包含C

702
00:37:25,112 --> 0:37:28,148
你还可以通过在每个配置中

703
00:37:28,215 --> 0:37:29,650
启用未定义的Behavior Sanitizer

704
00:37:31,251 --> 0:37:34,421
你可能注意到未定义的

705
00:37:34,488 --> 0:37:35,622
在两个地方进行了设置

706
00:37:36,056 --> 0:37:37,824
它在每个配置中进行了重复设置

707
00:37:39,927 --> 0:37:41,628
把这个设置向上移到

708
00:37:41,695 --> 0:37:43,931
计划的共享设置层级更好

709
00:37:44,932 --> 0:37:46,967
然后计划中的每个配置

710
00:37:47,034 --> 0:37:48,836
将自动继承这个设置

711
00:37:50,537 --> 0:37:53,674
现在有一件事要注意

712
00:37:53,740 --> 0:37:55,876
带有手动不兼容sanitizer

713
00:37:56,710 --> 0:37:59,213
如果你运行计划中的两个配置

714
00:37:59,947 --> 0:38:03,350
Xcode需要创建两次项目

715
00:37:59,947 --> 0:38:03,350
Xcode需要创建两次项目

716
00:38:04,718 --> 0:38:07,087
这对于持续继承环境来说很棒

717
00:38:07,521 --> 0:38:10,390
你不用担心需要较长时间来创建测试

718
00:38:10,691 --> 0:38:12,593
因为它们执行的是更彻底的测试

719
00:38:15,462 --> 0:38:18,165
但测试计划并不只是选择不同的

720
00:38:18,932 --> 0:38:20,267
正如我在之前的演示中所展示的那样

721
00:38:20,334 --> 0:38:22,636
你还可以配置附带配置的计划

722
00:38:22,703 --> 0:38:24,872
配置可以代表不同的语种或区域

723
00:38:25,739 --> 0:38:29,042
比如我在这里选择了美国、韩国

724
00:38:29,710 --> 0:38:32,079
并没有可以拥有多少配置的限制

725
00:38:34,147 --> 0:38:35,582
现在如果你配置了一个像这样的计划

726
00:38:36,183 --> 0:38:37,751
你可以用它来运行你的UI测试

727
00:38:38,352 --> 0:38:40,754
然后你可以从这些测试中收集截图

728
00:38:41,221 --> 0:38:44,525
通过在共享设置中启用新的

729
00:38:45,959 --> 0:38:48,629
本地化截图时

730
00:38:49,029 --> 0:38:52,466
可以让你的UI测试保存所有截图

731
00:38:53,033 --> 0:38:54,201
甚至还会保存测试成功的测试的截图

732
00:38:55,369 --> 0:38:57,971
它会收集关于你app所使用的

733
00:38:59,540 --> 0:39:02,009
这就可以让你引用截图作为情境

734
00:38:59,540 --> 0:39:02,009
这就可以让你引用截图作为情境

735
00:39:02,075 --> 0:39:05,679
当你本地化app时

736
00:39:05,946 --> 0:39:08,515
你可以在App Store中列出

737
00:39:15,689 --> 0:39:16,890
要获取更多此类信息

738
00:39:16,957 --> 0:39:18,725
以及其它本地化改进

739
00:39:19,293 --> 0:39:20,761
请在WWDC网站上查看我们的…

740
00:39:20,827 --> 0:39:24,298
创建优秀的本地化体验演讲

741
00:39:26,800 --> 0:39:28,268
最后我想强调一下

742
00:39:28,335 --> 0:39:30,571
你可以在一个测试计划中混合并匹配

743
00:39:30,637 --> 0:39:32,372
只要对你的项目有意义就可以

744
00:39:33,507 --> 0:39:35,509
比如你可以以三种截然不同的配置

745
00:39:35,576 --> 0:39:38,378
构造这样一个测试计划

746
00:39:39,880 --> 0:39:41,815
第一个配置主要关注内存安全性

747
00:39:42,216 --> 0:39:43,851
因此它有

748
00:39:44,218 --> 0:39:45,853
以及Zombie Objects

749
00:39:47,754 --> 0:39:49,857
第二个配置是关于并发性

750
00:39:50,224 --> 0:39:53,794
它有Thread Sanitizer

751
00:39:54,361 --> 0:39:56,463
并且它每次都以随机顺序运行测试

752
00:39:58,432 --> 0:40:01,535
然后最后一个配置是当运行测试时

753
00:39:58,432 --> 0:40:01,535
然后最后一个配置是当运行测试时

754
00:40:01,602 --> 0:40:02,603
收集额外的诊断

755
00:40:03,270 --> 0:40:05,539
它通过给被测试的代码

756
00:40:05,839 --> 0:40:07,875
设置自定义环境变量实现

757
00:40:07,941 --> 0:40:09,643
从而可以出发更多的日志采集

758
00:40:10,644 --> 0:40:12,880
它还会启用

759
00:40:12,946 --> 0:40:15,749
甚至会保留测试成功的测试的

760
00:40:17,551 --> 0:40:20,354
这是一个非常复杂的例子

761
00:40:20,420 --> 0:40:22,289
测试计划的能力和灵活性

762
00:40:22,356 --> 0:40:23,891
你可以按照你的意愿来运行测试

763
00:40:26,560 --> 0:40:29,363
那么这就是测试计划

764
00:40:29,429 --> 0:40:31,265
通过以不同方式多次运行测试

765
00:40:31,665 --> 0:40:33,534
可以让你最大限度地利用测试

766
00:40:34,468 --> 0:40:35,802
现在我要把舞台交给Ethan

767
00:40:35,869 --> 0:40:38,272
他会分享使用Xcode

768
00:40:38,705 --> 0:40:39,540
谢谢

769
00:40:42,776 --> 0:40:44,444
（持续集成流程）

770
00:40:46,013 --> 0:40:46,847
谢谢Stuart

771
00:40:47,381 --> 0:40:49,383
要利用测试计划的全部能量

772
00:40:49,683 --> 0:40:52,920
你很可能想在许多不同配置下

773
00:40:53,720 --> 0:40:56,290
有一个很不错的地方可以实现

774
00:40:56,557 --> 0:40:59,493
这会自动化创建和运行测试的过程

775
00:41:00,227 --> 0:41:01,228
当你坐在办公桌前

776
00:41:01,295 --> 0:41:03,630
你主要关注的是让测试成功

777
00:41:04,131 --> 0:41:07,968
持续集成会在所有设备上

778
00:41:08,335 --> 0:41:09,570
为你提供最大程度的覆盖率

779
00:41:10,637 --> 0:41:12,873
Xcode的持续集成

780
00:41:12,940 --> 0:41:15,142
有两个主要的可选方案

781
00:41:15,976 --> 0:41:19,446
第一个方案是Xcode服务器

782
00:41:20,414 --> 0:41:22,916
通过Xcode服务器

783
00:41:22,983 --> 0:41:25,419
使用最少量的配置创建并测试app

784
00:41:26,787 --> 0:41:30,057
第二个选项是创建你自己的

785
00:41:31,058 --> 0:41:32,092
这个选项更高级一些

786
00:41:32,159 --> 0:41:35,162
如果你有自定义需求

787
00:41:35,229 --> 0:41:37,397
或需要与现有基础结构进行集成的话

788
00:41:38,599 --> 0:41:40,367
如果你确实需要进行自定义设置

789
00:41:40,667 --> 0:41:41,602
你是幸运的

790
00:41:41,869 --> 0:41:45,606
Xcode配备强大的工具

791
00:41:47,875 --> 0:41:49,109
在这个部分中

792
00:41:49,176 --> 0:41:50,911
我们主要讲第二种方案

793
00:41:51,245 --> 0:41:54,548
并了解如何创建一个完全自定义的

794
00:41:55,883 --> 0:41:58,685
端对端 我们的管道由四个步骤组成

795
00:41:59,086 --> 0:42:01,388
每一步都包含不同工具的使用

796
00:41:59,086 --> 0:42:01,388
每一步都包含不同工具的使用

797
00:42:02,823 --> 0:42:04,124
第一步

798
00:42:04,591 --> 0:42:07,294
我们要在专用的创建器机器上

799
00:42:09,429 --> 0:42:10,531
第二步

800
00:42:10,597 --> 0:42:14,401
我们要在一套设备上执行

801
00:42:15,602 --> 0:42:18,071
这些设备将与第二台机器相连接

802
00:42:18,138 --> 0:42:20,007
我们留出第二台机器用于运行测试

803
00:42:21,675 --> 0:42:24,978
前两个步骤将生成一些创建

804
00:42:25,946 --> 0:42:29,416
这些结果将作为下两个步骤的数据源

805
00:42:31,552 --> 0:42:34,988
第三步 我们主要关注

806
00:42:35,389 --> 0:42:37,524
从而填充我们最喜欢的问题追踪器

807
00:42:39,560 --> 0:42:41,295
最后第四步

808
00:42:41,662 --> 0:42:43,330
我们要随时间追踪我们的代码覆盖率

809
00:42:43,630 --> 0:42:47,000
从而了解我们在整体测试覆盖率方面

810
00:42:50,070 --> 0:42:52,139
让我们从前两个步骤开始

811
00:42:52,206 --> 0:42:53,774
创建并运行测试

812
00:42:55,409 --> 0:42:57,578
对于这些任务

813
00:42:58,278 --> 0:43:00,914
Xcodebuild是

814
00:42:58,278 --> 0:43:00,914
Xcodebuild是

815
00:43:01,248 --> 0:43:02,950
它是整个流程的核心力量

816
00:43:03,951 --> 0:43:06,720
在xcodebuild背后是

817
00:43:07,020 --> 0:43:08,989
和XCTest

818
00:43:10,958 --> 0:43:13,627
通过xcodebuild

819
00:43:14,328 --> 0:43:17,064
第一种是在同一个调用中创建并测试

820
00:43:18,165 --> 0:43:19,900
为此你要使用测试动作

821
00:43:20,334 --> 0:43:22,936
传入你要测试的项目的名称和方案

822
00:43:23,403 --> 0:43:26,039
以及测试运行的目的地

823
00:43:26,106 --> 0:43:27,708
（用XCODEBUILD

824
00:43:28,542 --> 0:43:30,511
第二种是创建然后测试

825
00:43:31,078 --> 0:43:33,213
这会在xcodebuild的

826
00:43:33,280 --> 0:43:35,582
实施创建和测试动作

827
00:43:36,683 --> 0:43:39,319
这个功能的一个很重要的用例是

828
00:43:39,386 --> 0:43:41,588
让一台机器专用于创建

829
00:43:41,889 --> 0:43:43,957
另一台机器专用于运行测试

830
00:43:44,024 --> 0:43:45,792
这是我们尝试要实现的流程

831
00:43:47,127 --> 0:43:50,330
要实现这个流程

832
00:43:50,764 --> 0:43:52,766
并传入与之前一样的参数

833
00:43:53,901 --> 0:43:57,337
这既会产生用于测试的创建产品

834
00:43:57,771 --> 0:43:59,506
还会产生一个

835
00:44:00,474 --> 0:44:02,609
Xctestrun文件是一个清单

836
00:44:02,676 --> 0:44:04,111
描述创建产品

837
00:44:04,511 --> 0:44:07,014
并说明xctestrun

838
00:44:09,216 --> 0:44:11,652
接下来 不通过创建动作调用测试

839
00:44:12,119 --> 0:44:14,755
传入之前生成的

840
00:44:16,123 --> 0:44:18,091
这将会实际上执行测试

841
00:44:20,627 --> 0:44:23,664
实际上你可以构建自己的

842
00:44:24,097 --> 0:44:27,134
可以让你更容易控制在测试过程中

843
00:44:28,302 --> 0:44:30,838
如果你想了解更多

844
00:44:30,904 --> 0:44:32,039
请查看主页

845
00:44:33,073 --> 0:44:36,043
同时请注意 Xcode版本不同

846
00:44:36,844 --> 0:44:39,279
一般来说 请使用

847
00:44:39,346 --> 0:44:41,415
来创建和运行测试

848
00:44:43,917 --> 0:44:44,918
提到运行测试

849
00:44:45,385 --> 0:44:46,987
xcodebuild支持同时

850
00:44:47,054 --> 0:44:49,823
在多台设备或模拟器上运行测试

851
00:44:50,824 --> 0:44:55,028
这可以最大范围的覆盖各种设备类型

852
00:44:56,196 --> 0:44:58,498
这对于UI测试来说尤其有用

853
00:44:58,899 --> 0:45:01,635
因为app的UI很可能

854
00:44:58,899 --> 0:45:01,635
因为app的UI很可能

855
00:45:03,270 --> 0:45:04,471
如果你想了解更多

856
00:45:04,538 --> 0:45:07,074
关于xcodebuild

857
00:45:07,508 --> 0:45:10,477
请查看2018年的

858
00:45:13,280 --> 0:45:15,549
目前我们已经讲了

859
00:45:15,616 --> 0:45:16,917
以及如何创建并运行测试

860
00:45:17,384 --> 0:45:20,787
现在我想讲一下

861
00:45:22,489 --> 0:45:24,691
如果你有一个方案是有多个测试计划

862
00:45:24,758 --> 0:45:27,761
你可以使用显示测试计划选项

863
00:45:29,630 --> 0:45:31,632
如果你有一个方案有多个测试计划

864
00:45:31,698 --> 0:45:33,200
可以开启一些引人注目的流程

865
00:45:33,867 --> 0:45:36,170
比如你可以有一个

866
00:45:36,236 --> 0:45:38,038
包含一整套测试

867
00:45:38,405 --> 0:45:41,275
以及一个运行时间短的测试计划

868
00:45:42,276 --> 0:45:43,911
如果你选择有多个测试计划

869
00:45:44,278 --> 0:45:46,580
其中一个测试计划将被作为

870
00:45:46,914 --> 0:45:49,683
你可以给它配置

871
00:45:50,584 --> 0:45:53,120
默认计划是xcodebuild

872
00:45:53,187 --> 0:45:54,521
除非你另有说明

873
00:45:56,957 --> 0:45:59,159
要覆盖默认的测试计划

874
00:45:59,226 --> 0:46:00,727
可以使用测试计划选项

875
00:45:59,226 --> 0:46:00,727
可以使用测试计划选项

876
00:46:01,161 --> 0:46:04,031
传入你想要运行的计划的名称

877
00:46:07,301 --> 0:46:09,469
通过以上这些

878
00:46:09,837 --> 0:46:11,939
我们可以开始在我们的管道中填写

879
00:46:13,540 --> 0:46:15,108
从创建器机器开始

880
00:46:15,375 --> 0:46:17,711
我们使用xcodebuild

881
00:46:17,778 --> 0:46:20,747
来产生我们所需要的build产品

882
00:46:22,149 --> 0:46:24,084
这将被传到运行器机器上

883
00:46:24,451 --> 0:46:26,820
运行器机器将调用xcodebuild

884
00:46:27,187 --> 0:46:29,389
在我们的设备上执行测试

885
00:46:32,426 --> 0:46:34,862
这两个步骤产生

886
00:46:35,562 --> 0:46:37,397
这是我接下来要讲的内容

887
00:46:38,832 --> 0:46:40,033
即结果捆绑包

888
00:46:40,767 --> 0:46:42,669
今年关于结果捆绑包

889
00:46:42,736 --> 0:46:43,804
我们有一些很棒的东西要与你们分享

890
00:46:43,871 --> 0:46:45,105
（结果捆绑包）

891
00:46:45,806 --> 0:46:48,075
首先 什么是结果捆绑包？

892
00:46:49,042 --> 0:46:51,378
结果捆绑包是由Xcode

893
00:46:51,712 --> 0:46:53,113
包含结构化数据

894
00:46:53,180 --> 0:46:55,616
描述创建和运行测试的结果

895
00:46:56,650 --> 0:46:58,785
它包含资产比如创建日志

896
00:46:59,186 --> 0:47:01,688
显示编译了哪些目标和源文件

897
00:46:59,186 --> 0:47:01,688
显示编译了哪些目标和源文件

898
00:47:03,223 --> 0:47:05,959
测试报告显示哪些测试通过了

899
00:47:07,828 --> 0:47:10,130
代码覆盖率报告显示所运行的测试

900
00:47:10,197 --> 0:47:11,532
覆盖了哪些代码

901
00:47:13,300 --> 0:47:16,170
以及由测试使用

902
00:47:16,470 --> 0:47:18,472
所创建的所有测试附件

903
00:47:21,141 --> 0:47:22,576
要如何生成结果捆绑包呢？

904
00:47:23,343 --> 0:47:26,180
只需要给xcodebuild传递

905
00:47:29,149 --> 0:47:31,084
现在我们知道如何生成结果捆绑包了

906
00:47:31,385 --> 0:47:33,320
我们还可以填充另一个遗漏的东西

907
00:47:34,421 --> 0:47:37,925
我们要给Xcode创建调用

908
00:47:38,525 --> 0:47:40,327
从而开始生成这些创建和测试结果

909
00:47:43,397 --> 0:47:45,365
结果捆绑包已经存在一段时间了

910
00:47:45,732 --> 0:47:49,369
但在Xcode 11中 我们彻底

911
00:47:49,436 --> 0:47:50,637
这带来了一些好处

912
00:47:52,139 --> 0:47:55,742
首先 新格式经过高度优化

913
00:47:56,577 --> 0:47:59,613
在我们自己的测试中

914
00:47:59,680 --> 0:48:01,682
与之前的格式相比平均缩小了四倍

915
00:47:59,680 --> 0:48:01,682
与之前的格式相比平均缩小了四倍

916
00:48:02,716 --> 0:48:04,918
这在持续集成中尤其有用

917
00:48:05,385 --> 0:48:08,288
在持续集成中 结果捆绑包可以

918
00:48:10,457 --> 0:48:13,927
第二 现在可以直接在Xcode中

919
00:48:14,361 --> 0:48:16,930
这就可以让你轻松地深入查看

920
00:48:19,132 --> 0:48:21,468
第三 我们第一次提供一种

921
00:48:21,535 --> 0:48:23,937
以编程方式访问结果捆绑包的

922
00:48:24,438 --> 0:48:27,241
我们可以在自己的持续集成设置中

923
00:48:29,843 --> 0:48:31,411
要在Xcode中打开结果捆绑包

924
00:48:31,778 --> 0:48:33,180
双击文件

925
00:48:33,247 --> 0:48:36,116
即可使用你已经很熟悉的UI

926
00:48:37,084 --> 0:48:39,386
请看测试报告中失败和成功的测试

927
00:48:39,920 --> 0:48:41,555
在创建日志中深入了解创建失败

928
00:48:42,155 --> 0:48:44,658
并在代码覆盖率报告中了解

929
00:48:51,465 --> 0:48:52,299
谢谢

930
00:48:53,133 --> 0:48:55,335
要以编程方式访问结果捆绑包的内容

931
00:48:55,669 --> 0:48:59,006
你可使用Xcode 11的新命令行工具

932
00:49:00,674 --> 0:49:03,677
Xcresulttool

933
00:49:03,744 --> 0:49:04,978
所含结构数据的完全权限

934
00:49:06,246 --> 0:49:07,848
它把这个数据作为JSON提交

935
00:49:08,148 --> 0:49:10,984
而JSON的格式已经被公开记录

936
00:49:13,187 --> 0:49:15,756
我们要在下一步中

937
00:49:16,156 --> 0:49:19,159
给问题追踪器填充

938
00:49:19,226 --> 0:49:20,260
在创建和测试过程中所发生的

939
00:49:22,696 --> 0:49:24,164
要提取创建失败

940
00:49:24,731 --> 0:49:27,100
使用get命令调用

941
00:49:27,634 --> 0:49:29,236
传入ResultBundle路径

942
00:49:30,771 --> 0:49:32,339
在接下来的JSON输出中

943
00:49:33,006 --> 0:49:35,943
你可以发现创建失败嵌套在

944
00:49:37,311 --> 0:49:39,780
每个创建失败都包含失败信息

945
00:49:40,147 --> 0:49:42,716
以及源文件和创建失败的行编号

946
00:49:42,783 --> 0:49:44,384
（提取创建失败和测试失败）

947
00:49:45,185 --> 0:49:47,588
测试失败也嵌套在JSON内

948
00:49:48,088 --> 0:49:49,790
其中包含失败的测试的名称

949
00:49:49,857 --> 0:49:51,291
以及断言信息

950
00:49:54,761 --> 0:49:56,830
如果你没有100%按这些步骤进行

951
00:49:57,297 --> 0:49:58,599
就像我之前提到的那样

952
00:49:58,665 --> 0:50:00,334
xcresulttool的

953
00:49:58,665 --> 0:50:00,334
xcresulttool的

954
00:50:00,400 --> 0:50:03,136
它生成的JSON是公开记录的

955
00:50:03,904 --> 0:50:07,140
事实上 工具自身可以使用格式

956
00:50:07,441 --> 0:50:09,042
描述JSON的架构

957
00:50:10,210 --> 0:50:12,646
架构列出了可以在输出中呈现的

958
00:50:12,713 --> 0:50:14,114
所有可能的对象类型

959
00:50:14,581 --> 0:50:17,351
因此我鼓励你们当你们编写自己的

960
00:50:17,618 --> 0:50:18,619
参考一下这个列表

961
00:50:20,888 --> 0:50:21,855
最后但并不是最不重要的

962
00:50:21,922 --> 0:50:24,157
请查看工具的主页获取更多信息

963
00:50:26,860 --> 0:50:28,729
通过我们新开发的

964
00:50:28,795 --> 0:50:30,264
我们现在可以进入第三步了

965
00:50:31,164 --> 0:50:34,735
我们要用xcresulttool

966
00:50:34,801 --> 0:50:37,004
提取那些创建失败和测试失败

967
00:50:40,007 --> 0:50:41,408
目前我们已经做了很多操作了

968
00:50:41,475 --> 0:50:43,210
但我们还有最后一个步骤要完成

969
00:50:43,877 --> 0:50:45,646
我们想随时间追踪我们的代码覆盖率

970
00:50:45,712 --> 0:50:47,014
用于了解覆盖率是否有所下降

971
00:50:48,849 --> 0:50:51,785
为此 我们要使用另一个命令行工具

972
00:50:53,020 --> 0:50:56,056
Xccov可以让你以编程方式

973
00:50:56,123 --> 0:50:58,058
可以是人可读的文本或JSON

974
00:50:59,359 --> 0:51:01,295
要使用xccov浏览覆盖率报告

975
00:50:59,359 --> 0:51:01,295
要使用xccov浏览覆盖率报告

976
00:51:01,361 --> 0:51:03,931
就要调用浏览命令

977
00:51:03,997 --> 0:51:05,132
（用XCCOV

978
00:51:05,599 --> 0:51:06,834
在随后的输出中

979
00:51:06,900 --> 0:51:09,303
你可以看到每个目标的行覆盖率

980
00:51:09,970 --> 0:51:13,040
源文件和项目中的函数或方法

981
00:51:15,342 --> 0:51:17,277
现在简单地浏览覆盖率报告

982
00:51:17,344 --> 0:51:18,812
可能并不完全是你想要实现的功能

983
00:51:19,580 --> 0:51:22,783
如果你还想比较两个报告

984
00:51:22,850 --> 0:51:24,218
用于了解覆盖率是否增加了或减少了

985
00:51:24,618 --> 0:51:25,886
你可以使用diff命令

986
00:51:26,920 --> 0:51:29,156
把路径传给工具的两个结果捆绑包

987
00:51:29,523 --> 0:51:31,258
这将生成类似这样的输出

988
00:51:32,492 --> 0:51:35,863
在这个例子中 我们可以看到

989
00:51:36,330 --> 0:51:39,466
在两个结果捆绑包之间增加了50%

990
00:51:42,569 --> 0:51:45,372
跟xcresulttool一样

991
00:51:45,672 --> 0:51:46,907
请查看xccov主页获取更多信息

992
00:51:50,143 --> 0:51:51,945
这样我们终于完成了最后一步

993
00:51:52,846 --> 0:51:55,616
我们将使用xccov

994
00:51:56,149 --> 0:51:57,518
用于追踪我们的进度

995
00:52:00,854 --> 0:52:03,490
太棒了 我们的持续集成流程完成了

996
00:52:04,091 --> 0:52:06,360
使用xcodebuild

997
00:52:06,860 --> 0:52:09,263
用xcresulttool

998
00:52:09,830 --> 0:52:11,431
并使用xccov来浏览代码覆盖率

999
00:52:11,765 --> 0:52:14,067
我们创建了一个完全功能性的

1000
00:52:14,134 --> 0:52:15,669
自动化我们的app的测试流程

1001
00:52:16,770 --> 0:52:19,806
希望这能让你们了解了一些

1002
00:52:19,873 --> 0:52:22,376
使用Xcode配套工具

1003
00:52:23,243 --> 0:52:25,045
我们只讲了其中一种可能的流程

1004
00:52:25,412 --> 0:52:27,748
但通过这些创建代码块

1005
00:52:30,150 --> 0:52:32,085
今天我们讲了很多内容

1006
00:52:32,152 --> 0:52:33,921
让我们快速回顾一下

1007
00:52:35,088 --> 0:52:38,492
我们先介绍了Xcode中的测试

1008
00:52:39,426 --> 0:52:42,229
了解了如何用XCTest

1009
00:52:42,496 --> 0:52:43,730
以及如何运行它们以捕捉错误

1010
00:52:45,432 --> 0:52:47,334
接下来我们了解了测试计划

1011
00:52:47,401 --> 0:52:49,970
这是一个新功能

1012
00:52:50,337 --> 0:52:53,073
以及在不同配置下多次运行测试

1013
00:52:54,708 --> 0:52:56,877
最后我们了解了我们可以用于

1014
00:52:56,944 --> 0:52:59,213
创建自定义持续集成管道的工具

1015
00:53:01,215 --> 0:53:03,650
如果你想了解更多

1016
00:53:03,717 --> 0:53:05,052
复制这几张幻灯片

1017
00:53:05,519 --> 0:53:07,688
请一定要查看

1018
00:53:08,956 --> 0:53:12,125
最后如果你有兴趣了解

1019
00:53:12,192 --> 0:53:13,994
用于测量代码的性能的新API

1020
00:53:14,261 --> 0:53:16,930
请查看今天稍后举办的

1021
00:53:18,131 --> 0:53:20,167
请参加我们的演讲
