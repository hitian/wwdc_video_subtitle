1
00:00:06,939 --> 0:00:11,178
（Combine介绍）

2
00:00:15,148 --> 0:00:15,983
大家好

3
00:00:16,583 --> 0:00:17,451
谢谢

4
00:00:17,518 --> 0:00:18,552
我是Tony Parker

5
00:00:18,619 --> 0:00:20,787
是Apple的

6
00:00:20,854 --> 0:00:22,656
今天很开心

7
00:00:22,723 --> 0:00:24,591
向大家介绍最新的框架

8
00:00:24,658 --> 0:00:25,926
叫做Combine

9
00:00:26,527 --> 0:00:28,495
我们先来谈谈异步编程

10
00:00:29,796 --> 0:00:31,298
这里正在运行一款app

11
00:00:31,365 --> 0:00:35,235
可以让学生注册成为我的

12
00:00:35,302 --> 0:00:37,604
你可以看到

13
00:00:38,272 --> 0:00:40,107
首先要一个有效用户名

14
00:00:40,174 --> 0:00:43,243
我们将通过向服务器

15
00:00:43,510 --> 0:00:45,445
当然还要密码

16
00:00:45,512 --> 0:00:47,781
这我们在app本地就可以检查

17
00:00:48,448 --> 0:00:49,650
在我们做这些事的同时

18
00:00:49,716 --> 0:00:52,519
我们还要维护响应式用户界面

19
00:00:52,586 --> 0:00:53,987
不会阻塞主线程

20
00:00:54,054 --> 0:00:55,289
（app的要求）

21
00:00:55,355 --> 0:00:57,191
我们来试试这是怎么运行的

22
00:00:57,758 --> 0:01:01,461
首先我们输入用户名

23
00:00:57,758 --> 0:01:01,461
首先我们输入用户名

24
00:01:01,528 --> 0:01:02,663
就Merlin吧

25
00:01:03,397 --> 0:01:04,798
听起来是个不错的巫师名字

26
00:01:04,864 --> 0:01:08,235
其实这已经有许多异步行为了

27
00:01:08,302 --> 0:01:12,239
我使用Target/Action

28
00:01:12,706 --> 0:01:16,577
我运用计时器来等待用户暂定输入

29
00:01:16,643 --> 0:01:20,447
这样网络请求就不会

30
00:01:20,814 --> 0:01:23,951
最后我使用诸如KVO之类的东西来

31
00:01:24,017 --> 0:01:25,786
接收有关异步操作的进度更新

32
00:01:26,620 --> 0:01:27,754
如果我继续下去的话

33
00:01:28,155 --> 0:01:30,424
我就会收到关于该请求的响应

34
00:01:30,490 --> 0:01:31,925
我们就要更新UI了

35
00:01:31,992 --> 0:01:33,193
所以 我选择一个新的用户名

36
00:01:33,493 --> 0:01:37,297
再填入我超级安全的密码12345

37
00:01:37,631 --> 0:01:39,733
请不要真的用这种密码

38
00:01:41,001 --> 0:01:43,804
到这里 我们又完成了许多异步工作

39
00:01:43,871 --> 0:01:47,140
我们等待了URL会话请求的响应

40
00:01:47,207 --> 0:01:49,042
我们将该结果与

41
00:01:49,109 --> 0:01:51,278
同步检查结果合并

42
00:01:51,345 --> 0:01:53,146
最后做完这些事情

43
00:01:53,480 --> 0:01:56,350
做完这些事情之后

44
00:01:56,416 --> 0:01:57,985
使用KVC之类的东西

45
00:01:59,486 --> 0:02:00,387
（异步界面）

46
00:01:59,486 --> 0:02:00,387
（异步界面）

47
00:02:00,454 --> 0:02:01,889
在Cocoa SDK里

48
00:02:01,955 --> 0:02:05,125
你可以看到很多异步界面

49
00:02:05,192 --> 0:02:07,995
如这里Target/Action

50
00:02:08,061 --> 0:02:11,064
包括Notification Center

51
00:02:11,131 --> 0:02:14,201
这些都是采用闭合或完成块的API

52
00:02:14,268 --> 0:02:17,204
这些都有重要和不同的用途

53
00:02:17,504 --> 0:02:19,640
但如果你要将它们结合起来的话

54
00:02:19,706 --> 0:02:21,175
就有点挑战了

55
00:02:21,808 --> 0:02:25,179
对于Combine

56
00:02:25,245 --> 0:02:27,781
而是找到它们的共同点

57
00:02:28,315 --> 0:02:29,650
这就是Combine

58
00:02:29,950 --> 0:02:34,087
会根据时间处理这些值的

59
00:02:35,389 --> 0:02:38,192
Combine是Swift中写的

60
00:02:38,258 --> 0:02:41,595
也就意味着我们可以利用

61
00:02:41,962 --> 0:02:44,431
泛型可以减少

62
00:02:44,498 --> 0:02:45,599
样板代码的数量

63
00:02:45,899 --> 0:02:48,302
也就是说我们只需

64
00:02:48,368 --> 0:02:51,171
泛型算法

65
00:02:51,238 --> 0:02:53,740
所有类型的异步界面

66
00:02:54,908 --> 0:02:56,543
Combine也是类型安全的

67
00:02:56,610 --> 0:03:00,247
它让我们在编译时就能捕获错误

68
00:02:56,610 --> 0:03:00,247
它让我们在编译时就能捕获错误

69
00:03:00,314 --> 0:03:01,281
（Combine功能）

70
00:03:01,348 --> 0:03:04,785
Combine的主要设计点是

71
00:03:05,118 --> 0:03:09,389
这意味着核心概念是简单易懂的

72
00:03:09,456 --> 0:03:10,657
但是一旦你将它们组合起来

73
00:03:10,724 --> 0:03:13,393
创造出的总价值

74
00:03:14,261 --> 0:03:16,496
最后Combine是请求驱动的

75
00:03:16,763 --> 0:03:20,200
它让你能够更加仔细地管理

76
00:03:20,267 --> 0:03:21,935
以及app的性能

77
00:03:22,736 --> 0:03:24,905
所以 现在我们就来谈谈

78
00:03:24,972 --> 0:03:28,375
核心概念只有三个

79
00:03:28,442 --> 0:03:30,143
我们每一个都会详细讲到

80
00:03:30,210 --> 0:03:31,845
首先是发布程序

81
00:03:33,280 --> 0:03:36,016
发布程序是

82
00:03:36,450 --> 0:03:39,553
它描述了值和错误是如何产生的

83
00:03:39,620 --> 0:03:42,422
但不一定是产生这些东西的源头

84
00:03:42,990 --> 0:03:45,659
这意味着作为描述

85
00:03:45,926 --> 0:03:48,295
在Swift里的意思就是

86
00:03:49,329 --> 0:03:53,667
发布程序允许注册订阅程序

87
00:03:53,734 --> 0:03:56,170
该程序会随着时间来接收这些值

88
00:03:57,337 --> 0:03:58,338
这是协议

89
00:03:58,705 --> 0:03:59,873
这就是发布程序

90
00:03:59,940 --> 0:04:01,608
它有两种相关类型

91
00:03:59,940 --> 0:04:01,608
它有两种相关类型

92
00:04:01,675 --> 0:04:04,444
输出 这就是它会生成的值

93
00:04:04,511 --> 0:04:05,546
还有故障

94
00:04:05,612 --> 0:04:07,614
是它生成的错误

95
00:04:07,881 --> 0:04:10,450
如果发布程序不能生成错误

96
00:04:10,517 --> 0:04:13,820
你就可以将从不类型

97
00:04:14,955 --> 0:04:18,325
发布程序有一个核心功能

98
00:04:18,659 --> 0:04:20,327
从这个函数的泛型约束

99
00:04:20,394 --> 0:04:21,595
可以看出

100
00:04:21,661 --> 0:04:25,199
订阅要求用订阅程序的输入

101
00:04:25,265 --> 0:04:27,801
用订阅程序的故障来匹配

102
00:04:27,868 --> 0:04:29,603
（发布程序）

103
00:04:29,670 --> 0:04:31,271
这是一个发布程序的例子

104
00:04:31,338 --> 0:04:33,473
这是我们Notification Center

105
00:04:34,107 --> 0:04:39,513
你可以看到 它是一个结构

106
00:04:39,813 --> 0:04:41,281
故障类型是从不

107
00:04:41,882 --> 0:04:44,484
它初始化了三样东西 中心

108
00:04:44,551 --> 0:04:46,286
名称 还有对象

109
00:04:46,620 --> 0:04:49,356
如果你了解我们现在的

110
00:04:49,423 --> 0:04:50,724
你应该很熟悉这些代码

111
00:04:50,791 --> 0:04:52,893
再次强调 我们并没有替换

112
00:04:52,960 --> 0:04:54,061
只是做了适当改写

113
00:04:55,329 --> 0:04:56,697
接下来说说订阅程序

114
00:04:57,231 --> 0:04:59,700
订阅程序与发布程序对应

115
00:05:00,267 --> 0:05:01,435
它用于接收值

116
00:05:01,502 --> 0:05:04,271
如果发布程序有限的话

117
00:05:05,038 --> 0:05:09,142
因为订阅程序在接收到值后

118
00:05:09,209 --> 0:05:12,446
我们在Swift中用的是引用类型

119
00:05:13,247 --> 0:05:14,815
这是订阅程序协议

120
00:05:15,115 --> 0:05:17,384
你可以看到

121
00:05:17,451 --> 0:05:18,519
输入和故障

122
00:05:18,585 --> 0:05:21,522
同样 如果订阅程序无法接收故障

123
00:05:21,588 --> 0:05:23,090
那么你就可以使用永不类型

124
00:05:23,590 --> 0:05:25,192
订阅程序有三种主要功能

125
00:05:25,792 --> 0:05:27,227
它会接收订阅

126
00:05:27,628 --> 0:05:30,597
订阅是订阅程序控制从发布服务器

127
00:05:30,664 --> 0:05:32,432
到订阅服务器的数据流的方法

128
00:05:32,966 --> 0:05:34,735
它也可以接收输入

129
00:05:35,002 --> 0:05:37,971
最后 如果它所连接的

130
00:05:38,038 --> 0:05:41,875
那么它也可以接受

131
00:05:41,942 --> 0:05:43,577
（订阅程序）

132
00:05:43,644 --> 0:05:45,179
这是订阅程序的例子

133
00:05:45,812 --> 0:05:47,214
叫做分配

134
00:05:47,714 --> 0:05:52,719
分配是一个类 它用类的实例

135
00:05:52,786 --> 0:05:56,957
对象的实例 以及进入该对象的

136
00:05:57,457 --> 0:05:59,693
当它接受到输入

137
00:05:59,760 --> 0:06:02,229
它就会将其写入该对象的属性

138
00:05:59,760 --> 0:06:02,229
它就会将其写入该对象的属性

139
00:06:02,529 --> 0:06:04,631
因为在Swift中

140
00:06:04,698 --> 0:06:06,333
它是没有办法处理错误的

141
00:06:06,600 --> 0:06:09,102
我们将分配的故障类型设为永不

142
00:06:10,404 --> 0:06:11,705
我们接下来谈谈

143
00:06:11,772 --> 0:06:12,973
（模式）

144
00:06:13,040 --> 0:06:14,908
你可能会用某些控制器对象

145
00:06:14,975 --> 0:06:18,011
或是其他类型来保存你的订阅程序

146
00:06:18,078 --> 0:06:20,781
它负责用订阅程序来

147
00:06:20,848 --> 0:06:21,982
调用订阅

148
00:06:22,449 --> 0:06:24,751
将其作为附加发送给发布程序

149
00:06:25,652 --> 0:06:28,288
这时 发布程序就会将订阅

150
00:06:28,655 --> 0:06:29,890
发送给订阅程序

151
00:06:29,957 --> 0:06:33,961
订阅程序会将其用于

152
00:06:34,027 --> 0:06:36,463
一定数量或无数值的请求

153
00:06:37,231 --> 0:06:38,799
这时 发布程序

154
00:06:38,866 --> 0:06:42,369
就可以将该数量或者更少的值

155
00:06:42,436 --> 0:06:44,338
再次强调 如果发布程序是有限的

156
00:06:44,404 --> 0:06:47,341
那么它只会发送完成或者是错误

157
00:06:48,308 --> 0:06:50,043
所以 一个订阅会发送

158
00:06:50,444 --> 0:06:53,480
0个或更多的值 或者是一个完成

159
00:06:55,449 --> 0:06:56,984
回到我们的例子

160
00:06:57,050 --> 0:07:00,187
假设我有一个模型对象叫巫师

161
00:06:57,050 --> 0:07:00,187
假设我有一个模型对象叫巫师

162
00:07:00,254 --> 0:07:03,457
我现在关注的是巫师的年级

163
00:07:03,790 --> 0:07:06,026
我们先从五年级的Merlin开始

164
00:07:07,594 --> 0:07:09,963
我想做的是接收关于

165
00:07:10,030 --> 0:07:11,932
毕业学生的通知

166
00:07:11,999 --> 0:07:16,103
当他们毕业 我就要更新

167
00:07:16,470 --> 0:07:18,972
所以 我从默认中心

168
00:07:19,439 --> 0:07:20,574
Merlin毕业情况的

169
00:07:21,375 --> 0:07:22,943
Notification Center

170
00:07:24,244 --> 0:07:26,713
接下来 我要创建分配订阅程序

171
00:07:26,780 --> 0:07:30,817
让它将新年级写入

172
00:07:32,686 --> 0:07:35,222
我再用订阅进行附加

173
00:07:35,289 --> 0:07:38,025
但是可能如你所料 它没有进行编译

174
00:07:38,392 --> 0:07:40,661
原因是类型不匹配

175
00:07:41,395 --> 0:07:43,330
Notification Center

176
00:07:43,730 --> 0:07:48,235
但是分配被配置需要整数

177
00:07:48,902 --> 0:07:51,038
所以我们要在通知

178
00:07:51,104 --> 0:07:53,774
和整数之间折中

179
00:07:54,241 --> 0:07:55,108
那就是

180
00:07:55,876 --> 0:07:56,710
操作程序

181
00:07:57,411 --> 0:08:00,314
操作程序在采用发布程序协议前

182
00:07:57,411 --> 0:08:00,314
操作程序在采用发布程序协议前

183
00:08:00,647 --> 0:08:03,317
它也是声明性的 所以它也是值类型

184
00:08:03,717 --> 0:08:07,387
它会描述改变值 增加值

185
00:08:07,454 --> 0:08:08,288
或删除值的行为

186
00:08:08,355 --> 0:08:11,058
或者是其他行为

187
00:08:11,792 --> 0:08:15,229
并订阅我们称之为上游的

188
00:08:15,963 --> 0:08:18,999
并将结果发送至

189
00:08:19,066 --> 0:08:20,234
（操作程序）

190
00:08:20,300 --> 0:08:21,935
这是操作程序的例子

191
00:08:22,236 --> 0:08:24,071
当你运用Combine的时候

192
00:08:24,137 --> 0:08:25,005
你就会了解该例

193
00:08:25,072 --> 0:08:26,240
它叫做Map

194
00:08:26,640 --> 0:08:31,378
Map是上游连接的初始化结构

195
00:08:31,445 --> 0:08:34,748
它会将下游的输出转化为自己的输出

196
00:08:35,482 --> 0:08:37,484
因为Map无法自己生成故障

197
00:08:37,551 --> 0:08:39,686
它只会反映上游的故障类型

198
00:08:39,753 --> 0:08:41,054
并且传递

199
00:08:41,621 --> 0:08:43,390
所以有了Map 我们就有了

200
00:08:43,457 --> 0:08:45,826
在通知和整数之间转化的工具

201
00:08:46,460 --> 0:08:47,294
我们来看

202
00:08:48,128 --> 0:08:50,597
我们用的是之前的

203
00:08:50,664 --> 0:08:51,899
我添加转换器

204
00:08:52,165 --> 0:08:55,802
你可以看到它被配置为

205
00:08:55,869 --> 0:08:57,004
还有一个闭合包

206
00:08:57,070 --> 0:08:59,206
该闭合包会接收通知

207
00:08:59,473 --> 0:09:02,109
并查找名为新年级的用户信息密钥

208
00:08:59,473 --> 0:09:02,109
并查找名为新年级的用户信息密钥

209
00:09:02,676 --> 0:09:03,677
如果有该密钥

210
00:09:03,744 --> 0:09:06,313
且该密钥为整数

211
00:09:06,780 --> 0:09:09,216
如果无密钥或密钥不为整数

212
00:09:09,283 --> 0:09:11,084
就将新默认值设为0

213
00:09:11,485 --> 0:09:15,122
也就是说不管如何

214
00:09:15,189 --> 0:09:18,792
这样我们就可以将其连接至订阅程序

215
00:09:19,159 --> 0:09:22,396
这样所有东西就可以连接

216
00:09:23,297 --> 0:09:26,033
现在所有这些构造语法都有点冗长

217
00:09:26,099 --> 0:09:28,435
所以我们需要更为流畅的语法

218
00:09:28,702 --> 0:09:29,770
让我们来看看

219
00:09:31,405 --> 0:09:35,843
作为发布程序协议的扩展

220
00:09:36,310 --> 0:09:40,080
我们添加了一系列

221
00:09:40,347 --> 0:09:41,582
这是Map的函数

222
00:09:42,015 --> 0:09:42,916
如你所见

223
00:09:42,983 --> 0:09:46,420
它的参数是初始化Map所需的一切

224
00:09:46,486 --> 0:09:47,988
除了上游

225
00:09:48,055 --> 0:09:50,824
原因是作为发布程序的扩展

226
00:09:50,891 --> 0:09:52,292
我们使用self就可以了

227
00:09:53,427 --> 0:09:55,696
这看起来是一个简便的方法

228
00:09:55,762 --> 0:09:58,465
但事实上这会改变

229
00:09:58,532 --> 0:10:01,034
你对app的异步编程的看法

230
00:09:58,532 --> 0:10:01,034
你对app的异步编程的看法

231
00:10:01,535 --> 0:10:04,538
回到我们的例子 但这次用新的语法

232
00:10:06,006 --> 0:10:08,709
我从Merlin毕业情况的

233
00:10:08,775 --> 0:10:10,310
Notification Center

234
00:10:11,378 --> 0:10:14,147
当我接受到通知 我就对其使用地图

235
00:10:15,148 --> 0:10:17,217
闭合包与我们刚才所用一致

236
00:10:17,985 --> 0:10:21,588
之后我将其分配至

237
00:10:22,122 --> 0:10:24,558
你可以看到现在的语法是线性的

238
00:10:24,625 --> 0:10:27,561
每一步发生了什么都可以轻松看懂

239
00:10:28,395 --> 0:10:31,398
分配之后会返回一个叫可取消的东西

240
00:10:31,465 --> 0:10:33,700
取消也是Combine中的一部分

241
00:10:34,067 --> 0:10:36,870
取消能够让你尽早拆除发布程序和

242
00:10:36,937 --> 0:10:38,939
订阅程序间的序列 如果有该需要

243
00:10:40,474 --> 0:10:43,110
所以该逐步语法是

244
00:10:43,177 --> 0:10:44,611
使用Combine的核心

245
00:10:44,978 --> 0:10:48,048
每个步骤都描述了链中的下一组指令

246
00:10:48,415 --> 0:10:50,517
并传输从第一个发布程序开始

247
00:10:50,584 --> 0:10:53,220
逐一向操作程序传送的值

248
00:10:53,287 --> 0:10:55,088
到订阅程序为止

249
00:10:55,856 --> 0:10:57,457
我们有许多像这样的操作程序

250
00:10:57,758 --> 0:11:00,060
我们叫它声明性操作程序API

251
00:10:57,758 --> 0:11:00,060
我们叫它声明性操作程序API

252
00:11:00,527 --> 0:11:02,563
它们包括像Map这样的转换功能

253
00:11:02,629 --> 0:11:04,431
我们也有筛选和减少

254
00:11:04,498 --> 0:11:09,002
列出操作 例如获取发布程序的

255
00:11:09,403 --> 0:11:13,740
错误处理 例如将错误转换为

256
00:11:14,107 --> 0:11:17,744
线程或Q移动

257
00:11:17,811 --> 0:11:20,781
后台线程或UI工作到主线程

258
00:11:21,114 --> 0:11:23,917
还有调度和时间 包括循环集成

259
00:11:24,384 --> 0:11:27,921
调度队列 计时器支持 超时等

260
00:11:28,789 --> 0:11:30,657
有这么多许多可用的操作程序

261
00:11:30,724 --> 0:11:32,326
到底要用哪一个

262
00:11:32,392 --> 0:11:35,696
你可能会有点选择困难症

263
00:11:36,029 --> 0:11:37,164
所以我建议你

264
00:11:37,231 --> 0:11:40,267
回到关于Combine的

265
00:11:40,334 --> 0:11:42,503
那就是组成

266
00:11:42,569 --> 0:11:44,004
（首先尝试组成）

267
00:11:44,071 --> 0:11:47,708
我们并不是只提供少数的操作程序

268
00:11:47,774 --> 0:11:50,544
而是提供许多操作程序

269
00:11:50,611 --> 0:11:52,112
这样会让它们更便于理解

270
00:11:52,913 --> 0:11:55,816
所以为了帮助你在

271
00:11:55,883 --> 0:12:00,153
我们从现有的Swift collection

272
00:11:55,883 --> 0:12:00,153
我们从现有的Swift collection

273
00:12:01,255 --> 0:12:02,089
让我们来看看

274
00:12:02,789 --> 0:12:04,291
我们想象这样一个象限图

275
00:12:04,791 --> 0:12:08,996
一边是同步的API

276
00:12:09,363 --> 0:12:13,367
顶部是单个值 底部是多个

277
00:12:14,401 --> 0:12:17,638
在Swift中

278
00:12:17,704 --> 0:12:19,473
你就要用到int之类的功能

279
00:12:19,873 --> 0:12:22,242
如果你想同步表示许多整数

280
00:12:22,309 --> 0:12:24,478
就要用整数数组之类的东西

281
00:12:25,012 --> 0:12:26,613
在Combine中

282
00:12:26,680 --> 0:12:29,116
并将它们映射到异步中

283
00:12:29,449 --> 0:12:32,119
所以 如果你想要异步表示一个值

284
00:12:32,186 --> 0:12:34,321
那么之后会有future值

285
00:12:34,388 --> 0:12:37,291
如果你要异步表示许多值

286
00:12:37,357 --> 0:12:38,325
那么这就是一个发布程序

287
00:12:38,992 --> 0:12:39,860
意思就是

288
00:12:39,927 --> 0:12:42,095
如果你在寻找一种你已经知道

289
00:12:42,162 --> 0:12:44,831
如何处理数组的特定操作

290
00:12:44,898 --> 0:12:47,134
试试使用发布程序的名称

291
00:12:47,668 --> 0:12:48,936
看看下面这个例子

292
00:12:50,637 --> 0:12:54,408
这个例子中 如果密钥不存在

293
00:12:54,474 --> 0:12:57,144
或者不为整数的话

294
00:12:57,544 --> 0:13:01,215
如果不让这个坏值进入我们的程序

295
00:12:57,544 --> 0:13:01,215
如果不让这个坏值进入我们的程序

296
00:13:01,281 --> 0:13:03,851
并最终写入我的模型对象中就更好了

297
00:13:04,318 --> 0:13:07,988
所以我可以允许让这个闭合包返回无

298
00:13:08,055 --> 0:13:10,190
再筛选掉无值

299
00:13:10,691 --> 0:13:14,661
在Swift 4.1 标准库

300
00:13:14,728 --> 0:13:16,129
叫compactMap

301
00:13:16,196 --> 0:13:20,033
发布程序也有一个相似的名称

302
00:13:20,100 --> 0:13:23,804
如果闭合包返回无值

303
00:13:23,871 --> 0:13:25,973
防止它继续在流程中继续

304
00:13:27,107 --> 0:13:28,909
让我们使用一些更熟悉的名称

305
00:13:28,976 --> 0:13:31,144
来构建我们的分步说明

306
00:13:33,380 --> 0:13:35,983
假如只有五年级以上的学生

307
00:13:36,049 --> 0:13:37,518
可以继续留下来

308
00:13:37,818 --> 0:13:39,686
我就可以用过滤器来做到

309
00:13:40,153 --> 0:13:41,321
过滤器会接受一个谓词

310
00:13:41,388 --> 0:13:44,691
并只允许传递该谓词的元素继续下去

311
00:13:44,758 --> 0:13:47,561
这与数组过滤器完全一致

312
00:13:48,262 --> 0:13:50,464
让我们进一步假设你最多只能

313
00:13:50,531 --> 0:13:52,099
毕业三次

314
00:13:52,866 --> 0:13:54,334
那么在数组中

315
00:13:54,401 --> 0:13:55,869
如果你想要获取前三项元素

316
00:13:55,936 --> 0:13:57,437
你可以使用前缀3

317
00:13:57,704 --> 0:13:58,539
在发布程序中

318
00:13:58,605 --> 0:14:00,307
如果你只想接受前三项元素

319
00:13:58,605 --> 0:14:00,307
如果你只想接受前三项元素

320
00:14:00,374 --> 0:14:02,376
你可以使用3的前缀

321
00:14:02,776 --> 0:14:05,179
它在接收到这三个值后

322
00:14:05,245 --> 0:14:06,713
它将取消上游

323
00:14:06,780 --> 0:14:08,582
并向下游发送完成

324
00:14:10,250 --> 0:14:12,519
所以后退一步 看看这里有什么

325
00:14:12,819 --> 0:14:16,757
Notification Center发布程序接收到

326
00:14:17,724 --> 0:14:20,627
当他毕业后 我们就会从该属性中

327
00:14:20,694 --> 0:14:23,197
获取新年级 从该通知中获取

328
00:14:23,664 --> 0:14:26,600
我们要确保该值大于五年级

329
00:14:26,667 --> 0:14:29,236
并且最多只发生三次

330
00:14:29,303 --> 0:14:32,906
最后再将它分配给

331
00:14:34,575 --> 0:14:35,676
（结合发布程序）

332
00:14:35,742 --> 0:14:37,778
Map和过滤器都是很好的API

333
00:14:37,845 --> 0:14:40,013
但它们主要是同步行为

334
00:14:40,514 --> 0:14:43,684
Combine在进行异步行为时

335
00:14:44,184 --> 0:14:46,486
所以接下来我们就会讲到

336
00:14:46,553 --> 0:14:48,121
对异步行为十分有用

337
00:14:48,188 --> 0:14:49,256
首先是Zip

338
00:14:50,190 --> 0:14:54,194
所以在我们的app中

339
00:14:54,261 --> 0:14:56,063
才能继续操作

340
00:14:56,129 --> 0:14:59,299
这是三个长时间运行的异步操作

341
00:15:00,434 --> 0:15:01,268
所以

342
00:15:01,535 --> 0:15:04,905
等这三件事完成之后

343
00:15:05,272 --> 0:15:06,773
这就是Zip的工作

344
00:15:07,474 --> 0:15:11,278
Zip将几个上游输入

345
00:15:12,279 --> 0:15:14,815
因为它需要所有来自上游的输入

346
00:15:14,882 --> 0:15:16,083
才能继续进行

347
00:15:16,149 --> 0:15:19,119
它会在一件事情完成

348
00:15:19,186 --> 0:15:22,689
开始进行下一件事的时候

349
00:15:23,790 --> 0:15:26,660
比如第一个发布程序生成A

350
00:15:27,127 --> 0:15:29,496
然后第二个发布程序生成1

351
00:15:29,563 --> 0:15:31,999
我就有足够的信息来创造一个元组了

352
00:15:32,366 --> 0:15:35,435
并将该值下游发送给订阅程序

353
00:15:37,371 --> 0:15:40,374
我的app用的是这个版本的Zip

354
00:15:40,440 --> 0:15:44,444
它让三个上游等待

355
00:15:44,511 --> 0:15:46,446
每个操作都会

356
00:15:46,513 --> 0:15:48,582
所以我将该元组映射到布尔

357
00:15:48,649 --> 0:15:50,851
这时我就会将它写入

358
00:15:50,918 --> 0:15:52,753
来将它启动

359
00:15:55,022 --> 0:15:57,958
所以 在等待魔杖生成后

360
00:15:58,025 --> 0:15:59,026
像其他人一样

361
00:15:59,092 --> 0:16:01,662
我的学生必须要

362
00:15:59,092 --> 0:16:01,662
我的学生必须要

363
00:16:01,728 --> 0:16:04,698
才能被允许继续玩他们的魔杖

364
00:16:05,332 --> 0:16:07,534
这也就是说在启用开始按钮之前

365
00:16:07,601 --> 0:16:10,337
必须启用这三个开关

366
00:16:10,404 --> 0:16:13,140
但是如果其中一个开关之后被禁用了

367
00:16:13,207 --> 0:16:15,242
那么这个开关也要被禁用

368
00:16:15,843 --> 0:16:17,911
这就是

369
00:16:18,545 --> 0:16:21,882
与Zip一样 它将几个上游输入

370
00:16:22,282 --> 0:16:23,383
但又不完全像Zip

371
00:16:23,450 --> 0:16:26,653
它需要来自任何上游的输入

372
00:16:26,720 --> 0:16:29,156
才能使其成为when/or操作

373
00:16:29,623 --> 0:16:30,624
为了支持这一点

374
00:16:30,691 --> 0:16:34,027
它会存储从每个上游

375
00:16:34,094 --> 0:16:35,729
同时配置闭合包

376
00:16:35,796 --> 0:16:38,632
这样你就可以将其

377
00:16:39,900 --> 0:16:42,536
比如我的第一个发布程序生成了A

378
00:16:42,936 --> 0:16:45,506
第二个生成A1

379
00:16:45,772 --> 0:16:48,408
之后我运行闭合包将其串联

380
00:16:48,475 --> 0:16:49,776
发送至下游

381
00:16:50,244 --> 0:16:53,080
之后如果第二个发布程序再生成新值

382
00:16:53,146 --> 0:16:56,183
我就可以将它与前面

383
00:16:56,250 --> 0:16:59,052
第一个发布程序生成的值结合

384
00:16:59,620 --> 0:17:03,056
也就是说每当上游发生变化时

385
00:16:59,620 --> 0:17:03,056
也就是说每当上游发生变化时

386
00:17:04,090 --> 0:17:05,925
所以在我的app中

387
00:17:05,992 --> 0:17:08,829
我用的是这种Combine Latest

388
00:17:09,496 --> 0:17:10,430
每当三个开关的

389
00:17:10,497 --> 0:17:13,032
布尔状态变化时

390
00:17:13,300 --> 0:17:15,536
就再次将其转化

391
00:17:15,602 --> 0:17:18,539
再将其写入开始按钮的

392
00:17:19,205 --> 0:17:22,276
也就是说 只要其中任何一个

393
00:17:22,342 --> 0:17:25,045
如果全为真 结果也为真

394
00:17:25,112 --> 0:17:26,445
这样我们就能启用按钮了

395
00:17:28,448 --> 0:17:31,752
我们设计Combine的里面是

396
00:17:31,818 --> 0:17:34,321
你不用转化所有内容来使用它

397
00:17:34,588 --> 0:17:37,057
所以开始我有一些建议

398
00:17:37,124 --> 0:17:40,827
可能会对你在app中

399
00:17:41,261 --> 0:17:43,997
比如你要使用

400
00:17:44,064 --> 0:17:46,767
你就会收到通知 之后你会查看

401
00:17:46,834 --> 0:17:50,070
来决定是否执行 那么试试过滤器

402
00:17:51,371 --> 0:17:54,575
如果你要对几个

403
00:17:54,842 --> 0:17:58,645
那么你可以用Zip

404
00:17:59,479 --> 0:18:04,017
最后 如果你用的是

405
00:17:59,479 --> 0:18:04,017
最后 如果你用的是

406
00:18:04,084 --> 0:18:07,588
然后使用JSON Decoder

407
00:18:07,855 --> 0:18:09,790
我们同样也有一款

408
00:18:09,857 --> 0:18:11,291
那就是Decode

409
00:18:11,358 --> 0:18:12,860
（试试看）

410
00:18:12,926 --> 0:18:13,861
（关于Combine的更多信息）

411
00:18:13,927 --> 0:18:18,065
今天我们讲到了基础的东西

412
00:18:18,131 --> 0:18:20,133
但是Combine还有更多的东西

413
00:18:20,934 --> 0:18:23,504
包括错误处理和取消

414
00:18:23,937 --> 0:18:27,541
调度程序和时间

415
00:18:27,608 --> 0:18:30,377
包括在app中的不同模块或

416
00:18:30,444 --> 0:18:34,481
不同区域之间使用Combine

417
00:18:34,548 --> 0:18:37,851
或许更多详情

418
00:18:39,119 --> 0:18:41,188
今天就说这么多 谢谢大家

419
00:18:41,255 --> 0:18:44,057
（更多信息）
