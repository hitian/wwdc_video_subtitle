1
00:00:06,406 --> 0:00:10,777
（开发优秀的分析体验

2
00:00:14,982 --> 0:00:16,850
下午好 欢迎参加我们的演讲

3
00:00:16,917 --> 0:00:18,952
开发优秀的分析体验

4
00:00:19,319 --> 0:00:21,688
我是Daniel Delwood 稍后同事

5
00:00:22,122 --> 0:00:25,292
今天我们在此要讲开发优秀的自定义

6
00:00:26,527 --> 0:00:29,429
作为开发人员

7
00:00:29,496 --> 0:00:31,732
可维护的、模块化的

8
00:00:32,165 --> 0:00:34,134
我们都使用其它人设计的框架

9
00:00:34,201 --> 0:00:36,837
我们希望其它人也能使用

10
00:00:37,971 --> 0:00:40,841
良好的API设计和文档

11
00:00:40,908 --> 0:00:43,210
对于用户使用你的框架的体验来说

12
00:00:43,577 --> 0:00:47,147
但我希望你们也考虑一下开发

13
00:00:48,515 --> 0:00:50,784
要了解为什么

14
00:00:51,318 --> 0:00:53,820
API设计是中枢 API的调用

15
00:00:53,887 --> 0:00:55,455
围绕一组核心概念、

16
00:00:55,756 --> 0:00:58,125
设备、命令缓冲区、纹理等等

17
00:00:59,126 --> 0:01:00,360
但这并不是全部

18
00:00:59,126 --> 0:01:00,360
但这并不是全部

19
00:01:00,861 --> 0:01:02,963
API界面表达了什么是可能的

20
00:01:03,363 --> 0:01:05,032
但文档和示例代码

21
00:01:05,098 --> 0:01:08,902
是其他人了解如何用这些概念

22
00:01:09,937 --> 0:01:11,305
但这也不是全部

23
00:01:11,972 --> 0:01:14,374
这两者结合可以帮助开发人员

24
00:01:14,441 --> 0:01:15,943
使用你的类或框架编写代码

25
00:01:16,476 --> 0:01:18,011
但如果出现错误怎么办？

26
00:01:18,712 --> 0:01:21,849
嗯 自定义Instruments

27
00:01:22,115 --> 0:01:26,353
教会其他人如何调试、优化

28
00:01:26,820 --> 0:01:29,323
若你用过Instruments中

29
00:01:29,623 --> 0:01:31,191
你肯定了解了其中一些可能的情况

30
00:01:31,391 --> 0:01:33,994
创建可视化工具

31
00:01:34,061 --> 0:01:36,463
并针对你所定义的概念和API

32
00:01:37,698 --> 0:01:40,801
Instruments程序包

33
00:01:41,134 --> 0:01:43,504
在底层 你的框架可以对

34
00:01:43,570 --> 0:01:45,172
可理解并且支持良好

35
00:01:45,506 --> 0:01:47,641
花时间来创建一个

36
00:01:47,708 --> 0:01:49,676
可以帮助你建立自信和信任

37
00:01:50,143 --> 0:01:52,346
坚信代码正在执行你所期待的操作

38
00:01:53,347 --> 0:01:55,916
工具也是开发成本模型的一个好方式

39
00:01:56,250 --> 0:01:58,952
你可以了解哪个调用消耗较大

40
00:01:59,419 --> 0:02:00,988
当出现性能问题时

41
00:01:59,419 --> 0:02:00,988
当出现性能问题时

42
00:02:01,054 --> 0:02:03,824
它们是区分框架错误

43
00:02:03,991 --> 0:02:05,292
或客户代码错误的最佳方式

44
00:02:06,627 --> 0:02:11,598
最重要的是Instrument

45
00:02:12,366 --> 0:02:15,569
Instruments程序包

46
00:02:15,636 --> 0:02:17,671
从而帮助可视化重要的指标

47
00:02:17,738 --> 0:02:20,207
并在用户遇到问题时

48
00:02:21,074 --> 0:02:22,876
今天我们要讲

49
00:02:22,943 --> 0:02:25,245
如何创建优秀的检测 从里到外

50
00:02:25,512 --> 0:02:28,982
从核心开始讲

51
00:02:29,316 --> 0:02:33,687
然后在跟踪点上创建架构

52
00:02:34,054 --> 0:02:37,658
最后在讲可视化和Instrument UI前

53
00:02:38,625 --> 0:02:42,329
我们今天要按顺序讲追踪、建模

54
00:02:42,796 --> 0:02:46,266
让我们现在开始吧

55
00:02:47,835 --> 0:02:52,072
OSSignpost是2018年

56
00:02:52,472 --> 0:02:56,076
路标分为两种：点事件和区间

57
00:02:56,743 --> 0:02:58,912
现在它们支持在参数中

58
00:02:59,079 --> 0:03:01,882
通过像printf一样的

59
00:02:59,079 --> 0:03:01,882
通过像printf一样的

60
00:03:02,349 --> 0:03:06,220
与printf不同

61
00:03:07,921 --> 0:03:10,657
现在在Swift中

62
00:03:10,724 --> 0:03:13,760
它有三种类型：开始、结束和事件

63
00:03:14,294 --> 0:03:17,965
在C语言中 它们的界面

64
00:03:19,333 --> 0:03:22,870
现在重点是要注意

65
00:03:23,303 --> 0:03:26,006
意思是许多追踪行为和可配置性

66
00:03:26,340 --> 0:03:28,542
都由所提供的日志句柄决定

67
00:03:29,409 --> 0:03:32,145
日志句柄实际上是用于

68
00:03:32,679 --> 0:03:35,682
可以让你指定子系统和类别

69
00:03:36,350 --> 0:03:40,087
以及每个路标的静态名称

70
00:03:40,420 --> 0:03:43,891
这就给追踪点提供了逻辑结构和等级

71
00:03:45,692 --> 0:03:49,062
自定义Instruments创建在

72
00:03:49,596 --> 0:03:50,964
第一 它们是暂时的

73
00:03:52,032 --> 0:03:54,701
所有路标 无论是点事件或区间

74
00:03:55,002 --> 0:03:57,838
都隐含地记录高精度的时间戳

75
00:03:59,773 --> 0:04:00,807
在我们高度并行的世界中

76
00:03:59,773 --> 0:04:00,807
在我们高度并行的世界中

77
00:04:00,874 --> 0:04:03,010
拥有对重叠区间的良好支持

78
00:04:03,076 --> 0:04:04,611
也非常重要

79
00:04:04,778 --> 0:04:07,614
OSSignpost通过路标ID

80
00:04:08,215 --> 0:04:12,186
这为匹配相关事件记录了足够的情境

81
00:04:12,419 --> 0:04:14,021
甚至当开端或结束事件

82
00:04:14,087 --> 0:04:16,890
发生在不同的线程上

83
00:04:18,392 --> 0:04:21,595
OSSignpost的

84
00:04:22,196 --> 0:04:25,165
日志记录机制在设计时考虑到了效率

85
00:04:25,532 --> 0:04:29,503
无论何时当你提交OSSignpost

86
00:04:30,470 --> 0:04:33,040
围绕静态字符串有一些优化

87
00:04:33,207 --> 0:04:35,943
比如格式字符串和路标名称

88
00:04:36,143 --> 0:04:40,080
实际上只是作为

89
00:04:40,747 --> 0:04:43,851
事实上OSSignpost的

90
00:04:44,418 --> 0:04:47,321
在绝大多数情况下

91
00:04:47,821 --> 0:04:50,724
这就是它们对创建工具有用的原因

92
00:04:50,791 --> 0:04:54,528
这些工具除了帮助你解决问题之外

93
00:04:56,096 --> 0:04:57,865
当Instruments

94
00:04:57,931 --> 0:05:01,368
你将获得所有明确的字段

95
00:04:57,931 --> 0:05:01,368
你将获得所有明确的字段

96
00:05:01,802 --> 0:05:04,438
包括那个格式字符串以及

97
00:05:05,172 --> 0:05:07,140
但在Instruments中

98
00:05:07,207 --> 0:05:09,376
所有隐含的字段

99
00:05:09,743 --> 0:05:12,446
比如时间戳或调用线程

100
00:05:12,513 --> 0:05:13,547
这些非常有用

101
00:05:14,548 --> 0:05:17,618
如果你使用启用了回溯的日志句柄

102
00:05:17,985 --> 0:05:22,489
那么还会记录调用栈

103
00:05:24,124 --> 0:05:26,293
当向代码找那个添加追踪时

104
00:05:26,360 --> 0:05:30,430
OSLog和OSSignpost

105
00:05:31,331 --> 0:05:36,870
默认情况下OSLog是…

106
00:05:37,371 --> 0:05:40,674
因此它们仍然是低消耗

107
00:05:41,875 --> 0:05:46,413
当Instruments或

108
00:05:47,848 --> 0:05:50,050
OSLog系统会立即进入流模式

109
00:05:50,117 --> 0:05:51,552
那将会增加一些消耗

110
00:05:53,086 --> 0:05:56,156
然而今年有两个新的动态类别

111
00:05:56,456 --> 0:05:58,458
只有当Instruments

112
00:05:59,493 --> 0:06:01,228
这些动态类别

113
00:05:59,493 --> 0:06:01,228
这些动态类别

114
00:06:01,695 --> 0:06:05,199
用于记录第二个栈追踪

115
00:06:05,365 --> 0:06:07,534
这增加了少许额外的消耗

116
00:06:08,268 --> 0:06:11,438
考虑到这点 OSSignpost

117
00:06:13,006 --> 0:06:16,343
嗯 许多因素都会影响真实的性能

118
00:06:16,610 --> 0:06:18,879
比如设备类型、硬件型号、

119
00:06:19,146 --> 0:06:22,216
OS版本号、系统加载、热处理等等

120
00:06:22,716 --> 0:06:24,318
因此很难给出一个具体的数字

121
00:06:24,852 --> 0:06:27,221
但我想给出一些对数尺度的

122
00:06:27,287 --> 0:06:28,388
数量级近似值

123
00:06:28,689 --> 0:06:31,458
因为我认为理解相对消耗很有用

124
00:06:32,292 --> 0:06:34,361
如果我们在发布版本中看一下路标

125
00:06:35,028 --> 0:06:37,197
所有路标都以不到一微妙的速度记录

126
00:06:37,397 --> 0:06:42,135
新的默认关闭的动态类别实际上处于

127
00:06:43,537 --> 0:06:47,875
当Instruments在延迟

128
00:06:48,609 --> 0:06:50,310
这些动态类别将会开启

129
00:06:50,377 --> 0:06:52,946
以匹配默认为开的类别的行为

130
00:06:53,514 --> 0:06:55,315
并且它们的消耗相同

131
00:06:55,382 --> 0:06:58,051
除动态堆栈类别外

132
00:06:58,218 --> 0:07:00,988
由于动态堆栈记录调用栈

133
00:06:58,218 --> 0:07:00,988
由于动态堆栈记录调用栈

134
00:07:01,288 --> 0:07:02,856
处于毫秒范围内

135
00:07:04,525 --> 0:07:06,260
然而当请求流模式时

136
00:07:06,426 --> 0:07:08,996
所有这些的消耗将明显增加

137
00:07:09,730 --> 0:07:11,532
并进入几十微妙的范围

138
00:07:13,000 --> 0:07:14,101
考虑到这一点

139
00:07:15,702 --> 0:07:19,806
你可以采取什么措施来最小化

140
00:07:20,040 --> 0:07:22,209
如果你担心那个运行时间消耗

141
00:07:22,276 --> 0:07:24,178
或它们开始在配置文件中显示的话

142
00:07:25,479 --> 0:07:27,014
嗯 你可以采取两个很容易的措施

143
00:07:27,447 --> 0:07:31,051
首先你使用Instruments

144
00:07:31,118 --> 0:07:32,152
替换立即模式

145
00:07:32,519 --> 0:07:34,788
这可以避免OSSignpost

146
00:07:35,255 --> 0:07:36,456
并减少消耗

147
00:07:36,623 --> 0:07:38,325
配置模板 当你打开模板时

148
00:07:38,525 --> 0:07:40,861
以其中一种模式进行记录

149
00:07:43,463 --> 0:07:46,633
同时如果你使用新的动态追踪类别

150
00:07:46,867 --> 0:07:49,803
这是一种在不记录时

151
00:07:50,070 --> 0:07:53,974
因为路标默认为关闭

152
00:07:54,708 --> 0:07:56,810
只有自定义Instruments

153
00:07:56,877 --> 0:08:00,180
因此这个数据也不会在内置的

154
00:07:56,877 --> 0:08:00,180
因此这个数据也不会在内置的

155
00:08:02,416 --> 0:08:05,085
那么作为框架或子系统的作者

156
00:08:05,152 --> 0:08:08,555
当你分析时到底提交多少路标

157
00:08:09,122 --> 0:08:10,090
嗯 你可以提交许多

158
00:08:10,157 --> 0:08:14,127
但让我们假定一个非常保守的目标

159
00:08:14,361 --> 0:08:16,797
当你分析时

160
00:08:17,531 --> 0:08:19,800
然后让我们假定

161
00:08:20,267 --> 0:08:22,202
路标的大概消耗是

162
00:08:22,269 --> 0:08:25,372
每启用一个路标需要大约半微妙

163
00:08:26,440 --> 0:08:29,443
那等同于每秒启用20000个路标

164
00:08:30,244 --> 0:08:32,446
即使是在iPad Pro上的

165
00:08:32,513 --> 0:08:35,448
以每秒120帧的速度运行

166
00:08:36,015 --> 0:08:39,119
这仍然足够使帧之间有83个区间

167
00:08:40,587 --> 0:08:46,693
再一次 真实性能会发生改变

168
00:08:47,094 --> 0:08:50,564
重点是要记住路标是一个共享资源

169
00:08:51,865 --> 0:08:54,234
你用得越多

170
00:08:54,635 --> 0:08:58,105
那就是说它们可以执行这种

171
00:08:58,172 --> 0:09:00,474
并且有时候非常有用

172
00:08:58,172 --> 0:09:00,474
并且有时候非常有用

173
00:09:00,941 --> 0:09:03,911
有时候它们对于查找你代码中的

174
00:09:04,244 --> 0:09:06,213
或排序问题非常关键

175
00:09:07,281 --> 0:09:10,150
然而请记住 你可能想根据不同用户

176
00:09:10,450 --> 0:09:12,819
把路标分离到不同类别中

177
00:09:13,353 --> 0:09:15,889
很可能你框架的客户

178
00:09:15,956 --> 0:09:18,458
不像框架的贡献者那样

179
00:09:18,792 --> 0:09:21,161
客户可能需要追踪更多的实施细节

180
00:09:22,296 --> 0:09:25,399
如果你把追踪点分到

181
00:09:25,766 --> 0:09:28,535
这将使你的工具只能启用必要的子集

182
00:09:30,270 --> 0:09:32,239
因为追踪是检测的基础

183
00:09:32,306 --> 0:09:34,308
我想快速讲四个最佳实践

184
00:09:36,243 --> 0:09:40,647
第一个也是最重要的一个

185
00:09:41,281 --> 0:09:42,783
这对于正确性来说至关重要

186
00:09:43,450 --> 0:09:45,319
永久开启的区间

187
00:09:45,385 --> 0:09:47,454
真会降低Instruments的

188
00:09:48,388 --> 0:09:51,258
在这个例子中

189
00:09:51,325 --> 0:09:55,662
包装了一段消耗大

190
00:09:56,396 --> 0:09:58,832
问题是如果出现报错

191
00:09:58,999 --> 0:10:03,670
控制流将跳到捕捉范围

192
00:09:58,999 --> 0:10:03,670
控制流将跳到捕捉范围

193
00:10:05,038 --> 0:10:07,841
现在Swift的延迟状态

194
00:10:07,908 --> 0:10:11,845
确保无论提前返回或出现报错

195
00:10:13,547 --> 0:10:16,183
当我们提交当前范围时

196
00:10:16,250 --> 0:10:17,484
仍会调用那个

197
00:10:19,186 --> 0:10:20,521
第二 为了效率

198
00:10:20,854 --> 0:10:25,125
请避免在开始和结束追踪点中

199
00:10:25,292 --> 0:10:27,194
当数据可用时

200
00:10:27,895 --> 0:10:29,396
这就避免了重复工作

201
00:10:29,796 --> 0:10:32,132
并尽快给

202
00:10:32,766 --> 0:10:38,071
在这个例子中 我们不需要重复

203
00:10:39,206 --> 0:10:43,877
我们不使用请求编号来匹配

204
00:10:44,845 --> 0:10:47,181
这些追踪点实际上可以用来

205
00:10:47,748 --> 0:10:51,952
给每个区间对的日志句柄

206
00:10:53,420 --> 0:10:58,492
第三 当没启用路标时避免做

207
00:10:59,359 --> 0:11:02,696
如果你的日志句柄需要使用其中一个

208
00:10:59,359 --> 0:11:02,696
如果你的日志句柄需要使用其中一个

209
00:11:02,996 --> 0:11:05,032
那么路标启用属性将表明

210
00:11:05,098 --> 0:11:06,934
无论Instruments

211
00:11:07,267 --> 0:11:08,902
意思是

212
00:11:09,102 --> 0:11:14,975
把消耗大的数据的计算放在那个

213
00:11:17,211 --> 0:11:20,647
第四 其实对于你的工具而言

214
00:11:21,448 --> 0:11:23,550
思考一下你的Guard

215
00:11:23,951 --> 0:11:25,686
因为有时你想追踪这些

216
00:11:25,752 --> 0:11:27,120
以包含短区间

217
00:11:27,754 --> 0:11:29,456
比如 如果你有一个方法

218
00:11:29,756 --> 0:11:32,893
你想了解缓存命中和缓存缺失

219
00:11:33,660 --> 0:11:36,496
但其它时候

220
00:11:36,864 --> 0:11:38,332
对于这些情况而言

221
00:11:38,732 --> 0:11:41,969
请考虑把路标移到预处理之后

222
00:11:42,236 --> 0:11:45,806
从而减少

223
00:11:46,840 --> 0:11:49,376
现在了解了这些技巧

224
00:11:49,643 --> 0:11:51,445
追踪点确实是你在追踪点上

225
00:11:51,678 --> 0:11:53,347
创建的所有工具的基础

226
00:11:53,747 --> 0:11:56,550
并且绝大多数时候

227
00:11:56,917 --> 0:11:58,685
因此这也是为什么考虑追踪点的

228
00:11:58,886 --> 0:12:01,188
非常重要的原因

229
00:11:58,886 --> 0:12:01,188
非常重要的原因

230
00:12:01,889 --> 0:12:03,190
因为它们处于核心中

231
00:12:03,557 --> 0:12:04,992
路标调用的变更

232
00:12:05,058 --> 0:12:07,828
可能会导致需要修改

233
00:12:09,429 --> 0:12:10,998
因此请保持追踪点的稳定

234
00:12:11,498 --> 0:12:13,400
避免追踪实施细节

235
00:12:13,734 --> 0:12:18,038
如果可能 请尽可能接近API层

236
00:12:19,039 --> 0:12:21,708
现在在代码基中四处移动追踪点

237
00:12:22,042 --> 0:12:24,144
你不必担心诸如内联之类的

238
00:12:24,211 --> 0:12:25,779
那可能会替你进行此类优化

239
00:12:26,813 --> 0:12:30,284
你需要确保不要修改

240
00:12:30,651 --> 0:12:32,085
静态字符串

241
00:12:32,352 --> 0:12:36,456
我的意思是特别是子系统、类别、

242
00:12:37,090 --> 0:12:39,626
路标名称或格式字符串

243
00:12:40,027 --> 0:12:41,161
如果你修改了其中任意一个

244
00:12:41,228 --> 0:12:43,597
你要记得更新

245
00:12:45,132 --> 0:12:47,801
接下来让我们讲一下建模

246
00:12:48,168 --> 0:12:51,171
以及向Instruments内的

247
00:12:53,106 --> 0:12:56,443
Instruments的架构基于

248
00:12:56,877 --> 0:12:59,179
模式决定那些表的结构

249
00:12:59,246 --> 0:13:01,381
这些都是由Instruments

250
00:12:59,246 --> 0:13:01,381
这些都是由Instruments

251
00:13:02,249 --> 0:13:04,952
要更深入地了解

252
00:13:05,252 --> 0:13:08,555
我推荐你参看2018年的创建

253
00:13:08,889 --> 0:13:11,024
然而现在让我们看一下

254
00:13:11,091 --> 0:13:13,026
建模在哪里创建分析体验

255
00:13:14,328 --> 0:13:16,496
在左侧我们有OSSignpost

256
00:13:16,563 --> 0:13:19,399
它是Instruments记录的

257
00:13:20,033 --> 0:13:21,635
表中所填充的数据

258
00:13:21,835 --> 0:13:24,571
有预定义的模式可以在自定义

259
00:13:26,073 --> 0:13:27,908
建模在中间 是下一个阶段

260
00:13:27,975 --> 0:13:31,078
建模器从一个或多个输入表中

261
00:13:31,378 --> 0:13:34,381
对数据进行推理 然后把数据提交给

262
00:13:34,448 --> 0:13:37,050
你指定的一个或多个输出表

263
00:13:38,085 --> 0:13:40,754
建模器是特定域逻辑所在的地方

264
00:13:41,121 --> 0:13:43,056
输出表的模式

265
00:13:43,423 --> 0:13:47,694
用于指定在数据中应用哪种

266
00:13:49,363 --> 0:13:51,298
右侧是最后一步即可视化

267
00:13:51,798 --> 0:13:55,035
可视化用于在XML中描述

268
00:13:55,435 --> 0:13:58,005
你可以在这里指定

269
00:13:58,071 --> 0:13:59,406
显示数据和如何用图表显示数据

270
00:13:59,840 --> 0:14:02,509
比如给哪一栏绘图并用作值

271
00:13:59,840 --> 0:14:02,509
比如给哪一栏绘图并用作值

272
00:14:02,743 --> 0:14:04,611
或哪一栏用作彩色标签

273
00:14:05,779 --> 0:14:07,814
因为所有的自定义

274
00:14:07,881 --> 0:14:10,884
都基于你的模式

275
00:14:11,451 --> 0:14:13,353
因此下边这个过程非常重要

276
00:14:13,420 --> 0:14:16,423
检查OSSignpost

277
00:14:16,924 --> 0:14:20,394
然后了解如何把这个数据

278
00:14:22,996 --> 0:14:25,766
因此自定义Instrument中

279
00:14:25,832 --> 0:14:28,168
表以一种或两种方式处理数据

280
00:14:28,769 --> 0:14:30,704
点模式有一个时间戳栏

281
00:14:31,471 --> 0:14:34,942
而区间模式既有时间戳栏

282
00:14:35,642 --> 0:14:39,146
这意味着你需要定义至少一个

283
00:14:39,546 --> 0:14:41,682
然后把命名和类型提供给其余的栏

284
00:14:42,850 --> 0:14:45,619
现在通过建模规则填充数据

285
00:14:46,186 --> 0:14:47,588
建模规则操纵的是输入数据

286
00:14:47,654 --> 0:14:49,857
这些规则在CLIPS

287
00:14:50,390 --> 0:14:54,194
好消息是Instruments

288
00:14:54,628 --> 0:14:56,096
可以自动生成建模器

289
00:14:56,430 --> 0:14:59,399
因此你不需要编写CLIPS代码

290
00:15:00,868 --> 0:15:02,469
事实上 如果你刚开始编写

291
00:15:02,536 --> 0:15:04,171
并且你想确保数据的准确性

292
00:15:04,505 --> 0:15:07,608
Instruments在库中提供一个内置

293
00:15:08,008 --> 0:15:09,877
对于记录和检查

294
00:15:09,943 --> 0:15:12,646
OSSignpost区间看起来

295
00:15:13,247 --> 0:15:16,650
检查器可以帮助你验证原生数据

296
00:15:18,085 --> 0:15:19,219
一旦你检查了数据

297
00:15:19,586 --> 0:15:21,021
一个新的

298
00:15:21,522 --> 0:15:23,457
是开始创建你自己的工具的好方法

299
00:15:24,024 --> 0:15:27,594
通过Xcode针对自定义

300
00:15:27,828 --> 0:15:29,630
你距离在库中拥有

301
00:15:29,963 --> 0:15:32,566
自动建模器和Instrument

302
00:15:33,133 --> 0:15:35,536
要了解这一切的最佳方式是通过演示

303
00:15:35,602 --> 0:15:37,838
为此 我要邀请我同事

304
00:15:44,611 --> 0:15:46,380
谢谢Daniel 大家好

305
00:15:48,749 --> 0:15:50,784
我们在Mac上的

306
00:15:50,851 --> 0:15:53,887
用于处理大量关于星球、

307
00:15:54,288 --> 0:15:56,523
图片、视频和二进制的数据

308
00:15:57,057 --> 0:15:58,926
为了优化它的磁盘使用情况

309
00:15:59,092 --> 0:16:01,228
我创建了一个框架叫做

310
00:15:59,092 --> 0:16:01,228
我创建了一个框架叫做

311
00:16:01,461 --> 0:16:03,163
使用路标的压缩库

312
00:16:03,363 --> 0:16:06,233
有效地从磁盘中编码和解码数据

313
00:16:07,100 --> 0:16:09,670
现在我想给我的框架创建检查

314
00:16:09,870 --> 0:16:11,972
给未来用户提供一些数据

315
00:16:12,973 --> 0:16:16,143
我们有两个概念值得追踪

316
00:16:16,777 --> 0:16:20,848
首先CompressionManager

317
00:16:21,415 --> 0:16:23,183
可以通过许多通道创建它

318
00:16:23,350 --> 0:16:26,453
指定可以同时执行多少任务

319
00:16:27,554 --> 0:16:29,223
第二 我想通过捕捉压缩速率

320
00:16:29,289 --> 0:16:32,793
衡量对特定文件类型和算法的

321
00:16:33,026 --> 0:16:34,528
压缩性能

322
00:16:35,229 --> 0:16:36,430
通过检查这些

323
00:16:36,496 --> 0:16:39,299
用户可以决定是否值得压缩数据

324
00:16:40,434 --> 0:16:43,303
我编写了区间

325
00:16:43,370 --> 0:16:44,738
表达框架的这个概念

326
00:16:45,005 --> 0:16:47,875
让我们进入CompressionManager

327
00:16:49,610 --> 0:16:51,311
首先让我们看一下日志句柄

328
00:16:51,712 --> 0:16:55,582
我的日志句柄把我框架的

329
00:16:55,883 --> 0:16:57,551
并把我的类名称指定为类别

330
00:16:59,520 --> 0:17:00,721
压缩和解压

331
00:16:59,520 --> 0:17:00,721
压缩和解压

332
00:17:00,787 --> 0:17:03,557
是压缩管理器的公共界面的一部分

333
00:17:04,558 --> 0:17:07,560
它们一开始都创建压缩工作项实例

334
00:17:07,627 --> 0:17:10,497
压缩有关特定压缩任务的信息

335
00:17:11,164 --> 0:17:14,201
接下来它们调用私有的

336
00:17:15,736 --> 0:17:18,105
因为压缩通道可能非常繁忙

337
00:17:18,305 --> 0:17:21,775
在通道上创建压缩项

338
00:17:21,942 --> 0:17:23,343
可能有很长的时间间隔

339
00:17:23,777 --> 0:17:26,246
这是开始测量这种延迟的完美场所

340
00:17:27,181 --> 0:17:29,783
我们要通过调用

341
00:17:30,083 --> 0:17:31,685
以CompressionItemWait

342
00:17:32,986 --> 0:17:35,222
接下来我们在这里使用

343
00:17:35,389 --> 0:17:39,026
在我们继续进一步之前

344
00:17:39,860 --> 0:17:42,930
根据Daniel的建议

345
00:17:43,096 --> 0:17:45,365
从而确保我的区间总是处于关闭状态

346
00:17:47,367 --> 0:17:49,670
接下来我们有

347
00:17:49,937 --> 0:17:53,507
当压缩任务已经准备好在通道上

348
00:17:54,641 --> 0:17:57,811
起初 我们需要给那个项指出

349
00:17:58,078 --> 0:18:01,548
通过调用以与之前名称相同的名称

350
00:17:58,078 --> 0:18:01,548
通过调用以与之前名称相同的名称

351
00:18:03,150 --> 0:18:05,485
接下来我们用

352
00:18:05,686 --> 0:18:07,454
表明压缩的开端

353
00:18:08,188 --> 0:18:10,891
在元数据中 我们有诸如此类的东西

354
00:18:10,958 --> 0:18:14,528
某种操作、关于源目的地的信息、

355
00:18:14,595 --> 0:18:17,297
通道和调用线程

356
00:18:18,398 --> 0:18:22,836
正如我们之前所了解的

357
00:18:23,003 --> 0:18:26,240
包括线程 因此你现在移除线程

358
00:18:31,378 --> 0:18:33,213
接下来我们创建目的地文件

359
00:18:33,714 --> 0:18:37,384
并同步执行压缩操作

360
00:18:37,951 --> 0:18:41,889
完成后 我们把它记录下来

361
00:18:42,556 --> 0:18:45,592
这是我可以改善路标调用的

362
00:18:45,959 --> 0:18:49,763
这里的StartCompressionMethod

363
00:18:50,264 --> 0:18:51,698
如果它确实产生了报错

364
00:18:52,065 --> 0:18:54,168
将不会调用这里的路标调用

365
00:18:55,002 --> 0:18:56,336
为了防止这种情况发生

366
00:18:56,403 --> 0:18:58,639
我可以在这里引入延迟代码块

367
00:19:00,741 --> 0:19:04,912
并移动我的代码

368
00:19:07,581 --> 0:19:12,286
让我们使用Xcode的Profile动作

369
00:19:19,359 --> 0:19:20,894
让我们从一个空的模板开始

370
00:19:22,729 --> 0:19:24,965
给它添加我们的

371
00:19:26,800 --> 0:19:28,769
并只做几秒钟的记录

372
00:19:32,306 --> 0:19:33,574
我们现在可以检验数据

373
00:19:33,974 --> 0:19:38,545
我展开路标instrument查看

374
00:19:40,247 --> 0:19:41,882
这是我们的那个

375
00:19:42,249 --> 0:19:45,853
我可以进一步展开它

376
00:19:46,987 --> 0:19:51,558
我可用Control-Z重新调整

377
00:19:52,860 --> 0:19:55,495
让我们捏合以放大

378
00:19:57,397 --> 0:20:00,567
顶部有全部的压缩执行路标

379
00:19:57,397 --> 0:20:00,567
顶部有全部的压缩执行路标

380
00:20:01,368 --> 0:20:03,170
底部有等待执行的任务的

381
00:20:03,237 --> 0:20:04,471
全部区间

382
00:20:04,972 --> 0:20:07,174
在这里我们可以注意到一些模式

383
00:20:08,475 --> 0:20:11,678
比如一次最多执行两个任务

384
00:20:12,379 --> 0:20:15,616
因此很可能app代码使用了两个

385
00:20:16,850 --> 0:20:19,553
同时我们可以看到一些尖峰

386
00:20:19,920 --> 0:20:23,123
那表明有许多任务等待被压缩

387
00:20:25,392 --> 0:20:29,296
OSSignpost是用于分析

388
00:20:29,496 --> 0:20:31,498
但通常不能给框架的用户

389
00:20:31,899 --> 0:20:34,067
提供足够的分析情境

390
00:20:35,002 --> 0:20:36,170
为了改善这个功能

391
00:20:36,236 --> 0:20:41,441
我创建了使用自定义Instruments的

392
00:20:42,376 --> 0:20:45,679
通过把这两个路标放到

393
00:20:45,746 --> 0:20:49,850
并调整符合工具标准的UI

394
00:20:50,250 --> 0:20:52,953
现在让我们打开包含这个

395
00:20:58,825 --> 0:21:01,562
在底部我们看到全部等待执行的任务

396
00:20:58,825 --> 0:21:01,562
在底部我们看到全部等待执行的任务

397
00:21:01,628 --> 0:21:04,364
它们的呈现方式与OSSignpost

398
00:21:07,234 --> 0:21:10,003
在顶部我们看到全部执行区间

399
00:21:10,204 --> 0:21:11,638
现在由通道分离开

400
00:21:11,805 --> 0:21:14,708
因此我们确实可以看到

401
00:21:16,176 --> 0:21:19,313
在这底部 我看到全部的压缩任务

402
00:21:19,479 --> 0:21:21,982
附带区间信息、源路径、

403
00:21:22,249 --> 0:21:24,785
文件尺寸、压缩速率等等

404
00:21:25,752 --> 0:21:27,588
有一个任务引起了我的注意

405
00:21:27,855 --> 0:21:30,190
这个任务很长 并且以红色显示

406
00:21:30,591 --> 0:21:33,126
那意味着这个任务的压缩速率很慢

407
00:21:34,628 --> 0:21:36,196
为了方便地了解它是哪种任务

408
00:21:36,430 --> 0:21:38,298
我可以切换到活跃的任务详情

409
00:21:38,966 --> 0:21:43,470
它只用于显示与我的检查头

410
00:21:44,204 --> 0:21:47,274
我可以移动我的检查头

411
00:21:48,709 --> 0:21:51,178
看起来我们正在尝试压缩zip存档

412
00:21:51,778 --> 0:21:55,048
文件尺寸缩减了百分之一点多

413
00:21:55,549 --> 0:21:58,385
这并没有缩减很多

414
00:22:00,487 --> 0:22:02,689
接下来让我们看一下任务概要详情

415
00:22:02,756 --> 0:22:04,825
这里汇总了全部压缩任务

416
00:22:05,225 --> 0:22:07,427
它提供三种汇总等级

417
00:22:07,661 --> 0:22:11,098
压缩、源扩展和算法

418
00:22:12,266 --> 0:22:14,835
在右侧我们看到不同的统计信息

419
00:22:14,902 --> 0:22:19,640
比如平均压缩速率、持续时间

420
00:22:20,507 --> 0:22:24,111
这些详情对于比较不同的算法

421
00:22:24,278 --> 0:22:27,848
或查看不同文件类型的压缩速率

422
00:22:28,682 --> 0:22:31,652
比如我们可以看到我们的JPEG

423
00:22:31,985 --> 0:22:35,455
平均缩减了34%

424
00:22:35,522 --> 0:22:38,058
这对于已经严重压缩的文件来说

425
00:22:39,660 --> 0:22:43,363
现在让我们看一下

426
00:22:47,167 --> 0:22:51,538
我们在这边有

427
00:22:51,905 --> 0:22:54,975
它查看…所有的开始和结束事件

428
00:22:56,276 --> 0:22:58,912
我们还有两个路标的表

429
00:23:00,514 --> 0:23:02,216
这是我们的执行表

430
00:23:02,549 --> 0:23:05,118
它包含我们所记录的与任务有关的

431
00:23:05,552 --> 0:23:09,189
但现在它是根据我们所分配的

432
00:23:11,358 --> 0:23:15,863
在右侧我们可以看到

433
00:23:19,333 --> 0:23:21,301
目前我对我的工具非常满意

434
00:23:21,935 --> 0:23:25,706
我要改善一件事

435
00:23:26,440 --> 0:23:28,275
我不想查看特定区间

436
00:23:28,542 --> 0:23:30,844
我想通过某种方式把它们汇总起来

437
00:23:31,211 --> 0:23:33,614
清晰地指出负载较高的区域

438
00:23:34,348 --> 0:23:36,750
我认为Daniel

439
00:23:37,384 --> 0:23:38,218
Daniel？

440
00:23:46,260 --> 0:23:47,094
谢谢Kacper

441
00:23:47,427 --> 0:23:50,063
正如Kacper所展示的那样

442
00:23:50,430 --> 0:23:53,433
和Inspector

443
00:23:53,800 --> 0:23:56,103
检查Instrument确实

444
00:23:57,104 --> 0:23:59,973
甚至不需要编写自定义

445
00:24:00,240 --> 0:24:01,909
Kacper就能创建一个工具

446
00:24:01,975 --> 0:24:04,111
从而以更有意义的方式呈现他的数据

447
00:24:04,344 --> 0:24:06,680
通过使用他的框架的压缩概念实现

448
00:24:07,014 --> 0:24:11,485
只使用了四个追踪点和两个

449
00:24:12,286 --> 0:24:14,821
意思是那并不完全是

450
00:24:14,888 --> 0:24:15,923
他想要创建的分析体验

451
00:24:17,024 --> 0:24:20,394
现在自定义建模器

452
00:24:20,761 --> 0:24:23,530
它们可以让你融合

453
00:24:23,597 --> 0:24:25,365
甚至可以使用来自内嵌表的数据

454
00:24:25,899 --> 0:24:28,335
它们可以让你嵌入更复杂的逻辑

455
00:24:28,702 --> 0:24:32,005
以维持状态 并对事件顺序进行推理

456
00:24:32,840 --> 0:24:34,908
编写你自己的自定义建模器

457
00:24:34,975 --> 0:24:38,645
对于某些自定义程度较高的绘图

458
00:24:39,146 --> 0:24:42,115
点模式、区间模式和建模器标签

459
00:24:42,182 --> 0:24:43,483
是开始自定义建模器的好方式

460
00:24:43,917 --> 0:24:46,286
但这是一个很深的话题

461
00:24:46,787 --> 0:24:48,322
要获取更多关于自定义建模的信息

462
00:24:48,589 --> 0:24:51,158
请参看2019年的建模和

463
00:24:51,425 --> 0:24:53,894
更深入地讲了具体信息

464
00:24:54,995 --> 0:24:57,698
让我们继续讲分析体验的UI部分

465
00:24:58,131 --> 0:25:01,134
可视化

466
00:24:58,131 --> 0:25:01,134
可视化

467
00:25:02,402 --> 0:25:05,606
可视化是关于你作为作者

468
00:25:05,973 --> 0:25:08,408
向使用你代码的开发人员

469
00:25:09,209 --> 0:25:10,944
最重要的准则是要记住

470
00:25:11,578 --> 0:25:14,381
数据与故事不一样

471
00:25:15,148 --> 0:25:19,152
如Kacper所展示的 通过查看

472
00:25:19,686 --> 0:25:22,489
原生区间只擅长向它们的作者

473
00:25:23,290 --> 0:25:26,093
使用你的工具的用户不会直观地了解

474
00:25:26,159 --> 0:25:29,363
时间线中的某个空缺是好还是坏

475
00:25:29,796 --> 0:25:32,666
或下一个处理阶段是什么

476
00:25:33,567 --> 0:25:35,269
作为Instruments

477
00:25:35,569 --> 0:25:36,703
你应该不只是

478
00:25:36,904 --> 0:25:39,473
创建显示发生了什么的可视化信息

479
00:25:39,873 --> 0:25:41,408
你要教学和诊断

480
00:25:41,842 --> 0:25:44,478
你要帮助用户查找问题

481
00:25:46,013 --> 0:25:48,048
并且可视化也不只是与图表有关

482
00:25:48,448 --> 0:25:50,584
有时候沟通问题的最好方式是

483
00:25:51,018 --> 0:25:52,886
使用正确的统计数据集

484
00:25:52,953 --> 0:25:57,124
或使用精心编写的文本叙述

485
00:25:58,725 --> 0:26:00,894
然而图表如此重要的原因是

486
00:25:58,725 --> 0:26:00,894
然而图表如此重要的原因是

487
00:26:01,161 --> 0:26:03,497
绝大部分情况下 图表是用户的起点

488
00:26:03,830 --> 0:26:05,566
这是你的故事书的第一页

489
00:26:06,867 --> 0:26:09,837
可视化应该帮助其他人学习、

490
00:26:10,137 --> 0:26:13,707
而自私的动机是

491
00:26:14,241 --> 0:26:17,344
这是可视化的目标 让问题变得明显

492
00:26:17,945 --> 0:26:20,047
图表是你将看到的第一个汇总

493
00:26:20,113 --> 0:26:22,182
它们应该把你的目光吸引到

494
00:26:22,583 --> 0:26:24,251
一旦你开始深入了解

495
00:26:24,418 --> 0:26:26,153
你的代码应该围绕

496
00:26:26,587 --> 0:26:29,056
详情视图和指标那些核心概念

497
00:26:29,923 --> 0:26:33,193
因为Instruments

498
00:26:33,260 --> 0:26:36,396
点和区间 我想讲一下

499
00:26:38,398 --> 0:26:41,568
汇总点事件有助于评估它们的重要性

500
00:26:42,035 --> 0:26:43,704
如果它们全都相对相等

501
00:26:43,971 --> 0:26:46,039
那么在时间线上

502
00:26:46,106 --> 0:26:48,275
显示事件密度的一个不错的方式是

503
00:26:49,009 --> 0:26:51,378
快速扫一眼就能立即看到较高的柱子

504
00:26:51,445 --> 0:26:53,013
你就知道从哪里开始看

505
00:26:53,380 --> 0:26:54,515
对于自定义Instruments

506
00:26:54,581 --> 0:26:56,416
自定义图表行为非常容易

507
00:26:57,017 --> 0:27:00,354
柱形图元素可以让你指定

508
00:26:57,017 --> 0:27:00,354
柱形图元素可以让你指定

509
00:27:00,954 --> 0:27:02,589
有一个最适合分辨率元素

510
00:27:02,923 --> 0:27:05,192
可以让你在用户缩小时使用柱形图

511
00:27:05,592 --> 0:27:08,362
然后当用户放大时

512
00:27:08,428 --> 0:27:09,463
交换单一事件的细节

513
00:27:11,999 --> 0:27:14,902
当点事件的重要性发生变化时

514
00:27:15,202 --> 0:27:18,272
有时候对为重大事件开辟一条道路

515
00:27:19,907 --> 0:27:23,310
多个图表和详情视图

516
00:27:23,777 --> 0:27:25,279
从而指定最顶级的

517
00:27:25,579 --> 0:27:28,615
意思就是给

518
00:27:28,682 --> 0:27:30,384
如何从表中选择要显示哪些值

519
00:27:31,084 --> 0:27:33,654
现在这两个功能都能完全

520
00:27:33,887 --> 0:27:35,088
而不需要自定义建模器

521
00:27:37,491 --> 0:27:39,760
表格式汇总点数据或区间数据

522
00:27:40,027 --> 0:27:42,763
你可以定义哪些指标是重要指标

523
00:27:43,430 --> 0:27:45,132
通过汇总的详情视图

524
00:27:45,199 --> 0:27:48,635
有用于结合值的函数

525
00:27:49,002 --> 0:27:50,170
如Min、Max、Average

526
00:27:50,737 --> 0:27:52,940
新用户可以查看你所提供的汇总

527
00:27:53,607 --> 0:27:56,009
从而了解哪些重要

528
00:27:56,176 --> 0:27:57,377
以及要对哪些进行优化

529
00:27:57,911 --> 0:27:59,346
即使是显示属性也很重要

530
00:27:59,413 --> 0:28:01,782
比如栏的标题是什么

531
00:27:59,413 --> 0:28:01,782
比如栏的标题是什么

532
00:28:01,849 --> 0:28:04,017
或它们的显示顺序

533
00:28:05,819 --> 0:28:07,988
现在当用户深入查看详情时

534
00:28:08,322 --> 0:28:11,959
叙述类型是用于解释正在发生什么的

535
00:28:12,526 --> 0:28:15,929
它可以让你使用自然语言

536
00:28:16,129 --> 0:28:19,132
以一种易理解的方式解释

537
00:28:20,000 --> 0:28:22,402
这些视图可以很好地告诉用户

538
00:28:22,569 --> 0:28:24,538
预期应该发生什么但却没有发生

539
00:28:25,072 --> 0:28:27,074
或当某些有意思的事情发生时

540
00:28:27,140 --> 0:28:28,775
他们可能想进一步调查

541
00:28:30,177 --> 0:28:32,546
因此绘制区间数据可能有点棘手

542
00:28:33,680 --> 0:28:37,551
跟点不一样 区间因为重叠的原因

543
00:28:37,618 --> 0:28:38,452
并不总是位于单一垂直空间内

544
00:28:39,186 --> 0:28:43,223
如果你可以规划固定的或有限制的

545
00:28:43,524 --> 0:28:47,427
有两种方式可以将一条垂直的栏

546
00:28:48,295 --> 0:28:50,664
限制绘制用于把栏分成

547
00:28:50,731 --> 0:28:52,499
使用一个标题的多个空间

548
00:28:53,166 --> 0:28:57,037
而实例绘制用于给每个空间

549
00:28:57,938 --> 0:28:59,339
现在OSSignpost工具

550
00:28:59,740 --> 0:29:01,308
结合使用这些技术

551
00:28:59,740 --> 0:29:01,308
结合使用这些技术

552
00:29:01,375 --> 0:29:03,977
但只有当要显示的重叠区间的数量

553
00:29:04,044 --> 0:29:05,546
为有限数量时才能用

554
00:29:06,346 --> 0:29:07,281
当有许多等级时

555
00:29:08,081 --> 0:29:11,518
你可能要采用Instruments 11

556
00:29:12,452 --> 0:29:15,355
把追踪数据分离到嵌套的追踪中

557
00:29:15,422 --> 0:29:19,092
使其易于过滤、查找

558
00:29:19,726 --> 0:29:22,296
特别是当图表情境的数量特别多时

559
00:29:23,163 --> 0:29:25,532
但无论你是否提供追踪等级

560
00:29:25,599 --> 0:29:28,368
规划汇总区间数据都很重要

561
00:29:28,802 --> 0:29:31,038
要么是在每一个等级上都进行汇总

562
00:29:31,505 --> 0:29:33,307
要么是作为你的

563
00:29:35,542 --> 0:29:36,777
对于简单的区间数据

564
00:29:36,844 --> 0:29:39,580
可以尝试应用与点相同的方案

565
00:29:40,013 --> 0:29:41,315
即使用柱形图元素

566
00:29:42,349 --> 0:29:44,518
然而只有当你拥有短区间时

567
00:29:44,585 --> 0:29:47,421
因为柱形图元素按开始时间进行汇总

568
00:29:48,288 --> 0:29:51,225
对于较长的区间

569
00:29:51,658 --> 0:29:53,427
并且它会产生非常大的值

570
00:29:54,795 --> 0:29:58,365
更重要的是 当绘制拥有持续时间的

571
00:29:58,765 --> 0:30:02,536
请不要在Y轴绘制时间

572
00:29:58,765 --> 0:30:02,536
请不要在Y轴绘制时间

573
00:30:03,403 --> 0:30:05,506
诸如利用率百分比这样的指标

574
00:30:05,572 --> 0:30:06,874
对于显示这种数据较好

575
00:30:08,709 --> 0:30:10,644
在更实际的使用中

576
00:30:10,711 --> 0:30:12,012
区间总是发生更多的重叠

577
00:30:12,346 --> 0:30:15,782
因此我想演示三个例子

578
00:30:15,949 --> 0:30:17,618
以及在你的框架中所呈现的概念

579
00:30:17,684 --> 0:30:19,786
和你想要的使用模式

580
00:30:20,354 --> 0:30:23,757
如何影响你的表模式

581
00:30:25,459 --> 0:30:29,963
对于某些情境

582
00:30:30,597 --> 0:30:31,632
对于这种数据

583
00:30:31,698 --> 0:30:34,101
使用限定平均载荷

584
00:30:34,701 --> 0:30:36,270
甚至会突显某些极端值

585
00:30:37,304 --> 0:30:38,572
CLIPS建模器

586
00:30:38,805 --> 0:30:41,241
和Instruments

587
00:30:41,575 --> 0:30:44,178
因此结合那个

588
00:30:44,244 --> 0:30:46,513
通过来自区间计时器标签的输入

589
00:30:47,080 --> 0:30:48,982
当计时器信号到达时

590
00:30:49,049 --> 0:30:52,052
建模器可以计算并提交

591
00:30:52,920 --> 0:30:55,923
建模器的输出表看起来可能像这样

592
00:30:55,989 --> 0:30:59,393
只表达了四栏数据

593
00:30:59,960 --> 0:31:03,297
包括一个决定图表的值的利用率栏

594
00:30:59,960 --> 0:31:03,297
包括一个决定图表的值的利用率栏

595
00:31:03,830 --> 0:31:06,099
以及决定显示颜色的严重性栏

596
00:31:08,335 --> 0:31:09,436
对于其它情境

597
00:31:09,503 --> 0:31:11,872
许多快速运行的区间可能更重要

598
00:31:11,939 --> 0:31:14,341
因为它们可以表达

599
00:31:15,242 --> 0:31:17,644
查看与上一个示例中同样的数据

600
00:31:17,945 --> 0:31:21,081
好的图表可能基于建模器计数

601
00:31:21,148 --> 0:31:24,251
在特定时段内所看到的

602
00:31:25,519 --> 0:31:28,355
建模器的输出表与上一个

603
00:31:29,089 --> 0:31:33,460
但用户的注意力立即就被吸引到

604
00:31:33,827 --> 0:31:34,795
有助于放大

605
00:31:34,862 --> 0:31:36,730
并调查导致这些区间短的原因

606
00:31:38,532 --> 0:31:40,167
前两个示例

607
00:31:40,367 --> 0:31:42,769
都以10毫秒分组汇总数据

608
00:31:43,203 --> 0:31:46,273
但如果某个重叠时段

609
00:31:46,340 --> 0:31:50,410
对于区分一个、两个或更多并存区间

610
00:31:51,445 --> 0:31:53,780
嗯 我们不根据时间量化

611
00:31:54,214 --> 0:31:57,784
按重叠度进行分类的图表会更有帮助

612
00:31:57,985 --> 0:32:01,221
并显示具体的持续时间

613
00:31:57,985 --> 0:32:01,221
并显示具体的持续时间

614
00:32:03,190 --> 0:32:06,226
建模器只追踪

615
00:32:06,627 --> 0:32:09,329
可以输出一个额外的表

616
00:32:10,397 --> 0:32:14,034
这一次 可以通过可变的持续时间

617
00:32:14,201 --> 0:32:16,136
还有一个描述栏作为标签使用

618
00:32:17,538 --> 0:32:19,640
这三个只是示例

619
00:32:20,007 --> 0:32:21,475
但它们可以帮助你了解

620
00:32:21,708 --> 0:32:23,777
当呈现数据时

621
00:32:24,144 --> 0:32:26,813
当你设计图标模式时 概念很重要

622
00:32:27,981 --> 0:32:30,551
对于许多情况来说

623
00:32:30,717 --> 0:32:32,519
就可以满足你创建合适的体验

624
00:32:32,753 --> 0:32:34,021
所需要的功能和灵活性

625
00:32:34,655 --> 0:32:36,190
但一定在某些时候

626
00:32:36,256 --> 0:32:38,892
你想拥有一个输入或输出

627
00:32:39,560 --> 0:32:42,529
对于那些情况

628
00:32:42,963 --> 0:32:46,466
自定义建模器可以提供

629
00:32:46,867 --> 0:32:48,535
从而可视化地表达它们的概念

630
00:32:49,169 --> 0:32:52,372
或富文本的叙述、图表和详情视图

631
00:32:53,407 --> 0:32:55,175
现在我要把舞台交给Kacper

632
00:32:55,242 --> 0:32:56,844
看看他有什么样的可视化操作

633
00:33:02,816 --> 0:33:03,684
谢谢Daniel

634
00:33:04,852 --> 0:33:06,753
我讲了自定义建模器

635
00:33:06,820 --> 0:33:09,523
并努力改善我们现有的检查

636
00:33:09,957 --> 0:33:10,791
让我们看一下

637
00:33:11,491 --> 0:33:14,494
我要从我创建的那个

638
00:33:17,965 --> 0:33:20,934
它现在包含一个

639
00:33:21,101 --> 0:33:22,803
当使用压缩库时

640
00:33:22,970 --> 0:33:26,139
用于提供关于I/O操作的消耗的

641
00:33:27,274 --> 0:33:28,108
让我们记录一下

642
00:33:29,943 --> 0:33:34,982
现在我在窗口模式中记录

643
00:33:36,550 --> 0:33:41,088
Instrument会从主机传输

644
00:33:45,993 --> 0:33:47,194
现在让我们检验一下数据

645
00:33:48,695 --> 0:33:51,231
我可以立即看到

646
00:33:51,298 --> 0:33:52,699
在文件系统行动

647
00:33:53,033 --> 0:33:54,935
和我的执行路标之间有一些相关性

648
00:33:56,203 --> 0:33:58,272
我们主要看较长的zip压缩任务

649
00:33:58,338 --> 0:33:59,439
我们之间曾分析过

650
00:34:00,407 --> 0:34:02,242
把它显示为红色

651
00:34:02,543 --> 0:34:03,810
可以很好地吸引用户的注意

652
00:34:04,011 --> 0:34:07,414
但如果能使用叙述

653
00:34:07,681 --> 0:34:08,916
来提供一些额外信息更好

654
00:34:09,949 --> 0:34:13,253
我编写了建模器

655
00:34:13,520 --> 0:34:15,289
并呈现一些可能的方案

656
00:34:17,357 --> 0:34:19,126
让我们具体看一下建议详情

657
00:34:19,193 --> 0:34:21,562
看一下这个建模器的输出

658
00:34:25,866 --> 0:34:27,967
这个建模器…我们得到了一个建议

659
00:34:28,302 --> 0:34:31,371
建议说存档zip文件的尺寸

660
00:34:31,772 --> 0:34:33,841
缩减了百分之一点多

661
00:34:34,308 --> 0:34:37,110
可能没有必要压缩这个文件

662
00:34:38,011 --> 0:34:40,514
它还暗示如果速度不是问题

663
00:34:40,781 --> 0:34:43,183
我应该尝试使用LZMA算法

664
00:34:43,250 --> 0:34:45,585
可能会提供较快的压缩速率

665
00:34:46,253 --> 0:34:49,322
看起来很有用

666
00:34:49,857 --> 0:34:52,125
再次记录 并重新验证结果

667
00:34:53,994 --> 0:34:56,530
让我们看一下等待执行的任务

668
00:34:57,164 --> 0:35:00,033
我计算了正在等待执行的任务的

669
00:34:57,164 --> 0:35:00,033
我计算了正在等待执行的任务的

670
00:35:00,501 --> 0:35:04,905
这样 用户可以清晰地指出

671
00:35:05,873 --> 0:35:08,976
让我们看一下这个红色区域

672
00:35:10,143 --> 0:35:13,180
看起来有许多任务正在等待执行

673
00:35:13,247 --> 0:35:15,449
但随着任务在这个通道上的执行

674
00:35:15,716 --> 0:35:16,950
数量正在减少

675
00:35:17,885 --> 0:35:20,020
用户可以对那样的区域做出分析

676
00:35:20,287 --> 0:35:23,323
如果有必要

677
00:35:23,390 --> 0:35:25,125
从而实现更高级别的并发性

678
00:35:26,527 --> 0:35:29,263
实际上这个结论可以作为

679
00:35:29,329 --> 0:35:31,098
对详情视图的另一个建议

680
00:35:32,799 --> 0:35:36,737
现在让我们看一下它在

681
00:35:37,704 --> 0:35:41,175
让我们搜索我们的

682
00:35:41,842 --> 0:35:43,677
并看一下捆绑方案

683
00:35:45,812 --> 0:35:49,583
OSSignpost

684
00:35:49,783 --> 0:35:52,819
把OSSignpost

685
00:35:53,020 --> 0:35:55,455
Solar Compression

686
00:35:56,023 --> 0:35:58,926
就在这里 正如我们之前所看到的

687
00:35:59,560 --> 0:36:03,130
我们这里还有这个新实体

688
00:35:59,560 --> 0:36:03,130
我们这里还有这个新实体

689
00:36:03,597 --> 0:36:07,134
它把压缩执行表中的区间

690
00:36:07,801 --> 0:36:10,838
传输到点模式中的建议中

691
00:36:11,138 --> 0:36:13,440
稍后用于驱动叙述详情

692
00:36:15,609 --> 0:36:19,746
我对这个Instruments

693
00:36:20,047 --> 0:36:22,316
我感觉我们已经准备好

694
00:36:22,816 --> 0:36:24,151
让我们返回到幻灯片中

695
00:36:33,227 --> 0:36:34,895
创建优秀的分析体验

696
00:36:35,162 --> 0:36:37,531
是要给用户提供一个探索路径

697
00:36:38,432 --> 0:36:40,400
应该从一个有用的模板开始

698
00:36:40,667 --> 0:36:42,636
这个模板用于提供

699
00:36:42,703 --> 0:36:43,904
查看问题的必要的

700
00:36:44,605 --> 0:36:47,407
请记住 如果你的代码

701
00:36:47,474 --> 0:36:49,343
对由其它检查所暴露的信息敏感

702
00:36:49,676 --> 0:36:53,380
比如采样、系统追踪或优先级行动

703
00:36:53,647 --> 0:36:55,315
你应该在你的模板中包含这些

704
00:36:56,316 --> 0:36:57,684
当分析记录时

705
00:36:57,985 --> 0:37:00,554
优秀的图表应该可以把用户的注意力

706
00:36:57,985 --> 0:37:00,554
优秀的图表应该可以把用户的注意力

707
00:37:00,787 --> 0:37:03,457
执行时间线中可能存在问题的地方

708
00:37:03,991 --> 0:37:07,094
详情应该把他们带到

709
00:37:07,461 --> 0:37:09,129
并且通常还要提供有意义的暗示

710
00:37:10,697 --> 0:37:13,033
为了帮助你开发更好的分析体验

711
00:37:13,333 --> 0:37:16,003
今年在Instruments中

712
00:37:16,336 --> 0:37:18,805
第一个是分等级追踪的概念

713
00:37:19,606 --> 0:37:22,843
其中一个例子是这里可见的

714
00:37:23,076 --> 0:37:26,647
通过等级

715
00:37:26,813 --> 0:37:27,748
暴露了底层的子系统和类别名称空间

716
00:37:29,449 --> 0:37:31,652
等级时自定义

717
00:37:31,852 --> 0:37:35,556
你今天看到的所有等级都可在自己

718
00:37:37,558 --> 0:37:40,527
我们还有一种自定义你的分析流程的

719
00:37:40,794 --> 0:37:42,696
即通过创建自定义追踪范围

720
00:37:43,997 --> 0:37:46,967
这些允许你从不同角度查看

721
00:37:47,267 --> 0:37:50,204
通过应用追踪过滤器

722
00:37:50,571 --> 0:37:52,906
或为每个范围选择不同的追踪分支

723
00:37:54,174 --> 0:37:56,476
如果我只对查看系统调用

724
00:37:56,543 --> 0:37:58,412
和压缩库的路标感兴趣

725
00:37:59,079 --> 0:38:02,883
或只对分析虚拟内存对app的影响

726
00:37:59,079 --> 0:38:02,883
或只对分析虚拟内存对app的影响

727
00:38:03,116 --> 0:38:05,886
我可以创建过滤掉其它追踪的范围

728
00:38:06,086 --> 0:38:07,521
并一直给它们返回值

729
00:38:08,722 --> 0:38:10,958
稍后我可以把它们保存在我的模板中

730
00:38:11,191 --> 0:38:13,694
并与团队或Instruments

731
00:38:15,863 --> 0:38:17,664
检查形式的工具

732
00:38:17,731 --> 0:38:20,534
会把用户与你的框架的交互体验

733
00:38:20,868 --> 0:38:23,804
从良好变成优秀 从不了解变成信任

734
00:38:24,671 --> 0:38:28,709
你可以通过它们来描述你框架中

735
00:38:29,710 --> 0:38:33,013
它们应该教育人们

736
00:38:34,047 --> 0:38:36,683
无论何时当客户出现性能调试问题时

737
00:38:37,150 --> 0:38:39,152
他们都可以返回到工具中寻找答案

738
00:38:39,386 --> 0:38:40,487
这种交互

739
00:38:40,888 --> 0:38:43,724
将增加他们对你的库的信心和信任

740
00:38:45,425 --> 0:38:49,196
要获取更多关于自定义Instruments的

741
00:38:49,930 --> 0:38:52,232
我们还推荐你们观看这些演讲

742
00:38:52,799 --> 0:38:54,868
谢谢 祝你们愉快地度过
