1
00:00:07,040 --> 0:00:12,145
（在你的app中优化存储空间

2
00:00:16,884 --> 0:00:20,420
嗨 我是Kai Kaahaaina 今天

3
00:00:20,487 --> 0:00:23,524
我们会介绍如何为你的app优化

4
00:00:24,858 --> 0:00:28,228
就像CPU内存一样 存储是一个

5
00:00:29,363 --> 0:00:31,398
当一个app最佳使用存储空间时

6
00:00:31,798 --> 0:00:37,538
我们能更好地保证更长时间

7
00:00:39,439 --> 0:00:42,676
减少app的内存占用和

8
00:00:45,412 --> 0:00:48,949
今天我们主要要讲的优化主题是

9
00:00:50,017 --> 0:00:55,822
同步至硬盘 序列化数据文件

10
00:00:59,193 --> 0:01:00,661
首先 高效率的图片资源

11
00:00:59,193 --> 0:01:00,661
首先 高效率的图片资源

12
00:01:01,028 --> 0:01:04,031
当屏幕尺寸变得大一些了

13
00:01:04,096 --> 0:01:05,899
图片资源的尺寸也相应地增大了

14
00:01:09,169 --> 0:01:12,539
在我们的演讲中 我们创建了一个

15
00:01:12,606 --> 0:01:13,707
和最爱的图片

16
00:01:15,409 --> 0:01:17,711
不过 甚至是在预加载一些照片时

17
00:01:17,778 --> 0:01:20,814
我们的app也增大了24.6

18
00:01:21,849 --> 0:01:25,319
我们现在来了解优化

19
00:01:27,321 --> 0:01:28,622
首先是HEIC

20
00:01:29,022 --> 0:01:31,391
HEIC有时也被称为HEIF

21
00:01:31,892 --> 0:01:34,561
它更有效率且能够取代JPEG

22
00:01:36,597 --> 0:01:40,634
相同画质下 HEIC的文件大小

23
00:01:41,001 --> 0:01:46,206
当然 它意味着一个

24
00:01:46,273 --> 0:01:48,509
从网络上上传或下载变得更容易了

25
00:01:50,077 --> 0:01:52,379
它们也能被更快的加载和保持到硬盘

26
00:01:55,716 --> 0:01:58,118
HEIC也提供了很多JPEG

27
00:01:58,285 --> 0:02:01,054
比如存储包含了深度和视差信息

28
00:01:58,285 --> 0:02:01,054
比如存储包含了深度和视差信息

29
00:02:01,121 --> 0:02:02,289
的辅助图片的能力

30
00:02:04,124 --> 0:02:07,094
HEIC也支持阿尔法和无损压缩

31
00:02:09,096 --> 0:02:13,000
HEIC甚至允许你在单独的容器中

32
00:02:15,636 --> 0:02:17,804
iOS从iOS 11起

33
00:02:17,871 --> 0:02:20,507
MacOS从macOS High Sierra

34
00:02:21,475 --> 0:02:23,243
它在其他操作系统也同样可用

35
00:02:26,380 --> 0:02:29,416
那么 回到我们的示例app

36
00:02:29,483 --> 0:02:32,352
它在磁盘中占据24.6兆字节

37
00:02:34,188 --> 0:02:37,724
用HEIC取代JPEG格式后

38
00:02:37,791 --> 0:02:39,259
到17.9兆字节

39
00:02:39,960 --> 0:02:42,863
通过使用HEIC就减少了27%

40
00:02:46,533 --> 0:02:49,903
另一个减少我们app

41
00:02:50,504 --> 0:02:54,341
资源目录是管理你app的资源

42
00:02:55,175 --> 0:02:56,643
比如app图标 设备和你的

43
00:02:58,478 --> 0:03:00,514
不同尺寸的图片资源

44
00:02:58,478 --> 0:03:00,514
不同尺寸的图片资源

45
00:03:01,048 --> 0:03:04,318
资源目录提供了一个非常容易的

46
00:03:04,384 --> 0:03:05,352
具有多级分辨率的图片

47
00:03:05,919 --> 0:03:08,922
这让它非常简单就能

48
00:03:10,924 --> 0:03:14,261
我们也能使用资源目录来为

49
00:03:14,828 --> 0:03:16,797
这样用户就不需要看见它们下载

50
00:03:17,197 --> 0:03:18,265
直到他们需要使用它们时

51
00:03:21,301 --> 0:03:23,504
通过使用资源目录

52
00:03:23,570 --> 0:03:25,072
我们同时获取了存储和性能的优点

53
00:03:27,007 --> 0:03:28,842
我们首先减少了磁盘的内存占有量

54
00:03:28,909 --> 0:03:32,946
因为资源目录使用了单一的经过优化

55
00:03:33,013 --> 0:03:34,448
而不是个别文件

56
00:03:36,884 --> 0:03:40,220
App Store也使用了

57
00:03:40,287 --> 0:03:41,822
你的iOS app的app分割

58
00:03:43,323 --> 0:03:45,559
这样当一个用户从商店下载

59
00:03:45,926 --> 0:03:48,395
他们只会获取到他们自己设备所需

60
00:03:48,762 --> 0:03:50,330
这减轻了下载量

61
00:03:50,397 --> 0:03:52,900
也节省了用户下载app的时间

62
00:03:52,966 --> 0:03:54,868
他们很快就能开始使用你的app

63
00:03:57,271 --> 0:03:58,539
我们的性能也得到了提升

64
00:03:59,406 --> 0:04:02,609
再一次 由于资源目录优化了

65
00:03:59,406 --> 0:04:02,609
再一次 由于资源目录优化了

66
00:04:02,676 --> 0:04:05,646
图片能被更快地加载了

67
00:04:05,946 --> 0:04:08,649
在app启动时优化效果尤其明显

68
00:04:09,683 --> 0:04:11,051
特别是Mac上的硬件驱动

69
00:04:11,118 --> 0:04:14,755
我们看到了app启动时性能提升了

70
00:04:17,457 --> 0:04:21,261
资源目录也让基于GPU的压缩

71
00:04:22,196 --> 0:04:27,367
这个压缩默认是无损的

72
00:04:29,803 --> 0:04:32,039
所有的都能使用硬件加速的解压

73
00:04:33,140 --> 0:04:37,077
有一个选项甚至提供了一个减少

74
00:04:37,144 --> 0:04:38,212
你图片资源的内存占用的功能

75
00:04:41,849 --> 0:04:43,016
那么回到我们的示例app

76
00:04:43,083 --> 0:04:46,587
早些时候我们看到通过使用HEIC

77
00:04:46,653 --> 0:04:47,654
的体积减少至17.9兆字节

78
00:04:48,889 --> 0:04:51,425
现在 也通过适配资源目录

79
00:04:51,491 --> 0:04:55,429
主要通过app分割功能

80
00:04:55,495 --> 0:04:57,331
这个app的内存占用减少

81
00:04:58,532 --> 0:05:02,336
只需简单地使用了

82
00:04:58,532 --> 0:05:02,336
只需简单地使用了

83
00:05:02,636 --> 0:05:03,737
就比我们开始时减少了40%

84
00:05:05,939 --> 0:05:08,175
所以如果你还没使用HEIC

85
00:05:08,242 --> 0:05:10,444
和资源目录来管理你的图片资源

86
00:05:10,611 --> 0:05:11,845
我们非常推荐你调研使用它们

87
00:05:11,912 --> 0:05:14,147
它们是一个很棒又简单的

88
00:05:14,314 --> 0:05:15,516
和更小的app内存占用率

89
00:05:19,219 --> 0:05:21,455
接下来 我想要简单地聊一下

90
00:05:25,425 --> 0:05:28,662
我们示例app包含了一个小的

91
00:05:28,729 --> 0:05:29,796
app被启动的时间

92
00:05:30,230 --> 0:05:32,766
app每次被启动时

93
00:05:33,200 --> 0:05:36,270
更新last_app_launch时间属性

94
00:05:36,336 --> 0:05:37,337
重写回磁盘中

95
00:05:39,306 --> 0:05:42,376
如果我们观察到这个行为表现

96
00:05:42,442 --> 0:05:44,344
Alejandro将在之后演讲中

97
00:05:45,212 --> 0:05:47,114
我们能看到这个行为导致了一次读取

98
00:05:47,347 --> 0:05:49,416
它很有道理

99
00:05:50,551 --> 0:05:52,219
但它导致了三个写入操作

100
00:05:52,386 --> 0:05:55,322
你可能会有点吃惊

101
00:05:56,757 --> 0:05:59,526
我们也看到了一个fsync操作

102
00:05:59,593 --> 0:06:02,729
为什么那样操作开销会很大

103
00:05:59,593 --> 0:06:02,729
为什么那样操作开销会很大

104
00:06:04,765 --> 0:06:06,500
所以 为什么不是不是一次

105
00:06:07,167 --> 0:06:09,036
那么 答案就是文件系统元数据

106
00:06:10,037 --> 0:06:14,007
文件系统元数据是我们每次

107
00:06:14,074 --> 0:06:16,043
文件系统需要更新的数据

108
00:06:16,109 --> 0:06:20,914
当前案例中 写入了plist文件

109
00:06:23,650 --> 0:06:25,118
所以什么是文件系统元数据？

110
00:06:25,652 --> 0:06:28,455
文件系统元数据是文件系统

111
00:06:28,522 --> 0:06:29,590
需要追踪的关于我们文件的信息

112
00:06:29,656 --> 0:06:34,328
比如文件名字 尺寸 位置

113
00:06:35,629 --> 0:06:38,098
以及日期 比如创建的日期

114
00:06:38,866 --> 0:06:39,867
还有更多的

115
00:06:42,069 --> 0:06:44,104
为了更好地理解每次

116
00:06:44,171 --> 0:06:45,239
文件系统要实现什么

117
00:06:45,772 --> 0:06:47,774
我们来了解一下APFS要做什么

118
00:06:47,841 --> 0:06:50,143
当我们将NSDictionary

119
00:06:51,712 --> 0:06:55,749
好的 APFS要做的第一件事是

120
00:06:56,149 --> 0:06:58,118
它会通过更新它的一个节点来实现

121
00:06:59,253 --> 0:07:02,322
不过 因为APFS的即写即拷性质

122
00:06:59,253 --> 0:07:02,322
不过 因为APFS的即写即拷性质

123
00:07:02,890 --> 0:07:07,027
我们实际上并未更新一个已有的节点

124
00:07:07,461 --> 0:07:08,529
我们来深入了解一下

125
00:07:09,630 --> 0:07:11,265
这是我们已有的文件系统树

126
00:07:13,534 --> 0:07:16,136
我们看到了一个已有节点的备份

127
00:07:18,338 --> 0:07:20,908
这个新的节点和原始节点

128
00:07:20,974 --> 0:07:22,576
它其实和原始节点的名字一样

129
00:07:22,976 --> 0:07:26,213
但是新节点增加了内容

130
00:07:26,747 --> 0:07:29,583
它的这个不同的事务ID可以让

131
00:07:29,650 --> 0:07:31,485
高阶的功能 比如截屏

132
00:07:33,487 --> 0:07:37,724
那么返回到上一级 现在我们有了

133
00:07:38,325 --> 0:07:41,562
APFS需要更新这个对象地图

134
00:07:42,029 --> 0:07:44,865
那么 总体来说 为了支持写入新的

135
00:07:45,032 --> 0:07:47,301
APFS需要实现两个单独的操作

136
00:07:48,468 --> 0:07:50,237
总共8K的写入I/O

137
00:07:51,772 --> 0:07:56,176
4K用来更新文件系统树

138
00:07:57,744 --> 0:07:59,346
我们还是需要写入这个文件本身

139
00:07:59,580 --> 0:08:03,684
当前场景下 它虽只是240字节

140
00:07:59,580 --> 0:08:03,684
当前场景下 它虽只是240字节

141
00:08:04,117 --> 0:08:07,588
我们向一个iOS设备磁盘

142
00:08:07,855 --> 0:08:08,856
所以它被四舍五入了

143
00:08:10,591 --> 0:08:15,829
总体来说 须向磁盘写入12K的

144
00:08:17,164 --> 0:08:18,532
只有大约2%的效率

145
00:08:19,266 --> 0:08:21,969
所以示例不仅向我们展示了APFS

146
00:08:22,035 --> 0:08:26,006
它也高亮了在文件系统的独立文件中

147
00:08:26,073 --> 0:08:29,309
存储量极小的数据的成本

148
00:08:33,313 --> 0:08:36,650
那么 在我们刚看到的示例

149
00:08:36,717 --> 0:08:38,784
需要8K的I/O

150
00:08:40,419 --> 0:08:42,322
那么删除一个文件呢？

151
00:08:42,722 --> 0:08:46,093
另一个常见的操作

152
00:08:46,860 --> 0:08:49,429
修改一个已有文件是8K

153
00:08:52,366 --> 0:08:55,102
这里最重要的是文件系统更新

154
00:08:55,435 --> 0:08:58,639
事实上 它们涉及到

155
00:08:59,606 --> 0:09:02,042
作为一个结果

156
00:08:59,606 --> 0:09:02,042
作为一个结果

157
00:09:02,109 --> 0:09:03,143
我们需要有选择性地操作

158
00:09:04,044 --> 0:09:05,846
我们想要尝试避免高昂的行为操作

159
00:09:05,913 --> 0:09:08,282
比如快速地创建和删除文件

160
00:09:11,852 --> 0:09:15,189
如果我们有一个使用场景

161
00:09:15,389 --> 0:09:17,791
对于暂存数据来说

162
00:09:17,858 --> 0:09:18,859
这是一个减少系统耗费的一种好方式

163
00:09:19,226 --> 0:09:23,664
首先 创建你的文件

164
00:09:25,098 --> 0:09:26,366
不要为它调用fsync

165
00:09:26,967 --> 0:09:29,236
这样做会给文件系统一个它需要

166
00:09:29,303 --> 0:09:31,872
在OS缓冲中需要尽可能长时间地

167
00:09:32,105 --> 0:09:35,642
以及不要将它可能需要频繁地

168
00:09:37,244 --> 0:09:40,147
如果你想要了解更多关于APFS

169
00:09:40,214 --> 0:09:42,416
我们的开发者网站上有一个

170
00:09:42,583 --> 0:09:43,951
我非常推荐你查看它

171
00:09:48,488 --> 0:09:49,623
接下来 同步到磁盘

172
00:09:52,726 --> 0:09:54,761
当它开始管理我们的数据在哪存储时

173
00:09:54,828 --> 0:09:58,866
为了最佳的性能表现 我们想要保存

174
00:09:59,633 --> 0:10:04,671
但当我们需要它时 我们也想要能够

175
00:09:59,633 --> 0:10:04,671
但当我们需要它时 我们也想要能够

176
00:10:05,873 --> 0:10:07,774
首先 我们来了解一下我们有的

177
00:10:09,409 --> 0:10:10,677
首先 这是OS缓存

178
00:10:10,744 --> 0:10:13,447
这是我们为了最佳性能表现想要

179
00:10:14,848 --> 0:10:17,417
对OS缓存进行读写操作

180
00:10:18,218 --> 0:10:19,887
因为这个缓存依靠内存

181
00:10:19,953 --> 0:10:22,556
逻辑I/O操作完成得非常快速

182
00:10:23,323 --> 0:10:25,526
在OS缓存中保存数据通常对

183
00:10:25,592 --> 0:10:27,694
频繁使用和修改数据有利

184
00:10:30,531 --> 0:10:31,565
接下来 我们有了磁盘缓存

185
00:10:31,632 --> 0:10:34,701
磁盘缓存实际上

186
00:10:36,503 --> 0:10:38,372
最后 我们有了永久存储

187
00:10:38,438 --> 0:10:41,241
这实际上是物理媒介

188
00:10:41,308 --> 0:10:42,309
保存数据

189
00:10:42,376 --> 0:10:45,245
在iOS设备和最新的Mac上

190
00:10:48,182 --> 0:10:51,285
物理I/O在物理存储器上

191
00:10:51,552 --> 0:10:56,723
这些I/O会抵达或去往磁盘缓存

192
00:10:58,825 --> 0:11:01,828
那么 现在我们已经了解了一些

193
00:10:58,825 --> 0:11:01,828
那么 现在我们已经了解了一些

194
00:11:02,196 --> 0:11:05,632
我们来了解一下最通用的API

195
00:11:05,899 --> 0:11:06,900
到存储设备上

196
00:11:08,669 --> 0:11:09,670
首先 是fsync

197
00:11:11,705 --> 0:11:14,708
fsync会让数据从OS缓存中

198
00:11:16,643 --> 0:11:18,412
但它不保证数据

199
00:11:18,478 --> 0:11:20,414
将会被立刻永久存储

200
00:11:20,981 --> 0:11:24,384
若软件没有更进一步输入

201
00:11:24,451 --> 0:11:27,221
来查明数据何时会从磁盘缓存中

202
00:11:28,622 --> 0:11:30,257
它也不能保证写命令

203
00:11:31,024 --> 0:11:33,961
就是说OS缓存中的数据

204
00:11:34,027 --> 0:11:37,231
可能不太会和数据被磁盘缓存

205
00:11:37,297 --> 0:11:39,233
写入至永久存储时的命令一样

206
00:11:41,101 --> 0:11:43,370
如果我们过度使用fsync时

207
00:11:44,204 --> 0:11:48,942
当我们在OS缓存中有数据时

208
00:11:49,009 --> 0:11:50,944
重写或改动同样的数据

209
00:11:51,278 --> 0:11:53,413
只要我们使用了fsync

210
00:11:54,681 --> 0:11:56,884
基于我们需要保证我们的数据

211
00:11:56,950 --> 0:11:57,951
被移动到磁盘缓存的节奏

212
00:11:58,519 --> 0:12:00,821
手动调用fsync可能并不必要

213
00:11:58,519 --> 0:12:00,821
手动调用fsync可能并不必要

214
00:12:00,888 --> 0:12:03,023
OS会为我们周期性地实现

215
00:12:07,895 --> 0:12:11,498
从OS缓存中将数据移动至永久存储

216
00:12:11,565 --> 0:12:14,501
最主要的方式是通过F controls的

217
00:12:15,636 --> 0:12:18,572
这会导致驱动中的磁盘缓存的数据

218
00:12:20,107 --> 0:12:22,709
不过 这会导致磁盘缓存中

219
00:12:23,277 --> 0:12:25,913
所以我们不只是想要移动到永久存储

220
00:12:25,979 --> 0:12:29,383
的数据会被移动到永久存储

221
00:12:29,683 --> 0:12:31,485
磁盘缓存中的所有数据都会被移动

222
00:12:32,719 --> 0:12:33,787
最后 它的耗费量很大

223
00:12:34,188 --> 0:12:36,256
因为它可能有很多数据

224
00:12:37,891 --> 0:12:40,460
再一次 它可能实际上并不需要

225
00:12:41,061 --> 0:12:43,697
OS会为我们周期性地实现了

226
00:12:46,667 --> 0:12:50,704
如我们用FFULLFSYNC

227
00:12:51,038 --> 0:12:53,974
一个更好更有效的替代方式是使用

228
00:12:55,175 --> 0:12:57,311
F BARRIERFSYNC

229
00:12:58,946 --> 0:13:01,915
将F BARRIERFSYNC

230
00:12:58,946 --> 0:13:01,915
将F BARRIERFSYNC

231
00:13:02,082 --> 0:13:06,486
可能是最好的思考方法 这个障碍是

232
00:13:06,553 --> 0:13:10,757
在障碍之前收到的所有iOS的提示

233
00:13:10,824 --> 0:13:12,793
在障碍之后才会收到它们

234
00:13:14,361 --> 0:13:16,830
最后 它比F FULLFSYNC

235
00:13:17,431 --> 0:13:20,868
不用将所有磁盘缓存中

236
00:13:20,934 --> 0:13:22,936
就得到了我们想要的相同的结果

237
00:13:24,705 --> 0:13:27,708
所以如果你对I/O命令有所顾虑

238
00:13:27,774 --> 0:13:28,842
而不是F FULLFSYNC

239
00:13:28,909 --> 0:13:31,979
它是更快速和有效的方式

240
00:13:34,848 --> 0:13:36,316
序列化的数据文件

241
00:13:37,050 --> 0:13:38,285
序列化的数据文件

242
00:13:39,086 --> 0:13:41,788
文件比如plist、XML

243
00:13:42,055 --> 0:13:43,290
它们用起来很方便

244
00:13:43,657 --> 0:13:47,060
它们是存储不常用的修改后的数据

245
00:13:47,995 --> 0:13:49,463
它们解析起来相当容易

246
00:13:50,531 --> 0:13:52,699
然而 除了所有这些简易操作的方面

247
00:13:55,269 --> 0:13:57,905
每次我们对这个文件

248
00:13:57,971 --> 0:14:01,008
整个文件会被重新序列化

249
00:13:57,971 --> 0:14:01,008
整个文件会被重新序列化

250
00:14:02,176 --> 0:14:03,810
结果就是 它们的扩展性不佳

251
00:14:04,945 --> 0:14:07,648
因为它们使用起来非常方便

252
00:14:08,749 --> 0:14:11,151
因为只要有一个改动

253
00:14:11,218 --> 0:14:13,120
它们是非常集中的文件系统元数据

254
00:14:15,989 --> 0:14:18,325
它们并不意味着能取代一个数据库

255
00:14:20,594 --> 0:14:23,263
查看文件活跃状态仪表的截图

256
00:14:23,330 --> 0:14:26,867
我们能看到创建

257
00:14:27,501 --> 0:14:29,603
导致了12次分散的I/O操作

258
00:14:30,037 --> 0:14:32,439
这对于四行代码可能有点多

259
00:14:34,608 --> 0:14:36,777
如果我们在这个有点略微不同的视图

260
00:14:36,844 --> 0:14:38,879
我们调用NSDictionary

261
00:14:40,314 --> 0:14:42,850
这个操作同一个fsync

262
00:14:43,217 --> 0:14:45,619
代表在该NSDictionary

263
00:14:45,686 --> 0:14:48,822
我们推送至磁盘 它永远不会

264
00:14:51,225 --> 0:14:55,529
最后 非常大的数据集

265
00:14:55,829 --> 0:14:59,366
它们在一个序列化plist格式中

266
00:15:01,969 --> 0:15:03,604
如果你的数据量很大

267
00:15:03,670 --> 0:15:06,773
或需要频繁改动

268
00:15:09,476 --> 0:15:13,146
Core Data管理创建在SQLite上

269
00:15:13,213 --> 0:15:16,283
和你app的模型层之间的

270
00:15:18,485 --> 0:15:21,488
Core data自动地管理

271
00:15:23,323 --> 0:15:25,526
支持变化追踪和通知

272
00:15:27,528 --> 0:15:30,497
自动地版本追踪和多次写入冲突解决

273
00:15:30,931 --> 0:15:34,401
Core Data甚至会自动地

274
00:15:34,568 --> 0:15:36,303
为多个并行操作建立联系

275
00:15:37,871 --> 0:15:41,775
iOS 13新加入的Core Data

276
00:15:41,842 --> 0:15:43,710
对于Core Data适配者来说

277
00:15:45,245 --> 0:15:47,147
Core Data

278
00:15:47,214 --> 0:15:49,216
它允许你快速集成查询

279
00:15:49,883 --> 0:15:52,653
那么 你不必提前手写你觉得你可能

280
00:15:52,719 --> 0:15:53,854
需要的所有的SQLite查询代码

281
00:15:55,989 --> 0:15:58,292
Core Data

282
00:15:59,793 --> 0:16:01,428
状态聚合和数据处理

283
00:15:59,793 --> 0:16:01,428
状态聚合和数据处理

284
00:16:03,096 --> 0:16:08,936
模式迁移和iOS 13新加入的

285
00:16:10,237 --> 0:16:11,338
等其他更多

286
00:16:12,973 --> 0:16:14,975
我们也观察到了

287
00:16:15,042 --> 0:16:18,579
必须写50%到70%的少量代码

288
00:16:19,313 --> 0:16:22,516
那段代码无需写入、修改或调试

289
00:16:23,016 --> 0:16:26,053
不过 如果你有一个使用场景

290
00:16:26,286 --> 0:16:28,255
我们有一些最佳实践想要分享给你

291
00:16:30,023 --> 0:16:33,060
这是一个更大的话题 所以我们有

292
00:16:33,560 --> 0:16:38,332
日志登载 数据处理

293
00:16:40,834 --> 0:16:41,835
或子连接

294
00:16:43,270 --> 0:16:45,506
SQLite的稳健性保证并不是免费的

295
00:16:45,973 --> 0:16:48,675
打开和关闭一个数据库

296
00:16:48,742 --> 0:16:52,379
比如持续检查 日志恢复和

297
00:16:54,715 --> 0:16:57,384
最后 我们实际上推荐不要使用

298
00:16:57,451 --> 0:17:00,087
来每次按需打开和关闭一个数据库

299
00:16:57,451 --> 0:17:00,087
来每次按需打开和关闭一个数据库

300
00:17:01,088 --> 0:17:02,556
取而代之 我们推荐相反的方式

301
00:17:03,123 --> 0:17:07,160
让数据库尽可能地一直保存打开

302
00:17:08,028 --> 0:17:10,230
对于多线程的处理 建立连接

303
00:17:10,297 --> 0:17:12,733
这样 只要一个线程还需要数据库

304
00:17:12,799 --> 0:17:14,101
数据库就会保持打开状态

305
00:17:14,800 --> 0:17:17,871
这帮助分担了多次打开和

306
00:17:17,938 --> 0:17:18,939
关闭一个数据库成本

307
00:17:21,942 --> 0:17:22,943
接下来 日志登载

308
00:17:25,078 --> 0:17:27,714
删除模式日志登载是SQLite

309
00:17:27,948 --> 0:17:29,683
但它并不是最高效的

310
00:17:30,150 --> 0:17:33,854
为了知道为什么 我们来看一下

311
00:17:35,422 --> 0:17:37,925
我们有一个数据库

312
00:17:39,459 --> 0:17:42,095
发生的第一件事是

313
00:17:42,162 --> 0:17:43,163
到一个日志文件结束后

314
00:17:45,933 --> 0:17:48,502
接下来我们能在数据库中

315
00:17:49,436 --> 0:17:52,706
完成之后 日志文件就会被删除

316
00:17:53,440 --> 0:17:57,578
所以如果我们想一想

317
00:17:57,644 --> 0:18:01,882
我们需要修改的页面

318
00:17:57,644 --> 0:18:01,882
我们需要修改的页面

319
00:18:01,949 --> 0:18:03,650
只做了一次数据处理的短时间

320
00:18:05,886 --> 0:18:10,023
幸运的是 SQLite为预写日志

321
00:18:10,090 --> 0:18:11,391
提供了一个更加高效的替代品

322
00:18:11,892 --> 0:18:15,095
WAL模式日志登载提供了

323
00:18:15,529 --> 0:18:18,999
它允许我们在同一页上将

324
00:18:19,333 --> 0:18:20,467
它使用了更少的障碍物

325
00:18:21,301 --> 0:18:23,504
它能同时支持多个读入和写入操作

326
00:18:24,004 --> 0:18:25,239
以及支持截屏

327
00:18:26,273 --> 0:18:27,741
我们来看一下WAL模式日志

328
00:18:29,142 --> 0:18:31,578
所以再一次 我们有一个数据库

329
00:18:32,179 --> 0:18:34,348
它们被写入预写日志文件

330
00:18:34,681 --> 0:18:36,517
而不是直接地在数据库中修改

331
00:18:37,084 --> 0:18:39,152
以及 我们有了额外的数据处理

332
00:18:39,786 --> 0:18:42,122
这些页面也被添加至

333
00:18:42,789 --> 0:18:45,325
直到预写日志文件变得相当大之后

334
00:18:45,392 --> 0:18:46,393
它才会为它开始检查点

335
00:18:47,528 --> 0:18:50,497
当我们为它开始检查点时 我们能使

336
00:18:51,131 --> 0:18:55,702
在删除模式数据库里

337
00:18:56,170 --> 0:18:59,706
所有这些在同一页面的改动

338
00:18:59,773 --> 0:19:02,242
同一页面只需被写入一次

339
00:18:59,773 --> 0:19:02,242
同一页面只需被写入一次

340
00:19:04,511 --> 0:19:07,714
当我们完成后 一个简单的

341
00:19:07,781 --> 0:19:09,950
是所有将来所需用到的

342
00:19:10,217 --> 0:19:13,320
因此要减少文件系统维护这个

343
00:19:15,689 --> 0:19:19,793
多数SQLite的使用场景中

344
00:19:19,860 --> 0:19:22,596
如果你还没为SQLite数据库

345
00:19:22,663 --> 0:19:24,598
我们非常建议你切换至WAL模式

346
00:19:25,098 --> 0:19:28,235
它是为你的app提升性能

347
00:19:29,603 --> 0:19:31,805
使用多次插入 更新和删除声明

348
00:19:31,872 --> 0:19:35,475
在一次数据处理中是为SQLite

349
00:19:35,542 --> 0:19:37,945
这样它能更有效地为你运行

350
00:19:39,279 --> 0:19:42,950
通过多次声明 在相同的数据处理下

351
00:19:43,016 --> 0:19:45,586
被多次修改的文章

352
00:19:47,120 --> 0:19:49,590
在这个示例中

353
00:19:49,656 --> 0:19:52,292
每一个都在数据库中修改相同页面的

354
00:19:53,060 --> 0:19:55,963
我们会看到数据库中的同一页面

355
00:19:57,698 --> 0:20:01,001
不过 如果我们在这三个声明中

356
00:19:57,698 --> 0:20:01,001
不过 如果我们在这三个声明中

357
00:20:01,602 --> 0:20:04,204
所有的这些改变会被结合在一起

358
00:20:04,271 --> 0:20:05,472
只会被重写一次

359
00:20:07,674 --> 0:20:10,911
最后 在单个SQLite

360
00:20:10,978 --> 0:20:13,547
是聚合多次变动的一个很好的方式

361
00:20:17,751 --> 0:20:18,919
文件大小和隐私

362
00:20:21,154 --> 0:20:22,990
所以当我们在数据库中删除数据时

363
00:20:23,957 --> 0:20:26,527
空间包含了被标记为

364
00:20:26,960 --> 0:20:28,829
当它不再是数据库的一部分时

365
00:20:28,896 --> 0:20:30,230
从技术角度来看

366
00:20:31,398 --> 0:20:34,868
所以如果我们要如何更高效

367
00:20:37,271 --> 0:20:39,373
我们推荐使用

368
00:20:39,907 --> 0:20:41,308
secure_delete=Fast

369
00:20:42,743 --> 0:20:44,478
它自动地清理被删除的数据

370
00:20:45,012 --> 0:20:47,080
对于相同页面数据并没有成本损失

371
00:20:47,147 --> 0:20:49,750
我们在头文件中修改过的

372
00:20:50,551 --> 0:20:53,787
现在它也是iOS 13中

373
00:20:54,721 --> 0:20:57,391
如果你需要它来创建老版本的iOS

374
00:20:57,457 --> 0:21:00,561
请注意secure_delete=FAST

375
00:20:57,457 --> 0:21:00,561
请注意secure_delete=FAST

376
00:21:03,964 --> 0:21:06,433
当它被用来管理

377
00:21:06,767 --> 0:21:09,102
我们强烈建议你

378
00:21:10,604 --> 0:21:14,007
VACUUM是一个非常慢的内存

379
00:21:14,341 --> 0:21:17,344
为了更好理解为什么 我们来看看

380
00:21:17,411 --> 0:21:18,378
数据库工作的

381
00:21:19,913 --> 0:21:22,649
那么 假如我们有一个数据库

382
00:21:24,618 --> 0:21:26,820
发生了什么呢？我们最后为我们的

383
00:21:26,887 --> 0:21:30,557
创建了一个日志文件 接下来

384
00:21:30,924 --> 0:21:32,492
到日志文件的SQLite转储

385
00:21:32,993 --> 0:21:36,296
为我们的数据库拷贝了所有

386
00:21:37,664 --> 0:21:40,100
接下来 当为日志文件实行

387
00:21:40,601 --> 0:21:43,303
为了符合日志文件的大小

388
00:21:44,171 --> 0:21:47,574
日志中的所有数据都会被重新插入

389
00:21:49,009 --> 0:21:51,411
接下来当它完成时

390
00:21:54,081 --> 0:21:55,582
如我们看到的 这个开销很大

391
00:21:55,649 --> 0:21:58,952
我们数据库中的这些

392
00:21:59,152 --> 0:22:00,220
一次被写入到了日志文件

393
00:21:59,152 --> 0:22:00,220
一次被写入到了日志文件

394
00:22:00,287 --> 0:22:02,422
接着再一次回到了数据库

395
00:22:04,858 --> 0:22:08,128
如果数据库工作的这一边太大

396
00:22:08,462 --> 0:22:12,766
SQLite其实会利用多余的文件

397
00:22:13,100 --> 0:22:14,568
直到操作完成

398
00:22:18,238 --> 0:22:21,575
很幸运 SQLite中有很多

399
00:22:22,009 --> 0:22:24,344
在当前情况下 就是

400
00:22:24,912 --> 0:22:26,547
auto_vacuum的增量很棒

401
00:22:26,613 --> 0:22:29,316
因为它不仅允许我们更高效地

402
00:22:29,383 --> 0:22:33,220
它还让我们确认页数

403
00:22:33,287 --> 0:22:34,922
我们想要清空数据库

404
00:22:35,589 --> 0:22:39,326
为数据库保留之后会用到的

405
00:22:43,530 --> 0:22:45,599
我们来看一下auto_vacuum=INCREMENTAL

406
00:22:46,867 --> 0:22:49,970
那么 在这个例子中 我们会清空

407
00:22:50,838 --> 0:22:53,073
然而 当我们从WAL文件的

408
00:22:53,140 --> 0:22:54,541
移出我们所有的数据之前

409
00:22:55,976 --> 0:22:59,112
为了增量自动清理

410
00:22:59,279 --> 0:23:01,582
的两页到预写日志

411
00:22:59,279 --> 0:23:01,582
的两页到预写日志

412
00:23:02,249 --> 0:23:07,921
在调整数据库树的时候

413
00:23:07,988 --> 0:23:09,489
也会被写入预写日志

414
00:23:10,490 --> 0:23:13,093
接下来 当预写日志获得了检查点

415
00:23:14,261 --> 0:23:16,129
数据库文件本身会被删除

416
00:23:17,197 --> 0:23:19,166
我们从数据库的最后迁移的页面

417
00:23:19,233 --> 0:23:20,534
将会去到之前的空闲页面

418
00:23:20,601 --> 0:23:23,470
任何被更新的父节点会被写入到

419
00:23:24,271 --> 0:23:26,640
那么 就像你看到的

420
00:23:26,707 --> 0:23:28,876
和移出数据库之前

421
00:23:28,942 --> 0:23:31,044
在数据库中修改页面的一个子集

422
00:23:31,945 --> 0:23:33,146
这非常有效率

423
00:23:34,781 --> 0:23:38,218
最后 我们相当推荐使用

424
00:23:38,285 --> 0:23:41,288
通过快速安全地删除

425
00:23:41,355 --> 0:23:42,623
数据库文件大小和隐私

426
00:23:48,128 --> 0:23:49,129
部分索引

427
00:23:51,832 --> 0:23:52,833
索引很棒

428
00:23:53,066 --> 0:23:56,370
索引允许更快的排序分组

429
00:23:57,104 --> 0:23:58,405
不幸的是 他们不能被免费使用

430
00:23:58,572 --> 0:24:00,641
数据库需要支持索引

431
00:23:58,572 --> 0:24:00,641
数据库需要支持索引

432
00:24:00,707 --> 0:24:01,942
这些会有一定量的开销

433
00:24:02,609 --> 0:24:04,011
在我们添加了更多的索引之后

434
00:24:04,244 --> 0:24:07,948
每个新写入到数据库的数据开销

435
00:24:09,950 --> 0:24:11,685
幸运的是 它有更有效率的

436
00:24:11,752 --> 0:24:12,953
部分索引形式的替代品

437
00:24:13,587 --> 0:24:16,490
部分索引允许你使用WHERE

438
00:24:16,557 --> 0:24:18,492
查询子句来描述你想要索引

439
00:24:19,259 --> 0:24:22,729
这很棒 因为现在你能获取到

440
00:24:22,796 --> 0:24:26,967
当你想要它 但又不想为索引

441
00:24:27,034 --> 0:24:28,335
当它不能为你带来任何好处时

442
00:24:33,540 --> 0:24:34,942
那么 SQLite的总结

443
00:24:37,110 --> 0:24:39,580
请尽可能长时间保持数据库连接打开

444
00:24:41,515 --> 0:24:44,117
使用WAL日志登载模式

445
00:24:45,919 --> 0:24:48,355
可能的话 在每个数据处理时

446
00:24:48,422 --> 0:24:51,058
这是SQLite为我们做的优化

447
00:24:53,060 --> 0:24:55,462
使用快速安全删除和自动清理增量

448
00:24:55,696 --> 0:24:58,165
来同时管理你数据库的

449
00:24:59,333 --> 0:25:02,069
如果可行的话

450
00:24:59,333 --> 0:25:02,069
如果可行的话

451
00:25:02,135 --> 0:25:03,303
而不是一般的常规索引

452
00:25:05,706 --> 0:25:09,610
如果你真的不关心SQLite

453
00:25:09,676 --> 0:25:11,879
我们强烈建议你

454
00:25:11,945 --> 0:25:14,448
Core Data为你解决了

455
00:25:15,048 --> 0:25:17,251
因为Core Data

456
00:25:17,651 --> 0:25:20,554
Core Data的适配者

457
00:25:25,292 --> 0:25:27,160
接下来 Alejandro

458
00:25:27,227 --> 0:25:28,795
最新版的文件活跃状态仪表

459
00:25:29,496 --> 0:25:32,966
为我们展示现实世界中我们应该

460
00:25:33,534 --> 0:25:34,535
Alejandro

461
00:25:38,038 --> 0:25:39,706
（文件活跃状态仪表）

462
00:25:41,942 --> 0:25:44,645
好的 谢谢Kai 大家早上好

463
00:25:44,811 --> 0:25:47,014
欢迎大家参加本次关于优化内存

464
00:25:48,448 --> 0:25:50,417
我想介绍我们对

465
00:25:50,484 --> 0:25:52,152
所做的一些提升

466
00:25:52,219 --> 0:25:55,155
来看看我们如何使用它

467
00:25:55,923 --> 0:25:56,890
那么我们开始吧

468
00:25:57,357 --> 0:25:59,259
文件活跃状态仪表有哪些改变？

469
00:26:01,061 --> 0:26:03,297
我们做的第一件事是为所有的

470
00:26:03,363 --> 0:26:04,531
Apple设备增加了支持

471
00:26:04,865 --> 0:26:07,734
所以这意味着你可以使用

472
00:26:07,801 --> 0:26:12,105
在你的iOS设备 Mac

473
00:26:15,409 --> 0:26:18,011
文件活跃状态仪表也允许你

474
00:26:18,078 --> 0:26:21,114
追踪除了你自己的app之外

475
00:26:21,415 --> 0:26:25,853
这样你就能看到你的app的行为

476
00:26:26,119 --> 0:26:28,689
以及它如何同剩下的系统交互

477
00:26:28,755 --> 0:26:30,390
这样你能看到正在进行中的不同交互

478
00:26:32,726 --> 0:26:35,329
接下来 Kai提到过的

479
00:26:35,395 --> 0:26:36,396
逻辑和物理I/O之间是有差别的

480
00:26:36,697 --> 0:26:39,766
了解它们是如何相互交互的

481
00:26:40,100 --> 0:26:42,102
你的I/O使用量是非常重要的

482
00:26:42,402 --> 0:26:45,172
文件活跃状态仪表让我们

483
00:26:47,274 --> 0:26:50,177
最后 我们也添加了

484
00:26:50,611 --> 0:26:53,447
自动推理有各种不同的机制

485
00:26:53,514 --> 0:26:55,249
那么我想要非常简短地介绍一下它

486
00:26:57,451 --> 0:27:00,554
首先 自动推理的其中一个是

487
00:26:57,451 --> 0:27:00,554
首先 自动推理的其中一个是

488
00:27:00,621 --> 0:27:03,156
我们添加它实际上是想要过度的

489
00:27:03,590 --> 0:27:07,094
那么当你在追踪时 文件活跃

490
00:27:07,160 --> 0:27:10,497
一些过度活动行为时

491
00:27:10,564 --> 0:27:12,399
你可以从仪表中直接跳转

492
00:27:12,466 --> 0:27:13,700
来查看是什么导致它发生的

493
00:27:16,703 --> 0:27:20,007
当查看某个I/O相关的系统

494
00:27:20,073 --> 0:27:22,709
我们对此也加入了支持

495
00:27:22,776 --> 0:27:24,611
因为这个框架已经失败了

496
00:27:25,012 --> 0:27:27,648
这些是需要了解的重要的内容

497
00:27:27,714 --> 0:27:29,349
你app中的正确性也同样重要

498
00:27:31,885 --> 0:27:35,756
最后 Kai提到过F FULLFSYNC的

499
00:27:35,822 --> 0:27:38,992
我们也有一个检查次优缓存的机制

500
00:27:39,293 --> 0:27:42,696
这样你就能看到 你的app可能会

501
00:27:42,930 --> 0:27:45,299
没有非常好地利用OS缓存

502
00:27:46,066 --> 0:27:47,568
那么我们从文件活跃状态仪表开始

503
00:27:47,634 --> 0:27:48,635
来看它是什么样子的

504
00:27:49,803 --> 0:27:53,607
使用Instruments 11 当我们打开

505
00:27:53,674 --> 0:27:56,910
文件活跃状态的图标还是和之前相似

506
00:27:56,977 --> 0:27:58,812
这是它所能做的一个总结

507
00:27:59,880 --> 0:28:03,083
如果我们接下来选择它

508
00:27:59,880 --> 0:28:03,083
如果我们接下来选择它

509
00:28:03,951 --> 0:28:06,153
首先是文件系统建议行踪

510
00:28:06,653 --> 0:28:08,722
这个轨道是所有的这些反模式

511
00:28:08,789 --> 0:28:10,958
和自动推理建议的行踪

512
00:28:12,025 --> 0:28:14,061
在它下面

513
00:28:14,361 --> 0:28:16,997
文件系统活跃状态会打断逻辑的读取

514
00:28:17,064 --> 0:28:18,065
逻辑的写入

515
00:28:18,365 --> 0:28:21,301
它会为你展示这些操作发生次数

516
00:28:21,635 --> 0:28:25,739
你也能更深入地了解调用的次数

517
00:28:25,806 --> 0:28:27,007
和某些其他的统计

518
00:28:27,875 --> 0:28:30,210
相似地 在磁盘使用量的正下方

519
00:28:30,277 --> 0:28:32,980
你可以看到相同的读入和写入差别

520
00:28:33,046 --> 0:28:34,214
除了物理的层级之外

521
00:28:34,982 --> 0:28:38,051
最后 磁盘I/O的延时

522
00:28:38,118 --> 0:28:39,486
I/O的时长

523
00:28:40,287 --> 0:28:43,056
那么 我们开始吧

524
00:28:43,724 --> 0:28:46,960
我想实现的第一件事实际上是

525
00:28:47,427 --> 0:28:50,130
那么 在这些图片中

526
00:28:50,397 --> 0:28:52,733
我想要实现的是能选择那个星星

527
00:28:52,799 --> 0:28:54,368
来标记一张图片为最爱

528
00:28:54,935 --> 0:28:57,938
比如 我能选择一张香蕉蛞蝓图片

529
00:28:59,439 --> 0:29:00,541
这些摩天大楼也是

530
00:28:59,439 --> 0:29:00,541
这些摩天大楼也是

531
00:29:01,275 --> 0:29:04,111
我会做的第一步是

532
00:29:04,178 --> 0:29:07,080
通过打开和关闭数据库来实现

533
00:29:07,714 --> 0:29:10,083
Kai讲过这不是最佳的实现方案

534
00:29:10,150 --> 0:29:13,320
但我还是觉得将它导入到文件

535
00:29:13,520 --> 0:29:15,923
我们有一条基线

536
00:29:18,058 --> 0:29:19,760
在我后面 的确是那样

537
00:29:19,826 --> 0:29:23,163
我运行文件活跃状态仪表

538
00:29:23,230 --> 0:29:25,299
和关闭数据库对照相同的工作流

539
00:29:25,966 --> 0:29:28,902
我想要关注磁盘使用量的第一条轨迹

540
00:29:28,969 --> 0:29:30,337
I/O信息所在的地方

541
00:29:31,004 --> 0:29:35,108
我们在物理地写入列

542
00:29:35,175 --> 0:29:37,277
我们看到物理I/O的数量不一致

543
00:29:37,344 --> 0:29:41,582
在当前情况下 在工具提示文字中

544
00:29:42,182 --> 0:29:43,851
但在它的正下方是详情视图

545
00:29:43,917 --> 0:29:45,586
详情视图是所有额外的统计信息

546
00:29:45,652 --> 0:29:48,522
那么我将进到这里

547
00:29:48,589 --> 0:29:49,590
的一些东西

548
00:29:50,958 --> 0:29:54,628
通过放大 我想要知道

549
00:29:54,695 --> 0:29:56,330
这个工作流中的最爱照片

550
00:29:56,563 --> 0:29:59,099
每次操作通过打开和关闭数据库

551
00:29:59,266 --> 0:30:02,002
我们有1,002次不同的

552
00:29:59,266 --> 0:30:02,002
我们有1,002次不同的

553
00:30:02,069 --> 0:30:04,271
总共占有低于6兆字节的内存

554
00:30:05,038 --> 0:30:07,708
这看上去没有很多

555
00:30:07,774 --> 0:30:11,078
我们能更好地了解

556
00:30:11,144 --> 0:30:12,145
为什么这个如此糟糕

557
00:30:12,813 --> 0:30:16,817
那么这里我们有一些关于

558
00:30:17,284 --> 0:30:19,553
但我想要切换回总视图

559
00:30:20,053 --> 0:30:22,556
因为我也注意到

560
00:30:22,623 --> 0:30:25,492
我们有一些仪表给我们的通知

561
00:30:25,792 --> 0:30:28,862
我想要进到里面

562
00:30:29,630 --> 0:30:31,431
在底部 我们的详情视图

563
00:30:31,498 --> 0:30:33,534
这里的详情视图的数量列

564
00:30:33,700 --> 0:30:36,403
告诉我们一共有12条通知

565
00:30:37,704 --> 0:30:40,841
如果我们到下拉框

566
00:30:40,908 --> 0:30:43,076
是过度物理写入的精准描述

567
00:30:43,710 --> 0:30:47,080
我们知道打开和关闭数据库不一定

568
00:30:47,147 --> 0:30:49,516
我们将要尝试其他技术来实现

569
00:30:49,816 --> 0:30:53,153
但我想从这个有着12则

570
00:30:53,220 --> 0:30:54,388
文件活跃状态仪表

571
00:30:57,357 --> 0:31:00,761
最后 我也想要聊一下

572
00:30:57,357 --> 0:31:00,761
最后 我也想要聊一下

573
00:31:01,161 --> 0:31:03,997
我们能从中看到被调用的操作的

574
00:31:04,064 --> 0:31:08,635
比如写入和读入等等

575
00:31:08,802 --> 0:31:11,839
我们也获取到了我们app的

576
00:31:12,339 --> 0:31:14,107
这里默认是文件系统统计信息

577
00:31:14,174 --> 0:31:17,444
但我们也能找到下面的

578
00:31:21,048 --> 0:31:23,317
好的 记住这一点 现在我要切回

579
00:31:23,383 --> 0:31:26,353
到一个不同的模式

580
00:31:27,120 --> 0:31:30,023
特别地 我会回到磁盘

581
00:31:30,557 --> 0:31:32,159
我想要做的第一件事是

582
00:31:32,226 --> 0:31:35,395
我们从1,002次物理I/O操作

583
00:31:35,462 --> 0:31:39,766
跌到至54次 我们从6兆字节

584
00:31:39,933 --> 0:31:43,003
跌到288千字节

585
00:31:43,070 --> 0:31:45,572
当我们打开和关闭我们的数据库时

586
00:31:45,639 --> 0:31:47,841
只用改变使用量模型就能轻易实现

587
00:31:49,610 --> 0:31:52,546
更进一步 再次关注文件系统建议

588
00:31:52,846 --> 0:31:56,617
我们从之前这么做的时候

589
00:31:57,851 --> 0:31:58,952
但现在我们只有3个了

590
00:31:59,353 --> 0:32:02,389
这个还不是最理想的使用方式

591
00:31:59,353 --> 0:32:02,389
这个还不是最理想的使用方式

592
00:32:02,456 --> 0:32:05,325
我们实现了不同的行为表现比如

593
00:32:05,392 --> 0:32:06,393
我们会看到这个数字改变

594
00:32:07,895 --> 0:32:10,397
说到这 我们来开始介绍删除模式

595
00:32:10,564 --> 0:32:12,032
就像Kai提过的

596
00:32:12,099 --> 0:32:13,534
是SQLite默认设置

597
00:32:14,501 --> 0:32:17,871
所以这里的这个统计页面和我之前

598
00:32:17,938 --> 0:32:20,741
按需打开和关闭数据库所

599
00:32:21,041 --> 0:32:24,811
所以我不会再展示整个轨迹

600
00:32:25,179 --> 0:32:28,182
54物理I/O操作

601
00:32:31,051 --> 0:32:33,353
但当我们切换至使用WAL

602
00:32:33,420 --> 0:32:35,589
我想要讲一下一些有趣的现象

603
00:32:37,257 --> 0:32:40,194
首先 现在我们在文件系统

604
00:32:40,260 --> 0:32:41,762
建议轨道上有0个建议

605
00:32:42,362 --> 0:32:44,798
我们之前有12条 最后变为3个

606
00:32:44,865 --> 0:32:48,068
我们只是简单地使用了WAL模式

607
00:32:48,135 --> 0:32:49,136
日志登载就做出了非常巨大的优化

608
00:32:50,337 --> 0:32:53,874
我想讲的第二点是逻辑的

609
00:32:53,941 --> 0:32:55,175
和物理的I/O之间的交互

610
00:32:55,676 --> 0:32:58,512
特别要说的是

611
00:32:58,579 --> 0:33:02,816
我们看到了很多逻辑I/O

612
00:32:58,579 --> 0:33:02,816
我们看到了很多逻辑I/O

613
00:33:02,883 --> 0:33:05,152
直到我们停止app的轨迹

614
00:33:05,786 --> 0:33:06,887
这为什么重要呢？

615
00:33:07,287 --> 0:33:09,389
当我们和之前实现的比较时

616
00:33:09,623 --> 0:33:11,425
使用删除模式日志登载

617
00:33:12,359 --> 0:33:13,560
注意在删除模式日志登载里

618
00:33:13,627 --> 0:33:16,597
每次我们有了文件系统活跃状态

619
00:33:16,663 --> 0:33:19,032
我们也有了一个和它

620
00:33:19,499 --> 0:33:21,969
然而使用WAL模式日志登载

621
00:33:22,035 --> 0:33:24,872
为我们提供了很多很棒的性能表现

622
00:33:26,773 --> 0:33:27,808
想要更为仔细地了解它

623
00:33:27,875 --> 0:33:31,712
我们能再一次回到文件系统活跃轨迹

624
00:33:32,946 --> 0:33:35,549
使用WAL模式日志登载

625
00:33:36,016 --> 0:33:38,919
然而使用删除模式日志登载

626
00:33:39,753 --> 0:33:43,190
所以WAL模式非常好地利用了

627
00:33:46,693 --> 0:33:49,029
接下来 我想讲的是我们如何实现

628
00:33:49,096 --> 0:33:50,097
删除照片功能

629
00:33:50,163 --> 0:33:52,032
我们讲过设置最爱

630
00:33:52,099 --> 0:33:53,700
照片

631
00:33:54,501 --> 0:33:57,271
我们要讲的第一件事是

632
00:33:57,337 --> 0:33:59,673
Kai也提到过的

633
00:34:00,407 --> 0:34:02,776
特别地 当我们想要选择删除一张

634
00:34:02,843 --> 0:34:04,678
我们会选择左下脚的符号

635
00:34:05,078 --> 0:34:07,614
我们会向数据库发送

636
00:34:08,148 --> 0:34:10,184
现在我们可以将这认为是一个

637
00:34:10,250 --> 0:34:13,286
因为我们在每张照片执行

638
00:34:13,353 --> 0:34:15,188
我们自己不会做任何合并

639
00:34:17,757 --> 0:34:20,494
使用这个模型

640
00:34:20,561 --> 0:34:23,864
我们也使用一些文件系统活跃状态

641
00:34:24,864 --> 0:34:26,766
但值得关注的一点是这个方式

642
00:34:26,833 --> 0:34:29,503
我们有111次不同的文件系统操作

643
00:34:31,304 --> 0:34:33,005
到达磁盘使用量轨道

644
00:34:33,072 --> 0:34:36,710
我们有12次写入

645
00:34:39,246 --> 0:34:42,014
接下来 我想要聊一下多次声明

646
00:34:42,081 --> 0:34:44,717
通过这些照片中的每一个

647
00:34:44,952 --> 0:34:46,286
甚至是一个逻辑的视角

648
00:34:46,520 --> 0:34:49,456
我们不想一次只删除这些照片中

649
00:34:49,523 --> 0:34:51,958
合乎逻辑地 我们想要将它们

650
00:34:52,359 --> 0:34:54,695
我们为它使用SQLite

651
00:34:54,761 --> 0:34:57,531
通过合并所有这些删除声明至一次

652
00:34:57,731 --> 0:34:59,633
所以我们在一个单次的数据修改中

653
00:35:00,534 --> 0:35:04,137
如果我们这样做

654
00:35:04,204 --> 0:35:05,873
所以我们显著地减少了工作量

655
00:35:06,974 --> 0:35:09,810
除此之外 如果我们

656
00:35:10,611 --> 0:35:14,581
我们的写入减少到了4个

657
00:35:16,416 --> 0:35:17,684
把它们并排一起看

658
00:35:18,185 --> 0:35:20,621
我们开始一共有111次单个

659
00:35:20,687 --> 0:35:22,155
声明数据修改的文件系统活动

660
00:35:22,489 --> 0:35:25,292
我们使用多次声明数据修改

661
00:35:26,260 --> 0:35:29,296
回到这个这个是如何

662
00:35:29,863 --> 0:35:33,000
我们开始时有12次写入

663
00:35:33,233 --> 0:35:35,502
现在我们使用多次声明数据修改

664
00:35:35,569 --> 0:35:36,970
一共24千字节

665
00:35:39,072 --> 0:35:41,975
因为我们在介绍关于删除的话题

666
00:35:42,042 --> 0:35:44,044
应为我们想保持我们的数据

667
00:35:44,111 --> 0:35:45,479
或尽可能紧凑

668
00:35:45,979 --> 0:35:47,414
我们从一个全面的清理开始了解

669
00:35:47,948 --> 0:35:49,983
在当前使用案例中 每次当我们

670
00:35:50,050 --> 0:35:51,618
我们会发出一条清理声明

671
00:35:52,119 --> 0:35:55,656
Kai告诉过我们全面清理

672
00:35:55,722 --> 0:35:58,692
但我们能看到它在文件活跃状态仪表

673
00:36:00,060 --> 0:36:04,631
特别地 通过实现这个

674
00:36:04,698 --> 0:36:07,334
发出一条全面的清理

675
00:36:09,736 --> 0:36:12,506
但如果我们切换至使用增量清除呢

676
00:36:13,540 --> 0:36:14,608
我们有一些不同的数字

677
00:36:15,342 --> 0:36:19,346
我们为72千字节的存储占用

678
00:36:22,549 --> 0:36:24,151
再一次 把它们并排看

679
00:36:25,052 --> 0:36:27,588
使用一个全面清理

680
00:36:27,654 --> 0:36:29,790
使用增量清理

681
00:36:30,090 --> 0:36:35,395
从全面清除的168K的总磁盘占用

682
00:36:36,129 --> 0:36:38,232
通过在SQLite中使用这些模式

683
00:36:38,298 --> 0:36:39,733
它获取了颇多利益

684
00:36:44,271 --> 0:36:46,073
那么 我现在想要总结一下

685
00:36:46,139 --> 0:36:49,376
第一点是我想要你

686
00:36:49,443 --> 0:36:53,113
无论你是在使用Core Data

687
00:36:53,180 --> 0:36:56,083
我们想要你吸取这些教训

688
00:36:56,149 --> 0:36:59,152
我们也希望你能使用文件

689
00:36:59,653 --> 0:37:02,022
现在文件活跃状态仪表可能会

690
00:36:59,653 --> 0:37:02,022
现在文件活跃状态仪表可能会

691
00:37:02,089 --> 0:37:04,958
通过提供这些功能来帮你

692
00:37:05,025 --> 0:37:07,728
你甚至不知道的建议

693
00:37:07,794 --> 0:37:10,531
会将它们以可视化的方式提供给你

694
00:37:12,399 --> 0:37:15,536
记住这些 我们也希望你能持续

695
00:37:15,869 --> 0:37:19,006
除了眼前的这些内容之外还有更多

696
00:37:19,072 --> 0:37:20,440
我们希望这些教训和

697
00:37:20,641 --> 0:37:22,242
能为每个人带来好的体验

698
00:37:24,511 --> 0:37:27,981
想要了解更多信息 今天晚些时候

699
00:37:28,048 --> 0:37:31,051
今年的WWDC

700
00:37:31,118 --> 0:37:32,286
关于使用Core Data

701
00:37:32,352 --> 0:37:35,022
如果你想要了解更多

702
00:37:37,691 --> 0:37:39,726
感谢大家参加
