1
00:00:06,273 --> 0:00:10,711
（低延迟HTTP现场直播）

2
00:00:12,679 --> 0:00:13,680
嘿！

3
00:00:14,882 --> 0:00:16,049
下午好

4
00:00:16,917 --> 0:00:18,118
大家下午好

5
00:00:19,319 --> 0:00:20,787
我是Roger Pantos

6
00:00:20,954 --> 0:00:26,793
今天关于HLS的演讲我们主要讲

7
00:00:27,494 --> 0:00:29,863
首先

8
00:00:30,531 --> 0:00:35,035
当我们提到低延迟时什么是延迟呢？

9
00:00:36,570 --> 0:00:38,672
嗯 在这个情境中

10
00:00:39,106 --> 0:00:40,941
它指的是时间量

11
00:00:41,175 --> 0:00:43,677
从摄像头开始记录视频时

12
00:00:43,744 --> 0:00:45,646
或击中你的产品后台时

13
00:00:46,013 --> 0:00:47,347
以及当用户

14
00:00:47,548 --> 0:00:52,186
在家里在iPad或

15
00:00:53,353 --> 0:00:56,456
缩短延迟的持续时间

16
00:00:56,523 --> 0:01:01,228
保持简短的持续时间

17
00:00:56,523 --> 0:01:01,228
保持简短的持续时间

18
00:01:02,596 --> 0:01:07,134
其中我们很可能最熟悉的一种类型是

19
00:01:07,901 --> 0:01:11,171
但对于最新消息来说也很重要

20
00:01:11,405 --> 0:01:15,375
比如游戏直播

21
00:01:16,009 --> 0:01:18,812
甚至比如奥斯卡颁奖这样的新闻

22
00:01:19,079 --> 0:01:22,149
实际上 这对于任何有大量人群

23
00:01:22,216 --> 0:01:25,352
同时观看同一个视频时的情况

24
00:01:25,686 --> 0:01:28,088
通常它存在社交因素

25
00:01:28,789 --> 0:01:35,028
那么延迟需要有多低才能提供

26
00:01:36,496 --> 0:01:42,970
嗯 如今的金标准大约是二到八秒

27
00:01:43,403 --> 0:01:46,673
这是由当前设备情况决定的

28
00:01:46,740 --> 0:01:49,743
电视广播装置、电缆、卫星电视

29
00:01:50,644 --> 0:01:53,413
因此 当我们设计低延迟HLS时

30
00:01:53,780 --> 0:01:55,349
我们就给我们设置了一个目标

31
00:01:56,083 --> 0:01:59,086
在任何合理的往返时间内

32
00:01:59,520 --> 0:02:01,288
比公共互联网上的大规模直播

33
00:01:59,520 --> 0:02:01,288
比公共互联网上的大规模直播

34
00:02:01,588 --> 0:02:03,590
延迟一到两秒

35
00:02:04,691 --> 0:02:08,262
现在我们不需要牺牲任何东西

36
00:02:09,329 --> 0:02:12,966
不需要牺牲任何功能就能让HLS

37
00:02:13,534 --> 0:02:18,205
因此我们仍采用品质来匹配

38
00:02:18,639 --> 0:02:20,774
我们仍允许你保护你的内容

39
00:02:21,008 --> 0:02:23,143
我们仍允许你插入广告

40
00:02:23,477 --> 0:02:26,914
并提供程序边界和其它元数据

41
00:02:28,282 --> 0:02:32,753
我们仍可以让你以经济有效的方式

42
00:02:32,953 --> 0:02:39,493
把你的广播推广给数十万

43
00:02:40,594 --> 0:02:45,065
我们确保这些数据流向后兼容

44
00:02:45,699 --> 0:02:50,304
因此你仍可以看到数据流在较老的

45
00:02:51,471 --> 0:02:53,607
我们是如何实现这些的？

46
00:02:54,908 --> 0:02:57,477
嗯 要了解这个问题

47
00:02:58,111 --> 0:03:03,717
我们首先要返回到常规的HLS

48
00:02:58,111 --> 0:03:03,717
我们首先要返回到常规的HLS

49
00:03:05,919 --> 0:03:08,522
首先

50
00:03:08,956 --> 0:03:14,061
从起初开始 HLS就被设计成一个

51
00:03:14,428 --> 0:03:15,729
那非常棒

52
00:03:16,430 --> 0:03:22,202
事实上 如果你的内容

53
00:03:22,936 --> 0:03:24,605
你知道的

54
00:03:24,771 --> 0:03:27,875
你应该继续使用常规的HLS

55
00:03:28,809 --> 0:03:32,012
但那种简单是有代价的

56
00:03:32,212 --> 0:03:34,214
当你观看体育赛事时 比如说

57
00:03:34,715 --> 0:03:37,117
那种代价的表现通常是

58
00:03:37,284 --> 0:03:40,287
你在Apple TV上

59
00:03:40,454 --> 0:03:42,356
你会先通过公寓的墙面听到得分

60
00:03:43,924 --> 0:03:45,025
这是为什么呢？

61
00:03:45,859 --> 0:03:47,127
嗯 要理解这个问题

62
00:03:47,628 --> 0:03:51,665
让我们看一下常规HLS如何

63
00:03:52,099 --> 0:03:54,668
从产品后台获取特定帧

64
00:03:55,068 --> 0:03:58,038
并发送给在家里的用户

65
00:03:58,872 --> 0:04:00,040
我们先看一下帧

66
00:03:58,872 --> 0:04:00,040
我们先看一下帧

67
00:04:00,274 --> 0:04:04,311
我们要做的第一件事就是编码帧

68
00:04:04,711 --> 0:04:06,780
现在我们推荐六秒钟为一段

69
00:04:07,114 --> 0:04:10,717
但那确实意味着

70
00:04:10,984 --> 0:04:14,655
因此甚至在你有能放在CDN上的

71
00:04:15,756 --> 0:04:19,959
在我们得到那个视频段之后

72
00:04:20,928 --> 0:04:24,164
现今HLS使用查询机制

73
00:04:24,231 --> 0:04:27,434
意思是客户端时常检查服务器端

74
00:04:27,501 --> 0:04:30,103
看是否有最新的播放列表

75
00:04:31,071 --> 0:04:33,874
在最佳情况下 客户端可能会说

76
00:04:34,141 --> 0:04:39,313
服务器端一向播放列表中

77
00:04:39,379 --> 0:04:42,482
这很棒 但通常我们不能实现那种

78
00:04:42,549 --> 0:04:44,451
事实上 在某些情况下

79
00:04:44,518 --> 0:04:46,486
甚至在客户端发现有新视频段之前

80
00:04:46,787 --> 0:04:50,090
差不多还存在另一个六秒钟

81
00:04:51,525 --> 0:04:54,962
在客户端发现之后 取回新播放列表

82
00:04:55,362 --> 0:04:57,564
然后客户端必须转向反方向

83
00:04:57,865 --> 0:04:59,533
才能实际上获得视频段

84
00:05:00,167 --> 0:05:04,304
请记住 每个请求在网络上

85
00:05:05,005 --> 0:05:07,241
在某些网络中 特别是蜂窝

86
00:05:07,574 --> 0:05:09,243
这段时间可能在数百毫秒内

87
00:05:09,309 --> 0:05:11,378
并不是无关紧要的

88
00:05:12,646 --> 0:05:14,248
因此无论怎样

89
00:05:14,648 --> 0:05:17,017
视频段才开始流入客户端

90
00:05:17,751 --> 0:05:20,854
然后一旦客户端获得足够多的视频段

91
00:05:21,355 --> 0:05:24,892
在这个例子中

92
00:05:25,459 --> 0:05:29,229
但如果你通过CDN提交内容

93
00:05:29,630 --> 0:05:34,668
我们绝大多数人都是通过CDN

94
00:05:35,702 --> 0:05:36,870
原因是

95
00:05:37,171 --> 0:05:42,976
由于常规HLS与

96
00:05:43,043 --> 0:05:44,111
让我们看一下

97
00:05:45,279 --> 0:05:49,383
想象一下你获得了你的HLS视频流

98
00:05:49,449 --> 0:05:51,585
你将其发布到右侧的视频源中

99
00:05:51,785 --> 0:05:53,086
在特定时间内

100
00:05:53,453 --> 0:05:56,190
它的播放列表有三个视频段

101
00:05:56,857 --> 0:06:00,661
现在第一个客户端想查找最新、

102
00:05:56,857 --> 0:06:00,661
现在第一个客户端想查找最新、

103
00:06:01,495 --> 0:06:04,364
如果客户端所通讯的

104
00:06:04,598 --> 0:06:06,867
尚未缓存任何那种媒体内容

105
00:06:07,167 --> 0:06:10,370
它实际上状况良好

106
00:06:10,671 --> 0:06:12,339
CDN将从源获取播放列表

107
00:06:12,573 --> 0:06:14,575
获取最新版本并直接发送给客户端

108
00:06:14,641 --> 0:06:15,776
客户端1状况良好

109
00:06:16,410 --> 0:06:19,680
问题出现在一秒或两秒钟之后

110
00:06:20,113 --> 0:06:21,415
当在源上

111
00:06:21,882 --> 0:06:25,219
我们从众多视频段中得到了一个

112
00:06:25,586 --> 0:06:28,355
现在播放列表包含视频段1到4

113
00:06:29,323 --> 0:06:30,691
那之后会发生什么？

114
00:06:30,991 --> 0:06:33,493
当客户端2进入并再次查找时

115
00:06:33,560 --> 0:06:35,262
“好的 有哪些最新内容？”

116
00:06:35,963 --> 0:06:38,565
嗯 客户端2将取回的播放列表

117
00:06:38,799 --> 0:06:42,703
是仅包含视频段1到3的

118
00:06:42,769 --> 0:06:45,739
它甚至都不能发现有视频段4

119
00:06:46,006 --> 0:06:50,277
因为CDN为它提供了播放列表的

120
00:06:51,545 --> 0:06:54,414
为什么CDN会这样做呢？

121
00:06:55,816 --> 0:06:58,218
嗯 它就不能给它提供最新版本吗？

122
00:06:58,986 --> 0:07:03,090
嗯 问题是CDN没有办法了解

123
00:06:58,986 --> 0:07:03,090
嗯 问题是CDN没有办法了解

124
00:07:03,323 --> 0:07:05,726
源上已经更新了播放列表

125
00:07:06,460 --> 0:07:09,329
如果有每次有随机客户端进入

126
00:07:09,596 --> 0:07:12,266
并说“嘿 最新播放列表是什么？”

127
00:07:12,332 --> 0:07:13,901
它就进入并检查源

128
00:07:14,134 --> 0:07:15,702
那会让源变得一团糟

129
00:07:16,537 --> 0:07:19,673
因此CDN需要缓存一段时间

130
00:07:19,740 --> 0:07:21,008
这叫做生存时间

131
00:07:21,909 --> 0:07:24,878
生存时间越长

132
00:07:25,479 --> 0:07:27,414
客户端查看

133
00:07:27,481 --> 0:07:29,550
并看到过时的播放列表版本的

134
00:07:29,783 --> 0:07:33,053
并又把现场延迟时间拉长了那么多

135
00:07:34,721 --> 0:07:39,393
所有问题都可以被修复

136
00:07:40,727 --> 0:07:44,464
但在决定如何修复时

137
00:07:44,831 --> 0:07:48,435
我们需要考虑更多因素

138
00:07:49,803 --> 0:07:54,608
第一个是HTTP仍然是

139
00:07:54,875 --> 0:07:56,543
通过因特网向数十万人

140
00:07:57,177 --> 0:08:01,949
同时提交同一媒体内容的最佳方式

141
00:07:57,177 --> 0:08:01,949
同时提交同一媒体内容的最佳方式

142
00:08:02,416 --> 0:08:04,151
因此我们应该坚持用HTTP

143
00:08:04,751 --> 0:08:10,924
但那样做意味着

144
00:08:11,191 --> 0:08:15,262
那会给客户端分配不连续的视频段

145
00:08:15,329 --> 0:08:18,765
不连续的资源块

146
00:08:19,199 --> 0:08:23,237
如果它需要六秒钟才能产生那个

147
00:08:23,804 --> 0:08:25,739
那么我们已经错过了我们的最终目标

148
00:08:26,273 --> 0:08:30,010
如果我们能实现比现场

149
00:08:30,611 --> 0:08:34,214
那么我们通过HTTP所分配的内容

150
00:08:34,914 --> 0:08:37,284
在某些情况下会变得更短

151
00:08:38,684 --> 0:08:40,787
我们要努力克服的下一件事

152
00:08:41,154 --> 0:08:43,823
是现在对于可预见的未来

153
00:08:44,091 --> 0:08:49,763
CDN对于帮助我们扩展到

154
00:08:50,864 --> 0:08:53,500
但CDN最终

155
00:08:53,834 --> 0:08:58,238
从本质上来说是HTTP代理缓存

156
00:08:58,705 --> 0:09:01,575
我们必须面对这个问题

157
00:08:58,705 --> 0:09:01,575
我们必须面对这个问题

158
00:09:02,876 --> 0:09:05,078
最后一件事是

159
00:09:05,546 --> 0:09:08,415
当我们延迟的时间非常接近现场时

160
00:09:08,615 --> 0:09:10,751
我们只能提前缓冲非常少量的内容

161
00:09:10,817 --> 0:09:11,785
因为那就是我们所得到的全部内容

162
00:09:12,686 --> 0:09:17,558
因此 如果我们要执行比如切换到

163
00:09:18,225 --> 0:09:19,459
那么我们只能得到比如

164
00:09:19,826 --> 0:09:22,329
在我们失速之前我们没有

165
00:09:22,696 --> 0:09:25,299
我们可能只有不到一秒钟

166
00:09:25,666 --> 0:09:27,134
因此我们要确保

167
00:09:27,367 --> 0:09:30,804
切换机制要尽可能得高效

168
00:09:31,171 --> 0:09:32,706
因为我们的执行时间很短

169
00:09:33,807 --> 0:09:34,641
因此

170
00:09:35,909 --> 0:09:42,482
我们查看了整个HLS提交模型

171
00:09:43,016 --> 0:09:47,154
并且我们发现了需要做出

172
00:09:47,521 --> 0:09:49,056
五处大的修改

173
00:09:49,389 --> 0:09:54,127
从而实现这个比现场延迟

174
00:09:55,028 --> 0:09:56,730
我们要讲的第一件事

175
00:09:57,397 --> 0:10:03,203
就是我们需要一种能把那个媒体内容

176
00:09:57,397 --> 0:10:03,203
就是我们需要一种能把那个媒体内容

177
00:10:04,605 --> 0:10:06,240
时间要小于六秒

178
00:10:06,440 --> 0:10:08,542
我们把它叫做减少发布延迟

179
00:10:10,143 --> 0:10:11,311
我们的实现方式是

180
00:10:11,378 --> 0:10:13,614
我们允许服务器

181
00:10:13,814 --> 0:10:18,385
在主视频段准备好之前

182
00:10:18,919 --> 0:10:21,221
因此我们可以提前提交这些

183
00:10:22,055 --> 0:10:23,624
我们要做的第二件事是

184
00:10:24,024 --> 0:10:28,028
优化客户端发现视频段的方式

185
00:10:28,462 --> 0:10:29,897
从而客户端可以迅速发现视频段

186
00:10:30,063 --> 0:10:31,298
我们的实现方式是

187
00:10:31,765 --> 0:10:36,436
修改客户端更新它的播放列表的方式

188
00:10:37,171 --> 0:10:40,240
我们允许客户端在播放列表实际上

189
00:10:40,674 --> 0:10:43,277
提前请求特定的播放列表更新

190
00:10:43,911 --> 0:10:46,680
然后服务器端将保有那个请求

191
00:10:46,747 --> 0:10:50,651
并关注播放列表

192
00:10:50,884 --> 0:10:55,889
那时你将立刻把播放列表发送回

193
00:10:57,224 --> 0:11:01,028
客户端将在小于往返时间的时间内

194
00:10:57,224 --> 0:11:01,028
客户端将在小于往返时间的时间内

195
00:11:01,695 --> 0:11:03,230
在这个模型中

196
00:11:03,730 --> 0:11:07,534
每个单一播放列表更新

197
00:11:08,335 --> 0:11:10,637
这提供了一秒钟的优势

198
00:11:11,305 --> 0:11:12,840
也就是

199
00:11:13,273 --> 0:11:16,910
它让这些播放列表更新的缓存

200
00:11:17,544 --> 0:11:20,214
因为每次更新都有不同的URL

201
00:11:20,614 --> 0:11:23,550
每个更新看起来都像是一个独立的

202
00:11:24,384 --> 0:11:25,686
现在发生的是

203
00:11:26,086 --> 0:11:28,789
当客户端1想获得特定更新时

204
00:11:29,156 --> 0:11:30,057
它会发出请求

205
00:11:30,257 --> 0:11:31,892
CDN说“我从没听说过

206
00:11:31,959 --> 0:11:33,393
我要直接去源那儿”

207
00:11:33,760 --> 0:11:35,796
然后源会说“嗯

208
00:11:36,063 --> 0:11:37,297
因此现在它就离开了

209
00:11:37,531 --> 0:11:38,699
一旦它获得那个更新

210
00:11:39,066 --> 0:11:41,401
它就把更新传给CDN

211
00:11:42,269 --> 0:11:45,105
下一个客户端进入时

212
00:11:45,639 --> 0:11:49,810
CDN通过使用URL对其进行了

213
00:11:49,877 --> 0:11:52,779
后续的每个请求更新的客户端

214
00:11:53,180 --> 0:11:56,316
都将立即获得CDN缓存

215
00:11:56,884 --> 0:11:59,286
但下一次

216
00:11:59,586 --> 0:12:02,723
此后第一个客户端或任何其它客户端

217
00:11:59,586 --> 0:12:02,723
此后第一个客户端或任何其它客户端

218
00:12:03,790 --> 0:12:07,160
发送CDN的URL

219
00:12:07,561 --> 0:12:10,764
因此CDN立即就知道它的缓存里

220
00:12:10,831 --> 0:12:12,366
它将不会传输过时的内容

221
00:12:12,666 --> 0:12:14,268
相反它会立即返回到源

222
00:12:14,334 --> 0:12:15,736
源说“嗯 我还没有创建”

223
00:12:16,103 --> 0:12:18,605
然后一旦它创建好

224
00:12:18,939 --> 0:12:23,644
它就把它传回给CDN

225
00:12:25,646 --> 0:12:26,480
因此

226
00:12:27,814 --> 0:12:33,287
这些新播放列表更新请求是

227
00:12:33,720 --> 0:12:37,558
那会让缓存在CDN上更好地运作

228
00:12:38,859 --> 0:12:40,961
我们要做的第三件事是

229
00:12:41,662 --> 0:12:45,232
消除额外的往返

230
00:12:45,532 --> 0:12:48,669
在你发现一个视频段离开

231
00:12:49,503 --> 0:12:51,572
我们的实现方式是使用“推送”

232
00:12:52,372 --> 0:12:55,509
当客户端请求下一个播放列表更新时

233
00:12:56,343 --> 0:12:57,644
它会告诉服务器端

234
00:12:57,845 --> 0:12:58,946
“顺便提一下

235
00:12:59,546 --> 0:13:02,916
当你得到我所不知道的

236
00:12:59,546 --> 0:13:02,916
当你得到我所不知道的

237
00:13:03,450 --> 0:13:05,118
我希望你…

238
00:13:05,285 --> 0:13:06,954
当你给我返回那个播放列表时

239
00:13:07,020 --> 0:13:09,122
我希望你立即把那个视频段推送给我

240
00:13:09,523 --> 0:13:12,893
那样我就不需要转向反方向

241
00:13:15,262 --> 0:13:16,930
我们要做的第四件事是

242
00:13:17,164 --> 0:13:21,468
我们要一遍又一遍地

243
00:13:21,535 --> 0:13:22,603
设法处理转移播放列表的成本

244
00:13:22,970 --> 0:13:26,373
我们所采用的基本方式是

245
00:13:26,940 --> 0:13:28,642
它的运作方式是

246
00:13:28,976 --> 0:13:32,145
客户端首次请求特定媒体播放列表时

247
00:13:32,446 --> 0:13:33,614
它会取回完整的播放列表

248
00:13:34,248 --> 0:13:37,985
然而在此之后

249
00:13:38,252 --> 0:13:43,357
它只对了解末端发生变更的部分

250
00:13:43,790 --> 0:13:46,026
因此 在此之后

251
00:13:46,827 --> 0:13:48,395
下一次它请求播放列表时 它会说

252
00:13:48,695 --> 0:13:50,764
“我想要播放列表更新

253
00:13:51,198 --> 0:13:52,466
它所返回的是

254
00:13:53,100 --> 0:13:56,937
非常少的数据块 只包含

255
00:13:57,237 --> 0:13:59,673
在实际数字播放列表中

256
00:13:59,740 --> 0:14:02,709
这些更新通常会放在一个数据包中

257
00:13:59,740 --> 0:14:02,709
这些更新通常会放在一个数据包中

258
00:14:03,043 --> 0:14:04,278
单一MTU数据

259
00:14:04,578 --> 0:14:07,814
因此这对于后续的每次更新来说

260
00:14:09,583 --> 0:14:11,552
现在第五个变更是

261
00:14:11,852 --> 0:14:15,989
因为我们现在知道

262
00:14:16,557 --> 0:14:19,326
我们可以用它们携带一些信息

263
00:14:19,526 --> 0:14:22,429
那可以帮助我们把切换到其它

264
00:14:23,697 --> 0:14:27,000
换句话说

265
00:14:27,568 --> 0:14:29,102
客户端正在以第一种比特率播放

266
00:14:30,204 --> 0:14:35,108
当它请求更新时

267
00:14:35,342 --> 0:14:39,046
它可以携带其它信息

268
00:14:39,580 --> 0:14:42,883
比如如果它决定它需要切换到

269
00:14:43,150 --> 0:14:45,719
它可以直接获取

270
00:14:45,986 --> 0:14:47,254
2MB播放列表的最新版本

271
00:14:47,454 --> 0:14:50,390
这就使切换比特率变得更有效率了

272
00:14:51,525 --> 0:14:54,061
因此这五个变更是

273
00:14:55,429 --> 0:14:58,599
我们减少发布延迟

274
00:14:58,999 --> 0:15:00,667
优化视频段的发觉

275
00:14:58,999 --> 0:15:00,667
优化视频段的发觉

276
00:15:01,268 --> 0:15:02,803
我们消除往返

277
00:15:03,303 --> 0:15:05,973
我们减少转移播放列表的消耗

278
00:15:06,240 --> 0:15:08,909
并且我们使切换层的速度尽可能地快

279
00:15:09,576 --> 0:15:11,979
现在让我们具体看一下

280
00:15:14,748 --> 0:15:17,484
为了让这些新功能运作起来

281
00:15:19,686 --> 0:15:22,089
客户端需要一种方式来告诉服务器端

282
00:15:22,356 --> 0:15:25,192
它想确保这些新功能

283
00:15:25,259 --> 0:15:28,362
比如播放列表Delta更新

284
00:15:30,731 --> 0:15:36,003
它的实现方式是

285
00:15:38,005 --> 0:15:40,374
它的运作方式是服务自身

286
00:15:40,440 --> 0:15:41,975
是由服务器端使用一个新标签公布的

287
00:15:42,176 --> 0:15:44,378
即服务器控制标签

288
00:15:45,579 --> 0:15:47,614
当客户端发现服务可用时

289
00:15:47,881 --> 0:15:49,016
它通过给服务器端发送少量指令

290
00:15:49,283 --> 0:15:52,052
来使用它们

291
00:15:52,352 --> 0:15:57,291
这些指令作为查询参数

292
00:15:58,225 --> 0:15:59,626
看起来是类似这样的东西

293
00:16:00,827 --> 0:16:01,662
现在

294
00:16:03,564 --> 0:16:04,765
这是首次

295
00:16:05,032 --> 0:16:08,168
我们把查询参数

296
00:16:08,936 --> 0:16:09,803
因此

297
00:16:10,170 --> 0:16:14,007
我们会继续储备所有查询参数

298
00:16:14,074 --> 0:16:17,611
从播放列表URL上的

299
00:16:17,978 --> 0:16:19,346
它用于协议的使用

300
00:16:20,214 --> 0:16:21,515
我们要做的另一件事就是

301
00:16:21,748 --> 0:16:24,484
确保在所有客户端

302
00:16:24,751 --> 0:16:29,289
那些查询参数都以确定性顺序

303
00:16:29,723 --> 0:16:33,260
从而不会导致CDN缓存

304
00:16:33,460 --> 0:16:35,929
同一请求的多个有效附本

305
00:16:36,864 --> 0:16:41,902
现在让我们更具体地看一下

306
00:16:44,371 --> 0:16:46,673
第一个是处理这个概念…

307
00:16:46,740 --> 0:16:49,376
是减少发布延迟

308
00:16:49,443 --> 0:16:54,381
因此我们向HLS引入了

309
00:16:54,915 --> 0:16:56,650
我们把这些简称为“部分”

310
00:16:57,851 --> 0:17:02,122
因此部分视频段实际上就是

311
00:16:57,851 --> 0:17:02,122
因此部分视频段实际上就是

312
00:17:02,422 --> 0:17:06,660
包含那个父视频段内

313
00:17:07,794 --> 0:17:12,665
并且CMAF已经给这种内容

314
00:17:12,733 --> 0:17:15,636
叫作CAMF数据块或FMP4内容

315
00:17:16,036 --> 0:17:20,406
因此在HLS中你可以使用

316
00:17:20,741 --> 0:17:23,577
你还可以使用少量传输流

317
00:17:23,644 --> 0:17:27,013
或任何其它已定义的

318
00:17:27,247 --> 0:17:28,515
作为部分视频段

319
00:17:30,551 --> 0:17:32,519
它们的主要问题在于它们很短

320
00:17:33,053 --> 0:17:35,022
比如它们可以不到一个完整的GOP

321
00:17:35,088 --> 0:17:36,290
那意味着你可以有

322
00:17:36,523 --> 0:17:40,294
半秒钟的部分视频段并仍保持

323
00:17:42,763 --> 0:17:45,132
每次你创建新的部分视频段时

324
00:17:45,332 --> 0:17:46,867
它都被添加到播放列表中

325
00:17:47,234 --> 0:17:51,205
那意味着如果你已经得到了半秒钟的

326
00:17:51,638 --> 0:17:55,576
然后你可以在它击中你的产品后台

327
00:17:56,143 --> 0:17:58,979
把内容发布到你的CDN

328
00:17:59,246 --> 0:18:01,682
它只能减少这么短时间的发布延迟

329
00:17:59,246 --> 0:18:01,682
它只能减少这么短时间的发布延迟

330
00:18:03,750 --> 0:18:05,819
部分视频段与常规视频段流

331
00:18:06,153 --> 0:18:12,025
但部分视频段不会保留太长时间

332
00:18:13,861 --> 0:18:18,465
那是因为部分视频段主要

333
00:18:18,999 --> 0:18:20,667
当播放非常接近现场时有用

334
00:18:20,734 --> 0:18:24,838
它们可以让客户端尽快发现媒体内容

335
00:18:25,372 --> 0:18:30,377
并且那些部分视频段的详细的

336
00:18:30,644 --> 0:18:32,913
允许加入那些视频流的客户端的

337
00:18:33,213 --> 0:18:37,017
延迟时间更短

338
00:18:37,818 --> 0:18:42,923
但在部分视频段偏离现场边界更远

339
00:18:42,990 --> 0:18:45,559
并且它们的父视频段

340
00:18:45,859 --> 0:18:47,227
客户端实际上

341
00:18:47,294 --> 0:18:49,963
加载父视频段

342
00:18:50,030 --> 0:18:53,033
因此部分视频段

343
00:18:53,767 --> 0:18:56,036
这会帮助保持播放列表的紧凑性

344
00:18:56,970 --> 0:19:00,807
它的运作方式是当你生产视频段时

345
00:18:56,970 --> 0:19:00,807
它的运作方式是当你生产视频段时

346
00:19:00,974 --> 0:19:03,043
你同时会生产部分视频段

347
00:19:03,677 --> 0:19:04,511
不久之后

348
00:19:04,578 --> 0:19:08,415
随着那些部分视频段距离现场边界

349
00:19:08,615 --> 0:19:12,920
它们就被移除并且替换为

350
00:19:13,520 --> 0:19:16,290
让我们在实际的HLS播放列表中

351
00:19:17,891 --> 0:19:20,027
我这里有一些东西

352
00:19:20,427 --> 0:19:23,330
我希望你注意的第一件事是

353
00:19:23,630 --> 0:19:26,600
就像常规播放列表有目标持续时间

354
00:19:26,800 --> 0:19:28,802
表明视频段有多长一样

355
00:19:29,570 --> 0:19:32,539
部分视频段也有同样的东西

356
00:19:32,773 --> 0:19:35,609
它表明了这个播放列表中的

357
00:19:35,676 --> 0:19:39,346
部分视频段最多有十分之一秒的

358
00:19:39,413 --> 0:19:41,782
要注意的下一件事是

359
00:19:41,849 --> 0:19:43,617
是一个6秒的视频段43

360
00:19:44,785 --> 0:19:48,422
当我们把视频段43

361
00:19:48,622 --> 0:19:52,926
我们可以放…

362
00:19:53,227 --> 0:19:56,430
我们使用一个新标签实现

363
00:19:57,030 --> 0:20:01,401
因此你可以看到每个部分标签

364
00:19:57,030 --> 0:20:01,401
因此你可以看到每个部分标签

365
00:20:01,468 --> 0:20:04,371
因此视频段获得…

366
00:20:04,605 --> 0:20:08,242
视频段44.1是半秒钟

367
00:20:08,408 --> 0:20:11,178
并且它是独立的

368
00:20:12,379 --> 0:20:13,580
在此之后半秒钟

369
00:20:14,114 --> 0:20:17,618
我们可以向播放列表中添加

370
00:20:18,018 --> 0:20:19,086
如此反复

371
00:20:19,152 --> 0:20:21,722
这是一个6秒的播放列表

372
00:20:22,422 --> 0:20:26,193
一旦我们到达视频段44的

373
00:20:26,593 --> 0:20:29,730
我们实际上已经拥有整个父视频段了

374
00:20:29,963 --> 0:20:33,567
因此我们可以同时发布

375
00:20:33,934 --> 0:20:35,969
和父视频段

376
00:20:36,270 --> 0:20:39,006
然后半秒钟之后 再次重复这种循环

377
00:20:39,306 --> 0:20:41,175
我们就得到了视频段45

378
00:20:41,775 --> 0:20:44,211
然后不久之后

379
00:20:44,511 --> 0:20:46,346
中间的那些部分视频段

380
00:20:46,547 --> 0:20:49,149
就距离播放列表的最前方足够远了

381
00:20:49,416 --> 0:20:50,684
它们就可以被移除了

382
00:20:50,984 --> 0:20:54,655
现在我们已经有了视频段43、

383
00:20:54,922 --> 0:20:57,758
以及视频段45的一部分及其以后

384
00:20:58,792 --> 0:21:02,196
这就是我们如何使用部分视频段

385
00:20:58,792 --> 0:21:02,196
这就是我们如何使用部分视频段

386
00:21:02,863 --> 0:21:06,400
现在让我们看一下

387
00:21:07,968 --> 0:21:11,972
我们通过叫做

388
00:21:12,372 --> 0:21:13,340
它的运作方式是

389
00:21:13,574 --> 0:21:16,276
服务器端公布它可以

390
00:21:16,343 --> 0:21:18,345
处理阻止播放列表重加载

391
00:21:18,745 --> 0:21:23,317
通过在服务器控制标签中放一个

392
00:21:24,251 --> 0:21:25,519
当客户端看到这个参数之后

393
00:21:25,786 --> 0:21:28,388
它就知道它可以

394
00:21:28,755 --> 0:21:30,557
提前请求下一个播放列表更新

395
00:21:30,624 --> 0:21:32,860
因此我们通过这种方式

396
00:21:34,361 --> 0:21:36,797
那时服务器端收到请求

397
00:21:36,864 --> 0:21:39,166
意识到还没有客户端请求

398
00:21:39,333 --> 0:21:40,501
播放列表更新

399
00:21:40,701 --> 0:21:42,603
那它就会保有它直到有请求为止

400
00:21:44,371 --> 0:21:47,708
客户端是如何向服务器端指明

401
00:21:48,342 --> 0:21:50,143
它想要哪个更新的呢

402
00:21:51,144 --> 0:21:54,214
它想要一个包含部分视频段的

403
00:21:54,915 --> 0:21:58,352
嗯 它使用HLS的一个功能

404
00:21:58,919 --> 0:22:04,424
现在HLS播放列表中的每个视频段

405
00:21:58,919 --> 0:22:04,424
现在HLS播放列表中的每个视频段

406
00:22:05,158 --> 0:22:07,728
播放列表中第一个视频段的序列号

407
00:22:07,995 --> 0:22:10,163
是你在顶部看到的

408
00:22:10,230 --> 0:22:11,231
那个媒体序列标签的值

409
00:22:11,798 --> 0:22:13,433
在这个例子中是1800

410
00:22:14,368 --> 0:22:18,038
下一个视频段的媒体序列号就是

411
00:22:18,739 --> 0:22:19,606
媒体序列号仍遵守上述规则

412
00:22:19,840 --> 0:22:24,211
即使下一个视频段由不连续标签

413
00:22:24,478 --> 0:22:26,446
或键旋转或其它任何东西

414
00:22:26,613 --> 0:22:28,649
序列号会继续向前计数

415
00:22:30,250 --> 0:22:33,387
那意味着如果我们有这个播放列表

416
00:22:33,820 --> 0:22:38,091
然后我们知道下一次它更新时

417
00:22:38,425 --> 0:22:41,728
下一个视频段的序列号是什么

418
00:22:42,763 --> 0:22:47,534
因此为了获得

419
00:22:47,601 --> 0:22:49,169
你知道的 下一个感兴趣的视频段

420
00:22:49,570 --> 0:22:52,072
我们可以告诉服务器端 “嘿

421
00:22:52,272 --> 0:22:55,409
请为我提供播放列表更新

422
00:22:55,609 --> 0:22:58,145
媒体序列号为1803的媒体内容”

423
00:22:58,779 --> 0:23:00,147
看起来就是这样的

424
00:22:58,779 --> 0:23:00,147
看起来就是这样的

425
00:23:00,781 --> 0:23:04,551
因此我们在这里得到了

426
00:23:04,618 --> 0:23:06,820
你可以看到它正在请求m3u8

427
00:23:07,187 --> 0:23:12,893
我们有个查询参数

428
00:23:12,960 --> 0:23:14,595
这是客户端告诉服务器端

429
00:23:14,962 --> 0:23:16,864
我想要这个特定播放列表更新的方式

430
00:23:16,930 --> 0:23:19,032
就是那个包含这个媒体序列号的

431
00:23:19,867 --> 0:23:22,035
在客户端收到播放列表更新之后

432
00:23:22,369 --> 0:23:25,606
就立即发送下一个1804的

433
00:23:26,406 --> 0:23:29,877
那些对于CDN来说看起来是

434
00:23:29,943 --> 0:23:33,013
即使只有一个查询参数的一个值不同

435
00:23:33,347 --> 0:23:36,450
对于CDN来说

436
00:23:36,817 --> 0:23:38,519
因此那就为我们提供了缓存破坏

437
00:23:39,987 --> 0:23:42,756
这对于部分视频段来说也能起作用

438
00:23:43,290 --> 0:23:45,392
在这个例子中看起来是这样的

439
00:23:45,726 --> 0:23:47,261
我们有第二个例子

440
00:23:47,628 --> 0:23:49,863
第二个例子说

441
00:23:50,097 --> 0:23:53,834
“我想要包含媒体序列号

442
00:23:54,301 --> 0:23:57,538
第一部分的播放列表更新”

443
00:23:59,540 --> 0:24:03,977
现在这里还会执行另一个操作

444
00:23:59,540 --> 0:24:03,977
现在这里还会执行另一个操作

445
00:24:04,044 --> 0:24:04,945
那是什么？

446
00:24:05,846 --> 0:24:09,616
嗯 还记得我们想要做的另一件事是

447
00:24:09,917 --> 0:24:14,321
消除获取视频段的这些额外的

448
00:24:14,788 --> 0:24:17,558
为此我们使用了“推送”

449
00:24:18,292 --> 0:24:20,928
为此我们要使用HTTP/2

450
00:24:22,729 --> 0:24:26,934
因为有些人可能

451
00:24:27,000 --> 0:24:28,569
所以让我快速介绍一下

452
00:24:29,937 --> 0:24:33,540
HTTP/2是我们的老伙伴

453
00:24:34,374 --> 0:24:37,678
大概在四年前IATF

454
00:24:38,612 --> 0:24:43,250
自那时起 它就被网络服务器、

455
00:24:44,685 --> 0:24:47,821
必须采用低延迟HLS

456
00:24:48,155 --> 0:24:50,257
因为它为我们提供一些功能

457
00:24:50,557 --> 0:24:54,795
可以让我们提高协议交换的效率

458
00:24:55,262 --> 0:24:57,231
其中最值得注意的是“推送”

459
00:24:57,898 --> 0:24:58,932
那么推送是如何运作的呢？

460
00:24:59,967 --> 0:25:00,801
嗯

461
00:24:59,967 --> 0:25:00,801
嗯

462
00:25:01,368 --> 0:25:04,338
从客户端来说 HTTP/2的

463
00:25:04,404 --> 0:25:07,007
当客户端想获得资源时

464
00:25:07,074 --> 0:25:08,709
它会向服务器端发送get请求

465
00:25:09,209 --> 0:25:11,612
HTTP/2中的新功能是

466
00:25:11,812 --> 0:25:14,548
当服务器端看到请求后

467
00:25:14,982 --> 0:25:18,485
“哦 我看到你想要这个资源了

468
00:25:19,019 --> 0:25:22,122
当它给你发送你所请求的资源时

469
00:25:22,389 --> 0:25:24,658
同时它还可以单方面地

470
00:25:24,858 --> 0:25:28,762
开始给你发送那个你并不知道

471
00:25:29,396 --> 0:25:31,365
那样如果它猜对了

472
00:25:31,765 --> 0:25:34,401
你就不必再次发出第二次请求了

473
00:25:34,468 --> 0:25:35,936
因为它已经发送给你的路上了

474
00:25:37,171 --> 0:25:42,109
因此我们在延迟HLS中

475
00:25:43,243 --> 0:25:47,648
当客户端请求包含下一个视频段x的

476
00:25:48,215 --> 0:25:50,517
特定播放列表更新时

477
00:25:50,884 --> 0:25:53,487
它可以告诉服务器端

478
00:25:53,720 --> 0:25:57,057
当你给我发送播放列表更新时

479
00:25:58,091 --> 0:26:01,028
那就允许我们剔除

480
00:25:58,091 --> 0:26:01,028
那就允许我们剔除

481
00:26:01,361 --> 0:26:04,731
请求视频段的额外的往返

482
00:26:06,266 --> 0:26:07,100
那么

483
00:26:07,901 --> 0:26:11,939
让我们看一下这前三种优化

484
00:26:12,372 --> 0:26:17,744
看看相对于常规的HLS

485
00:26:17,811 --> 0:26:18,912
让我们把那个放在那儿

486
00:26:19,246 --> 0:26:22,316
让我们看一下新流程

487
00:26:22,382 --> 0:26:25,118
低延迟客户端与低延迟服务器端通讯

488
00:26:25,752 --> 0:26:29,523
首先客户端会提前请求播放列表

489
00:26:29,590 --> 0:26:30,791
请求会在那儿排队

490
00:26:31,091 --> 0:26:32,159
服务器端保留它

491
00:26:32,459 --> 0:26:36,697
同时服务器端也生产第一个

492
00:26:37,564 --> 0:26:41,268
假如在这个例子中

493
00:26:41,335 --> 0:26:43,403
在它执行编码操作一秒钟后

494
00:26:43,904 --> 0:26:46,907
那时它可以把部分视频段添加到

495
00:26:47,307 --> 0:26:49,209
并解禁那个播放列表请求

496
00:26:49,910 --> 0:26:54,081
同时向客户端推送第一个部分视频段

497
00:26:54,748 --> 0:26:58,151
然后客户端会在收到足够多的视频段

498
00:26:58,652 --> 0:27:00,320
与此同时

499
00:26:58,652 --> 0:27:00,320
与此同时

500
00:27:00,521 --> 0:27:02,422
在服务器端上排列起下一个

501
00:27:02,489 --> 0:27:06,927
从而可以尽快发现

502
00:27:08,028 --> 0:27:11,431
即使部分视频段的时长有一秒钟

503
00:27:11,798 --> 0:27:17,437
你也可以看到这极大地减少了

504
00:27:17,704 --> 0:27:19,573
指定媒体帧

505
00:27:19,640 --> 0:27:22,876
从服务器端传输到客户端的时间

506
00:27:24,778 --> 0:27:27,281
最后两个修改实际上是

507
00:27:27,614 --> 0:27:30,050
对这个基本流程的优化

508
00:27:31,952 --> 0:27:34,288
第一个是关于一遍一遍地减少

509
00:27:34,555 --> 0:27:37,224
传输播放列表的消耗

510
00:27:37,858 --> 0:27:39,193
减少传输消耗为什么重要呢？

511
00:27:40,093 --> 0:27:43,163
嗯 如果你正在传输的播放列表

512
00:27:43,230 --> 0:27:47,267
包含三小时或甚至是五小时的视频段

513
00:27:47,768 --> 0:27:51,672
并且你正在以每秒传输三到四次的

514
00:27:52,206 --> 0:27:54,575
传输速度就变得非常重要了

515
00:27:55,943 --> 0:28:00,280
所以我们添加了

516
00:27:55,943 --> 0:28:00,280
所以我们添加了

517
00:28:01,548 --> 0:28:04,284
它的运作方式是

518
00:28:04,651 --> 0:28:07,120
再一次 服务器端宣布客户端可以…

519
00:28:07,187 --> 0:28:09,523
可以提供Delta更新

520
00:28:09,590 --> 0:28:12,392
它通过CAN…SKIP…UNTIL

521
00:28:12,726 --> 0:28:15,796
那会告诉客户端

522
00:28:15,863 --> 0:28:17,164
它将跳过所有的视频段

523
00:28:17,231 --> 0:28:19,967
直到距离现场边界一定的秒数

524
00:28:20,567 --> 0:28:21,902
如果客户端看到了

525
00:28:22,269 --> 0:28:24,605
它知道它上次更新播放列表的时间

526
00:28:24,671 --> 0:28:25,639
因此它算出

527
00:28:25,839 --> 0:28:29,109
它可以执行Delta更新

528
00:28:29,643 --> 0:28:31,678
然后它可以当它下一次更新

529
00:28:31,879 --> 0:28:34,348
发起明确请求 请求Delta更新

530
00:28:35,983 --> 0:28:36,917
那个更新

531
00:28:37,618 --> 0:28:43,323
只包含播放列表中的最后几个视频段

532
00:28:43,390 --> 0:28:45,225
就是距离现场边界最近的几个视频段

533
00:28:46,059 --> 0:28:48,095
并且它跳过了较早的播放列表部分

534
00:28:48,161 --> 0:28:49,363
因为客户端已经有了

535
00:28:52,699 --> 0:28:54,134
这里有个例子

536
00:28:55,035 --> 0:29:00,374
在这个例子中 你可以看到客户端

537
00:28:55,035 --> 0:29:00,374
在这个例子中 你可以看到客户端

538
00:29:00,741 --> 0:29:05,412
通过指定underscore HLS

539
00:29:05,679 --> 0:29:08,549
当它发起它的…

540
00:29:10,050 --> 0:29:11,585
在返回来的播放列表中

541
00:29:12,419 --> 0:29:14,254
你会看到有一个

542
00:29:14,655 --> 0:29:17,925
它告诉客户端

543
00:29:18,258 --> 0:29:20,127
Delta更新将跳过一切

544
00:29:20,194 --> 0:29:22,896
一直到距离现场边界前的36秒钟

545
00:29:23,997 --> 0:29:27,467
然后这里的最后一个新标签是

546
00:29:28,001 --> 0:29:29,903
你可以把跳过标签看作是

547
00:29:30,237 --> 0:29:35,209
代替1700 xm视频段

548
00:29:35,275 --> 0:29:38,879
可能存在于完整播放列表更新中的

549
00:29:40,747 --> 0:29:43,517
那么这就是Delta更新

550
00:29:43,817 --> 0:29:47,754
可以让我们真正最小化

551
00:29:47,821 --> 0:29:49,389
用于不断地刷新播放列表的网络流量

552
00:29:49,456 --> 0:29:51,792
而不会失去HLS播放列表

553
00:29:51,859 --> 0:29:53,360
提供给你的任何普遍性和能力

554
00:29:54,461 --> 0:29:56,029
现在让我们看一下最后一个修改

555
00:29:56,096 --> 0:30:01,235
正是这个修改帮助我们更快地切换

556
00:29:56,096 --> 0:30:01,235
正是这个修改帮助我们更快地切换

557
00:30:01,902 --> 0:30:03,570
它们叫做“演奏报告”

558
00:30:04,037 --> 0:30:05,706
我们的想法是

559
00:30:06,006 --> 0:30:09,476
当你的客户端以特定比特率

560
00:30:09,543 --> 0:30:12,112
加载特定播放列表的最新版本时

561
00:30:12,613 --> 0:30:18,185
那个更新可以深入了解

562
00:30:18,452 --> 0:30:21,889
客户端可能在下一秒或下两秒决定

563
00:30:23,590 --> 0:30:24,625
特别是

564
00:30:25,225 --> 0:30:27,995
“演奏报告”在它的最后一个

565
00:30:28,262 --> 0:30:31,565
包含那个纯播放列表中的最后一个

566
00:30:31,899 --> 0:30:34,601
那就为客户端提供了用于构成URL

567
00:30:34,835 --> 0:30:36,270
以获取最新播放列表所需要的东西

568
00:30:36,970 --> 0:30:38,138
它看起来是这样的

569
00:30:39,740 --> 0:30:40,774
在这个例子中

570
00:30:41,275 --> 0:30:45,779
我们让客户端请求

571
00:30:46,346 --> 0:30:47,381
当它请求时

572
00:30:47,447 --> 0:30:50,317
它使用了HLS报告查询参数

573
00:30:50,784 --> 0:30:53,187
请求深入查看

574
00:30:53,253 --> 0:30:54,454
位于同一台服务器上的

575
00:30:55,889 --> 0:30:57,457
当它得到播放列表时

576
00:30:57,891 --> 0:31:00,494
播放列表也包含一个

577
00:30:57,891 --> 0:31:00,494
播放列表也包含一个

578
00:31:00,994 --> 0:31:05,098
里面包含关于其他视频段的各种信息

579
00:31:07,100 --> 0:31:10,437
因此如果我们把这些都放在一起

580
00:31:12,072 --> 0:31:14,474
问题是它们可以一起发挥作用吗？

581
00:31:15,876 --> 0:31:17,010
你们想看一个演示吗？

582
00:31:21,014 --> 0:31:21,849
让我们做个演示吧

583
00:31:22,683 --> 0:31:27,387
你知道的

584
00:31:27,855 --> 0:31:29,556
我们像是“是的

585
00:31:29,623 --> 0:31:31,558
或我们可以做一个

586
00:31:32,025 --> 0:31:35,362
但如果我们从距离我们更远的地方

587
00:31:35,429 --> 0:31:38,265
不是更有说明力吗？

588
00:31:38,899 --> 0:31:42,970
也许距离我们7000英里

589
00:31:43,036 --> 0:31:45,506
也许是12000英里

590
00:31:45,739 --> 0:31:47,007
比如澳大利亚悉尼？

591
00:31:51,211 --> 0:31:54,047
但等一下 我们认识悉尼的人吗？

592
00:31:55,382 --> 0:31:56,783
Matt 我们认识Matt

593
00:31:57,351 --> 0:31:58,285
让我们呼叫Matt

594
00:32:02,222 --> 0:32:03,290
好的 让我们看一下

595
00:32:03,657 --> 0:32:04,825
天啊 我希望Matt已经醒了

596
00:32:13,934 --> 0:32:14,935
日安Roger

597
00:32:15,302 --> 0:32:16,637
嘿Matt 你好吗？

598
00:32:17,404 --> 0:32:18,272
我很好 谢谢

599
00:32:18,739 --> 0:32:22,743
太棒了 嘿 告诉你

600
00:32:23,010 --> 0:32:26,046
我想给大家演示一下低延迟HLS

601
00:32:26,513 --> 0:32:28,148
你那个视频流还在运行吗？

602
00:32:28,882 --> 0:32:29,783
当然了

603
00:32:29,850 --> 0:32:31,084
哦 太好了

604
00:32:31,818 --> 0:32:34,922
好的 让我们…让我们打开它

605
00:32:34,988 --> 0:32:36,023
看看我们有什么

606
00:32:36,456 --> 0:32:38,358
我有Apple TV

607
00:32:38,525 --> 0:32:39,626
好的 这就好

608
00:32:40,294 --> 0:32:42,763
好的 嘿 太神奇了

609
00:32:43,564 --> 0:32:45,165
好吧 让我们打开我们的app

610
00:32:45,232 --> 0:32:48,535
这里有悉尼视频流 让我们打开它

611
00:32:53,774 --> 0:32:55,609
并没有开始播放悉尼视频流

612
00:32:56,476 --> 0:32:58,178
让我们再尝试一下

613
00:33:04,484 --> 0:33:07,254
好的 让我试试库比蒂诺视频流

614
00:33:07,321 --> 0:33:09,790
只是为了看看是否有人…

615
00:33:09,857 --> 0:33:10,924
Simon在库比蒂诺

616
00:33:11,325 --> 0:33:15,495
所以那是…

617
00:33:17,364 --> 0:33:20,334
好吧 让我们再试一下这个

618
00:33:20,400 --> 0:33:21,368
我们…

619
00:33:22,836 --> 0:33:27,074
哎呦 来吧 我该怎么搞定这个呢？

620
00:33:28,775 --> 0:33:30,677
Matt 你还在啊

621
00:33:30,744 --> 0:33:32,746
-是的 我还在这里 你好

622
00:33:35,349 --> 0:33:37,985
但是 嘿 你知道的

623
00:33:38,952 --> 0:33:39,820
当然是

624
00:33:40,287 --> 0:33:41,655
哦 伙计 来吧

625
00:33:42,389 --> 0:33:44,458
我们没有…抱歉…我要再试一次

626
00:33:52,533 --> 0:33:56,603
今天我的视频流

627
00:33:58,272 --> 0:33:59,740
是的 Simon还在

628
00:34:01,642 --> 0:34:02,476
哦 伙计

629
00:34:04,378 --> 0:34:06,813
然后那是…好的那是…

630
00:34:08,215 --> 0:34:10,050
我要点击播放吗 还是暂停？

631
00:34:12,786 --> 0:34:14,353
嗯 你知道吗

632
00:34:15,054 --> 0:34:18,257
也许我们最后要呼叫Simon

633
00:34:18,458 --> 0:34:19,560
那让我有点失望

634
00:34:19,626 --> 0:34:21,527
因为我其实想给你们演示视频流

635
00:34:23,864 --> 0:34:24,697
让我们看一下

636
00:34:25,264 --> 0:34:26,567
屏住呼吸 好了吗？

637
00:34:27,400 --> 0:34:28,768
你们需要重启视频流吗？

638
00:34:29,803 --> 0:34:31,103
刚才网络断开了

639
00:34:31,170 --> 0:34:32,239
网络断开了？

640
00:34:32,806 --> 0:34:33,639
太棒了

641
00:34:40,280 --> 0:34:41,748
好的 我们有…

642
00:34:42,014 --> 0:34:45,485
让我看一下是否也许

643
00:34:48,155 --> 0:34:49,723
这些现场演示真的要搞死我了

644
00:35:01,268 --> 0:35:02,936
双击这个会…

645
00:35:05,839 --> 0:35:06,974
试着不用这个了

646
00:35:07,241 --> 0:35:09,676
是的 我不知道这是否会帮助我

647
00:35:16,083 --> 0:35:17,150
哦 伙计

648
00:35:18,018 --> 0:35:21,388
好的 我认为我们要

649
00:35:21,889 --> 0:35:24,324
我们就要寻求备选方案了

650
00:35:24,892 --> 0:35:25,726
好吧

651
00:35:26,360 --> 0:35:29,162
抱歉Matt

652
00:35:29,229 --> 0:35:30,264
因此让我…

653
00:35:31,431 --> 0:35:35,102
感谢你的出现

654
00:35:35,169 --> 0:35:37,104
但我现在要连线库比蒂诺了

655
00:35:37,171 --> 0:35:38,038
好吧 没问题

656
00:35:38,472 --> 0:35:39,339
好的

657
00:35:39,740 --> 0:35:42,109
嗯 这真的令人失望 但无论怎样

658
00:35:42,876 --> 0:35:44,411
我猜这就是为什么需要备份的原因

659
00:35:49,883 --> 0:35:50,918
嘿 Simon 你在吗？

660
00:35:51,552 --> 0:35:53,387
是的 我在Roger 你好吗？

661
00:35:53,620 --> 0:35:55,422
很好 Simon也是澳大利亚人

662
00:35:55,489 --> 0:35:57,991
我意识到那不是…这是一种

663
00:35:58,058 --> 0:35:59,293
澳大利亚人随处可见

664
00:36:01,228 --> 0:36:06,133
Simon 我想给这里的

665
00:36:06,600 --> 0:36:07,467
哦 当然

666
00:36:08,035 --> 0:36:09,236
那么我们为什么不这样做呢

667
00:36:09,303 --> 0:36:11,205
我要让你举起手来

668
00:36:11,471 --> 0:36:12,940
然后人们会听到你说…

669
00:36:13,006 --> 0:36:16,043
如果你在举手的时候说了

670
00:36:16,109 --> 0:36:17,311
然后他们才会在视频流上看到你

671
00:36:17,377 --> 0:36:20,180
那会给你…给他们一种关于

672
00:36:20,247 --> 0:36:21,748
-那么为什么不举起你的手呢…

673
00:36:23,817 --> 0:36:24,818
好的 举起你的手

674
00:36:26,053 --> 0:36:27,020
嘿 大家好

675
00:36:27,821 --> 0:36:29,423
-我举起我的手了

676
00:36:29,857 --> 0:36:31,091
很好 一直举着

677
00:36:31,758 --> 0:36:33,327
并且…哦 你放下了

678
00:36:34,494 --> 0:36:37,331
好的 现在 举起三根手指

679
00:36:38,232 --> 0:36:39,132
三根手指

680
00:36:40,067 --> 0:36:40,934
我们看到了

681
00:36:41,168 --> 0:36:44,071
所以那是个…它们要 你知道的…

682
00:36:44,872 --> 0:36:47,407
HLS视频流有不到两秒钟的延迟

683
00:36:48,175 --> 0:36:50,244
Simon非常感谢你

684
00:36:50,777 --> 0:36:53,647
当然 我希望你们能度过一个

685
00:36:54,081 --> 0:36:54,915
谢谢

686
00:36:56,049 --> 0:37:00,621
好的 那么这就是低延迟HLS

687
00:36:56,049 --> 0:37:00,621
好的 那么这就是低延迟HLS

688
00:37:01,021 --> 0:37:03,490
在这点上 有些人很可能在想

689
00:37:03,824 --> 0:37:06,627
我该如何为我提供那些HLS低延迟

690
00:37:07,694 --> 0:37:08,529
那么

691
00:37:09,162 --> 0:37:12,032
首先许多人都是app开发人员

692
00:37:12,099 --> 0:37:13,700
因此让我先讲一下app

693
00:37:15,836 --> 0:37:17,237
好消息是 默认情况下

694
00:37:17,304 --> 0:37:20,574
你们不需要做任何操作 如果你正

695
00:37:20,641 --> 0:37:22,976
并且你支持低延迟视频流的话

696
00:37:24,311 --> 0:37:26,513
然而我们确实有一些新API

697
00:37:27,514 --> 0:37:30,884
其中一个会告诉你 你当前设置的

698
00:37:31,084 --> 0:37:33,086
另一个是一个推荐

699
00:37:33,253 --> 0:37:36,023
根据我们所观察到的东西进行推荐

700
00:37:36,256 --> 0:37:38,525
因此你可以结合使用两个API

701
00:37:38,759 --> 0:37:40,794
比如 如果你看到延迟风险太大了

702
00:37:40,861 --> 0:37:42,863
你可以把它降低一点

703
00:37:42,930 --> 0:37:43,997
也许我们应该在这里实现

704
00:37:44,932 --> 0:37:49,036
第二个是一种让你维持播放头

705
00:37:49,203 --> 0:37:50,404
相对于现场边界的位置的方式

706
00:37:50,470 --> 0:37:52,639
它之所以有意思是因为

707
00:37:52,940 --> 0:37:54,908
今天如果你正在播放现场直播

708
00:37:54,975 --> 0:37:57,411
然后你穿过隧道或其它什么东西

709
00:37:57,477 --> 0:38:00,047
当你恢复时

710
00:37:57,477 --> 0:38:00,047
当你恢复时

711
00:38:00,380 --> 0:38:01,782
意思就是你不会错过任何东西

712
00:38:01,849 --> 0:38:04,384
但每一次你缓冲时

713
00:38:04,885 --> 0:38:08,889
因此如果你把距离现场边界的

714
00:38:09,189 --> 0:38:12,926
然后每一次我们缓冲之后

715
00:38:13,193 --> 0:38:14,494
距离现场边界的同一个位置

716
00:38:14,561 --> 0:38:15,929
因此 那会让你保持现场直播

717
00:38:16,663 --> 0:38:19,299
要考虑的下一件事是配置你的CDN

718
00:38:21,001 --> 0:38:22,870
我们真的很想避免

719
00:38:24,204 --> 0:38:27,875
在CDN上放置外来的

720
00:38:27,941 --> 0:38:31,078
因为我们希望CDN的重点主要是

721
00:38:31,512 --> 0:38:33,180
因此我们做到直截了当

722
00:38:33,947 --> 0:38:36,483
你需要使用符合行业标准的

723
00:38:36,550 --> 0:38:38,552
来提交你的HSL视频段和播放列表

724
00:38:38,619 --> 0:38:41,788
那包含支持“推送”

725
00:38:42,956 --> 0:38:46,226
你应该在每台服务器上都放一个

726
00:38:46,293 --> 0:38:48,295
你仍然可以有多台冗余的服务器

727
00:38:48,362 --> 0:38:52,199
但每一台应该有完整的阶梯

728
00:38:53,166 --> 0:38:57,137
并且你需要设置你的CDN

729
00:38:57,204 --> 0:38:59,373
如果Fred请求特定播放列表

730
00:38:59,540 --> 0:39:01,108
它会进入源并获取它

731
00:38:59,540 --> 0:39:01,108
它会进入源并获取它

732
00:39:01,275 --> 0:39:03,110
然后如果Bob请求同样的内容

733
00:39:03,177 --> 0:39:05,379
你不要通过CDN发送同样的请求

734
00:39:05,445 --> 0:39:06,947
你应该把它放在Fred的请求旁边

735
00:39:07,147 --> 0:39:09,082
等待返回来的第一个响应

736
00:39:09,283 --> 0:39:10,484
然后再同时提交给他们

737
00:39:11,051 --> 0:39:12,953
不同的CDN对这个过程

738
00:39:13,020 --> 0:39:15,289
Apache Traffic Server

739
00:39:15,589 --> 0:39:19,293
其它可能把它叫做提早发布

740
00:39:19,359 --> 0:39:21,261
重点是找到它并设置好它

741
00:39:23,197 --> 0:39:25,899
这里的主要工作是实施你的源

742
00:39:25,966 --> 0:39:28,335
修改用于发出部分视频段的程序包

743
00:39:28,602 --> 0:39:30,404
并实施源API

744
00:39:30,904 --> 0:39:34,575
为了帮助你们实现这个操作 我们

745
00:39:34,641 --> 0:39:35,909
你可以从网站上找到它

746
00:39:35,976 --> 0:39:39,847
在我们的演讲页面也有一个链接

747
00:39:40,581 --> 0:39:42,683
它当前是一个单独的草案

748
00:39:42,749 --> 0:39:45,786
我们计划在今年下半年把规则

749
00:39:46,420 --> 0:39:49,590
它包含一些新东西即服务器配置分析

750
00:39:49,790 --> 0:39:53,060
那包含服务器提交链的一组属性

751
00:39:53,126 --> 0:39:55,762
需要在客户端采用低延迟模式

752
00:39:56,129 --> 0:39:58,832
客户端会检查这些属性

753
00:39:59,066 --> 0:40:00,834
它会退回到常规延迟

754
00:39:59,066 --> 0:40:00,834
它会退回到常规延迟

755
00:40:02,069 --> 0:40:05,873
同时我们还提供了一个引用实施

756
00:40:05,939 --> 0:40:10,177
用于生产和串流低延迟HLS视频流

757
00:40:10,911 --> 0:40:13,847
它叫做低延迟

758
00:40:14,581 --> 0:40:17,217
它包含一些工具

759
00:40:17,284 --> 0:40:20,254
是程序化Bitbop

760
00:40:20,487 --> 0:40:22,756
并把它打包到低延迟视频流中

761
00:40:23,423 --> 0:40:25,692
它包含Apache的一个前端

762
00:40:26,026 --> 0:40:27,995
实施源API

763
00:40:28,061 --> 0:40:31,565
包括阻止播放列表重加载、

764
00:40:31,932 --> 0:40:35,235
你可以使用它在你的app中

765
00:40:35,302 --> 0:40:36,336
或当你创建它时

766
00:40:36,603 --> 0:40:39,072
把它与后台实施进行对比

767
00:40:40,307 --> 0:40:44,444
那么这就是你作为开发人员

768
00:40:44,511 --> 0:40:46,280
让我们谈谈用户

769
00:40:46,880 --> 0:40:50,551
我们意识到低延迟HLS是一个

770
00:40:51,151 --> 0:40:56,290
因此我们允许你花点时间来了解它

771
00:40:56,857 --> 0:40:57,891
并且我们…

772
00:40:57,958 --> 0:41:01,261
支持你对客户端的实施

773
00:40:57,958 --> 0:41:01,261
支持你对客户端的实施

774
00:41:01,962 --> 0:41:04,198
简而言之

775
00:41:04,264 --> 0:41:06,600
你需要一个低延迟模式的app权利

776
00:41:06,834 --> 0:41:08,202
这允许你通过TestFlight

777
00:41:08,402 --> 0:41:10,237
创建你的app、测试你的视频流

778
00:41:10,304 --> 0:41:12,639
甚至是部署视频流

779
00:41:13,006 --> 0:41:14,508
然后一旦你确认

780
00:41:14,741 --> 0:41:16,844
一切都没问题了

781
00:41:17,044 --> 0:41:19,112
你就可以把app提交到商店中了

782
00:41:19,546 --> 0:41:22,683
因此总而言之 请一定要看规范文档

783
00:41:23,217 --> 0:41:24,418
在测试模式中试着用一下

784
00:41:25,385 --> 0:41:28,555
并开始创建你的后台

785
00:41:29,089 --> 0:41:30,657
为了帮助你们实现这个操作

786
00:41:31,124 --> 0:41:34,161
今天或本周我们有一些

787
00:41:34,595 --> 0:41:37,497
我和我们团队的一些同事将会参加

788
00:41:37,564 --> 0:41:40,501
我们将非常乐于回答

789
00:41:40,801 --> 0:41:42,402
以及其它关于HLS的任何疑问

790
00:41:42,636 --> 0:41:44,905
第一场演讲是在

791
00:41:45,105 --> 0:41:48,609
第二场演讲 我想是在周五的

792
00:41:49,142 --> 0:41:52,079
非常感谢你们的参与

793
00:41:52,246 --> 0:41:53,714
我希望每个人都有精彩的表现
