1
00:00:00,506 --> 0:00:04,500
[音乐]

2
00:00:12,516 --> 0:00:14,636
[掌声]

3
00:00:15,136 --> 0:00:15,666
&gt;&gt;  下午好

4
00:00:16,366 --> 0:00:17,206
各位下午好

5
00:00:18,456 --> 0:00:22,546
欢迎来到比特币专场

6
00:00:22,546 --> 0:00:23,156
[笑声]

7
00:00:23,156 --> 0:00:25,276
开个玩笑 欢迎大家来到

8
00:00:25,276 --> 0:00:26,306
Cryptography and Your Apps 专场

9
00:00:27,206 --> 0:00:29,126
今天 我的同事 Frederic

10
00:00:29,126 --> 0:00:31,326
会和我一起向你们展示

11
00:00:31,326 --> 0:00:33,026
在 Apple 产品上使用密码

12
00:00:33,026 --> 0:00:34,936
变得前所未有的简单

13
00:00:35,776 --> 0:00:36,636
我是 Yannick Sierra

14
00:00:36,636 --> 0:00:37,846
我在 Apple 负责管理

15
00:00:37,846 --> 0:00:39,496
加密工程团队

16
00:00:39,496 --> 0:00:43,466
那么今天一方面

17
00:00:43,466 --> 0:00:45,756
我们会带来一套系统功能

18
00:00:45,926 --> 0:00:48,456
来解决一组常见安全问题

19
00:00:49,326 --> 0:00:51,306
另一方面 我们还将

20
00:00:51,446 --> 0:00:54,406
为大家带来一个全新的

21
00:00:54,406 --> 0:00:55,576
为加密操作服务的 Swift API

22
00:00:56,336 --> 0:00:58,476
我们很高兴能为大家讲这些

23
00:00:58,476 --> 0:01:00,056
你们来到这里

24
00:00:58,476 --> 0:01:00,056
你们来到这里

25
00:01:00,056 --> 0:01:01,506
一定是因为想要

26
00:01:01,506 --> 0:01:02,766
保护一些信息 对吧

27
00:01:05,476 --> 0:01:08,246
我们知道各位

28
00:01:08,396 --> 0:01:11,016
作为开发者和用户

29
00:01:11,016 --> 0:01:12,526
都认为保护用户的信息

30
00:01:12,526 --> 0:01:13,976
是十分重要的

31
00:01:16,656 --> 0:01:17,806
我们有各种各样的信息

32
00:01:17,806 --> 0:01:19,826
它们都十分敏感

33
00:01:19,866 --> 0:01:21,966
包括个人资料信息

34
00:01:21,966 --> 0:01:23,796
比如电话号码

35
00:01:23,796 --> 0:01:25,746
和电子邮件地址

36
00:01:26,636 --> 0:01:28,156
你的 App 可能也会

37
00:01:28,156 --> 0:01:31,866
处理一些用户信息

38
00:01:31,866 --> 0:01:34,386
如照片或音乐

39
00:01:34,386 --> 0:01:36,686
通过 App 来处理和加工

40
00:01:38,196 --> 0:01:39,976
你的 App 也会

41
00:01:39,976 --> 0:01:41,596
处理商业素材

42
00:01:42,826 --> 0:01:44,846
这可能是你的 App

43
00:01:45,026 --> 0:01:46,886
提供给用户的付费内容

44
00:01:47,716 --> 0:01:49,586
或者是如手机银行

45
00:01:49,586 --> 0:01:51,626
这样的场景中的账户信息

46
00:01:53,136 --> 0:01:54,836
所有这些信息

47
00:01:54,836 --> 0:01:56,636
我们都务必保护其安全

48
00:01:57,106 --> 0:01:59,346
那么你就需要使用很好的工具

49
00:01:59,986 --> 0:02:04,436
在 Apple 里 安全和隐私

50
00:01:59,986 --> 0:02:04,436
在 Apple 里 安全和隐私

51
00:02:04,716 --> 0:02:06,146
是核心价值

52
00:02:06,826 --> 0:02:08,406
它根植在我们所开发的

53
00:02:08,406 --> 0:02:11,056
所有功能之中

54
00:02:12,356 --> 0:02:15,486
加密技术是其中一个重要的部分

55
00:02:16,036 --> 0:02:18,086
举个例子 对于设备完整性

56
00:02:18,086 --> 0:02:20,476
我们使用加密技术

57
00:02:20,476 --> 0:02:21,886
来验证在平台上运行的

58
00:02:21,886 --> 0:02:23,506
软件的完整性

59
00:02:23,876 --> 0:02:25,206
以确保它不被破坏

60
00:02:25,206 --> 0:02:27,216
同时保证其安全属性

61
00:02:27,216 --> 0:02:29,376
没有被篡改

62
00:02:30,746 --> 0:02:32,996
我们用加密技术来保护静态数据

63
00:02:34,086 --> 0:02:36,236
我们在众多用户

64
00:02:36,476 --> 0:02:38,166
喜爱的 App 中使用加密技术

65
00:02:38,666 --> 0:02:42,416
用户广泛地使用它们

66
00:02:42,616 --> 0:02:45,816
来捕捉和分享非常私人的时刻

67
00:02:46,426 --> 0:02:47,946
这是一个在信息

68
00:02:48,766 --> 0:02:50,876
Safari 浏览器和 iCloud 的例子

69
00:02:51,876 --> 0:02:53,806
我们有超过十亿的设备

70
00:02:53,806 --> 0:02:55,726
因此我们大范围地使用加密技术

71
00:02:57,056 --> 0:02:58,806
那么你可以想象

72
00:02:59,186 --> 0:03:00,206
风险也是非常高的

73
00:02:59,186 --> 0:03:00,206
风险也是非常高的

74
00:03:00,626 --> 0:03:02,936
性能对提高用户体验来说

75
00:03:02,936 --> 0:03:04,066
是至关重要的

76
00:03:05,016 --> 0:03:07,006
电量是保证我们

77
00:03:07,136 --> 0:03:09,296
全天使用的基础

78
00:03:09,296 --> 0:03:11,166
而安全则是基石

79
00:03:12,526 --> 0:03:13,856
现在 我们来进一步了解一下

80
00:03:13,856 --> 0:03:14,516
加密技术

81
00:03:16,196 --> 0:03:17,896
加密技术其实是一个工具

82
00:03:18,286 --> 0:03:20,116
它为一系列基本属性

83
00:03:20,306 --> 0:03:21,956
提供解决方案

84
00:03:23,186 --> 0:03:25,096
比如身份认证 它能够

85
00:03:25,096 --> 0:03:27,776
让你知道是谁向你发送了信息

86
00:03:29,456 --> 0:03:31,406
加密 就意味着

87
00:03:31,406 --> 0:03:34,546
只有你才能解密该消息

88
00:03:35,456 --> 0:03:37,836
而完整性 则代表着

89
00:03:37,836 --> 0:03:39,536
没有人可以在你之前

90
00:03:39,536 --> 0:03:42,506
修改该消息的内容

91
00:03:43,456 --> 0:03:45,636
为解决更广泛的

92
00:03:45,636 --> 0:03:47,166
安全问题

93
00:03:47,166 --> 0:03:48,916
我们将加密功能

94
00:03:48,916 --> 0:03:51,376
结合到加密协议中

95
00:03:51,376 --> 0:03:52,466
这并不容易

96
00:03:54,036 --> 0:03:56,266
事实上 你们中的很多人

97
00:03:56,266 --> 0:03:57,316
大多数人可能都听过这个说法

98
00:03:57,356 --> 0:03:59,426
不要使用加密 对吧

99
00:04:00,206 --> 0:04:01,616
这个说法有很好的理由

100
00:04:01,616 --> 0:04:04,256
有很多地方都可能出错

101
00:04:05,456 --> 0:04:07,476
比如它有可能选中

102
00:04:07,476 --> 0:04:09,116
错误的原语

103
00:04:09,116 --> 0:04:09,946
从而使你得不到

104
00:04:09,946 --> 0:04:11,766
你想要获得的安全

105
00:04:12,636 --> 0:04:14,566
或者它也可能添加了正确的

106
00:04:14,566 --> 0:04:16,745
原语 但没有正确使用它们

107
00:04:16,745 --> 0:04:19,656
而最低级的错误 

108
00:04:19,656 --> 0:04:22,366
即安装启动的时候

109
00:04:22,366 --> 0:04:23,916
就可能泄露了隐私或密钥

110
00:04:24,296 --> 0:04:25,476
这可能会造成定时攻击

111
00:04:25,476 --> 0:04:27,556
或 Padding Oracle 攻击

112
00:04:28,886 --> 0:04:30,696
这就是为什么

113
00:04:30,696 --> 0:04:32,056
加密十分困难

114
00:04:32,386 --> 0:04:35,046
新闻上我们可以看到

115
00:04:35,186 --> 0:04:36,356
无数关于加密协议

116
00:04:36,356 --> 0:04:39,636
失败的例子

117
00:04:39,636 --> 0:04:41,236
而最糟糕的是

118
00:04:41,236 --> 0:04:42,656
安全漏洞也许不是当时

119
00:04:42,656 --> 0:04:43,426
就能发现的

120
00:04:43,426 --> 0:04:45,186
也许要等到几年后

121
00:04:45,186 --> 0:04:46,306
有人报告说发现了一个漏洞

122
00:04:47,656 --> 0:04:50,386
这就是风险高的原因

123
00:04:50,386 --> 0:04:53,146
所以要保证其正确性需要

124
00:04:53,146 --> 0:04:53,736
花费很多努力

125
00:04:55,026 --> 0:04:56,286
设计一个强大的协议

126
00:04:56,636 --> 0:04:59,336
需要花费大量时间和技巧

127
00:04:59,336 --> 0:05:02,166
还需要你作为一个加密专家的专业知识

128
00:04:59,336 --> 0:05:02,166
还需要你作为一个加密专家的专业知识

129
00:05:03,306 --> 0:05:04,686
甚至当你设计出协议的时候

130
00:05:05,056 --> 0:05:06,226
工作仍没有结束

131
00:05:06,946 --> 0:05:07,996
你还要做大量连续的工作

132
00:05:07,996 --> 0:05:10,576
来监控新的攻击

133
00:05:10,576 --> 0:05:12,156
看看什么适用于你的代码

134
00:05:12,156 --> 0:05:14,806
然后响应它

135
00:05:15,476 --> 0:05:17,096
但有时并不是那么简单

136
00:05:17,486 --> 0:05:18,676
它们可能是彼此依赖的

137
00:05:19,226 --> 0:05:20,606
那些你选择整合进

138
00:05:20,606 --> 0:05:23,846
你的 App 中的库文件

139
00:05:24,106 --> 0:05:25,856
在一些情况下

140
00:05:25,856 --> 0:05:27,006
你也需要修改并传输协议

141
00:05:27,006 --> 0:05:29,196
同时管理所有的

142
00:05:29,196 --> 0:05:30,916
可解释的场景

143
00:05:31,516 --> 0:05:35,436
所有这些是个大工程

144
00:05:36,076 --> 0:05:38,326
它会花费大量的时间和精力

145
00:05:38,326 --> 0:05:40,106
让你无暇实践可能有的精彩想法

146
00:05:40,106 --> 0:05:42,546
或者下一个很酷的功能

147
00:05:44,416 --> 0:05:46,936
这就是为什么你可以

148
00:05:46,936 --> 0:05:49,136
真正从原生功能中获益

149
00:05:50,256 --> 0:05:51,766
我们的理念一直是

150
00:05:51,766 --> 0:05:55,306
为一系列常见的问题

151
00:05:55,646 --> 0:05:57,836
提供完整的解决方案

152
00:05:57,836 --> 0:05:59,626
而你无需为此费心

153
00:06:00,936 --> 0:06:03,726
对你来说 它增加了风险

154
00:06:03,726 --> 0:06:05,586
和工作量 我们完全可以

155
00:06:05,586 --> 0:06:07,716
通过我们平台上的

156
00:06:07,716 --> 0:06:09,856
代理的硬件功能

157
00:06:09,856 --> 0:06:11,936
来实现更好的安全性

158
00:06:14,686 --> 0:06:17,046
现在 我们来看一组

159
00:06:17,046 --> 0:06:18,626
你们可能非常熟悉的

160
00:06:19,156 --> 0:06:20,646
很常见的场景

161
00:06:20,646 --> 0:06:24,146
我会先开始讲如何

162
00:06:24,146 --> 0:06:25,736
保护一个设备上的数据

163
00:06:26,366 --> 0:06:28,676
接着我们可以看看

164
00:06:28,676 --> 0:06:30,206
保护凭证和密钥

165
00:06:30,766 --> 0:06:36,456
之后是跨设备和用户的数据共享

166
00:06:38,256 --> 0:06:40,106
接着是保护网络链接安全

167
00:06:40,106 --> 0:06:42,196
那么最后是

168
00:06:42,346 --> 0:06:44,846
用证书验证间接联系人

169
00:06:46,426 --> 0:06:49,276
现在 我们来看第一个例子

170
00:06:49,406 --> 0:06:50,456
相信你们中的很多人

171
00:06:50,546 --> 0:06:54,106
已经发现了该场景

172
00:06:54,106 --> 0:06:56,556
并且在努力保护设备上的数据

173
00:06:57,406 --> 0:07:00,496
那么 我建议你们不要

174
00:06:57,406 --> 0:07:00,496
那么 我建议你们不要

175
00:07:00,496 --> 0:07:01,586
仅仅是复制粘贴你在

176
00:07:01,586 --> 0:07:03,246
一些网站上发现的东西

177
00:07:03,896 --> 0:07:06,976
最好使用数据保护

178
00:07:08,016 --> 0:07:09,276
数据保护综合了

179
00:07:09,276 --> 0:07:11,046
密码的长处

180
00:07:11,046 --> 0:07:12,766
和 Secure Enclave 中的

181
00:07:12,766 --> 0:07:14,696
硬件技术

182
00:07:14,816 --> 0:07:16,966
来确保密钥的安全性

183
00:07:16,966 --> 0:07:19,886
同时使加密数据不能被

184
00:07:19,886 --> 0:07:20,796
暴力破解密码

185
00:07:21,396 --> 0:07:23,816
但还有更多优点

186
00:07:24,526 --> 0:07:26,586
数据保护提供了

187
00:07:26,586 --> 0:07:27,556
破解后的复原

188
00:07:28,726 --> 0:07:30,656
破解后复原

189
00:07:30,656 --> 0:07:31,806
也称前向保密性

190
00:07:32,156 --> 0:07:34,166
它能确保如果攻击者

191
00:07:34,456 --> 0:07:35,666
攻击了设备的密钥

192
00:07:35,666 --> 0:07:37,736
之后用户更改了密码

193
00:07:37,736 --> 0:07:40,276
那么旧的密码

194
00:07:40,276 --> 0:07:42,086
都不能被用来恢复

195
00:07:42,086 --> 0:07:43,346
所有之后加密的数据

196
00:07:44,496 --> 0:07:47,296
这一点可以说至关重要

197
00:07:47,296 --> 0:07:48,476
如果你想要了解更多

198
00:07:49,086 --> 0:07:49,996
数据保护能做的事情

199
00:07:49,996 --> 0:07:51,946
你可以看看 iOS

200
00:07:51,946 --> 0:07:53,276
安全白皮书

201
00:07:53,276 --> 0:07:56,086
来获得更多信息

202
00:07:56,926 --> 0:07:58,386
有一件事你需要知道

203
00:07:59,166 --> 0:07:59,996
就是当你的 App 出现问题时

204
00:07:59,996 --> 0:08:02,336
你可以设置

205
00:07:59,996 --> 0:08:02,336
你可以设置

206
00:08:02,396 --> 0:08:03,626
不同的保护属性

207
00:08:04,276 --> 0:08:08,736
首次身份验证后就可以设置

208
00:08:09,496 --> 0:08:12,776
而数据甚至一直会被保护

209
00:08:14,096 --> 0:08:15,526
直到用户在开机后第一次

210
00:08:15,526 --> 0:08:17,096
将手机解锁

211
00:08:18,346 --> 0:08:19,126
这很不错

212
00:08:20,136 --> 0:08:21,766
今天 你可以做得更好

213
00:08:22,316 --> 0:08:24,236
我们有完整的文件保护

214
00:08:24,766 --> 0:08:26,076
完整的文件保护 意味着

215
00:08:26,546 --> 0:08:28,746
只有在用户解锁他的手机后

216
00:08:28,796 --> 0:08:30,876
数据才能获取

217
00:08:31,326 --> 0:08:32,836
只要用户锁起他的手机

218
00:08:32,836 --> 0:08:33,846
将其放入一个口袋或包里

219
00:08:33,846 --> 0:08:36,336
数据就再一次被保护起来了

220
00:08:36,885 --> 0:08:39,846
这样使用起来真的很方便

221
00:08:40,145 --> 0:08:40,775
这里有一个例子

222
00:08:41,566 --> 0:08:42,686
你唯一需要使用的

223
00:08:42,846 --> 0:08:43,606
就是这个选项

224
00:08:43,916 --> 0:08:44,966
completeFileProtection

225
00:08:44,966 --> 0:08:46,706
不能比这更简单了 对

226
00:08:47,216 --> 0:08:48,376
如果你现在还没使用这个选项

227
00:08:48,376 --> 0:08:49,686
请回去查看你的 App

228
00:08:49,686 --> 0:08:50,906
看看你可以在哪里使用它

229
00:08:50,906 --> 0:08:53,446
以获得最佳级别的安全性

230
00:08:55,576 --> 0:08:58,506
现在 除了文件

231
00:08:58,506 --> 0:08:59,616
你想要保护的

232
00:08:59,616 --> 0:09:01,066
也许还有更为敏感的信息

233
00:08:59,616 --> 0:09:01,066
也许还有更为敏感的信息

234
00:09:02,076 --> 0:09:03,596
也有身份验证令牌 这样的证书

235
00:09:03,836 --> 0:09:05,906
它们用于对服务

236
00:09:05,906 --> 0:09:09,006
或加密密钥进行身份验证

237
00:09:09,546 --> 0:09:13,986
但不要将它们

238
00:09:13,986 --> 0:09:15,436
编写成默认值 像我们可以

239
00:09:15,436 --> 0:09:16,936
在所有平台上看到的那样

240
00:09:17,736 --> 0:09:19,666
相反 我们有钥匙串

241
00:09:21,106 --> 0:09:22,826
SecItem API 中的钥匙串

242
00:09:23,356 --> 0:09:24,826
让你能像在本地钥匙串中一样

243
00:09:25,446 --> 0:09:27,036
写那些项目 这意味着

244
00:09:27,036 --> 0:09:28,146
它们会继续保留在该设备上

245
00:09:28,146 --> 0:09:30,976
或者在 iCloud 钥匙串上

246
00:09:31,836 --> 0:09:33,076
在那里 他们将所有的设备同步

247
00:09:33,076 --> 0:09:34,426
从而实现一种

248
00:09:34,546 --> 0:09:37,306
用户账户的无缝体验

249
00:09:37,946 --> 0:09:40,086
这需要用户账户能够

250
00:09:40,306 --> 0:09:41,706
进行双重验证

251
00:09:42,306 --> 0:09:45,006
而对于钥匙串 你会发现

252
00:09:45,006 --> 0:09:47,466
它对我前面提到的文件

253
00:09:47,466 --> 0:09:48,906
和一些额外文件

254
00:09:49,576 --> 0:09:50,696
有非常相似的保护

255
00:09:51,246 --> 0:09:52,556
这里 我要再推荐你

256
00:09:52,556 --> 0:09:53,786
可以去看看那个文档

257
00:09:53,786 --> 0:09:54,286
来进一步学习

258
00:09:55,686 --> 0:09:56,946
除了了解何时可用密钥外

259
00:09:56,986 --> 0:09:58,136
有时知道用户

260
00:09:58,636 --> 0:10:00,306
如何及何时

261
00:09:58,636 --> 0:10:00,306
如何及何时

262
00:10:00,306 --> 0:10:01,976
对其进行身份验证 也很重要

263
00:10:03,656 --> 0:10:05,576
所以在这里 我们用

264
00:10:05,576 --> 0:10:06,976
LocalAuthentication

265
00:10:08,256 --> 0:10:10,196
LocalAuthentication 使你可以

266
00:10:10,196 --> 0:10:12,446
根据何时可以执行一个操作

267
00:10:12,446 --> 0:10:14,726
来进行限制

268
00:10:15,306 --> 0:10:16,746
例如 你可以定义

269
00:10:16,886 --> 0:10:18,336
用户需要使用 Face ID

270
00:10:18,336 --> 0:10:19,646
这样的生物鉴定识别

271
00:10:19,646 --> 0:10:20,296
进行身份验证

272
00:10:21,256 --> 0:10:22,906
这样做非常方便

273
00:10:22,906 --> 0:10:25,336
同时在这方面 在 macOS 上

274
00:10:25,336 --> 0:10:26,446
我们有一些更有意思的操作

275
00:10:27,036 --> 0:10:31,066
在 macOS 上 你习惯了

276
00:10:31,146 --> 0:10:33,776
设备身份验证属性

277
00:10:33,776 --> 0:10:35,986
它为用户提供了两种方法

278
00:10:35,986 --> 0:10:38,256
来进行身份验证 分别是

279
00:10:38,256 --> 0:10:39,886
密码和支持 Touch ID 进行验证的

280
00:10:39,886 --> 0:10:41,496
Mac 上的生物鉴定识别

281
00:10:42,466 --> 0:10:43,606
今年 我们非常高兴地宣布

282
00:10:43,606 --> 0:10:46,006
现在 你不需要在

283
00:10:46,006 --> 0:10:48,746
App 上做任何的改变

284
00:10:48,746 --> 0:10:50,446
用户就可以用 Apple Watch

285
00:10:50,446 --> 0:10:52,496
来进行身份验证 只要双击 Apple Watch

286
00:10:53,376 --> 0:10:54,606
这是个很棒的全新体验

287
00:10:54,796 --> 0:10:56,506
它将会减少密码的使用

288
00:10:56,506 --> 0:10:57,986
减少摩擦

289
00:10:58,026 --> 0:10:59,926
从而提高用户体验

290
00:11:00,916 --> 0:11:02,366
现在 因为有了这些新功能

291
00:11:02,536 --> 0:11:04,306
我们增加了两个新的规则

292
00:11:05,236 --> 0:11:08,386
第一个是将身份验证

293
00:11:08,386 --> 0:11:10,416
简化为只用生物鉴定识别

294
00:11:10,416 --> 0:11:11,926
和 Watch

295
00:11:12,506 --> 0:11:16,426
第二个则是只用 Watch 验证

296
00:11:17,696 --> 0:11:18,686
我们期待看到

297
00:11:18,776 --> 0:11:19,946
你将如何在你的 macOS 上的

298
00:11:20,076 --> 0:11:21,566
App 中使用这些

299
00:11:25,196 --> 0:11:26,386
那么 我之前提到过钥匙串

300
00:11:27,316 --> 0:11:28,186
这里有一种简单的方法

301
00:11:28,236 --> 0:11:30,376
可以将一个账户

302
00:11:30,376 --> 0:11:32,286
在所有设备上的项目同步

303
00:11:33,196 --> 0:11:34,066
那么如果你有数据怎么办呢

304
00:11:35,086 --> 0:11:36,636
好 对于数据我们也有很好的

305
00:11:36,636 --> 0:11:37,236
解决方法

306
00:11:38,626 --> 0:11:41,436
CloudKit 它使你可以

307
00:11:41,436 --> 0:11:43,336
在私人 CloudKit 数据库里

308
00:11:43,336 --> 0:11:46,856
对素材进行加密

309
00:11:46,856 --> 0:11:48,556
相应的数据就会

310
00:11:48,556 --> 0:11:50,156
在所有的设备间共享

311
00:11:50,156 --> 0:11:52,376
而用户不需要登录 App

312
00:11:52,936 --> 0:11:56,296
这很不错 甚至你可以用它

313
00:11:56,296 --> 0:11:58,636
来共享给所有的用户

314
00:12:00,796 --> 0:12:02,896
它的工作方式是 Apple

315
00:12:02,936 --> 0:12:05,746
将作为一个信任方

316
00:12:05,846 --> 0:12:08,046
来帮助管理 iCloud 身份

317
00:12:08,046 --> 0:12:09,886
和对数据的控制

318
00:12:10,596 --> 0:12:13,776
这里我再举一个例子

319
00:12:13,776 --> 0:12:15,786
这个设置起来很容易

320
00:12:16,946 --> 0:12:17,976
从文件中 我们创建一个素材

321
00:12:20,556 --> 0:12:22,626
用这个素材 我们创建了一个记录

322
00:12:23,496 --> 0:12:24,846
然后我们将这个记录

323
00:12:24,906 --> 0:12:26,476
上传到私人 CloudKit 数据库

324
00:12:27,166 --> 0:12:31,386
这样就可以了 如果你想

325
00:12:31,436 --> 0:12:32,816
向其他用户添加共享

326
00:12:32,816 --> 0:12:34,486
API 也是可以做到的

327
00:12:34,486 --> 0:12:36,326
如果你之前没有关注过 CloudKit

328
00:12:36,356 --> 0:12:38,076
那么这是一个很好的时机

329
00:12:38,376 --> 0:12:39,366
你可以去查看说明文档

330
00:12:39,366 --> 0:12:40,656
看看它对你来说

331
00:12:40,656 --> 0:12:42,046
有多么强大

332
00:12:42,046 --> 0:12:45,326
那么 我们之前说了

333
00:12:45,326 --> 0:12:47,846
保护设备里的数据

334
00:12:47,846 --> 0:12:49,876
然后将其在设备间共享

335
00:12:49,876 --> 0:12:52,626
甚至是共享到另一用户的设备

336
00:12:52,626 --> 0:12:55,756
比如 在你想对来自你自己的

337
00:12:55,756 --> 0:12:58,206
服务器的数据执行此操作的时候

338
00:12:59,436 --> 0:13:00,986
你想在哪里建立

339
00:12:59,436 --> 0:13:00,986
你想在哪里建立

340
00:13:00,986 --> 0:13:02,276
一个安全连接

341
00:13:03,556 --> 0:13:04,646
安全连接

342
00:13:04,646 --> 0:13:06,956
真的十分重要

343
00:13:07,126 --> 0:13:08,916
因为它能帮助我们

344
00:13:08,916 --> 0:13:10,376
保证用户在使用你的

345
00:13:10,376 --> 0:13:12,826
App 时的所有信息的

346
00:13:12,826 --> 0:13:14,896
保密性 同时保证

347
00:13:14,896 --> 0:13:16,676
该信息的可信度

348
00:13:16,676 --> 0:13:18,976
确保它不被篡改

349
00:13:21,226 --> 0:13:22,346
那么在这里

350
00:13:22,346 --> 0:13:23,936
你首先不应该做的就是

351
00:13:23,936 --> 0:13:25,696
只是尝试使用你的自定协议

352
00:13:26,296 --> 0:13:27,776
有一个很好的解决方案

353
00:13:28,626 --> 0:13:29,696
这是一个标准的解决方案

354
00:13:30,946 --> 0:13:32,446
传输层安全协议

355
00:13:33,236 --> 0:13:35,826
它在我们的平台上真的很好用

356
00:13:36,246 --> 0:13:39,096
因为我们有两个很棒的 API

357
00:13:39,906 --> 0:13:41,076
第一个是网络框架

358
00:13:41,076 --> 0:13:42,796
你可能已经在

359
00:13:42,796 --> 0:13:46,316
去年的 WWDC 中发现了这个

360
00:13:47,036 --> 0:13:48,946
第二个就是 URL 会话

361
00:13:49,286 --> 0:13:51,356
你可能知道它是

362
00:13:51,356 --> 0:13:53,236
App 传输层安全的一部分

363
00:13:55,116 --> 0:13:56,726
而在 URL 会话中

364
00:13:56,726 --> 0:13:59,816
我们只需要使用一个

365
00:14:00,656 --> 0:14:00,986
https TPS 端点

366
00:14:00,986 --> 0:14:02,926
在这两种情况中

367
00:14:03,786 --> 0:14:07,106
我们依赖的都是

368
00:14:07,866 --> 0:14:09,496
包含很多默认值的 TLS

369
00:14:10,336 --> 0:14:12,876
默认值保证密码套件提供

370
00:14:13,436 --> 0:14:14,676
强大的安全性

371
00:14:14,966 --> 0:14:16,486
包括完美前向保密

372
00:14:16,556 --> 0:14:18,796
以及 Apple 产品上

373
00:14:18,796 --> 0:14:21,276
最有效的算法

374
00:14:21,816 --> 0:14:24,576
或者在默认情况下

375
00:14:26,156 --> 0:14:28,086
实现 TLS 也要使用 TLS 1.3

376
00:14:28,086 --> 0:14:30,766
你可能不是很熟悉 TLS 1.3

377
00:14:30,766 --> 0:14:32,936
它相对于之前的版本

378
00:14:32,936 --> 0:14:34,596
有很大的改进

379
00:14:34,596 --> 0:14:37,446
它可以大大提高

380
00:14:37,726 --> 0:14:39,156
安全性和效率

381
00:14:39,156 --> 0:14:41,246
通过减少一些运行行程

382
00:14:42,996 --> 0:14:45,166
如果你还没有使用 TLS 1.3

383
00:14:46,026 --> 0:14:46,876
那么请你试着将其

384
00:14:46,876 --> 0:14:48,816
应用在你的服务器上

385
00:14:48,816 --> 0:14:50,526
而你不需要在你的 App 上

386
00:14:50,526 --> 0:14:51,556
做任何改变

387
00:14:51,556 --> 0:14:53,826
就可以受益

388
00:14:55,456 --> 0:14:56,836
好 为了向你展示它真的很简单

389
00:14:56,836 --> 0:14:58,936
我这里有两个使用网络框架

390
00:14:58,936 --> 0:15:01,206
和 URL 会话的例子

391
00:14:58,936 --> 0:15:01,206
和 URL 会话的例子

392
00:15:02,026 --> 0:15:04,016
但在讲这两个例子前

393
00:15:04,016 --> 0:15:05,586
我想要强调的是

394
00:15:05,586 --> 0:15:06,826
安全传输这种方法

395
00:15:07,096 --> 0:15:08,376
我们不再推荐

396
00:15:08,376 --> 0:15:10,886
我们希望你

397
00:15:10,886 --> 0:15:12,576
转用网络框架

398
00:15:12,576 --> 0:15:13,776
和 URL 会话

399
00:15:13,776 --> 0:15:14,776
如果你正在使用安全传输的话

400
00:15:15,686 --> 0:15:17,806
我们为此准备了很多的例子

401
00:15:18,776 --> 0:15:20,896
首先是网络框架

402
00:15:20,896 --> 0:15:22,676
当你建立了一个连接

403
00:15:22,676 --> 0:15:24,926
你需要做的唯一的事就是

404
00:15:25,006 --> 0:15:27,926
加上 using:tls 好了

405
00:15:27,926 --> 0:15:30,516
你添加了该 TLS 连接

406
00:15:30,516 --> 0:15:32,226
会带给你更好的安全性和性能

407
00:15:33,296 --> 0:15:35,356
然后是 URL 会话

408
00:15:35,356 --> 0:15:38,186
在这里 你只需要用 http 端点

409
00:15:38,236 --> 0:15:40,866
好了

410
00:15:41,136 --> 0:15:43,636
在一些情况下

411
00:15:44,286 --> 0:15:45,736
你也许无法用 TLS

412
00:15:45,986 --> 0:15:47,566
例如 如果你已经在尝试

413
00:15:47,566 --> 0:15:49,876
通过一个内容发布网络

414
00:15:49,876 --> 0:15:51,356
来保护数据

415
00:15:52,146 --> 0:15:54,116
这时 你管理那些证书

416
00:15:54,116 --> 0:15:56,296
而对于证书来说

417
00:15:56,456 --> 0:15:59,606
首先要避免的就是

418
00:15:59,606 --> 0:16:01,816
将它用在解析器上

419
00:15:59,606 --> 0:16:01,816
将它用在解析器上

420
00:16:01,816 --> 0:16:02,896
或尝试用一个你在网站上

421
00:16:02,896 --> 0:16:04,416
随意发现的解析器

422
00:16:05,066 --> 0:16:06,626
解析器非常脆弱

423
00:16:06,626 --> 0:16:09,526
因为它包含大量的攻击暴露

424
00:16:10,956 --> 0:16:12,026
这是很严重的问题

425
00:16:13,216 --> 0:16:16,286
在平台上我们有 SecTrust

426
00:16:17,126 --> 0:16:18,466
SecTrust 提供了一个简单的方法

427
00:16:18,466 --> 0:16:20,436
即根据一个信任规则

428
00:16:21,056 --> 0:16:22,286
来验证证书

429
00:16:23,086 --> 0:16:24,286
而信任规则可能包含

430
00:16:24,286 --> 0:16:26,096
过期信息

431
00:16:27,006 --> 0:16:29,786
作废信息

432
00:16:29,786 --> 0:16:31,666
而直到证书已经被验证了

433
00:16:31,836 --> 0:16:36,386
你才知道你可以使用密码

434
00:16:36,636 --> 0:16:38,196
注意 如果你使用 TLS 的话

435
00:16:38,196 --> 0:16:40,566
你就不需要担心证书的问题了

436
00:16:40,736 --> 0:16:43,326
一切都在为你安排好了

437
00:16:43,886 --> 0:16:47,546
好 在这个版本中

438
00:16:47,546 --> 0:16:49,606
我们很高兴介绍一个

439
00:16:49,606 --> 0:16:51,846
SecTrust 中的新函数

440
00:16:52,716 --> 0:16:54,256
该函数综合了

441
00:16:54,256 --> 0:16:56,686
你之前能做的两件事

442
00:16:57,286 --> 0:16:58,476
一方面 这是一个函数

443
00:16:58,476 --> 0:17:00,206
它允许异步执行

444
00:16:58,476 --> 0:17:00,206
它允许异步执行

445
00:17:00,656 --> 0:17:02,796
通过显式操作

446
00:17:02,796 --> 0:17:04,806
来完成一个验证证书

447
00:17:04,806 --> 0:17:06,026
这样你的 App 就可以

448
00:17:06,026 --> 0:17:07,336
在证书被验证的同时

449
00:17:07,336 --> 0:17:09,026
进行其他的事

450
00:17:09,626 --> 0:17:11,925
但同时 这个函数

451
00:17:11,925 --> 0:17:13,026
可以进行更丰富的处理

452
00:17:13,685 --> 0:17:15,996
那么 作为一个开发人员

453
00:17:16,705 --> 0:17:18,726
你知道万一失败了要怎么办

454
00:17:18,776 --> 0:17:20,665
你可以进行调试

455
00:17:21,306 --> 0:17:22,675
但同时 你可以在你的 App 里

456
00:17:22,675 --> 0:17:25,215
建立逻辑来对不同的

457
00:17:25,215 --> 0:17:26,556
错误场景作出回应

458
00:17:27,146 --> 0:17:29,086
那么这个新函数将会

459
00:17:29,086 --> 0:17:30,736
让调试变得更为

460
00:17:30,736 --> 0:17:31,856
方便和简单

461
00:17:31,856 --> 0:17:34,106
我们期待着你能运用它

462
00:17:34,656 --> 0:17:37,626
那么 我刚刚向大家介绍了

463
00:17:37,626 --> 0:17:40,336
五种不同的场景

464
00:17:40,336 --> 0:17:42,466
对于这些场景

465
00:17:42,836 --> 0:17:44,976
我们有非常易于使用的解决方案

466
00:17:45,456 --> 0:17:47,536
它们提供了很好的安全性

467
00:17:47,536 --> 0:17:50,186
你只需要使用默认设置

468
00:17:50,186 --> 0:17:53,306
或者修改几个属性就可以

469
00:17:53,876 --> 0:17:57,546
在这里 我们又一次地

470
00:17:58,156 --> 0:17:59,326
受益于与硬件的深度融合

471
00:17:59,326 --> 0:18:00,756
以此提供安全特性

472
00:17:59,326 --> 0:18:00,756
以此提供安全特性

473
00:18:00,816 --> 0:18:02,326
否则我们是很难

474
00:18:02,326 --> 0:18:03,396
提供这些特性的

475
00:18:04,026 --> 0:18:06,646
那么 无论在哪个场景中

476
00:18:06,906 --> 0:18:09,496
当你遇到它们

477
00:18:09,496 --> 0:18:10,406
就去使用系统框架

478
00:18:10,406 --> 0:18:11,986
如果你已经这么做了

479
00:18:11,986 --> 0:18:13,296
就要保证你正在使用的

480
00:18:13,296 --> 0:18:14,016
都是最好的属性

481
00:18:14,016 --> 0:18:14,936
这样你才能

482
00:18:14,936 --> 0:18:17,656
以尽可能好的方式

483
00:18:17,656 --> 0:18:19,466
来保护用户和商业素材

484
00:18:20,086 --> 0:18:24,056
我们明白在一些情况下

485
00:18:24,056 --> 0:18:26,186
使用系统功能

486
00:18:26,186 --> 0:18:29,216
也许对你来说并不是那么实用

487
00:18:29,746 --> 0:18:32,556
例如 你可能需要

488
00:18:32,926 --> 0:18:35,726
在适用系统之外具备互操作性

489
00:18:35,856 --> 0:18:38,626
你可以用你的服务

490
00:18:38,626 --> 0:18:41,936
来进行身份验证

491
00:18:41,936 --> 0:18:44,096
或者只是给一个

492
00:18:44,096 --> 0:18:46,386
需要实现的规范

493
00:18:46,386 --> 0:18:49,536
对所有这些例子 我们现在

494
00:18:49,536 --> 0:18:50,766
要介绍一个很棒的解决方案

495
00:18:51,976 --> 0:18:53,006
Apple CryptoKit

496
00:18:53,936 --> 0:18:57,026
Apple CryptoKit 是

497
00:18:57,096 --> 0:18:59,576
新的 Swift 加密 API

498
00:18:59,576 --> 0:19:00,956
其设计理念与我们

499
00:18:59,576 --> 0:19:00,956
其设计理念与我们

500
00:19:00,956 --> 0:19:02,866
所讨论的功能的设计理念相同

501
00:19:02,866 --> 0:19:05,396
它让你能够很容易地

502
00:19:05,396 --> 0:19:06,886
访问加密函数

503
00:19:06,886 --> 0:19:10,096
也很难误用函数

504
00:19:11,006 --> 0:19:14,966
我们很高兴在本次发布中介绍它

505
00:19:16,106 --> 0:19:17,766
现在 我要交给 Frederic

506
00:19:17,886 --> 0:19:18,916
他将向你们介绍

507
00:19:18,916 --> 0:19:20,386
这个全新的 API

508
00:19:21,076 --> 0:19:22,976
下面有请 Frederic 上台

509
00:19:23,516 --> 0:19:29,546
[掌声]

510
00:19:30,046 --> 0:19:30,846
&gt;&gt; 谢谢 Yannick

511
00:19:31,776 --> 0:19:32,386
大家好

512
00:19:32,796 --> 0:19:34,946
我的名字是 Frederic Jacobs

513
00:19:34,946 --> 0:19:36,526
我来自 Apple 的

514
00:19:36,526 --> 0:19:37,936
加密工程团队

515
00:19:38,646 --> 0:19:40,536
很高兴能向你们进一步介绍

516
00:19:40,536 --> 0:19:42,546
Apple CryptoKit

517
00:19:43,386 --> 0:19:44,866
我们认为你一定会喜欢

518
00:19:44,866 --> 0:19:49,346
在 Swift 中实现加密协议

519
00:19:49,396 --> 0:19:51,786
关于 Apple CryptoKit 有四个方面

520
00:19:51,786 --> 0:19:53,376
我想要在今天下午

521
00:19:53,376 --> 0:19:54,346
与你分享

522
00:19:55,216 --> 0:19:57,596
首先 我们要谈一谈

523
00:19:57,786 --> 0:19:59,656
CryptoKit 和 Swift

524
00:20:00,876 --> 0:20:03,876
第二 我们会向大家介绍

525
00:20:03,876 --> 0:20:06,016
能够在 CryptoKit 里

526
00:20:06,016 --> 0:20:07,566
获得的算法

527
00:20:08,556 --> 0:20:11,016
第三 我们将讨论一下

528
00:20:11,126 --> 0:20:14,146
Secure Enclave

529
00:20:14,146 --> 0:20:16,016
和生物鉴定识别

530
00:20:16,586 --> 0:20:18,746
最后 我们会谈谈性能

531
00:20:19,706 --> 0:20:21,006
我们开始吧

532
00:20:22,096 --> 0:20:23,806
在过去 当你从 Swift 中

533
00:20:23,856 --> 0:20:25,556
调用 C 加密 API 时

534
00:20:25,556 --> 0:20:28,726
你可能不得不编写

535
00:20:28,726 --> 0:20:30,366
这样的代码

536
00:20:31,126 --> 0:20:33,326
你需要分配缓冲区

537
00:20:33,596 --> 0:20:34,806
分析出每一个

538
00:20:34,806 --> 0:20:36,706
缓冲区的尺寸大小

539
00:20:37,406 --> 0:20:39,576
也有像随机数这样的值

540
00:20:39,576 --> 0:20:42,246
你可能需要查找

541
00:20:42,246 --> 0:20:45,366
该值的安全值是多少

542
00:20:46,326 --> 0:20:47,836
然后 你将所有这些

543
00:20:47,836 --> 0:20:50,406
嵌套调用至

544
00:20:50,406 --> 0:20:52,746
你传递指针的加密函数中

545
00:20:52,746 --> 0:20:54,346
同时这里没有参数标签

546
00:20:54,346 --> 0:20:56,556
来帮你弄清

547
00:20:56,846 --> 0:21:01,426
哪个指针需要进入哪个参数

548
00:20:56,846 --> 0:21:01,426
哪个指针需要进入哪个参数

549
00:21:02,306 --> 0:21:04,716
相比之下 用 Apple CryptoKit

550
00:21:04,716 --> 0:21:07,556
你可以只写一行代码

551
00:21:07,556 --> 0:21:09,836
来进行完全一样的操作

552
00:21:11,086 --> 0:21:12,696
是不是很棒呢

553
00:21:13,516 --> 0:21:18,506
[掌声]

554
00:21:19,006 --> 0:21:21,746
那么 为了完成这个

555
00:21:21,746 --> 0:21:23,036
你将你想要加密的数据

556
00:21:23,036 --> 0:21:24,666
进行传输

557
00:21:24,786 --> 0:21:26,836
在这个例子里 我们使用 AES.GCM

558
00:21:26,836 --> 0:21:29,536
同时 我们用你想要加密的

559
00:21:29,536 --> 0:21:31,616
数据的密钥

560
00:21:31,616 --> 0:21:34,716
这就好了

561
00:21:35,926 --> 0:21:38,276
你也许还需要

562
00:21:38,276 --> 0:21:40,016
生成自己的加密密钥

563
00:21:40,016 --> 0:21:42,036
当你从 Swift 中

564
00:21:42,036 --> 0:21:44,146
调用 C 加密 API 的时候

565
00:21:44,766 --> 0:21:46,796
我们首先需要

566
00:21:47,116 --> 0:21:48,646
转换一些位和字节

567
00:21:48,646 --> 0:21:50,456
因为加密密钥

568
00:21:50,456 --> 0:21:52,996
通常是用位来表示的

569
00:21:54,066 --> 0:21:56,446
接着你需要为

570
00:21:56,446 --> 0:22:01,416
这一数量的字节

571
00:21:56,446 --> 0:22:01,416
这一数量的字节

572
00:22:01,576 --> 0:22:03,576
分配一个缓冲区

573
00:22:03,576 --> 0:22:05,606
并使用系统随机数生成器 

574
00:22:05,666 --> 0:22:08,096
来用加密安全的随机数

575
00:22:08,096 --> 0:22:09,556
填充该缓冲区

576
00:22:11,216 --> 0:22:14,606
接着 如果出现错误

577
00:22:14,606 --> 0:22:15,666
你必须处理它

578
00:22:16,726 --> 0:22:19,646
然后你终于可以使用该密钥了

579
00:22:19,646 --> 0:22:22,816
当使用完该密钥时

580
00:22:22,816 --> 0:22:24,706
即使你忘记把它归零

581
00:22:24,706 --> 0:22:28,216
也可以将其从内存中移除

582
00:22:28,836 --> 0:22:32,956
而使用 CryptoKit

583
00:22:32,956 --> 0:22:37,906
只要一行代码就可生成一个密钥

584
00:22:38,636 --> 0:22:40,376
你调用 SymmetricKey

585
00:22:40,906 --> 0:22:42,796
初始化程序 然后传输

586
00:22:42,796 --> 0:22:45,836
你希望密钥持有的一定量的位

587
00:22:50,096 --> 0:22:52,666
我们能在释放时将该密钥归零

588
00:22:52,666 --> 0:22:55,966
因为只要了解该值的

589
00:22:56,566 --> 0:22:58,916
自动引用计数

590
00:22:58,916 --> 0:23:02,626
无论它什么时候被释放

591
00:22:58,916 --> 0:23:02,626
无论它什么时候被释放

592
00:23:03,096 --> 0:23:04,806
我们都在将

593
00:23:04,806 --> 0:23:09,246
该缓冲区归零

594
00:23:09,456 --> 0:23:11,376
好 CryptoKit 和 Swift

595
00:23:12,266 --> 0:23:15,426
我们有一个强类型的 API

596
00:23:16,366 --> 0:23:18,726
无论你何时初始化一个值

597
00:23:19,426 --> 0:23:22,436
我们都在验证

598
00:23:22,436 --> 0:23:24,826
你所传递的数据

599
00:23:25,076 --> 0:23:26,596
是否为该参数的一个强值

600
00:23:28,116 --> 0:23:32,706
多亏 Swift 的内存管理模型

601
00:23:32,706 --> 0:23:34,506
我们才能够在释放时

602
00:23:34,946 --> 0:23:38,376
将所有分配在

603
00:23:38,376 --> 0:23:40,656
CryptoKit 里的秘值归零

604
00:23:41,986 --> 0:23:43,646
我们将对一些

605
00:23:43,646 --> 0:23:46,846
如消息身份验证代码之类的值

606
00:23:47,066 --> 0:23:49,416
执行公平的一致性

607
00:23:49,736 --> 0:23:50,746
如果你熟悉该内容的话

608
00:23:50,746 --> 0:23:52,756
你就能够通过

609
00:23:52,756 --> 0:23:53,966
只使用 == 操作符

610
00:23:53,966 --> 0:23:56,006
在恒定的时间内

611
00:23:56,006 --> 0:23:58,786
来对双消息身份验证代码

612
00:23:58,786 --> 0:23:59,866
进行验证

613
00:24:03,556 --> 0:24:06,516
CryptoKit 也定义协议

614
00:24:06,806 --> 0:24:09,296
这样你可以在

615
00:24:09,296 --> 0:24:12,336
哈希函数 H 上编写通用代码

616
00:24:12,426 --> 0:24:14,176
如果在你代码库的多个位置中

617
00:24:14,176 --> 0:24:16,136
需要传递不同的哈希函数

618
00:24:16,136 --> 0:24:17,656
那么你可以只编写一次代码

619
00:24:17,656 --> 0:24:19,346
然后确定函数的参数

620
00:24:19,496 --> 0:24:21,976
来调用一个不同的哈希函数

621
00:24:24,776 --> 0:24:27,456
那么 我们讲过了 CryptoKit 和 Swift

622
00:24:27,456 --> 0:24:29,836
接下来我想深入讲讲

623
00:24:29,836 --> 0:24:32,996
CryptoKit 中所支持的

624
00:24:33,066 --> 0:24:36,716
算法集

625
00:24:37,756 --> 0:24:40,716
所有算法都是标准的

626
00:24:40,716 --> 0:24:41,896
同行评议的算法

627
00:24:42,526 --> 0:24:46,216
我们来看看 CryptoKit 中支持什么

628
00:24:47,716 --> 0:24:49,066
这里支持哈希函数

629
00:24:49,066 --> 0:24:51,276
消息身份验证代码

630
00:24:51,276 --> 0:24:53,056
认证加密

631
00:24:53,696 --> 0:24:56,796
密钥协商

632
00:24:57,026 --> 0:25:01,126
以及签名

633
00:24:57,026 --> 0:25:01,126
以及签名

634
00:25:02,876 --> 0:25:05,096
这其中的一些算法

635
00:25:05,096 --> 0:25:06,686
是我们之前在

636
00:25:06,686 --> 0:25:09,316
如 Common Crypto 或 SecKey 等框架中

637
00:25:09,316 --> 0:25:11,576
就支持的算法

638
00:25:11,576 --> 0:25:13,136
但有一些算法

639
00:25:13,136 --> 0:25:15,206
则是我们首次支持的算法

640
00:25:15,726 --> 0:25:17,816
我将它们用绿色标出

641
00:25:18,466 --> 0:25:22,596
注意我们还有一个非安全的模块

642
00:25:23,936 --> 0:25:27,216
该模块提供如 MD5 和 SHA1

643
00:25:27,216 --> 0:25:30,776
这样的算法

644
00:25:30,776 --> 0:25:32,806
这样即使你需要使用一些

645
00:25:32,806 --> 0:25:35,356
不再满足最佳安全标准的算法

646
00:25:35,356 --> 0:25:38,526
你也可以使用 CryptoKit 

647
00:25:42,836 --> 0:25:46,306
我们通过一些例子

648
00:25:46,636 --> 0:25:47,986
来看 CryptoKit 是如何工作的

649
00:25:48,806 --> 0:25:50,356
让我们从哈希函数开始

650
00:25:50,926 --> 0:25:53,406
哈希函数会生成

651
00:25:53,406 --> 0:25:56,456
确定的固定大小的输出

652
00:25:56,616 --> 0:25:58,816
我们称其为摘要

653
00:25:58,996 --> 0:26:01,526
与 Swift 中 Hashable 希的不同

654
00:25:58,996 --> 0:26:01,526
与 Swift 中 Hashable 希的不同

655
00:26:01,526 --> 0:26:04,326
CryptoKit中的哈希函数

656
00:26:04,726 --> 0:26:07,686
提供了如防碰撞等加密特性

657
00:26:08,626 --> 0:26:10,876
这意味着你很难找到

658
00:26:10,876 --> 0:26:16,986
两个会哈希出相同摘要的输入

659
00:26:16,986 --> 0:26:19,606
计算该哈希十分简单

660
00:26:19,606 --> 0:26:22,926
就像在你想要使用的哈希函数上

661
00:26:22,926 --> 0:26:24,976
调用哈希方法

662
00:26:24,976 --> 0:26:28,166
然后传递所要哈希的数据那样

663
00:26:29,196 --> 0:26:32,016
这里我想要哈希一些音频数据

664
00:26:32,016 --> 0:26:35,496
那么我会用 SHA256 哈希函数

665
00:26:35,496 --> 0:26:38,976
来计算一个摘要

666
00:26:45,146 --> 0:26:47,676
那你也许会从输入流中读取它

667
00:26:49,096 --> 0:26:50,416
在这种情况下

668
00:26:50,416 --> 0:26:53,906
你需要以增量来计算摘要

669
00:26:55,096 --> 0:26:57,566
首先你初始化一个哈希

670
00:26:57,566 --> 0:26:59,836
通过在哈希函数上

671
00:26:59,836 --> 0:27:01,746
调用 MT 初始化程序

672
00:26:59,836 --> 0:27:01,746
调用 MT 初始化程序

673
00:27:02,236 --> 0:27:07,016
接着传送你想要哈希的数据

674
00:27:07,016 --> 0:27:09,146
然后为此一次或多次地

675
00:27:09,146 --> 0:27:14,516
调用 update() 方法

676
00:27:14,756 --> 0:27:17,966
当你想要计算该摘要时

677
00:27:17,966 --> 0:27:20,446
你只要立即在哈希上

678
00:27:20,446 --> 0:27:22,226
调用 finalize() 方法

679
00:27:22,226 --> 0:27:24,466
然后它就会返回摘要

680
00:27:24,886 --> 0:27:29,396
接下来 我们来说说

681
00:27:29,636 --> 0:27:30,886
认证加密

682
00:27:31,716 --> 0:27:34,446
这也是你们一直想知道的

683
00:27:35,106 --> 0:27:37,496
正如它的名字所示

684
00:27:37,496 --> 0:27:39,896
它可以同时提供认证和加密

685
00:27:41,436 --> 0:27:44,146
在加密协议中

686
00:27:44,146 --> 0:27:46,686
缺少认证

687
00:27:46,686 --> 0:27:49,276
会导致很多攻击

688
00:27:49,836 --> 0:27:51,316
将身份验证

689
00:27:51,436 --> 0:27:53,636
和加密手动结合

690
00:27:54,356 --> 0:27:56,266
会导致如 Padding Oracle 

691
00:27:56,266 --> 0:27:58,076
这样的攻击

692
00:27:58,436 --> 0:28:00,586
所以 我们非常乐意将它

693
00:27:58,436 --> 0:28:00,586
所以 我们非常乐意将它

694
00:28:00,656 --> 0:28:03,036
作为一个 API 调用提供给你

695
00:28:07,076 --> 0:28:08,846
我正在做的一个项目

696
00:28:09,096 --> 0:28:10,586
这是一个徒步旅行 App

697
00:28:11,216 --> 0:28:12,786
该 App 上的大多数内容是免费的

698
00:28:12,786 --> 0:28:15,316
但也有额外的内容

699
00:28:15,316 --> 0:28:21,276
你可以在 App 里花钱购买

700
00:28:21,386 --> 0:28:22,876
一旦购买了该内容

701
00:28:23,216 --> 0:28:25,156
你就可以获取额外的内容

702
00:28:26,576 --> 0:28:27,936
我正在使用一个内容发布网络

703
00:28:27,936 --> 0:28:29,706
以此来保证随着用户群的增长

704
00:28:29,706 --> 0:28:32,776
下载的速度仍然很快

705
00:28:35,436 --> 0:28:37,776
为了获得该内容

706
00:28:38,026 --> 0:28:41,366
我首先检查了我的服务器

707
00:28:41,366 --> 0:28:44,976
看 App 内购买是否有效

708
00:28:45,596 --> 0:28:49,706
接着从服务器中获取到密钥

709
00:28:49,706 --> 0:28:51,296
然后通过手机传递过来

710
00:28:52,656 --> 0:28:54,836
我从内容发布网络上

711
00:28:55,136 --> 0:28:56,286
下载该加密数据

712
00:28:56,286 --> 0:29:00,686
然后使用密钥

713
00:28:56,286 --> 0:29:00,686
然后使用密钥

714
00:29:00,686 --> 0:29:02,736
来将加密内容解密

715
00:29:03,136 --> 0:29:06,346
如果密钥正确

716
00:29:06,346 --> 0:29:08,276
且在内容发布网络上的内容

717
00:29:08,276 --> 0:29:10,816
没有被篡改

718
00:29:10,866 --> 0:29:12,696
那么我就可以获取地图数据

719
00:29:13,306 --> 0:29:19,166
下面我们来看如何转化为代码

720
00:29:19,336 --> 0:29:22,166
我们首先用服务器

721
00:29:22,166 --> 0:29:24,366
获取的密钥数据

722
00:29:24,366 --> 0:29:29,036
初始化一个 SymmetricKey

723
00:29:29,186 --> 0:29:31,976
然后我们初始化一个密封箱

724
00:29:32,996 --> 0:29:35,576
在这个例子中

725
00:29:35,576 --> 0:29:37,246
密封箱里有什么真的不重要

726
00:29:37,306 --> 0:29:39,216
但是要知道如果你

727
00:29:39,556 --> 0:29:42,106
正在实现一个规范 

728
00:29:42,106 --> 0:29:44,066
该规范要求你以一种特定的方式

729
00:29:44,066 --> 0:29:46,146
将随机数 密码文本

730
00:29:46,146 --> 0:29:48,286
和标签结合起来

731
00:29:48,286 --> 0:29:49,986
那么你就可以使用密封箱来完成

732
00:29:50,816 --> 0:29:52,216
如果你要实现

733
00:29:52,216 --> 0:29:54,446
一个需要你传输

734
00:29:54,446 --> 0:29:57,146
特定随机数值的协议

735
00:29:57,366 --> 0:29:59,176
我们也能支持这个操作

736
00:29:59,336 --> 0:30:01,376
但是在这个例子里

737
00:29:59,336 --> 0:30:01,376
但是在这个例子里

738
00:30:01,416 --> 0:30:02,676
我们要看看简单的情况

739
00:30:04,096 --> 0:30:06,216
好 我们将下载的数据

740
00:30:06,216 --> 0:30:08,086
作为一个 combined

741
00:30:08,086 --> 0:30:09,636
传输到密封箱里

742
00:30:09,636 --> 0:30:12,156
既然我们有一个密封箱

743
00:30:12,896 --> 0:30:15,496
我们就可以打开它

744
00:30:15,496 --> 0:30:18,936
通过在密码上调用 open() 方法

745
00:30:19,566 --> 0:30:22,816
然后我们传输密钥

746
00:30:23,426 --> 0:30:23,976
就是这么简单

747
00:30:26,916 --> 0:30:28,896
接下来 我们说一说签名

748
00:30:30,196 --> 0:30:31,946
签名被用来

749
00:30:31,946 --> 0:30:34,036
使用一个私钥

750
00:30:34,036 --> 0:30:36,616
对数据进行身份验证

751
00:30:36,616 --> 0:30:38,926
使用签名我们可以

752
00:30:38,926 --> 0:30:41,346
用关联的公共密钥来验证数据

753
00:30:41,866 --> 0:30:45,856
我们来看一个例子

754
00:30:45,856 --> 0:30:47,846
这里我们想要用签名

755
00:30:47,846 --> 0:30:49,976
来授权操作

756
00:30:50,796 --> 0:30:54,496
而这里的操作可以是一个

757
00:30:54,496 --> 0:30:56,866
双重验证登录

758
00:30:56,916 --> 0:30:58,916
或一些敏感交易事项

759
00:30:58,916 --> 0:31:01,536
比如给 App 中的其他用户汇款

760
00:30:58,916 --> 0:31:01,536
比如给 App 中的其他用户汇款

761
00:31:03,666 --> 0:31:07,096
为此 我们首先要

762
00:31:07,406 --> 0:31:09,466
在设备上生成一个私钥

763
00:31:10,956 --> 0:31:13,246
接着获取相关联的公共密钥

764
00:31:13,816 --> 0:31:16,666
关联的公共密钥

765
00:31:16,666 --> 0:31:20,826
是用你的服务进行注册的

766
00:31:20,956 --> 0:31:24,016
一旦我们想要执行该操作

767
00:31:24,016 --> 0:31:25,926
我们就用私钥

768
00:31:25,926 --> 0:31:29,516
生成交易数据上的签名

769
00:31:29,516 --> 0:31:33,056
然后将该交易数据

770
00:31:33,056 --> 0:31:35,456
和签名发送给服务器

771
00:31:36,866 --> 0:31:40,566
服务器会验证

772
00:31:40,566 --> 0:31:44,686
该签名是否正确

773
00:31:44,686 --> 0:31:47,636
如果签名正确

774
00:31:47,636 --> 0:31:51,276
它将开始执行操作

775
00:31:51,756 --> 0:31:54,976
下面我们看看这组代码

776
00:31:54,976 --> 0:31:57,676
为了生成一个

777
00:31:57,676 --> 0:32:00,066
强加密的私钥

778
00:31:57,676 --> 0:32:00,066
强加密的私钥

779
00:32:00,066 --> 0:32:03,566
我们调用 PrivateKey 初始化程序

780
00:32:06,876 --> 0:32:09,546
然后我们想在服务器上

781
00:32:09,546 --> 0:32:11,316
注册一些公共密钥数据

782
00:32:12,176 --> 0:32:14,556
首先我们要获取公共密钥

783
00:32:14,806 --> 0:32:17,506
通过私钥上

784
00:32:17,596 --> 0:32:19,326
调用公共密钥

785
00:32:19,956 --> 0:32:24,536
然后我们要说

786
00:32:24,596 --> 0:32:26,766
我们想从公共密钥上

787
00:32:27,156 --> 0:32:28,346
得到的表示形式

788
00:32:29,026 --> 0:32:30,546
公共密钥有多种表示形式

789
00:32:30,546 --> 0:32:32,406
而在 CryptoKit 中

790
00:32:32,456 --> 0:32:36,216
我们支持许多公共密钥

791
00:32:37,536 --> 0:32:39,886
这种情况下

792
00:32:39,886 --> 0:32:41,106
我们使用紧凑表示

793
00:32:41,776 --> 0:32:44,106
与往常一样 我们将私钥

794
00:32:44,106 --> 0:32:45,586
存储在密钥链中

795
00:32:46,676 --> 0:32:48,996
为了实现这一点

796
00:32:48,996 --> 0:32:50,236
开发者门户上提供了

797
00:32:50,236 --> 0:32:51,266
示例代码

798
00:32:51,266 --> 0:32:54,946
要生成签名

799
00:32:54,946 --> 0:32:57,456
我们要在私钥上

800
00:32:57,516 --> 0:32:59,346
调用 signature() 方法

801
00:32:59,346 --> 0:33:02,446
然后传输我们

802
00:32:59,346 --> 0:33:02,446
然后传输我们

803
00:33:02,446 --> 0:33:03,796
想要签名的交易数据

804
00:33:03,796 --> 0:33:05,926
我们就可以返回签名

805
00:33:09,136 --> 0:33:13,126
现在 保护这些操作的密钥

806
00:33:13,266 --> 0:33:16,416
是十分有价值的

807
00:33:16,416 --> 0:33:19,366
所以我们想要给它

808
00:33:19,366 --> 0:33:21,416
最好的安全保障

809
00:33:21,906 --> 0:33:23,846
这时候就轮到 Secure Enclave 了

810
00:33:25,716 --> 0:33:27,726
Secure Enclave 是

811
00:33:27,726 --> 0:33:29,156
基于硬件的密钥管理器

812
00:33:29,466 --> 0:33:30,886
它与主处理器隔离

813
00:33:30,886 --> 0:33:33,766
来提供额外的安全层

814
00:33:34,466 --> 0:33:36,316
它被用作关键系统特性的一部分 

815
00:33:36,316 --> 0:33:39,606
如 Touch ID 或 Face ID

816
00:33:41,336 --> 0:33:45,186
让我们看看如何改进

817
00:33:45,186 --> 0:33:48,156
使用签名来利用

818
00:33:48,156 --> 0:33:49,986
Secure Enclave 的代码

819
00:33:50,596 --> 0:33:54,726
我们首先检查 Secure Enclave

820
00:33:54,726 --> 0:33:56,496
是否可以在设备上获得

821
00:33:57,206 --> 0:34:00,476
我们通过在 SecureEnclave 上调用 

822
00:33:57,206 --> 0:34:00,476
我们通过在 SecureEnclave 上调用 

823
00:34:00,476 --> 0:34:01,446
isAvailable 来完成这一步

824
00:34:01,936 --> 0:34:07,286
从这里开始 我们可以使用

825
00:34:07,286 --> 0:34:09,565
和之前生成时完全一样的代码

826
00:34:10,886 --> 0:34:14,356
来生成密钥

827
00:34:14,356 --> 0:34:15,516
同时在 Secure Enclave 里

828
00:34:15,516 --> 0:34:18,076
生成签名

829
00:34:18,606 --> 0:34:20,966
注意 为了完成这一步

830
00:34:21,016 --> 0:34:24,656
我们只需给

831
00:34:24,656 --> 0:34:27,985
调用的 PrivateKey 初始化程序

832
00:34:27,985 --> 0:34:30,016
添加前缀

833
00:34:30,016 --> 0:34:31,356
SecureEnclave.

834
00:34:32,596 --> 0:34:35,746
用 Secure Enclave 就是如此简单

835
00:34:37,755 --> 0:34:41,646
使用 Secure Enclave 的一个优势是

836
00:34:41,646 --> 0:34:44,536
你可以限制密钥的使用

837
00:34:45,096 --> 0:34:48,045
在本例中 我们想说

838
00:34:48,045 --> 0:34:50,126
我们在 Secure Enclave 上

839
00:34:50,126 --> 0:34:51,755
生成的密钥

840
00:34:52,656 --> 0:34:54,866
只有在设备解锁时

841
00:34:54,866 --> 0:34:58,596
才能访问

842
00:34:58,596 --> 0:35:01,786
且该密钥只在该设备上可用

843
00:34:58,596 --> 0:35:01,786
且该密钥只在该设备上可用

844
00:35:02,886 --> 0:35:04,706
我们可以进一步限制密钥的使用

845
00:35:04,706 --> 0:35:06,816
方法是当我们使用

846
00:35:06,816 --> 0:35:09,556
私钥执行操作时 

847
00:35:09,556 --> 0:35:12,326
我们要求用户在场

848
00:35:13,496 --> 0:35:16,076
要求用户在场意味着

849
00:35:16,076 --> 0:35:18,006
用户要么按提示进行

850
00:35:18,006 --> 0:35:19,186
生物鉴定识别

851
00:35:19,186 --> 0:35:22,336
要么按要求

852
00:35:22,336 --> 0:35:24,846
输入设备密码

853
00:35:25,466 --> 0:35:29,956
既然我们已经组成了一个

854
00:35:29,956 --> 0:35:32,156
访问控制规则

855
00:35:32,216 --> 0:35:33,726
我们只需将其传递给

856
00:35:33,726 --> 0:35:35,426
正在生成的密钥的初始化程序

857
00:35:35,426 --> 0:35:39,616
就可以执行该策略

858
00:35:40,626 --> 0:35:41,846
你可能希望为用户

859
00:35:41,846 --> 0:35:43,576
提供一些额外的上下文

860
00:35:43,656 --> 0:35:45,646
来说明为什么需要他们

861
00:35:45,646 --> 0:35:46,236
进行身份验证

862
00:35:46,886 --> 0:35:49,216
那么 我们可以传输一个

863
00:35:49,216 --> 0:35:51,126
LocalAuthentication 上下文

864
00:35:51,696 --> 0:35:56,206
在本例中 我们想要

865
00:35:56,236 --> 0:35:58,166
LocalAuthentication 上下文的

866
00:35:58,166 --> 0:36:00,376
有效期为十秒

867
00:36:00,376 --> 0:36:02,476
因此用户在这段时间内

868
00:36:02,476 --> 0:36:03,896
将不需要

869
00:36:04,426 --> 0:36:06,746
进行身份认证

870
00:36:07,116 --> 0:36:09,056
我们想告诉用户

871
00:36:09,056 --> 0:36:10,546
他们需要进行身份认证

872
00:36:10,656 --> 0:36:12,476
因为他们正在允许

873
00:36:12,476 --> 0:36:14,066
给 Bob 转账十美元

874
00:36:14,576 --> 0:36:17,506
要使用这个认证上下文

875
00:36:17,786 --> 0:36:19,516
你只需要将它

876
00:36:19,556 --> 0:36:23,136
传给密钥的初始化器

877
00:36:26,976 --> 0:36:29,456
最后让我们来谈谈性能

878
00:36:32,226 --> 0:36:34,546
CryptoKit 建立在 corecrypto 顶端

879
00:36:35,386 --> 0:36:37,556
corecrypto 是 Apple 的

880
00:36:38,056 --> 0:36:40,286
本地加密库

881
00:36:40,286 --> 0:36:41,816
它支持之前 Yannick 描述过的

882
00:36:41,816 --> 0:36:43,726
所有系统框架

883
00:36:44,306 --> 0:36:47,676
在为你带来

884
00:36:47,676 --> 0:36:48,726
Accelerate 框架的团队

885
00:36:48,726 --> 0:36:50,826
及 CPU 设计团队的帮助下

886
00:36:50,866 --> 0:36:53,216
corecrypto 手工调整了汇编代码

887
00:36:53,216 --> 0:36:55,196
将每个周期

888
00:36:55,196 --> 0:36:58,646
从每个支持微架构中压出

889
00:37:00,636 --> 0:37:03,466
除此之外

890
00:37:03,466 --> 0:37:05,776
因为它使用了 corecrypto

891
00:37:05,776 --> 0:37:07,916
所以它利用了 corecrypto 中的

892
00:37:07,916 --> 0:37:10,886
安全缓解措施

893
00:37:10,886 --> 0:37:13,986
比如侧通道阻抗

894
00:37:14,356 --> 0:37:16,446
而且 corecrypto 经过了 FIPS 验证

895
00:37:16,446 --> 0:37:19,156
这意味着你可以用

896
00:37:19,156 --> 0:37:22,196
符合 FIPS 的方式使用 CryptoKit

897
00:37:22,996 --> 0:37:24,576
Yannick 用这张幻灯片开始

898
00:37:24,716 --> 0:37:27,586
为大家展示了很多漏洞的类别

899
00:37:27,586 --> 0:37:31,006
它们会出现在

900
00:37:31,006 --> 0:37:33,076
加密协议和加密实现中

901
00:37:34,116 --> 0:37:36,086
有了 CryptoKit 我们开始

902
00:37:36,086 --> 0:37:37,896
消除这些漏洞类别中的一些

903
00:37:37,896 --> 0:37:40,036
但 CryptoKit 仍然是一个

904
00:37:40,036 --> 0:37:42,036
底层加密 API 虽然它非常强大

905
00:37:42,036 --> 0:37:44,226
可以实现各种各样的协议

906
00:37:44,226 --> 0:37:48,906
甚至是损坏的协议

907
00:37:49,076 --> 0:37:50,726
但并不是所有的加密缺点

908
00:37:50,726 --> 0:37:52,046
都可以在密码库级别上

909
00:37:52,046 --> 0:37:53,136
得到解决

910
00:37:53,496 --> 0:37:55,266
因此 我们强烈建议你

911
00:37:55,266 --> 0:37:56,706
如果可以的话

912
00:37:56,706 --> 0:37:59,626
要依靠一个更高级别的系统框架

913
00:38:00,176 --> 0:38:01,786
这仅仅是个开始

914
00:38:01,786 --> 0:38:03,586
我们想要继续帮助你

915
00:38:03,686 --> 0:38:05,646
发布尽可能安全的 App

916
00:38:05,846 --> 0:38:07,646
通过提供 API 来帮助你

917
00:38:07,646 --> 0:38:08,856
防止你 App 中

918
00:38:08,856 --> 0:38:10,526
安全的法律漏洞

919
00:38:11,056 --> 0:38:13,486
我们非常期待看到

920
00:38:13,486 --> 0:38:15,566
你在你的 App 中使用 CryptoKit

921
00:38:15,896 --> 0:38:17,146
在本次会议的网页上

922
00:38:17,446 --> 0:38:18,546
你会找到一个

923
00:38:18,546 --> 0:38:20,986
CryptoKit 说明文档的链接

924
00:38:20,986 --> 0:38:22,536
可以在 Xcode Playground 中使用

925
00:38:23,746 --> 0:38:25,866
下载它 然后摸索一下

926
00:38:25,866 --> 0:38:28,096
看看有什么可用的

927
00:38:28,756 --> 0:38:30,596
看看你如何在你的 App 中

928
00:38:30,596 --> 0:38:32,366
使用 CryptoKit

929
00:38:34,156 --> 0:38:36,016
我们会在明天的实验室中

930
00:38:36,376 --> 0:38:38,466
解答你们的问题

931
00:38:38,466 --> 0:38:41,636
我们期待你的反馈 谢谢

932
00:38:42,016 --> 0:38:44,000
[掌声]
