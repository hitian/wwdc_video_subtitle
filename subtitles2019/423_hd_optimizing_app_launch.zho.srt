1
00:00:00,506 --> 0:00:04,500
[音乐]

2
00:00:07,516 --> 0:00:13,046
[掌声]

3
00:00:13,546 --> 0:00:16,216
&gt;&gt; 大家好 我是 Spencer Lewson

4
00:00:16,216 --> 0:00:17,876
我是 Apple 公司 Performance Team 

5
00:00:18,046 --> 0:00:18,566
的一名工程师

6
00:00:19,446 --> 0:00:21,116
今天我很高兴告诉你们

7
00:00:21,116 --> 0:00:23,786
如何优化你们 App 的启动

8
00:00:24,336 --> 0:00:27,196
我们今天将讨论

9
00:00:27,196 --> 0:00:28,006
这四个主要议题

10
00:00:28,746 --> 0:00:30,686
首先 什么是启动

11
00:00:31,256 --> 0:00:32,076
不同类型的启动有哪些

12
00:00:32,076 --> 0:00:33,516
以及我们如何

13
00:00:33,516 --> 0:00:35,486
将它们分解为不同的子阶段

14
00:00:36,576 --> 0:00:37,906
接下来 我们将讨论

15
00:00:37,906 --> 0:00:39,626
如何正确估测你们 App 的启动

16
00:00:40,646 --> 0:00:42,356
生活中 iOS 设备

17
00:00:42,356 --> 0:00:43,366
可能处于各种不同的

18
00:00:43,436 --> 0:00:46,226
状态和情况 并且这些

19
00:00:46,226 --> 0:00:48,126
状态和条件可能

20
00:00:48,126 --> 0:00:49,886
产生不一致的启动结果

21
00:00:50,566 --> 0:00:51,656
因此 了解这些状态

22
00:00:51,656 --> 0:00:53,136
以及如何在进行测量时

23
00:00:53,176 --> 0:00:54,596
减少其影响非常重要

24
00:00:55,266 --> 0:00:58,826
在这时候

25
00:00:58,826 --> 0:00:59,866
你们可以查看如何使用

26
00:01:00,006 --> 0:01:02,106
Instruments 来分析和了解

27
00:01:02,106 --> 0:01:03,476
你们的 App 以找到

28
00:01:03,476 --> 0:01:04,806
改进它的机会

29
00:01:06,026 --> 0:01:07,296
最后 我们将为你们提供

30
00:01:07,346 --> 0:01:09,406
有关如何监控 App 启动的

31
00:01:09,406 --> 0:01:10,616
一些可持续且适用于实战的

32
00:01:10,976 --> 0:01:12,856
提示和技巧

33
00:01:13,316 --> 0:01:14,806
以确保你们始终为

34
00:01:14,806 --> 0:01:17,866
所有用户提供愉快的体验

35
00:01:17,866 --> 0:01:21,356
那么 我正在谈论的

36
00:01:21,616 --> 0:01:22,466
App 启动是什么

37
00:01:23,226 --> 0:01:26,626
其实 App 启动是用户体验的中断

38
00:01:27,966 --> 0:01:28,996
这是什么意思呢

39
00:01:29,536 --> 0:01:30,076
让我们来看看

40
00:01:31,126 --> 0:01:34,136
好的 准备 开始

41
00:01:38,186 --> 0:01:40,546
哇 在这台 iPhone 6S Plus 上

42
00:01:41,176 --> 0:01:43,366
启动时间差不多 2.5 秒

43
00:01:44,176 --> 0:01:45,736
这并不像我们用户期望的

44
00:01:45,736 --> 0:01:46,946
那样令人愉快

45
00:01:48,326 --> 0:01:49,736
你们知道 令人愉悦的启动

46
00:01:49,736 --> 0:01:50,676
是非常重要的

47
00:01:51,326 --> 0:01:52,396
因为它经常发生

48
00:01:53,276 --> 0:01:55,746
事实上 在所有 iOS 设备中

49
00:01:56,316 --> 0:01:58,436
它每天都会发生数十亿次

50
00:01:59,666 --> 0:02:00,336
所以 我们做了一些

51
00:01:59,666 --> 0:02:00,336
所以 我们做了一些

52
00:02:00,336 --> 0:02:02,286
简单计算 发现

53
00:02:02,286 --> 0:02:03,916
如果每次启动时我们

54
00:02:03,916 --> 0:02:05,476
节省一毫秒

55
00:02:05,476 --> 0:02:07,586
我们将节省共惊人的

56
00:02:07,586 --> 0:02:12,186
162 天启动时间

57
00:02:13,196 --> 0:02:15,026
是的 换句话说

58
00:02:16,506 --> 0:02:18,236
[掌声] 谢谢你们

59
00:02:18,236 --> 0:02:19,916
换句话说 这就是将火箭

60
00:02:19,916 --> 0:02:22,886
发送到火星所需的时间

61
00:02:23,626 --> 0:02:26,246
但由于其他一些原因 

62
00:02:26,246 --> 0:02:27,236
这同样很重要

63
00:02:27,926 --> 0:02:31,626
首先 你们 App 的启动是

64
00:02:31,706 --> 0:02:33,176
你们用户对你们 App

65
00:02:33,176 --> 0:02:35,216
的第一印象 

66
00:02:35,216 --> 0:02:35,946
因此它应该是愉悦的

67
00:02:37,236 --> 0:02:38,646
现在重要的是要记住

68
00:02:38,646 --> 0:02:40,326
作为开发者

69
00:02:40,326 --> 0:02:41,796
我们倾向于被更新的设备吸引

70
00:02:42,706 --> 0:02:43,766
因此 重要的是要确保

71
00:02:43,906 --> 0:02:45,126
你们在眼前

72
00:02:45,126 --> 0:02:46,876
看到的体验与

73
00:02:46,876 --> 0:02:48,146
你们的用户

74
00:02:48,626 --> 0:02:50,386
在不同 iOS 设备

75
00:02:50,386 --> 0:02:52,506
和不同条件下拥有的

76
00:02:53,016 --> 0:02:55,606
用户体验相同

77
00:02:57,356 --> 0:02:59,726
此外 启动涵盖了

78
00:02:59,726 --> 0:03:01,026
你们代码库的很大一部分

79
00:02:59,726 --> 0:03:01,026
你们代码库的很大一部分

80
00:03:01,716 --> 0:03:02,736
从底层加工到初始化

81
00:03:02,736 --> 0:03:05,646
再到视图创建等等

82
00:03:06,316 --> 0:03:08,076
因此 如果你们发现

83
00:03:08,076 --> 0:03:09,976
你们的启动并不像

84
00:03:10,196 --> 0:03:11,546
用户期望的那样愉悦

85
00:03:12,226 --> 0:03:13,436
那么这也可能表明

86
00:03:13,436 --> 0:03:14,496
你们的代码库的

87
00:03:14,496 --> 0:03:17,896
其他部分也并不那么令人愉悦

88
00:03:18,066 --> 0:03:19,686
最后 启动是一个对于手机是

89
00:03:19,686 --> 0:03:20,726
非常紧张的时间

90
00:03:21,456 --> 0:03:23,326
会涉及大量 CPU 工作和

91
00:03:23,326 --> 0:03:24,046
大量内存工作

92
00:03:24,956 --> 0:03:25,846
因此 你们应该尝试减缓它

93
00:03:25,906 --> 0:03:27,486
因为它会影响系统性能

94
00:03:27,486 --> 0:03:30,306
当然还有你们用户的电池寿命

95
00:03:30,736 --> 0:03:33,496
那么 让我们来看看

96
00:03:33,696 --> 0:03:34,886
我之前谈过的那些启动

97
00:03:35,386 --> 0:03:40,386
有冷启动 暖启动

98
00:03:40,696 --> 0:03:42,056
继续运行通常被称为启动 

99
00:03:42,056 --> 0:03:43,216
但其实它不是一个启动

100
00:03:45,616 --> 0:03:47,166
重启后或你们的 App 

101
00:03:47,166 --> 0:03:49,316
很长时间未启动时

102
00:03:49,316 --> 0:03:50,666
会发生冷启动

103
00:03:52,116 --> 0:03:54,106
为了启动 App

104
00:03:54,106 --> 0:03:57,666
我们需要将它从磁盘带入内存

105
00:03:57,666 --> 0:03:58,906
启动支持你们 App 的系统端服务

106
00:03:58,906 --> 0:04:00,816
然后生成你们的进程

107
00:03:58,906 --> 0:04:00,816
然后生成你们的进程

108
00:04:02,266 --> 0:04:03,616
正如你们所预料的那样

109
00:04:03,616 --> 0:04:05,886
这可能需要一点时间

110
00:04:05,916 --> 0:04:07,546
但幸运的是

111
00:04:07,546 --> 0:04:09,006
一旦发生一次 你们都将体验到暖启动

112
00:04:09,576 --> 0:04:12,496
在这种情况下 你们的 App 仍然

113
00:04:12,496 --> 0:04:14,516
需要被唤醒

114
00:04:14,516 --> 0:04:15,916
但我们已经将你们的 App 

115
00:04:15,916 --> 0:04:17,565
带入内存并启动了

116
00:04:17,565 --> 0:04:18,896
那些系统端服务

117
00:04:19,426 --> 0:04:20,255
所以 这会更快一点

118
00:04:20,255 --> 0:04:22,036
也会更一致

119
00:04:23,676 --> 0:04:25,206
最后 还要说说继续运行

120
00:04:26,256 --> 0:04:28,536
当用户从主屏幕

121
00:04:28,536 --> 0:04:30,066
或 App 切换器重新进入你们的 App 时

122
00:04:30,066 --> 0:04:31,306
会发生这种情况

123
00:04:32,336 --> 0:04:33,926
如你们所知

124
00:04:33,926 --> 0:04:35,546
该 App 在此时已经启动

125
00:04:35,546 --> 0:04:36,786
因此速度非常快

126
00:04:38,146 --> 0:04:39,066
你们需要记住的是

127
00:04:39,066 --> 0:04:41,256
在进行估量时 

128
00:04:41,396 --> 0:04:43,116
不要将继续运行与启动混淆

129
00:04:43,906 --> 0:04:46,436
所以 鉴于这些信息

130
00:04:46,936 --> 0:04:49,986
如果启动与继续运行一样快速

131
00:04:50,696 --> 0:04:56,006
和令人愉悦

132
00:04:56,516 --> 0:04:57,096
那不是很棒吗

133
00:04:57,826 --> 0:05:00,676
我们怎样才能做到这一点

134
00:04:57,826 --> 0:05:00,676
我们怎样才能做到这一点

135
00:05:02,036 --> 0:05:04,146
好吧 我们需要达到

136
00:05:04,146 --> 0:05:05,486
在 400 毫秒内渲染

137
00:05:05,626 --> 0:05:06,906
第一帧的目标

138
00:05:08,066 --> 0:05:09,266
这样我们就可以在

139
00:05:09,266 --> 0:05:10,866
启动动画期间

140
00:05:10,866 --> 0:05:13,116
向用户显示像素

141
00:05:13,116 --> 0:05:14,136
并且在启动动画完成时

142
00:05:14,136 --> 0:05:15,796
你们的 App 就具有

143
00:05:15,796 --> 0:05:17,506
交互性和响应性

144
00:05:18,096 --> 0:05:20,346
这样做的第一步是

145
00:05:20,346 --> 0:05:22,296
了解启动期间发生的情况

146
00:05:22,866 --> 0:05:24,666
那么 让我们启动《地图》

147
00:05:26,496 --> 0:05:28,126
如你们所知 

148
00:05:28,126 --> 0:05:29,606
启动通常发生在用户点按

149
00:05:29,606 --> 0:05:32,236
主屏幕上你们的图标时

150
00:05:32,406 --> 0:05:34,316
然后在接下来的 100 毫秒左右内

151
00:05:34,316 --> 0:05:36,136
iOS 将执行必要的

152
00:05:36,136 --> 0:05:37,916
系统端工作以

153
00:05:37,916 --> 0:05:39,746
初始化你们的 App

154
00:05:40,456 --> 0:05:42,386
这给了你们开发者有

155
00:05:42,786 --> 0:05:46,846
大约 300 毫秒来创建视图加载内容

156
00:05:46,846 --> 0:05:48,206
并生成第一帧

157
00:05:49,716 --> 0:05:51,506
现在这个帧不一定

158
00:05:51,506 --> 0:05:53,316
需要完全完成

159
00:05:53,316 --> 0:05:55,056
它可以有一些占位符

160
00:05:55,226 --> 0:05:58,996
用于异步加载数据

161
00:05:58,996 --> 0:06:00,706
但此时你们的 App 应该是

162
00:05:58,996 --> 0:06:00,706
但此时你们的 App 应该是

163
00:06:00,706 --> 0:06:01,356
可交互 且有响应的

164
00:06:02,536 --> 0:06:04,936
因此 在这个 Maps 的例子中 

165
00:06:04,936 --> 0:06:06,106
所有视窗尚未加载

166
00:06:06,526 --> 0:06:07,586
你们仍然可以启动搜索

167
00:06:07,586 --> 0:06:10,086
并浏览收藏夹

168
00:06:10,656 --> 0:06:13,786
然后在接下来的几百毫秒内

169
00:06:13,786 --> 0:06:15,006
你们可以显示异步加载的

170
00:06:15,006 --> 0:06:16,636
数据并为你们的用户

171
00:06:16,636 --> 0:06:17,646
生成最终帧

172
00:06:18,636 --> 0:06:19,976
让我们仔细看看这些阶段

173
00:06:24,156 --> 0:06:25,316
这六个阶段涵盖所有内容

174
00:06:25,316 --> 0:06:28,676
从系统初始化到 App 初始化

175
00:06:28,676 --> 0:06:32,716
再到视图创建和布局

176
00:06:32,716 --> 0:06:34,576
如果你们的 App 有需要的

177
00:06:34,576 --> 0:06:36,736
还可能有一个扩展阶段

178
00:06:37,036 --> 0:06:37,976
用于数据的异步加载

179
00:06:42,086 --> 0:06:44,666
系统界面的前半部分是 DYLD3

180
00:06:44,726 --> 0:06:47,476
对于你们中那些不熟悉的人

181
00:06:47,476 --> 0:06:49,356
动态链接器会加载

182
00:06:49,356 --> 0:06:50,536
你们的共享库和框架

183
00:06:52,156 --> 0:06:56,256
在 2017 年 我们引入了 DYLD3

184
00:06:56,296 --> 0:06:58,636
它为系统增加了

185
00:06:58,636 --> 0:07:00,026
令人兴奋的优化

186
00:06:58,636 --> 0:07:00,026
令人兴奋的优化

187
00:07:01,096 --> 0:07:02,026
好吧 我们很高兴地宣布

188
00:07:02,026 --> 0:07:03,906
在 iOS 13 中 我们会为

189
00:07:03,906 --> 0:07:05,966
你们的 App 带来这些优化

190
00:07:07,176 --> 0:07:08,726
这意味着我们现在会为热启动

191
00:07:08,726 --> 0:07:10,166
缓存运行时依赖项

192
00:07:10,166 --> 0:07:13,486
这应该会给它们带来显著的速度提升 [掌声]

193
00:07:13,956 --> 0:07:15,446
谢谢你们

194
00:07:21,066 --> 0:07:22,566
现在有了一个新的链接器

195
00:07:22,566 --> 0:07:23,606
我们提出了一些新的建议

196
00:07:24,846 --> 0:07:26,126
为了充分利用这些新的改进

197
00:07:26,126 --> 0:07:28,606
我们建议你们

198
00:07:28,606 --> 0:07:30,276
避免链接未使用的框架

199
00:07:30,276 --> 0:07:32,786
因为这可能会产生潜在成本

200
00:07:32,786 --> 0:07:33,136
我们稍后会向你们展示

201
00:07:34,646 --> 0:07:37,186
我们还建议你们

202
00:07:37,186 --> 0:07:39,236
避免动态库加载

203
00:07:39,236 --> 0:07:42,086
例如 dlopen() 或 NSBundle 中的 load()

204
00:07:42,166 --> 0:07:43,666
因为这会损失你们

205
00:07:43,666 --> 0:07:46,516
在缓存中建立的那些优势

206
00:07:47,816 --> 0:07:49,216
最后 这意味着

207
00:07:49,216 --> 0:07:51,386
你们应该硬链接

208
00:07:51,386 --> 0:07:52,786
所有依赖项

209
00:07:52,916 --> 0:07:54,676
因为它现在甚至比以前更快

210
00:07:57,456 --> 0:07:58,886
系统接口的后半部分

211
00:07:58,886 --> 0:08:00,476
是 libSystem Init

212
00:07:58,886 --> 0:08:00,476
是 libSystem Init

213
00:08:01,616 --> 0:08:02,716
这是我们在 App 中

214
00:08:02,716 --> 0:08:05,336
初始化底层系统组件的时候

215
00:08:06,436 --> 0:08:08,106
现在这主要是系统方面的工作

216
00:08:08,106 --> 0:08:09,556
有固定成本

217
00:08:10,336 --> 0:08:11,976
因此 开发者不需要关注该部分

218
00:08:15,106 --> 0:08:16,956
接下来是静态运行时初始化

219
00:08:18,496 --> 0:08:19,406
这在系统初始化

220
00:08:19,406 --> 0:08:21,386
Objective-C 和 Swift 

221
00:08:21,386 --> 0:08:22,136
运行次数时会出现

222
00:08:23,666 --> 0:08:25,006
一般来说

223
00:08:25,006 --> 0:08:26,136
你们的 App 不应该在这里做任何工作

224
00:08:26,706 --> 0:08:29,416
除非你有可能存在于代码中的

225
00:08:29,416 --> 0:08:30,816
静态初始化方法

226
00:08:31,436 --> 0:08:33,446
或者更可能是你链接的

227
00:08:33,446 --> 0:08:35,246
框架带来的“惊喜”

228
00:08:36,056 --> 0:08:38,626
通常 我们不建议静态初始化

229
00:08:38,626 --> 0:08:40,395
所以 让我们花点时间谈谈

230
00:08:40,395 --> 0:08:42,186
如何减少其影响

231
00:08:43,376 --> 0:08:45,016
如果你们拥有一个

232
00:08:45,016 --> 0:08:46,336
使用静态初始化的框架

233
00:08:46,686 --> 0:08:48,916
你们要考虑暴露 API 以

234
00:08:48,916 --> 0:08:50,076
尽早初始化你们的栈

235
00:08:50,716 --> 0:08:52,636
但是如果必须使用静态初始化

236
00:08:52,636 --> 0:08:56,966
请考虑将代码移出 +[Class load]

237
00:08:56,966 --> 0:08:59,366
它在 App 启动期间

238
00:09:00,226 --> 0:09:01,906
总会被调用

239
00:09:01,906 --> 0:09:03,646
就在你在类中第一次使用方法的时候

240
00:09:03,646 --> 0:09:08,066
被懒调用

241
00:09:08,246 --> 0:09:09,946
接下来是 UIKit 初始化

242
00:09:11,266 --> 0:09:12,156
这就是系统实例化

243
00:09:12,186 --> 0:09:13,896
你们的 UIApplication 

244
00:09:13,896 --> 0:09:15,896
和 UIApplicationDelegate 的时候

245
00:09:16,566 --> 0:09:18,646
在大多数情况下

246
00:09:18,646 --> 0:09:20,036
这是系统方面的工作

247
00:09:20,036 --> 0:09:21,606
设置事件处理

248
00:09:21,606 --> 0:09:22,206
和与系统的集成

249
00:09:23,256 --> 0:09:24,226
但是你们其实仍然

250
00:09:24,226 --> 0:09:26,996
可以影响此阶段

251
00:09:26,996 --> 0:09:29,876
如果你们在子类 UIApplication

252
00:09:30,056 --> 0:09:31,926
或者在 UIApplicationDelegate

253
00:09:32,646 --> 0:09:35,746
初始化程序中做任何工作

254
00:09:35,746 --> 0:09:36,516
现在我们看看 App 初始化

255
00:09:37,436 --> 0:09:38,476
最重要的东西都在这里

256
00:09:38,896 --> 0:09:40,136
这是作为开发者

257
00:09:40,136 --> 0:09:40,996
可能在你们 App 启动时

258
00:09:40,996 --> 0:09:42,706
初始化程序中做任何工作地方

259
00:09:43,246 --> 0:09:45,586
对于你们之中尚未采用

260
00:09:45,586 --> 0:09:47,826
UIScene API 或针对 iOS 12 

261
00:09:49,146 --> 0:09:50,326
或更早版本的用户的人来说

262
00:09:50,326 --> 0:09:53,356
App 初始化

263
00:09:54,116 --> 0:09:55,766
仍然可以用这些

264
00:09:55,766 --> 0:09:56,426
代理回调方法

265
00:09:57,186 --> 0:09:57,736
application:willFinishLaunchingwithOptions

266
00:09:57,736 --> 0:10:01,216
和 application:didFinishLaunchingwithOptions

267
00:09:57,736 --> 0:10:01,216
和 application:didFinishLaunchingwithOptions

268
00:10:01,956 --> 0:10:04,196
当你们的 App 显示给用户时

269
00:10:04,196 --> 0:10:06,286
applicationDidBecomeActive 这个方法

270
00:10:07,006 --> 0:10:09,036
会被进一步调用

271
00:10:10,176 --> 0:10:11,356
现在重要的是要知道

272
00:10:11,356 --> 0:10:13,316
如果你没有采用 UIScene API

273
00:10:13,316 --> 0:10:14,116
你应该创建视图控制器

274
00:10:14,116 --> 0:10:16,546
和 didFinishLaunchingwithOptions

275
00:10:17,686 --> 0:10:19,276
这是因为使用 UIScene 时

276
00:10:19,666 --> 0:10:23,216
App 初始化的工作方式略有不同

277
00:10:23,216 --> 0:10:24,276
现在你仍然可以获得

278
00:10:24,276 --> 0:10:25,456
willFinishLaunching 和

279
00:10:25,456 --> 0:10:26,726
didFinishLaunchingwithOptions

280
00:10:27,546 --> 0:10:28,736
但是当你们的 App 显示给用户时

281
00:10:28,736 --> 0:10:30,126
你们将获得

282
00:10:30,126 --> 0:10:32,836
UISceneDelegate 生命周期回调

283
00:10:34,116 --> 0:10:35,986
当然就是带有选项的

284
00:10:35,986 --> 0:10:36,426
scene:willConnectToSession

285
00:10:36,846 --> 0:10:38,586
sceneWillEnterForeground 和

286
00:10:38,586 --> 0:10:39,446
sceneDidBecomeActive

287
00:10:40,106 --> 0:10:41,666
你们应该创建视图控制器

288
00:10:41,666 --> 0:10:43,446
和带有选项的

289
00:10:43,446 --> 0:10:44,866
scene:willConnectToSession

290
00:10:46,266 --> 0:10:48,016
重要的是要注意 

291
00:10:48,016 --> 0:10:49,206
你们应该只创建

292
00:10:49,206 --> 0:10:50,256
视图控制器和带有选项的

293
00:10:50,256 --> 0:10:51,406
scene:willConnectToSession

294
00:10:51,666 --> 0:10:52,836
以及带有选项的

295
00:10:52,836 --> 0:10:53,956
didFinishLaunching

296
00:10:54,416 --> 0:10:55,956
这是常见的陷阱

297
00:10:55,956 --> 0:10:59,176
当然会导致性能损失

298
00:10:59,476 --> 0:11:01,826
并且可能导致你们代码库中

299
00:10:59,476 --> 0:11:01,826
并且可能导致你们代码库中

300
00:11:04,316 --> 0:11:04,426
出现不可预测的错误

301
00:11:04,636 --> 0:11:05,716
无论你们是否

302
00:11:05,846 --> 0:11:07,256
采用了新的 UIScene API

303
00:11:07,326 --> 0:11:09,196
我们对此阶段的建议

304
00:11:09,196 --> 0:11:09,996
通常都是相同的

305
00:11:09,996 --> 0:11:12,896
你们应该推迟

306
00:11:12,896 --> 0:11:14,456
任何不相关的工作

307
00:11:14,456 --> 0:11:15,926
但是没有必要

308
00:11:15,926 --> 0:11:18,446
提交你的第一帧

309
00:11:18,446 --> 0:11:20,846
可以通过将其推送到后台队列

310
00:11:20,846 --> 0:11:22,346
或者稍后再完全执行

311
00:11:25,096 --> 0:11:27,386
如果你们确实采用了 UIScenes

312
00:11:27,386 --> 0:11:28,886
那么你们可以再做一件事

313
00:11:28,886 --> 0:11:31,506
那就是确保你们在场景之间共享资源

314
00:11:32,126 --> 0:11:33,486
当然 这是为了减少

315
00:11:33,486 --> 0:11:35,456
多次不必要地

316
00:11:35,456 --> 0:11:37,766
进行一些工作的开销

317
00:11:38,696 --> 0:11:40,206
要了解有关 UIScenes 的更多信息

318
00:11:40,636 --> 0:11:43,366
那就是确保你们在场景之间这两个会议 

319
00:11:46,126 --> 0:11:47,456
接下来是第一帧 渲染阶段

320
00:11:48,446 --> 0:11:50,066
这是相对简单的

321
00:11:50,506 --> 0:11:51,776
这是我们创建视图

322
00:11:51,776 --> 0:11:54,106
执行布局 然后绘制它们的时候

323
00:11:55,236 --> 0:11:56,486
然后我们获取该信息

324
00:11:56,956 --> 0:11:58,166
并将你们的第一帧渲染

325
00:11:58,166 --> 0:11:59,956
用漂亮的像素呈现出来

326
00:12:02,446 --> 0:12:03,816
你们可以通过减少

327
00:12:03,816 --> 0:12:05,876
层次结构中的视图数

328
00:12:05,876 --> 0:12:06,406
来影响此阶段

329
00:12:06,446 --> 0:12:08,466
你们也可以通过

330
00:12:08,656 --> 0:12:09,946
展平视图以减少使用

331
00:12:09,946 --> 0:12:13,156
或延迟加载在启动期间

332
00:12:13,546 --> 0:12:15,026
未显示的视图来实现

333
00:12:15,556 --> 0:12:18,946
你们还应该查看自动布局

334
00:12:18,946 --> 0:12:19,966
看看是否可以减少

335
00:12:19,966 --> 0:12:21,496
正在使用的约束数量

336
00:12:23,516 --> 0:12:25,416
最后 我们有一个扩展阶段

337
00:12:26,106 --> 0:12:27,776
这是从你们第一次

338
00:12:27,896 --> 0:12:29,786
提交到向用户显示

339
00:12:29,786 --> 0:12:31,976
最终帧的 App 特定时间段

340
00:12:33,016 --> 0:12:34,146
这是当你加载

341
00:12:34,146 --> 0:12:35,506
我们谈到的异步数据时

342
00:12:36,316 --> 0:12:38,826
其实不是每个 App 都有这个阶段

343
00:12:39,916 --> 0:12:41,546
但如果你们确实有这个阶段

344
00:12:42,736 --> 0:12:44,876
那么你们的 App 应该具有互动性和响应性

345
00:12:45,436 --> 0:12:47,936
如果你们确实有这个阶段

346
00:12:47,936 --> 0:12:49,366
我们只会就你应该如何处理

347
00:12:49,366 --> 0:12:50,956
这个问题提供广泛性建议

348
00:12:50,956 --> 0:12:52,216
那就是了解正在发生什么

349
00:12:52,216 --> 0:12:54,386
并且你们可以通过

350
00:12:54,386 --> 0:12:56,626
利用 os_signpost API 来标记和衡量

351
00:12:56,956 --> 0:13:00,336
在这两个时期发生的工作

352
00:12:56,956 --> 0:13:00,336
在这两个时期发生的工作

353
00:13:04,476 --> 0:13:05,956
既然我们讨论了启动是什么

354
00:13:05,956 --> 0:13:08,886
让我们谈谈如何获得可用的测量

355
00:13:11,556 --> 0:13:14,236
在任何给定时间

356
00:13:14,236 --> 0:13:16,006
iOS 设备都处于各种

357
00:13:16,006 --> 0:13:17,836
不同的状态和情况下

358
00:13:17,836 --> 0:13:19,066
这可能会在启动时

359
00:13:19,066 --> 0:13:20,226
引入很大的差异

360
00:13:21,166 --> 0:13:22,506
因此 当我们分析和

361
00:13:22,506 --> 0:13:24,356
比较我们的启动结果时

362
00:13:24,846 --> 0:13:26,686
确保我们进行“Apple-Apple”的

363
00:13:26,686 --> 0:13:27,896
对比比较至关重要

364
00:13:27,896 --> 0:13:30,106
因为如果在进行任何更改之前

365
00:13:30,106 --> 0:13:33,396
你的启动结果完全不可预测

366
00:13:33,396 --> 0:13:35,146
你们如何知道

367
00:13:35,146 --> 0:13:36,356
自己是否取得了进展呢

368
00:13:36,896 --> 0:13:38,866
使其可预测的第一步是

369
00:13:38,866 --> 0:13:40,546
消除这些差异来源

370
00:13:40,546 --> 0:13:44,286
例如网络干扰和

371
00:13:44,286 --> 0:13:45,816
后台进程中的干扰

372
00:13:47,126 --> 0:13:48,526
现在我们意识到

373
00:13:48,576 --> 0:13:50,366
这听起来有悖常理

374
00:13:50,366 --> 0:13:51,836
因为这可能会导致

375
00:13:51,836 --> 0:13:53,366
启动不能完全

376
00:13:53,366 --> 0:13:55,506
代表常规使用 但我们想让

377
00:13:55,506 --> 0:13:57,276
你们知道这没关系

378
00:13:58,356 --> 0:13:59,456
拥有一致的结果可以

379
00:13:59,566 --> 0:14:01,286
使评估很好地进展

380
00:13:59,566 --> 0:14:01,286
使评估很好地进展

381
00:14:01,286 --> 0:14:02,416
这一点尤为重要

382
00:14:03,216 --> 0:14:07,186
在 Apple 我们一直在使用这种技术

383
00:14:07,276 --> 0:14:08,666
在开发过程中成功检测回归

384
00:14:09,186 --> 0:14:10,326
并缩短启动时间

385
00:14:11,106 --> 0:14:13,736
然后 我们通过使用

386
00:14:14,016 --> 0:14:15,626
在实际情况中收集的遥测数据

387
00:14:16,156 --> 0:14:17,406
来验证这些性能改进

388
00:14:17,586 --> 0:14:18,816
幸运的是 

389
00:14:18,816 --> 0:14:20,076
我们提供了一些关于建立干净

390
00:14:20,076 --> 0:14:21,066
和一致的环境的技巧

391
00:14:23,176 --> 0:14:25,146
首先 重启你们的设备

392
00:14:26,046 --> 0:14:26,976
这将清除任何

393
00:14:26,976 --> 0:14:28,616
不必要的状态

394
00:14:28,616 --> 0:14:29,996
然后让它在接下来的几分钟内

395
00:14:29,996 --> 0:14:31,506
安定下来以清除

396
00:14:31,506 --> 0:14:31,956
任何启动时间工作

397
00:14:34,256 --> 0:14:37,126
你们还可以通过打开飞行模式

398
00:14:37,126 --> 0:14:38,486
或在代码中标记

399
00:14:39,196 --> 0:14:40,306
网络依赖性来

400
00:14:40,306 --> 0:14:41,446
减少对网络的依赖

401
00:14:42,496 --> 0:14:45,156
网络可以引入相当多的差异

402
00:14:45,926 --> 0:14:48,056
接下来是 iCloud

403
00:14:49,176 --> 0:14:50,746
iCloud 是一个很棒的功能

404
00:14:50,776 --> 0:14:51,926
它可以在后台运行

405
00:14:51,926 --> 0:14:53,436
为我们的用户提供无缝体验

406
00:14:53,436 --> 0:14:55,726
但是在后台工作

407
00:14:55,726 --> 0:14:57,776
会干扰 App 的启动

408
00:14:58,246 --> 0:14:59,236
因此 在你们的测量过程中

409
00:15:00,106 --> 0:15:04,446
使用不变的 iCloud 帐户和不变的数据

410
00:15:04,446 --> 0:15:05,746
或完全注销 iCloud

411
00:15:06,296 --> 0:15:12,456
接下来一定要在进行测量时

412
00:15:12,456 --> 0:15:13,276
使用 App 的发布构建版本

413
00:15:13,946 --> 0:15:19,306
当然 这是为了减少测量期间

414
00:15:19,306 --> 0:15:22,796
不必要的调试代码的开销

415
00:15:22,796 --> 0:15:24,946
并利用编译时优化

416
00:15:26,276 --> 0:15:28,196
最后 你们应该使用

417
00:15:28,246 --> 0:15:30,216
热启动进行测量

418
00:15:30,216 --> 0:15:31,406
如前所述

419
00:15:31,406 --> 0:15:33,216
它们更加一致

420
00:15:33,216 --> 0:15:34,196
因为你们的某些 App 可能已经在内存中

421
00:15:34,996 --> 0:15:35,946
并且其中一些

422
00:15:35,946 --> 0:15:37,506
系统端服务可能已在运行

423
00:15:37,536 --> 0:15:41,786
现在我们可以设置

424
00:15:41,786 --> 0:15:42,196
一些数据来测试

425
00:15:43,286 --> 0:15:44,716
创建一致的模拟

426
00:15:44,806 --> 0:15:46,136
数据集非常重要

427
00:15:46,136 --> 0:15:48,296
你们可能需要

428
00:15:48,296 --> 0:15:49,366
为不同类型的用户

429
00:15:49,366 --> 0:15:51,376
提供一些数据集

430
00:15:51,376 --> 0:15:53,236
例如具有少量数据的用户

431
00:15:53,336 --> 0:15:55,966
和具有大量数据的用户

432
00:15:55,966 --> 0:15:58,406
但在理想情况下

433
00:15:58,406 --> 0:15:59,906
你们的 App 应该能够扩展到

434
00:15:59,906 --> 0:16:00,486
任何数量的数据

435
00:15:59,906 --> 0:16:00,486
任何数量的数据

436
00:16:01,546 --> 0:16:02,826
这就是为什么

437
00:16:02,826 --> 0:16:04,066
在显示第一帧时

438
00:16:04,066 --> 0:16:04,716
只加载必要数据的原因

439
00:16:08,076 --> 0:16:09,526
现在我们准备挑选一些设备了

440
00:16:10,656 --> 0:16:11,906
你们应该选择

441
00:16:11,906 --> 0:16:13,126
对用户重要的各种设备

442
00:16:13,126 --> 0:16:14,636
然后坚持使用它们

443
00:16:14,636 --> 0:16:15,626
强制一致性

444
00:16:16,876 --> 0:16:18,466
请确保将最旧的

445
00:16:18,466 --> 0:16:19,416
设备包含在

446
00:16:19,416 --> 0:16:20,686
最早支持的版本中

447
00:16:21,436 --> 0:16:22,496
这是因为旧设备

448
00:16:22,496 --> 0:16:24,186
和较新设备之间

449
00:16:24,186 --> 0:16:26,136
的性能特征

450
00:16:26,136 --> 0:16:28,716
看起来不同

451
00:16:29,196 --> 0:16:31,636
后者具有不同数量的 RAM 和 CPU 内核

452
00:16:32,936 --> 0:16:33,856
这将确保你们的

453
00:16:33,856 --> 0:16:35,776
所有设备上的

454
00:16:35,776 --> 0:16:38,046
所有用户都能感到愉快

455
00:16:41,046 --> 0:16:41,836
现在我们准备

456
00:16:41,836 --> 0:16:42,276
进行一些测量

457
00:16:43,576 --> 0:16:45,076
我们可以利用新的 XCTest 

458
00:16:45,286 --> 0:16:46,916
来在 Xcode 11 中

459
00:16:46,916 --> 0:16:47,636
测试 App 性能

460
00:16:48,686 --> 0:16:49,936
只需几行代码

461
00:16:50,506 --> 0:16:51,446
Xcode 就会重复启动你们的 App 

462
00:16:51,496 --> 0:16:53,716
然后提供有关其

463
00:16:53,796 --> 0:16:55,626
执行情况的统计结果

464
00:16:56,856 --> 0:16:58,626
我们稍后会谈到这个

465
00:17:01,466 --> 0:17:03,026
所以 现在我们已经讨论了

466
00:17:03,026 --> 0:17:05,326
启动是什么以及如何衡量它

467
00:17:06,306 --> 0:17:09,126
让我们谈谈如何改进它

468
00:17:10,516 --> 0:17:11,715
当你们在代码和工具中

469
00:17:11,715 --> 0:17:13,556
查看 App 的启动时

470
00:17:13,556 --> 0:17:15,136
你们应该记住

471
00:17:15,136 --> 0:17:16,756
这三个提示和技巧

472
00:17:18,205 --> 0:17:20,066
首先是最小化你们的工作

473
00:17:20,066 --> 0:17:22,226
然后优先考虑你们的工作

474
00:17:23,006 --> 0:17:25,205
最后 优化你们的工作

475
00:17:27,016 --> 0:17:28,846
在最小化工作时

476
00:17:28,846 --> 0:17:30,696
你们应该推迟与

477
00:17:31,086 --> 0:17:32,536
生成第一帧无关的任何内容

478
00:17:33,356 --> 0:17:34,746
这意味着推迟

479
00:17:34,746 --> 0:17:36,746
未显示的视图或尚未使用的

480
00:17:36,746 --> 0:17:39,146
预加热功能等内容

481
00:17:41,216 --> 0:17:42,776
你们还应该避免阻塞主线程

482
00:17:42,776 --> 0:17:46,996
比如网络 I/O  文件 I/O 或其他

483
00:17:47,696 --> 0:17:48,836
因为这会影响启动

484
00:17:49,216 --> 0:17:50,826
将其移动到后台线程

485
00:17:51,756 --> 0:17:53,566
最后 你们应该注意

486
00:17:53,566 --> 0:17:56,556
减少内存使用量分配和操作

487
00:17:56,556 --> 0:18:00,686
内存可能需要时间

488
00:17:56,556 --> 0:18:00,686
内存可能需要时间

489
00:18:00,896 --> 0:18:02,286
接下来 优先工作

490
00:18:03,416 --> 0:18:04,206
这时你们应确保以

491
00:18:04,206 --> 0:18:06,976
正确的服务质量安排工作

492
00:18:08,296 --> 0:18:10,306
现在 在 iOS 13 中

493
00:18:10,306 --> 0:18:11,456
我们对排程器进行了

494
00:18:11,456 --> 0:18:14,006
一些令人兴奋的优化

495
00:18:14,006 --> 0:18:15,076
使你们的 App 启动速度更快

496
00:18:15,076 --> 0:18:16,876
但这意味着

497
00:18:16,876 --> 0:18:18,706
保持优先问题跨线程传播工作

498
00:18:18,706 --> 0:18:21,456
比以往任何时候都更加重要

499
00:18:22,196 --> 0:18:24,456
你们应该看看 2017 年 WWDC 的

500
00:18:24,456 --> 0:18:25,536
《Modernizing Grand Central 

501
00:18:25,536 --> 0:18:28,236
Dispatch Usage》

502
00:18:28,566 --> 0:18:30,056
它深入探讨了

503
00:18:30,056 --> 0:18:31,286
如何正确处理并发问题

504
00:18:33,916 --> 0:18:35,566
最后 我们要进行优化工作

505
00:18:36,696 --> 0:18:37,966
这应该是在最小化

506
00:18:37,966 --> 0:18:38,936
并考虑优先级之后

507
00:18:38,936 --> 0:18:40,746
剩下的所有东西了

508
00:18:41,366 --> 0:18:42,526
也就是说它应该是

509
00:18:42,526 --> 0:18:43,976
简化的和有限的

510
00:18:44,726 --> 0:18:46,376
例如 限制仅在

511
00:18:46,376 --> 0:18:48,016
启动期间获取所需

512
00:18:48,016 --> 0:18:50,306
数据的数据量

513
00:18:50,306 --> 0:18:52,186
或者懒计算

514
00:18:52,186 --> 0:18:53,406
所需的任何变量和结果

515
00:18:55,016 --> 0:18:56,486
当你们这样做时

516
00:18:56,486 --> 0:18:57,556
请查看你们的方法和算法

517
00:18:57,556 --> 0:19:00,896
看看你们是否可以优化它们

518
00:18:57,556 --> 0:19:00,896
看看你们是否可以优化它们

519
00:19:00,896 --> 0:19:02,196
因为你们可以通过

520
00:19:02,196 --> 0:19:03,596
不同的计算结果或

521
00:19:04,066 --> 0:19:05,006
使用不同的数据结构

522
00:19:05,006 --> 0:19:05,426
来获得显着的改进

523
00:19:06,006 --> 0:19:10,616
最后 你们应该缓存你们的资源和复杂功能

524
00:19:11,396 --> 0:19:12,476
当然 这是通过多次

525
00:19:12,526 --> 0:19:14,386
不必要地工作

526
00:19:14,386 --> 0:19:16,646
来减少 CPU 和内存开销

527
00:19:17,246 --> 0:19:20,506
现在 我想把舞台交给 Dan

528
00:19:20,506 --> 0:19:22,696
Dan 将为你们提供一个

529
00:19:22,696 --> 0:19:24,236
关于如何在 Xcode Instruments 中使用

530
00:19:24,236 --> 0:19:25,496
新的 App 启动模板

531
00:19:25,496 --> 0:19:27,696
来理解和改进我们的 App 发布的精彩演示

532
00:19:28,516 --> 0:19:34,176
[掌声]

533
00:19:34,676 --> 0:19:35,436
&gt;&gt; 谢谢 Spencer

534
00:19:36,336 --> 0:19:38,326
嗨 大家好 我是 Dan Sawada

535
00:19:38,376 --> 0:19:39,786
我也是 Apple 的

536
00:19:39,786 --> 0:19:41,686
性能工程师之一

537
00:19:42,666 --> 0:19:44,276
今天 我将介绍一个了解

538
00:19:44,356 --> 0:19:45,676
你们的 App 启动的

539
00:19:45,846 --> 0:19:47,616
典型工作流程

540
00:19:48,156 --> 0:19:49,686
并寻找最小化 

541
00:19:49,686 --> 0:19:53,886
优先处理 以及优化工作的机会

542
00:19:53,886 --> 0:19:55,166
以便你们可以真正提供

543
00:19:55,416 --> 0:19:57,596
令人愉悦的第一次用户体验

544
00:19:58,836 --> 0:19:59,606
那么 我们开始吧

545
00:19:59,606 --> 0:20:02,096
我今天要展示的 

546
00:19:59,606 --> 0:20:02,096
我今天要展示的 

547
00:20:02,096 --> 0:20:04,496
App 叫做《Star Searcher》

548
00:20:04,856 --> 0:20:06,186
这是我们为此次分享会

549
00:20:06,186 --> 0:20:08,366
专门编写的示例 App

550
00:20:09,106 --> 0:20:10,856
如你们所见

551
00:20:10,856 --> 0:20:13,686
这是一个非常典型的 UITableView

552
00:20:13,746 --> 0:20:14,976
列出了我所有想象中的星星

553
00:20:15,176 --> 0:20:17,556
如果单击单元格或星形

554
00:20:17,556 --> 0:20:19,936
除了图片之外

555
00:20:19,936 --> 0:20:21,436
它还会显示一些

556
00:20:21,436 --> 0:20:22,026
描述性模糊状

557
00:20:23,116 --> 0:20:24,496
但是 我们有一个问题 

558
00:20:25,496 --> 0:20:26,766
先让我们继续并启动它

559
00:20:28,176 --> 0:20:29,676
准备 开始

560
00:20:33,196 --> 0:20:38,926
所以 这需要花费惊人的 2.5 秒才能启动

561
00:20:38,926 --> 0:20:40,546
不知道我是否可以称之为 令人愉快的

562
00:20:40,896 --> 0:20:42,676
所以 让我们使用 Xcode 和

563
00:20:43,016 --> 0:20:44,606
Instruments 来看看

564
00:20:45,016 --> 0:20:46,786
我们能做些什么

565
00:20:49,106 --> 0:20:51,326
所以 这里我们有

566
00:20:51,386 --> 0:20:52,726
《Star Searcher》 的 Xcode 项目

567
00:20:53,456 --> 0:21:01,126
现在 在进行任何与性能相关的分析之前

568
00:20:53,456 --> 0:21:01,126
现在 在进行任何与性能相关的分析之前

569
00:21:01,956 --> 0:21:03,576
我们应该做的一件重要事情

570
00:21:03,576 --> 0:21:04,026
是在 Xcode 中选择“Profile”Scheme

571
00:21:04,856 --> 0:21:08,076
这将确保 Xcode 

572
00:21:08,076 --> 0:21:11,816
在发布模式下重新编译你们的 App

573
00:21:11,816 --> 0:21:14,646
以便你们可以利用编译器时间优化

574
00:21:15,716 --> 0:21:17,196
一旦 Xcode 重新编译你们的 App

575
00:21:17,756 --> 0:21:19,026
它将在你们的设备上安装它

576
00:21:19,026 --> 0:21:21,936
并启动 Instruments

577
00:21:22,736 --> 0:21:24,816
现在我们很高兴地宣布

578
00:21:25,056 --> 0:21:28,416
从 iOS 13 或 Xcode 11 开始

579
00:21:28,796 --> 0:21:29,896
我们现在有了

580
00:21:29,896 --> 0:21:31,316
App Launch 模板

581
00:21:31,316 --> 0:21:35,496
专门用于这样的情况

582
00:21:35,496 --> 0:21:36,616
弄清楚 App 启动的问题

583
00:21:37,366 --> 0:21:39,096
那么 让我们继续并

584
00:21:39,806 --> 0:21:42,256
双击 App Launch

585
00:21:42,826 --> 0:21:45,786
现在我们要做的

586
00:21:45,786 --> 0:21:49,876
第一件事就是点按记录按钮

587
00:21:52,776 --> 0:21:54,176
此时 Instruments 将自动

588
00:21:54,176 --> 0:21:57,826
启动我们的 App《Star Searcher》

589
00:21:57,826 --> 0:22:00,016
收集所有指标

590
00:21:57,826 --> 0:22:00,016
收集所有指标

591
00:22:00,586 --> 0:22:02,176
遥测数据 分析它们

592
00:22:02,176 --> 0:22:03,756
并为所有 App 启动阶段

593
00:22:03,756 --> 0:22:04,776
创建可视化

594
00:22:05,686 --> 0:22:06,816
所以 看一看

595
00:22:07,396 --> 0:22:09,906
标记为紫色的

596
00:22:09,906 --> 0:22:12,836
前几个阶段是

597
00:22:12,836 --> 0:22:14,316
在 App 中调用 main 函数

598
00:22:14,316 --> 0:22:15,506
之前发生的阶段

599
00:22:17,656 --> 0:22:19,316
在绿色阶段

600
00:22:19,316 --> 0:22:21,356
当你们的 App 完成其启动

601
00:22:21,356 --> 0:22:22,916
并在 UI 中绘制其第一帧

602
00:22:22,916 --> 0:22:24,426
早期的这些过程发生在

603
00:22:24,426 --> 0:22:26,556
你们的主要功能的

604
00:22:26,556 --> 0:22:29,746
第一阶段

605
00:22:29,906 --> 0:22:32,166
让我们继续并展开轨道

606
00:22:32,686 --> 0:22:34,566
在我们展开轨道时

607
00:22:34,716 --> 0:22:36,496
你们可以看到在 App 进程中

608
00:22:36,496 --> 0:22:37,956
响应的所有线程的

609
00:22:37,956 --> 0:22:39,126
详细状态

610
00:22:40,086 --> 0:22:41,966
显然 最重要的一个

611
00:22:41,966 --> 0:22:44,256
是主线程

612
00:22:44,296 --> 0:22:46,106
或者也称为 UI 线程

613
00:22:46,356 --> 0:22:47,936
它负责处理

614
00:22:47,936 --> 0:22:51,016
用户输入和绘制 UI

615
00:22:51,786 --> 0:22:53,416
让我们继续并确定

616
00:22:53,416 --> 0:22:54,646
与我们的目的相关的轨道

617
00:22:54,646 --> 0:22:56,206
从 App 启动阶段开始

618
00:22:56,386 --> 0:22:59,356
我们的主要线程

619
00:22:59,786 --> 0:23:01,436
还有一个工人线程

620
00:22:59,786 --> 0:23:01,436
还有一个工人线程

621
00:23:01,436 --> 0:23:02,616
在启动期间

622
00:23:02,826 --> 0:23:04,546
做了大量的工作

623
00:23:05,476 --> 0:23:08,086
所以 让我们继续下去 并将其

624
00:23:08,976 --> 0:23:10,136
固定下来

625
00:23:11,616 --> 0:23:13,426
说到线程状态 

626
00:23:13,426 --> 0:23:18,226
哎呀 像那样

627
00:23:21,076 --> 0:23:23,596
说到线程状态 

628
00:23:23,596 --> 0:23:24,856
灰色意味着它被阻止

629
00:23:24,856 --> 0:23:26,336
这意味着线程没有做任何工作

630
00:23:27,856 --> 0:23:30,016
红色意味着它可以运行

631
00:23:30,016 --> 0:23:31,546
这意味着计划完成工作

632
00:23:31,546 --> 0:23:34,326
但缺乏 CPU 资源

633
00:23:35,256 --> 0:23:37,046
橙色意味着它被抢先一步

634
00:23:37,166 --> 0:23:39,336
这意味着它正在开展工作

635
00:23:39,566 --> 0:23:41,376
但却被中断

636
00:23:41,466 --> 0:23:44,216
支持其他具有更高优先级的竞争工作

637
00:23:44,856 --> 0:23:47,046
最后但并非不重要的是

638
00:23:47,046 --> 0:23:48,376
蓝色表示它正在运行

639
00:23:48,376 --> 0:23:49,836
这意味着它实际上正在 

640
00:23:49,926 --> 0:23:50,676
CPU 核心上工作

641
00:23:50,676 --> 0:23:53,856
因此 有了这些信息

642
00:23:53,856 --> 0:23:57,266
让我们从系统界面初始化

643
00:23:57,266 --> 0:23:58,516
开始逐步查看

644
00:24:00,036 --> 0:24:01,736
如果我们点按一个阶段三次

645
00:24:02,706 --> 0:24:04,676
我们可以突出显示这个阶段

646
00:24:04,676 --> 0:24:06,016
并在屏幕下半部分

647
00:24:06,016 --> 0:24:07,236
获取详细信息

648
00:24:08,026 --> 0:24:09,776
在你们的左侧

649
00:24:09,776 --> 0:24:12,246
你们可以看到在此时间段内

650
00:24:12,246 --> 0:24:13,376
正在完成的所有工作的

651
00:24:13,376 --> 0:24:14,216
详细栈跟踪

652
00:24:14,926 --> 0:24:17,676
在右侧 你们也可以看到

653
00:24:17,676 --> 0:24:19,176
聚合栈跟踪

654
00:24:19,176 --> 0:24:21,786
其中列出了按 CPU 

655
00:24:21,786 --> 0:24:23,856
样本数量排序的所有符号

656
00:24:24,826 --> 0:24:29,366
现在请注意这个初始阶段

657
00:24:29,736 --> 0:24:32,576
在设置系统接口时只需要 6 毫秒

658
00:24:33,316 --> 0:24:35,196
这主要归功于 

659
00:24:35,196 --> 0:24:37,666
dyld3 的引入

660
00:24:37,946 --> 0:24:39,546
和第三方应 App 的优势

661
00:24:39,546 --> 0:24:42,086
以及其他系统层的增强功能

662
00:24:42,996 --> 0:24:45,316
因此 作为开发者

663
00:24:45,316 --> 0:24:46,706
我们可以利用所有这些

664
00:24:46,706 --> 0:24:49,906
增强功能 而无需编写任何代码

665
00:24:50,876 --> 0:24:54,386
让我们继续来看

666
00:24:54,386 --> 0:24:55,986
但在我们这样做之前

667
00:24:55,986 --> 0:24:56,806
我还应该指出另一件事

668
00:24:57,996 --> 0:25:00,156
请注意 虽然此阶段

669
00:24:57,996 --> 0:25:00,156
请注意 虽然此阶段

670
00:25:00,156 --> 0:25:02,206
仅为《Star Searcher》 的

671
00:25:02,206 --> 0:25:05,876
CPU 占时上花费了 6 毫秒

672
00:25:05,876 --> 0:25:09,186
但它实际上花费了 149 毫秒

673
00:25:09,626 --> 0:25:11,366
这种差异来自

674
00:25:11,406 --> 0:25:13,016
分析机制本身的开销

675
00:25:13,016 --> 0:25:15,376
它确实为我们

676
00:25:15,376 --> 0:25:17,006
提供了大量的信息和想法

677
00:25:17,006 --> 0:25:18,886
但是它有自己的成本 

678
00:25:19,056 --> 0:25:21,156
因此 这就是将分析与

679
00:25:21,156 --> 0:25:23,016
测量结果区分开来

680
00:25:23,176 --> 0:25:24,946
非常重要的原因

681
00:25:25,186 --> 0:25:26,866
稍后我将对此进行解释

682
00:25:27,496 --> 0:25:30,506
进入下一阶段

683
00:25:30,506 --> 0:25:32,276
即静态运行时初始化

684
00:25:32,856 --> 0:25:35,566
现在我们注意到这个阶段

685
00:25:35,566 --> 0:25:38,616
耗时惊人的 375 毫秒

686
00:25:39,046 --> 0:25:40,866
这就有点太长了

687
00:25:42,316 --> 0:25:43,126
那我们来看看吧

688
00:25:43,866 --> 0:25:45,056
查看详细的栈跟踪

689
00:25:45,096 --> 0:25:47,566
我们看到一个带有

690
00:25:47,696 --> 0:25:50,576
蓝色图标的突出显示的符号

691
00:25:50,686 --> 0:25:54,366
标志着 CPU 工作量为 370 毫秒

692
00:25:54,716 --> 0:25:56,186
现在 所有这些突出显示的

693
00:25:56,256 --> 0:25:58,336
符号表示在我们的

694
00:25:58,376 --> 0:25:59,976
源中声明的代码

695
00:26:00,546 --> 0:26:02,796
我们来点按它

696
00:26:08,046 --> 0:26:09,826
现在通过扩展栈跟踪

697
00:26:09,866 --> 0:26:12,426
它将我们指向

698
00:26:12,426 --> 0:26:14,046
SLSuperFastLogger

699
00:26:14,456 --> 0:26:18,496
现在 如果一个库自称超高速（SuperFast）

700
00:26:18,596 --> 0:26:22,496
是有一些可疑的

701
00:26:22,496 --> 0:26:22,706
但还是让我们来看看

702
00:26:23,266 --> 0:26:26,266
那么 SLSuperFastLogger

703
00:26:26,266 --> 0:26:27,786
是我们专门导入 

704
00:26:27,786 --> 0:26:29,926
《Star Searcher》的外部框架

705
00:26:29,926 --> 0:26:34,606
可以利用强大而方便的日志记录

706
00:26:35,556 --> 0:26:37,256
但是 我们调用此框架的

707
00:26:37,256 --> 0:26:41,186
唯一位置是

708
00:26:41,186 --> 0:26:42,556
在 TableViewController 中

709
00:26:43,016 --> 0:26:44,296
具体说来

710
00:26:44,296 --> 0:26:46,146
在 didSelectRowAt 回调中

711
00:26:47,236 --> 0:26:49,816
现在这个回调完全在

712
00:26:49,816 --> 0:26:51,226
启动路径之外

713
00:26:51,406 --> 0:26:53,176
因为它只在用户点按

714
00:26:53,176 --> 0:26:54,026
一个单元格时调用

715
00:26:54,326 --> 0:26:56,616
那么 为什么它在之前的启动期间

716
00:26:56,616 --> 0:27:00,656
甚至在我们的主函数被调用之前

717
00:26:56,616 --> 0:27:00,656
甚至在我们的主函数被调用之前

718
00:27:00,656 --> 0:27:02,976
它的工作量超过 300 毫秒呢

719
00:27:03,436 --> 0:27:04,836
好吧 我们来探个究竟

720
00:27:08,476 --> 0:27:10,696
通过搜索符号

721
00:27:10,696 --> 0:27:13,336
它指向我们在

722
00:27:13,376 --> 0:27:14,666
SLSuperFastLogger 类中

723
00:27:14,756 --> 0:27:16,006
声明的加载方法

724
00:27:16,796 --> 0:27:18,026
现在 这是一个

725
00:27:18,026 --> 0:27:20,816
静态初始化程序

726
00:27:20,816 --> 0:27:23,296
这意味着所有这些工作

727
00:27:23,296 --> 0:27:24,976
都将在调用 main 函数之前的

728
00:27:24,976 --> 0:27:26,486
早期启动时完成

729
00:27:26,486 --> 0:27:27,886
因为我们链接了它

730
00:27:28,416 --> 0:27:30,636
这里的重点是

731
00:27:30,636 --> 0:27:33,686
了解依赖在你们使用的

732
00:27:33,686 --> 0:27:37,296
框架中的影响 是非常重要的

733
00:27:38,016 --> 0:27:39,116
外部库和框架可能很方便

734
00:27:39,116 --> 0:27:40,676
也可能很强大

735
00:27:40,676 --> 0:27:42,976
但可能需要付出

736
00:27:42,976 --> 0:27:44,076
巨大的代价

737
00:27:44,456 --> 0:27:48,316
所以 如果这些成本带来了

738
00:27:48,316 --> 0:27:49,796
这些好处 那很好

739
00:27:49,796 --> 0:27:51,606
但对于我们的情况

740
00:27:51,606 --> 0:27:54,166
在启动期间的 300 毫秒

741
00:27:54,166 --> 0:27:55,536
对于它的价值来说有点花费太多了

742
00:27:56,316 --> 0:27:58,496
所以 让我们继续前进

743
00:27:58,496 --> 0:27:59,216
寻求替代方案

744
00:28:00,626 --> 0:28:02,296
在我们的例子中 让我们使用 os.log

745
00:28:02,346 --> 0:28:03,956
这是一个非常轻量级

746
00:28:03,956 --> 0:28:06,226
和高效的日志记录机制

747
00:28:06,226 --> 0:28:08,546
适用于 iOS 以及

748
00:28:08,716 --> 0:28:11,696
其他 Apple 平台

749
00:28:11,696 --> 0:28:15,076
一旦我们删除了依赖

750
00:28:15,076 --> 0:28:17,696
我们一定要记住一件事

751
00:28:18,176 --> 0:28:23,426
即删除实际的链接

752
00:28:23,946 --> 0:28:26,616
现在因为这里的成本

753
00:28:26,706 --> 0:28:28,476
是静态初始化程序

754
00:28:28,916 --> 0:28:31,936
我们需要确保删除链接

755
00:28:31,936 --> 0:28:36,766
以免影响我们

756
00:28:37,106 --> 0:28:40,066
那么 有了这个 让我们回到我们的跟踪

757
00:28:41,076 --> 0:28:44,706
下一阶段是 UIKit 初始化 

758
00:28:44,706 --> 0:28:48,316
实际上耗时 28 毫秒

759
00:28:48,746 --> 0:28:52,186
这几乎是所有 App 的固定成本

760
00:28:53,066 --> 0:28:58,596
除非你们将 UI App 子类化

761
00:28:58,596 --> 0:28:59,966
或在 UIApplicationDelegate 中执行

762
00:28:59,966 --> 0:29:02,136
自定义初始化工作

763
00:28:59,966 --> 0:29:02,136
自定义初始化工作

764
00:29:02,136 --> 0:29:03,196
否则它几乎是我们

765
00:29:03,196 --> 0:29:04,446
现在可以忽略的

766
00:29:04,976 --> 0:29:06,856
那么 让我们继续前进

767
00:29:08,416 --> 0:29:11,296
下一部分工作是

768
00:29:11,336 --> 0:29:13,046
你们的 App 初始化

769
00:29:13,566 --> 0:29:15,586
这基本是由你们控制的

770
00:29:16,146 --> 0:29:18,296
注意到使用 

771
00:29:18,296 --> 0:29:20,116
didFinishLaunchingWithOptions 

772
00:29:20,266 --> 0:29:25,306
回调进行了大量的工作

773
00:29:25,306 --> 0:29:26,736
这在时钟上花费了 791 毫秒

774
00:29:27,086 --> 0:29:28,706
这其实很长

775
00:29:29,546 --> 0:29:32,276
让我们来看看

776
00:29:32,536 --> 0:29:35,056
因此 此阶段立即

777
00:29:35,056 --> 0:29:36,846
指出我们在

778
00:29:36,846 --> 0:29:39,986
StarDataProvider 类中进行了大量工作

779
00:29:41,156 --> 0:29:42,276
也就是在载入星星

780
00:29:42,796 --> 0:29:48,076
好的 现在请注意主线程中

781
00:29:48,076 --> 0:29:50,776
存在巨大的阻塞

782
00:29:50,776 --> 0:29:52,066
这实际上是我们启动的延迟

783
00:29:52,596 --> 0:29:55,896
我们的主线程被阻止了 754 毫秒

784
00:29:56,306 --> 0:29:58,396
这很不理想

785
00:29:59,606 --> 0:30:00,266
让我们来看看

786
00:29:59,606 --> 0:30:00,266
让我们来看看

787
00:30:01,926 --> 0:30:03,126
因此 为了检查详细状态

788
00:30:03,126 --> 0:30:07,326
我们应该查看事件列表

789
00:30:09,016 --> 0:30:11,096
通过查看事件列表

790
00:30:11,096 --> 0:30:12,666
我们注意到它被

791
00:30:12,796 --> 0:30:15,756
阻止了 754 毫秒

792
00:30:15,796 --> 0:30:20,376
之后 它被线程 0x12253 解除阻塞

793
00:30:20,376 --> 0:30:22,576
或者说变得可运行了

794
00:30:23,396 --> 0:30:28,316
这对应着正在做大量工作的工人线程

795
00:30:29,636 --> 0:30:31,386
所以 这里有一些联系

796
00:30:32,576 --> 0:30:34,096
现在回到主线程

797
00:30:34,096 --> 0:30:36,256
注意它被安排

798
00:30:36,296 --> 0:30:38,816
在优先级 47 上工作

799
00:30:39,376 --> 0:30:41,356
47 个等同于

800
00:30:41,356 --> 0:30:45,066
用户交互 QoS

801
00:30:45,276 --> 0:30:47,016
现在注意到这些红色交汇处

802
00:30:47,016 --> 0:30:49,606
我们还有很多工作要做

803
00:30:49,646 --> 0:30:51,986
但是他缺少 CPU 资源

804
00:30:52,496 --> 0:30:54,196
好吧 让我们找出原因

805
00:30:55,446 --> 0:30:58,476
当我们点按工人线程时

806
00:30:58,476 --> 0:30:59,836
我们注意到有

807
00:30:59,836 --> 0:31:02,156
很多工作计划在

808
00:30:59,836 --> 0:31:02,156
很多工作计划在

809
00:31:02,156 --> 0:31:03,456
优先级 4 下工作

810
00:31:03,966 --> 0:31:06,106
这相当于后台 QoS

811
00:31:06,106 --> 0:31:09,116
我们在这里

812
00:31:09,116 --> 0:31:11,326
实际看到的是一种被称为

813
00:31:11,326 --> 0:31:13,176
优先级倒置的问题

814
00:31:13,316 --> 0:31:15,186
其中给定线程被一个比自身

815
00:31:15,186 --> 0:31:17,406
具有更低 QoS 或优先级的

816
00:31:17,906 --> 0:31:19,386
单独线程阻塞

817
00:31:20,176 --> 0:31:21,676
显然 这并不理想

818
00:31:21,936 --> 0:31:23,816
因为它占用的资源

819
00:31:23,816 --> 0:31:25,286
超出了应有的范围

820
00:31:25,736 --> 0:31:30,346
所以 让我们继续尝试解决这个问题

821
00:31:30,346 --> 0:31:32,096
回顾一下这个问题的核心

822
00:31:32,096 --> 0:31:34,826
StarDataProvider 是一个

823
00:31:34,826 --> 0:31:36,576
非常简单的类

824
00:31:36,576 --> 0:31:38,016
它负责从 SQLite 数据库

825
00:31:38,506 --> 0:31:40,396
中获取我们的星星数据

826
00:31:40,396 --> 0:31:42,516
有一个具有

827
00:31:42,516 --> 0:31:44,456
后台 QoS 的专用调度队列

828
00:31:45,296 --> 0:31:47,286
并注意这是

829
00:31:47,286 --> 0:31:48,786
为了确保数据提取

830
00:31:48,786 --> 0:31:50,946
不会与 UI 竞争

831
00:31:50,946 --> 0:31:54,556
并且有两个 API 被暴露

832
00:31:55,246 --> 0:31:56,556
一个用于使用

833
00:31:56,556 --> 0:32:00,846
此 GrandCentralDispatch 的异步原语

834
00:31:56,556 --> 0:32:00,846
此 GrandCentralDispatch 的异步原语

835
00:32:00,886 --> 0:32:06,866
和另一个以同步方式加载数据的同步 API

836
00:32:08,446 --> 0:32:10,876
现在看看  

837
00:32:10,876 --> 0:32:12,026
didFinishLaunchingWithOptions

838
00:32:12,026 --> 0:32:13,686
中的实际调用站点

839
00:32:14,776 --> 0:32:15,916
我们正在利用

840
00:32:16,046 --> 0:32:19,486
异步 API

841
00:32:19,486 --> 0:32:20,706
但也利用调度 semaphore

842
00:32:20,816 --> 0:32:23,346
来确保在继续

843
00:32:23,346 --> 0:32:26,706
绘制 TableView 的第一帧之前

844
00:32:26,706 --> 0:32:29,816
等待所有数据都被提取

845
00:32:29,816 --> 0:32:32,626
现在 如果我们要这样做

846
00:32:32,626 --> 0:32:37,376
我们应该使用正确的并发原语

847
00:32:37,696 --> 0:32:41,736
也就是 GCD 中的同步原语

848
00:32:42,306 --> 0:32:45,436
用过使用正确的并发原语

849
00:32:45,746 --> 0:32:47,376
GrandCentralDispatch 将

850
00:32:47,376 --> 0:32:49,186
临时将主线程

851
00:32:49,246 --> 0:32:51,176
的优先级传播到

852
00:32:51,176 --> 0:32:52,626
工人线程 并将其提升为

853
00:32:52,626 --> 0:32:55,206
用户非活动状态

854
00:32:57,376 --> 0:32:57,546
以使其匹配

855
00:32:57,676 --> 0:32:59,986
所以 在这一点上

856
00:32:59,986 --> 0:33:01,916
我认为我们有可能

857
00:32:59,986 --> 0:33:01,916
我认为我们有可能

858
00:33:01,916 --> 0:33:03,186
解决优先级倒置问题

859
00:33:03,186 --> 0:33:04,456
但我还注意这儿

860
00:33:04,456 --> 0:33:05,066
有一个问题

861
00:33:06,326 --> 0:33:09,006
loadStarDataSync API 接受

862
00:33:09,006 --> 0:33:12,576
一系列行来加载数据

863
00:33:13,196 --> 0:33:15,016
在我们的例子中

864
00:33:15,296 --> 0:33:17,776
我们从第 0 行加载到最后一行

865
00:33:17,996 --> 0:33:19,766
这基本上就是一切

866
00:33:20,646 --> 0:33:22,946
现在 当你们考虑它时

867
00:33:22,946 --> 0:33:24,666
第一帧只能适合

868
00:33:24,666 --> 0:33:27,746
可能在屏幕尺寸上的

869
00:33:27,746 --> 0:33:28,706
有限数量的单元格

870
00:33:29,186 --> 0:33:30,506
在《Star Searcher》的情况下

871
00:33:30,986 --> 0:33:32,386
可能大约 10 到 15 个

872
00:33:32,736 --> 0:33:33,636
具体取决于设备

873
00:33:34,186 --> 0:33:36,186
所以 让我们继续并优化它

874
00:33:36,186 --> 0:33:38,086
而不是加载所有内容

875
00:33:38,216 --> 0:33:41,336
让我们只加载前 20 行

876
00:33:41,496 --> 0:33:44,806
就足以以同步方式

877
00:33:44,886 --> 0:33:47,006
绘制 TableView 的第一帧

878
00:33:47,846 --> 0:33:49,606
之后 我们应该在后台

879
00:33:49,606 --> 0:33:51,316
懒加载所有其余的

880
00:33:51,316 --> 0:33:53,156
只在启动后完成后

881
00:33:53,156 --> 0:33:55,566
更新 TableView

882
00:33:58,136 --> 0:33:58,916
让我们继续吧

883
00:33:59,696 --> 0:34:02,006
最后但也很重要的是回到追踪

884
00:33:59,696 --> 0:34:02,006
最后但也很重要的是回到追踪

885
00:34:02,396 --> 0:34:05,046
最后一个阶段是我们的

886
00:34:05,046 --> 0:34:06,256
第一个帧渲染

887
00:34:07,846 --> 0:34:11,126
请注意 这个阶段花了 951 毫秒

888
00:34:11,126 --> 0:34:12,656
这是非常长的

889
00:34:12,656 --> 0:34:15,866
考虑到这只是负责

890
00:34:15,866 --> 0:34:17,556
布局工作和我们

891
00:34:17,556 --> 0:34:18,186
第一帧的渲染

892
00:34:19,606 --> 0:34:22,656
现在让我们更深入地了解它

893
00:34:22,856 --> 0:34:28,206
它指向 StarTableViewController

894
00:34:29,906 --> 0:34:31,896
并查看详细的栈跟踪

895
00:34:31,936 --> 0:34:36,916
我们看到了很多工作和

896
00:34:36,916 --> 0:34:39,755
一个 cellForRowAt 回调

897
00:34:39,755 --> 0:34:42,485
它负责执行单元格的布局工作

898
00:34:42,485 --> 0:34:45,335
让我们继续并扩展我们所说的

899
00:34:46,216 --> 0:34:49,136
当我们扩展栈跟踪时

900
00:34:49,176 --> 0:34:53,815
它指明我们为 StarDetailViewController 进行了

901
00:34:53,815 --> 0:34:56,565
大量的初始化工作

902
00:34:56,565 --> 0:34:59,386
这在 CPU 上耗时 882 毫秒

903
00:34:59,466 --> 0:35:02,586
所以 在这一点上我们已经发现

904
00:34:59,466 --> 0:35:02,586
所以 在这一点上我们已经发现

905
00:35:02,586 --> 0:35:02,976
这几乎是这里的瓶颈

906
00:35:05,046 --> 0:35:06,626
我们来看看我们的代码吧

907
00:35:06,676 --> 0:35:12,416
现在查看 cellforRowAt 回调中的

908
00:35:12,556 --> 0:35:15,746
tableView 控制器

909
00:35:15,746 --> 0:35:17,406
我们使用自定义单元格创建单元格

910
00:35:18,576 --> 0:35:22,976
同时 我们进行推测性优化

911
00:35:22,976 --> 0:35:26,846
预热和缓存 DetailView 的 

912
00:35:27,036 --> 0:35:29,516
DetailViewControllers

913
00:35:29,516 --> 0:35:29,806
就像我们做布局工作一样

914
00:35:30,306 --> 0:35:31,686
这是希望简化从

915
00:35:32,046 --> 0:35:33,806
表格视图到

916
00:35:33,806 --> 0:35:35,266
详细视图的过渡

917
00:35:35,836 --> 0:35:38,456
但正如我们在追踪中所看到的

918
00:35:38,846 --> 0:35:40,126
这并不会产生高成本

919
00:35:41,196 --> 0:35:43,156
现在退一步

920
00:35:43,306 --> 0:35:44,296
当你想到它时

921
00:35:44,296 --> 0:35:45,816
详细的视图对

922
00:35:45,816 --> 0:35:47,356
我们的第一帧没有意义

923
00:35:47,816 --> 0:35:49,126
只有当用户点按

924
00:35:49,126 --> 0:35:50,376
一个单元格时才有意义

925
00:35:51,276 --> 0:35:54,336
所以 让我们继续推迟这项工作

926
00:35:57,356 --> 0:35:58,486
我们应该把它推迟到哪里

927
00:35:59,216 --> 0:36:01,566
也许是 didSelectRowAt 回调这里

928
00:35:59,216 --> 0:36:01,566
也许是 didSelectRowAt 回调这里

929
00:36:01,566 --> 0:36:07,966
当用户点按一个单元格时调用它

930
00:36:09,336 --> 0:36:11,156
因此 此时 我们对 

931
00:36:11,276 --> 0:36:12,526
《Star Searcher》进行了

932
00:36:12,526 --> 0:36:14,316
一些改进或优化

933
00:36:14,466 --> 0:36:15,976
所以 让我们继续并重新分析它

934
00:36:23,086 --> 0:36:26,656
现在需要注意的一点是

935
00:36:26,656 --> 0:36:29,646
当你们进行增量更改时

936
00:36:29,646 --> 0:36:32,046
你们应该在进展时

937
00:36:32,046 --> 0:36:34,076
不断重新测量

938
00:36:34,076 --> 0:36:35,006
和重新分析

939
00:36:35,356 --> 0:36:37,676
这样 你们就可以

940
00:36:37,746 --> 0:36:41,776
真正了解你们增量变更集的确切影响

941
00:36:42,046 --> 0:36:43,416
但是为了这个演示

942
00:36:43,696 --> 0:36:44,916
我们实际上因为

943
00:36:44,916 --> 0:36:49,566
节省时间 把所有变化合并为一个 Boom

944
00:36:49,566 --> 0:36:51,086
有一点 UI 故障

945
00:36:51,086 --> 0:36:54,016
但我们可以立即看到

946
00:36:54,406 --> 0:36:56,456
我们的启动时间不到 500 毫秒

947
00:36:57,186 --> 0:37:02,346
现在 正如我之前所说

948
00:36:57,186 --> 0:37:02,346
现在 正如我之前所说

949
00:37:02,346 --> 0:37:04,296
分析机制确实带来了

950
00:37:04,296 --> 0:37:05,376
自己的成本

951
00:37:05,636 --> 0:37:06,896
因此 为了更好地了解

952
00:37:06,896 --> 0:37:08,816
我们的用户将

953
00:37:08,816 --> 0:37:11,486
体验到什么

954
00:37:12,476 --> 0:37:15,656
让我们继续使用

955
00:37:16,066 --> 0:37:17,626
新的 XCTest API 来测量

956
00:37:17,626 --> 0:37:18,886
我们测试中的启动性能

957
00:37:20,246 --> 0:37:21,986
只需几行代码

958
00:37:22,176 --> 0:37:23,886
我们就可以将

959
00:37:23,886 --> 0:37:25,876
启动性能测试

960
00:37:25,876 --> 0:37:27,766
或任何性能测试与 XCTest 集成在一起

961
00:37:28,306 --> 0:37:32,446
让我们继续 并启动测试

962
00:37:33,886 --> 0:37:39,636
现在 XCTest 将进行一次一次性的启动测试

963
00:37:39,846 --> 0:37:41,936
这将取消冷启动

964
00:37:42,536 --> 0:37:44,946
会产生的差异

965
00:37:45,466 --> 0:37:47,116
之后 它将执行

966
00:37:47,116 --> 0:37:48,676
指定的迭代次数

967
00:37:48,816 --> 0:37:51,326
或者默认执行

968
00:37:51,436 --> 0:37:54,016
五次迭代 并测量所花费的时间

969
00:37:54,856 --> 0:37:57,176
之后 它将产生一些

970
00:37:57,176 --> 0:38:01,986
很好的统计数据

971
00:37:57,176 --> 0:38:01,986
很好的统计数据

972
00:38:02,186 --> 0:38:06,236
这项测试需要几分钟才能完成

973
00:38:06,236 --> 0:38:09,986
现在我们已经将《Star Searcher》的启动

974
00:38:10,106 --> 0:38:12,696
从 2.5 秒推到了

975
00:38:13,066 --> 0:38:16,536
刚刚超过 300 毫秒

976
00:38:17,031 --> 0:38:19,031
[掌声]

977
00:38:19,046 --> 0:38:21,346
为了结束演示

978
00:38:21,346 --> 0:38:22,136
我想向你们展示

979
00:38:22,686 --> 0:38:23,726
UI 上的实际情况

980
00:38:24,606 --> 0:38:26,276
好了 让我们确保漂亮得完成了

981
00:38:26,276 --> 0:38:29,126
《Star Searcher》真的很快

982
00:38:30,516 --> 0:38:33,500
[掌声]

983
00:38:38,056 --> 0:38:39,946
谢谢你们 交回给你 Spencer

984
00:38:41,516 --> 0:38:45,376
[掌声]

985
00:38:45,876 --> 0:38:47,066
&gt;&gt; 多谢 Dan 关于如何使用

986
00:38:47,066 --> 0:38:49,076
Xcode Instruments

987
00:38:49,486 --> 0:38:51,746
App Launch 模板

988
00:38:52,006 --> 0:38:53,766
来改善我们的 App 启动体验的精彩演示

989
00:38:54,526 --> 0:38:57,226
好的 我们意识到

990
00:38:57,226 --> 0:38:59,816
在你们的代码库中

991
00:38:59,816 --> 0:39:01,766
你们不会在代码中

992
00:38:59,816 --> 0:39:01,766
你们不会在代码中

993
00:39:01,766 --> 0:39:03,356
找到几个可以用几行修复的地方

994
00:39:03,356 --> 0:39:06,516
并获得如此重大的改进

995
00:39:07,546 --> 0:39:10,356
你很可能必须找到一堆

996
00:39:10,356 --> 0:39:12,396
5 到 10 毫秒的胜利

997
00:39:12,396 --> 0:39:13,586
然后将所有这些组合在一起

998
00:39:14,816 --> 0:39:15,866
我们想让你们知道

999
00:39:15,866 --> 0:39:16,396
我们已经在背后支持你们了

1000
00:39:17,746 --> 0:39:20,146
我们已经进行了

1001
00:39:20,146 --> 0:39:21,636
大量的 iOS 优化以改善

1002
00:39:21,636 --> 0:39:23,146
你们的 App 的推出

1003
00:39:23,146 --> 0:39:26,076
并帮助你们实现目标

1004
00:39:26,076 --> 0:39:27,016
而你们几乎没有采用

1005
00:39:28,016 --> 0:39:30,396
我想特别呼吁采用一些

1006
00:39:30,956 --> 0:39:36,256
如前所述 dyld3 将运行时依赖项

1007
00:39:36,256 --> 0:39:38,056
缓存到你们的 App 中

1008
00:39:38,056 --> 0:39:39,276
你们在演示中看到了这些依赖项

1009
00:39:39,426 --> 0:39:40,976
这提供了巨大的改进

1010
00:39:41,496 --> 0:39:43,606
排程器还经过优化

1011
00:39:43,606 --> 0:39:45,626
以帮助确定启动期间

1012
00:39:45,626 --> 0:39:47,236
发生的工作的优先级

1013
00:39:48,026 --> 0:39:50,126
我们还仔细看了 Auto Layout

1014
00:39:50,126 --> 0:39:51,646
和 Objective-C

1015
00:39:51,956 --> 0:39:53,736
并在那里进行了一系列优化

1016
00:39:54,896 --> 0:39:56,526
最后 我们将在今年晚些时候

1017
00:39:56,526 --> 0:39:57,566
对 App 打包进行

1018
00:39:57,766 --> 0:39:59,386
激动人心的更改

1019
00:40:00,436 --> 0:40:02,216
我们认为这些变化

1020
00:40:02,216 --> 0:40:03,786
总会导致你们几乎没有

1021
00:40:03,786 --> 0:40:09,176
采用优化的 App 的大幅改进

1022
00:40:09,316 --> 0:40:10,956
所以 让我们总结

1023
00:40:10,956 --> 0:40:12,316
一些提示和技巧

1024
00:40:12,316 --> 0:40:13,266
了解如何在完成

1025
00:40:13,306 --> 0:40:14,976
所有这些工作后确保你们的 App 令人愉悦

1026
00:40:19,076 --> 0:40:20,276
首先 不要让性能

1027
00:40:20,276 --> 0:40:21,546
成为事后的想法

1028
00:40:22,326 --> 0:40:24,136
你们应该在每个 Bug 

1029
00:40:24,136 --> 0:40:25,566
修复的开始

1030
00:40:25,696 --> 0:40:27,036
每个参数改动的开始

1031
00:40:27,736 --> 0:40:30,316
以及每个功能研发的开始时

1032
00:40:30,316 --> 0:40:30,956
考虑并研究它

1033
00:40:32,286 --> 0:40:35,316
这是因为 引入回归非常容易

1034
00:40:35,756 --> 0:40:38,216
特别是像 2 毫秒这样的小回归

1035
00:40:39,026 --> 0:40:40,616
问题是这些小问题

1036
00:40:40,616 --> 0:40:43,026
加起来是一个大问题

1037
00:40:43,026 --> 0:40:45,576
如果你不立即解决它们

1038
00:40:45,576 --> 0:40:46,336
就很难找到它们

1039
00:40:46,336 --> 0:40:49,536
为了做到这一点 

1040
00:40:49,536 --> 0:40:51,096
为了要检测这些回归

1041
00:40:51,096 --> 0:40:52,926
你们应该定期绘制 App 的启动

1042
00:40:52,926 --> 0:40:54,896
并定期运行测试

1043
00:40:55,646 --> 0:40:58,016
这将确保你们达到目标

1044
00:40:58,016 --> 0:40:59,446
并立即知道你们

1045
00:40:59,446 --> 0:41:03,896
是否已回归了该目标

1046
00:40:59,446 --> 0:41:03,896
是否已回归了该目标

1047
00:41:03,986 --> 0:41:05,946
你们还应该看看

1048
00:41:05,946 --> 0:41:08,416
新的 Xcode 管理器

1049
00:41:08,816 --> 0:41:09,736
它可以让你们了解

1050
00:41:09,776 --> 0:41:10,586
你们 App 在现场的表现

1051
00:41:11,666 --> 0:41:13,366
在 iOS 13 中 对于已选择加入的用户

1052
00:41:13,366 --> 0:41:15,756
将收集有关你们 App 的

1053
00:41:15,756 --> 0:41:17,256
耗电和性能指标

1054
00:41:18,296 --> 0:41:19,816
然后 它们将在

1055
00:41:19,816 --> 0:41:21,456
24 小时内汇总

1056
00:41:21,456 --> 0:41:22,886
并发送回你们的组织者

1057
00:41:22,886 --> 0:41:25,936
你们可以通过软件版本和设备版本 

1058
00:41:25,936 --> 0:41:26,796
以直方图的形式查看它们

1059
00:41:28,136 --> 0:41:29,726
但是 如果你们希望

1060
00:41:29,726 --> 0:41:31,026
对该数据进行更多控制

1061
00:41:31,916 --> 0:41:33,236
你们可以采用 MetricKit

1062
00:41:34,636 --> 0:41:36,406
MetricKit 允许你们

1063
00:41:36,616 --> 0:41:38,386
指定自定义功率和性能指标

1064
00:41:39,886 --> 0:41:41,236
现在 与组织者一样

1065
00:41:41,236 --> 0:41:42,486
这些数据将在

1066
00:41:42,486 --> 0:41:44,046
24 小时内收集和汇总

1067
00:41:44,046 --> 0:41:46,226
然后通过你们 App 

1068
00:41:46,266 --> 0:41:49,276
中的授权方法 传回给你们

1069
00:41:50,066 --> 0:41:51,186
从那里开始 你们就可以

1070
00:41:51,186 --> 0:41:52,686
随意处理数据

1071
00:41:53,696 --> 0:41:54,976
要了解更多相关信息

1072
00:41:54,976 --> 0:41:55,846
我们建议你们查看

1073
00:41:55,996 --> 0:41:57,066
2019 年 WWDC 中的

1074
00:41:57,066 --> 0:41:59,846
提升电池寿命和性能

1075
00:42:03,096 --> 0:42:05,566
那么 总而言之

1076
00:42:05,756 --> 0:42:07,736
我们今天非常开心

1077
00:42:07,736 --> 0:42:09,146
通过 Xcode Instruments 中的新

1078
00:42:09,146 --> 0:42:10,596
App Lauch 模板开始

1079
00:42:10,596 --> 0:42:11,116
了解你们 App 的启动

1080
00:42:11,916 --> 0:42:12,616
看看你们是否能

1081
00:42:12,616 --> 0:42:16,816
找到最小化 最优排序和

1082
00:42:17,536 --> 0:42:17,626
优化你们工作的机会

1083
00:42:18,836 --> 0:42:21,036
接下来 虽然意图很好

1084
00:42:21,276 --> 0:42:22,786
但并非所有优化都能成功得到

1085
00:42:23,586 --> 0:42:24,596
例如 Dan 在他的演示中

1086
00:42:24,596 --> 0:42:26,936
提到的预热 DetailView 控制器

1087
00:42:27,936 --> 0:42:30,026
因此 每当你们进行更改时

1088
00:42:30,026 --> 0:42:32,596
请务必测量而不是

1089
00:42:32,596 --> 0:42:33,406
大致估计性能

1090
00:42:34,026 --> 0:42:35,646
再说一次 无意中

1091
00:42:35,646 --> 0:42:37,566
引入回归 非常容易

1092
00:42:38,956 --> 0:42:40,496
最后 你们应该

1093
00:42:40,496 --> 0:42:41,916
在开发的所有阶段

1094
00:42:41,916 --> 0:42:42,566
跟踪你们的表现

1095
00:42:43,576 --> 0:42:44,696
这意味着在各种设备上

1096
00:42:44,696 --> 0:42:48,826
使用新的 XCTest App 启动测量

1097
00:42:48,826 --> 0:42:50,156
并可能将其与

1098
00:42:50,156 --> 0:42:52,006
持续集成相结合

1099
00:42:53,176 --> 0:42:54,216
这将确保你们

1100
00:42:54,216 --> 0:42:57,356
始终为所有设备上的所有用户

1101
00:42:57,356 --> 0:42:59,546
提供令人愉快的 App 启动

1102
00:43:02,206 --> 0:43:03,896
有关更多信息

1103
00:43:03,896 --> 0:43:04,646
请查看我们今天

1104
00:43:04,646 --> 0:43:06,806
引用的会议

1105
00:43:06,806 --> 0:43:07,756
然后在周五下午

1106
00:43:07,756 --> 0:43:08,806
好好休息一下 多谢你们

1107
00:43:09,516 --> 0:43:12,500
[掌声]
