1
00:00:00,506 --> 0:00:05,500
[音乐]

2
00:00:09,516 --> 0:00:16,556
[掌声]

3
00:00:17,056 --> 0:00:18,706
&gt;&gt; 欢迎来到网络发展专场

4
00:00:18,756 --> 0:00:19,976
我是 Joshua Graessley

5
00:00:20,126 --> 0:00:21,416
我和我的同事都来自

6
00:00:21,416 --> 0:00:22,896
互联网技术部

7
00:00:22,896 --> 0:00:24,946
我们很高兴向你们介绍去年我们在

8
00:00:24,946 --> 0:00:26,196
我们平台的网络方面

9
00:00:26,276 --> 0:00:28,076
所做的一些改进

10
00:00:29,206 --> 0:00:32,636
第一部分 我们要讲讲低数据模式

11
00:00:32,706 --> 0:00:34,156
这是一个令人惊喜的新功能

12
00:00:34,156 --> 0:00:35,286
我们可以一起协作

13
00:00:35,286 --> 0:00:36,766
来帮助保存用户的网络数据

14
00:00:36,766 --> 0:00:38,116
如果它很重要的话

15
00:00:38,406 --> 0:00:39,896
我们会跟大家谈谈

16
00:00:39,896 --> 0:00:41,466
你是如何编写异步

17
00:00:41,466 --> 0:00:42,926
用 Combine 在 URLSession 里编写

18
00:00:42,926 --> 0:00:45,486
非常漂亮的异步网络代码

19
00:00:46,396 --> 0:00:48,816
我们也会谈到 WebSocket API

20
00:00:49,096 --> 0:00:50,056
去年 这是你们在答疑会上

21
00:00:50,056 --> 0:00:51,326
提出的一系列问题中的一个

22
00:00:51,326 --> 0:00:52,896
今年 我们很高兴

23
00:00:52,896 --> 0:00:54,426
能为你们带来一个解决方案

24
00:00:55,506 --> 0:00:56,866
最后 我们会说说

25
00:00:56,866 --> 0:00:58,446
一些在移动性上的改进

26
00:00:58,526 --> 0:00:59,976
我们还将讨论如何彼此协作

27
00:00:59,976 --> 0:01:01,346
以在设备从一个网络转换到另一个时

28
00:00:59,976 --> 0:01:01,346
以在设备从一个网络转换到另一个时

29
00:01:01,346 --> 0:01:03,156
给我们的用户提供

30
00:01:03,156 --> 0:01:05,396
一个更加无缝的体验

31
00:01:07,036 --> 0:01:10,606
在第二部分 我们将涉及到

32
00:01:10,606 --> 0:01:11,476
许多额外的话题

33
00:01:11,526 --> 0:01:12,596
将会在今天的 5 点进行

34
00:01:12,696 --> 0:01:13,736
我希望你们届时能够

35
00:01:13,736 --> 0:01:15,246
回来继续参加

36
00:01:15,936 --> 0:01:17,866
那么在我们进入低数据模式之前

37
00:01:17,866 --> 0:01:19,016
我想要花几分钟

38
00:01:19,016 --> 0:01:20,546
来说说我们平台上

39
00:01:20,546 --> 0:01:22,036
使用的网络 API

40
00:01:23,046 --> 0:01:25,376
在我们的平台上使用的

41
00:01:25,376 --> 0:01:27,226
最好的网络 API 是 URLSession

42
00:01:27,366 --> 0:01:28,226
和 Network.framework

43
00:01:28,696 --> 0:01:29,676
接下来你会在这一场

44
00:01:29,676 --> 0:01:31,526
和这个部分的第二场中听到

45
00:01:31,526 --> 0:01:33,936
我们做了许多很棒的改进

46
00:01:33,936 --> 0:01:34,736
所有这些改进

47
00:01:34,736 --> 0:01:35,966
都可以在你的 App 里获得

48
00:01:36,166 --> 0:01:37,516
如果你正在使用这些框架的话

49
00:01:38,936 --> 0:01:40,636
但如果你使用套接字

50
00:01:40,636 --> 0:01:42,146
那么你将不能利用这个

51
00:01:42,686 --> 0:01:44,106
因为很不巧 套接字并不具备

52
00:01:44,106 --> 0:01:45,266
我们所要求的丰富性

53
00:01:45,266 --> 0:01:46,706
以在该层提供

54
00:01:46,706 --> 0:01:48,076
这个功能

55
00:01:48,076 --> 0:01:49,876
那么 如果你正在做一个

56
00:01:49,876 --> 0:01:52,056
VPN 或者一个内容过滤器

57
00:01:52,386 --> 0:01:53,686
那么 NetworkExtension 框架

58
00:01:53,686 --> 0:01:54,916
是一个很好的解决方案

59
00:01:54,916 --> 0:01:56,146
我们在这方面也做了很多改进

60
00:01:56,146 --> 0:01:57,386
我们将会在明早 9 点

61
00:01:57,386 --> 0:02:01,226
为大家介绍

62
00:01:57,386 --> 0:02:01,226
为大家介绍

63
00:02:01,386 --> 0:02:03,326
现在 我要为大家介绍低数据模式

64
00:02:03,946 --> 0:02:05,486
低数据模式是一个非常棒的

65
00:02:05,486 --> 0:02:07,516
iOS 13 里的新功能

66
00:02:08,876 --> 0:02:10,166
我觉得要介绍低数据模式

67
00:02:10,166 --> 0:02:11,526
最好的方法就是

68
00:02:11,526 --> 0:02:12,736
你可以回想一下

69
00:02:12,736 --> 0:02:14,086
你是怎么来到 WWDC 的

70
00:02:14,086 --> 0:02:17,326
也许你会乘坐飞机

71
00:02:17,386 --> 0:02:20,006
飞到明媚的圣何塞

72
00:02:21,046 --> 0:02:22,646
而在那班飞机上

73
00:02:22,736 --> 0:02:24,786
也许有一个 Wi-Fi 网络

74
00:02:24,786 --> 0:02:26,686
而这个 Wi-Fi 网络

75
00:02:26,796 --> 0:02:28,786
可能有点昂贵

76
00:02:28,786 --> 0:02:30,656
而且可能很拥挤

77
00:02:30,656 --> 0:02:31,706
这时你可能很希望

78
00:02:31,706 --> 0:02:33,646
你能有办法

79
00:02:33,646 --> 0:02:35,036
告诉你的 App

80
00:02:35,036 --> 0:02:37,036
和你设备上的系统

81
00:02:37,036 --> 0:02:38,696
说使用这个网络

82
00:02:38,696 --> 0:02:39,946
真的要在非常节省地

83
00:02:39,946 --> 0:02:42,116
使用网络数据

84
00:02:43,066 --> 0:02:45,776
低数据模式就是用来解决这个问题的

85
00:02:47,226 --> 0:02:48,936
低数据模式给用户一种能力

86
00:02:49,216 --> 0:02:51,176
一种偏好选择

87
00:02:51,176 --> 0:02:52,546
来给你的 App 和系统

88
00:02:52,606 --> 0:02:54,436
发出信号并告诉它们

89
00:02:54,666 --> 0:02:56,556
你真的很想在用这个网络时

90
00:02:56,686 --> 0:02:57,826
十分节省数据

91
00:02:59,256 --> 0:03:01,636
这个可以在每一个

92
00:02:59,256 --> 0:03:01,636
这个可以在每一个

93
00:03:01,636 --> 0:03:03,856
基于 SSID 的 Wi-Fi 网络上

94
00:03:03,926 --> 0:03:05,506
和基于 SIM 的蜂窝移动网络上进行设定

95
00:03:06,876 --> 0:03:09,416
当你的设备处于 

96
00:03:09,416 --> 0:03:10,696
低数据模式网络时

97
00:03:10,736 --> 0:03:11,686
会有两个主要的影响

98
00:03:11,876 --> 0:03:12,986
包括对系统规则的一个更改

99
00:03:12,986 --> 0:03:14,816
以及对采用了 

100
00:03:14,816 --> 0:03:16,976
低数据模式的 App 的一个更改

101
00:03:17,536 --> 0:03:19,866
在系统规则方面

102
00:03:19,866 --> 0:03:21,206
当我们打开低数据模式网络时 

103
00:03:21,206 --> 0:03:22,796
我们会推迟所有的

104
00:03:22,796 --> 0:03:24,016
后台自主型任务

105
00:03:24,806 --> 0:03:26,016
因此 如果你在飞机上

106
00:03:26,016 --> 0:03:27,166
打开了低数据模式

107
00:03:27,166 --> 0:03:28,986
我们会推迟所有的

108
00:03:29,016 --> 0:03:30,336
后台自主任务

109
00:03:30,946 --> 0:03:31,616
当你下了飞机

110
00:03:31,616 --> 0:03:32,766
入住酒店之后

111
00:03:32,806 --> 0:03:34,606
然后连上了酒店的 Wi-Fi 网络

112
00:03:34,606 --> 0:03:35,986
那儿的网络可能不是那么拥挤 

113
00:03:35,986 --> 0:03:37,386
也更加便宜

114
00:03:37,386 --> 0:03:39,316
然后我们会将所有这些后台任务

115
00:03:39,316 --> 0:03:43,026
重新开始并继续进行下去

116
00:03:43,616 --> 0:03:44,976
我们所做的另一个更改是

117
00:03:45,126 --> 0:03:46,776
禁用后台 App 刷新

118
00:03:47,166 --> 0:03:48,686
这帮助我们避免了

119
00:03:48,686 --> 0:03:49,656
后台的 App 占用网络数据

120
00:03:49,656 --> 0:03:51,386
而这些后台 App

121
00:03:51,386 --> 0:03:52,266
和用户真正感兴趣的

122
00:03:52,266 --> 0:03:54,856
可能一点关系都没有

123
00:03:55,676 --> 0:03:56,786
这样我们已经节省了很多数据

124
00:03:56,786 --> 0:03:58,236
但我们认为如果你在

125
00:03:58,236 --> 0:03:59,566
你的 App 中采用

126
00:03:59,566 --> 0:04:00,486
低数据模式

127
00:03:59,566 --> 0:04:00,486
低数据模式

128
00:04:00,486 --> 0:04:01,266
那么它所带来的改变

129
00:04:01,266 --> 0:04:03,276
还能节省更多的数据

130
00:04:04,166 --> 0:04:05,196
因此 我想花一些时间

131
00:04:05,196 --> 0:04:07,016
来谈谈你可以使用的技术

132
00:04:07,576 --> 0:04:10,126
首先我们要看看

133
00:04:10,126 --> 0:04:11,746
你的 App 是怎样

134
00:04:11,746 --> 0:04:12,906
使用网络数据的

135
00:04:13,816 --> 0:04:15,856
当你开始深入了解时

136
00:04:15,916 --> 0:04:17,266
一定要时刻记住

137
00:04:18,106 --> 0:04:20,766
你可以节省数据

138
00:04:20,815 --> 0:04:22,256
但不要影响你的用户体验

139
00:04:22,256 --> 0:04:24,636
务必要做到这一点

140
00:04:25,636 --> 0:04:26,496
我知道虽然这看上去很明显

141
00:04:26,496 --> 0:04:27,356
但你也许会惊讶于

142
00:04:27,416 --> 0:04:28,406
能减少你正在使用的

143
00:04:28,406 --> 0:04:29,796
网络数据的数量

144
00:04:30,126 --> 0:04:34,026
的优化方式

145
00:04:35,366 --> 0:04:36,666
好 一旦你达成了

146
00:04:36,666 --> 0:04:38,276
这些容易实现的目标

147
00:04:38,276 --> 0:04:39,356
即可以在节省数据的同时

148
00:04:39,356 --> 0:04:40,536
保证用户体验不受影响

149
00:04:40,656 --> 0:04:41,766
那么你就必须要开始

150
00:04:41,766 --> 0:04:43,246
做出一些权衡的决定

151
00:04:44,506 --> 0:04:46,226
在很多情况下

152
00:04:46,226 --> 0:04:48,116
你有机会使用更多的数据

153
00:04:48,116 --> 0:04:49,396
这给你带来很好的体验

154
00:04:49,396 --> 0:04:51,206
而使用更少的数据

155
00:04:51,206 --> 0:04:52,906
仍然能给你一个很好的体验

156
00:04:52,986 --> 0:04:54,846
但也有可能会让你的用户体验打折扣

157
00:04:55,406 --> 0:04:57,266
低数据模式就是一种方法

158
00:04:57,266 --> 0:04:58,566
让用户来向你的 App 发送信号

159
00:04:58,566 --> 0:05:01,876
说明你真的想要节省该数据

160
00:04:58,566 --> 0:05:01,876
说明你真的想要节省该数据

161
00:05:01,876 --> 0:05:03,596
然后在选择该选项的同时

162
00:05:03,596 --> 0:05:04,806
要保证一个好的用户体验

163
00:05:05,146 --> 0:05:08,076
但也许没有那么好

164
00:05:08,356 --> 0:05:09,156
那么 我们来说说你一些

165
00:05:09,156 --> 0:05:10,116
你能用到的技术

166
00:05:10,556 --> 0:05:12,956
第一个是减少图片质量

167
00:05:13,386 --> 0:05:15,856
如果你的 App 里并不以图片为主

168
00:05:15,856 --> 0:05:17,546
那么通过降低图片质量

169
00:05:17,546 --> 0:05:18,866
你可以节省大量数据

170
00:05:18,866 --> 0:05:20,396
你仍然可以让用户

171
00:05:20,396 --> 0:05:21,716
做他们想要做的事

172
00:05:21,716 --> 0:05:24,676
但在此过程中节省数据

173
00:05:26,256 --> 0:05:28,296
你可以减少预载入

174
00:05:28,526 --> 0:05:29,986
预载入是一个很棒的技术

175
00:05:30,116 --> 0:05:31,766
能够提高性能

176
00:05:31,766 --> 0:05:33,026
但它也有个缺点

177
00:05:33,026 --> 0:05:34,436
即有时你所预载的资源

178
00:05:34,436 --> 0:05:36,046
是用户从来不需要的

179
00:05:36,236 --> 0:05:37,406
同时 如果他们真的在意

180
00:05:37,406 --> 0:05:38,636
自己使用了多少

181
00:05:38,636 --> 0:05:39,736
网络数据的话 

182
00:05:39,986 --> 0:05:41,746
预载入确实是会增加数据使用量

183
00:05:43,056 --> 0:05:44,656
那么 当你在低数据模式时

184
00:05:44,656 --> 0:05:46,206
你可以使用

185
00:05:46,206 --> 0:05:47,606
你可以消除预载入

186
00:05:47,606 --> 0:05:48,336
这样就能节省数据

187
00:05:48,336 --> 0:05:49,526
而如果用户将该内容

188
00:05:49,526 --> 0:05:50,646
滚到视图中等待它加载

189
00:05:50,646 --> 0:05:54,126
那他们则必须等得久一点

190
00:05:54,746 --> 0:05:56,036
你可以少进行同步

191
00:05:56,206 --> 0:05:57,266
数据将会延迟

192
00:05:57,266 --> 0:05:58,496
稍微长一点

193
00:05:58,496 --> 0:05:59,206
但你仍然会有数据

194
00:05:59,366 --> 0:06:00,576
用户仍然可以完成

195
00:05:59,366 --> 0:06:00,576
用户仍然可以完成

196
00:06:00,576 --> 0:06:04,366
他们打算去做的事

197
00:06:04,366 --> 0:06:05,636
但是在一长段时间内

198
00:06:05,636 --> 0:06:06,816
你其实可以节省相当多的数据

199
00:06:06,876 --> 0:06:09,886
通过降低同步的频率

200
00:06:10,536 --> 0:06:14,436
你可以标记后台任务

201
00:06:14,436 --> 0:06:15,306
为自主型任务

202
00:06:15,896 --> 0:06:16,916
你会感到惊讶

203
00:06:16,916 --> 0:06:18,076
有多少你设置的后台任务

204
00:06:18,076 --> 0:06:20,876
并不是真的需要立即完成

205
00:06:21,936 --> 0:06:23,216
标记一个后台任务

206
00:06:23,216 --> 0:06:25,176
为自主型任务

207
00:06:25,176 --> 0:06:26,756
这使得系统在实际的

208
00:06:26,756 --> 0:06:28,586
调度操作时具有很大的灵活性

209
00:06:28,716 --> 0:06:30,696
正如我之前提到过的

210
00:06:30,926 --> 0:06:32,246
当你坐在飞机上

211
00:06:32,246 --> 0:06:33,886
系统就有机会

212
00:06:33,886 --> 0:06:35,156
推迟那个任务

213
00:06:35,156 --> 0:06:36,566
直到我们连上一个

214
00:06:36,566 --> 0:06:39,066
非低数据模式网络

215
00:06:39,536 --> 0:06:41,796
另一个很棒的解决方案是禁用自动播放

216
00:06:42,686 --> 0:06:44,076
这样做真的很棒

217
00:06:44,076 --> 0:06:45,326
因为它不会妨碍用户

218
00:06:45,446 --> 0:06:46,466
播放他们感兴趣的内容

219
00:06:46,466 --> 0:06:48,046
但是它意味着用户

220
00:06:48,046 --> 0:06:49,226
不需要为他们

221
00:06:49,226 --> 0:06:50,836
根本不感兴趣的内容花费数据

222
00:06:51,726 --> 0:06:54,356
这就引出了另一个

223
00:06:54,356 --> 0:06:55,836
非常重要的问题

224
00:06:55,836 --> 0:06:56,646
当你选择如何实现

225
00:06:56,646 --> 0:06:57,676
低数据模式时

226
00:06:58,106 --> 0:06:59,236
你不能够阻碍

227
00:06:59,236 --> 0:07:00,286
用户发起的活动

228
00:06:59,236 --> 0:07:00,286
用户发起的活动

229
00:07:00,796 --> 0:07:02,346
低数据模式就是

230
00:07:02,986 --> 0:07:04,486
告诉系统来减少

231
00:07:04,486 --> 0:07:05,446
所使用的网络数量

232
00:07:05,446 --> 0:07:07,326
但是要确保

233
00:07:07,326 --> 0:07:08,886
用户仍然可以完成

234
00:07:08,886 --> 0:07:09,846
他们打算要做的

235
00:07:10,926 --> 0:07:11,916
当你查看你的 App 时

236
00:07:11,916 --> 0:07:13,286
你可能意识到

237
00:07:13,286 --> 0:07:14,316
你所进行的一些操作

238
00:07:14,316 --> 0:07:16,206
的确使用了很多网络数据

239
00:07:16,206 --> 0:07:17,906
而你对此无能为力

240
00:07:18,936 --> 0:07:20,646
虽然我们想用任何可能的方式 

241
00:07:20,646 --> 0:07:21,686
来减少用于这些操作的

242
00:07:21,686 --> 0:07:22,926
网络数据的使用量

243
00:07:22,926 --> 0:07:25,166
但是我们并不想

244
00:07:25,166 --> 0:07:26,876
突然弹出一个对话框

245
00:07:26,926 --> 0:07:28,176
来问你确定要这么做吗

246
00:07:28,336 --> 0:07:29,586
我看到你在使用网络数据

247
00:07:29,586 --> 0:07:31,106
而这将会花费很多数据

248
00:07:31,256 --> 0:07:32,476
不要质疑用户

249
00:07:32,586 --> 0:07:33,696
他们已经打开了低数据模式

250
00:07:34,666 --> 0:07:35,436
同时已经要求你的 App 

251
00:07:35,436 --> 0:07:37,226
来执行该操作了

252
00:07:37,266 --> 0:07:40,236
那就直接照做吧

253
00:07:40,316 --> 0:07:41,596
那么 我们来再说说

254
00:07:41,596 --> 0:07:43,346
支持你的 App 执行

255
00:07:43,346 --> 0:07:45,766
低数据模式的 API

256
00:07:47,266 --> 0:07:49,546
我们已经为 URLSession

257
00:07:49,546 --> 0:07:50,936
和 Network.framework 增加了 API

258
00:07:51,746 --> 0:07:54,966
我们要记住的是

259
00:07:54,966 --> 0:07:55,896
当一个网络处于

260
00:07:55,896 --> 0:07:57,676
低数据模式时

261
00:07:57,676 --> 0:07:59,756
该数据网络上则会设置约束属性

262
00:08:00,876 --> 0:08:02,596
那么 下面就是我们提供的

263
00:08:02,596 --> 0:08:04,756
所有基于该约束属性的 API 

264
00:08:05,156 --> 0:08:07,016
在 URLSession 中我们

265
00:08:07,016 --> 0:08:07,906
添加了一个属性

266
00:08:07,906 --> 0:08:09,546
allowsConstrainedNetworkAccess

267
00:08:10,326 --> 0:08:11,706
在默认情况下 此属性设置为真

268
00:08:12,096 --> 0:08:13,246
你的 App 就可以在默认情况下

269
00:08:13,246 --> 0:08:14,886
使用低数据模式网络

270
00:08:15,506 --> 0:08:17,236
然后可以将其设置为假来退出

271
00:08:17,236 --> 0:08:18,936
你可以将其设置

272
00:08:18,936 --> 0:08:20,576
在 URLSession 请求上

273
00:08:20,576 --> 0:08:22,026
和 URLSession 配置上

274
00:08:23,036 --> 0:08:25,006
在 URLSession 中 我们真的

275
00:08:25,006 --> 0:08:26,536
鼓励你继续尝试

276
00:08:26,536 --> 0:08:28,796
大型资源获取

277
00:08:28,796 --> 0:08:29,926
或者预取并设置

278
00:08:29,926 --> 0:08:31,816
allowsConstrainedNetworkAccess 为假

279
00:08:32,635 --> 0:08:33,936
如果操作出现错误

280
00:08:33,936 --> 0:08:35,876
且该错误有一个网络不可用的

281
00:08:35,876 --> 0:08:37,486
原因限制 那就意味着

282
00:08:37,486 --> 0:08:38,876
该操作的失败

283
00:08:38,926 --> 0:08:40,076
是因为你正处于低数据模式

284
00:08:40,076 --> 0:08:41,756
而此时你要做的事应该是

285
00:08:41,926 --> 0:08:43,436
返回并执行

286
00:08:43,436 --> 0:08:44,776
低数据模式操作

287
00:08:44,776 --> 0:08:46,576
如果是一个大型资源获取的情况

288
00:08:46,696 --> 0:08:48,016
它可能就反而获取一个

289
00:08:48,016 --> 0:08:49,206
更小的资源

290
00:08:49,206 --> 0:08:51,026
而在预取的例子中

291
00:08:51,026 --> 0:08:52,836
只要等到用户真正需要该内容

292
00:08:53,916 --> 0:08:55,936
这样做的另一个好处是

293
00:08:55,936 --> 0:08:56,856
你可以利用缓存中

294
00:08:56,856 --> 0:08:58,946
可能已经存在的任何内容

295
00:08:59,876 --> 0:09:01,366
那么在 Network.framework 中

296
00:08:59,876 --> 0:09:01,366
那么在 Network.framework 中

297
00:09:01,366 --> 0:09:02,446
有一个相似的属性

298
00:09:02,446 --> 0:09:03,646
叫做 prohibitConstrainedPaths

299
00:09:04,136 --> 0:09:05,396
你可以设置其为真

300
00:09:05,396 --> 0:09:06,666
来限制你的连接

301
00:09:06,666 --> 0:09:08,526
及其他网络对象

302
00:09:08,526 --> 0:09:09,556
使用低数据模式

303
00:09:10,796 --> 0:09:12,276
不过在 Network.framework 里

304
00:09:12,276 --> 0:09:13,056
你还有另一个选择

305
00:09:13,376 --> 0:09:14,216
如果你要连接相同的主机

306
00:09:14,216 --> 0:09:15,566
无论你是否处于低数据模式

307
00:09:15,566 --> 0:09:17,046
你都可以继续

308
00:09:17,046 --> 0:09:18,426
并建立该连接

309
00:09:18,776 --> 0:09:19,736
一旦连接建立起来

310
00:09:19,736 --> 0:09:21,196
你可以获得当前的路径

311
00:09:21,196 --> 0:09:23,016
而在当前路径上

312
00:09:23,016 --> 0:09:25,516
你可以查看它是否受到限制

313
00:09:25,516 --> 0:09:26,396
这会告诉你这个连接

314
00:09:26,426 --> 0:09:28,056
是否建立在一个

315
00:09:28,056 --> 0:09:29,046
低数据模式网络下

316
00:09:30,296 --> 0:09:32,216
好 如果你照此方法做

317
00:09:32,216 --> 0:09:33,356
一定要确保

318
00:09:33,356 --> 0:09:34,526
你处理了路径的更新

319
00:09:35,876 --> 0:09:36,896
因为很有可能

320
00:09:36,896 --> 0:09:38,346
限制属性会改变

321
00:09:38,376 --> 0:09:40,616
你的连接的使用寿命

322
00:09:43,176 --> 0:09:44,106
那么 我花了很多时间

323
00:09:44,106 --> 0:09:45,126
讨论了限制属性

324
00:09:45,126 --> 0:09:46,406
和低数据模式

325
00:09:47,066 --> 0:09:48,236
还有一些其他的属性

326
00:09:48,236 --> 0:09:49,876
你的 App 可以用它们

327
00:09:49,876 --> 0:09:51,306
来在给定的网络上

328
00:09:51,586 --> 0:09:52,336
判断该做什么

329
00:09:53,376 --> 0:09:54,946
还有一个昂贵属性

330
00:09:55,016 --> 0:09:56,936
我们去年在 Network.framework 中引入了它

331
00:09:56,936 --> 0:09:58,656
今年我们将在 URLSession 中引入

332
00:09:58,656 --> 0:10:02,386
allowsExpensiveNetworkAccess 属性

333
00:09:58,656 --> 0:10:02,386
allowsExpensiveNetworkAccess 属性

334
00:10:03,656 --> 0:10:06,056
也有特定接口类型的检查

335
00:10:06,056 --> 0:10:08,526
比如蜂窝移动网络或 Wi-Fi

336
00:10:09,896 --> 0:10:11,006
如果你还没有

337
00:10:11,006 --> 0:10:12,226
采用其中任何一个

338
00:10:12,226 --> 0:10:13,606
你可以将重点放在

339
00:10:13,606 --> 0:10:14,886
采用低数据模式上

340
00:10:14,886 --> 0:10:16,046
这绝对是一条正确的路

341
00:10:16,846 --> 0:10:18,006
低数据模式

342
00:10:18,006 --> 0:10:19,196
与限制属性相互关联

343
00:10:19,236 --> 0:10:22,646
因而用户拥有控制权

344
00:10:22,776 --> 0:10:25,466
他们有自己控制的设定

345
00:10:25,466 --> 0:10:26,766
另一方面 昂贵属性

346
00:10:26,766 --> 0:10:27,976
是一个系统设置的属性

347
00:10:27,976 --> 0:10:29,946
它几乎总是为

348
00:10:29,996 --> 0:10:31,386
蜂窝移动网络而设置

349
00:10:31,386 --> 0:10:32,976
它同时也为 Wi-Fi 网络设置

350
00:10:33,016 --> 0:10:35,196
当该网络连接到个人热点时

351
00:10:36,316 --> 0:10:37,946
你也可以检查蜂窝移动网络

352
00:10:38,286 --> 0:10:39,536
但那也是用户

353
00:10:39,536 --> 0:10:40,916
无法控制的事

354
00:10:41,896 --> 0:10:42,766
所以 如果你正在进行

355
00:10:42,766 --> 0:10:44,086
基于蜂窝移动网络接口

356
00:10:44,146 --> 0:10:45,386
或昂贵属性的检查

357
00:10:45,436 --> 0:10:47,116
这个时候转去

358
00:10:47,116 --> 0:10:49,406
使用限制属性

359
00:10:49,406 --> 0:10:51,166
来利用低数据模式

360
00:10:51,166 --> 0:10:52,226
是非常好的想法

361
00:10:52,886 --> 0:10:54,606
如果你已经着眼于这些选项

362
00:10:54,606 --> 0:10:55,896
并决定了你仍然想要

363
00:10:55,896 --> 0:10:57,166
基于昂贵属性

364
00:10:57,166 --> 0:10:59,626
或蜂窝移动网络来做决定

365
00:10:59,626 --> 0:11:02,566
我们强烈建议你使用昂贵属性

366
00:10:59,626 --> 0:11:02,566
我们强烈建议你使用昂贵属性

367
00:11:03,746 --> 0:11:05,336
昂贵属性更为灵活

368
00:11:05,336 --> 0:11:07,196
在许多方面 它都能够

369
00:11:07,196 --> 0:11:09,026
有效地保证你的 App 不过时  

370
00:11:09,676 --> 0:11:11,186
现在 蜂窝移动网络几乎

371
00:11:11,186 --> 0:11:12,046
总是被标记为昂贵的

372
00:11:12,046 --> 0:11:13,426
但是在未来也许不会

373
00:11:13,426 --> 0:11:16,106
也许还会有其他的接口类型

374
00:11:16,106 --> 0:11:17,956
它们也可能很昂贵

375
00:11:18,456 --> 0:11:19,846
通过使用昂贵属性

376
00:11:19,956 --> 0:11:21,236
你的 App 会在将来

377
00:11:21,236 --> 0:11:23,346
用不同的接口来保证正常运行

378
00:11:23,996 --> 0:11:24,686
如果你正在检查

379
00:11:24,686 --> 0:11:25,726
一个特定的接口

380
00:11:25,726 --> 0:11:27,326
比如蜂窝移动网络

381
00:11:27,326 --> 0:11:29,316
那么你就不能够利用它

382
00:11:29,916 --> 0:11:31,116
我真的很期待看到

383
00:11:31,116 --> 0:11:32,816
你们都真的采用了低数据模式

384
00:11:33,146 --> 0:11:34,216
非常感谢大家的聆听

385
00:11:34,456 --> 0:11:36,936
下面 我想要请 Guoye 上台来跟大家谈谈

386
00:11:36,936 --> 0:11:38,566
URLSession 中的 Combine

387
00:11:39,516 --> 0:11:42,636
[掌声]

388
00:11:43,136 --> 0:11:45,916
&gt;&gt; 谢谢 Josh 早上好

389
00:11:46,206 --> 0:11:48,346
我是 Guoye Zhang

390
00:11:48,696 --> 0:11:50,616
今天很高兴与那么分享

391
00:11:50,886 --> 0:11:52,366
我们是如何支持一个

392
00:11:52,366 --> 0:11:54,026
新的 Swift 框架的

393
00:11:54,026 --> 0:11:56,466
也就是 URLSession 里的 Combine

394
00:11:56,466 --> 0:11:57,866
以及你如何利用 Combine 来简化

395
00:11:57,866 --> 0:11:59,386
你的网络代码

396
00:12:00,976 --> 0:12:05,486
Combine 将装饰异步编程带进 Swift 中

397
00:12:06,446 --> 0:12:09,486
要给大家解释这是什么

398
00:12:09,586 --> 0:12:11,266
我就要从一个构建一个

399
00:12:11,266 --> 0:12:13,156
响应式检索栏的例子开始

400
00:12:13,786 --> 0:12:16,826
因此 无论何时用户

401
00:12:16,826 --> 0:12:19,676
在这里键入和接收订阅

402
00:12:19,676 --> 0:12:21,446
同时接收 URL 以启动搜索

403
00:12:21,446 --> 0:12:24,006
搜索栏都会发布值

404
00:12:24,556 --> 0:12:27,326
在这中间 我们用

405
00:12:27,326 --> 0:12:30,626
映射操作符来为 URL 映射值

406
00:12:33,526 --> 0:12:35,496
那么 假设我只想

407
00:12:35,496 --> 0:12:37,306
在有足够内容的时候

408
00:12:37,346 --> 0:12:38,316
启动一个搜索

409
00:12:38,916 --> 0:12:42,406
我们可以使用过滤器

410
00:12:43,896 --> 0:12:45,566
在这种情况下 过滤器会

411
00:12:45,946 --> 0:12:48,916
删除所有小于三个字符的字符串

412
00:12:52,406 --> 0:12:54,926
现在我们已经消除了

413
00:12:54,926 --> 0:12:57,056
用户类似于一个 H 这样的查询

414
00:12:57,896 --> 0:13:01,526
但是 该搜索仍然时常发生

415
00:12:57,896 --> 0:13:01,526
但是 该搜索仍然时常发生

416
00:13:02,286 --> 0:13:04,526
如果我只想在用户

417
00:13:04,806 --> 0:13:06,756
暂时停止输入时进行搜索呢

418
00:13:07,396 --> 0:13:11,426
我们可以用去 debounce() 操作符

419
00:13:12,516 --> 0:13:17,776
[掌声]

420
00:13:18,276 --> 0:13:20,576
这样 去抖动就延迟了该值

421
00:13:20,896 --> 0:13:22,566
并且只在有显著延迟时转发它

422
00:13:22,566 --> 0:13:26,486
在这个例子中是 0.2 秒

423
00:13:30,316 --> 0:13:33,296
然而 使用去抖动

424
00:13:33,296 --> 0:13:35,186
如果用户键入了一些东西

425
00:13:35,646 --> 0:13:37,176
然后删除掉了 我们最终可能

426
00:13:37,176 --> 0:13:38,766
会在该链上发送相同的值

427
00:13:38,766 --> 0:13:40,806
然后一次又一次地开始

428
00:13:40,806 --> 0:13:43,136
相同的搜索

429
00:13:43,356 --> 0:13:45,786
为了解决这个问题

430
00:13:45,786 --> 0:13:47,416
我们可以添加 removeDuplicates() 操作符

431
00:13:49,036 --> 0:13:51,836
removeDuplicates 会记住

432
00:13:51,836 --> 0:13:54,346
接收到的最后的值

433
00:13:54,346 --> 0:13:56,526
然后当它发生改变的时候只转发一个新的值

434
00:14:01,356 --> 0:14:03,526
现在 我们有了最后的

435
00:14:03,526 --> 0:14:05,596
检索栏的版本

436
00:14:05,596 --> 0:14:07,696
通过更改这些操作符

437
00:14:07,696 --> 0:14:10,656
你的异步代码就会变成线性且可组合的代码了

438
00:14:16,116 --> 0:14:20,196
Combine 会处理一段时间内的值

439
00:14:21,336 --> 0:14:23,866
它由发布器 操作符

440
00:14:24,146 --> 0:14:26,216
和订阅器组成

441
00:14:27,596 --> 0:14:30,166
这个链是由订阅器

442
00:14:30,166 --> 0:14:32,526
所发送的需求驱动的

443
00:14:34,236 --> 0:14:36,136
为了对需求做出响应

444
00:14:36,676 --> 0:14:38,536
发布器向该链发送值

445
00:14:39,486 --> 0:14:41,436
这就是 Combine

446
00:14:41,436 --> 0:14:42,476
处理压力的方法

447
00:14:43,116 --> 0:14:46,376
如果你想要学习更多

448
00:14:47,306 --> 0:14:48,866
近期会有一个会议叫做

449
00:14:48,866 --> 0:14:50,596
介绍 Foundation 中的 Combine 和 Advances

450
00:14:51,076 --> 0:14:52,536
同时我还建议你去参加

451
00:14:52,796 --> 0:14:58,276
周四下午的 Combine 实践会议

452
00:14:58,436 --> 0:15:00,326
网络在本质上是异步的

453
00:14:58,436 --> 0:15:00,326
网络在本质上是异步的

454
00:15:00,326 --> 0:15:02,006
这就是它为什么

455
00:15:02,006 --> 0:15:03,356
很适合采用 Combine

456
00:15:05,396 --> 0:15:07,706
今年 我们在 URLSession 中

457
00:15:07,706 --> 0:15:10,206
引入 DataTaskPublisher

458
00:15:10,876 --> 0:15:13,076
它是一个单一的值发布器

459
00:15:13,616 --> 0:15:14,936
它的工作原理类似于

460
00:15:14,996 --> 0:15:18,946
我们现有的基于闭包的便利方法

461
00:15:18,946 --> 0:15:20,736
这意味着你可以从一个共享的

462
00:15:20,736 --> 0:15:23,016
URLSession  或从你自己的

463
00:15:23,016 --> 0:15:24,706
URLSession 中创造它

464
00:15:24,706 --> 0:15:26,386
同时接收你的委托上的

465
00:15:26,386 --> 0:15:27,986
身份验证挑战和软件度量

466
00:15:28,576 --> 0:15:32,556
这是 DataTaskPublisher 的界面

467
00:15:33,116 --> 0:15:37,006
它遵循发布器协议

468
00:15:37,806 --> 0:15:39,926
一旦成功 它会向你发送一个

469
00:15:39,926 --> 0:15:41,906
真正的数据池和响应

470
00:15:42,196 --> 0:15:44,976
如果失败它会发送给你一个 URLError

471
00:15:48,416 --> 0:15:50,206
现在 让我给你演示一下

472
00:15:50,206 --> 0:15:51,976
Combine 在 URLSession 中是如何工作的

473
00:15:59,006 --> 0:16:00,186
那么 为了做这个演示

474
00:15:59,006 --> 0:16:00,186
那么 为了做这个演示

475
00:16:00,186 --> 0:16:02,766
我已经禁用了 URL 缓存

476
00:16:02,966 --> 0:16:04,536
所以所有的资源都要

477
00:16:04,536 --> 0:16:05,456
通过网络获取

478
00:16:06,296 --> 0:16:08,126
我也已经使用网络连接调节器

479
00:16:08,226 --> 0:16:10,976
来模拟一个真实的 3G 环境

480
00:16:16,426 --> 0:16:18,396
因此 我正在为一个

481
00:16:18,396 --> 0:16:19,286
叫 PubSocket 的酒吧构建一个 App

482
00:16:20,636 --> 0:16:23,536
这个 App 在栏中显示了

483
00:16:23,536 --> 0:16:25,956
每个项目的名字 图像和项目价格

484
00:16:27,956 --> 0:16:29,676
那么 在听完 Josh 讲的低数据模式后

485
00:16:29,676 --> 0:16:32,626
我决定为低数据模式提供

486
00:16:32,626 --> 0:16:34,346
一个高分辨率的图像

487
00:16:34,346 --> 0:16:37,756
和一个低分辨率的图像

488
00:16:37,976 --> 0:16:39,336
现在我正处于低数据模式

489
00:16:39,336 --> 0:16:40,976
那你可以看这些黑白的图像

490
00:16:43,686 --> 0:16:45,296
而如果我关掉低数据模式

491
00:16:49,036 --> 0:16:50,676
这些图片就会被换成

492
00:16:50,676 --> 0:16:51,976
高分辨率的图片

493
00:16:55,416 --> 0:16:56,896
让我们来看看没有 Combine

494
00:16:56,896 --> 0:16:57,946
现在这个是怎么完成的

495
00:17:04,876 --> 0:17:06,516
那么该界面是

496
00:17:06,516 --> 0:17:09,396
在 UITableView 中构建的

497
00:17:09,396 --> 0:17:11,516
这里我们有数据资源方法

498
00:17:11,516 --> 0:17:12,236
cellForRowAt indexPath

499
00:17:13,156 --> 0:17:15,675
在这个方法中 我们取回

500
00:17:15,675 --> 0:17:18,266
一个可重用单元格

501
00:17:18,266 --> 0:17:20,366
并配置单元格上的每个项目的名称和价格

502
00:17:21,596 --> 0:17:25,626
然后我们开始一个 URLRequest

503
00:17:25,626 --> 0:17:27,386
来提取高分辨率的图像

504
00:17:27,516 --> 0:17:29,816
同时禁止限制网络访问

505
00:17:31,116 --> 0:17:33,196
这里的 pubSession 是

506
00:17:33,196 --> 0:17:35,066
共享全球会话

507
00:17:35,066 --> 0:17:37,496
我们在《PubSocket》App 中使用它

508
00:17:37,496 --> 0:17:40,226
同时用它从请求中创建数据任务

509
00:17:44,376 --> 0:17:46,826
当任务结束时

510
00:17:46,826 --> 0:17:48,546
我们查看状态码是否是 200

511
00:17:48,546 --> 0:17:50,796
好 我们将数据转换为图片

512
00:17:50,796 --> 0:17:52,946
然后将图片放进单元格中

513
00:17:59,496 --> 0:18:01,446
当任务因为低数据模式而失败时

514
00:17:59,496 --> 0:18:01,446
当任务因为低数据模式而失败时

515
00:18:01,446 --> 0:18:04,256
我们创建一个新的数据任务

516
00:18:04,556 --> 0:18:05,976
来提取低分辨率的图片

517
00:18:09,556 --> 0:18:10,776
我们在这里做同样的事

518
00:18:10,776 --> 0:18:13,406
我们检查状态码

519
00:18:13,406 --> 0:18:14,976
转换成图片 然后将它放入单元格

520
00:18:17,576 --> 0:18:18,916
不要忘记重新开始这些任务

521
00:18:23,696 --> 0:18:26,056
那么 作为一个网络工程师

522
00:18:26,056 --> 0:18:28,176
我知道这里的网络逻辑是可靠的

523
00:18:29,216 --> 0:18:30,556
我坚持用最好的方法

524
00:18:30,556 --> 0:18:32,566
以不进行任何预取操作

525
00:18:33,236 --> 0:18:36,046
但是 我对现在的代码

526
00:18:36,046 --> 0:18:38,196
还不是很满意

527
00:18:38,196 --> 0:18:39,566
因为它有很多的重复

528
00:18:40,476 --> 0:18:42,236
我们要两次查看状态码

529
00:18:42,236 --> 0:18:46,796
然后转换图片

530
00:18:46,966 --> 0:18:48,796
同时 你也许注意到了

531
00:18:49,056 --> 0:18:50,286
我犯了最常见的错误

532
00:18:50,286 --> 0:18:52,436
即采集单元格

533
00:18:52,436 --> 0:18:53,676
然后异步地将图像

534
00:18:53,676 --> 0:18:54,976
放入单元格中

535
00:18:57,126 --> 0:18:58,596
该单元格此时可能已经

536
00:18:58,596 --> 0:19:00,516
被 UIKit 重新使用了

537
00:18:58,596 --> 0:19:00,516
被 UIKit 重新使用了

538
00:19:02,446 --> 0:19:04,256
那么 接下来为大家展示这个 Bug

539
00:19:04,256 --> 0:19:07,426
我会很快速地向下滚动

540
00:19:07,426 --> 0:19:10,236
请注意菜单上的最后一些项目

541
00:19:10,796 --> 0:19:13,546
正如你看到的 

542
00:19:13,546 --> 0:19:15,476
热狗和鸡腿的图片给放错了

543
00:19:19,086 --> 0:19:20,526
让我再来演示一遍

544
00:19:20,526 --> 0:19:21,986
我会滚动到顶端

545
00:19:21,986 --> 0:19:24,356
然后注意前几个项目

546
00:19:27,436 --> 0:19:28,686
对 沙士和炸薯条

547
00:19:28,686 --> 0:19:30,396
摆放的图像也是错误的

548
00:19:30,396 --> 0:19:31,976
在它们被正确的图像替换之前

549
00:19:37,506 --> 0:19:38,886
好 我们来看看如何使用

550
00:19:38,886 --> 0:19:40,746
Combine 来解决所有这些问题

551
00:19:42,676 --> 0:19:44,976
首先 我要删除这个用来提取的代码

552
00:19:49,666 --> 0:19:50,446
这里我们用

553
00:19:50,446 --> 0:19:52,746
MenuItemTableViewCell 类

554
00:19:53,146 --> 0:19:55,816
那么 单元格接收到一个图像

555
00:19:55,816 --> 0:19:57,106
单元格是很适合放

556
00:19:57,106 --> 0:19:58,866
订阅器的地方

557
00:20:00,076 --> 0:20:02,186
这里的订阅器适合

558
00:20:02,186 --> 0:20:03,526
任何可取消的协议

559
00:20:04,796 --> 0:20:07,096
我们可以取消该订阅器

560
00:20:08,676 --> 0:20:10,486
准备使用重用方法

561
00:20:11,036 --> 0:20:12,326
取消会立即发生

562
00:20:12,326 --> 0:20:13,886
这意味着我们将不会

563
00:20:13,886 --> 0:20:15,586
有机会将任何图像

564
00:20:15,586 --> 0:20:17,106
放置在错误的单元格上

565
00:20:18,996 --> 0:20:20,556
现在我们回到

566
00:20:20,556 --> 0:20:22,196
TableView 数据资源方法

567
00:20:22,196 --> 0:20:23,776
和 cellForRowAt indexPath

568
00:20:26,256 --> 0:20:28,046
我们首先要做同一件事情

569
00:20:28,046 --> 0:20:30,216
即创建一个 URL 请求

570
00:20:30,386 --> 0:20:31,916
然后提取高分辨率的图像

571
00:20:32,156 --> 0:20:34,116
并禁用限制网络访问

572
00:20:34,926 --> 0:20:36,876
但是我们不创建数据任务

573
00:20:36,876 --> 0:20:39,446
而是一个请求的数据任务发布器

574
00:20:44,156 --> 0:20:46,536
然后我们在 Combine 中使用

575
00:20:46,536 --> 0:20:47,766
新的 tryCatch 操作符

576
00:20:48,336 --> 0:20:50,446
这个 tryCatch 操作符

577
00:20:50,446 --> 0:20:51,466
会捕捉 DataTaskPublisher

578
00:20:51,466 --> 0:20:53,856
所产生的错误

579
00:20:53,856 --> 0:20:55,506
如果该任务因为低数据模式

580
00:20:55,506 --> 0:20:57,856
而失败 我们就用新的发布器

581
00:20:57,856 --> 0:20:59,236
来更换该发布器

582
00:20:59,236 --> 0:21:01,146
以提取低分辨率的图像

583
00:20:59,236 --> 0:21:01,146
以提取低分辨率的图像

584
00:21:02,776 --> 0:21:04,486
否则 我们只是将一样的错误

585
00:21:04,486 --> 0:21:05,686
重新抛给了该链条

586
00:21:10,336 --> 0:21:13,226
接下来我们用 tryMap 操作符

587
00:21:13,416 --> 0:21:15,036
来处理我们接收该数据

588
00:21:15,036 --> 0:21:16,956
和该响应的成功案例

589
00:21:17,406 --> 0:21:18,986
我们查看了状态码

590
00:21:18,986 --> 0:21:20,566
然后从该数据中创建一个图像

591
00:21:21,876 --> 0:21:23,606
而此图可以同时处理

592
00:21:23,936 --> 0:21:25,286
高分辨率图像

593
00:21:25,286 --> 0:21:26,446
和低分辨率图像

594
00:21:26,856 --> 0:21:28,646
这样就消除了代码的复制

595
00:21:33,556 --> 0:21:35,926
最后 我们将该错误

596
00:21:35,926 --> 0:21:38,776
用一个图片占位符代替

597
00:21:38,776 --> 0:21:40,566
切换主队列

598
00:21:40,566 --> 0:21:42,646
然后使用指定的订阅器

599
00:21:42,646 --> 0:21:43,596
将该图像放入该单元格

600
00:21:51,096 --> 0:21:52,136
现在 这样很不错

601
00:21:52,396 --> 0:21:53,976
我们完成了一样的逻辑

602
00:21:53,976 --> 0:21:56,076
用更短的代码和线性的代码

603
00:21:57,436 --> 0:21:58,756
但是我们可以完成更多吗

604
00:21:59,726 --> 0:22:01,336
还有一个操作符

605
00:21:59,726 --> 0:22:01,336
还有一个操作符

606
00:22:01,336 --> 0:22:02,226
我想分享给大家

607
00:22:02,786 --> 0:22:04,506
它叫做 retry

608
00:22:06,936 --> 0:22:09,446
想象一下在支持 retry 之前

609
00:22:09,446 --> 0:22:11,976
你应该要做些什么呢

610
00:22:12,586 --> 0:22:16,276
你必须要么递归地调用

611
00:22:16,276 --> 0:22:19,686
数据任务创建器

612
00:22:19,686 --> 0:22:20,996
要么维护一个状态机

613
00:22:22,486 --> 0:22:24,976
现在在 Combine 里我可以

614
00:22:24,976 --> 0:22:28,346
直接把 retry 操作符放在这里

615
00:22:28,346 --> 0:22:29,596
在我们替换该错误之前

616
00:22:32,516 --> 0:22:37,826
[掌声]

617
00:22:38,326 --> 0:22:40,276
retry 会捕捉

618
00:22:40,276 --> 0:22:43,116
抛在这里的错误 它通过重启

619
00:22:43,116 --> 0:22:44,406
操作符的链条进行重试

620
00:22:44,406 --> 0:22:46,906
然后再次提取该图像

621
00:22:46,906 --> 0:22:49,856
在这个例子里 我只重试了一次

622
00:22:53,816 --> 0:22:55,616
那么 所有平台上的网络 API

623
00:22:55,616 --> 0:22:57,166
都设计得十分可靠

624
00:22:57,166 --> 0:22:59,576
所以通常来说

625
00:22:59,576 --> 0:23:00,646
你不需要进行重试

626
00:22:59,576 --> 0:23:00,646
你不需要进行重试

627
00:23:01,306 --> 0:23:03,466
但是 你的 App 也许需要

628
00:23:03,466 --> 0:23:05,066
连接一些不可靠的服务器

629
00:23:05,066 --> 0:23:07,496
或者 Meta Box 它经常会

630
00:23:07,496 --> 0:23:09,136
出现 500 服务器错误

631
00:23:09,666 --> 0:23:12,906
这种情况下这个 tryMap 操作符

632
00:23:12,906 --> 0:23:14,876
将会抛出一个无效的

633
00:23:14,876 --> 0:23:16,756
服务器响应错误

634
00:23:16,756 --> 0:23:17,956
而这会被 retry 捕捉

635
00:23:21,536 --> 0:23:23,296
但一定要注意

636
00:23:23,296 --> 0:23:24,906
网络操作符是很昂贵的

637
00:23:24,906 --> 0:23:27,336
retry 也不例外

638
00:23:27,336 --> 0:23:30,396
所以如果可以 就尽量避免 retry

639
00:23:30,956 --> 0:23:32,996
如果必须要 retry

640
00:23:32,996 --> 0:23:34,066
就从一个非常低的数字开始

641
00:23:35,916 --> 0:23:37,826
同时 我们还要注意

642
00:23:37,826 --> 0:23:39,686
你的请求的幂等性

643
00:23:40,876 --> 0:23:43,206
在我的 App 中两次下载

644
00:23:43,206 --> 0:23:45,436
一个图像没问题

645
00:23:45,436 --> 0:23:46,856
但如果你的 App 要处理

646
00:23:46,856 --> 0:23:49,236
如付款等交易的话

647
00:23:49,236 --> 0:23:50,286
盲目进行重试是很危险的

648
00:23:56,286 --> 0:23:57,976
现在我来再次打开低数据模式

649
00:24:06,266 --> 0:24:07,846
我们让 App 再次运行起来

650
00:24:23,286 --> 0:24:24,676
正如你所看到的

651
00:24:24,676 --> 0:24:25,976
我们像以前一样提取了低分辨率的图像

652
00:24:29,066 --> 0:24:30,616
而如果我关闭低数据模式

653
00:24:34,416 --> 0:24:36,716
会提取一样的高分辨率图像

654
00:24:36,976 --> 0:24:38,496
我们的单元格里

655
00:24:38,496 --> 0:24:39,976
不会有任何放错的图像

656
00:24:44,516 --> 0:24:52,206
[掌声]

657
00:24:52,706 --> 0:24:55,646
好 让我们回到幻灯片

658
00:24:59,046 --> 0:25:01,086
总的来说 我已经给你们展示了

659
00:24:59,046 --> 0:25:01,086
总的来说 我已经给你们展示了

660
00:25:01,086 --> 0:25:02,276
如何用 Combine 使你的网络代码

661
00:25:02,276 --> 0:25:05,306
变为简单的线性的

662
00:25:05,516 --> 0:25:07,396
同时更少出错的代码

663
00:25:08,156 --> 0:25:09,646
我也为大家讲了

664
00:25:09,646 --> 0:25:11,146
这些 Combine 操作符

665
00:25:11,146 --> 0:25:12,946
是多么容易组合

666
00:25:12,946 --> 0:25:14,396
你可以通过添加一次性代码

667
00:25:14,396 --> 0:25:15,346
来支持 retry

668
00:25:16,256 --> 0:25:18,536
但是一定要注意

669
00:25:18,536 --> 0:25:20,636
使用少量 retry 次数

670
00:25:20,636 --> 0:25:22,036
且只重试幂等的请求

671
00:25:23,026 --> 0:25:25,576
最后我向大家展示了

672
00:25:25,936 --> 0:25:28,056
你可以如何在低数据模式中

673
00:25:28,056 --> 0:25:30,546
使用 Combine 且不用做任何预取检查

674
00:25:34,176 --> 0:25:35,736
这是我从我的演示中

675
00:25:35,736 --> 0:25:37,666
抽取出的代码

676
00:25:37,666 --> 0:25:39,026
为低数据模式进行自适应加载

677
00:25:39,636 --> 0:25:43,276
它接受一个常规 URL

678
00:25:43,276 --> 0:25:45,846
和一个低数据 URL

679
00:25:45,846 --> 0:25:48,696
并返回一个数据发布器

680
00:25:48,876 --> 0:25:51,906
首先 我们创建一个请求

681
00:25:51,906 --> 0:25:53,946
来提取一个常规 URL

682
00:25:54,156 --> 0:25:56,186
并禁用限制网络访问

683
00:25:57,196 --> 0:25:58,976
我们用 URL 用该请求

684
00:25:58,976 --> 0:26:01,376
创建一个数据任务发布器

685
00:25:58,976 --> 0:26:01,376
创建一个数据任务发布器

686
00:26:03,116 --> 0:26:05,516
然后 我们马上处理

687
00:26:05,516 --> 0:26:08,106
低数据模式所引起的错误

688
00:26:08,106 --> 0:26:09,916
然后我们用一个新的发布器

689
00:26:09,916 --> 0:26:11,336
来代替该发布器

690
00:26:11,516 --> 0:26:13,376
来提取低数据 URL

691
00:26:13,866 --> 0:26:17,466
下面 我们一起处理这两个

692
00:26:17,466 --> 0:26:19,486
成功案例 检查状态码

693
00:26:19,556 --> 0:26:21,976
然后将数据返回给你

694
00:26:25,796 --> 0:26:27,066
你可以将这个代码

695
00:26:27,066 --> 0:26:29,076
用作一个 Combine

696
00:26:29,076 --> 0:26:31,156
和低数据模式的起点

697
00:26:31,156 --> 0:26:31,936
然后根据需要定制此代码

698
00:26:34,096 --> 0:26:35,646
在这里我必须要提到

699
00:26:35,646 --> 0:26:37,316
在现有的 SDK 中还无法获得

700
00:26:37,406 --> 0:26:38,216
其中一些 API

701
00:26:38,216 --> 0:26:40,166
我们正在努力将它们放入

702
00:26:40,166 --> 0:26:41,816
未来的测试版中

703
00:26:45,486 --> 0:26:46,956
接下来我想邀请

704
00:26:46,956 --> 0:26:49,956
我的同事 Jiten 来谈谈 WebSocket

705
00:26:50,726 --> 0:26:51,946
&gt;&gt; 谢谢你 Guoye

706
00:26:51,946 --> 0:26:54,166
大家早上好

707
00:26:54,606 --> 0:26:56,946
我的名字叫 Jiten Mehta

708
00:26:56,946 --> 0:26:58,506
很高兴能你们谈谈

709
00:26:58,506 --> 0:27:00,516
网络框架中的 

710
00:26:58,506 --> 0:27:00,516
网络框架中的 

711
00:27:00,516 --> 0:27:03,026
iOS 13 和 macOS Catalina 里

712
00:27:03,076 --> 0:27:05,026
全新的 WebSocket 协议

713
00:27:06,726 --> 0:27:08,696
过去几年 有大量的开发者

714
00:27:08,696 --> 0:27:09,886
向我们询问

715
00:27:09,886 --> 0:27:11,446
关于 Apple 框架

716
00:27:11,446 --> 0:27:13,216
对 WebSocket 的支持

717
00:27:14,096 --> 0:27:15,516
事实上 这是我们去年进行的

718
00:27:15,516 --> 0:27:16,666
一项关于网络的调查中

719
00:27:16,666 --> 0:27:18,976
开发者们提出的第一个要求

720
00:27:22,456 --> 0:27:24,526
WebSocket 允许通过

721
00:27:24,526 --> 0:27:27,496
单个 HTTP 连接进行双向通信

722
00:27:28,676 --> 0:27:30,346
这使得开发者们能够

723
00:27:30,346 --> 0:27:31,966
编写一些 App

724
00:27:32,736 --> 0:27:34,356
如聊天 多人游戏

725
00:27:34,356 --> 0:27:36,166
和其他实时的 App

726
00:27:36,976 --> 0:27:38,606
WebSocket 在众所周知的

727
00:27:38,606 --> 0:27:41,386
HTTP 端口上工作

728
00:27:41,446 --> 0:27:42,816
它完全兼容于

729
00:27:42,816 --> 0:27:44,426
现有的网络基础设施

730
00:27:44,796 --> 0:27:46,176
允许你连接到代理服务器

731
00:27:46,246 --> 0:27:48,886
CDN 和防火墙

732
00:27:50,256 --> 0:27:52,156
在过去 WebSocket 协议

733
00:27:52,156 --> 0:27:54,316
已经作为 JavaScript API 

734
00:27:54,316 --> 0:27:56,686
在网络浏览器中可用

735
00:27:57,866 --> 0:27:59,146
但是看到 WebSocket

736
00:27:59,146 --> 0:28:00,636
给网络 App 带来的益处

737
00:27:59,146 --> 0:28:00,636
给网络 App 带来的益处

738
00:28:00,936 --> 0:28:03,206
我们决定将这种益处

739
00:28:03,426 --> 0:28:05,446
扩大到我们的网络框架中

740
00:28:05,446 --> 0:28:07,026
不知是在网络视图中

741
00:28:07,026 --> 0:28:09,906
已有的 JavaScript API 中

742
00:28:11,226 --> 0:28:12,746
这让你能够使用

743
00:28:12,746 --> 0:28:14,856
你现有的网络基础设施

744
00:28:14,856 --> 0:28:16,166
并将它带到 Apple 平台上的

745
00:28:16,226 --> 0:28:16,976
本地 App 中

746
00:28:20,476 --> 0:28:22,106
之前我们说过 WebSocket

747
00:28:22,836 --> 0:28:24,186
那么现在我们来看一个

748
00:28:24,186 --> 0:28:26,516
我们今天使用的能够

749
00:28:26,516 --> 0:28:28,056
实现双向通信的普通技术

750
00:28:29,136 --> 0:28:31,456
我们以一个聊天 App 为例

751
00:28:31,956 --> 0:28:34,726
当一个客户端想要从服务器

752
00:28:34,726 --> 0:28:36,096
接收一个响应

753
00:28:36,096 --> 0:28:37,056
它会发出一个请求

754
00:28:38,266 --> 0:28:40,046
该服务器用一个 200 OK 的状态码

755
00:28:40,046 --> 0:28:42,006
来立即做出响应

756
00:28:42,006 --> 0:28:43,496
但它并没有发出响应体

757
00:28:43,496 --> 0:28:45,706
因为它在这时候没有响应体

758
00:28:46,866 --> 0:28:48,536
在未来的某个时候

759
00:28:48,536 --> 0:28:50,336
一旦服务器具备为客户端

760
00:28:50,336 --> 0:28:52,576
准备的响应 它便会将它发给客户端

761
00:28:53,356 --> 0:28:55,116
就在这时 客户端

762
00:28:55,116 --> 0:28:56,656
会发送一个新的请求

763
00:28:56,656 --> 0:28:58,536
表示它想要接受下个消息

764
00:28:59,916 --> 0:29:01,606
这被称作长期轮询

765
00:28:59,916 --> 0:29:01,606
这被称作长期轮询

766
00:29:02,206 --> 0:29:03,666
但是长期轮询

767
00:29:03,666 --> 0:29:04,976
也有一些缺点

768
00:29:06,436 --> 0:29:08,176
当它们想发送消息时

769
00:29:08,176 --> 0:29:09,916
两个端点都必须发送

770
00:29:09,916 --> 0:29:12,396
一个 HTTP 请求

771
00:29:12,396 --> 0:29:14,786
或一个 HTTP 响应

772
00:29:14,786 --> 0:29:15,336
这是很大的开销

773
00:29:16,836 --> 0:29:18,536
此外我们必须要

774
00:29:18,696 --> 0:29:19,936
在服务器上维护复杂性

775
00:29:19,936 --> 0:29:21,176
以启用长期轮询

776
00:29:22,726 --> 0:29:24,226
我们来看看 WebSocket 是怎么

777
00:29:24,226 --> 0:29:25,396
解决这个问题的吧

778
00:29:25,936 --> 0:29:29,446
在 WebSocket 进行握手的

779
00:29:29,446 --> 0:29:31,086
第一步的第一部分

780
00:29:31,336 --> 0:29:33,586
客户端发送给

781
00:29:33,766 --> 0:29:35,416
服务器一个请求

782
00:29:35,416 --> 0:29:36,696
说明想要升级这个

783
00:29:36,696 --> 0:29:37,766
到 WebSocket 的连接

784
00:29:39,206 --> 0:29:41,376
服务器用 101 

785
00:29:41,456 --> 0:29:42,996
切换协议来响应

786
00:29:43,566 --> 0:29:45,126
就在这个时候

787
00:29:45,126 --> 0:29:47,076
我们在两个端口中间

788
00:29:47,076 --> 0:29:47,966
有一个双向流

789
00:29:48,506 --> 0:29:51,286
现在 两个端点都可以

790
00:29:51,286 --> 0:29:53,526
自由地向任何方向发送消息

791
00:29:54,096 --> 0:29:56,716
它们可以发送数据串

792
00:29:57,026 --> 0:29:59,246
或 Ping/Pong 帧之类的消息

793
00:29:59,566 --> 0:30:03,566
且不需要任何 HTTP 开销

794
00:29:59,566 --> 0:30:03,566
且不需要任何 HTTP 开销

795
00:30:03,566 --> 0:30:07,056
URLSession 是 Apple 推荐的 HTTP API

796
00:30:07,056 --> 0:30:10,816
今年我们很高兴宣布

797
00:30:10,986 --> 0:30:13,216
URLSessionWebSocketTask

798
00:30:13,216 --> 0:30:14,976
一个基础框架中新的 API

799
00:30:15,516 --> 0:30:20,816
[欢呼和掌声]

800
00:30:21,316 --> 0:30:22,906
为了创建一个 WebSocket 任务

801
00:30:22,906 --> 0:30:24,626
你可以简单地传入

802
00:30:24,626 --> 0:30:26,736
你想要的连接和调用 resume() 的 URL

803
00:30:27,406 --> 0:30:28,996
我们将开始进行握手

804
00:30:28,996 --> 0:30:29,936
你不需要担心

805
00:30:29,936 --> 0:30:31,426
要处理任何的状态码

806
00:30:31,956 --> 0:30:34,866
WebSocket 握手的第一部分

807
00:30:34,866 --> 0:30:37,296
使用的是 HTTP 语义

808
00:30:37,666 --> 0:30:38,996
这意味着你的 

809
00:30:39,036 --> 0:30:42,106
URLSessionWebSocketTask 将会使用

810
00:30:42,106 --> 0:30:45,016
你现有的 URLSession 配置对象

811
00:30:46,136 --> 0:30:47,576
它还将使用你的网络存储

812
00:30:47,576 --> 0:30:48,996
来做 Cookie 及约定查找

813
00:30:48,996 --> 0:30:50,766
我们将处理你代理

814
00:30:50,766 --> 0:30:52,826
收到的任何挑战

815
00:30:54,156 --> 0:30:55,566
一旦你成功连接

816
00:30:55,616 --> 0:30:58,336
你就可以在该任务上发送消息

817
00:30:59,556 --> 0:31:01,266
你还可以通过传送一个

818
00:30:59,556 --> 0:31:01,266
你还可以通过传送一个

819
00:31:01,266 --> 0:31:03,206
完成处理程序来接收

820
00:31:03,206 --> 0:31:04,806
该任务上的消息 一旦我们

821
00:31:04,806 --> 0:31:06,706
从服务器接收到整个消息

822
00:31:06,706 --> 0:31:09,336
该处理程序将被异步调用

823
00:31:10,396 --> 0:31:12,456
WebSockets 中的 URLSession API

824
00:31:12,456 --> 0:31:14,186
很接近 JavaScript API

825
00:31:14,186 --> 0:31:16,576
而后者是基于

826
00:31:16,576 --> 0:31:19,466
完整的消息和回调

827
00:31:20,706 --> 0:31:21,936
但是一些开发者需要的

828
00:31:21,936 --> 0:31:24,766
不止如此 比如服务器支持

829
00:31:24,766 --> 0:31:26,186
或读取部分消息

830
00:31:26,726 --> 0:31:28,616
为此 我们很高兴介绍

831
00:31:28,616 --> 0:31:31,136
Network.framework 中的 WebSocketSupport 

832
00:31:31,136 --> 0:31:32,756
通过 NWConnection 

833
00:31:32,756 --> 0:31:34,816
和 NWListener 对象

834
00:31:34,816 --> 0:31:36,976
同时给你客户端和服务器支持

835
00:31:39,516 --> 0:31:43,066
[掌声]

836
00:31:43,566 --> 0:31:45,646
有了它 你可以有一个

837
00:31:45,646 --> 0:31:47,066
面向消息的传输协议

838
00:31:47,066 --> 0:31:50,306
该协议可以扩展为对等通信

839
00:31:51,646 --> 0:31:53,166
你也可以通过

840
00:31:53,166 --> 0:31:54,566
为 give 和 receive 操作值

841
00:31:54,566 --> 0:31:56,406
指定最小和最大字节

842
00:31:56,406 --> 0:31:57,836
来接收部分消息

843
00:31:58,446 --> 0:32:00,816
要将 WebSocket 添加到

844
00:31:58,446 --> 0:32:00,816
要将 WebSocket 添加到

845
00:32:00,816 --> 0:32:02,416
对象的网络框架中

846
00:32:02,416 --> 0:32:04,556
你可以只创造一个

847
00:32:04,556 --> 0:32:06,156
启用了 TLS 的参数对象

848
00:32:07,066 --> 0:32:09,686
接着 创建一个 websocketOptions

849
00:32:09,956 --> 0:32:11,766
然后将其设置为

850
00:32:11,766 --> 0:32:12,966
参数的默认协议栈

851
00:32:15,506 --> 0:32:16,766
一旦你创建了参数

852
00:32:17,196 --> 0:32:18,516
接下来你就可以将

853
00:32:18,516 --> 0:32:20,206
这些参数传入

854
00:32:20,206 --> 0:32:21,886
NWConnection 构造器

855
00:32:21,886 --> 0:32:22,916
来创建一个 NWConnection 对象

856
00:32:23,826 --> 0:32:24,836
或者如果你想要创建

857
00:32:24,836 --> 0:32:26,196
一个监听器 你只要将这些参数

858
00:32:26,196 --> 0:32:28,026
传入该监听器的构造器中

859
00:32:29,446 --> 0:32:31,946
发送和接收 API

860
00:32:31,946 --> 0:32:34,156
与去年相比没有变化

861
00:32:34,156 --> 0:32:36,346
你可以继续使用这些

862
00:32:36,346 --> 0:32:37,976
来发送和接收 WebSocket 消息

863
00:32:42,046 --> 0:32:43,156
好 下面我们来看看

864
00:32:43,156 --> 0:32:44,366
WebSocket 的实际操作

865
00:32:44,976 --> 0:32:47,166
我将会在 Guoyue 刚刚

866
00:32:47,166 --> 0:32:48,476
向你们展示的 App

867
00:32:48,476 --> 0:32:51,276
《PubSocket》上进行创建

868
00:32:51,276 --> 0:32:52,496
但我想对《PubSocket》的商业模式

869
00:32:52,496 --> 0:32:54,406
进行一点点改变

870
00:32:54,876 --> 0:32:57,836
现在项目的价格将会变为动态的

871
00:32:57,836 --> 0:33:00,486
而且会根据需求而变化

872
00:32:57,836 --> 0:33:00,486
而且会根据需求而变化

873
00:33:01,266 --> 0:33:02,686
那么 想一想股票市场

874
00:33:02,686 --> 0:33:05,126
但这里是交易食物和饮品的

875
00:33:05,886 --> 0:33:06,896
那么 在左边你可以看到

876
00:33:06,896 --> 0:33:08,366
《PubServer》它是

877
00:33:08,366 --> 0:33:09,936
调酒师可以在其中

878
00:33:09,936 --> 0:33:11,316
编辑商品或者

879
00:33:11,316 --> 0:33:13,246
更改价格的一款 App

880
00:33:14,286 --> 0:33:15,286
在右边是我们

881
00:33:15,326 --> 0:33:16,396
已经看到的酒吧菜单

882
00:33:16,396 --> 0:33:17,886
这是你的客户端

883
00:33:17,886 --> 0:33:19,516
或走进酒吧的客户

884
00:33:19,516 --> 0:33:20,766
可以看到的 App

885
00:33:21,316 --> 0:33:24,096
动态定价的新功能

886
00:33:24,096 --> 0:33:26,826
将被称作 PubSocket+

887
00:33:27,246 --> 0:33:28,096
因此 我们来看 PubSocket+

888
00:33:28,096 --> 0:33:29,336
是如何与我们当前的

889
00:33:29,336 --> 0:33:31,136
服务器和客户端实现一起工作的

890
00:33:31,726 --> 0:33:34,966
我们假设调酒师想要

891
00:33:34,966 --> 0:33:36,476
把沙士的价格

892
00:33:36,476 --> 0:33:39,226
提升到 6.99 美元

893
00:33:39,226 --> 0:33:41,126
我单击更新

894
00:33:42,316 --> 0:33:44,956
现在 客户端就要下拉刷新

895
00:33:45,496 --> 0:33:47,836
只要他们这么做了

896
00:33:47,836 --> 0:33:49,796
沙士的价格就更新了

897
00:33:50,936 --> 0:33:53,096
好了 但我觉得我们肯定能

898
00:33:53,096 --> 0:33:53,956
做得比这个更好

899
00:33:54,806 --> 0:33:56,856
我想让《PubSocket》的客户

900
00:33:56,856 --> 0:33:58,496
有一个无缝的体验

901
00:33:58,706 --> 0:33:59,746
他们不需要下拉刷新

902
00:33:59,746 --> 0:34:02,826
就可以得到实时的价格更新

903
00:33:59,746 --> 0:34:02,826
就可以得到实时的价格更新

904
00:34:03,526 --> 0:34:06,156
让我们来看看 WebSocket 是如何

905
00:34:06,156 --> 0:34:07,496
帮助我们实现这个的

906
00:34:08,025 --> 0:34:11,275
下面我们前往 Xcode

907
00:34:11,366 --> 0:34:13,476
首先我要停止

908
00:34:14,525 --> 0:34:18,466
服务器和客户端

909
00:34:18,466 --> 0:34:20,775
接着我们前往服务器

910
00:34:20,775 --> 0:34:22,576
那里有一个 NWListener

911
00:34:22,576 --> 0:34:25,795
它作为我的 TCB 服务器

912
00:34:27,156 --> 0:34:29,016
这里有一些参数

913
00:34:29,016 --> 0:34:31,096
这些参数是我用设置了 TLS 选项的方法创建的

914
00:34:32,156 --> 0:34:32,966
首先 我要在这里做一个更改

915
00:34:32,966 --> 0:34:35,416
来创建一些 WebSocket 选项

916
00:34:35,416 --> 0:34:37,856
然后将它设置在

917
00:34:37,856 --> 0:34:39,966
参数的协议栈上

918
00:34:40,856 --> 0:34:43,876
这样就告诉我的服务器

919
00:34:43,876 --> 0:34:45,716
怎样完成 WebSocket 与想要

920
00:34:45,755 --> 0:34:47,525
与之相连接的用户端的握手

921
00:34:48,156 --> 0:34:49,985
我将会在我的服务器上

922
00:34:49,985 --> 0:34:53,056
做出的下一个改变

923
00:34:53,056 --> 0:34:55,176
在这个叫做 sendPriceChanges 的函数里

924
00:34:56,306 --> 0:34:58,556
这个函数原本发送

925
00:34:58,556 --> 0:35:00,686
WebSocket 消息给所有

926
00:34:58,556 --> 0:35:00,686
WebSocket 消息给所有

927
00:35:00,686 --> 0:35:01,826
想要连接到它的客户端

928
00:35:01,826 --> 0:35:04,446
在服务器上每次更改

929
00:35:04,446 --> 0:35:07,146
一个项目的一个价格

930
00:35:07,326 --> 0:35:09,216
现在 我使用 defaultStream

931
00:35:09,216 --> 0:35:11,936
实现了一个 send()

932
00:35:13,056 --> 0:35:15,166
这意味着我传送到

933
00:35:15,166 --> 0:35:17,086
send() 方法的数据

934
00:35:17,086 --> 0:35:18,626
是作为一个字节包

935
00:35:18,626 --> 0:35:20,416
在这个 TCB 连接中被发送的

936
00:35:20,416 --> 0:35:21,876
它没有任何的消息结构

937
00:35:21,876 --> 0:35:24,496
我要更改这里的上下文

938
00:35:24,496 --> 0:35:28,246
并创建一个新的上下文

939
00:35:28,606 --> 0:35:32,876
用一些与之相联系的元数据

940
00:35:32,926 --> 0:35:34,946
现在 这就告诉我的连接

941
00:35:34,946 --> 0:35:38,296
要以 WebSocket 消息结构的形式发送数据

942
00:35:39,376 --> 0:35:40,586
有了这两点变化

943
00:35:40,586 --> 0:35:42,456
我的服务器应该准备好

944
00:35:42,456 --> 0:35:44,266
向我的客户端发送 WebSocket 消息了

945
00:35:45,316 --> 0:35:48,216
现在 我们来看

946
00:35:48,216 --> 0:35:49,656
我可以在创建服务器的同时

947
00:35:49,656 --> 0:35:50,336
前往客户端

948
00:35:51,566 --> 0:35:52,956
那么 在客户端上

949
00:35:54,086 --> 0:35:55,086
我首先要更改

950
00:35:55,086 --> 0:35:57,546
connect() 函数

951
00:35:58,116 --> 0:35:59,086
connect() 将会连接到

952
00:35:59,086 --> 0:36:01,936
一个新的服务器上

953
00:35:59,086 --> 0:36:01,936
一个新的服务器上

954
00:36:02,286 --> 0:36:05,316
因此我要用 URLSessionWebSocketTask

955
00:36:05,316 --> 0:36:07,686
我会简单地将 URL 传入任务中

956
00:36:07,686 --> 0:36:09,836
然后调用重新开始

957
00:36:09,836 --> 0:36:11,876
这样就可以开始进行握手

958
00:36:12,866 --> 0:36:14,266
一旦我连接上了

959
00:36:14,266 --> 0:36:16,436
我就会调用 readMessage

960
00:36:16,536 --> 0:36:18,196
它将会收到来自服务器的消息

961
00:36:18,196 --> 0:36:20,846
现在 我们看看应该如何

962
00:36:20,846 --> 0:36:21,646
完成 readMessage

963
00:36:23,156 --> 0:36:26,386
在 readMessage 里我将

964
00:36:26,386 --> 0:36:28,916
在任务上调用 receive()

965
00:36:28,916 --> 0:36:29,866
然后通过一个完成块

966
00:36:30,866 --> 0:36:34,276
在成功的案例里

967
00:36:34,276 --> 0:36:36,616
我将更新我的 UI 更改价格

968
00:36:36,616 --> 0:36:38,046
之后我会立刻再次调用

969
00:36:38,046 --> 0:36:39,676
readMessage 来读取

970
00:36:39,676 --> 0:36:41,696
下一条从服务器传回的消息

971
00:36:42,646 --> 0:36:44,166
一旦我在客户端上做了

972
00:36:44,166 --> 0:36:45,916
这两处更改 我应该完全

973
00:36:46,136 --> 0:36:47,806
准备好连接我的服务器

974
00:36:47,806 --> 0:36:49,246
并接收 WebSocket 消息

975
00:36:50,576 --> 0:36:52,656
好 现在来运行一个新的服务器

976
00:36:52,656 --> 0:36:54,386
和客户端 看看它们是如何工作

977
00:36:55,486 --> 0:37:01,086
首先我要运行我的服务器

978
00:36:55,486 --> 0:37:01,086
首先我要运行我的服务器

979
00:37:01,276 --> 0:37:02,416
现在我们的新客户端在读取

980
00:37:02,486 --> 0:37:04,456
PubSocket+ 它有新的

981
00:37:04,456 --> 0:37:06,836
改良的 WebSocket 能力

982
00:37:07,606 --> 0:37:09,396
那么 我们假设现在是

983
00:37:09,396 --> 0:37:11,156
饮品减价供应的时间

984
00:37:11,156 --> 0:37:12,516
调酒师想将沙士的价格

985
00:37:12,676 --> 0:37:14,556
降低到 1.99 美元

986
00:37:14,556 --> 0:37:16,326
那么 让我来完成这个更改

987
00:37:20,076 --> 0:37:21,756
我会点击更新

988
00:37:22,506 --> 0:37:23,606
然后你可以看到

989
00:37:23,606 --> 0:37:25,296
客户端上的价格就会更新

990
00:37:25,346 --> 0:37:26,396
客户不需要再刷新

991
00:37:27,516 --> 0:37:29,586
[掌声]

992
00:37:30,086 --> 0:37:32,386
那么 对于那些错过的人

993
00:37:32,386 --> 0:37:33,306
我将降低炸薯条的价格

994
00:37:33,306 --> 0:37:34,386
降到和沙士一样

995
00:37:34,386 --> 0:37:35,886
那么现在仍然是降价时间

996
00:37:36,556 --> 0:37:39,906
而只要我点击更新

997
00:37:39,906 --> 0:37:41,586
你就会看到在客户端上

998
00:37:41,586 --> 0:37:42,886
炸薯条的价格发生了改变

999
00:37:42,886 --> 0:37:43,426
我并不用下拉刷新

1000
00:37:43,646 --> 0:37:45,926
我再做一次

1001
00:37:45,926 --> 0:37:47,696
那里薯条的价格就改变了

1002
00:37:48,516 --> 0:37:51,746
[掌声]

1003
00:37:52,246 --> 0:37:54,166
那么 这是没有

1004
00:37:54,386 --> 0:37:55,726
任何 HTTP 开销的

1005
00:37:55,726 --> 0:37:57,696
WebSockets 双向通信

1006
00:37:58,916 --> 0:38:00,766
你们中的一些人也许想知道

1007
00:37:58,916 --> 0:38:00,766
你们中的一些人也许想知道

1008
00:38:00,766 --> 0:38:02,926
右上角的“Stats”按钮是用来干什么的

1009
00:38:03,376 --> 0:38:05,216
如果我单击它 

1010
00:38:05,216 --> 0:38:06,446
这里就会有一些我们

1011
00:38:06,446 --> 0:38:07,866
从 URLSessionTaskMetrics API 中

1012
00:38:07,866 --> 0:38:09,886
收集的新统计数据

1013
00:38:11,486 --> 0:38:13,216
此外 在底部

1014
00:38:13,216 --> 0:38:15,326
RTT 是我的客户端

1015
00:38:15,326 --> 0:38:17,006
和服务器之间的往返时间

1016
00:38:17,006 --> 0:38:19,116
我在 WebSockets 中使用

1017
00:38:19,116 --> 0:38:20,256
Ping/Pong 帧进行计算

1018
00:38:21,126 --> 0:38:22,806
我目前使用网络连接调节器

1019
00:38:22,806 --> 0:38:25,366
来模仿一个繁忙的酒吧环境

1020
00:38:25,366 --> 0:38:26,246
你看可以用像这样的东西

1021
00:38:26,246 --> 0:38:27,396
来监控你的客户端

1022
00:38:27,446 --> 0:38:29,866
和服务器之间的连接

1023
00:38:30,886 --> 0:38:31,946
如果你有兴趣了解更多

1024
00:38:31,946 --> 0:38:33,646
关于添加 Metrics API 中的新特性

1025
00:38:33,646 --> 0:38:35,966
或者如何使用

1026
00:38:35,966 --> 0:38:37,686
网络连接调节器

1027
00:38:37,946 --> 0:38:39,326
请在今天下午 5 点

1028
00:38:39,326 --> 0:38:41,116
来到我们的网络会场

1029
00:38:42,266 --> 0:38:43,736
现在让我们回到幻灯片

1030
00:38:47,496 --> 0:38:51,706
让我们快速回顾一下 PubSocket+

1031
00:38:51,886 --> 0:38:53,406
对于我们的服务器

1032
00:38:53,406 --> 0:38:55,176
我们使用了设置在协议栈上的

1033
00:38:55,176 --> 0:38:56,836
WebSocket 选项中的 NWListener

1034
00:38:57,486 --> 0:38:59,846
而对于客户端 我们使用了

1035
00:38:59,846 --> 0:39:01,816
URLSessionWebSocketTask

1036
00:38:59,846 --> 0:39:01,816
URLSessionWebSocketTask

1037
00:39:01,816 --> 0:39:04,006
来连接我们的服务器读取消息

1038
00:39:04,006 --> 0:39:07,026
对于传输 我们使用了

1039
00:39:07,026 --> 0:39:08,736
双向 WebSocket 消息

1040
00:39:09,606 --> 0:39:11,076
最后 所有操作的优点是

1041
00:39:11,106 --> 0:39:12,496
双向消息传递

1042
00:39:12,976 --> 0:39:14,556
这样做的话

1043
00:39:14,556 --> 0:39:18,586
开销非常小

1044
00:39:18,706 --> 0:39:20,676
现在 让我们回顾一下

1045
00:39:20,676 --> 0:39:23,026
可以为你的 App 添加 WebSockets 的 API

1046
00:39:24,256 --> 0:39:26,136
让你能够在你的

1047
00:39:26,136 --> 0:39:28,266
网络 App 和网络视图中

1048
00:39:28,266 --> 0:39:30,556
现有的 JavaScript API 中

1049
00:39:30,556 --> 0:39:31,366
添加 WebSockets

1050
00:39:31,916 --> 0:39:34,626
而今年有所不同的是

1051
00:39:34,626 --> 0:39:37,196
我们可以将创建在 Network.framework

1052
00:39:37,196 --> 0:39:39,376
顶端的 URLSessionWebSocketTask

1053
00:39:39,376 --> 0:39:40,526
嵌入 URLSession

1054
00:39:41,276 --> 0:39:42,976
它与你现有的 URLSession

1055
00:39:42,976 --> 0:39:44,666
配置对象一起工作

1056
00:39:44,896 --> 0:39:46,796
同时提供自动的 Cookie

1057
00:39:46,796 --> 0:39:47,836
和身份验证支持

1058
00:39:48,656 --> 0:39:50,896
它还提供一个便利的方法

1059
00:39:50,896 --> 0:39:53,746
用 Ping/Pong 来测量往返时间

1060
00:39:55,606 --> 0:39:56,616
此外 今年

1061
00:39:56,846 --> 0:39:58,226
在 Network.framework 中的

1062
00:39:58,226 --> 0:39:59,686
WebSocketSupport

1063
00:39:59,686 --> 0:40:01,546
可以通过 NWConnection 和 NWListener 对象 

1064
00:39:59,686 --> 0:40:01,546
可以通过 NWConnection 和 NWListener 对象 

1065
00:40:01,546 --> 0:40:04,836
为你提供客户端和服务器支持

1066
00:40:06,046 --> 0:40:07,916
它让你直接存储

1067
00:40:07,966 --> 0:40:09,706
完整和部分的消息

1068
00:40:10,006 --> 0:40:11,726
包括 Ping/Pong 帧

1069
00:40:12,636 --> 0:40:14,076
你可以通过 webSocketOptions 对象

1070
00:40:14,076 --> 0:40:16,226
随意地设置自定 Header

1071
00:40:16,226 --> 0:40:17,846
如 Cookie 或其他的

1072
00:40:17,846 --> 0:40:19,536
身份验证 Header

1073
00:40:20,806 --> 0:40:21,916
我们很高兴为所有的开发者们

1074
00:40:21,916 --> 0:40:23,056
开放这项技术

1075
00:40:23,056 --> 0:40:24,656
我们很想看看你们

1076
00:40:24,656 --> 0:40:25,836
要拿这个来做什么

1077
00:40:26,806 --> 0:40:28,116
接下来就有请

1078
00:40:28,176 --> 0:40:29,776
Christoph 来为大家讲讲

1079
00:40:29,776 --> 0:40:30,456
移动性的改进

1080
00:40:31,516 --> 0:40:35,826
[掌声]

1081
00:40:36,326 --> 0:40:39,276
&gt;&gt; 谢谢 Jiten 大家好

1082
00:40:40,386 --> 0:40:41,766
我是 Christoph 我现在要为你

1083
00:40:41,766 --> 0:40:43,726
展示我们在 iOS 13 中

1084
00:40:43,726 --> 0:40:45,526
对移动性所做的改进

1085
00:40:46,986 --> 0:40:50,276
那么 用户经常会遇到这种情况

1086
00:40:50,556 --> 0:40:51,966
当他们走出家门

1087
00:40:51,966 --> 0:40:53,696
并远离他们的

1088
00:40:53,696 --> 0:40:54,976
Wi-Fi 接入点时

1089
00:40:54,976 --> 0:40:57,476
Wi-Fi 的信号变得更弱

1090
00:40:57,476 --> 0:40:59,666
通常这时 App

1091
00:40:59,666 --> 0:41:00,906
就会变得更慢

1092
00:40:59,666 --> 0:41:00,906
就会变得更慢

1093
00:41:00,906 --> 0:41:03,056
因为网络变得更慢了

1094
00:41:03,736 --> 0:41:05,576
有时 App 会完全失效

1095
00:41:06,326 --> 0:41:08,136
所以人们已经习惯了

1096
00:41:08,136 --> 0:41:08,976
这种状况 所以当他们

1097
00:41:08,976 --> 0:41:10,136
走出家门的时候

1098
00:41:10,136 --> 0:41:11,706
他们就会向上滑出控制中心

1099
00:41:11,706 --> 0:41:13,546
然后关闭 Wi-Fi

1100
00:41:14,986 --> 0:41:16,836
好 我相信我们都经历过

1101
00:41:16,836 --> 0:41:18,206
这种情况 对吗

1102
00:41:19,066 --> 0:41:21,556
所以我想要改变这种现状

1103
00:41:22,326 --> 0:41:23,526
我认为用户应该永远

1104
00:41:23,526 --> 0:41:25,116
不需要关掉 Wi-Fi

1105
00:41:25,556 --> 0:41:26,976
当他们走出家门的时候

1106
00:41:27,416 --> 0:41:28,056
而你的 App

1107
00:41:28,056 --> 0:41:29,576
也应该时刻正常运行

1108
00:41:29,576 --> 0:41:31,906
甚至是在 Wi-Fi 信号很差的时候

1109
00:41:33,106 --> 0:41:34,536
我相信这个屋子里

1110
00:41:34,536 --> 0:41:37,136
在座的每个人都想达到这一目标

1111
00:41:38,026 --> 0:41:39,976
那么让我来展示我们要怎么做

1112
00:41:44,536 --> 0:41:47,686
我们常用这种方法来表述 Wi-Fi

1113
00:41:48,316 --> 0:41:50,016
我们在中间有一个 Wi-Fi 接入点

1114
00:41:50,016 --> 0:41:51,586
它周围的同心圆

1115
00:41:51,586 --> 0:41:54,096
向我们显示 Wi-Fi 信号

1116
00:41:54,096 --> 0:41:55,706
是如何逐渐消失的

1117
00:41:55,706 --> 0:41:57,536
随着手机越来越远

1118
00:41:57,536 --> 0:42:00,166
信号就变得越来越弱

1119
00:41:57,536 --> 0:42:00,166
信号就变得越来越弱

1120
00:42:01,216 --> 0:42:02,666
在这种场景中

1121
00:42:02,666 --> 0:42:04,676
要手机决定是使用 Wi-Fi

1122
00:42:04,676 --> 0:42:06,216
还是切换到蜂窝移动网络

1123
00:42:06,626 --> 0:42:07,886
这是非常简单的

1124
00:42:08,656 --> 0:42:11,846
对吗 好 现在问题是

1125
00:42:12,166 --> 0:42:13,526
这种对 Wi-Fi 外观的描述

1126
00:42:13,526 --> 0:42:16,986
实际上与现实相去甚远

1127
00:42:17,796 --> 0:42:22,316
事实上它看上去更像这样

1128
00:42:22,536 --> 0:42:23,856
在中间有Wi-Fi接入点

1129
00:42:23,856 --> 0:42:25,786
然后在它周围的是非常

1130
00:42:25,786 --> 0:42:27,636
参差不齐的 Wi-Fi 信号

1131
00:42:28,556 --> 0:42:29,826
而这些斑点是因为

1132
00:42:29,826 --> 0:42:32,656
房间里的物体干扰了信号

1133
00:42:33,316 --> 0:42:35,546
房间 墙壁 所有的东西

1134
00:42:35,546 --> 0:42:37,406
都在使 Wi-Fi 信号成为

1135
00:42:37,406 --> 0:42:41,366
一个非常不确定的质量指标

1136
00:42:42,216 --> 0:42:43,766
手机只要有一点小的移动

1137
00:42:43,766 --> 0:42:45,186
就可能将它从一个好的位置

1138
00:42:45,186 --> 0:42:47,566
移到一个坏的位置

1139
00:42:48,486 --> 0:42:49,536
所以 手机的确很难

1140
00:42:49,536 --> 0:42:51,296
知道 Wi-Fi 信号

1141
00:42:51,296 --> 0:42:53,196
仍然是好或坏

1142
00:42:53,546 --> 0:42:54,576
它也许仍然接收到

1143
00:42:54,576 --> 0:42:56,186
来自接入点的信标

1144
00:42:56,756 --> 0:42:57,636
但是尽管如此

1145
00:42:57,636 --> 0:42:59,196
信号其实可能会很差

1146
00:42:59,256 --> 0:43:01,916
以至于无法发送或接收任何数据

1147
00:42:59,256 --> 0:43:01,916
以至于无法发送或接收任何数据

1148
00:43:03,076 --> 0:43:04,906
所以 在这种环境下

1149
00:43:05,366 --> 0:43:06,656
手机需要决定

1150
00:43:06,866 --> 0:43:08,676
自己使用 Wi-Fi 还是

1151
00:43:08,676 --> 0:43:09,246
蜂窝移动网络

1152
00:43:10,236 --> 0:43:11,726
Wi-Fi 信号的不确定性

1153
00:43:11,726 --> 0:43:15,146
正是移动性所面临的重大挑战

1154
00:43:17,696 --> 0:43:20,936
那么 在 Apple 中我们已经

1155
00:43:20,936 --> 0:43:22,106
意识到这个问题有一段时间了

1156
00:43:22,106 --> 0:43:24,526
我要向你展示在过去

1157
00:43:24,526 --> 0:43:27,456
我们已经采取了多少步骤

1158
00:43:27,456 --> 0:43:28,966
来改进这样的场景

1159
00:43:28,966 --> 0:43:33,706
这一切都开始于 iOS 7 的 Siri

1160
00:43:36,156 --> 0:43:38,066
在 iOS 7 中 我们为 Siri

1161
00:43:38,066 --> 0:43:39,766
引入了多路 TCP

1162
00:43:40,516 --> 0:43:42,056
多路 TCP 允许同时使用

1163
00:43:42,056 --> 0:43:43,996
Wi-Fi 和蜂窝移动网络

1164
00:43:44,496 --> 0:43:46,656
所以 从 iOS 7 开始

1165
00:43:46,716 --> 0:43:48,226
无论何时 当人们

1166
00:43:48,226 --> 0:43:49,366
走出家门使用 Siri 时

1167
00:43:50,276 --> 0:43:52,276
多路 TCP 都会保证

1168
00:43:52,276 --> 0:43:53,426
要么使用 Wi-Fi

1169
00:43:53,426 --> 0:43:56,556
要么使用蜂窝移动网络

1170
00:43:56,556 --> 0:43:58,846
以减少 Siri 用户的延迟

1171
00:43:58,846 --> 0:44:00,046
同时减少出错率

1172
00:43:58,846 --> 0:44:00,046
同时减少出错率

1173
00:44:01,316 --> 0:44:03,556
通过引入多路 TCP

1174
00:44:03,776 --> 0:44:05,136
我们看到了很不错的结果

1175
00:44:06,346 --> 0:44:08,656
那么 一个真正的端对端的

1176
00:44:08,836 --> 0:44:12,376
多路径协议 如多路 TCP

1177
00:44:12,376 --> 0:44:14,466
要求客户端

1178
00:44:14,466 --> 0:44:15,896
和服务器都知道它

1179
00:44:16,546 --> 0:44:18,926
二者需要一起工作 对吧

1180
00:44:19,236 --> 0:44:20,586
它们需要共同决定

1181
00:44:20,586 --> 0:44:21,776
是通过 Wi-Fi 发送流量

1182
00:44:21,776 --> 0:44:23,516
还是通过蜂窝移动网络

1183
00:44:24,566 --> 0:44:26,866
所以我们问自己

1184
00:44:26,866 --> 0:44:29,436
如何在提高移动性的同时

1185
00:44:29,436 --> 0:44:31,896
不需要让客户端

1186
00:44:31,896 --> 0:44:33,586
和服务器一起工作

1187
00:44:34,436 --> 0:44:36,306
也不需要修改

1188
00:44:36,356 --> 0:44:38,056
服务器配置

1189
00:44:39,366 --> 0:44:41,126
答案出现在两年后的

1190
00:44:41,126 --> 0:44:43,266
带有 Wi-Fi Assist 的 iOS 9 中

1191
00:44:43,796 --> 0:44:47,516
Wi-Fi Assist 为所有的 App

1192
00:44:47,516 --> 0:44:49,536
和所有的流量处理移动性

1193
00:44:49,536 --> 0:44:51,226
与任意的服务器对话

1194
00:44:51,226 --> 0:44:53,986
而它所用的方法是

1195
00:44:53,986 --> 0:44:56,216
首先启动 Wi-Fi

1196
00:44:56,216 --> 0:44:57,596
当信号不好连接不上时

1197
00:44:57,596 --> 0:44:59,326
它会设法足够快速地

1198
00:44:59,326 --> 0:45:00,786
建立起连接 

1199
00:44:59,326 --> 0:45:00,786
建立起连接 

1200
00:45:01,256 --> 0:45:02,406
我们只需要通过蜂窝移动网络

1201
00:45:02,406 --> 0:45:06,306
连接来建立另一个连接

1202
00:45:06,696 --> 0:45:08,406
从 iOS 9 开始

1203
00:45:08,406 --> 0:45:09,666
自从我们引入了 Wi-Fi Assist

1204
00:45:09,666 --> 0:45:11,456
你所有的使用

1205
00:45:12,176 --> 0:45:13,506
高级 API 的应用

1206
00:45:13,506 --> 0:45:14,976
都可以从 Wi-Fi Assist 中获益

1207
00:45:14,976 --> 0:45:17,566
而当用户移动时

1208
00:45:17,606 --> 0:45:19,346
会带来更好的体验

1209
00:45:19,346 --> 0:45:21,916
这适用于任何的在网上

1210
00:45:22,246 --> 0:45:24,726
与服务器对话的服务器

1211
00:45:26,626 --> 0:45:28,186
那么 Wi-Fi Assist 也许

1212
00:45:28,186 --> 0:45:30,276
仍会被 Wi-Fi 困住

1213
00:45:30,276 --> 0:45:31,556
例如 如果它设法

1214
00:45:31,556 --> 0:45:33,286
建立该连接

1215
00:45:33,286 --> 0:45:34,966
但是之后信号变弱了

1216
00:45:35,426 --> 0:45:37,676
那么那些流量仍然会被堵住

1217
00:45:38,156 --> 0:45:39,416
为了更好地处理

1218
00:45:39,416 --> 0:45:42,016
那些场景 我们仍然需要

1219
00:45:42,016 --> 0:45:43,856
真实的端对端的多路径

1220
00:45:44,306 --> 0:45:45,836
和我们在 Siri 中使用的方法一样

1221
00:45:46,766 --> 0:45:48,466
所以 有了四年的 Siri 中的

1222
00:45:48,466 --> 0:45:52,096
多路 TCP 的经验后

1223
00:45:52,096 --> 0:45:54,616
我们决定向你们每个人

1224
00:45:54,616 --> 0:45:55,736
开放这个 API

1225
00:45:56,616 --> 0:45:58,776
那么 从 iOS 11 开始 你就可以

1226
00:45:58,776 --> 0:46:00,616
开始使用切换或者 URLSession

1227
00:45:58,776 --> 0:46:00,616
开始使用切换或者 URLSession

1228
00:46:00,616 --> 0:46:04,336
或 Network.framework 中的交互方式

1229
00:46:05,426 --> 0:46:07,076
所以 当你能够确定

1230
00:46:07,076 --> 0:46:07,976
你的服务器准备好了

1231
00:46:07,976 --> 0:46:09,946
你就可以启动多路 TCP

1232
00:46:09,946 --> 0:46:11,966
然后获得与 Siri 所获相同的好处

1233
00:46:13,456 --> 0:46:15,836
那么 在这些版本中的每一个

1234
00:46:16,036 --> 0:46:19,596
包括 iOS 7 iOS 9 和 iOS 11 中

1235
00:46:19,596 --> 0:46:22,366
我们都集中一个指定区域来提高移动性

1236
00:46:23,876 --> 0:46:25,736
我们集中在多路 TCP

1237
00:46:25,736 --> 0:46:28,416
集中在 Siri 集中在 Wi-Fi Assist

1238
00:46:29,356 --> 0:46:31,166
那么现在是 iOS 13

1239
00:46:32,326 --> 0:46:34,906
在 iOS 13 中我们改进了

1240
00:46:34,906 --> 0:46:36,986
许多东西 这张幻灯片

1241
00:46:36,986 --> 0:46:38,116
甚至放不下它们

1242
00:46:40,086 --> 0:46:43,436
这就是在 iOS 13 中

1243
00:46:43,436 --> 0:46:44,976
移动性的改进 谢谢

1244
00:46:45,516 --> 0:46:48,276
[掌声]

1245
00:46:48,776 --> 0:46:50,866
谢谢 在 iOS 13 中

1246
00:46:50,866 --> 0:46:52,966
移动性的改进贯穿整个系统

1247
00:46:53,756 --> 0:46:55,206
包括许多不同的框架

1248
00:46:55,316 --> 0:46:57,626
后台程序和 App

1249
00:46:57,626 --> 0:46:59,016
从固件到驱动程序

1250
00:46:59,696 --> 0:47:02,226
所有东西的移动性都得到了改进

1251
00:46:59,696 --> 0:47:02,226
所有东西的移动性都得到了改进

1252
00:47:02,546 --> 0:47:04,256
那么在这场的这个部分里

1253
00:47:04,436 --> 0:47:05,836
我要谈一谈其中的两个

1254
00:47:05,836 --> 0:47:08,206
即 Wi-Fi Assist

1255
00:47:08,206 --> 0:47:09,526
和多路径传输

1256
00:47:10,816 --> 0:47:13,716
那么 首先是 Wi-Fi Assist

1257
00:47:14,636 --> 0:47:16,746
传统上来说

1258
00:47:16,746 --> 0:47:18,656
Wi-Fi Assist 只是考虑到

1259
00:47:18,656 --> 0:47:20,356
非常有限的信息

1260
00:47:20,356 --> 0:47:23,266
来判断 Wi-Fi 信号是否足够好

1261
00:47:24,376 --> 0:47:26,596
在 iOS 13 里我们改变了这一点

1262
00:47:27,946 --> 0:47:30,046
我们使系统中的

1263
00:47:30,046 --> 0:47:31,766
所有组件都提供信息

1264
00:47:31,766 --> 0:47:33,476
到 Wi-Fi Assist 中去

1265
00:47:33,476 --> 0:47:35,526
使 Wi-Fi Assist 有一个

1266
00:47:35,526 --> 0:47:37,396
完整的跨层的移动性检测

1267
00:47:38,526 --> 0:47:40,316
较低层 Wi-Fi

1268
00:47:40,316 --> 0:47:41,716
和蜂窝移动网络

1269
00:47:41,716 --> 0:47:43,656
都提供关于信号质量的信息

1270
00:47:43,656 --> 0:47:45,256
以一种比 iOS 12 中

1271
00:47:45,256 --> 0:47:47,236
粒度更细的方式

1272
00:47:48,306 --> 0:47:49,526
同时 高层次的框架

1273
00:47:49,626 --> 0:47:52,596
比如 Network.framework 和 URLSession

1274
00:47:53,116 --> 0:47:54,516
及系统其他的后台程序

1275
00:47:54,736 --> 0:47:55,596
它们都为 Wi-Fi Assist

1276
00:47:55,596 --> 0:47:57,166
提供关于它们的流量

1277
00:47:57,636 --> 0:47:59,826
如何前进的信息

1278
00:48:00,666 --> 0:48:02,796
所有进入到 Wi-Fi Assist 中的

1279
00:48:02,796 --> 0:48:04,206
信息让他能够检测到

1280
00:48:04,206 --> 0:48:06,136
我们是否在一个

1281
00:48:06,136 --> 0:48:08,076
移动性的情景内

1282
00:48:08,076 --> 0:48:09,526
同时我们是否应该开始

1283
00:48:09,526 --> 0:48:10,796
使用蜂窝移动网络

1284
00:48:11,776 --> 0:48:13,416
那么有了所有这些信息

1285
00:48:13,746 --> 0:48:15,086
之后 Wi-Fi Assist 就会

1286
00:48:15,086 --> 0:48:17,786
做出它的决定

1287
00:48:17,786 --> 0:48:19,106
并反馈给系统

1288
00:48:19,546 --> 0:48:21,326
它告诉较低层 Wi-Fi 

1289
00:48:21,326 --> 0:48:23,106
和蜂窝移动网络

1290
00:48:23,106 --> 0:48:24,346
去努力提高信号质量

1291
00:48:25,246 --> 0:48:27,046
它还与其他层对话

1292
00:48:27,046 --> 0:48:27,936
如 Network.framework

1293
00:48:28,406 --> 0:48:29,986
和 URLSession

1294
00:48:30,076 --> 0:48:31,406
来开始恢复数据

1295
00:48:31,406 --> 0:48:34,946
所有这些都大大改善了

1296
00:48:34,946 --> 0:48:36,306
流量的恢复

1297
00:48:37,796 --> 0:48:39,896
那么即使已经在 Wi-Fi 上

1298
00:48:39,896 --> 0:48:40,886
建立了流量

1299
00:48:40,886 --> 0:48:42,416
并开始交换数据

1300
00:48:42,416 --> 0:48:44,936
如果之后信号质量下降

1301
00:48:44,936 --> 0:48:47,636
我们也能够移动

1302
00:48:47,636 --> 0:48:49,466
下一个会在 Wi-Fi 上

1303
00:48:49,466 --> 0:48:50,786
使用的请求

1304
00:48:50,786 --> 0:48:53,396
我们能够将该请求

1305
00:48:53,396 --> 0:48:54,796
移动到蜂窝移动网络

1306
00:48:55,796 --> 0:48:57,476
因此你的 App 现在应该

1307
00:48:57,476 --> 0:48:59,686
不太容易被困在 Wi-Fi 上

1308
00:49:00,286 --> 0:49:03,306
现在 你们的问题

1309
00:49:03,306 --> 0:49:04,976
当然是如何从

1310
00:49:04,976 --> 0:49:06,676
Wi-Fi Assist 中获得好处

1311
00:49:07,236 --> 0:49:08,366
如何从我们在 iOS 13 中所做的

1312
00:49:08,366 --> 0:49:10,886
所有这些改进中获得好处呢

1313
00:49:12,346 --> 0:49:14,756
那么首先 你可以获得好处

1314
00:49:14,756 --> 0:49:16,096
通过使用高级别的 API

1315
00:49:16,096 --> 0:49:18,356
比如 URLSession

1316
00:49:18,356 --> 0:49:19,306
和 Network.framework

1317
00:49:20,206 --> 0:49:22,276
所有这些 API 都是在考虑

1318
00:49:22,276 --> 0:49:23,886
Wi-Fi Assist 的情况下构建的

1319
00:49:24,846 --> 0:49:26,586
它们从中得到了充分的好处

1320
00:49:27,396 --> 0:49:28,656
那么 你只要确保

1321
00:49:28,656 --> 0:49:32,656
你的 App 在使用那些 API

1322
00:49:33,706 --> 0:49:36,966
接下来 你们中的一些人正在用

1323
00:49:36,966 --> 0:49:39,566
SCNetworkReachability 之类的 API 

1324
00:49:39,566 --> 0:49:41,896
来进行活跃的接口管理

1325
00:49:42,686 --> 0:49:43,996
你也许在做启动时检查

1326
00:49:43,996 --> 0:49:45,896
以知道你的请求

1327
00:49:46,016 --> 0:49:47,506
最终会到达哪里

1328
00:49:47,506 --> 0:49:49,476
它会打开 Wi-Fi 还是蜂窝移动网络呢

1329
00:49:50,606 --> 0:49:51,666
但这些启动时检查

1330
00:49:51,666 --> 0:49:53,766
有一个问题就是

1331
00:49:53,766 --> 0:49:55,906
在你检查的时候和

1332
00:49:55,906 --> 0:49:57,326
你确实使用连接时

1333
00:49:58,816 --> 0:50:00,196
接口有可能已经改变了

1334
00:49:58,816 --> 0:50:00,196
接口有可能已经改变了

1335
00:50:00,316 --> 0:50:02,136
Wi-Fi Assist 可能已经决定

1336
00:50:02,136 --> 0:50:03,396
将你的流量发送到蜂窝移动网络

1337
00:50:03,396 --> 0:50:05,256
或者 Wi-Fi 信号可能已经

1338
00:50:05,346 --> 0:50:06,456
明显地改善了

1339
00:50:06,946 --> 0:50:08,806
因此 启动时检查是一个

1340
00:50:08,806 --> 0:50:10,636
表明你的流量最终

1341
00:50:10,636 --> 0:50:11,966
会流向哪里非常糟糕的指标

1342
00:50:12,506 --> 0:50:14,696
那么 我们建议你回想一下

1343
00:50:14,696 --> 0:50:16,166
你所使用的启动时检查

1344
00:50:16,166 --> 0:50:18,796
然后在之后的答疑会中

1345
00:50:18,796 --> 0:50:20,326
告诉我们为什么你需要它

1346
00:50:20,326 --> 0:50:22,286
我们将会和你一起

1347
00:50:22,286 --> 0:50:24,246
找到一个替代

1348
00:50:25,806 --> 0:50:28,656
现在如果你仍然需要

1349
00:50:28,756 --> 0:50:30,316
掌控流量 比如说不使用

1350
00:50:30,316 --> 0:50:32,216
蜂窝移动网络

1351
00:50:32,216 --> 0:50:34,936
原因也许是数据传输太大

1352
00:50:34,936 --> 0:50:36,966
或者流量对用户体验

1353
00:50:36,966 --> 0:50:39,146
不是很重要

1354
00:50:39,146 --> 0:50:40,206
你就可以使用

1355
00:50:40,296 --> 0:50:42,396
allowsExpensiveNetworkAccess 之类的 Helper

1356
00:50:42,396 --> 0:50:43,346
并将它们设置为假

1357
00:50:43,946 --> 0:50:46,116
这样一来 你的请求

1358
00:50:46,116 --> 0:50:48,546
就不会进入蜂窝移动网络连接

1359
00:50:50,176 --> 0:50:53,076
那么 这是 Wi-Fi Assist

1360
00:50:53,076 --> 0:50:54,486
我们做了很多努力

1361
00:50:54,486 --> 0:50:56,616
来使它在 iOS 13 里变得更好

1362
00:50:56,616 --> 0:50:59,066
你还可以通过使用高级别的 API

1363
00:50:59,066 --> 0:51:01,356
来获得其好处

1364
00:50:59,066 --> 0:51:01,356
来获得其好处

1365
00:51:01,356 --> 0:51:02,856
那么我要进入下一个

1366
00:51:03,186 --> 0:51:04,696
多路径传输

1367
00:51:07,296 --> 0:51:10,306
Siri 已经用它有一段时间了

1368
00:51:10,676 --> 0:51:12,366
我们已经在两年前

1369
00:51:12,366 --> 0:51:15,416
开放了这个 API

1370
00:51:15,416 --> 0:51:18,336
并鼓励你浏览自己的 App

1371
00:51:18,336 --> 0:51:19,776
查看哪个流量可能让你

1372
00:51:19,776 --> 0:51:23,716
从多路径 TCP 中获益最多

1373
00:51:23,926 --> 0:51:26,326
那么今年在 iOS 13 中

1374
00:51:26,326 --> 0:51:27,946
这个运行得很好

1375
00:51:27,946 --> 0:51:31,246
浏览我们自己的 App 

1376
00:51:31,556 --> 0:51:33,126
我们决定看看如何

1377
00:51:33,126 --> 0:51:34,266
从多路径 TCP 中获益最多

1378
00:51:34,936 --> 0:51:36,196
当移动设备对用户体验

1379
00:51:36,196 --> 0:51:37,736
非常关键

1380
00:51:37,736 --> 0:51:39,046
且难以恢复时

1381
00:51:39,046 --> 0:51:40,206
我们通常使用哪一个流量

1382
00:51:41,256 --> 0:51:43,796
那么一个 App 是 Apple 的《地图》

1383
00:51:44,576 --> 0:51:46,306
大多数用户 当他们

1384
00:51:46,306 --> 0:51:47,666
寻找他们的方向时

1385
00:51:47,666 --> 0:51:48,816
都是走出家门的时候

1386
00:51:49,336 --> 0:51:50,526
这时候才需要搜索

1387
00:51:50,956 --> 0:51:53,226
那么在 iOS 13 中 我们为

1388
00:51:53,226 --> 0:51:54,976
《地图》启用了 Multipath TCP

1389
00:51:55,516 --> 0:51:59,716
[掌声]

1390
00:52:00,216 --> 0:52:01,806
现在 无论你什么时候

1391
00:52:01,806 --> 0:52:03,576
走出家门 使用 Apple《地图》

1392
00:52:03,876 --> 0:52:05,846
来查找方向

1393
00:52:05,916 --> 0:52:07,346
并尝试搜索餐馆

1394
00:52:08,266 --> 0:52:10,016
你都会使用 MP TCP

1395
00:52:10,016 --> 0:52:11,616
你的流量将会从 Wi-Fi 移动到蜂窝移动网络

1396
00:52:12,456 --> 0:52:14,666
从周一开始 从第一个

1397
00:52:14,666 --> 0:52:15,836
测试版开始 我们就一直

1398
00:52:15,836 --> 0:52:17,846
在启用它 我们将看到

1399
00:52:17,846 --> 0:52:20,286
Apple《地图》的响应能力将大大提高

1400
00:52:22,086 --> 0:52:24,386
在接下来这个 App 中我们有一个

1401
00:52:24,386 --> 0:52:26,666
非常关键的用户体验

1402
00:52:27,326 --> 0:52:29,236
这也是经常使用的

1403
00:52:29,236 --> 0:52:30,916
当你走出家门

1404
00:52:30,916 --> 0:52:31,856
你会播放音乐 对吗

1405
00:52:32,416 --> 0:52:33,616
当你播放音乐时

1406
00:52:33,616 --> 0:52:34,796
你就是在下载一个

1407
00:52:34,796 --> 0:52:38,006
充满音乐内容的大文件

1408
00:52:38,326 --> 0:52:40,696
你不想让这个音乐暂停

1409
00:52:41,116 --> 0:52:42,286
因为当它暂停时

1410
00:52:42,286 --> 0:52:43,646
用户会收到打扰

1411
00:52:44,616 --> 0:52:46,836
所以在 iOS 13 中我们

1412
00:52:46,836 --> 0:52:48,716
为 Apple Music 启用了多路径 TCP

1413
00:52:49,516 --> 0:52:53,866
[掌声]

1414
00:52:54,366 --> 0:52:56,026
我们看到音乐播放的暂停

1415
00:52:56,026 --> 0:52:58,616
越来越少 因为多路径 TCP 现在正在

1416
00:52:58,616 --> 0:53:00,596
将流量移到蜂窝移动网络

1417
00:52:58,616 --> 0:53:00,596
将流量移到蜂窝移动网络

1418
00:53:00,846 --> 0:53:02,806
当我们接近暂停时

1419
00:53:03,616 --> 0:53:05,466
所以用户就会有

1420
00:53:05,466 --> 0:53:06,666
一个更好的体验

1421
00:53:07,266 --> 0:53:09,916
现在 关于这一点

1422
00:53:09,916 --> 0:53:11,816
我们已经在 Siri 地图

1423
00:53:11,876 --> 0:53:14,316
和音乐中启用了它

1424
00:53:14,316 --> 0:53:14,576
你也可以这么做

1425
00:53:15,646 --> 0:53:17,536
我们推荐你

1426
00:53:17,536 --> 0:53:19,146
看看你自己的 App

1427
00:53:19,286 --> 0:53:20,566
看看出门的时候

1428
00:53:20,566 --> 0:53:21,646
经常使用的是哪个流量

1429
00:53:22,516 --> 0:53:24,746
哪一个有很重要的流量

1430
00:53:24,746 --> 0:53:26,266
对用户体验至关重要

1431
00:53:26,266 --> 0:53:28,256
并且很难恢复呢

1432
00:53:29,146 --> 0:53:30,376
这些流量的种类

1433
00:53:30,376 --> 0:53:31,676
他们都很适合

1434
00:53:31,676 --> 0:53:33,316
多路径服务类型

1435
00:53:33,316 --> 0:53:35,056
你可以切换选择他们

1436
00:53:35,516 --> 0:53:36,736
或者在 URLSession 

1437
00:53:36,736 --> 0:53:37,516
和 Network.framework 中进行交互

1438
00:53:38,696 --> 0:53:42,596
那么不要忘记 如果你真的进入多路径

1439
00:53:42,596 --> 0:53:44,446
它仍然需要客户端

1440
00:53:44,446 --> 0:53:47,046
和服务器一起工作

1441
00:53:47,046 --> 0:53:49,076
所以去看看这个 URL

1442
00:53:49,076 --> 0:53:50,776
确定正确配置了你的服务器

1443
00:53:52,796 --> 0:53:56,566
那么移动性的部分

1444
00:53:56,626 --> 0:53:58,466
到这里就结束了

1445
00:53:59,976 --> 0:54:01,146
如果我们想要你记住一件事

1446
00:53:59,976 --> 0:54:01,146
如果我们想要你记住一件事

1447
00:54:01,146 --> 0:54:02,866
那就是无论何时

1448
00:54:03,626 --> 0:54:05,886
一个用户走出他的家门

1449
00:54:05,886 --> 0:54:07,586
他都不应该有一个

1450
00:54:07,676 --> 0:54:09,846
不好的体验 导致他关掉 Wi-Fi

1451
00:54:10,786 --> 0:54:13,416
那么 当你开发你的 App 时

1452
00:54:13,416 --> 0:54:14,666
当你在测试它们的时候

1453
00:54:14,666 --> 0:54:16,716
当你在配置一个

1454
00:54:16,716 --> 0:54:19,336
糟糕的 Wi-Fi 网络的时候

1455
00:54:19,336 --> 0:54:20,316
当你走出家门去测试它的时候

1456
00:54:20,316 --> 0:54:22,266
不要期望你的 App

1457
00:54:22,266 --> 0:54:23,416
会变得很慢 甚至失灵

1458
00:54:23,416 --> 0:54:25,556
或者你的流量

1459
00:54:25,556 --> 0:54:29,156
会基本上永远持续下去

1460
00:54:29,916 --> 0:54:31,476
原则上它应该就是正常运行

1461
00:54:31,956 --> 0:54:33,996
如果不能运行 就要确保

1462
00:54:33,996 --> 0:54:35,106
那些失效的流量

1463
00:54:35,106 --> 0:54:37,736
正在使用高层次的 API

1464
00:54:38,026 --> 0:54:39,356
这些 API 充分地

1465
00:54:39,356 --> 0:54:41,356
受益于 Wi-Fi Assist 

1466
00:54:41,356 --> 0:54:42,856
受益于 iOS 13 中我们做的

1467
00:54:42,856 --> 0:54:43,806
所有改进

1468
00:54:44,376 --> 0:54:46,576
如果你正在进行活跃的

1469
00:54:46,606 --> 0:54:48,826
接口管理 请来答疑会告诉我们

1470
00:54:48,826 --> 0:54:50,726
或者发送给我们一个

1471
00:54:50,726 --> 0:54:51,726
Apple Bug 报告

1472
00:54:52,296 --> 0:54:53,846
告诉我们你的使用案例

1473
00:54:53,846 --> 0:54:55,086
我们将会和你一起

1474
00:54:55,086 --> 0:54:57,056
找到一个替代

1475
00:54:57,516 --> 0:55:00,226
这样你就可以避免进行

1476
00:54:57,516 --> 0:55:00,226
这样你就可以避免进行

1477
00:55:00,226 --> 0:55:01,736
这种活跃的接口管理

1478
00:55:01,736 --> 0:55:03,666
并充分获益于 Wi-Fi Assist

1479
00:55:04,206 --> 0:55:07,026
最后 如果你有流量

1480
00:55:07,026 --> 0:55:08,146
仍然堵在 Wi-Fi 上

1481
00:55:08,146 --> 0:55:09,826
并且很难恢复

1482
00:55:09,826 --> 0:55:12,756
试着看看你能否开始

1483
00:55:12,756 --> 0:55:14,266
使用一个多路径服务类型

1484
00:55:14,266 --> 0:55:16,006
准备好服务器

1485
00:55:16,006 --> 0:55:17,956
然后获得和 Apple Music 和《地图》

1486
00:55:17,956 --> 0:55:20,056
以及 Siri 一样的益处

1487
00:55:20,556 --> 0:55:23,186
那么 这就是本场的这一部分

1488
00:55:24,126 --> 0:55:25,336
我们看过了用低数据模式

1489
00:55:25,336 --> 0:55:28,196
用户现在可以打开

1490
00:55:28,196 --> 0:55:29,816
标记了的网络 这样就能

1491
00:55:29,816 --> 0:55:32,206
减少那些网络上的数据使用

1492
00:55:32,696 --> 0:55:34,906
我们展示了一个新的 API

1493
00:55:34,906 --> 0:55:37,726
你们的 App 也可以从中获益

1494
00:55:38,276 --> 0:55:41,246
如果你在构建一个发布器

1495
00:55:41,246 --> 0:55:43,036
订阅器风格的 App

1496
00:55:43,766 --> 0:55:45,496
在 URLSession 中使用 Combine

1497
00:55:45,496 --> 0:55:47,136
你就能够创建一个很好的 App

1498
00:55:47,746 --> 0:55:49,936
就像 Guoyue 今天向你们展示的那样

1499
00:55:50,676 --> 0:55:52,706
最后是 WebSockets

1500
00:55:53,106 --> 0:55:54,366
最受欢迎的功能就是

1501
00:55:54,406 --> 0:55:57,026
将它引入了 iOS 13 中

1502
00:55:57,596 --> 0:55:59,396
这样你可以很容易地

1503
00:55:59,396 --> 0:56:01,876
在你的 App 中建立双向通信

1504
00:55:59,396 --> 0:56:01,876
在你的 App 中建立双向通信

1505
00:56:02,436 --> 0:56:05,996
在 iOS 13 中我们对 App 的

1506
00:56:05,996 --> 0:56:08,486
移动性进行了大量的改进

1507
00:56:08,636 --> 0:56:11,306
这样你就可以获得

1508
00:56:11,306 --> 0:56:14,746
与使用高级的 API 一样的益处

1509
00:56:15,816 --> 0:56:18,796
那么 今天下午晚些时候

1510
00:56:18,796 --> 0:56:20,446
我们将会进行网络 

1511
00:56:20,446 --> 0:56:21,346
专场的第二部分

1512
00:56:21,836 --> 0:56:23,216
我们会看到更令人兴奋的

1513
00:56:23,216 --> 0:56:26,016
给你的 App 带来益处的新的 API

1514
00:56:26,836 --> 0:56:28,216
明天 对于那些

1515
00:56:28,216 --> 0:56:30,496
正在 macOS 上开发的人

1516
00:56:30,906 --> 0:56:32,466
网络扩展上我们有新的 API

1517
00:56:32,466 --> 0:56:35,046
我们也在早上 9 点有答疑会

1518
00:56:35,046 --> 0:56:36,636
明天早上 9 点开始

1519
00:56:36,636 --> 0:56:38,016
你可以届时前来

1520
00:56:38,016 --> 0:56:39,626
向我们提出问题

1521
00:56:40,086 --> 0:56:41,586
我们很高兴能够

1522
00:56:41,586 --> 0:56:44,006
帮你解决问题

1523
00:56:44,286 --> 0:56:45,676
那么 就到这里吧

1524
00:56:45,776 --> 0:56:50,516
希望你们喜欢今天的内容 谢谢大家

1525
00:56:51,508 --> 0:56:53,508
[掌声]
