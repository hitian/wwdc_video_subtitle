1
00:00:06,039 --> 0:00:09,910
（字体管理和文本大小）

2
00:00:16,015 --> 0:00:18,285
早上好 我是

3
00:00:18,352 --> 0:00:20,087
我是键入工程团队的主管

4
00:00:20,320 --> 0:00:22,623
今天很高兴能来这里与大家分享

5
00:00:22,756 --> 0:00:27,027
我们在iOS中

6
00:00:28,262 --> 0:00:30,397
我们今天的议程很满

7
00:00:31,131 --> 0:00:35,769
一开始我要讲用于你app中的一些

8
00:00:37,504 --> 0:00:40,174
然后接着讲如何创建app

9
00:00:40,240 --> 0:00:43,443
使字体在全系统内可用

10
00:00:43,744 --> 0:00:47,214
以及如何使app访问那些

11
00:00:48,215 --> 0:00:52,219
然后我们讲app选择字体的新机制

12
00:00:53,253 --> 0:00:57,457
最后讲一些文本缩放注意事项

13
00:00:57,824 --> 0:01:01,161
你可能会在把你的iPad app

14
00:00:57,824 --> 0:01:01,161
你可能会在把你的iPad app

15
00:01:02,462 --> 0:01:03,430
让我们开始讲吧

16
00:01:04,063 --> 0:01:06,834
我们在所有新版本中

17
00:01:07,034 --> 0:01:08,302
提供三种新的系统字体

18
00:01:09,102 --> 0:01:11,471
第一种是一种圆角系统字体

19
00:01:11,772 --> 0:01:14,007
你可以在这里看到

20
00:01:14,074 --> 0:01:17,044
Reminders app最顶部

21
00:01:18,679 --> 0:01:21,515
还有一种衬线系统字体

22
00:01:21,982 --> 0:01:26,453
你可以在这里看到它在

23
00:01:27,621 --> 0:01:30,524
最后还有一种单间距系统字体

24
00:01:30,791 --> 0:01:33,894
你之前可能在Swift Playground中

25
00:01:34,494 --> 0:01:37,731
我鼓励你参考

26
00:01:37,998 --> 0:01:40,734
了解如何在你的app UI中

27
00:01:40,901 --> 0:01:42,436
最好地使用这些系统字体

28
00:01:43,804 --> 0:01:48,509
你可以通过UIFontDescriptor中的

29
00:01:49,209 --> 0:01:51,245
我们为你定义了四个新常量

30
00:01:51,745 --> 0:01:55,682
第一个也是默认常量

31
00:01:55,749 --> 0:01:58,118
这些年来你们一直都在用

32
00:01:58,418 --> 0:02:00,087
然后我们给每个新添加的系统字体

33
00:01:58,418 --> 0:02:00,087
然后我们给每个新添加的系统字体

34
00:02:00,153 --> 0:02:03,123
都定义了一个常量

35
00:02:04,124 --> 0:02:07,194
你可以通过一个叫做withDesign的

36
00:02:07,494 --> 0:02:09,395
这个新方法用于转换字体描述符

37
00:02:09,463 --> 0:02:12,232
从一个设计转换到另一个设计

38
00:02:13,200 --> 0:02:14,401
用起来很简单

39
00:02:14,668 --> 0:02:15,903
从字体描述符开始

40
00:02:15,969 --> 0:02:17,838
在这个例子中 我们从已经实例化的

41
00:02:18,105 --> 0:02:21,542
粗体系统字体中

42
00:02:22,109 --> 0:02:26,046
然后我们要做的就是

43
00:02:26,246 --> 0:02:30,784
我们用圆角常量

44
00:02:31,084 --> 0:02:35,522
如果成功 我们就可以实例化

45
00:02:35,889 --> 0:02:40,060
请注意 我们使用了高层级的API

46
00:02:40,294 --> 0:02:43,564
我们没有通过使用它的名称

47
00:02:44,097 --> 0:02:45,699
那是我们的下一个话题

48
00:02:46,800 --> 0:02:48,635
我们已经注意到许多app

49
00:02:49,203 --> 0:02:52,272
至今仍然按名称实例化系统字体

50
00:02:52,906 --> 0:02:56,310
我们以前强烈反对你们这样做

51
00:02:56,844 --> 0:02:59,112
那么从新版本开始

52
00:02:59,613 --> 0:03:01,949
任何诸如此类的字体实例化

53
00:02:59,613 --> 0:03:01,949
任何诸如此类的字体实例化

54
00:03:02,216 --> 0:03:05,953
你需要使用高层级的系统调用

55
00:03:06,019 --> 0:03:07,955
来实例化此种字体

56
00:03:08,355 --> 0:03:11,058
你知道你正在按名称实例化系统字体

57
00:03:11,491 --> 0:03:14,428
因为如果你看一下你传给它的名称

58
00:03:14,528 --> 0:03:17,497
如果它以点为开端 那你就正在使用

59
00:03:17,564 --> 0:03:19,900
一个Apple私有名称

60
00:03:20,601 --> 0:03:23,270
现在按名称实例化字体

61
00:03:23,770 --> 0:03:26,807
这是你如何在app中

62
00:03:27,241 --> 0:03:30,310
以及如果你解析文档 这就是你如何

63
00:03:30,911 --> 0:03:32,846
实例化文档所需要的字体的方式

64
00:03:33,447 --> 0:03:35,749
现在我们还注意到许多app

65
00:03:36,283 --> 0:03:39,586
没有恰当地处理

66
00:03:40,921 --> 0:03:42,623
有时候它们会发生崩溃 原因就是

67
00:03:42,689 --> 0:03:46,793
因为他们实际上并没有查看

68
00:03:46,860 --> 0:03:48,629
他们假定实例化总是会成功

69
00:03:49,396 --> 0:03:52,366
因为我们修改了OS中的某些字体

70
00:03:52,733 --> 0:03:56,570
或我们从OS中移除了某些字体

71
00:03:56,637 --> 0:03:58,772
因此 你不能假定

72
00:03:59,039 --> 0:04:01,875
会在另一个版本上存在

73
00:03:59,039 --> 0:04:01,875
会在另一个版本上存在

74
00:04:02,342 --> 0:04:05,412
你需要注意实例化的结果

75
00:04:05,479 --> 0:04:07,447
并在app中采取适当的行动

76
00:04:07,781 --> 0:04:10,150
如果必要的话用另一种字体替代

77
00:04:12,186 --> 0:04:15,856
那么我想把主题切换到我作为用户

78
00:04:15,923 --> 0:04:18,591
和作为字体开发人员

79
00:04:18,791 --> 0:04:21,428
即app可以在OS系统范围内

80
00:04:21,495 --> 0:04:23,564
安装字体的能力

81
00:04:25,165 --> 0:04:27,734
我们把这些app叫做

82
00:04:28,168 --> 0:04:31,572
从根本上说

83
00:04:31,805 --> 0:04:34,441
可以让字体在OS系统范围内

84
00:04:34,975 --> 0:04:39,279
与那些app一起 我们还创建了

85
00:04:39,813 --> 0:04:41,682
在这些UI设置中用户可以浏览

86
00:04:42,249 --> 0:04:43,817
app所安装的字体

87
00:04:44,017 --> 0:04:46,486
以及移除他们不再想使用的字体

88
00:04:47,621 --> 0:04:51,291
要创建一个这样的app

89
00:04:51,458 --> 0:04:53,160
第一 app必须包含

90
00:04:53,694 --> 0:04:56,730
第二 当app被提交到

91
00:04:56,897 --> 0:04:59,299
它需要同时提交

92
00:04:59,366 --> 0:05:01,635
app提供给OS的所有字体

93
00:04:59,366 --> 0:05:01,635
app提供给OS的所有字体

94
00:05:02,102 --> 0:05:05,539
这很重要

95
00:05:05,606 --> 0:05:07,841
或是资产目录的一部分

96
00:05:08,642 --> 0:05:13,080
关键点在于OS

97
00:05:14,014 --> 0:05:16,016
安装任何任意的字体

98
00:05:16,517 --> 0:05:19,720
因为你把字体提交到

99
00:05:19,887 --> 0:05:22,723
它的验证流程类似于

100
00:05:23,090 --> 0:05:24,758
我们在macOS中的

101
00:05:25,025 --> 0:05:26,059
我们要做的其中一件事是

102
00:05:26,126 --> 0:05:29,630
检查字体的格式的类型

103
00:05:30,030 --> 0:05:35,502
我们支持全部现代格式 ttf、

104
00:05:35,802 --> 0:05:38,639
我们不支持旧字体格式

105
00:05:38,705 --> 0:05:40,774
比如suitcase字体

106
00:05:42,943 --> 0:05:45,112
获取entitlement

107
00:05:45,312 --> 0:05:47,915
在Xcode中有一个新功能

108
00:05:48,515 --> 0:05:50,918
一旦你选择它 你将面临两个选项

109
00:05:52,052 --> 0:05:55,055
第一个选项是安装字体

110
00:05:55,489 --> 0:06:00,060
那会使app在全系统范围内

111
00:05:55,489 --> 0:06:00,060
那会使app在全系统范围内

112
00:06:00,794 --> 0:06:03,864
第二个选项是使用已安装的字体

113
00:06:04,264 --> 0:06:05,999
我们为什么需要这个选项？

114
00:06:06,333 --> 0:06:11,471
嗯 默认情况下app不能访问

115
00:06:11,905 --> 0:06:15,309
app需要通过选择

116
00:06:15,576 --> 0:06:17,211
从而可以查看那些已安装的字体

117
00:06:18,879 --> 0:06:24,551
现在这些app的客户或用户

118
00:06:24,785 --> 0:06:26,520
第一个就是

119
00:06:26,920 --> 0:06:30,357
app应该提供一个有意义的UI

120
00:06:30,958 --> 0:06:32,526
并移除字体

121
00:06:32,826 --> 0:06:34,595
这很有必要 因为在iOS中

122
00:06:34,661 --> 0:06:37,931
OS中没有像macOS中那样的

123
00:06:38,165 --> 0:06:39,466
能安装字体的app

124
00:06:41,001 --> 0:06:45,105
同时app应该响应系统字体

125
00:06:45,539 --> 0:06:46,940
原因是

126
00:06:47,007 --> 0:06:50,344
用户能从设置app中移除字体

127
00:06:50,677 --> 0:06:54,147
app应该注意用户何时移除了字体

128
00:06:54,982 --> 0:06:57,217
最后如果你有字体提供器app

129
00:06:57,284 --> 0:06:59,987
并计划为用户提供一大套字体

130
00:07:00,053 --> 0:07:02,523
一大套字体库

131
00:07:03,090 --> 0:07:05,759
我们强烈推荐你使用按需资源

132
00:07:05,826 --> 0:07:07,995
并把字体打包到一个资产目录中

133
00:07:08,662 --> 0:07:12,232
这是提交用户所需字体的一种

134
00:07:12,533 --> 0:07:14,501
因为用户只能下载

135
00:07:14,568 --> 0:07:16,103
他们实际上要使用的字体

136
00:07:16,170 --> 0:07:19,339
而不是下载一个巨大的字体库

137
00:07:19,473 --> 0:07:21,475
因为他们只使用少量字体

138
00:07:22,676 --> 0:07:27,414
让我们去演示机器那给你们演示

139
00:07:28,949 --> 0:07:32,252
假设用户已经从Store下载了

140
00:07:32,319 --> 0:07:35,522
一个浏览文档的app

141
00:07:35,956 --> 0:07:37,691
这就是一个浏览文档的app

142
00:07:37,758 --> 0:07:39,359
我把它叫做Font

143
00:07:40,060 --> 0:07:43,430
在左侧 它有一些能显示的文档

144
00:07:43,697 --> 0:07:46,266
在右侧 它仅显示文档内容

145
00:07:46,834 --> 0:07:48,502
让我们继续并重新加载这个文档

146
00:07:48,902 --> 0:07:50,204
请注意表单出来了

147
00:07:50,404 --> 0:07:52,139
这张表单并不是由app打开的

148
00:07:52,406 --> 0:07:53,841
而是由OS打开的

149
00:07:54,441 --> 0:07:59,346
之所以这样是因为它注意到

150
00:07:59,947 --> 0:08:03,250
而这三种字体在这个app上不可用

151
00:07:59,947 --> 0:08:03,250
而这三种字体在这个app上不可用

152
00:08:03,617 --> 0:08:07,821
因此这个app替换了字体

153
00:08:07,955 --> 0:08:10,624
以Helvetica字体

154
00:08:11,391 --> 0:08:13,126
那么用户所要做的就是

155
00:08:13,193 --> 0:08:15,996
尝试找到一个

156
00:08:16,063 --> 0:08:19,132
能在OS上使用那些字体的app

157
00:08:19,600 --> 0:08:22,569
假如他们已经从Store中

158
00:08:22,936 --> 0:08:24,471
我把它叫做Font

159
00:08:24,671 --> 0:08:27,341
在左侧 它有一套我可以使用的字体

160
00:08:27,407 --> 0:08:30,410
在右侧 它显示了字体的简单的预览

161
00:08:30,611 --> 0:08:32,479
让我们继续并注册所有字体

162
00:08:32,779 --> 0:08:34,515
请再次注意 这个表单出来了

163
00:08:34,847 --> 0:08:36,149
它不是由app打开的

164
00:08:36,216 --> 0:08:37,484
它是由OS打开的

165
00:08:37,784 --> 0:08:41,321
这很有必要

166
00:08:41,388 --> 0:08:44,825
app以用户名义悄悄地安装字体

167
00:08:45,058 --> 0:08:47,227
必须经过用户准许

168
00:08:47,461 --> 0:08:49,062
这也就是这个对话框的功能

169
00:08:49,496 --> 0:08:51,431
那么让我们继续并准许

170
00:08:52,666 --> 0:08:54,134
请注意UI

171
00:08:54,201 --> 0:08:56,403
所有字体名称从红色变成了黑色

172
00:08:56,537 --> 0:08:59,706
app以这种简单的方式来表明

173
00:08:59,940 --> 0:09:01,542
让我们确保它们已经注册成功了

174
00:08:59,940 --> 0:09:01,542
让我们确保它们已经注册成功了

175
00:09:01,909 --> 0:09:06,413
我现在可以进入设置app

176
00:09:06,547 --> 0:09:07,648
在这里有一个新设置

177
00:09:08,282 --> 0:09:11,351
有字体提供器app所提供的

178
00:09:12,152 --> 0:09:14,721
我们看到了Font

179
00:09:14,888 --> 0:09:16,290
我可以浏览其中一种字体

180
00:09:16,690 --> 0:09:17,724
Century Schoolbook

181
00:09:18,392 --> 0:09:20,861
你可以在这里查看

182
00:09:21,528 --> 0:09:25,098
我现在就要尝试移除这个字体

183
00:09:26,633 --> 0:09:27,568
我要继续并移除它

184
00:09:28,035 --> 0:09:29,803
我要移除Century Schoolbook

185
00:09:30,003 --> 0:09:31,805
现在它已经从列表中去掉了

186
00:09:31,905 --> 0:09:34,374
现在我希望我的app

187
00:09:35,008 --> 0:09:37,144
能注意到字体已被移除

188
00:09:37,611 --> 0:09:39,279
确实 它现在以红色显示那种字体了

189
00:09:39,346 --> 0:09:42,816
因为它监听了字体变更通知

190
00:09:43,250 --> 0:09:45,786
我们继续并注册所有字体

191
00:09:47,521 --> 0:09:50,023
我要返回到Font

192
00:09:50,824 --> 0:09:54,595
我现在看到文档已经不再

193
00:09:54,795 --> 0:09:57,631
它实际上也监听了字体变更通知

194
00:09:57,965 --> 0:10:01,268
请注意所有字体现在都可用了

195
00:09:57,965 --> 0:10:01,268
请注意所有字体现在都可用了

196
00:10:01,935 --> 0:10:05,405
如果我查看其它文档 我看到它们

197
00:10:05,506 --> 0:10:09,343
它们用Font Provider

198
00:10:10,511 --> 0:10:12,946
现在让我在代码中给你演示

199
00:10:13,413 --> 0:10:15,482
如何创建一个这样的app

200
00:10:16,817 --> 0:10:21,355
在CoreText中 特别是在

201
00:10:21,421 --> 0:10:23,590
我们引入了一套全新的API

202
00:10:24,057 --> 0:10:26,994
所有新引入的API

203
00:10:27,561 --> 0:10:29,830
注册字体有三种新方式

204
00:10:30,330 --> 0:10:34,835
其中一种是通过使用

205
00:10:35,536 --> 0:10:38,972
还有一种方式是你可以通过使用

206
00:10:39,540 --> 0:10:41,842
最后一种是你可以注册

207
00:10:42,309 --> 0:10:44,311
存在于资产目录中的字体

208
00:10:44,378 --> 0:10:48,115
如果你有一大套字体库

209
00:10:48,448 --> 0:10:49,750
你可以创建一个资产目录

210
00:10:49,816 --> 0:10:52,986
并且你可以使用按需资源

211
00:10:53,453 --> 0:10:57,591
请注意最后一个API在你的种子中

212
00:10:57,824 --> 0:11:00,294
但它在下一个即将到来的种子中可用

213
00:10:57,824 --> 0:11:00,294
但它在下一个即将到来的种子中可用

214
00:11:02,763 --> 0:11:04,698
还有一个新API

215
00:11:04,831 --> 0:11:09,169
Font Provider app

216
00:11:10,737 --> 0:11:13,440
最后一个API

217
00:11:13,507 --> 0:11:15,876
查看用户安装了哪些字体

218
00:11:16,143 --> 0:11:18,111
你可以通过选择

219
00:11:18,178 --> 0:11:21,748
我之前给你展示过的使用字体的

220
00:11:22,683 --> 0:11:26,420
那么让我们看看这些API是如何

221
00:11:26,486 --> 0:11:27,921
让我们从Font

222
00:11:28,021 --> 0:11:30,424
它是个很简单的app

223
00:11:30,991 --> 0:11:33,760
你基本可以按家族注册字体

224
00:11:33,894 --> 0:11:35,929
那么我们要做的就是

225
00:11:35,996 --> 0:11:37,664
以及指向它们的URL

226
00:11:38,131 --> 0:11:41,768
一旦我们准备好了

227
00:11:42,236 --> 0:11:44,571
然后必要时更新UI

228
00:11:45,205 --> 0:11:47,541
让我们从查看更新UI的代码开始

229
00:11:48,942 --> 0:11:51,078
请注意Font

230
00:11:51,144 --> 0:11:52,246
和Font

231
00:11:52,412 --> 0:11:55,115
都利用了字体通知来更新UI

232
00:11:55,382 --> 0:11:58,218
当我们在这个演示中注册字体时

233
00:11:58,819 --> 0:12:02,122
要监听这样一条通知非常简单

234
00:11:58,819 --> 0:12:02,122
要监听这样一条通知非常简单

235
00:12:03,290 --> 0:12:06,093
我们告诉通知服务中心

236
00:12:06,159 --> 0:12:10,564
观察KCTFontManager注册

237
00:12:10,631 --> 0:12:12,366
RegisterFontsChanged通知

238
00:12:13,634 --> 0:12:17,104
一旦我们在选择器中

239
00:12:17,204 --> 0:12:21,241
我们要做的就是更新已注册的字体

240
00:12:21,308 --> 0:12:23,076
我马上会给你展示相应的代码

241
00:12:23,410 --> 0:12:26,947
然后我们更新我们的UI 就像你在

242
00:12:27,247 --> 0:12:29,983
从根本上说

243
00:12:30,050 --> 0:12:32,753
以黑色显示名称

244
00:12:34,021 --> 0:12:35,122
要注册字体

245
00:12:35,422 --> 0:12:40,928
我们需要收集代表我们想要注册的

246
00:12:41,395 --> 0:12:45,165
并调用我们的新API

247
00:12:45,532 --> 0:12:48,769
我们传递一个字体URL列表

248
00:12:48,836 --> 0:12:50,838
一个叫做Persistent的

249
00:12:50,904 --> 0:12:55,542
这是iOS 13中的新功能

250
00:12:56,076 --> 0:12:59,046
同时在这个例子中 布尔型标志

251
00:12:59,479 --> 0:13:02,082
表示我们希望所有字体在OS上可见

252
00:12:59,479 --> 0:13:02,082
表示我们希望所有字体在OS上可见

253
00:13:02,816 --> 0:13:04,952
API获取一个闭包

254
00:13:05,285 --> 0:13:08,889
它需要闭包的原因是

255
00:13:09,256 --> 0:13:10,691
当你注册字体时

256
00:13:11,158 --> 0:13:12,659
如果发现报错的话

257
00:13:13,093 --> 0:13:17,931
将多次调用你的闭包

258
00:13:18,432 --> 0:13:20,133
当整个操作完成后

259
00:13:20,534 --> 0:13:22,970
闭包中的完成参数就被设为真

260
00:13:23,871 --> 0:13:27,374
对于这个演示来说 我在闭包中

261
00:13:27,474 --> 0:13:28,575
我只需要登录进去

262
00:13:28,742 --> 0:13:30,077
我不更新我的UI

263
00:13:30,711 --> 0:13:34,114
当我更新时 我使用

264
00:13:34,181 --> 0:13:35,315
来更新我的UI

265
00:13:35,782 --> 0:13:39,753
一旦我收到通知 我就调用这个方法

266
00:13:39,920 --> 0:13:41,788
我会直接调用新API

267
00:13:42,155 --> 0:13:44,658
CTFontManagerCopyRegister

268
00:13:44,958 --> 0:13:47,561
从而了解我的app

269
00:13:48,128 --> 0:13:49,930
一旦我得到了这个信息

270
00:13:49,997 --> 0:13:51,965
我只需记录字体描述符列表

271
00:13:52,299 --> 0:13:56,303
更新我的家族模型

272
00:13:57,070 --> 0:13:59,339
这个Font Consuming app

273
00:13:59,773 --> 0:14:02,709
它是个非常简单的app

274
00:13:59,773 --> 0:14:02,709
它是个非常简单的app

275
00:14:03,644 --> 0:14:06,914
这种解析文档的app的关键在于

276
00:14:07,781 --> 0:14:09,950
随着整个文档的解析

277
00:14:10,017 --> 0:14:12,586
你要找出哪些字体可以被实例化

278
00:14:12,653 --> 0:14:16,790
并保留一份列表

279
00:14:17,658 --> 0:14:20,727
可能会由于用户从未安装过字体

280
00:14:21,261 --> 0:14:24,565
或进程中尚不能使用该字体

281
00:14:25,032 --> 0:14:27,334
你实际上需要利用新API

282
00:14:27,401 --> 0:14:29,403
从OS中请求那些字体

283
00:14:29,970 --> 0:14:33,407
一旦拥有了字体 你就可以更新UI

284
00:14:33,907 --> 0:14:36,543
对于一个解析文档的app来说

285
00:14:36,610 --> 0:14:40,214
JSON是一种非常简单的

286
00:14:41,081 --> 0:14:44,852
它的功能是在每次运行时

287
00:14:44,952 --> 0:14:47,321
如果它不能实现

288
00:14:48,288 --> 0:14:49,923
但当它替代那种字体时

289
00:14:49,990 --> 0:14:51,992
它保留一份它不能执行实例化的

290
00:14:52,059 --> 0:14:53,427
所有字体名称的流动标签

291
00:14:54,261 --> 0:14:56,763
通过这些 现在我可以创建

292
00:14:56,897 --> 0:14:59,333
或一组字体描述符

293
00:14:59,833 --> 0:15:03,036
并把那个数组传给

294
00:14:59,833 --> 0:15:03,036
并把那个数组传给

295
00:15:03,704 --> 0:15:06,707
这个API的功能是注意或查看

296
00:15:06,773 --> 0:15:10,644
用户是否使用Font

297
00:15:10,777 --> 0:15:14,748
如果是 它会让字体

298
00:15:15,349 --> 0:15:17,050
如果有字体不能进行实例化

299
00:15:17,251 --> 0:15:20,954
那些字体将使用你之前看到过的

300
00:15:21,989 --> 0:15:23,757
API获取一个闭包

301
00:15:24,024 --> 0:15:27,227
对于这个app来说 对于可见文档

302
00:15:27,361 --> 0:15:31,899
我们只使用任意可用字体

303
00:15:32,533 --> 0:15:34,635
那么如你所见 对于app来说

304
00:15:34,701 --> 0:15:37,971
利用其它app提供的字体

305
00:15:39,640 --> 0:15:42,442
现在我要与你们分享一些注意事项

306
00:15:42,509 --> 0:15:44,678
对于字体提供器app来说非常重要

307
00:15:45,846 --> 0:15:51,752
首先字体提供器app不能操作

308
00:15:52,085 --> 0:15:55,088
比如它不能尝试注销

309
00:15:55,155 --> 0:15:57,858
其它字体提供器app已注册的字体

310
00:15:58,425 --> 0:16:02,229
类似地 字体提供器app不能覆盖

311
00:15:58,425 --> 0:16:02,229
类似地 字体提供器app不能覆盖

312
00:16:02,663 --> 0:16:05,032
其它字体提供器

313
00:16:05,199 --> 0:16:06,867
或已安装在系统中的字体

314
00:16:08,168 --> 0:16:11,238
OS有关于可以注册

315
00:16:11,738 --> 0:16:13,707
并没有固定的数量限制

316
00:16:14,007 --> 0:16:14,908
从根本上说

317
00:16:15,242 --> 0:16:17,344
取决于由不同的字体提供器

318
00:16:17,411 --> 0:16:18,979
所安装的字体类型

319
00:16:19,346 --> 0:16:22,816
每种字体都可以使用不同数量的资源

320
00:16:25,285 --> 0:16:28,722
以这种方式安装的字体

321
00:16:29,590 --> 0:16:33,260
从根本上说

322
00:16:33,527 --> 0:16:38,432
你的字体是显示指定字体的唯一方法

323
00:16:38,599 --> 0:16:41,735
它将不会自动替换并使用

324
00:16:42,169 --> 0:16:44,905
实质上唯一方法是指

325
00:16:44,972 --> 0:16:48,008
而使用这些字体的唯一方法

326
00:16:49,109 --> 0:16:53,614
最后字体提供器app

327
00:16:54,548 --> 0:16:58,619
意思是如果用户删除

328
00:16:58,886 --> 0:17:00,921
那些字体也会被移除

329
00:16:58,886 --> 0:17:00,921
那些字体也会被移除

330
00:17:01,255 --> 0:17:03,123
系统确实会警告用户

331
00:17:03,190 --> 0:17:05,959
表明他们正在尝试删除

332
00:17:06,260 --> 0:17:08,295
用户有机会退回

333
00:17:08,896 --> 0:17:11,098
这就是我要讲的全部内容

334
00:17:11,365 --> 0:17:13,433
但在我离开之前 我想与你们分享

335
00:17:13,500 --> 0:17:15,836
下面这个功能

336
00:17:16,403 --> 0:17:19,640
在OS中安装各种各样字体

337
00:17:19,705 --> 0:17:22,009
并且所有app都可以在某个时间点

338
00:17:22,309 --> 0:17:25,078
这对于创建优质内容来说至关重要

339
00:17:25,145 --> 0:17:26,847
通过这个功能

340
00:17:27,181 --> 0:17:30,184
我们就可以在平台上解锁

341
00:17:30,250 --> 0:17:31,718
特别是在iPad平台上

342
00:17:32,419 --> 0:17:34,188
我要邀请

343
00:17:34,721 --> 0:17:38,091
Eric Dudiak上台

344
00:17:38,325 --> 0:17:40,360
关于在OS中选择字体的一些新技巧

345
00:17:46,867 --> 0:17:48,268
大家好 谢谢Julio

346
00:17:48,902 --> 0:17:51,705
我是Erik Dudiak

347
00:17:52,606 --> 0:17:55,843
我们刚了解了

348
00:17:56,276 --> 0:17:58,645
但你的app可能还想使用那些字体

349
00:17:59,012 --> 0:18:01,281
那么让我们看一下如何允许用户

350
00:17:59,012 --> 0:18:01,281
那么让我们看一下如何允许用户

351
00:18:01,548 --> 0:18:04,418
选择并使用他们已安装的自定义字体

352
00:18:06,520 --> 0:18:08,555
app要做的第一件事可能是

353
00:18:08,622 --> 0:18:11,258
尝试在系统上枚举全部可用字体

354
00:18:11,325 --> 0:18:13,227
并呈现给用户

355
00:18:13,594 --> 0:18:16,029
然后允许用户选择其中一种字体

356
00:18:16,897 --> 0:18:18,999
然而在系统上枚举全部字体

357
00:18:19,066 --> 0:18:21,602
只能提供内置字体的列表

358
00:18:21,668 --> 0:18:23,904
它不能显示任何自定义字体

359
00:18:24,838 --> 0:18:27,474
因为这没有考虑到隐私权

360
00:18:29,710 --> 0:18:32,779
那么相反 当你的app想允许用户

361
00:18:32,846 --> 0:18:35,249
选择他们已安装的其中一种字体时

362
00:18:35,816 --> 0:18:38,252
我们在UIKit中提供了一个

363
00:18:38,385 --> 0:18:41,121
即UIFontPickerViewController

364
00:18:43,223 --> 0:18:44,791
现在它可以以模态呈现

365
00:18:44,858 --> 0:18:46,760
并默认显示

366
00:18:46,827 --> 0:18:48,729
你在iOS 13中见过的新表单

367
00:18:49,596 --> 0:18:54,301
或者如果是带检查器的

368
00:18:54,368 --> 0:18:56,603
你可能想把它嵌在侧边栏中

369
00:18:56,670 --> 0:18:58,605
字体选择器也支持这个功能

370
00:19:02,376 --> 0:19:04,912
那么让我们看一下

371
00:19:05,779 --> 0:19:07,047
为了安全起见

372
00:19:07,114 --> 0:19:10,050
它完全在你的app进程之外运行

373
00:19:11,652 --> 0:19:15,055
默认情况下 它还将只显示内置字体

374
00:19:15,389 --> 0:19:19,259
你需用一个entitlement

375
00:19:21,495 --> 0:19:24,298
用户从字体选择器中选择一种字体后

376
00:19:24,631 --> 0:19:27,301
当前app中将可以使用这种字体

377
00:19:27,367 --> 0:19:29,436
通过常规的字体API实现

378
00:19:30,671 --> 0:19:35,042
然而 只有当用户选择它之后才可用

379
00:19:38,545 --> 0:19:40,714
因此 为了方便

380
00:19:40,781 --> 0:19:45,018
在UIFontPickerViewController上

381
00:19:47,454 --> 0:19:51,725
比如可能有app

382
00:19:52,025 --> 0:19:55,963
现在默认情况下

383
00:19:56,330 --> 0:19:59,867
这类似于比如Mail这样的app

384
00:20:00,400 --> 0:20:01,802
然而如果你有一个app

385
00:20:01,869 --> 0:20:04,104
它有理由显示不同字体的额外比重

386
00:20:04,171 --> 0:20:07,074
比如半粗体或中粗体

387
00:20:07,541 --> 0:20:10,744
你可以有选择地在字体选择器中

388
00:20:11,745 --> 0:20:13,447
此外 你的app要选择

389
00:20:13,514 --> 0:20:16,083
它是否获得

390
00:20:16,517 --> 0:20:18,285
或系统字体中所显示的

391
00:20:18,352 --> 0:20:21,321
每种字体的更默认的呈现

392
00:20:23,624 --> 0:20:26,226
现在 你的app可能还想筛选

393
00:20:26,293 --> 0:20:28,428
对用户可用的字体列表

394
00:20:28,996 --> 0:20:30,531
你有两种实现方式

395
00:20:31,665 --> 0:20:33,433
第一种 你可以按特征筛选

396
00:20:34,501 --> 0:20:37,704
如果你的app显示源代码 比如

397
00:20:37,771 --> 0:20:39,239
你可能只想查看

398
00:20:39,673 --> 0:20:42,342
或只想给用户显示单间距字体

399
00:20:42,543 --> 0:20:45,646
因为那样对于查看源代码来说

400
00:20:45,979 --> 0:20:49,183
在这里我们看到

401
00:20:52,186 --> 0:20:56,323
此外 你的app可能需要让字体

402
00:20:56,456 --> 0:20:59,793
从而在它所使用的情境中能讲得通

403
00:21:00,194 --> 0:21:02,663
为此我们提供一个

404
00:21:02,729 --> 0:21:04,464
允许你筛选字体所要支持的单一语种

405
00:21:04,531 --> 0:21:06,333
或几个语种的组合

406
00:21:06,600 --> 0:21:09,703
从而能呈现内容

407
00:21:10,470 --> 0:21:12,539
在这个例子中

408
00:21:12,606 --> 0:21:15,008
仅显示支持汉语的字体

409
00:21:19,046 --> 0:21:24,117
字体选择器还存在于macOS上

410
00:21:25,419 --> 0:21:27,921
如果你只呈现字体选择器

411
00:21:28,222 --> 0:21:30,524
而不是我们之前看到过的那个

412
00:21:30,791 --> 0:21:32,192
你将看到类似这样的东西

413
00:21:32,459 --> 0:21:34,294
一个更传统的Mac菜单

414
00:21:36,230 --> 0:21:37,931
为了控制

415
00:21:37,998 --> 0:21:40,033
这个菜单在你的app中

416
00:21:40,100 --> 0:21:42,870
因为它应该在用户刚点击过的按钮

417
00:21:43,437 --> 0:21:47,407
在视图控制器之外使用

418
00:21:47,774 --> 0:21:49,543
来选择用于呈现它的视图

419
00:21:51,278 --> 0:21:54,748
除此之外 使用菜单的语义学

420
00:21:55,349 --> 0:21:56,817
基本类似于视图控制器

421
00:21:59,186 --> 0:22:01,121
点击关闭菜单 比如说

422
00:21:59,186 --> 0:22:01,121
点击关闭菜单 比如说

423
00:22:01,188 --> 0:22:03,023
与遣散视图控制器相同

424
00:22:03,423 --> 0:22:05,826
当用户在菜单中

425
00:22:06,426 --> 0:22:08,562
它将自动发送委托API

426
00:22:08,629 --> 0:22:12,366
就像视图控制器通常会做的那样

427
00:22:14,668 --> 0:22:18,472
这是在macOS上围绕字体选择

428
00:22:18,539 --> 0:22:20,941
从而你的app感觉就像是

429
00:22:21,008 --> 0:22:23,177
用户期待在常规Mac app上

430
00:22:26,280 --> 0:22:29,616
当然 macOS

431
00:22:30,350 --> 0:22:33,720
以一种macOS

432
00:22:34,888 --> 0:22:37,925
运行在macOS上的

433
00:22:38,325 --> 0:22:41,295
它甚至包含在菜单栏的默认选项内

434
00:22:41,562 --> 0:22:43,897
因此 用户可以在任意时间

435
00:22:44,131 --> 0:22:48,001
并在你的app运行的任意时间内

436
00:22:51,872 --> 0:22:55,876
现在你还可以通过程序

437
00:22:56,410 --> 0:22:59,847
并且你可以通过

438
00:23:00,314 --> 0:23:02,683
你可以在那查看当前是否显示面板

439
00:23:02,950 --> 0:23:05,586
并手动打开或关闭它的呈现

440
00:23:08,856 --> 0:23:11,859
由于字体面板的非模态本质

441
00:23:12,526 --> 0:23:15,295
当你的app在macOS上运行时

442
00:23:15,362 --> 0:23:17,030
有一些注意事项

443
00:23:17,865 --> 0:23:21,969
来自字体面板的变更

444
00:23:22,970 --> 0:23:26,707
当使用标准UIKit控制时

445
00:23:27,641 --> 0:23:30,577
通过UITextFormattingCoordinator

446
00:23:31,144 --> 0:23:34,014
事实上 共享的

447
00:23:34,081 --> 0:23:37,885
甚至可以被用作我们之前看到过的

448
00:23:38,085 --> 0:23:42,256
因此你还可以通过响应器链

449
00:23:43,724 --> 0:23:46,693
然而 如果你的app中

450
00:23:47,461 --> 0:23:48,295
你可能需要采用

451
00:23:48,362 --> 0:23:51,331
一些新

452
00:23:51,431 --> 0:23:53,967
协议方法 以便当字体通过字体面板

453
00:23:54,401 --> 0:23:56,670
发生变更时收到通知

454
00:23:57,971 --> 0:24:01,842
这将允许你的自定义响应器

455
00:23:57,971 --> 0:24:01,842
这将允许你的自定义响应器

456
00:24:04,912 --> 0:24:07,848
现在让我们快速看一个演示

457
00:24:14,521 --> 0:24:16,790
很棒 这是Font Consuming app

458
00:24:17,524 --> 0:24:19,660
在这里我们看到

459
00:24:20,294 --> 0:24:21,862
但这个app的一个很棒的功能是

460
00:24:21,929 --> 0:24:25,499
它还让客户选择他们想看到的字体

461
00:24:25,766 --> 0:24:27,568
而不仅仅是显示字体

462
00:24:27,868 --> 0:24:29,603
我们可以随时修改文档字体

463
00:24:30,204 --> 0:24:33,207
我只需要按这个修改标题按钮即可

464
00:24:34,441 --> 0:24:38,178
我按下这个按钮时

465
00:24:39,279 --> 0:24:41,849
我得到了一个

466
00:24:41,915 --> 0:24:45,285
我还可以进行搜索并扫描

467
00:24:47,120 --> 0:24:51,525
现在我们已经把它自定义为

468
00:24:51,859 --> 0:24:54,127
因此我可以看到

469
00:24:54,695 --> 0:24:58,398
我要扫描它并找到我想要的那种字体

470
00:24:59,266 --> 0:25:00,167
让我们看一下

471
00:24:59,266 --> 0:25:00,167
让我们看一下

472
00:25:00,601 --> 0:25:01,602
让我们使用Papyrus字体

473
00:25:02,603 --> 0:25:05,138
太棒了 我可以像那样修改标题

474
00:25:06,406 --> 0:25:08,475
并且你可以在任意app中

475
00:25:08,542 --> 0:25:12,479
提供很棒的标准控制

476
00:25:13,914 --> 0:25:16,783
当然 当然 因为这是一款

477
00:25:16,850 --> 0:25:18,585
我们还可以把它引入到macOS上

478
00:25:19,753 --> 0:25:20,621
在这里我们可以看到

479
00:25:21,021 --> 0:25:24,892
这与我刚在iPadOS上展示的

480
00:25:25,158 --> 0:25:26,960
现在它运行在macOS上

481
00:25:28,228 --> 0:25:29,930
现在因为我们没有太多地自定义

482
00:25:29,997 --> 0:25:34,001
如何呈现标题菜单的字体选择器

483
00:25:34,568 --> 0:25:36,870
如果我继续并按下同一个按钮

484
00:25:37,104 --> 0:25:39,606
而不修改app的任何代码

485
00:25:40,107 --> 0:25:43,410
我们可以看到它没有显示

486
00:25:43,477 --> 0:25:46,747
所看到的字体选择器ViewController

487
00:25:47,848 --> 0:25:49,983
在那个菜单中 我仍能得到许多

488
00:25:50,050 --> 0:25:52,953
与iPadOS上运行字体选择器时

489
00:25:53,020 --> 0:25:54,321
我仍能在顶部看到Recents

490
00:25:54,721 --> 0:25:56,757
并且我仍能选择单个face

491
00:25:57,157 --> 0:25:59,493
我也仍能得到那个

492
00:25:59,560 --> 0:26:02,796
从而我能很好地了解我所选择的字体

493
00:25:59,560 --> 0:26:02,796
从而我能很好地了解我所选择的字体

494
00:26:03,530 --> 0:26:05,966
在这个例子中 我要继续并选择

495
00:26:08,735 --> 0:26:10,971
现在我们已经在app中实现了

496
00:26:11,271 --> 0:26:12,639
当在macOS上运行时的一些

497
00:26:12,973 --> 0:26:15,209
因为我们可以使用字体面板了

498
00:26:15,676 --> 0:26:18,312
我们可以继续并更新这里的正文

499
00:26:18,679 --> 0:26:19,947
从而响应

500
00:26:20,013 --> 0:26:21,915
来自字体面板中的任意变更

501
00:26:22,816 --> 0:26:26,186
我们实现这个功能之后

502
00:26:26,753 --> 0:26:28,422
在macOS上运行时

503
00:26:28,655 --> 0:26:31,091
而是显示字体面板

504
00:26:32,526 --> 0:26:34,394
这可以让我们做一些额外自定义

505
00:26:35,262 --> 0:26:38,198
我可以像在字体选择器中所做的那样

506
00:26:38,999 --> 0:26:42,135
但在macOS上 我还可以在这里

507
00:26:42,636 --> 0:26:46,206
我可以修改 比如说文本大小

508
00:26:48,742 --> 0:26:51,712
这在macOS上提供了一种

509
00:26:51,778 --> 0:26:54,481
这种体验是多年以来用户所习惯的

510
00:26:56,483 --> 0:26:58,018
太棒了 这是我们的示例app

511
00:26:58,085 --> 0:27:00,654
让我们看一下

512
00:26:58,085 --> 0:27:00,654
让我们看一下

513
00:27:06,426 --> 0:27:08,795
首先让我们看一下

514
00:27:09,196 --> 0:27:12,599
首先第一步是给它创建一个配置

515
00:27:13,333 --> 0:27:15,636
在这个例子中 我们实例化配置对象

516
00:27:16,103 --> 0:27:19,640
并告诉它当我们显示字体选择器时

517
00:27:21,775 --> 0:27:23,110
设置好配置之后

518
00:27:23,477 --> 0:27:26,613
我们现在可以创建字体选择器

519
00:27:27,414 --> 0:27:30,217
配置将决定字体选择器

520
00:27:30,284 --> 0:27:32,219
在它的整个生命周期中的行为

521
00:27:33,554 --> 0:27:36,323
我们还把我们自己设为

522
00:27:36,590 --> 0:27:38,959
从而当用户选择字体时

523
00:27:40,961 --> 0:27:43,463
最后我们只需要呈现字体选择器即可

524
00:27:43,530 --> 0:27:45,132
就像我们呈现其它视图控制器一样

525
00:27:49,036 --> 0:27:50,504
现在 在委托回调中

526
00:27:50,838 --> 0:27:53,607
我们看到我们可以获得

527
00:27:53,841 --> 0:27:56,443
用户直接从字体选择器中

528
00:27:57,177 --> 0:27:59,913
在这里我们看到当用户

529
00:28:00,681 --> 0:28:01,715
在这个例子中

530
00:28:01,782 --> 0:28:04,651
我们把用户所选择的字体

531
00:28:04,985 --> 0:28:07,988
并把它发送给你app中的一个

532
00:28:09,790 --> 0:28:11,825
当然 如果用户取消选择字体

533
00:28:11,892 --> 0:28:13,193
我们也会收到通知

534
00:28:13,260 --> 0:28:16,630
因此我们可以针对取消

535
00:28:19,666 --> 0:28:21,802
最后让我们看一下自定义响应器代码

536
00:28:21,902 --> 0:28:25,172
这是当在macOS上运行时

537
00:28:25,706 --> 0:28:28,108
在这个例子中 我们实施了一个方法

538
00:28:28,942 --> 0:28:32,980
它让我们了解用户何时更改了

539
00:28:33,046 --> 0:28:33,981
我们应该使用的属性

540
00:28:34,815 --> 0:28:37,351
我们不仅仅是获得

541
00:28:37,417 --> 0:28:39,086
我们实际上会得到这个便利的闭包

542
00:28:39,620 --> 0:28:42,155
它包含我们当前所拥有的一组属性

543
00:28:42,456 --> 0:28:44,358
并在用户做出修改之后

544
00:28:44,525 --> 0:28:46,860
传出应该传出的一组属性

545
00:28:47,594 --> 0:28:49,830
这么做的原因是

546
00:28:49,897 --> 0:28:51,832
根据用户所做的修改

547
00:28:51,899 --> 0:28:53,367
当前属性可能会保持相同

548
00:28:53,867 --> 0:28:56,270
比如 如果当前设置了下划线

549
00:28:57,104 --> 0:28:59,940
那么用户修改文本的前景颜色

550
00:29:00,207 --> 0:29:01,708
不应该改变下划线效果

551
00:29:02,209 --> 0:29:06,547
在这个例子中

552
00:29:10,417 --> 0:29:12,886
让我们快速回顾一下字体选择

553
00:29:13,887 --> 0:29:16,356
当我们想要显示用户字体时

554
00:29:17,157 --> 0:29:21,395
甚至macOS上有一个新视图控制器

555
00:29:21,595 --> 0:29:26,266
而不是在系统上枚举所有的字体

556
00:29:27,334 --> 0:29:31,572
此外 在macOS上运行

557
00:29:32,239 --> 0:29:33,941
其中涉及一些额外的注意事项

558
00:29:34,775 --> 0:29:37,578
因为自定义响应器可能需要处理

559
00:29:37,644 --> 0:29:39,880
app运行时

560
00:29:41,248 --> 0:29:43,450
标准文本视图将自动处理这个问题

561
00:29:45,452 --> 0:29:47,221
现在我想邀请Donna上台来

562
00:29:47,721 --> 0:29:50,858
她会讲Apple跨平台文本缩放

563
00:29:55,929 --> 0:29:56,830
谢谢Eric

564
00:30:00,167 --> 0:30:02,469
文本缩放是我们在iOS 13

565
00:30:02,803 --> 0:30:05,239
和macOS Catalina中

566
00:30:05,606 --> 0:30:08,242
今天我们要讲如何使用这个新概念

567
00:30:08,308 --> 0:30:10,310
来确保app中的文本尺寸

568
00:30:10,477 --> 0:30:11,812
处处保持一致

569
00:30:13,714 --> 0:30:15,048
现在作为iOS开发人员

570
00:30:15,215 --> 0:30:17,718
你很可能非常熟悉人机界面指南

571
00:30:18,452 --> 0:30:21,255
这是指南中的一个表

572
00:30:21,321 --> 0:30:22,890
它显示了默认动态排版的文本尺寸

573
00:30:23,857 --> 0:30:27,961
UIKit app中的大多数文本

574
00:30:29,863 --> 0:30:31,365
在iPad上看起来是这样的

575
00:30:31,765 --> 0:30:32,933
读起来很容易 对吗？

576
00:30:35,802 --> 0:30:38,372
你再看看Mac上

577
00:30:38,672 --> 0:30:40,107
看起来有那么点不一样

578
00:30:42,042 --> 0:30:43,544
当你把这两个并排放在一起时

579
00:30:43,777 --> 0:30:45,179
你可以看到通过对比

580
00:30:45,445 --> 0:30:48,315
Mac上的17点文本看起来大一些

581
00:30:50,884 --> 0:30:52,419
那是因为在Mac上

582
00:30:52,753 --> 0:30:54,988
我们更习惯于较小的默认文本尺寸

583
00:30:55,289 --> 0:30:56,990
接近13点

584
00:30:59,092 --> 0:31:01,261
但如果我们把同样的13点文本

585
00:30:59,092 --> 0:31:01,261
但如果我们把同样的13点文本

586
00:31:01,762 --> 0:31:03,096
放在iPad上看

587
00:31:04,831 --> 0:31:07,167
它看起来很小 读起来很费劲

588
00:31:07,835 --> 0:31:10,470
这种不一致已经存在很长时间了

589
00:31:11,138 --> 0:31:15,709
我们选择17点作为iOS中

590
00:31:15,943 --> 0:31:19,780
从而使文本易读并易于在触摸屏幕上

591
00:31:21,415 --> 0:31:22,449
但随着技术的进步

592
00:31:22,749 --> 0:31:25,819
跨平台用户体验变得越来越重要了

593
00:31:26,720 --> 0:31:28,689
现在你可以把你的iPad app

594
00:31:29,122 --> 0:31:31,158
用户一定会注意到

595
00:31:31,258 --> 0:31:33,794
当你在Mac上同时运行

596
00:31:34,261 --> 0:31:38,432
当在app之间复制和粘贴文本时

597
00:31:40,167 --> 0:31:43,604
我们要如何让文本尺寸

598
00:31:44,238 --> 0:31:48,008
理想情况是 如果我们正在浏览

599
00:31:48,408 --> 0:31:49,843
我们希望它看起来类似这样

600
00:31:50,477 --> 0:31:52,613
可视缩放适合每个平台

601
00:31:52,980 --> 0:31:55,148
这里其实有两种不同的可视缩放

602
00:31:56,750 --> 0:31:59,186
一种是用于iOS

603
00:31:59,419 --> 0:32:01,221
默认尺寸为17点

604
00:31:59,419 --> 0:32:01,221
默认尺寸为17点

605
00:32:01,622 --> 0:32:03,590
我们把它叫做iOS文本缩放

606
00:32:05,692 --> 0:32:08,795
然后还有用于macOS和其它

607
00:32:09,029 --> 0:32:11,331
默认尺寸接近于13点

608
00:32:11,698 --> 0:32:13,333
我们把这个叫做标准文本缩放

609
00:32:15,002 --> 0:32:18,639
我们希望你们作为开发人员

610
00:32:19,139 --> 0:32:22,676
并恰当地使用标准文本缩放

611
00:32:22,910 --> 0:32:24,645
如果它能改善跨平台用户体验的话

612
00:32:25,212 --> 0:32:27,281
现在让我们看一些例子

613
00:32:29,183 --> 0:32:31,084
首先是Mac上的iPad app

614
00:32:33,220 --> 0:32:35,789
因为UITextViews是选择

615
00:32:36,123 --> 0:32:37,624
显示大量文本的控件

616
00:32:37,925 --> 0:32:39,993
你最可能在这里注意到其中的差异

617
00:32:40,894 --> 0:32:43,130
我们想为你提供一种简单的解决方式

618
00:32:45,399 --> 0:32:48,402
因此在iOS 13中

619
00:32:48,735 --> 0:32:50,671
叫做usesStandardTextScaling

620
00:32:51,038 --> 0:32:52,105
打开它时

621
00:32:52,472 --> 0:32:55,475
UIKit将在文本视图内

622
00:32:55,542 --> 0:32:56,510
自动调整文本的渲染

623
00:32:56,577 --> 0:32:57,945
以匹配标准文本缩放

624
00:32:59,713 --> 0:33:00,881
让我们返回到这里的文本

625
00:32:59,713 --> 0:33:00,881
让我们返回到这里的文本

626
00:33:01,515 --> 0:33:03,584
我们可以看到缩放看起来稍微

627
00:33:04,484 --> 0:33:07,321
让我们看一下打开

628
00:33:10,424 --> 0:33:11,792
啊 看起来好多了

629
00:33:12,993 --> 0:33:15,829
使用这个新属性的确是一个

630
00:33:15,996 --> 0:33:18,565
确保文本

631
00:33:20,434 --> 0:33:24,238
但请注意usesStandardTextScaling

632
00:33:24,838 --> 0:33:27,841
那是因为在文本视图上

633
00:33:27,908 --> 0:33:30,511
可能没有预见到当与这个属性

634
00:33:31,311 --> 0:33:33,046
因此如果你想使用标准文本缩放

635
00:33:33,146 --> 0:33:35,315
请确保你给每个文本视图

636
00:33:37,384 --> 0:33:39,786
接下来我们讲复制粘贴的文本缩放

637
00:33:40,787 --> 0:33:42,890
现在因为iOS使用独特的文本缩放

638
00:33:43,190 --> 0:33:45,058
你可能注意到这个可视尺寸差异了

639
00:33:45,125 --> 0:33:48,161
当在UIKit和AppKit app之间

640
00:33:48,629 --> 0:33:50,364
如果你曾用过通用剪贴板

641
00:33:50,430 --> 0:33:52,065
你实际上可能早就注意到这个问题了

642
00:33:53,467 --> 0:33:56,303
嗯 好消息是你现在实际上不需要

643
00:33:57,304 --> 0:33:58,405
从最新版OS开始

644
00:33:58,472 --> 0:34:01,341
你可以免费使用

645
00:33:58,472 --> 0:34:01,341
你可以免费使用

646
00:34:02,743 --> 0:34:04,144
让我们看一下它是如何运作的

647
00:34:04,578 --> 0:34:05,846
这是两个平台

648
00:34:06,146 --> 0:34:08,382
左侧是iOS 右侧是macOS

649
00:34:10,117 --> 0:34:11,385
在每个平台上

650
00:34:11,685 --> 0:34:15,188
复制和粘贴都在系统的两个

651
00:34:15,656 --> 0:34:18,058
这里的小跑步者代表运行时层

652
00:34:18,458 --> 0:34:20,928
而这些磁盘代表持久层

653
00:34:22,963 --> 0:34:26,766
运行时层中文本视图中的文本

654
00:34:27,467 --> 0:34:28,668
当你复制那段文本时

655
00:34:29,036 --> 0:34:31,271
它从运行时层的文本视图中移出来

656
00:34:31,538 --> 0:34:33,172
并进入持久层的粘贴板中

657
00:34:33,639 --> 0:34:37,511
并且把它序列化为富文本格式或叫做

658
00:34:39,847 --> 0:34:40,947
在最新版OS上

659
00:34:41,047 --> 0:34:44,418
我们给属性化字符串API添加了

660
00:34:44,952 --> 0:34:47,888
因此当你从属性化字符串中

661
00:34:48,121 --> 0:34:51,358
它将添加表示它所使用的

662
00:34:53,193 --> 0:34:55,429
现在当在iOS上复制文本时

663
00:34:55,562 --> 0:34:57,865
文本会用那个元数据进行自动标记

664
00:34:57,931 --> 0:35:00,234
这个表示它使用了iOS文本缩放

665
00:34:57,931 --> 0:35:00,234
这个表示它使用了iOS文本缩放

666
00:35:03,504 --> 0:35:05,072
现在我们还在属性化字符串上

667
00:35:05,138 --> 0:35:07,674
给RTF读取API

668
00:35:08,542 --> 0:35:10,978
因此当你从RTF

669
00:35:11,311 --> 0:35:13,313
系统将查找那个文本缩放元数据

670
00:35:13,580 --> 0:35:16,116
如果需要 它会替你调整文本尺寸

671
00:35:18,218 --> 0:35:21,221
返回到我们的原始文本中

672
00:35:21,655 --> 0:35:22,823
当我们把它粘贴到Mac上时

673
00:35:23,090 --> 0:35:26,760
系统看到元数据表明

674
00:35:27,294 --> 0:35:30,364
然后系统会在属性字符串中

675
00:35:30,631 --> 0:35:32,666
从而当文本在Mac上显示时

676
00:35:32,933 --> 0:35:36,236
它看起来

677
00:35:38,505 --> 0:35:41,475
最终结果跟之前的这个例子

678
00:35:42,342 --> 0:35:43,877
但字体尺寸不一样

679
00:35:44,945 --> 0:35:48,515
我们在iOS上复制的原始文本尺寸

680
00:35:49,783 --> 0:35:52,986
而我们在Mac上粘贴的文本尺寸

681
00:35:55,088 --> 0:35:57,624
两个平台上拥有不同的字体尺寸

682
00:35:57,691 --> 0:35:58,992
对于复制和粘贴来说已经没问题了

683
00:35:59,293 --> 0:36:01,228
因为字体尺寸信息是临时信息

684
00:35:59,293 --> 0:36:01,228
因为字体尺寸信息是临时信息

685
00:36:01,628 --> 0:36:03,297
它只存在于运行时层中

686
00:36:04,198 --> 0:36:07,467
但RTF也是一种文档格式

687
00:36:07,534 --> 0:36:09,002
这对于存储层的持久性来说

688
00:36:10,838 --> 0:36:12,406
这是我们的最后一种情况

689
00:36:12,673 --> 0:36:14,908
用于文档互换的文本缩放

690
00:36:16,643 --> 0:36:19,079
我们在这里权衡特殊考虑

691
00:36:19,313 --> 0:36:21,648
从而平衡跨平台视觉一致性的渴望

692
00:36:22,783 --> 0:36:24,985
与在文档模型完整性的需要

693
00:36:27,354 --> 0:36:29,690
为了让文本在不同平台上看起来一样

694
00:36:29,857 --> 0:36:31,959
同时也在文档中保持同样的文本尺寸

695
00:36:32,292 --> 0:36:36,163
我们所需要的其实就是浏览文档时

696
00:36:36,663 --> 0:36:38,232
并在保存它时使用另一种文本缩放

697
00:36:40,267 --> 0:36:42,269
我们有两种不同的实现方式

698
00:36:42,636 --> 0:36:43,971
我们可以修改文档模型

699
00:36:44,037 --> 0:36:46,340
并对浏览和保存使用不同的文本尺寸

700
00:36:47,007 --> 0:36:50,544
或者我们可以通过修改渲染缩放

701
00:36:50,878 --> 0:36:52,779
并在保存时保持相同的文本尺寸

702
00:36:54,515 --> 0:36:57,117
我们实际上对RTF

703
00:36:57,518 --> 0:37:00,120
因为这是我们内部常用的格式

704
00:36:57,518 --> 0:37:00,120
因为这是我们内部常用的格式

705
00:37:01,021 --> 0:37:02,356
我希望与你分享

706
00:37:02,422 --> 0:37:04,424
我们为了实现这个功能

707
00:37:04,691 --> 0:37:06,260
从而你可以采用其中一些技巧

708
00:37:06,460 --> 0:37:07,928
在你自己的流程和文档格式中

709
00:37:08,061 --> 0:37:10,197
创建文本缩放支持

710
00:37:12,099 --> 0:37:14,701
我们所做的第一件事是

711
00:37:14,868 --> 0:37:17,037
从而用那个文本缩放元数据标记文档

712
00:37:17,638 --> 0:37:20,240
文档解析器和浏览器需要这个信息

713
00:37:20,307 --> 0:37:22,809
来理解文档正在使用哪种文本缩放

714
00:37:24,811 --> 0:37:27,481
因为早已存在的文档

715
00:37:27,548 --> 0:37:29,716
我们还需要把它们迁移出来

716
00:37:30,551 --> 0:37:32,686
对于RTF 这个过程是自动发生的

717
00:37:32,786 --> 0:37:34,821
当文档在最新版OS上保存时

718
00:37:37,424 --> 0:37:38,992
现在我们还需要确保

719
00:37:39,159 --> 0:37:41,962
我们的文档拥有与之相匹配的

720
00:37:42,362 --> 0:37:44,865
这对于初始迁移来说尤其重要

721
00:37:45,732 --> 0:37:48,035
因此 我们引入了一个新的

722
00:37:48,101 --> 0:37:50,537
以新文档属性形式提供帮助

723
00:37:52,806 --> 0:37:54,975
现在你可以使用文本缩放文档属性

724
00:37:55,042 --> 0:37:57,010
在保存时设置文档中的元数据

725
00:37:57,477 --> 0:38:00,214
使用属性化字符串编写API

726
00:37:57,477 --> 0:38:00,214
使用属性化字符串编写API

727
00:38:02,049 --> 0:38:04,184
如果需要 当你保存文档时

728
00:38:04,251 --> 0:38:06,053
特定的文本缩放格式

729
00:38:06,653 --> 0:38:09,556
你可以通过

730
00:38:12,326 --> 0:38:13,560
对于基于模型的方法

731
00:38:13,627 --> 0:38:15,329
我们需要一种能控制当打开文档时

732
00:38:15,395 --> 0:38:17,431
不同文本缩放格式之间的转换的方式

733
00:38:17,998 --> 0:38:21,435
为此我们引入了更多的

734
00:38:21,835 --> 0:38:24,771
还有用于目标和源文本缩放的

735
00:38:26,440 --> 0:38:28,408
并且你可以控制使用哪种文本缩放

736
00:38:28,742 --> 0:38:32,045
通过在从RTF文档中

737
00:38:32,212 --> 0:38:33,313
指定这些读取选项实现

738
00:38:35,549 --> 0:38:37,184
最后对于基于视图的方法

739
00:38:37,251 --> 0:38:39,353
我们推荐使用标准文本缩放

740
00:38:40,187 --> 0:38:43,257
现在对于RTF文档

741
00:38:43,624 --> 0:38:45,893
当你把RTF读取到一个

742
00:38:45,959 --> 0:38:48,395
你首先把目标文本缩放设置为标准

743
00:38:49,596 --> 0:38:52,099
然后在文本视图上设置

744
00:38:52,165 --> 0:38:54,201
它会显示文档

745
00:38:56,370 --> 0:38:57,404
哦 好的

746
00:38:57,804 --> 0:38:59,106
我们今天讲了很多内容

747
00:38:59,640 --> 0:39:01,275
现在作为一个提醒

748
00:38:59,640 --> 0:39:01,275
现在作为一个提醒

749
00:39:01,942 --> 0:39:04,344
iOS app现在可以使字体

750
00:39:05,078 --> 0:39:07,648
仅对非系统字体使用名称实例化

751
00:39:08,248 --> 0:39:11,218
请记住 名称实例化并不保险

752
00:39:12,219 --> 0:39:14,621
请使用按需资源向OS提交字体

753
00:39:14,888 --> 0:39:18,258
请使用标准文本缩放

754
00:39:19,860 --> 0:39:22,129
请参加几个小时后的

755
00:39:22,262 --> 0:39:24,398
你可以了解与我们今天在这里

756
00:39:24,898 --> 0:39:27,568
你还可以在iPad app

757
00:39:27,734 --> 0:39:29,436
并了解关于文本缩放的更多信息

758
00:39:30,470 --> 0:39:33,307
我们真的非常期待你们用这些新功能

759
00:39:33,640 --> 0:39:35,242
谢谢 祝你们享受余下的会议时光
