1
00:00:00,506 --> 0:00:04,516
[音乐]

2
00:00:05,116 --> 0:00:07,116
[掌声]

3
00:00:07,216 --> 0:00:07,966
&gt;&gt; 早上好

4
00:00:08,516 --> 0:00:10,806
[掌声]

5
00:00:11,306 --> 0:00:12,166
我是 Nick Gillett

6
00:00:12,256 --> 0:00:13,716
一名 Apple Core Data 团队的工程师

7
00:00:13,716 --> 0:00:15,246
欢迎大家来到

8
00:00:15,346 --> 0:00:18,556
Using Core Data with CloudKit 会议

9
00:00:19,496 --> 0:00:20,826
今天 我们要谈的是

10
00:00:20,826 --> 0:00:22,746
这样的一种想法

11
00:00:22,746 --> 0:00:24,326
我们想要数据随时可用

12
00:00:24,326 --> 0:00:26,036
不论我使用什么设备

13
00:00:26,066 --> 0:00:27,516
也不论我身处何方

14
00:00:28,166 --> 0:00:30,796
如果想要实现这种设想

15
00:00:30,796 --> 0:00:32,756
我们需要让

16
00:00:32,756 --> 0:00:34,286
添加该功能到你的 App 上这个步骤

17
00:00:34,286 --> 0:00:35,346
变得更加方便

18
00:00:36,096 --> 0:00:37,346
我相信今天在座的各位

19
00:00:37,346 --> 0:00:39,016
大多数都携带了 iPhone

20
00:00:39,016 --> 0:00:40,716
也许在家还有一台 Mac

21
00:00:41,176 --> 0:00:42,826
而此时此刻你的背包里

22
00:00:42,826 --> 0:00:44,506
或许还有一台 MacBook

23
00:00:44,506 --> 0:00:46,326
或者 MacBook Pro

24
00:00:46,906 --> 0:00:48,906
我们在这些设备上

25
00:00:48,906 --> 0:00:50,816
操作的所有数据

26
00:00:50,816 --> 0:00:52,976
都存储在本地上 对吧

27
00:00:52,976 --> 0:00:54,656
对于我们来说

28
00:00:54,656 --> 0:00:55,956
不用任何交互 把数据从一个设备上

29
00:00:55,956 --> 0:00:58,546
转移到另外一个设备 还是比较麻烦的

30
00:00:59,196 --> 0:01:01,306
现在为了解决这个问题

31
00:00:59,196 --> 0:01:01,306
现在为了解决这个问题

32
00:01:01,306 --> 0:01:03,066
我们想到了云存储

33
00:01:03,446 --> 0:01:05,266
因为它可以让我们

34
00:01:05,385 --> 0:01:06,756
把一个设备上的数据 

35
00:01:06,756 --> 0:01:08,556
无缝透明地

36
00:01:08,556 --> 0:01:10,096
转移到我们所拥有的

37
00:01:10,096 --> 0:01:11,496
其他设备上

38
00:01:12,076 --> 0:01:13,956
即使我们只有一台设备

39
00:01:13,956 --> 0:01:15,726
云存储也是非常好用的

40
00:01:15,726 --> 0:01:17,306
对吧

41
00:01:17,306 --> 0:01:18,986
当 App 在设备上产生数据

42
00:01:18,986 --> 0:01:22,466
它在云端备份并存储

43
00:01:22,966 --> 0:01:24,136
所以当我们主动或碰巧

44
00:01:24,136 --> 0:01:26,396
使用一台新的设备

45
00:01:26,396 --> 0:01:28,176
别问我是怎么知道的 

46
00:01:28,336 --> 0:01:30,326
在踏出商店之后

47
00:01:30,326 --> 0:01:32,026
这台新设备就能变成

48
00:01:32,026 --> 0:01:33,976
我们熟悉和深爱的那个

49
00:01:34,546 --> 0:01:36,316
这也许会让你感到惊讶

50
00:01:36,316 --> 0:01:37,406
现在我们平台上

51
00:01:37,406 --> 0:01:39,066
已经有一些技术

52
00:01:39,066 --> 0:01:40,556
可以帮助我们解决这个问题

53
00:01:40,556 --> 0:01:43,406
例如 Core Data 提供了

54
00:01:43,406 --> 0:01:44,936
一套健壮的 API

55
00:01:44,936 --> 0:01:46,526
在 App 和磁盘上

56
00:01:46,526 --> 0:01:48,766
管理本地数据

57
00:01:48,766 --> 0:01:51,666
而 CloudKit 框架可以访问

58
00:01:51,666 --> 0:01:53,246
世界上最大的

59
00:01:53,246 --> 0:01:54,026
分布式数据库之一

60
00:01:54,526 --> 0:01:57,976
这两个框架在 Apple 的所有平台上均可用

61
00:01:58,236 --> 0:02:00,106
正因如此 我们才能

62
00:01:58,236 --> 0:02:00,106
正因如此 我们才能

63
00:02:00,106 --> 0:02:02,526
创作出各种各样的 App

64
00:02:03,316 --> 0:02:04,806
事实上 这些框架

65
00:02:04,806 --> 0:02:06,116
其实很相似

66
00:02:06,666 --> 0:02:10,826
它们甚至用同一套模式和范例

67
00:02:11,276 --> 0:02:13,106
来根据对象 模型和存储

68
00:02:13,106 --> 0:02:15,646
对它们的 API 进行建模

69
00:02:16,346 --> 0:02:18,726
在 Core Data 我们把对象实例

70
00:02:18,726 --> 0:02:21,726
叫做 NSManagedObject

71
00:02:21,726 --> 0:02:23,096
它们可以让我们的 App

72
00:02:23,096 --> 0:02:25,926
访问存储在磁盘上的值

73
00:02:26,636 --> 0:02:28,956
相似的 CloudKit 利用

74
00:02:29,076 --> 0:02:31,086
类似键值对的 CKRecord 来实现

75
00:02:31,086 --> 0:02:32,606
可以访问你存储在

76
00:02:32,606 --> 0:02:34,166
云端的数据

77
00:02:35,036 --> 0:02:37,026
这些对象

78
00:02:37,026 --> 0:02:38,466
是用模型来描述的

79
00:02:38,906 --> 0:02:40,736
在 Core Data 我们把它叫做

80
00:02:40,796 --> 0:02:42,856
NSManagedObjectModel

81
00:02:42,856 --> 0:02:44,686
你可以使用代码

82
00:02:44,686 --> 0:02:46,106
或者是 Xcode 模型编辑器创作出来

83
00:02:46,926 --> 0:02:49,586
非常相似 CloudKit 使用的是 Schema

84
00:02:50,196 --> 0:02:51,696
CloudKit Schema

85
00:02:51,696 --> 0:02:53,096
可以在你使用 CKRecords 开发时

86
00:02:53,136 --> 0:02:55,626
由 CloudKit 动态定义

87
00:02:55,626 --> 0:02:59,056
或者使用 CloudKit 仪表盘定义

88
00:02:59,796 --> 0:03:01,776
最终 使用 Core Data

89
00:02:59,796 --> 0:03:01,776
最终 使用 Core Data

90
00:03:01,776 --> 0:03:03,686
将对象持久化

91
00:03:04,116 --> 0:03:05,856
这也是我们称作的存储

92
00:03:06,266 --> 0:03:07,906
在 Core Data 中叫做

93
00:03:07,906 --> 0:03:09,396
NSPersistentStore 实例

94
00:03:09,756 --> 0:03:12,436
但是在 CloudKit 里

95
00:03:12,436 --> 0:03:15,146
CKRecords 是储存在 CKRecordZone

96
00:03:15,246 --> 0:03:16,166
或者 CKDatabase 中的

97
00:03:16,866 --> 0:03:18,696
正如你们所见

98
00:03:18,696 --> 0:03:19,956
当然很多人也曾经

99
00:03:20,076 --> 0:03:20,976
向我指出

100
00:03:20,976 --> 0:03:22,926
如果我们可以

101
00:03:22,926 --> 0:03:24,786
把两个相似机制的框架

102
00:03:24,786 --> 0:03:26,416
结合的过程变得简单

103
00:03:26,416 --> 0:03:27,106
那就再好不过了

104
00:03:27,776 --> 0:03:29,216
为了给你们展示

105
00:03:29,276 --> 0:03:30,436
我们这些年的成果

106
00:03:30,436 --> 0:03:31,586
我将带领你们看一下

107
00:03:31,626 --> 0:03:32,996
在 Xcode 中

108
00:03:32,996 --> 0:03:34,996
制作一款新 App 是什么感受

109
00:03:35,296 --> 0:03:37,766
大家请看 我打开 Xcode

110
00:03:38,176 --> 0:03:39,666
我要制作一款

111
00:03:39,786 --> 0:03:42,926
Master-Detail App 模版的 iOS 项目

112
00:03:43,416 --> 0:03:44,356
我喜欢 Master-Detail App

113
00:03:44,356 --> 0:03:45,636
是因为它给我们

114
00:03:45,636 --> 0:03:47,646
提供了很棒的 UI

115
00:03:47,646 --> 0:03:49,596
可以在探索 Core Data 功能时使用

116
00:03:50,086 --> 0:03:51,896
所以我选择它 然后点按 Next

117
00:03:51,896 --> 0:03:54,956
给我的 App 命名

118
00:03:55,186 --> 0:03:57,436
此情此景 就叫 WWDC Demo 吧

119
00:03:58,106 --> 0:03:59,476
然后 因为我们是来了解

120
00:03:59,476 --> 0:04:01,246
Core Data

121
00:03:59,476 --> 0:04:01,246
Core Data

122
00:04:01,246 --> 0:04:02,546
我们需要打开它的复选框

123
00:04:03,066 --> 0:04:05,176
在 Xcode 11 里面 

124
00:04:05,176 --> 0:04:06,346
它叫做 Use CloudKit

125
00:04:06,826 --> 0:04:08,346
这一步是告诉 Xcode

126
00:04:08,346 --> 0:04:09,746
我们想要制作一款 App

127
00:04:09,746 --> 0:04:11,336
而它需要同时用到

128
00:04:11,336 --> 0:04:12,646
Core Data 和 CloudKit

129
00:04:12,806 --> 0:04:14,876
那么让我们选中

130
00:04:14,876 --> 0:04:16,536
然后我们点按 Next

131
00:04:16,536 --> 0:04:18,676
设置 App 在文件系统中的存储位置

132
00:04:19,676 --> 0:04:21,495
当我们点按 Create

133
00:04:21,495 --> 0:04:23,196
Xcode 就为我们生成了 App

134
00:04:23,396 --> 0:04:24,716
如果你之前已经构建过

135
00:04:24,716 --> 0:04:26,246
使用 CloudKit 的 App

136
00:04:26,806 --> 0:04:27,716
那么你就知道

137
00:04:27,716 --> 0:04:29,266
在它准备构建运行之前

138
00:04:29,266 --> 0:04:30,866
我们还需要

139
00:04:30,866 --> 0:04:31,986
添加一些其他的东西

140
00:04:32,476 --> 0:04:35,606
这些额外的功能要在

141
00:04:35,606 --> 0:04:37,226
Signing & Capabilities 标签中添加

142
00:04:37,766 --> 0:04:38,786
我们需要加上这两个

143
00:04:39,396 --> 0:04:41,516
第一个是 iCloud 功能

144
00:04:41,706 --> 0:04:42,936
所以我点按

145
00:04:42,936 --> 0:04:43,776
Capability 旁边的 + 号 

146
00:04:43,776 --> 0:04:46,556
输入 iCloud 然后点按回车键

147
00:04:47,256 --> 0:04:49,706
当我做这一步的时候

148
00:04:49,706 --> 0:04:51,436
我可以打开 CloudKit 的复选框

149
00:04:51,436 --> 0:04:52,486
你可以看到它还给我

150
00:04:52,486 --> 0:04:54,366
添加了 Push Notifications 复选框

151
00:04:54,856 --> 0:04:56,556
Xcode 也能自动

152
00:04:56,556 --> 0:05:01,056
为我的 App 创作 iCloud 容器标识符

153
00:04:56,556 --> 0:05:01,056
为我的 App 创作 iCloud 容器标识符

154
00:05:01,276 --> 0:05:03,926
下面 我们要添加后台模式功能

155
00:05:04,446 --> 0:05:05,396
为了添加功能

156
00:05:05,396 --> 0:05:06,636
再次点击 + 号

157
00:05:06,696 --> 0:05:07,726
输入 Background 再点按回车键

158
00:05:08,266 --> 0:05:09,616
我们这么做的原因是

159
00:05:09,616 --> 0:05:11,276
启用远程通知

160
00:05:11,276 --> 0:05:12,836
这样就可以使我们的 App

161
00:05:12,836 --> 0:05:14,756
在非运行状态

162
00:05:14,756 --> 0:05:15,506
接收推送通知

163
00:05:16,356 --> 0:05:18,086
那么 让我们运行这个 App

164
00:05:18,126 --> 0:05:20,316
看看效果如何

165
00:05:21,506 --> 0:05:22,706
现在你可以看到

166
00:05:22,706 --> 0:05:24,636
我们已经有了一个很简单的 App

167
00:05:24,636 --> 0:05:25,446
有两个视图控制器

168
00:05:25,556 --> 0:05:27,096
左侧是表格视图

169
00:05:27,096 --> 0:05:28,636
右侧是详情视图控制器

170
00:05:29,316 --> 0:05:30,836
现在我为 App 添加数据

171
00:05:30,836 --> 0:05:33,756
点按右上角的 + 号

172
00:05:34,286 --> 0:05:35,746
默认状态下 Xcode 会生成

173
00:05:35,746 --> 0:05:37,596
一个简单的 Core Data 模型

174
00:05:37,686 --> 0:05:39,766
仅仅是一个时间戳

175
00:05:40,506 --> 0:05:42,276
但是 我们可以看到

176
00:05:42,276 --> 0:05:43,806
同步功能是如何运行的

177
00:05:44,076 --> 0:05:46,636
这样我们就需要另外一个设备

178
00:05:46,766 --> 0:05:48,186
现在在我们的 iPhone

179
00:05:48,236 --> 0:05:48,816
上面运行这个 App

180
00:05:49,246 --> 0:05:50,516
你们可以看到 我们已经

181
00:05:50,516 --> 0:05:52,576
有了主视图控制器

182
00:05:52,576 --> 0:05:55,446
以及我们在 iPad 上添加的所有数据

183
00:05:55,976 --> 0:05:57,856
现在 让我们使用手机添加数据

184
00:05:58,376 --> 0:06:01,796
当然了 数据也会同步给 iPad

185
00:05:58,376 --> 0:06:01,796
当然了 数据也会同步给 iPad

186
00:06:02,306 --> 0:06:04,066
现在 因为我手中的遥控器

187
00:06:04,066 --> 0:06:05,596
有着神奇的推送功能

188
00:06:05,596 --> 0:06:07,496
任何时间我都可以进行推送

189
00:06:08,216 --> 0:06:09,566
现在让我们

190
00:06:09,566 --> 0:06:11,106
更真实一点

191
00:06:11,106 --> 0:06:13,156
我要删除所有

192
00:06:13,156 --> 0:06:14,336
从 iPhone 上面添加到

193
00:06:14,336 --> 0:06:17,016
我的 iPad 的数据

194
00:06:17,016 --> 0:06:18,206
只留下前四行

195
00:06:18,746 --> 0:06:20,346
然后 我要做相同的事

196
00:06:20,446 --> 0:06:22,146
在 iPhone 上删除所有

197
00:06:22,146 --> 0:06:24,476
从 iPad 导入的数据

198
00:06:25,326 --> 0:06:28,596
我之前使用了遥控器

199
00:06:28,816 --> 0:06:29,966
现在 我不会再去

200
00:06:29,966 --> 0:06:30,916
碰那个遥控器

201
00:06:31,056 --> 0:06:32,756
我就继续播放视频

202
00:06:32,756 --> 0:06:34,326
然后你们可以看到

203
00:06:34,326 --> 0:06:35,866
当我拍摄视频时

204
00:06:35,866 --> 0:06:40,796
这两个设备是如何同步数据的 对吧

205
00:06:41,806 --> 0:06:43,086
虽然看起来不太自然

206
00:06:43,146 --> 0:06:44,396
但很棒的是

207
00:06:44,396 --> 0:06:46,476
仅仅点按了几下

208
00:06:46,476 --> 0:06:47,936
我们就构建了一个 App

209
00:06:47,936 --> 0:06:49,896
使用 Core Data 和 CloudKit 端对端同步数据

210
00:06:50,486 --> 0:06:51,526
如果我不告诉你们

211
00:06:51,526 --> 0:06:52,666
AppDelegate 中实际上隐藏了

212
00:06:52,666 --> 0:06:54,236
15000 行代码 

213
00:06:54,286 --> 0:06:55,806
那就是我的不对了

214
00:06:56,366 --> 0:06:58,126
所以让我们看看这部分代码

215
00:06:59,836 --> 0:07:01,526
这是一个非常标准的

216
00:06:59,836 --> 0:07:01,526
这是一个非常标准的

217
00:07:01,526 --> 0:07:02,716
AppDelegate

218
00:07:02,806 --> 0:07:04,086
事实上 如果你以前

219
00:07:04,086 --> 0:07:05,496
用 Xcode 构建过

220
00:07:05,496 --> 0:07:07,326
Core Data App

221
00:07:07,326 --> 0:07:09,246
那你应该会非常熟悉 

222
00:07:09,246 --> 0:07:10,726
包括这部分

223
00:07:10,726 --> 0:07:11,766
设置 Core Data 堆栈的代码

224
00:07:12,166 --> 0:07:13,376
这个 App 唯一有些不同的地方

225
00:07:13,376 --> 0:07:16,676
就是今年 Core Data 里面的一个新 API

226
00:07:17,066 --> 0:07:19,086
叫做 NSPersistentCloudKitContainer

227
00:07:19,626 --> 0:07:20,786
它的设计目的就是为了帮助你

228
00:07:20,786 --> 0:07:22,266
来管理 CloudKit 数据库中 

229
00:07:22,266 --> 0:07:24,686
的 Core Data 存储

230
00:07:26,216 --> 0:07:28,236
现在 如果你之前

231
00:07:28,236 --> 0:07:29,626
就用 Xcode 做过 Core Data App

232
00:07:29,766 --> 0:07:31,556
那么你在此处看到的是

233
00:07:31,666 --> 0:07:33,216
NSPersistentContainer

234
00:07:33,216 --> 0:07:37,606
它是 NSPersistentCloudKitContainer 的父类

235
00:07:37,816 --> 0:07:41,086
正因如此 你可以只改一行代码 

236
00:07:41,086 --> 0:07:42,736
就给你现有的 Core Data App

237
00:07:42,786 --> 0:07:45,036
增加 CloudKit 功能

238
00:07:45,336 --> 0:07:46,716
所以到底什么是

239
00:07:46,866 --> 0:07:48,576
NSPersistentCloudKitContainer

240
00:07:49,426 --> 0:07:51,836
其实它是封装了

241
00:07:51,836 --> 0:07:53,466
一套非常常见的模版

242
00:07:53,466 --> 0:07:54,896
每个人都必须构建

243
00:07:54,986 --> 0:07:56,346
才能使用 CloudKit

244
00:07:56,346 --> 0:07:58,496
实现端对端同步

245
00:07:58,976 --> 0:08:00,316
它可以让你省去

246
00:07:58,976 --> 0:08:00,316
它可以让你省去

247
00:08:00,316 --> 0:08:02,296
成千上万行代码的麻烦

248
00:08:03,636 --> 0:08:05,276
它也是我们

249
00:08:05,276 --> 0:08:06,676
今后希望和你们共同完成

250
00:08:06,756 --> 0:08:08,656
不断迭代的基础

251
00:08:09,066 --> 0:08:11,436
当然了 为了实现这个目标

252
00:08:11,436 --> 0:08:13,596
说到重点了 我们需要你们的帮助

253
00:08:15,376 --> 0:08:17,206
我们现在需要你们的反馈

254
00:08:17,356 --> 0:08:18,696
比如 NSPersistentCloudKitContainer 效果如何

255
00:08:18,696 --> 0:08:20,696
还缺失什么功能

256
00:08:20,696 --> 0:08:22,246
亦或者在工作的过程中

257
00:08:22,246 --> 0:08:25,626
现有功能是否满足了你 App 的需求

258
00:08:25,856 --> 0:08:27,396
所以 让我再仔细介绍一下

259
00:08:27,666 --> 0:08:29,296
它的部分功能

260
00:08:30,266 --> 0:08:31,796
NSPersistentCloudKitContainer

261
00:08:31,796 --> 0:08:33,566
可以为你的 App 

262
00:08:33,566 --> 0:08:34,385
提供本地副本

263
00:08:34,806 --> 0:08:36,936
一个完全一致的

264
00:08:36,936 --> 0:08:38,126
Core Data 或者 CloudKit

265
00:08:38,155 --> 0:08:39,486
数据库镜像

266
00:08:40,265 --> 0:08:42,596
它还具备健壮的

267
00:08:42,596 --> 0:08:44,135
调度以及错误恢复事件循环

268
00:08:44,135 --> 0:08:45,076
因此你的 App

269
00:08:45,076 --> 0:08:46,116
完全不用担心

270
00:08:46,116 --> 0:08:47,716
任何运维方面的问题

271
00:08:47,886 --> 0:08:49,986
最后 它还有

272
00:08:49,986 --> 0:08:51,876
NSManagedObject 实例

273
00:08:51,916 --> 0:08:53,096
和 CKRecord 之间的

274
00:08:53,096 --> 0:08:55,636
转化功能

275
00:08:57,406 --> 0:09:00,236
现在本地副本非常重要

276
00:08:57,406 --> 0:09:00,236
现在本地副本非常重要

277
00:09:01,096 --> 0:09:02,056
但是这意味着

278
00:09:02,056 --> 0:09:03,676
当你的 App 处理对象时

279
00:09:03,866 --> 0:09:07,766
它会将其写入 Core Data 管理的本地存储文件中

280
00:09:08,256 --> 0:09:09,626
而且 它也会从本地存储文件中

281
00:09:09,626 --> 0:09:11,006
读取对象

282
00:09:11,006 --> 0:09:14,176
这是由于本地数据库

283
00:09:14,176 --> 0:09:18,056
与云存储的性能不太相同 对吧

284
00:09:18,536 --> 0:09:19,646
当我们谈到

285
00:09:19,646 --> 0:09:21,116
访问本地文件的延迟

286
00:09:21,116 --> 0:09:23,396
读取磁盘上的文件

287
00:09:23,396 --> 0:09:24,796
都是以毫秒为单位

288
00:09:24,796 --> 0:09:25,926
即使在最坏的情况下也是如此

289
00:09:26,126 --> 0:09:27,256
然而如果通过网络 

290
00:09:27,256 --> 0:09:28,806
可能会花上几秒甚至几分钟

291
00:09:28,806 --> 0:09:30,846
才能获取 App 所需的数据

292
00:09:31,496 --> 0:09:33,066
同样地 本地存储

293
00:09:33,066 --> 0:09:34,396
可以为你的 App 提供

294
00:09:34,396 --> 0:09:36,146
更高的带宽

295
00:09:36,146 --> 0:09:37,756
即使在我们的 iPhone 上面

296
00:09:37,756 --> 0:09:39,606
可以以 gb/s 为单位

297
00:09:40,096 --> 0:09:41,396
而云端的可用带宽

298
00:09:41,396 --> 0:09:45,116
被限制在 kb/s 或者 mb/s

299
00:09:46,316 --> 0:09:47,816
本地副本

300
00:09:47,816 --> 0:09:49,876
必然将增加

301
00:09:49,876 --> 0:09:51,926
程序的复杂性

302
00:09:51,926 --> 0:09:53,776
因此 NSPersistentCloudKitContainer

303
00:09:53,776 --> 0:09:55,536
需要一个健壮的调度和

304
00:09:55,536 --> 0:09:57,336
错误恢复事件循环

305
00:09:57,796 --> 0:09:59,136
所以当你的 App

306
00:09:59,136 --> 0:10:00,666
将数据写入本地存储时

307
00:09:59,136 --> 0:10:00,666
将数据写入本地存储时

308
00:10:01,116 --> 0:10:02,736
NSPersistentCloudKitContainer

309
00:10:02,736 --> 0:10:04,956
自动将这些内容上传到云

310
00:10:06,376 --> 0:10:08,846
当 CloudKit 上的内容发生变化

311
00:10:08,846 --> 0:10:10,336
NSPersistentCloudKitContainer

312
00:10:10,336 --> 0:10:11,816
就会在系统上调度工作

313
00:10:12,216 --> 0:10:14,086
将这些对象

314
00:10:14,086 --> 0:10:15,136
传输到你的本地数据库

315
00:10:15,136 --> 0:10:17,846
供你的 App 使用

316
00:10:18,776 --> 0:10:20,846
当然 在这个过程中

317
00:10:20,846 --> 0:10:22,546
你的对象需要

318
00:10:22,546 --> 0:10:24,116
被 NSPersistentCloudKitContainer

319
00:10:24,116 --> 0:10:26,426
从 NSManagedObject 实例 

320
00:10:26,426 --> 0:10:29,726
转变为 CKRecord 实例

321
00:10:30,736 --> 0:10:32,606
同样的 当有些内容

322
00:10:32,606 --> 0:10:34,016
在云上发生变化

323
00:10:34,016 --> 0:10:35,086
那些 CKRecord 实例

324
00:10:35,086 --> 0:10:37,106
就会作为 NSManagedObject 实例

325
00:10:37,196 --> 0:10:38,636
被存放在本地储存文件中

326
00:10:38,636 --> 0:10:41,726
这就是

327
00:10:41,726 --> 0:10:43,146
NSPersistentCloudKitContainer

328
00:10:43,246 --> 0:10:44,486
可以为你的 App 所做的事

329
00:10:44,856 --> 0:10:46,406
它就是一个

330
00:10:46,406 --> 0:10:47,676
CloudKit 的

331
00:10:47,676 --> 0:10:49,106
私人数据库本地副本

332
00:10:49,706 --> 0:10:53,116
你要知道我们制作了一个特定区域

333
00:10:53,406 --> 0:10:54,506
用于 Core Data 同步

334
00:10:55,096 --> 0:10:57,566
我们实现了自动调度

335
00:10:57,566 --> 0:10:58,876
因此你不用担心

336
00:10:58,876 --> 0:11:00,576
如何优化操作

337
00:10:58,876 --> 0:11:00,576
如何优化操作

338
00:11:00,576 --> 0:11:02,886
或在系统调度它们

339
00:11:03,356 --> 0:11:04,856
我认为更重要的是

340
00:11:04,916 --> 0:11:05,966
你无需担心

341
00:11:05,966 --> 0:11:07,436
在 App 中实现任何

342
00:11:07,436 --> 0:11:08,866
错误恢复逻辑问题

343
00:11:10,066 --> 0:11:11,956
最后 我们实现了

344
00:11:11,956 --> 0:11:12,986
从 NSManagedObject 到 CKRecord 的

345
00:11:12,986 --> 0:11:15,286
自动序列化

346
00:11:15,626 --> 0:11:17,106
并且我们是使用

347
00:11:17,106 --> 0:11:18,916
NSManagedObject 模型实现的

348
00:11:20,476 --> 0:11:24,256
如果我站在这里 告诉你们

349
00:11:24,256 --> 0:11:25,176
只要采用 NSPersistentCloudKitContainer

350
00:11:25,236 --> 0:11:26,916
你就将拥有一个

351
00:11:26,966 --> 0:11:28,066
功能齐全的 App

352
00:11:28,066 --> 0:11:29,616
那我就太愚蠢了

353
00:11:29,696 --> 0:11:33,026
所以我就想用剩下的时间谈一谈

354
00:11:33,026 --> 0:11:34,866
在 NSPersistentCloudKitContainer 的基础上

355
00:11:34,936 --> 0:11:36,486
可以做到什么

356
00:11:36,986 --> 0:11:38,216
我认为首先

357
00:11:38,266 --> 0:11:39,656
要从利用 Core Data

358
00:11:39,656 --> 0:11:40,886
制作优秀的 App 讲起

359
00:11:41,836 --> 0:11:43,356
然后 我们再看一看

360
00:11:43,356 --> 0:11:44,906
你如何能够扩展

361
00:11:44,906 --> 0:11:45,966
我们在 NSPersistentCloudKitContainer 

362
00:11:46,056 --> 0:11:48,026
中已经构建的基础

363
00:11:48,026 --> 0:11:49,496
以此来更精准地满足你的使用需求

364
00:11:50,746 --> 0:11:52,256
现在 对于我来说

365
00:11:52,256 --> 0:11:53,616
用 Core Data 来打造优秀的 App

366
00:11:54,066 --> 0:11:56,326
需要用足够的知识

367
00:11:56,846 --> 0:12:00,286
为此 我们今年已经写了

368
00:11:56,846 --> 0:12:00,286
为此 我们今年已经写了

369
00:12:00,286 --> 0:12:02,496
无数的文档来具体解释

370
00:12:02,496 --> 0:12:04,476
NSPersistentCloudKitContainer 如何工作

371
00:12:04,476 --> 0:12:05,806
以及如何将它融入到你的 App 中

372
00:12:07,376 --> 0:12:08,526
Core Data 有很多功能

373
00:12:08,526 --> 0:12:10,276
都可以搭配

374
00:12:10,276 --> 0:12:12,076
NSPersistentCloudKitContainer 使用

375
00:12:12,596 --> 0:12:14,776
比如 FetchResultsController

376
00:12:14,776 --> 0:12:16,376
它可以帮助你

377
00:12:16,376 --> 0:12:17,486
构建可扩展用户界面

378
00:12:17,486 --> 0:12:18,956
并由大量数据支持

379
00:12:19,796 --> 0:12:21,726
而查询生成则可以帮助你

380
00:12:21,726 --> 0:12:23,446
维护界面的稳定性

381
00:12:23,446 --> 0:12:24,966
在后台可能发生一些变化的时候

382
00:12:24,966 --> 0:12:26,436
不受影响

383
00:12:27,196 --> 0:12:29,776
比如来自 NSPersistentCloudKitContainer 的变化

384
00:12:30,846 --> 0:12:34,176
最后 还需要回溯到几年前

385
00:12:34,176 --> 0:12:35,506
我们曾经介绍过的内容

386
00:12:35,506 --> 0:12:36,956
帮助你理解

387
00:12:36,956 --> 0:12:37,576
数据库到底有了什么改变

388
00:12:37,956 --> 0:12:39,756
并且有了 NSPersistentCloudKitContainer

389
00:12:39,756 --> 0:12:41,486
你可以使用它来决定

390
00:12:41,486 --> 0:12:42,816
后台更新是否与

391
00:12:42,816 --> 0:12:46,146
你的用户正在做的事情有所关联

392
00:12:47,026 --> 0:12:48,216
我们将在星期三的下午三点

393
00:12:48,216 --> 0:12:51,326
对这些功能以及其他更多内容进行介绍

394
00:12:51,966 --> 0:12:55,216
与此同时

395
00:12:55,216 --> 0:12:56,776
我们今年还将推出

396
00:12:57,086 --> 0:12:59,566
一款全新的 App 样例

397
00:12:59,566 --> 0:13:00,306
让你们实际感受到

398
00:12:59,566 --> 0:13:00,306
让你们实际感受到

399
00:13:00,366 --> 0:13:01,846
NSPersistentCloudKitContainer

400
00:13:01,846 --> 0:13:03,816
和 Core Data 其他功能

401
00:13:03,816 --> 0:13:04,926
共同工作的优势所在

402
00:13:05,546 --> 0:13:07,016
它是用来管理

403
00:13:07,116 --> 0:13:07,746
帖子的一款 App

404
00:13:07,986 --> 0:13:09,506
而帖子是我们

405
00:13:09,506 --> 0:13:10,806
过去几年在 Core Data 中

406
00:13:10,806 --> 0:13:13,046
一直研究的主题 对吧

407
00:13:13,096 --> 0:13:14,536
它们是很棒的对象

408
00:13:14,536 --> 0:13:15,726
能让我们了解

409
00:13:15,876 --> 0:13:17,206
对象图的不同部分

410
00:13:17,206 --> 0:13:19,306
是如何受到 CloudKit 影响的

411
00:13:19,836 --> 0:13:21,186
在这里 你可以看到

412
00:13:21,186 --> 0:13:22,726
我们的数据模型非常简单 是吧

413
00:13:22,776 --> 0:13:24,046
我们有一个标题

414
00:13:24,046 --> 0:13:24,426
以及一些内容

415
00:13:24,426 --> 0:13:26,116
然后 我们还有一堆标签

416
00:13:26,116 --> 0:13:28,266
可以与每个帖子相关联

417
00:13:28,326 --> 0:13:29,606
这款 App 甚至可以

418
00:13:29,606 --> 0:13:31,016
让你看到 CloudKit

419
00:13:31,016 --> 0:13:32,156
是如何管理照片的

420
00:13:32,506 --> 0:13:35,746
App 允许你从设备的照片库

421
00:13:35,746 --> 0:13:39,716
附加文件至帖子

422
00:13:39,896 --> 0:13:43,586
现在 我们谈谈如何基于

423
00:13:42,376 --> 0:13:43,586
NSPersistentCloudKitContainer

424
00:13:43,656 --> 0:13:45,206
进行开发

425
00:13:45,696 --> 0:13:47,606
正如你们所期待的那样

426
00:13:47,606 --> 0:13:49,606
这一部分绝对是今天会议的重点

427
00:13:50,106 --> 0:13:51,236
但是你们也应该知道

428
00:13:51,236 --> 0:13:52,966
我们的文档其实包括

429
00:13:52,966 --> 0:13:55,486
我们今天所讲内容的更多细节

430
00:13:56,006 --> 0:13:57,776
所以不用担心

431
00:13:57,776 --> 0:13:58,676
会漏掉什么内容

432
00:13:58,796 --> 0:14:04,626
我们看到有很多客户用了不同的方法

433
00:13:58,796 --> 0:14:04,626
我们看到有很多客户用了不同的方法

434
00:14:04,786 --> 0:14:06,276
扩展 NSPersistentCloudKitContainer

435
00:14:06,876 --> 0:14:09,096
有的是从多个存储开始扩展

436
00:14:10,006 --> 0:14:11,916
还有的客户

437
00:14:11,916 --> 0:14:14,206
喜欢自定义 Schema

438
00:14:14,206 --> 0:14:16,586
并用于 CloudKit

439
00:14:16,616 --> 0:14:18,216
当然也用于 NSPersistentCloudKitContainer

440
00:14:18,826 --> 0:14:20,166
你们都知道

441
00:14:20,166 --> 0:14:21,756
因为 CloudKit

442
00:14:21,756 --> 0:14:23,446
在很多平台都是可用的

443
00:14:23,496 --> 0:14:25,436
不仅仅局限于 Apple

444
00:14:25,436 --> 0:14:27,056
还适用于 Web Services

445
00:14:27,056 --> 0:14:27,706
或者 JavaScript 

446
00:14:28,286 --> 0:14:29,466
所以你应该可以使用

447
00:14:29,526 --> 0:14:30,006
NSPersistentCloudKitContainer 对象

448
00:14:30,036 --> 0:14:33,366
即使不是在

449
00:14:33,366 --> 0:14:34,736
Apple 的平台上

450
00:14:35,686 --> 0:14:37,316
最后来看看

451
00:14:37,406 --> 0:14:39,146
协同数据建模

452
00:14:40,656 --> 0:14:42,176
现在 我们有很多理由

453
00:14:42,176 --> 0:14:45,486
在 App 中使用多存储文件

454
00:14:45,486 --> 0:14:48,126
尤其是处理网络存储时

455
00:14:48,816 --> 0:14:50,086
多存储文件能够帮助我们

456
00:14:50,186 --> 0:14:51,676
在 App 中

457
00:14:51,676 --> 0:14:53,636
为不同的用例隔离数据

458
00:14:54,206 --> 0:14:56,926
而且还能给我们

459
00:14:57,086 --> 0:14:59,786
提供不同类型的限制 对吧

460
00:14:59,786 --> 0:15:01,146
所以 如果我们想要

461
00:14:59,786 --> 0:15:01,146
所以 如果我们想要

462
00:15:01,146 --> 0:15:02,786
使用一个存储文件

463
00:15:02,786 --> 0:15:04,126
管理一组非常特殊的验证限制

464
00:15:04,126 --> 0:15:05,786
可能用于验证用户输入

465
00:15:05,786 --> 0:15:07,476
我们可以为此

466
00:15:07,476 --> 0:15:09,266
单独使用一个存储文件

467
00:15:10,766 --> 0:15:12,316
多存储文件也能够很好的

468
00:15:12,316 --> 0:15:15,856
来节流或合并设备上

469
00:15:15,856 --> 0:15:16,526
频繁写的数据

470
00:15:17,446 --> 0:15:18,586
当你从设备上读取的内容

471
00:15:18,586 --> 0:15:19,426
产生自设备本身 

472
00:15:19,426 --> 0:15:21,066
或者产生自

473
00:15:21,066 --> 0:15:22,556
创建数据的算法

474
00:15:22,556 --> 0:15:24,546
这种情况可能就会发生

475
00:15:25,206 --> 0:15:26,726
如果这个算法

476
00:15:26,726 --> 0:15:28,216
产生数据的速度很快

477
00:15:28,216 --> 0:15:29,866
那么持续同步到 CloudKit

478
00:15:29,866 --> 0:15:31,796
就会极其昂贵

479
00:15:32,406 --> 0:15:34,006
因此我们发现客户会嵌入

480
00:15:34,006 --> 0:15:36,136
另外的存储文件

481
00:15:36,136 --> 0:15:37,866
并使用它来合并数据

482
00:15:37,866 --> 0:15:41,366
直到做好分析的准备再上传至

483
00:15:41,366 --> 0:15:42,186
CloudKit

484
00:15:42,936 --> 0:15:46,316
为了向你们展示工作原理

485
00:15:46,316 --> 0:15:47,566
以及 Core Data 如何把这个过程

486
00:15:47,566 --> 0:15:49,186
变得更加简单 我们将利用

487
00:15:49,186 --> 0:15:50,316
NSManagedObjectModel 

488
00:15:50,346 --> 0:15:52,706
的一个名叫做配置的功能

489
00:15:53,366 --> 0:15:55,856
现在 你们可以看到

490
00:15:55,856 --> 0:15:56,656
我们的 App 示例

491
00:15:56,906 --> 0:15:58,626
XCode 模型编辑器里面的

492
00:15:58,626 --> 0:15:59,886
NSManagedObjectModel

493
00:16:00,526 --> 0:16:02,016
现在 假设我想

494
00:16:02,016 --> 0:16:04,396
在帖子中添加位置 对吧

495
00:16:04,396 --> 0:16:06,966
我想记录下

496
00:16:07,376 --> 0:16:08,476
帖子被创建时的位置

497
00:16:08,976 --> 0:16:12,716
位置可以由系统高速生成

498
00:16:12,716 --> 0:16:16,106
但我只有在帖子被创建时

499
00:16:16,106 --> 0:16:16,866
才需要当前的位置

500
00:16:16,966 --> 0:16:19,036
让我们将它们与

501
00:16:19,036 --> 0:16:20,036
数据模型的其余部分分开

502
00:16:21,416 --> 0:16:24,706
我将点按左下角 + 号

503
00:16:24,706 --> 0:16:26,496
添加新的实体

504
00:16:26,496 --> 0:16:28,156
存储我的位置信息

505
00:16:28,786 --> 0:16:30,796
现在 我的位置信息将非常简单

506
00:16:30,796 --> 0:16:34,036
它将只包括双精度的纬度和经度

507
00:16:34,036 --> 0:16:36,946
即 Core Location 框架中提供的信息

508
00:16:37,296 --> 0:16:38,546
当然 你也可以包括

509
00:16:38,546 --> 0:16:39,986
其他方面的信息 

510
00:16:39,986 --> 0:16:41,000
如海拔或精度

511
00:16:45,126 --> 0:16:46,336
现在 我们想将位置信息

512
00:16:46,336 --> 0:16:48,166
与我们其他的数据隔离

513
00:16:48,406 --> 0:16:50,006
为此 我将创建一个新的配置

514
00:16:50,006 --> 0:16:53,526
再次点击这个 + 号按钮

515
00:16:53,526 --> 0:16:55,496
但是这次 我将长按

516
00:16:55,496 --> 0:16:56,886
直到出现一个菜单

517
00:16:56,886 --> 0:16:58,036
可以让我添加配置

518
00:16:58,916 --> 0:17:00,106
我将此配置命名为

519
00:16:58,916 --> 0:17:00,106
我将此配置命名为

520
00:17:00,106 --> 0:17:01,946
Cloud 并且添加

521
00:17:01,946 --> 0:17:03,196
全部的四个

522
00:17:03,196 --> 0:17:05,165
需要同步的实体

523
00:17:06,036 --> 0:17:07,376
现在你们可以看到

524
00:17:07,376 --> 0:17:09,396
Cloud 配置中

525
00:17:09,396 --> 0:17:11,445
这些我想要与 CloudKit 同步的实体

526
00:17:12,076 --> 0:17:13,526
让我们创建一个新的配置

527
00:17:13,526 --> 0:17:14,915
叫做 Local

528
00:17:14,915 --> 0:17:15,886
用来储存我们的位置对象

529
00:17:22,566 --> 0:17:23,925
仅仅几行代码

530
00:17:24,026 --> 0:17:25,205
它就能为我们工作

531
00:17:25,205 --> 0:17:27,406
允许 Core Data

532
00:17:27,406 --> 0:17:28,986
自动告诉存储文件

533
00:17:28,986 --> 0:17:30,526
存储对象的类型

534
00:17:30,526 --> 0:17:32,506
第一行你可以看到我们创建了

535
00:17:32,506 --> 0:17:33,186
一个 NSPersistentCloudKitContainer 实例

536
00:17:33,186 --> 0:17:36,506
然后我们利用

537
00:17:36,506 --> 0:17:38,396
NSPersistentStoreDescription

538
00:17:38,896 --> 0:17:39,566
它可以告诉

539
00:17:39,566 --> 0:17:41,126
NSPersistentCloudKitContainer

540
00:17:41,126 --> 0:17:42,506
目前正在处理的

541
00:17:42,506 --> 0:17:43,196
储存类型

542
00:17:43,946 --> 0:17:45,036
我们创建的

543
00:17:45,036 --> 0:17:46,526
NSPersistentStoreDescription 实例

544
00:17:46,936 --> 0:17:48,296
指向 local.sqlite 文件

545
00:17:48,296 --> 0:17:51,056
作为储存位置信息的地方

546
00:17:51,526 --> 0:17:52,866
我们将其分配给

547
00:17:52,866 --> 0:17:55,286
刚才创建的本地配置

548
00:17:56,066 --> 0:17:57,856
然后 我们建立了自己的云存储

549
00:17:58,366 --> 0:18:00,346
同样 我们创建一个

550
00:17:58,366 --> 0:18:00,346
同样 我们创建一个

551
00:18:00,386 --> 0:18:03,706
NSPersistentStoreDescription 实例

552
00:18:03,706 --> 0:18:05,416
指向 cloud.sqlite

553
00:18:06,056 --> 0:18:08,786
然后给它刚才的云配置

554
00:18:08,786 --> 0:18:10,306
告诉 NSPersistentCloudKitContainer

555
00:18:10,306 --> 0:18:14,596
只有类似帖子标签还有附件

556
00:18:14,596 --> 0:18:16,906
图片这类内容才能在库中存储

557
00:18:17,936 --> 0:18:19,996
最后 我们为它分配

558
00:18:19,996 --> 0:18:23,706
NSPersistentCloudKitContainerOptions 的实例

559
00:18:23,706 --> 0:18:24,086
它可以告诉

560
00:18:24,226 --> 0:18:25,776
NSPersistentCloudKitContainer

561
00:18:25,916 --> 0:18:27,916
这个存储应该与什么

562
00:18:28,286 --> 0:18:29,776
iCloud 容器标识符同步

563
00:18:30,386 --> 0:18:32,336
最后我们分配

564
00:18:32,336 --> 0:18:33,736
这两个存储说明

565
00:18:33,736 --> 0:18:35,256
给 PersistentStoreDescription 的 

566
00:18:35,486 --> 0:18:37,866
NSPersistentCloudKitContainer 属性

567
00:18:38,886 --> 0:18:40,806
有了 NSPersistentCloudKitContainer 

568
00:18:40,806 --> 0:18:42,246
可以更好地利用它

569
00:18:42,946 --> 0:18:44,766
我们现在已经有了本地存储

570
00:18:44,766 --> 0:18:45,396
还有一个云存储

571
00:18:45,396 --> 0:18:47,066
如果我们想要

572
00:18:47,066 --> 0:18:48,666
在多个正在运行的 App 之间

573
00:18:48,666 --> 0:18:50,156
共享一些存储在

574
00:18:50,156 --> 0:18:50,676
CloudKit 的数据怎么办呢

575
00:18:51,226 --> 0:18:53,006
NSPersistentCloudKitContainer

576
00:18:53,006 --> 0:18:54,196
同样可以做到

577
00:18:54,856 --> 0:18:56,356
事实上因为你在

578
00:18:56,356 --> 0:18:57,876
使用 Core Data

579
00:18:57,946 --> 0:18:59,636
是非常容易就可以

580
00:18:59,636 --> 0:19:01,876
让你的 App 同时处理这些存储中的所有数据

581
00:18:59,636 --> 0:19:01,876
让你的 App 同时处理这些存储中的所有数据

582
00:19:02,456 --> 0:19:04,216
并且 Core Data

583
00:19:04,216 --> 0:19:05,556
还能自动帮助你处理

584
00:19:05,796 --> 0:19:07,186
写入数据

585
00:19:07,186 --> 0:19:09,196
自动插入到正确的存储文件里

586
00:19:10,476 --> 0:19:11,846
仅仅加了三行代码

587
00:19:11,916 --> 0:19:13,586
我们就能实现这个功能 对吧

588
00:19:13,586 --> 0:19:15,056
我们创建一个新的 StoreDescription

589
00:19:15,056 --> 0:19:16,266
然后指向我们分享的

590
00:19:16,266 --> 0:19:17,636
存储文件

591
00:19:17,636 --> 0:19:18,856
并且给它一个新配置

592
00:19:18,856 --> 0:19:20,046
命名为 Shared

593
00:19:20,736 --> 0:19:22,466
然后 我们给它分配

594
00:19:22,466 --> 0:19:23,846
NSPersistentCloudKitContainerOptions 实例

595
00:19:23,846 --> 0:19:25,546
它可以

596
00:19:25,546 --> 0:19:27,406
指定容器

597
00:19:27,406 --> 0:19:28,956
用于存储我们的共享数据

598
00:19:29,296 --> 0:19:32,696
现在是 iCloud.com.wwdc.shared

599
00:19:33,366 --> 0:19:34,626
当然 最后重要的一点

600
00:19:34,626 --> 0:19:36,776
我们将给它分配一个

601
00:19:36,776 --> 0:19:38,116
PersistentStoreDescriptions

602
00:19:38,486 --> 0:19:40,246
现在谈谈 Schema

603
00:19:41,036 --> 0:19:43,586
现在我想介绍

604
00:19:43,686 --> 0:19:44,956
关于 Schema 的

605
00:19:44,956 --> 0:19:46,436
几个重点

606
00:19:46,436 --> 0:19:48,486
是当你在读取 CloudKit 中

607
00:19:48,566 --> 0:19:49,686
创建的记录时

608
00:19:49,686 --> 0:19:50,576
你需要知道的东西

609
00:19:51,556 --> 0:19:54,736
我就从如何管理记录类型

610
00:19:54,736 --> 0:19:56,416
以及管理实体开始讲起

611
00:19:56,416 --> 0:19:58,776
这是你在 NSManagedObjectModel 创建的东西

612
00:19:59,466 --> 0:20:01,126
然后 我们将看看

613
00:19:59,466 --> 0:20:01,126
然后 我们将看看

614
00:20:01,126 --> 0:20:02,616
如何实现数据外化功能

615
00:20:02,616 --> 0:20:05,826
也就是使用

616
00:20:05,826 --> 0:20:07,566
NSPersistentCloudKitContainer

617
00:20:07,566 --> 0:20:08,626
将任意大的数据

618
00:20:08,656 --> 0:20:09,936
无缝存储在 CloudKit

619
00:20:10,436 --> 0:20:12,846
最后 我们将谈谈

620
00:20:12,846 --> 0:20:14,916
如何管理关系

621
00:20:14,916 --> 0:20:16,166
它可能与你曾经使用

622
00:20:16,166 --> 0:20:17,766
CloudKit 的经验有所不同

623
00:20:18,726 --> 0:20:22,526
我们将在 App 样例中

624
00:20:22,526 --> 0:20:23,596
使用 ManageObjectModel

625
00:20:23,966 --> 0:20:26,816
然后我将从 Post 实体开始讲起

626
00:20:27,356 --> 0:20:28,546
你可以看到它有两个属性

627
00:20:28,546 --> 0:20:30,746
标题字符串

628
00:20:30,746 --> 0:20:31,486
以及内容字符串

629
00:20:31,946 --> 0:20:33,066
而且它还有两个关系

630
00:20:33,066 --> 0:20:36,386
分别是对附件和标签实体

631
00:20:37,386 --> 0:20:39,206
Core Data 可以为你生成一个类

632
00:20:39,206 --> 0:20:40,906
在代码中使用

633
00:20:40,906 --> 0:20:42,586
作为 NSManagedObject 的子类

634
00:20:42,586 --> 0:20:43,596
看起来是这样的

635
00:20:44,216 --> 0:20:47,406
你可以看到所有的属性和关系

636
00:20:47,406 --> 0:20:49,756
都是在这个类中展示

637
00:20:49,756 --> 0:20:53,266
这是 CloudKit 中

638
00:20:53,266 --> 0:20:55,146
在帖子生成时创建的记录

639
00:20:55,936 --> 0:20:57,156
这些都是我用来

640
00:20:57,156 --> 0:20:58,326
填充记录的样例值

641
00:20:58,756 --> 0:21:02,496
使记录具体化

642
00:20:58,756 --> 0:21:02,496
使记录具体化

643
00:21:03,436 --> 0:21:04,836
现在 我还想与你们

644
00:21:04,836 --> 0:21:06,236
强调另外一些事情

645
00:21:06,716 --> 0:21:07,466
那就是记录 ID

646
00:21:07,996 --> 0:21:09,956
Core Data 有一个记录 ID

647
00:21:09,956 --> 0:21:11,286
对应在 CloudKit 中

648
00:21:11,286 --> 0:21:12,436
创建的每一个对象

649
00:21:12,866 --> 0:21:14,356
对于每一个对象

650
00:21:14,356 --> 0:21:16,836
都会生成一个简单的 UUID

651
00:21:16,836 --> 0:21:17,776
作为其记录的名称

652
00:21:18,336 --> 0:21:19,806
当这个记录名称与

653
00:21:19,806 --> 0:21:21,816
区域标识符合并之后

654
00:21:21,816 --> 0:21:22,806
你就得到了 CKRecord ID

655
00:21:23,076 --> 0:21:26,126
下面两行你看到的是

656
00:21:26,126 --> 0:21:28,156
Core Data 如何处理类型信息

657
00:21:28,826 --> 0:21:30,556
这里有两个比较

658
00:21:30,556 --> 0:21:33,516
有意思的事情

659
00:21:33,516 --> 0:21:34,866
第一个是 CD_ 到底是什么意思

660
00:21:35,906 --> 0:21:37,276
这是 Core Data 

661
00:21:37,276 --> 0:21:41,296
用来分开自身处理任务

662
00:21:41,296 --> 0:21:42,706
和 CloudKit 为你运行的

663
00:21:42,706 --> 0:21:44,386
任务的一种方式

664
00:21:44,386 --> 0:21:46,166
你不会相信有多少人会给 CKRecord

665
00:21:46,166 --> 0:21:47,236
添加修改日期

666
00:21:48,006 --> 0:21:49,386
或者区分用户

667
00:21:49,386 --> 0:21:49,906
自己添加的东西

668
00:21:50,056 --> 0:21:51,906
因此 我们提前标好前缀

669
00:21:51,906 --> 0:21:53,576
记录类型和所有的字段名称

670
00:21:53,676 --> 0:21:55,466
都包含 CD_ 前缀

671
00:21:56,386 --> 0:21:58,666
但是在 CD_entityName 字段

672
00:21:59,046 --> 0:22:01,096
我们会保留

673
00:21:59,046 --> 0:22:01,096
我们会保留

674
00:22:01,096 --> 0:22:03,966
记录中对象实体的真实名称

675
00:22:04,896 --> 0:22:06,206
这么做是为了

676
00:22:06,206 --> 0:22:07,386
可以实现

677
00:22:07,386 --> 0:22:09,346
实体继承的功能

678
00:22:09,346 --> 0:22:11,406
你可以创建帖子的子类

679
00:22:11,406 --> 0:22:15,056
比如 像是一个图像帖子或者是

680
00:22:15,056 --> 0:22:18,186
视频帖子 实际的实体一般都会

681
00:22:18,186 --> 0:22:19,826
被在 CD_entityName

682
00:22:19,826 --> 0:22:21,156
标示出来

683
00:22:22,096 --> 0:22:23,296
我们这么做是为了

684
00:22:23,296 --> 0:22:26,156
在查询时

685
00:22:26,156 --> 0:22:28,156
只要查询一个记录类型

686
00:22:28,156 --> 0:22:30,126
就能得到所有你感兴趣的

687
00:22:30,126 --> 0:22:31,196
实体层次结构

688
00:22:32,456 --> 0:22:33,486
现在看看我们如何

689
00:22:33,486 --> 0:22:35,016
实现这两个字符串

690
00:22:35,066 --> 0:22:38,166
因为这些字段的长度是可变的

691
00:22:38,166 --> 0:22:39,666
还有我们将其上传至 CloudKit 中时

692
00:22:39,666 --> 0:22:41,696
也有很多有趣的习惯

693
00:22:43,336 --> 0:22:44,516
你会看到我们已经将其

694
00:22:44,516 --> 0:22:46,246
填充进四个字段中

695
00:22:46,586 --> 0:22:48,306
而这么做的原因是

696
00:22:48,366 --> 0:22:49,946
我们使用了

697
00:22:49,946 --> 0:22:51,006
数据外化的方式

698
00:22:51,716 --> 0:22:52,816
你可以看到我们

699
00:22:52,866 --> 0:22:54,506
既有了 CD_content

700
00:22:54,576 --> 0:22:58,326
又有了 CD_content_CKAsset

701
00:22:58,806 --> 0:23:00,416
借此 我们可以储存字符串

702
00:22:58,806 --> 0:23:00,416
借此 我们可以储存字符串

703
00:23:00,456 --> 0:23:02,106
无论它们有多长

704
00:23:02,466 --> 0:23:04,666
从几 kb

705
00:23:04,666 --> 0:23:06,146
再到几百 mb

706
00:23:06,146 --> 0:23:08,356
甚至是以 gb 计算都可以储存

707
00:23:09,626 --> 0:23:11,036
当我说 这个记录

708
00:23:11,036 --> 0:23:11,976
已经进行了全部的具体化

709
00:23:11,976 --> 0:23:13,446
我的意思是

710
00:23:13,446 --> 0:23:15,516
你不会在同一时间

711
00:23:15,516 --> 0:23:17,586
看到全部的四个字段

712
00:23:18,206 --> 0:23:19,286
如果字符串很短

713
00:23:19,286 --> 0:23:20,676
那么你会看到记录中有

714
00:23:20,676 --> 0:23:22,406
CD_content

715
00:23:22,406 --> 0:23:23,686
和 CD_title

716
00:23:24,216 --> 0:23:25,456
但是 如果它们变得

717
00:23:25,456 --> 0:23:27,656
非常很长

718
00:23:27,656 --> 0:23:30,446
大于 750 kb

719
00:23:30,446 --> 0:23:32,316
又或者整个记录的大小

720
00:23:32,566 --> 0:23:34,296
超过了 CloudKit 的 1 mb 的限制

721
00:23:34,296 --> 0:23:38,686
那么你就会看到 asset 字段  

722
00:23:38,686 --> 0:23:42,276
也就是现在的 CD_content_CKAsset

723
00:23:43,016 --> 0:23:44,326
如果你需要一直

724
00:23:44,326 --> 0:23:45,546
使用我们的记录

725
00:23:45,576 --> 0:23:47,316
那你需要检查这两个字段

726
00:23:47,316 --> 0:23:48,946
看看某个属性

727
00:23:48,946 --> 0:23:50,000
是否被赋了某个值

728
00:23:54,066 --> 0:23:57,016
现在看看 Post 里面的关系

729
00:23:57,546 --> 0:23:58,576
你可以看到它们

730
00:23:58,576 --> 0:24:00,796
都是 Core Data 为你在对象中创建且

731
00:23:58,576 --> 0:24:00,796
都是 Core Data 为你在对象中创建且

732
00:24:00,796 --> 0:24:03,626
可供你使用的 NSSet 实例

733
00:24:04,126 --> 0:24:05,976
这是因为 Post 中

734
00:24:06,086 --> 0:24:07,536
有我们所谓的

735
00:24:07,536 --> 0:24:08,456
多元关系

736
00:24:08,936 --> 0:24:10,226
这意味着 一个帖子

737
00:24:10,226 --> 0:24:12,406
可以有多个附件

738
00:24:12,616 --> 0:24:16,846
或者它可以有多个标签

739
00:24:16,846 --> 0:24:17,686
我们一般称附件关系为

740
00:24:17,686 --> 0:24:19,126
多对一

741
00:24:19,126 --> 0:24:21,646
因为一个附件只能被分配给一个帖子

742
00:24:23,266 --> 0:24:24,686
当我们写代码的时候

743
00:24:24,686 --> 0:24:26,016
你可以看到 Post

744
00:24:26,016 --> 0:24:27,876
中有一个 NSSet

745
00:24:27,876 --> 0:24:30,346
但 Attachment ManageObject

746
00:24:30,566 --> 0:24:32,406
仅有一个 Post 对象

747
00:24:33,506 --> 0:24:36,876
这就是为附件生成的记录

748
00:24:37,366 --> 0:24:39,316
你可以看到它已经有了一个 UUID

749
00:24:39,316 --> 0:24:40,526
一个实体名称和记录类型

750
00:24:40,526 --> 0:24:42,576
就像 Post 一样

751
00:24:42,576 --> 0:24:43,886
但是你也看到了

752
00:24:43,886 --> 0:24:46,196
这里有一个叫做 CD_post 的字段

753
00:24:46,576 --> 0:24:47,546
这是我们如何储存

754
00:24:47,546 --> 0:24:50,316
多对一的关系

755
00:24:51,046 --> 0:24:53,446
在 CloudKit 中 相关记录的 UUID

756
00:24:53,446 --> 0:24:57,236
始终会储存在与它相关联的对象中

757
00:24:57,806 --> 0:24:59,696
并且 也许你会想

758
00:24:59,696 --> 0:25:00,726
为什么我们不用

759
00:24:59,696 --> 0:25:00,726
为什么我们不用

760
00:25:00,726 --> 0:25:02,006
CKReference 来处理这个问题呢

761
00:25:02,006 --> 0:25:04,076
那是因为 CKReference

762
00:25:04,076 --> 0:25:05,536
有一些我们认为

763
00:25:05,536 --> 0:25:07,116
对于 Core Data 客户来说

764
00:25:07,116 --> 0:25:07,906
并不是很友好的地方

765
00:25:08,386 --> 0:25:11,996
那就是它对象的数量只能限制在 750 之内

766
00:25:12,376 --> 0:25:13,686
但是通过这样储存关系

767
00:25:13,756 --> 0:25:15,426
你可以在 CloudKit 容器中

768
00:25:15,426 --> 0:25:17,006
存储足够多的关系

769
00:25:17,626 --> 0:25:20,866
现在看看多对多关系

770
00:25:21,156 --> 0:25:22,336
在本例中

771
00:25:22,336 --> 0:25:23,736
也就是帖子和它的标签之间的关系

772
00:25:24,976 --> 0:25:26,226
你可以看到对象中

773
00:25:26,306 --> 0:25:29,146
有两个 NSSet 

774
00:25:29,146 --> 0:25:31,326
这是因为两个对象都

775
00:25:31,326 --> 0:25:33,436
与其他的很多类型相连

776
00:25:33,436 --> 0:25:35,586
当我们生成

777
00:25:35,586 --> 0:25:37,186
这些对象的记录时

778
00:25:37,186 --> 0:25:39,116
我们没有具体化的字段

779
00:25:39,116 --> 0:25:40,426
来存储这种关系

780
00:25:41,176 --> 0:25:43,556
而是 Core Data

781
00:25:43,556 --> 0:25:44,976
具体化了一种自定义连接记录

782
00:25:45,406 --> 0:25:46,626
现在如果你对于

783
00:25:46,656 --> 0:25:48,566
关系数据库很熟悉

784
00:25:48,566 --> 0:25:49,866
你会理解这个概念

785
00:25:50,026 --> 0:25:51,816
基本上来说 它就是

786
00:25:51,816 --> 0:25:53,876
对于连接表中一行的外推

787
00:25:54,466 --> 0:25:57,276
被叫做 CDMR 或者是

788
00:25:57,276 --> 0:25:58,466
Core Data 镜像关系

789
00:25:59,176 --> 0:26:01,426
CDMR 包含了一对元组

790
00:25:59,176 --> 0:26:01,426
CDMR 包含了一对元组

791
00:26:01,426 --> 0:26:02,736
这是为了描述

792
00:26:02,736 --> 0:26:04,166
两个相关联对象

793
00:26:04,566 --> 0:26:06,106
首先是相关联对象的

794
00:26:06,106 --> 0:26:07,306
实体名称

795
00:26:07,306 --> 0:26:09,446
以及记录名称

796
00:26:09,916 --> 0:26:13,216
我之前说过 这不是记录 ID

797
00:26:13,596 --> 0:26:15,156
这是记录名称

798
00:26:15,156 --> 0:26:16,576
需要你把它和

799
00:26:16,576 --> 0:26:18,436
区域标识符结合起来

800
00:26:18,436 --> 0:26:22,536
然后得到 CDMR 相连的记录的标识符

801
00:26:22,946 --> 0:26:27,306
最后 我们也将此关联的

802
00:26:27,306 --> 0:26:28,546
确切关系进行记录

803
00:26:30,996 --> 0:26:33,396
那么为什么我要花费这么多时间

804
00:26:33,396 --> 0:26:34,126
来和你们介绍关系呢

805
00:26:35,486 --> 0:26:38,326
因为它们会影响我们

806
00:26:38,416 --> 0:26:40,676
协作进行数据建模的方式

807
00:26:41,346 --> 0:26:42,926
我也需要说清楚

808
00:26:42,926 --> 0:26:46,676
协作并非冲突解决

809
00:26:47,296 --> 0:26:50,586
冲突解决可以通过

810
00:26:50,586 --> 0:26:52,246
NSPersistentCloudKitContainer

811
00:26:52,296 --> 0:26:54,486
使用后写入为准的策略实现

812
00:26:55,166 --> 0:26:56,546
我们这么做的原因是

813
00:26:56,546 --> 0:27:00,036
冲突解决的作用是保持对象图

814
00:26:56,546 --> 0:27:00,036
冲突解决的作用是保持对象图

815
00:27:00,086 --> 0:27:01,726
以及 CloudKit 中的数据

816
00:27:02,086 --> 0:27:04,466
与你们建模的数据保持一致

817
00:27:05,286 --> 0:27:07,806
但是 这些年来

818
00:27:07,806 --> 0:27:09,396
一直进行的不尽如人意

819
00:27:09,936 --> 0:27:12,686
那么 现在看看你如何使用关系

820
00:27:12,686 --> 0:27:15,726
能更好地进行合并

821
00:27:15,766 --> 0:27:20,846
并且将合并行为与特定用户用例保持一致

822
00:27:22,436 --> 0:27:24,176
为了实现这个目标

823
00:27:24,176 --> 0:27:25,616
我们将再次使用 Post App

824
00:27:26,016 --> 0:27:27,456
我要创建一个帖子

825
00:27:27,906 --> 0:27:29,066
但是我这次不会给它

826
00:27:29,066 --> 0:27:29,826
分配任何内容

827
00:27:30,866 --> 0:27:32,516
我就让它同步给另外一个设备

828
00:27:32,516 --> 0:27:36,406
换句话说 我将同时在每台设备

829
00:27:36,406 --> 0:27:37,436
上面进行一些编辑

830
00:27:38,016 --> 0:27:39,316
现在 这才是我们

831
00:27:39,316 --> 0:27:41,406
传统概念上称作的冲突

832
00:27:41,936 --> 0:27:44,116
但是其实 这是一个

833
00:27:44,116 --> 0:27:45,446
两台设备想要对

834
00:27:45,446 --> 0:27:47,676
一个数值进行协同的好例子

835
00:27:48,416 --> 0:27:50,606
现在 NSPersistentCloudKitContainer

836
00:27:51,036 --> 0:27:52,196
已经发现 CloudKit 里面

837
00:27:52,196 --> 0:27:53,686
的内容发生了改变

838
00:27:53,686 --> 0:27:55,796
它将解决这个问题

839
00:27:55,796 --> 0:27:57,856
以保留两个数值中的一个 是吧

840
00:27:57,956 --> 0:27:59,876
使用后写入为准的策略

841
00:28:00,366 --> 0:28:01,276
这就意味着要么我们

842
00:28:01,276 --> 0:28:03,376
将协同做得很棒

843
00:28:03,826 --> 0:28:04,806
要么要修改两次

844
00:28:05,156 --> 0:28:09,056
的确如此 当然 也许你会想

845
00:28:09,056 --> 0:28:10,896
嗯 这是多此一举的

846
00:28:11,436 --> 0:28:12,566
Core Data 为什么不直接

847
00:28:12,596 --> 0:28:14,056
连接两个字符串呢

848
00:28:14,696 --> 0:28:15,576
我们的确能这么做

849
00:28:16,026 --> 0:28:17,346
除非你在过去的几年里

850
00:28:17,346 --> 0:28:20,506
采取了我们的建议实现了增量存储

851
00:28:20,856 --> 0:28:21,806
否则结果可能会是这样

852
00:28:21,806 --> 0:28:25,016
这不是我们想看到的

853
00:28:25,556 --> 0:28:26,796
而且它甚至还不是英文

854
00:28:28,446 --> 0:28:30,496
所以我们怎么才能改善呢 对吧

855
00:28:30,536 --> 0:28:31,966
很明显 这是一个

856
00:28:31,966 --> 0:28:33,426
不仅对我们 也是对客户来说

857
00:28:33,426 --> 0:28:35,056
至关重要的问题

858
00:28:35,806 --> 0:28:38,866
那么我们就看下 Post 实体

859
00:28:38,866 --> 0:28:41,046
看看能做哪些改进

860
00:28:41,716 --> 0:28:44,936
我们首要任务是停止

861
00:28:44,936 --> 0:28:47,126
在表面值上创建冲突

862
00:28:47,676 --> 0:28:49,986
内容只不过是表面上的字符串

863
00:28:50,026 --> 0:28:52,806
我们没办法仅仅通过它本身推断

864
00:28:52,806 --> 0:28:54,096
你想为字符串实行的

865
00:28:54,096 --> 0:28:55,236
合并策略

866
00:28:56,356 --> 0:29:01,406
但是 如果我们将它的关系进行分解

867
00:28:56,356 --> 0:29:01,406
但是 如果我们将它的关系进行分解

868
00:29:01,406 --> 0:29:05,816
多个设备将对内容字段做出贡献

869
00:29:06,336 --> 0:29:10,096
因为我们储存二对一关系的方式

870
00:29:10,096 --> 0:29:11,416
很多设备可以在

871
00:29:11,416 --> 0:29:13,246
同一时间里修改内容

872
00:29:13,246 --> 0:29:15,836
而且不会对 Post 对象产生冲突

873
00:29:16,936 --> 0:29:18,566
所以 我现在将其分解

874
00:29:18,566 --> 0:29:20,776
使之变成一个由简单字符串

875
00:29:21,126 --> 0:29:22,366
构成的 PostContent 实体

876
00:29:23,556 --> 0:29:25,756
现在 因为我们存储

877
00:29:25,756 --> 0:29:27,536
二对一关系的方式

878
00:29:27,536 --> 0:29:29,986
这些将会由设备自行合并

879
00:29:30,176 --> 0:29:31,796
对吧 我们得去研究它们

880
00:29:31,796 --> 0:29:33,546
以此来收集最终值

881
00:29:34,056 --> 0:29:36,506
我们将其称为最终一致性

882
00:29:36,926 --> 0:29:38,896
当两台设备一起

883
00:29:38,896 --> 0:29:40,026
修改 PostContent 对象的时候

884
00:29:40,026 --> 0:29:41,186
它们就会从对方那里

885
00:29:41,186 --> 0:29:42,736
下载 PostContent 对象

886
00:29:42,736 --> 0:29:45,026
并将其连接或者合并

887
00:29:45,026 --> 0:29:46,516
再或者其他你选择的连接方式

888
00:29:46,516 --> 0:29:48,326
用来解决这个问题

889
00:29:48,326 --> 0:29:49,606
以此收集最终值的操作

890
00:29:50,926 --> 0:29:52,786
但是我们想让这个过程

891
00:29:52,786 --> 0:29:54,766
在所有设备中都保持一致

892
00:29:54,836 --> 0:29:56,136
不同的下载顺序

893
00:29:56,136 --> 0:29:57,966
就可能导致最终值的不同

894
00:29:58,476 --> 0:30:00,536
因此 我们要用一些信息

895
00:29:58,476 --> 0:30:00,536
因此 我们要用一些信息

896
00:30:00,536 --> 0:30:02,216
将它们排序 比如日期

897
00:30:02,806 --> 0:30:04,306
这样做的话 设备就可以

898
00:30:04,306 --> 0:30:05,876
在连接之前

899
00:30:05,876 --> 0:30:07,466
使用 Core Data 中简单的排序描述符

900
00:30:07,466 --> 0:30:10,716
对 PostContent 对象排序

901
00:30:10,716 --> 0:30:12,186
使下载顺序和合并策略

902
00:30:12,186 --> 0:30:14,336
在所有设备上保持一致

903
00:30:15,216 --> 0:30:17,106
然而 我还是比较喜欢研究

904
00:30:17,106 --> 0:30:20,166
分布式系统 而时间有其局限性

905
00:30:21,296 --> 0:30:22,826
事实上 如果设备们都在你的房间中

906
00:30:22,826 --> 0:30:24,276
那它们的时间

907
00:30:24,276 --> 0:30:24,976
可能都不会有所差别

908
00:30:26,716 --> 0:30:28,716
那么 我们可以把这一步

909
00:30:28,716 --> 0:30:32,306
做得更远

910
00:30:32,306 --> 0:30:33,546
利用修改的层级关系

911
00:30:33,546 --> 0:30:35,446
并给予实体一些

912
00:30:35,446 --> 0:30:38,476
关于正在进行实际工作的设备信息

913
00:30:38,476 --> 0:30:39,626
从而实现完整的因果树

914
00:30:40,326 --> 0:30:42,006
这样的话 我们就完成了

915
00:30:42,006 --> 0:30:43,326
一个称作无冲突

916
00:30:43,326 --> 0:30:45,526
复制数据类型的粗略草图

917
00:30:46,026 --> 0:30:47,626
这是一个极棒的

918
00:30:47,626 --> 0:30:49,376
新兴计算机科学领域

919
00:30:49,376 --> 0:30:52,866
它可以帮助我们部署算法 

920
00:30:52,866 --> 0:30:54,426
在不同的用户-用户场景之间

921
00:30:54,426 --> 0:30:55,806
生成一致的合并行为

922
00:30:56,316 --> 0:31:02,216
这就是在 Using Core Data with CloudKit 的主要内容

923
00:30:56,316 --> 0:31:02,216
这就是在 Using Core Data with CloudKit 的主要内容

924
00:31:02,216 --> 0:31:03,386
我非常荣幸能够向你们展示

925
00:31:03,516 --> 0:31:05,046
NSPersistentCloudKitContainer

926
00:31:05,116 --> 0:31:07,886
以及对于你来说为自己的 App 实现

927
00:31:07,886 --> 0:31:08,886
同步功能有多简单

928
00:31:09,726 --> 0:31:10,876
今年 我们可以为你们提供

929
00:31:10,876 --> 0:31:12,316
非常棒的示例代码和文档

930
00:31:12,386 --> 0:31:15,046
并且我非常希望可以给你们带来

931
00:31:15,046 --> 0:31:16,466
全新 API 的极致体验

932
00:31:17,076 --> 0:31:19,516
最后 我已经迫不及待

933
00:31:19,516 --> 0:31:20,396
想看看你们如何使用

934
00:31:20,396 --> 0:31:21,946
NSPersistentCloudKitContainer

935
00:31:22,266 --> 0:31:24,476
以及如何去扩展它

936
00:31:24,626 --> 0:31:28,366
今年我们有很多实验室 这周每天都有

937
00:31:28,546 --> 0:31:30,026
正如你们所知道的 我们会在

938
00:31:30,026 --> 0:31:31,846
星期三的三点钟举办一个会议

939
00:31:31,846 --> 0:31:33,846
届时 Core Data 更多的功能将亮相

940
00:31:35,196 --> 0:31:36,246
非常感谢 我希望大家

941
00:31:36,246 --> 0:31:37,976
都能好好享受 WWDC

942
00:31:38,516 --> 0:31:42,500
[掌声]
