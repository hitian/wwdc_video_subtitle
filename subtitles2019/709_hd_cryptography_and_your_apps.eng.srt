1
00:00:00,506 --> 0:00:04,500
[ Music ]

2
00:00:12,516 --> 0:00:14,636
[ Applause ]

3
00:00:15,136 --> 0:00:15,666
&gt;&gt; Good afternoon.

4
00:00:16,366 --> 0:00:17,206
Good afternoon everyone.

5
00:00:18,456 --> 0:00:22,546
Welcome to the bitcoin session

6
00:00:22,546 --> 0:00:23,156
[laughter].

7
00:00:23,156 --> 0:00:25,276
Kidding. Welcome to Cryptography

8
00:00:25,276 --> 0:00:26,306
and Your Apps session.

9
00:00:27,206 --> 0:00:29,126
Today, my colleague, Frederic,

10
00:00:29,126 --> 0:00:31,326
and I are here to show you that

11
00:00:31,326 --> 0:00:33,026
using cryptography on Apple

12
00:00:33,026 --> 0:00:34,936
products has never been easier.

13
00:00:35,776 --> 0:00:36,636
I am Yannick Sierra.

14
00:00:36,636 --> 0:00:37,846
I manage the Cryptographic

15
00:00:37,846 --> 0:00:39,496
Engineering Team at Apple.

16
00:00:39,496 --> 0:00:43,466
So today on one hand we have a

17
00:00:43,466 --> 0:00:45,756
set of great system features

18
00:00:45,926 --> 0:00:47,606
which solve a set of common

19
00:00:47,636 --> 0:00:48,456
security problems.

20
00:00:49,326 --> 0:00:51,306
On the other hand, we have an

21
00:00:51,446 --> 0:00:54,406
exciting new Swift API for

22
00:00:54,406 --> 0:00:55,576
cryptographic operation.

23
00:00:56,336 --> 0:00:58,476
We're really excited about it.

24
00:00:58,476 --> 0:01:00,056
If you here, it's probably

25
00:00:58,476 --> 0:01:00,056
If you here, it's probably

26
00:01:00,056 --> 0:01:01,506
because there's some information

27
00:01:01,506 --> 0:01:02,766
you want to protect, right.

28
00:01:05,476 --> 0:01:08,246
We know that you as developers

29
00:01:08,396 --> 0:01:11,016
and as users find it really

30
00:01:11,016 --> 0:01:12,526
important to protect user's

31
00:01:12,526 --> 0:01:13,976
information, your information.

32
00:01:16,656 --> 0:01:17,806
There are different kind of

33
00:01:17,806 --> 0:01:19,326
information, which are all

34
00:01:19,426 --> 0:01:19,826
sensitive.

35
00:01:19,866 --> 0:01:21,966
It starts with profile

36
00:01:21,966 --> 0:01:23,796
information such as phone

37
00:01:23,796 --> 0:01:25,746
numbers and email addresses.

38
00:01:26,636 --> 0:01:28,156
Your applications may also be

39
00:01:28,156 --> 0:01:31,866
handling user information such

40
00:01:31,866 --> 0:01:34,386
as photos or music by using an

41
00:01:34,386 --> 0:01:36,256
application to process and

42
00:01:36,256 --> 0:01:36,686
improve.

43
00:01:38,196 --> 0:01:39,976
Your application may also be

44
00:01:39,976 --> 0:01:41,596
handling business assets.

45
00:01:42,826 --> 0:01:44,846
This could be paid content your

46
00:01:45,026 --> 0:01:46,266
app is making available to

47
00:01:46,266 --> 0:01:46,886
users.

48
00:01:47,716 --> 0:01:49,586
Or account information like in

49
00:01:49,586 --> 0:01:51,626
the mobile banking scenarios.

50
00:01:53,136 --> 0:01:54,836
For all of this information, it

51
00:01:54,836 --> 0:01:56,636
is critical to keep them secure,

52
00:01:57,106 --> 0:01:58,926
and you need to have great tools

53
00:01:58,926 --> 0:01:59,346
for that.

54
00:01:59,986 --> 0:02:04,436
At Apple, security and privacy

55
00:01:59,986 --> 0:02:04,436
At Apple, security and privacy

56
00:02:04,716 --> 0:02:06,146
are core values.

57
00:02:06,826 --> 0:02:08,406
We built it in all of the

58
00:02:08,406 --> 0:02:11,056
features that we work on.

59
00:02:12,356 --> 0:02:14,626
Cryptography is a big part of

60
00:02:15,416 --> 0:02:15,486
it.

61
00:02:16,036 --> 0:02:18,086
For example, with device

62
00:02:18,086 --> 0:02:20,476
integrity we use cryptography to

63
00:02:20,476 --> 0:02:21,886
validate the integrity of the

64
00:02:21,886 --> 0:02:23,506
software running on the platform

65
00:02:23,876 --> 0:02:25,206
to make sure it has not been

66
00:02:25,206 --> 0:02:27,216
tampered with and guarantee its

67
00:02:27,216 --> 0:02:28,936
security properties are not

68
00:02:28,936 --> 0:02:29,376
changed.

69
00:02:30,746 --> 0:02:32,236
We use cryptography to protect

70
00:02:32,236 --> 0:02:32,996
data at rest.

71
00:02:34,086 --> 0:02:36,236
We use cryptography across a

72
00:02:36,476 --> 0:02:38,166
wide variety of applications

73
00:02:38,666 --> 0:02:42,416
users love, use extensively for

74
00:02:42,616 --> 0:02:44,736
capturing very personal moments

75
00:02:44,866 --> 0:02:45,816
and sharing them.

76
00:02:46,426 --> 0:02:47,946
This is a case of Messages,

77
00:02:48,766 --> 0:02:50,876
Safari, and iCloud.

78
00:02:51,876 --> 0:02:53,806
With over a billion device, we

79
00:02:53,806 --> 0:02:55,346
operation cryptography at a huge

80
00:02:55,386 --> 0:02:55,726
scale.

81
00:02:57,056 --> 0:02:58,806
The stakes, as you can imagine,

82
00:02:59,186 --> 0:03:00,206
are really high too.

83
00:02:59,186 --> 0:03:00,206
are really high too.

84
00:03:00,626 --> 0:03:02,936
Performance is critical for a

85
00:03:02,936 --> 0:03:04,066
great user experience.

86
00:03:05,016 --> 0:03:07,006
Energy is fundamental for that

87
00:03:07,136 --> 0:03:09,296
full-day battery life, and

88
00:03:09,296 --> 0:03:10,966
security, it's a cornerstone

89
00:03:10,966 --> 0:03:11,166
here.

90
00:03:12,526 --> 0:03:13,856
Now, let's have a closer look at

91
00:03:13,856 --> 0:03:14,516
cryptography.

92
00:03:16,196 --> 0:03:17,896
Cryptography is really a tool.

93
00:03:18,286 --> 0:03:20,116
It provides solution to a set of

94
00:03:20,306 --> 0:03:21,956
basic properties.

95
00:03:23,186 --> 0:03:25,096
It starts with authentication as

96
00:03:25,096 --> 0:03:27,356
an example, knowing who sent you

97
00:03:27,356 --> 0:03:27,776
a message.

98
00:03:29,456 --> 0:03:31,406
Encryption, knowing that that

99
00:03:31,406 --> 0:03:34,546
message only you can decrypt it.

100
00:03:35,456 --> 0:03:37,836
And Integrity, knowing that no

101
00:03:37,836 --> 0:03:39,536
one else could have modified the

102
00:03:39,536 --> 0:03:41,316
content of that message before

103
00:03:41,316 --> 0:03:42,506
it got to you.

104
00:03:43,456 --> 0:03:45,636
To solve broader security

105
00:03:45,636 --> 0:03:47,166
problem, we combine

106
00:03:47,166 --> 0:03:48,916
cryptographic functions into

107
00:03:48,916 --> 0:03:51,376
cryptographic protocol, and

108
00:03:51,376 --> 0:03:52,466
that's no easy task.

109
00:03:54,036 --> 0:03:56,266
Actually, many of you, most of

110
00:03:56,266 --> 0:03:57,316
you have probably heard the

111
00:03:57,356 --> 0:03:58,476
saying, "don't roll your own

112
00:03:58,476 --> 0:03:59,426
crypto", right.

113
00:04:00,206 --> 0:04:01,616
There are good reasons for that.

114
00:04:01,616 --> 0:04:04,256
A lot of things can go wrong.

115
00:04:05,456 --> 0:04:07,476
It starts with maybe not picking

116
00:04:07,476 --> 0:04:09,116
the right primitives and

117
00:04:09,116 --> 0:04:09,946
therefore not getting the

118
00:04:09,946 --> 0:04:11,766
security you want to achieve.

119
00:04:12,636 --> 0:04:14,566
It may also be adding the right

120
00:04:14,566 --> 0:04:16,745
primitives but not using them

121
00:04:16,745 --> 0:04:19,656
the right way, and the lowest

122
00:04:19,656 --> 0:04:22,366
level, the implementation may

123
00:04:22,366 --> 0:04:23,526
give away the secrets or the

124
00:04:23,526 --> 0:04:23,916
keys.

125
00:04:24,296 --> 0:04:25,476
That could be the case of timing

126
00:04:25,476 --> 0:04:27,016
attacks or padding oracle

127
00:04:27,016 --> 0:04:27,556
attacks.

128
00:04:28,886 --> 0:04:30,696
This is why cryptography is

129
00:04:30,696 --> 0:04:32,056
incredibly difficult.

130
00:04:32,386 --> 0:04:35,046
There are endless examples of

131
00:04:35,186 --> 0:04:36,356
failures of cryptographic

132
00:04:36,356 --> 0:04:39,636
protocols in the news, and the

133
00:04:39,636 --> 0:04:41,236
worst thing is, security

134
00:04:41,236 --> 0:04:42,656
vulnerabilities may take a while

135
00:04:42,656 --> 0:04:43,426
to be discovered.

136
00:04:43,426 --> 0:04:45,186
It may take years before someone

137
00:04:45,186 --> 0:04:46,306
reports finding an issue.

138
00:04:47,656 --> 0:04:50,386
This is why the risks are really

139
00:04:50,386 --> 0:04:53,146
high, and so it's an effort to

140
00:04:53,146 --> 0:04:53,736
get it right.

141
00:04:55,026 --> 0:04:56,286
Designing a robust protocol

142
00:04:56,636 --> 0:04:59,336
takes a lot of time, skills, and

143
00:04:59,336 --> 0:05:01,446
expertise you need to be a

144
00:04:59,336 --> 0:05:01,446
expertise you need to be a

145
00:05:01,446 --> 0:05:02,166
cryptographer.

146
00:05:03,306 --> 0:05:04,686
Even when you got the protocol,

147
00:05:05,056 --> 0:05:06,226
the work is not done yet.

148
00:05:06,946 --> 0:05:07,996
There is a continuous amount of

149
00:05:07,996 --> 0:05:10,576
work to monitor new attacks, see

150
00:05:10,576 --> 0:05:12,156
what is applicable to your own

151
00:05:12,156 --> 0:05:14,806
code, and then respond to it,

152
00:05:15,476 --> 0:05:16,746
but sometimes it's not even that

153
00:05:16,746 --> 0:05:17,096
easy.

154
00:05:17,486 --> 0:05:18,676
It can be dependencies.

155
00:05:19,226 --> 0:05:20,606
Those libraries that you picked

156
00:05:20,606 --> 0:05:23,846
to integrate in your app.

157
00:05:24,106 --> 0:05:25,856
And in some situation, you also

158
00:05:25,856 --> 0:05:27,006
need to revise and carry the

159
00:05:27,006 --> 0:05:29,196
protocol and manage all kind of

160
00:05:29,196 --> 0:05:30,916
interpretability scenarios.

161
00:05:31,516 --> 0:05:35,436
All of this is a lot of work,

162
00:05:36,076 --> 0:05:38,326
and it's taking time and energy

163
00:05:38,326 --> 0:05:40,106
away of the big ideas you may

164
00:05:40,106 --> 0:05:42,546
have or the next cool features.

165
00:05:44,416 --> 0:05:46,936
This is why you can truly

166
00:05:46,936 --> 0:05:49,136
benefit from native features.

167
00:05:50,256 --> 0:05:51,766
Our philosophy has been to

168
00:05:51,766 --> 0:05:55,306
provide full solutions for a set

169
00:05:55,646 --> 0:05:57,836
of common problems so that we do

170
00:05:57,836 --> 0:05:59,416
the hard work and you don't have

171
00:05:59,466 --> 0:05:59,626
to.

172
00:06:00,936 --> 0:06:03,726
For you, it raises the risk and

173
00:06:03,726 --> 0:06:05,586
the effort, and we can even

174
00:06:05,586 --> 0:06:07,716
achieve better security through

175
00:06:07,716 --> 0:06:09,856
the assistance of delegated

176
00:06:09,856 --> 0:06:11,406
hardware features we have on our

177
00:06:11,406 --> 0:06:11,936
platforms.

178
00:06:14,686 --> 0:06:17,046
Now, we actually look through a

179
00:06:17,046 --> 0:06:18,626
set of very common scenarios

180
00:06:19,156 --> 0:06:20,406
many of you may be familiar

181
00:06:20,406 --> 0:06:20,646
with.

182
00:06:20,646 --> 0:06:24,146
We're going to start with how to

183
00:06:24,146 --> 0:06:25,736
protect data on a device.

184
00:06:26,366 --> 0:06:28,676
Then we can look at protecting

185
00:06:28,676 --> 0:06:30,206
credentials and keys.

186
00:06:30,766 --> 0:06:34,446
After that, sharing data across

187
00:06:34,446 --> 0:06:36,456
devices and users.

188
00:06:38,256 --> 0:06:40,106
Then, securing network

189
00:06:40,106 --> 0:06:42,196
connections, and finally,

190
00:06:42,346 --> 0:06:44,126
verifying remote parties with

191
00:06:44,166 --> 0:06:44,846
certificates.

192
00:06:46,426 --> 0:06:48,186
Now, I'm going to look into the

193
00:06:48,276 --> 0:06:49,276
first example.

194
00:06:49,406 --> 0:06:50,456
Like I'm sure many of you have

195
00:06:50,546 --> 0:06:54,106
found that scenario and find

196
00:06:54,106 --> 0:06:55,196
yourself trying to protect data

197
00:06:55,716 --> 0:06:56,556
on device.

198
00:06:57,406 --> 0:07:00,496
Well, the best advice is not to

199
00:06:57,406 --> 0:07:00,496
Well, the best advice is not to

200
00:07:00,496 --> 0:07:01,586
just copy and paste what you

201
00:07:01,586 --> 0:07:03,246
find on some of those websites.

202
00:07:03,896 --> 0:07:06,436
You're better off using data

203
00:07:06,436 --> 0:07:06,976
protection.

204
00:07:08,016 --> 0:07:09,276
Data protection combines the

205
00:07:09,276 --> 0:07:11,046
strengths of the passcode with

206
00:07:11,046 --> 0:07:12,766
the hardware technologies in the

207
00:07:12,766 --> 0:07:14,696
Secure Enclave to make sure the

208
00:07:14,816 --> 0:07:16,966
keys are well secured, and the

209
00:07:16,966 --> 0:07:19,886
encrypted data cannot be used to

210
00:07:19,886 --> 0:07:20,796
brute-force the passcode.

211
00:07:21,396 --> 0:07:23,816
But there's even more.

212
00:07:24,526 --> 0:07:26,586
Data protection provides post

213
00:07:26,586 --> 0:07:27,556
compromise recovery.

214
00:07:28,726 --> 0:07:30,656
Post compromise recovery, also

215
00:07:30,656 --> 0:07:31,806
known as forward secrecy,

216
00:07:32,156 --> 0:07:34,166
guarantees that if adversary

217
00:07:34,456 --> 0:07:35,666
gets his hand on the keys on the

218
00:07:35,666 --> 0:07:37,736
device and the users change the

219
00:07:37,736 --> 0:07:40,276
passcode, well, all the data

220
00:07:40,276 --> 0:07:42,086
encrypted after that cannot be

221
00:07:42,086 --> 0:07:43,346
recovered from those old keys.

222
00:07:44,496 --> 0:07:47,296
This is important, critical, and

223
00:07:47,296 --> 0:07:48,476
if you want to learn more,

224
00:07:49,086 --> 0:07:49,996
there's even more data

225
00:07:49,996 --> 0:07:51,946
protection does, and you can

226
00:07:51,946 --> 0:07:53,276
look at the iOS security white

227
00:07:53,276 --> 0:07:56,086
paper to get more information.

228
00:07:56,926 --> 0:07:58,386
The one thing you need to know

229
00:07:59,166 --> 0:07:59,996
is that there are different

230
00:07:59,996 --> 0:08:02,336
protection attributes you can

231
00:07:59,996 --> 0:08:02,336
protection attributes you can

232
00:08:02,396 --> 0:08:03,626
set when your app fails.

233
00:08:04,276 --> 0:08:07,876
It starts from until first

234
00:08:07,876 --> 0:08:08,736
authentication.

235
00:08:09,496 --> 0:08:12,776
Even the data is protected until

236
00:08:14,096 --> 0:08:15,526
the first time the user unlocks

237
00:08:15,526 --> 0:08:17,096
the phone after boot.

238
00:08:18,346 --> 0:08:19,126
It's great.

239
00:08:20,136 --> 0:08:21,576
Today is a lot better you can

240
00:08:21,576 --> 0:08:21,766
do.

241
00:08:22,316 --> 0:08:23,716
There is the complete file

242
00:08:23,716 --> 0:08:24,236
protection.

243
00:08:24,766 --> 0:08:26,076
Complete file protection means

244
00:08:26,546 --> 0:08:28,746
the data is only available after

245
00:08:28,796 --> 0:08:30,876
the user unlocks his phone.

246
00:08:31,326 --> 0:08:32,836
As soon as the user locks his

247
00:08:32,836 --> 0:08:33,846
phone back, put it back in the

248
00:08:33,846 --> 0:08:35,826
pocket or in a bag, the data is

249
00:08:35,866 --> 0:08:36,336
secure again.

250
00:08:36,885 --> 0:08:39,846
And it's really easy to use.

251
00:08:40,145 --> 0:08:40,775
Here's an example.

252
00:08:41,566 --> 0:08:42,686
The only thing you need to use

253
00:08:42,846 --> 0:08:43,606
is this option,

254
00:08:43,916 --> 0:08:44,966
completeFileProtection.

255
00:08:44,966 --> 0:08:46,496
It can't be easier than that,

256
00:08:46,496 --> 0:08:46,706
right.

257
00:08:47,216 --> 0:08:48,376
If you're not using this option

258
00:08:48,376 --> 0:08:49,686
yet, please go ahead and look in

259
00:08:49,686 --> 0:08:50,906
your application where you could

260
00:08:50,906 --> 0:08:52,866
use it to get that best level of

261
00:08:52,866 --> 0:08:53,446
security.

262
00:08:55,576 --> 0:08:58,506
Now, in addition to files, there

263
00:08:58,506 --> 0:08:59,616
may be more sensitive

264
00:08:59,616 --> 0:09:00,746
information that you may want to

265
00:08:59,616 --> 0:09:00,746
information that you may want to

266
00:09:00,746 --> 0:09:01,066
protect.

267
00:09:02,076 --> 0:09:03,596
There could be credentials like

268
00:09:03,836 --> 0:09:05,906
authentication tokens used to

269
00:09:05,906 --> 0:09:08,216
authenticate on services or

270
00:09:08,216 --> 0:09:09,006
cryptography keys.

271
00:09:09,546 --> 0:09:13,986
But for those, please don't

272
00:09:13,986 --> 0:09:15,436
write them in defaults that you

273
00:09:15,436 --> 0:09:16,936
could see on all the platforms.

274
00:09:17,736 --> 0:09:19,666
Instead, there is Keychain.

275
00:09:21,106 --> 0:09:22,826
Keychain in the Secitem APIs

276
00:09:23,356 --> 0:09:24,826
allows you to write those items

277
00:09:25,446 --> 0:09:27,036
as in the local Keychain, which

278
00:09:27,036 --> 0:09:28,146
means they stay on that one

279
00:09:28,146 --> 0:09:30,976
device or on iCloud Keychain

280
00:09:31,836 --> 0:09:33,076
where they synchronize across

281
00:09:33,076 --> 0:09:34,426
all of the devices for a

282
00:09:34,546 --> 0:09:36,916
seamless experience in the user

283
00:09:36,916 --> 0:09:37,306
account.

284
00:09:37,946 --> 0:09:40,086
This requires user accounts with

285
00:09:40,306 --> 0:09:41,286
two-factor authentication

286
00:09:41,286 --> 0:09:41,706
enabled.

287
00:09:42,306 --> 0:09:45,006
For Keychain, you find very

288
00:09:45,006 --> 0:09:47,466
similar protection as for the

289
00:09:47,466 --> 0:09:48,906
files that I mentioned before

290
00:09:49,576 --> 0:09:50,696
and a few extra ones.

291
00:09:51,246 --> 0:09:52,556
Here, again, I will recommend

292
00:09:52,556 --> 0:09:53,786
you to look at the documentation

293
00:09:53,786 --> 0:09:54,286
to learn more.

294
00:09:55,686 --> 0:09:56,946
In addition to when a key is

295
00:09:56,986 --> 0:09:58,136
cryptographically available,

296
00:09:58,636 --> 0:10:00,306
sometimes important for you to

297
00:09:58,636 --> 0:10:00,306
sometimes important for you to

298
00:10:00,306 --> 0:10:01,676
know how the user authenticated

299
00:10:01,676 --> 0:10:01,976
it and when.

300
00:10:03,656 --> 0:10:05,576
This is why we have

301
00:10:05,576 --> 0:10:06,976
LocalAuthentication.

302
00:10:08,256 --> 0:10:10,196
LocalAuthentication allows you

303
00:10:10,196 --> 0:10:12,446
to put restrictions as to when

304
00:10:12,446 --> 0:10:14,726
an operation can be executed.

305
00:10:15,306 --> 0:10:16,746
For example, you could define

306
00:10:16,886 --> 0:10:18,336
that it is required for the user

307
00:10:18,336 --> 0:10:19,646
to authenticate with biometrics

308
00:10:19,646 --> 0:10:20,296
with Face ID.

309
00:10:21,256 --> 0:10:22,906
It can be very handy, and in

310
00:10:22,906 --> 0:10:25,336
this world, on macOS we have

311
00:10:25,336 --> 0:10:26,446
some exciting news.

312
00:10:27,036 --> 0:10:31,066
On macOS, you're used to device

313
00:10:31,146 --> 0:10:33,776
authentication properties, and

314
00:10:33,776 --> 0:10:35,986
it gives two way for the user to

315
00:10:35,986 --> 0:10:38,256
authenticate, the password or

316
00:10:38,256 --> 0:10:39,886
biometrics for Macs which

317
00:10:39,886 --> 0:10:41,286
support biometrics with Touch

318
00:10:41,286 --> 0:10:41,496
ID.

319
00:10:42,466 --> 0:10:43,606
This year we're really excited

320
00:10:43,606 --> 0:10:46,006
to announce that now without any

321
00:10:46,006 --> 0:10:48,746
change in your application, the

322
00:10:48,746 --> 0:10:50,446
user can authenticate with Apple

323
00:10:50,446 --> 0:10:52,186
Watch and a double-click on Apple

324
00:10:52,186 --> 0:10:52,496
Watch.

325
00:10:53,376 --> 0:10:54,606
It's a great new experience,

326
00:10:54,796 --> 0:10:56,506
which is going to reduce the use

327
00:10:56,506 --> 0:10:57,986
of the password and reduce the

328
00:10:58,026 --> 0:10:59,356
friction, improves user

329
00:10:59,356 --> 0:10:59,926
experience.

330
00:11:00,916 --> 0:11:02,366
Now, with these new capabilities

331
00:11:02,536 --> 0:11:04,306
we added two new policies.

332
00:11:05,236 --> 0:11:08,386
The first one, to reduce the

333
00:11:08,386 --> 0:11:10,416
authentication to biometrics

334
00:11:10,416 --> 0:11:11,926
only and Watch.

335
00:11:12,506 --> 0:11:15,586
And the second one to the Watch

336
00:11:15,936 --> 0:11:16,426
alone.

337
00:11:17,696 --> 0:11:18,686
We are looking forward to see

338
00:11:18,776 --> 0:11:19,946
how you're going to use those in

339
00:11:20,076 --> 0:11:21,566
your application on macOS.

340
00:11:25,196 --> 0:11:26,386
Now, I mentioned the Keychain,

341
00:11:27,316 --> 0:11:28,186
there is an easy way to

342
00:11:28,236 --> 0:11:30,376
synchronize items across all of

343
00:11:30,376 --> 0:11:32,286
the devices of an account.

344
00:11:33,196 --> 0:11:34,066
What if you have data?

345
00:11:35,086 --> 0:11:36,636
Well, for data we have a great

346
00:11:36,636 --> 0:11:37,236
solution too.

347
00:11:38,626 --> 0:11:41,436
CloudKit. CloudKit allows you to

348
00:11:41,436 --> 0:11:43,336
encrypt assets in the Private

349
00:11:43,336 --> 0:11:46,856
CloudKit Database, and the data

350
00:11:46,856 --> 0:11:48,556
will be available across all of

351
00:11:48,556 --> 0:11:50,156
the devices without the user

352
00:11:50,156 --> 0:11:51,656
having to sign in into the

353
00:11:51,656 --> 0:11:52,376
application.

354
00:11:52,936 --> 0:11:56,296
It is great, and even more, you

355
00:11:56,296 --> 0:11:57,926
can also use it to share to all

356
00:11:57,926 --> 0:11:58,636
the users.

357
00:12:00,796 --> 0:12:02,896
The way it works is Apple as a

358
00:12:02,936 --> 0:12:05,746
trusted party help manage the

359
00:12:05,846 --> 0:12:08,046
iCloud identities and the

360
00:12:08,046 --> 0:12:09,886
control to the data.

361
00:12:10,596 --> 0:12:13,776
And I have an example here

362
00:12:13,776 --> 0:12:15,656
again, to show it's easy to set

363
00:12:15,656 --> 0:12:15,786
up.

364
00:12:16,946 --> 0:12:17,856
From the file, we create an

365
00:12:17,856 --> 0:12:17,976
asset.

366
00:12:20,556 --> 0:12:22,206
With this asset, we created a

367
00:12:22,206 --> 0:12:22,626
record.

368
00:12:23,496 --> 0:12:24,846
And then we upload this record

369
00:12:24,906 --> 0:12:25,976
into the Private CloudKit

370
00:12:25,976 --> 0:12:26,476
Database.

371
00:12:27,166 --> 0:12:31,386
And this is it, and if you want

372
00:12:31,436 --> 0:12:32,816
to add sharing to other users,

373
00:12:32,816 --> 0:12:33,886
it is possible for a set of defined

374
00:12:33,886 --> 0:12:34,486
APIs.

375
00:12:34,486 --> 0:12:36,326
If you haven't looked into

376
00:12:36,356 --> 0:12:38,076
CloudKit before, it's great time

377
00:12:38,376 --> 0:12:39,366
to go have a look at the

378
00:12:39,366 --> 0:12:40,656
documentation and see how

379
00:12:40,656 --> 0:12:42,046
powerful it can be for you.

380
00:12:42,046 --> 0:12:45,326
Now, with this, we talked about

381
00:12:45,326 --> 0:12:47,846
protecting data inside of

382
00:12:47,846 --> 0:12:49,876
devices, share it across

383
00:12:49,876 --> 0:12:52,626
devices, even devices from

384
00:12:52,626 --> 0:12:55,756
another user, what when you want

385
00:12:55,756 --> 0:12:57,086
it done on data from your own

386
00:12:57,086 --> 0:12:58,206
server for example.

387
00:12:59,436 --> 0:13:00,986
Where for that you want to

388
00:12:59,436 --> 0:13:00,986
Where for that you want to

389
00:13:00,986 --> 0:13:02,276
establish a secure connection.

390
00:13:03,556 --> 0:13:04,646
A secure connection is really,

391
00:13:04,646 --> 0:13:06,956
really important because it

392
00:13:07,126 --> 0:13:08,916
helps guaranteeing the

393
00:13:08,916 --> 0:13:10,376
confidentiality of all of the

394
00:13:10,376 --> 0:13:12,076
information that the user is

395
00:13:12,076 --> 0:13:12,826
accessing through your

396
00:13:12,826 --> 0:13:14,896
application as well as guarantee

397
00:13:14,896 --> 0:13:16,676
the trustworthiness of that

398
00:13:16,676 --> 0:13:18,066
information, make sure it does

399
00:13:18,066 --> 0:13:18,976
not be tampered with.

400
00:13:21,226 --> 0:13:22,346
And the first thing you should

401
00:13:22,346 --> 0:13:23,936
not do here again, you're just

402
00:13:23,936 --> 0:13:25,266
trying to use your custom own

403
00:13:25,266 --> 0:13:25,696
protocol.

404
00:13:26,296 --> 0:13:27,776
There is a great solution.

405
00:13:28,626 --> 0:13:29,696
It's a standard solution.

406
00:13:30,946 --> 0:13:32,446
Transport Layer Security.

407
00:13:33,236 --> 0:13:35,206
And it's really easy to use on

408
00:13:35,206 --> 0:13:35,826
our platforms.

409
00:13:36,246 --> 0:13:37,966
We have two great APIs that make

410
00:13:37,966 --> 0:13:39,096
that really easy.

411
00:13:39,906 --> 0:13:41,076
The first one is network

412
00:13:41,076 --> 0:13:42,796
framework, which you may have

413
00:13:42,796 --> 0:13:44,156
discovered last year with a

414
00:13:44,156 --> 0:13:46,316
great talk at WWDC.

415
00:13:47,036 --> 0:13:48,946
The second one is URL Sessions,

416
00:13:49,286 --> 0:13:51,356
which you may know about as part

417
00:13:51,356 --> 0:13:53,236
of the App Transport Security.

418
00:13:55,116 --> 0:13:56,726
For URL Session, the only thing

419
00:13:56,726 --> 0:13:59,816
you need to do is use an https

420
00:14:00,656 --> 0:14:00,986
endpoint.

421
00:14:00,986 --> 0:14:02,926
In either of those cases, it

422
00:14:03,786 --> 0:14:07,106
relies on our implementation of TLS with

423
00:14:07,866 --> 0:14:09,496
great defaults underneath.

424
00:14:10,336 --> 0:14:12,876
Defaults ensures cypher suites are chosen to

425
00:14:13,436 --> 0:14:14,676
provide strong security

426
00:14:14,966 --> 0:14:16,486
including perfect forward secrecy as

427
00:14:16,556 --> 0:14:18,796
well as the algorithm that would

428
00:14:18,796 --> 0:14:20,656
be the most efficient on Apple

429
00:14:20,656 --> 0:14:21,276
products.

430
00:14:21,816 --> 0:14:24,576
Or implementation of TLS also

431
00:14:26,156 --> 0:14:28,086
use TLS 1.3 by default.

432
00:14:28,086 --> 0:14:30,766
If you're not familiar with TLS

433
00:14:30,766 --> 0:14:32,936
1.3, it has a lot of

434
00:14:32,936 --> 0:14:34,596
improvements from the previous

435
00:14:34,596 --> 0:14:37,446
revisions, a lot better security

436
00:14:37,726 --> 0:14:39,156
and even better efficiency by

437
00:14:39,156 --> 0:14:40,236
reducing some of those round

438
00:14:41,096 --> 0:14:41,246
trips.

439
00:14:42,996 --> 0:14:45,166
If you are not using TLS 1.3,

440
00:14:46,026 --> 0:14:46,876
please go ahead and try to

441
00:14:46,876 --> 0:14:48,816
deploy that on your servers and

442
00:14:48,816 --> 0:14:50,526
without any change of the

443
00:14:50,526 --> 0:14:51,556
Code of your application, you

444
00:14:51,556 --> 0:14:52,846
will have the benefit of it in

445
00:14:52,846 --> 0:14:53,826
your app.

446
00:14:55,456 --> 0:14:56,836
And now, to show you it's really

447
00:14:56,836 --> 0:14:58,936
easy, I have two examples to

448
00:14:58,936 --> 0:15:01,206
show you with Network Framework

449
00:14:58,936 --> 0:15:01,206
show you with Network Framework

450
00:15:02,026 --> 0:15:04,016
and URL Session, but before

451
00:15:04,016 --> 0:15:05,586
jumping into those, I want to

452
00:15:05,586 --> 0:15:06,826
highlight that Secure Transport

453
00:15:07,096 --> 0:15:08,376
is not the recommended way

454
00:15:08,376 --> 0:15:10,886
anymore, and we ask you to

455
00:15:10,886 --> 0:15:12,576
migrate to Network Framework and

456
00:15:12,576 --> 0:15:13,776
URL Sessions if you're already

457
00:15:13,776 --> 0:15:14,776
using Secure Transport.

458
00:15:15,686 --> 0:15:17,186
With that, here's a couple of

459
00:15:17,186 --> 0:15:17,806
examples.

460
00:15:18,776 --> 0:15:20,896
With Network Framework, when you

461
00:15:20,896 --> 0:15:22,676
establish a connection, the only

462
00:15:22,676 --> 0:15:24,926
thing you need to do is using

463
00:15:25,006 --> 0:15:27,926
:.tls, and here we go, you add

464
00:15:27,926 --> 0:15:30,516
that TLS connection, providing

465
00:15:30,516 --> 0:15:32,226
great security and performance.

466
00:15:33,296 --> 0:15:35,356
For URL Session, the only thing

467
00:15:35,356 --> 0:15:38,186
here, it's https endpoint, and

468
00:15:38,236 --> 0:15:40,866
this is it.

469
00:15:41,136 --> 0:15:43,636
In some situation, you may not

470
00:15:44,286 --> 0:15:45,736
have the possibility to use TLS.

471
00:15:45,986 --> 0:15:47,566
For example, if you have trying

472
00:15:47,566 --> 0:15:49,876
to secure data through a content

473
00:15:49,876 --> 0:15:51,356
delivery network, for example.

474
00:15:52,146 --> 0:15:54,116
In this case, you manage those

475
00:15:54,116 --> 0:15:56,296
certificates, and for

476
00:15:56,456 --> 0:15:59,606
certificates, one of the things

477
00:15:59,606 --> 0:16:01,816
to avoid is using it on parser

478
00:15:59,606 --> 0:16:01,816
to avoid is using it on parser

479
00:16:01,816 --> 0:16:02,896
or trying to take a parser you

480
00:16:02,896 --> 0:16:04,416
find somewhere on a website.

481
00:16:05,066 --> 0:16:06,626
Parsers are incredibly

482
00:16:06,626 --> 0:16:08,606
vulnerable by providing a great

483
00:16:08,606 --> 0:16:09,526
attack exposure.

484
00:16:10,956 --> 0:16:12,026
They're critical.

485
00:16:13,216 --> 0:16:15,866
On a platform, we have SecTrust

486
00:16:15,866 --> 0:16:16,286
for that.

487
00:16:17,126 --> 0:16:18,466
SecTrust provides you an easy

488
00:16:18,466 --> 0:16:20,436
way to validate the certificate

489
00:16:21,056 --> 0:16:22,286
against a trust policy.

490
00:16:23,086 --> 0:16:24,286
The trust policy may contain

491
00:16:24,286 --> 0:16:26,096
information about expiration,

492
00:16:27,006 --> 0:16:29,786
revocation, and until

493
00:16:29,786 --> 0:16:31,666
certificate has been validated,

494
00:16:31,836 --> 0:16:36,386
you know that you can use a key.

495
00:16:36,636 --> 0:16:38,196
Note that if using TLS you don't

496
00:16:38,196 --> 0:16:40,056
have a need to worry about

497
00:16:40,056 --> 0:16:40,566
certificate.

498
00:16:40,736 --> 0:16:42,236
It's all handled for you

499
00:16:42,696 --> 0:16:43,326
underneath.

500
00:16:43,886 --> 0:16:47,546
Now, in this release, we're

501
00:16:47,546 --> 0:16:49,606
happy to introduce a new

502
00:16:49,606 --> 0:16:51,846
function in SecTrust.

503
00:16:52,716 --> 0:16:54,256
This new function combines two

504
00:16:54,256 --> 0:16:56,426
things you were able to do

505
00:16:56,426 --> 0:16:56,686
before.

506
00:16:57,286 --> 0:16:58,476
On one hand, it's a function,

507
00:16:58,476 --> 0:17:00,206
which allows to asynchronously

508
00:16:58,476 --> 0:17:00,206
which allows to asynchronously

509
00:17:00,656 --> 0:17:02,796
through an explicit action, do a

510
00:17:02,796 --> 0:17:04,806
certificate validation so that

511
00:17:04,806 --> 0:17:06,026
your application can do

512
00:17:06,026 --> 0:17:07,336
something else while the

513
00:17:07,336 --> 0:17:09,026
certificate is being validated.

514
00:17:09,626 --> 0:17:11,925
But also this function gives you

515
00:17:11,925 --> 0:17:13,026
a richer handling.

516
00:17:13,685 --> 0:17:15,996
So, as a developer, you know

517
00:17:16,705 --> 0:17:18,726
what is going on in case of

518
00:17:18,776 --> 0:17:20,665
failure, and you can debug it.

519
00:17:21,306 --> 0:17:22,675
But also, you can build logic

520
00:17:22,675 --> 0:17:25,215
into your application to respond

521
00:17:25,215 --> 0:17:26,556
to different error scenarios.

522
00:17:27,146 --> 0:17:29,086
So this new function is going to

523
00:17:29,086 --> 0:17:30,736
make things even more convenient

524
00:17:30,736 --> 0:17:31,856
and easier for you to debug.

525
00:17:31,856 --> 0:17:33,046
We're looking forward to you

526
00:17:33,046 --> 0:17:34,106
adopting it.

527
00:17:34,656 --> 0:17:37,626
So, with this, I just walked you

528
00:17:37,626 --> 0:17:40,336
through a set of five different

529
00:17:40,336 --> 0:17:42,466
scenarios for which we have

530
00:17:42,836 --> 0:17:44,976
really easy to use solutions,

531
00:17:45,456 --> 0:17:47,536
which provide great security by

532
00:17:47,536 --> 0:17:50,186
defaults or you're only a few

533
00:17:50,186 --> 0:17:52,756
attributes away from great

534
00:17:52,756 --> 0:17:53,306
security.

535
00:17:53,876 --> 0:17:57,546
And here again, we benefit from

536
00:17:58,156 --> 0:17:59,326
deep integration with the

537
00:17:59,326 --> 0:18:00,756
hardware to provide security

538
00:17:59,326 --> 0:18:00,756
hardware to provide security

539
00:18:00,816 --> 0:18:02,326
features which otherwise are

540
00:18:02,326 --> 0:18:03,396
very challenging to provide.

541
00:18:04,026 --> 0:18:06,646
So, in any of the scenarios,

542
00:18:06,906 --> 0:18:09,496
when you encounter them, go

543
00:18:09,496 --> 0:18:10,406
ahead and use the system

544
00:18:10,406 --> 0:18:11,986
frameworks, and if you already

545
00:18:11,986 --> 0:18:13,296
do, go ahead and make sure

546
00:18:13,296 --> 0:18:14,016
you're using those best

547
00:18:14,016 --> 0:18:14,936
attributes so that you can

548
00:18:14,936 --> 0:18:17,656
protect users and business

549
00:18:17,656 --> 0:18:19,466
assets the best possible way.

550
00:18:20,086 --> 0:18:24,056
And we understand that in some

551
00:18:24,056 --> 0:18:26,186
situations it may not be

552
00:18:26,186 --> 0:18:28,386
practical for you to use the

553
00:18:28,386 --> 0:18:29,216
system features.

554
00:18:29,746 --> 0:18:32,556
For example, you may need to

555
00:18:32,926 --> 0:18:35,236
have interoperability outside of

556
00:18:35,236 --> 0:18:35,726
the Apple ecosystem.

557
00:18:35,856 --> 0:18:38,626
You may to authenticate with

558
00:18:38,626 --> 0:18:41,936
your service or simply you're

559
00:18:41,936 --> 0:18:44,096
given a specification you will

560
00:18:44,096 --> 0:18:46,386
need to implement.

561
00:18:46,386 --> 0:18:49,536
For all of these cases, we now

562
00:18:49,536 --> 0:18:50,766
have a great solution for you.

563
00:18:51,976 --> 0:18:53,006
Apple CryptoKit.

564
00:18:53,936 --> 0:18:57,026
Apple CryptoKit is new Swift

565
00:18:57,096 --> 0:18:59,576
cryptographic API which has been

566
00:18:59,576 --> 0:19:00,956
designed to follow the same

567
00:18:59,576 --> 0:19:00,956
designed to follow the same

568
00:19:00,956 --> 0:19:02,866
philosophy as for those features

569
00:19:02,866 --> 0:19:05,396
we talked about and give you an

570
00:19:05,396 --> 0:19:06,886
easy access to cryptographic

571
00:19:06,886 --> 0:19:09,616
functions and hard to misuse

572
00:19:09,616 --> 0:19:10,096
functions.

573
00:19:11,006 --> 0:19:13,146
We're really excited to give

574
00:19:13,146 --> 0:19:14,966
that in this release.

575
00:19:16,106 --> 0:19:17,766
And now, I'm going to hand over

576
00:19:17,886 --> 0:19:18,916
to Frederic who is going to tell

577
00:19:18,916 --> 0:19:20,136
you all about this exciting new

578
00:19:20,136 --> 0:19:20,386
API.

579
00:19:21,076 --> 0:19:22,306
So please join me in welcoming

580
00:19:22,306 --> 0:19:22,976
Frederic on stage.

581
00:19:23,516 --> 0:19:29,546
[ Applause ]

582
00:19:30,046 --> 0:19:30,846
&gt;&gt; Thanks Yannick.

583
00:19:31,776 --> 0:19:32,386
Hello everyone.

584
00:19:32,796 --> 0:19:34,946
My name is Frederic Jacobs, and

585
00:19:34,946 --> 0:19:36,526
I'm working on the Cryptographic

586
00:19:36,526 --> 0:19:37,936
Engineering Team here at Apple.

587
00:19:38,646 --> 0:19:40,536
I'm excited to tell you more

588
00:19:40,536 --> 0:19:42,546
today about Apple CryptoKit.

589
00:19:43,386 --> 0:19:44,866
We think you're really going to

590
00:19:44,866 --> 0:19:46,676
like implementing cryptographic

591
00:19:46,676 --> 0:19:49,346
protocols in Swift.

592
00:19:49,396 --> 0:19:51,786
There are four aspects of Apple

593
00:19:51,786 --> 0:19:53,376
CryptoKit I would like to share

594
00:19:53,376 --> 0:19:54,346
with you this afternoon.

595
00:19:55,216 --> 0:19:57,596
First, we are going to talk

596
00:19:57,786 --> 0:19:59,656
about CryptoKit and Swift.

597
00:20:00,876 --> 0:20:03,876
Second, we will talk about the

598
00:20:03,876 --> 0:20:06,016
curated set of algorithms that

599
00:20:06,016 --> 0:20:07,566
is available in CryptoKit.

600
00:20:08,556 --> 0:20:11,016
Third, we are going to discuss

601
00:20:11,126 --> 0:20:14,146
about the Secure Enclave and

602
00:20:14,146 --> 0:20:16,016
biometric authentication, and

603
00:20:16,586 --> 0:20:18,136
finally, we'll talk about

604
00:20:18,186 --> 0:20:18,746
performance.

605
00:20:19,706 --> 0:20:21,006
Let's dive right in.

606
00:20:22,096 --> 0:20:23,806
In the past, you might have had

607
00:20:23,856 --> 0:20:25,556
to write code that looks like

608
00:20:25,556 --> 0:20:28,726
this when you were calling into

609
00:20:28,726 --> 0:20:30,366
C crypto API from Swift.

610
00:20:31,126 --> 0:20:33,326
You had to allocate buffers,

611
00:20:33,596 --> 0:20:34,806
figure out for each of the

612
00:20:34,806 --> 0:20:36,706
buffers what size it had to be,

613
00:20:37,406 --> 0:20:39,576
and there were values such as

614
00:20:39,576 --> 0:20:42,246
the nonce that you might have to

615
00:20:42,246 --> 0:20:44,456
search what the safe value for

616
00:20:44,456 --> 0:20:45,366
that value was.

617
00:20:46,326 --> 0:20:47,836
And then you have all of these

618
00:20:47,836 --> 0:20:50,406
nested calls into the encryption

619
00:20:50,406 --> 0:20:52,746
function where you're passing

620
00:20:52,746 --> 0:20:54,346
pointers, and there are no

621
00:20:54,346 --> 0:20:56,556
argument labels that help you

622
00:20:56,846 --> 0:20:58,996
figure out which pointer needs

623
00:20:58,996 --> 0:21:01,426
to go into which argument.

624
00:20:58,996 --> 0:21:01,426
to go into which argument.

625
00:21:02,306 --> 0:21:04,716
In contrast, with Apple

626
00:21:04,716 --> 0:21:07,556
CryptoKit, you can do exactly

627
00:21:07,556 --> 0:21:09,246
the same operation with a single

628
00:21:09,246 --> 0:21:09,836
line of code.

629
00:21:11,086 --> 0:21:12,696
In this-- isn't this cool?

630
00:21:13,516 --> 0:21:18,506
[ Applause ]

631
00:21:19,006 --> 0:21:21,746
So, in order to do so, you're

632
00:21:21,746 --> 0:21:23,036
passing the data you want to

633
00:21:23,036 --> 0:21:24,666
encrypt to cipher.

634
00:21:24,786 --> 0:21:26,836
In this case we're using

635
00:21:26,836 --> 0:21:29,536
AES.GCM, and you're using the

636
00:21:29,536 --> 0:21:31,616
key you want to encrypt the data

637
00:21:31,616 --> 0:21:34,716
with and that's it.

638
00:21:35,926 --> 0:21:38,276
Something else you might have

639
00:21:38,276 --> 0:21:40,016
had to do is generating your own

640
00:21:40,016 --> 0:21:42,036
cryptographic key when you were

641
00:21:42,036 --> 0:21:43,826
calling into a C crypto API from

642
00:21:43,826 --> 0:21:44,146
Swift.

643
00:21:44,766 --> 0:21:46,796
And that involved first

644
00:21:47,116 --> 0:21:48,646
converting a number of bits and

645
00:21:48,646 --> 0:21:50,456
bytes because cryptographic keys

646
00:21:50,456 --> 0:21:52,996
are commonly expressed in bits.

647
00:21:54,066 --> 0:21:56,446
Then you have to allocate a

648
00:21:56,446 --> 0:22:01,416
buffer for that amount of bytes

649
00:21:56,446 --> 0:22:01,416
buffer for that amount of bytes

650
00:22:01,576 --> 0:22:03,576
and use the system, random

651
00:22:03,576 --> 0:22:05,606
number generator to fill that

652
00:22:05,666 --> 0:22:08,096
buffer with cryptographically

653
00:22:08,096 --> 0:22:09,556
secure random numbers.

654
00:22:11,216 --> 0:22:14,606
Then, if an error occurred you

655
00:22:14,606 --> 0:22:15,666
had to handle that.

656
00:22:16,726 --> 0:22:19,646
You're then finally ready to use

657
00:22:19,646 --> 0:22:22,816
that key, and when you're done

658
00:22:22,816 --> 0:22:24,706
with that key, you don't have to

659
00:22:24,706 --> 0:22:27,556
forget to zeroize it to remove

660
00:22:27,556 --> 0:22:28,216
it from memory.

661
00:22:28,836 --> 0:22:32,956
In contrast the CryptoKit,

662
00:22:32,956 --> 0:22:34,986
generating a key is just a

663
00:22:34,986 --> 0:22:37,906
single line of code.

664
00:22:38,636 --> 0:22:40,376
You call the SymmetricKey

665
00:22:40,906 --> 0:22:42,796
initializer, and you pass the

666
00:22:42,796 --> 0:22:45,386
number of bits you want the key

667
00:22:45,386 --> 0:22:45,836
to hold.

668
00:22:50,096 --> 0:22:52,666
We're able to zeroize this key

669
00:22:52,666 --> 0:22:55,966
on release for you because

670
00:22:56,566 --> 0:22:58,916
knowing about the auto reference

671
00:22:58,916 --> 0:23:02,626
counting of this value whenever

672
00:22:58,916 --> 0:23:02,626
counting of this value whenever

673
00:23:03,096 --> 0:23:04,806
it is getting deallocated, we're

674
00:23:04,806 --> 0:23:09,246
zeroizing that buffer for you.

675
00:23:09,456 --> 0:23:11,376
So, CryptoKit and Swift.

676
00:23:12,266 --> 0:23:15,426
We have a strongly typed API,

677
00:23:16,366 --> 0:23:18,726
and whenever you're initializing

678
00:23:19,426 --> 0:23:22,436
a value, we are verifying that

679
00:23:22,436 --> 0:23:24,826
the data you're passing is a

680
00:23:25,076 --> 0:23:26,596
strong value for that argument.

681
00:23:28,116 --> 0:23:32,706
Thanks to Swift's memory

682
00:23:32,706 --> 0:23:34,506
management model, we're able to

683
00:23:34,946 --> 0:23:38,376
zeroize on release all of the

684
00:23:38,376 --> 0:23:40,156
secret values allocated within

685
00:23:40,156 --> 0:23:40,656
CryptoKit.

686
00:23:41,986 --> 0:23:43,646
We perform equitable

687
00:23:43,646 --> 0:23:46,846
conformances for values like

688
00:23:47,066 --> 0:23:49,416
message authentication code if

689
00:23:49,736 --> 0:23:50,746
you're familiar with that

690
00:23:50,746 --> 0:23:52,756
content so that you're able to

691
00:23:52,756 --> 0:23:53,966
verify two-message

692
00:23:53,966 --> 0:23:56,006
authentication codes in constant

693
00:23:56,006 --> 0:23:58,786
time by just using the equals

694
00:23:58,786 --> 0:23:59,866
equals operator.

695
00:24:03,556 --> 0:24:06,516
CryptoKit also defines protocols

696
00:24:06,806 --> 0:24:09,296
so that you can write generic

697
00:24:09,296 --> 0:24:12,336
code over a hash function H, and

698
00:24:12,426 --> 0:24:14,176
if in multiple places of your

699
00:24:14,176 --> 0:24:16,136
code base you have to pass

700
00:24:16,136 --> 0:24:17,656
different hash functions, you

701
00:24:17,656 --> 0:24:19,346
can write the code once and then

702
00:24:19,496 --> 0:24:21,036
parametrize the function call on

703
00:24:21,036 --> 0:24:21,976
a different hash function.

704
00:24:24,776 --> 0:24:27,456
So, we talked about CryptoKit

705
00:24:27,456 --> 0:24:29,836
and Swift, and now I want to

706
00:24:29,836 --> 0:24:32,996
dive into the curated set of

707
00:24:33,066 --> 0:24:36,166
algorithms that is supported in

708
00:24:36,166 --> 0:24:36,716
CryptoKit.

709
00:24:37,756 --> 0:24:40,716
All algorithms are standard and

710
00:24:40,716 --> 0:24:41,896
peer-reviewed algorithms.

711
00:24:42,526 --> 0:24:45,726
Let's see what's available in

712
00:24:45,726 --> 0:24:46,216
CryptoKit.

713
00:24:47,716 --> 0:24:49,066
We have support for hash

714
00:24:49,066 --> 0:24:51,276
functions, message

715
00:24:51,276 --> 0:24:53,056
authentication codes,

716
00:24:53,696 --> 0:24:56,796
authenticated encryption, key

717
00:24:57,026 --> 0:25:01,126
agreement, and signatures.

718
00:24:57,026 --> 0:25:01,126
agreement, and signatures.

719
00:25:02,876 --> 0:25:05,096
Some of these algorithms are

720
00:25:05,096 --> 0:25:06,686
algorithms we have supported

721
00:25:06,686 --> 0:25:09,316
before in frameworks such as

722
00:25:09,316 --> 0:25:11,576
Common Crypto or SecKey, but

723
00:25:11,576 --> 0:25:13,136
some of these algorithms are

724
00:25:13,136 --> 0:25:14,546
algorithms we're supporting for

725
00:25:14,546 --> 0:25:15,206
the first time.

726
00:25:15,726 --> 0:25:17,206
Those are highlighted in green

727
00:25:17,206 --> 0:25:17,816
on the slide.

728
00:25:18,466 --> 0:25:21,656
Note that we also have an

729
00:25:21,656 --> 0:25:22,596
insecure module.

730
00:25:23,936 --> 0:25:27,216
This module provides algorithms

731
00:25:27,216 --> 0:25:30,776
such as MD5 and SHA1 so that you

732
00:25:30,776 --> 0:25:32,806
can adopt CryptoKit even if you

733
00:25:32,806 --> 0:25:35,356
need to be using some algorithms

734
00:25:35,356 --> 0:25:37,356
that no longer meet the best

735
00:25:37,446 --> 0:25:38,526
security standards.

736
00:25:42,836 --> 0:25:46,306
Let's focus on a few examples to

737
00:25:46,636 --> 0:25:47,986
see how CryptoKit works.

738
00:25:48,806 --> 0:25:50,356
Let's start with hash functions.

739
00:25:50,926 --> 0:25:53,406
Hash functions produced

740
00:25:53,406 --> 0:25:56,456
deterministic fixed-size output

741
00:25:56,616 --> 0:25:58,816
that is called a digest, and

742
00:25:58,996 --> 0:26:01,526
unlike hashable in Swift, hash

743
00:25:58,996 --> 0:26:01,526
unlike hashable in Swift, hash

744
00:26:01,526 --> 0:26:04,326
functions in CryptoKit provide

745
00:26:04,726 --> 0:26:06,636
cryptographic properties such as

746
00:26:06,716 --> 0:26:07,686
collision resistance.

747
00:26:08,626 --> 0:26:10,876
This means that it is hard to

748
00:26:10,876 --> 0:26:13,426
find two inputs that will hash

749
00:26:13,466 --> 0:26:16,986
to the same digest.

750
00:26:16,986 --> 0:26:19,606
In order to compute the hash, it

751
00:26:19,606 --> 0:26:22,926
is as easy as calling the hash

752
00:26:22,926 --> 0:26:24,976
method on the hash function you

753
00:26:24,976 --> 0:26:27,386
want to use, passing the data

754
00:26:27,386 --> 0:26:28,166
you want to hash.

755
00:26:29,196 --> 0:26:32,016
Here, I have some audio data I

756
00:26:32,016 --> 0:26:35,496
want to hash, and I use the

757
00:26:35,496 --> 0:26:38,636
SHA256 hash function to compute

758
00:26:38,636 --> 0:26:38,976
a digest.

759
00:26:42,906 --> 0:26:45,146
If you're streaming a file, you

760
00:26:45,146 --> 0:26:47,086
might be reading it from an

761
00:26:47,086 --> 0:26:47,676
input stream.

762
00:26:49,096 --> 0:26:50,416
In that case, you want to

763
00:26:50,416 --> 0:26:53,216
compute the digest

764
00:26:53,216 --> 0:26:53,906
incrementally.

765
00:26:55,096 --> 0:26:57,566
You start by initializing a

766
00:26:57,566 --> 0:26:59,836
hasher by calling the MT

767
00:26:59,836 --> 0:27:01,336
initializer on the hash

768
00:26:59,836 --> 0:27:01,336
initializer on the hash

769
00:27:01,336 --> 0:27:01,746
function.

770
00:27:02,236 --> 0:27:07,016
You then pass the data you want

771
00:27:07,016 --> 0:27:09,146
to hash, and you call the update

772
00:27:09,146 --> 0:27:11,286
method one or multiple times in

773
00:27:11,286 --> 0:27:14,516
order to do so.

774
00:27:14,756 --> 0:27:17,966
And when you want the digest to

775
00:27:17,966 --> 0:27:20,446
be computed, you just call the

776
00:27:20,446 --> 0:27:22,226
finalize method on the hash for

777
00:27:22,226 --> 0:27:23,916
instance, and that will return

778
00:27:23,916 --> 0:27:24,466
the digest.

779
00:27:24,886 --> 0:27:29,396
Next, let's talk about

780
00:27:29,636 --> 0:27:30,886
authenticated encryption.

781
00:27:31,716 --> 0:27:33,456
This is something you've long

782
00:27:33,456 --> 0:27:34,446
been asking for.

783
00:27:35,106 --> 0:27:37,496
As its name suggests, it

784
00:27:37,496 --> 0:27:39,326
provides both authentication and

785
00:27:39,326 --> 0:27:39,896
encryption.

786
00:27:41,436 --> 0:27:44,146
The lack of authentication in

787
00:27:44,146 --> 0:27:46,686
cryptographic protocols can lead

788
00:27:46,686 --> 0:27:49,276
to a variety of attacks, and

789
00:27:49,836 --> 0:27:51,316
manually combining

790
00:27:51,436 --> 0:27:53,636
authentication with encryption

791
00:27:54,356 --> 0:27:56,266
can lead to things like padding

792
00:27:56,266 --> 0:27:58,076
oracle attacks.

793
00:27:58,436 --> 0:28:00,586
So, instead we're really happy

794
00:27:58,436 --> 0:28:00,586
So, instead we're really happy

795
00:28:00,656 --> 0:28:02,426
to provide it to you as a single

796
00:28:02,426 --> 0:28:03,036
API call.

797
00:28:07,076 --> 0:28:08,846
I'm working on the site project.

798
00:28:09,096 --> 0:28:10,586
It's a hiking app.

799
00:28:11,216 --> 0:28:12,786
Most of the content on the app

800
00:28:12,786 --> 0:28:15,316
is free, but there's additional

801
00:28:15,316 --> 0:28:17,006
content you can purchase through

802
00:28:17,006 --> 0:28:21,276
the in-app purchase.

803
00:28:21,386 --> 0:28:22,876
Once you purchase the content,

804
00:28:23,216 --> 0:28:24,696
you can retrieve the additional

805
00:28:24,696 --> 0:28:25,156
content.

806
00:28:26,576 --> 0:28:27,936
I'm using a content delivery

807
00:28:27,936 --> 0:28:29,706
network in order to keep the

808
00:28:29,706 --> 0:28:32,516
downloads fast, as my user base

809
00:28:32,556 --> 0:28:32,776
grows.

810
00:28:35,436 --> 0:28:37,776
In order to obtain the content,

811
00:28:38,026 --> 0:28:41,366
I first check with my server if

812
00:28:41,366 --> 0:28:44,976
the in-app purchase is valid.

813
00:28:45,596 --> 0:28:49,706
Then, the key is retrieved from

814
00:28:49,706 --> 0:28:50,966
the server and passed on the

815
00:28:50,966 --> 0:28:51,296
phone.

816
00:28:52,656 --> 0:28:54,836
I download the encrypted data

817
00:28:55,136 --> 0:28:56,286
from the content delivery

818
00:28:56,286 --> 0:29:00,686
network, and I use the key in

819
00:28:56,286 --> 0:29:00,686
network, and I use the key in

820
00:29:00,686 --> 0:29:02,326
order to decrypt the encrypted

821
00:29:02,326 --> 0:29:02,736
content.

822
00:29:03,136 --> 0:29:06,346
And if the key is right, and the

823
00:29:06,346 --> 0:29:08,276
data wasn't tampered with on the

824
00:29:08,276 --> 0:29:10,816
content delivery network, I'm

825
00:29:10,866 --> 0:29:12,696
able to retrieve the map data.

826
00:29:13,306 --> 0:29:17,376
Let's see how this translates to

827
00:29:19,056 --> 0:29:19,166
code.

828
00:29:19,336 --> 0:29:22,166
First, we start by initializing

829
00:29:22,166 --> 0:29:24,366
a SymmetricKey from the key data

830
00:29:24,366 --> 0:29:26,696
that was retrieved from the

831
00:29:28,856 --> 0:29:29,036
server.

832
00:29:29,186 --> 0:29:31,256
Then we are initializing a

833
00:29:31,256 --> 0:29:31,976
sealed box.

834
00:29:32,996 --> 0:29:35,576
In this case, it doesn't really

835
00:29:35,576 --> 0:29:37,246
matter what's in the sealed box,

836
00:29:37,306 --> 0:29:39,216
but know that if you're working

837
00:29:39,556 --> 0:29:42,106
on implementing a specification

838
00:29:42,106 --> 0:29:44,066
that requires you to combine the

839
00:29:44,066 --> 0:29:46,146
nonce, the cipher text and the

840
00:29:46,146 --> 0:29:48,286
tag in a specific way, you can

841
00:29:48,286 --> 0:29:49,986
use the sealed box to do that.

842
00:29:50,816 --> 0:29:52,216
If you're implementing a

843
00:29:52,216 --> 0:29:54,446
protocol that requires you to

844
00:29:54,446 --> 0:29:57,146
pass specific nonce values we're

845
00:29:57,366 --> 0:29:59,176
also able to support that.

846
00:29:59,336 --> 0:30:01,376
But, in this example, we'll

847
00:29:59,336 --> 0:30:01,376
But, in this example, we'll

848
00:30:01,416 --> 0:30:02,676
focus on the simple case.

849
00:30:04,096 --> 0:30:06,216
So, we're passing the downloaded

850
00:30:06,216 --> 0:30:08,086
data as a combined

851
00:30:08,086 --> 0:30:09,636
representation to the sealed

852
00:30:09,636 --> 0:30:12,156
box, and now that we have a box,

853
00:30:12,896 --> 0:30:15,496
we can simply open it by calling

854
00:30:15,496 --> 0:30:18,936
the open method on the cipher.

855
00:30:19,566 --> 0:30:22,816
And we're passing the key.

856
00:30:23,426 --> 0:30:23,976
It's that easy.

857
00:30:26,916 --> 0:30:28,366
Next, let's talk about

858
00:30:28,366 --> 0:30:28,896
signatures.

859
00:30:30,196 --> 0:30:31,946
Signatures are used to

860
00:30:31,946 --> 0:30:34,036
authenticate data using a

861
00:30:34,036 --> 0:30:36,616
private key, and using the

862
00:30:36,616 --> 0:30:38,926
signature, we are able to verify

863
00:30:38,926 --> 0:30:41,106
data using the associated public

864
00:30:41,166 --> 0:30:41,346
key.

865
00:30:41,866 --> 0:30:45,856
Let's take an example where we

866
00:30:45,856 --> 0:30:47,846
want to use the signature in

867
00:30:47,846 --> 0:30:49,366
order to authorize and

868
00:30:49,366 --> 0:30:49,976
operation.

869
00:30:50,796 --> 0:30:54,496
The operation here can be a

870
00:30:54,496 --> 0:30:56,866
two-factor log-in or some

871
00:30:56,916 --> 0:30:58,916
sensitive transaction such as

872
00:30:58,916 --> 0:31:00,866
wiring money to another user of

873
00:30:58,916 --> 0:31:00,866
wiring money to another user of

874
00:31:00,866 --> 0:31:01,536
the application.

875
00:31:03,666 --> 0:31:07,096
In order to do so, we start by

876
00:31:07,406 --> 0:31:08,976
generating a private key on the

877
00:31:08,976 --> 0:31:09,466
device.

878
00:31:10,956 --> 0:31:12,566
We then retrieve the associated

879
00:31:12,566 --> 0:31:13,246
public key.

880
00:31:13,816 --> 0:31:16,666
The associated public key is

881
00:31:16,666 --> 0:31:20,826
registered with your service,

882
00:31:20,956 --> 0:31:24,016
and once we want to perform that

883
00:31:24,016 --> 0:31:25,926
operation, we're using the

884
00:31:25,926 --> 0:31:27,536
private key to generate the

885
00:31:27,536 --> 0:31:29,516
signature on the transaction

886
00:31:29,516 --> 0:31:33,056
data and then sending over the

887
00:31:33,056 --> 0:31:34,226
transaction data and the

888
00:31:34,226 --> 0:31:35,456
signature to the server.

889
00:31:36,866 --> 0:31:40,566
The server will verify that the

890
00:31:40,566 --> 0:31:44,686
signature is correct, and if the

891
00:31:44,686 --> 0:31:47,636
signature is right, it will

892
00:31:47,636 --> 0:31:51,276
proceed to doing the operation.

893
00:31:51,756 --> 0:31:54,806
Let's see what this code looks

894
00:31:54,806 --> 0:31:54,976
like.

895
00:31:54,976 --> 0:31:57,676
In order to generate a

896
00:31:57,676 --> 0:32:00,066
cryptographically strong private

897
00:31:57,676 --> 0:32:00,066
cryptographically strong private

898
00:32:00,066 --> 0:32:02,896
key, we call the PrivateKey

899
00:32:02,896 --> 0:32:03,566
initializer.

900
00:32:06,876 --> 0:32:09,546
Then we want to register some

901
00:32:09,546 --> 0:32:11,316
public key data on the server.

902
00:32:12,176 --> 0:32:14,556
We start by retrieving the

903
00:32:14,806 --> 0:32:17,506
public key by just calling

904
00:32:17,596 --> 0:32:19,326
public key on the private key,

905
00:32:19,956 --> 0:32:24,536
and then we want to say what

906
00:32:24,596 --> 0:32:26,766
representation we want to get

907
00:32:27,156 --> 0:32:28,346
from the public key.

908
00:32:29,026 --> 0:32:30,546
Multiple representations of

909
00:32:30,546 --> 0:32:32,406
public keys exist, and we have

910
00:32:32,456 --> 0:32:35,916
support in CryptoKit for a lot

911
00:32:35,916 --> 0:32:36,216
of them.

912
00:32:37,536 --> 0:32:39,886
In this case, we're taking the

913
00:32:39,886 --> 0:32:41,106
compact representation.

914
00:32:41,776 --> 0:32:44,106
As always, we're storing the

915
00:32:44,106 --> 0:32:45,586
private key in the Keychain.

916
00:32:46,676 --> 0:32:48,996
Sample code in order to do that

917
00:32:48,996 --> 0:32:50,236
will be available on the

918
00:32:50,236 --> 0:32:51,266
developer portal.

919
00:32:51,266 --> 0:32:54,946
In order to produce the

920
00:32:54,946 --> 0:32:57,456
signature, we are calling the

921
00:32:57,516 --> 0:32:59,346
signature method on the private

922
00:32:59,346 --> 0:33:02,446
key, and we're passing the

923
00:32:59,346 --> 0:33:02,446
key, and we're passing the

924
00:33:02,446 --> 0:33:03,796
transaction data we wish to

925
00:33:03,796 --> 0:33:05,486
sign, and this returns the

926
00:33:05,486 --> 0:33:05,926
signature.

927
00:33:09,136 --> 0:33:13,126
Now, this key that protects

928
00:33:13,266 --> 0:33:16,416
these operations is of high

929
00:33:16,416 --> 0:33:19,366
value, so we want to give it the

930
00:33:19,366 --> 0:33:21,416
best security it can.

931
00:33:21,906 --> 0:33:23,316
That's where the Secure Enclave

932
00:33:23,396 --> 0:33:23,846
comes in.

933
00:33:25,716 --> 0:33:27,726
The Secure Enclave is s

934
00:33:27,726 --> 0:33:29,156
hardware-based key manager

935
00:33:29,466 --> 0:33:30,886
that's isolated from the main

936
00:33:30,886 --> 0:33:32,816
processor to provide an extra

937
00:33:32,816 --> 0:33:33,766
layer of security.

938
00:33:34,466 --> 0:33:36,316
It is used as part of critical

939
00:33:36,316 --> 0:33:38,106
system features, such as Touch

940
00:33:38,106 --> 0:33:39,606
ID or Face ID.

941
00:33:41,336 --> 0:33:45,186
Let's see how to improve on or

942
00:33:45,186 --> 0:33:48,156
code that uses signatures to

943
00:33:48,156 --> 0:33:49,576
take advantage of the Secure

944
00:33:49,576 --> 0:33:49,986
Enclave.

945
00:33:50,596 --> 0:33:54,726
We start by checking if a Secure

946
00:33:54,726 --> 0:33:56,186
Enclave is available on the

947
00:33:56,186 --> 0:33:56,496
device.

948
00:33:57,206 --> 0:34:00,476
We do so by calling isAvailable

949
00:33:57,206 --> 0:34:00,476
We do so by calling isAvailable

950
00:34:00,476 --> 0:34:01,446
on SecureEnclave.

951
00:34:01,936 --> 0:34:07,286
And from there, we can use

952
00:34:07,286 --> 0:34:09,565
exactly the same code as before

953
00:34:10,886 --> 0:34:14,356
in order to produce, to generate

954
00:34:14,356 --> 0:34:15,516
the key and produce the

955
00:34:15,516 --> 0:34:17,696
signature within the Secure

956
00:34:17,696 --> 0:34:18,076
Enclave.

957
00:34:18,606 --> 0:34:20,966
Note that in order to do so, we

958
00:34:21,016 --> 0:34:24,656
simply prefix or call to the

959
00:34:24,656 --> 0:34:27,985
PrivateKey initializer call that

960
00:34:27,985 --> 0:34:30,016
generates the key, and we prefix

961
00:34:30,016 --> 0:34:31,356
it with Secure Enclave dot.

962
00:34:32,596 --> 0:34:34,735
It's that easy to take advantage

963
00:34:34,835 --> 0:34:35,746
of the Secure Enclave.

964
00:34:37,755 --> 0:34:41,646
An advantage of using the Secure

965
00:34:41,646 --> 0:34:43,456
Enclave is that you can

966
00:34:43,456 --> 0:34:44,536
constrain key usage.

967
00:34:45,096 --> 0:34:48,045
In this case, we want to say

968
00:34:48,045 --> 0:34:50,126
that the key that we're

969
00:34:50,126 --> 0:34:51,755
generating on the Secure Enclave

970
00:34:52,656 --> 0:34:54,866
is only accessible when the

971
00:34:54,866 --> 0:34:58,596
device is unlocked and that this

972
00:34:58,596 --> 0:35:01,026
key will be available on this

973
00:34:58,596 --> 0:35:01,026
key will be available on this

974
00:35:01,026 --> 0:35:01,786
device only.

975
00:35:02,886 --> 0:35:04,706
We can further constrain key

976
00:35:04,706 --> 0:35:06,816
usage by saying that when we're

977
00:35:06,816 --> 0:35:09,556
performing an operation with the

978
00:35:09,556 --> 0:35:11,566
private key, we want to require

979
00:35:11,566 --> 0:35:12,326
user presence.

980
00:35:13,496 --> 0:35:16,076
Requiring user presence means

981
00:35:16,076 --> 0:35:18,006
that the user will either be

982
00:35:18,006 --> 0:35:19,186
prompted for biometric

983
00:35:19,186 --> 0:35:22,336
authentication or they will be

984
00:35:22,336 --> 0:35:24,316
requested for their device

985
00:35:24,386 --> 0:35:24,846
password.

986
00:35:25,466 --> 0:35:29,956
Now that we have composed an

987
00:35:29,956 --> 0:35:32,156
access control policy, we are

988
00:35:32,216 --> 0:35:33,726
simply passing it to the

989
00:35:33,726 --> 0:35:35,426
initializer of the key we're

990
00:35:35,426 --> 0:35:39,106
generating, and that policy will

991
00:35:39,106 --> 0:35:39,616
be enforced.

992
00:35:40,626 --> 0:35:41,846
You might want to give some

993
00:35:41,846 --> 0:35:43,576
additional context to your users

994
00:35:43,656 --> 0:35:45,646
about why they're required to

995
00:35:45,646 --> 0:35:46,236
authenticate.

996
00:35:46,886 --> 0:35:49,216
In order to do so, you can pass

997
00:35:49,216 --> 0:35:51,126
a LocalAuthentication context.

998
00:35:51,696 --> 0:35:56,206
In this case, we say that we

999
00:35:56,236 --> 0:35:58,166
want the LocalAuthentication

1000
00:35:58,166 --> 0:36:00,376
context to be valid for ten

1001
00:35:58,166 --> 0:36:00,376
context to be valid for ten

1002
00:36:00,376 --> 0:36:02,476
seconds, so the user will not be

1003
00:36:02,476 --> 0:36:03,896
required to reauthenticate

1004
00:36:04,426 --> 0:36:06,746
during that amount of time, and

1005
00:36:07,116 --> 0:36:09,056
we want to tell the user that

1006
00:36:09,056 --> 0:36:10,546
they're required to authenticate

1007
00:36:10,656 --> 0:36:12,476
because they're authorizing a

1008
00:36:12,476 --> 0:36:14,066
$10 transfer to Bob.

1009
00:36:14,576 --> 0:36:17,506
In order to use that

1010
00:36:17,786 --> 0:36:19,516
authentication context, you

1011
00:36:19,556 --> 0:36:22,236
simply pass it to the key's

1012
00:36:22,316 --> 0:36:23,136
initializer.

1013
00:36:26,976 --> 0:36:28,766
Finally, let's talk about

1014
00:36:28,766 --> 0:36:29,456
performance.

1015
00:36:32,226 --> 0:36:33,876
CryptoKit is built on top of

1016
00:36:33,876 --> 0:36:34,546
corecrypto.

1017
00:36:35,386 --> 0:36:37,556
Corecrypto is Apple's native

1018
00:36:38,056 --> 0:36:40,286
cryptographic library that

1019
00:36:40,286 --> 0:36:41,816
features all of the system

1020
00:36:41,816 --> 0:36:42,916
frameworks that Yannick has

1021
00:36:42,916 --> 0:36:43,726
described before.

1022
00:36:44,306 --> 0:36:47,676
With the help of the team that

1023
00:36:47,676 --> 0:36:48,726
brought you the Accelerate

1024
00:36:48,726 --> 0:36:50,826
framework and the CPU design

1025
00:36:50,866 --> 0:36:53,216
team, corecrypto has hand-tuned

1026
00:36:53,216 --> 0:36:55,196
assembly code, squeezing every

1027
00:36:55,196 --> 0:36:57,646
cycle out of each of the support

1028
00:36:57,646 --> 0:36:58,646
micro architectures.

1029
00:37:00,636 --> 0:37:03,466
In addition to that, because it

1030
00:37:03,466 --> 0:37:05,776
uses corecrypto, it takes

1031
00:37:05,776 --> 0:37:07,916
advantage of security

1032
00:37:07,916 --> 0:37:10,886
mitigations in corecrypto such

1033
00:37:10,886 --> 0:37:13,986
as side-channel resistance, and

1034
00:37:14,356 --> 0:37:16,446
because corecrypto is FIPS

1035
00:37:16,446 --> 0:37:19,156
validated, that means that you

1036
00:37:19,156 --> 0:37:21,496
can use CryptoKit in the FIPS

1037
00:37:21,496 --> 0:37:22,196
compliant way.

1038
00:37:22,996 --> 0:37:24,576
Yannick opened with this slide

1039
00:37:24,716 --> 0:37:27,586
showing large categories of bug

1040
00:37:27,586 --> 0:37:31,006
classes that are available in

1041
00:37:31,006 --> 0:37:32,236
cryptographic protocols and

1042
00:37:32,236 --> 0:37:33,076
implementations.

1043
00:37:34,116 --> 0:37:36,086
With CryptoKit, we are starting

1044
00:37:36,086 --> 0:37:37,896
to eliminate some of these bug

1045
00:37:37,896 --> 0:37:40,036
classes, but CryptoKit remains a

1046
00:37:40,036 --> 0:37:42,036
low-level crypto API that's

1047
00:37:42,036 --> 0:37:44,226
powerful to let you implement a

1048
00:37:44,226 --> 0:37:46,236
wide range of protocols, even

1049
00:37:46,236 --> 0:37:48,906
broken ones.

1050
00:37:49,076 --> 0:37:50,726
Not all cryptographic weaknesses

1051
00:37:50,726 --> 0:37:52,046
can be addressed at the level of

1052
00:37:52,046 --> 0:37:53,136
the cryptographic library.

1053
00:37:53,496 --> 0:37:55,266
Therefore, we strongly recommend

1054
00:37:55,266 --> 0:37:56,706
you to rely on higher level

1055
00:37:56,706 --> 0:37:59,626
system frameworks when you can.

1056
00:38:00,176 --> 0:38:01,786
This is only the beginning, and

1057
00:38:01,786 --> 0:38:03,586
we want to continue helping you

1058
00:38:03,686 --> 0:38:05,646
ship the safest apps as possible

1059
00:38:05,846 --> 0:38:07,646
by delivering on APIs that help

1060
00:38:07,646 --> 0:38:08,856
you prevent secure legal

1061
00:38:08,856 --> 0:38:09,846
vulnerabilities in your

1062
00:38:09,846 --> 0:38:10,526
applications.

1063
00:38:11,056 --> 0:38:13,486
We can't wait for you to start

1064
00:38:13,486 --> 0:38:15,566
adopting CryptoKit in your apps.

1065
00:38:15,896 --> 0:38:17,146
On the page of this session,

1066
00:38:17,446 --> 0:38:18,546
you'll find a link to the

1067
00:38:18,546 --> 0:38:20,986
CryptoKit documentation, and it

1068
00:38:20,986 --> 0:38:22,536
comes with Xcode Playground.

1069
00:38:23,746 --> 0:38:25,866
Download it, play with it for an

1070
00:38:25,866 --> 0:38:28,096
hour, and see what's available.

1071
00:38:28,756 --> 0:38:30,596
See how you could take advantage

1072
00:38:30,596 --> 0:38:32,366
of CryptoKit in your apps.

1073
00:38:34,156 --> 0:38:36,016
We will be at the labs tomorrow

1074
00:38:36,376 --> 0:38:38,466
to answer any of your questions,

1075
00:38:38,466 --> 0:38:39,816
and we're looking forward to

1076
00:38:39,816 --> 0:38:40,366
your feedback.

1077
00:38:40,926 --> 0:38:41,636
Thank you.

1078
00:38:42,016 --> 0:38:44,000
[ Applause ]
