1
00:00:06,039 --> 0:00:10,911
（与SwiftUI相整合）

2
00:00:18,085 --> 0:00:19,052
下午好

3
00:00:19,520 --> 0:00:21,021
我是Tanu Singhal

4
00:00:21,455 --> 0:00:23,156
我和我的同事Raleigh一起

5
00:00:23,557 --> 0:00:27,461
今天跟大家分享

6
00:00:28,161 --> 0:00:29,863
（目标）

7
00:00:29,930 --> 0:00:31,331
今天我们的第一个目标是

8
00:00:31,765 --> 0:00:35,903
帮助你在你现有的app中

9
00:00:37,137 --> 0:00:43,577
接下来我们学习如何在SwiftUI中

10
00:00:44,778 --> 0:00:49,483
稍后我们讲设置数据模型的策略

11
00:00:49,550 --> 0:00:51,685
从而使数据模型

12
00:00:52,753 --> 0:00:56,023
最后我们学习使用拖放、

13
00:00:56,089 --> 0:00:59,359
粘贴模式和SwiftUI中的

14
00:00:59,426 --> 0:01:02,596
从而使我们的app

15
00:00:59,426 --> 0:01:02,596
从而使我们的app

16
00:01:05,566 --> 0:01:10,137
在app上托管SwiftUI内容

17
00:01:10,204 --> 0:01:11,572
（在你的app中

18
00:01:11,638 --> 0:01:14,808
我们通过托管控制器来实现

19
00:01:16,476 --> 0:01:22,716
托管控制器可以用于

20
00:01:22,783 --> 0:01:25,552
ViewController

21
00:01:27,688 --> 0:01:31,358
托管控制器在全部三个框架中都可用

22
00:01:33,927 --> 0:01:37,865
首先让我们具体看一下

23
00:01:39,499 --> 0:01:44,004
UIHostingController

24
00:01:45,172 --> 0:01:49,476
它有一个初始化程序 可获取一个

25
00:01:50,644 --> 0:01:53,714
我们要把SwiftUI视图

26
00:01:55,182 --> 0:01:57,718
一旦对托管控制器进行了初始化

27
00:01:57,985 --> 0:02:03,156
它通过代码或Storyboard

28
00:01:57,985 --> 0:02:03,156
它通过代码或Storyboard

29
00:02:05,692 --> 0:02:09,128
对于Mac 我们有

30
00:02:09,830 --> 0:02:14,735
用于在NSViewController中

31
00:02:16,603 --> 0:02:18,372
现在如果你是Mac开发人员

32
00:02:18,639 --> 0:02:22,442
你可能并不总是希望呈现

33
00:02:23,076 --> 0:02:27,314
也许你想在你现有的AppKit

34
00:02:27,381 --> 0:02:30,017
嵌入一个小的SwiftUI视图

35
00:02:31,351 --> 0:02:34,555
为此我们有

36
00:02:35,756 --> 0:02:39,560
NSHostingView

37
00:02:39,826 --> 0:02:43,697
用于直接在AppKit视图等级中

38
00:02:43,764 --> 0:02:46,400
呈现SwiftUI视图

39
00:02:48,468 --> 0:02:50,170
如果你使用了自动布局

40
00:02:50,904 --> 0:02:52,472
我们会自动遵守

41
00:02:52,539 --> 0:02:56,076
你的SwiftUI视图的

42
00:02:56,376 --> 0:02:58,812
并且你的布局将满足你的预期

43
00:03:00,714 --> 0:03:04,918
当使用容器视图在你现有的

44
00:03:04,985 --> 0:03:09,289
嵌入UIHostingControllers

45
00:03:09,723 --> 0:03:13,660
也可以使用自动布局

46
00:03:16,930 --> 0:03:21,668
对于watchOS开发人员

47
00:03:22,936 --> 0:03:26,139
要使用它 你首先要创建一个子类

48
00:03:26,907 --> 0:03:31,378
在子类中 我们会从主体中返回

49
00:03:32,346 --> 0:03:34,781
接下来进入Storyboard

50
00:03:35,716 --> 0:03:39,286
并选择任意界面控制器或托管控制器

51
00:03:40,921 --> 0:03:46,159
从身份检测器中

52
00:03:46,226 --> 0:03:48,128
把类设置为你的自定义子类

53
00:03:49,396 --> 0:03:54,034
现在托管控制器可以与任何

54
00:03:55,369 --> 0:03:57,671
如果你由于发生在

55
00:03:57,738 --> 0:04:00,674
需要使主体无效

56
00:03:57,738 --> 0:04:00,674
需要使主体无效

57
00:04:01,008 --> 0:04:04,811
你可通过使用

58
00:04:04,878 --> 0:04:07,414
和updateBodyIfNeeded方法实现

59
00:04:09,183 --> 0:04:15,689
在动态交互式通知中使用

60
00:04:17,024 --> 0:04:21,361
为此我们使用WKUserNotification

61
00:04:22,296 --> 0:04:26,466
再一次 我们首先从主体中返回

62
00:04:27,134 --> 0:04:30,037
然后每次调用

63
00:04:30,103 --> 0:04:33,207
这个主体都会被更新

64
00:04:35,776 --> 0:04:39,246
要了解关于用SwiftUI

65
00:04:39,746 --> 0:04:42,616
请查看watchOS上的

66
00:04:45,452 --> 0:04:48,589
现在让我们看一个示例app

67
00:04:48,655 --> 0:04:51,325
关于我们需要在哪里使用

68
00:04:52,993 --> 0:04:55,195
几天前我出门去买一些植物

69
00:04:56,296 --> 0:04:58,966
我学习了很多

70
00:04:59,233 --> 0:05:03,003
我决定创建一个

71
00:04:59,233 --> 0:05:03,003
我决定创建一个

72
00:05:04,538 --> 0:05:07,407
我开始使用UIKit创建app

73
00:05:08,008 --> 0:05:11,812
你在这里看到的是一个

74
00:05:13,547 --> 0:05:16,049
然后我学习了SwiftUI

75
00:05:16,583 --> 0:05:20,821
并使用SwiftUI为我的app

76
00:05:22,122 --> 0:05:25,158
现在我还没有添加任何

77
00:05:25,225 --> 0:05:28,228
从UIKitTableViewController

78
00:05:29,663 --> 0:05:32,566
让我们进行一次演示

79
00:05:32,966 --> 0:05:39,806
（关于在你的app中

80
00:05:47,181 --> 0:05:49,149
在这里我们有SwiftUI视图

81
00:05:50,050 --> 0:05:52,519
用于呈现详情视图

82
00:05:52,953 --> 0:05:55,422
这是当我们轻触表时

83
00:05:55,489 --> 0:05:57,024
想要导航到的视图

84
00:05:57,891 --> 0:05:59,626
让我们进入Storyboard

85
00:06:03,363 --> 0:06:05,866
Storyboard将进入库

86
00:06:06,333 --> 0:06:08,502
并查找托管视图控制器

87
00:06:09,169 --> 0:06:11,738
让我们在Storyboard中

88
00:06:13,507 --> 0:06:17,511
我要选择表中的这个网格

89
00:06:17,578 --> 0:06:19,813
并把它拖动到托管控制器中

90
00:06:20,547 --> 0:06:22,316
选择显示跳转

91
00:06:23,517 --> 0:06:27,221
现在我们需要在这个托管控制器中

92
00:06:27,788 --> 0:06:30,724
因此让我们打开另一侧的

93
00:06:33,260 --> 0:06:35,963
让我隐藏其中一些面板

94
00:06:39,199 --> 0:06:41,668
现在我要选择我们刚创建的跳转

95
00:06:42,236 --> 0:06:45,639
按住Control键

96
00:06:46,607 --> 0:06:49,243
这会创建一个

97
00:06:50,944 --> 0:06:54,181
IBSegueActions

98
00:06:54,248 --> 0:06:58,218
允许你把Storyboard中的

99
00:06:58,485 --> 0:07:00,187
你的视图控制器代码

100
00:06:58,485 --> 0:07:00,187
你的视图控制器代码

101
00:07:00,854 --> 0:07:01,955
通过使用这些

102
00:07:02,022 --> 0:07:05,759
你可以直接在你的目标视图控制器中

103
00:07:05,826 --> 0:07:08,762
而不需要使用

104
00:07:13,300 --> 0:07:14,168
谢谢

105
00:07:16,904 --> 0:07:19,907
让我们关闭Storyboard

106
00:07:21,608 --> 0:07:25,045
在这里我要创建一个

107
00:07:26,280 --> 0:07:29,883
这里的rootView被设置到了

108
00:07:29,950 --> 0:07:31,785
PlantDetailsView

109
00:07:32,753 --> 0:07:35,722
我们所要做的就是

110
00:07:36,223 --> 0:07:38,692
托管控制器的初始化工具中

111
00:07:41,228 --> 0:07:42,629
现在当我们运行我们的app时

112
00:07:43,063 --> 0:07:46,767
我们将可以从

113
00:07:47,568 --> 0:07:50,804
导航到我们的PlantDetailsView

114
00:07:54,508 --> 0:07:57,744
（关于在你的app中

115
00:08:01,615 --> 0:08:07,354
我们在这演示中看到了在app中

116
00:08:08,589 --> 0:08:13,594
接下来我们要学习

117
00:08:13,660 --> 0:08:15,596
嵌入使用现有框架创建的视图

118
00:08:17,097 --> 0:08:20,067
为此我们要使用

119
00:08:20,901 --> 0:08:25,973
Representable协议允许我们

120
00:08:26,039 --> 0:08:29,209
和WKInterfaceObject

121
00:08:29,276 --> 0:08:30,544
（Representable

122
00:08:30,611 --> 0:08:34,914
此外我们还可以在SwiftUI中

123
00:08:34,982 --> 0:08:38,118
通过视图控制器

124
00:08:40,287 --> 0:08:43,857
Representable

125
00:08:44,258 --> 0:08:46,827
Make方法和Update方法

126
00:08:48,428 --> 0:08:49,730
Make方法

127
00:08:50,364 --> 0:08:54,902
是创建你希望在SwiftUI中

128
00:08:55,636 --> 0:08:59,039
而Update方法是把这个视图

129
00:08:59,106 --> 0:09:00,841
更新为当前配置的地方

130
00:08:59,106 --> 0:09:00,841
更新为当前配置的地方

131
00:09:02,009 --> 0:09:05,812
在初始化过程中

132
00:09:05,879 --> 0:09:08,015
然后再调用Update方法

133
00:09:09,416 --> 0:09:12,452
可以多次调用Update方法

134
00:09:12,519 --> 0:09:15,889
无论何时当SwiftUI

135
00:09:17,891 --> 0:09:21,695
最后我们为你提供了一个

136
00:09:22,129 --> 0:09:25,332
你可以在视图或控制器被移除之前

137
00:09:25,399 --> 0:09:27,835
在Dismantle方法中

138
00:09:30,170 --> 0:09:33,207
现在让我们看看这些方法的

139
00:09:33,273 --> 0:09:34,474
Swift定义

140
00:09:36,210 --> 0:09:39,713
请注意Make、Update

141
00:09:39,780 --> 0:09:43,283
在跨平台上看起来和用起来很相似

142
00:09:44,384 --> 0:09:46,320
对于AppKit和UIKit

143
00:09:46,954 --> 0:09:50,357
这些协议可用于

144
00:09:50,424 --> 0:09:52,926
在SwiftUI中

145
00:09:53,760 --> 0:09:58,732
对于WatchKit 我们可以使用

146
00:09:59,032 --> 0:10:03,704
在SwiftUI中呈现

147
00:09:59,032 --> 0:10:03,704
在SwiftUI中呈现

148
00:10:05,072 --> 0:10:08,442
你可以在developer.apple.com上

149
00:10:08,509 --> 0:10:10,410
所支持的WatchKitObjects的

150
00:10:12,346 --> 0:10:13,714
那么正如我们所提到过的

151
00:10:13,780 --> 0:10:17,584
Make和Update方法

152
00:10:17,651 --> 0:10:22,422
呈现视图的仅有的两个必需方法

153
00:10:23,257 --> 0:10:26,393
然而视图通常很复杂

154
00:10:26,660 --> 0:10:29,363
你想做的可能不仅仅是

155
00:10:29,429 --> 0:10:30,564
（视图的高级整合）

156
00:10:30,631 --> 0:10:36,436
也许你想在SwiftUI中

157
00:10:38,205 --> 0:10:42,442
或你可能想从SwiftUI的

158
00:10:42,509 --> 0:10:43,944
并做出相应的响应

159
00:10:45,379 --> 0:10:50,184
了解你的视图上是否有动画

160
00:10:52,219 --> 0:10:57,524
为了让你能更好地整合

161
00:10:57,824 --> 0:11:00,494
我们创建了

162
00:10:57,824 --> 0:11:00,494
我们创建了

163
00:11:01,862 --> 0:11:05,299
Representable

164
00:11:05,766 --> 0:11:07,935
第一个是coordinator

165
00:11:08,468 --> 0:11:12,239
帮助协调你的视图和SwiftUI

166
00:11:13,106 --> 0:11:16,877
coordinator

167
00:11:16,944 --> 0:11:19,880
比如委托、数据源和目标动作

168
00:11:19,947 --> 0:11:21,515
（Representable

169
00:11:21,582 --> 0:11:24,284
下一个属性是

170
00:11:24,718 --> 0:11:28,055
帮助你读取SwiftUI的环境

171
00:11:28,522 --> 0:11:32,759
可以是系统环境 比如色性或尺寸类

172
00:11:32,826 --> 0:11:34,528
或明确的方向

173
00:11:35,162 --> 0:11:39,399
或是app定义的自定义环境属性

174
00:11:40,534 --> 0:11:43,237
最后是transaction属性

175
00:11:44,137 --> 0:11:48,876
让我们的视图了解

176
00:11:50,811 --> 0:11:54,348
Representable

177
00:11:54,414 --> 0:11:57,518
视图控制器以及界面控制器中使用

178
00:11:59,620 --> 0:12:01,755
现在让我们再看一下

179
00:11:59,620 --> 0:12:01,755
现在让我们再看一下

180
00:12:01,822 --> 0:12:04,691
我们之前看到过的

181
00:12:05,859 --> 0:12:09,830
在Make和Update方法中

182
00:12:10,230 --> 0:12:12,099
我们为Representable

183
00:12:13,100 --> 0:12:18,238
这个情境已经拥有关于environment

184
00:12:19,373 --> 0:12:21,842
然而如果你想使用

185
00:12:22,176 --> 0:12:24,044
你需要自己创建

186
00:12:24,745 --> 0:12:25,812
可以通过

187
00:12:25,879 --> 0:12:28,582
使用可选的Make Coordinator

188
00:12:29,983 --> 0:12:31,685
在初始化过程中

189
00:12:31,752 --> 0:12:34,388
首先调用

190
00:12:34,454 --> 0:12:37,624
然后是Make View

191
00:12:38,091 --> 0:12:40,661
从而当你配置你的视图时

192
00:12:40,994 --> 0:12:43,864
coordinator

193
00:12:45,899 --> 0:12:48,569
通过例子来理解这些概念

194
00:12:48,635 --> 0:12:50,170
可能容易得多

195
00:12:51,538 --> 0:12:53,907
我们再看一下我们的植物app

196
00:12:54,241 --> 0:12:56,844
这是我们刚才看到过的详情视图

197
00:12:57,845 --> 0:13:00,147
它是在SwiftUI中创建的视图

198
00:12:57,845 --> 0:13:00,147
它是在SwiftUI中创建的视图

199
00:13:01,682 --> 0:13:05,485
我还在UIKit中

200
00:13:06,086 --> 0:13:07,855
用于呈现评级

201
00:13:08,822 --> 0:13:09,823
我想要做的就是

202
00:13:10,224 --> 0:13:15,629
在我的SwiftUI视图中嵌入

203
00:13:17,364 --> 0:13:22,169
除此之外 我还想在

204
00:13:22,236 --> 0:13:25,172
可以从我的评级控件中读取评级

205
00:13:26,673 --> 0:13:31,378
这些全部都可以通过

206
00:13:32,145 --> 0:13:34,281
让我们在演示中实现这些功能

207
00:13:34,348 --> 0:13:36,950
（关于在SwiftUI中

208
00:13:39,419 --> 0:13:43,056
在这个项目中 我包含了一个

209
00:13:43,490 --> 0:13:47,327
它是基于UIKit的视图

210
00:13:47,895 --> 0:13:51,598
它就是我们要在SwiftUI中

211
00:13:53,367 --> 0:13:58,772
RatingsControlRepresentation

212
00:13:59,106 --> 0:14:02,943
它可以让我们在SwiftUI中

213
00:13:59,106 --> 0:14:02,943
它可以让我们在SwiftUI中

214
00:14:04,478 --> 0:14:07,080
我们还为UIViewRepresentable协议

215
00:14:07,347 --> 0:14:12,252
即makeUIView

216
00:14:14,087 --> 0:14:15,923
在makeUIView方法中

217
00:14:16,456 --> 0:14:20,761
我所要做的就是

218
00:14:21,094 --> 0:14:24,665
也就是这里的

219
00:14:25,799 --> 0:14:26,934
通过这个代码

220
00:14:27,000 --> 0:14:30,270
我可以开始在SwiftUI中

221
00:14:30,337 --> 0:14:31,839
使用RatingsControlRepresentation了

222
00:14:32,539 --> 0:14:34,408
让我们看看预览

223
00:14:37,878 --> 0:14:40,614
这些星星的显示

224
00:14:40,681 --> 0:14:43,817
调用RatingsControlRepresentation

225
00:14:43,884 --> 0:14:47,154
这反过来呈现了

226
00:14:48,222 --> 0:14:51,525
然而请注意

227
00:14:52,426 --> 0:14:55,229
要根据评级正确设置突显

228
00:14:55,729 --> 0:14:58,465
我们需要从SwiftUI中

229
00:14:58,732 --> 0:15:01,001
并把它设置到

230
00:14:58,732 --> 0:15:01,001
并把它设置到

231
00:15:02,669 --> 0:15:06,373
在我们的代码中

232
00:15:06,440 --> 0:15:08,942
因此我们可以

233
00:15:10,477 --> 0:15:13,514
现在让我们进入

234
00:15:14,047 --> 0:15:16,517
并在UI视图上设置评级

235
00:15:20,821 --> 0:15:24,491
星星将立即按照我们所预期的那样

236
00:15:25,559 --> 0:15:28,295
并且这是我们从SwiftUI中

237
00:15:31,398 --> 0:15:32,232
谢谢

238
00:15:35,169 --> 0:15:38,205
我们要进入实时模式查看

239
00:15:38,972 --> 0:15:43,410
在这预览中 我在SwiftUI中

240
00:15:43,677 --> 0:15:45,946
用于把评级更新为零

241
00:15:47,114 --> 0:15:48,715
请注意当我轻触它时

242
00:15:49,216 --> 0:15:52,252
会调用

243
00:15:52,319 --> 0:15:54,988
并把评级上传到我们的UI视图上

244
00:15:55,989 --> 0:15:59,426
我们还可以轻触星星修改评级

245
00:16:00,727 --> 0:16:02,763
当我轻触这些星星时

246
00:16:03,263 --> 0:16:06,667
右侧的标签并没有进行适当的更新

247
00:16:07,968 --> 0:16:14,374
原因是我们的UI视图对于评级

248
00:16:14,641 --> 0:16:17,911
并且不会把固有值

249
00:16:18,912 --> 0:16:20,180
为了解决这个问题

250
00:16:20,247 --> 0:16:23,183
我们要使用目标动作模式

251
00:16:23,817 --> 0:16:26,019
让我们继续并实施它

252
00:16:27,621 --> 0:16:31,525
要使用目标动作模式

253
00:16:32,125 --> 0:16:33,927
让我们在这里创建一个协调器

254
00:16:34,828 --> 0:16:36,730
这只是个NSObject

255
00:16:37,564 --> 0:16:41,602
是我们存储我们所感兴趣的值的地方

256
00:16:42,302 --> 0:16:46,073
并且我们有一个初始化工具

257
00:16:46,406 --> 0:16:47,875
就是这里的评级

258
00:16:49,142 --> 0:16:54,147
接下来我们给评级添加了一个叫做

259
00:16:54,715 --> 0:16:58,418
我们通过目标动作模式调用它

260
00:16:58,852 --> 0:17:02,489
在这里我们仅仅把协调器的评级

261
00:16:58,852 --> 0:17:02,489
在这里我们仅仅把协调器的评级

262
00:17:02,756 --> 0:17:05,492
设置为我们从UI视图中

263
00:17:06,993 --> 0:17:09,930
现在我们可以实施

264
00:17:10,998 --> 0:17:12,165
在这个方法中

265
00:17:12,432 --> 0:17:15,636
我们仅仅是返回协调器的一个实例

266
00:17:15,969 --> 0:17:20,273
并且我们从RatingsControl

267
00:17:23,242 --> 0:17:27,781
最后我们可以在makeUIView方法中

268
00:17:28,682 --> 0:17:30,050
并添加目标

269
00:17:31,652 --> 0:17:32,486
这样

270
00:17:32,553 --> 0:17:35,322
无论何时当在UIKit中 触发

271
00:17:35,656 --> 0:17:39,226
就调用协调器

272
00:17:40,227 --> 0:17:43,096
现在我们已经准备好

273
00:17:43,897 --> 0:17:45,866
我要进入

274
00:17:47,267 --> 0:17:49,870
在这里调用

275
00:17:51,271 --> 0:17:55,709
我们还可以设置一个

276
00:17:56,443 --> 0:17:58,545
让我们重新预览一下

277
00:18:01,415 --> 0:18:02,816
我要进入实时模式

278
00:18:04,451 --> 0:18:07,154
现在当我轻触这些星星时

279
00:18:07,688 --> 0:18:11,191
值和文本标签如我们所期待的那样

280
00:18:15,896 --> 0:18:19,066
（关于在SwiftUI中

281
00:18:21,068 --> 0:18:24,371
我们希望你对于在你的app中

282
00:18:24,805 --> 0:18:25,939
作为第一步

283
00:18:26,206 --> 0:18:28,942
用SwiftUI内容

284
00:18:29,009 --> 0:18:30,777
创建一些托管控制器

285
00:18:31,345 --> 0:18:36,049
使用IBSegueActions把托管控制器

286
00:18:36,116 --> 0:18:37,417
（试一下！）

287
00:18:37,484 --> 0:18:40,787
如果你已经创建好

288
00:18:40,854 --> 0:18:43,190
想要嵌入到

289
00:18:43,257 --> 0:18:45,692
你可以了解一下

290
00:18:46,460 --> 0:18:50,497
最后一定要利用

291
00:18:50,564 --> 0:18:52,299
实现更高级的功能

292
00:18:53,367 --> 0:18:58,305
接下来Raleigh会讲

293
00:18:58,372 --> 0:19:00,007
（与你的数据模型相整合）

294
00:18:58,372 --> 0:19:00,007
（与你的数据模型相整合）

295
00:19:05,345 --> 0:19:06,280
谢谢Tanu

296
00:19:07,948 --> 0:19:09,116
我是Raleigh Ledet

297
00:19:09,183 --> 0:19:12,085
我既是SwiftUI

298
00:19:13,020 --> 0:19:17,324
你们已经了解在你现有的app中

299
00:19:17,391 --> 0:19:18,825
迅速添加

300
00:19:19,092 --> 0:19:20,827
并且我们已经得到了数据

301
00:19:21,195 --> 0:19:24,064
但我想讲的是如何真正把它

302
00:19:25,866 --> 0:19:29,136
你在Tanu的演示中所看到的是

303
00:19:29,469 --> 0:19:31,905
传递给我们的根SwiftUI视图

304
00:19:32,873 --> 0:19:34,341
这非常棒 因为SwiftUI视图

305
00:19:34,408 --> 0:19:36,710
能取出适当的属性

306
00:19:36,777 --> 0:19:37,945
并且我们能对这些属性进行渲染

307
00:19:38,712 --> 0:19:41,882
然而这更应该叫做单次操作

308
00:19:41,949 --> 0:19:42,850
（静态数据）

309
00:19:43,283 --> 0:19:46,753
因为我们的数据模型是存在于

310
00:19:46,820 --> 0:19:48,522
SwiftUI框架之外

311
00:19:48,589 --> 0:19:49,823
（动态数据）

312
00:19:49,890 --> 0:19:52,359
这意味着如果我们的数据模型

313
00:19:52,426 --> 0:19:54,528
也许是云发生变更

314
00:19:54,995 --> 0:19:56,463
SwiftUI将不了解这些变更

315
00:19:56,864 --> 0:19:59,266
并且它也不会对我们的数据内容

316
00:20:01,001 --> 0:20:02,102
我们的方案是

317
00:20:02,803 --> 0:20:05,372
BindableObject

318
00:20:06,006 --> 0:20:07,674
它是一个非常简单的协议

319
00:20:07,741 --> 0:20:11,278
你所要做的就是公开发布一个

320
00:20:14,548 --> 0:20:17,251
一旦你实施了

321
00:20:17,317 --> 0:20:19,953
你就在SwiftUI视图中遵守了

322
00:20:20,587 --> 0:20:25,692
就是我们之前引用数据模型的那个

323
00:20:25,759 --> 0:20:29,196
现在我们可以使用

324
00:20:30,464 --> 0:20:34,334
它告诉SwiftUI我们正引用

325
00:20:34,635 --> 0:20:37,237
然后它就知道它可以为这个视图订阅

326
00:20:37,905 --> 0:20:39,606
现在无论何时当你的数据发生变更时

327
00:20:40,007 --> 0:20:44,144
didChange发布器

328
00:20:44,211 --> 0:20:46,046
发布有数据发生了变更

329
00:20:46,113 --> 0:20:48,949
当然 其中一个订阅者

330
00:20:49,416 --> 0:20:51,218
现在SwiftUI自动了解

331
00:20:51,285 --> 0:20:53,520
哪个视图正在引用你的数据模型

332
00:20:53,587 --> 0:20:54,821
并需要更新

333
00:20:55,989 --> 0:20:56,823
此外

334
00:20:58,258 --> 0:21:00,961
我们可以使用$加数据

335
00:20:58,258 --> 0:21:00,961
我们可以使用$加数据

336
00:21:01,395 --> 0:21:03,497
并可以对数据模型

337
00:21:04,231 --> 0:21:05,432
使用捆绑

338
00:21:05,499 --> 0:21:08,235
这将使我们拥有直接重写

339
00:21:08,569 --> 0:21:09,870
数据模型的权限

340
00:21:11,538 --> 0:21:14,508
因此现在 无论何时当我们做修改时

341
00:21:14,575 --> 0:21:17,077
这些修改都将直接

342
00:21:18,879 --> 0:21:19,847
因此正如你所看到的

343
00:21:20,347 --> 0:21:22,850
BindableObecject

344
00:21:22,916 --> 0:21:25,018
再一次 你只需要实施一个属性

345
00:21:25,686 --> 0:21:27,254
并且它有很高的灵活性

346
00:21:27,988 --> 0:21:30,490
它可以使许多发布器

347
00:21:30,557 --> 0:21:34,261
与你正在使用的

348
00:21:34,528 --> 0:21:36,697
记录在你的数据模型中所发生的变更

349
00:21:37,865 --> 0:21:39,633
并且这里的关键点是我们想确保

350
00:21:39,700 --> 0:21:42,202
你的数据模型在你的app中

351
00:21:42,269 --> 0:21:43,804
保持数据的单一数据来源

352
00:21:45,205 --> 0:21:47,174
这在SwiftUI中非常重要

353
00:21:48,075 --> 0:21:51,545
我们总是希望你的数据模型

354
00:21:51,612 --> 0:21:53,413
都只有单一的事实来源

355
00:21:54,481 --> 0:21:57,351
与声明性视图等级一起

356
00:21:57,417 --> 0:21:59,920
就不再需要给同步数据

357
00:22:00,187 --> 0:22:01,588
写入视图控制器了

358
00:22:05,492 --> 0:22:06,860
现在让我们在演示中看一下

359
00:22:08,629 --> 0:22:11,798
Tanu过来找我的时候

360
00:22:12,266 --> 0:22:13,634
我非常激动

361
00:22:14,401 --> 0:22:16,403
并且我想参与并提供一些帮助

362
00:22:16,470 --> 0:22:18,939
我想从写Mac版app开始

363
00:22:20,407 --> 0:22:22,709
因此我们就开始写app

364
00:22:23,277 --> 0:22:25,646
我做Mac版

365
00:22:26,146 --> 0:22:27,481
然后我们达到了相同的目标

366
00:22:27,915 --> 0:22:29,516
当我们看到SwiftUI时

367
00:22:30,150 --> 0:22:31,385
我们感到惊叹万分

368
00:22:31,451 --> 0:22:34,254
因为我们可以使用

369
00:22:34,788 --> 0:22:36,023
并写我们的详情视图

370
00:22:40,093 --> 0:22:41,295
那么在这里我们正在

371
00:22:42,062 --> 0:22:44,765
运行同一个app

372
00:22:46,099 --> 0:22:49,136
那么在这里

373
00:22:49,203 --> 0:22:51,672
右侧有同样的详情视图

374
00:22:54,041 --> 0:22:55,175
但现在我们想再进一步

375
00:22:55,242 --> 0:22:57,311
把它真正与我们的数据模型

376
00:22:57,377 --> 0:22:59,780
从而我们可以修改我们的详情视图

377
00:22:59,847 --> 0:23:01,915
并变更反映到我们的数据模型中

378
00:22:59,847 --> 0:23:01,915
并变更反映到我们的数据模型中

379
00:23:03,050 --> 0:23:04,117
这是我们的数据模型

380
00:23:04,618 --> 0:23:06,587
你可以看到

381
00:23:11,191 --> 0:23:13,760
我们所拥有的就是一些植物

382
00:23:14,127 --> 0:23:16,797
嗯 我特别想指出一点

383
00:23:18,332 --> 0:23:19,833
无论何时当植物发生变更时

384
00:23:19,900 --> 0:23:22,836
我们都会发布一个

385
00:23:23,437 --> 0:23:25,639
我们这样做是为了

386
00:23:25,973 --> 0:23:29,743
可以监听变更

387
00:23:30,344 --> 0:23:33,614
但因为我们已经发布了一个通知

388
00:23:33,680 --> 0:23:38,619
我们要使用那个通知来实施

389
00:23:41,388 --> 0:23:42,990
那么这是我们对

390
00:23:43,056 --> 0:23:46,527
我们对PlantsDidChange使用了

391
00:23:46,593 --> 0:23:49,129
我们使用self作为

392
00:23:49,830 --> 0:23:52,199
现在我想指出另外一点

393
00:23:53,600 --> 0:23:56,503
对数据的修改需要通知

394
00:23:56,970 --> 0:24:00,007
主线程上的SwiftUI

395
00:23:56,970 --> 0:24:00,007
主线程上的SwiftUI

396
00:24:00,073 --> 0:24:03,477
因此我们用receive(on)

397
00:24:03,544 --> 0:24:05,312
我们的发布器向主线程上

398
00:24:06,847 --> 0:24:10,450
现在我们的数据模型已经准备好了

399
00:24:11,118 --> 0:24:13,253
在这里你可以看到我们引用了

400
00:24:13,320 --> 0:24:14,521
我们的

401
00:24:15,489 --> 0:24:16,957
现在我们可以添加

402
00:24:21,962 --> 0:24:23,297
我们的

403
00:24:25,866 --> 0:24:28,202
现在我们正在使用

404
00:24:28,268 --> 0:24:30,904
我们要向下进入…

405
00:24:30,971 --> 0:24:34,107
我们在isEditing状态上现有视图

406
00:24:35,876 --> 0:24:38,212
我已经在EditablePlantsView中写好了

407
00:24:38,278 --> 0:24:41,315
我想指出的是

408
00:24:41,381 --> 0:24:44,585
从而我们可以对指定植物索引

409
00:24:46,620 --> 0:24:48,155
现在我们要重新运行app

410
00:24:51,592 --> 0:24:55,128
现在通过那个简单的修改

411
00:24:55,195 --> 0:24:59,233
当我们点击编辑按钮时

412
00:24:59,299 --> 0:25:01,502
你可以看到立即更新了表视图

413
00:24:59,299 --> 0:25:01,502
你可以看到立即更新了表视图

414
00:25:01,568 --> 0:25:05,005
我非常喜欢夏威夷木槿

415
00:25:05,072 --> 0:25:07,875
那么现在我们已经直接

416
00:25:07,941 --> 0:25:10,410
我们随时可以重新回到数据模型中

417
00:25:17,584 --> 0:25:19,119
（关于与我们的数据相整合的演示）

418
00:25:22,389 --> 0:25:26,126
如你在那个演示中所见 我使用了

419
00:25:26,193 --> 0:25:28,695
因此我只需要使用NotificationCenter

420
00:25:29,296 --> 0:25:31,265
但我们还有其它类型的发布器

421
00:25:31,765 --> 0:25:34,334
比如关键值观察发布器

422
00:25:36,537 --> 0:25:41,275
遵守KVO的任何对象都有一个

423
00:25:41,341 --> 0:25:44,111
你可以通过对关键值函数

424
00:25:44,178 --> 0:25:45,612
使用发布器来获取它

425
00:25:46,547 --> 0:25:49,149
但让我们再看一个更有意思的例子

426
00:25:50,350 --> 0:25:53,654
在这个例子中 我们有一个类用于

427
00:25:53,954 --> 0:25:56,456
在用户默认中监看

428
00:25:58,825 --> 0:26:00,294
有意思的是

429
00:25:58,825 --> 0:26:00,294
有意思的是

430
00:26:01,061 --> 0:26:03,497
我们给每个用户默认都创建了一个

431
00:26:03,564 --> 0:26:06,166
一个用于userOption1

432
00:26:06,700 --> 0:26:09,870
但我们把它们合并到了一个发布器中

433
00:26:11,438 --> 0:26:13,807
并应用到我们的

434
00:26:15,175 --> 0:26:16,109
因此现在

435
00:26:16,176 --> 0:26:20,013
无论当userOption1或

436
00:26:21,014 --> 0:26:25,519
didChange合并发布器

437
00:26:25,586 --> 0:26:27,721
并且SwiftUI将更新

438
00:26:29,022 --> 0:26:30,157
（合并）

439
00:26:30,224 --> 0:26:33,060
所有发布器都经由合并框架

440
00:26:33,126 --> 0:26:35,529
并且那还有更多发布器

441
00:26:35,596 --> 0:26:38,198
并且合并框架是一个很强大的新框架

442
00:26:38,265 --> 0:26:41,869
它是一个统一的声明性API

443
00:26:41,935 --> 0:26:44,171
（合并）

444
00:26:44,238 --> 0:26:47,341
除了你在合并操作器看到的发布器

445
00:26:47,407 --> 0:26:48,809
还有大量不同的操作器

446
00:26:48,876 --> 0:26:53,180
执行复杂的合并或把不同的发布器

447
00:26:54,314 --> 0:26:57,484
我强烈建议你观看

448
00:26:58,785 --> 0:27:03,557
然而我想指出另一个指定发布器

449
00:26:58,785 --> 0:27:03,557
然而我想指出另一个指定发布器

450
00:27:03,924 --> 0:27:05,392
即PassthroughSubject

451
00:27:06,660 --> 0:27:09,196
如果你的数据模型遇到这样一种情况

452
00:27:09,263 --> 0:27:12,165
合并框架中没有任何一个发布器

453
00:27:12,599 --> 0:27:15,002
适用于你的情况

454
00:27:15,669 --> 0:27:19,106
你可以使用PassthroughSubject

455
00:27:20,007 --> 0:27:21,542
如果你有一个核心数据app

456
00:27:21,975 --> 0:27:25,112
那么你就已经在使用

457
00:27:25,179 --> 0:27:27,681
来从数据库中取出数据了

458
00:27:28,649 --> 0:27:32,186
并且NSFetchedResultsController

459
00:27:32,252 --> 0:27:33,287
以帮助协调

460
00:27:34,254 --> 0:27:37,457
你需要实施的其中一个委托消息是

461
00:27:37,925 --> 0:27:40,727
controllerDidChangeContent

462
00:27:41,395 --> 0:27:44,031
当数据库中的数据发生变更时

463
00:27:44,097 --> 0:27:46,800
当数据发生变更时

464
00:27:47,334 --> 0:27:51,038
因此我们抓取我们的didChange

465
00:27:51,405 --> 0:27:53,640
我们要告诉它手动发送变更

466
00:27:53,707 --> 0:27:56,543
现在SwiftUI把它看作是

467
00:27:56,610 --> 0:27:58,745
并更新你的全部视图

468
00:27:59,713 --> 0:28:01,248
（处理数据流的工具）

469
00:27:59,713 --> 0:28:01,248
（处理数据流的工具）

470
00:28:01,315 --> 0:28:03,684
我主要讲

471
00:28:04,451 --> 0:28:06,753
但还有许多工具可以帮助你管理

472
00:28:06,820 --> 0:28:08,922
SwiftUI之内和之外的数据

473
00:28:09,423 --> 0:28:14,061
SwiftUI中的数据流

474
00:28:14,394 --> 0:28:15,395
非常具体地讲了所有的数据工具

475
00:28:15,729 --> 0:28:19,233
同时讨论了何时使用

476
00:28:20,801 --> 0:28:22,803
（与系统相整合）

477
00:28:22,870 --> 0:28:23,737
现在当然了

478
00:28:24,505 --> 0:28:26,540
当你运行SwiftUI界面时

479
00:28:26,607 --> 0:28:28,141
你并不是只需要思考

480
00:28:28,208 --> 0:28:30,210
与你的数据模型相整合

481
00:28:30,544 --> 0:28:33,280
你还需要思考

482
00:28:33,347 --> 0:28:37,818
与iOS和macOS的拖放相整合

483
00:28:38,952 --> 0:28:41,989
以及也许是与watchOS上的

484
00:28:44,791 --> 0:28:47,461
让我们从item提供器开始讲

485
00:28:48,428 --> 0:28:50,430
item提供器是一个强大的技术

486
00:28:50,497 --> 0:28:52,399
由基础框架提供

487
00:28:52,733 --> 0:28:55,903
为你提供一种围绕你的app

488
00:28:55,969 --> 0:28:57,237
以不同形式移动数据的方法

489
00:28:57,304 --> 0:29:01,842
它还是用于帮助在各进程间

490
00:28:57,304 --> 0:29:01,842
它还是用于帮助在各进程间

491
00:29:03,343 --> 0:29:07,514
从大体上说item提供器

492
00:29:07,581 --> 0:29:11,485
描述你的item可以表示为

493
00:29:11,752 --> 0:29:15,489
当然了 你需要按照请求

494
00:29:16,723 --> 0:29:19,960
请记住 之前在演示中我指出

495
00:29:20,027 --> 0:29:22,963
我们需要在主线程上修改数据

496
00:29:23,030 --> 0:29:24,932
而item提供器是异步的

497
00:29:25,832 --> 0:29:27,668
因此当你让数据

498
00:29:27,734 --> 0:29:29,770
你需要确保你实际上修改了数据

499
00:29:29,837 --> 0:29:31,805
或让发布器在主线程上进行发布

500
00:29:33,774 --> 0:29:35,809
我们使用item提供器和拖放

501
00:29:36,343 --> 0:29:41,882
因此你可以使用onDrag修改器

502
00:29:42,282 --> 0:29:44,384
那么现在当用户开始在你的视图上

503
00:29:44,451 --> 0:29:47,354
我们将调用闭包 然后你就可以

504
00:29:47,654 --> 0:29:48,488
它会

505
00:29:49,056 --> 0:29:51,191
提供与那个视图相关联的数据

506
00:29:51,258 --> 0:29:54,127
然后我们会自动渲染你的视图

507
00:29:54,194 --> 0:29:55,863
并把它用作DragImage

508
00:29:55,929 --> 0:29:56,997
（拖放）

509
00:29:57,064 --> 0:30:00,501
要接受一个释放

510
00:29:57,064 --> 0:30:00,501
要接受一个释放

511
00:30:01,268 --> 0:30:02,836
通过onDrop修改器

512
00:30:03,403 --> 0:30:07,474
你可以传递一些

513
00:30:07,908 --> 0:30:10,577
这个字符串描述你可以在你的视图上

514
00:30:11,478 --> 0:30:12,613
如果用户在你的视图上释放

515
00:30:13,680 --> 0:30:15,182
那种类型的数据

516
00:30:15,249 --> 0:30:18,085
我们将自动调用你的动作闭包

517
00:30:18,151 --> 0:30:21,622
并提供一些

518
00:30:22,489 --> 0:30:23,924
当然我们还将告诉你

519
00:30:23,991 --> 0:30:26,894
在你的视图中

520
00:30:27,895 --> 0:30:31,031
onDrop修改器还有另一个变量

521
00:30:31,098 --> 0:30:34,468
它获取的是委托闭包

522
00:30:34,935 --> 0:30:37,237
并且当释放在你的视图中四处移动时

523
00:30:37,304 --> 0:30:40,007
委托为你提供关于释放过程的

524
00:30:40,073 --> 0:30:42,009
比如你可以在用户实际释放

525
00:30:42,075 --> 0:30:46,013
并实施释放动作之前获得游标的位置

526
00:30:48,448 --> 0:30:50,884
我们还在pasteboard中

527
00:30:51,952 --> 0:30:52,819
因此比如说如果你想接受

528
00:30:53,387 --> 0:30:57,224
一个粘贴命令 你可以使用

529
00:30:58,492 --> 0:31:00,928
类似于onDrop修改器

530
00:30:58,492 --> 0:31:00,928
类似于onDrop修改器

531
00:31:00,994 --> 0:31:04,331
你提供一些通用类型识别器

532
00:31:04,398 --> 0:31:05,332
然后就可以接受粘贴了

533
00:31:05,699 --> 0:31:07,234
当用户在你的视图上进行粘贴时

534
00:31:07,301 --> 0:31:09,870
我们将提供一些item提供器

535
00:31:10,537 --> 0:31:11,705
然而我想指出一些

536
00:31:12,372 --> 0:31:16,043
使onPaste与onDrop

537
00:31:17,477 --> 0:31:20,614
第一个是

538
00:31:20,681 --> 0:31:21,548
闭包中没有位置参数

539
00:31:21,915 --> 0:31:23,951
这对于这里所发生的操作至关重要

540
00:31:24,952 --> 0:31:26,720
当你拖放时

541
00:31:26,787 --> 0:31:30,991
用户直接通过游标或触摸位置标定

542
00:31:31,058 --> 0:31:32,659
应该接受释放的视图

543
00:31:34,127 --> 0:31:35,929
但粘贴命令更间接一些

544
00:31:36,296 --> 0:31:38,932
用户要么选择从菜单中粘贴

545
00:31:38,999 --> 0:31:41,535
或也许是使用键盘捷径

546
00:31:41,602 --> 0:31:43,904
或使用iOS中的新手势

547
00:31:46,773 --> 0:31:49,510
我们了解

548
00:31:49,576 --> 0:31:52,779
粘贴命令即将在哪个视图上执行的

549
00:31:53,580 --> 0:31:56,783
焦点系统是一个很重要的工具

550
00:31:57,251 --> 0:32:01,088
它是用户用于导航不同的UI元素

551
00:31:57,251 --> 0:32:01,088
它是用户用于导航不同的UI元素

552
00:32:01,154 --> 0:32:02,456
并通知我们没有特别指向的动作

553
00:32:03,290 --> 0:32:06,093
应该发生在哪里

554
00:32:08,028 --> 0:32:12,533
它在Mac上很有用

555
00:32:12,599 --> 0:32:15,169
和菜单动作命令 在iOS中

556
00:32:15,802 --> 0:32:17,604
是对键盘命令

557
00:32:17,671 --> 0:32:22,709
此外还有复制-粘贴和撤销-重做

558
00:32:22,776 --> 0:32:25,112
（焦点）

559
00:32:25,179 --> 0:32:29,082
在tvOS上尤其重要

560
00:32:29,149 --> 0:32:30,284
在这里焦点是我们如何决定

561
00:32:30,350 --> 0:32:35,255
用户想在哪里实施

562
00:32:36,657 --> 0:32:40,994
对于watchOS 我们使用焦点

563
00:32:44,364 --> 0:32:45,232
它的运作方式是

564
00:32:45,799 --> 0:32:48,101
在某一时刻你拥有视图等级

565
00:32:48,836 --> 0:32:51,371
其中一个视图将被作为焦点视图

566
00:32:52,005 --> 0:32:54,374
当用户实施间接动作时

567
00:32:54,441 --> 0:32:56,210
比如旋转表冠

568
00:32:56,977 --> 0:32:59,413
我们会检查焦点视图是否

569
00:33:00,180 --> 0:33:02,649
有针对那种命令的视图修改器

570
00:33:02,716 --> 0:33:04,384
在这个例子中是表冠命令

571
00:33:04,852 --> 0:33:07,721
如果它有 我们会调用适当的闭包

572
00:33:08,188 --> 0:33:12,726
如果它没有 我们会沿原型向上

573
00:33:12,793 --> 0:33:13,627
尝试找到一个拥有表冠命令的

574
00:33:14,261 --> 0:33:17,598
并调用适当的闭包

575
00:33:19,333 --> 0:33:23,203
SwiftUI将在每个平台上

576
00:33:23,637 --> 0:33:25,038
恰当地处理

577
00:33:25,873 --> 0:33:27,608
从一个视图到另一个视图的移动焦点

578
00:33:28,842 --> 0:33:31,478
你所需要做的唯一一件事就是

579
00:33:31,545 --> 0:33:34,414
哪个SwiftUI视图

580
00:33:34,481 --> 0:33:36,517
你可以通过focususable

581
00:33:37,551 --> 0:33:41,555
除了leaf控件 比如文本字段

582
00:33:44,124 --> 0:33:44,958
SwiftUI视图

583
00:33:45,692 --> 0:33:47,094
默认不会成为焦点视图

584
00:33:47,160 --> 0:33:48,829
因此你需要使用

585
00:33:48,896 --> 0:33:51,832
和Passthrough告诉我们

586
00:33:52,766 --> 0:33:56,003
你可以视需要传递一个

587
00:33:56,069 --> 0:33:58,605
当你的视图得到或失去焦点时

588
00:33:58,672 --> 0:34:01,341
你可以使用这个来更新你的UI

589
00:33:58,672 --> 0:34:01,341
你可以使用这个来更新你的UI

590
00:34:01,975 --> 0:34:04,611
从而为用户提供视觉反馈通知他们

591
00:34:05,546 --> 0:34:06,613
（命令）

592
00:34:06,680 --> 0:34:09,917
我们有许多命令 如onExit

593
00:34:09,983 --> 0:34:13,920
这些例子来自于tvOS

594
00:34:14,621 --> 0:34:16,790
但我现在要讲的是

595
00:34:16,857 --> 0:34:19,159
通用的onCommand修改器

596
00:34:19,760 --> 0:34:24,164
这是你用于指示动作的工具

597
00:34:24,231 --> 0:34:27,701
从Objective-C-style

598
00:34:27,768 --> 0:34:30,737
比如说从菜单传送到第一个响应器

599
00:34:30,804 --> 0:34:34,440
或从工具栏按钮

600
00:34:34,507 --> 0:34:37,911
再一次 这是它在iOS上的用法

601
00:34:39,279 --> 0:34:40,179
并且它们是可链接的

602
00:34:40,246 --> 0:34:41,514
因此假如说如果你的视图可以接受

603
00:34:42,149 --> 0:34:44,251
三个菜单项

604
00:34:44,318 --> 0:34:46,652
你还可以给你的视图附加三个

605
00:34:46,719 --> 0:34:49,690
每个都有适当的选择器

606
00:34:50,958 --> 0:34:52,492
（撤销和重做）

607
00:34:52,559 --> 0:34:54,393
现在我知道你们的app

608
00:34:54,460 --> 0:34:57,130
全都已经有很强大的

609
00:34:57,998 --> 0:34:58,899
在SwiftUI中

610
00:34:58,966 --> 0:35:01,802
我们所用的UndoManager

611
00:34:58,966 --> 0:35:01,802
我们所用的UndoManager

612
00:35:03,537 --> 0:35:04,371
并且

613
00:35:04,771 --> 0:35:07,608
在绝大部分情况下 当你向app中

614
00:35:08,041 --> 0:35:08,876
添加新SwiftUI时

615
00:35:08,942 --> 0:35:12,279
你不需在UndoManager中

616
00:35:12,346 --> 0:35:15,282
特别是当你的撤销注册

617
00:35:15,349 --> 0:35:17,818
在较低层上接近数据模型时执行时

618
00:35:18,952 --> 0:35:19,920
然而

619
00:35:19,987 --> 0:35:22,189
如果你需要使用

620
00:35:22,523 --> 0:35:25,792
你可以通过environment

621
00:35:26,126 --> 0:35:27,828
通过UndoManager

622
00:35:31,632 --> 0:35:33,033
（Objective-C整合）

623
00:35:33,100 --> 0:35:36,203
现在SwiftUI很明显是一个

624
00:35:38,005 --> 0:35:41,074
但我们知道你已经拥有大量

625
00:35:41,608 --> 0:35:43,076
Swift中的

626
00:35:43,143 --> 0:35:46,046
已经可以很好地整合到一起了

627
00:35:47,014 --> 0:35:50,417
同样地 你也可以用SwiftUI

628
00:35:51,518 --> 0:35:54,454
适用标准的

629
00:35:55,155 --> 0:35:58,525
基本上 当涉及

630
00:35:58,592 --> 0:36:00,627
你需要包装Swift中的

631
00:35:58,592 --> 0:36:00,627
你需要包装Swift中的

632
00:36:00,694 --> 0:36:02,930
或托管视图

633
00:36:04,431 --> 0:36:07,334
在这个例子中

634
00:36:07,601 --> 0:36:10,337
我要给UIViewController

635
00:36:10,604 --> 0:36:14,007
我把它放在

636
00:36:14,074 --> 0:36:17,544
这会允许我稍后在

637
00:36:17,611 --> 0:36:19,880
实例化这些Swift类

638
00:36:21,515 --> 0:36:23,784
现在 在我们的Swift实施内

639
00:36:23,851 --> 0:36:27,321
我们可以实例化

640
00:36:27,387 --> 0:36:29,723
并把它传到适当的

641
00:36:31,758 --> 0:36:34,761
现在我们有

642
00:36:34,828 --> 0:36:37,164
我们可以从Objective-C

643
00:36:37,231 --> 0:36:39,199
就像其它任何

644
00:36:39,266 --> 0:36:40,934
在这个例子中 我们只是呈现了它

645
00:36:43,704 --> 0:36:46,240
类似地 你也需要包装你的数据模型

646
00:36:47,508 --> 0:36:50,744
那样我们就可以实施

647
00:36:51,745 --> 0:36:53,680
那么这里我们有个简单的

648
00:36:54,348 --> 0:36:55,282
我们要

649
00:36:56,016 --> 0:37:00,754
通过这里的NotificationCenter

650
00:36:56,016 --> 0:37:00,754
通过这里的NotificationCenter

651
00:37:00,821 --> 0:37:01,688
这是个例子

652
00:37:01,755 --> 0:37:05,292
让我们假设ObjCDataModel

653
00:37:05,559 --> 0:37:07,861
NotificationCenter通知

654
00:37:08,629 --> 0:37:12,766
那么我们只需要把它引用到

655
00:37:13,700 --> 0:37:14,902
它的运作方式是

656
00:37:16,370 --> 0:37:18,071
在WrappedHostingController中

657
00:37:18,138 --> 0:37:21,241
你要给ObjCDataModel传递一个

658
00:37:21,308 --> 0:37:24,178
在你的托管控制器中 你可以创建

659
00:37:24,645 --> 0:37:29,016
并把它分配为你的ObjCDataModel

660
00:37:29,283 --> 0:37:31,051
传递到你的

661
00:37:31,919 --> 0:37:34,955
仅通过这两个简单包装的类

662
00:37:35,789 --> 0:37:38,158
你现在已经可以把SwiftUI

663
00:37:38,425 --> 0:37:39,693
和Objective-C代码

664
00:37:42,029 --> 0:37:42,896
因此正如你所看到的

665
00:37:43,363 --> 0:37:47,201
开始在你的app中

666
00:37:47,501 --> 0:37:48,702
当你添加新UI时

667
00:37:49,636 --> 0:37:50,971
请开始使用SwiftUI

668
00:37:53,874 --> 0:37:57,377
我们明天上午11点有一场讨论会

669
00:37:57,744 --> 0:38:00,214
在你的app中

670
00:37:57,744 --> 0:38:00,214
在你的app中

671
00:38:00,547 --> 0:38:03,016
如果你有任何疑问

672
00:38:03,083 --> 0:38:04,551
我们非常高兴能与你们沟通

673
00:38:04,618 --> 0:38:05,853
我们对SwiftUI感到非常激动

674
00:38:05,919 --> 0:38:07,821
我们已经迫不及待要看到你们

675
00:38:08,522 --> 0:38:10,557
谢谢大家 请享受余下的会议时光
