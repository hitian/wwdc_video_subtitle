1
00:00:07,040 --> 0:00:11,645
（Clang和LLVM中的

2
00:00:11,712 --> 0:00:13,146
在去年

3
00:00:13,680 --> 0:00:16,783
我们一直非常努力地向编译器中

4
00:00:16,850 --> 0:00:17,951
添加一些很棒的新功能

5
00:00:18,585 --> 0:00:19,520
我是Jessica

6
00:00:19,853 --> 0:00:22,923
今天我和我的同事JF和Devin

7
00:00:23,190 --> 0:00:26,193
将与你们分享其中一些非常棒的功能

8
00:00:27,461 --> 0:00:29,096
今天我们有许多内容要讲

9
00:00:29,730 --> 0:00:31,999
我们要讲新平台支持；

10
00:00:32,566 --> 0:00:34,801
一些低级代码尺寸优化；

11
00:00:35,235 --> 0:00:38,038
一些语言级代码尺寸优化；

12
00:00:38,505 --> 0:00:40,340
一些很棒的新诊断；

13
00:00:40,607 --> 0:00:43,810
然后最后我们讲

14
00:00:43,877 --> 0:00:45,779
那会帮助你查找你代码中的错误

15
00:00:46,980 --> 0:00:48,749
我们先讲新平台支持

16
00:00:48,815 --> 0:00:50,017
（新平台支持）

17
00:00:50,083 --> 0:00:53,287
我要特别讲一下

18
00:00:55,455 --> 0:00:59,092
Series 4 Watch

19
00:01:00,727 --> 0:01:04,464
但所有App Store app

20
00:01:06,633 --> 0:01:09,837
对此稀奇的是你们所有的app

21
00:01:10,304 --> 0:01:14,107
都将在Series 4 Watch上

22
00:01:16,610 --> 0:01:17,878
这听起来像是一种魔法

23
00:01:18,312 --> 0:01:19,947
你不需要重新编译任何东西

24
00:01:20,681 --> 0:01:22,316
但所有的app都能无缝运行

25
00:01:24,218 --> 0:01:25,185
这是怎么发生的呢？

26
00:01:26,186 --> 0:01:28,121
现在如果坐在前排的观众

27
00:01:28,188 --> 0:01:30,624
可以给我这样一个击鼓声真是太棒了

28
00:01:30,691 --> 0:01:31,959
但如果你们不愿意也没关系

29
00:01:33,026 --> 0:01:35,796
答案是Bitcode

30
00:01:37,564 --> 0:01:39,533
我什么也没解释

31
00:01:39,600 --> 0:01:42,469
因此…请允许我给你们解释一下

32
00:01:44,171 --> 0:01:46,507
让我们看一些源代码

33
00:01:47,140 --> 0:01:50,010
我们要做的就是要把它交给编译器

34
00:01:50,744 --> 0:01:52,646
现在一般来说你们在这里会

35
00:01:53,113 --> 0:01:55,983
继续标准的编译过程

36
00:01:56,049 --> 0:01:58,752
你会得到 比如二进制或什么东西

37
00:01:59,453 --> 0:02:00,587
但我们不要这样做

38
00:01:59,453 --> 0:02:00,587
但我们不要这样做

39
00:02:01,421 --> 0:02:03,123
我们要做的是

40
00:02:03,190 --> 0:02:05,826
提前停止编译过程

41
00:02:06,326 --> 0:02:09,029
我们要生成

42
00:02:12,032 --> 0:02:14,535
关于LLVM Bitcode

43
00:02:15,235 --> 0:02:18,672
就是它在编译器中编码一个中间状态

44
00:02:18,739 --> 0:02:20,174
（什么是

45
00:02:20,641 --> 0:02:23,043
你可以用这个中间状态

46
00:02:23,810 --> 0:02:27,281
从你停止它的地方

47
00:02:27,814 --> 0:02:28,682
继续进行编译过程

48
00:02:29,917 --> 0:02:30,817
这就是我们要做的操作

49
00:02:31,451 --> 0:02:33,487
这一次我们要在

50
00:02:35,022 --> 0:02:37,891
这样我们可以从一个app中

51
00:02:37,958 --> 0:02:40,294
并从中生成两个不同的app

52
00:02:40,360 --> 0:02:42,162
一个在32位芯片上运行

53
00:02:42,629 --> 0:02:45,365
一个在新型64位芯片上运行

54
00:02:47,401 --> 0:02:49,903
现在这里有个问题

55
00:02:50,704 --> 0:02:53,707
问题就是编译器实际上不知道

56
00:02:53,774 --> 0:02:57,544
你将在一个64位的设备上执行代码

57
00:02:58,345 --> 0:02:59,446
如果它知道的话

58
00:02:59,813 --> 0:03:03,717
它实际上可以利用那个信息

59
00:02:59,813 --> 0:03:03,717
它实际上可以利用那个信息

60
00:03:04,318 --> 0:03:06,253
为了应付这个问题

61
00:03:06,320 --> 0:03:09,556
我们也收集64位芯片的

62
00:03:10,424 --> 0:03:13,160
那可以让我们从

63
00:03:13,827 --> 0:03:14,695
速度非常非常快的app

64
00:03:15,362 --> 0:03:17,297
这非常酷

65
00:03:17,364 --> 0:03:18,198
这就像…

66
00:03:19,499 --> 0:03:21,835
这是其中一件

67
00:03:22,269 --> 0:03:23,337
非常棒 嗯？

68
00:03:25,038 --> 0:03:27,975
现在让我们转到代码尺寸改进上

69
00:03:28,041 --> 0:03:29,343
这是我最喜欢的话题之一

70
00:03:29,409 --> 0:03:30,544
（代码尺寸改进

71
00:03:30,611 --> 0:03:33,447
我们一直致力于让编译器生成

72
00:03:33,514 --> 0:03:34,882
尽可能少的代码

73
00:03:35,816 --> 0:03:38,852
现在代码尺寸非常重要

74
00:03:38,919 --> 0:03:42,556
因为代码越多意味着下载越大、越慢

75
00:03:42,990 --> 0:03:46,660
app越大会占用

76
00:03:46,960 --> 0:03:48,262
并且你也注意到了这种事

77
00:03:48,896 --> 0:03:53,600
因此为了支持用户

78
00:03:53,901 --> 0:03:55,936
这个需求超越了其它的度量

79
00:03:56,870 --> 0:03:59,840
我们在Xcode中添加了一个

80
00:04:00,908 --> 0:04:04,144
即-Oz

81
00:04:05,279 --> 0:04:07,548
我要继续说-Oz

82
00:04:07,614 --> 0:04:10,918
因为我是加拿大人 因此

83
00:04:16,255 --> 0:04:19,760
今天我要给大家展示的是一个

84
00:04:19,826 --> 0:04:21,295
-Oz优化的例子

85
00:04:22,029 --> 0:04:23,497
但在此之前

86
00:04:24,331 --> 0:04:27,701
接下来的几分钟时间 我要尽我所能

87
00:04:27,768 --> 0:04:28,936
给你们讲一下编译器是如何运作的

88
00:04:29,002 --> 0:04:30,137
（编译器是如何运作的？）

89
00:04:31,805 --> 0:04:33,040
当你编译一些代码时

90
00:04:33,974 --> 0:04:36,977
初始表示是非常非常目标独立的

91
00:04:37,044 --> 0:04:38,011
这是源代码

92
00:04:38,679 --> 0:04:40,347
当你把源代码放到编译器中时

93
00:04:41,248 --> 0:04:44,718
它被降级为IR 一种中间表示

94
00:04:45,352 --> 0:04:49,523
这种中间表示的大部分

95
00:04:50,190 --> 0:04:52,826
但它确实有一些内置的目标依赖功能

96
00:04:53,994 --> 0:04:55,729
看起来有点像通用程序集

97
00:04:56,830 --> 0:05:00,267
这时候你就可以停止编译过程

98
00:04:56,830 --> 0:05:00,267
这时候你就可以停止编译过程

99
00:05:00,334 --> 0:05:01,802
并给出一些Bitcode

100
00:05:02,302 --> 0:05:03,203
但我们不会这样做

101
00:05:03,270 --> 0:05:04,271
我们要继续进行编译

102
00:05:05,606 --> 0:05:07,040
那个表示…

103
00:05:07,107 --> 0:05:10,244
将被进一步降级到一个叫做

104
00:05:10,310 --> 0:05:12,179
它是Machine IR的缩写

105
00:05:13,247 --> 0:05:14,948
在编译过程的最后

106
00:05:15,015 --> 0:05:18,952
Machine IR看起来

107
00:05:19,319 --> 0:05:21,221
在这个例子中是64位程序集

108
00:05:21,989 --> 0:05:23,924
我们可以比如说把代码并排放在一起

109
00:05:25,492 --> 0:05:28,996
在我们要讲的优化中

110
00:05:29,730 --> 0:05:32,299
我们要使用Machine IR

111
00:05:33,066 --> 0:05:35,302
但为了让你们感到熟悉

112
00:05:35,369 --> 0:05:37,671
我将在程序集中完成我们所有的示例

113
00:05:37,738 --> 0:05:39,139
因为那看起来没有那么可怕

114
00:05:40,974 --> 0:05:43,877
我要讲的是一种叫做函数概述的

115
00:05:43,944 --> 0:05:45,212
代码尺寸优化

116
00:05:45,279 --> 0:05:46,547
（函数概述

117
00:05:46,613 --> 0:05:49,950
函数概述是其中一种优化

118
00:05:50,017 --> 0:05:52,319
它会尽可能地为你缩小一些尺寸

119
00:05:52,953 --> 0:05:54,821
它在编译器中发挥作用的时间

120
00:05:55,289 --> 0:05:58,225
它实际上不依赖于任意一种

121
00:05:59,593 --> 0:06:02,296
最好是通过例子来解释它的作用

122
00:05:59,593 --> 0:06:02,296
最好是通过例子来解释它的作用

123
00:06:03,430 --> 0:06:06,333
假如你有一些这样的程序集

124
00:06:07,067 --> 0:06:10,804
hasse和kakutani是

125
00:06:11,872 --> 0:06:14,508
对于hasse和kakutani

126
00:06:15,108 --> 0:06:18,011
它们有一些相同的指令

127
00:06:19,279 --> 0:06:20,547
我们可以用它

128
00:06:20,614 --> 0:06:23,150
我们可以获取这些相同的指令

129
00:06:24,151 --> 0:06:26,153
并把它们输出到一个新函数中

130
00:06:27,387 --> 0:06:29,690
在我们把它们输入到新函数之后

131
00:06:30,357 --> 0:06:31,525
我们要做的就是

132
00:06:31,592 --> 0:06:34,127
替换我们所发现的序列

133
00:06:34,595 --> 0:06:36,463
通过调用或分支实现

134
00:06:37,197 --> 0:06:39,900
结果就是我们最后会得到一个

135
00:06:41,068 --> 0:06:42,002
有多小呢？

136
00:06:42,402 --> 0:06:46,139
嗯 对于我们的测试程序来说

137
00:06:50,210 --> 0:06:52,279
现在有些人可能在想

138
00:06:52,346 --> 0:06:54,581
好的 嗯 这里从哪里节约来的呢？

139
00:06:55,282 --> 0:06:57,317
是否是因为复制和粘贴的代码？

140
00:06:57,818 --> 0:06:59,786
是否是因为你的代码需要被重构？

141
00:07:00,554 --> 0:07:03,824
嗯 都不是 实际上这里所发生的事

142
00:07:04,124 --> 0:07:06,593
如果你复制和粘贴了一堆代码

143
00:07:07,094 --> 0:07:08,962
那会影响概述行为

144
00:07:09,029 --> 0:07:11,031
但那还不是最重要的事

145
00:07:12,332 --> 0:07:13,500
让我们来看另一个例子

146
00:07:14,902 --> 0:07:16,203
假如你有这个函数

147
00:07:17,571 --> 0:07:19,506
这个函数是做什么的没有关系

148
00:07:19,573 --> 0:07:23,177
但我们想提出的是

149
00:07:23,243 --> 0:07:25,979
如果我们把这个函数放到编译器中

150
00:07:26,346 --> 0:07:27,314
我们会得到一些程序集

151
00:07:28,615 --> 0:07:32,252
嗯 你可能会得到像这样的东西

152
00:07:33,420 --> 0:07:36,690
再一次 你其实无需了解这个程序集

153
00:07:37,591 --> 0:07:39,526
但我想让你们注意一下…

154
00:07:40,060 --> 0:07:43,263
函数开端和末端的指令

155
00:07:45,165 --> 0:07:47,234
这些叫做函数的序言与结语

156
00:07:47,901 --> 0:07:51,705
这些指令不响应源代码中的

157
00:07:52,673 --> 0:07:55,309
这些是由编译器插入的指令

158
00:07:55,843 --> 0:07:57,945
用于满足某种系统要求

159
00:07:59,446 --> 0:08:01,849
因此这些东西 比如这些存储…

160
00:07:59,446 --> 0:08:01,849
因此这些东西 比如这些存储…

161
00:08:02,583 --> 0:08:03,984
和这些负载

162
00:08:04,051 --> 0:08:06,353
可能会在你整个程序的多个地方出现

163
00:08:07,120 --> 0:08:10,791
这就是概述程序可以用于

164
00:08:10,858 --> 0:08:12,860
缩小程序整体尺寸的东西

165
00:08:16,096 --> 0:08:17,564
但有一些与此相关的陷阱

166
00:08:17,631 --> 0:08:18,498
（陷阱）

167
00:08:19,299 --> 0:08:21,802
首先当你进行概述时

168
00:08:22,769 --> 0:08:24,471
你会修改程序的控制流

169
00:08:25,405 --> 0:08:29,009
在这里你最初可能有ulam

170
00:08:29,576 --> 0:08:32,479
然后你可能把调用概述

171
00:08:33,347 --> 0:08:36,116
这里发生的事就是

172
00:08:36,183 --> 0:08:38,952
我们修改了程序的控制流

173
00:08:40,220 --> 0:08:43,857
那么问题是…

174
00:08:44,491 --> 0:08:46,593
如果在collatz内

175
00:08:47,828 --> 0:08:49,363
嗯 结果就是

176
00:08:49,630 --> 0:08:51,365
你要把你的程序

177
00:08:51,431 --> 0:08:52,966
扔到LLDB中

178
00:08:54,201 --> 0:08:57,571
你将在反向追踪中看到

179
00:08:57,638 --> 0:08:59,840
这是你要留意的东西

180
00:08:59,907 --> 0:09:01,608
如果你实际上在概述代码的话

181
00:08:59,907 --> 0:09:01,608
如果你实际上在概述代码的话

182
00:09:03,343 --> 0:09:05,279
另一件事是概述

183
00:09:05,345 --> 0:09:07,281
可以增加程序的执行时间

184
00:09:08,815 --> 0:09:09,850
你增加了调用

185
00:09:09,917 --> 0:09:11,919
并且调用会增加执行时间

186
00:09:12,819 --> 0:09:14,988
但这其实还好 因为

187
00:09:15,355 --> 0:09:18,625
-Oz优化了尺寸 这超越了一切

188
00:09:19,293 --> 0:09:21,762
当你在-Oz时

189
00:09:23,664 --> 0:09:24,731
因为这个原因

190
00:09:24,798 --> 0:09:29,203
我们不推荐你用-Oz

191
00:09:30,237 --> 0:09:32,306
如果执行时间对你的程序至关重要

192
00:09:32,806 --> 0:09:34,341
-Oz并不是最好的方案

193
00:09:34,408 --> 0:09:35,609
（不要用-Oz编译

194
00:09:35,676 --> 0:09:39,646
然而我们的确推荐你们使用

195
00:09:40,347 --> 0:09:41,782
Instruments会告诉你

196
00:09:41,849 --> 0:09:44,051
你程序中的热点在哪儿

197
00:09:44,117 --> 0:09:46,854
这可以让你做出

198
00:09:47,554 --> 0:09:49,957
关于app优化的最佳决策

199
00:09:50,924 --> 0:09:53,760
编译器有许多不同的优化级别

200
00:09:55,495 --> 0:09:57,030
这些优化级别

201
00:09:58,298 --> 0:09:59,766
都优化不同的东西

202
00:10:01,768 --> 0:10:02,870
比如

203
00:10:03,270 --> 0:10:06,607
-Oz不惜任何代价优化代码尺寸

204
00:10:07,274 --> 0:10:09,843
结果是你可能会有

205
00:10:10,244 --> 0:10:12,012
稍微慢一点点的执行时间

206
00:10:12,646 --> 0:10:14,181
但在另一方面

207
00:10:15,616 --> 0:10:16,884
你有-O3

208
00:10:16,950 --> 0:10:20,921
-O3会不惜任何代价

209
00:10:20,988 --> 0:10:22,823
结果就是

210
00:10:22,890 --> 0:10:24,124
你可能会得到一个尺寸较大的程序

211
00:10:26,226 --> 0:10:31,732
-Os是Xcode中的

212
00:10:31,999 --> 0:10:35,769
因为它很好地平衡了速度和尺寸

213
00:10:36,937 --> 0:10:39,840
但你知道的

214
00:10:39,907 --> 0:10:42,009
因此你可以利用

215
00:10:44,111 --> 0:10:46,680
编译器还提供一些额外的优化

216
00:10:47,181 --> 0:10:48,882
我没有足够的时间讲这些

217
00:10:48,949 --> 0:10:50,884
不过我还是想稍微提一下

218
00:10:51,952 --> 0:10:53,520
它提供PGO

219
00:10:53,787 --> 0:10:55,322
即配置文件引导的优化

220
00:10:55,389 --> 0:10:56,323
（额外优化）

221
00:10:56,390 --> 0:10:57,824
PGO非常酷

222
00:10:57,891 --> 0:11:00,694
因为它允许你实际上执行你的程序

223
00:10:57,891 --> 0:11:00,694
因为它允许你实际上执行你的程序

224
00:11:01,161 --> 0:11:04,131
然后收集关于程序运行得如何的信息

225
00:11:04,631 --> 0:11:08,802
然后当你再次编译程序时

226
00:11:10,070 --> 0:11:11,471
它还提供LTO

227
00:11:11,538 --> 0:11:12,973
即链接时间优化

228
00:11:13,607 --> 0:11:15,943
关于链接时间优化的很酷的事就是

229
00:11:16,009 --> 0:11:18,212
以编译时间为代价

230
00:11:18,278 --> 0:11:20,647
你可以告诉编译器说

231
00:11:21,081 --> 0:11:23,650
“好的 让我们等待直到

232
00:11:23,717 --> 0:11:26,253
我们在程序中得到每一个文件

233
00:11:26,320 --> 0:11:30,557
并用每一个文件来

234
00:11:31,191 --> 0:11:33,527
优化比如代码嵌入或概述

235
00:11:33,861 --> 0:11:36,730
如果有更多的情境 会更好发挥作用

236
00:11:37,831 --> 0:11:40,868
你还可以合并使用这些额外的优化

237
00:11:40,934 --> 0:11:43,036
通过现有优化级别实现

238
00:11:43,337 --> 0:11:46,206
从而获得非常非常优秀的实际性能

239
00:11:47,774 --> 0:11:50,677
因为我没有足够的时间一一讲到

240
00:11:51,245 --> 0:11:54,548
我推荐你们查看之前的

241
00:11:54,948 --> 0:11:56,517
你可以了解更多信息

242
00:11:58,719 --> 0:12:00,521
了解这些之后 你可能在想 好的

243
00:11:58,719 --> 0:12:00,521
了解这些之后 你可能在想 好的

244
00:12:00,587 --> 0:12:01,855
我要如何启用-Oz？

245
00:12:01,922 --> 0:12:04,358
嗯 只需要进入项目的创建设置

246
00:12:04,791 --> 0:12:07,194
并选择-Oz作为优化级别

247
00:12:08,195 --> 0:12:11,298
你还可以在Xcode的特定文件上

248
00:12:11,365 --> 0:12:13,333
启用-Oz或其它优化级别

249
00:12:13,700 --> 0:12:18,038
通过进入项目的创建阶段

250
00:12:18,105 --> 0:12:19,540
并设置编译器标志实现

251
00:12:21,642 --> 0:12:23,377
好的 我给你们讲了很多内容

252
00:12:23,443 --> 0:12:26,480
你很可能在想 好的

253
00:12:26,980 --> 0:12:28,749
我该如何得到这种信息？

254
00:12:28,815 --> 0:12:29,650
（这会对app代码尺寸

255
00:12:29,716 --> 0:12:32,219
嗯 要得到代码尺寸

256
00:12:32,819 --> 0:12:35,689
我推荐一个叫做Size的小工具

257
00:12:36,990 --> 0:12:38,258
我经常使用这个工具

258
00:12:38,325 --> 0:12:39,593
它是一个很不错的小的终端app

259
00:12:40,227 --> 0:12:41,828
Size会为你提供

260
00:12:41,895 --> 0:12:46,200
关于你app的一些很不错的

261
00:12:46,533 --> 0:12:49,403
它不会告诉你app的实际总尺寸

262
00:12:49,469 --> 0:12:52,005
因为它不包含比如像资产一样的东西

263
00:12:52,439 --> 0:12:54,975
如果你在app中

264
00:12:55,042 --> 0:12:56,677
并且有像Hello World

265
00:12:56,743 --> 0:12:58,378
编译器将不会给你提供帮助

266
00:12:59,980 --> 0:13:01,682
但假如你想使用Size

267
00:12:59,980 --> 0:13:01,682
但假如你想使用Size

268
00:13:02,482 --> 0:13:03,784
这是使用方法 非常简单

269
00:13:03,851 --> 0:13:07,020
你只需要告诉Size说

270
00:13:07,921 --> 0:13:09,022
它将会

271
00:13:09,089 --> 0:13:11,558
它将为你提供像这样的输出

272
00:13:12,359 --> 0:13:14,261
它会告诉你

273
00:13:14,328 --> 0:13:16,430
你二进制中的每个片段的尺寸

274
00:13:16,830 --> 0:13:19,499
并且它还会告诉你二进制的整体尺寸

275
00:13:20,534 --> 0:13:22,703
但问题是…

276
00:13:23,203 --> 0:13:27,508
二进制中的每个片段实际上

277
00:13:28,742 --> 0:13:32,112
在这个例子中我只关心可执行指令

278
00:13:32,179 --> 0:13:34,281
因此我要做的就是

279
00:13:34,815 --> 0:13:37,351
为Size提供一些额外标志

280
00:13:38,018 --> 0:13:42,222
这些额外标志是-l和-m标志

281
00:13:42,923 --> 0:13:45,292
我这样做Size将

282
00:13:45,659 --> 0:13:47,895
给我提供每个部分的尺寸

283
00:13:48,395 --> 0:13:51,265
如果我想了解

284
00:13:51,532 --> 0:13:53,734
我只需要查看文本部分即可

285
00:13:55,636 --> 0:13:57,871
我希望这些可以帮助你们

286
00:13:57,938 --> 0:14:00,474
获得关于app代码尺寸的更多理解

287
00:13:57,938 --> 0:14:00,474
获得关于app代码尺寸的更多理解

288
00:14:01,074 --> 0:14:03,143
现在我要走了

289
00:14:03,210 --> 0:14:05,078
同样是加拿大人的JF

290
00:14:05,145 --> 0:14:08,182
他会与大家分享一些

291
00:14:08,248 --> 0:14:10,284
（代码尺寸改进

292
00:14:10,350 --> 0:14:11,485
谢谢Jessica

293
00:14:13,887 --> 0:14:16,823
我是Jeff 我要讲语言级优化

294
00:14:17,124 --> 0:14:21,061
Jessica给你们讲了低级别

295
00:14:21,461 --> 0:14:23,397
我要讲的是

296
00:14:23,463 --> 0:14:24,865
当你使用语言自身时所发生的事

297
00:14:24,932 --> 0:14:26,900
好的 那么是你编写代码的构造

298
00:14:26,967 --> 0:14:28,969
我今天要讲四种优化

299
00:14:29,236 --> 0:14:30,604
它们也会影响代码尺寸

300
00:14:32,472 --> 0:14:35,809
第一个与Objective C

301
00:14:35,876 --> 0:14:38,178
那么代码块有一堆相关联的元数据

302
00:14:38,245 --> 0:14:39,947
是编译器为你生成的

303
00:14:40,647 --> 0:14:43,851
它有元数据以及帮助函数

304
00:14:44,218 --> 0:14:46,720
我们会通过一些例子来看具体的内容

305
00:14:47,487 --> 0:14:50,724
假如说你写了一些代码

306
00:14:51,358 --> 0:14:53,227
好的 那么请注意…

307
00:14:53,527 --> 0:14:55,863
我有两个不同的代码块

308
00:14:55,929 --> 0:14:57,297
代码并不重要

309
00:14:57,364 --> 0:15:01,435
但重点是要注意

310
00:14:57,364 --> 0:15:01,435
但重点是要注意

311
00:15:01,502 --> 0:15:03,370
好的 代码之间并没有任何关系

312
00:15:03,537 --> 0:15:05,138
但它们的结构非常相似

313
00:15:05,205 --> 0:15:07,908
在这一点上

314
00:15:07,975 --> 0:15:11,245
在这个例子中

315
00:15:12,212 --> 0:15:15,682
现在我告诉你每个代码块都有

316
00:15:15,749 --> 0:15:16,717
那是什么样子的？

317
00:15:17,150 --> 0:15:19,853
嗯 这是我们正在讲的元数据 好的

318
00:15:19,920 --> 0:15:22,589
编译器自动为你生成元数据

319
00:15:22,656 --> 0:15:25,893
当你使用代码块来追踪

320
00:15:25,959 --> 0:15:28,128
并给它们提供语言担保的行为时

321
00:15:28,929 --> 0:15:30,898
你要注意的是有代码块尺寸

322
00:15:31,031 --> 0:15:32,799
有一个复制帮助和销毁帮助

323
00:15:32,866 --> 0:15:35,536
我们需要稍微了解一下这两个方法

324
00:15:35,802 --> 0:15:38,405
还有一个代码块方法签名

325
00:15:39,139 --> 0:15:40,607
好的 如果你看一下

326
00:15:40,674 --> 0:15:41,942
屏幕上的例子

327
00:15:42,009 --> 0:15:45,379
这实际上是编译器生成的合成代码

328
00:15:45,445 --> 0:15:47,347
那看起来是一堆技术术语

329
00:15:47,414 --> 0:15:51,485
但重要的是结构自身是一样的

330
00:15:51,552 --> 0:15:53,320
因此我们可以在许多例子中进行复制

331
00:15:53,720 --> 0:15:55,355
请注意在这个例子中我们不能复制

332
00:15:55,656 --> 0:15:59,426
因为除了捕获两个强健的ARC指针

333
00:15:59,493 --> 0:16:02,696
还存在其它捕获

334
00:15:59,493 --> 0:16:02,696
还存在其它捕获

335
00:16:03,330 --> 0:16:05,699
好的 我们不能合并这些情况 好的

336
00:16:05,766 --> 0:16:09,903
但总的来说 在某些情况下

337
00:16:10,270 --> 0:16:12,239
请注意在这个例子中

338
00:16:13,740 --> 0:16:17,911
我们有函数 是的

339
00:16:18,478 --> 0:16:21,548
请注意自Xcode 11起

340
00:16:21,615 --> 0:16:22,482
那么这些是一样的

341
00:16:22,883 --> 0:16:23,617
那意味着什么？

342
00:16:23,684 --> 0:16:27,354
嗯 复制帮助用于帮助你移动代码块

343
00:16:27,688 --> 0:16:31,458
是的 销毁帮助用于帮你移除代码块

344
00:16:31,525 --> 0:16:34,394
当你这样做时 编译器合成的代码

345
00:16:35,095 --> 0:16:36,864
看起来就像这样

346
00:16:38,165 --> 0:16:40,200
好的 那么在我的例子中

347
00:16:40,267 --> 0:16:42,669
我们有两个强健的ARC指针

348
00:16:42,936 --> 0:16:45,172
我们所生成的代码是像那样的代码

349
00:16:45,239 --> 0:16:47,541
当你销毁它时 就会释放它

350
00:16:48,041 --> 0:16:51,011
现在当你复制或销毁时

351
00:16:51,078 --> 0:16:52,446
代码块还有一堆其它事要做

352
00:16:52,713 --> 0:16:54,181
你可能有C++对象

353
00:16:54,248 --> 0:16:55,883
在这种情况下你需要调用

354
00:16:56,350 --> 0:16:58,785
你可能有…以及销毁构造函数

355
00:16:58,852 --> 0:17:01,221
你可能有一些很弱的ARC指针

356
00:16:58,852 --> 0:17:01,221
你可能有一些很弱的ARC指针

357
00:17:01,288 --> 0:17:04,424
你可能有具有意义的C类型

358
00:17:04,491 --> 0:17:06,593
还需要发生许多其它事

359
00:17:06,727 --> 0:17:08,561
但基本上来说 你使用代码块写代码

360
00:17:08,628 --> 0:17:11,298
当编译器检测到有冗余时

361
00:17:11,365 --> 0:17:13,099
我们尝试尽可能地剔除它

362
00:17:13,767 --> 0:17:15,169
这会得到多少好处？

363
00:17:15,234 --> 0:17:17,503
嗯 我们发现在

364
00:17:17,570 --> 0:17:21,040
尺寸大致会缩减百分之二到百分之七

365
00:17:21,108 --> 0:17:22,009
并且这是你免费获得的

366
00:17:22,075 --> 0:17:23,210
它是默认启用的

367
00:17:27,247 --> 0:17:29,216
我要讲的第二个优化

368
00:17:29,316 --> 0:17:33,320
与NSObject的

369
00:17:33,787 --> 0:17:35,055
这太拗口了

370
00:17:35,122 --> 0:17:36,256
我要给你看一个例子

371
00:17:36,323 --> 0:17:38,225
并解释一下具体是什么意思 好的

372
00:17:38,292 --> 0:17:39,626
假如我正在写一个卡牌游戏

373
00:17:39,960 --> 0:17:41,795
我的代码就像这样

374
00:17:41,895 --> 0:17:42,829
关键是要记住

375
00:17:42,896 --> 0:17:45,399
我正在从NSObject中

376
00:17:45,732 --> 0:17:47,835
当我写

377
00:17:47,901 --> 0:17:51,738
我的属性响应实例变量 是的

378
00:17:51,805 --> 0:17:54,174
会自动生成实例变量用于备份

379
00:17:54,241 --> 0:17:56,109
我在这里所拥有的属性 是的

380
00:17:56,677 --> 0:17:58,679
现在我所编写的那个类自身

381
00:17:59,413 --> 0:18:01,615
编译器查看它并生成一个结构

382
00:17:59,413 --> 0:18:01,615
编译器查看它并生成一个结构

383
00:18:01,682 --> 0:18:03,684
看起来大概就像这样 是的

384
00:18:04,084 --> 0:18:06,587
它列出了成员 一个接一个

385
00:18:07,187 --> 0:18:08,956
在Objective C中的

386
00:18:09,022 --> 0:18:12,125
你可以从它派生出一个基类

387
00:18:12,192 --> 0:18:15,262
然后把一个框架中的代码

388
00:18:15,562 --> 0:18:18,699
然后基类也会改变

389
00:18:18,765 --> 0:18:20,934
派生类不会中断 是的

390
00:18:21,001 --> 0:18:23,270
并且Objective…

391
00:18:23,337 --> 0:18:26,406
如果你派生 就会改变基类的布局

392
00:18:26,473 --> 0:18:27,307
你就有新的尺寸

393
00:18:27,875 --> 0:18:29,910
在这里

394
00:18:29,977 --> 0:18:34,081
NSObject实际上

395
00:18:34,147 --> 0:18:36,183
我们知道它不会发生改变 是的

396
00:18:36,483 --> 0:18:39,119
因此我们有类的这种布局

397
00:18:39,453 --> 0:18:41,522
当我们实施类时 是的

398
00:18:41,588 --> 0:18:43,724
我实施这个

399
00:18:44,157 --> 0:18:47,461
我就知道类中的每一个东西的布局

400
00:18:47,728 --> 0:18:51,231
那么自Xcode 11起 编译器

401
00:18:51,298 --> 0:18:53,233
就可以说我知道插件在哪儿

402
00:18:53,767 --> 0:18:55,435
嗯 好的 那实际上是什么意思？

403
00:18:55,936 --> 0:18:57,638
我要看一下这个

404
00:18:59,139 --> 0:19:00,741
它看起来是这样的东西 是的

405
00:18:59,139 --> 0:19:00,741
它看起来是这样的东西 是的

406
00:19:00,807 --> 0:19:02,743
我让

407
00:19:03,010 --> 0:19:05,512
现在设置函数为它生成了一段代码

408
00:19:05,579 --> 0:19:08,415
在Xcode 11之前

409
00:19:08,482 --> 0:19:12,052
它把查找合成到了一个

410
00:19:12,119 --> 0:19:14,821
了解名称属性的插件

411
00:19:15,422 --> 0:19:17,257
代码量很少

412
00:19:17,558 --> 0:19:20,260
但自Xcode 11起

413
00:19:20,327 --> 0:19:23,130
当你实施方法时 我们要硬编码插件

414
00:19:23,397 --> 0:19:25,933
那个方法是S对象的直接派生物

415
00:19:26,433 --> 0:19:28,068
这就可以理解了 我们知道它不会变

416
00:19:28,135 --> 0:19:30,337
因为我们实施的是你刚写的方法

417
00:19:30,571 --> 0:19:31,405
这看起来不重要

418
00:19:31,471 --> 0:19:33,207
只是三个指令中的一个 是的

419
00:19:33,273 --> 0:19:36,076
但它会缩减app

420
00:19:36,910 --> 0:19:37,845
非常棒

421
00:19:40,514 --> 0:19:42,616
我要讲的下一个尺寸优化

422
00:19:42,850 --> 0:19:45,452
是对C++类型改进了可调试性

423
00:19:45,519 --> 0:19:47,521
你可能会说 等一下 这不是尺寸

424
00:19:47,821 --> 0:19:49,156
它是尺寸 让我来解释一下

425
00:19:49,857 --> 0:19:51,258
好的 我说我写了一些代码

426
00:19:52,025 --> 0:19:53,227
这是非常直截了当的代码

427
00:19:53,493 --> 0:19:55,162
它是命令行app 是的

428
00:19:55,596 --> 0:19:59,800
我要做的就是从命令行中取出参数

429
00:20:00,200 --> 0:20:02,135
并把它们转换为整型

430
00:20:02,202 --> 0:20:03,871
并把它们放到

431
00:20:03,937 --> 0:20:06,206
然后把它们一个接一个地打印出来

432
00:20:06,273 --> 0:20:07,975
这是一个非常直截了当的演示app

433
00:20:08,208 --> 0:20:12,179
重点是我使用了标准库的类型

434
00:20:12,646 --> 0:20:14,815
特别是我使用了矢量

435
00:20:14,882 --> 0:20:16,783
我想在这里放一个断点

436
00:20:17,451 --> 0:20:21,421
这在Xcode 11之前

437
00:20:21,488 --> 0:20:24,224
原因是我们控制着

438
00:20:24,591 --> 0:20:27,995
库C++方法的可见性

439
00:20:28,061 --> 0:20:31,565
就像pushback强制把它们

440
00:20:31,632 --> 0:20:32,699
一般来说没有问题

441
00:20:32,766 --> 0:20:36,170
问题是pushback是一系列

442
00:20:36,236 --> 0:20:37,638
四处游逛 删除一些代码

443
00:20:37,938 --> 0:20:40,340
而调试程序 当你告诉它

444
00:20:40,407 --> 0:20:41,742
你不是在尝试进入pushback

445
00:20:41,808 --> 0:20:43,544
你只是想在那一行代码中放一个断点

446
00:20:43,644 --> 0:20:45,112
其实调试程序不知道

447
00:20:45,179 --> 0:20:47,181
因为到处都是 对吧

448
00:20:47,548 --> 0:20:50,384
那么自Xcode 11起

449
00:20:50,450 --> 0:20:51,885
我们不再强制代码嵌入

450
00:20:52,152 --> 0:20:55,522
我们让代码嵌入程序决定

451
00:20:55,589 --> 0:20:57,958
在这个具体的例子中

452
00:20:58,025 --> 0:20:59,226
在Xcode 11之前

453
00:20:59,293 --> 0:21:02,930
你放在那儿的断点实际上会在

454
00:20:59,293 --> 0:21:02,930
你放在那儿的断点实际上会在

455
00:21:02,996 --> 0:21:04,998
因为到处都是pushbacks

456
00:21:05,699 --> 0:21:07,801
自Xcode 11起

457
00:21:07,868 --> 0:21:10,037
这是调试会话

458
00:21:10,103 --> 0:21:11,305
假如我运行lldb

459
00:21:11,772 --> 0:21:14,408
我运行我的程序

460
00:21:15,342 --> 0:21:16,643
是的 非常简单明了

461
00:21:17,244 --> 0:21:19,213
调试程序进入并说耶 断点

462
00:21:19,746 --> 0:21:20,981
现在我点击运行

463
00:21:21,348 --> 0:21:22,182
现在会发生这样的事

464
00:21:23,417 --> 0:21:26,086
好的 那么我在第12行停止了

465
00:21:26,153 --> 0:21:27,421
酷 起作用了 是的

466
00:21:27,788 --> 0:21:30,023
这个演示有点无聊

467
00:21:31,358 --> 0:21:33,794
它原来不会 现在很酷的是

468
00:21:34,127 --> 0:21:35,696
我正在讲代码尺寸优化 是的

469
00:21:35,762 --> 0:21:38,332
嗯 这个 因为我们不强制嵌入

470
00:21:38,398 --> 0:21:40,634
如果你在代码中频繁使用stl

471
00:21:40,701 --> 0:21:43,203
你会创建相当大量的代码膨胀

472
00:21:43,670 --> 0:21:46,874
我们测量了在大app发布模式上

473
00:21:46,940 --> 0:21:49,443
如果你这样做 你会缩减代码尺寸

474
00:21:49,843 --> 0:21:51,612
再一次 这是在发布模式中 对吧

475
00:21:52,079 --> 0:21:55,549
这节约了相当大量的代码

476
00:21:55,983 --> 0:21:56,817
非常棒

477
00:21:57,618 --> 0:21:59,319
我要讲的最后一个缩小代码尺寸的是

478
00:21:59,386 --> 0:22:01,622
C++静态销毁程序抑制

479
00:21:59,386 --> 0:22:01,622
C++静态销毁程序抑制

480
00:22:01,688 --> 0:22:02,523
（C++静态销毁程序抑制）

481
00:22:02,589 --> 0:22:03,557
再一次

482
00:22:03,824 --> 0:22:06,260
让我们通过一个例子来解释

483
00:22:07,027 --> 0:22:09,763
假如我写了一些

484
00:22:09,830 --> 0:22:12,966
大部分app最后都会有一个记录器

485
00:22:13,333 --> 0:22:14,268
当你记录时

486
00:22:14,334 --> 0:22:16,537
你不想在app中传递记录器

487
00:22:16,603 --> 0:22:18,572
因此你有一个全局变量

488
00:22:19,106 --> 0:22:20,340
非常简单明了

489
00:22:20,641 --> 0:22:22,543
在C++中 当你拥有一个这样的

490
00:22:22,609 --> 0:22:25,979
会有一个销毁程序

491
00:22:26,580 --> 0:22:27,781
好的 请注意

492
00:22:27,848 --> 0:22:30,017
logger包含一个缓冲区

493
00:22:30,083 --> 0:22:32,419
这就是销毁程序的功能

494
00:22:32,486 --> 0:22:34,454
它会销毁字符串的那个矢量 是的

495
00:22:34,821 --> 0:22:36,023
目前来说简单明了

496
00:22:36,256 --> 0:22:37,524
现在我进入我的app

497
00:22:37,891 --> 0:22:38,892
它是个游戏

498
00:22:39,359 --> 0:22:40,761
是的 我在这里添加这段代码

499
00:22:40,827 --> 0:22:43,297
它只是个游戏

500
00:22:43,363 --> 0:22:46,600
和一个游戏

501
00:22:47,134 --> 0:22:48,702
代码完全合理 是吧

502
00:22:49,236 --> 0:22:53,540
现在问题是如果我进入

503
00:22:53,941 --> 0:22:55,075
并在游戏结构中添加一些记录代码

504
00:22:55,709 --> 0:22:58,545
嗯 请注意

505
00:22:58,612 --> 0:22:59,780
游戏也是全局的

506
00:23:00,047 --> 0:23:01,548
那可能不太管用

507
00:23:01,615 --> 0:23:04,718
原因是在C++中

508
00:23:05,018 --> 0:23:08,522
不能保证调用销毁程序的次序 是的

509
00:23:08,589 --> 0:23:11,692
在许多情况下 你会在销毁游戏之前

510
00:23:12,025 --> 0:23:15,262
这会导致崩溃 非常不好 是吧

511
00:23:15,662 --> 0:23:17,264
这个问题有点头疼

512
00:23:17,931 --> 0:23:20,200
然后让我们再深入去看

513
00:23:20,267 --> 0:23:23,170
这是C++在我心目中的样子 是的

514
00:23:23,537 --> 0:23:25,973
那么你开始添加线程本地存储

515
00:23:26,039 --> 0:23:27,040
你开始添加线程

516
00:23:27,341 --> 0:23:30,277
比如C++销毁程序次序的图表

517
00:23:30,344 --> 0:23:32,479
非常复杂 它太过复杂了

518
00:23:32,546 --> 0:23:35,249
甚至和编译器的复杂程度差不多

519
00:23:35,682 --> 0:23:37,784
但却没有任何概念 几个月前我需要

520
00:23:37,851 --> 0:23:40,354
在非常罕见的情况下

521
00:23:40,621 --> 0:23:43,524
Clang会在终端发生崩溃 是吧

522
00:23:43,590 --> 0:23:44,625
这有点尴尬

523
00:23:44,691 --> 0:23:47,628
这只是表明要得到正确的销毁次序

524
00:23:47,694 --> 0:23:49,897
并不是一件小事 好吧

525
00:23:50,264 --> 0:23:52,199
让我们在深入一点 在iOS上…

526
00:23:52,266 --> 0:23:54,868
这是app的生命周期 是的

527
00:23:54,935 --> 0:23:58,038
其实app并没有

528
00:23:58,305 --> 0:24:00,974
有时候当app进入前台时

529
00:23:58,305 --> 0:24:00,974
有时候当app进入前台时

530
00:24:01,041 --> 0:24:03,410
并且关闭了 但跟销毁一样

531
00:24:03,477 --> 0:24:06,780
好像app的关闭

532
00:24:06,847 --> 0:24:08,081
意义不大

533
00:24:08,549 --> 0:24:11,251
最后的结果就是你实施回调

534
00:24:11,552 --> 0:24:12,986
类似这样的东西 是的

535
00:24:13,053 --> 0:24:14,788
然后app告诉你 你将进入后台

536
00:24:14,855 --> 0:24:16,023
你将返回去 类似这样的

537
00:24:16,089 --> 0:24:18,292
销毁程序不完全是在一个

538
00:24:19,092 --> 0:24:21,161
如果我们返回我们之前的代码 是的

539
00:24:21,228 --> 0:24:22,796
它是个app

540
00:24:23,397 --> 0:24:24,464
这是我们写的

541
00:24:24,531 --> 0:24:27,234
嗯 其实并没有一个合理的时间

542
00:24:27,301 --> 0:24:29,670
让这个logger

543
00:24:30,037 --> 0:24:32,673
但跟在销毁程序中一样

544
00:24:32,739 --> 0:24:35,409
你真正想要做的就是说

545
00:24:35,475 --> 0:24:37,010
请首先刷新缓冲区 是吧

546
00:24:37,277 --> 0:24:39,479
你在销毁程序中没有任何清理要执行

547
00:24:39,780 --> 0:24:41,448
销毁程序看起来有点傻

548
00:24:41,515 --> 0:24:44,218
生成了一大堆代码

549
00:24:44,284 --> 0:24:46,486
那么自Xcode 11起

550
00:24:46,553 --> 0:24:49,022
允许你说 嘿 不要销毁这个东西

551
00:24:49,089 --> 0:24:50,991
它是全局属性 它不需要销毁程序

552
00:24:52,426 --> 0:24:55,229
当然了 当发生回调时

553
00:24:55,295 --> 0:24:57,965
并且你可以在Xcode中

554
00:24:58,031 --> 0:25:00,934
并使用设置对整个app设置

555
00:24:58,031 --> 0:25:00,934
并使用设置对整个app设置

556
00:25:01,535 --> 0:25:02,569
看起来非常微不足道

557
00:25:02,636 --> 0:25:05,005
但它却根据你在代码中

558
00:25:05,072 --> 0:25:07,908
给你提供也许是缩减百分之一的

559
00:25:08,742 --> 0:25:11,111
让我们从代码尺寸缩减继续讲

560
00:25:11,411 --> 0:25:13,514
我们要讲一下诊断

561
00:25:13,981 --> 0:25:16,250
我要讲五种诊断

562
00:25:16,316 --> 0:25:19,152
在Xcode 11中

563
00:25:20,087 --> 0:25:23,390
第一个是

564
00:25:23,457 --> 0:25:25,259
来自构造程序或销毁程序

565
00:25:25,726 --> 0:25:26,793
那是什么意思？

566
00:25:26,860 --> 0:25:28,762
让我们写一些面向对象的代码

567
00:25:28,829 --> 0:25:30,564
从表开始 好吧

568
00:25:30,831 --> 0:25:31,999
我有这个表

569
00:25:32,065 --> 0:25:34,535
我想用一个纯虚函数来说明

570
00:25:34,601 --> 0:25:35,435
我正在说什么

571
00:25:35,502 --> 0:25:38,005
我要写这个galahad函数

572
00:25:38,071 --> 0:25:39,173
它是纯虚函数

573
00:25:39,540 --> 0:25:41,275
我要给表添加一个销毁程序

574
00:25:41,341 --> 0:25:42,643
当表被销毁时 我要说

575
00:25:42,709 --> 0:25:44,745
galahad 请查找把手 是的

576
00:25:45,279 --> 0:25:46,113
这非常有意义

577
00:25:46,180 --> 0:25:48,415
我那样做了 我得到了一个警告

578
00:25:49,016 --> 0:25:51,585
自Xcode 11起

579
00:25:51,652 --> 0:25:54,388
因为从构造程序或销毁程序中

580
00:25:54,454 --> 0:25:56,323
调用纯虚函数没有任何意义

581
00:25:56,390 --> 0:25:57,424
没什么可以调用的函数

582
00:25:57,791 --> 0:26:00,127
因为表是基类

583
00:25:57,791 --> 0:26:00,127
因为表是基类

584
00:26:00,194 --> 0:26:04,164
绝大部分派生类已经在这种情况下

585
00:26:04,231 --> 0:26:07,067
没有任何实施需要再调用

586
00:26:07,134 --> 0:26:08,235
这个galahad函数了

587
00:26:09,002 --> 0:26:10,270
那你要如何修复这个问题呢？

588
00:26:10,337 --> 0:26:11,205
嗯 你可以

589
00:26:11,271 --> 0:26:13,240
进入实施那个

590
00:26:13,307 --> 0:26:18,245
其销毁程序调用查找galahad

591
00:26:18,846 --> 0:26:19,980
那就有点道理了

592
00:26:20,681 --> 0:26:22,583
好的 让我们继续看下一个诊断

593
00:26:24,284 --> 0:26:25,853
带转置参数的memset

594
00:26:26,520 --> 0:26:29,523
假如我这个叫做收件箱的结构

595
00:26:29,790 --> 0:26:31,225
其中有一些邮件

596
00:26:31,291 --> 0:26:33,794
我度假回来 我看到收件箱是零

597
00:26:33,861 --> 0:26:36,230
我该怎么做？我只是把

598
00:26:36,830 --> 0:26:38,799
现在我写了这段代码

599
00:26:40,234 --> 0:26:42,269
是的 我把参数调换成了

600
00:26:42,636 --> 0:26:44,905
我时常会犯这种错误

601
00:26:44,972 --> 0:26:47,708
因为我不知道要memset

602
00:26:47,774 --> 0:26:50,944
我尝试设置销毁的值是否是

603
00:26:51,278 --> 0:26:54,515
第一个参数或是否是第二个参数

604
00:26:54,848 --> 0:26:56,583
它是否是我尝试要设置的尺寸

605
00:26:56,650 --> 0:26:58,719
那么现在自Xcode 11起

606
00:26:58,785 --> 0:26:59,620
并告诉你

607
00:26:59,686 --> 0:27:00,954
你该如何修复它？非常简单

608
00:26:59,686 --> 0:27:00,954
你该如何修复它？非常简单

609
00:27:01,021 --> 0:27:02,956
你只需要把参数翻转过来即可 是的

610
00:27:03,490 --> 0:27:05,826
在这里你可能想要考虑的一件事是

611
00:27:05,893 --> 0:27:07,661
不想使用难以获取的memset

612
00:27:07,728 --> 0:27:08,962
甚至像看代码一样

613
00:27:09,029 --> 0:27:10,864
仍然不明确它是否正确 是的

614
00:27:11,331 --> 0:27:13,767
你想要做的可能是使用像

615
00:27:13,834 --> 0:27:15,002
在某些情况下讲得通

616
00:27:15,369 --> 0:27:17,237
你重写代码

617
00:27:18,138 --> 0:27:19,239
现在出错几率更小了

618
00:27:19,306 --> 0:27:21,241
但是更容易了解它正在做什么了

619
00:27:21,675 --> 0:27:22,843
是的 看起来有点整洁了

620
00:27:23,977 --> 0:27:25,679
我要讲的第三个警告是…

621
00:27:26,647 --> 0:27:27,681
标准的move返回

622
00:27:27,748 --> 0:27:30,217
move在C++中有点复杂

623
00:27:30,284 --> 0:27:32,553
但总是有许多诊断可以帮助你

624
00:27:32,619 --> 0:27:34,488
以合适的方式使用它 是的

625
00:27:34,888 --> 0:27:37,057
那么再一次

626
00:27:37,124 --> 0:27:38,692
来了解我正在讲什么

627
00:27:38,759 --> 0:27:41,595
假如我有三个结构 狮子、山羊和蛇

628
00:27:41,962 --> 0:27:43,397
以及爱面向对象

629
00:27:43,463 --> 0:27:45,365
我要把它们合成奇美拉 是的

630
00:27:45,899 --> 0:27:46,733
代码不错

631
00:27:46,900 --> 0:27:49,937
我要进入并分配

632
00:27:50,003 --> 0:27:51,505
我想杀死奇美拉

633
00:27:51,572 --> 0:27:53,340
然后返回一个我杀死了它的证据

634
00:27:53,674 --> 0:27:56,443
嗯 现在有个诊断告诉我说

635
00:27:56,710 --> 0:27:58,378
比如你正在返回奇美拉

636
00:27:58,712 --> 0:28:01,448
但你只是比如你正在返回的返回类型

637
00:27:58,712 --> 0:28:01,448
但你只是比如你正在返回的返回类型

638
00:28:01,515 --> 0:28:02,883
实际上是山羊 是的

639
00:28:02,950 --> 0:28:05,018
我要获取那个矢量 复制它

640
00:28:05,085 --> 0:28:08,121
因为从奇美拉中切出矢量

641
00:28:08,188 --> 0:28:09,823
并把矢量放到山羊中是没有意义的

642
00:28:10,324 --> 0:28:12,960
好的 那么你在这里做什么

643
00:28:13,026 --> 0:28:15,429
你所写的代码基本上就是

644
00:28:15,495 --> 0:28:16,763
与std::move有关

645
00:28:16,830 --> 0:28:19,633
你依赖于copy elision

646
00:28:19,700 --> 0:28:22,870
在绝大多数时候 当你执行

647
00:28:23,203 --> 0:28:25,339
在这个例子中你却需要它

648
00:28:25,405 --> 0:28:28,442
语言说返回 只是切出类的一部分

649
00:28:28,509 --> 0:28:29,643
不管怎样 听起来有点古怪

650
00:28:29,710 --> 0:28:31,745
move不应该是隐含的 是吧

651
00:28:32,112 --> 0:28:35,082
因此警告告诉你

652
00:28:35,382 --> 0:28:38,285
第一种修复方式是进入并调用

653
00:28:39,586 --> 0:28:43,190
好的 现在那会把矢量移动到山羊中

654
00:28:43,257 --> 0:28:45,492
这样执行move更有效率一些

655
00:28:46,093 --> 0:28:48,495
你可能想要做的另一件事是

656
00:28:48,562 --> 0:28:51,665
不仅仅返回山羊 还要让人们相信你

657
00:28:51,732 --> 0:28:52,833
它实际上是奇美拉

658
00:28:52,900 --> 0:28:54,034
嗯 你只要返回奇美拉

659
00:28:54,101 --> 0:28:56,436
那就讲得通了 在这里你得到了

660
00:28:56,503 --> 0:28:58,772
如果你添加了std::move

661
00:28:58,839 --> 0:29:00,807
你正在通过添加move

662
00:28:58,839 --> 0:29:00,807
你正在通过添加move

663
00:29:01,441 --> 0:29:03,110
你想要做的另一件事 因为你不确定

664
00:29:03,177 --> 0:29:04,645
你是否会得到奇美拉

665
00:29:04,945 --> 0:29:06,847
就是你可能想返回一个带

666
00:29:06,914 --> 0:29:08,115
这再一次做了对的事情

667
00:29:08,182 --> 0:29:10,884
它不会从类中切出东西 因此语言说

668
00:29:10,951 --> 0:29:12,686
是的 这会得到隐含的

669
00:29:13,487 --> 0:29:15,656
好的 我想讲的另一个诊断是

670
00:29:16,023 --> 0:29:17,191
size-of-pointer-div

671
00:29:17,891 --> 0:29:20,127
它是什么样的？

672
00:29:20,794 --> 0:29:21,662
相当不错的代码

673
00:29:22,062 --> 0:29:23,897
目前没有任何问题 是吧

674
00:29:23,964 --> 0:29:25,499
我说的是我有这个数组

675
00:29:25,999 --> 0:29:29,169
取数组的大小除以第零个元素

676
00:29:29,236 --> 0:29:31,471
那会给你提供数组内的元素数量

677
00:29:31,805 --> 0:29:34,608
这是C样式代码的标准代码 是吧

678
00:29:35,943 --> 0:29:36,877
一个很常用的计算

679
00:29:36,944 --> 0:29:39,813
这里的问题是如果我重构这段代码

680
00:29:40,614 --> 0:29:41,648
我做这样的操作

681
00:29:41,715 --> 0:29:43,984
我把数组作为参数进行传递

682
00:29:44,585 --> 0:29:48,288
嗯 那样C规则会说数组

683
00:29:48,355 --> 0:29:49,523
现在衰减到一个指针

684
00:29:50,123 --> 0:29:51,625
而新诊断告诉你说 嘿

685
00:29:51,692 --> 0:29:53,460
这很可能不是你想要的结果 是吧

686
00:29:53,527 --> 0:29:55,762
这不会给你返回数组中的元素数量

687
00:29:56,697 --> 0:29:58,098
这是一个问题

688
00:29:59,032 --> 0:30:01,301
我们发现了它 你该如何修复它呢？

689
00:29:59,032 --> 0:30:01,301
我们发现了它 你该如何修复它呢？

690
00:30:01,368 --> 0:30:03,637
嗯 你可以用稍微不同的方式写代码

691
00:30:03,704 --> 0:30:05,105
我们不使用那种常见的计算

692
00:30:05,739 --> 0:30:08,442
是的 你可用类似

693
00:30:08,509 --> 0:30:11,612
意思是我们不错误地重构代码

694
00:30:11,912 --> 0:30:14,681
当你尝试重构代码时

695
00:30:14,748 --> 0:30:16,450
std::size

696
00:30:16,984 --> 0:30:19,853
这是一种警告 它捕捉错误

697
00:30:21,121 --> 0:30:22,523
我要讲的最后一个诊断是

698
00:30:22,589 --> 0:30:24,057
defaulted-function-delete

699
00:30:24,525 --> 0:30:27,060
再一次 假如我在这里写了

700
00:30:27,127 --> 0:30:28,462
我的代码结构失常

701
00:30:28,529 --> 0:30:30,531
我有一些浮动的眼柄

702
00:30:30,898 --> 0:30:32,900
我想默认这种异常结构

703
00:30:32,966 --> 0:30:34,401
请给我一个默认的异常结构

704
00:30:34,601 --> 0:30:36,470
嗯 编译器会告诉你说 嘿

705
00:30:36,537 --> 0:30:38,305
我不知道什么是默认的异常结构

706
00:30:38,372 --> 0:30:40,107
为什么不知道呢？

707
00:30:40,174 --> 0:30:43,110
我不能为那个引用

708
00:30:43,644 --> 0:30:46,747
那是一种我不能默认创建的类型

709
00:30:47,080 --> 0:30:50,184
有许多其它方式

710
00:30:50,250 --> 0:30:52,386
要创建非默认构造的东西

711
00:30:52,452 --> 0:30:53,954
编译器现在会告诉你

712
00:30:54,021 --> 0:30:55,489
如果你请求默认构造程序

713
00:30:55,556 --> 0:30:57,758
它会告诉你我不能给你提供

714
00:30:57,925 --> 0:31:00,594
你该如何修复这个问题呢？

715
00:30:57,925 --> 0:31:00,594
你该如何修复这个问题呢？

716
00:31:01,461 --> 0:31:02,462
自己创建构造程序

717
00:31:02,529 --> 0:31:05,432
当你传入眼柄时

718
00:31:05,766 --> 0:31:06,600
看起来很整洁

719
00:31:06,667 --> 0:31:10,404
但就我而言 我认为情人眼里出西施

720
00:31:10,470 --> 0:31:12,706
但也许这个异常应该以不同的方式

721
00:31:12,773 --> 0:31:14,541
而不是通过一个浮动引用

722
00:31:14,608 --> 0:31:16,143
也许你应该这样做 是的

723
00:31:16,210 --> 0:31:18,245
这样做好多了 是的

724
00:31:18,312 --> 0:31:20,480
现在我可以默认创建异常了

725
00:31:21,148 --> 0:31:22,983
好的 那么这就是

726
00:31:23,050 --> 0:31:24,184
我想与你们分享的诊断

727
00:31:24,251 --> 0:31:25,652
现在我要把舞台交给Devin

728
00:31:25,719 --> 0:31:27,921
他会讲一下新的静态分析器检查

729
00:31:29,857 --> 0:31:31,258
（新静态分析器检查）

730
00:31:32,926 --> 0:31:34,494
到目前为止

731
00:31:34,962 --> 0:31:36,296
我们在本场演讲中所讲的警告

732
00:31:36,363 --> 0:31:38,465
都来自你创建时的编译器

733
00:31:39,199 --> 0:31:41,502
但我们还有其它工具

734
00:31:42,503 --> 0:31:43,971
其中一个就是静态分析器

735
00:31:46,740 --> 0:31:49,243
分析器查找你代码深处的错误

736
00:31:49,309 --> 0:31:51,612
甚至不运行你的app就可以实现

737
00:31:52,479 --> 0:31:53,947
这使它擅长测试

738
00:31:54,214 --> 0:31:56,517
和捕捉那些难以再现的错误

739
00:31:56,917 --> 0:31:59,453
你甚至从未想过为之写测试代码

740
00:32:00,153 --> 0:32:02,523
它甚至会给你显示

741
00:32:02,923 --> 0:32:04,458
错误产生的步骤序列

742
00:32:05,259 --> 0:32:08,428
这样易于理解问题并修复问题

743
00:32:10,230 --> 0:32:14,067
今天我要讲我们所添加的三种

744
00:32:14,868 --> 0:32:16,336
一种检查用在move错误之后；

745
00:32:16,937 --> 0:32:20,440
一种检查用于通过C++ std::string

746
00:32:21,108 --> 0:32:25,479
还有一种检查用于在新的DriverKit

747
00:32:26,880 --> 0:32:28,448
让我们从第一个开始讲

748
00:32:31,351 --> 0:32:32,619
在C++中

749
00:32:32,686 --> 0:32:35,556
move可以让你避免多余的复制

750
00:32:35,622 --> 0:32:37,891
这里有个例子 在这个例子中

751
00:32:39,259 --> 0:32:41,361
让我们假设我写了一本小说

752
00:32:41,962 --> 0:32:44,498
如果你们了解我的话

753
00:32:45,065 --> 0:32:47,668
当我把它交给我的发行商时

754
00:32:47,968 --> 0:32:51,772
我不想支付关于复制小说的

755
00:32:52,539 --> 0:32:54,374
所以我使用了一个move

756
00:32:55,843 --> 0:32:59,479
这会从源变量中把它移出来

757
00:33:00,514 --> 0:33:01,782
最棒的是

758
00:33:01,849 --> 0:33:05,519
它允许我强制执行唯一所有权语义

759
00:33:05,919 --> 0:33:09,289
这样就不再混淆

760
00:33:09,823 --> 0:33:11,024
我或我的发行商

761
00:33:12,259 --> 0:33:13,961
但我在这里的确需要小心一些

762
00:33:14,528 --> 0:33:18,832
那是因为move会让源变量

763
00:33:20,334 --> 0:33:21,568
让我们看看这是如何出错的

764
00:33:24,371 --> 0:33:28,942
假如我要在发行小说之后

765
00:33:31,278 --> 0:33:33,714
这可能会导致出乎意料的结果

766
00:33:33,981 --> 0:33:36,183
取决于所实施的书的类型

767
00:33:37,718 --> 0:33:41,221
幸运的是静态分析器现在可以捕捉

768
00:33:43,190 --> 0:33:45,993
要修复这个错误

769
00:33:46,793 --> 0:33:51,431
在我发行小说之前进行拼写检查

770
00:33:54,234 --> 0:33:55,169
好的

771
00:33:55,569 --> 0:33:59,039
让我们继续讲来自

772
00:33:59,106 --> 0:34:00,607
（来自std::string

773
00:33:59,106 --> 0:34:00,607
（来自std::string

774
00:34:00,941 --> 0:34:03,544
你们中搞不清楚

775
00:34:03,610 --> 0:34:05,746
知道这非常棘手

776
00:34:06,680 --> 0:34:07,648
这里有个例子

777
00:34:09,116 --> 0:34:11,752
我创建了这个

778
00:34:11,818 --> 0:34:15,722
它接受一个C字符串名称

779
00:34:16,723 --> 0:34:18,592
在这个函数的实施中

780
00:34:19,025 --> 0:34:21,527
我选择使用

781
00:34:21,929 --> 0:34:23,397
因为它易于操作

782
00:34:24,665 --> 0:34:26,233
我声明了一个

783
00:34:26,300 --> 0:34:27,467
把它初始化为hello…

784
00:34:28,601 --> 0:34:31,538
附加上所传入的名称 然后

785
00:34:31,905 --> 0:34:34,107
因为函数返回一个C字符串

786
00:34:34,641 --> 0:34:38,312
我在C++字符串上

787
00:34:38,579 --> 0:34:40,480
然后从这里开始就出问题了

788
00:34:41,481 --> 0:34:42,882
在这里有一个关键点要注意

789
00:34:43,150 --> 0:34:45,886
就是c str给

790
00:34:46,453 --> 0:34:48,322
返回一个内部指针

791
00:34:49,456 --> 0:34:53,493
std::string超出范围时

792
00:34:55,262 --> 0:34:58,498
这意味着我正在给一个

793
00:34:58,966 --> 0:35:00,133
即将被接触分配的内存

794
00:34:58,966 --> 0:35:00,133
即将被接触分配的内存

795
00:35:00,701 --> 0:35:03,770
然后当我使用那个内存时

796
00:35:05,806 --> 0:35:08,041
现在静态分析器可以捕捉这种错误了

797
00:35:10,844 --> 0:35:11,912
那么该如何修复这个错误呢？

798
00:35:12,946 --> 0:35:17,518
嗯 我们推荐匹配你的C++

799
00:35:18,986 --> 0:35:21,255
在这里我修改了

800
00:35:21,522 --> 0:35:22,890
以返回一个std::string

801
00:35:23,657 --> 0:35:26,693
然后我把结果存储到一个局部变量中

802
00:35:28,529 --> 0:35:30,664
这意味着当我调用c str方法时

803
00:35:31,465 --> 0:35:35,536
只要我需要使用C字符串

804
00:35:37,304 --> 0:35:40,174
实质上我在这里所做的就是

805
00:35:40,541 --> 0:35:41,909
把它的范围改为

806
00:35:43,544 --> 0:35:48,081
请注意 尽可能长时间地

807
00:35:48,549 --> 0:35:49,883
保留在C++内总是很容易

808
00:35:50,484 --> 0:35:53,954
只需要在我需要的那一时刻

809
00:35:56,623 --> 0:35:58,392
好的 让我们继续

810
00:35:58,458 --> 0:36:00,928
我要讲的第三个也是最后一个检查

811
00:35:58,458 --> 0:36:00,928
我要讲的第三个也是最后一个检查

812
00:36:01,328 --> 0:36:05,265
是在DriverKit中

813
00:36:08,202 --> 0:36:10,904
这些驱动框架使用手动保留/释放

814
00:36:11,338 --> 0:36:12,673
来管理内存

815
00:36:13,407 --> 0:36:16,009
对于熟悉

816
00:36:16,376 --> 0:36:18,879
或熟悉不带自动引用计数的

817
00:36:19,313 --> 0:36:20,547
非常类似

818
00:36:20,614 --> 0:36:21,982
（使用手动保留/释放的驱动）

819
00:36:22,049 --> 0:36:25,652
手动保留/释放可以给你提供

820
00:36:26,186 --> 0:36:28,722
但它确实伴随着一些附加的责任

821
00:36:30,224 --> 0:36:32,926
你需要注意不要过度释放内存

822
00:36:33,861 --> 0:36:34,828
因为如果你释放过度

823
00:36:35,128 --> 0:36:37,931
内存可能会被解除配置

824
00:36:37,998 --> 0:36:39,132
你的程序会发生崩溃

825
00:36:41,702 --> 0:36:44,304
类似地 你也不应该内存释放不足

826
00:36:44,705 --> 0:36:46,240
因为内存可能会发生泄漏

827
00:36:49,076 --> 0:36:50,377
让我给你一个内存泄漏的例子

828
00:36:51,845 --> 0:36:56,116
在这里我写了一些代码

829
00:36:56,950 --> 0:36:59,786
然后它会填写那些设备

830
00:37:01,221 --> 0:37:02,489
这里的重点是

831
00:37:02,923 --> 0:37:04,758
那个

832
00:37:05,292 --> 0:37:08,462
它分配一个新数组并返回保留它

833
00:37:09,763 --> 0:37:14,001
这意味着如果那个数组不被释放

834
00:37:16,270 --> 0:37:18,539
现在分析器可以捕捉这种错误

835
00:37:20,274 --> 0:37:21,208
那我该如何修复这个错误呢？

836
00:37:22,109 --> 0:37:26,246
我要做的就是确保当我用完数组后

837
00:37:29,082 --> 0:37:33,487
现在内存管理规则都是基于命名约定

838
00:37:34,054 --> 0:37:38,091
这在实质上与CoreFoundation

839
00:37:38,158 --> 0:37:39,459
在手动保留/释放方面

840
00:37:40,694 --> 0:37:44,998
但我想指出IOKit和

841
00:37:46,133 --> 0:37:50,003
即默认约定返回保留

842
00:37:50,504 --> 0:37:52,506
或者我们有时候把它叫做at +1

843
00:37:53,740 --> 0:37:56,777
意思是客户必须

844
00:37:57,077 --> 0:37:59,179
在他们调用的方法的结果上调用释放

845
00:38:00,214 --> 0:38:01,782
否则对象会发生泄漏

846
00:38:04,084 --> 0:38:06,019
这个规则的一个重要的例外情况是

847
00:38:06,086 --> 0:38:08,222
getter返回不保留

848
00:38:08,689 --> 0:38:10,123
或我们把它叫做at +0

849
00:38:11,091 --> 0:38:14,494
客户不应该释放getter的结果

850
00:38:14,862 --> 0:38:16,430
（内存管理约定）

851
00:38:17,831 --> 0:38:21,768
现在你编写的代码

852
00:38:21,835 --> 0:38:23,604
这是我写的一个示例代码

853
00:38:25,439 --> 0:38:28,141
这个方法在数组中查找第一台设备

854
00:38:29,443 --> 0:38:31,545
它应用了默认约定

855
00:38:31,612 --> 0:38:32,713
它应该返回保留

856
00:38:33,881 --> 0:38:35,616
但如果我们看一下实施

857
00:38:36,316 --> 0:38:38,452
它返回了getter的结果

858
00:38:39,119 --> 0:38:40,721
并且getter返回不保留

859
00:38:41,588 --> 0:38:42,823
那么这里就发生了不匹配

860
00:38:44,391 --> 0:38:46,527
幸运的是分析器现在可以替我们指出

861
00:38:48,362 --> 0:38:49,396
那我该如何修复这个错误呢？

862
00:38:50,464 --> 0:38:52,900
嗯 我有三种可选方案

863
00:38:53,800 --> 0:38:57,104
第一种是修改行为 使其遵守约定

864
00:38:58,105 --> 0:39:00,440
在这里约定是方法应该返回保留

865
00:38:58,105 --> 0:39:00,440
在这里约定是方法应该返回保留

866
00:39:01,041 --> 0:39:03,977
所以我可以在返回结果之前保留它

867
00:39:05,913 --> 0:39:08,515
另一种可能性是重命名方法

868
00:39:09,650 --> 0:39:11,985
如果我看一下这个

869
00:39:12,352 --> 0:39:14,254
它看起来很像是个getter

870
00:39:14,955 --> 0:39:17,224
我可以把它重命名为

871
00:39:17,291 --> 0:39:18,792
那会遵守约定

872
00:39:20,627 --> 0:39:23,564
但你可能还有一个方法用于实施

873
00:39:24,131 --> 0:39:25,265
并且它的名称很合理

874
00:39:25,766 --> 0:39:27,034
你不想修改它

875
00:39:27,401 --> 0:39:28,535
没关系

876
00:39:29,536 --> 0:39:32,306
在这种情况下 你应该添加一个注释

877
00:39:32,840 --> 0:39:36,243
告诉代码的阅读器和分析器

878
00:39:36,577 --> 0:39:38,879
你是有意不遵守约定的

879
00:39:40,514 --> 0:39:44,785
在这种情况下 我可以添加

880
00:39:45,185 --> 0:39:46,520
来表明我的意图

881
00:39:48,856 --> 0:39:50,691
如果你有一个IOKit驱动

882
00:39:50,757 --> 0:39:52,860
或你正在编写一个

883
00:39:53,427 --> 0:39:56,430
我强烈鼓励你在代码上运行分析器

884
00:39:57,898 --> 0:40:01,502
要运行分析器 你要做的就是

885
00:39:57,898 --> 0:40:01,502
要运行分析器 你要做的就是

886
00:40:01,802 --> 0:40:03,237
并选择分析

887
00:40:04,071 --> 0:40:05,806
你甚至可以让Xcode

888
00:40:05,873 --> 0:40:08,175
在你每次点击创建时都运行分析器

889
00:40:08,876 --> 0:40:12,913
通过进入目标的创建设置

890
00:40:13,881 --> 0:40:16,850
这会帮助你捕捉错误

891
00:40:20,020 --> 0:40:22,489
好的 我们今天讲了许多内容

892
00:40:23,557 --> 0:40:27,628
我们讲了

893
00:40:27,995 --> 0:40:29,196
针对watchOS的

894
00:40:29,263 --> 0:40:33,400
而你的32位app将第一次

895
00:40:34,835 --> 0:40:37,638
我们讲了如何通过新的编译器优化

896
00:40:37,704 --> 0:40:38,705
和语言功能缩减代码尺寸

897
00:40:38,972 --> 0:40:41,408
以及如何在你的代码上运行

898
00:40:43,043 --> 0:40:45,612
要获取更多信息 请查看演讲网站

899
00:40:46,079 --> 0:40:48,615
我们非常希望能在实验室中

900
00:40:49,249 --> 0:40:50,317
谢谢
