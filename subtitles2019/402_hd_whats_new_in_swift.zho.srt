1
00:00:00,506 --> 0:00:04,500
[音乐]

2
00:00:13,131 --> 0:00:15,131
[掌声]

3
00:00:15,246 --> 0:00:15,906
&gt;&gt; 早上好

4
00:00:16,856 --> 0:00:18,716
欢迎来到 What's New in Swift 专场

5
00:00:19,786 --> 0:00:21,086
今天 我们将讨论两个重要

6
00:00:21,146 --> 0:00:23,856
且令人兴奋的 Swift 发布版本

7
00:00:24,276 --> 0:00:28,876
Swift 5 是我们最近在三月份发布的版本

8
00:00:29,036 --> 0:00:32,906
Swift 5.1 现在可以在 Xcode 11 中使用开发者预览版

9
00:00:34,196 --> 0:00:36,326
有了这两个新的版本

10
00:00:36,326 --> 0:00:41,156
我们进一步释放了 Swift 作为语言和技术的潜力

11
00:00:41,216 --> 0:00:42,986
Apple 和你们所有人都可以

12
00:00:43,276 --> 0:00:45,616
在此基础上进行开发

13
00:00:46,666 --> 0:00:49,326
从 Swift 和 API 的

14
00:00:49,326 --> 0:00:54,666
强大组合的形式中获益

15
00:00:55,756 --> 0:00:58,136
现在 Apple 的操作系统

16
00:00:58,206 --> 0:00:59,876
已经为第三方 App 提供了

17
00:00:59,876 --> 0:01:02,356
共享的 Swift Runtime

18
00:00:59,876 --> 0:01:02,356
共享的 Swift Runtime

19
00:01:02,356 --> 0:01:03,726
并且用 Swift 写的二进制框架

20
00:01:03,726 --> 0:01:05,716
现在已经可以部署

21
00:01:06,326 --> 0:01:08,416
使用这些 Apple 做出了

22
00:01:08,616 --> 0:01:10,856
仅用于 Swift 的跑马灯效果框架

23
00:01:11,926 --> 0:01:14,136
此外 在 Xcode 中

24
00:01:14,486 --> 0:01:15,826
对 Swift 包管理器的集成支持

25
00:01:15,826 --> 0:01:17,296
使得 Swift 包可以直接

26
00:01:17,296 --> 0:01:21,516
进入 App 开发的核心工作流中

27
00:01:22,166 --> 0:01:25,066
同时 Swift 语言本身有了新的可供性

28
00:01:25,066 --> 0:01:27,886
来构建精美丰富的 API

29
00:01:28,396 --> 0:01:31,216
也有了用于表达 API 发展的新特性

30
00:01:31,716 --> 0:01:33,096
对于该语言及其整个生态环境来说

31
00:01:33,096 --> 0:01:36,306
这都是一个非常激动人心的时刻

32
00:01:36,966 --> 0:01:38,716
那么让我们开始吧

33
00:01:38,716 --> 0:01:42,296
首先我要多说几句二进制框架

34
00:01:42,296 --> 0:01:43,806
特别是深入谈谈

35
00:01:43,806 --> 0:01:46,176
促成这一发展的核心要素

36
00:01:46,846 --> 0:01:48,536
那些要素就是 ABI 稳定性

37
00:01:48,536 --> 0:01:50,256
及模块稳定性

38
00:01:51,516 --> 0:01:56,496
ABI 就是 Application Binary Interface

39
00:01:56,496 --> 0:01:57,966
它是一些规则 用来控制编译后的代码

40
00:01:57,966 --> 0:02:01,766
如何在运行时进行交互的具体细节

41
00:01:57,966 --> 0:02:01,766
如何在运行时进行交互的具体细节

42
00:02:02,576 --> 0:02:04,636
就像是函数调用这样的细节

43
00:02:04,916 --> 0:02:06,796
那么它究竟是如何工作的

44
00:02:07,416 --> 0:02:12,636
参数中的值是如何从调用者传递给被调用者的呢

45
00:02:13,086 --> 0:02:14,386
可用的元数据是什么

46
00:02:14,386 --> 0:02:15,506
它在内存中又是如何排列的

47
00:02:15,626 --> 0:02:16,766
所有这些细节都是

48
00:02:16,766 --> 0:02:19,436
编译后的代码相互作用时所必须的

49
00:02:19,766 --> 0:02:21,526
因此为了说明这个观点

50
00:02:21,526 --> 0:02:24,116
假设你有一个用 Swift 写的程序

51
00:02:24,236 --> 0:02:25,626
它是一个 App

52
00:02:25,626 --> 0:02:27,246
可以是命令行工具 这并不是很重要 

53
00:02:27,246 --> 0:02:28,876
只要是可执行的

54
00:02:29,706 --> 0:02:33,756
它使用的框架也是用 Swift 写的

55
00:02:33,756 --> 0:02:35,066
而所有的这些已编译代码

56
00:02:35,066 --> 0:02:37,786
是在一个运行过程中一起运行的

57
00:02:37,876 --> 0:02:40,926
那么这个可执行文件

58
00:02:41,116 --> 0:02:42,146
正在使用框架中的 API

59
00:02:42,186 --> 0:02:44,456
它们必须能在运行时与彼此进行对话

60
00:02:45,246 --> 0:02:46,966
那么 为了完成这个

61
00:02:46,966 --> 0:02:48,186
它们必须有一个可兼容的 ABI

62
00:02:48,186 --> 0:02:50,926
就像这两段代码是被分开进行编译的

63
00:02:51,006 --> 0:02:53,856
但编译后的代码则需要一起共同工作

64
00:02:54,436 --> 0:02:56,296
在 ABI 稳定性之前

65
00:02:56,296 --> 0:02:58,876
我们唯一能保证的是

66
00:02:59,066 --> 0:03:00,546
它们会有一个可兼容的 ABI

67
00:02:59,066 --> 0:03:00,546
它们会有一个可兼容的 ABI

68
00:03:00,546 --> 0:03:02,966
只要构建它们的编译器是相同的

69
00:03:03,056 --> 0:03:04,826
之所以这样 是因为

70
00:03:04,826 --> 0:03:08,176
我们真的是在发展 Swift 的核心基础要素

71
00:03:08,176 --> 0:03:09,746
以确保所有我们

72
00:03:09,746 --> 0:03:13,096
想要的构建块都被放在合适的位置上

73
00:03:13,096 --> 0:03:14,106
以便在未来进行构建

74
00:03:14,766 --> 0:03:18,286
那么 在 Swift 5 中我们已经明确了那些细节

75
00:03:18,386 --> 0:03:20,436
现在的 Swift 已有了 ABI 稳定性

76
00:03:20,436 --> 0:03:23,796
这意味着这两个组件不再需要用相同的编译器进行构建了

77
00:03:23,796 --> 0:03:25,826
只要它们是用 Swift 5 编译器

78
00:03:25,826 --> 0:03:28,106
或更新的版本进行构建的

79
00:03:28,676 --> 0:03:31,386
第二个重要的要素

80
00:03:31,386 --> 0:03:33,346
就是模块的稳定性

81
00:03:33,346 --> 0:03:35,146
这是一个编译时的概念

82
00:03:35,146 --> 0:03:36,996
如果你有一个 Swift 框架

83
00:03:37,156 --> 0:03:38,966
使用该框架内的所有 API

84
00:03:38,966 --> 0:03:43,076
那么这些就都是一个被称为模块的共享命名空间的一部分

85
00:03:43,466 --> 0:03:48,296
当 Swift 编译器构建该框架时

86
00:03:48,296 --> 0:03:53,716
它会生成该框架中的所有 API 的 Manifest

87
00:03:53,716 --> 0:03:56,326
之后该框架的客户端就可以使用这些 API

88
00:03:56,636 --> 0:03:58,776
该 Manifest 被称为 Swift 模块文件

89
00:03:59,196 --> 0:04:00,666
那么如果我们回到这个例子

90
00:03:59,196 --> 0:04:00,666
那么如果我们回到这个例子

91
00:04:00,666 --> 0:04:03,346
我们就假设我们正在编译程序

92
00:04:03,386 --> 0:04:04,716
有一个源文件

93
00:04:04,716 --> 0:04:06,396
它引用了该框架

94
00:04:06,466 --> 0:04:09,216
接下来该编译器就会去读取模块文件

95
00:04:09,256 --> 0:04:11,416
并获取可用的 API

96
00:04:11,416 --> 0:04:14,246
但是这个模块文件里的细节真的很丰富

97
00:04:14,246 --> 0:04:17,326
并且在很多方面

98
00:04:17,326 --> 0:04:19,826
与编译器本身紧密耦合

99
00:04:19,826 --> 0:04:22,746
所以我们就有和 ABI 稳定性相同的问题了

100
00:04:22,746 --> 0:04:24,016
那么唯一的办法就是

101
00:04:24,016 --> 0:04:27,446
这两块必须要用相同的编译器进行编译

102
00:04:28,026 --> 0:04:33,446
在 Swift 5.1 里我们引入了一个新的补充 Manifest

103
00:04:33,936 --> 0:04:36,396
它被称为 Swift 模块接口文件

104
00:04:36,996 --> 0:04:38,766
它可以被框架用来提供

105
00:04:39,186 --> 0:04:42,896
用户端可以使用的稳定接口

106
00:04:43,666 --> 0:04:45,736
而如果你将它打开

107
00:04:45,736 --> 0:04:47,816
它看起来就像 Swift 源代码

108
00:04:47,866 --> 0:04:50,836
它也是被构建在源稳定性的概念上的

109
00:04:50,836 --> 0:04:52,776
这个概念在 Swift 中很早就有了

110
00:04:53,086 --> 0:04:54,946
那么有了这两个要素

111
00:04:55,186 --> 0:04:57,626
你就可以得到可以部署

112
00:04:57,626 --> 0:05:00,296
并与他人共享的 Swift 框架

113
00:04:57,626 --> 0:05:00,296
并与他人共享的 Swift 框架

114
00:05:01,516 --> 0:05:06,546
[掌声]

115
00:05:07,046 --> 0:05:08,096
那么我们有很多十分有趣的

116
00:05:08,096 --> 0:05:09,576
关于 ABI 稳定性的细节

117
00:05:09,576 --> 0:05:10,786
我们已经准备了

118
00:05:10,786 --> 0:05:13,216
很长一段时间了

119
00:05:13,216 --> 0:05:14,386
如果你有兴趣

120
00:05:14,386 --> 0:05:15,896
了解更多的细节

121
00:05:15,896 --> 0:05:16,946
我们今天就要向大家介绍

122
00:05:16,946 --> 0:05:19,326
swift.org 是一个很好的资源

123
00:05:19,326 --> 0:05:23,056
这是 Swift 开放源代码的项目的主页

124
00:05:23,056 --> 0:05:24,136
里面有很多很棒的

125
00:05:24,136 --> 0:05:26,276
关于 ABI 稳定性的博客文章

126
00:05:27,816 --> 0:05:29,286
同时 如果你有兴趣

127
00:05:29,286 --> 0:05:33,576
使用二进制框架来为你自己所用

128
00:05:33,576 --> 0:05:34,416
比如与他人进行共享

129
00:05:34,416 --> 0:05:35,866
我们会在这周晚些时候的

130
00:05:35,866 --> 0:05:37,176
Swift 中的 Binary Frameworks in Swift 专场中

131
00:05:37,176 --> 0:05:38,976
对这些进行讨论

132
00:05:39,276 --> 0:05:40,256
届时我们还会讨论

133
00:05:40,256 --> 0:05:41,666
当与他人共享框架时

134
00:05:41,996 --> 0:05:44,036
你应该进行考虑的一些事项

135
00:05:45,316 --> 0:05:48,286
那么二进制框架只是 API 中要为大家介绍的一个部分

136
00:05:48,286 --> 0:05:51,116
另一个重要的部分就是 Swift 包

137
00:05:51,946 --> 0:05:53,336
现在 Xcode 中已经

138
00:05:53,336 --> 0:05:55,216
集成了 Swift 包管理器

139
00:05:55,626 --> 0:05:58,816
它们是创建 App 的核心工作流的一部分

140
00:05:59,666 --> 0:06:00,826
这周还会有两个关于

141
00:05:59,666 --> 0:06:00,826
这周还会有两个关于

142
00:06:00,826 --> 0:06:04,206
在 Xcode 中创建和使用包的专场

143
00:06:04,296 --> 0:06:07,766
二进制框架和 Swift 包的结合

144
00:06:07,766 --> 0:06:09,346
为我们提供了一组非常丰富的选项

145
00:06:09,346 --> 0:06:12,766
来与他人共享 API

146
00:06:14,556 --> 0:06:15,966
那么让我们换个话题

147
00:06:15,966 --> 0:06:17,386
来谈谈性能

148
00:06:18,066 --> 0:06:20,386
Swift 语言是一种

149
00:06:20,386 --> 0:06:22,326
现代的 安全的

150
00:06:22,326 --> 0:06:24,216
且高性能的编程语言

151
00:06:24,856 --> 0:06:25,856
同时 ABI 稳定性

152
00:06:25,856 --> 0:06:28,376
还带来了一些关键的性能优势

153
00:06:29,706 --> 0:06:30,976
其中的一个性能优势

154
00:06:30,976 --> 0:06:32,696
是因为在操作系统中有了

155
00:06:32,696 --> 0:06:34,676
App 所共享的 Swift Runtime

156
00:06:34,676 --> 0:06:37,206
这是三月份发布的

157
00:06:37,206 --> 0:06:41,086
包括 macOS iOS tvOS watchOS 以及现在的 iPadOS

158
00:06:41,406 --> 0:06:42,666
在这些发布版本中都有

159
00:06:42,666 --> 0:06:45,176
一个共享的 Swift Runtime

160
00:06:45,176 --> 0:06:46,046
第三方 App 和 Apple 原生 App

161
00:06:46,046 --> 0:06:47,936
及系统中的所有东西都在使用

162
00:06:48,526 --> 0:06:51,546
那么 它究竟是如何工作

163
00:06:51,546 --> 0:06:54,196
又是在什么时候开始起作用呢

164
00:06:54,406 --> 0:06:56,376
如果你的 App 是用 Swift 5

165
00:06:56,376 --> 0:06:58,656
或更新的版本创建的

166
00:06:58,716 --> 0:07:00,496
它就会在运行的时候

167
00:06:58,716 --> 0:07:00,496
它就会在运行的时候

168
00:07:00,916 --> 0:07:02,486
使用系统中的共享 Runtime

169
00:07:03,636 --> 0:07:05,336
然而 你也许仍然需要将你的 App

170
00:07:05,336 --> 0:07:08,496
构建并部署到较早发行的操作系统版本中

171
00:07:08,496 --> 0:07:09,546
而那时的版本还没有共享 Runtime

172
00:07:10,886 --> 0:07:13,976
在这种情况下 Xcode 会继续在你的 App 中

173
00:07:13,976 --> 0:07:15,986
捆绑一个 Runtime 的副本

174
00:07:15,986 --> 0:07:18,596
以便它可以继续在那些较老的操作系统版本上运行

175
00:07:19,796 --> 0:07:24,166
但是 我们总是倾向于使用在操作系统中的副本

176
00:07:24,166 --> 0:07:25,986
那么这样一来 

177
00:07:25,986 --> 0:07:27,956
当运行在较新的系统上时

178
00:07:28,566 --> 0:07:29,806
这个 App 中的副本将会失效

179
00:07:30,536 --> 0:07:33,976
作为优化

180
00:07:34,156 --> 0:07:37,906
iOS App Store 将不提供 App 中的 Runtime 副本

181
00:07:38,356 --> 0:07:41,926
当下载设备的操作系统包含 Runtime 时

182
00:07:41,926 --> 0:07:44,966
为用户节约下载流量

183
00:07:45,606 --> 0:07:51,286
这是一个非常重要的代码量优化

184
00:07:51,286 --> 0:07:52,796
但在操作系统中拥有这个 Runtime

185
00:07:52,796 --> 0:07:54,526
其真正的好处是

186
00:07:54,586 --> 0:07:56,476
现在它可以作为操作系统本身的一部分

187
00:07:56,476 --> 0:07:58,126
来进行优化

188
00:07:58,126 --> 0:07:01,676
然后这些优化就可以转到 App 本身了

189
00:08:03,226 --> 0:08:06,096
有一个重要的好处就是启动时间

190
00:08:06,336 --> 0:08:08,506
那么让我们回到过去

191
00:08:08,506 --> 0:08:11,496
一年前 我们讨论了 Swift 4.2

192
00:08:12,996 --> 0:08:14,926
如果你有一个 Objective-C App

193
00:08:14,926 --> 0:08:17,506
它什么都不做

194
00:08:17,506 --> 0:08:19,166
它只是启动 然后什么都不做

195
00:08:19,716 --> 0:08:21,346
而一个 Swift App 也是

196
00:08:21,346 --> 0:08:22,526
同样没有功能

197
00:08:22,526 --> 0:08:23,386
它就只是启动

198
00:08:23,796 --> 0:08:25,446
使用 Swift 大约会有 5% 的额外时间消耗

199
00:08:25,446 --> 0:08:27,326
因为我们需要处理

200
00:08:27,356 --> 0:08:30,116
嵌入的 Runtime

201
00:08:30,306 --> 0:08:32,546
但是如果你的 App 是用

202
00:08:32,546 --> 0:08:34,265
Swift 5 编译器重新编译的

203
00:08:34,265 --> 0:08:35,506
并运行在一个有共享 Runtime 的操作系统上

204
00:08:35,506 --> 0:08:38,686
这个时间消耗就没有了

205
00:08:39,515 --> 0:08:43,216
[掌声]

206
00:08:43,716 --> 0:08:45,676
这个真的十分重要

207
00:08:45,676 --> 0:08:47,006
我的意思是 该延时是

208
00:08:47,006 --> 0:08:50,156
用户要开始使用你的 App 的时间

209
00:08:50,156 --> 0:08:53,866
和他们真正开始体验它的时间之间的差别

210
00:08:54,996 --> 0:08:56,856
我们进行优化的

211
00:08:56,856 --> 0:08:58,476
另一个重要的领域

212
00:08:58,476 --> 0:09:02,686
是进一步调整编译器编译后的代码

213
00:08:58,476 --> 0:09:02,686
是进一步调整编译器编译后的代码

214
00:09:02,686 --> 0:09:03,676
它进一步减少了

215
00:09:03,676 --> 0:09:06,026
Swift App 的代码规模

216
00:09:06,026 --> 0:09:07,776
这真的很像是微调

217
00:09:07,776 --> 0:09:11,126
考虑 Swift App 中特定的模式

218
00:09:11,126 --> 0:09:13,086
比如说字典在生成代码时

219
00:09:13,086 --> 0:09:16,656
应该怎样表示 等等

220
00:09:16,656 --> 0:09:19,696
我们只是要确保编译器的输出

221
00:09:19,696 --> 0:09:23,406
针对这些用例进行了优化

222
00:09:23,786 --> 0:09:24,756
通过各种各样的优化

223
00:09:24,756 --> 0:09:29,546
我们看到代码规模能够减少 10%

224
00:09:29,546 --> 0:09:31,506
如果使用 Swift 5.1 编译器的话

225
00:09:31,846 --> 0:09:32,846
如果你使用 Optimize for Size 选项

226
00:09:32,846 --> 0:09:36,566
那代码规模会减少 15%

227
00:09:36,976 --> 0:09:39,086
那么这是一些非常重要的优化

228
00:09:40,076 --> 0:09:42,786
我们也已经继续

229
00:09:42,786 --> 0:09:44,536
对桥接的性能进行完善

230
00:09:45,156 --> 0:09:46,246
通过桥接 我说的是

231
00:09:46,246 --> 0:09:49,046
Swift 和 Objective-C 之间的桥接

232
00:09:49,046 --> 0:09:52,456
这两种语言之间有着很强的互操作性

233
00:09:54,556 --> 0:09:56,666
那么 Swift 和 Objective-C

234
00:09:56,666 --> 0:10:00,206
都有我们所谓的通用的流通类型

235
00:09:56,666 --> 0:10:00,206
都有我们所谓的通用的流通类型

236
00:10:00,256 --> 0:10:01,786
它们被用在整个 API 空间里

237
00:10:02,326 --> 0:10:04,206
比如 String 和 NSString

238
00:10:04,556 --> 0:10:06,356
Dictionary 以及 NSDictionary

239
00:10:06,356 --> 0:10:10,296
而这些流通类型之间的互操作性

240
00:10:10,296 --> 0:10:11,136
是 Swift 和 Objective-C 之间

241
00:10:11,136 --> 0:10:13,706
互操作性的非常基础的部分

242
00:10:14,246 --> 0:10:15,646
使用自己的流通类型的 Objective-C API

243
00:10:15,646 --> 0:10:19,326
被重新映射到使用 Swift 流通类型的 Swift 中

244
00:10:19,506 --> 0:10:21,166
现在的工作一个编译器

245
00:10:21,166 --> 0:10:23,006
是一个编译器工作的组合

246
00:10:23,566 --> 0:10:24,696
但同时还要使用到 Runtime

247
00:10:24,696 --> 0:10:26,116
它在你将一个类型的值

248
00:10:26,116 --> 0:10:28,696
传递为另一种类型

249
00:10:28,726 --> 0:10:29,956
并跨越 API 边界时出现

250
00:10:31,026 --> 0:10:32,076
这是我们进一步调整的一部分

251
00:10:32,076 --> 0:10:33,626
作为 Swift 的一部分

252
00:10:33,676 --> 0:10:35,756
现在是操作系统的一部分

253
00:10:36,676 --> 0:10:39,106
比如现在 NSDictionary

254
00:10:39,106 --> 0:10:40,256
和 Dictionary 之间的桥接速度

255
00:10:40,256 --> 0:10:42,156
比之前快 1.6 倍

256
00:10:43,186 --> 0:10:44,966
如果你正在传递一个

257
00:10:44,966 --> 0:10:47,416
Swift 字符串给 Objecitive-C

258
00:10:47,416 --> 0:10:49,346
而它作为 NSString 桥接而使用

259
00:10:49,346 --> 0:10:50,206
并且是从 Objective-C 端使用它

260
00:10:50,206 --> 0:10:55,566
那么它的操作就可以达到 15 倍之快

261
00:10:56,516 --> 0:11:01,096
[掌声]

262
00:10:56,516 --> 0:11:01,096
[掌声]

263
00:11:01,596 --> 0:11:04,666
所有的这些小的好处加起来确实不少

264
00:11:04,666 --> 0:11:05,896
因为这些类型

265
00:11:05,896 --> 0:11:08,436
在整个 API 生态系统中都在使用

266
00:11:09,076 --> 0:11:12,326
现在说到字符串

267
00:11:12,326 --> 0:11:13,986
我们继续完善了它们的核心表达

268
00:11:13,986 --> 0:11:15,316
我们做了一个重大的改变

269
00:11:15,316 --> 0:11:18,826
在 Swift 5 中的字符串类型上

270
00:11:19,786 --> 0:11:20,856
这是一个隐藏的变化

271
00:11:20,856 --> 0:11:23,346
我们将字符串的 Unicode 表达

272
00:11:23,346 --> 0:11:29,326
从 UTF-16 更改为 UTF-8

273
00:11:30,206 --> 0:11:33,416
那么这完全是由性能驱动的

274
00:11:34,296 --> 0:11:36,226
这个变化有很多丰富的细节

275
00:11:36,226 --> 0:11:38,506
如果你有兴趣了解更多的相关内容

276
00:11:38,506 --> 0:11:40,406
你可以去 swift.org

277
00:11:40,406 --> 0:11:41,566
那里有一篇博文

278
00:11:41,566 --> 0:11:43,666
讲解了实际的技术变化及其推动力量

279
00:11:44,196 --> 0:11:45,766
那么在这里我要强调一些重要的事情

280
00:11:46,816 --> 0:11:49,556
首先 我们将 Swift 创建为

281
00:11:49,556 --> 0:11:52,996
一种你可以达到像 C 语言性能的语言

282
00:11:54,256 --> 0:11:55,536
但其中的一个关键方面是

283
00:11:55,536 --> 0:11:56,846
我们想要 Swift 对现有的

284
00:11:56,846 --> 0:12:00,266
C API 生态系统有很强的互操作性

285
00:11:56,846 --> 0:12:00,266
C API 生态系统有很强的互操作性

286
00:12:00,266 --> 0:12:05,016
当 Swift 字符串使用 UTF-16 时

287
00:12:05,016 --> 0:12:08,866
当你把一个字符串传递给 C API 的时候

288
00:12:09,186 --> 0:12:10,936
你也许不知道

289
00:12:10,936 --> 0:12:12,796
你需要进行的操作是

290
00:12:12,796 --> 0:12:14,556
分配 副本和转码

291
00:12:14,556 --> 0:12:15,776
只是为了把字符串放进

292
00:12:15,776 --> 0:12:17,746
一个可以传递到 C 的兼容格式中

293
00:12:17,746 --> 0:12:19,366
那么这就是很大的开销了

294
00:12:20,176 --> 0:12:22,346
现在通过移动到 UTF-8

295
00:12:22,346 --> 0:12:23,436
我们可以直接将一个

296
00:12:23,436 --> 0:12:25,396
以 null 结尾的 UTF-8 字符串

297
00:12:25,396 --> 0:12:26,036
传递给 C API

298
00:12:26,396 --> 0:12:29,276
不需要分配和副本 且零开销

299
00:12:30,886 --> 0:12:32,666
同时我们还能够

300
00:12:32,666 --> 0:12:34,816
扩大字符串类型本身的优化

301
00:12:35,576 --> 0:12:37,396
字符串有一个小的字符串优化

302
00:12:37,396 --> 0:12:39,376
即如果该字符串中的字符数

303
00:12:39,376 --> 0:12:41,796
大约是 15 个字符或者更少的话

304
00:12:41,796 --> 0:12:44,746
我们就不需要一个单独的分配来获得

305
00:12:44,746 --> 0:12:45,816
这些字符的有效荷载

306
00:12:45,816 --> 0:12:48,546
我们可以直接将它打包到字符串值中

307
00:12:48,706 --> 0:12:49,726
这真的是一个进步

308
00:12:49,836 --> 0:12:53,026
在 Swift 5 中我们能够将这个优化扩展到

309
00:12:53,026 --> 0:12:55,716
包括基本上所有的 Unicode 字符

310
00:12:55,716 --> 0:12:57,806
不仅限于 ASCII 这就意味着

311
00:12:57,806 --> 0:13:00,946
它现在可以应用到非罗马字符的语言中

312
00:12:57,806 --> 0:13:00,946
它现在可以应用到非罗马字符的语言中

313
00:13:01,506 --> 0:13:03,596
我们在这样做的同时

314
00:13:03,596 --> 0:13:06,236
也在性能层面上保持

315
00:13:06,456 --> 0:13:08,036
NSStrings 和 String 之间

316
00:13:08,036 --> 0:13:08,876
强大的互操作性

317
00:13:10,216 --> 0:13:11,456
但是真正令人兴奋的是

318
00:13:11,456 --> 0:13:13,906
这完全是关乎性能的

319
00:13:13,906 --> 0:13:14,966
我已经说过好几次了

320
00:13:16,056 --> 0:13:17,486
有一个很好的例子

321
00:13:17,556 --> 0:13:18,916
就是 SwiftNIO

322
00:13:18,916 --> 0:13:20,266
对于不熟悉它的人来说

323
00:13:20,266 --> 0:13:21,756
SwiftNIO 是来自于

324
00:13:21,756 --> 0:13:23,086
用于服务器的 Swift

325
00:13:23,566 --> 0:13:27,976
它是一个用于构建网络协议和服务的跨平台框架

326
00:13:28,246 --> 0:13:30,486
它为了速度而进行了调整

327
00:13:31,676 --> 0:13:35,156
通过切换到 UTF-8

328
00:13:35,226 --> 0:13:37,776
我们可以看到构建在 SwiftNIO 上的

329
00:13:37,776 --> 0:13:40,266
网络服务器的吞吐量增加了 20%

330
00:13:40,266 --> 0:13:44,136
那么这就只是文本处理的一个基准

331
00:13:44,736 --> 0:13:46,726
而这恰恰与我们的想法类似

332
00:13:46,726 --> 0:13:47,926
我们想让字符串成为一种

333
00:13:47,926 --> 0:13:51,406
你可以用它来进行

334
00:13:51,566 --> 0:13:54,216
高性能密集的字符串操作

335
00:13:54,216 --> 0:13:56,326
但同时它对用户友好

336
00:13:56,386 --> 0:13:59,906
且易于使用的类型

337
00:14:00,366 --> 0:14:01,576
过一会我会把舞台交给 Anna

338
00:14:01,696 --> 0:14:03,266
她会向大家主要介绍

339
00:14:03,266 --> 0:14:04,636
Swift 5 和 Swift 5.1 

340
00:14:04,636 --> 0:14:06,536
中的语言变化

341
00:14:06,536 --> 0:14:07,636
在此之前 我想再谈一些

342
00:14:07,636 --> 0:14:09,556
核心工具和改进

343
00:14:09,556 --> 0:14:12,846
及其中的开源项目的关键方面

344
00:14:14,416 --> 0:14:16,766
现在 Swift 作为一个开源项目

345
00:14:16,766 --> 0:14:18,936
已经不仅仅是一个项目上的

346
00:14:18,936 --> 0:14:20,556
日常的工程工作了

347
00:14:20,886 --> 0:14:22,216
而是关于 Swift 成为一个

348
00:14:22,216 --> 0:14:23,926
更广泛且更多样化的

349
00:14:23,986 --> 0:14:25,886
软件生态系统的一部分

350
00:14:26,536 --> 0:14:28,816
那么举个例子

351
00:14:28,816 --> 0:14:30,566
Swift 社群聚集在一起

352
00:14:30,566 --> 0:14:32,746
为 Swift 创建了官方的 Docker 镜像

353
00:14:32,926 --> 0:14:35,786
它们都被托管在 Docker Hub 中

354
00:14:36,446 --> 0:14:37,546
而如果你在 Mac 上

355
00:14:37,546 --> 0:14:38,636
安装 Docker 其实就是

356
00:14:38,636 --> 0:14:40,606
敲几下键盘的事情

357
00:14:40,606 --> 0:14:42,016
你就可以拥有一个 Docker

358
00:14:42,016 --> 0:14:43,406
就是这个 Docker 镜像

359
00:14:43,406 --> 0:14:45,066
同时拥有在你的 Mac 上

360
00:14:45,466 --> 0:14:46,896
工作的 Docker Linux 容器

361
00:14:46,896 --> 0:14:48,866
包括一个编译器和包管理器

362
00:14:48,866 --> 0:14:50,866
这就是你需要的一切

363
00:14:51,366 --> 0:14:52,566
之所以能这样做

364
00:14:52,626 --> 0:14:53,986
是因为容器如今被视为

365
00:14:53,986 --> 0:14:56,306
构建服务的一个

366
00:14:56,406 --> 0:14:58,396
固有的部分

367
00:14:59,736 --> 0:15:01,816
另一个重要的开源技术

368
00:14:59,736 --> 0:15:01,816
另一个重要的开源技术

369
00:15:01,816 --> 0:15:03,516
就是 SourceKit

370
00:15:03,936 --> 0:15:05,536
它是语义代码引擎

371
00:15:05,656 --> 0:15:07,286
支持着很多 Xcode 的特性

372
00:15:07,426 --> 0:15:08,426
如自动补全

373
00:15:08,426 --> 0:15:11,376
跳转到定义 以及重构等等

374
00:15:12,116 --> 0:15:14,406
这是我们继续完善的地方

375
00:15:14,406 --> 0:15:15,546
我们想要使得

376
00:15:15,546 --> 0:15:17,826
代码补全之类的结果更好

377
00:15:19,186 --> 0:15:21,406
所以我们需要不断地迭代

378
00:15:22,266 --> 0:15:23,886
但同时我们想要让它

379
00:15:23,886 --> 0:15:25,466
更可靠也更鲁棒

380
00:15:27,296 --> 0:15:28,556
我们所做的努力之一

381
00:15:28,556 --> 0:15:29,546
作为今年开源项目的一部分

382
00:15:29,546 --> 0:15:31,006
是为 SourceKit 构建一个

383
00:15:31,006 --> 0:15:32,526
新的压力测试工具

384
00:15:33,676 --> 0:15:37,696
它所做的就是用 IDE 可以发出的所有查询

385
00:15:37,696 --> 0:15:40,086
连续击打 SourceKit

386
00:15:40,136 --> 0:15:42,296
以快速找出 SourceKit 的问题

387
00:15:42,856 --> 0:15:43,816
那么比如崩溃和断言

388
00:15:43,816 --> 0:15:44,756
它为我们创造了

389
00:15:44,796 --> 0:15:46,476
可重现的测试用例

390
00:15:46,896 --> 0:15:49,106
这里还有一些变化的东西

391
00:15:50,466 --> 0:15:52,086
我们相信用 Swift

392
00:15:52,086 --> 0:15:55,096
为你们所有人创建

393
00:15:55,096 --> 0:15:56,996
一流的工具

394
00:15:56,996 --> 0:15:58,396
并将其投入我们自己的

395
00:15:58,396 --> 0:15:59,386
工作流程的一部分

396
00:15:59,386 --> 0:16:01,146
这就像是我们在享用

397
00:15:59,386 --> 0:16:01,146
这就像是我们在享用

398
00:16:01,786 --> 0:16:04,386
自己的理念 而像这样的努力

399
00:16:04,486 --> 0:16:06,686
就是现在我们日常的

400
00:16:06,686 --> 0:16:08,766
项目工程的一个核心部分

401
00:16:10,906 --> 0:16:12,986
那么我想要谈一谈

402
00:16:12,986 --> 0:16:14,626
一个面向未来的

403
00:16:14,626 --> 0:16:16,046
对 SourceKit 的投入

404
00:16:16,046 --> 0:16:17,676
那就是采用语言服务器协议

405
00:16:18,386 --> 0:16:20,896
举这个之前出现过的例子

406
00:16:21,576 --> 0:16:23,546
你可以用 Xcode

407
00:16:23,546 --> 0:16:24,896
或者把这个图片概括成为

408
00:16:24,896 --> 0:16:27,636
任何一种编辑器或工具

409
00:16:27,636 --> 0:16:29,086
我的意思是 SourceKit 是开源的

410
00:16:29,406 --> 0:16:30,776
它被设计为用于

411
00:16:30,776 --> 0:16:33,116
构建工具的可重用组件

412
00:16:34,196 --> 0:16:37,386
因此这样可以工作 对

413
00:16:37,386 --> 0:16:40,016
但这真的是一种很老的模型

414
00:16:40,236 --> 0:16:41,646
你可以假设那里有

415
00:16:41,646 --> 0:16:43,996
各种各样的工具和编辑器

416
00:16:43,996 --> 0:16:45,806
以及 IDE 它们想要

417
00:16:45,806 --> 0:16:48,816
连接到各种不同的语言服务

418
00:16:49,246 --> 0:16:50,316
因此 虽然它们能够直接

419
00:16:50,316 --> 0:16:51,526
连接逻辑来与 SourceKit 进行对话

420
00:16:51,526 --> 0:16:53,836
但这就都是相当临时的

421
00:16:53,836 --> 0:16:54,926
你必须让每一个编辑器

422
00:16:54,926 --> 0:16:57,096
连接到它自己的支持

423
00:16:57,096 --> 0:16:58,136
同时它们必须理解 SourceKit

424
00:16:58,136 --> 0:16:58,926
而且它们也必须了解

425
00:16:58,926 --> 0:17:00,526
所有它们想要连接的其他服务

426
00:16:58,926 --> 0:17:00,526
所有它们想要连接的其他服务

427
00:17:00,526 --> 0:17:02,776
所以这不是一个可扩展的模型

428
00:17:03,296 --> 0:17:04,576
但是像大多数

429
00:17:04,576 --> 0:17:05,626
计算机科学中的问题一样

430
00:17:05,626 --> 0:17:06,486
你都可以用一个间接层来解决

431
00:17:06,486 --> 0:17:08,546
除了性能问题

432
00:17:08,546 --> 0:17:11,776
已经出现了一种

433
00:17:11,776 --> 0:17:12,886
行业标准解决方案

434
00:17:12,886 --> 0:17:15,596
称为语言服务协议或 LSP

435
00:17:15,596 --> 0:17:18,056
这个想法是

436
00:17:18,056 --> 0:17:20,205
如果编辑器使用 LSP

437
00:17:20,205 --> 0:17:22,056
这是一组标准的查询

438
00:17:22,056 --> 0:17:23,846
而服务可以将其返回

439
00:17:23,846 --> 0:17:25,286
你就可以直接将它们

440
00:17:25,286 --> 0:17:26,056
混聚在一起

441
00:17:27,576 --> 0:17:28,976
这是一个正在进行的积极的努力

442
00:17:28,976 --> 0:17:31,136
也是一个开放源代码

443
00:17:31,376 --> 0:17:32,236
你可以关注一下

444
00:17:32,846 --> 0:17:34,446
但是要让你们了解一下

445
00:17:34,446 --> 0:17:36,806
它的功能

446
00:17:36,806 --> 0:17:39,146
这个动画显示的是

447
00:17:39,146 --> 0:17:41,596
使用 SourceKit LSP 的代码补全支持

448
00:17:41,596 --> 0:17:44,296
还有对其他各种

449
00:17:44,296 --> 0:17:45,536
编辑器的支持

450
00:17:45,536 --> 0:17:48,006
你可以在 GitHub 的页面上找到说明

451
00:17:49,516 --> 0:17:54,616
[掌声]

452
00:17:55,116 --> 0:17:56,476
正是像这样的投入

453
00:17:56,476 --> 0:17:57,906
让我们感到非常的兴奋

454
00:17:57,906 --> 0:17:59,416
因为 Swift 真的是

455
00:17:59,416 --> 0:18:00,976
我们为通用计算

456
00:17:59,416 --> 0:18:00,976
我们为通用计算

457
00:18:00,976 --> 0:18:03,326
而构建的语言 对吗

458
00:18:03,326 --> 0:18:05,166
它有巨大的潜力

459
00:18:05,216 --> 0:18:07,616
这实际上是为了

460
00:18:07,616 --> 0:18:10,036
让 Swift 真正蓬勃发展

461
00:18:10,036 --> 0:18:11,636
在一个多样化的软件生态系统中

462
00:18:12,126 --> 0:18:13,766
到这里 我要把舞台

463
00:18:13,766 --> 0:18:15,146
交给我的同事 Anna Zaks

464
00:18:15,146 --> 0:18:16,496
她会向大家分享

465
00:18:16,496 --> 0:18:18,516
Swift 中的语言变化

466
00:18:19,516 --> 0:18:24,056
[掌声]

467
00:18:24,556 --> 0:18:25,146
&gt;&gt; 谢谢你 Ted

468
00:18:25,756 --> 0:18:26,526
Ted 和大家分享了

469
00:18:26,526 --> 0:18:28,586
项目和编译器方面的改进

470
00:18:28,956 --> 0:18:30,366
现在让我来为大家介绍

471
00:18:30,526 --> 0:18:32,136
我们在 Swift 语言

472
00:18:32,136 --> 0:18:33,516
以及 Swift 5 和 Swift 5.1 中的

473
00:18:33,516 --> 0:18:36,006
标准库上所作的改进

474
00:18:37,126 --> 0:18:38,836
这些特性中有许多都在

475
00:18:38,836 --> 0:18:41,576
继续完善语言和库的核心部分

476
00:18:42,256 --> 0:18:43,956
同时为了与 Apple 今年推出的 

477
00:18:43,956 --> 0:18:45,556
几个主要的 Swift 框架

478
00:18:45,556 --> 0:18:47,086
匹配一致

479
00:18:47,086 --> 0:18:48,626
我们已经添加了能支持创建

480
00:18:48,626 --> 0:18:50,386
更好的 Swift API 的特性

481
00:18:51,356 --> 0:18:52,876
你们很多人都知道

482
00:18:52,876 --> 0:18:54,556
Swift 语言经历了

483
00:18:54,556 --> 0:18:55,516
开放的发展过程

484
00:18:56,006 --> 0:18:57,676
你们在幻灯片上看到的

485
00:18:57,676 --> 0:18:59,716
这些 SE 编号

486
00:18:59,716 --> 0:19:01,006
与可以 Swift 发展网站上

487
00:18:59,716 --> 0:19:01,006
与可以 Swift 发展网站上

488
00:19:01,006 --> 0:19:02,916
找到的特性文档相对应

489
00:19:03,926 --> 0:19:05,146
这是一个很棒的资源

490
00:19:05,146 --> 0:19:06,786
如果你想要进一步了解这些特性

491
00:19:07,306 --> 0:19:08,486
现在 让我来带你们

492
00:19:08,486 --> 0:19:11,096
看看其中的一些特性

493
00:19:11,256 --> 0:19:12,726
首先我要讲几个例子

494
00:19:12,726 --> 0:19:14,726
是关于遗漏缺陷的弥补

495
00:19:15,296 --> 0:19:18,046
许多人都喜欢

496
00:19:18,046 --> 0:19:20,026
单表达式闭包语法的简单性

497
00:19:20,606 --> 0:19:22,036
因此他们需要用单表达式

498
00:19:22,216 --> 0:19:24,226
来编写一个返回

499
00:19:24,226 --> 0:19:27,066
而函数 方法和下标

500
00:19:27,156 --> 0:19:28,896
则像是不必要的负担

501
00:19:29,216 --> 0:19:31,456
那么现在你可以在任何地方

502
00:19:31,456 --> 0:19:32,676
使用简单的语法了

503
00:19:33,516 --> 0:19:38,476
[掌声]

504
00:19:38,976 --> 0:19:40,466
另一个缺陷是被

505
00:19:40,466 --> 0:19:41,876
一个开源贡献者修复的

506
00:19:42,156 --> 0:19:43,416
他就是 Alejandro Alonso 

507
00:19:43,766 --> 0:19:45,716
令人惊讶的是

508
00:19:45,716 --> 0:19:46,856
他刚刚高中毕业

509
00:19:47,766 --> 0:19:49,146
我们看看这个结构体

510
00:19:49,146 --> 0:19:50,806
它便利地为它的

511
00:19:50,806 --> 0:19:52,436
两个属性定义默认值

512
00:19:53,396 --> 0:19:54,896
以前 你可以调用一个初始化

513
00:19:54,896 --> 0:19:57,146
然后不传递参数

514
00:19:57,806 --> 0:19:58,776
你也可以调用一个初始化

515
00:19:58,776 --> 0:20:00,216
然后传递所有参数

516
00:19:58,776 --> 0:20:00,216
然后传递所有参数

517
00:20:00,216 --> 0:20:02,326
但是你不可以

518
00:20:02,356 --> 0:20:04,196
调用一个初始化

519
00:20:04,196 --> 0:20:05,406
然后只传递一些参数

520
00:20:06,266 --> 0:20:08,626
在 Swift 5 中 这个问题被修复了

521
00:20:09,506 --> 0:20:11,106
一切都如你所愿地进行

522
00:20:11,606 --> 0:20:15,736
[掌声]

523
00:20:16,236 --> 0:20:18,286
编译器会为

524
00:20:18,506 --> 0:20:20,156
所有这些情况生成初始化

525
00:20:21,116 --> 0:20:23,176
另一个重要的领域是

526
00:20:23,176 --> 0:20:24,206
高性能计算

527
00:20:25,106 --> 0:20:26,896
在 Swift 5 中 标准库

528
00:20:26,896 --> 0:20:29,006
增加了对 SIMD 

529
00:20:29,006 --> 0:20:30,396
即单指令多数据流

530
00:20:30,496 --> 0:20:31,576
指令和类型的支持

531
00:20:32,496 --> 0:20:33,986
这些通常用于

532
00:20:33,986 --> 0:20:36,056
为图形编写底层性能敏感的代码

533
00:20:36,056 --> 0:20:39,766
比如图像处理或 AR

534
00:20:40,276 --> 0:20:41,706
事实上 我们今年发布的

535
00:20:41,706 --> 0:20:43,036
新的 RealityKit 库

536
00:20:43,276 --> 0:20:44,496
就正在使用这些类型

537
00:20:45,226 --> 0:20:47,716
新的 SIMD 类型表示

538
00:20:47,916 --> 0:20:49,486
固定大小的 SIMD 矢量

539
00:20:50,136 --> 0:20:51,786
正如你所期望的

540
00:20:51,786 --> 0:20:53,566
你可以在这里使用

541
00:20:53,606 --> 0:20:55,966
标准库整型和浮点类型作为元素

542
00:20:56,916 --> 0:20:58,396
让我来带你们了解一下

543
00:20:58,396 --> 0:21:01,916
你可以用这些类型来做什么

544
00:20:58,396 --> 0:21:01,916
你可以用这些类型来做什么

545
00:21:02,096 --> 0:21:03,876
你可以从数组字面量

546
00:21:03,876 --> 0:21:04,786
初始化 SIMD 矢量

547
00:21:05,626 --> 0:21:07,676
这里我们有大小为 4 的数组

548
00:21:08,156 --> 0:21:09,696
实际上是两个大小为 4 的数组

549
00:21:09,696 --> 0:21:11,816
而新的点运算符

550
00:21:11,816 --> 0:21:14,046
允许你在这些矢量上

551
00:21:14,096 --> 0:21:16,096
执行逐点运算

552
00:21:16,706 --> 0:21:18,676
比如等式和比较

553
00:21:19,296 --> 0:21:20,906
这里举个例子

554
00:21:20,906 --> 0:21:23,636
我们正在检查 x 是否在每个点上

555
00:21:23,936 --> 0:21:24,616
都比 y 点大

556
00:21:25,406 --> 0:21:27,136
结果告诉我们

557
00:21:27,136 --> 0:21:30,076
x 只在最后两点比 y 大

558
00:21:30,676 --> 0:21:33,076
该结果被储存在

559
00:21:33,076 --> 0:21:36,136
另一种叫 SIMDMask 的类型中

560
00:21:36,136 --> 0:21:37,906
而 SIMDMask 类型上的点运算符

561
00:21:37,906 --> 0:21:40,096
让你可以进一步操作

562
00:21:40,496 --> 0:21:42,036
这些生成的掩码

563
00:21:42,246 --> 0:21:43,226
举个例子在这里

564
00:21:43,226 --> 0:21:45,466
我们在对之前的计算结果取反

565
00:21:48,376 --> 0:21:50,456
Swift 5 还为你提供了

566
00:21:50,456 --> 0:21:53,576
更多的文本操作表达能力

567
00:21:53,806 --> 0:21:55,246
字符串内插已经

568
00:21:55,246 --> 0:21:56,946
在 Swift 5 中被重新设计

569
00:21:57,506 --> 0:22:00,346
新设计的速度和距离

570
00:21:57,506 --> 0:22:00,346
新设计的速度和距离

571
00:22:00,346 --> 0:22:03,376
达到之前的 1.7 倍

572
00:22:03,376 --> 0:22:05,256
你可以自定义

573
00:22:05,256 --> 0:22:07,116
所构建的内插

574
00:22:07,116 --> 0:22:08,676
通过提供自己的助手

575
00:22:08,676 --> 0:22:10,956
你可以用内插字符串

576
00:22:10,956 --> 0:22:12,946
将你的类型初始化

577
00:22:12,946 --> 0:22:14,786
来赋予字符串内插自定义的意义

578
00:22:15,886 --> 0:22:17,576
Swift 从一开始

579
00:22:17,576 --> 0:22:19,116
就可以支持字符串内插

580
00:22:19,466 --> 0:22:20,666
如果你写一个反斜杠符号

581
00:22:21,016 --> 0:22:22,266
后面跟着一些括号内引用

582
00:22:22,266 --> 0:22:23,566
在一个字符串字面量中

583
00:22:23,566 --> 0:22:25,166
编译器就会

584
00:22:25,166 --> 0:22:26,636
执行该代码

585
00:22:26,636 --> 0:22:28,916
并将值插入字符串

586
00:22:28,916 --> 0:22:31,246
这一直是行得通的

587
00:22:31,246 --> 0:22:32,546
但也会有一些限制

588
00:22:33,556 --> 0:22:35,736
举个例子 用一个封闭在

589
00:22:35,736 --> 0:22:37,816
NSLocalizedString 中的内插字符串

590
00:22:37,816 --> 0:22:40,056
这样是行不通的

591
00:22:41,236 --> 0:22:44,276
内插绘发生在转换之前

592
00:22:44,946 --> 0:22:46,986
比如说在这里

593
00:22:46,986 --> 0:22:48,996
字符串文件不包含

594
00:22:48,996 --> 0:22:51,246
对字符串中

595
00:22:51,296 --> 0:22:53,306
插入的整型的转换

596
00:22:53,726 --> 0:22:57,636
因此 You have 10 apples

597
00:22:57,636 --> 0:22:58,466
将无法被转换

598
00:22:59,576 --> 0:23:01,016
相反 你首先需要做的是

599
00:22:59,576 --> 0:23:01,016
相反 你首先需要做的是

600
00:23:01,016 --> 0:23:03,416
创建 formatString

601
00:23:05,146 --> 0:23:07,166
接着 将它本地化

602
00:23:08,176 --> 0:23:10,046
然后 将值插入

603
00:23:10,046 --> 0:23:11,716
已经本地化的字符串中

604
00:23:12,836 --> 0:23:14,376
这就是用 UIKit 和 AppKit

605
00:23:14,376 --> 0:23:17,406
来完成字符串本地化的正确方法

606
00:23:18,456 --> 0:23:20,476
但是新的字符串内插设计

607
00:23:20,476 --> 0:23:22,236
让我们更进一步

608
00:23:22,236 --> 0:23:24,526
来设计出更有表现力的 API

609
00:23:24,526 --> 0:23:28,036
比如 SwiftUI 框架中的文本

610
00:23:28,706 --> 0:23:30,666
文本用于表示 SwiftUI 中的标签

611
00:23:30,666 --> 0:23:33,506
我们想要将其本地化

612
00:23:34,616 --> 0:23:35,606
我们来看看要怎么做

613
00:23:36,336 --> 0:23:39,096
这里我们传递一个

614
00:23:39,096 --> 0:23:40,256
内插字符串

615
00:23:40,256 --> 0:23:41,526
给文本的初始化

616
00:23:42,506 --> 0:23:44,126
而这里的技巧是

617
00:23:44,126 --> 0:23:46,656
文本初始化不接受

618
00:23:46,656 --> 0:23:48,046
字符串类型作为输入

619
00:23:48,616 --> 0:23:50,026
而是接受另一种类型

620
00:23:50,146 --> 0:23:52,456
它叫做 LocalizedStringKey

621
00:23:52,456 --> 0:23:54,616
该类型被定义在 SwiftUI 框架内

622
00:23:54,726 --> 0:23:56,916
因此 Swift 编译器

623
00:23:56,946 --> 0:23:58,316
就将自定义的规则

624
00:23:58,316 --> 0:24:00,186
应用到了字符串中

625
00:23:58,316 --> 0:24:00,186
应用到了字符串中

626
00:24:00,186 --> 0:24:02,026
通过字符串内插协议

627
00:24:02,236 --> 0:24:03,876
来处理该内插

628
00:24:04,896 --> 0:24:06,496
一旦它知道使用哪个规则

629
00:24:06,496 --> 0:24:08,656
编译器就会转换

630
00:24:08,656 --> 0:24:10,606
这个字符串内插

631
00:24:10,606 --> 0:24:12,156
用该自动生成的代码

632
00:24:13,306 --> 0:24:15,276
我们用三步来理解它的作用

633
00:24:16,166 --> 0:24:18,546
第一步 Swift 创建

634
00:24:18,596 --> 0:24:21,296
一个实例给构建器

635
00:24:21,296 --> 0:24:23,076
针对 LocalizedStringKey

636
00:24:23,566 --> 0:24:25,396
这个实例会包含两个东西

637
00:24:25,396 --> 0:24:27,876
分别是 formatKey

638
00:24:27,876 --> 0:24:29,276
和一个变量数组

639
00:24:30,756 --> 0:24:33,216
第二步 我们通过处理

640
00:24:33,716 --> 0:24:36,336
内插的段来构建字符串

641
00:24:37,076 --> 0:24:38,666
首先 我们有一个字符串字面量

642
00:24:38,786 --> 0:24:40,036
我们将它添加给 formatKey

643
00:24:41,296 --> 0:24:43,506
其次 在处理 quantity 时

644
00:24:43,646 --> 0:24:45,856
分别恢复 formatKey 中的

645
00:24:45,856 --> 0:24:48,256
格式说明符

646
00:24:48,256 --> 0:24:50,186
和变量数组中的值

647
00:24:51,666 --> 0:24:54,046
最后给 formatKey 添加另一段字面值

648
00:24:55,346 --> 0:24:58,946
第三步 调用 LocalizedStringKey 的初始化器

649
00:24:58,946 --> 0:25:00,806
这个时候你有了足够的信息

650
00:24:58,946 --> 0:25:00,806
这个时候你有了足够的信息

651
00:25:00,806 --> 0:25:03,306
来将字符串合理地本地化

652
00:25:05,356 --> 0:25:06,856
这样 SwiftUI 就可以使用

653
00:25:06,856 --> 0:25:08,326
该语言特性将文本本地化

654
00:25:08,386 --> 0:25:12,646
然后用户就可以读取信息 很酷吧

655
00:25:13,516 --> 0:25:19,036
[掌声]

656
00:25:19,536 --> 0:25:21,266
这个例子只是

657
00:25:21,266 --> 0:25:22,796
粗浅地介绍了一点

658
00:25:22,796 --> 0:25:23,886
字符串内插的使用

659
00:25:24,296 --> 0:25:26,196
如果你像我们一样

660
00:25:26,196 --> 0:25:27,886
对这个新特性感兴趣的话

661
00:25:27,916 --> 0:25:30,646
那么你可以去阅读

662
00:25:30,646 --> 0:25:33,056
ExpressibleByStringInterpolation 协议的文档

663
00:25:35,166 --> 0:25:36,926
现在 我们来谈谈焦点

664
00:25:37,506 --> 0:25:39,896
API 设计的一部分就是要

665
00:25:39,896 --> 0:25:42,806
决定从你的 API 中排除什么

666
00:25:42,876 --> 0:25:44,766
在 Swift 5.1 中 我们已经

667
00:25:44,866 --> 0:25:47,466
专门针对返回的类型做了改进

668
00:25:47,986 --> 0:25:50,146
虽然很重要的一点是

669
00:25:50,146 --> 0:25:51,636
返回的类型表示

670
00:25:51,636 --> 0:25:53,166
类型的性能

671
00:25:53,166 --> 0:25:54,956
你的 API 的用户可以从中推断

672
00:25:54,956 --> 0:25:57,416
但有时我们想要

673
00:25:57,416 --> 0:25:59,246
将返回的内容抽象化

674
00:26:00,246 --> 0:26:01,906
一个函数可以

675
00:26:01,906 --> 0:26:05,066
在运行时返回多次 

676
00:26:05,066 --> 0:26:06,736
或者它总是返回相同的类型

677
00:26:07,366 --> 0:26:08,716
但是该类型也许会透露

678
00:26:08,716 --> 0:26:11,426
你的 API 的实现细节

679
00:26:12,456 --> 0:26:14,446
且显示一些你的 API 的用户

680
00:26:14,446 --> 0:26:16,186
不应该推出的东西

681
00:26:17,026 --> 0:26:18,456
让我们来看看 Swift

682
00:26:18,666 --> 0:26:20,766
提供给这些例子的选项

683
00:26:22,226 --> 0:26:23,846
我们在例子中

684
00:26:24,176 --> 0:26:25,106
使用简单的形状 API

685
00:26:25,626 --> 0:26:27,116
那么正如你所期待的

686
00:26:27,116 --> 0:26:29,626
我们这里有一个 Shape 协议

687
00:26:29,626 --> 0:26:31,696
我们有定义如圆形 椭圆形

688
00:26:31,696 --> 0:26:34,616
和正方形等基本图形的类型

689
00:26:35,736 --> 0:26:37,226
同时我们还有这样的结构

690
00:26:37,226 --> 0:26:40,136
可以操作图形来创建

691
00:26:40,136 --> 0:26:42,256
图形的并集然后转换它们

692
00:26:42,916 --> 0:26:45,076
看看这个 FaceShape 的例子

693
00:26:45,796 --> 0:26:47,906
注意 这个 API 会根据你的图形的类型

694
00:26:47,946 --> 0:26:50,206
也就是 faceType

695
00:26:50,296 --> 0:26:53,016
来返回不同的类型

696
00:26:53,216 --> 0:26:55,686
但它们都是符合 Shape 协议的

697
00:26:55,996 --> 0:26:57,806
因此它是一个很好的例子

698
00:26:57,876 --> 0:26:59,466
将协议类型用作我们的返回类型

699
00:27:00,086 --> 0:27:02,726
那么 在这个例子中

700
00:27:02,916 --> 0:27:05,126
我们来构建一个八角星

701
00:27:05,216 --> 0:27:07,696
通过创建一个正方形

702
00:27:07,696 --> 0:27:10,596
和转换后的正方形的并集 对吗

703
00:27:11,866 --> 0:27:13,476
在这里声明具体的返回类型

704
00:27:13,476 --> 0:27:15,376
就会将大部分实现细节

705
00:27:15,376 --> 0:27:16,696
透露给客户

706
00:27:16,696 --> 0:27:19,726
同时显示出这个

707
00:27:19,726 --> 0:27:21,546
不必要的细节

708
00:27:21,546 --> 0:27:24,106
会让 API 很难推出

709
00:27:25,626 --> 0:27:27,406
但是 在这里使用一个

710
00:27:27,406 --> 0:27:29,216
协议类型 Shape 也不太好

711
00:27:29,606 --> 0:27:30,236
让我们看看这是为什么

712
00:27:31,706 --> 0:27:33,226
当协议类型被返回时

713
00:27:33,226 --> 0:27:34,856
这里并不能保证

714
00:27:34,856 --> 0:27:36,516
从每个调用中

715
00:27:36,516 --> 0:27:38,046
返回相同的类型给 API

716
00:27:38,046 --> 0:27:40,606
除 Swift 的泛型外

717
00:27:40,606 --> 0:27:42,486
它也给我们带来了

718
00:27:42,486 --> 0:27:44,086
这些基础的限制

719
00:27:44,806 --> 0:27:46,906
如果八角星有两个值

720
00:27:46,906 --> 0:27:49,046
从相同的 API 

721
00:27:49,046 --> 0:27:51,336
但不同的两个调用中

722
00:27:51,336 --> 0:27:53,526
返回到这个 API

723
00:27:53,526 --> 0:27:54,976
它们可能就没有相同的类型

724
00:27:54,976 --> 0:27:56,766
这样你就不能进行比较相等

725
00:27:57,636 --> 0:27:59,296
返回的类型不能

726
00:27:59,296 --> 0:28:01,766
有任何的关联类型

727
00:27:59,296 --> 0:28:01,766
有任何的关联类型

728
00:28:01,766 --> 0:28:03,486
也不能有涉及到自身的需求

729
00:28:04,526 --> 0:28:06,606
此外 丢失此类型标识

730
00:28:06,606 --> 0:28:07,926
也可能让

731
00:28:07,926 --> 0:28:08,976
某些编译器无法进行优化

732
00:28:11,496 --> 0:28:14,216
Swift 5.1 引入了另外一个

733
00:28:14,216 --> 0:28:17,126
叫做不透明结果类型的概念

734
00:28:17,706 --> 0:28:19,476
这是一个伟大的进步

735
00:28:19,476 --> 0:28:21,476
适用于已知返回相同具体类型的 API

736
00:28:21,476 --> 0:28:24,406
但是有可能想要将这种类型

737
00:28:24,406 --> 0:28:26,816
对用户隐藏起来

738
00:28:27,876 --> 0:28:29,126
不透明结果类型

739
00:28:29,126 --> 0:28:31,576
在这里写作 some Shape

740
00:28:31,576 --> 0:28:33,736
它代表一个特定的

741
00:28:33,736 --> 0:28:35,266
Shape 类型从这个 API 中返回

742
00:28:36,936 --> 0:28:38,996
这种类型标识的保证

743
00:28:39,316 --> 0:28:40,536
也让我们能够

744
00:28:40,536 --> 0:28:42,326
在 API 的主体里

745
00:28:42,326 --> 0:28:43,586
执行更强的类型检查

746
00:28:44,516 --> 0:28:46,296
因此 如果你有几个返回了

747
00:28:46,296 --> 0:28:48,046
不同类型的返回语句

748
00:28:48,046 --> 0:28:50,946
编译器就会将其缓存

749
00:28:51,256 --> 0:28:53,246
并提醒你修复该问题

750
00:28:54,606 --> 0:28:55,996
不透明结果类型能够

751
00:28:55,996 --> 0:28:58,476
在 Swift 5.1 中使用

752
00:28:58,476 --> 0:29:00,626
你可以从文档中了解更多

753
00:28:58,476 --> 0:29:00,626
你可以从文档中了解更多

754
00:29:01,806 --> 0:29:03,296
注意 这个特性需要

755
00:29:03,296 --> 0:29:04,336
新的 Swift Runtime

756
00:29:05,086 --> 0:29:07,366
因此它只能在更新的 Swift 操作系统里工作

757
00:29:08,356 --> 0:29:09,796
如果你要进行向后部署

758
00:29:09,796 --> 0:29:11,636
你就可以使用这个特性

759
00:29:11,636 --> 0:29:13,686
但你需要进行静态可用性检查

760
00:29:13,986 --> 0:29:15,656
来保证它们的使用

761
00:29:17,816 --> 0:29:19,766
现在我们来说说代码重用

762
00:29:19,866 --> 0:29:22,306
及叫做属性包装器的新功能

763
00:29:23,636 --> 0:29:26,306
访问属性的自定模式很常见

764
00:29:26,856 --> 0:29:28,816
其中的一些模式

765
00:29:28,816 --> 0:29:30,246
具有一流的语言支持

766
00:29:30,246 --> 0:29:32,426
比如懒惰模式

767
00:29:32,866 --> 0:29:34,206
但你也可能正在编写

768
00:29:34,206 --> 0:29:35,826
你自己的自定包装器

769
00:29:36,716 --> 0:29:39,066
也许你有一些

770
00:29:39,106 --> 0:29:42,396
访问访问本地线程存储或写时拷贝

771
00:29:42,396 --> 0:29:43,686
也许你使用计算属性

772
00:29:43,686 --> 0:29:45,536
来储存用户默认值

773
00:29:46,956 --> 0:29:48,666
我们一直编写自定的

774
00:29:48,666 --> 0:29:50,476
get 和 set

775
00:29:50,476 --> 0:29:52,146
但有时这个代码是重复的

776
00:29:53,106 --> 0:29:54,636
例如在这里我有两个

777
00:29:54,636 --> 0:29:57,506
指定用户默认值的属性

778
00:29:58,436 --> 0:29:59,696
但这个代码的大多数

779
00:29:59,696 --> 0:30:02,206
只是在复制粘贴

780
00:29:59,696 --> 0:30:02,206
只是在复制粘贴

781
00:30:02,336 --> 0:30:03,856
有了属性包装器

782
00:30:03,856 --> 0:30:06,756
我们可以声明一种

783
00:30:06,756 --> 0:30:07,896
指定访问模式的类型

784
00:30:09,446 --> 0:30:10,816
我们将它命名为 UserDefaults

785
00:30:12,186 --> 0:30:13,846
接着 我们告诉编译器

786
00:30:13,846 --> 0:30:15,416
这个类型是特殊的

787
00:30:16,256 --> 0:30:18,246
它的首要目的就是

788
00:30:18,246 --> 0:30:21,236
包裹一个属性并指定其访问模式

789
00:30:22,486 --> 0:30:24,646
这样做我们得到的就是

790
00:30:24,646 --> 0:30:26,056
这个类型会允许我们

791
00:30:26,106 --> 0:30:28,796
使用一个自定属性来声明

792
00:30:28,796 --> 0:30:31,126
用户默认访问模式的属性

793
00:30:32,486 --> 0:30:33,556
我们来仔细看看

794
00:30:33,806 --> 0:30:35,326
有了这里的属性包装器

795
00:30:35,326 --> 0:30:38,746
我们可以重写

796
00:30:38,746 --> 0:30:40,116
之前那两个用户默认属性 

797
00:30:40,116 --> 0:30:41,096
写成这样

798
00:30:41,216 --> 0:30:43,626
这样就没有重复了

799
00:30:43,626 --> 0:30:44,886
非常干净明了

800
00:30:45,386 --> 0:30:47,196
我需要做的就只是

801
00:30:47,196 --> 0:30:50,546
添加自定属性

802
00:30:50,546 --> 0:30:52,236
同时知道这些属性

803
00:30:52,236 --> 0:30:53,436
仍被声明为布尔类型

804
00:30:53,716 --> 0:30:55,296
因此你可以使用它们

805
00:30:55,296 --> 0:30:56,826
像使用简单的布尔值一样

806
00:30:58,516 --> 0:31:04,276
[掌声]

807
00:30:58,516 --> 0:31:04,276
[掌声]

808
00:31:04,776 --> 0:31:06,236
属性包装器使得我们可以

809
00:31:06,236 --> 0:31:08,096
定义自定访问模式

810
00:31:08,486 --> 0:31:09,856
而属性可以选择使用它们

811
00:31:09,856 --> 0:31:11,776
只需要在其声明中

812
00:31:11,776 --> 0:31:13,726
添加一个自定属性

813
00:31:16,136 --> 0:31:18,046
我们寻求特定的工具

814
00:31:18,046 --> 0:31:19,396
来解决特定的问题

815
00:31:19,926 --> 0:31:22,486
它们在各自的领域都十分有用

816
00:31:23,526 --> 0:31:25,776
同样 DSL 在程序员的生活中

817
00:31:25,776 --> 0:31:27,256
也有着重要的作用

818
00:31:27,936 --> 0:31:29,536
我们用它们来

819
00:31:30,006 --> 0:31:31,646
查询数据库并构建图表

820
00:31:31,646 --> 0:31:33,256
我们喜欢这种声明风格

821
00:31:33,546 --> 0:31:35,116
我们可以简洁明了地

822
00:31:35,116 --> 0:31:39,126
声明我们网页的布局

823
00:31:40,016 --> 0:31:42,146
但是 它们也有不同

824
00:31:43,176 --> 0:31:44,626
当我们每次使用其中一种时

825
00:31:44,626 --> 0:31:46,806
都需要进行上下文切换

826
00:31:46,806 --> 0:31:48,966
每种语言都有自己的语法和语义

827
00:31:50,166 --> 0:31:51,546
它们都有各自独特的

828
00:31:51,546 --> 0:31:52,746
强大的工具来支持它们

829
00:31:53,456 --> 0:31:55,576
如果你缺失了一个 HTML 标记

830
00:31:55,576 --> 0:31:57,496
如果你在一个 HTML 编辑器里 

831
00:31:57,496 --> 0:31:58,806
这是很容易解决的

832
00:31:59,916 --> 0:32:01,426
但是 因为语法和语义

833
00:31:59,916 --> 0:32:01,426
但是 因为语法和语义

834
00:32:01,456 --> 0:32:03,436
都被调整为特定的目的

835
00:32:03,506 --> 0:32:05,986
支持它们的工具

836
00:32:05,986 --> 0:32:08,036
也常常有特定的领域

837
00:32:09,196 --> 0:32:10,946
因此当我们需要将

838
00:32:10,946 --> 0:32:12,636
这些 DSL 整合进我们的项目时

839
00:32:13,496 --> 0:32:14,776
通常没有什么好办法

840
00:32:16,066 --> 0:32:17,586
在一些情况里 我们会

841
00:32:17,586 --> 0:32:20,336
添加自定构建阶段

842
00:32:20,336 --> 0:32:21,336
但通常我们会用这个解决方案

843
00:32:22,456 --> 0:32:23,826
它看起来十分眼熟

844
00:32:23,826 --> 0:32:25,296
这是一个表示 HTML 的

845
00:32:25,296 --> 0:32:26,376
字符串字面值

846
00:32:27,666 --> 0:32:29,936
我们完成了整合 却失去了工具的支持

847
00:32:30,566 --> 0:32:32,726
编译器代码补全将这个

848
00:32:32,726 --> 0:32:33,606
看作一个字符串

849
00:32:34,476 --> 0:32:35,866
这里没有类型检查

850
00:32:36,186 --> 0:32:38,176
对 Swift 编译器来说只是一堆文本

851
00:32:39,046 --> 0:32:40,526
因此像忘记结束标记

852
00:32:40,526 --> 0:32:42,836
这样的低级错误

853
00:32:42,836 --> 0:32:44,286
直到运行时才会被注意到

854
00:32:45,306 --> 0:32:47,316
我们想要使用这些 DSL

855
00:32:47,736 --> 0:32:49,146
但我们也想要将它们

856
00:32:49,276 --> 0:32:51,526
整合到我们的语言和工具中

857
00:32:53,316 --> 0:32:55,466
在 Swift 5.1 中 我们

858
00:32:55,466 --> 0:32:57,626
引入了在 Swift 中定义

859
00:32:57,626 --> 0:32:58,766
嵌入式 DSL 的功能

860
00:32:59,516 --> 0:33:06,516
[掌声]

861
00:32:59,516 --> 0:33:06,516
[掌声]

862
00:33:07,016 --> 0:33:08,256
我们来看看这个代码

863
00:33:08,256 --> 0:33:10,116
它定义了一个 HTML 对象

864
00:33:10,656 --> 0:33:12,476
我的一位同事只是为了娱乐

865
00:33:12,476 --> 0:33:15,636
用这个新的 Swift 特性

866
00:33:15,636 --> 0:33:17,906
在几个小时内 为 HTML DSL

867
00:33:17,906 --> 0:33:19,236
提供了原型支持

868
00:33:20,056 --> 0:33:21,706
在这里你可以看到

869
00:33:21,706 --> 0:33:23,796
这个代码看起来像 Swift

870
00:33:23,796 --> 0:33:26,276
但你又被 HTML 元素的定义所吸引

871
00:33:26,536 --> 0:33:29,886
而你在这里可以看到

872
00:33:29,886 --> 0:33:32,646
熟悉的 Swift 概念 比如闭包和方法调用

873
00:33:33,076 --> 0:33:34,596
我们这里使用的是

874
00:33:34,596 --> 0:33:35,956
Swift 程序中的变量

875
00:33:36,756 --> 0:33:38,496
该工具将会确保

876
00:33:38,496 --> 0:33:40,366
没有标签的缺失

877
00:33:40,366 --> 0:33:42,816
同时提供语法的高亮显示和重构操作

878
00:33:43,946 --> 0:33:45,666
我们的设想是

879
00:33:45,666 --> 0:33:47,126
你不仅可以声明一个

880
00:33:47,126 --> 0:33:49,366
元素列表 还可以使用

881
00:33:49,426 --> 0:33:51,506
这样的 Swift 控制语句

882
00:33:51,506 --> 0:33:54,116
就在这个 DSL 当中

883
00:33:56,306 --> 0:33:56,456
好了

884
00:33:58,516 --> 0:34:02,316
[掌声]

885
00:33:58,516 --> 0:34:02,316
[掌声]

886
00:34:02,816 --> 0:34:04,386
让我们来看看在后台

887
00:34:04,386 --> 0:34:05,706
这是如何实现的

888
00:34:06,256 --> 0:34:07,926
DSL 实现者添加了一个函数

889
00:34:07,986 --> 0:34:10,565
来构建每一个 HTML 元素

890
00:34:11,545 --> 0:34:13,356
而这些函数都是闭包函数

891
00:34:14,216 --> 0:34:16,626
而这里有趣的部分是

892
00:34:16,626 --> 0:34:18,216
这些闭包是特殊的

893
00:34:18,815 --> 0:34:20,106
它们都有这个自定特性

894
00:34:20,106 --> 0:34:22,806
即 @HTMLBuilder

895
00:34:22,806 --> 0:34:24,656
这告诉了编译器

896
00:34:24,656 --> 0:34:27,025
要使用 HTMLBuilder 类型

897
00:34:27,096 --> 0:34:27,896
来处理这些闭包

898
00:34:29,576 --> 0:34:30,826
我们来看看包含 DSL 代码的

899
00:34:30,826 --> 0:34:32,706
闭包函数是如何转换为

900
00:34:32,706 --> 0:34:34,716
一个正常的 Swift 闭包函数的

901
00:34:36,056 --> 0:34:37,896
这个 DSL 闭包在做什么呢

902
00:34:38,386 --> 0:34:40,446
它正在生成一批值

903
00:34:41,386 --> 0:34:42,806
然而 这些值是未使用的

904
00:34:42,806 --> 0:34:43,976
同时这里也没有

905
00:34:43,976 --> 0:34:45,716
返回语句

906
00:34:46,456 --> 0:34:48,126
那么为了让它工作

907
00:34:48,126 --> 0:34:51,286
编译器将这个代码进行转换

908
00:34:51,896 --> 0:34:53,646
通过先收集这些未使用的值

909
00:34:54,266 --> 0:34:57,196
然后调用构建函数

910
00:34:57,196 --> 0:34:59,226
将它们组合起来

911
00:35:00,686 --> 0:35:02,196
这些函数都是由

912
00:35:02,196 --> 0:35:05,046
HTMLBuilder 类型提供的

913
00:35:05,046 --> 0:35:08,076
它是由你这个 DSL 作者编写的

914
00:35:08,146 --> 0:35:10,396
同时它可以构建任何

915
00:35:10,396 --> 0:35:11,576
适合你的 DSL 的对象

916
00:35:12,236 --> 0:35:14,196
这里我们正在构建 HTML

917
00:35:14,196 --> 0:35:15,676
因此它就会构建 HTML 对象

918
00:35:17,976 --> 0:35:19,756
我们很高兴使用这个功能

919
00:35:19,756 --> 0:35:21,336
我们用它来驱动

920
00:35:21,566 --> 0:35:23,796
你会在新的 SwiftUI 中

921
00:35:23,796 --> 0:35:26,286
用到的声明语法

922
00:35:27,516 --> 0:35:33,266
[掌声]

923
00:35:33,766 --> 0:35:35,366
这里有一个相关的例子

924
00:35:35,366 --> 0:35:37,616
在 Swift UI 中使用

925
00:35:37,616 --> 0:35:39,896
其自定 Swift DSL

926
00:35:41,196 --> 0:35:42,706
这个特性可在 beta 1 中使用

927
00:35:42,706 --> 0:35:44,596
我们很想看到

928
00:35:44,596 --> 0:35:46,146
它将怎样让你从中受益

929
00:35:46,146 --> 0:35:47,846
而你又会用它构建出怎样的 DSL

930
00:35:48,886 --> 0:35:50,226
我们会马上在 Swift 论坛上

931
00:35:50,226 --> 0:35:52,526
讨论该特性背后的这些细节

932
00:35:53,336 --> 0:35:54,356
如果你有兴趣来

933
00:35:54,356 --> 0:35:55,776
塑造这个特性的未来

934
00:35:55,776 --> 0:35:57,416
或者其他的 Swift 特性

935
00:35:57,886 --> 0:35:59,306
那么十分欢迎你的加入

936
00:36:01,596 --> 0:36:03,216
总的来说 

937
00:36:03,216 --> 0:36:05,106
我所说谈到的许多改进

938
00:36:05,106 --> 0:36:06,996
都会在我们今年

939
00:36:06,996 --> 0:36:08,436
新发布的 Swift 框架之中

940
00:36:09,276 --> 0:36:11,186
我们非常期待看到

941
00:36:11,186 --> 0:36:13,286
你们将如何从中获益

942
00:36:13,286 --> 0:36:15,276
让你们的 API 更有表现力

943
00:36:15,276 --> 0:36:15,946
干净且易于使用

944
00:36:16,776 --> 0:36:18,626
我们的同事将会做一个

945
00:36:18,626 --> 0:36:20,906
关于现代 Swift API 设计的演讲

946
00:36:20,906 --> 0:36:22,466
届时他们会与你们分享

947
00:36:22,466 --> 0:36:24,206
在用这些特性构建 Apple 框架时

948
00:36:24,206 --> 0:36:26,646
所学到的一些经验教训

949
00:36:27,446 --> 0:36:29,356
那么今天就到这里了

950
00:36:29,356 --> 0:36:30,816
参会愉快 谢谢大家

951
00:36:31,516 --> 0:36:36,500
[掌声]
