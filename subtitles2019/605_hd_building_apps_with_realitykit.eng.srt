1
00:00:00,506 --> 0:00:04,500
[ Music ]

2
00:00:09,016 --> 0:00:10,236
[ Applause ]

3
00:00:10,236 --> 0:00:13,766
&gt;&gt; Hello everyone.

4
00:00:13,766 --> 0:00:14,886
I'm Ross. I'm an engineer on the

5
00:00:14,886 --> 0:00:16,666
RealityKit team at Apple and

6
00:00:16,666 --> 0:00:18,106
welcome to Building Apps with

7
00:00:18,106 --> 0:00:18,686
RealityKit.

8
00:00:19,766 --> 0:00:22,316
So this session is intended as a

9
00:00:22,316 --> 0:00:23,076
follow up.

10
00:00:23,076 --> 0:00:24,786
So you might want to check out

11
00:00:24,786 --> 0:00:26,506
Intro to RealityKit and Reality

12
00:00:26,506 --> 0:00:27,206
Composer Session.

13
00:00:27,686 --> 0:00:28,596
Today we're going into the

14
00:00:28,596 --> 0:00:30,216
applied usage of RealityKit.

15
00:00:30,216 --> 0:00:31,136
And we'll walk you through

16
00:00:31,136 --> 0:00:32,226
building an augmented reality

17
00:00:32,226 --> 0:00:33,686
app and how you can leverage

18
00:00:33,686 --> 0:00:34,646
many of the frameworks key

19
00:00:34,646 --> 0:00:35,156
features.

20
00:00:35,706 --> 0:00:36,856
Before we dive in let's do a

21
00:00:36,856 --> 0:00:38,186
quick recap of what RealityKit

22
00:00:38,186 --> 0:00:38,386
is.

23
00:00:39,056 --> 0:00:40,916
So RealityKit is Apple's new

24
00:00:40,916 --> 0:00:43,986
framework for building AR Apps.

25
00:00:44,076 --> 0:00:46,296
Trying to make it as simple and

26
00:00:46,296 --> 0:00:47,596
intuitive as possible for any

27
00:00:47,596 --> 0:00:48,066
developer.

28
00:00:48,726 --> 0:00:49,566
It's been built from the ground

29
00:00:49,566 --> 0:00:50,636
up to work with AR.

30
00:00:50,636 --> 0:00:52,096
And it allows you to seamlessly

31
00:00:52,096 --> 0:00:53,466
blend rendered content with a

32
00:00:53,466 --> 0:00:54,436
real world environment.

33
00:00:54,436 --> 0:00:57,126
Its Swift API is simple yet

34
00:00:57,126 --> 0:00:58,536
powerful and lets you do a lot

35
00:00:58,536 --> 0:00:59,716
with only a few lines of code.

36
00:01:00,586 --> 0:01:01,696
All right, let's build an app.

37
00:01:02,956 --> 0:01:03,826
The app we're going to be

38
00:01:03,826 --> 0:01:05,066
building today is called "Memory

39
00:01:05,066 --> 0:01:05,556
Cards."

40
00:01:05,816 --> 0:01:06,766
And as the name cleverly

41
00:01:06,766 --> 0:01:08,256
implies, it's a card matching

42
00:01:08,256 --> 0:01:08,476
game.

43
00:01:09,736 --> 0:01:10,806
To play you tap on a card to

44
00:01:10,806 --> 0:01:12,086
select it and its image is

45
00:01:12,086 --> 0:01:12,476
revealed.

46
00:01:12,986 --> 0:01:14,946
Select another card to reveal it

47
00:01:14,946 --> 0:01:16,276
and if the pair is a match the

48
00:01:16,276 --> 0:01:17,006
cards are removed.

49
00:01:17,726 --> 0:01:19,106
If they don't match both cards

50
00:01:19,106 --> 0:01:20,506
are hidden and you're free to

51
00:01:20,506 --> 0:01:21,226
select another pair.

52
00:01:21,926 --> 0:01:23,636
This simple game will allow us

53
00:01:23,636 --> 0:01:24,726
to highlight and discuss a lot of

54
00:01:24,726 --> 0:01:26,016
useful RealityKit features.

55
00:01:26,016 --> 0:01:28,186
So we're going to build Memory

56
00:01:28,186 --> 0:01:29,306
Cards in four stages.

57
00:01:30,156 --> 0:01:30,876
First we're going to put

58
00:01:30,876 --> 0:01:33,226
together a prototype that will

59
00:01:33,226 --> 0:01:34,796
place our content in AR and

60
00:01:34,796 --> 0:01:35,556
allow for some simple

61
00:01:35,556 --> 0:01:35,976
interaction.

62
00:01:37,596 --> 0:01:38,896
Next we'll add some polish with

63
00:01:38,896 --> 0:01:40,306
some fancy art assets, improve

64
00:01:40,306 --> 0:01:41,476
performance and AR rendering

65
00:01:41,476 --> 0:01:41,916
tricks.

66
00:01:43,176 --> 0:01:44,326
Then we'll leverage the entity

67
00:01:44,326 --> 0:01:46,406
component system to track custom

68
00:01:46,406 --> 0:01:47,186
state information.

69
00:01:48,596 --> 0:01:49,706
And finally we'll show you how

70
00:01:49,706 --> 0:01:50,706
to use RealityKit's built in

71
00:01:50,706 --> 0:01:51,736
network support by adding

72
00:01:51,736 --> 0:01:53,576
multiplayer to our game.

73
00:01:55,396 --> 0:01:55,976
All right.

74
00:01:56,166 --> 0:01:56,966
Let's get started with our

75
00:01:56,966 --> 0:01:57,226
prototype.

76
00:01:57,886 --> 0:01:59,856
So as mentioned in the intro

77
00:01:59,856 --> 0:02:01,346
session there are four objects

78
00:01:59,856 --> 0:02:01,346
session there are four objects

79
00:02:01,346 --> 0:02:02,906
that you'll need to use in every

80
00:02:02,996 --> 0:02:07,446
RealityKit app -- an ARView, the

81
00:02:07,446 --> 0:02:11,636
Scene, Anchors, and Entities.

82
00:02:12,206 --> 0:02:15,056
ARView is your window into the

83
00:02:15,056 --> 0:02:15,736
world of AR.

84
00:02:16,146 --> 0:02:17,346
And in your entry point for

85
00:02:17,346 --> 0:02:17,946
RealityKit.

86
00:02:18,606 --> 0:02:19,896
It's a view and it goes into

87
00:02:19,896 --> 0:02:21,136
your apps View hierarchy.

88
00:02:21,696 --> 0:02:24,106
The scene holds up with a

89
00:02:24,106 --> 0:02:25,086
virtual content that makes up

90
00:02:25,086 --> 0:02:26,816
your app and is owned by ARView.

91
00:02:29,506 --> 0:02:31,146
In RealityKit, Anchors describe

92
00:02:31,146 --> 0:02:32,486
how objects relate to the real

93
00:02:32,486 --> 0:02:32,846
world.

94
00:02:33,156 --> 0:02:34,116
And you'll need them to be able

95
00:02:34,316 --> 0:02:35,716
to place your virtual content.

96
00:02:36,326 --> 0:02:37,766
To place an anchor you add it to

97
00:02:37,766 --> 0:02:39,076
the scene and when the

98
00:02:39,076 --> 0:02:40,406
appropriate target is found the

99
00:02:40,406 --> 0:02:41,986
anchor is automatically placed

100
00:02:42,056 --> 0:02:42,546
in the world.

101
00:02:43,436 --> 0:02:44,636
For Memory Cards we'll use an

102
00:02:44,636 --> 0:02:45,656
anchor to place our game board

103
00:02:45,656 --> 0:02:46,886
on a horizontal surface.

104
00:02:47,836 --> 0:02:49,606
And entities are used to

105
00:02:49,606 --> 0:02:50,916
represent your virtual content

106
00:02:51,136 --> 0:02:52,096
and are the building blocks that

107
00:02:52,096 --> 0:02:52,676
make up your scene.

108
00:02:53,196 --> 0:02:54,876
In Memory Cards each of the

109
00:02:54,876 --> 0:02:56,196
cards will be represented by an

110
00:02:56,196 --> 0:02:56,586
entity.

111
00:02:57,186 --> 0:02:58,716
Since your game has 16 cards

112
00:02:58,716 --> 0:03:00,206
we'll need 16 entities.

113
00:02:58,716 --> 0:03:00,206
we'll need 16 entities.

114
00:03:01,656 --> 0:03:02,996
So now that we've covered the

115
00:03:02,996 --> 0:03:03,926
important elements that we'll

116
00:03:03,926 --> 0:03:05,656
need in our app let's talk about

117
00:03:05,656 --> 0:03:07,216
how we'll create our anchor so

118
00:03:07,216 --> 0:03:08,846
we can place our virtual game

119
00:03:08,846 --> 0:03:11,126
board in the real world.

120
00:03:12,216 --> 0:03:13,266
RealityKit anchoring is built on

121
00:03:13,266 --> 0:03:14,466
top of and integrated with

122
00:03:14,496 --> 0:03:14,976
ARkit.

123
00:03:14,976 --> 0:03:16,696
But then you leverage it's full

124
00:03:16,696 --> 0:03:17,246
feature set.

125
00:03:18,516 --> 0:03:20,366
To define Anchor content you

126
00:03:20,366 --> 0:03:21,446
create an anchor entity.

127
00:03:22,146 --> 0:03:23,416
To clear the type of anchoring

128
00:03:23,416 --> 0:03:25,616
you'd like to use and then add

129
00:03:25,616 --> 0:03:27,076
the anchor entity to your scene.

130
00:03:27,556 --> 0:03:30,236
Once the appropriate target is

131
00:03:30,236 --> 0:03:32,256
detected by ARkit, the anchor

132
00:03:32,256 --> 0:03:33,426
entity will automatically track

133
00:03:33,426 --> 0:03:34,986
it and making your virtual

134
00:03:34,986 --> 0:03:35,956
content feel like it's been

135
00:03:35,956 --> 0:03:37,266
placed in the real world as your

136
00:03:37,266 --> 0:03:38,586
device moves.

137
00:03:40,266 --> 0:03:41,276
Also as mentioned in the intro

138
00:03:41,276 --> 0:03:43,016
session, RealityKit supports all

139
00:03:43,016 --> 0:03:44,026
of the anchor types available

140
00:03:44,026 --> 0:03:45,206
with ARkit, allowing me to

141
00:03:45,206 --> 0:03:46,516
anchor things like planes,

142
00:03:46,856 --> 0:03:49,696
faces, images, objects, and new

143
00:03:49,696 --> 0:03:51,836
for ARkit 3, body anchors.

144
00:03:53,376 --> 0:03:54,816
For Memory Cards we just need a

145
00:03:54,816 --> 0:03:56,276
single anchor to place our game

146
00:03:56,276 --> 0:03:56,516
board.

147
00:03:57,686 --> 0:03:58,706
We like to place it on a

148
00:03:58,706 --> 0:04:00,006
horizontal surface with enough

149
00:03:58,706 --> 0:04:00,006
horizontal surface with enough

150
00:04:00,006 --> 0:04:01,236
space to fit all the cards,

151
00:04:01,236 --> 0:04:03,286
about 20 centimeters squared.

152
00:04:04,346 --> 0:04:05,416
And that anchor will represent

153
00:04:05,416 --> 0:04:07,176
our game board in the world and

154
00:04:07,176 --> 0:04:08,506
we'll place our content around

155
00:04:08,506 --> 0:04:08,626
it.

156
00:04:09,416 --> 0:04:10,186
Let's write some code to do

157
00:04:10,186 --> 0:04:10,526
this.

158
00:04:11,706 --> 0:04:12,386
So here we have the view

159
00:04:12,386 --> 0:04:13,586
controller for our Memory Cards

160
00:04:13,586 --> 0:04:14,076
prototype.

161
00:04:14,586 --> 0:04:15,996
We have an ARView in place in

162
00:04:15,996 --> 0:04:17,426
the View hierarchy and we're

163
00:04:17,426 --> 0:04:18,706
ready to find our anchor and

164
00:04:18,706 --> 0:04:19,946
create out virtual content,

165
00:04:20,636 --> 0:04:22,156
which we'll be doing in the

166
00:04:22,156 --> 0:04:23,606
viewDidLoad method.

167
00:04:25,366 --> 0:04:26,946
To define our anchor we create

168
00:04:26,946 --> 0:04:28,856
an anchor entity and using this

169
00:04:28,856 --> 0:04:30,266
convenience initializer we can

170
00:04:30,266 --> 0:04:31,856
specify the type of plane we'd

171
00:04:31,856 --> 0:04:32,526
like it to anchor to.

172
00:04:32,526 --> 0:04:33,946
In this case the horizontal

173
00:04:33,946 --> 0:04:34,216
plane.

174
00:04:35,336 --> 0:04:36,546
And we can optionally pass in

175
00:04:36,546 --> 0:04:38,476
the minimum area we require, 20

176
00:04:38,476 --> 0:04:39,326
centimeters squared.

177
00:04:40,246 --> 0:04:41,496
RealityKit's units are in meters

178
00:04:41,786 --> 0:04:44,166
so I get 20 centimeters by 20

179
00:04:44,166 --> 0:04:46,316
centimeters, we pass in 0.2 by

180
00:04:46,316 --> 0:04:47,626
0.2.

181
00:04:48,086 --> 0:04:48,936
Then we just add our anchor to

182
00:04:48,936 --> 0:04:50,316
the scene and as soon as

183
00:04:50,316 --> 0:04:51,566
RealityKit finds a horizontal

184
00:04:51,566 --> 0:04:52,786
plane of at least 20 centimeters

185
00:04:52,786 --> 0:04:54,656
squared, any virtual content we

186
00:04:54,656 --> 0:04:55,756
attach to this anchor will

187
00:04:55,756 --> 0:04:56,306
appear in AR.

188
00:04:56,946 --> 0:04:59,356
Now that we have our anchor set

189
00:04:59,356 --> 0:05:00,236
up let's add some virtual

190
00:04:59,356 --> 0:05:00,236
up let's add some virtual

191
00:05:00,236 --> 0:05:00,686
content.

192
00:05:01,346 --> 0:05:02,246
First we need to load in the

193
00:05:02,246 --> 0:05:02,576
model.

194
00:05:03,326 --> 0:05:04,586
RealityKit natively supports

195
00:05:04,586 --> 0:05:06,386
assets in USDZ in the new

196
00:05:06,516 --> 0:05:07,696
Reality File formats.

197
00:05:08,766 --> 0:05:09,326
Loading can be done

198
00:05:09,326 --> 0:05:10,866
synchronously or asynchronously.

199
00:05:11,036 --> 0:05:11,856
For now we'll start with

200
00:05:11,856 --> 0:05:13,176
synchronous loading but we'll

201
00:05:13,176 --> 0:05:16,456
touch more on this later.

202
00:05:16,456 --> 0:05:18,236
When you load a USDZ or reality

203
00:05:18,236 --> 0:05:19,586
file asset, RealityKit

204
00:05:19,586 --> 0:05:20,956
automatically imports its entity

205
00:05:20,956 --> 0:05:23,126
hierarchy, and meshes used by

206
00:05:23,126 --> 0:05:25,806
the asset, its materials, and

207
00:05:25,806 --> 0:05:27,536
any animations it may have as

208
00:05:27,536 --> 0:05:27,726
well.

209
00:05:29,886 --> 0:05:30,796
Let's load in our basic card

210
00:05:30,796 --> 0:05:31,396
assets.

211
00:05:31,966 --> 0:05:34,396
To load a model you just need to

212
00:05:34,396 --> 0:05:36,026
go entities load model method

213
00:05:36,216 --> 0:05:37,196
with the name of the asset.

214
00:05:37,866 --> 0:05:38,816
There's not need to specify the

215
00:05:38,816 --> 0:05:40,466
file extension if the asset is

216
00:05:40,466 --> 0:05:41,146
in your app bundle.

217
00:05:42,426 --> 0:05:43,556
If RealityKit is able to load

218
00:05:43,556 --> 0:05:44,766
the asset, it will automatically

219
00:05:44,766 --> 0:05:46,066
create a ready to use entity for

220
00:05:46,066 --> 0:05:47,326
you to use however you want.

221
00:05:47,986 --> 0:05:49,146
Here we're loading on the eight

222
00:05:49,146 --> 0:05:50,666
base card models and storing

223
00:05:50,666 --> 0:05:51,316
them in an array.

224
00:05:51,926 --> 0:05:54,736
So Memory Card has 16 total

225
00:05:54,736 --> 0:05:55,376
cards.

226
00:05:56,366 --> 0:05:57,876
There are eight card types, each

227
00:05:57,876 --> 0:05:58,586
with a different image.

228
00:05:58,916 --> 0:06:00,666
And then there are two instances

229
00:05:58,916 --> 0:06:00,666
And then there are two instances

230
00:06:00,666 --> 0:06:02,476
of each type to create our eight

231
00:06:02,606 --> 0:06:03,536
matching pairs.

232
00:06:04,436 --> 0:06:05,496
So we've got our eight type

233
00:06:05,526 --> 0:06:06,796
models loaded, but how do we get

234
00:06:06,796 --> 0:06:07,346
the other eight?

235
00:06:08,496 --> 0:06:10,466
Now we could call entities load

236
00:06:10,466 --> 0:06:12,196
model method again, but any

237
00:06:12,196 --> 0:06:13,476
setup we perform on our cards

238
00:06:13,476 --> 0:06:14,846
will need to be done for each of

239
00:06:14,846 --> 0:06:15,306
these as well.

240
00:06:16,746 --> 0:06:17,826
RealityKit provides and easier

241
00:06:17,826 --> 0:06:19,616
solution with entity cloning.

242
00:06:20,206 --> 0:06:22,646
To create a clone you call

243
00:06:22,646 --> 0:06:23,616
entities clone method.

244
00:06:24,966 --> 0:06:26,146
And cloning creates an identical

245
00:06:26,146 --> 0:06:27,646
copy of the original entity.

246
00:06:28,996 --> 0:06:29,976
It references all the same

247
00:06:29,976 --> 0:06:32,576
assets used by the original, and

248
00:06:32,576 --> 0:06:33,486
cloning can also be done

249
00:06:33,626 --> 0:06:35,236
recursively, which will clone

250
00:06:35,236 --> 0:06:36,176
all of entities children as

251
00:06:36,176 --> 0:06:37,996
well, which really comes in

252
00:06:37,996 --> 0:06:39,076
handy when you're composing

253
00:06:39,136 --> 0:06:40,686
complex scenes with deep

254
00:06:40,686 --> 0:06:41,366
hierarchies.

255
00:06:41,996 --> 0:06:44,146
It's also important to note that

256
00:06:44,146 --> 0:06:45,876
clone entities are copies of the

257
00:06:45,876 --> 0:06:48,386
originals, not instances.

258
00:06:48,386 --> 0:06:49,906
So if you make a change to the

259
00:06:49,906 --> 0:06:51,246
original entity, say by removing

260
00:06:51,246 --> 0:06:53,106
a child, that change will not be

261
00:06:53,106 --> 0:06:54,226
reflective in any of its all

262
00:06:54,226 --> 0:06:55,366
ready existing clones.

263
00:06:56,466 --> 0:06:57,866
Let's use cloning to create our

264
00:06:57,866 --> 0:06:58,506
card pairs.

265
00:06:59,086 --> 0:07:01,836
So here we're cloning the two

266
00:06:59,086 --> 0:07:01,836
So here we're cloning the two

267
00:07:01,836 --> 0:07:03,236
instances of each card type we

268
00:07:03,236 --> 0:07:04,676
need and storing them in a

269
00:07:04,676 --> 0:07:06,266
separate array, which we'll use

270
00:07:06,266 --> 0:07:07,096
to build our game board.

271
00:07:08,406 --> 0:07:09,696
We could use the original card

272
00:07:09,696 --> 0:07:10,626
templates and then just clone

273
00:07:10,626 --> 0:07:12,206
one new instance, but by keeping

274
00:07:12,206 --> 0:07:13,286
the card template separate we

275
00:07:13,286 --> 0:07:14,456
can easily refer back to them to

276
00:07:14,456 --> 0:07:15,616
recreate the game board later

277
00:07:15,856 --> 0:07:16,746
without having to load them all

278
00:07:16,746 --> 0:07:17,796
again from scratch.

279
00:07:19,916 --> 0:07:21,426
Now that you have all 16 cards

280
00:07:21,426 --> 0:07:22,806
ready to go we need to place

281
00:07:22,806 --> 0:07:23,596
them in our game board.

282
00:07:24,336 --> 0:07:25,396
The anchor will be at the center

283
00:07:25,396 --> 0:07:26,576
of the play area and we'll

284
00:07:26,576 --> 0:07:27,706
arrange the cards in a

285
00:07:27,826 --> 0:07:30,266
four-by-four grid around them.

286
00:07:30,706 --> 0:07:31,916
Then all we need to do is add

287
00:07:31,916 --> 0:07:33,056
each card to the anchor and

288
00:07:33,056 --> 0:07:34,386
they'll be displayed in our ARC.

289
00:07:35,026 --> 0:07:38,036
So to do this we calculate the

290
00:07:38,036 --> 0:07:39,426
position of each card using its

291
00:07:39,426 --> 0:07:41,286
index and the array and then set

292
00:07:41,286 --> 0:07:42,496
it on it's position property.

293
00:07:43,226 --> 0:07:45,336
This will position it relative

294
00:07:45,336 --> 0:07:47,066
to its parent, the anchor, when

295
00:07:47,096 --> 0:07:48,156
we add each card to it.

296
00:07:48,816 --> 0:07:51,376
And that's all we need to do to

297
00:07:51,376 --> 0:07:52,906
get our cards laid out and

298
00:07:52,956 --> 0:07:54,066
rendering in AR.

299
00:07:54,736 --> 0:07:56,366
So we got our cards placing in a

300
00:07:56,366 --> 0:07:58,006
surface in AR, but we can't do

301
00:07:58,006 --> 0:07:59,186
anything with them yet, so let's

302
00:07:59,186 --> 0:07:59,976
add some interaction.

303
00:08:00,656 --> 0:08:02,946
We want the cards to flip when

304
00:08:02,946 --> 0:08:03,636
we tap on them.

305
00:08:03,706 --> 0:08:05,106
But to be able to do that we

306
00:08:05,106 --> 0:08:06,466
need to translate that tap on

307
00:08:06,466 --> 0:08:08,126
our devices screen into the

308
00:08:08,126 --> 0:08:09,836
world of AR so we can figure out

309
00:08:09,876 --> 0:08:11,486
what we're actually tapping on.

310
00:08:12,316 --> 0:08:13,156
And RealityKit provides a

311
00:08:13,156 --> 0:08:14,606
solution to this with hit

312
00:08:14,606 --> 0:08:14,966
testing.

313
00:08:16,386 --> 0:08:18,116
Hit testing works by turning a

314
00:08:18,116 --> 0:08:19,556
2D point that was tapped on your

315
00:08:19,556 --> 0:08:21,526
device's screen into a ray in

316
00:08:21,526 --> 0:08:22,396
our virtual scene.

317
00:08:23,236 --> 0:08:24,826
That ray is then cast into the

318
00:08:24,826 --> 0:08:26,556
scene and RealityKit finds all

319
00:08:26,556 --> 0:08:27,276
of the objects that are

320
00:08:27,276 --> 0:08:28,786
intersected by the ray.

321
00:08:29,286 --> 0:08:31,086
Any entities that were

322
00:08:31,086 --> 0:08:32,385
intersected by the ray are

323
00:08:32,385 --> 0:08:34,256
returned and you now know what

324
00:08:34,256 --> 0:08:35,606
objects lie under the tap.

325
00:08:37,145 --> 0:08:38,405
ARView provides the methods for

326
00:08:38,405 --> 0:08:38,986
hit testing.

327
00:08:39,285 --> 0:08:40,535
Entity at point returns the

328
00:08:40,535 --> 0:08:42,106
entity closest to the camera for

329
00:08:42,106 --> 0:08:44,066
the given point and entities at

330
00:08:44,066 --> 0:08:45,516
point returns all the entities

331
00:08:45,516 --> 0:08:47,006
that are intersected by the ray

332
00:08:47,136 --> 0:08:48,146
caster that given point.

333
00:08:48,616 --> 0:08:51,196
And we can easily integrate this

334
00:08:51,196 --> 0:08:52,216
into our Memory Cards app.

335
00:08:53,076 --> 0:08:54,746
Here we have a method responding

336
00:08:54,786 --> 0:08:56,496
to a tap gesture recognizer.

337
00:08:57,116 --> 0:08:58,556
We get the tap location in the

338
00:08:58,556 --> 0:09:00,206
ARView and then pass it into

339
00:08:58,556 --> 0:09:00,206
ARView and then pass it into

340
00:09:00,206 --> 0:09:01,806
entity at, which we're using

341
00:09:01,806 --> 0:09:03,456
because we only want the entity

342
00:09:03,566 --> 0:09:04,626
closest to our device.

343
00:09:05,596 --> 0:09:06,876
If there's an entity under that

344
00:09:06,876 --> 0:09:09,636
tap location, dis call, we'll

345
00:09:09,636 --> 0:09:10,896
return it, and we could then

346
00:09:10,896 --> 0:09:12,616
perform our interaction on it.

347
00:09:13,436 --> 0:09:14,506
However, there's still one more

348
00:09:14,506 --> 0:09:15,586
thing we need to do for hit

349
00:09:15,586 --> 0:09:16,966
testing to work.

350
00:09:18,646 --> 0:09:20,026
For entities to be hit testable

351
00:09:20,086 --> 0:09:21,086
they need a collision type

352
00:09:21,086 --> 0:09:21,426
shape.

353
00:09:22,926 --> 0:09:24,636
Collision shape is simplified

354
00:09:24,636 --> 0:09:26,356
geometry, typically a box.

355
00:09:27,086 --> 0:09:28,346
They're easy to find and they

356
00:09:28,346 --> 0:09:30,236
allow for efficient intersection

357
00:09:30,236 --> 0:09:31,736
and collision calculations.

358
00:09:32,426 --> 0:09:34,326
And importantly without a

359
00:09:34,326 --> 0:09:36,086
collision shape, entities are

360
00:09:36,086 --> 0:09:37,296
not hit testable.

361
00:09:37,516 --> 0:09:39,086
So let's add them to our cards.

362
00:09:39,826 --> 0:09:42,066
So this is the same code we saw

363
00:09:42,066 --> 0:09:43,426
before for leading our models

364
00:09:43,426 --> 0:09:44,766
and creating our card templates.

365
00:09:45,336 --> 0:09:47,836
We'll make a small change here

366
00:09:47,836 --> 0:09:50,216
to add entities generate

367
00:09:50,276 --> 0:09:51,236
collision shapes method.

368
00:09:52,086 --> 0:09:53,446
This will automatically generate

369
00:09:53,676 --> 0:09:55,346
simple box collision shapes for

370
00:09:55,346 --> 0:09:57,506
an entity using the entities

371
00:09:57,506 --> 0:09:58,476
visual bounds.

372
00:09:59,016 --> 0:10:00,516
As you can see, much like with

373
00:09:59,016 --> 0:10:00,516
As you can see, much like with

374
00:10:00,516 --> 0:10:01,886
cloning, this can be performed

375
00:10:01,966 --> 0:10:03,646
recursively creating collision

376
00:10:03,646 --> 0:10:05,086
shapes for all the children of

377
00:10:05,086 --> 0:10:06,176
an entity as well.

378
00:10:07,206 --> 0:10:08,126
And speaking of cloning,

379
00:10:08,446 --> 0:10:09,686
collision shapes are included in

380
00:10:09,686 --> 0:10:10,986
the data that gets copied when

381
00:10:10,986 --> 0:10:11,886
an entity is cloned.

382
00:10:12,656 --> 0:10:13,806
Since we're all ready cloning

383
00:10:13,806 --> 0:10:14,696
the card templates to build our

384
00:10:14,696 --> 0:10:15,586
game board, they'll be

385
00:10:15,586 --> 0:10:17,496
automatically included with

386
00:10:17,496 --> 0:10:18,446
these collision shapes as well.

387
00:10:18,656 --> 0:10:21,346
Now that we can figure out what

388
00:10:21,346 --> 0:10:22,806
entities we're interacting with,

389
00:10:22,976 --> 0:10:24,196
let's add an animation that will

390
00:10:24,196 --> 0:10:25,266
play when we tap on a card.

391
00:10:26,056 --> 0:10:27,396
RealityKit supports two kinds of

392
00:10:27,396 --> 0:10:27,946
animation.

393
00:10:28,156 --> 0:10:29,926
The first is transform

394
00:10:29,926 --> 0:10:30,356
animation.

395
00:10:30,356 --> 0:10:31,776
It let's you animate the

396
00:10:32,016 --> 0:10:36,446
position, rotation, and scale of

397
00:10:36,446 --> 0:10:37,566
entities in code.

398
00:10:38,186 --> 0:10:40,686
And the second is asset

399
00:10:40,686 --> 0:10:41,966
animation, which plays the

400
00:10:41,966 --> 0:10:43,226
animations that are baked into

401
00:10:43,226 --> 0:10:44,716
your assets that are loaded in

402
00:10:44,716 --> 0:10:46,896
from USDZs or reality files.

403
00:10:47,526 --> 0:10:49,506
And RealityKit also provides

404
00:10:49,506 --> 0:10:50,856
completion handlers for use with

405
00:10:50,856 --> 0:10:52,376
both kinds of animation, letting

406
00:10:52,376 --> 0:10:53,446
you know when the animation

407
00:10:53,446 --> 0:10:54,006
finishes.

408
00:10:55,166 --> 0:10:57,566
Once our card assets don't have

409
00:10:57,566 --> 0:10:59,236
a baked in animation, so to flip

410
00:10:59,236 --> 0:11:00,186
them we're going to use a

411
00:10:59,236 --> 0:11:00,186
them we're going to use a

412
00:11:00,186 --> 0:11:01,786
transform animation on our card

413
00:11:01,786 --> 0:11:02,136
entities.

414
00:11:05,206 --> 0:11:06,506
Transform animations can make

415
00:11:06,506 --> 0:11:07,696
use of a variety of timing

416
00:11:07,696 --> 0:11:09,046
functions that can control the

417
00:11:09,046 --> 0:11:09,986
speed of which the animation is

418
00:11:09,986 --> 0:11:10,316
played.

419
00:11:11,306 --> 0:11:12,536
There's linear, which plays the

420
00:11:12,536 --> 0:11:13,776
animation at a constant rate

421
00:11:13,996 --> 0:11:15,306
with instantaneous acceleration

422
00:11:15,306 --> 0:11:16,386
and deceleration.

423
00:11:16,686 --> 0:11:19,116
There's the ease in, which

424
00:11:19,116 --> 0:11:20,536
gradually ramps up the animation

425
00:11:20,576 --> 0:11:21,626
speed over its duration.

426
00:11:22,296 --> 0:11:24,696
Ease out is the opposite of ease

427
00:11:24,696 --> 0:11:25,816
in, which slows the animation

428
00:11:25,816 --> 0:11:27,126
down until its complete.

429
00:11:27,796 --> 0:11:30,436
And the ease in and ease out

430
00:11:30,686 --> 0:11:32,056
combines both, ramping the

431
00:11:32,056 --> 0:11:33,056
animations to be up until the

432
00:11:33,056 --> 0:11:34,586
halfway point and then slowing

433
00:11:34,586 --> 0:11:35,976
it down until its complete.

434
00:11:36,546 --> 0:11:38,836
And there's also a cubic Bezier

435
00:11:38,836 --> 0:11:40,436
option for customization of your

436
00:11:40,436 --> 0:11:41,126
timing function.

437
00:11:41,636 --> 0:11:43,346
Let's create an animation for

438
00:11:43,346 --> 0:11:43,886
our card flip.

439
00:11:44,556 --> 0:11:46,966
So we're going to start by

440
00:11:47,076 --> 0:11:48,606
copying our card's current

441
00:11:48,606 --> 0:11:49,276
transform.

442
00:11:49,936 --> 0:11:51,376
This ensures that we preserve

443
00:11:51,376 --> 0:11:52,596
the current scale and

444
00:11:52,596 --> 0:11:54,196
translation of the entity, which

445
00:11:54,296 --> 0:11:55,246
right here we don't want to

446
00:11:55,246 --> 0:11:55,636
change.

447
00:11:57,456 --> 0:11:59,346
Next we'll set the transform to

448
00:11:59,346 --> 0:12:01,566
a 180-degree rotation around the

449
00:11:59,346 --> 0:12:01,566
a 180-degree rotation around the

450
00:12:01,566 --> 0:12:03,616
x-axis using a quaternion.

451
00:12:03,966 --> 0:12:05,596
This will flip the card so its

452
00:12:05,596 --> 0:12:06,576
image is facing up.

453
00:12:06,656 --> 0:12:09,506
Now we can start the animation

454
00:12:09,506 --> 0:12:09,976
itself.

455
00:12:10,606 --> 0:12:12,216
Transform animation is applied

456
00:12:12,216 --> 0:12:13,786
using entities "move to" method.

457
00:12:15,136 --> 0:12:16,096
RealityKit will smooth the

458
00:12:16,096 --> 0:12:17,176
animated entity between its

459
00:12:17,176 --> 0:12:18,386
current transform and the one

460
00:12:18,386 --> 0:12:19,466
you provide in this method.

461
00:12:19,986 --> 0:12:20,946
Using the requested timing

462
00:12:20,946 --> 0:12:22,556
function, in this case "ease in

463
00:12:22,556 --> 0:12:24,226
and out" over the given length

464
00:12:24,226 --> 0:12:24,566
of time.

465
00:12:25,626 --> 0:12:27,406
This gives us the animation we

466
00:12:27,406 --> 0:12:28,926
need to flip the card face up.

467
00:12:29,386 --> 0:12:32,646
And entities move method return

468
00:12:32,646 --> 0:12:33,576
in animation with playback

469
00:12:33,576 --> 0:12:34,676
controller that allows you to

470
00:12:34,676 --> 0:12:36,156
pause, resume, or stop the

471
00:12:36,156 --> 0:12:37,886
animation, or to receive

472
00:12:37,886 --> 0:12:39,006
notification when the animation

473
00:12:39,006 --> 0:12:40,426
completes like we're doing here.

474
00:12:41,026 --> 0:12:43,806
Then to flip the card back to

475
00:12:43,806 --> 0:12:45,236
being face down, we just need to

476
00:12:45,236 --> 0:12:46,976
make one small tweak setting the

477
00:12:46,976 --> 0:12:48,666
rotation of our transform back

478
00:12:48,666 --> 0:12:49,096
to zero.

479
00:12:49,296 --> 0:12:50,786
When we call move this

480
00:12:50,786 --> 0:12:51,986
transform, the card will flip

481
00:12:51,986 --> 0:12:53,356
back to being face down.

482
00:12:55,406 --> 0:12:56,756
So now we can show the app with

483
00:12:56,756 --> 0:12:58,056
interaction enabled, using hit

484
00:12:58,056 --> 0:12:59,396
testing to detect what objects

485
00:12:59,396 --> 0:13:01,266
the user is selecting and

486
00:12:59,396 --> 0:13:01,266
the user is selecting and

487
00:13:01,266 --> 0:13:02,696
transform animation to hide the

488
00:13:02,696 --> 0:13:02,976
cards.

489
00:13:06,046 --> 0:13:07,056
Now that we've got the basics

490
00:13:07,056 --> 0:13:08,326
working, let's polish things up

491
00:13:08,326 --> 0:13:10,146
a bit with some detail work.

492
00:13:10,716 --> 0:13:12,976
We've got our simple card models

493
00:13:12,976 --> 0:13:14,966
loaded and placed in AR, but 2D

494
00:13:14,966 --> 0:13:16,596
images on cards is not very

495
00:13:16,596 --> 0:13:17,076
exciting.

496
00:13:18,056 --> 0:13:19,176
Thankfully our art team has also

497
00:13:19,176 --> 0:13:20,366
created a bunch of high quality

498
00:13:20,366 --> 0:13:21,866
models, so let's add them into

499
00:13:21,866 --> 0:13:23,136
the mix to help our app be a bit

500
00:13:23,136 --> 0:13:24,096
more three-dimensional.

501
00:13:24,656 --> 0:13:27,156
We could load these new assets

502
00:13:27,156 --> 0:13:28,696
the same way we did before with

503
00:13:28,696 --> 0:13:30,166
the synchronous entity.load

504
00:13:30,166 --> 0:13:30,556
method.

505
00:13:31,076 --> 0:13:32,436
However, these models are a lot

506
00:13:32,436 --> 0:13:34,396
more detailed than the simple

507
00:13:34,396 --> 0:13:35,226
card assets.

508
00:13:35,226 --> 0:13:36,756
And the larger assets will take

509
00:13:36,756 --> 0:13:37,446
longer to load.

510
00:13:37,926 --> 0:13:40,096
Loading them will be quick, but

511
00:13:40,096 --> 0:13:41,446
the app will be blocked while

512
00:13:41,446 --> 0:13:41,946
they're loading.

513
00:13:42,926 --> 0:13:44,226
And if you're loading a lot of

514
00:13:44,226 --> 0:13:45,186
assets that can add up to

515
00:13:45,186 --> 0:13:46,766
noticeable delays where nothing

516
00:13:46,766 --> 0:13:47,316
is happening.

517
00:13:48,136 --> 0:13:48,876
Is there anything we can do to

518
00:13:48,876 --> 0:13:49,436
make this better?

519
00:13:50,726 --> 0:13:51,806
Thankfully as we mentioned it

520
00:13:51,806 --> 0:13:53,106
earlier, RealityKit offers both

521
00:13:53,106 --> 0:13:54,446
synchronous and asynchronous

522
00:13:54,446 --> 0:13:54,786
loading.

523
00:13:55,576 --> 0:13:56,446
We can load models

524
00:13:56,446 --> 0:13:57,666
asynchronously by calling

525
00:13:57,666 --> 0:13:59,906
entities load model async

526
00:14:00,736 --> 0:14:00,896
method.

527
00:14:01,046 --> 0:14:02,106
With asynchronous loading,

528
00:14:02,556 --> 0:14:03,396
assets are loaded in the

529
00:14:03,396 --> 0:14:05,836
background and this unlocks the

530
00:14:05,836 --> 0:14:07,076
app and allows it to continue

531
00:14:07,116 --> 0:14:08,506
uninterrupted, which makes your

532
00:14:08,506 --> 0:14:10,266
app responsive and allows ARkit

533
00:14:10,266 --> 0:14:14,216
to continue observing the world.

534
00:14:14,536 --> 0:14:16,266
When asynchronous loading is

535
00:14:16,266 --> 0:14:17,676
complete you'll receive a call

536
00:14:17,676 --> 0:14:18,566
back and then it can use your

537
00:14:18,566 --> 0:14:20,436
assets just as you would with

538
00:14:20,436 --> 0:14:21,136
synchronous loading.

539
00:14:21,946 --> 0:14:23,486
And additionally you can also

540
00:14:23,486 --> 0:14:24,636
combine load requests and

541
00:14:24,636 --> 0:14:26,446
execute them simultaneously and

542
00:14:26,726 --> 0:14:28,056
receive notification when all

543
00:14:28,056 --> 0:14:29,136
assets have finished loading.

544
00:14:29,306 --> 0:14:30,186
So you don't need to load your

545
00:14:30,186 --> 0:14:31,326
content piecemeal.

546
00:14:32,136 --> 0:14:33,186
Let's write some code to load

547
00:14:33,186 --> 0:14:34,796
our new models asynchronously.

548
00:14:36,056 --> 0:14:37,426
So we'll start by loading a

549
00:14:37,516 --> 0:14:39,046
single model asynchronously.

550
00:14:39,846 --> 0:14:41,516
Entities load model async method

551
00:14:41,686 --> 0:14:43,176
takes on the name of the asset

552
00:14:43,436 --> 0:14:44,386
just like its synchronous

553
00:14:44,416 --> 0:14:44,966
counterpart.

554
00:14:45,656 --> 0:14:48,276
It returns a load request to

555
00:14:48,276 --> 0:14:49,316
receive notification when the

556
00:14:49,316 --> 0:14:51,396
model has finished loading and

557
00:14:51,396 --> 0:14:52,016
can be used.

558
00:14:52,596 --> 0:14:54,546
We call the sync method with a

559
00:14:54,546 --> 0:14:56,056
closure that will be executed

560
00:14:56,056 --> 0:14:57,266
when the asset is ready.

561
00:14:58,246 --> 0:15:00,456
The load request uses API

562
00:14:58,246 --> 0:15:00,456
The load request uses API

563
00:15:00,456 --> 0:15:01,536
introduced with a new Swift

564
00:15:01,536 --> 0:15:02,416
framework Combine.

565
00:15:02,816 --> 0:15:03,696
So I recommend checking out the

566
00:15:03,696 --> 0:15:05,216
session Introducing Combine and

567
00:15:05,216 --> 0:15:06,346
Advances in Foundation.

568
00:15:06,346 --> 0:15:08,656
And that's all you need to do to

569
00:15:08,656 --> 0:15:09,696
be able to load your content

570
00:15:09,696 --> 0:15:10,356
asynchronously.

571
00:15:10,706 --> 0:15:11,856
No you could load all of your

572
00:15:11,856 --> 0:15:13,416
assets individually like this,

573
00:15:13,856 --> 0:15:14,966
but you can also combine

574
00:15:14,966 --> 0:15:16,716
multiple load requests into one.

575
00:15:19,046 --> 0:15:19,896
We can do this by simply

576
00:15:19,956 --> 0:15:21,146
appending another load request

577
00:15:21,276 --> 0:15:22,126
on to the first one.

578
00:15:22,676 --> 0:15:25,316
We then call collect to combine

579
00:15:25,316 --> 0:15:26,326
our to load requests.

580
00:15:26,876 --> 0:15:28,876
And then we call sink.

581
00:15:29,036 --> 0:15:30,506
And our closure will be executed

582
00:15:30,506 --> 0:15:31,956
when both models have finished

583
00:15:31,956 --> 0:15:33,466
loading, packaged into the

584
00:15:33,466 --> 0:15:34,946
models of array parameter for

585
00:15:34,946 --> 0:15:35,896
easy processing.

586
00:15:38,256 --> 0:15:39,396
And we can extend this as far as

587
00:15:39,396 --> 0:15:39,766
we want.

588
00:15:40,356 --> 0:15:41,676
Here we're collecting all eight

589
00:15:41,676 --> 0:15:43,046
of our detailed card models into

590
00:15:43,046 --> 0:15:44,426
a single load request.

591
00:15:45,916 --> 0:15:46,816
Our sink closure will be

592
00:15:46,816 --> 0:15:48,146
executed when all eight have

593
00:15:48,396 --> 0:15:49,026
finished loading.

594
00:15:49,656 --> 0:15:50,756
Combine and load requests makes

595
00:15:50,756 --> 0:15:51,976
managing your content much

596
00:15:51,976 --> 0:15:52,346
easier.

597
00:15:55,106 --> 0:15:55,866
Let's show how synchronous

598
00:15:55,866 --> 0:15:56,516
loading compares with

599
00:15:56,516 --> 0:15:57,266
asynchronous loading.

600
00:15:57,266 --> 0:15:59,546
On the left our app is using

601
00:15:59,546 --> 0:16:00,466
synchronous loading and on the

602
00:15:59,546 --> 0:16:00,466
synchronous loading and on the

603
00:16:00,466 --> 0:16:01,566
right asynchronous.

604
00:16:01,566 --> 0:16:03,306
As soon as the synchronous app

605
00:16:03,306 --> 0:16:04,836
starts loading everything comes

606
00:16:04,836 --> 0:16:06,596
to a stop as the app is blocked

607
00:16:06,596 --> 0:16:07,556
until loading is complete.

608
00:16:08,216 --> 0:16:09,806
By contrast the asynchronous app

609
00:16:09,806 --> 0:16:11,076
continues to be responsive

610
00:16:11,386 --> 0:16:12,506
allowing it to respond to user

611
00:16:12,506 --> 0:16:14,766
input, update the camera, and

612
00:16:14,766 --> 0:16:15,706
you continue to observe the

613
00:16:15,706 --> 0:16:18,006
world in front of the camera.

614
00:16:18,196 --> 0:16:19,046
Loading takes about the same

615
00:16:19,046 --> 0:16:20,836
amount of time for both, however

616
00:16:20,836 --> 0:16:22,256
the device using async loading

617
00:16:22,256 --> 0:16:23,286
is able to place its content

618
00:16:23,606 --> 0:16:24,746
first because its able to

619
00:16:24,746 --> 0:16:26,076
continue observing the world

620
00:16:26,356 --> 0:16:26,986
during loading.

621
00:16:27,186 --> 0:16:27,956
While the device using

622
00:16:27,956 --> 0:16:29,636
asynchronous loading is not

623
00:16:29,876 --> 0:16:31,706
making it a much better fit for

624
00:16:31,706 --> 0:16:33,256
use with AR.

625
00:16:35,006 --> 0:16:35,626
So now we have out detailed

626
00:16:35,626 --> 0:16:36,396
models loading in without

627
00:16:36,396 --> 0:16:37,506
freezing the app.

628
00:16:37,826 --> 0:16:39,526
However an astute observer may

629
00:16:39,526 --> 0:16:40,446
notice that we can see the new

630
00:16:40,446 --> 0:16:41,756
models while the cards are faced

631
00:16:41,756 --> 0:16:42,076
down.

632
00:16:43,356 --> 0:16:44,366
We could simply hide the models

633
00:16:44,366 --> 0:16:45,436
while the cards are face down,

634
00:16:45,436 --> 0:16:46,356
but nothing would stop the user

635
00:16:46,356 --> 0:16:47,626
from bending over and looking at

636
00:16:47,626 --> 0:16:48,996
the underside of the cards and

637
00:16:48,996 --> 0:16:49,876
seeing which ones match up

638
00:16:50,126 --> 0:16:52,606
without having to flip them.

639
00:16:52,716 --> 0:16:54,386
So RealityKit provides a super

640
00:16:54,386 --> 0:16:55,426
useful way to fix this,

641
00:16:55,616 --> 0:16:56,696
occlusion materials.

642
00:16:57,396 --> 0:16:58,496
Occlusion materials are

643
00:16:58,496 --> 0:17:00,056
invisible, but when applied to

644
00:16:58,496 --> 0:17:00,056
invisible, but when applied to

645
00:17:00,056 --> 0:17:01,516
geometry in a scene they hide

646
00:17:01,516 --> 0:17:03,136
virtual content behind them

647
00:17:03,886 --> 0:17:04,925
revealing the video pass

648
00:17:04,925 --> 0:17:05,146
through.

649
00:17:05,685 --> 0:17:06,836
Here you can see we've added

650
00:17:06,836 --> 0:17:07,896
some occlusion geometry to our

651
00:17:07,896 --> 0:17:09,086
scene, along with some

652
00:17:09,086 --> 0:17:10,256
additional highlighting to show

653
00:17:10,256 --> 0:17:11,705
the shape of an otherwise

654
00:17:11,796 --> 0:17:12,675
invisible object.

655
00:17:13,476 --> 0:17:15,356
As in animates up and down parts

656
00:17:15,356 --> 0:17:16,566
of the robot it intersects are

657
00:17:16,656 --> 0:17:18,175
hidden and lets the real world

658
00:17:18,445 --> 0:17:19,455
behind it show through.

659
00:17:20,616 --> 0:17:21,576
Occlusion materials are great

660
00:17:21,576 --> 0:17:22,796
for simulating real world

661
00:17:22,796 --> 0:17:24,215
objects that would block virtual

662
00:17:24,215 --> 0:17:26,086
objects from being seen like a

663
00:17:26,086 --> 0:17:26,856
table or wall.

664
00:17:27,276 --> 0:17:28,296
So let's make use of it in our

665
00:17:28,996 --> 0:17:29,066
app.

666
00:17:30,076 --> 0:17:31,346
Let's start by adding an

667
00:17:31,346 --> 0:17:32,686
occlusion plane under our game

668
00:17:32,686 --> 0:17:32,956
board.

669
00:17:33,526 --> 0:17:34,756
We'll create a plane mesh half a

670
00:17:34,756 --> 0:17:35,926
meter wide and half a meter

671
00:17:35,926 --> 0:17:36,216
deep.

672
00:17:37,476 --> 0:17:38,436
We'll then create our occlusion

673
00:17:38,436 --> 0:17:41,346
material and then create a model

674
00:17:41,346 --> 0:17:42,786
entity using it and our plane

675
00:17:42,786 --> 0:17:43,176
mesh.

676
00:17:43,876 --> 0:17:45,276
We'll position it slightly below

677
00:17:45,276 --> 0:17:46,206
the game board so that it

678
00:17:46,206 --> 0:17:47,676
doesn't intersect the bottom of

679
00:17:47,676 --> 0:17:48,166
our models.

680
00:17:49,106 --> 0:17:50,196
And then we just add it to our

681
00:17:50,196 --> 0:17:51,736
anchor to place the occlusion

682
00:17:51,786 --> 0:17:52,856
plane in our scene.

683
00:17:54,366 --> 0:17:56,006
Here we can see the occlusion

684
00:17:56,006 --> 0:17:56,876
plane in action.

685
00:17:57,106 --> 0:17:58,306
At first glance this seems to do

686
00:17:58,306 --> 0:17:59,166
a great job of solving the

687
00:17:59,166 --> 0:18:00,456
problem, however when we start

688
00:17:59,166 --> 0:18:00,456
problem, however when we start

689
00:18:00,456 --> 0:18:02,046
to move the device down we can

690
00:18:02,046 --> 0:18:03,676
see the edge of the occlusion

691
00:18:03,676 --> 0:18:04,896
plane and see our virtual

692
00:18:04,896 --> 0:18:06,076
content rendering inside the

693
00:18:06,076 --> 0:18:06,456
table.

694
00:18:06,456 --> 0:18:08,016
So this plane works great when

695
00:18:08,016 --> 0:18:09,396
we're above the game board but

696
00:18:09,396 --> 0:18:10,406
we need occlusion that will work

697
00:18:10,406 --> 0:18:13,476
for an angle in this case.

698
00:18:13,646 --> 0:18:14,976
Solution is using occlusion

699
00:18:14,976 --> 0:18:16,206
box instead of an occlusion

700
00:18:16,206 --> 0:18:16,466
plane.

701
00:18:16,986 --> 0:18:20,016
So we'll generate a box, make

702
00:18:20,016 --> 0:18:20,846
use of the same occlusion

703
00:18:20,846 --> 0:18:23,036
material, and then create a

704
00:18:23,036 --> 0:18:24,566
model entity using the box in

705
00:18:24,566 --> 0:18:25,336
place of the plane.

706
00:18:26,806 --> 0:18:28,256
Generated geometric objects have

707
00:18:28,256 --> 0:18:30,106
their origins in the center so

708
00:18:30,106 --> 0:18:31,176
we need to bump it down by

709
00:18:31,176 --> 0:18:31,716
half a size and then just a

710
00:18:31,716 --> 0:18:32,806
little bit more so that the top

711
00:18:32,806 --> 0:18:34,096
of the box will rest just below

712
00:18:34,096 --> 0:18:35,006
the bottom of the game board.

713
00:18:36,376 --> 0:18:38,246
And then once again we just add

714
00:18:38,246 --> 0:18:39,266
it to our anchor to place the

715
00:18:39,266 --> 0:18:42,496
occlusion box in our scene.

716
00:18:43,136 --> 0:18:44,696
Initially it looks the same as

717
00:18:44,696 --> 0:18:46,656
the occlusion plane until we

718
00:18:46,656 --> 0:18:48,096
start to move our device down

719
00:18:48,736 --> 0:18:50,716
and we can see, or rather can't

720
00:18:50,716 --> 0:18:52,096
see our virtual content.

721
00:18:52,746 --> 0:18:54,026
Our occlusion box is preventing

722
00:18:54,026 --> 0:18:55,396
content from rendering inside

723
00:18:55,396 --> 0:18:57,046
the table simulating the real

724
00:18:57,046 --> 0:18:58,486
world object in our virtual

725
00:18:58,486 --> 0:18:58,856
scene.

726
00:19:00,226 --> 0:19:01,266
So now we have an app where we

727
00:19:01,266 --> 0:19:02,386
can place our virtual cards in

728
00:19:02,386 --> 0:19:03,716
the real world and interact with

729
00:19:03,716 --> 0:19:03,896
them.

730
00:19:03,896 --> 0:19:05,246
We're loading assets

731
00:19:05,246 --> 0:19:06,366
asynchronously and we're

732
00:19:06,366 --> 0:19:07,736
simulating our virtual content

733
00:19:07,736 --> 0:19:08,916
being hidden by real world

734
00:19:08,916 --> 0:19:10,376
objects using occlusion

735
00:19:10,376 --> 0:19:10,906
geometry.

736
00:19:11,566 --> 0:19:13,116
Now I'd like to invite my

737
00:19:13,116 --> 0:19:14,236
colleague Courtland up to talk

738
00:19:14,236 --> 0:19:15,336
about tracking game state.

739
00:19:15,706 --> 0:19:16,036
Courtland.

740
00:19:17,016 --> 0:19:21,500
[ Applause ]

741
00:19:25,236 --> 0:19:25,816
&gt;&gt; Thank you Ross.

742
00:19:26,476 --> 0:19:27,776
Hello. I'm Courtland, an

743
00:19:27,776 --> 0:19:29,296
engineer on the RealityKit team

744
00:19:29,296 --> 0:19:29,666
at Apple.

745
00:19:30,396 --> 0:19:31,766
We've just seen how to prototype

746
00:19:31,766 --> 0:19:33,756
a functioning AR game, add

747
00:19:33,756 --> 0:19:35,616
interaction, and integrate final

748
00:19:35,616 --> 0:19:36,006
artwork.

749
00:19:36,876 --> 0:19:38,056
Now I'd like to show you how to

750
00:19:38,056 --> 0:19:39,396
best track your state with

751
00:19:39,396 --> 0:19:40,796
custom components and entities

752
00:19:41,146 --> 0:19:42,416
and finally how to add

753
00:19:42,416 --> 0:19:42,916
mutli-player.

754
00:19:43,896 --> 0:19:45,446
Let's start with tracking state.

755
00:19:46,606 --> 0:19:48,106
As we covered in the intro

756
00:19:48,106 --> 0:19:49,936
session, RealityKit uses the

757
00:19:49,936 --> 0:19:51,296
entity component design pattern

758
00:19:51,446 --> 0:19:52,666
to build objects within the

759
00:19:52,666 --> 0:19:53,306
virtual world.

760
00:19:53,476 --> 0:19:56,326
An entity itself is comprised of

761
00:19:56,326 --> 0:19:57,676
pieces called "components."

762
00:19:58,616 --> 0:20:00,396
These components define specific

763
00:19:58,616 --> 0:20:00,396
These components define specific

764
00:20:00,396 --> 0:20:02,536
behaviors and data that can be

765
00:20:02,536 --> 0:20:03,856
added to individual entities.

766
00:20:04,846 --> 0:20:06,546
Using entities and components

767
00:20:06,546 --> 0:20:08,286
allows for reuse of code and is

768
00:20:08,286 --> 0:20:09,126
flexible to use.

769
00:20:09,786 --> 0:20:10,956
Let's take a look at how we can

770
00:20:10,956 --> 0:20:11,806
apply components.

771
00:20:12,356 --> 0:20:14,986
We're using RealityKit's model

772
00:20:14,986 --> 0:20:16,646
entity to represent our cards.

773
00:20:17,096 --> 0:20:18,226
It provides us with a set of

774
00:20:18,226 --> 0:20:19,806
components, which are useful for

775
00:20:19,806 --> 0:20:21,626
representing most common virtual

776
00:20:21,626 --> 0:20:22,196
objects.

777
00:20:22,946 --> 0:20:24,306
We've made use of the model

778
00:20:24,306 --> 0:20:25,796
component for visual appearance

779
00:20:25,796 --> 0:20:27,776
and the collision component for

780
00:20:27,776 --> 0:20:28,276
hit testing.

781
00:20:29,436 --> 0:20:30,936
Model entity also contains a

782
00:20:30,936 --> 0:20:32,626
physics component, allowing the

783
00:20:32,626 --> 0:20:34,326
entity to move and interact with

784
00:20:34,326 --> 0:20:35,736
other objects in a physically

785
00:20:35,816 --> 0:20:37,496
realistic way, though we haven't

786
00:20:37,496 --> 0:20:38,246
made use of it here.

787
00:20:39,836 --> 0:20:40,996
RealityKit enable you to

788
00:20:40,996 --> 0:20:42,006
customize an entity.

789
00:20:42,626 --> 0:20:43,866
By using an entity component

790
00:20:43,866 --> 0:20:45,206
design you can include the

791
00:20:45,206 --> 0:20:47,116
behaviors you want, exclude the

792
00:20:47,116 --> 0:20:49,296
ones you don't need, and add new

793
00:20:49,296 --> 0:20:50,166
behaviors of your own.

794
00:20:51,196 --> 0:20:52,926
Let's customize this entity for

795
00:20:53,636 --> 0:20:54,826
our cards.

796
00:20:54,966 --> 0:20:56,486
Model entity has most of what we

797
00:20:56,486 --> 0:20:56,746
need.

798
00:20:57,476 --> 0:20:58,996
We'll remove physics since we're

799
00:20:58,996 --> 0:20:59,506
not using it.

800
00:21:00,746 --> 0:21:01,986
We want to store whether the

801
00:21:01,986 --> 0:21:03,716
card is hidden or revealed and

802
00:21:03,826 --> 0:21:06,076
the kind of card which we'll use

803
00:21:06,116 --> 0:21:07,296
to determine if two cards are

804
00:21:07,296 --> 0:21:07,616
matching.

805
00:21:08,736 --> 0:21:10,286
To do this we need to create a

806
00:21:10,286 --> 0:21:12,226
new card component type with

807
00:21:12,226 --> 0:21:13,296
these properties, which we'll

808
00:21:13,296 --> 0:21:13,956
add to the entity.

809
00:21:15,266 --> 0:21:16,906
So what exactly is a component?

810
00:21:17,626 --> 0:21:20,196
A RealityKit component is a

811
00:21:20,196 --> 0:21:21,656
Swift struct that contains your

812
00:21:21,656 --> 0:21:22,046
properties.

813
00:21:23,046 --> 0:21:24,366
It conforms to the component

814
00:21:24,366 --> 0:21:26,056
protocol, which allows us to

815
00:21:26,056 --> 0:21:27,086
attach it to an entity.

816
00:21:28,466 --> 0:21:30,376
It's also a good idea to conform

817
00:21:30,376 --> 0:21:31,616
to Codable, as we'll see in the

818
00:21:31,616 --> 0:21:32,556
multi-player segment.

819
00:21:33,496 --> 0:21:34,066
So let's make one.

820
00:21:35,076 --> 0:21:37,506
We start by declaring our struct

821
00:21:37,866 --> 0:21:38,936
called CardComponent.

822
00:21:39,966 --> 0:21:41,046
We adopt the component in

823
00:21:41,046 --> 0:21:42,036
Codable protocols.

824
00:21:44,066 --> 0:21:45,086
Next we'll add our two

825
00:21:45,086 --> 0:21:46,626
properties -- a boolean called

826
00:21:46,626 --> 0:21:48,066
"revealed" to represent whether

827
00:21:48,066 --> 0:21:49,226
the card's contents are hidden

828
00:21:49,226 --> 0:21:51,006
or revealed and a string "kind,"

829
00:21:51,496 --> 0:21:52,516
which we can use to match the

830
00:21:52,516 --> 0:21:52,946
two cards.

831
00:21:53,726 --> 0:21:54,476
That's all for the type.

832
00:21:55,396 --> 0:21:56,476
We'll start with one of the card

833
00:21:56,476 --> 0:21:57,826
models Ross loaded earlier.

834
00:21:58,446 --> 0:22:01,106
For demonstration purposes I'll

835
00:21:58,446 --> 0:22:01,106
For demonstration purposes I'll

836
00:22:01,106 --> 0:22:02,226
show how to remove a physics

837
00:22:02,256 --> 0:22:02,936
body component.

838
00:22:03,696 --> 0:22:05,036
The model entity provides a

839
00:22:05,036 --> 0:22:06,346
physics body property, which

840
00:22:06,346 --> 0:22:07,156
makes this easy.

841
00:22:08,016 --> 0:22:10,586
We just assign nil and we're

842
00:22:11,696 --> 0:22:11,806
done.

843
00:22:12,026 --> 0:22:12,666
Now we'll load the card

844
00:22:12,666 --> 0:22:13,986
component by assigning to the

845
00:22:13,986 --> 0:22:16,336
components array indexed by the

846
00:22:16,336 --> 0:22:17,236
type of component.

847
00:22:18,246 --> 0:22:19,376
This will add the component, if

848
00:22:19,376 --> 0:22:21,006
it doesn't all ready exist, on

849
00:22:21,816 --> 0:22:23,046
the entity.

850
00:22:23,246 --> 0:22:24,446
Changing the kind property is

851
00:22:24,446 --> 0:22:24,756
similar.

852
00:22:25,726 --> 0:22:27,016
Indexed into the entities

853
00:22:27,016 --> 0:22:28,666
components array, and assigned

854
00:22:28,666 --> 0:22:29,476
to the kind property.

855
00:22:30,406 --> 0:22:31,766
Since not every entity contains

856
00:22:31,766 --> 0:22:33,506
a card component, the accesser

857
00:22:33,506 --> 0:22:36,216
returns an optional value.

858
00:22:37,266 --> 0:22:38,846
For common configuration of

859
00:22:38,876 --> 0:22:40,056
components used throughout your

860
00:22:40,056 --> 0:22:41,566
game, we can take it a step

861
00:22:41,566 --> 0:22:42,736
further and create our own

862
00:22:42,806 --> 0:22:43,476
custom entity.

863
00:22:44,466 --> 0:22:45,746
RealityKit comes with a number

864
00:22:45,746 --> 0:22:47,346
of entity configurations such as

865
00:22:47,346 --> 0:22:48,946
directional light and model

866
00:22:48,946 --> 0:22:49,306
entity.

867
00:22:49,816 --> 0:22:50,766
And you can make your own very

868
00:22:50,766 --> 0:22:51,166
easily.

869
00:22:51,926 --> 0:22:53,156
We're using cards everywhere in

870
00:22:53,156 --> 0:22:55,336
our game, so this makes an ideal

871
00:22:55,336 --> 0:22:56,546
candidate to turn into an

872
00:22:56,546 --> 0:22:56,866
entity.

873
00:22:58,006 --> 0:22:59,386
We'll get compile times, static

874
00:22:59,386 --> 0:23:00,836
typing and code completion for

875
00:22:59,386 --> 0:23:00,836
typing and code completion for

876
00:23:00,836 --> 0:23:01,496
these objects.

877
00:23:01,996 --> 0:23:03,346
This is also where we can add

878
00:23:03,346 --> 0:23:04,836
methods to encapsulate

879
00:23:04,836 --> 0:23:05,366
functionality.

880
00:23:06,726 --> 0:23:08,126
This is especially useful when

881
00:23:08,126 --> 0:23:08,976
you're changing multiple

882
00:23:08,976 --> 0:23:11,106
components at the same time such

883
00:23:11,106 --> 0:23:12,156
as setting the state of the card

884
00:23:12,156 --> 0:23:14,146
to revealed at the same time as

885
00:23:14,146 --> 0:23:16,326
flipping it over.

886
00:23:16,576 --> 0:23:18,006
Creating new entity is just a

887
00:23:18,006 --> 0:23:18,486
few steps.

888
00:23:19,736 --> 0:23:21,266
First we needed a new class to

889
00:23:21,296 --> 0:23:24,196
represent our entity.

890
00:23:24,406 --> 0:23:25,906
Then we added any RealityKit

891
00:23:25,906 --> 0:23:27,566
components we need.

892
00:23:28,696 --> 0:23:30,416
Next we'll add any custom

893
00:23:30,416 --> 0:23:31,016
components.

894
00:23:31,226 --> 0:23:32,136
We solved the physics body

895
00:23:32,136 --> 0:23:33,316
property on model entity

896
00:23:33,316 --> 0:23:34,816
earlier, which provide a

897
00:23:34,816 --> 0:23:36,356
convenient syntax for accessing

898
00:23:36,356 --> 0:23:37,496
the physical body component.

899
00:23:38,066 --> 0:23:39,966
We'll do the same for our card.

900
00:23:40,976 --> 0:23:42,516
Last we extend it with methods

901
00:23:43,646 --> 0:23:45,366
reveal and hide.

902
00:23:46,466 --> 0:23:49,246
So we create our card entity

903
00:23:49,246 --> 0:23:51,136
class derive from entity.

904
00:23:52,666 --> 0:23:54,086
Next include the RealityKit

905
00:23:54,086 --> 0:23:54,726
components.

906
00:23:55,356 --> 0:23:57,136
We're adding the HasModel and

907
00:23:57,136 --> 0:23:58,386
HasCollision protocols.

908
00:23:59,146 --> 0:24:00,606
These protocols give us access

909
00:23:59,146 --> 0:24:00,606
These protocols give us access

910
00:24:00,646 --> 0:24:01,766
to the model and collision

911
00:24:01,766 --> 0:24:04,056
components via properties and

912
00:24:04,056 --> 0:24:05,186
any methods that they provide

913
00:24:05,466 --> 0:24:06,536
such as generate collision

914
00:24:06,536 --> 0:24:06,996
shapes.

915
00:24:07,496 --> 0:24:10,356
Last we add a card property,

916
00:24:10,816 --> 0:24:11,936
which returns a CardComponent.

917
00:24:12,626 --> 0:24:13,976
Since all cards need a card

918
00:24:13,976 --> 0:24:15,066
component we'll make it

919
00:24:15,066 --> 0:24:15,636
non-optional.

920
00:24:16,276 --> 0:24:19,246
The getter will retrieve our

921
00:24:19,246 --> 0:24:20,096
CardComponent from the

922
00:24:20,096 --> 0:24:20,706
components array.

923
00:24:21,686 --> 0:24:22,736
We use the nil coalescing

924
00:24:22,736 --> 0:24:24,466
operator to return a default

925
00:24:24,466 --> 0:24:25,506
value if we didn't all ready

926
00:24:25,506 --> 0:24:25,996
have a card.

927
00:24:27,236 --> 0:24:28,986
The setter copies new value into

928
00:24:28,986 --> 0:24:29,626
the components array.

929
00:24:29,626 --> 0:24:32,776
Now that we have our class we

930
00:24:32,776 --> 0:24:33,566
extend it with methods.

931
00:24:34,276 --> 0:24:37,926
I've included the reveal method

932
00:24:38,086 --> 0:24:39,466
to show us how easy it is to

933
00:24:39,466 --> 0:24:40,596
coordinate multiple updates.

934
00:24:41,756 --> 0:24:43,366
We first update the card's state

935
00:24:43,456 --> 0:24:44,646
to indicate that it's revealed.

936
00:24:45,596 --> 0:24:46,986
We'll do this immediately rather

937
00:24:46,986 --> 0:24:48,196
than at the end of the animation

938
00:24:48,576 --> 0:24:49,936
in case you tap it again while

939
00:24:49,936 --> 0:24:50,626
it's still animating.

940
00:24:51,886 --> 0:24:53,596
Next we use the same code that

941
00:24:53,596 --> 0:24:55,016
Ross showed us earlier to

942
00:24:55,016 --> 0:24:56,126
animate the card flipping over.

943
00:24:57,006 --> 0:24:58,406
And that's it.

944
00:24:58,506 --> 0:24:59,426
Hide method would do the

945
00:24:59,426 --> 0:24:59,816
opposite.

946
00:25:00,436 --> 0:25:02,016
Set reveal to false and turn the

947
00:25:02,016 --> 0:25:03,066
card to be facing down.

948
00:25:04,106 --> 0:25:05,356
Let's see what this is like to

949
00:25:05,356 --> 0:25:05,756
use now.

950
00:25:07,156 --> 0:25:08,266
We'll go back to the onTap

951
00:25:08,266 --> 0:25:08,676
handler.

952
00:25:09,866 --> 0:25:11,636
We call the same ARView entity

953
00:25:11,636 --> 0:25:13,756
at method, but this time cast

954
00:25:13,756 --> 0:25:15,206
its result to a card entity.

955
00:25:16,136 --> 0:25:17,236
Though we only have cards in our

956
00:25:17,236 --> 0:25:18,896
game, your app might have other

957
00:25:18,896 --> 0:25:19,676
types of entities.

958
00:25:20,926 --> 0:25:22,596
Casting to card entity lets us

959
00:25:22,856 --> 0:25:24,466
perform actions specific to the

960
00:25:24,466 --> 0:25:24,716
card.

961
00:25:26,186 --> 0:25:27,546
With a new card entity and

962
00:25:27,546 --> 0:25:29,106
component, we can just ask the

963
00:25:29,106 --> 0:25:30,346
card if it's revealed.

964
00:25:30,346 --> 0:25:32,366
If it is currently revealed

965
00:25:32,846 --> 0:25:34,136
we'll hide it.

966
00:25:34,256 --> 0:25:35,786
Otherwise we'll reveal it.

967
00:25:36,886 --> 0:25:37,926
With hide and reveal

968
00:25:37,926 --> 0:25:39,226
encapsulated as methods on the

969
00:25:39,226 --> 0:25:40,726
entity, we don't need to be

970
00:25:40,726 --> 0:25:42,076
concerned with the specifics of

971
00:25:42,076 --> 0:25:43,606
hiding and revealing cards here.

972
00:25:44,226 --> 0:25:46,726
We've cleaned things up

973
00:25:46,726 --> 0:25:48,136
considerably by adding a custom

974
00:25:48,136 --> 0:25:50,056
component in entity and made one

975
00:25:50,056 --> 0:25:51,126
important functional change

976
00:25:51,126 --> 0:25:51,336
here.

977
00:25:52,426 --> 0:25:53,686
We now know that a card is

978
00:25:53,686 --> 0:25:55,536
revealed and can tap on it again

979
00:25:55,536 --> 0:25:57,186
to hide it in case it wasn't the

980
00:25:57,186 --> 0:25:57,996
card you remembered.

981
00:25:58,686 --> 0:26:00,906
Now that we've modeled our state

982
00:25:58,686 --> 0:26:00,906
Now that we've modeled our state

983
00:26:00,906 --> 0:26:02,386
as components and entities, it's

984
00:26:02,386 --> 0:26:04,186
time to take the game to the

985
00:26:04,186 --> 0:26:04,786
next level.

986
00:26:05,316 --> 0:26:06,326
What's something easy we can

987
00:26:06,326 --> 0:26:06,506
add?

988
00:26:11,086 --> 0:26:12,436
Just add multiplayer right?

989
00:26:15,636 --> 0:26:17,706
AR games are fun and playing

990
00:26:17,706 --> 0:26:18,896
with friends makes them even

991
00:26:18,896 --> 0:26:19,286
more fun.

992
00:26:20,666 --> 0:26:21,986
Multiplayer can turn a simple

993
00:26:21,986 --> 0:26:23,386
card matching game into a real

994
00:26:23,386 --> 0:26:25,766
competition, however making a

995
00:26:25,766 --> 0:26:27,576
multiplayer AR game comes with a

996
00:26:27,576 --> 0:26:28,986
few additional challenges that

997
00:26:28,986 --> 0:26:30,476
we don't encounter with non-AR

998
00:26:30,476 --> 0:26:30,886
games.

999
00:26:32,076 --> 0:26:33,356
When they place virtual objects

1000
00:26:33,356 --> 0:26:35,056
in the real world, we want them

1001
00:26:35,056 --> 0:26:36,516
to be in the same location for

1002
00:26:36,516 --> 0:26:37,316
everyone playing the game.

1003
00:26:37,316 --> 0:26:39,966
And because everyone is in the

1004
00:26:39,966 --> 0:26:41,496
same place, we want updates

1005
00:26:41,536 --> 0:26:43,286
between devices to be fast, to

1006
00:26:43,286 --> 0:26:44,856
maintain the shared illusion of

1007
00:26:44,856 --> 0:26:45,236
reality.

1008
00:26:46,376 --> 0:26:47,506
To enable this we built

1009
00:26:47,506 --> 0:26:49,276
RealityKit from the ground up to

1010
00:26:49,276 --> 0:26:50,446
support multiplayer AR.

1011
00:26:51,386 --> 0:26:52,226
Combined with ARKit's

1012
00:26:52,226 --> 0:26:53,826
Collaborative Session, also

1013
00:26:53,826 --> 0:26:55,576
introduced this year, this gives

1014
00:26:55,576 --> 0:26:57,146
you the tools you need to add

1015
00:26:57,146 --> 0:26:59,036
multi users support to your AR

1016
00:26:59,036 --> 0:26:59,506
experiences.

1017
00:27:00,916 --> 0:27:02,146
So let's take a look at what

1018
00:27:02,146 --> 0:27:04,816
multiplayer means for our game.

1019
00:27:04,956 --> 0:27:05,976
Both players will play

1020
00:27:05,976 --> 0:27:07,986
simultaneously and can turn over

1021
00:27:07,986 --> 0:27:09,156
cards at any time.

1022
00:27:10,486 --> 0:27:11,596
Everyone can see the reveal of

1023
00:27:11,596 --> 0:27:11,986
cards.

1024
00:27:12,146 --> 0:27:13,896
So you can gain an advantage if

1025
00:27:13,896 --> 0:27:15,096
you're paying attention to what

1026
00:27:15,096 --> 0:27:16,346
the other player is doing.

1027
00:27:16,346 --> 0:27:18,726
We'll also add a small white

1028
00:27:18,726 --> 0:27:20,366
circle to indicate to the player

1029
00:27:20,636 --> 0:27:21,976
which card they turned over.

1030
00:27:25,176 --> 0:27:26,616
Let's take a look at multiplayer

1031
00:27:26,816 --> 0:27:27,456
in RealityKit.

1032
00:27:28,236 --> 0:27:29,786
RealityKit provides automatic

1033
00:27:29,916 --> 0:27:30,836
scene synchronization.

1034
00:27:31,676 --> 0:27:33,276
Changes made automatically

1035
00:27:33,276 --> 0:27:35,206
update on all devices.

1036
00:27:36,576 --> 0:27:38,136
Leverages, device discovery, and

1037
00:27:38,136 --> 0:27:39,346
connection for multi peer

1038
00:27:39,346 --> 0:27:39,836
connectivity.

1039
00:27:40,856 --> 0:27:42,316
This makes it simple to find and

1040
00:27:42,316 --> 0:27:43,406
connect to nearby devices

1041
00:27:44,096 --> 0:27:45,756
without maintaining servers or

1042
00:27:45,756 --> 0:27:46,846
even connecting to the same

1043
00:27:46,846 --> 0:27:47,476
Wi-Fi network.

1044
00:27:48,016 --> 0:27:49,966
It provides an easy to use

1045
00:27:49,966 --> 0:27:51,406
ownership model allowing you to

1046
00:27:51,406 --> 0:27:52,826
control which peers are allowed

1047
00:27:52,826 --> 0:27:54,376
to change which entities.

1048
00:27:55,006 --> 0:27:57,986
And provides low latency even on

1049
00:27:57,986 --> 0:27:59,466
busy Wi-Fi networks, which is

1050
00:27:59,466 --> 0:28:00,956
essential for convincing AR

1051
00:27:59,466 --> 0:28:00,956
essential for convincing AR

1052
00:28:00,956 --> 0:28:01,496
experiences.

1053
00:28:04,256 --> 0:28:05,826
Let's go through the steps for

1054
00:28:05,826 --> 0:28:07,246
adopting multiplayer for our

1055
00:28:07,246 --> 0:28:07,356
game.

1056
00:28:08,386 --> 0:28:09,786
First we need to designate a

1057
00:28:09,786 --> 0:28:10,156
host.

1058
00:28:10,526 --> 0:28:11,406
We'll place the game board.

1059
00:28:12,696 --> 0:28:13,826
We'll ask the user to select

1060
00:28:13,826 --> 0:28:15,756
this at the game's main menu.

1061
00:28:16,686 --> 0:28:18,486
Then we connect the sessions so

1062
00:28:18,486 --> 0:28:20,116
that they can communicate with

1063
00:28:20,116 --> 0:28:20,426
each other.

1064
00:28:21,686 --> 0:28:23,776
We'll also enable ARkit's

1065
00:28:23,776 --> 0:28:25,326
Collaborative Session, which

1066
00:28:25,326 --> 0:28:26,386
enables our peers to create a

1067
00:28:26,386 --> 0:28:27,726
shared map of the environment.

1068
00:28:28,826 --> 0:28:30,136
And we'll create a synchronized

1069
00:28:30,136 --> 0:28:31,966
anchor, which attaches our game

1070
00:28:31,966 --> 0:28:33,786
board to a specific world

1071
00:28:33,786 --> 0:28:35,566
location and coordinated between

1072
00:28:35,566 --> 0:28:35,956
peers.

1073
00:28:36,786 --> 0:28:38,476
And last, we use ownership to

1074
00:28:38,476 --> 0:28:39,676
make changes to the game board

1075
00:28:40,076 --> 0:28:41,366
such as flipping over the cards

1076
00:28:41,656 --> 0:28:42,316
and removing them.

1077
00:28:43,126 --> 0:28:45,166
We've asked the user to choose

1078
00:28:45,166 --> 0:28:46,356
"host" or "join" from the main

1079
00:28:46,356 --> 0:28:46,676
menu.

1080
00:28:47,406 --> 0:28:48,586
Now we need to establish a

1081
00:28:48,586 --> 0:28:49,056
connection.

1082
00:28:50,286 --> 0:28:51,506
We use the multi peer

1083
00:28:51,506 --> 0:28:53,936
connectivity framework to get

1084
00:28:53,936 --> 0:28:54,396
connected.

1085
00:28:54,396 --> 0:28:56,356
We won't go into all of the

1086
00:28:56,356 --> 0:28:57,416
detail of multi peer

1087
00:28:57,416 --> 0:28:58,946
connectivity here, but if you

1088
00:28:58,946 --> 0:28:59,996
want to know more check out the

1089
00:28:59,996 --> 0:29:02,246
2014 session, Cross Platform

1090
00:28:59,996 --> 0:29:02,246
2014 session, Cross Platform

1091
00:29:02,306 --> 0:29:03,006
Nearby Networking.

1092
00:29:04,186 --> 0:29:06,466
First create an MCPeerID and

1093
00:29:06,466 --> 0:29:06,876
MCSession.

1094
00:29:07,976 --> 0:29:09,426
Be sure to enable encryption as

1095
00:29:09,426 --> 0:29:10,556
it's required for use with

1096
00:29:10,556 --> 0:29:11,116
RealityKit.

1097
00:29:14,036 --> 0:29:14,966
We'll check the user's role

1098
00:29:14,966 --> 0:29:15,696
before proceeding.

1099
00:29:16,426 --> 0:29:17,586
If they choose host we'll

1100
00:29:17,586 --> 0:29:19,266
advertise the session using

1101
00:29:19,316 --> 0:29:21,166
MCNearbyServiceAdvertiser.

1102
00:29:21,906 --> 0:29:23,046
This broadcast that we have an

1103
00:29:23,046 --> 0:29:23,766
available session.

1104
00:29:24,416 --> 0:29:26,316
The client creates an

1105
00:29:26,396 --> 0:29:28,366
MCNearbyServiceBrowser to start

1106
00:29:28,366 --> 0:29:29,066
looking for sessions.

1107
00:29:29,936 --> 0:29:30,786
And now that we have an

1108
00:29:30,836 --> 0:29:32,796
MCSession we need to instruct

1109
00:29:32,796 --> 0:29:33,836
RealityKit to use it for

1110
00:29:33,836 --> 0:29:34,586
synchronization.

1111
00:29:35,406 --> 0:29:36,766
We do this by creating a multi

1112
00:29:36,806 --> 0:29:38,706
peer connectivity service, which

1113
00:29:38,706 --> 0:29:40,496
is a RealityKit class that wraps

1114
00:29:40,546 --> 0:29:42,126
the MCSession and makes it

1115
00:29:42,126 --> 0:29:43,086
usable for scene

1116
00:29:43,086 --> 0:29:43,726
synchronization.

1117
00:29:44,626 --> 0:29:45,966
We'll create this and assign it

1118
00:29:45,966 --> 0:29:47,316
to the synchronization service

1119
00:29:47,416 --> 0:29:50,136
property on the scene.

1120
00:29:50,316 --> 0:29:51,246
Now we have two devices

1121
00:29:51,246 --> 0:29:52,566
connected and synching their

1122
00:29:52,566 --> 0:29:52,836
scene.

1123
00:29:53,786 --> 0:29:55,246
However, they don't yet know

1124
00:29:55,246 --> 0:29:56,426
where they are in the physical

1125
00:29:56,426 --> 0:29:57,896
world relative to each other.

1126
00:29:59,076 --> 0:30:00,056
Let's take advantage of the

1127
00:29:59,076 --> 0:30:00,056
Let's take advantage of the

1128
00:30:00,056 --> 0:30:01,466
collaborative session introduced

1129
00:30:01,466 --> 0:30:03,226
in ARKit 3, which is natively

1130
00:30:03,226 --> 0:30:03,976
supported by RealityKit.

1131
00:30:05,486 --> 0:30:06,786
Collaborative session lets us

1132
00:30:06,786 --> 0:30:07,966
build the world more quickly and

1133
00:30:08,266 --> 0:30:09,776
lets multiple users share the

1134
00:30:09,776 --> 0:30:10,956
same in world experience.

1135
00:30:10,956 --> 0:30:13,646
Since we want collaborative

1136
00:30:13,646 --> 0:30:15,006
mapping we need to turn it on.

1137
00:30:15,646 --> 0:30:16,656
We'll do this at the end of

1138
00:30:16,656 --> 0:30:17,236
viewDidLoad.

1139
00:30:18,226 --> 0:30:19,976
We create a new world tracking

1140
00:30:19,976 --> 0:30:20,756
configuration.

1141
00:30:21,876 --> 0:30:24,016
Set is collaboration enabled to

1142
00:30:25,066 --> 0:30:27,166
true, instruct AR Session to run

1143
00:30:27,166 --> 0:30:27,916
our configuration.

1144
00:30:29,176 --> 0:30:30,736
Now that we have collaborative

1145
00:30:30,736 --> 0:30:32,346
session enabled we can create a

1146
00:30:32,346 --> 0:30:33,856
synchronized anchor.

1147
00:30:34,616 --> 0:30:36,436
Previously we created an anchor

1148
00:30:36,436 --> 0:30:38,266
entity requesting any horizontal

1149
00:30:38,266 --> 0:30:39,536
plane that's at least 20

1150
00:30:39,536 --> 0:30:40,536
centimeters on a side.

1151
00:30:41,386 --> 0:30:42,556
With multiple players we want to

1152
00:30:42,556 --> 0:30:43,586
make sure the board is in a good

1153
00:30:43,626 --> 0:30:44,876
place for two players to walk

1154
00:30:44,876 --> 0:30:45,206
around.

1155
00:30:45,676 --> 0:30:46,996
To ensure this we'll ask the

1156
00:30:46,996 --> 0:30:47,886
host to place the board.

1157
00:30:48,676 --> 0:30:49,926
And since we want the same world

1158
00:30:49,926 --> 0:30:51,636
position on both peers, we'll

1159
00:30:51,636 --> 0:30:53,086
ask ARkit to synchronize this

1160
00:30:53,086 --> 0:30:53,376
anchor.

1161
00:30:54,396 --> 0:30:54,976
How do we do this?

1162
00:30:58,416 --> 0:31:00,516
On the host, we'll use the same

1163
00:30:58,416 --> 0:31:00,516
On the host, we'll use the same

1164
00:31:00,516 --> 0:31:02,066
onTap handler as before.

1165
00:31:03,106 --> 0:31:04,186
We want to pick a spot that's

1166
00:31:04,186 --> 0:31:04,816
good for everybody.

1167
00:31:05,076 --> 0:31:06,486
So we'll raycast into the real

1168
00:31:06,526 --> 0:31:06,736
world.

1169
00:31:07,926 --> 0:31:09,416
This is similar to the hit test

1170
00:31:09,416 --> 0:31:11,296
Ross showed us earlier, however

1171
00:31:11,496 --> 0:31:12,546
this one is run against an

1172
00:31:12,546 --> 0:31:14,006
estimation of the real world

1173
00:31:14,456 --> 0:31:15,696
rather than virtual objects.

1174
00:31:16,236 --> 0:31:17,926
Our game board needs to go on a

1175
00:31:17,926 --> 0:31:19,726
flat surface, so we're asking

1176
00:31:19,726 --> 0:31:20,916
for a horizontal plane.

1177
00:31:21,576 --> 0:31:24,226
If it finds a horizontal plane

1178
00:31:24,696 --> 0:31:25,976
we'll take the world transform

1179
00:31:25,976 --> 0:31:27,176
and use it to create an AR

1180
00:31:27,176 --> 0:31:27,516
anchor.

1181
00:31:28,206 --> 0:31:30,146
This is an ARkit anchor, which

1182
00:31:30,146 --> 0:31:31,296
we add to the AR session

1183
00:31:31,436 --> 0:31:32,286
provided by the view.

1184
00:31:33,126 --> 0:31:34,516
And this creates a synchronized

1185
00:31:34,516 --> 0:31:36,796
anchor whose real world position

1186
00:31:36,796 --> 0:31:38,266
will be coordinated by ARkit.

1187
00:31:39,696 --> 0:31:41,416
Using that AR anchor we'll

1188
00:31:41,416 --> 0:31:42,356
create a RealityKit anchor

1189
00:31:42,356 --> 0:31:42,736
entity.

1190
00:31:43,426 --> 0:31:44,936
This is our bridge between ARkit

1191
00:31:45,106 --> 0:31:47,026
and RealityKit and allows us to

1192
00:31:47,026 --> 0:31:47,706
attach our card.

1193
00:31:47,706 --> 0:31:50,086
And then we have the game board,

1194
00:31:50,236 --> 0:31:51,276
as Ross showed us earlier.

1195
00:31:52,326 --> 0:31:53,506
Only the host needs to build the

1196
00:31:53,506 --> 0:31:54,326
randomized board.

1197
00:31:55,146 --> 0:31:56,116
Everyone else receives it

1198
00:31:56,116 --> 0:31:57,606
automatically via network

1199
00:31:57,606 --> 0:31:58,266
synchronization.

1200
00:31:59,526 --> 0:32:00,636
The models we loaded aren't

1201
00:31:59,526 --> 0:32:00,636
The models we loaded aren't

1202
00:32:00,636 --> 0:32:01,716
synchronized as part of the

1203
00:32:01,716 --> 0:32:02,996
scene because that would be

1204
00:32:02,996 --> 0:32:03,506
loads of data.

1205
00:32:04,446 --> 0:32:05,666
Remember when Ross showed us how

1206
00:32:05,666 --> 0:32:07,286
to load the card templates?

1207
00:32:07,606 --> 0:32:08,696
Make sure we still do this on

1208
00:32:08,696 --> 0:32:09,296
all appearance.

1209
00:32:10,046 --> 0:32:11,166
And that's enough to get our

1210
00:32:11,166 --> 0:32:12,396
game running.

1211
00:32:15,206 --> 0:32:16,676
On the left we can see that the

1212
00:32:16,676 --> 0:32:17,766
host has placed the board and

1213
00:32:18,056 --> 0:32:18,986
the client can see it.

1214
00:32:19,476 --> 0:32:20,676
It's in the same real world

1215
00:32:20,676 --> 0:32:21,106
location.

1216
00:32:22,076 --> 0:32:23,386
Watch as the host flips over one

1217
00:32:23,386 --> 0:32:24,846
of the objects and then another.

1218
00:32:25,456 --> 0:32:26,536
OK, not a match.

1219
00:32:27,206 --> 0:32:28,226
Notice how it's automatically

1220
00:32:28,226 --> 0:32:29,656
reflected on the client and how

1221
00:32:29,656 --> 0:32:30,856
smooth the animation is.

1222
00:32:31,526 --> 0:32:32,366
No network program here

1223
00:32:32,366 --> 0:32:32,796
required.

1224
00:32:33,776 --> 0:32:34,766
Now watch as the client flips

1225
00:32:34,766 --> 0:32:35,836
over one of the cards.

1226
00:32:36,396 --> 0:32:38,626
it flips over in their screen

1227
00:32:39,076 --> 0:32:40,266
but not on the hosts.

1228
00:32:40,776 --> 0:32:41,926
To explain what's happening I

1229
00:32:41,926 --> 0:32:43,066
need to introduce you to

1230
00:32:43,066 --> 0:32:43,476
ownership.

1231
00:32:44,046 --> 0:32:45,696
What is ownership?

1232
00:32:46,596 --> 0:32:47,976
It's the right to modify an

1233
00:32:47,976 --> 0:32:48,386
entity.

1234
00:32:49,636 --> 0:32:51,496
In a shared session an entity

1235
00:32:51,496 --> 0:32:53,536
has one owner at a time, which

1236
00:32:53,536 --> 0:32:54,816
defaults to whomever created the

1237
00:32:54,816 --> 0:32:55,256
entity.

1238
00:32:56,056 --> 0:32:58,246
In our case that's the host.

1239
00:33:00,226 --> 0:33:02,276
Ownership is transferable, which

1240
00:33:02,276 --> 0:33:03,086
is how you can allow other

1241
00:33:03,176 --> 0:33:04,216
players to make changes.

1242
00:33:05,006 --> 0:33:06,266
And ownership transfer is

1243
00:33:06,266 --> 0:33:08,486
configurable so you can decide

1244
00:33:08,486 --> 0:33:09,196
which entities can be

1245
00:33:09,196 --> 0:33:10,836
transferred and at what times.

1246
00:33:11,926 --> 0:33:13,416
To illustrate ownership let's

1247
00:33:13,416 --> 0:33:14,486
look at what's happening in our

1248
00:33:14,486 --> 0:33:14,686
game.

1249
00:33:17,006 --> 0:33:18,096
The host creates the cards,

1250
00:33:18,546 --> 0:33:19,546
which means it owns them.

1251
00:33:20,126 --> 0:33:22,106
And the cards automatically show

1252
00:33:22,106 --> 0:33:22,866
up on the client.

1253
00:33:23,426 --> 0:33:25,506
When the owner of an entity

1254
00:33:25,506 --> 0:33:27,146
makes the change, such as

1255
00:33:27,146 --> 0:33:29,306
flipping it over, this change is

1256
00:33:29,306 --> 0:33:30,786
sent to the client and reflected

1257
00:33:30,786 --> 0:33:31,316
in their scene.

1258
00:33:32,486 --> 0:33:33,666
Since RealityKit has been built

1259
00:33:33,666 --> 0:33:34,696
from the ground up for

1260
00:33:34,696 --> 0:33:36,036
multiplayer, we're only

1261
00:33:36,106 --> 0:33:37,326
synchronizing the instruction to

1262
00:33:37,326 --> 0:33:38,736
animate, rather than to

1263
00:33:38,736 --> 0:33:39,906
transform every frame.

1264
00:33:40,506 --> 0:33:41,876
This is why it looks so smooth

1265
00:33:41,876 --> 0:33:42,406
on the client.

1266
00:33:43,126 --> 0:33:45,156
Now the client flips over our

1267
00:33:45,156 --> 0:33:45,476
card.

1268
00:33:46,506 --> 0:33:47,756
Since the client does not own

1269
00:33:47,756 --> 0:33:49,756
the entity, the change will not

1270
00:33:49,756 --> 0:33:50,466
get sent to peers.

1271
00:33:51,616 --> 0:33:52,596
While it's still allowed to make

1272
00:33:52,626 --> 0:33:53,956
the changes locally, they're

1273
00:33:53,956 --> 0:33:55,696
likely to get overwritten the

1274
00:33:55,696 --> 0:33:56,706
next time the owner sends an

1275
00:33:56,706 --> 0:33:57,076
update.

1276
00:33:58,096 --> 0:33:59,456
This presents a dilemma because

1277
00:33:59,456 --> 0:34:00,586
we do want to make changes to

1278
00:33:59,456 --> 0:34:00,586
we do want to make changes to

1279
00:34:00,586 --> 0:34:00,956
the card.

1280
00:34:01,696 --> 0:34:03,036
So let's go back a step before

1281
00:34:03,036 --> 0:34:04,406
the client had turned over the

1282
00:34:04,406 --> 0:34:04,746
robot.

1283
00:34:05,956 --> 0:34:06,796
So I mentioned earlier,

1284
00:34:07,716 --> 0:34:08,766
ownership can be transferred.

1285
00:34:09,476 --> 0:34:11,315
Any peer can request ownership

1286
00:34:11,315 --> 0:34:11,896
of an entity.

1287
00:34:12,726 --> 0:34:13,815
Let's have the client request

1288
00:34:13,815 --> 0:34:15,275
ownership of a yellow robot

1289
00:34:15,626 --> 0:34:16,806
before making its changes.

1290
00:34:18,106 --> 0:34:19,456
It sends a request to the host

1291
00:34:19,806 --> 0:34:20,726
asking for ownership.

1292
00:34:21,826 --> 0:34:23,036
The entities owner decides

1293
00:34:23,036 --> 0:34:24,166
whether to allow the transfer.

1294
00:34:24,755 --> 0:34:26,076
It may decline if a different

1295
00:34:26,076 --> 0:34:28,186
peer requested ownership or if

1296
00:34:28,186 --> 0:34:29,446
the object's transfer mode was

1297
00:34:29,446 --> 0:34:29,826
changed.

1298
00:34:30,835 --> 0:34:32,565
Since from the default state the

1299
00:34:32,565 --> 0:34:34,496
host accepts the request and

1300
00:34:34,496 --> 0:34:35,846
ownership is transferred to the

1301
00:34:35,846 --> 0:34:36,176
client.

1302
00:34:37,286 --> 0:34:38,856
The client is now free to make

1303
00:34:38,856 --> 0:34:39,726
changes to the card.

1304
00:34:40,505 --> 0:34:42,136
We can reveal the card and the

1305
00:34:42,136 --> 0:34:43,766
changes will be reflected on the

1306
00:34:43,766 --> 0:34:44,186
host.

1307
00:34:45,206 --> 0:34:46,446
And we've made this simple to

1308
00:34:46,446 --> 0:34:46,716
use.

1309
00:34:47,255 --> 0:34:50,306
The client starts by requesting

1310
00:34:50,306 --> 0:34:51,496
ownership of the entity.

1311
00:34:52,485 --> 0:34:53,766
If we all ready own the object

1312
00:34:54,076 --> 0:34:54,516
that's fine.

1313
00:34:55,176 --> 0:34:56,246
The request will be granted

1314
00:34:56,246 --> 0:34:57,586
without doing any additional

1315
00:34:58,166 --> 0:34:58,266
work.

1316
00:34:59,236 --> 0:35:00,106
When the ownership request

1317
00:34:59,236 --> 0:35:00,106
When the ownership request

1318
00:35:00,106 --> 0:35:01,586
returns we'll be informed

1319
00:35:01,586 --> 0:35:02,926
whether the ownership was

1320
00:35:02,926 --> 0:35:03,266
granted.

1321
00:35:04,046 --> 0:35:05,846
If it was, we'll call reveal on

1322
00:35:05,846 --> 0:35:06,966
the card to flip it over.

1323
00:35:07,996 --> 0:35:09,156
However, if the request was

1324
00:35:09,196 --> 0:35:10,676
denied, for example someone else

1325
00:35:10,676 --> 0:35:12,166
turned it over, we'll give the

1326
00:35:12,166 --> 0:35:13,646
user the opportunity to select a

1327
00:35:13,646 --> 0:35:14,176
different card.

1328
00:35:15,246 --> 0:35:16,246
And that's all we need to flip

1329
00:35:16,246 --> 0:35:17,746
over the card and see it on both

1330
00:35:17,746 --> 0:35:18,096
peers.

1331
00:35:18,676 --> 0:35:19,706
But we want to go one step

1332
00:35:19,766 --> 0:35:20,006
further.

1333
00:35:21,006 --> 0:35:22,466
While the card is revealed, we

1334
00:35:22,466 --> 0:35:24,236
want to keep ownership of it.

1335
00:35:24,966 --> 0:35:26,666
We want to deny any requests to

1336
00:35:26,666 --> 0:35:28,196
take ownership while we have it

1337
00:35:28,196 --> 0:35:28,606
revealed.

1338
00:35:29,576 --> 0:35:30,776
We'll go back to our reveal

1339
00:35:30,776 --> 0:35:30,956
method.

1340
00:35:33,066 --> 0:35:34,656
Here's where we previously set

1341
00:35:34,826 --> 0:35:36,116
the revealed property to true.

1342
00:35:37,166 --> 0:35:38,436
Because we adopted the codable

1343
00:35:38,436 --> 0:35:40,856
protocol on card component, this

1344
00:35:40,926 --> 0:35:42,286
automatically updates on other

1345
00:35:42,286 --> 0:35:42,686
peers.

1346
00:35:42,936 --> 0:35:43,896
There's nothing else to do.

1347
00:35:44,546 --> 0:35:46,726
And after we change the cards

1348
00:35:46,726 --> 0:35:48,916
revealed property to true, set

1349
00:35:48,916 --> 0:35:49,996
the ownership transfer mode to

1350
00:35:49,996 --> 0:35:50,316
manual.

1351
00:35:51,036 --> 0:35:52,936
This automatically denies any

1352
00:35:52,936 --> 0:35:56,226
requests to transfer the entity.

1353
00:35:56,486 --> 0:35:57,756
When we flip the object back to

1354
00:35:57,756 --> 0:35:59,096
hidden we'll want to start

1355
00:35:59,096 --> 0:36:00,286
accepting requests for

1356
00:35:59,096 --> 0:36:00,286
accepting requests for

1357
00:36:00,286 --> 0:36:00,656
ownership.

1358
00:36:02,036 --> 0:36:03,046
This is what the hide method

1359
00:36:03,046 --> 0:36:03,566
might look like.

1360
00:36:04,856 --> 0:36:05,846
After changing revealed to

1361
00:36:05,896 --> 0:36:07,776
false, we changed the ownership

1362
00:36:07,776 --> 0:36:09,476
transfer mode to auto accept.

1363
00:36:10,286 --> 0:36:11,776
This will instruct RealityKit to

1364
00:36:11,776 --> 0:36:13,126
accept transfer requests for

1365
00:36:13,126 --> 0:36:14,806
this entity automatically.

1366
00:36:16,096 --> 0:36:17,056
One thing that's worth pointing

1367
00:36:17,056 --> 0:36:19,166
out -- the host isn't special

1368
00:36:19,296 --> 0:36:20,196
when it comes to ownership

1369
00:36:21,036 --> 0:36:22,786
because it placed the board, it

1370
00:36:22,926 --> 0:36:24,506
initially owned all the cards,

1371
00:36:25,096 --> 0:36:26,756
but otherwise behaves like any

1372
00:36:26,756 --> 0:36:28,086
other peer.

1373
00:36:28,406 --> 0:36:29,676
Once an object is transferred,

1374
00:36:29,886 --> 0:36:30,946
if the host wants to turn it

1375
00:36:30,946 --> 0:36:32,836
over it needs to request it too.

1376
00:36:34,006 --> 0:36:34,756
You can use the ownership

1377
00:36:34,756 --> 0:36:36,046
transfer mode to change this

1378
00:36:36,046 --> 0:36:37,306
behavior to suit your app.

1379
00:36:38,336 --> 0:36:39,636
And there's one last detail for

1380
00:36:40,336 --> 0:36:41,136
our app.

1381
00:36:41,396 --> 0:36:42,326
When you play with two or more

1382
00:36:42,326 --> 0:36:43,596
players you'll notice that the

1383
00:36:43,596 --> 0:36:44,406
board can get a little

1384
00:36:44,406 --> 0:36:44,976
confusing.

1385
00:36:45,516 --> 0:36:47,096
It could be hard to know what

1386
00:36:47,096 --> 0:36:48,296
piece you've selected and which

1387
00:36:48,296 --> 0:36:49,586
ones were selected by others.

1388
00:36:50,246 --> 0:36:51,636
We'd like to add a transparent

1389
00:36:51,636 --> 0:36:53,026
disk to display our selection.

1390
00:36:53,936 --> 0:36:55,946
As we've seen, everything gets

1391
00:36:55,946 --> 0:36:56,296
shared.

1392
00:36:56,596 --> 0:36:57,846
So that will show for everyone

1393
00:36:57,846 --> 0:36:59,076
and defeat its purpose.

1394
00:37:00,426 --> 0:37:02,256
Fortunately, RealityKit supports

1395
00:37:02,256 --> 0:37:03,366
local-only entities.

1396
00:37:04,206 --> 0:37:05,636
This is ideal for displaying

1397
00:37:05,636 --> 0:37:07,086
selection indicators or hidden

1398
00:37:07,086 --> 0:37:08,576
information like your hand in

1399
00:37:08,576 --> 0:37:08,916
poker.

1400
00:37:09,876 --> 0:37:11,226
And we do this by removing the

1401
00:37:11,226 --> 0:37:12,926
synchronization component and

1402
00:37:12,926 --> 0:37:14,566
otherwise handling the entity

1403
00:37:14,566 --> 0:37:15,266
like any other.

1404
00:37:15,896 --> 0:37:19,166
If the entity has children, they

1405
00:37:19,166 --> 0:37:20,286
will be unshared as well.

1406
00:37:20,776 --> 0:37:21,866
This can be useful to make an

1407
00:37:21,866 --> 0:37:23,716
entire tree of entities local

1408
00:37:23,716 --> 0:37:23,996
only.

1409
00:37:25,316 --> 0:37:26,936
While I'm not showing it here,

1410
00:37:26,936 --> 0:37:28,346
I've created a selection entity

1411
00:37:28,346 --> 0:37:29,526
class that represents our

1412
00:37:29,526 --> 0:37:30,036
selection.

1413
00:37:30,736 --> 0:37:32,186
It's initializer adds a white

1414
00:37:32,466 --> 0:37:33,746
slightly transparent disk.

1415
00:37:35,046 --> 0:37:35,986
Let's take a look at adding it

1416
00:37:35,986 --> 0:37:37,356
to our reveal method from

1417
00:37:37,356 --> 0:37:37,536
earlier.

1418
00:37:38,176 --> 0:37:40,606
We create the entity and

1419
00:37:40,606 --> 0:37:41,996
position it slightly above the

1420
00:37:41,996 --> 0:37:42,316
card.

1421
00:37:43,516 --> 0:37:45,166
Then we assign nil to the

1422
00:37:45,166 --> 0:37:46,196
synchronization component.

1423
00:37:46,866 --> 0:37:48,176
This instructs RealityKit that

1424
00:37:48,176 --> 0:37:49,046
we do not want to share this

1425
00:37:49,046 --> 0:37:49,466
entity.

1426
00:37:50,226 --> 0:37:51,756
And we add the child normally to

1427
00:37:52,196 --> 0:37:53,106
enter the hierarchy.

1428
00:37:54,206 --> 0:37:55,416
Now that we've added it in

1429
00:37:55,416 --> 0:37:56,946
reveal, we need to remove it

1430
00:37:57,016 --> 0:37:57,806
when we hide the card.

1431
00:37:58,336 --> 0:38:00,686
Here's the hide method from

1432
00:37:58,336 --> 0:38:00,686
Here's the hide method from

1433
00:38:01,356 --> 0:38:01,506
earlier.

1434
00:38:02,766 --> 0:38:04,026
After changing other properties,

1435
00:38:04,316 --> 0:38:05,486
we'll iterate over the children

1436
00:38:05,746 --> 0:38:06,416
with the for loop.

1437
00:38:07,256 --> 0:38:08,796
We can use the where clause to

1438
00:38:08,796 --> 0:38:10,086
look for entities of type

1439
00:38:10,186 --> 0:38:11,026
selection entity.

1440
00:38:12,206 --> 0:38:14,016
Once we find it we'll remove it

1441
00:38:14,016 --> 0:38:14,556
from its parent.

1442
00:38:15,416 --> 0:38:16,336
Since we know there can only be

1443
00:38:16,336 --> 0:38:17,896
one selection entity, we'll

1444
00:38:17,896 --> 0:38:18,606
break out of the loop.

1445
00:38:19,096 --> 0:38:21,126
And that's it.

1446
00:38:21,456 --> 0:38:22,266
We're handling ownership

1447
00:38:22,266 --> 0:38:23,926
correctly and adding or removing

1448
00:38:23,926 --> 0:38:25,656
a local entity for selection.

1449
00:38:25,966 --> 0:38:27,886
Our game now works correctly

1450
00:38:27,886 --> 0:38:28,816
across two devices.

1451
00:38:29,706 --> 0:38:30,966
And while we've demonstrated

1452
00:38:30,966 --> 0:38:31,846
using two devices for

1453
00:38:31,846 --> 0:38:33,446
simplicity, we can actually

1454
00:38:33,446 --> 0:38:35,676
support more devices without any

1455
00:38:35,676 --> 0:38:36,906
additional code.

1456
00:38:42,906 --> 0:38:43,996
Let's look back at what we've

1457
00:38:44,036 --> 0:38:44,316
learned.

1458
00:38:44,876 --> 0:38:46,236
Today we've shown you how

1459
00:38:46,236 --> 0:38:47,696
RealityKit makes building AR

1460
00:38:47,696 --> 0:38:49,236
Apps easy and fast.

1461
00:38:50,486 --> 0:38:51,506
We've covered how to place

1462
00:38:51,506 --> 0:38:53,656
content with anchoring, load

1463
00:38:53,656 --> 0:38:55,246
assets both synchronous and

1464
00:38:55,246 --> 0:38:57,446
asynchronously, integrate

1465
00:38:57,446 --> 0:38:59,176
interaction in hit testing,

1466
00:39:00,266 --> 0:39:01,346
create custom components in

1467
00:39:01,346 --> 0:39:03,196
entities, and how to add

1468
00:39:03,196 --> 0:39:04,916
multiplayer to augmented reality

1469
00:39:04,916 --> 0:39:05,506
experiences.

1470
00:39:06,506 --> 0:39:07,506
I hope that we've given you a

1471
00:39:07,506 --> 0:39:08,746
better understanding of what

1472
00:39:08,746 --> 0:39:10,236
RealityKit is and what it

1473
00:39:10,236 --> 0:39:10,626
provides.

1474
00:39:11,386 --> 0:39:12,846
We can't wait to see what you do

1475
00:39:12,846 --> 0:39:13,806
with it.

1476
00:39:14,616 --> 0:39:16,246
For more information and access

1477
00:39:16,296 --> 0:39:18,036
to this session video check out

1478
00:39:18,036 --> 0:39:18,966
this session webpage.

1479
00:39:19,916 --> 0:39:21,076
Also check out Introducing

1480
00:39:21,076 --> 0:39:22,686
RealityKit and Reality Composer

1481
00:39:22,956 --> 0:39:23,786
for more information on

1482
00:39:23,786 --> 0:39:25,526
RealityKit and don't miss

1483
00:39:25,526 --> 0:39:27,506
Introducing ARkit 3 to learn

1484
00:39:27,506 --> 0:39:28,816
more about collaborative session

1485
00:39:29,146 --> 0:39:30,116
and other new features.

1486
00:39:31,326 --> 0:39:32,276
And be sure to catch us in the

1487
00:39:32,276 --> 0:39:34,886
labs today at noon and tomorrow

1488
00:39:34,886 --> 0:39:35,506
at 3:00 PM.

1489
00:39:36,966 --> 0:39:38,266
Thanks everyone and please enjoy

1490
00:39:38,266 --> 0:39:38,976
the rest of the conference.

1491
00:39:39,516 --> 0:39:42,500
[ Applause ]
