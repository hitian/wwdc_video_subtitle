1
00:00:00,506 --> 0:00:08,516
[音乐]

2
00:00:09,516 --> 0:00:13,946
[掌声]

3
00:00:14,446 --> 0:00:14,886
&gt;&gt; 欢迎大家

4
00:00:15,346 --> 0:00:16,346
我的名字叫 Steve Breen

5
00:00:16,346 --> 0:00:17,856
我是 UIKit 团队的工程师

6
00:00:18,446 --> 0:00:19,436
今天和我一起的

7
00:00:19,436 --> 0:00:20,966
还有我的同事们 

8
00:00:20,966 --> 0:00:22,596
来自 AppKit 团队的 Troy Stephens

9
00:00:22,596 --> 0:00:24,716
还有来自 App Store 团队的 Abolfathi

10
00:00:26,436 --> 0:00:27,436
今天我们将谈一谈

11
00:00:27,436 --> 0:00:29,006
关于 CollectionView 布局的一些

12
00:00:29,006 --> 0:00:30,646
改进与发展

13
00:00:30,846 --> 0:00:31,486
下面我们的发言

14
00:00:31,486 --> 0:00:33,536
将分成四大部分

15
00:00:33,536 --> 0:00:34,376
首先 我们将回顾目前

16
00:00:34,376 --> 0:00:35,316
这项技术的发展状况

17
00:00:35,316 --> 0:00:35,966
也就是现在我们是怎么做的

18
00:00:35,966 --> 0:00:38,076
我们如何定义 App 中的

19
00:00:38,076 --> 0:00:39,456
CollectionView 布局

20
00:00:40,436 --> 0:00:41,326
之后 我们会介绍一种

21
00:00:41,426 --> 0:00:43,216
全新的方法

22
00:00:43,216 --> 0:00:44,406
今年会将它应用到所有平台上

23
00:00:44,406 --> 0:00:46,256
包括 iOS 和 tvOS 以及 Mac

24
00:00:46,896 --> 0:00:48,326
接着 我们将进行一些

25
00:00:48,326 --> 0:00:49,956
实际操作的演示

26
00:00:49,956 --> 0:00:51,556
这样就能看到运行中的 API 了

27
00:00:52,276 --> 0:00:53,526
最后 我们将为大家展示

28
00:00:53,526 --> 0:00:55,136
更多的高级功能

29
00:00:55,136 --> 0:00:56,886
以使这个 API 发挥最大功效

30
00:01:00,236 --> 0:01:01,746
我们的内容很多

31
00:01:01,746 --> 0:01:03,346
我们开始吧

32
00:01:04,215 --> 0:01:06,306
首先我们说一说

33
00:01:06,306 --> 0:01:07,166
现在这项技术的发展状况

34
00:01:07,166 --> 0:01:07,876
我们现在是怎么做的呢

35
00:01:07,876 --> 0:01:10,056
我们是如何定义 CollectionView 布局的呢

36
00:01:11,336 --> 0:01:13,176
当 CollectionView

37
00:01:13,176 --> 0:01:15,206
被引入 iOS 6 的时候

38
00:01:15,206 --> 0:01:17,006
就有一个很新颖的概念

39
00:01:17,006 --> 0:01:18,426
它用一个单独的抽象概念

40
00:01:18,426 --> 0:01:19,256
来定义布局

41
00:01:20,156 --> 0:01:21,766
因此它其实是

42
00:01:21,766 --> 0:01:22,906
相互配合作用的两个类

43
00:01:22,906 --> 0:01:23,686
一个负责渲染

44
00:01:23,686 --> 0:01:25,626
另一个负责布局

45
00:01:25,626 --> 0:01:27,966
也就是 CollectionView 布局

46
00:01:28,856 --> 0:01:30,256
CollectionView 布局是一个

47
00:01:30,256 --> 0:01:31,166
抽象的概念

48
00:01:31,166 --> 0:01:32,676
所以我们必须将其编入子类

49
00:01:32,676 --> 0:01:33,306
去使用它

50
00:01:33,356 --> 0:01:35,416
我们之前在 iOS 6 中装载了

51
00:01:35,416 --> 0:01:37,336
一个具体的布局类

52
00:01:37,336 --> 0:01:38,576
称作 CollectionView 流式布局

53
00:01:40,136 --> 0:01:41,696
流式布局对许多不同的设计

54
00:01:41,696 --> 0:01:43,476
都十分有用

55
00:01:43,476 --> 0:01:44,926
特别是在 iOS 6 时期

56
00:01:44,926 --> 0:01:46,126
当时的情况

57
00:01:46,126 --> 0:01:47,176
可能更简单一些

58
00:01:48,066 --> 0:01:49,576
当时这么做是因为它使用的

59
00:01:49,576 --> 0:01:51,306
是一种基于行的布局系统

60
00:01:51,306 --> 0:01:53,606
去年 我们在

61
00:01:54,146 --> 0:01:55,686
UI CollectionView 中讲到了它

62
00:01:56,146 --> 0:01:57,826
但总的来说 一个基于行的系统

63
00:01:57,826 --> 0:01:59,096
使你能够在正交轴上进行布局

64
00:01:59,096 --> 0:02:00,576
设置布局轴

65
00:01:59,096 --> 0:02:00,576
设置布局轴

66
00:02:00,576 --> 0:02:02,386
直到你填满

67
00:02:02,386 --> 0:02:03,496
可用的空间数量

68
00:02:03,496 --> 0:02:05,026
然后开始下一行

69
00:02:05,726 --> 0:02:07,726
这种方法真的很不错

70
00:02:07,726 --> 0:02:09,446
它运行简单 推理容易

71
00:02:09,485 --> 0:02:10,826
你很快就可以做好布局

72
00:02:11,786 --> 0:02:15,736
但是今天的 App 呢

73
00:02:16,636 --> 0:02:18,906
随着设备的异构性增强

74
00:02:18,906 --> 0:02:20,656
和屏幕大小的改变

75
00:02:20,656 --> 0:02:21,756
在如今的 App 里

76
00:02:21,756 --> 0:02:23,326
情况变得更加复杂了

77
00:02:23,326 --> 0:02:25,186
在这里我们看到的是

78
00:02:25,326 --> 0:02:26,866
装载在 iOS 13 中的 App Store

79
00:02:27,736 --> 0:02:29,236
如果今设计师天交给你这样的设计

80
00:02:29,236 --> 0:02:31,116
你会怎么办呢

81
00:02:31,116 --> 0:02:32,216
你肯定会想

82
00:02:32,216 --> 0:02:33,986
“好吧 我得选择如何进行设计”

83
00:02:33,986 --> 0:02:35,156
因为现在我们可选的选项

84
00:02:35,156 --> 0:02:35,716
远多于从前

85
00:02:36,806 --> 0:02:38,656
然后你也许会选定 CollectionView

86
00:02:38,656 --> 0:02:40,426
而如果你选定了它

87
00:02:40,486 --> 0:02:42,196
你就会想

88
00:02:42,196 --> 0:02:43,406
“我真的能在这里实现流式布局吗”

89
00:02:44,256 --> 0:02:45,666
然后你有可能立刻放弃它

90
00:02:47,196 --> 0:02:47,976
你所面对的

91
00:02:47,976 --> 0:02:49,486
则是一个自定布局

92
00:02:49,486 --> 0:02:51,256
并且 我看到你们在 Twitter 上

93
00:02:51,256 --> 0:02:52,876
关于自定布局的讨论

94
00:02:52,876 --> 0:02:53,996
它们可能会很复杂

95
00:02:53,996 --> 0:02:55,676
去年我们在

96
00:02:55,766 --> 0:02:58,136
CollectionView 的介绍中讨论过它

97
00:02:58,716 --> 0:03:00,256
我们当时讨论了

98
00:02:58,716 --> 0:03:00,256
我们当时讨论了

99
00:03:00,256 --> 0:03:02,076
创建一个自定布局所需要的东西

100
00:03:03,476 --> 0:03:05,016
你需要

101
00:03:05,266 --> 0:03:06,536
在你的具体的布局类中

102
00:03:06,536 --> 0:03:08,976
提供一定数量的东西

103
00:03:09,336 --> 0:03:10,486
我们也讨论了这些东西

104
00:03:10,756 --> 0:03:12,236
同时我们也考虑到了

105
00:03:12,286 --> 0:03:13,566
一些性能注意事项

106
00:03:13,566 --> 0:03:14,776
这是你在设计一个自定布局时

107
00:03:14,776 --> 0:03:15,976
所必须要考虑的事情

108
00:03:15,976 --> 0:03:17,386
以确保当你的 CollectionView 中

109
00:03:17,386 --> 0:03:18,466
有大量的项目时

110
00:03:18,466 --> 0:03:19,046
它依然能快速运行

111
00:03:19,576 --> 0:03:20,716
但我们并没有涵盖所有的情况

112
00:03:20,716 --> 0:03:22,286
如果我们创建这些

113
00:03:22,286 --> 0:03:23,356
自定布局的话

114
00:03:23,356 --> 0:03:24,296
还会遇到其他的挑战

115
00:03:25,436 --> 0:03:26,766
有很多这样的例子

116
00:03:26,766 --> 0:03:27,876
我将在这里介绍一些

117
00:03:27,916 --> 0:03:29,286
比如 补充视图

118
00:03:29,286 --> 0:03:31,246
和装饰视图

119
00:03:31,246 --> 0:03:33,416
都是可以在 CollectionView 里

120
00:03:33,416 --> 0:03:34,816
搞得定的视图

121
00:03:34,816 --> 0:03:36,236
而它们在自定布局里就有点棘手了

122
00:03:36,236 --> 0:03:36,986
你只能靠自己了

123
00:03:37,566 --> 0:03:39,296
同时还有自定尺寸这一挑战

124
00:03:39,296 --> 0:03:40,556
你都得想办法解决

125
00:03:41,016 --> 0:03:42,336
之后我们还会谈到这个

126
00:03:42,606 --> 0:03:44,186
今年我们将一种

127
00:03:44,186 --> 0:03:46,796
全新的具体的布局类

128
00:03:46,796 --> 0:03:48,666
应用到平台中

129
00:03:48,666 --> 0:03:50,676
作为流式布局的同级

130
00:03:51,286 --> 0:03:53,886
我们称之为组合布局

131
00:03:54,986 --> 0:03:55,706
好的

132
00:03:56,091 --> 0:03:58,091
[掌声]

133
00:03:58,166 --> 0:03:59,936
我们还没看过这种布局呢

134
00:04:00,566 --> 0:04:02,686
什么是组合布局呢

135
00:04:02,686 --> 0:04:03,496
它是做什么的呢

136
00:04:04,606 --> 0:04:06,856
先讲一点原理

137
00:04:06,916 --> 0:04:08,076
这是建立在什么基础上的呢

138
00:04:08,076 --> 0:04:09,656
它有三个基本支柱

139
00:04:09,656 --> 0:04:10,976
我们在上面搭建组合布局

140
00:04:10,976 --> 0:04:12,466
首先 它是可组合的

141
00:04:12,466 --> 0:04:13,816
也就是用简单的东西

142
00:04:13,816 --> 0:04:14,696
来制作复杂的东西

143
00:04:15,636 --> 0:04:17,086
同时它也是灵活的

144
00:04:17,555 --> 0:04:19,866
你可以用组合布局

145
00:04:19,866 --> 0:04:20,606
来写任何布局

146
00:04:20,606 --> 0:04:21,776
它十分灵活

147
00:04:21,776 --> 0:04:23,496
在默认情况下它的速度也很快

148
00:04:23,496 --> 0:04:25,296
我们之前已经

149
00:04:25,296 --> 0:04:26,626
在框架中进行了

150
00:04:26,626 --> 0:04:27,966
所有的性能优化

151
00:04:27,966 --> 0:04:28,836
因此在这里不用考虑这点

152
00:04:28,836 --> 0:04:30,276
组合布局就是

153
00:04:30,276 --> 0:04:32,376
描述或定义你想做什么

154
00:04:32,376 --> 0:04:33,766
它是一种描述性的 API

155
00:04:36,346 --> 0:04:37,376
“组成”这个词

156
00:04:37,376 --> 0:04:39,016
你将会在本讲座中听到很多次

157
00:04:39,016 --> 0:04:40,776
我们该如何用组合布局

158
00:04:40,776 --> 0:04:41,776
来进行组成呢

159
00:04:41,776 --> 0:04:43,186
我们会用小块的布局

160
00:04:43,186 --> 0:04:44,636
这些小组件

161
00:04:44,636 --> 0:04:46,896
将它们缝合在一起

162
00:04:47,196 --> 0:04:48,556
这样你就用小块的布局

163
00:04:48,556 --> 0:04:50,126
组成了更大的布局

164
00:04:50,516 --> 0:04:51,766
我们已经从大量相关课程里

165
00:04:51,766 --> 0:04:52,916
学习了流式布局

166
00:04:52,916 --> 0:04:54,416
通过这些基于行的课程

167
00:04:54,416 --> 0:04:56,836
你可以学习沿着行进行布局

168
00:04:56,916 --> 0:04:57,956
我们也许知道有多少项目

169
00:04:57,956 --> 0:04:58,506
也许不知道

170
00:04:58,506 --> 0:04:59,766
但我们可以在这些小布局组中的

171
00:04:59,766 --> 0:05:01,126
一行上布局项目

172
00:04:59,766 --> 0:05:01,126
一行上布局项目

173
00:05:02,626 --> 0:05:03,506
最后 正如名字所示

174
00:05:03,506 --> 0:05:05,656
你不用设置子类

175
00:05:05,656 --> 0:05:06,496
你只需要构建一个东西

176
00:05:06,496 --> 0:05:08,096
然后将一些元素组合起来

177
00:05:08,096 --> 0:05:09,706
之后就可以运行了

178
00:05:09,706 --> 0:05:13,676
说了这么多还没有看代码

179
00:05:13,676 --> 0:05:14,686
在这样的会议上

180
00:05:14,686 --> 0:05:15,696
讨论的应该全是代码

181
00:05:15,696 --> 0:05:17,586
我们来看些代码吧

182
00:05:18,056 --> 0:05:22,026
这是一个 Hello World

183
00:05:22,376 --> 0:05:23,156
组合布局

184
00:05:23,206 --> 0:05:24,676
共有五行代码

185
00:05:24,676 --> 0:05:27,036
现在 我要切换到

186
00:05:27,036 --> 0:05:28,666
我这里的设备

187
00:05:30,026 --> 0:05:33,446
这里展示的是我们的示例 App

188
00:05:33,446 --> 0:05:35,536
接着是列表示例

189
00:05:35,886 --> 0:05:36,876
哇 这个布局挺无聊的

190
00:05:36,876 --> 0:05:38,496
看起来像个表格 

191
00:05:39,296 --> 0:05:41,436
这不重要

192
00:05:41,806 --> 0:05:46,336
下面我们把重点

193
00:05:46,336 --> 0:05:47,236
放在代码上

194
00:05:47,236 --> 0:05:47,976
我们来看这个

195
00:05:48,886 --> 0:05:50,846
这里我们马上

196
00:05:50,986 --> 0:05:52,206
就会有一些发现

197
00:05:52,206 --> 0:05:53,426
那第一个发现

198
00:05:53,426 --> 0:05:54,986
因为我知道开发者们会说

199
00:05:54,986 --> 0:05:55,896
“嘿 Steve 我可以在流式布局中

200
00:05:55,936 --> 0:05:57,956
用两行代码完成这个

201
00:05:57,996 --> 0:05:59,146
你这个有什么意义呢”

202
00:05:59,856 --> 0:06:01,476
这种想法的确没错

203
00:05:59,856 --> 0:06:01,476
这种想法的确没错

204
00:06:01,476 --> 0:06:03,156
你也许可以那样做

205
00:06:03,156 --> 0:06:05,186
但在听完今天的整个发言后

206
00:06:05,186 --> 0:06:05,996
我希望你们

207
00:06:05,996 --> 0:06:07,416
记住和思考的是

208
00:06:07,416 --> 0:06:08,996
当这些布局变得更多更复杂的时候

209
00:06:08,996 --> 0:06:10,096
我们不会让代码量

210
00:06:10,096 --> 0:06:12,766
随着问题的大小

211
00:06:12,766 --> 0:06:14,126
呈线性增长

212
00:06:14,126 --> 0:06:14,686
而是逐渐减少

213
00:06:14,686 --> 0:06:15,286
因为我们只要将

214
00:06:15,286 --> 0:06:16,806
新的东西组到布局中去

215
00:06:16,806 --> 0:06:18,436
用一种非常简单的

216
00:06:18,676 --> 0:06:20,526
容易推出的方法

217
00:06:20,526 --> 0:06:21,966
来得到十分复杂的布局

218
00:06:22,626 --> 0:06:23,876
我非常激动能向你们展示这些成果

219
00:06:24,636 --> 0:06:26,316
第二个发现是

220
00:06:26,466 --> 0:06:27,406
我想要你们看看

221
00:06:27,406 --> 0:06:29,746
这些类型中有一个自然过渡 

222
00:06:29,746 --> 0:06:31,076
这里我们一共有五种类型

223
00:06:31,076 --> 0:06:32,226
这里什么情况

224
00:06:33,246 --> 0:06:34,926
我首先要关注的类型

225
00:06:35,136 --> 0:06:36,666
是这四种类型

226
00:06:36,666 --> 0:06:38,216
它们在逐级递进时

227
00:06:38,216 --> 0:06:40,306
自然会看到这个抽象过程

228
00:06:40,536 --> 0:06:42,596
我们从一个项目开始

229
00:06:42,596 --> 0:06:43,716
这个项目被折叠成一个组

230
00:06:43,716 --> 0:06:45,916
这个组又变成一个段

231
00:06:46,366 --> 0:06:48,606
而这个段又变为我们的布局

232
00:06:49,856 --> 0:06:51,756
现在 我们直观地看一下

233
00:06:53,386 --> 0:06:58,016
这里 这个大矩形就是布局

234
00:06:58,016 --> 0:07:01,716
这个布局是你整个的布局

235
00:06:58,016 --> 0:07:01,716
这个布局是你整个的布局

236
00:07:02,426 --> 0:07:03,676
然后这些明显的白色部分

237
00:07:03,676 --> 0:07:06,456
代表我们的段

238
00:07:06,806 --> 0:07:08,256
这会直接映射到

239
00:07:08,256 --> 0:07:09,966
数据源 也就是

240
00:07:09,966 --> 0:07:10,726
那些段中的内容

241
00:07:11,606 --> 0:07:12,316
接着在这个具体的例子里

242
00:07:12,316 --> 0:07:14,126
我们展示的是一种

243
00:07:14,126 --> 0:07:15,766
传统的网格型布局

244
00:07:15,766 --> 0:07:17,666
我们可以看到这些组

245
00:07:17,666 --> 0:07:19,026
代表了我们的行

246
00:07:19,886 --> 0:07:22,016
在里面的就是项目

247
00:07:22,906 --> 0:07:24,086
这里主要是为了

248
00:07:24,086 --> 0:07:25,136
展示这个将贯穿

249
00:07:25,136 --> 0:07:26,296
整个演讲的层次结构

250
00:07:26,326 --> 0:07:27,706
也就是这种重复的模式

251
00:07:27,806 --> 0:07:31,106
项目 组 段 布局的模式

252
00:07:33,076 --> 0:07:34,256
现在我想要

253
00:07:34,256 --> 0:07:35,296
简要谈一谈

254
00:07:35,296 --> 0:07:36,486
一些概念

255
00:07:36,486 --> 0:07:38,526
在组合布局中的这些核心类型

256
00:07:38,636 --> 0:07:40,046
只要我们弄懂这些

257
00:07:40,046 --> 0:07:41,006
我们就可以直接跳到

258
00:07:41,006 --> 0:07:42,486
实际演示中来检测其适用性

259
00:07:42,526 --> 0:07:45,266
我想从设定尺寸

260
00:07:45,266 --> 0:07:46,316
开始讲起

261
00:07:47,236 --> 0:07:48,306
组合布局扩展了

262
00:07:48,306 --> 0:07:49,906
设定尺寸的功能

263
00:07:49,906 --> 0:07:51,226
让你更容易推出

264
00:07:51,226 --> 0:07:52,876
在一个组合布局里面

265
00:07:52,876 --> 0:07:53,866
如何设定尺寸

266
00:07:54,566 --> 0:07:56,226
所有东西都有一个清楚的尺寸

267
00:07:56,226 --> 0:07:57,766
每个东西的大小

268
00:07:57,766 --> 0:07:58,696
都十分明确

269
00:08:00,076 --> 0:08:01,836
现在 我们在这个欧几里得

270
00:08:01,836 --> 0:08:03,266
二维几何平面上

271
00:08:03,336 --> 0:08:03,856
用弯曲视图

272
00:08:03,856 --> 0:08:05,916
因此 一个尺寸实际上

273
00:08:05,916 --> 0:08:06,756
只是两个属性

274
00:08:06,756 --> 0:08:08,646
一个是宽度 一个是高度

275
00:08:09,466 --> 0:08:11,756
这里我们可以看到

276
00:08:11,756 --> 0:08:12,866
我们得到了该类型的

277
00:08:12,896 --> 0:08:13,696
简化版定义

278
00:08:13,696 --> 0:08:15,646
它有一个宽度和一个高度

279
00:08:15,646 --> 0:08:16,686
但要注意的是

280
00:08:16,686 --> 0:08:17,396
宽度和高度这两个维度

281
00:08:17,396 --> 0:08:18,676
它们并不是标量值

282
00:08:18,676 --> 0:08:19,506
它不只是一个浮点数或其他

283
00:08:19,506 --> 0:08:20,846
它其实是另一种类型

284
00:08:20,896 --> 0:08:22,116
也就是

285
00:08:22,166 --> 0:08:24,046
NSCollectionLayoutDimension

286
00:08:25,136 --> 0:08:26,156
那又是什么呢

287
00:08:26,956 --> 0:08:27,756
其实很简单

288
00:08:27,896 --> 0:08:29,896
这是用一种不依赖于轴的方式

289
00:08:29,896 --> 0:08:31,966
来描述一个具体的轴的大小

290
00:08:31,966 --> 0:08:32,876
我们有四个不同的方法

291
00:08:32,876 --> 0:08:35,015
来定义这个东西

292
00:08:35,775 --> 0:08:36,885
我们用一种可视的方式

293
00:08:36,885 --> 0:08:38,586
来完成这些

294
00:08:39,716 --> 0:08:41,395
你现在有一个项目

295
00:08:41,395 --> 0:08:42,296
你想要描述它

296
00:08:42,296 --> 0:08:44,166
相对于其容器的大小

297
00:08:44,926 --> 0:08:45,906
最外层的容器

298
00:08:45,906 --> 0:08:46,676
将会是你的 CollectionView

299
00:08:47,256 --> 0:08:48,376
在这里我们只说

300
00:08:48,376 --> 0:08:49,976
这个项目的宽度

301
00:08:49,976 --> 0:08:51,176
会是其容器宽度的

302
00:08:51,176 --> 0:08:53,246
一部分或 50%

303
00:08:54,656 --> 0:08:56,846
同样的 我们可以说

304
00:08:56,846 --> 0:08:58,056
某个东西的高度

305
00:08:58,056 --> 0:08:59,566
是其容器高度的一部分

306
00:08:59,566 --> 0:09:01,566
在这里是 30%

307
00:08:59,566 --> 0:09:01,566
在这里是 30%

308
00:09:03,496 --> 0:09:05,266
因为我们可以用这种

309
00:09:05,266 --> 0:09:07,656
不依赖轴的方法来描述某物

310
00:09:07,656 --> 0:09:09,616
我们就可以用

311
00:09:09,616 --> 0:09:11,486
具体的长宽比来定义某物

312
00:09:11,486 --> 0:09:12,816
在这个例子里长宽比是 1

313
00:09:12,816 --> 0:09:15,516
通过将宽度和高度

314
00:09:15,666 --> 0:09:18,166
定义为一个维度

315
00:09:18,166 --> 0:09:19,876
即其容器宽度的一部分

316
00:09:20,526 --> 0:09:22,186
因此当它的宽度为

317
00:09:22,186 --> 0:09:23,496
其容器的 25% 时

318
00:09:23,676 --> 0:09:24,326
其高度也是 25%

319
00:09:25,906 --> 0:09:26,656
这些就是

320
00:09:26,876 --> 0:09:28,716
创建维度的分数变量

321
00:09:29,626 --> 0:09:31,006
基于点的值呢

322
00:09:31,736 --> 0:09:32,636
我们有两个

323
00:09:33,256 --> 0:09:34,876
第一个是最简单的 绝对值

324
00:09:35,536 --> 0:09:36,296
你把这个值设为 200 点

325
00:09:36,296 --> 0:09:37,246
因为你的设计师

326
00:09:37,246 --> 0:09:40,256
强调它必须是 200 点

327
00:09:40,256 --> 0:09:42,076
那它就是这样的 

328
00:09:42,076 --> 0:09:42,796
接着在这里

329
00:09:42,986 --> 0:09:44,336
就一个有趣的概念 估算值

330
00:09:45,376 --> 0:09:47,246
如果你不知道具体的

331
00:09:47,246 --> 0:09:48,166
项目的尺寸是多少

332
00:09:48,166 --> 0:09:49,606
我们会经常这样说

333
00:09:49,736 --> 0:09:51,056
你可以估计其大小

334
00:09:51,056 --> 0:09:52,206
假设它是 200 点

335
00:09:52,566 --> 0:09:55,226
随着时间的过去

336
00:09:55,226 --> 0:09:56,456
它会随着项目的渲染而增长

337
00:09:56,456 --> 0:09:57,566
我们对这个项目中的内容

338
00:09:57,566 --> 0:09:59,436
也会更加了解

339
00:10:00,506 --> 0:10:03,996
这就是布局的维度和尺寸

340
00:10:05,146 --> 0:10:06,666
接下来我们来谈一谈项目

341
00:10:06,666 --> 0:10:07,656
这很简单

342
00:10:07,656 --> 0:10:09,406
这是一个储存格或者补充物

343
00:10:09,406 --> 0:10:11,116
它是一个呈现在屏幕上的东西

344
00:10:12,296 --> 0:10:14,886
你会在 STK 中看到更多的东西

345
00:10:14,886 --> 0:10:16,866
但这只是那种类型定义的一小部分

346
00:10:17,586 --> 0:10:18,516
我们发现当我们构建这些东西时

347
00:10:18,516 --> 0:10:20,756
我们总要给它一个尺寸

348
00:10:20,996 --> 0:10:22,566
所有的东西都要有一个尺寸

349
00:10:23,236 --> 0:10:25,866
我们就接着说

350
00:10:25,916 --> 0:10:27,146
按照抽象层级

351
00:10:27,146 --> 0:10:28,536
已经说过了项目 下面我们来说组

352
00:10:28,856 --> 0:10:29,536
所以什么是组呢

353
00:10:29,536 --> 0:10:31,366
组是层级中的骨干

354
00:10:31,366 --> 0:10:33,206
它就是你要

355
00:10:33,206 --> 0:10:34,756
组成的布局的基本单元

356
00:10:34,756 --> 0:10:37,286
有三种形式

357
00:10:37,426 --> 0:10:38,506
水平 垂直 和自定

358
00:10:39,136 --> 0:10:39,976
你可以把这些想象成

359
00:10:39,976 --> 0:10:41,226
小型的流式布局 

360
00:10:41,226 --> 0:10:42,696
它们布局在水平轴

361
00:10:42,696 --> 0:10:44,496
和垂直轴的一条线上

362
00:10:45,426 --> 0:10:46,806
但要记住 我们之前说过

363
00:10:46,806 --> 0:10:48,556
它是十分灵活的

364
00:10:48,696 --> 0:10:50,426
如果你有一些东西

365
00:10:50,426 --> 0:10:51,446
没有沿着该线进行布局

366
00:10:51,446 --> 0:10:52,826
很多布局就都没有做到这一点

367
00:10:53,176 --> 0:10:54,316
我们可以用一个自定组

368
00:10:55,096 --> 0:10:56,166
那是什么呢

369
00:10:57,286 --> 0:10:58,726
自定组让你以一种

370
00:10:58,726 --> 0:11:00,876
自定义的方式

371
00:10:58,726 --> 0:11:00,876
自定义的方式

372
00:11:00,876 --> 0:11:02,446
描述项目的绝对大小和位置

373
00:11:02,446 --> 0:11:03,436
所以如果你有

374
00:11:03,436 --> 0:11:04,896
预定义的生成器

375
00:11:04,896 --> 0:11:06,726
来生成布局 那你就可以用自定组

376
00:11:07,286 --> 0:11:08,166
或者如果你要做一个径向的布局

377
00:11:08,166 --> 0:11:09,096
并且你想要计算它

378
00:11:09,096 --> 0:11:10,926
那你也可以用自定组来完成

379
00:11:11,526 --> 0:11:12,896
很厉害的是

380
00:11:12,896 --> 0:11:14,066
你可以直接在垂直

381
00:11:14,066 --> 0:11:15,786
和水平方向上组成自定义组

382
00:11:15,786 --> 0:11:17,596
也就是用简单

383
00:11:17,596 --> 0:11:18,016
构建复杂

384
00:11:19,696 --> 0:11:22,156
这就是组 层级中的骨干

385
00:11:23,486 --> 0:11:24,446
接下来我们要说

386
00:11:24,666 --> 0:11:26,276
NSCollectionLayoutSection

387
00:11:27,166 --> 0:11:28,666
正如它的名字所示

388
00:11:28,666 --> 0:11:29,806
这是一种基于

389
00:11:29,886 --> 0:11:31,586
CollectionView 中每个段的

390
00:11:31,586 --> 0:11:32,936
布局定义

391
00:11:33,066 --> 0:11:34,196
可以把该段中有多少项目

392
00:11:34,196 --> 0:11:37,406
直接映射到该段的数据源

393
00:11:37,406 --> 0:11:38,886
正如预期 我们看到

394
00:11:39,466 --> 0:11:40,556
对段进行初始化

395
00:11:40,556 --> 0:11:42,146
只需输入布局组

396
00:11:42,676 --> 0:11:45,106
我们已经讲过了项目 组 和段

397
00:11:45,916 --> 0:11:49,076
在这部分的最后

398
00:11:49,076 --> 0:11:51,686
我们将讲到两个

399
00:11:51,686 --> 0:11:53,486
顶级的布局类

400
00:11:53,566 --> 0:11:56,786
在 iOS 和 tvOS 中我们有

401
00:11:56,786 --> 0:11:58,296
UICollectionViewCompositionalLayout

402
00:11:59,016 --> 0:12:00,856
而在 Mac 中我们有

403
00:11:59,016 --> 0:12:00,856
而在 Mac 中我们有

404
00:12:01,356 --> 0:12:02,646
NSViewCompositionalLayout

405
00:12:03,806 --> 0:12:05,026
有趣的是

406
00:12:05,116 --> 0:12:06,556
这些布局的定义都是一样的

407
00:12:06,556 --> 0:12:08,896
无论应用在哪个平台

408
00:12:09,586 --> 0:12:10,236
它们只是在顶级类上

409
00:12:10,236 --> 0:12:12,896
有一些细微的差别

410
00:12:13,516 --> 0:12:15,046
最后在这里要说的是

411
00:12:15,046 --> 0:12:15,866
一件十分有趣的事

412
00:12:15,866 --> 0:12:16,546
我们也会在之后的

413
00:12:16,546 --> 0:12:17,296
演示中看到更多

414
00:12:17,296 --> 0:12:20,956
构建一个组合布局的方法

415
00:12:21,126 --> 0:12:22,056
有两种方法

416
00:12:22,556 --> 0:12:24,486
最简单的方法是

417
00:12:24,486 --> 0:12:26,206
直接描述一个布局段的定义

418
00:12:26,416 --> 0:12:27,776
这和我们今天在流式布局中

419
00:12:27,776 --> 0:12:29,296
所用的方法差不多

420
00:12:29,296 --> 0:12:30,696
因为流式布局将每个段的量

421
00:12:30,696 --> 0:12:31,926
定义为与其他所有段一样

422
00:12:31,926 --> 0:12:33,206
因而它是均匀的

423
00:12:34,396 --> 0:12:36,946
而组合布局则扩展了这个想法

424
00:12:37,526 --> 0:12:38,646
因为现在我们有了

425
00:12:38,646 --> 0:12:39,856
这种对段的定义

426
00:12:39,856 --> 0:12:42,976
我们就可以指定一个闭包

427
00:12:43,236 --> 0:12:44,856
该闭包将被调回

428
00:12:44,856 --> 0:12:46,586
并将在每个段的基础上

429
00:12:46,586 --> 0:12:48,876
请求这些段的定义

430
00:12:49,236 --> 0:12:51,126
这样就带来了许多的可能性

431
00:12:51,126 --> 0:12:52,306
因为现在你的布局

432
00:12:52,736 --> 0:12:53,846
能够在段间

433
00:12:53,846 --> 0:12:55,876
被完全区分开

434
00:12:55,976 --> 0:12:57,886
在之后的演示中

435
00:12:57,886 --> 0:12:59,276
我们会向你们展示很多

436
00:12:59,276 --> 0:13:02,016
现在就到演示的部分了

437
00:12:59,276 --> 0:13:02,016
现在就到演示的部分了

438
00:13:02,176 --> 0:13:03,926
关于类型的讨论已经够多了

439
00:13:04,006 --> 0:13:05,626
下面我们要看看它的实际应用

440
00:13:05,626 --> 0:13:06,536
这一部分就交给

441
00:13:06,536 --> 0:13:08,896
我的同事 Troy Stephens

442
00:13:08,896 --> 0:13:09,116
Troy

443
00:13:10,321 --> 0:13:12,321
[掌声]

444
00:13:12,626 --> 0:13:13,266
&gt;&gt; 谢谢 Steve

445
00:13:14,776 --> 0:13:16,676
接下来 我们就来看一些代码

446
00:13:16,676 --> 0:13:17,816
我们将深入探讨

447
00:13:17,816 --> 0:13:19,716
一些实用的方法

448
00:13:19,716 --> 0:13:21,416
我们如何用 Steve 刚才描述的

449
00:13:21,516 --> 0:13:22,886
这些简单的元素

450
00:13:23,046 --> 0:13:24,366
来构建任意类型的

451
00:13:24,366 --> 0:13:25,406
你想要的布局

452
00:13:25,956 --> 0:13:27,016
因此如果你还没有下载

453
00:13:27,016 --> 0:13:28,596
本次讲座的示例项目的话

454
00:13:28,596 --> 0:13:29,496
请务必下载

455
00:13:29,986 --> 0:13:31,306
这样你就可以跟着做

456
00:13:31,486 --> 0:13:33,156
还能有空的时候研究一下

457
00:13:33,156 --> 0:13:35,506
最重要的是可以在你自己的项目中

458
00:13:35,506 --> 0:13:37,246
免费使用我们的代码

459
00:13:37,756 --> 0:13:38,736
而无论你想要完成

460
00:13:38,736 --> 0:13:39,656
哪种布局的构建

461
00:13:39,656 --> 0:13:41,236
你都能在我们今天

462
00:13:41,236 --> 0:13:42,356
所讲的例子里

463
00:13:42,356 --> 0:13:43,746
找到与之类似的案例

464
00:13:44,376 --> 0:13:45,916
用我们的代码作为基础

465
00:13:45,916 --> 0:13:46,806
进行你的布局

466
00:13:46,806 --> 0:13:48,266
你将会更快更有效地

467
00:13:48,266 --> 0:13:49,056
接近你的目标

468
00:13:49,096 --> 0:13:50,706
我们将看到这很容易

469
00:13:50,796 --> 0:13:52,696
我们利用任意现有的

470
00:13:52,696 --> 0:13:54,226
组合布局描述

471
00:13:54,566 --> 0:13:56,246
并逐步改进它

472
00:13:56,246 --> 0:13:57,666
使之成为你想要的布局

473
00:13:59,026 --> 0:13:59,996
当我们看完今天的示例

474
00:13:59,996 --> 0:14:01,566
我想让你们注意的是

475
00:13:59,996 --> 0:14:01,566
我想让你们注意的是

476
00:14:01,566 --> 0:14:03,726
每一个例子中都有

477
00:14:03,726 --> 0:14:04,806
相同的基本模式

478
00:14:05,076 --> 0:14:07,236
这就是 Steve 向我们介绍的模式

479
00:14:07,916 --> 0:14:09,466
每一个组合布局描述

480
00:14:09,466 --> 0:14:11,346
都由四个相同的

481
00:14:11,346 --> 0:14:13,846
基础部分组成

482
00:14:13,976 --> 0:14:15,896
分别是项目 组和段的描述

483
00:14:15,896 --> 0:14:17,596
以及包含三者的

484
00:14:17,596 --> 0:14:19,146
整个布局

485
00:14:19,496 --> 0:14:20,936
在接下来我们看的

486
00:14:20,936 --> 0:14:21,606
每一个代码示例里

487
00:14:21,606 --> 0:14:22,836
我们都将会看到相同的

488
00:14:22,836 --> 0:14:24,346
四层嵌套结构

489
00:14:24,726 --> 0:14:26,036
在更高级的讨论中

490
00:14:26,036 --> 0:14:27,056
我们将看到如何

491
00:14:27,056 --> 0:14:28,776
将组嵌套进其他的组中

492
00:14:28,776 --> 0:14:30,166
利用这些简单的

493
00:14:30,206 --> 0:14:32,476
易懂的部分

494
00:14:32,506 --> 0:14:34,306
来构建或组成

495
00:14:34,476 --> 0:14:37,026
更为复杂精细的布局

496
00:14:37,676 --> 0:14:38,686
接下来我们来看代码

497
00:14:45,066 --> 0:14:46,286
这里我们会从

498
00:14:46,286 --> 0:14:47,876
我们的列表示例开始

499
00:14:48,456 --> 0:14:49,646
这是 Steve 之前展示过的那个

500
00:14:49,646 --> 0:14:51,426
在这里 这是我们

501
00:14:51,426 --> 0:14:54,396
能想到的最简单的有用的布局

502
00:14:54,576 --> 0:14:56,456
这一个单列列表

503
00:14:56,456 --> 0:14:58,226
其中项目的宽度与

504
00:14:58,226 --> 0:14:58,956
CollectionView 相当

505
00:14:59,656 --> 0:15:02,316
如果我把手机转过来

506
00:14:59,656 --> 0:15:02,316
如果我把手机转过来

507
00:15:02,316 --> 0:15:03,646
我们能看到这些项目的确会

508
00:15:03,646 --> 0:15:05,206
进行扩展以填充可用的宽度

509
00:15:05,206 --> 0:15:06,836
但同时可以

510
00:15:06,836 --> 0:15:07,966
保持原有高度不变

511
00:15:08,376 --> 0:15:09,656
我们如何用组合布局

512
00:15:09,726 --> 0:15:11,016
来实施这个呢

513
00:15:11,566 --> 0:15:12,956
我打开了列表视图

514
00:15:12,956 --> 0:15:14,946
控制器源文件

515
00:15:14,946 --> 0:15:15,836
这就是我们

516
00:15:15,836 --> 0:15:16,656
实施布局的地方

517
00:15:16,686 --> 0:15:17,856
在今天要讲的每个例子里

518
00:15:17,856 --> 0:15:19,476
我们进行了一个

519
00:15:19,476 --> 0:15:20,986
CreatLayout 的函数

520
00:15:20,986 --> 0:15:22,346
它能够灵活地将

521
00:15:22,346 --> 0:15:23,936
组合布局的描述

522
00:15:23,936 --> 0:15:25,686
打包封装起来

523
00:15:25,686 --> 0:15:27,456
然后再返回来连接到

524
00:15:27,456 --> 0:15:28,676
我们的 CollectionView 中

525
00:15:28,676 --> 0:15:29,626
就像其他任何的

526
00:15:29,746 --> 0:15:30,906
CollectionView 布局一样

527
00:15:31,836 --> 0:15:33,056
这里要注意的第一件事

528
00:15:33,606 --> 0:15:35,606
就是我们之前说过的

529
00:15:35,606 --> 0:15:37,656
要从描述一个项目及其尺寸开始

530
00:15:38,536 --> 0:15:39,906
我们先描述一个项目

531
00:15:40,396 --> 0:15:42,036
然后用它来描述

532
00:15:42,036 --> 0:15:44,626
一个项目组

533
00:15:45,156 --> 0:15:46,906
接着我们把该组放进一个段里

534
00:15:47,636 --> 0:15:49,196
最后我们创建并回到

535
00:15:49,196 --> 0:15:51,106
我们的组合布局

536
00:15:51,856 --> 0:15:53,016
这就是项目 组

537
00:15:53,016 --> 0:15:54,256
段及布局的结构

538
00:15:54,596 --> 0:15:55,406
这里值得注意的第二件事

539
00:15:55,446 --> 0:15:56,676
也是我们在进入到

540
00:15:56,676 --> 0:15:57,746
另一个例子之前

541
00:15:57,746 --> 0:15:59,056
应该真正理解的事

542
00:15:59,356 --> 0:16:01,996
是我们定义项目尺寸的方式

543
00:15:59,356 --> 0:16:01,996
是我们定义项目尺寸的方式

544
00:16:02,766 --> 0:16:04,336
在这个例子中

545
00:16:04,336 --> 0:16:06,666
组的大小最终决定了

546
00:16:07,306 --> 0:16:08,466
项目的大小

547
00:16:08,466 --> 0:16:10,066
下面我来解释一下原理

548
00:16:10,506 --> 0:16:12,296
在这个简单的列表示例中

549
00:16:12,296 --> 0:16:14,396
组似乎有一点多余

550
00:16:14,646 --> 0:16:15,896
在一个组合布局里

551
00:16:15,896 --> 0:16:17,766
一个组代表了一些

552
00:16:17,766 --> 0:16:19,076
典型的重复结构

553
00:16:19,076 --> 0:16:20,686
即一列项目

554
00:16:20,966 --> 0:16:21,926
或一行项目

555
00:16:22,196 --> 0:16:23,656
在这个例子里是一行项目

556
00:16:23,656 --> 0:16:24,726
但的确在一些十分简单的例子里

557
00:16:24,726 --> 0:16:26,716
每一行只有一个项目

558
00:16:27,166 --> 0:16:29,896
这时每个项目都会有自己的组

559
00:16:30,266 --> 0:16:31,576
但是组通常都是

560
00:16:31,576 --> 0:16:32,906
组合布局描述中

561
00:16:32,906 --> 0:16:33,706
固定的一部分

562
00:16:33,706 --> 0:16:34,626
同时我们要用组

563
00:16:34,626 --> 0:16:36,256
来帮助我们定义

564
00:16:36,256 --> 0:16:37,326
项目的大小

565
00:16:38,046 --> 0:16:40,076
之前 Steve 已经介绍了如何

566
00:16:40,076 --> 0:16:41,466
用容器定义大小

567
00:16:42,676 --> 0:16:44,866
我们先来看组的大小的描述

568
00:16:45,856 --> 0:16:48,206
这里我们要求组

569
00:16:48,206 --> 0:16:49,836
也就是这个例子里的行

570
00:16:50,156 --> 0:16:52,946
扩展成容器宽度的 100%

571
00:16:53,256 --> 0:16:54,726
这个组的容器就是它的段

572
00:16:54,726 --> 0:16:56,406
而段会反过来扩大

573
00:16:56,406 --> 0:16:57,656
布局或 CollectionView

574
00:16:59,586 --> 0:17:01,036
同时 我们要求每一个组的高度

575
00:16:59,586 --> 0:17:01,036
同时 我们要求每一个组的高度

576
00:17:01,116 --> 0:17:03,116
都是一个绝对值

577
00:17:03,116 --> 0:17:05,215
即 44 点高

578
00:17:06,336 --> 0:17:07,185
要注意的是

579
00:17:07,185 --> 0:17:09,076
这基本上已经定义了

580
00:17:09,076 --> 0:17:10,376
这个项目方框

581
00:17:10,376 --> 0:17:11,656
就是我们想要的项目大小

582
00:17:11,656 --> 0:17:12,626
即与 CollectionView 等宽

583
00:17:12,626 --> 0:17:13,646
44 点高

584
00:17:14,215 --> 0:17:15,326
在指定项目的大小时

585
00:17:15,326 --> 0:17:17,346
我们需要做的就是

586
00:17:17,896 --> 0:17:18,986
假设我们想要每个项目的

587
00:17:18,986 --> 0:17:21,396
宽度都是其容器的 100%

588
00:17:21,396 --> 0:17:22,756
高度也是 100%

589
00:17:22,756 --> 0:17:25,896
这时该项目的容器就是组

590
00:17:26,695 --> 0:17:28,056
这就是完成一个列表

591
00:17:28,056 --> 0:17:29,076
所需要的全部信息

592
00:17:29,076 --> 0:17:30,166
但有趣的是 在此过程中

593
00:17:30,166 --> 0:17:31,186
我们会发现

594
00:17:31,186 --> 0:17:32,316
我们并不需要在编码上

595
00:17:32,316 --> 0:17:33,436
做大的改变

596
00:17:33,436 --> 0:17:35,106
就能得到十分不同的布局

597
00:17:35,996 --> 0:17:37,006
我们来看另一个例子

598
00:17:37,006 --> 0:17:40,016
这里我要

599
00:17:40,016 --> 0:17:40,976
打开我们的网格

600
00:17:41,236 --> 0:17:43,196
这是一个无边框的

601
00:17:43,196 --> 0:17:44,566
五列的网格

602
00:17:46,036 --> 0:17:47,646
我们可以看看

603
00:17:47,646 --> 0:17:51,046
如果把手机转过来

604
00:17:51,046 --> 0:17:52,466
这个布局就变成了这样

605
00:17:52,466 --> 0:17:54,376
这时我们的确仍然有五列

606
00:17:54,376 --> 0:17:56,496
项目也仍然是正方形的

607
00:17:56,496 --> 0:17:58,136
而项目大小随之改变

608
00:17:58,216 --> 0:18:00,506
以适应这五列的宽度

609
00:17:58,216 --> 0:18:00,506
以适应这五列的宽度

610
00:18:03,426 --> 0:18:04,626
在这个例子中

611
00:18:04,626 --> 0:18:06,376
组其实要更方便一些

612
00:18:06,376 --> 0:18:07,646
同时我们更容易理解

613
00:18:07,646 --> 0:18:09,496
它们的函数是什么

614
00:18:10,326 --> 0:18:11,576
打开合格网格视图

615
00:18:11,576 --> 0:18:12,706
控制源文件

616
00:18:12,706 --> 0:18:13,806
看看这里创建布局的函数

617
00:18:13,806 --> 0:18:16,056
同样的 还是这个结构

618
00:18:16,106 --> 0:18:20,676
项目 组 段和布局

619
00:18:21,496 --> 0:18:22,826
这看起来和列表布局描述

620
00:18:22,826 --> 0:18:23,456
基本上差不多

621
00:18:23,456 --> 0:18:24,516
这里唯一不同的就是

622
00:18:24,516 --> 0:18:27,376
我们所设定的项目和组的大小

623
00:18:27,406 --> 0:18:28,716
我们来看看能有什么不同

624
00:18:29,616 --> 0:18:31,876
因为一组代表一行

625
00:18:31,876 --> 0:18:33,216
我们仍然让每一组都

626
00:18:33,216 --> 0:18:34,936
扩展到整个

627
00:18:34,936 --> 0:18:35,786
CollectionView 的宽度

628
00:18:35,936 --> 0:18:38,976
这很但这次我们不想让项目

629
00:18:38,976 --> 0:18:40,406
与组的宽度保持一致

630
00:18:40,536 --> 0:18:42,306
我们想要一行有五个项目

631
00:18:42,306 --> 0:18:43,406
那在这个例子里

632
00:18:43,406 --> 0:18:45,566
我们所要做的就是

633
00:18:45,566 --> 0:18:48,396
在这里指定该项目的宽度

634
00:18:48,396 --> 0:18:50,636
为其容器的 20%

635
00:18:51,106 --> 0:18:52,216
该项目的容器是组或行

636
00:18:52,216 --> 0:18:53,916
这时我们就

637
00:18:53,916 --> 0:18:55,146
能够通过我们对

638
00:18:55,146 --> 0:18:57,076
宽度的设定

639
00:18:57,076 --> 0:18:58,946
使一行有五个项目

640
00:18:59,906 --> 0:19:01,226
现在 我们来看高度

641
00:18:59,906 --> 0:19:01,226
现在 我们来看高度

642
00:19:01,226 --> 0:19:02,626
我们不设定一个绝对点值

643
00:19:03,606 --> 0:19:04,826
我们说过想让每组

644
00:19:04,976 --> 0:19:07,236
或每行的高度

645
00:19:07,236 --> 0:19:11,076
是其容器宽度的 20%

646
00:19:11,076 --> 0:19:12,236
注意 这里我们用这个方法

647
00:19:12,746 --> 0:19:15,096
来指定横轴的

648
00:19:15,096 --> 0:19:17,146
百分比宽度或高度

649
00:19:17,146 --> 0:19:18,756
这真的很容易

650
00:19:18,756 --> 0:19:20,706
这样我们就能让项目呈正方形

651
00:19:21,076 --> 0:19:23,286
项目的宽度和组的高度

652
00:19:23,666 --> 0:19:25,186
是一样的

653
00:19:26,436 --> 0:19:27,506
同时因为组的高度

654
00:19:27,506 --> 0:19:28,756
决定了项目的高度

655
00:19:28,756 --> 0:19:30,096
在这里我们需要做的就是

656
00:19:30,096 --> 0:19:32,616
设定项目的高度为其组高的 100%

657
00:19:33,326 --> 0:19:35,886
这样创建一个网格

658
00:19:35,886 --> 0:19:37,306
是很简单的

659
00:19:37,306 --> 0:19:38,566
而我们现在所用的代码

660
00:19:38,566 --> 0:19:39,856
与制作列表时所用的

661
00:19:39,856 --> 0:19:41,856
并没有根本上的不同

662
00:19:42,566 --> 0:19:43,726
如果设计师给你一个布局

663
00:19:43,726 --> 0:19:44,626
通常来说 你会想要

664
00:19:44,626 --> 0:19:46,446
在项目之间有一些空间

665
00:19:46,446 --> 0:19:48,046
那接下来就看看怎样加这些空间

666
00:19:48,936 --> 0:19:50,466
打开嵌入式项目网格示例

667
00:19:50,466 --> 0:19:52,136
这仍然是一个

668
00:19:52,136 --> 0:19:54,086
五列的网格

669
00:19:54,086 --> 0:19:55,866
只是在项目之间

670
00:19:55,866 --> 0:19:57,056
增加了一些空间

671
00:19:59,416 --> 0:20:01,576
接下来打开嵌入式项目视图

672
00:19:59,416 --> 0:20:01,576
接下来打开嵌入式项目视图

673
00:20:02,376 --> 0:20:04,006
InsetItemsGridViewController

674
00:20:04,006 --> 0:20:05,726
我们来看

675
00:20:06,246 --> 0:20:08,146
这里 如果把这些代码与

676
00:20:08,146 --> 0:20:09,296
之前的例子相比

677
00:20:09,296 --> 0:20:10,786
你就会发现

678
00:20:10,836 --> 0:20:12,516
只有一行代码有所变化

679
00:20:12,666 --> 0:20:15,006
这个发现很有用

680
00:20:15,006 --> 0:20:16,016
因为你完全可以

681
00:20:16,016 --> 0:20:17,966
把这个布局想成

682
00:20:17,966 --> 0:20:19,886
和之前的无边框布局

683
00:20:19,886 --> 0:20:21,616
几乎完全一样的计算

684
00:20:22,726 --> 0:20:25,016
每个项目都会分配到

685
00:20:25,016 --> 0:20:26,476
与之前给的无边框方块

686
00:20:26,476 --> 0:20:28,256
一样的方块中

687
00:20:28,716 --> 0:20:30,046
但在这个例子里

688
00:20:30,046 --> 0:20:32,406
我们决定不通过

689
00:20:32,406 --> 0:20:33,576
设定项目的大小

690
00:20:33,576 --> 0:20:34,886
使其占据所分配的整个正方形

691
00:20:34,976 --> 0:20:37,156
而是在最后 通过每个边上的

692
00:20:37,156 --> 0:20:40,096
五个点 来嵌入项目的内容

693
00:20:40,226 --> 0:20:41,706
所以这时候 项目的内容

694
00:20:41,706 --> 0:20:42,686
就很有用了

695
00:20:42,686 --> 0:20:45,136
而这个最后的步骤

696
00:20:45,136 --> 0:20:46,896
是从已计算过的布局中减去一部分

697
00:20:47,426 --> 0:20:48,066
这真的很棒

698
00:20:48,066 --> 0:20:50,196
我们看过了如何创建列表和网格

699
00:20:50,436 --> 0:20:51,896
还通过定义项目的大小

700
00:20:52,216 --> 0:20:54,726
创建了网格

701
00:20:55,096 --> 0:20:55,896
这里还有一种很好的方法

702
00:20:55,946 --> 0:20:58,306
可以用来创建

703
00:20:58,416 --> 0:21:00,596
含有行和列的网格状布局

704
00:20:58,416 --> 0:21:00,596
含有行和列的网格状布局

705
00:21:01,636 --> 0:21:02,806
我在这里展示给你们

706
00:21:02,806 --> 0:21:03,746
这样就能熟悉它了

707
00:21:04,366 --> 0:21:05,126
这里我打开

708
00:21:05,126 --> 0:21:06,636
两列的网格示例

709
00:21:07,166 --> 0:21:09,956
从表面上看起来

710
00:21:09,956 --> 0:21:11,016
这和五列的网格很像

711
00:21:11,016 --> 0:21:13,366
只是这里的列更少 

712
00:21:13,366 --> 0:21:15,446
的确 如果我把它转过来

713
00:21:15,446 --> 0:21:17,056
它就变成了这样

714
00:21:17,056 --> 0:21:18,936
仍然保持两列不变

715
00:21:19,426 --> 0:21:20,606
而每个项目都扩展到了适当宽度

716
00:21:21,696 --> 0:21:22,886
但是这与之前的做法

717
00:21:22,886 --> 0:21:24,426
还是有所不同的

718
00:21:24,426 --> 0:21:25,376
所以我们有必要讲讲

719
00:21:25,926 --> 0:21:27,016
这里

720
00:21:27,016 --> 0:21:28,876
在 TwoColumnViewController 中

721
00:21:29,206 --> 0:21:30,506
我们要看的是

722
00:21:30,506 --> 0:21:31,556
createLayout 函数

723
00:21:33,056 --> 0:21:34,546
我们注意到 有趣的是

724
00:21:34,546 --> 0:21:36,146
这里又一次出现了

725
00:21:36,146 --> 0:21:39,096
项目 组 段和布局结构

726
00:21:39,096 --> 0:21:39,946
但我们首先要注意的

727
00:21:39,946 --> 0:21:42,006
这也许不会

728
00:21:42,006 --> 0:21:43,776
立刻表现出来

729
00:21:43,776 --> 0:21:45,406
即我们在创建代表着

730
00:21:45,406 --> 0:21:47,246
每一行的水平组时

731
00:21:47,246 --> 0:21:48,436
用了一种不太一样的方法

732
00:21:49,106 --> 0:21:50,516
我们用一种不同形式的

733
00:21:50,516 --> 0:21:52,276
初始化程序

734
00:21:52,276 --> 0:21:53,926
该程序有明确的计数参数

735
00:21:54,236 --> 0:21:56,066
这里我们就明确地设定

736
00:21:56,606 --> 0:21:58,676
每一组需要有两个项目

737
00:21:58,676 --> 0:22:01,236
即每行两个项目

738
00:21:58,676 --> 0:22:01,236
即每行两个项目

739
00:22:01,816 --> 0:22:02,466
如此一来

740
00:22:02,466 --> 0:22:03,576
组合布局就会

741
00:22:03,656 --> 0:22:05,356
自动计算出

742
00:22:05,356 --> 0:22:06,546
项目的宽度

743
00:22:06,546 --> 0:22:07,446
以满足这一设定

744
00:22:08,406 --> 0:22:10,226
我们在这里像往常一样

745
00:22:10,226 --> 0:22:11,396
设定一个项目的宽度

746
00:22:11,616 --> 0:22:13,506
我们假设它是容器的 100%

747
00:22:14,036 --> 0:22:15,366
但是顶部的值

748
00:22:15,366 --> 0:22:17,006
最终会被覆盖

749
00:22:17,006 --> 0:22:18,106
当你要求每一组都有

750
00:22:18,106 --> 0:22:19,586
一定数量的项目时

751
00:22:19,976 --> 0:22:21,336
组合布局

752
00:22:21,626 --> 0:22:22,616
该组合布局就会

753
00:22:22,616 --> 0:22:24,026
将其视为一种覆盖

754
00:22:24,326 --> 0:22:25,136
然后就会计算出

755
00:22:25,136 --> 0:22:26,246
真正能够满足

756
00:22:26,246 --> 0:22:28,316
我们要求的宽度

757
00:22:28,476 --> 0:22:29,936
我们也用一种不同的方法

758
00:22:29,936 --> 0:22:31,216
增加项目与项目

759
00:22:31,216 --> 0:22:32,286
之间的空间

760
00:22:32,286 --> 0:22:33,446
组合布局提供了

761
00:22:33,446 --> 0:22:34,906
很多方法来完成这一步

762
00:22:34,906 --> 0:22:36,486
这让 API 变得十分灵活

763
00:22:37,706 --> 0:22:39,666
在这个例子里

764
00:22:39,666 --> 0:22:42,216
我们不指定 itemInsets

765
00:22:42,826 --> 0:22:44,446
而是在段上指定 contentInsets

766
00:22:45,066 --> 0:22:46,306
这里 我想在左右两边

767
00:22:46,306 --> 0:22:47,616
都加上一点空白

768
00:22:47,616 --> 0:22:48,956
我们只有一个段

769
00:22:48,956 --> 0:22:50,856
所以这基本上就是我们整个的布局

770
00:22:51,336 --> 0:22:53,236
我们想要 10 个点的前导间隔

771
00:22:53,236 --> 0:22:55,776
和 10 个点的尾随间隔

772
00:22:56,846 --> 0:22:58,266
注意当我们在这行代码上时

773
00:22:58,266 --> 0:23:00,836
组合布局的设计会促使你

774
00:22:58,266 --> 0:23:00,836
组合布局的设计会促使你

775
00:23:00,836 --> 0:23:02,626
用不确定布局方向的方式

776
00:23:02,626 --> 0:23:05,556
来表达你的布局

777
00:23:05,556 --> 0:23:07,776
所以不用明确指出左右

778
00:23:07,776 --> 0:23:09,526
我们只用指定

779
00:23:09,526 --> 0:23:10,676
前导和尾随

780
00:23:10,856 --> 0:23:12,316
这样真的很棒

781
00:23:12,316 --> 0:23:13,726
因为当你用一种从右到左的语言

782
00:23:13,726 --> 0:23:15,156
运行 App 的时候

783
00:23:15,156 --> 0:23:17,146
你会自动得到

784
00:23:17,146 --> 0:23:18,206
正确的布局

785
00:23:19,156 --> 0:23:23,106
这里我们也用到一个组的属性

786
00:23:23,106 --> 0:23:24,896
叫做 interItemSpacing

787
00:23:24,896 --> 0:23:26,416
我们请求一个组

788
00:23:26,416 --> 0:23:27,666
在其项目之间增加一定量的空间

789
00:23:27,696 --> 0:23:29,256
在这个例子中

790
00:23:29,316 --> 0:23:31,516
我们将其设为 10 个点

791
00:23:31,806 --> 0:23:34,246
其他的都与前面的例子

792
00:23:34,246 --> 0:23:35,506
非常相似

793
00:23:35,506 --> 0:23:36,776
我们只用那个方法

794
00:23:36,776 --> 0:23:39,206
来明确指定每一组的项目数

795
00:23:40,566 --> 0:23:41,586
这样就相当不错

796
00:23:42,356 --> 0:23:43,606
但 Steve 之前提到了

797
00:23:43,696 --> 0:23:44,916
另一种很棒的功能

798
00:23:44,916 --> 0:23:45,876
我想深入讲讲

799
00:23:46,916 --> 0:23:48,326
他提到每个段

800
00:23:48,326 --> 0:23:50,476
都可以有不同的布局

801
00:23:50,476 --> 0:23:51,816
目前为止我们只看了

802
00:23:51,816 --> 0:23:53,586
一个段的布局

803
00:23:53,586 --> 0:23:54,546
但要是我们想要有多个段呢

804
00:23:54,546 --> 0:23:56,456
而且每个段还要有

805
00:23:56,456 --> 0:23:57,856
不同的布局呢

806
00:23:58,746 --> 0:23:59,926
下面打开不同的

807
00:23:59,926 --> 0:24:00,866
段的示例

808
00:23:59,926 --> 0:24:00,866
段的示例

809
00:24:02,106 --> 0:24:03,616
现在这个布局

810
00:24:03,616 --> 0:24:04,876
有点像我们之前讲过的

811
00:24:04,876 --> 0:24:05,686
示例的合成

812
00:24:05,936 --> 0:24:07,726
在这个布局中有三个段

813
00:24:08,726 --> 0:24:11,446
第一段是一个简单的

814
00:24:11,446 --> 0:24:13,326
类似于之前的单列列表

815
00:24:14,126 --> 0:24:16,006
第二段是一个正方形项目的

816
00:24:16,006 --> 0:24:16,806
五列网格

817
00:24:16,806 --> 0:24:18,876
第三段则是一个长方形项目的

818
00:24:18,876 --> 0:24:20,266
三列网格

819
00:24:21,176 --> 0:24:22,976
那我们该怎么做呢

820
00:24:24,346 --> 0:24:25,076
首先打开

821
00:24:25,076 --> 0:24:26,616
DistinctSectionsViewController

822
00:24:26,616 --> 0:24:28,586
看 createLayout 函数

823
00:24:30,126 --> 0:24:31,456
第一眼看上去

824
00:24:31,456 --> 0:24:32,406
它好像和之前完全不同

825
00:24:32,406 --> 0:24:33,946
但实际上只是

826
00:24:33,946 --> 0:24:35,206
最外层的组件不同

827
00:24:35,206 --> 0:24:36,386
相比我们先前例示的布局

828
00:24:36,386 --> 0:24:37,486
它不是在结尾

829
00:24:37,486 --> 0:24:38,666
而是在开头

830
00:24:39,306 --> 0:24:40,166
原因是这样

831
00:24:40,766 --> 0:24:42,336
当我们例示组合布局时

832
00:24:42,336 --> 0:24:43,596
用的是一个初始化程序

833
00:24:43,596 --> 0:24:45,356
该程序将提供段的闭包

834
00:24:45,356 --> 0:24:47,066
视为其参数

835
00:24:47,066 --> 0:24:48,526
这是 Steve 提到过的

836
00:24:49,286 --> 0:24:50,656
提供段的闭包

837
00:24:50,656 --> 0:24:52,406
是一个任意代码块

838
00:24:52,406 --> 0:24:54,596
因此你们可以想象

839
00:24:54,596 --> 0:24:56,756
你可以通过返回任何类型的

840
00:24:56,756 --> 0:24:58,396
你想要的段的布局

841
00:24:58,396 --> 0:25:00,296
来对这个被调用做出响应

842
00:24:58,396 --> 0:25:00,296
来对这个被调用做出响应

843
00:25:01,096 --> 0:25:02,516
传两个指明具体段的参数

844
00:25:03,206 --> 0:25:04,376
即两个段指数参数

845
00:25:04,376 --> 0:25:05,186
在这个例子里

846
00:25:05,186 --> 0:25:06,606
将会是 0 1 或 2

847
00:25:07,596 --> 0:25:08,976
一个布局环境

848
00:25:08,976 --> 0:25:10,106
包含了各种

849
00:25:10,106 --> 0:25:11,326
你可以查到的有用属性

850
00:25:11,326 --> 0:25:13,076
那个我们待会再看

851
00:25:14,536 --> 0:25:16,676
这个闭包里的

852
00:25:16,676 --> 0:25:17,796
其他东西都只是

853
00:25:17,796 --> 0:25:18,956
和之前一样的代码

854
00:25:19,026 --> 0:25:21,446
我们指定一个项目的描述

855
00:25:22,066 --> 0:25:24,576
然后将其嵌入一个组的描述

856
00:25:25,056 --> 0:25:27,026
最后 我们指定

857
00:25:27,026 --> 0:25:28,256
一个段的描述

858
00:25:28,256 --> 0:25:29,166
这就是提供段的闭包

859
00:25:29,166 --> 0:25:30,386
所返回的内容

860
00:25:30,996 --> 0:25:32,966
组合布局会

861
00:25:32,966 --> 0:25:34,156
在需要重新查询

862
00:25:34,156 --> 0:25:35,866
一个对特定段的

863
00:25:35,866 --> 0:25:38,666
新的描述时

864
00:25:38,666 --> 0:25:39,676
自动调用这个闭包

865
00:25:40,346 --> 0:25:42,126
这里的内容就与

866
00:25:42,126 --> 0:25:43,266
之前的十分相似

867
00:25:44,126 --> 0:25:45,466
有趣的是

868
00:25:45,466 --> 0:25:46,516
使各种布局有所区分的

869
00:25:46,516 --> 0:25:47,886
主要是每个布局中

870
00:25:47,886 --> 0:25:49,116
列的数量不同

871
00:25:49,846 --> 0:25:50,746
我们已经有

872
00:25:50,746 --> 0:25:52,966
这个 SectionLayoutKind 类型

873
00:25:52,966 --> 0:25:54,376
它在源文件的顶端

874
00:25:54,376 --> 0:25:55,416
我们来看一下

875
00:25:55,416 --> 0:25:56,846
当我们将它初始化

876
00:25:56,886 --> 0:25:58,506
我们就进入到段指数中

877
00:25:58,506 --> 0:25:59,816
该指数为 0 1 或 2

878
00:26:00,626 --> 0:26:02,666
它要做的就是将其映射到

879
00:26:02,666 --> 0:26:04,476
一个告诉我们

880
00:26:04,476 --> 0:26:05,606
SectionLayoutKind 要么是一个列表

881
00:26:05,606 --> 0:26:08,306
要么是网格 5 或网格 3

882
00:26:08,306 --> 0:26:08,906
的枚举类型中

883
00:26:09,126 --> 0:26:11,696
我们还添加了 columnCount

884
00:26:11,896 --> 0:26:13,436
这个方便易得的属性

885
00:26:13,436 --> 0:26:14,636
这里我们可以直接请求

886
00:26:14,636 --> 0:26:16,636
该 SectionLayoutKind 值

887
00:26:16,636 --> 0:26:18,136
即在该布局中应有多少列

888
00:26:18,646 --> 0:26:21,056
回到我们的 createLayout 函数

889
00:26:21,056 --> 0:26:22,376
我们能看到在我们请求

890
00:26:22,376 --> 0:26:24,356
该 columnCount 的地方

891
00:26:24,356 --> 0:26:25,556
有两处不同应用

892
00:26:25,866 --> 0:26:29,436
在两列网格的示例里

893
00:26:29,436 --> 0:26:31,256
当我们将水平的组

894
00:26:31,256 --> 0:26:32,796
初始化时

895
00:26:32,796 --> 0:26:34,836
我们明确指定了

896
00:26:34,836 --> 0:26:35,826
想要的列的数量

897
00:26:36,616 --> 0:26:38,866
因此我们就交给复合布局

898
00:26:38,956 --> 0:26:40,506
来自动算出

899
00:26:40,506 --> 0:26:42,006
所含的是哪种项目宽度

900
00:26:42,276 --> 0:26:43,676
我们还用列的数量

901
00:26:43,676 --> 0:26:45,716
来决定布局中的

902
00:26:45,716 --> 0:26:46,936
组或行的高度

903
00:26:46,936 --> 0:26:48,416
来区分布局

904
00:26:48,416 --> 0:26:50,516
你可以选择你想用的方法

905
00:26:50,806 --> 0:26:52,816
真的很不错

906
00:26:52,816 --> 0:26:53,856
但如果我们想要

907
00:26:53,856 --> 0:26:56,066
调整这个布局呢

908
00:26:56,066 --> 0:26:58,596
如果我们将手机转过来

909
00:26:59,306 --> 0:27:00,726
可能空间就没有被

910
00:26:59,306 --> 0:27:00,726
可能空间就没有被

911
00:27:00,726 --> 0:27:01,776
充分利用了

912
00:27:02,526 --> 0:27:03,906
或许我们可以放更多的项目

913
00:27:04,866 --> 0:27:06,836
那我们就来看看自适应段布局

914
00:27:07,856 --> 0:27:09,276
第一眼看上去

915
00:27:09,276 --> 0:27:10,926
这和上一个例子一模一样

916
00:27:11,336 --> 0:27:13,896
但旋转过来之后

917
00:27:13,896 --> 0:27:15,216
我们发现第一段

918
00:27:15,216 --> 0:27:16,846
调整显示为两列

919
00:27:16,846 --> 0:27:18,806
第二段调整为十列

920
00:27:18,806 --> 0:27:21,766
第三段调整为六列

921
00:27:22,486 --> 0:27:24,176
这个代码应该怎么写呢

922
00:27:24,616 --> 0:27:26,976
其实和前一个例子很像

923
00:27:28,586 --> 0:27:29,196
下面打开

924
00:27:29,356 --> 0:27:31,096
AdaptiveSectionsViewController

925
00:27:31,156 --> 0:27:33,076
看 createLayout 函数

926
00:27:33,076 --> 0:27:36,676
这和前一个例子很像

927
00:27:36,786 --> 0:27:37,576
我们最先注意到的不同

928
00:27:37,576 --> 0:27:39,366
就是我们改变了

929
00:27:39,366 --> 0:27:41,376
SectionLayoutKind 的类型

930
00:27:42,026 --> 0:27:42,696
这里仍然有

931
00:27:42,696 --> 0:27:43,866
SectionLayoutKind

932
00:27:44,286 --> 0:27:45,786
但 columnCount 不再只是

933
00:27:45,786 --> 0:27:47,326
一个可获取的属性

934
00:27:47,406 --> 0:27:48,796
而是有一个参数的函数

935
00:27:48,796 --> 0:27:52,396
这里我们给它传一个

936
00:27:52,556 --> 0:27:55,286
从 layoutEnvironment 里获得的宽度

937
00:27:55,286 --> 0:27:56,746
该 layoutEnvironment 类型里

938
00:27:57,056 --> 0:27:58,366
就包含了一些信息

939
00:27:58,406 --> 0:27:59,806
比如你的布局所要处理的

940
00:28:00,056 --> 0:28:01,386
总的容器宽度

941
00:28:01,896 --> 0:28:04,046
在 iOS 上它还包含

942
00:28:04,046 --> 0:28:05,666
特征集合信息

943
00:28:05,846 --> 0:28:07,076
因此你可以用这些信息

944
00:28:07,076 --> 0:28:08,906
来计算出

945
00:28:08,906 --> 0:28:10,116
什么样的布局

946
00:28:10,116 --> 0:28:11,336
适合现在的环境

947
00:28:11,826 --> 0:28:13,276
这里我们只使用宽度

948
00:28:13,276 --> 0:28:16,476
如果我们看看顶部

949
00:28:16,476 --> 0:28:18,026
我们在这里用了 SectionLayoutKind

950
00:28:18,806 --> 0:28:19,946
我们可以发现该 columnCount 函数

951
00:28:19,946 --> 0:28:21,416
现在是一个函数

952
00:28:21,796 --> 0:28:24,096
它接受我们传入的宽度参数

953
00:28:24,096 --> 0:28:25,106
在这个例子里

954
00:28:25,106 --> 0:28:26,616
这是 CollectionView 的宽度

955
00:28:26,986 --> 0:28:28,236
我们基本上实现了

956
00:28:28,236 --> 0:28:28,926
一个布局改变

957
00:28:29,326 --> 0:28:30,906
我们决定如果在我们的设备上

958
00:28:30,906 --> 0:28:32,696
需要处理大于

959
00:28:32,696 --> 0:28:34,106
800 个点的宽度

960
00:28:34,106 --> 0:28:36,126
我们会用 wideMode

961
00:28:36,566 --> 0:28:38,896
在 wideMode 里我们只要

962
00:28:38,896 --> 0:28:40,946
在每个段中返回大量的列

963
00:28:41,646 --> 0:28:43,266
就可以完成

964
00:28:43,436 --> 0:28:44,566
如果我们返回 creatLayout 函数

965
00:28:44,566 --> 0:28:45,766
我们就会发现

966
00:28:45,766 --> 0:28:47,336
当我们得到列的数量后

967
00:28:47,336 --> 0:28:49,646
我们所用的方法

968
00:28:49,646 --> 0:28:51,936
可能还是和以前差不多

969
00:28:51,936 --> 0:28:53,506
所以我们不用改变太多代码

970
00:28:53,716 --> 0:28:55,266
就可以得到一个自适应

971
00:28:55,266 --> 0:28:57,426
旋转的布局

972
00:28:57,956 --> 0:29:00,396
这样就很不错

973
00:28:57,956 --> 0:29:00,396
这样就很不错

974
00:29:00,506 --> 0:29:02,006
但目前为止

975
00:29:02,006 --> 0:29:03,306
我们只讨论了项目

976
00:29:03,306 --> 0:29:05,136
我们甚至还没有深入探讨

977
00:29:05,136 --> 0:29:07,516
我们可以用补充视图

978
00:29:07,516 --> 0:29:08,836
和装饰视图做什么

979
00:29:09,056 --> 0:29:09,916
我最喜欢组合布局的

980
00:29:09,916 --> 0:29:10,866
一点是

981
00:29:10,866 --> 0:29:12,776
它使事情变得

982
00:29:12,776 --> 0:29:14,926
前所未有地简单

983
00:29:14,926 --> 0:29:17,046
我们能够超出页眉和页脚

984
00:29:17,046 --> 0:29:18,136
使用你自己设计的

985
00:29:18,246 --> 0:29:21,276
任意的补充视图

986
00:29:21,856 --> 0:29:24,336
接下来的部分

987
00:29:24,336 --> 0:29:25,646
我们将进入

988
00:29:25,646 --> 0:29:26,976
一些更高级的话题

989
00:29:26,976 --> 0:29:28,556
一些你可以用组合布局

990
00:29:28,556 --> 0:29:29,896
完成的很棒的事情

991
00:29:29,896 --> 0:29:31,866
下面就继续交给我的同事 Steve

992
00:29:32,016 --> 0:29:32,496
谢谢

993
00:29:33,516 --> 0:29:37,876
[掌声]

994
00:29:38,376 --> 0:29:39,336
&gt;&gt; 既然我们已经

995
00:29:39,336 --> 0:29:40,856
看过基本的工作原理

996
00:29:41,026 --> 0:29:41,896
知道如何创建

997
00:29:41,896 --> 0:29:42,806
和运行组合布局

998
00:29:42,806 --> 0:29:44,736
接下来我就要带大家进入

999
00:29:44,856 --> 0:29:46,106
更高级的话题了

1000
00:29:46,106 --> 0:29:47,326
因为我们有很多种方法

1001
00:29:47,326 --> 0:29:48,936
可以用组合布局

1002
00:29:48,936 --> 0:29:50,046
来创建自定布局

1003
00:29:50,806 --> 0:29:53,926
首先我要接着

1004
00:29:53,926 --> 0:29:55,476
谈一谈补充项目

1005
00:29:56,616 --> 0:29:58,126
CollectionView 可以做三个基本的

1006
00:29:58,126 --> 0:30:00,086
视图类类型

1007
00:29:58,126 --> 0:30:00,086
视图类类型

1008
00:30:00,086 --> 0:30:01,486
包括储存格 即用来表示

1009
00:30:01,486 --> 0:30:02,906
模型对象的交互对象

1010
00:30:02,906 --> 0:30:04,966
同时它也代表着

1011
00:30:05,136 --> 0:30:07,736
补充项目和装饰项目

1012
00:30:08,446 --> 0:30:10,236
它们是为了装饰

1013
00:30:10,236 --> 0:30:11,296
布局的其他部分 

1014
00:30:11,296 --> 0:30:12,786
来给你一些关于内容信息的

1015
00:30:12,926 --> 0:30:14,436
视觉提示 比如

1016
00:30:14,436 --> 0:30:16,106
一个储存格上的标记会说

1017
00:30:16,106 --> 0:30:17,076
“嘿 你有一条推特评论”

1018
00:30:17,076 --> 0:30:17,816
或其他什么

1019
00:30:18,946 --> 0:30:20,906
今天我们会看到一些

1020
00:30:20,946 --> 0:30:22,886
这三个例子的常见用法

1021
00:30:22,966 --> 0:30:24,776
即标记 页眉和页脚

1022
00:30:25,186 --> 0:30:26,766
现在我们有流支持

1023
00:30:26,766 --> 0:30:28,406
以及粘性的页眉和页脚

1024
00:30:28,406 --> 0:30:29,876
它们在内容上方浮动

1025
00:30:30,176 --> 0:30:32,086
但我们可以在

1026
00:30:32,086 --> 0:30:32,946
组合布局里进行扩展

1027
00:30:32,946 --> 0:30:34,166
使其变得更容易

1028
00:30:34,616 --> 0:30:36,776
我们可以用这个概念简化它

1029
00:30:36,776 --> 0:30:37,836
将内容锚定在

1030
00:30:37,836 --> 0:30:42,036
你布局的一个项目或组上

1031
00:30:42,036 --> 0:30:43,276
这样可以简化视觉关系

1032
00:30:43,276 --> 0:30:44,536
这是怎么做到的呢

1033
00:30:44,536 --> 0:30:47,496
我们来直观地看一下

1034
00:30:47,496 --> 0:30:50,406
这里 我们能看到

1035
00:30:50,576 --> 0:30:51,416
有一个新的类型

1036
00:30:51,646 --> 0:30:52,876
NSCollectionLayoutAnchor

1037
00:30:53,586 --> 0:30:54,986
我们在这里设定

1038
00:30:55,186 --> 0:30:56,896
这两种类型的关系

1039
00:30:56,896 --> 0:30:58,066
我们的补充物就会

1040
00:30:58,066 --> 0:31:00,216
通过与一个主空间

1041
00:30:58,066 --> 0:31:00,216
通过与一个主空间

1042
00:31:00,216 --> 0:31:02,016
一个项目或组的几何形状

1043
00:31:02,016 --> 0:31:04,326
相对应的方式被锚定

1044
00:31:04,986 --> 0:31:06,956
这非常容易推出

1045
00:31:09,466 --> 0:31:11,766
那这里我们马上看到

1046
00:31:11,766 --> 0:31:14,276
我们创建的 NSCollectionLayoutAnchor

1047
00:31:14,276 --> 0:31:15,376
我们指定边缘

1048
00:31:15,376 --> 0:31:16,716
我们想要把这个项目固定在

1049
00:31:16,716 --> 0:31:20,156
该储存格顶端的尾随边

1050
00:31:20,836 --> 0:31:22,656
我们想让它稍微

1051
00:31:23,076 --> 0:31:24,106
超出几何图形

1052
00:31:24,106 --> 0:31:25,276
我们可以用分数高度

1053
00:31:27,106 --> 0:31:29,416
这里我们能看到这个设备

1054
00:31:29,416 --> 0:31:31,066
我们已经放上了这些标记

1055
00:31:31,606 --> 0:31:33,096
得益于我精湛的设计技巧

1056
00:31:33,096 --> 0:31:34,396
这里有一个四个项目的网格

1057
00:31:34,846 --> 0:31:36,696
由浅蓝色的储存格组成

1058
00:31:37,296 --> 0:31:38,476
这里我们能看到

1059
00:31:38,476 --> 0:31:39,436
在一些项目上

1060
00:31:39,436 --> 0:31:40,246
有小的通知标记 

1061
00:31:40,246 --> 0:31:41,146
它们是在说

1062
00:31:41,146 --> 0:31:42,396
“嘿 你需要注意这里”

1063
00:31:43,576 --> 0:31:45,626
而这里的这些标记

1064
00:31:45,626 --> 0:31:47,456
就稍稍超出了几何图形

1065
00:31:47,676 --> 0:31:48,486
它们不完全在

1066
00:31:48,486 --> 0:31:49,676
储存格的几何图形里面

1067
00:31:50,376 --> 0:31:51,486
我们回到幻灯片上

1068
00:31:51,486 --> 0:31:52,686
快速浏览一下

1069
00:31:53,076 --> 0:31:56,156
就是 fractionalOffset

1070
00:31:56,156 --> 0:31:58,306
使它们能稍稍超出几何图形

1071
00:31:58,306 --> 0:31:59,096
现在我们将

1072
00:31:59,096 --> 0:32:01,406
在正 X 上移动 30% 

1073
00:31:59,096 --> 0:32:01,406
在正 X 上移动 30% 

1074
00:32:01,406 --> 0:32:04,436
然后在负 Y 上也移动30%

1075
00:32:04,916 --> 0:32:06,646
然后我们用

1076
00:32:06,646 --> 0:32:07,956
badgeSize 和 elementKind 定义

1077
00:32:07,956 --> 0:32:11,156
CollectionLayoutSupplementaryItem

1078
00:32:11,156 --> 0:32:12,046
我们要用

1079
00:32:12,046 --> 0:32:12,766
已注册的补充类型 

1080
00:32:12,766 --> 0:32:13,606
重新回到

1081
00:32:13,666 --> 0:32:14,846
CollectionView 的视图类

1082
00:32:15,486 --> 0:32:17,426
然后我们指定容器的锚

1083
00:32:17,426 --> 0:32:19,796
指定它如何进行关联

1084
00:32:19,796 --> 0:32:21,456
既然我们有了

1085
00:32:21,496 --> 0:32:22,856
这个补充物的定义

1086
00:32:22,856 --> 0:32:24,516
就要把它和一些东西关联起来

1087
00:32:24,786 --> 0:32:26,086
我们要把它与一个项目

1088
00:32:26,416 --> 0:32:28,476
一个储存格相关联

1089
00:32:29,026 --> 0:32:30,226
在这个例子中

1090
00:32:30,226 --> 0:32:31,686
我们要用一个带有

1091
00:32:31,686 --> 0:32:33,346
一系列补充物的初始化程序

1092
00:32:33,346 --> 0:32:34,456
的扩展变体

1093
00:32:34,456 --> 0:32:35,566
来进行初始化

1094
00:32:35,566 --> 0:32:39,476
就是这样

1095
00:32:39,476 --> 0:32:41,146
页眉和页脚呢

1096
00:32:41,486 --> 0:32:43,166
页眉和页脚

1097
00:32:43,166 --> 0:32:44,696
与这些项目的补充物

1098
00:32:44,696 --> 0:32:45,886
只有一点点不同

1099
00:32:45,886 --> 0:32:47,326
当你想到

1100
00:32:47,326 --> 0:32:48,776
用一个补充页眉和页脚

1101
00:32:48,776 --> 0:32:50,566
来装饰的内容时

1102
00:32:51,276 --> 0:32:52,226
你并不想让

1103
00:32:52,226 --> 0:32:53,106
补充页眉或页脚

1104
00:32:53,106 --> 0:32:54,726
遮挡住真正的内容

1105
00:32:54,726 --> 0:32:56,596
需要扩展内容的区域

1106
00:32:56,596 --> 0:32:58,096
以便看到内容本身

1107
00:32:59,186 --> 0:33:00,466
在这个例子里

1108
00:32:59,186 --> 0:33:00,466
在这个例子里

1109
00:33:00,466 --> 0:33:01,666
我们有很多不同的补充物

1110
00:33:01,666 --> 0:33:03,886
叫做边界补充物

1111
00:33:03,946 --> 0:33:04,936
我们要把它放在

1112
00:33:04,936 --> 0:33:06,346
主几何图形的补充物

1113
00:33:06,346 --> 0:33:07,426
的边界上

1114
00:33:08,636 --> 0:33:09,706
我们可以为段或整个布局

1115
00:33:09,706 --> 0:33:11,136
制作这些边界补充物

1116
00:33:11,136 --> 0:33:13,316
我们可以将它们

1117
00:33:13,316 --> 0:33:14,716
固定在这整个平衡中

1118
00:33:14,716 --> 0:33:16,056
完成一些很棒的布局

1119
00:33:16,726 --> 0:33:18,196
下面我将切换到

1120
00:33:18,196 --> 0:33:19,226
设备上的例子

1121
00:33:20,726 --> 0:33:21,856
就是这样

1122
00:33:22,106 --> 0:33:24,586
我们看看这个例子

1123
00:33:25,146 --> 0:33:27,206
很简单易懂的例子

1124
00:33:27,206 --> 0:33:29,146
这里有一个固定在段上

1125
00:33:29,146 --> 0:33:30,136
的页眉和页脚

1126
00:33:30,616 --> 0:33:31,676
上下滑动

1127
00:33:31,676 --> 0:33:33,926
发现这就是我们想要的

1128
00:33:34,186 --> 0:33:34,786
下面来看代码

1129
00:33:38,716 --> 0:33:40,296
这个和几分钟前说到的

1130
00:33:40,296 --> 0:33:42,326
BoundarySupplementaryItems 代码很像

1131
00:33:42,786 --> 0:33:44,016
现在除了这个容器锚

1132
00:33:44,086 --> 0:33:45,636
这里还有

1133
00:33:45,636 --> 0:33:46,726
对齐属性

1134
00:33:47,706 --> 0:33:49,896
这里为页眉指定了顶部

1135
00:33:49,896 --> 0:33:51,116
为页脚指定了底部

1136
00:33:51,116 --> 0:33:52,316
因为想到达几何图形的

1137
00:33:52,316 --> 0:33:53,786
段的顶部和底部

1138
00:33:54,456 --> 0:33:55,806
为了确保页眉浮动

1139
00:33:55,806 --> 0:33:57,566
并固定在段中

1140
00:33:57,616 --> 0:33:58,876
它所在的内容区域

1141
00:33:58,876 --> 0:34:00,616
我们只需指定

1142
00:33:58,876 --> 0:34:00,616
我们只需指定

1143
00:34:00,616 --> 0:34:02,046
PinToVisibleBounds

1144
00:34:02,306 --> 0:34:04,526
接着我们需要将页眉和页脚

1145
00:34:04,526 --> 0:34:05,516
与它们要进入的

1146
00:34:05,516 --> 0:34:06,466
几何图形关联起来

1147
00:34:06,466 --> 0:34:07,256
也就是段

1148
00:34:07,446 --> 0:34:08,315
这里我们就用

1149
00:34:08,315 --> 0:34:10,016
BoundarySupplementaryItems 阵列

1150
00:34:11,016 --> 0:34:11,735
很简单吧

1151
00:34:12,886 --> 0:34:15,196
目前为止我们展示时

1152
00:34:15,196 --> 0:34:17,255
都用的是全新的 iOS 13 卡片

1153
00:34:17,255 --> 0:34:18,766
这种卡片设计语言

1154
00:34:19,156 --> 0:34:20,976
贯穿整个系统

1155
00:34:21,936 --> 0:34:23,666
我们在滚动 UI 中也能看到 

1156
00:34:23,826 --> 0:34:26,156
各种各样的内容

1157
00:34:26,156 --> 0:34:27,306
都用卡片

1158
00:34:27,366 --> 0:34:28,815
以逻辑方式组合在一起

1159
00:34:29,136 --> 0:34:30,556
这自然很适合 CollectionView

1160
00:34:30,556 --> 0:34:31,426
因为我们一直

1161
00:34:31,426 --> 0:34:33,536
支持装饰视图的概念

1162
00:34:33,536 --> 0:34:36,446
在过去你需要自己进行运算

1163
00:34:36,446 --> 0:34:37,156
但在组合布局里

1164
00:34:37,156 --> 0:34:39,056
这就变得很简单

1165
00:34:39,666 --> 0:34:41,166
我们用一个

1166
00:34:41,196 --> 0:34:42,706
CollectionLayoutDecorationItem 进行支持

1167
00:34:43,025 --> 0:34:43,696
你只要用一个 elementKind

1168
00:34:43,696 --> 0:34:44,976
来创建它就可以了

1169
00:34:45,746 --> 0:34:47,436
这么做是为了

1170
00:34:47,436 --> 0:34:49,045
在段的内容之后

1171
00:34:49,045 --> 0:34:50,485
产生一个视图

1172
00:34:50,485 --> 0:34:51,866
以提供良好的视觉分组

1173
00:34:52,646 --> 0:34:54,315
想要创建它

1174
00:34:54,315 --> 0:34:55,206
只需要一行代码

1175
00:34:55,206 --> 0:34:55,996
想要将它加到段里

1176
00:34:55,996 --> 0:34:57,896
你只要指定项目

1177
00:34:58,116 --> 0:35:00,116
这样就可以了

1178
00:34:58,116 --> 0:35:00,116
这样就可以了

1179
00:35:01,076 --> 0:35:01,696
就是这样

1180
00:35:02,256 --> 0:35:03,816
那我们来快速浏览一下

1181
00:35:03,816 --> 0:35:04,446
这组代码的结果

1182
00:35:04,876 --> 0:35:08,586
非常简单也非常直观

1183
00:35:08,976 --> 0:35:09,906
这是包含多个段的列表

1184
00:35:09,906 --> 0:35:11,196
我们增加了装饰视图

1185
00:35:11,196 --> 0:35:14,096
只用了一行代码

1186
00:35:14,226 --> 0:35:14,946
很简单

1187
00:35:17,756 --> 0:35:20,306
下面是一个我

1188
00:35:20,306 --> 0:35:21,356
非常关心的话题

1189
00:35:21,356 --> 0:35:22,176
估算自定尺寸

1190
00:35:23,466 --> 0:35:25,436
在 iOS 13 中我们花了

1191
00:35:25,436 --> 0:35:27,836
很多时间来确保其速度快 准确性高

1192
00:35:29,436 --> 0:35:30,806
组合布局以非常具体的方式

1193
00:35:30,806 --> 0:35:31,766
扩展了估算自定尺寸

1194
00:35:31,766 --> 0:35:34,406
这一概念

1195
00:35:34,406 --> 0:35:36,616
它允许你按每个轴来确定尺寸

1196
00:35:36,616 --> 0:35:37,816
这非常重要

1197
00:35:38,496 --> 0:35:39,486
因为通常你想要

1198
00:35:39,486 --> 0:35:40,366
在你呈现内容时

1199
00:35:40,366 --> 0:35:41,606
得到良好的视图层次

1200
00:35:41,606 --> 0:35:43,086
你并不想要完全

1201
00:35:43,086 --> 0:35:44,736
被限制在轴线上

1202
00:35:44,866 --> 0:35:47,086
不想只能在 X 轴上

1203
00:35:47,086 --> 0:35:48,546
和 Y 轴上增长

1204
00:35:49,066 --> 0:35:50,286
比如你可能知道

1205
00:35:50,286 --> 0:35:51,296
这个东西的宽度

1206
00:35:52,216 --> 0:35:53,716
举一个页眉和页脚的例子

1207
00:35:53,716 --> 0:35:55,336
我们希望它的宽度

1208
00:35:55,336 --> 0:35:58,106
恰好是 CollectionView 的宽度

1209
00:35:58,266 --> 0:35:59,546
但是 我们希望它的高度

1210
00:35:59,546 --> 0:36:00,756
有一点变化

1211
00:35:59,546 --> 0:36:00,756
有一点变化

1212
00:36:01,386 --> 0:36:03,466
快速看一下这个例子

1213
00:36:03,466 --> 0:36:04,996
我们之前已经看过这个代码了

1214
00:36:05,636 --> 0:36:07,796
所以这里 我们看到非常熟悉的

1215
00:36:07,796 --> 0:36:10,206
段 页眉和页脚

1216
00:36:10,206 --> 0:36:11,216
然后我从这里下拉

1217
00:36:11,216 --> 0:36:14,566
打开文本大小部件 把它放大

1218
00:36:15,896 --> 0:36:18,326
这里所有的东西都变大了

1219
00:36:18,456 --> 0:36:19,746
这就对了 是吧

1220
00:36:20,096 --> 0:36:21,336
这是怎么做到的呢

1221
00:36:21,406 --> 0:36:23,756
这里我们能看到

1222
00:36:23,756 --> 0:36:25,306
heightDimension 是估算的

1223
00:36:25,656 --> 0:36:26,936
这就是唯一的不同

1224
00:36:26,936 --> 0:36:28,226
我们指定了

1225
00:36:28,226 --> 0:36:29,606
我们知道的确定宽度

1226
00:36:29,606 --> 0:36:31,676
但我们不知道具体高度

1227
00:36:31,676 --> 0:36:33,426
我们只是将其估算为 44 个点

1228
00:36:34,046 --> 0:36:35,316
随着内容的呈现

1229
00:36:35,686 --> 0:36:36,436
我们有了更好的想法

1230
00:36:36,436 --> 0:36:38,096
我们可以使布局自动作废

1231
00:36:38,096 --> 0:36:39,026
这些都是自动的

1232
00:36:39,396 --> 0:36:40,466
这使得你的 App

1233
00:36:40,466 --> 0:36:42,046
更容易支持动态类型

1234
00:36:42,046 --> 0:36:43,356
即使其中包含

1235
00:36:43,356 --> 0:36:44,776
补充物 页眉和页脚

1236
00:36:44,776 --> 0:36:46,536
所以 这是很不错的

1237
00:36:48,906 --> 0:36:49,926
现在我们来说一些

1238
00:36:49,926 --> 0:36:50,636
很有趣的东西

1239
00:36:50,636 --> 0:36:52,076
怎样嵌套呢

1240
00:36:52,186 --> 0:36:54,606
我们之前说过组成这个概念

1241
00:36:54,606 --> 0:36:56,646
我们来看看要怎么做

1242
00:36:57,436 --> 0:37:00,856
组合布局的

1243
00:36:57,436 --> 0:37:00,856
组合布局的

1244
00:37:00,856 --> 0:37:02,226
核心布局是布局组

1245
00:37:02,766 --> 0:37:04,416
布局组其实是

1246
00:37:04,416 --> 0:37:06,766
NSCollectionLayoutItem 的一个子类型 

1247
00:37:07,506 --> 0:37:09,006
因为有了这样的关系

1248
00:37:09,086 --> 0:37:11,186
当你指定一个

1249
00:37:11,186 --> 0:37:12,966
布局组中的项目时

1250
00:37:12,966 --> 0:37:14,826
你还可以有其他的组

1251
00:37:14,826 --> 0:37:15,736
你可以将它们嵌套

1252
00:37:15,736 --> 0:37:17,186
这个嵌套是没有限制的

1253
00:37:17,226 --> 0:37:18,636
它是任意的

1254
00:37:18,786 --> 0:37:21,086
因为这一点

1255
00:37:21,086 --> 0:37:24,146
我们解锁了很多有趣的新设计

1256
00:37:25,456 --> 0:37:27,076
那在这个例子里

1257
00:37:27,326 --> 0:37:29,456
我们看到一个组里有三个项目

1258
00:37:30,156 --> 0:37:32,006
我们看到在前导侧

1259
00:37:32,006 --> 0:37:33,716
有个大方块

1260
00:37:33,716 --> 0:37:37,246
在尾随侧有个垂直的组

1261
00:37:37,646 --> 0:37:39,436
那这个怎么在代码里推出呢

1262
00:37:43,906 --> 0:37:45,366
这个很简单

1263
00:37:45,366 --> 0:37:46,646
底部有一个

1264
00:37:46,646 --> 0:37:47,686
水平的组

1265
00:37:47,776 --> 0:37:49,546
其子项分别是

1266
00:37:49,546 --> 0:37:52,966
leadingItem 和一个 trailingGroup

1267
00:37:52,966 --> 0:37:54,236
我们很容易

1268
00:37:54,236 --> 0:37:55,186
推出这样的东西

1269
00:37:55,186 --> 0:37:56,786
我们现在就看看要怎么做

1270
00:37:56,786 --> 0:37:57,856
只需添加一些额外的东西

1271
00:37:57,856 --> 0:38:01,126
就可以得到这些很棒的布局

1272
00:37:57,856 --> 0:38:01,126
就可以得到这些很棒的布局

1273
00:38:02,056 --> 0:38:05,406
嵌套组是很有用的

1274
00:38:05,406 --> 0:38:08,446
嵌套 CollectionView 呢

1275
00:38:08,916 --> 0:38:10,266
好的

1276
00:38:10,266 --> 0:38:14,296
这里我们看到的是 App Store

1277
00:38:14,656 --> 0:38:16,756
是 iOS 13 的更新

1278
00:38:17,516 --> 0:38:18,396
我不知道你怎么看

1279
00:38:18,396 --> 0:38:19,146
但如果我是一个

1280
00:38:19,146 --> 0:38:20,116
第三方开发者时

1281
00:38:20,606 --> 0:38:21,826
要是交给我这样的设计

1282
00:38:21,826 --> 0:38:22,776
我会心脏病发作的

1283
00:38:22,846 --> 0:38:24,116
这真的很复杂

1284
00:38:24,116 --> 0:38:25,916
很有挑战性

1285
00:38:25,916 --> 0:38:27,496
因为有很多簿记工作要做

1286
00:38:27,596 --> 0:38:28,776
但这是一种常见的模式

1287
00:38:28,776 --> 0:38:30,376
在今天的 App 中

1288
00:38:30,526 --> 0:38:32,236
我们也经常看到它

1289
00:38:32,656 --> 0:38:34,686
要使其外观好性能棒

1290
00:38:34,686 --> 0:38:36,656
这一点就颇具挑战性

1291
00:38:36,656 --> 0:38:37,696
组合布局能用

1292
00:38:37,696 --> 0:38:39,456
一行代码来解决这个问题

1293
00:38:40,366 --> 0:38:41,836
下面我就给你们展示一个示例

1294
00:38:42,516 --> 0:38:47,500
[鼓掌]

1295
00:38:52,306 --> 0:38:54,246
这里的组

1296
00:38:54,246 --> 0:38:55,366
和之前的一样

1297
00:38:55,366 --> 0:38:56,146
但我们注意到这个组

1298
00:38:56,146 --> 0:38:57,126
铺得更平了

1299
00:38:57,126 --> 0:38:59,586
它大概占了容器宽度的 80%

1300
00:38:59,586 --> 0:39:02,376
这是一个垂直滚动的 CollectionView

1301
00:38:59,586 --> 0:39:02,376
这是一个垂直滚动的 CollectionView

1302
00:39:02,376 --> 0:39:03,706
里面有五个段

1303
00:39:04,576 --> 0:39:05,946
但每个段都可以

1304
00:39:05,946 --> 0:39:07,876
用这一行代码垂直滚动

1305
00:39:08,516 --> 0:39:15,396
[掌声]

1306
00:39:15,896 --> 0:39:18,086
这里有很多不同的变化

1307
00:39:18,086 --> 0:39:18,646
请容许我

1308
00:39:18,646 --> 0:39:19,536
切换到这里

1309
00:39:19,596 --> 0:39:21,846
我们有五种不同的方法

1310
00:39:21,846 --> 0:39:22,886
对 这里还有

1311
00:39:22,886 --> 0:39:24,416
我不想看到的无的情况

1312
00:39:24,996 --> 0:39:26,626
有两个连续函数的例子

1313
00:39:26,876 --> 0:39:29,176
然后是三个分页函数的例子

1314
00:39:29,626 --> 0:39:31,166
我将用可视的方式

1315
00:39:31,166 --> 0:39:34,666
来讲每个例子

1316
00:39:36,256 --> 0:39:38,396
先向大家演示我们

1317
00:39:39,136 --> 0:39:40,756
垂直滚动段的行为

1318
00:39:41,396 --> 0:39:42,956
正如你所期待的那样

1319
00:39:42,956 --> 0:39:44,696
这是一个十分简单的

1320
00:39:44,696 --> 0:39:46,896
滚动视图的行为 

1321
00:39:46,896 --> 0:39:48,376
这里有一个弹回 

1322
00:39:48,376 --> 0:39:51,446
这个很棒

1323
00:39:51,446 --> 0:39:52,506
我这么滑几个小时都不会烦

1324
00:39:52,986 --> 0:39:54,226
好了

1325
00:39:54,226 --> 0:39:56,006
这只是正常滚动视图的行为

1326
00:39:56,006 --> 0:39:57,186
但在连续函数里

1327
00:39:57,186 --> 0:39:58,846
我们还有一个另外的

1328
00:39:58,846 --> 0:40:00,516
流体滚动视图行为

1329
00:39:58,846 --> 0:40:00,516
流体滚动视图行为

1330
00:40:00,516 --> 0:40:02,316
我们称为 continuousGroupLeadingBoundary

1331
00:40:02,316 --> 0:40:03,356
这有点拗口

1332
00:40:03,356 --> 0:40:04,066
但描述得很到位

1333
00:40:04,476 --> 0:40:05,696
当我们滚动然后松手时

1334
00:40:05,696 --> 0:40:07,836
我们自然会停留在

1335
00:40:07,836 --> 0:40:09,426
该组语义前导

1336
00:40:09,426 --> 0:40:10,976
的边界上

1337
00:40:11,516 --> 0:40:15,286
[掌声]

1338
00:40:15,786 --> 0:40:16,966
鼓掌的人以前一定做过

1339
00:40:17,006 --> 0:40:18,496
定向内容偏移或提议过偏移

1340
00:40:18,496 --> 0:40:20,356
所以你们知道有多痛苦

1341
00:40:20,566 --> 0:40:21,696
好了

1342
00:40:21,696 --> 0:40:24,926
说完这个连续行为

1343
00:40:24,926 --> 0:40:26,216
我们来说说分页行为

1344
00:40:26,216 --> 0:40:27,276
这个也很酷

1345
00:40:27,276 --> 0:40:29,316
这就像是普通的

1346
00:40:29,316 --> 0:40:30,856
滚动视图分页行为

1347
00:40:30,856 --> 0:40:32,216
我们称之为分页

1348
00:40:33,266 --> 0:40:33,696
很有创意

1349
00:40:34,386 --> 0:40:35,526
在这里 我们能看到

1350
00:40:35,526 --> 0:40:36,866
无论用户用怎样的速度进行滚动

1351
00:40:36,866 --> 0:40:39,216
得到的都只是一页的内容

1352
00:40:39,216 --> 0:40:40,826
这个页面被定义为

1353
00:40:40,826 --> 0:40:42,596
默认滚动视图行为

1354
00:40:42,596 --> 0:40:44,796
它的宽度是 CollectionView 的宽度

1355
00:40:46,776 --> 0:40:48,866
这里还可以有两种变化 

1356
00:40:48,866 --> 0:40:50,596
你可能已经猜到了

1357
00:40:50,596 --> 0:40:52,636
接下来我们要说组分页的概念

1358
00:40:53,316 --> 0:40:54,526
现在我们有关于

1359
00:40:54,526 --> 0:40:55,906
一个组的语义概念

1360
00:40:55,906 --> 0:40:57,786
我们就就可以将组的大小

1361
00:40:57,786 --> 0:40:58,606
设置为页面的大小

1362
00:40:59,646 --> 0:41:01,696
这样真的很棒

1363
00:40:59,646 --> 0:41:01,696
这样真的很棒

1364
00:41:03,121 --> 0:41:05,121
[掌声]

1365
00:41:05,226 --> 0:41:06,276
这样你可以自动得到

1366
00:41:06,306 --> 0:41:07,996
没有遮挡的内容

1367
00:41:07,996 --> 0:41:08,976
你的内容总是

1368
00:41:08,976 --> 0:41:10,116
呈现在前面和中间

1369
00:41:10,356 --> 0:41:13,226
最后要说的是组分页居中

1370
00:41:13,226 --> 0:41:14,626
这个和组分页很像

1371
00:41:15,426 --> 0:41:16,976
但现在我们会自动把该组居中

1372
00:41:17,516 --> 0:41:20,546
[掌声]

1373
00:41:21,046 --> 0:41:21,836
对 看上去很棒

1374
00:41:22,636 --> 0:41:23,756
这样就是一种很好的

1375
00:41:23,756 --> 0:41:24,716
显示部分内容的效果 

1376
00:41:24,716 --> 0:41:25,846
你可以看到前导

1377
00:41:25,846 --> 0:41:26,666
和尾随两端的内容

1378
00:41:26,666 --> 0:41:29,666
你就会很清楚你所在的位置

1379
00:41:31,056 --> 0:41:32,576
这就是一些

1380
00:41:32,576 --> 0:41:33,766
应用在组合 App 中的

1381
00:41:33,766 --> 0:41:36,156
高级的附加特性

1382
00:41:36,156 --> 0:41:36,536
诸如此类的还有很多

1383
00:41:36,536 --> 0:41:38,946
你可以打开 SDK 来查看

1384
00:41:40,296 --> 0:41:44,606
在 Apple

1385
00:41:44,606 --> 0:41:46,746
协作的概念

1386
00:41:46,746 --> 0:41:48,026
是非常重要的

1387
00:41:48,026 --> 0:41:49,496
我们要与全公司的团队

1388
00:41:49,496 --> 0:41:51,816
进行合作以解决问题

1389
00:41:53,036 --> 0:41:56,526
作为一名框架工程师

1390
00:41:56,526 --> 0:41:57,846
对我们来说

1391
00:41:57,916 --> 0:41:59,836
与公司中不同的团队合作

1392
00:41:59,836 --> 0:42:00,776
确保我们知道他们

1393
00:41:59,836 --> 0:42:00,776
确保我们知道他们

1394
00:42:00,776 --> 0:42:01,986
对新框架特性的需求

1395
00:42:01,986 --> 0:42:04,196
是非常重要的

1396
00:42:05,256 --> 0:42:07,616
其中一个团队

1397
00:42:07,616 --> 0:42:09,196
App Store 团队就在

1398
00:42:09,196 --> 0:42:10,526
iOS 13 中做了重新设计

1399
00:42:10,526 --> 0:42:11,466
他们真的很想

1400
00:42:11,466 --> 0:42:12,566
简化一下代码库

1401
00:42:12,566 --> 0:42:14,616
所以在沟通的过程中

1402
00:42:15,256 --> 0:42:16,836
我们讨论了组合布局

1403
00:42:16,836 --> 0:42:18,926
他们对此非常兴奋

1404
00:42:18,926 --> 0:42:20,846
用它写了很多代码

1405
00:42:20,846 --> 0:42:22,086
下面我们就有请

1406
00:42:22,086 --> 0:42:23,816
来自 App Store 团队的同事

1407
00:42:23,816 --> 0:42:25,906
Dersu Abolfathi 为大家介绍

1408
00:42:26,276 --> 0:42:26,646
Dersu

1409
00:42:27,516 --> 0:42:32,766
[掌声]

1410
00:42:33,266 --> 0:42:34,086
&gt;&gt; 谢谢 Steve

1411
00:42:35,266 --> 0:42:36,806
有数百万的用户

1412
00:42:36,906 --> 0:42:38,386
在 App Store 中

1413
00:42:38,486 --> 0:42:39,746
寻找合适的 App

1414
00:42:39,746 --> 0:42:41,506
以使其设备充分发挥效用

1415
00:42:42,896 --> 0:42:44,076
在座有很多人每天

1416
00:42:44,076 --> 0:42:45,976
都会访问 App Store

1417
00:42:45,976 --> 0:42:47,236
里面的内容就要丰富

1418
00:42:48,046 --> 0:42:50,176
吸引人而且有活力

1419
00:42:51,666 --> 0:42:53,486
CollectionView 在这其中

1420
00:42:53,486 --> 0:42:55,646
发挥着关键作用

1421
00:42:57,876 --> 0:42:59,606
这是 App Store

1422
00:43:00,536 --> 0:43:02,586
如果你今天想要只用

1423
00:43:02,646 --> 0:43:05,276
流式布局来构建这样的 UI

1424
00:43:05,276 --> 0:43:07,396
你可能会从

1425
00:43:07,396 --> 0:43:08,556
一个竖直方向滚动的

1426
00:43:08,556 --> 0:43:09,816
CollectionView 开始

1427
00:43:11,656 --> 0:43:14,046
而对于每一个

1428
00:43:14,236 --> 0:43:15,586
在水平轴上滚动的段

1429
00:43:15,586 --> 0:43:17,466
你都需要一个附加的 CollectionView

1430
00:43:17,466 --> 0:43:19,846
这意味着你需要有

1431
00:43:19,846 --> 0:43:21,526
更多的支持代码

1432
00:43:21,526 --> 0:43:24,406
来连接每个集合的演示和行为

1433
00:43:27,536 --> 0:43:29,576
而在组合布局中

1434
00:43:29,576 --> 0:43:32,226
只需要一个 CollectionView 就可以完成

1435
00:43:32,226 --> 0:43:35,816
事实上 我们已经这么做了

1436
00:43:37,086 --> 0:43:39,386
在 iOS 13 中我们用组合布局

1437
00:43:39,386 --> 0:43:41,736
重新设计了 App Store

1438
00:43:42,286 --> 0:43:45,436
你在此页上看到的

1439
00:43:45,436 --> 0:43:47,526
每种内容类型都能进行

1440
00:43:47,526 --> 0:43:49,646
它们自己的布局描述

1441
00:43:50,146 --> 0:43:52,016
所有的这些布局段

1442
00:43:52,016 --> 0:43:54,906
一起组成一个整体的

1443
00:43:54,906 --> 0:43:56,076
CollectionViewLayout

1444
00:43:59,646 --> 0:44:01,996
我们只用一个布局项目

1445
00:43:59,646 --> 0:44:01,996
我们只用一个布局项目

1446
00:44:01,996 --> 0:44:03,996
就能描述这个段

1447
00:44:03,996 --> 0:44:05,756
该项目有一个已知的高度

1448
00:44:05,756 --> 0:44:08,076
而宽度则为容器的 100%

1449
00:44:10,616 --> 0:44:12,266
布局项目位于一个布局组里

1450
00:44:12,266 --> 0:44:14,566
而布局组本身

1451
00:44:14,566 --> 0:44:16,556
占据容器宽度的一半

1452
00:44:17,056 --> 0:44:19,796
这些都是

1453
00:44:19,796 --> 0:44:22,136
让 UI 运行的基本构件

1454
00:44:22,696 --> 0:44:26,466
我们拿出该布局组

1455
00:44:26,466 --> 0:44:28,556
将其贴在一个布局段中

1456
00:44:28,556 --> 0:44:29,746
然后为了得到想要的分页行为

1457
00:44:29,746 --> 0:44:31,266
我们将垂直滚动行为

1458
00:44:31,266 --> 0:44:33,426
设置为组分页

1459
00:44:34,156 --> 0:44:34,976
然后好戏就开场了

1460
00:44:39,446 --> 0:44:41,676
在 iOS 13 的 App Store 里

1461
00:44:41,676 --> 0:44:43,636
UI 也支持

1462
00:44:43,636 --> 0:44:45,976
从右向左阅读的语言

1463
00:44:45,976 --> 0:44:48,436
组合布局帮助实现了这一功能

1464
00:44:49,016 --> 0:44:52,456
我们用所有

1465
00:44:52,566 --> 0:44:53,656
今天能看到的

1466
00:44:53,656 --> 0:44:55,376
相同的原语来构建布局

1467
00:44:55,376 --> 0:44:57,556
组合布局只负责剩下的部分

1468
00:44:58,056 --> 0:45:00,236
它确保我们的补充物

1469
00:44:58,056 --> 0:45:00,236
它确保我们的补充物

1470
00:45:00,236 --> 0:45:01,626
和储存格的位置

1471
00:45:01,626 --> 0:45:04,526
适合从右到左的环境

1472
00:45:05,186 --> 0:45:07,456
此外 我们不再需要 

1473
00:45:07,496 --> 0:45:09,326
单独写一行代码

1474
00:45:09,486 --> 0:45:10,976
来确保我们的分页行为

1475
00:45:10,976 --> 0:45:14,496
也适用于从右到左的布局方向

1476
00:45:17,496 --> 0:45:20,216
所以这个新的 API

1477
00:45:20,216 --> 0:45:21,946
使我们能够获取所有那些

1478
00:45:21,946 --> 0:45:23,466
我们之前从头管到脚的可滚动区域

1479
00:45:23,466 --> 0:45:25,746
并将它们平铺到

1480
00:45:25,936 --> 0:45:28,576
顶层的一个 CollectionView 中

1481
00:45:28,576 --> 0:45:31,336
这样一来我们的代码

1482
00:45:31,336 --> 0:45:34,086
变得更加简洁

1483
00:45:34,086 --> 0:45:36,286
更易于推出

1484
00:45:36,286 --> 0:45:37,736
同时也更易于日后维护

1485
00:45:40,016 --> 0:45:41,466
组合布局重新定义了

1486
00:45:41,526 --> 0:45:42,966
我们在自己的 App 中

1487
00:45:42,966 --> 0:45:44,686
思考 CollectionViews 的方式

1488
00:45:44,686 --> 0:45:46,546
我们迫不及待地想看看

1489
00:45:46,546 --> 0:45:47,756
它是如何提升

1490
00:45:47,756 --> 0:45:49,436
你们在 App Store 中

1491
00:45:49,436 --> 0:45:50,756
所得到的 App 的体验呢

1492
00:45:50,756 --> 0:45:51,936
下面交给你 Troy

1493
00:45:52,516 --> 0:45:57,546
[掌声]

1494
00:45:58,046 --> 0:45:59,206
&gt;&gt; 非常感谢 Dersu

1495
00:45:59,206 --> 0:46:00,996
这个设计真不错

1496
00:45:59,206 --> 0:46:00,996
这个设计真不错

1497
00:46:01,376 --> 0:46:02,996
我们非常高兴地看到

1498
00:46:03,116 --> 0:46:04,406
我们已经用组合布局

1499
00:46:04,436 --> 0:46:07,346
简化了一个知名的 

1500
00:46:07,346 --> 0:46:10,446
面向用户的 App 的开发过程

1501
00:46:10,446 --> 0:46:13,046
我很高兴在我们的平台上

1502
00:46:13,046 --> 0:46:14,556
开发人员能

1503
00:46:14,556 --> 0:46:16,756
使用同样的API

1504
00:46:17,186 --> 0:46:18,516
说到这儿 我想给你们

1505
00:46:18,516 --> 0:46:19,986
快速地展示一下

1506
00:46:19,986 --> 0:46:21,396
组合布局用 NSCollectionView

1507
00:46:21,396 --> 0:46:23,866
在 macOS 上的运行

1508
00:46:29,596 --> 0:46:31,086
当你打开你在 Xcode 上

1509
00:46:31,086 --> 0:46:32,316
下载的示例项目时

1510
00:46:32,316 --> 0:46:34,196
注意会有一个

1511
00:46:34,196 --> 0:46:35,866
Mac 的构建方案和目标

1512
00:46:36,196 --> 0:46:37,976
我们要在这里构建且运行它

1513
00:46:42,126 --> 0:46:43,656
我们打开

1514
00:46:43,656 --> 0:46:45,206
我们在本次讲座中看过的

1515
00:46:45,206 --> 0:46:47,016
所有布局示例

1516
00:46:47,016 --> 0:46:47,816
然后把它们分散开

1517
00:46:51,276 --> 0:46:53,096
就是这样 这就是我们的

1518
00:46:53,096 --> 0:46:54,376
各种组合布局的例子

1519
00:46:54,696 --> 0:46:55,876
而我们用的代码

1520
00:46:55,876 --> 0:46:57,326
本质上都是一样的

1521
00:46:57,326 --> 0:46:59,356
我们也将得到相同的 API

1522
00:46:59,686 --> 0:47:00,536
你真正看到的

1523
00:46:59,686 --> 0:47:00,536
你真正看到的

1524
00:47:00,536 --> 0:47:01,636
唯一的调整就是

1525
00:47:01,636 --> 0:47:03,816
我们想要在其中应用

1526
00:47:03,816 --> 0:47:05,896
更多适合 macOS 的指标

1527
00:47:05,896 --> 0:47:08,666
这里可以水平滚动

1528
00:47:10,176 --> 0:47:12,786
当然 在 Mac 上我们想要

1529
00:47:12,786 --> 0:47:14,636
它们以 Mac 的方式运行

1530
00:47:14,636 --> 0:47:15,396
我们在 Mac 上

1531
00:47:15,396 --> 0:47:16,396
使用 CollectionViews 时

1532
00:47:16,396 --> 0:47:19,066
它们是可以不断调整大小的 

1533
00:47:19,446 --> 0:47:21,546
我们已经确保 Mac

1534
00:47:21,546 --> 0:47:23,286
能又快又好地进行

1535
00:47:24,176 --> 0:47:25,296
超轻量的大小调整

1536
00:47:25,506 --> 0:47:27,286
布局也调整得非常快

1537
00:47:27,286 --> 0:47:29,156
我们的自适应段布局

1538
00:47:29,246 --> 0:47:31,076
和之前一样有一个布局改变

1539
00:47:31,076 --> 0:47:32,606
既然你知道了运行原理

1540
00:47:32,606 --> 0:47:33,886
你就可以随意地增加

1541
00:47:33,886 --> 0:47:35,126
额外的布局改变

1542
00:47:35,126 --> 0:47:37,546
给更大的窗口宽度和屏幕宽度

1543
00:47:38,226 --> 0:47:40,386
当然 我们还有一些特性

1544
00:47:40,386 --> 0:47:42,116
比如点击项目就能选中它们

1545
00:47:42,626 --> 0:47:45,656
用箭头键就可以进行导航

1546
00:47:46,446 --> 0:47:47,756
按住 Shift 键

1547
00:47:47,756 --> 0:47:48,736
同时按箭头键

1548
00:47:48,736 --> 0:47:49,926
就可以选中多个项目

1549
00:47:50,516 --> 0:47:53,546
[掌声]

1550
00:47:54,046 --> 0:47:56,026
当然 也可以拖动选择任意区域

1551
00:47:56,026 --> 0:47:57,266
可以大批量选择项目

1552
00:47:57,266 --> 0:47:58,986
这个在任何的

1553
00:47:58,986 --> 0:48:00,536
组合布局里都可以完成

1554
00:47:58,986 --> 0:48:00,536
组合布局里都可以完成

1555
00:48:00,536 --> 0:48:01,976
包括像这样更高级的布局

1556
00:48:02,016 --> 0:48:03,076
[掌声]

1557
00:48:03,076 --> 0:48:05,906
所有用户期待

1558
00:48:05,906 --> 0:48:07,386
在 Mac 上实现的东西都可以做到

1559
00:48:07,386 --> 0:48:09,606
我们已经运行所有这些布局

1560
00:48:09,896 --> 0:48:11,976
下面这些代码已经说得够多了

1561
00:48:11,976 --> 0:48:13,346
项目 段和组的描述

1562
00:48:13,346 --> 0:48:15,836
在所使用的 API 中

1563
00:48:15,836 --> 0:48:17,426
是相同的

1564
00:48:17,426 --> 0:48:18,586
你甚至可以提取代码

1565
00:48:18,586 --> 0:48:19,816
并在不同的平台项目之间

1566
00:48:19,816 --> 0:48:22,336
分享这些代码

1567
00:48:23,396 --> 0:48:24,846
所以我们可以看到

1568
00:48:24,846 --> 0:48:26,796
这里的组合布局我们

1569
00:48:26,796 --> 0:48:29,686
在不同的平台上的操作

1570
00:48:29,686 --> 0:48:30,896
变得更加容易

1571
00:48:31,026 --> 0:48:33,766
它确实有很多值得推荐的地方

1572
00:48:34,406 --> 0:48:35,806
从今天开始你就可以

1573
00:48:35,806 --> 0:48:39,856
在 iOS tvOS 和 macOS 上使用它

1574
00:48:39,856 --> 0:48:41,566
我们只要简单地描述它

1575
00:48:41,836 --> 0:48:43,966
就可以轻易地为 CollectionView

1576
00:48:43,966 --> 0:48:46,816
创建新的自定布局

1577
00:48:46,816 --> 0:48:48,546
我们认为这是一个打破格局的创新

1578
00:48:49,436 --> 0:48:50,386
反过来 这使得

1579
00:48:50,386 --> 0:48:51,766
CollectionView 成为一个

1580
00:48:51,846 --> 0:48:53,636
比以前更全能的工具

1581
00:48:53,636 --> 0:48:55,816
你可以随心所欲地

1582
00:48:55,816 --> 0:48:58,236
展示你的内容

1583
00:48:58,926 --> 0:49:00,176
你可以更容易地

1584
00:48:58,926 --> 0:49:00,176
你可以更容易地

1585
00:49:00,176 --> 0:49:02,116
描述新的布局

1586
00:49:02,116 --> 0:49:03,066
调整和改变布局

1587
00:49:03,066 --> 0:49:04,216
尝试不同的东西

1588
00:49:04,216 --> 0:49:05,556
并进行迭代

1589
00:49:05,606 --> 0:49:08,396
这些都将使设计人员

1590
00:49:08,526 --> 0:49:10,266
能够更快地进行迭代

1591
00:49:10,606 --> 0:49:12,786
这的确是个改变游戏规则的创新

1592
00:49:14,256 --> 0:49:15,606
所以等你们回去

1593
00:49:15,606 --> 0:49:17,806
打开示例项目进行试验

1594
00:49:17,846 --> 0:49:19,946
尝试改变不同的事物

1595
00:49:19,946 --> 0:49:21,746
以我们的代码作为基础

1596
00:49:21,746 --> 0:49:23,606
为 App 的下个版本

1597
00:49:23,606 --> 0:49:25,686
创建自定布局吧

1598
00:49:25,956 --> 0:49:27,026
我们迫不及待地想看到

1599
00:49:27,026 --> 0:49:28,696
组合布局能够使你

1600
00:49:28,696 --> 0:49:29,986
在很短的时间内

1601
00:49:29,986 --> 0:49:32,326
创建出更好的用户体验

1602
00:49:33,356 --> 0:49:34,426
如果你本次讲座很感兴趣

1603
00:49:34,426 --> 0:49:35,766
我们还有一个话题

1604
00:49:35,766 --> 0:49:36,616
我想你也会非常喜欢

1605
00:49:36,616 --> 0:49:37,696
特别是使用 CollectionViews 

1606
00:49:37,696 --> 0:49:40,046
甚至是 UI 表视图的朋友

1607
00:49:40,286 --> 0:49:42,486
在UI数据源方面的发展中

1608
00:49:42,806 --> 0:49:44,816
我们引入了一个全新的

1609
00:49:45,006 --> 0:49:47,126
非常简单的 API

1610
00:49:47,126 --> 0:49:48,806
用于向 CollectionViews

1611
00:49:48,806 --> 0:49:50,446
和 UI 表视图提供模型数据

1612
00:49:50,446 --> 0:49:52,016
同时免费获得

1613
00:49:52,016 --> 0:49:53,266
对差异的自动计算

1614
00:49:53,266 --> 0:49:55,596
和自动动画

1615
00:49:55,596 --> 0:49:56,666
它将创造令人愉快的

1616
00:49:56,666 --> 0:49:57,666
用户体验

1617
00:49:57,666 --> 0:49:59,876
所以一定要观看这个讲座

1618
00:50:01,046 --> 0:50:02,546
感谢各位的聆听

1619
00:50:03,508 --> 0:50:05,508
[掌声]
