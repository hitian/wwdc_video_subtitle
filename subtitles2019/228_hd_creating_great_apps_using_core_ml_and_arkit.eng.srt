1
00:00:00,506 --> 0:00:05,500
[ Music ]

2
00:00:12,496 --> 0:00:14,496
[ Applause ]

3
00:00:14,976 --> 0:00:16,666
&gt;&gt; Good morning, and thank you

4
00:00:16,666 --> 0:00:17,616
for coming to our session.

5
00:00:19,206 --> 0:00:21,996
At Apple, we build technologies.

6
00:00:22,936 --> 0:00:24,436
We build technologies so that

7
00:00:24,436 --> 0:00:26,236
you can make great apps with

8
00:00:26,236 --> 0:00:27,356
amazing experiences.

9
00:00:27,886 --> 0:00:30,916
And my favorite apps are the

10
00:00:30,916 --> 0:00:32,296
ones that seamlessly blend those

11
00:00:32,296 --> 0:00:34,096
technologies and really immerse

12
00:00:34,096 --> 0:00:35,166
us in the experience.

13
00:00:36,956 --> 0:00:39,496
Today we'd like to talk to you

14
00:00:39,496 --> 0:00:40,946
about two of these technologies:

15
00:00:41,446 --> 0:00:43,036
Core ML and ARKit.

16
00:00:43,586 --> 0:00:47,026
Both of these help our devices

17
00:00:47,116 --> 0:00:48,666
gain a level of understanding

18
00:00:48,666 --> 0:00:50,466
about the world around us.

19
00:00:51,696 --> 0:00:54,216
They help us blend the physical

20
00:00:54,216 --> 0:00:54,976
and virtual worlds.

21
00:00:57,216 --> 0:00:58,646
Today we're going to take you on

22
00:00:58,646 --> 0:00:59,926
a journey of building an app

23
00:00:59,926 --> 0:01:02,046
that does just that.

24
00:00:59,926 --> 0:01:02,046
that does just that.

25
00:01:02,516 --> 0:01:04,245
Along the way, we're going to

26
00:01:04,245 --> 0:01:05,296
look at some challenges that we

27
00:01:05,296 --> 0:01:07,076
faced and how we overcame them,

28
00:01:07,636 --> 0:01:09,136
and we're going to look at some

29
00:01:09,136 --> 0:01:11,266
themes that arose from facing

30
00:01:11,266 --> 0:01:12,066
those challenges.

31
00:01:13,836 --> 0:01:17,596
The first, being the question,

32
00:01:17,676 --> 0:01:19,486
can machine learning help?

33
00:01:20,656 --> 0:01:23,016
Well, okay, if I said no, then

34
00:01:23,016 --> 0:01:23,886
this would be a pretty short

35
00:01:23,886 --> 0:01:24,166
session.

36
00:01:24,806 --> 0:01:27,286
But I can't just say a blanket

37
00:01:27,286 --> 0:01:29,946
yes, because the answer really

38
00:01:29,946 --> 0:01:31,996
depends on the type of problem

39
00:01:31,996 --> 0:01:33,396
you're trying to solve and the

40
00:01:33,396 --> 0:01:34,836
data you have to solve it,

41
00:01:36,276 --> 0:01:37,366
because machine learning is

42
00:01:37,366 --> 0:01:38,646
about understanding data.

43
00:01:38,646 --> 0:01:40,506
It's about understanding

44
00:01:40,596 --> 0:01:42,486
patterns in data, patterns in

45
00:01:42,486 --> 0:01:44,476
data that may be difficult to

46
00:01:44,476 --> 0:01:45,816
write down programmatically.

47
00:01:46,246 --> 0:01:48,876
And this data exists in your

48
00:01:49,556 --> 0:01:49,746
apps.

49
00:01:50,106 --> 0:01:51,576
Your users enter it every day.

50
00:01:52,236 --> 0:01:53,836
They use the keyboard and they

51
00:01:53,836 --> 0:01:55,246
enter text.

52
00:01:56,216 --> 0:01:57,706
They use the microphone and they

53
00:01:57,706 --> 0:01:58,536
record sound.

54
00:02:00,456 --> 0:02:01,976
They use the camera and they

55
00:02:01,976 --> 0:02:03,726
capture video and pictures.

56
00:02:04,246 --> 0:02:07,006
So when facing a problem, asking

57
00:02:07,006 --> 0:02:08,466
yourself, can machine learning

58
00:02:08,466 --> 0:02:10,265
help, is a good question to ask.

59
00:02:10,705 --> 0:02:12,536
Now, you need to take a close

60
00:02:12,536 --> 0:02:13,256
look at the problem you're

61
00:02:13,256 --> 0:02:15,016
trying to solve and the data you

62
00:02:15,016 --> 0:02:16,726
have available to solve it.

63
00:02:19,656 --> 0:02:20,986
The second theme that we're

64
00:02:20,986 --> 0:02:22,806
going to look at today is

65
00:02:22,806 --> 0:02:23,886
understanding the behavior of

66
00:02:23,886 --> 0:02:25,076
your model.

67
00:02:25,996 --> 0:02:28,276
These models are trained to

68
00:02:28,276 --> 0:02:30,326
expect certain inputs in certain

69
00:02:30,326 --> 0:02:33,376
formats and to provide outputs

70
00:02:33,426 --> 0:02:35,036
in certain formats.

71
00:02:35,616 --> 0:02:38,806
And so if your input is not in

72
00:02:38,806 --> 0:02:40,176
the format that's expected for

73
00:02:40,176 --> 0:02:42,856
the model, then the output is

74
00:02:42,856 --> 0:02:44,046
going to be unexpected as well.

75
00:02:44,046 --> 0:02:48,046
And speaking of outputs, if you

76
00:02:48,046 --> 0:02:49,026
don't understand what's being

77
00:02:49,026 --> 0:02:50,326
output from your model, it's

78
00:02:50,326 --> 0:02:51,736
going to be difficult to use it

79
00:02:52,176 --> 0:02:53,616
to make that magical experience

80
00:02:53,616 --> 0:02:54,886
in your app.

81
00:02:56,136 --> 0:02:57,396
We're going to look at a couple

82
00:02:57,396 --> 0:02:59,316
ways that you can visualize the

83
00:02:59,316 --> 0:03:01,186
inputs and the outputs of some

84
00:02:59,316 --> 0:03:01,186
inputs and the outputs of some

85
00:03:01,186 --> 0:03:01,726
models.

86
00:03:02,206 --> 0:03:04,836
But for now, on with our

87
00:03:04,836 --> 0:03:05,116
journey.

88
00:03:06,166 --> 0:03:07,666
We said that we're going to

89
00:03:07,666 --> 0:03:09,456
combine technologies to blend

90
00:03:09,456 --> 0:03:10,776
the physical and virtual worlds,

91
00:03:10,836 --> 0:03:12,786
and what better context to do

92
00:03:12,786 --> 0:03:14,606
this in than an app?

93
00:03:14,706 --> 0:03:16,986
We thought that it would be fun

94
00:03:17,276 --> 0:03:18,716
to build an educational game app

95
00:03:18,806 --> 0:03:20,526
for children to practice their

96
00:03:20,526 --> 0:03:23,376
math skills, like counting, or

97
00:03:23,376 --> 0:03:24,986
addition, or multiplication.

98
00:03:25,796 --> 0:03:28,306
And we know that children

99
00:03:28,306 --> 0:03:29,746
sometimes use dice to practice

100
00:03:29,746 --> 0:03:30,266
these skills.

101
00:03:30,906 --> 0:03:32,266
Now, we could've just put

102
00:03:32,616 --> 0:03:35,036
virtual dice in the app and let

103
00:03:35,036 --> 0:03:36,406
those roll around on the screen,

104
00:03:36,656 --> 0:03:37,806
but we thought, wouldn't it be a

105
00:03:37,806 --> 0:03:39,946
lot more fun if the children

106
00:03:39,946 --> 0:03:41,236
could play with physical dice

107
00:03:41,236 --> 0:03:42,856
and roll those on the table and

108
00:03:43,396 --> 0:03:45,086
then interact with our app?

109
00:03:46,336 --> 0:03:47,996
So that's what we did.

110
00:03:48,296 --> 0:03:50,586
And the first challenge that we

111
00:03:50,586 --> 0:03:54,396
ran into was, how do you get an

112
00:03:54,396 --> 0:03:55,646
app to recognize dice?

113
00:03:56,146 --> 0:03:58,676
Well, there's a couple

114
00:03:58,676 --> 0:03:59,306
approaches.

115
00:04:00,266 --> 0:04:01,906
Let's start programmatically.

116
00:04:02,526 --> 0:04:04,666
But this is going to be a little

117
00:04:05,046 --> 0:04:05,306
difficult.

118
00:04:06,616 --> 0:04:08,106
If we constrain our problem to

119
00:04:08,106 --> 0:04:10,256
only six-sided dice, we can

120
00:04:10,256 --> 0:04:11,446
start to look at the properties

121
00:04:11,446 --> 0:04:11,726
of a die.

122
00:04:12,536 --> 0:04:14,666
For instance, the die behind me,

123
00:04:14,666 --> 0:04:15,606
its color is gray.

124
00:04:16,935 --> 0:04:19,466
But not all dice are gray, so

125
00:04:19,466 --> 0:04:21,536
that's not necessarily helpful.

126
00:04:22,856 --> 0:04:24,926
If you look at it in a 2D plane,

127
00:04:25,476 --> 0:04:26,876
it's a hexagon shape and it has

128
00:04:26,986 --> 0:04:28,596
three skewed squares for sides.

129
00:04:30,206 --> 0:04:31,926
But those move and change as the

130
00:04:31,926 --> 0:04:33,176
die rolls around on the table.

131
00:04:33,836 --> 0:04:36,416
If we take a closer look at each

132
00:04:36,416 --> 0:04:38,396
side, there's a number of dots

133
00:04:38,396 --> 0:04:40,096
on them; but again, that's

134
00:04:40,256 --> 0:04:41,426
different depending on the side

135
00:04:41,426 --> 0:04:42,966
you're looking at and depending

136
00:04:42,966 --> 0:04:44,236
on your perspective of the die.

137
00:04:45,426 --> 0:04:47,066
So with all of these properties

138
00:04:47,346 --> 0:04:49,476
changing, it's going to be

139
00:04:49,476 --> 0:04:50,726
pretty difficult to write a

140
00:04:50,876 --> 0:04:52,476
program to recognize dice.

141
00:04:52,866 --> 0:04:56,106
So let's take a look at the

142
00:04:56,106 --> 0:04:56,976
machine learning approach.

143
00:05:00,536 --> 0:05:02,376
We could train an image

144
00:05:02,376 --> 0:05:04,216
classification model to

145
00:05:04,216 --> 0:05:06,146
recognize dice in an image.

146
00:05:06,706 --> 0:05:10,996
But we want to know how many

147
00:05:10,996 --> 0:05:12,766
dice are in an image -- not just

148
00:05:12,766 --> 0:05:14,346
the existence of dice in an

149
00:05:14,346 --> 0:05:14,706
image.

150
00:05:15,896 --> 0:05:17,356
So instead, we looked at using

151
00:05:17,356 --> 0:05:18,426
an object detection model.

152
00:05:18,986 --> 0:05:21,056
An object detection model will

153
00:05:21,056 --> 0:05:22,316
tell us if there's dice in an

154
00:05:22,316 --> 0:05:24,366
image, but it will also tell us

155
00:05:24,366 --> 0:05:26,076
where it is in the image; and if

156
00:05:26,076 --> 0:05:27,176
we know where the dice are in

157
00:05:27,176 --> 0:05:29,446
the image, then we can count

158
00:05:30,476 --> 0:05:30,606
them.

159
00:05:30,786 --> 0:05:32,596
To do this, we needed to get

160
00:05:32,596 --> 0:05:34,846
data, so we took a bunch of

161
00:05:34,846 --> 0:05:37,336
pictures of dice rolling around

162
00:05:37,606 --> 0:05:38,116
on the table.

163
00:05:38,606 --> 0:05:41,436
Next, we took those pictures and

164
00:05:41,436 --> 0:05:43,286
we annotated them with bounding

165
00:05:43,286 --> 0:05:44,886
boxes, indicating where the dice

166
00:05:44,886 --> 0:05:45,906
are in the images.

167
00:05:46,226 --> 0:05:49,486
After that, we used the new

168
00:05:49,486 --> 0:05:51,276
Create ML to train our custom

169
00:05:51,276 --> 0:05:52,246
object detection model.

170
00:05:54,716 --> 0:05:56,026
If you'd like to learn more

171
00:05:56,026 --> 0:05:57,966
about this training, please see

172
00:05:57,966 --> 0:05:59,046
the Create ML for Object

173
00:05:59,046 --> 0:05:59,936
Detection and Sound

174
00:05:59,936 --> 0:06:00,876
Classification session.

175
00:05:59,936 --> 0:06:00,876
Classification session.

176
00:06:00,876 --> 0:06:04,806
Now I'd like to invite Scott up

177
00:06:04,806 --> 0:06:06,356
to show you this in action.

178
00:06:07,596 --> 0:06:07,896
Scott?

179
00:06:08,516 --> 0:06:13,036
[ Applause ]

180
00:06:13,536 --> 0:06:14,496
&gt;&gt; Good morning, everyone.

181
00:06:14,936 --> 0:06:15,176
&gt;&gt; Morning!

182
00:06:17,136 --> 0:06:18,246
&gt;&gt; As Brent discussed, we're

183
00:06:18,246 --> 0:06:19,916
going to be exploring adding the

184
00:06:19,916 --> 0:06:21,516
ability for our app to count

185
00:06:21,516 --> 0:06:23,006
dice using a machine learning

186
00:06:23,006 --> 0:06:24,006
technique called object

187
00:06:24,006 --> 0:06:24,446
detection.

188
00:06:25,066 --> 0:06:26,396
And I'm sure you're all eager to

189
00:06:26,396 --> 0:06:27,726
see it in action, so let's get

190
00:06:27,726 --> 0:06:29,000
right to it.

191
00:06:38,536 --> 0:06:40,736
So here, we have a very simple

192
00:06:40,946 --> 0:06:41,996
app that's wired with a live

193
00:06:41,996 --> 0:06:43,586
camera view, and we've added our

194
00:06:43,586 --> 0:06:44,866
object detector trained to

195
00:06:44,866 --> 0:06:46,516
detect dice so that we can count

196
00:06:46,516 --> 0:06:46,706
them.

197
00:06:47,196 --> 0:06:48,236
So let's see what happens when

198
00:06:48,236 --> 0:06:49,366
we add dice to the frame.

199
00:06:50,766 --> 0:06:55,896
One, two, three, and four.

200
00:06:56,056 --> 0:06:59,056
We can even take a roll for more

201
00:06:59,056 --> 0:06:59,366
fun.

202
00:07:00,066 --> 0:07:02,416
So this is great.

203
00:07:02,416 --> 0:07:04,446
Our app is able to count dice

204
00:07:04,786 --> 0:07:05,866
using object detection.

205
00:07:06,476 --> 0:07:07,836
But one of the themes that we

206
00:07:07,836 --> 0:07:09,066
want to discuss with you today

207
00:07:09,066 --> 0:07:10,476
is understanding your model's

208
00:07:10,506 --> 0:07:10,966
behavior.

209
00:07:11,416 --> 0:07:13,616
So let's actually take a look at

210
00:07:13,616 --> 0:07:15,286
a debug visualization of what

211
00:07:15,286 --> 0:07:16,436
the model is seeing.

212
00:07:17,006 --> 0:07:18,096
As you can see, we're drawing

213
00:07:18,096 --> 0:07:20,066
bounding boxes around each of

214
00:07:20,066 --> 0:07:21,926
the detected objects -- in this

215
00:07:21,926 --> 0:07:23,576
case, dice -- on the board.

216
00:07:23,576 --> 0:07:25,216
And if we move them around,

217
00:07:25,566 --> 0:07:28,396
those boxes will move as well.

218
00:07:28,606 --> 0:07:30,346
This is important to you because

219
00:07:30,346 --> 0:07:32,756
if you are training an object

220
00:07:32,756 --> 0:07:34,606
detector and you start playing

221
00:07:34,606 --> 0:07:35,946
around with it, and you don't

222
00:07:35,946 --> 0:07:37,416
notice certain boxes around

223
00:07:37,416 --> 0:07:38,556
objects that aren't what you're

224
00:07:38,556 --> 0:07:40,826
trying to detect, or you're not

225
00:07:40,886 --> 0:07:42,156
seeing boxes around the objects

226
00:07:42,156 --> 0:07:43,436
that you are trying to detect,

227
00:07:43,846 --> 0:07:45,276
this is probably the opportunity

228
00:07:45,276 --> 0:07:46,536
for you to go and collect more

229
00:07:46,536 --> 0:07:47,866
data in this kind of lighting.

230
00:07:48,376 --> 0:07:49,746
You may want to collect more

231
00:07:49,746 --> 0:07:50,726
data with different kinds of

232
00:07:50,726 --> 0:07:52,786
backgrounds, different lighting,

233
00:07:53,096 --> 0:07:54,276
with a different number of

234
00:07:54,276 --> 0:07:55,756
objects -- in this case, we have

235
00:07:55,836 --> 0:07:56,716
four, but you may want to

236
00:07:56,716 --> 0:07:58,486
collect with five, six, up to

237
00:07:58,486 --> 0:08:00,706
ten dice, or less, or even

238
00:07:58,486 --> 0:08:00,706
ten dice, or less, or even

239
00:08:00,706 --> 0:08:02,066
images without them to train it

240
00:08:02,066 --> 0:08:03,746
to not recognize other objects.

241
00:08:07,076 --> 0:08:09,116
Let's take a look at some code

242
00:08:09,116 --> 0:08:11,346
to do this.

243
00:08:11,506 --> 0:08:12,566
When you use your object

244
00:08:12,566 --> 0:08:13,536
detector that you've trained

245
00:08:13,536 --> 0:08:15,186
with Create ML, in the Vision

246
00:08:15,186 --> 0:08:16,796
framework, what you get back as

247
00:08:16,796 --> 0:08:18,056
a result is a list of VN

248
00:08:18,056 --> 0:08:19,586
recognized object observations.

249
00:08:20,316 --> 0:08:21,536
So here we have a function that

250
00:08:21,536 --> 0:08:22,846
handles those observations and

251
00:08:22,846 --> 0:08:23,946
does a couple things for us.

252
00:08:24,526 --> 0:08:25,746
The first one is the easiest:

253
00:08:26,286 --> 0:08:27,146
we're just counting dice.

254
00:08:27,606 --> 0:08:29,106
And this just is as simple as

255
00:08:29,106 --> 0:08:29,806
counting the number of

256
00:08:29,806 --> 0:08:31,076
observations because we have one

257
00:08:31,156 --> 0:08:31,766
per die.

258
00:08:32,326 --> 0:08:34,716
Next, we have a couple helper

259
00:08:34,716 --> 0:08:36,035
functions that help us draw

260
00:08:36,035 --> 0:08:37,566
these bounding boxes on screen

261
00:08:37,676 --> 0:08:39,666
based on these recognized object

262
00:08:39,666 --> 0:08:40,346
observations.

263
00:08:40,936 --> 0:08:43,145
We have a first function that

264
00:08:43,145 --> 0:08:44,636
matched the bounds you get from

265
00:08:44,636 --> 0:08:46,316
each recognized object

266
00:08:46,316 --> 0:08:47,826
observation, which come in

267
00:08:47,966 --> 0:08:50,186
normalized coordinates based on

268
00:08:50,186 --> 0:08:51,656
the input image you provide to

269
00:08:51,656 --> 0:08:53,936
Vision, so that function maps

270
00:08:54,006 --> 0:08:55,316
those back to our view

271
00:08:55,316 --> 0:08:56,496
controller's views coordinate

272
00:08:56,496 --> 0:08:57,366
system so that we can

273
00:08:57,366 --> 0:08:58,546
appropriately draw them on

274
00:08:58,606 --> 0:09:00,606
screen, overlaying them on top

275
00:08:58,606 --> 0:09:00,606
screen, overlaying them on top

276
00:09:00,606 --> 0:09:01,466
of the actual objects.

277
00:09:03,026 --> 0:09:04,376
Next we have a helper function

278
00:09:04,376 --> 0:09:06,836
that creates our beautiful

279
00:09:07,106 --> 0:09:08,416
rounded rectangles that we

280
00:09:08,416 --> 0:09:10,326
display on screen, which is a

281
00:09:10,396 --> 0:09:13,276
CALayer, and we add that CALayer

282
00:09:13,276 --> 0:09:15,256
to an overlay layer to be

283
00:09:15,256 --> 0:09:15,986
rendered on screen.

284
00:09:16,656 --> 0:09:17,886
All this code is available in

285
00:09:17,886 --> 0:09:19,276
the sample app associated with

286
00:09:19,276 --> 0:09:20,536
this session, which I encourage

287
00:09:20,536 --> 0:09:22,876
you to check out.

288
00:09:23,136 --> 0:09:25,246
So this is really promising: our

289
00:09:25,486 --> 0:09:27,566
app is able to count dice using

290
00:09:27,566 --> 0:09:28,296
object detection.

291
00:09:29,216 --> 0:09:30,716
But you may have already

292
00:09:30,716 --> 0:09:32,686
realized or thought about the

293
00:09:32,686 --> 0:09:34,236
fact that games typically don't

294
00:09:34,236 --> 0:09:35,886
rely on the count of dice; they

295
00:09:35,886 --> 0:09:37,196
typically rely on the values

296
00:09:37,236 --> 0:09:37,866
displayed on them.

297
00:09:38,796 --> 0:09:40,436
So we need to take this one step

298
00:09:40,486 --> 0:09:42,416
further and figure out how to

299
00:09:42,416 --> 0:09:43,706
recognize the values displayed

300
00:09:43,706 --> 0:09:45,586
on these dice.

301
00:09:45,796 --> 0:09:47,166
This is ultimately the goal that

302
00:09:47,166 --> 0:09:49,446
we want our app to have: we want

303
00:09:49,446 --> 0:09:50,376
it to be able to tell that the

304
00:09:50,376 --> 0:09:52,476
die on the right side is a 5 and

305
00:09:52,476 --> 0:09:55,156
the one on the left is a 1.

306
00:09:55,366 --> 0:09:57,166
Luckily for us, as Brent

307
00:09:57,166 --> 0:09:59,476
mentioned, object detectors can

308
00:09:59,576 --> 0:10:01,106
not only detect but classify

309
00:09:59,576 --> 0:10:01,106
not only detect but classify

310
00:10:01,106 --> 0:10:02,626
objects, because they're built

311
00:10:02,626 --> 0:10:04,196
to be able to recognize all

312
00:10:04,196 --> 0:10:05,496
sorts of different objects and

313
00:10:05,496 --> 0:10:05,916
images.

314
00:10:06,666 --> 0:10:09,636
So we went ahead and updated all

315
00:10:09,636 --> 0:10:11,186
our training data to actually

316
00:10:11,186 --> 0:10:12,936
consider dice with different

317
00:10:12,936 --> 0:10:14,376
values to be of a different

318
00:10:14,376 --> 0:10:16,246
class, just like you can see on

319
00:10:16,246 --> 0:10:16,766
the screen.

320
00:10:18,796 --> 0:10:21,136
So this sounded really

321
00:10:21,136 --> 0:10:22,856
promising, and so we gave it a

322
00:10:22,856 --> 0:10:24,246
try in our app.

323
00:10:24,246 --> 0:10:26,286
Let's take a look at some of the

324
00:10:26,286 --> 0:10:27,516
examples that we ran into.

325
00:10:27,566 --> 0:10:30,406
In most cases, it worked

326
00:10:30,446 --> 0:10:31,126
perfectly fine.

327
00:10:31,416 --> 0:10:32,566
As you can see in the picture

328
00:10:32,866 --> 0:10:34,866
behind me, our object detector

329
00:10:34,866 --> 0:10:36,396
is able to correctly and

330
00:10:36,436 --> 0:10:38,036
accurately detect and classify

331
00:10:38,036 --> 0:10:39,026
the dice on the left of the

332
00:10:39,026 --> 0:10:42,446
screen; but if we focus in on

333
00:10:42,446 --> 0:10:44,506
the other side, we can see that

334
00:10:44,506 --> 0:10:45,846
our object detector is actually

335
00:10:45,846 --> 0:10:47,736
detecting the 6 and the 4 as one

336
00:10:47,766 --> 0:10:48,266
single die.

337
00:10:49,816 --> 0:10:50,766
And if we think a little bit

338
00:10:50,766 --> 0:10:52,986
about what's happening, it's

339
00:10:52,986 --> 0:10:54,616
clear that the model isn't able

340
00:10:54,616 --> 0:10:56,476
to tell those apart as two

341
00:10:56,476 --> 0:10:58,986
separate dice, and it really

342
00:10:58,986 --> 0:11:00,246
comes down to the fact that the

343
00:10:58,986 --> 0:11:00,246
comes down to the fact that the

344
00:11:00,246 --> 0:11:01,966
4 is being occluded by the one

345
00:11:01,966 --> 0:11:02,346
in front.

346
00:11:03,646 --> 0:11:05,266
So after thinking about this a

347
00:11:05,266 --> 0:11:06,936
little bit, what we realized was

348
00:11:06,936 --> 0:11:09,356
that we really care about the

349
00:11:09,356 --> 0:11:11,296
tops of these dice, and those

350
00:11:11,296 --> 0:11:12,796
are always visible in our frame.

351
00:11:13,946 --> 0:11:15,916
So we went ahead and we helped

352
00:11:15,916 --> 0:11:17,396
our model a little bit.

353
00:11:17,846 --> 0:11:19,616
We updated all our training data

354
00:11:19,776 --> 0:11:21,436
to actually focus in on the tops

355
00:11:21,436 --> 0:11:21,896
of these dice.

356
00:11:22,566 --> 0:11:24,616
So now we're actually training

357
00:11:24,616 --> 0:11:26,256
an object detector, not to

358
00:11:26,256 --> 0:11:27,996
detect dice, but to detect tops

359
00:11:27,996 --> 0:11:28,316
of dice.

360
00:11:29,406 --> 0:11:30,506
So let's take a look at what

361
00:11:30,506 --> 0:11:31,326
happened when we did that.

362
00:11:31,756 --> 0:11:34,326
As you can see, our model was

363
00:11:34,326 --> 0:11:36,646
still able to correctly predict

364
00:11:36,766 --> 0:11:39,206
and classify the same dice as

365
00:11:39,206 --> 0:11:41,726
before, but now it's also able

366
00:11:41,726 --> 0:11:43,786
to correctly detect and identify

367
00:11:43,786 --> 0:11:44,516
the dice on the right.

368
00:11:47,476 --> 0:11:48,916
We wanted to share with you

369
00:11:48,916 --> 0:11:49,926
another anecdote today.

370
00:11:51,396 --> 0:11:53,396
At some point along our journey,

371
00:11:53,886 --> 0:11:55,946
we noticed this behavior, where

372
00:11:55,946 --> 0:11:57,466
our model was actually detecting

373
00:11:57,726 --> 0:11:58,896
the left side of the dice,

374
00:11:59,046 --> 0:11:59,666
consistently.

375
00:12:01,076 --> 0:12:02,146
This was very confusing at

376
00:12:02,146 --> 0:12:04,096
first, but if we actually rotate

377
00:12:04,096 --> 0:12:05,936
this image, we can understand

378
00:12:06,006 --> 0:12:07,106
how the model thought these were

379
00:12:07,106 --> 0:12:07,616
the tops.

380
00:12:08,496 --> 0:12:09,816
This was super easy to realize

381
00:12:10,056 --> 0:12:10,986
as soon as we looked at the

382
00:12:10,986 --> 0:12:12,356
input of our model.

383
00:12:13,146 --> 0:12:14,486
We were simply not handling the

384
00:12:14,486 --> 0:12:15,966
image orientation according to

385
00:12:15,966 --> 0:12:17,426
our device's orientation, which

386
00:12:17,426 --> 0:12:18,616
is a very common problem for

387
00:12:18,616 --> 0:12:20,266
Vision tasks.

388
00:12:20,266 --> 0:12:21,926
So the key lesson here is, if

389
00:12:21,926 --> 0:12:23,506
you notice odd behavior in your

390
00:12:23,506 --> 0:12:25,046
model's output, it doesn't hurt

391
00:12:25,046 --> 0:12:26,056
to take a look at the input.

392
00:12:26,896 --> 0:12:29,336
It may be as simple as rotating

393
00:12:29,336 --> 0:12:30,466
your image based on the

394
00:12:30,466 --> 0:12:33,276
orientation of the device.

395
00:12:33,446 --> 0:12:34,756
So let's see this new model in

396
00:12:34,796 --> 0:12:35,000
action.

397
00:12:43,696 --> 0:12:45,026
So here we have the same app,

398
00:12:45,686 --> 0:12:47,356
but we updated it to have our

399
00:12:47,546 --> 0:12:49,326
model that's able to detect and

400
00:12:49,356 --> 0:12:51,666
classify diced as well.

401
00:12:51,766 --> 0:12:52,816
For simplicity, I'm going to

402
00:12:52,816 --> 0:12:53,756
focus on three dice.

403
00:12:54,216 --> 0:12:56,286
We can see that our model is

404
00:12:56,716 --> 0:12:58,406
predicting 6, 5 and 2.

405
00:12:59,426 --> 0:12:59,976
So let's take a roll.

406
00:13:02,996 --> 0:13:04,476
Four, 6 and 5.

407
00:13:05,316 --> 0:13:06,566
Awesome. This is really

408
00:13:06,566 --> 0:13:06,936
promising.

409
00:13:07,516 --> 0:13:10,716
[ Applause ]

410
00:13:11,216 --> 0:13:12,076
So I want to bring your

411
00:13:12,076 --> 0:13:13,756
attention to a detail here that

412
00:13:13,806 --> 0:13:14,856
I think is very important.

413
00:13:15,606 --> 0:13:17,296
If I move the dice around, you

414
00:13:17,296 --> 0:13:18,656
can see that the list updates.

415
00:13:19,146 --> 0:13:20,816
We're actually displaying the

416
00:13:20,816 --> 0:13:22,566
list of values according to the

417
00:13:22,566 --> 0:13:24,146
order in which the dice are laid

418
00:13:24,146 --> 0:13:24,786
out on the table.

419
00:13:25,476 --> 0:13:26,916
This is a minor design detail,

420
00:13:27,396 --> 0:13:29,426
but it really brings consistency

421
00:13:29,426 --> 0:13:30,576
to the experience, because the

422
00:13:30,576 --> 0:13:32,166
user is seeing these dice laid

423
00:13:32,166 --> 0:13:33,266
out in that fashion on the

424
00:13:33,266 --> 0:13:33,586
table.

425
00:13:34,126 --> 0:13:36,196
So since we're blending the

426
00:13:36,196 --> 0:13:37,506
physical and virtual worlds,

427
00:13:38,186 --> 0:13:40,976
we're actually giving the user a

428
00:13:42,246 --> 0:13:43,876
very consistent display of the

429
00:13:43,876 --> 0:13:44,406
predictions.

430
00:13:45,536 --> 0:13:46,436
There's another thing we need to

431
00:13:46,436 --> 0:13:48,446
figure out: when does a roll

432
00:13:48,446 --> 0:13:48,696
end?

433
00:13:49,626 --> 0:13:51,466
Again, games typically don't

434
00:13:51,466 --> 0:13:53,936
rely on transient states of a

435
00:13:53,936 --> 0:13:55,516
roll; they rely on the result of

436
00:13:55,516 --> 0:13:55,636
a roll.

437
00:13:55,636 --> 0:13:57,086
When you play a game, you roll

438
00:13:57,086 --> 0:13:58,546
some dice, and based on the

439
00:13:58,546 --> 0:14:00,836
result of that, your pawn either

440
00:13:58,546 --> 0:14:00,836
result of that, your pawn either

441
00:14:00,836 --> 0:14:02,696
moves or you make some decision.

442
00:14:02,776 --> 0:14:04,276
In this case, we may want to

443
00:14:04,366 --> 0:14:05,806
animate something or provide

444
00:14:05,876 --> 0:14:06,996
feedback to the user.

445
00:14:07,276 --> 0:14:08,386
And you may have noticed in the

446
00:14:08,386 --> 0:14:10,036
demos that I just showed, I

447
00:14:10,036 --> 0:14:11,516
didn't show the numbers until

448
00:14:11,516 --> 0:14:12,326
the roll had ended.

449
00:14:13,086 --> 0:14:14,726
So how do we do this?

450
00:14:15,656 --> 0:14:16,736
Well, first we need to ask our

451
00:14:16,736 --> 0:14:18,336
self, what do we observe?

452
00:14:19,906 --> 0:14:21,756
In this case, we notice that the

453
00:14:21,756 --> 0:14:23,816
dice stop moving and the values

454
00:14:23,816 --> 0:14:25,336
are stable between different

455
00:14:25,336 --> 0:14:26,026
camera frames.

456
00:14:27,196 --> 0:14:28,696
So can machine learning help us

457
00:14:28,696 --> 0:14:28,926
here?

458
00:14:29,966 --> 0:14:32,716
Perhaps we could build a

459
00:14:32,716 --> 0:14:34,056
sequential model that takes in

460
00:14:34,096 --> 0:14:36,026
frames and decides when the roll

461
00:14:36,026 --> 0:14:37,636
has ended, but we already have a

462
00:14:37,636 --> 0:14:38,886
model that has a really good

463
00:14:38,886 --> 0:14:40,126
understanding of dice on the

464
00:14:40,126 --> 0:14:40,416
table.

465
00:14:40,816 --> 0:14:42,466
So what we really need to do is

466
00:14:42,466 --> 0:14:43,496
interpret the output of our

467
00:14:43,496 --> 0:14:43,816
model.

468
00:14:46,256 --> 0:14:47,746
So let's take a look at how to

469
00:14:47,746 --> 0:14:50,386
do this in code.

470
00:14:50,586 --> 0:14:51,956
Here we have a function that

471
00:14:51,956 --> 0:14:54,046
takes in two lists of object

472
00:14:54,046 --> 0:14:55,416
observations: one from the

473
00:14:55,416 --> 0:14:56,906
current camera frame and one

474
00:14:56,966 --> 0:14:58,286
from the previous camera frame.

475
00:14:59,336 --> 0:15:00,276
So there's a few things we need

476
00:14:59,336 --> 0:15:00,276
So there's a few things we need

477
00:15:00,276 --> 0:15:01,746
to check in order to decide that

478
00:15:01,776 --> 0:15:02,526
the roll has ended.

479
00:15:03,476 --> 0:15:05,396
The first is, do we have as many

480
00:15:05,396 --> 0:15:06,946
dice now as we had before?

481
00:15:07,996 --> 0:15:10,046
If not, maybe one die has

482
00:15:10,046 --> 0:15:11,206
entered the camera frame, so we

483
00:15:11,206 --> 0:15:12,346
now have more than before.

484
00:15:12,836 --> 0:15:14,226
If we have less than before,

485
00:15:14,536 --> 0:15:15,796
maybe one of them is bouncing

486
00:15:15,796 --> 0:15:17,186
around so the detector isn't

487
00:15:17,186 --> 0:15:18,526
picking that up.

488
00:15:19,216 --> 0:15:21,246
So if we don't have as many now

489
00:15:21,376 --> 0:15:22,986
as before, the roll is still

490
00:15:23,016 --> 0:15:23,336
happening.

491
00:15:23,816 --> 0:15:26,036
Next we're going to compare each

492
00:15:26,036 --> 0:15:27,366
of the observations in the

493
00:15:27,366 --> 0:15:29,586
previous prediction and in the

494
00:15:29,586 --> 0:15:30,136
current one.

495
00:15:31,516 --> 0:15:32,876
If the values represented on top

496
00:15:32,876 --> 0:15:35,606
of the dice aren't the same, our

497
00:15:35,606 --> 0:15:37,306
roll has not ended yet.

498
00:15:38,036 --> 0:15:40,186
And we also check that the

499
00:15:40,186 --> 0:15:41,456
bounding boxes overlap between

500
00:15:41,456 --> 0:15:42,666
these predictions by more than

501
00:15:42,666 --> 0:15:43,366
85%.

502
00:15:44,296 --> 0:15:45,576
If the bounding boxes between

503
00:15:45,576 --> 0:15:46,776
the prediction we're looking at

504
00:15:46,776 --> 0:15:48,036
and the one we're comparing it

505
00:15:48,036 --> 0:15:49,736
with don't overlap, either we're

506
00:15:49,736 --> 0:15:50,666
looking at two completely

507
00:15:50,666 --> 0:15:54,086
different dice, or it's the same

508
00:15:54,086 --> 0:15:55,036
one that has moved by a

509
00:15:55,096 --> 0:15:55,846
significant amount.

510
00:15:57,106 --> 0:15:59,726
Finally, if we have as many

511
00:15:59,726 --> 0:16:01,306
matches now as we have dice on

512
00:15:59,726 --> 0:16:01,306
matches now as we have dice on

513
00:16:01,306 --> 0:16:02,956
the table, the roll has ended.

514
00:16:03,466 --> 0:16:07,966
So now that our app can find,

515
00:16:08,126 --> 0:16:11,156
count, recognize dice on a table

516
00:16:11,196 --> 0:16:13,516
and figuring out the end of a

517
00:16:13,516 --> 0:16:15,486
roll, we have a foundation for

518
00:16:15,756 --> 0:16:16,576
building something more.

519
00:16:17,206 --> 0:16:18,246
And it's time to talk about the

520
00:16:18,246 --> 0:16:19,186
next steps of our journey.

521
00:16:19,976 --> 0:16:21,536
To do that, I'd like to welcome

522
00:16:21,536 --> 0:16:22,516
Brent back up to the stage.

523
00:16:23,516 --> 0:16:26,036
[ Applause ]

524
00:16:26,536 --> 0:16:27,036
&gt;&gt; Thank you, Scott.

525
00:16:29,406 --> 0:16:30,456
All right.

526
00:16:30,456 --> 0:16:33,436
As Scott said, our app can now

527
00:16:33,436 --> 0:16:34,816
recognize dice on the table.

528
00:16:35,906 --> 0:16:36,836
The next thing we need to look

529
00:16:36,836 --> 0:16:39,076
at is, how do we handle user

530
00:16:39,076 --> 0:16:39,426
input?

531
00:16:39,426 --> 0:16:42,706
We know that our users are going

532
00:16:42,706 --> 0:16:44,016
to be entering numbers into our

533
00:16:44,016 --> 0:16:45,046
app, because we're practicing

534
00:16:45,046 --> 0:16:45,776
math skills.

535
00:16:45,846 --> 0:16:48,716
And we could've just put a large

536
00:16:48,716 --> 0:16:50,146
number pad up on the screen and

537
00:16:50,146 --> 0:16:51,386
have them tap in the numbers,

538
00:16:51,716 --> 0:16:53,816
but we wanted to facilitate a

539
00:16:53,816 --> 0:16:55,656
more natural interaction with

540
00:16:55,656 --> 0:16:55,896
the app.

541
00:16:56,146 --> 0:16:58,226
And remember: we're working with

542
00:16:58,226 --> 0:17:00,116
children here, and children are

543
00:16:58,226 --> 0:17:00,116
children here, and children are

544
00:17:00,116 --> 0:17:01,386
also practicing writing their

545
00:17:01,386 --> 0:17:01,936
numbers.

546
00:17:02,596 --> 0:17:04,846
So we thought, why not just let

547
00:17:04,846 --> 0:17:06,435
them draw directly on the

548
00:17:06,435 --> 0:17:06,856
screen?

549
00:17:06,856 --> 0:17:10,516
Well, to do this, we're going to

550
00:17:10,516 --> 0:17:11,256
need our app to be able to

551
00:17:11,256 --> 0:17:12,806
recognize handwritten digits.

552
00:17:13,976 --> 0:17:15,506
Fortunately, machine learning is

553
00:17:15,506 --> 0:17:16,695
already doing a very good job at

554
00:17:16,695 --> 0:17:18,786
solving this problem; in fact,

555
00:17:19,106 --> 0:17:20,236
there's an entire dataset

556
00:17:20,236 --> 0:17:22,156
available to let you train your

557
00:17:22,156 --> 0:17:23,205
own models to recognize

558
00:17:23,266 --> 0:17:24,026
handwritten digits.

559
00:17:24,026 --> 0:17:25,086
It's called MNIST.

560
00:17:26,396 --> 0:17:28,185
Well, we did that, and we put

561
00:17:28,185 --> 0:17:29,726
that model on our new Core ML

562
00:17:29,726 --> 0:17:30,406
Models page.

563
00:17:31,576 --> 0:17:33,346
So let's take a look in code at

564
00:17:33,346 --> 0:17:34,436
how we'd use this model.

565
00:17:35,336 --> 0:17:36,396
We're going to use Vision and

566
00:17:36,396 --> 0:17:37,076
PencilKit here.

567
00:17:37,676 --> 0:17:40,696
We set up Vision to use our Core

568
00:17:40,696 --> 0:17:42,226
ML model; in this case,

569
00:17:42,226 --> 0:17:43,066
MNISTClassifier.

570
00:17:43,536 --> 0:17:47,756
Next, we get our image from the

571
00:17:47,756 --> 0:17:48,796
PencilKit canvas view.

572
00:17:48,966 --> 0:17:52,876
After that, we set up our Vision

573
00:17:52,876 --> 0:17:54,436
request handler to use that

574
00:17:54,436 --> 0:17:54,906
image.

575
00:17:56,356 --> 0:17:59,286
Then, we perform the request and

576
00:17:59,286 --> 0:18:00,076
we get the results.

577
00:17:59,286 --> 0:18:00,076
we get the results.

578
00:18:00,076 --> 0:18:00,976
It's as easy as that.

579
00:18:03,576 --> 0:18:04,956
So we integrated this into our

580
00:18:04,956 --> 0:18:07,916
model, and it started working

581
00:18:08,076 --> 0:18:08,616
pretty well.

582
00:18:08,616 --> 0:18:10,716
We were recognizing quite a few

583
00:18:10,716 --> 0:18:11,596
handwritten digits.

584
00:18:14,276 --> 0:18:15,976
But as we started drawing some

585
00:18:15,976 --> 0:18:17,506
larger digits, we noticed

586
00:18:17,506 --> 0:18:19,856
something interesting: our model

587
00:18:19,856 --> 0:18:20,766
was sometimes getting the

588
00:18:20,766 --> 0:18:21,906
predictions incorrect.

589
00:18:22,696 --> 0:18:24,566
So what's happening?

590
00:18:24,946 --> 0:18:27,646
Well, to understand, we need to

591
00:18:27,646 --> 0:18:30,236
see what image is being input to

592
00:18:30,236 --> 0:18:30,706
our model.

593
00:18:30,706 --> 0:18:33,186
And we can do that in Xcode.

594
00:18:34,286 --> 0:18:36,626
So we set a break point where we

595
00:18:36,626 --> 0:18:38,096
get the image from PencilKit,

596
00:18:38,096 --> 0:18:40,886
and we use Xcode's quick view to

597
00:18:41,206 --> 0:18:42,406
actually look at what that image

598
00:18:42,406 --> 0:18:42,826
is.

599
00:18:42,956 --> 0:18:44,996
And when we did, we saw

600
00:18:44,996 --> 0:18:47,456
something interesting: our 7s

601
00:18:47,456 --> 0:18:49,766
from the example are not looking

602
00:18:49,766 --> 0:18:51,126
like 7s to the model.

603
00:18:51,786 --> 0:18:52,956
They're looking a lot more like

604
00:18:52,956 --> 0:18:53,446
1s.

605
00:18:54,006 --> 0:18:56,396
So what's happening here?

606
00:18:56,396 --> 0:19:00,066
We need to think about what the

607
00:18:56,396 --> 0:19:00,066
We need to think about what the

608
00:19:00,066 --> 0:19:01,506
model's expecting for an input.

609
00:19:02,956 --> 0:19:05,506
This model is expecting a 28 by

610
00:19:05,506 --> 0:19:08,796
28 pixel image, but the image

611
00:19:08,796 --> 0:19:10,156
that we get drawn on the screen

612
00:19:10,156 --> 0:19:11,846
is much bigger than that.

613
00:19:13,096 --> 0:19:14,406
So to get the image in the right

614
00:19:14,456 --> 0:19:15,836
format, we have to downscale it.

615
00:19:16,656 --> 0:19:18,716
But as we downscaled it, we lost

616
00:19:18,716 --> 0:19:20,026
information about the strokes

617
00:19:20,026 --> 0:19:20,836
that were being drawn on the

618
00:19:20,836 --> 0:19:23,006
screen, and our 7s started

619
00:19:23,006 --> 0:19:24,316
looking a lot more like 1s.

620
00:19:24,716 --> 0:19:28,376
Once we knew that, the fix was

621
00:19:28,406 --> 0:19:29,786
pretty easy: we just needed to

622
00:19:29,786 --> 0:19:31,016
have a thicker stroke on the

623
00:19:31,016 --> 0:19:31,476
screen.

624
00:19:31,556 --> 0:19:35,046
And when we did that, after we

625
00:19:35,046 --> 0:19:37,006
downscaled, our images going to

626
00:19:37,006 --> 0:19:38,806
the model looked a lot more like

627
00:19:38,806 --> 0:19:39,776
what was being drawn on the

628
00:19:39,776 --> 0:19:41,766
screen, and the model started

629
00:19:41,766 --> 0:19:43,446
getting the predictions correct.

630
00:19:44,836 --> 0:19:46,386
PencilKit makes this really

631
00:19:46,386 --> 0:19:46,616
easy.

632
00:19:47,786 --> 0:19:49,746
Here we have allowsFingerDrawing

633
00:19:49,746 --> 0:19:51,436
set to true, since we're drawing

634
00:19:51,436 --> 0:19:52,726
on the screen with our fingers;

635
00:19:52,856 --> 0:19:56,826
and then, we set the tool to be

636
00:19:56,906 --> 0:19:57,556
something like a marker with a

637
00:19:57,556 --> 0:19:57,976
thicker stroke.

638
00:20:01,356 --> 0:20:01,976
All right.

639
00:20:01,976 --> 0:20:04,416
Our model is now predicting

640
00:20:05,426 --> 0:20:07,706
single digits really well, but

641
00:20:08,396 --> 0:20:09,906
we have another couple

642
00:20:09,906 --> 0:20:10,536
challenges.

643
00:20:11,396 --> 0:20:13,766
Some digits are written with

644
00:20:13,766 --> 0:20:14,976
multiple strokes.

645
00:20:15,506 --> 0:20:19,096
Our model takes a static image

646
00:20:19,176 --> 0:20:20,796
of a digit, not stroke

647
00:20:20,796 --> 0:20:21,926
information about that digit.

648
00:20:23,016 --> 0:20:24,466
So how do we know when to take

649
00:20:24,766 --> 0:20:26,126
what's being drawn on the screen

650
00:20:26,196 --> 0:20:28,416
and pass it to our model to get

651
00:20:29,126 --> 0:20:30,276
a prediction?

652
00:20:30,276 --> 0:20:33,816
Additionally, since we're adding

653
00:20:33,816 --> 0:20:35,246
dice or possibly multiplying

654
00:20:35,246 --> 0:20:36,576
dice, we may be working with

655
00:20:36,576 --> 0:20:37,566
numbers that have multiple

656
00:20:37,566 --> 0:20:39,896
digits, and our model is only

657
00:20:39,896 --> 0:20:41,116
trained to recognize single

658
00:20:41,116 --> 0:20:43,236
digits, not multiple digits.

659
00:20:44,096 --> 0:20:45,726
So how do we handle that?

660
00:20:46,496 --> 0:20:47,586
We could've used machine

661
00:20:47,586 --> 0:20:48,606
learning to solve these

662
00:20:48,606 --> 0:20:48,956
problems.

663
00:20:48,956 --> 0:20:50,456
We could've trained a model to

664
00:20:50,456 --> 0:20:51,796
recognize stroke information

665
00:20:51,796 --> 0:20:54,156
about digits, or we could've

666
00:20:54,156 --> 0:20:55,686
trained a model to recognize

667
00:20:55,686 --> 0:20:56,936
numbers with multiple digits,

668
00:20:56,986 --> 0:20:58,826
but we already know a lot of

669
00:20:58,826 --> 0:21:00,086
information about what's being

670
00:20:58,826 --> 0:21:00,086
information about what's being

671
00:21:00,086 --> 0:21:00,876
drawn on the screen.

672
00:21:01,386 --> 0:21:03,236
So instead, we decided to solve

673
00:21:03,236 --> 0:21:04,576
this problem programmatically,

674
00:21:04,876 --> 0:21:05,896
and I'll show you how.

675
00:21:06,426 --> 0:21:08,676
Let's take this example.

676
00:21:09,736 --> 0:21:11,116
Someone draws the first stroke

677
00:21:11,116 --> 0:21:12,426
of a 1 on the screen.

678
00:21:12,426 --> 0:21:15,406
We take that, we pass it as an

679
00:21:15,406 --> 0:21:16,626
image to our model, and we get a

680
00:21:16,626 --> 0:21:17,796
prediction, and it's a 1.

681
00:21:19,246 --> 0:21:20,766
Next, they draw the second

682
00:21:20,766 --> 0:21:23,766
stroke of a 1, the base.

683
00:21:23,966 --> 0:21:25,616
We look to see if any of that

684
00:21:25,616 --> 0:21:27,676
stroke is overlapping any of the

685
00:21:27,676 --> 0:21:28,216
first stroke.

686
00:21:29,086 --> 0:21:30,836
Since it is, we know that it's

687
00:21:30,836 --> 0:21:32,976
the same number, so we get rid

688
00:21:32,976 --> 0:21:34,716
of the first prediction, we

689
00:21:34,716 --> 0:21:35,916
combine the first stroke with

690
00:21:35,916 --> 0:21:37,756
the second stroke into one

691
00:21:37,756 --> 0:21:39,296
image, and we pass that entire

692
00:21:39,296 --> 0:21:40,026
image to the model.

693
00:21:40,136 --> 0:21:41,916
And that gets predicted to be a

694
00:21:41,916 --> 0:21:42,156
1.

695
00:21:42,696 --> 0:21:45,536
Next, the user draws another

696
00:21:45,536 --> 0:21:46,326
stroke on the screen.

697
00:21:47,546 --> 0:21:49,176
We look at that third stroke and

698
00:21:49,176 --> 0:21:51,926
see if any of it overlaps either

699
00:21:51,926 --> 0:21:52,876
of the first two strokes.

700
00:21:53,746 --> 0:21:55,306
Since it doesn't, we know that

701
00:21:55,306 --> 0:21:56,906
it's a separate number, so we

702
00:21:56,906 --> 0:21:58,226
pass it separately to the model,

703
00:21:58,226 --> 0:22:02,356
and it gets predicted to be a 2.

704
00:21:58,226 --> 0:22:02,356
and it gets predicted to be a 2.

705
00:22:02,596 --> 0:22:03,516
Now I'd like to invite Scott

706
00:22:03,516 --> 0:22:05,756
back up to show you this in the

707
00:22:05,826 --> 0:22:06,126
app.

708
00:22:06,126 --> 0:22:06,416
Scott?

709
00:22:07,516 --> 0:22:11,416
[ Applause ]

710
00:22:11,916 --> 0:22:12,316
&gt;&gt; Thanks, Brent.

711
00:22:13,136 --> 0:22:15,166
We now have an updated app that

712
00:22:15,266 --> 0:22:16,876
still has our object detector

713
00:22:16,876 --> 0:22:18,316
that's able to detect and

714
00:22:18,536 --> 0:22:20,716
classify dice and their values,

715
00:22:21,136 --> 0:22:22,536
but we've also added the ability

716
00:22:22,606 --> 0:22:23,856
to draw input just like Brent

717
00:22:23,856 --> 0:22:24,486
discussed with you.

718
00:22:25,716 --> 0:22:27,576
So I think it's time to do some

719
00:22:27,576 --> 0:22:27,726
math.

720
00:22:30,276 --> 0:22:31,796
Here, the user has the option to

721
00:22:31,796 --> 0:22:33,426
either add the values displayed

722
00:22:33,426 --> 0:22:34,986
on the dice or multiply them.

723
00:22:35,306 --> 0:22:36,726
And so to keep things simple,

724
00:22:36,726 --> 0:22:37,406
I'm going to start with

725
00:22:37,406 --> 0:22:37,816
addition.

726
00:22:38,426 --> 0:22:40,066
So let's see how input handling

727
00:22:40,066 --> 0:22:40,266
works.

728
00:22:44,896 --> 0:22:45,036
Yes.

729
00:22:46,516 --> 0:22:50,626
[ Applause ]

730
00:22:51,126 --> 0:22:53,516
So if we multiply these values,

731
00:22:53,516 --> 0:22:55,036
I'm pretty sure we get 24.

732
00:22:56,036 --> 0:22:56,876
Now, that's an interesting

733
00:22:56,876 --> 0:22:57,316
number.

734
00:22:57,826 --> 0:22:58,666
I want you to pay close

735
00:22:58,666 --> 0:23:00,146
attention to what happens when I

736
00:22:58,666 --> 0:23:00,146
attention to what happens when I

737
00:23:00,146 --> 0:23:01,226
draw the 4 on screen.

738
00:23:02,756 --> 0:23:04,236
If you think about a 4 that's

739
00:23:04,236 --> 0:23:06,076
drawn with two strokes, our

740
00:23:06,076 --> 0:23:07,086
model's going to have a pretty

741
00:23:07,086 --> 0:23:08,336
hard time figuring out that's a

742
00:23:08,456 --> 0:23:10,046
4 when it only sees the first

743
00:23:10,046 --> 0:23:11,746
stroke, so it may predict some

744
00:23:11,746 --> 0:23:13,396
other digit until I draw the

745
00:23:13,396 --> 0:23:13,966
second stroke.

746
00:23:15,066 --> 0:23:15,626
Let's have a look.

747
00:23:21,276 --> 0:23:22,646
Did you notice that the first

748
00:23:22,646 --> 0:23:24,046
stroke of my 4 was predicted as

749
00:23:24,046 --> 0:23:25,676
a 1, but as soon as I had the

750
00:23:25,726 --> 0:23:27,176
second stroke, that was a 4?

751
00:23:27,946 --> 0:23:30,646
There's one other answer that is

752
00:23:30,716 --> 0:23:33,026
always correct, and I just want

753
00:23:33,026 --> 0:23:34,376
to show you more 4s, so let's

754
00:23:34,546 --> 0:23:34,746
try it.

755
00:23:40,426 --> 0:23:43,846
Cool. So our app can recognize

756
00:23:43,846 --> 0:23:45,316
dice on the table, understand a

757
00:23:45,316 --> 0:23:47,576
roll, it can check our math, we

758
00:23:47,576 --> 0:23:50,806
can input that using drawing to

759
00:23:50,996 --> 0:23:52,716
draw the digits on screen, but

760
00:23:52,716 --> 0:23:53,896
we're talking about blending the

761
00:23:53,896 --> 0:23:55,246
physical and virtual worlds

762
00:23:55,246 --> 0:23:56,846
together, so we thought it would

763
00:23:56,846 --> 0:23:58,526
be a lot of fun and also very

764
00:23:58,526 --> 0:24:01,036
interactive if the kids playing

765
00:23:58,526 --> 0:24:01,036
interactive if the kids playing

766
00:24:01,036 --> 0:24:02,606
with our game could input their

767
00:24:02,606 --> 0:24:04,116
answers in the form of voice.

768
00:24:04,786 --> 0:24:07,766
So let's take a look at that.

769
00:24:07,766 --> 0:24:09,416
Again, I'm going to add or

770
00:24:09,416 --> 0:24:10,756
multiply these two together and

771
00:24:10,756 --> 0:24:11,516
get 24.

772
00:24:11,926 --> 0:24:13,646
And let's do that using speech.

773
00:24:14,906 --> 0:24:16,096
Twenty-four.

774
00:24:17,616 --> 0:24:18,466
Cool.

775
00:24:21,276 --> 0:24:22,686
This is super easy to do using

776
00:24:22,686 --> 0:24:23,396
the speech framework.

777
00:24:23,966 --> 0:24:29,836
And new this year in speech, we

778
00:24:29,836 --> 0:24:32,166
have offline speech recognition.

779
00:24:33,096 --> 0:24:34,406
This means that speech

780
00:24:34,406 --> 0:24:35,756
recognition can work in your app

781
00:24:36,126 --> 0:24:37,566
even when your device is not

782
00:24:37,566 --> 0:24:38,516
connected to the internet.

783
00:24:39,566 --> 0:24:41,586
And if you really want your

784
00:24:41,586 --> 0:24:43,746
user's data to remain on their

785
00:24:43,746 --> 0:24:45,696
device, you can actually require

786
00:24:45,696 --> 0:24:47,236
speech recognition to happen on

787
00:24:47,236 --> 0:24:48,226
device by setting

788
00:24:48,506 --> 0:24:50,026
requiresOnDeviceRecognition to

789
00:24:50,026 --> 0:24:50,946
true on your speech recognizer.

790
00:24:54,406 --> 0:24:56,326
So now our app can understand a

791
00:24:56,326 --> 0:24:58,206
dice roll and handle input in

792
00:24:58,206 --> 0:25:00,716
various different ways, but we

793
00:24:58,206 --> 0:25:00,716
various different ways, but we

794
00:25:00,716 --> 0:25:02,706
need to move on with our journey

795
00:25:02,796 --> 0:25:04,856
and finish this up.

796
00:25:05,116 --> 0:25:06,206
So I'd like to welcome Brent

797
00:25:06,206 --> 0:25:06,956
back up to the stage.

798
00:25:07,516 --> 0:25:10,536
[ Applause ]

799
00:25:11,036 --> 0:25:11,546
&gt;&gt; Thank you, Scott.

800
00:25:17,576 --> 0:25:21,566
As Scott mentioned, we have our

801
00:25:21,566 --> 0:25:24,616
app recognizing dice, and we

802
00:25:24,616 --> 0:25:26,696
know how to handle user input.

803
00:25:27,366 --> 0:25:29,156
But we said this was going to be

804
00:25:29,156 --> 0:25:29,896
a game, right?

805
00:25:30,626 --> 0:25:34,026
So let's make it that.

806
00:25:34,026 --> 0:25:36,066
Next we're going to integrate in

807
00:25:36,066 --> 0:25:38,196
ARKit and really finalize the

808
00:25:38,196 --> 0:25:39,116
whole experience.

809
00:25:39,666 --> 0:25:45,266
Of course, any game needs rules,

810
00:25:45,546 --> 0:25:48,566
so let's go over those first.

811
00:25:50,416 --> 0:25:52,706
Our game is played on a circular

812
00:25:52,706 --> 0:25:54,516
board with nine sections.

813
00:25:55,206 --> 0:25:58,026
Each player starts on section

814
00:25:58,026 --> 0:26:00,606
one, and the goal is to move

815
00:25:58,026 --> 0:26:00,606
one, and the goal is to move

816
00:26:00,606 --> 0:26:02,486
clockwise around the board and

817
00:26:02,486 --> 0:26:04,666
land directly on section nine.

818
00:26:05,286 --> 0:26:09,536
A roll that's too small, and you

819
00:26:09,536 --> 0:26:11,226
don't go far enough.

820
00:26:12,656 --> 0:26:14,556
A roll that's too large, and

821
00:26:14,556 --> 0:26:16,396
you're going to overshoot your

822
00:26:18,596 --> 0:26:18,706
goal.

823
00:26:18,906 --> 0:26:20,256
During each player's turn, they

824
00:26:20,256 --> 0:26:22,616
roll the dice, and they have two

825
00:26:22,616 --> 0:26:25,496
options: they can take the sum

826
00:26:25,496 --> 0:26:27,516
of that dice and move that

827
00:26:27,516 --> 0:26:28,836
number in a clockwise direction,

828
00:26:29,666 --> 0:26:30,856
or they can take the difference

829
00:26:30,856 --> 0:26:33,006
of the dice and move that number

830
00:26:33,046 --> 0:26:33,926
in a clockwise direction.

831
00:26:35,166 --> 0:26:38,426
So Scott, you up for a game?

832
00:26:39,516 --> 0:26:43,500
[ Applause ]

833
00:26:50,356 --> 0:26:51,496
&gt;&gt; So we've now integrated our

834
00:26:51,496 --> 0:26:53,766
virtual board into our ARKit

835
00:26:53,806 --> 0:26:56,246
game that's also using Core ML

836
00:26:56,576 --> 0:26:57,366
to recognize dice.

837
00:26:58,036 --> 0:26:59,366
How about you start off, Brent?

838
00:26:59,666 --> 0:27:00,126
&gt;&gt; Sounds good.

839
00:26:59,666 --> 0:27:00,126
&gt;&gt; Sounds good.

840
00:27:01,306 --> 0:27:02,456
All right.

841
00:27:02,976 --> 0:27:06,356
The 5 -- I've got a 5 and a 2.

842
00:27:06,356 --> 0:27:07,046
All right.

843
00:27:07,046 --> 0:27:09,976
I think I'm going to add those.

844
00:27:15,376 --> 0:27:15,686
&gt;&gt; All right.

845
00:27:16,446 --> 0:27:17,656
Ooh, you got really close.

846
00:27:17,726 --> 0:27:17,976
&gt;&gt; Close.

847
00:27:22,056 --> 0:27:24,996
&gt;&gt; So we got 6 and 1; I can

848
00:27:24,996 --> 0:27:27,116
either subtract these and get 5

849
00:27:27,186 --> 0:27:29,436
or add them and join Brent on

850
00:27:29,436 --> 0:27:30,966
the 8 slot, so let's add these.

851
00:27:37,796 --> 0:27:38,276
&gt;&gt; All right.

852
00:27:38,516 --> 0:27:41,236
I don't think I'm going to be

853
00:27:41,236 --> 0:27:42,626
able to get a 1.

854
00:27:42,626 --> 0:27:42,806
Let's see.

855
00:27:47,776 --> 0:27:49,316
I think I'll subtract this time.

856
00:27:49,316 --> 0:27:49,826
Let me do a 2.

857
00:27:59,676 --> 0:28:01,446
&gt;&gt; Okay. So I got 6 and 1 again.

858
00:27:59,676 --> 0:28:01,446
&gt;&gt; Okay. So I got 6 and 1 again.

859
00:28:01,686 --> 0:28:02,746
This time I'm going to change it

860
00:28:02,746 --> 0:28:04,546
up and do a 5.

861
00:28:05,506 --> 0:28:07,746
And Brent really thinks -- yeah.

862
00:28:08,866 --> 0:28:10,066
Brent thinks I draw funny 5s.

863
00:28:10,926 --> 0:28:13,946
&gt;&gt; You know, this game could

864
00:28:13,946 --> 0:28:16,496
probably go on pretty long, but

865
00:28:16,986 --> 0:28:18,876
I think Scott might've mentioned

866
00:28:18,876 --> 0:28:20,786
something about a number always

867
00:28:20,786 --> 0:28:23,366
being correct, so let's see if

868
00:28:23,366 --> 0:28:23,926
this works in our game.

869
00:28:28,326 --> 0:28:29,646
&gt;&gt; Ah, you found the secret,

870
00:28:29,646 --> 0:28:29,966
Brent.

871
00:28:30,976 --> 0:28:31,536
Good job.

872
00:28:31,776 --> 0:28:31,976
&gt;&gt; Success.

873
00:28:32,516 --> 0:28:37,500
[ Applause ]

874
00:28:43,626 --> 0:28:44,086
All right.

875
00:28:44,736 --> 0:28:47,466
Today we looked at combining

876
00:28:47,516 --> 0:28:49,686
multiple technologies together

877
00:28:49,806 --> 0:28:51,376
to blend our physical and

878
00:28:51,376 --> 0:28:52,186
virtual worlds.

879
00:28:53,436 --> 0:28:54,686
We built an experience that goes

880
00:28:54,686 --> 0:28:56,566
beyond any single technology and

881
00:28:57,016 --> 0:28:58,646
it let us play this fun game in

882
00:28:58,646 --> 0:28:59,996
this enhanced new world.

883
00:29:01,366 --> 0:29:03,606
We used object detection to

884
00:29:03,606 --> 0:29:07,326
recognize dice on the table.

885
00:29:07,466 --> 0:29:09,476
We used image classification to

886
00:29:09,476 --> 0:29:11,246
recognize handwritten digits on

887
00:29:11,246 --> 0:29:11,706
the screen.

888
00:29:12,916 --> 0:29:14,556
We used speech recognition as

889
00:29:14,556 --> 0:29:15,606
another way to interact with our

890
00:29:15,606 --> 0:29:15,886
app.

891
00:29:16,266 --> 0:29:18,636
And we brought in ARKit to

892
00:29:18,636 --> 0:29:19,976
really finalize the whole

893
00:29:19,976 --> 0:29:20,666
experience.

894
00:29:22,376 --> 0:29:23,996
If you'd like more information,

895
00:29:24,766 --> 0:29:26,856
please see our session 228 on

896
00:29:26,856 --> 0:29:28,616
the developer website or come

897
00:29:28,676 --> 0:29:30,096
talk to us in the labs tomorrow.

898
00:29:30,716 --> 0:29:32,416
Thank you, and have a great rest

899
00:29:32,416 --> 0:29:32,756
of the show.

900
00:29:33,508 --> 0:29:35,508
[ Applause ]
