1
00:00:06,139 --> 0:00:10,677
（用Metal进行现代化渲染）

2
00:00:16,583 --> 0:00:17,584
大家好

3
00:00:17,784 --> 0:00:21,088
我是Jaap van Muijden

4
00:00:21,188 --> 0:00:22,756
用Metal进行现代化渲染的演讲

5
00:00:24,591 --> 0:00:25,859
在演讲的第一部分

6
00:00:26,460 --> 0:00:28,996
我会讲一些更高级的渲染技巧

7
00:00:29,129 --> 0:00:31,231
你如今可以在你的app中使用了

8
00:00:32,432 --> 0:00:34,468
然后我的同事

9
00:00:34,968 --> 0:00:38,338
会讲如何把你的CPU渲染循环移到

10
00:00:38,972 --> 0:00:40,974
更多GPU驱动的管道上

11
00:00:42,176 --> 0:00:47,714
最后我们讲如何使用新的GPU家族

12
00:00:48,248 --> 0:00:50,350
来写跨平台的代码

13
00:00:52,886 --> 0:00:54,421
无论你是从零开始

14
00:00:54,988 --> 0:00:56,990
或是想改善现有的

15
00:00:58,025 --> 0:01:00,594
或你有一个很棒的渲染引擎

16
00:00:58,025 --> 0:01:00,594
或你有一个很棒的渲染引擎

17
00:01:00,661 --> 0:01:01,929
Metal平台上

18
00:01:02,729 --> 0:01:06,400
我们会告诉你如何通过渲染技巧

19
00:01:07,668 --> 0:01:10,604
最大限度地利用可用硬件

20
00:01:12,005 --> 0:01:17,211
我们从如今的游戏和app使用的

21
00:01:17,277 --> 0:01:19,413
一些渲染技巧开始讲

22
00:01:21,181 --> 0:01:23,383
从基本延迟渲染开始

23
00:01:24,051 --> 0:01:26,220
这是最常用的渲染技巧

24
00:01:26,320 --> 0:01:29,890
游戏和图形app在所有平台上

25
00:01:30,490 --> 0:01:32,793
我们会讨论经典的双通道设置

26
00:01:33,994 --> 0:01:37,731
我们会告诉你如何在Metal上

27
00:01:38,165 --> 0:01:39,233
以及如何针对iOS平台

28
00:01:40,234 --> 0:01:44,338
然后我们继续讲平铺延迟

29
00:01:44,404 --> 0:01:45,572
它扩展了延迟渲染的照明通道

30
00:01:46,139 --> 0:01:48,942
如果需要复杂的照明设置的话

31
00:01:49,009 --> 0:01:50,010
它是个非常完美的功能

32
00:01:51,512 --> 0:01:53,280
然后我们会了解前向渲染

33
00:01:53,780 --> 0:01:56,617
这对于Metal app来说

34
00:01:56,783 --> 0:02:01,455
要求复杂的材料、抗锯齿、透明度

35
00:01:56,783 --> 0:02:01,455
要求复杂的材料、抗锯齿、透明度

36
00:02:01,522 --> 0:02:03,323
或特殊的性能考虑

37
00:02:06,426 --> 0:02:09,496
我们要讲的最后一个技巧是

38
00:02:10,097 --> 0:02:14,368
它推迟集合逻辑

39
00:02:14,535 --> 0:02:17,604
现在在Metal 3中

40
00:02:18,705 --> 0:02:21,675
但在此之前

41
00:02:23,443 --> 0:02:27,047
延迟渲染把场景渲染分为两个通道

42
00:02:28,215 --> 0:02:29,550
一个是几何通道

43
00:02:30,050 --> 0:02:31,985
你可以把你的整个场景渲染到

44
00:02:32,186 --> 0:02:34,555
过渡几何图形中

45
00:02:35,289 --> 0:02:38,859
这个缓冲区中的纹理

46
00:02:38,926 --> 0:02:42,896
所需要的所有法线、反照率、

47
00:02:42,963 --> 0:02:45,599
粗糙度和任意一种表面或材料属性

48
00:02:46,834 --> 0:02:53,073
然后在第二通道中

49
00:02:53,473 --> 0:02:56,977
并在一个累积纹理中创建

50
00:02:58,011 --> 0:03:01,815
延迟的光照着色器将把GBuffer中的

51
00:02:58,011 --> 0:03:01,815
延迟的光照着色器将把GBuffer中的

52
00:03:02,115 --> 0:03:05,352
从而计算对最终光照表面颜色的影响

53
00:03:06,553 --> 0:03:09,223
让我们先定义这个技巧的数据流

54
00:03:09,489 --> 0:03:11,825
然后再讲Metal实施

55
00:03:13,260 --> 0:03:16,396
在这里我们有两个渲染通道

56
00:03:16,463 --> 0:03:18,165
我们要在GPU上相继地运行

57
00:03:19,366 --> 0:03:22,936
在我们的几何通道中

58
00:03:23,470 --> 0:03:26,206
深度用于执行在几何通道过程中的

59
00:03:26,540 --> 0:03:30,477
但它可以用于给照明通道

60
00:03:30,577 --> 0:03:31,578
计算像素位置和世界空间

61
00:03:33,180 --> 0:03:35,415
并且我们还输出

62
00:03:35,649 --> 0:03:40,220
在我们的例子中 我们使用了法线、

63
00:03:41,421 --> 0:03:43,624
然后在我们的第二通道 照明通道中

64
00:03:43,957 --> 0:03:46,026
我们读回GBuffer纹理

65
00:03:46,960 --> 0:03:50,631
然后我们绘制光照体积并把它们

66
00:03:52,299 --> 0:03:54,568
让我们看一下如何在Metal中

67
00:03:56,136 --> 0:03:57,404
要在Metal中设置渲染通道

68
00:03:57,471 --> 0:03:59,873
你首先要有一个渲染通道描述符

69
00:04:01,175 --> 0:04:03,777
渲染通道描述符最重要的部分

70
00:04:03,844 --> 0:04:04,878
就是它的输出

71
00:04:05,445 --> 0:04:07,548
在Metal中

72
00:04:08,916 --> 0:04:11,285
每个渲染通道都可以拥有

73
00:04:11,618 --> 0:04:13,020
和多颜色附件

74
00:04:14,288 --> 0:04:18,125
对于每个附件来说

75
00:04:18,192 --> 0:04:19,426
纹理要指向存储我们附件数据的数据

76
00:04:20,627 --> 0:04:22,563
我们需要定义我们的加载动作

77
00:04:22,763 --> 0:04:25,766
那会告诉我们如何从纹理中加载

78
00:04:26,633 --> 0:04:31,138
并且存储动作就是如何把渲染结果

79
00:04:31,205 --> 0:04:32,506
存回纹理中

80
00:04:33,407 --> 0:04:36,410
当你定义好所有附件的这些属性之后

81
00:04:37,044 --> 0:04:40,581
你就可以创建渲染命令编码器

82
00:04:40,781 --> 0:04:44,885
然后你就可以最终在你的渲染通道中

83
00:04:46,153 --> 0:04:48,755
让我们看一下如何在Metal中

84
00:04:50,090 --> 0:04:52,526
这是我们的设置功能

85
00:04:53,093 --> 0:04:55,128
我们要从创建渲染通道描述符开始

86
00:04:55,762 --> 0:04:57,998
现在我们刚开始填充所有附件

87
00:04:58,131 --> 0:04:59,499
我们先从深度附件开始

88
00:05:00,234 --> 0:05:03,270
因为我们使用深度附件来执行

89
00:05:03,337 --> 0:05:05,906
我们要确保在开始渲染场景之前

90
00:05:06,306 --> 0:05:08,308
因此我们把加载动作设置为清除

91
00:05:08,876 --> 0:05:11,445
当然 我们想存储深度用于第二通道

92
00:05:12,012 --> 0:05:14,114
因此我们把存储类型设置为存储

93
00:05:15,215 --> 0:05:17,384
现在我们转到我们的颜色附件

94
00:05:18,352 --> 0:05:21,989
颜色附件 我们需要一个颜色附件

95
00:05:22,723 --> 0:05:25,058
因为所有这些纹理都将以同样的方式

96
00:05:25,125 --> 0:05:26,426
我们只讲一下反照率

97
00:05:27,928 --> 0:05:32,533
因为我们在渲染过程中很可能会使用

98
00:05:32,599 --> 0:05:36,470
因此我们非常确定我们会覆盖

99
00:05:36,537 --> 0:05:38,639
我们的每一个帧中的每一个像素

100
00:05:38,972 --> 0:05:41,441
那意味着我们并不真正关心

101
00:05:41,842 --> 0:05:43,043
我们的GBuffer纹理中

102
00:05:43,177 --> 0:05:45,913
因此我们可以把加载动作设为不关心

103
00:05:47,781 --> 0:05:50,117
当然 我们想将存储

104
00:05:50,184 --> 0:05:52,252
因此我们把存储动作设为存储

105
00:05:53,453 --> 0:05:56,023
现在我们可以创建照明通道描述符了

106
00:05:56,490 --> 0:06:00,694
我们创建另一个描述符对象

107
00:05:56,490 --> 0:06:00,694
我们创建另一个描述符对象

108
00:06:00,761 --> 0:06:01,929
用于累积缓冲区

109
00:06:02,629 --> 0:06:05,465
因为我们累积数据

110
00:06:05,532 --> 0:06:07,501
因此我们把加载动作设置为清除

111
00:06:08,535 --> 0:06:10,838
当然 我们想保存我们的最终图片

112
00:06:10,971 --> 0:06:12,606
因此我们的存储动作将是存储

113
00:06:14,875 --> 0:06:18,145
现在让我们看一下

114
00:06:18,212 --> 0:06:19,780
来实际绘制我们的场景时的渲染循环

115
00:06:20,747 --> 0:06:22,716
我们再次从几何通道开始看

116
00:06:23,217 --> 0:06:25,953
我们使用我们的描述符

117
00:06:26,854 --> 0:06:29,823
然后我们开始迭代场景中的所有度量

118
00:06:30,224 --> 0:06:33,093
这是渲染场景的一种非常简单的方式

119
00:06:34,461 --> 0:06:38,498
我的同事Srinivas

120
00:06:38,799 --> 0:06:41,502
讲如何把基础的CPU渲染循环

121
00:06:42,102 --> 0:06:45,239
移到更多GPU驱动的管道中

122
00:06:45,506 --> 0:06:46,773
通过各种剔除和LOD选择来实现

123
00:06:47,875 --> 0:06:50,477
好的 现在我们已经编写好

124
00:06:50,878 --> 0:06:55,382
抱歉 整个几何通道

125
00:06:55,449 --> 0:06:58,051
我们创建另一个渲染命令编码器

126
00:06:58,519 --> 0:07:01,688
现在我们开始迭代

127
00:06:58,519 --> 0:07:01,688
现在我们开始迭代

128
00:07:02,489 --> 0:07:04,525
每个光照 每个延迟光照着色器

129
00:07:04,691 --> 0:07:09,062
都将绑定这些来自GBuffer

130
00:07:10,430 --> 0:07:15,769
嗯 这两个通道系统在macOS

131
00:07:16,003 --> 0:07:17,171
所有平台上用起来都非常顺畅

132
00:07:17,571 --> 0:07:19,740
各种类型的硬件都支持

133
00:07:20,574 --> 0:07:23,644
但我们还可以采取一些措施

134
00:07:23,710 --> 0:07:24,978
在iOS上进一步优化我们的实施

135
00:07:25,812 --> 0:07:29,349
让我们从代码中退回到我们的概览中

136
00:07:30,684 --> 0:07:34,955
你可以看到在两个渲染通道之间的

137
00:07:35,856 --> 0:07:39,459
几何通道把它的所有数据

138
00:07:40,194 --> 0:07:41,929
然后照明通道又把它们都带回来了

139
00:07:42,462 --> 0:07:45,465
如果我们在单个像素上有多个光照点

140
00:07:45,632 --> 0:07:48,101
我们会多次执行这种读回

141
00:07:49,136 --> 0:07:52,072
通过在Metal中使用一种叫做

142
00:07:52,773 --> 0:07:55,108
我们可以避免把这个过渡负荷存储到

143
00:07:55,409 --> 0:08:00,614
设备内存中

144
00:07:55,409 --> 0:08:00,614
设备内存中

145
00:08:01,181 --> 0:08:03,050
我们要如何利用这种技巧呢？

146
00:08:04,318 --> 0:08:05,819
嗯 要启动可编程混合

147
00:08:05,886 --> 0:08:08,889
我们要合并几何通道和照明通道

148
00:08:09,289 --> 0:08:12,759
并按几何和光照规则创建一个

149
00:08:14,361 --> 0:08:19,533
因此 由于iOS架构的本质

150
00:08:19,600 --> 0:08:22,970
附件总是处于平铺内存中

151
00:08:24,104 --> 0:08:26,707
这意味着我们不仅可以写入附件中

152
00:08:26,773 --> 0:08:28,075
但我们实际上还会把它们读回

153
00:08:29,109 --> 0:08:32,513
我们可以读回我们写入的

154
00:08:32,813 --> 0:08:34,381
并且这就是我们想要实现的操作

155
00:08:34,448 --> 0:08:39,052
当我们计算照明通道中的光照时

156
00:08:39,219 --> 0:08:41,655
同一个像素的GBuffer附件

157
00:08:42,756 --> 0:08:46,293
让我们看看这会如何影响我们的

158
00:08:47,427 --> 0:08:50,264
在这里我们有来自照明通道的

159
00:08:51,064 --> 0:08:56,870
你可能知道 你只需要把所有

160
00:08:56,937 --> 0:08:59,239
就能得到GBuffer数据

161
00:08:59,940 --> 0:09:03,010
然后你在所有GBuffer纹理中

162
00:08:59,940 --> 0:09:03,010
然后你在所有GBuffer纹理中

163
00:09:03,076 --> 0:09:06,513
从而获取所有材料和表面信息

164
00:09:07,247 --> 0:09:10,117
只有这样你才可以把材料

165
00:09:10,184 --> 0:09:11,852
从而获得最终光照颜色

166
00:09:12,986 --> 0:09:15,589
现在让我们看一下如果我们使用

167
00:09:16,990 --> 0:09:21,695
我们不绑定所有纹理

168
00:09:22,829 --> 0:09:26,733
我们可以直接在照明模型中

169
00:09:28,836 --> 0:09:32,239
你可以看到我们已给GBuffer

170
00:09:32,306 --> 0:09:35,475
这是因为当你使用可编程混合时

171
00:09:35,542 --> 0:09:37,411
你不能访问深度附件

172
00:09:39,379 --> 0:09:43,250
现在我们不再绑定或取样任何纹理

173
00:09:43,717 --> 0:09:47,054
让我们看一下如何使用这个来进一步

174
00:09:49,122 --> 0:09:53,160
当使用可编程混合时

175
00:09:53,427 --> 0:09:54,695
我们不再从GBuffer纹理中

176
00:09:55,329 --> 0:09:59,466
我们可以把颜色附件的存储动作

177
00:10:00,801 --> 0:10:02,536
好的 这解决了带宽问题

178
00:10:02,970 --> 0:10:04,771
但我们仍然有这些

179
00:10:04,838 --> 0:10:06,139
占用我们设备上的空间

180
00:10:06,807 --> 0:10:09,510
我们需要告诉Metal

181
00:10:09,576 --> 0:10:12,112
为GBuffer纹理

182
00:10:13,180 --> 0:10:17,184
我们通过把纹理的存储模式设为

183
00:10:17,718 --> 0:10:21,121
我们告诉Metal我们不再对纹理

184
00:10:21,188 --> 0:10:22,422
实施任何存储动作了

185
00:10:22,689 --> 0:10:24,358
因此我们实际上不需要分配内存

186
00:10:25,726 --> 0:10:30,931
通过这些步骤

187
00:10:31,265 --> 0:10:35,335
具有GBuffer所有的优点

188
00:10:35,802 --> 0:10:36,937
但却没有内存或带宽负担

189
00:10:39,706 --> 0:10:42,576
在讲平铺延迟之前 让我们总结一下

190
00:10:43,243 --> 0:10:46,813
几何通道和照明通道的分离

191
00:10:47,080 --> 0:10:48,715
使得可编程混合成为一个

192
00:10:49,349 --> 0:10:52,186
它可以很好地处理

193
00:10:52,920 --> 0:10:57,824
并且GBuffer可用于促进

194
00:10:58,158 --> 0:11:03,063
整个管道可使用这个可编程混合方法

195
00:10:58,158 --> 0:11:03,063
整个管道可使用这个可编程混合方法

196
00:11:04,932 --> 0:11:08,635
在macOS上

197
00:11:08,702 --> 0:11:09,703
和带宽消耗

198
00:11:10,904 --> 0:11:13,607
现在让我们讲一下平铺照明方案

199
00:11:14,474 --> 0:11:17,978
这适用于想要渲染最大光照体积

200
00:11:18,278 --> 0:11:22,149
但仍想减少光照通道消耗的情况

201
00:11:24,985 --> 0:11:28,889
平铺延迟渲染技巧尝试解决

202
00:11:29,289 --> 0:11:30,858
渲染大体积光照而导致的性能问题

203
00:11:31,692 --> 0:11:34,094
在经典延迟中

204
00:11:34,661 --> 0:11:36,663
这由于重叠光照

205
00:11:36,830 --> 0:11:38,065
而导致了大量GBuffer消耗

206
00:11:39,533 --> 0:11:42,836
平铺延迟渲染通过一个额外的计算

207
00:11:42,903 --> 0:11:45,772
那就允许我们进行着色

208
00:11:45,839 --> 0:11:48,775
但不是按光照层级着色

209
00:11:50,310 --> 0:11:55,449
预通道首先把我们的屏幕分成

210
00:11:56,016 --> 0:11:58,085
并给每个平铺生成一个光照列表

211
00:11:59,253 --> 0:12:01,855
然后第二步就是照明

212
00:11:59,253 --> 0:12:01,855
然后第二步就是照明

213
00:12:02,389 --> 0:12:05,993
然后通过使用单一光照碎片着色器

214
00:12:06,326 --> 0:12:09,563
这些光照用于有效地照亮平铺

215
00:12:09,630 --> 0:12:10,631
但光照是光照列表中的光照

216
00:12:11,331 --> 0:12:15,502
在我们深入实施细节之前

217
00:12:15,569 --> 0:12:17,304
如何生成这些光照列表

218
00:12:18,639 --> 0:12:22,976
嗯 我们首先把视椎分成

219
00:12:23,243 --> 0:12:24,478
每个平铺一个子椎

220
00:12:25,879 --> 0:12:29,783
然后使用计算着色器

221
00:12:29,950 --> 0:12:33,487
通过使用平铺的位置

222
00:12:34,188 --> 0:12:36,623
我们可以这样做

223
00:12:36,823 --> 0:12:38,225
几何通道

224
00:12:38,825 --> 0:12:40,661
因此深度缓冲区已经填充好了

225
00:12:41,962 --> 0:12:45,232
当我们调整这些子椎时 我们可以

226
00:12:45,299 --> 0:12:48,035
测试所有视椎的光照体积

227
00:12:48,368 --> 0:12:50,404
并向光照列表中添加任意交集

228
00:12:51,772 --> 0:12:56,043
这整个过程可以在所有平铺中

229
00:12:56,109 --> 0:12:59,146
非常适合计算内核

230
00:13:00,447 --> 0:13:04,184
我们要如何把这个整合到

231
00:13:05,452 --> 0:13:07,721
嗯 要在我们设置

232
00:13:09,456 --> 0:13:12,559
现在我们已经把计算通道

233
00:13:14,561 --> 0:13:16,864
那会为我们创建光照列表

234
00:13:16,930 --> 0:13:21,034
存储这些光照列表

235
00:13:22,336 --> 0:13:27,140
再一次 这个方案适用于所有平台

236
00:13:27,207 --> 0:13:33,547
我们只需要创建额外的计算

237
00:13:33,614 --> 0:13:35,782
从每个着色器一个光照

238
00:13:35,916 --> 0:13:38,819
移到照明着色器中的迭代循环中

239
00:13:39,620 --> 0:13:43,423
就像之前的渲染器一样

240
00:13:43,490 --> 0:13:46,226
iOS上的硬件平铺

241
00:13:46,693 --> 0:13:51,798
让我们看一下这在我们的单一编码器

242
00:13:53,400 --> 0:13:55,702
这是我们刚才讲过的单通道方案

243
00:13:56,103 --> 0:13:57,871
我们需要在那儿使用这个计算

244
00:13:58,305 --> 0:14:00,674
但我们需要留在单渲染命令编码器中

245
00:13:58,305 --> 0:14:00,674
但我们需要留在单渲染命令编码器中

246
00:14:00,841 --> 0:14:02,075
从而使用可编程混合

247
00:14:03,177 --> 0:14:09,016
Metal提供一种有效的方式

248
00:14:09,082 --> 0:14:12,753
来渲染我们所光栅化的

249
00:14:14,021 --> 0:14:18,625
为了iOS上的这个目的

250
00:14:18,825 --> 0:14:21,595
平铺着色器管道 使其运行计算函数

251
00:14:22,663 --> 0:14:25,232
这非常适合我们的平铺照明

252
00:14:25,632 --> 0:14:28,135
因为我们现在获取了照明平铺概念

253
00:14:28,368 --> 0:14:30,270
并把它直接映像到我们的硬件平铺上

254
00:14:32,005 --> 0:14:36,143
因此现在我们的光照调用预通道可以

255
00:14:36,643 --> 0:14:41,248
我们可以使用第二个Metal功能

256
00:14:41,715 --> 0:14:46,620
用于在平铺内存中存储所生成的

257
00:14:48,255 --> 0:14:51,024
然后与附件类似

258
00:14:51,258 --> 0:14:53,427
但渲染命令编码器中的所有绘制

259
00:14:53,994 --> 0:14:57,164
在我们的例子中是按光照绘制

260
00:15:00,067 --> 0:15:04,805
我们现在移动了照明后端

261
00:15:05,205 --> 0:15:07,241
完全在平铺内存内执行

262
00:15:08,609 --> 0:15:10,077
那么这在Metal中

263
00:15:10,644 --> 0:15:12,346
让我们返回到设置代码中

264
00:15:14,181 --> 0:15:17,484
创建平铺着色器与设置

265
00:15:17,551 --> 0:15:18,819
普通的渲染管道状态非常相似

266
00:15:19,786 --> 0:15:21,088
我们创建描述符

267
00:15:21,922 --> 0:15:23,590
我们设置所有的颜色附件

268
00:15:24,625 --> 0:15:28,195
然后设置我们想要执行的计算函数

269
00:15:28,562 --> 0:15:30,063
然后创建管道状态

270
00:15:30,931 --> 0:15:33,400
因为我们使用了持久线程组内存

271
00:15:33,600 --> 0:15:35,869
我们需要在平铺中保留一点儿内存

272
00:15:36,537 --> 0:15:39,139
因此我们返回到渲染通道描述符

273
00:15:39,940 --> 0:15:43,644
然后保留足够的数据

274
00:15:46,013 --> 0:15:49,816
现在让我们转到渲染循环

275
00:15:50,918 --> 0:15:54,221
我们的渲染循环这一次是从

276
00:15:55,055 --> 0:15:59,526
然后我们再一次循环场景中的

277
00:16:01,195 --> 0:16:03,597
然后我们不直接进入照明通道

278
00:16:03,664 --> 0:16:04,831
而是首先执行平铺着色器

279
00:16:05,799 --> 0:16:11,205
我们设置了管道状态

280
00:16:11,271 --> 0:16:16,376
存储我们场景中的所有光照

281
00:16:16,443 --> 0:16:17,444
绑定到我们的平铺内存中

282
00:16:18,245 --> 0:16:20,647
然后我们分派我们的平铺着色器

283
00:16:21,882 --> 0:16:27,387
现在我们已经执行了平铺着色器

284
00:16:27,688 --> 0:16:31,258
然后我们就可以在照明绘制中使用了

285
00:16:31,792 --> 0:16:36,563
我们可以让每个像素都能访问它

286
00:16:36,763 --> 0:16:38,332
它使用了持久线程组内存的

287
00:16:38,966 --> 0:16:41,502
现在可以非常有效率地给它的像素

288
00:16:42,836 --> 0:16:45,973
最后 设置好这一切之后

289
00:16:46,173 --> 0:16:47,174
这在着色器中看起来怎么样

290
00:16:48,442 --> 0:16:51,411
在这里我们有两个着色器

291
00:16:52,212 --> 0:16:54,381
它把输出光照列表绑定到

292
00:16:54,715 --> 0:16:56,416
一个持久线程组内存缓冲区中

293
00:16:58,952 --> 0:17:02,022
然后它会以某种方式循环所有光照

294
00:16:58,952 --> 0:17:02,022
然后它会以某种方式循环所有光照

295
00:17:02,089 --> 0:17:05,959
并把光罩输出到持久线程组内存中

296
00:17:07,227 --> 0:17:09,530
然后由第二着色器读回

297
00:17:09,596 --> 0:17:11,431
第二着色器是我们真实的照明着色器

298
00:17:12,665 --> 0:17:16,637
它会写入它平铺内的所有可见光照

299
00:17:17,137 --> 0:17:18,571
并给像素着色

300
00:17:20,040 --> 0:17:23,143
现在我们已经了解对平铺延迟技巧

301
00:17:23,242 --> 0:17:28,015
实施平铺照明技巧的所有要点

302
00:17:28,482 --> 0:17:31,952
让我们看一下如何使用这个原理

303
00:17:32,452 --> 0:17:35,822
使其有效地创建一个额外的前向通道

304
00:17:37,291 --> 0:17:41,128
因为我们已经在持久线程组内存中

305
00:17:41,428 --> 0:17:45,832
我们可以使用同样的数据来促进一个

306
00:17:47,901 --> 0:17:50,571
无论何时当我们在前向通道中

307
00:17:50,804 --> 0:17:54,775
我们都可以使用同一个

308
00:17:54,842 --> 0:17:59,513
并使用在延迟照明中所使用的同一个

309
00:17:59,580 --> 0:18:04,284
来非常有效率地对前向像素进行着色

310
00:17:59,580 --> 0:18:04,284
来非常有效率地对前向像素进行着色

311
00:18:05,485 --> 0:18:08,789
这个前向通道真的增强了渲染功能

312
00:18:09,056 --> 0:18:13,026
并接受透明度、

313
00:18:13,093 --> 0:18:15,028
如果只有延迟通道

314
00:18:16,897 --> 0:18:19,666
然而延迟管道总有一些限制

315
00:18:20,033 --> 0:18:21,068
抗锯齿

316
00:18:22,302 --> 0:18:24,805
复杂的材料表达仍然是个问题

317
00:18:25,038 --> 0:18:27,708
因为有过渡的GBuffer表示

318
00:18:28,509 --> 0:18:31,245
使用这个平铺技巧我们看到

319
00:18:31,311 --> 0:18:35,249
我们可以非常有效地加强前向渲染

320
00:18:35,415 --> 0:18:36,683
使用平铺照明技巧

321
00:18:37,851 --> 0:18:41,622
让我们往回退一步 只看前向通道

322
00:18:41,922 --> 0:18:45,626
因为除平铺照明之外

323
00:18:45,692 --> 0:18:46,693
成为了一个可行性方案

324
00:18:48,695 --> 0:18:53,467
要创建只进行前向渲染的渲染器

325
00:18:53,567 --> 0:18:54,568
和照明通道即可

326
00:18:55,669 --> 0:19:00,807
然而我们的照明剔除技巧

327
00:18:55,669 --> 0:19:00,807
然而我们的照明剔除技巧

328
00:19:02,409 --> 0:19:06,513
因此我们需要用深度预通道

329
00:19:06,713 --> 0:19:07,781
来填充这个深度缓冲区

330
00:19:08,882 --> 0:19:11,852
如果你的引擎已经拥有这样一个

331
00:19:11,919 --> 0:19:13,554
那这对于你来说

332
00:19:14,888 --> 0:19:18,458
如果你有过度绘制、优化、遮挡剔除

333
00:19:18,525 --> 0:19:21,094
或自我混合

334
00:19:22,296 --> 0:19:26,466
然而在iOS硬件上

335
00:19:27,134 --> 0:19:29,970
对于那些情况而言

336
00:19:30,037 --> 0:19:32,539
叫做集群照明 可能更适合你

337
00:19:33,807 --> 0:19:36,577
这个集群方案以不同的方式

338
00:19:37,010 --> 0:19:40,414
创建光照列表 而不需要任何深度

339
00:19:41,448 --> 0:19:45,252
因为对于集群光照来说

340
00:19:45,319 --> 0:19:50,057
但我们只是再细分深度轴上的椎

341
00:19:51,091 --> 0:19:54,661
然后我们发出一个3D光照列表贴图

342
00:19:56,430 --> 0:19:59,766
这可能不如平铺照明中的子椎

343
00:19:59,833 --> 0:20:00,968
那么有效率

344
00:19:59,833 --> 0:20:00,968
那么有效率

345
00:20:01,602 --> 0:20:04,638
但它将大大提高照明性能

346
00:20:05,205 --> 0:20:08,242
因为仅通过本地光照列表

347
00:20:10,110 --> 0:20:13,380
使用集群剔除 与平铺着色

348
00:20:13,514 --> 0:20:14,915
和持久线程组内存一起

349
00:20:15,282 --> 0:20:17,584
这将为我们提供一个非常优化的

350
00:20:19,887 --> 0:20:22,656
我们现在已经了解了一些

351
00:20:22,789 --> 0:20:24,291
以及如何在Metal上

352
00:20:25,359 --> 0:20:28,061
现在我们要了解一下

353
00:20:28,195 --> 0:20:31,098
它以一种不同方式

354
00:20:31,164 --> 0:20:35,002
从而更适合不支持硬件平铺的老硬件

355
00:20:37,004 --> 0:20:39,373
让我们一直退回到延迟渲染器中

356
00:20:40,140 --> 0:20:45,045
我们目前所了解的大部分优化

357
00:20:46,547 --> 0:20:49,283
可见度缓冲区技巧尝试以另一种方式

358
00:20:49,449 --> 0:20:53,921
把过渡缓冲区瓶颈最小化

359
00:20:53,987 --> 0:20:57,224
也就是在那个缓冲区中存储

360
00:20:58,358 --> 0:21:02,262
我们不按像素存储所有表面

361
00:20:58,358 --> 0:21:02,262
我们不按像素存储所有表面

362
00:21:02,596 --> 0:21:06,900
我们只存储原始标识符和重心坐标

363
00:21:09,469 --> 0:21:13,974
这个数据不直接用于给整个场景着色

364
00:21:14,208 --> 0:21:17,411
重构和插入原始几何图形

365
00:21:17,678 --> 0:21:20,814
然后在本地在照明着色器内

366
00:21:21,114 --> 0:21:22,349
运行整个材料逻辑

367
00:21:23,383 --> 0:21:26,987
因为这个重构步骤消耗太大

368
00:21:27,354 --> 0:21:28,789
但它在平铺照明技巧中用起来

369
00:21:28,989 --> 0:21:32,426
因为它保证只对每个像素

370
00:21:34,394 --> 0:21:37,531
当我们实施这个技巧时

371
00:21:37,598 --> 0:21:42,002
如何创建原始索引以及如何创建

372
00:21:43,470 --> 0:21:45,772
而不需要大量额外的处理

373
00:21:46,874 --> 0:21:48,675
我们现在很高兴地告诉你们

374
00:21:48,876 --> 0:21:51,845
你现在可以在片段着色器内

375
00:21:52,145 --> 0:21:54,681
检索当前原始索引

376
00:21:54,915 --> 0:21:57,384
和当前像素的重心坐标的索引了

377
00:21:59,086 --> 0:22:01,622
生成几何图形着色器现在非常简单

378
00:21:59,086 --> 0:22:01,622
生成几何图形着色器现在非常简单

379
00:22:01,955 --> 0:22:04,057
Metal 3使几何通道

380
00:22:04,791 --> 0:22:07,995
实施也比以前更简单了

381
00:22:10,264 --> 0:22:13,133
我们现在学习了

382
00:22:13,200 --> 0:22:14,868
用于场景渲染的所有这些不同方案

383
00:22:15,536 --> 0:22:17,838
现在让我们看一个小演示

384
00:22:17,905 --> 0:22:18,906
演示一下其中一些渲染技巧

385
00:22:20,874 --> 0:22:24,211
在这里我们有测试场景

386
00:22:24,444 --> 0:22:27,814
和设置PBR材料

387
00:22:28,649 --> 0:22:32,619
我们可以在任意设备上使用延迟

388
00:22:32,686 --> 0:22:33,854
来渲染这个场景

389
00:22:34,555 --> 0:22:37,758
让我们从普通的延迟渲染器开始

390
00:22:39,059 --> 0:22:42,296
延迟渲染器有两个通道

391
00:22:42,563 --> 0:22:44,765
第一个通道现在

392
00:22:44,831 --> 0:22:45,966
通过这些过渡

393
00:22:46,400 --> 0:22:48,602
现在让我们看其中一些

394
00:22:50,871 --> 0:22:52,339
在这里我们有反照率

395
00:22:54,541 --> 0:22:55,542
我们有法线

396
00:22:58,545 --> 0:23:00,247
我们有GBuffer的粗糙度纹理

397
00:22:58,545 --> 0:23:00,247
我们有GBuffer的粗糙度纹理

398
00:23:00,814 --> 0:23:04,284
如果你有暂时的抗锯齿

399
00:23:04,585 --> 0:23:06,987
你很可能需要在GBuffer中

400
00:23:07,988 --> 0:23:11,625
我们现在看到的场景

401
00:23:12,226 --> 0:23:15,395
因此让我们进入夜间场景

402
00:23:17,331 --> 0:23:19,800
现在在这个场景中

403
00:23:19,867 --> 0:23:23,237
我们需要渲染许多光照

404
00:23:24,137 --> 0:23:27,307
在普通延迟中

405
00:23:27,608 --> 0:23:30,043
那样效率很低 并且你可以看到

406
00:23:30,310 --> 0:23:31,378
在不同的光照之间有许多重叠

407
00:23:32,212 --> 0:23:34,681
因此让我们改用平铺延迟照明

408
00:23:36,884 --> 0:23:42,122
在这里我们有同一个场景 渲染

409
00:23:45,893 --> 0:23:50,163
我们想在这里展示的是我们所拥有的

410
00:23:50,531 --> 0:23:54,668
关于不同的平铺如何给你呈现

411
00:23:54,735 --> 0:23:56,770
在每一个不同的平铺中所渲染的

412
00:23:56,837 --> 0:24:00,908
你可以看到使用这些平铺细分

413
00:23:56,837 --> 0:24:00,908
你可以看到使用这些平铺细分

414
00:24:00,974 --> 0:24:02,442
相对于同时照亮所有像素来说

415
00:24:03,143 --> 0:24:06,547
效果真的不一样

416
00:24:07,981 --> 0:24:10,083
现在我们已经演示了一些

417
00:24:10,150 --> 0:24:12,719
你可以用于渲染场景的可能的

418
00:24:13,187 --> 0:24:16,156
接下来我的同事

419
00:24:16,490 --> 0:24:18,725
如何把CPU繁重的渲染循环

420
00:24:18,825 --> 0:24:19,927
放到GPU驱动的管道中去

421
00:24:24,565 --> 0:24:25,566
谢谢Jaap

422
00:24:26,099 --> 0:24:27,501
GPU驱动的管道

423
00:24:28,268 --> 0:24:31,405
在Metal 2中我们引入了

424
00:24:31,471 --> 0:24:34,708
由增强缓冲区

425
00:24:35,309 --> 0:24:38,378
通过这些你现在可以

426
00:24:38,445 --> 0:24:39,279
移到GPU上来

427
00:24:39,746 --> 0:24:41,648
我同事Jaap刚讲了

428
00:24:41,715 --> 0:24:43,984
各种高级渲染技巧

429
00:24:44,718 --> 0:24:48,755
我要讲的是如何

430
00:24:48,956 --> 0:24:49,957
移到GPU上来

431
00:24:50,424 --> 0:24:52,893
这不仅会让渲染循环变得更有效率

432
00:24:53,160 --> 0:24:56,263
它还允许你释放CPU用于执行

433
00:24:56,330 --> 0:25:00,234
比如复杂的物理模拟REI

434
00:24:56,330 --> 0:25:00,234
比如复杂的物理模拟REI

435
00:25:00,834 --> 0:25:04,271
在深入讲细节之前

436
00:25:04,338 --> 0:25:06,240
通常会执行哪些操作

437
00:25:07,975 --> 0:25:10,511
大场景要求复杂的渲染操作

438
00:25:10,644 --> 0:25:15,315
通常你会执行一系列操作

439
00:25:15,782 --> 0:25:18,619
你要做的第一件事就是椎剔除

440
00:25:19,520 --> 0:25:22,856
移除落在视椎外的对象

441
00:25:23,223 --> 0:25:25,192
我们只讲绘制调用

442
00:25:25,692 --> 0:25:27,294
接下来是遮挡剔除

443
00:25:27,761 --> 0:25:31,732
在这里你排除由其它较大对象

444
00:25:32,499 --> 0:25:36,537
通常要做的另一件事是细节层次选择

445
00:25:36,737 --> 0:25:40,741
根据模型到摄像机的距离

446
00:25:41,008 --> 0:25:42,543
从一系列的模型细节层次中进行选择

447
00:25:43,310 --> 0:25:46,580
那么带有所有这些操作的

448
00:25:46,647 --> 0:25:48,315
一般看起来就像这样

449
00:25:49,516 --> 0:25:53,954
从根本上说 你首先会

450
00:25:54,388 --> 0:25:59,359
编码到命令缓冲区中

451
00:25:59,426 --> 0:26:00,861
从而为下一帧生成遮挡数据

452
00:25:59,426 --> 0:26:00,861
从而为下一帧生成遮挡数据

453
00:26:01,728 --> 0:26:05,332
接下来你执行椎剔除

454
00:26:05,399 --> 0:26:06,400
从而排除视椎外的对象

455
00:26:06,900 --> 0:26:10,838
并做LOD选择

456
00:26:11,305 --> 0:26:15,442
然后是遮挡剔除 从而排除

457
00:26:15,509 --> 0:26:17,110
被较大对象遮挡的对象

458
00:26:17,878 --> 0:26:22,316
那么最后你要编码可见对象的绘制

459
00:26:22,382 --> 0:26:25,252
并在渲染通道中执行它

460
00:26:25,786 --> 0:26:29,556
现在这个流程用起来不错

461
00:26:29,923 --> 0:26:31,758
首先让我们看一下遮挡剔除

462
00:26:32,526 --> 0:26:36,196
要执行遮挡剔除

463
00:26:36,830 --> 0:26:40,467
但因为你不想减少

464
00:26:40,667 --> 0:26:43,437
你通常依赖于

465
00:26:43,637 --> 0:26:46,373
你通常得到的数据分辨率较低

466
00:26:47,140 --> 0:26:49,943
因此它是近似数据

467
00:26:50,344 --> 0:26:53,413
因此你很可能需要在游戏中

468
00:26:54,114 --> 0:26:57,951
第二 这里有些操作很有麻痹性

469
00:26:58,051 --> 0:27:00,153
比如椎剔除

470
00:26:58,051 --> 0:27:00,153
比如椎剔除

471
00:27:01,154 --> 0:27:06,159
在单CPU线程上 它是这样的

472
00:27:06,226 --> 0:27:08,095
你要对每个对象执行椎剔除

473
00:27:08,695 --> 0:27:12,699
现在你可以明确地把这个进程

474
00:27:13,367 --> 0:27:15,936
但只有几个CPU线程可用

475
00:27:16,436 --> 0:27:20,240
并且如果你包含你想要对每个对象

476
00:27:20,674 --> 0:27:22,376
你很可能正在做这样的事

477
00:27:23,310 --> 0:27:25,379
但这些操作是否很有麻痹性？

478
00:27:25,612 --> 0:27:28,515
如果你有更多的线程

479
00:27:28,582 --> 0:27:32,352
所有场景 处理场景中的所有对象

480
00:27:32,886 --> 0:27:36,323
但一般来说场景中有成千上万个对象

481
00:27:36,390 --> 0:27:38,825
你就需要成千上万个线程

482
00:27:39,359 --> 0:27:42,429
因此执行这些操作的

483
00:27:43,597 --> 0:27:47,634
GPU是一个大规模的并行处理器

484
00:27:47,701 --> 0:27:49,203
用于安排操作的执行

485
00:27:49,770 --> 0:27:53,707
可以把一个对象分配给一个

486
00:27:53,774 --> 0:27:56,176
我们想要在那个对象上执行的

487
00:27:56,710 --> 0:27:59,980
通过成千上万个线程

488
00:28:00,614 --> 0:28:04,184
因此如果你把它从CPU移到GPU

489
00:28:04,351 --> 0:28:09,923
并且正如我之前提到过的那样

490
00:28:10,023 --> 0:28:11,792
用于执行其它想要执行的处理

491
00:28:12,559 --> 0:28:15,329
如何把全部这些操作

492
00:28:16,196 --> 0:28:19,099
你可以通过在GPU上

493
00:28:19,166 --> 0:28:23,570
从而我们可以在GPU上驱动

494
00:28:23,637 --> 0:28:25,305
而不需要CPU参与

495
00:28:25,939 --> 0:28:27,541
这个想法 我的意思是

496
00:28:27,841 --> 0:28:31,545
这里的整个渲染循环都在GPU上

497
00:28:32,412 --> 0:28:36,517
现在让我们看一下这些通道

498
00:28:36,583 --> 0:28:37,584
实际是如何运作的

499
00:28:38,685 --> 0:28:41,288
现在我们需要的是

500
00:28:41,555 --> 0:28:44,992
那么首先我们有一个计算通道

501
00:28:45,058 --> 0:28:48,962
执行包围盒的椎剔除

502
00:28:49,029 --> 0:28:50,030
并编码渲染包围盒的命令

503
00:28:50,464 --> 0:28:54,301
现在这些编码的遮挡绘制命令

504
00:28:54,434 --> 0:28:56,703
因此我们生成所有必要的遮挡数据

505
00:28:57,237 --> 0:28:59,373
这个遮挡数据可以是多种不同的形式

506
00:28:59,439 --> 0:29:01,208
取决于它的生成方式

507
00:28:59,439 --> 0:29:01,208
取决于它的生成方式

508
00:29:01,675 --> 0:29:03,710
那么你可能想进一步处理那个数据

509
00:29:04,411 --> 0:29:06,513
为此我们有另一个计算通道

510
00:29:07,114 --> 0:29:10,551
在这个通道中

511
00:29:10,617 --> 0:29:12,953
更适用于遮挡剔除的形式

512
00:29:13,921 --> 0:29:17,090
我们还需要一个计算通道

513
00:29:17,591 --> 0:29:20,027
也就是剔除、细节层次选择、

514
00:29:20,294 --> 0:29:22,262
和编码场景绘制命令

515
00:29:22,996 --> 0:29:25,766
这里有一件事要了解

516
00:29:25,832 --> 0:29:28,902
已经不再依赖以前帧的数据了

517
00:29:29,570 --> 0:29:32,573
在我们刚讲过的前两个通道中

518
00:29:32,639 --> 0:29:34,641
为当前帧生成所要求的包围盒数据

519
00:29:35,142 --> 0:29:37,711
同时因为我们生成当前帧的数据

520
00:29:38,078 --> 0:29:39,479
数据也更精确了

521
00:29:40,948 --> 0:29:45,719
最后我们有另一个渲染通道执行

522
00:29:45,786 --> 0:29:46,787
用于渲染场景

523
00:29:47,688 --> 0:29:52,759
在这个GPU驱动的渲染循环中

524
00:29:53,193 --> 0:29:57,598
无论何处都没CPU-GPU

525
00:29:58,365 --> 0:30:00,667
我们该如何创建这个GPU驱动的

526
00:29:58,365 --> 0:30:00,667
我们该如何创建这个GPU驱动的

527
00:30:01,535 --> 0:30:04,605
现在很明确

528
00:30:04,671 --> 0:30:06,440
我们至少需要两个东西

529
00:30:07,307 --> 0:30:08,742
第一个是绘制命令

530
00:30:09,877 --> 0:30:14,214
我们需要一种在GPU上编码

531
00:30:14,281 --> 0:30:16,016
可以为渲染通道编码命令

532
00:30:16,650 --> 0:30:19,119
Metal所提供的支持这个功能的

533
00:30:19,186 --> 0:30:20,621
是非直接命令缓冲区

534
00:30:21,321 --> 0:30:23,090
我们还需要场景数据

535
00:30:23,857 --> 0:30:27,227
我们应该能通过帧在GPU上访问

536
00:30:27,294 --> 0:30:29,096
在任何需要的情况下

537
00:30:29,730 --> 0:30:32,432
通过这个场景数据

538
00:30:32,499 --> 0:30:37,137
整个场景了 比如几何图形、

539
00:30:37,638 --> 0:30:41,141
在Metal提供的支持这个功能的

540
00:30:41,208 --> 0:30:42,543
是参数缓冲区

541
00:30:43,410 --> 0:30:46,613
现在让我们深入看一下这两个

542
00:30:47,648 --> 0:30:52,052
现在参数缓冲区可以让你描述

543
00:30:52,119 --> 0:30:53,620
有复杂的数据结构

544
00:30:53,987 --> 0:30:57,591
它们允许你在渲染循环的任何位置

545
00:30:58,325 --> 0:31:01,995
而非直接命令缓冲区

546
00:30:58,325 --> 0:31:01,995
而非直接命令缓冲区

547
00:31:02,162 --> 0:31:05,098
从根本上来说 它在GPU上支持

548
00:31:05,399 --> 0:31:06,400
大量命令并行生成

549
00:31:06,834 --> 0:31:09,670
现在让我们进一步看一下参数缓冲区

550
00:31:09,736 --> 0:31:12,105
通过一个示例场景对象模型来看

551
00:31:14,041 --> 0:31:17,077
我们所需要的第一个东西是

552
00:31:17,778 --> 0:31:19,680
那么场景数据通常都包含什么？

553
00:31:20,080 --> 0:31:21,081
首先是网格

554
00:31:21,615 --> 0:31:22,816
这就是网格

555
00:31:23,183 --> 0:31:26,920
它是网格对象的一个区域

556
00:31:27,421 --> 0:31:30,858
还有材料 它是材料对象的一个区域

557
00:31:31,091 --> 0:31:35,195
每个材料对象都有一组材料属性、

558
00:31:35,262 --> 0:31:38,265
以及描述阴影管道的管道操纵对象

559
00:31:38,699 --> 0:31:41,201
场景还包含模型区域

560
00:31:41,935 --> 0:31:47,474
在此每个模型都可以拥有一个LOD

561
00:31:47,541 --> 0:31:52,713
每个LOD一个模型

562
00:31:53,480 --> 0:31:58,151
最后我们有场景对象

563
00:31:58,418 --> 0:31:59,586
那些都是我们场景的一部分

564
00:32:00,420 --> 0:32:04,992
让我们看一下这个对象模型

565
00:32:07,060 --> 0:32:11,665
它是一个非常简单的一对一映像

566
00:32:11,798 --> 0:32:15,769
比如这里的场景参数缓冲区包含

567
00:32:15,836 --> 0:32:18,405
我们在对象模型中描述的对象

568
00:32:19,072 --> 0:32:22,309
就是网格区、材料区和模型区

569
00:32:22,843 --> 0:32:26,813
从根本上来说 整个场景

570
00:32:27,714 --> 0:32:29,716
现在让我们看一下

571
00:32:29,783 --> 0:32:31,285
如何在着色器中构造并访问它

572
00:32:34,121 --> 0:32:38,125
现在我们所讨论的每个参数缓冲区

573
00:32:38,325 --> 0:32:39,326
都用结构表示

574
00:32:39,660 --> 0:32:41,962
那包含我们在对象模型中

575
00:32:42,029 --> 0:32:43,030
所描述的元素

576
00:32:43,564 --> 0:32:47,935
因为每个参数缓冲区都是一个

577
00:32:48,302 --> 0:32:52,606
你可以添加比如数组、指针、

578
00:32:53,006 --> 0:32:56,443
比如这是一个Metal参数缓冲区

579
00:32:56,977 --> 0:33:00,814
它包含Metal常量、

580
00:32:56,977 --> 0:33:00,814
它包含Metal常量、

581
00:33:00,881 --> 0:33:03,951
还有描述阴影管道的管道专用对象

582
00:33:04,484 --> 0:33:08,021
材料所需要的一切都在一个

583
00:33:08,989 --> 0:33:11,859
场景参数缓冲区

584
00:33:11,925 --> 0:33:13,427
所描述的样子

585
00:33:13,961 --> 0:33:18,098
因此用参数缓冲区构造对象模型

586
00:33:18,866 --> 0:33:22,769
现在让我们看一下如何访问

587
00:33:24,805 --> 0:33:28,208
我们刚讲过有一个计算内核

588
00:33:28,642 --> 0:33:31,245
它编码绘制命令

589
00:33:31,311 --> 0:33:32,412
把可见对象

590
00:33:33,280 --> 0:33:37,551
每个线程都执行这个内核的一个实例

591
00:33:37,818 --> 0:33:41,955
并编码一个单一绘制调用

592
00:33:42,523 --> 0:33:44,224
让我们看看它是如何实现的

593
00:33:45,425 --> 0:33:49,830
首先我们给着色器传入

594
00:33:50,531 --> 0:33:55,669
现在一旦我们可以访问着色器

595
00:33:55,736 --> 0:33:56,837
访问我们所需要的其它东西

596
00:33:57,371 --> 0:34:01,275
这里的命令R包含对我们想要编码的

597
00:33:57,371 --> 0:34:01,275
这里的命令R包含对我们想要编码的

598
00:34:01,341 --> 0:34:02,843
非直接命令缓冲区的引用

599
00:34:04,178 --> 0:34:08,181
我们首先根据线程ID

600
00:34:08,681 --> 0:34:12,652
请注意这个计算内核的所有线程

601
00:34:12,819 --> 0:34:14,655
每个线程操作一个特定的对象

602
00:34:15,621 --> 0:34:19,726
然后我们执行椎剔除

603
00:34:20,460 --> 0:34:24,965
一旦我们决定对象可见

604
00:34:25,032 --> 0:34:26,533
计算它的LOD

605
00:34:27,467 --> 0:34:30,036
一旦我们有了LOD

606
00:34:30,103 --> 0:34:34,241
读取它相应的网格和材料参数、

607
00:34:34,440 --> 0:34:35,943
应用到那个LOD上的参数缓冲区

608
00:34:36,610 --> 0:34:39,713
之所以直截了当主要是因为

609
00:34:39,780 --> 0:34:42,516
关联我们在场景中所需要的

610
00:34:43,650 --> 0:34:46,987
我们已经得到我们所需的全部信息

611
00:34:47,688 --> 0:34:50,724
让我们看一下编码到非参数缓冲区

612
00:34:50,791 --> 0:34:54,194
和非直接命令缓冲区到底是什么意思

613
00:34:57,164 --> 0:35:00,767
非直接命令缓冲区

614
00:34:57,164 --> 0:35:00,767
非直接命令缓冲区

615
00:35:01,068 --> 0:35:03,136
每个命令可以有不同的属性

616
00:35:03,670 --> 0:35:06,473
一个命令可以包含一个管道专用对象

617
00:35:06,840 --> 0:35:10,444
管道专用对象描述一个共享的管道

618
00:35:10,511 --> 0:35:11,578
和绘制调用所需要的任意漩涡

619
00:35:12,045 --> 0:35:13,146
还有绘制调用自己

620
00:35:13,580 --> 0:35:17,951
从根本上说 编码的意思是

621
00:35:18,385 --> 0:35:21,588
我们就读取它和它所有的属性

622
00:35:21,655 --> 0:35:23,457
并把这些编码到非直接命令缓冲区中

623
00:35:23,891 --> 0:35:28,762
现在凡是正在处理对象的线程

624
00:35:28,829 --> 0:35:30,097
这个非直接命令缓冲区的一个

625
00:35:30,564 --> 0:35:32,933
因为所有线程都是并行运行的

626
00:35:33,400 --> 0:35:35,402
可以同时进行命令编码

627
00:35:36,370 --> 0:35:39,239
现在让我们继续看剔除内核例子

628
00:35:39,306 --> 0:35:42,576
看一个真实的编码示例

629
00:35:44,545 --> 0:35:48,015
我们首先需要在命令缓冲区中

630
00:35:48,081 --> 0:35:49,082
来编码绘制命令

631
00:35:49,550 --> 0:35:53,954
因此我们使用绘制ID为我们自己

632
00:35:54,755 --> 0:35:58,859
就像我们所讨论的那样

633
00:35:59,359 --> 0:36:01,328
现在我们刚获得的

634
00:35:59,359 --> 0:36:01,328
现在我们刚获得的

635
00:36:01,395 --> 0:36:04,064
已经有我们要设置参数

636
00:36:04,131 --> 0:36:05,132
所需要的全部信息

637
00:36:05,699 --> 0:36:08,735
那么比如 从材料中我们可以设置

638
00:36:09,336 --> 0:36:10,337
我们需要设置的管道专用对象

639
00:36:10,804 --> 0:36:15,275
从网格对象中我们可以设置

640
00:36:15,342 --> 0:36:16,343
我们需要设置的任何漩涡缓冲区

641
00:36:16,944 --> 0:36:19,980
当然了 碎片需要材料

642
00:36:20,514 --> 0:36:22,916
最后 这就是如何编码绘制

643
00:36:23,584 --> 0:36:27,754
就是这样

644
00:36:29,790 --> 0:36:32,960
现在让我们看看

645
00:36:34,528 --> 0:36:36,797
现在我们首先需要一个

646
00:36:36,864 --> 0:36:39,566
来编码包围盒绘制命令

647
00:36:39,633 --> 0:36:43,971
GPU驱动的渲染器循环时

648
00:36:44,571 --> 0:36:48,675
要渲染包围盒

649
00:36:49,109 --> 0:36:50,944
执行包围盒的椎剔除

650
00:36:51,311 --> 0:36:53,146
并编码包围盒绘制命令

651
00:36:53,947 --> 0:36:59,119
因为每个线程都是独立编码绘制的

652
00:36:59,353 --> 0:37:02,990
因此在非直接命令缓冲区中

653
00:36:59,353 --> 0:37:02,990
因此在非直接命令缓冲区中

654
00:37:03,056 --> 0:37:04,658
写入和状态设置

655
00:37:05,425 --> 0:37:09,696
我们可以根据需要

656
00:37:09,963 --> 0:37:11,832
从而移除任何驱动端阶段设置

657
00:37:12,766 --> 0:37:15,702
现在这是一个随机通道

658
00:37:15,769 --> 0:37:16,937
执行包围盒绘制

659
00:37:17,905 --> 0:37:20,774
类似地 其余通道的设置也很简单

660
00:37:21,041 --> 0:37:26,947
比如这是我们的主计算分派

661
00:37:27,014 --> 0:37:31,718
启动我们刚才讲过的剔除内核

662
00:37:32,019 --> 0:37:35,355
它执行剔除测试、LOD选择

663
00:37:35,923 --> 0:37:39,059
我们已经准备好启动最后一个

664
00:37:39,126 --> 0:37:40,494
它会在非直接命令缓冲区中执行命令

665
00:37:41,094 --> 0:37:43,564
那么就是这些

666
00:37:44,264 --> 0:37:48,635
现在让我们看一下在编码绘制命令后

667
00:37:49,169 --> 0:37:50,971
非直接命令缓冲区看起来

668
00:37:53,140 --> 0:37:55,008
现在它可能很稀疏 有很多洞

669
00:37:55,676 --> 0:37:59,580
这主要是因为正如我们在剔除内核

670
00:38:00,180 --> 0:38:03,617
正在处理对象的线程

671
00:38:03,684 --> 0:38:05,986
如果它发现那个对象不可见的话

672
00:38:06,720 --> 0:38:09,256
比如这个例子中的对象一和对象三

673
00:38:09,957 --> 0:38:13,594
那意味着非直接命令缓冲区中的

674
00:38:14,027 --> 0:38:17,698
因此如果你把这个命令缓冲区

675
00:38:17,764 --> 0:38:21,034
一大堆空命令 那样效率很低

676
00:38:21,735 --> 0:38:25,939
因此理想情况是像这样

677
00:38:26,473 --> 0:38:30,777
也就是当我们编码绘制时

678
00:38:31,778 --> 0:38:34,214
为此我们有非直接原则

679
00:38:35,349 --> 0:38:41,088
通过非直接范围

680
00:38:41,154 --> 0:38:42,222
去哪里获取要执行的命令范围

681
00:38:42,823 --> 0:38:45,325
从根本上说

682
00:38:45,392 --> 0:38:49,763
它有一个起始位置

683
00:38:49,830 --> 0:38:53,267
并且这个缓冲区

684
00:38:53,333 --> 0:38:54,334
在GPU上进行填充

685
00:38:54,735 --> 0:38:57,938
执行调用将从这个缓冲区中

686
00:38:58,005 --> 0:38:59,840
和要执行的命令的数量

687
00:39:00,874 --> 0:39:02,843
它可用于打包 也可用于给出范围

688
00:39:03,610 --> 0:39:06,246
现在让我们看一个例子

689
00:39:08,182 --> 0:39:11,985
这是我们刚才讨论过的剔除内核

690
00:39:12,386 --> 0:39:15,122
我们对它进行了修改

691
00:39:15,589 --> 0:39:17,758
让我们看一下这个内核

692
00:39:19,393 --> 0:39:22,629
我们首先传入指向

693
00:39:22,696 --> 0:39:23,830
非直接范围缓冲区的长度元素的指针

694
00:39:24,331 --> 0:39:27,301
当我们检索要编码的命令时

695
00:39:27,601 --> 0:39:29,469
我们可以自动增加长度

696
00:39:30,103 --> 0:39:32,739
现在每个线程都自动增加长度

697
00:39:32,906 --> 0:39:34,942
当计算工作完成后

698
00:39:35,309 --> 0:39:38,045
长度会被自动设置到

699
00:39:38,879 --> 0:39:41,181
同时绘制命令也被打包好了

700
00:39:41,748 --> 0:39:45,919
因为在这段代码中

701
00:39:46,286 --> 0:39:47,754
是之前的长度值

702
00:39:48,255 --> 0:39:53,126
因此比如 如果你从零开始

703
00:39:53,193 --> 0:39:54,661
把长度增加到一

704
00:39:55,195 --> 0:39:56,964
使用第一个编码槽的线程

705
00:39:57,030 --> 0:39:59,199
把长度增加到二 以此类推

706
00:39:59,766 --> 0:40:02,536
这很棒

707
00:39:59,766 --> 0:40:02,536
这很棒

708
00:40:02,603 --> 0:40:04,605
我们同时还更新了范围

709
00:40:05,606 --> 0:40:09,176
现在让我们看一下如何在app中

710
00:40:09,476 --> 0:40:10,477
设置非直接范围缓冲区

711
00:40:12,312 --> 0:40:17,184
首先你要给计算通道创建一个

712
00:40:17,985 --> 0:40:21,355
接下来你要把范围缓冲区设置为

713
00:40:21,421 --> 0:40:23,156
剔除计算内核的内核参数

714
00:40:24,057 --> 0:40:28,362
然后我们执行启动了首先执行对象的

715
00:40:28,629 --> 0:40:33,634
同时自动更新范围

716
00:40:34,201 --> 0:40:37,971
最后你通过非直接范围API

717
00:40:38,172 --> 0:40:39,540
安排缓冲区中有执行命令的通道

718
00:40:39,907 --> 0:40:43,377
现在这个调用将选择起始位置

719
00:40:43,443 --> 0:40:46,146
和要从这个非直接范围缓冲区中

720
00:40:46,847 --> 0:40:50,350
通过非直接范围 你可以获得更多

721
00:40:50,417 --> 0:40:51,852
非直接命令缓冲区的有效执行

722
00:40:53,487 --> 0:40:56,590
目前在我们的GPU驱动的管道中

723
00:40:56,890 --> 0:41:00,160
所有这些绘制命令

724
00:40:56,890 --> 0:41:00,160
所有这些绘制命令

725
00:41:00,794 --> 0:41:03,664
并且这些计算通道是你的游戏中

726
00:41:03,730 --> 0:41:04,731
发生常规分派的地方

727
00:41:05,199 --> 0:41:08,836
那么有一个问题

728
00:41:09,002 --> 0:41:12,406
我们是否可以把计算分派

729
00:41:12,940 --> 0:41:16,910
我很高兴地告诉你们 我们在

730
00:41:16,977 --> 0:41:20,714
支持编码计算分派

731
00:41:21,715 --> 0:41:24,318
现在你也可以

732
00:41:24,651 --> 0:41:27,354
关于功能性 计算非直接命令缓冲区

733
00:41:27,721 --> 0:41:28,689
就跟渲染一样

734
00:41:28,822 --> 0:41:32,326
它们也可以创建一次之后

735
00:41:32,860 --> 0:41:35,295
它们还可以帮助节约CPU周期

736
00:41:35,829 --> 0:41:41,101
最棒的是渲染和计算现在都可以

737
00:41:41,835 --> 0:41:44,872
非常棒

738
00:41:44,938 --> 0:41:46,039
GPU驱动的管道了

739
00:41:46,740 --> 0:41:50,110
现在让我们通过一个用例看一个例子

740
00:41:51,912 --> 0:41:53,680
每个补丁曲面细分因素

741
00:41:54,181 --> 0:41:57,985
假如我们有一个网格

742
00:41:58,418 --> 0:42:01,021
我们想给每个补丁

743
00:41:58,418 --> 0:42:01,021
我们想给每个补丁

744
00:42:01,755 --> 0:42:04,291
我们当然可以在剔除计算内核中

745
00:42:04,491 --> 0:42:08,095
就是我们讲过的那个执行剔除任务

746
00:42:08,595 --> 0:42:12,733
它是GPU线程 处理对象的方式是

747
00:42:12,799 --> 0:42:15,502
并生成曲面细分因素

748
00:42:16,203 --> 0:42:17,905
但这样真的效率太低了

749
00:42:17,971 --> 0:42:23,076
因为生成曲面细分因素自身

750
00:42:23,810 --> 0:42:27,247
因此如果按操作在多线程中进行分配

751
00:42:27,314 --> 0:42:31,051
那样可以并行处理所有补丁

752
00:42:31,852 --> 0:42:34,621
也就是说 正在处理对象的

753
00:42:34,888 --> 0:42:38,192
都可以编码计算分派

754
00:42:38,258 --> 0:42:39,593
用于测试因素生成

755
00:42:40,027 --> 0:42:43,463
并且这些分配

756
00:42:43,764 --> 0:42:44,865
从而麻痹操作

757
00:42:45,632 --> 0:42:48,402
那么通过GPU驱动的分派

758
00:42:48,869 --> 0:42:52,873
让我们看一下

759
00:42:52,940 --> 0:42:53,941
交换为适应这种处理

760
00:42:56,710 --> 0:42:59,746
这是我们之前讨论过的主计算通道

761
00:42:59,813 --> 0:43:02,549
它执行剔除任务、LOD选择

762
00:42:59,813 --> 0:43:02,549
它执行剔除任务、LOD选择

763
00:43:02,616 --> 0:43:03,851
并编码绘制命令

764
00:43:04,418 --> 0:43:09,323
我们现在可以让这个通道

765
00:43:09,790 --> 0:43:14,161
比如在某线程决定某对象可见后

766
00:43:14,361 --> 0:43:16,864
它可以编码分派

767
00:43:16,930 --> 0:43:18,465
用于在非直接命令缓冲区中

768
00:43:19,032 --> 0:43:23,237
然后那些命令可以在主渲染通道之前

769
00:43:23,303 --> 0:43:24,972
在另一个计算通道上执行

770
00:43:25,772 --> 0:43:30,978
GPU驱动的分派

771
00:43:31,044 --> 0:43:33,046
可以让我们创建更灵活的

772
00:43:34,481 --> 0:43:37,985
我们要创建一个示例

773
00:43:38,285 --> 0:43:39,286
让我们看一下

774
00:43:41,655 --> 0:43:45,092
这里是你之前见过的小酒馆场景

775
00:43:45,592 --> 0:43:48,829
这个 我们实际上正在

776
00:43:49,296 --> 0:43:53,033
这个场景大约由280万个多边形

777
00:43:53,166 --> 0:43:55,235
和接近8000个绘制调用构成

778
00:43:55,869 --> 0:43:57,871
这只是一个视图的

779
00:43:58,005 --> 0:44:00,908
如果你考虑这里使用的

780
00:43:58,005 --> 0:44:00,908
如果你考虑这里使用的

781
00:44:00,974 --> 0:44:05,179
那么这个渲染器正在处理

782
00:44:05,679 --> 0:44:10,384
因此如果这场景在CPU上进行渲染

783
00:44:10,851 --> 0:44:13,787
但在这个例子中

784
00:44:14,354 --> 0:44:17,824
因此一切都在GPU上执行

785
00:44:18,225 --> 0:44:20,027
整个渲染循环都在GPU上

786
00:44:20,527 --> 0:44:23,363
因此它节约了许多CPU

787
00:44:25,132 --> 0:44:27,935
让我们再看一个视图

788
00:44:28,468 --> 0:44:31,972
现在我们看的是同一个视图

789
00:44:32,039 --> 0:44:34,174
摄像机穿过这里的街道

790
00:44:34,675 --> 0:44:38,178
为了能让大家看清楚

791
00:44:38,245 --> 0:44:39,246
那就是摄像机

792
00:44:40,781 --> 0:44:41,915
我们显示了几何图形

793
00:44:41,982 --> 0:44:46,920
那个洋红色的几何图形正在下落

794
00:44:46,987 --> 0:44:49,656
这个几何图形落在了摄像机的视椎外

795
00:44:50,457 --> 0:44:53,327
因此你可以看到

796
00:44:53,393 --> 0:44:56,230
有不少几何图形都落在了

797
00:44:56,296 --> 0:44:57,297
摄像机的视椎外

798
00:44:57,564 --> 0:45:01,802
我们的剔除计算分派在GPU上

799
00:44:57,564 --> 0:45:01,802
我们的剔除计算分派在GPU上

800
00:45:02,169 --> 0:45:05,973
它决定这个几何图形

801
00:45:06,206 --> 0:45:11,178
因此在GPU上不会处理或渲染

802
00:45:11,245 --> 0:45:12,613
节约了许多渲染成本

803
00:45:13,847 --> 0:45:15,716
让我们再看最后一个视图

804
00:45:17,885 --> 0:45:18,886
这是另一个视图

805
00:45:18,952 --> 0:45:21,755
在这里我们显示了工作中的

806
00:45:22,556 --> 0:45:27,394
我们 我们把被遮挡住的几何图形

807
00:45:27,928 --> 0:45:32,099
而洋红色的几何图形处于视椎外

808
00:45:32,599 --> 0:45:34,935
你可以看到右边有不少几何图形

809
00:45:35,002 --> 0:45:37,671
都被小酒馆遮挡住了

810
00:45:38,438 --> 0:45:41,008
你可以看到这里有许多几何图形

811
00:45:41,074 --> 0:45:43,944
无论是在视椎外或是被遮挡住了

812
00:45:44,211 --> 0:45:46,647
再一次 我们的剔除计算内核

813
00:45:46,847 --> 0:45:49,816
在GPU上既执行椎剔除

814
00:45:50,150 --> 0:45:53,020
那就决定了这些几何图形是不可见的

815
00:45:53,086 --> 0:45:58,859
因此我们不会在GPU上处理或渲染

816
00:45:58,926 --> 0:46:01,595
这节约了许多渲染成本并提升了性能

817
00:45:58,926 --> 0:46:01,595
这节约了许多渲染成本并提升了性能

818
00:46:04,932 --> 0:46:06,266
较为简单的GPU家族

819
00:46:06,800 --> 0:46:11,038
在我们结束这场演讲之前

820
00:46:11,338 --> 0:46:15,909
我要讲一下我们如何把

821
00:46:15,976 --> 0:46:16,977
变得比以前更简单了

822
00:46:17,411 --> 0:46:20,480
我还要讲一下如何更容易地瞄准

823
00:46:20,547 --> 0:46:23,684
iOS、tvOS和

824
00:46:24,284 --> 0:46:28,188
在此之前 先让我们看一下

825
00:46:28,255 --> 0:46:30,591
现在各平台上可用的Metal功能

826
00:46:32,726 --> 0:46:35,796
现在Metal在iOS和

827
00:46:36,597 --> 0:46:40,601
在演讲的上半场我们讲了

828
00:46:40,667 --> 0:46:46,073
设置管道状态从而帮助你充分利用

829
00:46:46,640 --> 0:46:51,645
我们还讲了非直接范围

830
00:46:51,712 --> 0:46:54,982
更有效地打包和执行非直接命令

831
00:46:55,649 --> 0:46:59,386
最后我们还向

832
00:46:59,453 --> 0:47:01,255
16位深度纹理支持

833
00:46:59,453 --> 0:47:01,255
16位深度纹理支持

834
00:47:02,322 --> 0:47:06,193
这一直都是一个很流行的请求

835
00:47:06,827 --> 0:47:10,330
Metal在macOS上

836
00:47:11,532 --> 0:47:13,367
如果你需要向内存缓冲区中

837
00:47:13,433 --> 0:47:17,171
我们现在可以实现不带附件渲染了

838
00:47:17,771 --> 0:47:20,974
你可以查询你的命令缓冲器

839
00:47:21,275 --> 0:47:24,244
从而可以动态地调整表示区间

840
00:47:24,845 --> 0:47:30,083
最后MacOS现在支持sRGB

841
00:47:30,417 --> 0:47:33,253
从而更好地适应线性和非线性照明

842
00:47:34,521 --> 0:47:38,458
现在让我们看一下

843
00:47:41,195 --> 0:47:45,332
你之前使用Metal功能

844
00:47:45,399 --> 0:47:48,268
设置查询使你的app适应

845
00:47:48,802 --> 0:47:53,440
但功能的数量 功能集合增长了

846
00:47:53,507 --> 0:47:54,508
以打为单位

847
00:47:55,142 --> 0:47:58,979
GPU家族查询替换了功能集合

848
00:47:59,046 --> 0:48:00,814
使得系统的查询功能更简单了

849
00:47:59,046 --> 0:48:00,814
使得系统的查询功能更简单了

850
00:48:01,682 --> 0:48:06,353
首先我们把它们合并为四个家族

851
00:48:06,420 --> 0:48:07,554
并把它们组织起来

852
00:48:08,455 --> 0:48:11,491
第二 每个家族都支持

853
00:48:11,792 --> 0:48:13,660
它们被组织到一个或多个实例中

854
00:48:14,061 --> 0:48:18,131
因此支持一个实例意味着

855
00:48:19,066 --> 0:48:23,003
第三 新API把Metal

856
00:48:23,070 --> 0:48:27,574
用于追踪指定家族的实例

857
00:48:28,475 --> 0:48:34,114
最后一个GPU家族

858
00:48:34,615 --> 0:48:38,085
有一些可选功能 并未放到家族中

859
00:48:39,019 --> 0:48:43,323
通过这些信息 让我们具体看一下

860
00:48:45,325 --> 0:48:48,862
现在所有iOS和tvOS功能

861
00:48:48,929 --> 0:48:50,964
一个家族有五个实例

862
00:48:51,565 --> 0:48:56,170
每个实例支持之前实例内的所有功能

863
00:48:56,870 --> 0:48:59,473
我不打算在这里列举所有功能

864
00:48:59,540 --> 0:49:04,578
但这场演讲的资源部分有一个表

865
00:48:59,540 --> 0:49:04,578
但这场演讲的资源部分有一个表

866
00:49:04,645 --> 0:49:06,380
表中列出了家族和实例的功能

867
00:49:07,314 --> 0:49:10,851
Mac功能只围绕两个实例组织

868
00:49:11,285 --> 0:49:14,888
Mac 2支持来自Mac 1的

869
00:49:16,123 --> 0:49:19,393
现在查询这些功能

870
00:49:19,459 --> 0:49:23,363
扁平的、非特定的代码的书写

871
00:49:23,430 --> 0:49:24,565
所有平台时会怎么样？

872
00:49:25,132 --> 0:49:27,601
为此我们有新的通用家族

873
00:49:28,535 --> 0:49:32,840
通用家族把Metal功能

874
00:49:33,574 --> 0:49:37,945
所有Metal GPU

875
00:49:38,011 --> 0:49:40,848
对于只稍微使用了Metal的

876
00:49:41,915 --> 0:49:46,820
通用2提供所有创建优秀游戏开发

877
00:49:46,887 --> 0:49:51,758
比如非直接绘制、统计遮挡查询、

878
00:49:51,925 --> 0:49:54,027
和Metal性能阴影支持

879
00:49:54,895 --> 0:49:59,299
通用3提供高级app所需要的

880
00:49:59,366 --> 0:50:03,704
比如非直接命令缓冲区、分层渲染、

881
00:49:59,366 --> 0:50:03,704
比如非直接命令缓冲区、分层渲染、

882
00:50:03,770 --> 0:50:05,172
以及漩涡位置不变量

883
00:50:06,106 --> 0:50:12,012
最后Metal 3为iPad app提供一个

884
00:50:12,513 --> 0:50:15,582
也就是为那种体验进行的调整

885
00:50:18,218 --> 0:50:22,422
两个iOS Mac实例

886
00:50:22,489 --> 0:50:24,458
这对于在Mac上获得强大性能来说

887
00:50:25,225 --> 0:50:26,793
特别是它们使得

888
00:50:26,860 --> 0:50:31,565
Mac专用的区块压缩像素格式

889
00:50:31,632 --> 0:50:34,635
可以在另外的

890
00:50:35,369 --> 0:50:39,339
现在iOS Mac 1

891
00:50:39,573 --> 0:50:41,408
外加来自通用3的一些功能

892
00:50:41,942 --> 0:50:45,979
除了BC像素格式和所管理的纹理

893
00:50:46,246 --> 0:50:51,685
它支持立方体纹理数组、读写纹理、

894
00:50:51,919 --> 0:50:54,254
多视图端口渲染和非直接曲面细分

895
00:50:56,023 --> 0:50:59,893
iOS Mac 2

896
00:51:00,194 --> 0:51:03,797
除BC像素格式和所管理的纹理之外

897
00:51:04,531 --> 0:51:06,233
那么这就是四个新家族

898
00:51:06,867 --> 0:51:11,371
现在让我们看一下

899
00:51:13,207 --> 0:51:16,710
在这个例子中

900
00:51:18,445 --> 0:51:22,516
我们先检查OS

901
00:51:23,250 --> 0:51:27,254
如果新家族API可用

902
00:51:27,321 --> 0:51:29,089
Metal 3功能是否可用

903
00:51:29,656 --> 0:51:32,292
因为Metal 3是新发布的

904
00:51:32,459 --> 0:51:33,794
但这是一个很好的做法

905
00:51:35,162 --> 0:51:40,100
如果Metal 3可用

906
00:51:40,434 --> 0:51:44,371
这里的跨平台app

907
00:51:44,805 --> 0:51:47,908
以及一个或多个

908
00:51:49,009 --> 0:51:54,047
如果API或版本号有一个不可用

909
00:51:54,114 --> 0:51:57,584
较老的功能集API

910
00:51:58,719 --> 0:52:02,923
现在让我们看一下

911
00:51:58,719 --> 0:52:02,923
现在让我们看一下

912
00:52:05,058 --> 0:52:09,029
当某家族在家族内指定了

913
00:52:09,463 --> 0:52:13,534
但某些重要的功能和限制在家族内

914
00:52:13,600 --> 0:52:14,601
并不是统一地都支持

915
00:52:14,668 --> 0:52:17,471
比如深度24模板8像素格式

916
00:52:17,638 --> 0:52:19,640
以及一个像素中MSA样本的数量

917
00:52:20,407 --> 0:52:26,079
为了处理这些问题

918
00:52:26,146 --> 0:52:27,314
可以直接查询其中每一个功能

919
00:52:27,881 --> 0:52:32,252
但你可以看到

920
00:52:33,554 --> 0:52:37,624
那么要结束这场演讲

921
00:52:37,691 --> 0:52:40,794
有多少被新GPU家族所支持

922
00:52:42,963 --> 0:52:46,533
经典的延迟着色在所有平台上都支持

923
00:52:46,834 --> 0:52:50,637
可编程混合在所有

924
00:52:50,771 --> 0:52:53,006
它是开发游戏的一个很好的默认选择

925
00:52:53,841 --> 0:52:57,144
平铺延迟和前向渲染也通过

926
00:52:57,444 --> 0:53:01,715
要求有更先进的硬件条件

927
00:52:57,444 --> 0:53:01,715
要求有更先进的硬件条件

928
00:53:02,349 --> 0:53:05,185
最后可见度缓冲区技巧

929
00:53:05,385 --> 0:53:07,421
只由Mac家族支持

930
00:53:08,021 --> 0:53:11,458
它恰好有非常苛刻的分辨率要求

931
00:53:12,526 --> 0:53:17,364
现在让我们看一下这些家族

932
00:53:17,431 --> 0:53:18,866
然后就结束我们的演讲

933
00:53:21,301 --> 0:53:25,939
现在有些功能要求广泛的支持

934
00:53:26,306 --> 0:53:29,843
我们相信GPU驱动的管道

935
00:53:30,544 --> 0:53:34,448
因此我们非常高兴地告诉你们

936
00:53:34,515 --> 0:53:37,951
现在通用家族2及之后的家族都支持

937
00:53:38,252 --> 0:53:41,054
用于图形和计算的参数缓冲区

938
00:53:43,824 --> 0:53:46,360
然后我们就要结束这场演讲了

939
00:53:46,426 --> 0:53:47,761
用Metal进行现代化渲染

940
00:53:48,395 --> 0:53:52,165
我们希望你们可以在你们的游戏

941
00:53:52,332 --> 0:53:53,567
让我们快速回顾一下

942
00:53:55,235 --> 0:53:58,138
我同事Jaap讲了

943
00:53:58,205 --> 0:53:59,473
实施更高级的渲染技巧

944
00:53:59,973 --> 0:54:03,177
比如延迟着色、平铺前向渲染

945
00:53:59,973 --> 0:54:03,177
比如延迟着色、平铺前向渲染

946
00:54:03,510 --> 0:54:05,045
与iOS非常相配

947
00:54:05,245 --> 0:54:10,851
当合并和优化可编程混合

948
00:54:11,552 --> 0:54:14,521
在Mac上

949
00:54:14,588 --> 0:54:18,325
和查询LOD来实施

950
00:54:18,392 --> 0:54:20,027
并以高分辨率进行渲染

951
00:54:20,928 --> 0:54:23,297
但无论你选择使用哪种技巧

952
00:54:23,530 --> 0:54:26,633
你都可以把整个渲染循环

953
00:54:27,267 --> 0:54:30,404
椎剔除、遮挡剔除、LOD选择

954
00:54:30,470 --> 0:54:34,041
都可以在通过参数缓冲区

955
00:54:34,708 --> 0:54:38,378
现在你还可以把计算分派编码到

956
00:54:38,846 --> 0:54:41,415
GPU上的非直接命令缓冲区中

957
00:54:42,950 --> 0:54:47,421
无论你是想瞄准iOS或

958
00:54:47,521 --> 0:54:50,691
或想使用一些高级Metal功能

959
00:54:50,958 --> 0:54:54,228
你现在都可以使用新的、

960
00:54:54,695 --> 0:54:57,197
在运行时检查可用的功能

961
00:54:59,433 --> 0:55:03,837
现在请访问我们的演讲网站了解

962
00:54:59,433 --> 0:55:03,837
现在请访问我们的演讲网站了解

963
00:55:03,904 --> 0:55:05,405
和GPU驱动的管道的更多信息

964
00:55:05,806 --> 0:55:08,408
我们将发布

965
00:55:08,976 --> 0:55:11,745
你可以探索这些技巧

966
00:55:11,812 --> 0:55:14,448
和游戏中 请参加我们的演讲

967
00:55:14,515 --> 0:55:16,316
事实上这场演讲结束之后

968
00:55:18,018 --> 0:55:20,020
谢谢 祝你们度过愉快的会议时光
