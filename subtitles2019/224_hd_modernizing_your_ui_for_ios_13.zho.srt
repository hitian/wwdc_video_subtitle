1
00:00:06,640 --> 0:00:10,744
（针对iOS 13

2
00:00:14,915 --> 0:00:15,949
大家好

3
00:00:16,850 --> 0:00:20,754
这是针对iOS 13

4
00:00:22,155 --> 0:00:23,624
我是David Duncan

5
00:00:23,690 --> 0:00:27,561
稍后我的同事

6
00:00:28,829 --> 0:00:30,597
James和Mohammed

7
00:00:32,933 --> 0:00:35,669
在这场演讲中 我们要讲六件事

8
00:00:36,503 --> 0:00:39,106
准备好app的灵活性UI

9
00:00:40,207 --> 0:00:42,776
我们针对栏和呈现

10
00:00:43,043 --> 0:00:44,178
所做的改进

11
00:00:45,145 --> 0:00:47,514
app中搜索的新功能

12
00:00:47,881 --> 0:00:51,718
让app变得

13
00:00:52,252 --> 0:00:54,388
更加多产的新手势

14
00:00:54,755 --> 0:00:58,592
一些你之前一直没能做到的示例

15
00:00:59,459 --> 0:01:02,529
最后我们要回顾

16
00:00:59,459 --> 0:01:02,529
最后我们要回顾

17
00:01:02,596 --> 0:01:04,031
本周稍早些时候

18
00:01:05,532 --> 0:01:08,569
那么让我们谈谈灵活性UI

19
00:01:10,938 --> 0:01:13,907
那么具有灵活性的第一步…

20
00:01:14,708 --> 0:01:18,011
是当用户打开app时

21
00:01:19,313 --> 0:01:21,148
自iOS 8以来

22
00:01:21,215 --> 0:01:24,318
故事板是表达启动UI的优选方式

23
00:01:25,552 --> 0:01:27,955
但自iOS诞生之日起

24
00:01:28,021 --> 0:01:29,323
我们还支持另一种可替换的方法

25
00:01:30,724 --> 0:01:31,959
就是启动图像

26
00:01:32,826 --> 0:01:35,395
启动图像要求你为每一个

27
00:01:35,462 --> 0:01:36,930
指定一张图像

28
00:01:37,464 --> 0:01:40,133
并在产生新的屏幕尺寸时进行修订

29
00:01:41,235 --> 0:01:42,569
那样灵活性很低

30
00:01:43,604 --> 0:01:46,073
因此明年春季 2020年四月

31
00:01:46,573 --> 0:01:49,576
链接了iOS 13 SDK

32
00:01:50,077 --> 0:01:53,780
必须提供一个启动故事板

33
00:01:54,314 --> 0:01:57,384
你再也不用只提交启动图像了

34
00:01:58,318 --> 0:02:00,354
因此 如果你还没有采用启动故事板

35
00:01:58,318 --> 0:02:00,354
因此 如果你还没有采用启动故事板

36
00:02:00,821 --> 0:02:02,489
现在正是时候

37
00:02:03,490 --> 0:02:06,793
那会引导你进入下一个变更

38
00:02:08,294 --> 0:02:09,763
就是在过去…

39
00:02:10,396 --> 0:02:12,900
如果我们引入

40
00:02:13,333 --> 0:02:14,535
你的app将会是宽屏幕格式

41
00:02:15,502 --> 0:02:17,905
嗯 我们也不再打算那样做了

42
00:02:18,605 --> 0:02:22,075
因此 如果你的app采用了

43
00:02:22,743 --> 0:02:24,344
那么它将总是

44
00:02:24,411 --> 0:02:27,281
以屏幕的原生全屏分辨率显示

45
00:02:28,182 --> 0:02:31,718
因此 我们期待

46
00:02:32,252 --> 0:02:35,022
都使用合适的API

47
00:02:35,389 --> 0:02:36,356
在任意尺寸的屏幕上

48
00:02:38,525 --> 0:02:41,094
对于那些创建iPad app

49
00:02:41,528 --> 0:02:44,531
这也适用于分屏多任务

50
00:02:45,499 --> 0:02:49,069
因此 我们期待绝大多数app

51
00:02:49,336 --> 0:02:51,672
除非你需要提供非常拟真的体验

52
00:02:52,472 --> 0:02:54,708
都支持分屏多任务功能

53
00:02:55,108 --> 0:02:57,611
你的app可以以任意尺寸

54
00:02:57,911 --> 0:02:59,546
紧邻其它app显示

55
00:02:59,880 --> 0:03:01,882
可能是用户所选择的其它app

56
00:02:59,880 --> 0:03:01,882
可能是用户所选择的其它app

57
00:03:03,217 --> 0:03:04,918
如果你不确定…

58
00:03:06,153 --> 0:03:08,188
如果你可以支持全部这些

59
00:03:08,255 --> 0:03:09,223
以及其它一切功能

60
00:03:09,556 --> 0:03:10,991
你可能会想尝试另外一件事

61
00:03:11,058 --> 0:03:12,192
尤其是当你有iPad app时

62
00:03:12,492 --> 0:03:13,694
那就是专门为Mac创建

63
00:03:13,760 --> 0:03:17,231
通过我们在macOS Catalina中

64
00:03:17,564 --> 0:03:19,032
并且你直接就能在办公桌上实现

65
00:03:19,099 --> 0:03:21,635
要确保重调尺寸之后的任意尺寸

66
00:03:22,636 --> 0:03:25,339
那么在此之前

67
00:03:26,139 --> 0:03:27,808
要采用启动故事板

68
00:03:28,075 --> 0:03:31,144
用户即将看到启动UI

69
00:03:31,211 --> 0:03:33,347
当用户首次启动你的app时

70
00:03:34,214 --> 0:03:38,185
要确保app的布局

71
00:03:38,752 --> 0:03:41,922
无论是最小的iPhone

72
00:03:43,090 --> 0:03:45,826
最后 确保你的iPad app

73
00:03:45,893 --> 0:03:47,895
同样也支持分屏多任务功能

74
00:03:48,595 --> 0:03:51,665
因为你必须在

75
00:03:52,933 --> 0:03:56,770
然后让我们再谈谈栏

76
00:03:59,540 --> 0:04:00,440
那么…

77
00:03:59,540 --> 0:04:00,440
那么…

78
00:04:01,542 --> 0:04:05,078
如果你在安装测试版之后

79
00:04:06,046 --> 0:04:09,049
你可以看到现在的栏是如何显示的

80
00:04:09,449 --> 0:04:11,185
当你持续向上滚动到顶部时

81
00:04:11,518 --> 0:04:12,819
我们会退出背景

82
00:04:13,620 --> 0:04:15,255
当我们向下滚动时

83
00:04:15,322 --> 0:04:18,024
我们把它带回来了 既流畅又透明

84
00:04:19,526 --> 0:04:21,728
类似地 在iPad上

85
00:04:22,362 --> 0:04:24,064
如果你有分割视图控制器

86
00:04:24,665 --> 0:04:26,834
我们分别为两个方向

87
00:04:26,900 --> 0:04:30,571
无论细节是否支持大标题

88
00:04:32,039 --> 0:04:33,473
并且它们会分别进行响应

89
00:04:33,540 --> 0:04:35,475
因此显示哪个背景

90
00:04:35,542 --> 0:04:36,677
取决于滚动方向

91
00:04:38,278 --> 0:04:39,580
现在你可能会问

92
00:04:40,214 --> 0:04:41,181
要如何采用这个？

93
00:04:41,248 --> 0:04:43,717
如何确保

94
00:04:44,785 --> 0:04:46,620
嗯 采用方法很简单

95
00:04:47,154 --> 0:04:48,922
链接iOS 13

96
00:04:49,289 --> 0:04:50,324
你会免费获得它

97
00:04:51,625 --> 0:04:54,661
但如何让它在你的app中

98
00:04:54,962 --> 0:04:56,096
可能需要花点儿时间

99
00:04:56,630 --> 0:04:59,967
因此我们引入了新外观自定义API

100
00:05:00,033 --> 0:05:00,968
来帮助你实现

101
00:05:02,169 --> 0:05:03,036
那么让我们来看一下

102
00:05:03,103 --> 0:05:05,506
在新外观API中

103
00:05:05,572 --> 0:05:06,874
自定义导航栏是什么样子

104
00:05:06,940 --> 0:05:08,175
（新栏外观）

105
00:05:08,976 --> 0:05:10,844
那么我们要做的第一件事

106
00:05:12,179 --> 0:05:13,413
就是创建对象

107
00:05:13,747 --> 0:05:15,215
它实际上表示外观

108
00:05:15,782 --> 0:05:17,284
UINavigationBarAppearance

109
00:05:18,051 --> 0:05:20,320
是UIBarAppearance

110
00:05:20,754 --> 0:05:23,290
它压缩了

111
00:05:23,557 --> 0:05:24,591
UINavigationBar的

112
00:05:25,158 --> 0:05:27,327
在这种情况下

113
00:05:27,394 --> 0:05:28,795
使用一种不透明的颜色

114
00:05:29,396 --> 0:05:31,231
因此我们要使用默认值

115
00:05:31,298 --> 0:05:33,567
它是由configureWith

116
00:05:34,568 --> 0:05:37,237
那会让导航栏的背景遵守

117
00:05:37,304 --> 0:05:40,207
明亮和暗黑模式

118
00:05:41,675 --> 0:05:43,710
在这个特例中

119
00:05:43,777 --> 0:05:45,512
我们还想改变标签颜色

120
00:05:46,079 --> 0:05:48,882
因此我们可以设置

121
00:05:48,949 --> 0:05:50,350
和largeTitleTextAttributes

122
00:05:50,884 --> 0:05:53,887
我们要给它们设定一个

123
00:05:54,354 --> 0:05:55,389
另一种动态颜色

124
00:05:55,455 --> 0:05:57,558
正因为如此 才能保证

125
00:05:58,892 --> 0:06:02,696
最后我们要把它应用到

126
00:05:58,892 --> 0:06:02,696
最后我们要把它应用到

127
00:06:03,797 --> 0:06:05,699
那么什么是

128
00:06:06,400 --> 0:06:07,568
嗯 让我们来看看

129
00:06:09,870 --> 0:06:11,038
导航栏

130
00:06:11,104 --> 0:06:12,873
当它是自己的尺寸时 没有大标题

131
00:06:13,173 --> 0:06:14,374
它是标准尺寸

132
00:06:14,942 --> 0:06:16,844
这就是standardAppearance

133
00:06:17,578 --> 0:06:20,981
此外 如果你不指定其它外观配置

134
00:06:21,481 --> 0:06:25,085
我们会对其它两个配置

135
00:06:25,152 --> 0:06:26,420
我们稍后再谈

136
00:06:29,456 --> 0:06:31,892
那么如果你使用

137
00:06:32,226 --> 0:06:33,627
你会得到

138
00:06:34,294 --> 0:06:35,762
这就是它所表达的东西

139
00:06:36,430 --> 0:06:37,297
它的数量

140
00:06:38,665 --> 0:06:41,468
之前我们在iOS 13中看到过

141
00:06:42,336 --> 0:06:44,905
导航栏把它的背景变成了透明的

142
00:06:44,972 --> 0:06:47,207
当你从滚动视图的顶部向下拉动时

143
00:06:47,975 --> 0:06:50,310
那就是

144
00:06:51,278 --> 0:06:53,780
无论何时

145
00:06:53,847 --> 0:06:55,249
这在app中很常见

146
00:06:55,883 --> 0:06:57,417
如果你处于滚动视图的顶部

147
00:06:57,851 --> 0:07:00,554
那么我们将使用

148
00:06:57,851 --> 0:07:00,554
那么我们将使用

149
00:07:01,421 --> 0:07:03,257
默认是使用一个透明背景

150
00:07:03,590 --> 0:07:06,426
这就是为什么

151
00:07:06,493 --> 0:07:08,128
无缝外观是我们在iOS 13中

152
00:07:10,397 --> 0:07:12,833
此外 你还可以自定义

153
00:07:12,900 --> 0:07:14,001
栏按钮项的外观

154
00:07:14,401 --> 0:07:16,170
并自定义buttonAppearance

155
00:07:16,737 --> 0:07:19,072
以及自定义doneButtonAppearance

156
00:07:21,008 --> 0:07:22,543
现在我们可以暂停一下

157
00:07:22,809 --> 0:07:24,511
你得到了导航栏 它是自定义导航栏

158
00:07:24,578 --> 0:07:25,412
很棒

159
00:07:26,413 --> 0:07:29,283
但我们决定把它应用到

160
00:07:29,716 --> 0:07:32,419
以便你可以用非常相似的方法

161
00:07:33,053 --> 0:07:35,689
每一个类都能使用它们自己的

162
00:07:35,756 --> 0:07:39,059
来实现它们自己的自定义功能

163
00:07:39,793 --> 0:07:42,262
ToolbarAppearance

164
00:07:42,329 --> 0:07:43,964
与navigationBarAppearance

165
00:07:44,031 --> 0:07:46,700
因此再进一步也没有多大意思

166
00:07:47,234 --> 0:07:48,969
但TabBarAppearance

167
00:07:49,036 --> 0:07:51,138
那是因为TabBar也有点不一样

168
00:07:52,906 --> 0:07:54,241
那么对于TabBar

169
00:07:54,775 --> 0:07:56,810
针对三个布局外观

170
00:07:57,344 --> 0:07:59,046
拥有附加的自定义选项

171
00:07:59,112 --> 0:08:00,447
stackedLayoutAppearance、

172
00:07:59,112 --> 0:08:00,447
stackedLayoutAppearance、

173
00:08:00,948 --> 0:08:02,950
你将在iPad上看到的

174
00:08:03,817 --> 0:08:06,653
以及你将在小屏幕手机上看到的

175
00:08:08,088 --> 0:08:10,123
那么你可以把它们放在一起

176
00:08:11,158 --> 0:08:13,927
并获得全部栏的新自定义外观

177
00:08:15,195 --> 0:08:16,230
但还有另一件事

178
00:08:18,465 --> 0:08:20,000
如果你看一下

179
00:08:20,400 --> 0:08:21,835
当你导航到一个列表时

180
00:08:22,636 --> 0:08:25,239
它的标题颜色会发生改变

181
00:08:26,740 --> 0:08:27,975
它的实现方式是

182
00:08:28,408 --> 0:08:31,778
对每个导航项都使用

183
00:08:32,546 --> 0:08:35,649
那就允许你根据

184
00:08:35,716 --> 0:08:37,351
要放到navigationBar

185
00:08:38,619 --> 0:08:40,354
导航项也与导航相关联

186
00:08:40,419 --> 0:08:41,255
或与视图控制器相关联

187
00:08:41,321 --> 0:08:43,457
因此 放到导航控制器上

188
00:08:43,524 --> 0:08:44,658
将会自动使用那个

189
00:08:45,659 --> 0:08:46,760
那么它看起来是什么样呢？

190
00:08:48,428 --> 0:08:49,463
嗯…

191
00:08:49,997 --> 0:08:52,032
导航项拥有

192
00:08:52,499 --> 0:08:53,834
与navigationBar

193
00:08:54,401 --> 0:08:56,737
因此通常要做的事就是

194
00:08:57,171 --> 0:08:59,072
从navigationBar中

195
00:08:59,840 --> 0:09:03,477
并复制 以便与那个外观相分离

196
00:08:59,840 --> 0:09:03,477
并复制 以便与那个外观相分离

197
00:09:04,845 --> 0:09:06,246
并做一切你想要做的变更

198
00:09:06,580 --> 0:09:08,081
如果你希望它是透明的

199
00:09:08,148 --> 0:09:10,083
你可以使用配置透明

200
00:09:10,984 --> 0:09:13,420
你可以修改栏按钮项的外观等等

201
00:09:14,922 --> 0:09:16,590
然后你再把它分配给导航项

202
00:09:17,424 --> 0:09:20,093
一旦完成 无论何时当视图控制器

203
00:09:20,160 --> 0:09:21,361
和导航栏项处于当前时

204
00:09:21,828 --> 0:09:25,032
我们都将使用那个外观而不是

205
00:09:25,465 --> 0:09:28,368
从而确保你可以自定义你的

206
00:09:28,435 --> 0:09:30,137
无论应用了哪种视图控制器

207
00:09:33,273 --> 0:09:35,576
为此我要邀请Russell上台来

208
00:09:35,642 --> 0:09:36,977
为大家讲讲呈现

209
00:09:41,315 --> 0:09:42,549
（呈现）

210
00:09:44,952 --> 0:09:45,953
谢谢David

211
00:09:47,087 --> 0:09:48,055
大家好

212
00:09:48,121 --> 0:09:50,691
我是Russell

213
00:09:51,058 --> 0:09:53,260
对于呈现我们有一个标准设计

214
00:09:53,527 --> 0:09:55,295
我今天要跟大家分享一下

215
00:09:56,797 --> 0:09:59,199
比如说如果我处于通讯录app中

216
00:09:59,766 --> 0:10:01,802
并且我轻触了加号

217
00:09:59,766 --> 0:10:01,802
并且我轻触了加号

218
00:10:02,202 --> 0:10:05,205
我们有一个新的呈现样式

219
00:10:05,539 --> 0:10:07,841
而不是之前的全屏呈现

220
00:10:08,675 --> 0:10:10,777
你可以看到根视图控制器的视图

221
00:10:10,844 --> 0:10:14,648
并没有按比例缩小

222
00:10:15,983 --> 0:10:17,384
这个设计的分层

223
00:10:17,718 --> 0:10:21,288
给你的用户提供了一种情境

224
00:10:22,022 --> 0:10:24,725
并且圆形顶部外观的作用是一个信号

225
00:10:25,158 --> 0:10:28,562
表示可以交互式地清除这些呈现

226
00:10:28,929 --> 0:10:30,197
在系统的任何地方

227
00:10:32,165 --> 0:10:33,433
那么…谢谢

228
00:10:37,671 --> 0:10:39,273
那么这个新的呈现样式是什么呢？

229
00:10:40,140 --> 0:10:43,477
这些呈现叫做Sheets

230
00:10:43,877 --> 0:10:45,512
Sheets也不是什么新东西

231
00:10:45,946 --> 0:10:48,415
这些呈现

232
00:10:48,482 --> 0:10:52,252
只是当前

233
00:10:52,586 --> 0:10:54,321
以及它兄弟

234
00:10:55,722 --> 0:10:56,590
之前

235
00:10:56,657 --> 0:10:59,092
这些样式会采用全屏呈现

236
00:10:59,159 --> 0:11:00,494
在宽度压缩的环境中

237
00:10:59,159 --> 0:11:00,494
在宽度压缩的环境中

238
00:11:01,061 --> 0:11:04,565
现在它们只会保留sheet

239
00:11:04,631 --> 0:11:07,501
和压缩宽度

240
00:11:09,403 --> 0:11:11,305
那么让我们通过实际操作看一些例子

241
00:11:12,472 --> 0:11:14,942
在手机和竖屏模式中

242
00:11:15,509 --> 0:11:16,677
但在手机的横屏模式中

243
00:11:16,743 --> 0:11:18,345
你获得一个与之前一样的全屏布局

244
00:11:20,347 --> 0:11:21,515
但我们不能遗忘iPad

245
00:11:21,849 --> 0:11:23,283
在这点上我们重新思考了

246
00:11:23,917 --> 0:11:26,620
页面Sheets悬浮

247
00:11:27,521 --> 0:11:29,823
并且如果有呈现多重Sheet

248
00:11:30,290 --> 0:11:32,259
它们会在检查控制器顶部形成堆栈

249
00:11:34,862 --> 0:11:38,198
特别是这个新尺寸要遵从可阅读宽度

250
00:11:38,465 --> 0:11:40,200
因此对于文本内容来说很完美

251
00:11:40,968 --> 0:11:42,102
并且因为可阅读宽度

252
00:11:42,369 --> 0:11:45,239
会随着用户当前所选择的动态类型

253
00:11:45,706 --> 0:11:47,774
这些页面Sheet的尺寸也会改变

254
00:11:48,141 --> 0:11:50,177
像这样或甚至是像这样

255
00:11:50,911 --> 0:11:52,546
或者它们会呈现堆叠式外观

256
00:11:52,813 --> 0:11:55,849
如果它们的优选宽度

257
00:11:59,319 --> 0:12:01,788
要在你的app中获得这个新外观

258
00:11:59,319 --> 0:12:01,788
要在你的app中获得这个新外观

259
00:12:01,855 --> 0:12:02,689
你都需要做哪些操作呢？

260
00:12:03,156 --> 0:12:05,125
嗯 你要做的很少

261
00:12:05,192 --> 0:12:08,328
让这种转换变得尽可能简单了

262
00:12:10,531 --> 0:12:13,367
默认的UIViewController

263
00:12:13,433 --> 0:12:16,570
变成了一种新样式

264
00:12:17,771 --> 0:12:20,440
Automatic

265
00:12:20,707 --> 0:12:23,010
在呈现时使用

266
00:12:23,911 --> 0:12:24,978
为了说明它的行为

267
00:12:25,445 --> 0:12:27,181
让我们一起来看几个例子

268
00:12:29,650 --> 0:12:32,586
那么在这里

269
00:12:32,886 --> 0:12:35,455
它将呈现

270
00:12:35,522 --> 0:12:36,890
显示用户的相册

271
00:12:37,224 --> 0:12:40,027
请注意那儿并没有设置

272
00:12:41,228 --> 0:12:43,564
在iOS 12中使用的同样的代码

273
00:12:43,630 --> 0:12:45,566
会全屏呈现图片选择器

274
00:12:45,632 --> 0:12:46,967
现在将以Sheet形式呈现

275
00:12:47,401 --> 0:12:49,169
而你不需要修改任何代码

276
00:12:51,872 --> 0:12:52,873
另一方面

277
00:12:52,940 --> 0:12:56,043
如果我配置UIImagePickerController

278
00:12:56,510 --> 0:12:59,813
这段代码将在iOS 13中

279
00:13:00,147 --> 0:13:01,548
就像它在iOS 12中那样

280
00:13:02,516 --> 0:13:05,519
这是自动的 解决不同的样式

281
00:13:05,819 --> 0:13:09,122
根据系统提供视图控制器的配置方式

282
00:13:09,423 --> 0:13:10,958
因此你不需要修改任何代码

283
00:13:13,961 --> 0:13:15,963
现在如何呈现

284
00:13:16,897 --> 0:13:20,067
如果我简单地初始化并呈现

285
00:13:20,133 --> 0:13:22,569
它将以Sheet形式呈现

286
00:13:23,036 --> 0:13:24,805
换句话说 在默认情况下

287
00:13:25,272 --> 0:13:27,374
Automatic

288
00:13:28,909 --> 0:13:31,879
这很棒 因为它对于

289
00:13:32,946 --> 0:13:34,648
再一次 不需要修改任何代码

290
00:13:36,383 --> 0:13:38,418
但如果是

291
00:13:39,219 --> 0:13:42,456
如果你有一个自定义视图控制器

292
00:13:42,856 --> 0:13:45,792
比如你自己的自定义相机

293
00:13:46,226 --> 0:13:48,161
你可能会发现当你创建这部分代码时

294
00:13:48,495 --> 0:13:50,464
你的沉浸式体验就会转变为

295
00:13:51,131 --> 0:13:53,500
但不要担心

296
00:13:54,234 --> 0:13:56,537
把这个视图控制器的

297
00:13:56,603 --> 0:13:58,472
明确地设置为全屏

298
00:13:59,773 --> 0:14:02,176
通常来说 保留属性的默认值就可以

299
00:13:59,773 --> 0:14:02,176
通常来说 保留属性的默认值就可以

300
00:14:02,242 --> 0:14:05,712
只需要指定一个确切值

301
00:14:05,779 --> 0:14:08,315
当你有意偏离默认行为时

302
00:14:11,885 --> 0:14:13,887
那么Popovers呢？

303
00:14:14,688 --> 0:14:16,857
Popover现在总会适应工作表

304
00:14:17,357 --> 0:14:19,293
因此 如果你想要一个

305
00:14:19,826 --> 0:14:21,862
和压缩宽度的Sheet

306
00:14:22,629 --> 0:14:25,465
你所要做的就是

307
00:14:25,532 --> 0:14:27,100
Popover 然后就完成了

308
00:14:27,434 --> 0:14:28,769
然后你将完全获得那种行为

309
00:14:32,172 --> 0:14:33,040
现在…

310
00:14:33,774 --> 0:14:37,444
要支持下拉清除需要做哪些操作呢？

311
00:14:40,514 --> 0:14:41,849
一般来说 什么也不用做

312
00:14:42,482 --> 0:14:43,984
如果你把某个东西

313
00:14:44,284 --> 0:14:46,687
你就可以免费获得下拉功能

314
00:14:47,287 --> 0:14:50,157
我们将在你所呈现的整个视图中

315
00:14:50,490 --> 0:14:54,127
因此在任意非交互性区域执行的下拉

316
00:14:55,195 --> 0:14:59,466
如用户在包含scrollView

317
00:14:59,733 --> 0:15:02,803
也会下拉sheet

318
00:14:59,733 --> 0:15:02,803
也会下拉sheet

319
00:15:05,372 --> 0:15:08,876
然而 有时候下拉sheet

320
00:15:08,942 --> 0:15:09,977
可能会不太合适

321
00:15:11,345 --> 0:15:15,115
比如 如果我们呈现了与这个

322
00:15:15,649 --> 0:15:17,451
那么就不应该允许下拉Sheet

323
00:15:17,751 --> 0:15:22,456
因为不清楚用户

324
00:15:23,123 --> 0:15:25,092
并且如果用户尝试下拉

325
00:15:25,592 --> 0:15:27,094
Sheet应该和橡皮筋一样

326
00:15:27,361 --> 0:15:28,896
并呈现一个

327
00:15:29,196 --> 0:15:32,466
显示用户可以进行的各种操作

328
00:15:36,236 --> 0:15:37,404
因此要创建这种体验

329
00:15:37,704 --> 0:15:39,106
我们有两个新API

330
00:15:40,073 --> 0:15:42,576
第一个是模态和呈现

331
00:15:43,143 --> 0:15:44,811
是pUIViewController上的

332
00:15:45,345 --> 0:15:48,015
当你在所呈现的视图控制器上

333
00:15:48,715 --> 0:15:52,953
它将使Sheet处于模态状态

334
00:15:54,388 --> 0:15:56,690
并且你将获得橡皮筋效果

335
00:15:57,457 --> 0:16:01,195
这个属性取代了现有的

336
00:15:57,457 --> 0:16:01,195
这个属性取代了现有的

337
00:16:01,261 --> 0:16:04,031
防止Sheets和

338
00:16:06,667 --> 0:16:10,237
第二个是一个新

339
00:16:10,304 --> 0:16:12,072
DelegateMethod 叫做

340
00:16:12,139 --> 0:16:15,275
presentationControllerDidAttemptToDismiss

341
00:16:15,342 --> 0:16:18,412
因此如果你在相关的呈现控制器上

342
00:16:19,012 --> 0:16:22,983
UIKit将调用这个方法

343
00:16:23,383 --> 0:16:25,586
那时你可以呈现

344
00:16:28,922 --> 0:16:31,491
在这里你可以看到

345
00:16:32,359 --> 0:16:36,797
只有当isModalInPresentation为真时

346
00:16:37,397 --> 0:16:40,801
并且用户下拉和释放的目的是清除

347
00:16:40,868 --> 0:16:42,603
有一点儿强迫或暴力

348
00:16:43,570 --> 0:16:44,838
我们把它叫做Modal Flow

349
00:16:45,239 --> 0:16:48,108
并且我有一个示例项目可以演示

350
00:16:48,175 --> 0:16:49,376
一个像这样的例子

351
00:16:49,743 --> 0:16:52,746
但请看一下描述中的链接

352
00:16:54,147 --> 0:16:55,349
但我们还有更多

353
00:16:56,116 --> 0:16:58,685
我们还有几个委托回调函数

354
00:16:59,119 --> 0:17:00,787
PresentationControllerShouldDismiss

355
00:16:59,119 --> 0:17:00,787
PresentationControllerShouldDismiss

356
00:17:01,088 --> 0:17:03,290
用于从委托中阻止清除

357
00:17:03,824 --> 0:17:06,425
WillDismiss用于获取

358
00:17:06,492 --> 0:17:08,595
视图控制器的一个转换协调器

359
00:17:08,896 --> 0:17:11,464
你可以用它设置周边的动画、

360
00:17:11,531 --> 0:17:14,501
交互变更通知和动画完成块

361
00:17:15,135 --> 0:17:16,303
以及DidDismiss

362
00:17:16,637 --> 0:17:20,574
用于清除状态 因为它只有当用户

363
00:17:20,641 --> 0:17:23,076
并完成转换时才会被调用一次

364
00:17:25,145 --> 0:17:27,446
这三种回调函数取代了拥有

365
00:17:27,513 --> 0:17:29,983
presentationControllerDelegate

366
00:17:30,651 --> 0:17:33,720
这些API既可在Sheets中

367
00:17:35,789 --> 0:17:39,927
请记住 如用户重复拉动Sheet

368
00:17:40,327 --> 0:17:41,728
而不是下拉

369
00:17:41,795 --> 0:17:43,764
委托会多次收到…

370
00:17:44,731 --> 0:17:48,936
Should和WillDismiss

371
00:17:49,269 --> 0:17:51,004
如果能收到DidDismiss

372
00:17:54,975 --> 0:17:57,377
现在让我们暂时转到分享扩展

373
00:17:58,545 --> 0:18:02,282
当你用iOS 13 SDK

374
00:17:58,545 --> 0:18:02,282
当你用iOS 13 SDK

375
00:18:02,683 --> 0:18:03,884
就像这里的邮箱一样

376
00:18:04,751 --> 0:18:08,222
它将成为Sheets

377
00:18:09,223 --> 0:18:12,326
那么在扩展的主视图控制器上

378
00:18:12,392 --> 0:18:15,295
就像你在Info P List中

379
00:18:15,929 --> 0:18:18,565
一定要设置

380
00:18:19,032 --> 0:18:20,901
一旦用户开始输入数据

381
00:18:21,568 --> 0:18:23,904
并且如果你让主视图控制器

382
00:18:23,971 --> 0:18:27,241
遵从UIAdaptivePresentation

383
00:18:27,541 --> 0:18:30,010
并实施

384
00:18:30,477 --> 0:18:33,447
我们将调用那个方法

385
00:18:33,981 --> 0:18:36,917
请注意 我们不会调用

386
00:18:38,785 --> 0:18:40,821
并且你可以在将来的种子中

387
00:18:43,524 --> 0:18:44,491
接下来

388
00:18:44,558 --> 0:18:46,793
我想让你思考一些东西

389
00:18:47,661 --> 0:18:50,797
第一个与UIViewController

390
00:18:51,765 --> 0:18:54,968
尤其是

391
00:18:55,435 --> 0:18:57,337
呈现视图控制器

392
00:18:58,005 --> 0:19:01,542
所接收的外观回调函数之间的区别

393
00:18:58,005 --> 0:19:01,542
所接收的外观回调函数之间的区别

394
00:19:02,943 --> 0:19:04,478
全屏呈现时

395
00:19:04,778 --> 0:19:08,482
呈现视图控制器的视图

396
00:19:09,216 --> 0:19:12,319
结果是它会收到

397
00:19:12,586 --> 0:19:15,522
当呈现转换开始时

398
00:19:15,889 --> 0:19:18,926
然后收到viewDidDisappear

399
00:19:19,660 --> 0:19:21,995
类似地 在清除转换过程中

400
00:19:22,062 --> 0:19:24,031
当它的视图移回视图等级中时

401
00:19:24,097 --> 0:19:25,732
它会收到

402
00:19:27,100 --> 0:19:29,403
但对于Sheet呈现

403
00:19:30,137 --> 0:19:31,305
呈现视图控制器的视图

404
00:19:31,371 --> 0:19:33,106
不会从视图等级中移除

405
00:19:33,507 --> 0:19:35,008
因此它的视图

406
00:19:35,075 --> 0:19:38,445
或视图控制器

407
00:19:39,346 --> 0:19:41,014
因此

408
00:19:41,315 --> 0:19:43,283
你需要在清除Sheet时执行

409
00:19:43,617 --> 0:19:45,652
你应该了解一下我们刚讲过的

410
00:19:45,719 --> 0:19:48,021
呈现控制器的Will

411
00:19:51,191 --> 0:19:53,193
第二 我希望你们都考虑一下

412
00:19:53,460 --> 0:19:55,829
我们插入了一些私有视图

413
00:19:55,896 --> 0:19:58,632
在UIWindow之间的视图等级

414
00:19:58,932 --> 0:20:00,300
及其rootViewController视图中

415
00:19:58,932 --> 0:20:00,300
及其rootViewController视图中

416
00:20:01,602 --> 0:20:03,370
这个变更应该不会影响你

417
00:20:03,937 --> 0:20:05,372
我们只是不希望你太吃惊

418
00:20:05,439 --> 0:20:07,140
当你在视图调试器中

419
00:20:07,941 --> 0:20:09,543
UIWindow之间的关系

420
00:20:09,810 --> 0:20:11,278
UIWindow与其

421
00:20:11,345 --> 0:20:13,247
是UIKit的一个实施细节

422
00:20:13,714 --> 0:20:16,183
因为UIWindow有责任

423
00:20:16,250 --> 0:20:18,952
管理这个视图

424
00:20:20,120 --> 0:20:22,389
一般来说

425
00:20:22,456 --> 0:20:23,724
app没有视图等级结构的所有权

426
00:20:24,024 --> 0:20:26,493
这个结构很容易被修改

427
00:20:27,361 --> 0:20:30,230
因此一定要确保你写代码的方式

428
00:20:30,597 --> 0:20:33,767
不会假定私有视图等级

429
00:20:35,536 --> 0:20:36,670
（更新你的APP）

430
00:20:36,737 --> 0:20:40,040
因此在你的app中

431
00:20:40,607 --> 0:20:43,777
你可以在绝大多数UI中使用它们

432
00:20:44,945 --> 0:20:48,682
当下拉请求用户的意图时

433
00:20:49,483 --> 0:20:51,985
请记住 有一个示例项目完全阐明了

434
00:20:52,052 --> 0:20:53,820
具体如何实现…

435
00:20:54,154 --> 0:20:55,422
在演讲的文档中

436
00:20:57,324 --> 0:20:58,225
谢谢大家

437
00:20:58,292 --> 0:21:00,694
现在我要把舞台交给Kyle

438
00:20:58,292 --> 0:21:00,694
现在我要把舞台交给Kyle

439
00:21:06,466 --> 0:21:07,434
讲得很好

440
00:21:09,803 --> 0:21:10,904
谢谢Russell

441
00:21:15,909 --> 0:21:18,645
大家好 我是Kyle

442
00:21:18,712 --> 0:21:19,546
（搜索）

443
00:21:19,613 --> 0:21:23,684
我要和大家分享一下iOS 13中

444
00:21:25,152 --> 0:21:27,221
这并不是新搜索 这是当前的搜索…

445
00:21:27,855 --> 0:21:30,224
Mail app中的搜索界面

446
00:21:31,024 --> 0:21:32,993
它使用的是UIKit

447
00:21:33,460 --> 0:21:37,731
特别是UIViewController的子类

448
00:21:38,765 --> 0:21:40,667
我们所有用户都很熟悉它

449
00:21:41,768 --> 0:21:43,470
在你的app中也可用

450
00:21:44,137 --> 0:21:46,306
它由许多部分组成

451
00:21:47,674 --> 0:21:49,810
最大的一部分是

452
00:21:50,210 --> 0:21:51,912
你可以在这里看到 在屏幕顶部

453
00:21:53,413 --> 0:21:55,349
搜索栏有很多组件

454
00:21:55,716 --> 0:21:59,019
包括取消按钮

455
00:21:59,086 --> 0:22:01,388
就是在搜索字段下方的按钮行

456
00:21:59,086 --> 0:22:01,388
就是在搜索字段下方的按钮行

457
00:22:03,323 --> 0:22:08,161
现在你可能注意到了范围栏

458
00:22:08,228 --> 0:22:09,363
在iOS 13中更新了视觉外观

459
00:22:11,932 --> 0:22:17,371
但现在我们允许app

460
00:22:17,804 --> 0:22:20,140
即使它由UISearchController

461
00:22:21,041 --> 0:22:24,745
因此如果你的app

462
00:22:25,112 --> 0:22:26,513
但你希望它们可用

463
00:22:26,847 --> 0:22:28,649
也许取决于UI状态

464
00:22:29,082 --> 0:22:32,886
你可以通过UISearchController

465
00:22:35,122 --> 0:22:36,056
同时…

466
00:22:37,024 --> 0:22:41,228
在UISearchBar上把

467
00:22:41,995 --> 0:22:44,097
意思是自定义非常简单

468
00:22:54,208 --> 0:22:56,376
那么要自定义

469
00:22:58,145 --> 0:23:00,881
请在UISearchController上

470
00:22:58,145 --> 0:23:00,881
请在UISearchController上

471
00:23:01,515 --> 0:23:03,851
并在UISearchBar上

472
00:23:03,917 --> 0:23:05,886
从而控制取消按钮

473
00:23:06,253 --> 0:23:07,421
和范围栏是否可见

474
00:23:08,689 --> 0:23:11,024
使用searchTextField属性

475
00:23:11,458 --> 0:23:14,828
以引用

476
00:23:15,395 --> 0:23:17,965
并修改文本字段上

477
00:23:18,031 --> 0:23:18,999
你想要修改的所有属性

478
00:23:19,266 --> 0:23:20,968
它是UITextField的子类

479
00:23:21,034 --> 0:23:23,070
你可以在那儿使用所有的样式属性

480
00:23:27,708 --> 0:23:30,711
UI搜索控制器行为也扩展到了外观

481
00:23:30,777 --> 0:23:32,179
和清除搜索

482
00:23:32,779 --> 0:23:33,914
因此标准行为…

483
00:23:34,882 --> 0:23:36,483
是当你通过轻触它的搜索字段

484
00:23:36,850 --> 0:23:38,218
而激活搜索栏时

485
00:23:39,319 --> 0:23:40,988
它会升到屏幕顶部

486
00:23:41,855 --> 0:23:44,224
但之前屏幕上的可见内容

487
00:23:44,858 --> 0:23:45,792
仍保持可见

488
00:23:48,028 --> 0:23:50,531
当你输入时 在这种情况下

489
00:23:50,864 --> 0:23:53,734
会显示与你的局部搜索项

490
00:23:55,669 --> 0:23:58,105
这是通过你的app提供的

491
00:23:58,172 --> 0:24:01,408
它叫做搜索结果控制器

492
00:23:58,172 --> 0:24:01,408
它叫做搜索结果控制器

493
00:24:04,178 --> 0:24:05,712
并不是每个app都像这样

494
00:24:06,413 --> 0:24:08,015
比如 在Mail app中

495
00:24:08,482 --> 0:24:10,250
如果你轻触搜索字段

496
00:24:10,984 --> 0:24:12,853
它会提供一份推荐搜索列表

497
00:24:15,689 --> 0:24:18,825
它仍然是UISearchController的

498
00:24:19,459 --> 0:24:21,695
我们在iOS 13中

499
00:24:21,995 --> 0:24:23,330
也增加了这个功能

500
00:24:29,903 --> 0:24:32,606
只需要在搜索控制器上

501
00:24:33,073 --> 0:24:35,242
把showsSearchResultsController

502
00:24:35,976 --> 0:24:37,744
然后你就可以管理自动化行为了

503
00:24:38,045 --> 0:24:40,514
自动显示搜索结果控制器属性

504
00:24:43,050 --> 0:24:44,585
在搜索中还有另一个大功能

505
00:24:46,920 --> 0:24:49,890
在Mail和Photos

506
00:24:50,591 --> 0:24:55,128
这些推荐搜索 结果…

507
00:24:55,896 --> 0:24:57,965
是对更复杂的

508
00:24:58,565 --> 0:25:00,234
搜索查询的可视化陈述

509
00:24:58,565 --> 0:25:00,234
搜索查询的可视化陈述

510
00:25:02,603 --> 0:25:05,205
你可以在你的app中使用这个功能

511
00:25:05,506 --> 0:25:07,608
在UISearchTextField的

512
00:25:08,408 --> 0:25:10,577
通过新

513
00:25:11,411 --> 0:25:14,815
并且这些token支持

514
00:25:15,382 --> 0:25:18,986
这与我们在所有app上

515
00:25:25,526 --> 0:25:28,996
比如Photos用它提供所保存的

516
00:25:29,062 --> 0:25:33,500
或所预测的针对人、

517
00:25:34,768 --> 0:25:38,205
在SearchResultsController中

518
00:25:38,972 --> 0:25:42,543
Photos把输入转为token

519
00:25:44,411 --> 0:25:45,546
（Token和文本）

520
00:25:45,612 --> 0:25:48,182
这是UITextField的子类

521
00:25:48,448 --> 0:25:50,584
Token会与文本相互作用

522
00:25:51,385 --> 0:25:54,288
事实上 它们总是优先于文本

523
00:25:55,756 --> 0:25:58,692
比如 如果我把token

524
00:25:59,159 --> 0:26:01,862
即使我的插入点位于搜索字段末端

525
00:25:59,159 --> 0:26:01,862
即使我的插入点位于搜索字段末端

526
00:26:02,596 --> 0:26:04,031
Token也会出现在开端

527
00:26:05,432 --> 0:26:07,534
正如你在这里所看到的

528
00:26:08,836 --> 0:26:12,306
我可以扩展选择

529
00:26:12,706 --> 0:26:13,707
又包含一些文本

530
00:26:15,275 --> 0:26:16,210
（创建Token）

531
00:26:16,276 --> 0:26:17,878
创建token非常简单

532
00:26:20,080 --> 0:26:22,850
首先获取所选中文本的范围

533
00:26:23,116 --> 0:26:25,252
以便了解你要把哪些文本

534
00:26:26,854 --> 0:26:28,789
创建一个

535
00:26:30,157 --> 0:26:32,726
并在SearchTextField上

536
00:26:33,227 --> 0:26:36,430
用token替换

537
00:26:37,731 --> 0:26:40,601
你的app可以完全控制

538
00:26:40,667 --> 0:26:41,835
和移除

539
00:26:42,703 --> 0:26:44,738
因此你可以赋予它

540
00:26:47,608 --> 0:26:52,913
UITextField换成了一个

541
00:26:53,981 --> 0:26:55,716
如果你正在执行程序性选择

542
00:26:56,283 --> 0:26:59,620
了解一下UITextInput

543
00:27:00,020 --> 0:27:02,656
尤其是范围和位置

544
00:27:03,957 --> 0:27:05,192
在常规的文本字段中

545
00:27:05,759 --> 0:27:08,762
每个字符都被分配了一个

546
00:27:09,997 --> 0:27:13,600
并且这些位置

547
00:27:13,667 --> 0:27:16,937
文档的开端和末端

548
00:27:17,204 --> 0:27:18,605
就是搜索字段的内容

549
00:27:21,008 --> 0:27:24,912
你可以用这些位置来创建

550
00:27:25,379 --> 0:27:29,283
比如 程序性地选择

551
00:27:32,052 --> 0:27:33,720
因为token是可选择的

552
00:27:34,188 --> 0:27:36,557
它们也会获得

553
00:27:39,092 --> 0:27:41,662
但搜索字段的文本长度…

554
00:27:42,629 --> 0:27:44,865
现在与从文档开端

555
00:27:45,399 --> 0:27:49,036
之间的距离不一样了

556
00:27:50,103 --> 0:27:51,205
如果这对你有影响

557
00:27:51,572 --> 0:27:54,975
比如说 程序性地选择文本的一部分

558
00:27:55,676 --> 0:28:00,013
UISearchTextField导出

559
00:27:55,676 --> 0:28:00,013
UISearchTextField导出

560
00:28:01,481 --> 0:28:02,916
textualRange的开端

561
00:28:03,283 --> 0:28:06,386
是字段中的

562
00:28:07,120 --> 0:28:08,989
并且它的末端是文档的末端

563
00:28:09,723 --> 0:28:13,060
这些与文本属性中的字符索引相匹配

564
00:28:15,095 --> 0:28:16,997
因此为了在你的app中

565
00:28:17,064 --> 0:28:18,098
利用全部这些新功能

566
00:28:18,599 --> 0:28:21,368
请了解一下

567
00:28:21,435 --> 0:28:22,836
UISearchController上

568
00:28:24,271 --> 0:28:25,739
使用UISearchTextField

569
00:28:26,106 --> 0:28:29,243
无论是在UISearchBar内

570
00:28:29,309 --> 0:28:30,577
或任何可以使用

571
00:28:31,378 --> 0:28:33,647
并对它进行自定义

572
00:28:33,714 --> 0:28:35,616
通过UITextField上

573
00:28:37,017 --> 0:28:40,387
采用UISearchToken

574
00:28:40,454 --> 0:28:41,955
既简明又可编辑

575
00:28:42,422 --> 0:28:44,958
它支持复制、粘贴和拖放

576
00:28:46,560 --> 0:28:48,629
通过这个你可以实现许多高级技巧

577
00:28:49,029 --> 0:28:51,298
我们很快会在本场演讲的网页上

578
00:28:51,565 --> 0:28:52,833
添加一个示例项目

579
00:28:53,166 --> 0:28:55,202
阐述如何有效地使用token

580
00:28:59,139 --> 0:29:01,942
现在我要把舞台交给James

581
00:28:59,139 --> 0:29:01,942
现在我要把舞台交给James

582
00:29:09,316 --> 0:29:10,284
谢谢Kyle

583
00:29:10,784 --> 0:29:11,685
大家好

584
00:29:11,752 --> 0:29:12,719
我是James McGaran

585
00:29:13,420 --> 0:29:16,857
我今天要在这里跟大家分享

586
00:29:17,224 --> 0:29:19,626
主要是选择、组织

587
00:29:19,693 --> 0:29:21,094
以及一些常见的编辑快捷方式

588
00:29:21,161 --> 0:29:22,196
（手势）

589
00:29:23,463 --> 0:29:25,232
那么这就是我今天要讲的全部内容

590
00:29:25,566 --> 0:29:27,000
你每天能听到的最棒的消息是

591
00:29:27,067 --> 0:29:29,269
又有许多行为是自动实现的了

592
00:29:29,336 --> 0:29:30,604
以及哪些东西可以免费使用

593
00:29:31,138 --> 0:29:33,040
但我在这里要讲一些不一样的内容

594
00:29:33,106 --> 0:29:34,174
以及你需要如何去做

595
00:29:34,474 --> 0:29:36,777
从而充分利用这些新功能

596
00:29:36,844 --> 0:29:37,945
在你的app内

597
00:29:38,812 --> 0:29:42,216
那么让我们从与自定义文本视图中的

598
00:29:42,282 --> 0:29:43,617
相关的新功能开始讲

599
00:29:45,652 --> 0:29:48,255
那么正如你所知道的

600
00:29:48,322 --> 0:29:51,058
可以使用手势在iOS上选择文本

601
00:29:51,658 --> 0:29:54,695
你可以轻触并按住

602
00:29:54,761 --> 0:29:56,096
这是iOS 13中的新功能

603
00:29:56,797 --> 0:29:58,765
你可以长按来获取选择循环

604
00:29:58,832 --> 0:30:00,300
并四处移动插入点

605
00:29:58,832 --> 0:30:00,300
并四处移动插入点

606
00:30:00,868 --> 0:30:02,836
并且你可以三次轻触某一段内容

607
00:30:02,903 --> 0:30:04,771
然后会立即选中整段内容

608
00:30:06,240 --> 0:30:09,243
因此这些手势在本地文本小工具中

609
00:30:09,543 --> 0:30:11,778
比如UITextView

610
00:30:12,112 --> 0:30:13,113
你已经拥有这些了

611
00:30:14,381 --> 0:30:16,617
但可能会有一些情况

612
00:30:16,917 --> 0:30:19,052
当你需要超出TextView

613
00:30:19,386 --> 0:30:20,754
和TextField的

614
00:30:21,255 --> 0:30:22,322
有些人需要在app中实施

615
00:30:22,456 --> 0:30:24,925
高度自定义的文本绘制

616
00:30:26,193 --> 0:30:27,394
那么这里以书为例

617
00:30:27,761 --> 0:30:29,863
它使用了完全自定义的文本视图

618
00:30:29,930 --> 0:30:32,766
来控制边缘、字符间距等

619
00:30:35,102 --> 0:30:37,804
因此 目前为了获得这样的选择行为

620
00:30:38,071 --> 0:30:39,473
在自定义文本视图中

621
00:30:39,940 --> 0:30:43,577
你必须向app中手动添加

622
00:30:43,844 --> 0:30:46,580
只是为了拥有

623
00:30:47,981 --> 0:30:50,884
许多人还不得不针对选择

624
00:30:51,251 --> 0:30:53,720
比如选择长方形 蓝色的选择长方形

625
00:30:53,787 --> 0:30:55,055
或选择控点

626
00:30:55,489 --> 0:30:56,790
只是为了提供这种行为

627
00:30:58,525 --> 0:31:00,561
因此我要很高兴地宣布

628
00:30:58,525 --> 0:31:00,561
因此我要很高兴地宣布

629
00:31:01,094 --> 0:31:04,831
通过UIInteraction的

630
00:31:04,898 --> 0:31:06,333
它叫做

631
00:31:07,768 --> 0:31:09,603
那么如果你不熟悉

632
00:31:09,937 --> 0:31:11,638
你可以把它看做是一种压缩方式

633
00:31:11,705 --> 0:31:14,074
一个行为和手势的集合

634
00:31:14,408 --> 0:31:15,943
与UIKit小工具相关

635
00:31:16,410 --> 0:31:18,545
想想拖放互动 跟那个类似

636
00:31:19,713 --> 0:31:21,281
它只是三行代码

637
00:31:21,882 --> 0:31:24,785
用于向app中

638
00:31:25,185 --> 0:31:26,920
你的用户们已经熟悉那些手势了

639
00:31:27,988 --> 0:31:29,590
我们提供的是一组手势

640
00:31:29,923 --> 0:31:32,860
针对可编辑和不可编辑的文本交互

641
00:31:34,161 --> 0:31:36,463
并且你可以使用

642
00:31:36,763 --> 0:31:40,434
获取更精细的控制 在选择UI之上

643
00:31:40,501 --> 0:31:43,537
比如我之前提到过的矩形和控点

644
00:31:46,173 --> 0:31:49,376
那么这是

645
00:31:49,710 --> 0:31:50,878
使用

646
00:31:51,612 --> 0:31:53,647
那么正如我所说过的

647
00:31:53,714 --> 0:31:54,615
不包含评论

648
00:31:55,749 --> 0:31:58,752
你使用UITextInteraction 4

649
00:31:58,819 --> 0:32:01,188
并告诉我们你是否想添加

650
00:31:58,819 --> 0:32:01,188
并告诉我们你是否想添加

651
00:32:01,255 --> 0:32:02,689
适用于可编辑或不可编辑的

652
00:32:04,024 --> 0:32:06,727
然后把文本输入属性分配给视图

653
00:32:06,793 --> 0:32:09,062
实施

654
00:32:09,663 --> 0:32:10,631
我们把这个独立出来

655
00:32:10,898 --> 0:32:13,133
万一你想

656
00:32:13,200 --> 0:32:14,034
比如滚动视图

657
00:32:14,401 --> 0:32:17,037
但你希望所有文本选择行为

658
00:32:17,404 --> 0:32:19,239
都能由某些内含视图进行处理

659
00:32:19,306 --> 0:32:21,008
比如绘制文本的那个视图

660
00:32:22,309 --> 0:32:24,244
最后只需要向视图中添加交互即可

661
00:32:24,578 --> 0:32:25,679
通过添加交互

662
00:32:27,748 --> 0:32:28,749
（表和集合中的多选手势）

663
00:32:29,183 --> 0:32:30,217
我们将 请跟我一起—

664
00:32:33,487 --> 0:32:35,189
请跟我一起来到舞台的这一侧

665
00:32:35,255 --> 0:32:38,058
我们谈一下TableViews

666
00:32:38,125 --> 0:32:39,927
和CollectionViews中的

667
00:32:42,996 --> 0:32:45,432
那么一直以来我们在

668
00:32:45,799 --> 0:32:47,768
和UITableView中

669
00:32:48,769 --> 0:32:51,238
类似Notes这样的app

670
00:32:51,305 --> 0:32:52,406
位于右上角

671
00:32:52,940 --> 0:32:55,742
用户可以轻触它进入多选模式

672
00:32:56,210 --> 0:32:59,646
然后分别选择每一个注释

673
00:32:59,713 --> 0:33:00,781
并把它们集合在一起

674
00:32:59,713 --> 0:33:00,781
并把它们集合在一起

675
00:33:01,615 --> 0:33:03,350
然后通过拖放

676
00:33:03,417 --> 0:33:05,352
或底部的那些操作按钮来组织它们

677
00:33:06,820 --> 0:33:08,455
嗯 在iOS 13中

678
00:33:08,522 --> 0:33:10,457
我们引入了一种全新的方式

679
00:33:10,757 --> 0:33:13,560
可以快速选择连续的一批项

680
00:33:13,627 --> 0:33:15,195
在集合视图和表视图中

681
00:33:15,996 --> 0:33:18,098
那么让我在这个巨型iPad上

682
00:33:19,032 --> 0:33:21,535
那么现在用户可以立即进入

683
00:33:21,935 --> 0:33:23,537
多选模式

684
00:33:23,604 --> 0:33:26,373
只需要把两根手指

685
00:33:26,440 --> 0:33:28,542
并平移即可

686
00:33:29,510 --> 0:33:30,777
立即开始选择

687
00:33:34,348 --> 0:33:35,382
谢谢 非常棒

688
00:33:36,316 --> 0:33:38,118
那么在这里你可以看到用两根手指

689
00:33:38,185 --> 0:33:39,887
在文件中的列表视图中向下滑动

690
00:33:39,953 --> 0:33:42,523
将立即进入编辑模式

691
00:33:43,957 --> 0:33:46,426
更酷的是这在

692
00:33:46,493 --> 0:33:48,195
流程布局中的网格项来说同样适用

693
00:33:48,629 --> 0:33:50,898
因此你的用户可以在网格项之间平移

694
00:33:50,964 --> 0:33:53,700
并同时选择一批项

695
00:33:54,501 --> 0:33:56,770
这对于拖放来说简直是梦想成真

696
00:33:59,840 --> 0:34:02,743
更不用说如果你的用户

697
00:33:59,840 --> 0:34:02,743
更不用说如果你的用户

698
00:34:03,110 --> 0:34:05,379
他们还能按住Shift

699
00:34:05,445 --> 0:34:06,647
以轻触其它项

700
00:34:06,713 --> 0:34:09,081
和在macOS上的性能一样

701
00:34:10,851 --> 0:34:11,685
谢谢

702
00:34:15,155 --> 0:34:18,091
特别是你的iPad app

703
00:34:18,358 --> 0:34:20,159
你的表视图就更如鱼得水了

704
00:34:22,629 --> 0:34:25,632
那么这些很棒的新行为

705
00:34:26,166 --> 0:34:28,735
原因就是因为你的app

706
00:34:28,802 --> 0:34:32,272
有一个不争的事实

707
00:34:33,072 --> 0:34:35,641
比如你可能希望修改选择或编辑按钮

708
00:34:35,708 --> 0:34:37,411
变成取消或完成

709
00:34:38,178 --> 0:34:39,513
你可能想显示操作按钮

710
00:34:39,580 --> 0:34:41,380
在屏幕底部

711
00:34:41,648 --> 0:34:43,183
通过你的用户所选择的内容

712
00:34:43,750 --> 0:34:47,087
或你可能要禁用某些UI

713
00:34:49,389 --> 0:34:51,925
因此为了解决这个问题

714
00:34:51,992 --> 0:34:53,760
帮助你适应这些新行为

715
00:34:54,561 --> 0:34:55,429
非常简单

716
00:34:55,495 --> 0:34:57,497
只需要实施两个委托方法

717
00:34:58,031 --> 0:35:00,834
并且在表视图和集合视图上

718
00:34:58,031 --> 0:35:00,834
并且在表视图和集合视图上

719
00:35:00,901 --> 0:35:01,869
拥有基本相同的版本

720
00:35:04,037 --> 0:35:05,005
就是这些

721
00:35:05,639 --> 0:35:06,740
第一个要实施的是

722
00:35:06,807 --> 0:35:10,110
是否在索引路径中开始多选交互

723
00:35:10,377 --> 0:35:11,278
或者你可以返回真

724
00:35:11,678 --> 0:35:13,480
如果你允许手势开始的话

725
00:35:14,181 --> 0:35:15,816
这里我们在这里提供了索引路径…

726
00:35:16,250 --> 0:35:18,218
如果你想阻止在表视图上

727
00:35:18,285 --> 0:35:19,987
不可选择的部分开始选择

728
00:35:20,053 --> 0:35:22,656
在那种情况下 你只需要返回假即可

729
00:35:24,858 --> 0:35:25,926
要实施的第二个方法是

730
00:35:25,993 --> 0:35:27,995
是否在索引路径上

731
00:35:28,061 --> 0:35:29,029
开始多选交互

732
00:35:29,363 --> 0:35:31,498
你可以调整周围的UI

733
00:35:31,565 --> 0:35:34,101
考虑到TableView

734
00:35:34,168 --> 0:35:36,436
会自动进入多选模式

735
00:35:36,737 --> 0:35:38,705
就像我们刚才在上一张幻灯片中

736
00:35:42,176 --> 0:35:44,244
那么继续 我想谈的最后一件事是

737
00:35:44,311 --> 0:35:46,747
简要谈谈我们针对某些使用新手势的

738
00:35:47,014 --> 0:35:49,750
常见的编辑任务所进行的一些改进

739
00:35:52,119 --> 0:35:55,322
那么在iOS 13中

740
00:35:55,389 --> 0:35:57,524
使执行某些编辑任务变得更简单

741
00:35:58,358 --> 0:36:00,494
比如使用三根手指

742
00:35:58,358 --> 0:36:00,494
比如使用三根手指

743
00:36:00,561 --> 0:36:02,729
用户可以滑动并返回到撤销

744
00:36:03,764 --> 0:36:05,332
然后反向滑动到恢复

745
00:36:08,235 --> 0:36:10,571
缩合三根手指可以复制…

746
00:36:11,905 --> 0:36:13,874
然后捏合三根手指可以粘贴

747
00:36:18,111 --> 0:36:21,215
那么我们向系统中引入了

748
00:36:21,281 --> 0:36:24,484
因此你就不需要担心

749
00:36:24,551 --> 0:36:25,886
对这些常见的编辑命令实施UI了

750
00:36:26,520 --> 0:36:28,322
它在整个系统中都是统一的

751
00:36:28,755 --> 0:36:32,025
因此你的用户可以在你的app中

752
00:36:32,092 --> 0:36:33,527
并且他们会立即熟悉起来

753
00:36:34,194 --> 0:36:35,762
这对于绘画app来说非常棒

754
00:36:35,829 --> 0:36:38,632
因为你不需要显示

755
00:36:38,699 --> 0:36:40,000
来实现这一行为

756
00:36:40,634 --> 0:36:42,736
最棒的是它完全免费

757
00:36:43,036 --> 0:36:46,206
如果你已经拥有撤销管理器

758
00:36:48,041 --> 0:36:51,044
那么在这里我呼吁大家在app中

759
00:36:51,411 --> 0:36:53,247
如果有机会的话

760
00:36:53,313 --> 0:36:54,848
要确保它们用起来很棒

761
00:36:56,083 --> 0:36:57,084
但以防万一

762
00:36:57,384 --> 0:36:58,752
我知道有些人很紧张

763
00:36:59,186 --> 0:37:02,556
因此为了防止它们与你app内

764
00:36:59,186 --> 0:37:02,556
因此为了防止它们与你app内

765
00:37:02,623 --> 0:37:03,924
可能存在的其它三指手势相冲突

766
00:37:04,491 --> 0:37:07,194
我们通过一些新API

767
00:37:07,928 --> 0:37:12,533
只是一个简单的属性 你需要覆盖

768
00:37:12,599 --> 0:37:14,501
它叫做

769
00:37:14,935 --> 0:37:16,170
你可以返回无

770
00:37:16,236 --> 0:37:18,005
如果你想添加这些手势的话

771
00:37:19,439 --> 0:37:21,942
那么这就是我今天要讲的要点

772
00:37:22,476 --> 0:37:25,779
最后要在你的自定义文本小工具中

773
00:37:26,313 --> 0:37:27,648
提供全系统的标准文本选择手势

774
00:37:28,081 --> 0:37:31,585
改变用户在你的app中

775
00:37:31,952 --> 0:37:33,587
使用多选手势

776
00:37:33,654 --> 0:37:34,922
我真的希望你们能采用它

777
00:37:36,356 --> 0:37:38,825
最后请允许你的用户

778
00:37:39,193 --> 0:37:40,594
并控制撤销堆栈

779
00:37:41,161 --> 0:37:42,563
通过一组标准手势

780
00:37:45,699 --> 0:37:46,667
是的 的确很痛苦

781
00:37:48,602 --> 0:37:50,537
谢谢大家 现在我要把舞台

782
00:37:50,604 --> 0:37:51,605
他会跟大家谈谈菜单

783
00:37:52,072 --> 0:37:58,178
（菜单）

784
00:37:58,245 --> 0:37:59,413
好的 谢谢James

785
00:38:01,114 --> 0:38:02,549
大家好 我是Mohammed

786
00:38:02,816 --> 0:38:05,986
我非常激动 我要跟大家谈谈

787
00:38:06,053 --> 0:38:07,988
我们在iOS 13中

788
00:38:08,455 --> 0:38:11,892
可以让你呈现流动性的交互菜单

789
00:38:11,959 --> 0:38:13,727
并带有丰富的预览

790
00:38:16,163 --> 0:38:19,666
第一个API是

791
00:38:21,935 --> 0:38:23,871
UIContextMenuInteraction

792
00:38:23,937 --> 0:38:25,372
是一个UIInteraction

793
00:38:25,806 --> 0:38:28,275
可以让你呈现带有丰富预览

794
00:38:28,675 --> 0:38:30,110
和复杂等级的菜单

795
00:38:31,078 --> 0:38:33,480
这些等级可以拥有嵌套的子菜单

796
00:38:33,780 --> 0:38:34,948
和内嵌节段

797
00:38:35,282 --> 0:38:36,617
我们稍后再解释

798
00:38:38,752 --> 0:38:41,755
由中心操作呈现的菜单高度自适应

799
00:38:42,389 --> 0:38:45,259
意思是它会根据它所呈现的情境

800
00:38:45,325 --> 0:38:46,360
选择呈现

801
00:38:47,227 --> 0:38:49,730
在这里我们看到

802
00:38:49,796 --> 0:38:51,798
预览和操作

803
00:38:51,865 --> 0:38:53,867
像是一个垂直地堆叠在另一个之上

804
00:38:56,203 --> 0:38:57,371
在横屏的iPhone上

805
00:38:57,437 --> 0:38:59,840
预览和操作是一个挨一个

806
00:38:59,907 --> 0:39:02,176
目的是为了更好地利用可用空间

807
00:38:59,907 --> 0:39:02,176
目的是为了更好地利用可用空间

808
00:39:04,912 --> 0:39:07,614
并且在iPad上

809
00:39:07,681 --> 0:39:11,518
根据可用空间

810
00:39:14,221 --> 0:39:16,490
由于这是一个跨平台API

811
00:39:16,557 --> 0:39:18,725
如果你的app在Mac上运行

812
00:39:19,326 --> 0:39:22,062
它会变成一种

813
00:39:25,966 --> 0:39:28,602
交互提供了一种一致的体验…

814
00:39:29,269 --> 0:39:34,041
通过呈现菜单

815
00:39:35,142 --> 0:39:37,544
因此用户会期待这个手势

816
00:39:38,078 --> 0:39:40,214
能在系统中的任何地方唤出菜单

817
00:39:41,982 --> 0:39:44,985
手势将适应设备的性能

818
00:39:45,586 --> 0:39:47,454
因此 在支持3D触摸的手机上

819
00:39:47,921 --> 0:39:50,224
我们将使用3D触摸迅速唤出菜单

820
00:39:50,557 --> 0:39:51,758
并提供一些很好的反馈

821
00:39:53,560 --> 0:39:55,429
在不支持3D触摸的手机上

822
00:39:55,495 --> 0:39:56,530
我们将使用触觉触摸

823
00:39:56,997 --> 0:39:59,433
我们将保留那种很棒的反馈

824
00:40:00,901 --> 0:40:03,370
在其它iOS设备上

825
00:40:04,304 --> 0:40:07,541
并且在Mac上

826
00:40:07,608 --> 0:40:09,910
因此 右击或命令点击…

827
00:40:10,244 --> 0:40:11,979
或两指轻触

828
00:40:16,016 --> 0:40:17,818
交互与其它系统行为自动整合

829
00:40:17,885 --> 0:40:20,654
比如拖放

830
00:40:21,555 --> 0:40:24,324
因此如果你已经在app中

831
00:40:24,825 --> 0:40:28,529
并且选择采用

832
00:40:29,596 --> 0:40:32,799
用户可以在任意点转换为拖拽

833
00:40:33,934 --> 0:40:37,905
因此在这里我们看到

834
00:40:38,505 --> 0:40:42,843
你就可以移动手指

835
00:40:44,745 --> 0:40:46,747
然而 如果你再等一会儿

836
00:40:46,813 --> 0:40:48,148
直到菜单呈现出来

837
00:40:48,749 --> 0:40:52,019
你仍然可以流畅地转换到拖拽模式

838
00:40:52,386 --> 0:40:54,488
而不需要把手指从屏幕上移开

839
00:40:55,622 --> 0:40:58,458
因此用户就会拥有这种

840
00:41:02,462 --> 0:41:04,965
今天要讲的API的第二部分

841
00:41:05,032 --> 0:41:07,167
是UIMenu和UIAction

842
00:41:08,869 --> 0:41:11,805
UIMenu和

843
00:41:12,206 --> 0:41:14,474
等级菜单构建系统

844
00:41:15,442 --> 0:41:19,079
允许我们定义并描述菜单等级

845
00:41:19,146 --> 0:41:20,480
就是我们想要显示的菜单

846
00:41:22,482 --> 0:41:24,151
UIMenus是可编辑的

847
00:41:24,218 --> 0:41:27,087
它们就像积木一样

848
00:41:27,154 --> 0:41:30,324
放到不同的配置中

849
00:41:33,527 --> 0:41:37,731
这里有个简单的例子

850
00:41:38,098 --> 0:41:39,633
通过创建UIMenu

851
00:41:40,167 --> 0:41:42,503
并把它传给

852
00:41:43,036 --> 0:41:45,038
一个分享操作和一个删除操作

853
00:41:47,007 --> 0:41:49,409
如果我想向菜单中添加更多功能

854
00:41:49,476 --> 0:41:50,811
通过比如说添加子菜单

855
00:41:51,445 --> 0:41:54,781
我所需要做的就是

856
00:41:55,516 --> 0:41:59,119
给它一些描述性标题

857
00:41:59,453 --> 0:42:02,489
并给它传递相应的子集

858
00:41:59,453 --> 0:42:02,489
并给它传递相应的子集

859
00:42:02,556 --> 0:42:05,726
那么在这里我已经选择

860
00:42:09,329 --> 0:42:11,865
因此当我们呈现它时

861
00:42:12,599 --> 0:42:15,602
顶部有一个分享操作

862
00:42:16,436 --> 0:42:19,940
中间有子菜单的编辑操作

863
00:42:20,507 --> 0:42:22,843
底部有删除操作

864
00:42:25,078 --> 0:42:26,280
当用户轻触编辑时

865
00:42:26,580 --> 0:42:27,781
会呈现我们的子菜单

866
00:42:27,848 --> 0:42:30,083
然后填充我们的复制和重复操作

867
00:42:33,587 --> 0:42:36,023
在你的app中采用交互

868
00:42:37,291 --> 0:42:40,360
如果你已经在app中

869
00:42:40,427 --> 0:42:43,063
比如UIDragInteraction

870
00:42:43,130 --> 0:42:44,865
或我们今年引入的某些

871
00:42:44,932 --> 0:42:46,834
你一定会非常熟悉这种模式

872
00:42:47,835 --> 0:42:48,869
我们需要做的第一件事

873
00:42:48,936 --> 0:42:53,373
就是创建UIContextMenuInteraction

874
00:42:53,907 --> 0:42:55,843
那么比如说 这是我们的视图控制器

875
00:42:57,177 --> 0:42:59,413
然后我们需要把它附加到某个视图上

876
00:42:59,479 --> 0:43:01,715
通过UIView的

877
00:42:59,479 --> 0:43:01,715
通过UIView的

878
00:43:04,418 --> 0:43:06,253
一旦这样做了 我们就需要遵守

879
00:43:06,320 --> 0:43:08,021
交互的委托协议

880
00:43:09,556 --> 0:43:11,692
协议有一个必需方法

881
00:43:11,992 --> 0:43:14,728
当交互即将开始时调用

882
00:43:15,896 --> 0:43:19,399
然后就交给app吧

883
00:43:19,466 --> 0:43:22,236
开始交互 要么返回空

884
00:43:22,636 --> 0:43:26,306
表明当前位置

885
00:43:30,577 --> 0:43:33,080
配置对象是

886
00:43:34,248 --> 0:43:36,517
它有一个标识符

887
00:43:36,950 --> 0:43:38,118
标识符是可选的

888
00:43:38,185 --> 0:43:40,954
你可以用于识别…

889
00:43:41,421 --> 0:43:43,824
交互 在它的整个周期中

890
00:43:44,758 --> 0:43:47,761
通过你可能获得的各种

891
00:43:49,663 --> 0:43:52,900
它还有previewProvider

892
00:43:53,767 --> 0:43:56,904
当即将呈现菜单时会调用它们

893
00:43:57,471 --> 0:44:00,407
这会降低我们要在实际创建菜单

894
00:43:57,471 --> 0:44:00,407
这会降低我们要在实际创建菜单

895
00:44:00,474 --> 0:44:02,809
所需要付出的潜在的昂贵的代价

896
00:44:03,076 --> 0:44:04,311
除非真的需要它们

897
00:44:06,647 --> 0:44:08,482
那么在我们刚才看过的示例中

898
00:44:08,549 --> 0:44:11,285
菜单没有那个巨大的丰富的预览

899
00:44:11,351 --> 0:44:12,753
它只有一些操作

900
00:44:13,287 --> 0:44:16,390
因此我们可以主要关注

901
00:44:16,456 --> 0:44:18,225
如何在委托方法的实施中

902
00:44:21,562 --> 0:44:23,330
那么当调用

903
00:44:24,331 --> 0:44:28,135
它有一个推荐操作列表

904
00:44:29,903 --> 0:44:33,373
可能既有UIMenus

905
00:44:33,440 --> 0:44:35,976
可能是一个构造完整的等级

906
00:44:36,343 --> 0:44:38,145
是从系统中选出来的

907
00:44:38,679 --> 0:44:41,448
这些可能是你在响应链中定义的东西

908
00:44:41,515 --> 0:44:45,385
使用iOS 13中

909
00:44:46,053 --> 0:44:48,755
或由其它系统组件所提供的东西

910
00:44:51,692 --> 0:44:53,193
那么我们在这里做了一个

911
00:44:53,260 --> 0:44:55,329
让我们把推荐操作放在旁边

912
00:44:56,797 --> 0:44:58,765
首先我们要创建我们的编辑菜单

913
00:44:59,032 --> 0:45:00,501
我们只需要创建一个UIMenu

914
00:44:59,032 --> 0:45:00,501
我们只需要创建一个UIMenu

915
00:45:01,068 --> 0:45:02,169
标题是Edit

916
00:45:02,603 --> 0:45:05,539
并且我们要给它传递

917
00:45:05,606 --> 0:45:07,808
一个标题是Copy的

918
00:45:08,075 --> 0:45:09,843
以及一个标题是Duplicate

919
00:45:13,247 --> 0:45:15,849
然后我们要定义我们的根菜单

920
00:45:16,884 --> 0:45:20,587
通常来说

921
00:45:20,854 --> 0:45:22,055
因此我们可以跳过

922
00:45:22,856 --> 0:45:24,825
然而如果你真心希望

923
00:45:24,892 --> 0:45:27,528
它将在操作列表上方作为页眉显示

924
00:45:29,730 --> 0:45:31,999
在这里我们把三个子集传给它

925
00:45:32,966 --> 0:45:34,401
我们刚刚创建的编辑按钮

926
00:45:34,801 --> 0:45:37,671
最后是一个

927
00:45:37,971 --> 0:45:41,942
从而让用户了解

928
00:45:44,478 --> 0:45:47,948
最后我们创建了一个

929
00:45:48,282 --> 0:45:49,683
并把我们的操作提供器传给它

930
00:45:51,084 --> 0:45:52,019
就是这样

931
00:45:52,085 --> 0:45:55,556
这就是要使用

932
00:45:55,622 --> 0:45:57,691
创建和显示菜单所要做的所有操作

933
00:46:00,794 --> 0:46:02,095
但还要再花点儿时间

934
00:46:03,564 --> 0:46:06,900
我们可以利用交互委托

935
00:46:07,367 --> 0:46:09,069
所提供的某些动画自定义API

936
00:46:09,536 --> 0:46:12,573
来创建一些非常棒、高度抛光的动画

937
00:46:12,973 --> 0:46:14,975
那真的能向我们的用户们

938
00:46:18,278 --> 0:46:19,446
那么在这个例子中

939
00:46:19,713 --> 0:46:21,648
我用了我们刚才用过的同一个菜单

940
00:46:22,149 --> 0:46:26,453
并且我用了源呈现自定义API

941
00:46:26,854 --> 0:46:29,990
从而在网格的图标中显示菜单

942
00:46:30,057 --> 0:46:32,726
而不是在整个网格中

943
00:46:33,360 --> 0:46:36,496
并且我甚至自定义了背景颜色

944
00:46:36,763 --> 0:46:39,266
甚至为预览做了一个很漂亮的圆形

945
00:46:41,635 --> 0:46:45,439
这些自定义API是

946
00:46:45,806 --> 0:46:49,409
这是在iOS 13中

947
00:46:50,077 --> 0:46:51,912
现在如果你已经采用了

948
00:46:51,979 --> 0:46:53,213
和UIDropInteraction

949
00:46:53,280 --> 0:46:56,416
并且你在app中创建了一些

950
00:46:56,884 --> 0:46:58,318
那么你很可能会觉得很熟悉这个

951
00:46:59,353 --> 0:47:01,922
我们实质上是把

952
00:46:59,353 --> 0:47:01,922
我们实质上是把

953
00:47:01,989 --> 0:47:04,992
使其成为一个更通用的API

954
00:47:05,058 --> 0:47:06,827
可以在其它交互中使用

955
00:47:08,295 --> 0:47:11,999
UITargetedDragPreview现在是

956
00:47:12,399 --> 0:47:15,969
因此如果你已经拥有了

957
00:47:16,303 --> 0:47:17,771
那对你的菜单来说就有意义

958
00:47:17,838 --> 0:47:20,040
因为会从同一个项中触发它们

959
00:47:20,541 --> 0:47:23,143
然后你可以重新使用那段代码

960
00:47:27,514 --> 0:47:30,083
为了让你在app中

961
00:47:30,150 --> 0:47:33,320
为了让你在某些最常见的情况中

962
00:47:33,754 --> 0:47:37,191
我们还针对UICollectionView

963
00:47:37,257 --> 0:47:38,392
引入了一些便利的API

964
00:47:39,459 --> 0:47:42,162
从app中唤出菜单

965
00:47:42,596 --> 0:47:46,834
从你的app所运行的全部平台上的

966
00:47:46,900 --> 0:47:49,603
你所需要做的全部工作就是

967
00:47:50,571 --> 0:47:52,973
在这里你会再一次返回一个配置

968
00:47:53,040 --> 0:47:54,208
如果你有要显示的菜单的话

969
00:47:54,708 --> 0:47:57,711
或返回空 表示没有要显示的东西

970
00:47:59,813 --> 0:48:01,949
那么除此之外 这些便利的API

971
00:47:59,813 --> 0:48:01,949
那么除此之外 这些便利的API

972
00:48:02,015 --> 0:48:04,284
给你提供了一些默认的抛光动画

973
00:48:04,718 --> 0:48:07,788
从表或集合视图网格中呈现菜单

974
00:48:07,855 --> 0:48:09,656
然后在遣散时再返回给它们

975
00:48:10,224 --> 0:48:12,759
但是我们还提供同样的自定义呈现

976
00:48:12,826 --> 0:48:13,927
和遣散钩子

977
00:48:13,994 --> 0:48:16,630
因此你可以创建你自己的自定义外观

978
00:48:17,231 --> 0:48:18,732
和遣散动画

979
00:48:21,401 --> 0:48:22,803
现在你很可能正在思考说

980
00:48:22,870 --> 0:48:25,706
这听起来有点儿像预览和跳转

981
00:48:26,640 --> 0:48:30,010
嗯…我们也注意到了

982
00:48:32,546 --> 0:48:36,383
然而 因为这个新API

983
00:48:36,450 --> 0:48:38,252
并且可以在多个平台上使用

984
00:48:39,086 --> 0:48:42,890
我们在iOS 13中忽略了

985
00:48:43,690 --> 0:48:46,460
因此请你们替换预览和跳转的实施

986
00:48:46,527 --> 0:48:48,328
通过UIContextMenuInteraction

987
00:48:48,962 --> 0:48:51,331
并为用户提供一种连续性体验…

988
00:48:52,432 --> 0:48:54,234
在所有设备上

989
00:48:57,137 --> 0:49:00,641
你可能还想考虑

990
00:48:57,137 --> 0:49:00,641
你可能还想考虑

991
00:49:00,707 --> 0:49:05,679
通过这个新交互

992
00:49:07,281 --> 0:49:10,517
并且如果你当前有菜单

993
00:49:10,584 --> 0:49:12,119
与拖拽同时显示

994
00:49:12,519 --> 0:49:14,688
这是一个很棒的流动性方案

995
00:49:15,055 --> 0:49:16,857
拥有协调一致的手势

996
00:49:16,924 --> 0:49:19,159
和完全整合的体验

997
00:49:19,526 --> 0:49:22,362
你的用户一定会期待

998
00:49:25,065 --> 0:49:28,402
好的 那么现在你已经了解了

999
00:49:28,468 --> 0:49:31,038
你应该动手把你的app准备好

1000
00:49:31,605 --> 0:49:33,140
确保它们为未来做好了准备

1001
00:49:33,207 --> 0:49:34,441
通过把它们变得有灵活性

1002
00:49:35,108 --> 0:49:38,445
利用新的栏外观和呈现API

1003
00:49:38,512 --> 0:49:41,381
给你的app一个抛光的现代化外观

1004
00:49:41,448 --> 0:49:42,816
用户们一定会非常期待

1005
00:49:43,851 --> 0:49:46,854
着手创建你们一直以来

1006
00:49:47,187 --> 0:49:49,056
使用很棒的新搜索API

1007
00:49:49,690 --> 0:49:51,825
并为你的app做一些很棒的功能

1008
00:49:52,192 --> 0:49:54,661
通过新手势和情境菜单

1009
00:49:56,897 --> 0:49:58,665
如果你对这些话题有任何疑问

1010
00:49:58,999 --> 0:50:01,468
或有任何与UIKit相关的疑问

1011
00:49:58,999 --> 0:50:01,468
或有任何与UIKit相关的疑问

1012
00:50:01,835 --> 0:50:03,437
请参加我们明天的讨论会

1013
00:50:03,804 --> 0:50:05,506
要获取关于演讲的附加信息

1014
00:50:05,839 --> 0:50:08,008
请查看演讲网页

1015
00:50:08,976 --> 0:50:11,278
谢谢大家的参与 祝大家在会议期间
