1
00:00:06,640 --> 0:00:09,743
（自定义工具建模

2
00:00:12,813 --> 0:00:13,680
谢谢

3
00:00:16,149 --> 0:00:18,252
大家下午好

4
00:00:18,318 --> 0:00:20,220
Apple的性能工具工程师

5
00:00:20,287 --> 0:00:24,291
演讲421的主题是自定义工具建模

6
00:00:24,925 --> 0:00:26,894
在自定义工具架构中

7
00:00:27,227 --> 0:00:30,030
负责建模的是中间这个 建模模块

8
00:00:30,097 --> 0:00:32,266
它是要推出

9
00:00:32,799 --> 0:00:35,035
操作系统记录的原始事件

10
00:00:35,102 --> 0:00:37,905
完成转换 创建可显示的事件

11
00:00:37,971 --> 0:00:42,543
或导入另一个建模模块

12
00:00:42,910 --> 0:00:46,046
这个架构的完整介绍收录在

13
00:00:46,113 --> 0:00:48,549
2018年“创建自定义工具”演讲

14
00:00:49,082 --> 0:00:50,450
本场演讲的内容

15
00:00:50,517 --> 0:00:52,719
重点关注的是

16
00:00:52,786 --> 0:00:54,488
中间的这个 建模模块

17
00:00:55,222 --> 0:00:57,224
建模模块对所有工具都很重要

18
00:00:57,291 --> 0:00:59,993
包括这里的

19
00:01:00,594 --> 0:01:04,164
在Time Profiler

20
00:01:04,230 --> 0:01:07,034
与内核记录的数据形式不一样

21
00:01:07,534 --> 0:01:09,636
我们用建模模块进行转换

22
00:01:10,137 --> 0:01:12,806
内核读取线程内容的样本时

23
00:01:12,873 --> 0:01:16,543
会创建或捕捉一个叫原始回溯的东西

24
00:01:17,010 --> 0:01:19,112
并添加到时间样本表格

25
00:01:19,613 --> 0:01:22,049
之后由Time Profiler

26
00:01:22,649 --> 0:01:25,919
再转换成可显示的回溯

27
00:01:25,986 --> 0:01:27,821
放入

28
00:01:28,422 --> 0:01:30,824
最终由Time Profiler

29
00:01:31,225 --> 0:01:32,693
这样做是为了

30
00:01:32,759 --> 0:01:36,830
更简单有效地捕捉原始回溯

31
00:01:36,997 --> 0:01:39,933
以便之后在模块的用户空间中修复

32
00:01:40,133 --> 0:01:42,970
从而有效地在内核留下记录

33
00:01:43,637 --> 0:01:46,874
内核做的另一种优化是

34
00:01:47,341 --> 0:01:52,346
如果内核对之前抽样过

35
00:01:52,546 --> 0:01:54,248
它不需要全部回溯

36
00:01:54,648 --> 0:01:58,085
只要在样本表格中

37
00:01:58,585 --> 0:02:00,821
然后

38
00:01:58,585 --> 0:02:00,821
然后

39
00:02:01,388 --> 0:02:03,423
提取最后一次回溯

40
00:02:03,924 --> 0:02:06,393
复制到

41
00:02:06,460 --> 0:02:07,895
然后由工具审阅

42
00:02:08,294 --> 0:02:09,562
它做了两件事

43
00:02:09,729 --> 0:02:12,566
它大量节省了内核的记录缓冲

44
00:02:12,633 --> 0:02:14,168
特别是当线程为闲置状态

45
00:02:14,768 --> 0:02:17,070
还能保持UI的效率

46
00:02:17,237 --> 0:02:19,940
因为UI不知道这个占位符转换

47
00:02:20,274 --> 0:02:23,177
因为是由建模模块转换的

48
00:02:23,844 --> 0:02:25,913
下面这些主题会不断重复出现

49
00:02:26,380 --> 0:02:29,716
基本上将自定义工具的复杂性

50
00:02:30,050 --> 0:02:31,919
吸收到建模层面

51
00:02:32,152 --> 0:02:34,788
这可以简化其他部分 特别是

52
00:02:35,155 --> 0:02:38,091
对内嵌在逻辑里的追踪代码

53
00:02:38,158 --> 0:02:40,027
和工具使用UI

54
00:02:40,994 --> 0:02:42,196
这就今天的内容

55
00:02:42,262 --> 0:02:43,997
我们会回顾建模基础

56
00:02:44,064 --> 0:02:47,234
然后了解创建自定义工具的流程

57
00:02:47,701 --> 0:02:49,803
在创建自定义模块时

58
00:02:50,604 --> 0:02:52,539
用Scratch很难操作

59
00:02:53,006 --> 0:02:56,944
因此今年的演讲中会展示样本代码

60
00:02:57,010 --> 0:02:58,512
你可以模仿样本

61
00:02:58,745 --> 0:03:00,581
或将其用作创建基础

62
00:02:58,745 --> 0:03:00,581
或将其用作创建基础

63
00:03:01,081 --> 0:03:02,683
现在我们要讲的是

64
00:03:02,850 --> 0:03:06,019
执行和Cliff规则引擎

65
00:03:06,320 --> 0:03:08,522
还有关键内容 推断

66
00:03:09,056 --> 0:03:12,226
首先来重温一些建模基础

67
00:03:13,994 --> 0:03:15,863
在创建模块时

68
00:03:16,096 --> 0:03:17,331
你需要定义

69
00:03:17,397 --> 0:03:19,600
其他架构部分

70
00:03:19,800 --> 0:03:21,702
比如定义schema

71
00:03:21,768 --> 0:03:24,004
整合查看器的所有内容

72
00:03:24,404 --> 0:03:28,108
并最后审阅查看器的输出

73
00:03:28,609 --> 0:03:31,612
所有这些都建在工具分布包中

74
00:03:31,678 --> 0:03:34,915
可以在工具内安装并测试

75
00:03:35,482 --> 0:03:36,984
这里我们假设

76
00:03:37,050 --> 0:03:39,853
Xcode中已经有一个项目

77
00:03:39,920 --> 0:03:42,623
你要做的是添加自定义模块

78
00:03:42,856 --> 0:03:44,791
或使用样本代码

79
00:03:44,992 --> 0:03:46,560
今年的演讲中有展示

80
00:03:46,927 --> 0:03:49,062
获得设置好的项目

81
00:03:50,197 --> 0:03:52,699
何时需要创建自定义模块呢

82
00:03:53,433 --> 0:03:56,170
Xcode的确可以生成模块

83
00:03:56,236 --> 0:04:00,040
特别是OS Signpost

84
00:03:56,236 --> 0:04:00,040
特别是OS Signpost

85
00:04:00,607 --> 0:04:02,409
但这些建模模块只是让你

86
00:04:02,476 --> 0:04:03,944
快速运行工具

87
00:04:04,011 --> 0:04:07,314
而不是开放所有功能

88
00:04:07,381 --> 0:04:08,749
让你自定义建块

89
00:04:09,416 --> 0:04:12,319
比如融合多个输入表的数据

90
00:04:12,386 --> 0:04:14,288
自定义模块可以做到

91
00:04:14,354 --> 0:04:15,822
已生成的案例就不行

92
00:04:16,790 --> 0:04:18,759
更重要的是维护工作记忆

93
00:04:18,825 --> 0:04:22,029
让模块记录运行总计

94
00:04:22,095 --> 0:04:23,397
追踪开区间

95
00:04:23,730 --> 0:04:25,732
运行更多计算

96
00:04:25,799 --> 0:04:27,968
使用模块的工作记忆

97
00:04:29,536 --> 0:04:31,538
另外能做的是创建自定义图表

98
00:04:31,605 --> 0:04:32,906
如果想要创建图表

99
00:04:32,973 --> 0:04:34,341
但工具不能在本地完成

100
00:04:34,675 --> 0:04:37,177
你可以在建模模块中合成

101
00:04:37,244 --> 0:04:40,681
比如 你可以计算移动平均值

102
00:04:40,747 --> 0:04:42,649
或更复杂的卡尔曼滤波

103
00:04:42,716 --> 0:04:43,817
这都取决于你

104
00:04:43,884 --> 0:04:46,353
所有这些都能在自定义建模中完成

105
00:04:46,920 --> 0:04:49,990
最终目标是建立更为智能的工具

106
00:04:50,691 --> 0:04:53,560
让工具知道代码在做什么

107
00:04:53,794 --> 0:04:56,029
甚至能够达到

108
00:04:56,330 --> 0:04:59,132
让使用代码的人会先查找工具

109
00:04:59,199 --> 0:05:00,901
然后再找你解决问题

110
00:04:59,199 --> 0:05:00,901
然后再找你解决问题

111
00:05:01,235 --> 0:05:03,971
这就解放了你 让你能投入下个项目

112
00:05:05,506 --> 0:05:07,407
模块基本等于规则引擎

113
00:05:07,608 --> 0:05:11,778
捆绑一套输入表和一套输出表

114
00:05:12,546 --> 0:05:16,683
工具的分析内核

115
00:05:16,750 --> 0:05:19,186
然后注入模块的工作记忆

116
00:05:19,586 --> 0:05:21,688
工作记忆中的对象叫做事实

117
00:05:21,922 --> 0:05:23,156
用来推断

118
00:05:23,223 --> 0:05:25,125
工作记忆和事实的变化

119
00:05:25,559 --> 0:05:28,529
是CLIPS语言的规则系统

120
00:05:28,595 --> 0:05:29,963
CLIPS是开源语言

121
00:05:30,030 --> 0:05:32,466
八十年代出现 并有很多优秀的案例

122
00:05:32,766 --> 0:05:34,401
和文献供你参考

123
00:05:34,635 --> 0:05:36,503
我们的样本代码里也有很多例子

124
00:05:36,570 --> 0:05:38,005
还有幻灯片中

125
00:05:39,173 --> 0:05:40,807
当建模模块发现

126
00:05:40,874 --> 0:05:42,476
它想输出的东西

127
00:05:42,543 --> 0:05:45,979
模块的函数可以编写绑定的输出表

128
00:05:46,947 --> 0:05:48,815
要从Scratch编写模块

129
00:05:48,882 --> 0:05:51,151
可以分三步 首先是

130
00:05:51,518 --> 0:05:52,753
决定模块内容

131
00:05:53,120 --> 0:05:55,122
意思是了解技术

132
00:05:55,189 --> 0:05:56,590
创建自定义工具

133
00:05:57,124 --> 0:05:58,258
也就是说

134
00:05:58,325 --> 0:06:00,594
了解自定义工具的结构

135
00:05:58,325 --> 0:06:00,594
了解自定义工具的结构

136
00:06:00,661 --> 0:06:02,129
和如何发挥最多用处

137
00:06:02,896 --> 0:06:05,766
2019年“开发优秀的剖析体验”

138
00:06:05,832 --> 0:06:07,601
我们团队会带你了解

139
00:06:08,001 --> 0:06:10,704
代码的变化如何讲故事

140
00:06:10,771 --> 0:06:11,738
通过自定义工具

141
00:06:11,805 --> 0:06:15,142
它可以作为了解建模内容的起点

142
00:06:16,343 --> 0:06:19,913
给建模模块定义了输出后

143
00:06:20,247 --> 0:06:21,648
需要一些输入

144
00:06:22,049 --> 0:06:24,618
从代码输入工具的最好方法是

145
00:06:24,685 --> 0:06:26,420
通过

146
00:06:26,920 --> 0:06:29,122
这个API可以穿插在代码中

147
00:06:29,189 --> 0:06:30,757
追踪代码变化

148
00:06:30,824 --> 0:06:32,593
传递实参数据

149
00:06:32,659 --> 0:06:35,896
让模块在输入流中完成推断

150
00:06:36,496 --> 0:06:38,599
有了输入和输出之后

151
00:06:38,665 --> 0:06:40,667
要开始定义规则系统

152
00:06:40,734 --> 0:06:41,768
并编写规则

153
00:06:42,169 --> 0:06:44,371
第二步和第三步都是迭代的

154
00:06:44,438 --> 0:06:46,540
因此在写规则时

155
00:06:46,607 --> 0:06:49,343
可能需要回溯

156
00:06:49,409 --> 0:06:51,545
或修改Signpost

157
00:06:51,612 --> 0:06:52,446
可以这样做

158
00:06:52,779 --> 0:06:55,916
但要记住

159
00:06:55,983 --> 0:06:58,385
隔离代码和工具的内容

160
00:06:58,452 --> 0:07:00,554
所以 你要保证

161
00:06:58,452 --> 0:07:00,554
所以 你要保证

162
00:07:00,988 --> 0:07:03,423
给Signpost调用添加评论

163
00:07:03,490 --> 0:07:05,692
让人们知道这实际是个合约

164
00:07:05,759 --> 0:07:08,462
如果修改就会破坏工具

165
00:07:09,463 --> 0:07:12,099
要了解这个过程 可能最好是要

166
00:07:12,165 --> 0:07:13,233
通过实际例子

167
00:07:13,300 --> 0:07:16,637
所以我要请上我们的建模专家

168
00:07:16,937 --> 0:07:19,006
Alejandro Lucena

169
00:07:24,211 --> 0:07:26,446
大家下午好 感谢Chad

170
00:07:27,681 --> 0:07:29,316
我要做的就是

171
00:07:29,383 --> 0:07:31,218
演示Chad说的思维过程

172
00:07:31,418 --> 0:07:34,588
并用一个例子演示

173
00:07:35,389 --> 0:07:38,258
首先 从这个演示app开始

174
00:07:38,458 --> 0:07:42,029
坦白说 这可能是我做过的最酷的事

175
00:07:42,496 --> 0:07:44,231
它是列出了各种山羊

176
00:07:44,831 --> 0:07:48,969
这些山羊不仅是显示在app中

177
00:07:49,036 --> 0:07:50,637
app还能让我排序

178
00:07:51,138 --> 0:07:53,006
排序的实现是通过

179
00:07:53,073 --> 0:07:54,441
“移动主体模式”

180
00:07:54,975 --> 0:07:58,412
它有很多并列的不同模式可供使用

181
00:07:58,478 --> 0:08:01,014
比如future和promise

182
00:07:58,478 --> 0:08:01,014
比如future和promise

183
00:08:01,448 --> 0:08:03,483
所以如果“移动主体”这个词

184
00:08:03,550 --> 0:08:04,484
你听到我们说

185
00:08:04,718 --> 0:08:08,322
你可以想象成你使用的任何模式

186
00:08:08,689 --> 0:08:11,491
但本场还是称之为“移动主体”

187
00:08:12,559 --> 0:08:13,794
如字面意思

188
00:08:13,861 --> 0:08:16,463
移动主体模式传递的重要概念

189
00:08:16,530 --> 0:08:17,664
就是移动主体

190
00:08:18,198 --> 0:08:21,435
可视化为左上角的圆圈

191
00:08:22,202 --> 0:08:25,372
这个主体是要完成任务 比如排序

192
00:08:25,439 --> 0:08:27,741
并分成几个子任务

193
00:08:27,975 --> 0:08:29,743
比如获取初始表

194
00:08:29,810 --> 0:08:31,578
排序 然后确认结果

195
00:08:32,145 --> 0:08:35,616
每个子任务会在“站点”执行

196
00:08:36,183 --> 0:08:37,784
站点告诉主体

197
00:08:37,851 --> 0:08:40,419
依赖关系或执行上下文

198
00:08:40,486 --> 0:08:41,688
帮它完成子目标

199
00:08:43,023 --> 0:08:45,792
下面看看如何执行任务 比如排序

200
00:08:45,859 --> 0:08:47,294
通过移动主体模式

201
00:08:47,895 --> 0:08:51,031
我们要做的是点击左上角的“排序”

202
00:08:51,732 --> 0:08:54,401
主体会移动到第一个站点

203
00:08:54,568 --> 0:08:56,503
这里的站点由UI控制

204
00:08:57,037 --> 0:09:00,107
它会执行第一个子任务 获取列表

205
00:08:57,037 --> 0:09:00,107
它会执行第一个子任务 获取列表

206
00:09:00,908 --> 0:09:02,309
获取列表后

207
00:09:02,509 --> 0:09:06,513
它可以移动到另一个站点

208
00:09:07,281 --> 0:09:10,417
在分发队列站点 它可以运行排序

209
00:09:11,585 --> 0:09:13,086
排序完成后

210
00:09:13,487 --> 0:09:14,721
它会回到UI

211
00:09:15,489 --> 0:09:18,091
最后将列表按序整理排列

212
00:09:19,226 --> 0:09:21,895
最后停泊到“排序”键 供以后使用

213
00:09:23,230 --> 0:09:25,766
刚才演示的就是移动主体模式

214
00:09:25,832 --> 0:09:28,268
主体可以是两个初始阶段中的一个

215
00:09:28,569 --> 0:09:32,105
可以在一个站点执行

216
00:09:32,539 --> 0:09:34,007
这就是建模有趣的地方

217
00:09:34,074 --> 0:09:36,610
具体来说 有趣的是看到它们

218
00:09:36,677 --> 0:09:38,645
交互的时间

219
00:09:39,446 --> 0:09:40,547
为了更好的可视化

220
00:09:40,614 --> 0:09:42,182
我再演示一遍这个排序的例子

221
00:09:42,249 --> 0:09:44,251
带上区间

222
00:09:44,318 --> 0:09:45,185
我要做的是

223
00:09:45,252 --> 0:09:47,387
将设备移动到左边

224
00:09:47,888 --> 0:09:49,189
因为需要一些空间

225
00:09:50,090 --> 0:09:53,760
然后点击“排序”按钮

226
00:09:54,494 --> 0:09:57,064
移动发生时 看到一个区间

227
00:09:57,130 --> 0:09:59,867
带描述性字符串

228
00:10:01,001 --> 0:10:02,102
然后在站点

229
00:10:02,169 --> 0:10:04,371
主体会执行第一个子任务

230
00:10:04,438 --> 0:10:05,973
获取列表

231
00:10:07,040 --> 0:10:08,809
这里有个不同的区间

232
00:10:10,410 --> 0:10:13,013
然后主体会移动到分发队列

233
00:10:13,714 --> 0:10:15,516
由它自己的区间显示

234
00:10:17,618 --> 0:10:20,087
在分发队列 主体会执行排序

235
00:10:21,221 --> 0:10:23,190
如所见 它在执行排序模式

236
00:10:24,691 --> 0:10:26,860
然后回到UI站点

237
00:10:26,927 --> 0:10:29,763
这是最后一个移动区间 移回UI

238
00:10:30,931 --> 0:10:34,067
这个站点上

239
00:10:34,134 --> 0:10:36,436
更新排序的子任务

240
00:10:37,738 --> 0:10:40,107
有了这些区间

241
00:10:40,174 --> 0:10:41,975
就是活动的起始时间

242
00:10:42,042 --> 0:10:43,377
无论是执行还是移动

243
00:10:43,744 --> 0:10:46,313
区间的结束就是活动的终止时间

244
00:10:47,047 --> 0:10:48,282
记住这些区间

245
00:10:48,348 --> 0:10:51,585
就可以拥有或设计想要的工具

246
00:10:51,785 --> 0:10:53,587
就是屏幕上展示的这样

247
00:10:54,421 --> 0:10:55,422
最上面的轨道

248
00:10:55,489 --> 0:10:57,124
显示了所有的区间

249
00:10:57,191 --> 0:10:59,259
可以看到不同的移动和执行

250
00:10:59,793 --> 0:11:01,562
它的下面

251
00:10:59,793 --> 0:11:01,562
它的下面

252
00:11:01,628 --> 0:11:03,764
是轨道上不同的活动站点

253
00:11:04,998 --> 0:11:07,234
除了工具的直观样式

254
00:11:07,301 --> 0:11:08,802
还要看看细节视图

255
00:11:09,169 --> 0:11:10,871
细节视图提供更多信息

256
00:11:10,938 --> 0:11:12,372
关于每个站点的活动

257
00:11:12,439 --> 0:11:15,309
比如起始时间 时长

258
00:11:15,642 --> 0:11:17,244
主体是什么 等等

259
00:11:18,378 --> 0:11:21,849
这里要注意最上面这一列

260
00:11:22,249 --> 0:11:25,419
它定义了建模的关键兴趣点

261
00:11:25,953 --> 0:11:27,287
这几列告诉了我们

262
00:11:27,354 --> 0:11:29,289
起始时间 时长和主体类型

263
00:11:29,590 --> 0:11:31,625
通常这几列中的定义

264
00:11:31,692 --> 0:11:34,027
在工具的XML文件包中

265
00:11:34,528 --> 0:11:37,030
它们共同组成输出表

266
00:11:37,598 --> 0:11:39,199
这也是我们的第一个检查点

267
00:11:39,600 --> 0:11:40,834
通过这些列

268
00:11:40,901 --> 0:11:43,337
定义要存储的数据

269
00:11:43,670 --> 0:11:45,172
这就完成了第一个目标

270
00:11:45,239 --> 0:11:47,007
决定模块的内容

271
00:11:47,841 --> 0:11:48,742
这就好了

272
00:11:49,576 --> 0:11:52,980
下一步就是获取数据

273
00:11:53,380 --> 0:11:55,249
通过OS Signpost实现

274
00:11:56,683 --> 0:11:58,118
再回到之前的区间

275
00:11:58,652 --> 0:11:59,486
就是它们

276
00:12:00,087 --> 0:12:03,056
我们有个API

277
00:12:03,123 --> 0:12:04,992
是本地为区间而创建的

278
00:12:05,759 --> 0:12:07,494
但我们想更进一步

279
00:12:07,728 --> 0:12:10,864
使用Event Signpost

280
00:12:11,331 --> 0:12:13,400
每个event Signpost

281
00:12:13,467 --> 0:12:15,469
活动区间之间的界限上

282
00:12:15,836 --> 0:12:17,871
这样做不仅是为了

283
00:12:17,938 --> 0:12:21,642
节省大约50%的Signpost

284
00:12:21,975 --> 0:12:23,944
更是为了更准确的显示

285
00:12:24,011 --> 0:12:25,145
移动主体模式

286
00:12:25,812 --> 0:12:28,348
就是主体结束当前活动后

287
00:12:28,415 --> 0:12:29,783
会立即开始另一个

288
00:12:29,850 --> 0:12:32,152
所以只能发射一个Signpost

289
00:12:32,319 --> 0:12:33,520
主体开始下一个活动了

290
00:12:35,422 --> 0:12:36,623
为实现它

291
00:12:36,857 --> 0:12:40,260
需要executeStop函数

292
00:12:40,694 --> 0:12:42,996
在运行内部逻辑

293
00:12:43,063 --> 0:12:45,232
执行该站点活动之前

294
00:12:45,666 --> 0:12:47,401
要有一个Signpost

295
00:12:47,668 --> 0:12:50,838
具体的Signpost ID

296
00:12:52,306 --> 0:12:53,140
除此之外

297
00:12:53,674 --> 0:12:57,578
visitNextStop函数中

298
00:12:57,644 --> 0:13:00,814
执行主体在站点间移动的逻辑

299
00:12:57,644 --> 0:13:00,814
执行主体在站点间移动的逻辑

300
00:13:01,315 --> 0:13:03,016
同样 执行移动之前

301
00:13:03,317 --> 0:13:05,586
命名

302
00:13:05,652 --> 0:13:08,021
再给一个Signpost ID

303
00:13:11,825 --> 0:13:14,294
现在注意看中间的模块

304
00:13:14,361 --> 0:13:16,430
它会转换Signpost

305
00:13:16,496 --> 0:13:17,698
把刚输入app的

306
00:13:18,065 --> 0:13:20,567
变成可用的区间 写入输出表

307
00:13:22,035 --> 0:13:23,170
举个例子

308
00:13:23,237 --> 0:13:24,238
这个模块

309
00:13:24,304 --> 0:13:26,640
一开始 工作记忆是空的

310
00:13:26,707 --> 0:13:29,276
因为它不知道app的状态

311
00:13:30,244 --> 0:13:31,778
但我们知道

312
00:13:32,145 --> 0:13:35,315
模块与OS Signpost表

313
00:13:35,649 --> 0:13:37,918
OS Signpost表

314
00:13:38,785 --> 0:13:41,488
假设模块想要侦测

315
00:13:41,688 --> 0:13:43,490
Signpost上的移动主体

316
00:13:44,591 --> 0:13:46,827
点击演示app上的排序按钮后

317
00:13:47,094 --> 0:13:49,263
模块会接收一个

318
00:13:49,563 --> 0:13:51,999
然后将它表述为一个事实

319
00:13:52,266 --> 0:13:53,901
这个事实带有信息栏

320
00:13:53,967 --> 0:13:56,069
根据调用

321
00:13:57,271 --> 0:13:59,106
现在 建模模块看到

322
00:13:59,173 --> 0:14:01,241
OS Signpost事实

323
00:13:59,173 --> 0:14:01,241
OS Signpost事实

324
00:14:01,308 --> 0:14:02,809
移动主体的各种信息

325
00:14:03,310 --> 0:14:07,080
模块就能通过

326
00:14:07,247 --> 0:14:09,983
通过确定事实 注入工作记忆

327
00:14:10,284 --> 0:14:12,920
确定知道有一个排序主体

328
00:14:12,986 --> 0:14:14,054
移动到后台

329
00:14:16,223 --> 0:14:19,193
然后 模块要决定主体的活动

330
00:14:19,259 --> 0:14:22,729
比如实际在做什么 以及时间

331
00:14:23,363 --> 0:14:25,799
然后模块会查看已知事实 然后说

332
00:14:25,866 --> 0:14:28,101
我知道主体正在移动

333
00:14:28,468 --> 0:14:31,538
而Signpost事实的

334
00:14:32,005 --> 0:14:33,607
建模模块会记住它

335
00:14:33,674 --> 0:14:35,943
在工作记忆中再输入一个事实

336
00:14:36,443 --> 0:14:38,445
表明起始时间为42

337
00:14:39,980 --> 0:14:42,216
这时Signpost事实消失了

338
00:14:43,183 --> 0:14:45,686
没问题 因为我们把所有相关信息

339
00:14:45,752 --> 0:14:48,021
确定的事实 都存入了工作记忆

340
00:14:49,156 --> 0:14:51,658
我把它们往上挪一点 留些空间

341
00:14:52,759 --> 0:14:54,494
最后建模模块要做的

342
00:14:54,795 --> 0:14:57,264
是决定活动的完整区间

343
00:14:57,564 --> 0:15:00,434
现在只有起始时间 没有完整区间

344
00:14:57,564 --> 0:15:00,434
现在只有起始时间 没有完整区间

345
00:15:01,134 --> 0:15:02,469
但我们知道某个点上

346
00:15:02,870 --> 0:15:05,072
演示app会发出

347
00:15:05,305 --> 0:15:06,640
同样的 建模模块接收后

348
00:15:06,840 --> 0:15:08,475
会表述为相应事实

349
00:15:09,309 --> 0:15:10,878
因为Signpost经过架构

350
00:15:10,944 --> 0:15:13,313
会在区间间隙发出

351
00:15:13,780 --> 0:15:16,850
模块知道何时接收

352
00:15:16,917 --> 0:15:20,087
它可以查看任何之前打开的区间事实

353
00:15:20,587 --> 0:15:21,421
并关闭

354
00:15:22,155 --> 0:15:25,359
这里 它会查看事实的值

355
00:15:25,592 --> 0:15:28,729
用足够的值决定完整区间

356
00:15:29,129 --> 0:15:31,031
为此 它要调出输出表

357
00:15:32,432 --> 0:15:34,668
删除已有的开区间事实

358
00:15:35,335 --> 0:15:36,837
用完整区间替代

359
00:15:36,904 --> 0:15:38,071
这里是移动到后台

360
00:15:38,872 --> 0:15:40,874
并使用这个区间填写输出表

361
00:15:43,210 --> 0:15:44,077
好了

362
00:15:44,645 --> 0:15:47,614
在研究实际的CLIPS代码之前

363
00:15:47,681 --> 0:15:51,752
还是要了解app代码

364
00:15:51,818 --> 0:15:53,620
能翻译成CLIPS事实

365
00:15:54,688 --> 0:15:58,659
特别是当调用特殊名称的

366
00:15:58,725 --> 0:16:02,696
这个名称会成为

367
00:15:58,725 --> 0:16:02,696
这个名称会成为

368
00:16:04,698 --> 0:16:07,668
另外 这个事件里的

369
00:16:07,734 --> 0:16:10,704
会成为OS Signpost

370
00:16:12,105 --> 0:16:14,174
最后 Signpost ID

371
00:16:14,575 --> 0:16:17,744
会成为OS Signpost

372
00:16:18,445 --> 0:16:20,080
还有消息 内嵌的消息

373
00:16:20,147 --> 0:16:23,650
也是OS Signpost

374
00:16:26,787 --> 0:16:27,721
现在我们知道

375
00:16:27,788 --> 0:16:30,057
可以通过查找规则来侦测移动主体

376
00:16:30,123 --> 0:16:31,525
这是一个CLIPS规则

377
00:16:31,758 --> 0:16:32,926
首先要做的是

378
00:16:32,993 --> 0:16:35,062
侦测OS Signpost

379
00:16:35,996 --> 0:16:38,532
通过名称

380
00:16:39,900 --> 0:16:41,935
我们要捕捉这个值

381
00:16:42,002 --> 0:16:45,138
位于标识符栏

382
00:16:47,007 --> 0:16:49,376
另外 我们可以对消息进行解析

383
00:16:49,443 --> 0:16:51,411
提取有用信息 如图

384
00:16:54,014 --> 0:16:54,948
第二部分

385
00:16:55,015 --> 0:16:56,884
我们要表述一个条件

386
00:16:57,050 --> 0:17:00,921
就是要匹配缺失的移动主体

387
00:16:57,050 --> 0:17:00,921
就是要匹配缺失的移动主体

388
00:17:00,988 --> 0:17:02,923
Signpost标识过的

389
00:17:03,223 --> 0:17:05,826
我们会用Signpost

390
00:17:05,893 --> 0:17:07,661
但是不想增加任何重复

391
00:17:07,994 --> 0:17:10,263
因此关键词not就是告诉模块

392
00:17:10,430 --> 0:17:12,598
前提是没有移动主体

393
00:17:12,665 --> 0:17:14,835
在这个instance变量中

394
00:17:16,069 --> 0:17:17,003
如果是这样

395
00:17:17,069 --> 0:17:19,839
模块可以确认这个移动主体

396
00:17:22,776 --> 0:17:25,679
同样的 在侦测移动主体活动时

397
00:17:26,280 --> 0:17:27,981
会再次匹配

398
00:17:28,048 --> 0:17:30,117
因为需要确定某些属性

399
00:17:30,984 --> 0:17:31,852
但这里

400
00:17:32,252 --> 0:17:34,021
省略了关键词not

401
00:17:34,087 --> 0:17:36,623
因为要将这个主体事实显示到

402
00:17:36,690 --> 0:17:37,824
工作记忆中

403
00:17:37,891 --> 0:17:39,893
现在已经解析了主体

404
00:17:40,160 --> 0:17:41,295
并可以用它做更多事情

405
00:17:42,462 --> 0:17:45,465
具体来说 一旦有了这两个事实

406
00:17:45,966 --> 0:17:48,368
就能确定或添加移动事实

407
00:17:48,669 --> 0:17:51,271
让建模模块可以追踪主体的实际活动

408
00:17:53,674 --> 0:17:56,577
以上是CLIPS代码的例子

409
00:17:56,777 --> 0:17:59,746
用来侦测主体和主体的活动

410
00:17:59,947 --> 0:18:02,716
但我们还需要更多底层执行的知识

411
00:17:59,947 --> 0:18:02,716
但我们还需要更多底层执行的知识

412
00:18:03,217 --> 0:18:05,485
以便更好地架构建模模块

413
00:18:06,119 --> 0:18:08,488
我要请Chad回到舞台

414
00:18:08,555 --> 0:18:09,790
讲解规则执行

415
00:18:14,161 --> 0:18:16,530
好的 下面来讲规则执行

416
00:18:16,597 --> 0:18:19,032
CLIPS语言下的规则引擎

417
00:18:20,667 --> 0:18:22,269
当我们在CLIPS中定义规则时

418
00:18:22,336 --> 0:18:24,771
分为左边(LHS)

419
00:18:24,838 --> 0:18:26,974
用=&gt;隔开

420
00:18:27,374 --> 0:18:30,511
左边是描述性语言

421
00:18:30,577 --> 0:18:32,145
定义了一个模式

422
00:18:32,212 --> 0:18:35,549
让规则引擎在工作记忆中查找事实

423
00:18:36,283 --> 0:18:38,919
当规则引擎找到了事实

424
00:18:38,986 --> 0:18:41,488
满足左边的模式

425
00:18:41,788 --> 0:18:43,156
会创建一个 激活

426
00:18:43,557 --> 0:18:46,960
每次激活会触发规则的右边

427
00:18:47,561 --> 0:18:48,729
规则的右边

428
00:18:48,795 --> 0:18:50,330
是命令式语言

429
00:18:50,397 --> 0:18:52,733
让你控制函数 比如“取消”

430
00:18:52,799 --> 0:18:55,035
就是从工作记忆中删除事实

431
00:18:55,636 --> 0:18:59,106
或“确认” 就是

432
00:18:59,706 --> 0:19:01,341
还有特殊函数

433
00:18:59,706 --> 0:19:01,341
还有特殊函数

434
00:19:01,408 --> 0:19:04,411
让你写入模块的输出表

435
00:19:04,811 --> 0:19:06,013
就能编写输出了

436
00:19:07,614 --> 0:19:08,982
先讲讲事实

437
00:19:09,383 --> 0:19:11,451
在工作记忆中确认事实

438
00:19:11,718 --> 0:19:13,053
要用assert函数

439
00:19:13,520 --> 0:19:16,857
每个新事实分配一个事实地址

440
00:19:16,924 --> 0:19:20,093
标识为f-加一些数字

441
00:19:20,894 --> 0:19:24,531
如果要在工作记忆中修改事实

442
00:19:24,698 --> 0:19:26,700
我们还要有modify函数

443
00:19:27,367 --> 0:19:29,870
它将修改的事实地址和栏

444
00:19:29,937 --> 0:19:31,238
替换进工作记忆

445
00:19:31,905 --> 0:19:34,575
这实际上结合了

446
00:19:34,641 --> 0:19:36,243
一个撤回和一个确认

447
00:19:36,310 --> 0:19:39,513
也就是先从工作记忆中撤回一个事实

448
00:19:39,780 --> 0:19:42,783
修改后重新在工作记忆中确认

449
00:19:42,850 --> 0:19:44,818
更新后的字段或栏

450
00:19:45,552 --> 0:19:47,421
这很重要 因为

451
00:19:47,487 --> 0:19:49,389
工作记忆中重新确认内容

452
00:19:49,456 --> 0:19:52,259
会再次触发或激活某些规则

453
00:19:52,526 --> 0:19:54,494
大部分情况下是好的

454
00:19:54,561 --> 0:19:56,797
因为这就是规则系统反应

455
00:19:56,864 --> 0:19:59,666
工作记忆事实变化的过程

456
00:20:00,400 --> 0:20:03,237
但是在某些情况下会有麻烦

457
00:20:03,303 --> 0:20:05,339
我说的是逻辑回路

458
00:20:05,873 --> 0:20:07,608
我们可能一不小心

459
00:20:07,674 --> 0:20:09,543
在代码中包括了逻辑回路

460
00:20:10,277 --> 0:20:11,812
所以这里有个小规则

461
00:20:11,879 --> 0:20:15,449
是为了给移动主体计数

462
00:20:15,782 --> 0:20:18,051
工作记忆中的移动主体

463
00:20:18,652 --> 0:20:21,889
它首先是带计数器的事实

464
00:20:22,489 --> 0:20:25,559
每个进入工作记忆的移动主体

465
00:20:25,626 --> 0:20:27,394
会触发规则的右边

466
00:20:27,895 --> 0:20:32,666
只要修改计数器的数字栏 +1

467
00:20:32,833 --> 0:20:34,234
这就很直白了

468
00:20:34,801 --> 0:20:37,471
来看看实际执行的样子

469
00:20:38,138 --> 0:20:39,072
首先

470
00:20:39,139 --> 0:20:40,674
工作记忆中的计数器

471
00:20:40,741 --> 0:20:42,276
初始值为0

472
00:20:43,810 --> 0:20:45,646
之后的某个时点

473
00:20:45,712 --> 0:20:47,848
一个移动主体在工作记忆中确认

474
00:20:47,915 --> 0:20:50,984
现在左边足以触发右边

475
00:20:51,818 --> 0:20:54,021
调用modify函数

476
00:20:54,087 --> 0:20:57,257
它先是撤回这个事实

477
00:20:57,891 --> 0:21:00,627
增加计数的值

478
00:20:57,891 --> 0:21:00,627
增加计数的值

479
00:21:01,094 --> 0:21:03,397
然后回到工作记忆中重新确认

480
00:21:03,697 --> 0:21:04,698
这样做时

481
00:21:04,898 --> 0:21:06,967
注意它重新触发了同一个规则

482
00:21:07,467 --> 0:21:09,436
现在对同一个移动主体实体

483
00:21:09,503 --> 0:21:12,206
它会计数2 3 4 5 6 7

484
00:21:12,272 --> 0:21:13,774
一直数下去

485
00:21:14,208 --> 0:21:15,676
直到追踪停止

486
00:21:15,742 --> 0:21:17,811
工具会警告有严重错误

487
00:21:18,178 --> 0:21:20,113
规则引擎卡住了

488
00:21:20,747 --> 0:21:23,650
模块界面的工具查看器中

489
00:21:24,084 --> 0:21:25,552
你看到的追踪

490
00:21:25,619 --> 0:21:27,654
显示了所有事件和激活

491
00:21:27,721 --> 0:21:29,656
在回路中发生的

492
00:21:29,723 --> 0:21:32,793
这就给你一个好的开始

493
00:21:33,594 --> 0:21:35,329
在我来看 最简单的方法

494
00:21:35,395 --> 0:21:36,663
消除逻辑回路

495
00:21:36,730 --> 0:21:38,398
就是目的引导式编程

496
00:21:38,966 --> 0:21:40,901
不是直接修改计数器事实

497
00:21:40,968 --> 0:21:45,506
而是创建目标事件 帮我们计数

498
00:21:46,240 --> 0:21:48,575
现在要侦测移动主体时

499
00:21:48,775 --> 0:21:51,245
就要确认目标事实 来对实体计数

500
00:21:51,945 --> 0:21:53,247
计数规则中

501
00:21:53,614 --> 0:21:56,350
要捕捉计数器和目标

502
00:21:56,783 --> 0:21:59,553
然后撤回目标 因为已经满足

503
00:21:59,920 --> 0:22:00,954
计数器计数的规则

504
00:21:59,920 --> 0:22:00,954
计数器计数的规则

505
00:22:01,021 --> 0:22:02,990
这样规则就会不断回来

506
00:22:03,056 --> 0:22:04,992
从而打破逻辑回路

507
00:22:06,660 --> 0:22:09,663
现在来看规则的触发顺序

508
00:22:09,730 --> 0:22:12,165
及其对模块结果的影响

509
00:22:13,367 --> 0:22:15,068
现在回到

510
00:22:15,135 --> 0:22:17,371
它先被调用 然后移动主体才会

511
00:22:17,437 --> 0:22:18,906
进入执行阶段

512
00:22:19,740 --> 0:22:21,909
现在你看到

513
00:22:21,975 --> 0:22:24,444
第一版代码的第一个实参

514
00:22:24,611 --> 0:22:27,281
实际上是主体的类型字符串

515
00:22:27,781 --> 0:22:29,183
这里就是排序主体

516
00:22:29,249 --> 0:22:32,853
或者是记入追踪缓冲的

517
00:22:33,187 --> 0:22:34,655
我想还可以改善

518
00:22:35,155 --> 0:22:38,659
将它从字符串变成类型代码

519
00:22:39,059 --> 0:22:41,228
就是一个四字节整数

520
00:22:41,295 --> 0:22:43,463
每个事件可节省10个字节

521
00:22:43,764 --> 0:22:46,066
如果数据成千上百的进来

522
00:22:46,466 --> 0:22:49,436
就可以节省几万字节的追踪缓冲

523
00:22:50,370 --> 0:22:51,238
为实现它

524
00:22:51,305 --> 0:22:53,540
就要在模块里创建映射

525
00:22:53,707 --> 0:22:55,976
将代码转化为字符串

526
00:22:56,043 --> 0:22:57,711
通过使用事实

527
00:22:58,512 --> 0:23:01,448
在侦测规则中

528
00:22:58,512 --> 0:23:01,448
在侦测规则中

529
00:23:01,615 --> 0:23:04,284
捕捉主体的类型代码

530
00:23:04,918 --> 0:23:06,687
在确认移动主体时

531
00:23:06,753 --> 0:23:09,857
类型那一栏标记为sentinel

532
00:23:09,923 --> 0:23:11,859
表示还没有完整的字符串

533
00:23:12,693 --> 0:23:14,161
因为在第二个规则

534
00:23:14,228 --> 0:23:16,430
我们要找到所有移动主体

535
00:23:16,597 --> 0:23:17,965
类型为sentinel的

536
00:23:18,799 --> 0:23:22,469
然后找到对应的类型代码

537
00:23:22,636 --> 0:23:25,405
就是上一张图里的类型字符串映射

538
00:23:26,106 --> 0:23:27,674
找到它们后

539
00:23:27,741 --> 0:23:29,643
修改类型栏

540
00:23:29,877 --> 0:23:32,813
从sentinel

541
00:23:33,614 --> 0:23:37,985
这一切都基于第二个查找规则

542
00:23:38,051 --> 0:23:40,320
在运行确认后立即触发

543
00:23:41,121 --> 0:23:42,823
但如果系统中有其他规则

544
00:23:42,890 --> 0:23:44,658
比如主体停靠规则

545
00:23:44,725 --> 0:23:46,493
也是引用移动主体

546
00:23:47,194 --> 0:23:49,162
捕捉和使用类型栏的

547
00:23:49,229 --> 0:23:52,900
如果它出现在确认

548
00:23:52,966 --> 0:23:54,401
这会有一个sentinel

549
00:23:54,835 --> 0:23:56,703
鉴于这是对规则系统的修改

550
00:23:56,770 --> 0:23:57,704
你要准备好

551
00:23:57,771 --> 0:23:59,072
面对很多新的缺陷

552
00:23:59,673 --> 0:24:01,008
为了解决问题

553
00:23:59,673 --> 0:24:01,008
为了解决问题

554
00:24:01,074 --> 0:24:05,045
要添加规则限制 就是

555
00:24:05,412 --> 0:24:07,614
只要类型不是sentinel

556
00:24:07,681 --> 0:24:09,550
这有效的延迟了规则触发

557
00:24:09,616 --> 0:24:13,453
直到查找规则实际改变了主体的类型

558
00:24:14,121 --> 0:24:15,822
从sentinel变为实际内容

559
00:24:16,557 --> 0:24:17,558
这完全可行

560
00:24:17,624 --> 0:24:19,226
但要用于所有规则

561
00:24:19,293 --> 0:24:20,961
否则就会有维护问题

562
00:24:21,028 --> 0:24:25,532
特别是当现有的规则集

563
00:24:26,466 --> 0:24:28,802
再来看另一种方法

564
00:24:29,036 --> 0:24:31,471
我们实际是让查找规则

565
00:24:31,538 --> 0:24:33,807
在确认后立即触发

566
00:24:34,007 --> 0:24:35,375
其中一种方法是

567
00:24:35,976 --> 0:24:39,980
告诉CLIPS那个规则更重要

568
00:24:40,047 --> 0:24:43,817
或比默认的0突出值更突出

569
00:24:44,518 --> 0:24:48,488
只要这个规则是系统中最突出的

570
00:24:48,789 --> 0:24:50,691
那么第一个规则结束时

571
00:24:50,757 --> 0:24:52,459
第二个就会被触发

572
00:24:52,793 --> 0:24:54,461
如果在其他位置使用突出性

573
00:24:54,528 --> 0:24:56,230
就要过一遍代码 确保

574
00:24:56,630 --> 0:24:58,966
100仍是最高突出值

575
00:24:59,032 --> 0:25:00,634
但这是后话了

576
00:24:59,032 --> 0:25:00,634
但这是后话了

577
00:25:01,034 --> 0:25:03,537
这里还有一个更直接的方法

578
00:25:03,604 --> 0:25:05,806
控制规则的排序和触发

579
00:25:06,206 --> 0:25:09,476
这就要了解激活

580
00:25:10,444 --> 0:25:12,846
提示一下 激活实际上是

581
00:25:12,913 --> 0:25:14,948
工作记忆中的事实集合

582
00:25:15,015 --> 0:25:16,917
满足规则的左边

583
00:25:17,217 --> 0:25:19,486
每次激活都会触发规则的右边

584
00:25:20,354 --> 0:25:23,257
现在不要直接触发规则的左边

585
00:25:23,557 --> 0:25:24,691
而是要将

586
00:25:24,892 --> 0:25:27,628
激活记入数据结构

587
00:25:27,995 --> 0:25:30,497
叫做agenda

588
00:25:32,032 --> 0:25:35,602
agenda实际是激活列表

589
00:25:35,669 --> 0:25:37,471
是工作记忆更新的结果

590
00:25:37,638 --> 0:25:39,006
因此所有规则引擎都要

591
00:25:39,072 --> 0:25:41,008
从上而下过一遍这个列表

592
00:25:41,074 --> 0:25:43,343
以特定的模式触发规则

593
00:25:44,244 --> 0:25:46,813
这里先触发第一个规则

594
00:25:47,047 --> 0:25:48,515
这个数据结构是动态的

595
00:25:48,582 --> 0:25:51,718
如果规则99是要撤回事实17

596
00:25:52,419 --> 0:25:55,822
而事实17由其他两个激活引用

597
00:25:55,889 --> 0:26:00,127
CLIPS会先撤回激活

598
00:25:55,889 --> 0:26:00,127
CLIPS会先撤回激活

599
00:26:00,194 --> 0:26:02,729
此时agenda会是这样

600
00:26:02,796 --> 0:26:04,498
在执行继续时

601
00:26:05,966 --> 0:26:09,837
agenda根据突出性排序

602
00:26:09,903 --> 0:26:11,738
突出值越高 agenda上的

603
00:26:12,472 --> 0:26:13,941
但更重要的是

604
00:26:14,007 --> 0:26:17,010
模块中没有单独的agenda

605
00:26:17,077 --> 0:26:19,379
定义中一个模块只有一个

606
00:26:19,713 --> 0:26:21,648
在分析内核中可以用它

607
00:26:21,715 --> 0:26:24,017
定义部分标准模块

608
00:26:24,651 --> 0:26:26,553
第一个是建模模块

609
00:26:26,620 --> 0:26:29,790
这里要放入纯推理逻辑

610
00:26:29,857 --> 0:26:32,125
和推理规则

611
00:26:32,192 --> 0:26:34,928
将规则名设为modeler::

612
00:26:35,896 --> 0:26:39,433
第二个模块是recorder

613
00:26:39,499 --> 0:26:41,502
放入的是输出规则

614
00:26:41,568 --> 0:26:43,704
前缀为recorder::

615
00:26:44,304 --> 0:26:45,506
这么做的原因是

616
00:26:46,006 --> 0:26:48,275
在执行这些规则时

617
00:26:48,642 --> 0:26:51,879
首先执行所有模块

618
00:26:52,212 --> 0:26:53,380
直到清空

619
00:26:53,447 --> 0:26:55,582
然后再到recorder模块

620
00:26:56,016 --> 0:26:58,418
它会让你拥有自信

621
00:26:58,719 --> 0:27:00,354
在写输出规则时

622
00:26:58,719 --> 0:27:00,354
在写输出规则时

623
00:27:00,521 --> 0:27:02,122
不用查看工作记忆中

624
00:27:02,189 --> 0:27:04,825
modeler模块推出的过程

625
00:27:05,759 --> 0:27:07,127
现在你可以利用这个

626
00:27:07,194 --> 0:27:09,763
自定义CLIPS模块

627
00:27:09,830 --> 0:27:11,698
现在看看如何实现

628
00:27:11,965 --> 0:27:16,103
更好的调整查找规则的执行

629
00:27:16,904 --> 0:27:20,207
首先是定义查找规则模块

630
00:27:21,008 --> 0:27:23,210
将查找规则放到

631
00:27:23,277 --> 0:27:26,079
模块里 命名为lookup::

632
00:27:27,247 --> 0:27:30,284
确认移动主体事实后

633
00:27:30,684 --> 0:27:35,155
要立刻告诉CLIPS

634
00:27:35,355 --> 0:27:38,058
就是运行查找agenda里的

635
00:27:38,525 --> 0:27:41,395
然后返回

636
00:27:41,628 --> 0:27:43,397
执行下一套建模规则

637
00:27:43,463 --> 0:27:45,232
这是防止规则插入

638
00:27:45,299 --> 0:27:48,202
执行顺序的好方法

639
00:27:49,069 --> 0:27:50,771
以上内容已经很充足

640
00:27:51,071 --> 0:27:55,075
现在可以看看调试和剖析了

641
00:27:55,142 --> 0:27:58,045
现在有请Alejandro

642
00:27:58,345 --> 0:27:59,246
讲解这一部分

643
00:28:05,085 --> 0:28:06,053
谢谢Chad

644
00:28:06,653 --> 0:28:09,556
我要讲的是调试和剖析基元

645
00:28:09,623 --> 0:28:11,792
用于搭建这些模块

646
00:28:12,492 --> 0:28:13,727
首先是日志

647
00:28:14,294 --> 0:28:16,730
我们可用的日志基元

648
00:28:16,897 --> 0:28:20,100
很像printf

649
00:28:20,400 --> 0:28:24,671
格式化标记和代表这些类别的变量

650
00:28:25,506 --> 0:28:28,175
与printf或其常用方法

651
00:28:28,642 --> 0:28:29,776
在工具查看器

652
00:28:29,843 --> 0:28:31,578
实际上可以动态的

653
00:28:31,645 --> 0:28:33,180
开关日志声明

654
00:28:33,247 --> 0:28:34,715
之后会举例说明

655
00:28:35,716 --> 0:28:38,418
怎么把这些日志声明放入规则？

656
00:28:39,319 --> 0:28:41,522
CLIPS里有个函数

657
00:28:41,922 --> 0:28:43,657
它的运行 如我之前所讲

658
00:28:43,724 --> 0:28:46,226
很像printf 定义字符串

659
00:28:46,293 --> 0:28:48,028
比如Resolved Agent Kind Code

660
00:28:48,462 --> 0:28:50,864
然后用%定义格式类别

661
00:28:51,164 --> 0:28:52,366
实际的工程类别

662
00:28:52,533 --> 0:28:56,403
这里是UN 64

663
00:28:56,770 --> 0:28:59,206
然后是表示数据类别的变量

664
00:29:01,909 --> 0:29:04,878
同样也可以使用不同的基元类别

665
00:29:04,945 --> 0:29:06,914
就是剖析 通过工具查看器

666
00:29:07,514 --> 0:29:10,551
剖析基元提供的是规则激活计数

667
00:29:10,617 --> 0:29:12,853
让我们知道规则触发的次数

668
00:29:13,420 --> 0:29:14,988
以及时间分布

669
00:29:15,055 --> 0:29:17,357
我们能知道用了多少秒

670
00:29:17,424 --> 0:29:20,127
去激活规则 按百分比计算

671
00:29:20,794 --> 0:29:22,196
为了整体理解

672
00:29:22,462 --> 0:29:23,730
我要做一个演示

673
00:29:23,797 --> 0:29:25,532
看看它们怎样放到一起

674
00:29:29,636 --> 0:29:32,472
这里是样本代码 也是可以下载的

675
00:29:32,739 --> 0:29:33,674
样本代码中

676
00:29:33,740 --> 0:29:35,409
有很多可用的不同目标

677
00:29:35,909 --> 0:29:37,377
我首先要讲的

678
00:29:37,444 --> 0:29:40,347
是这里的绘制模板建模对象

679
00:29:41,381 --> 0:29:44,451
它会在创建和运行工具的时候打开

680
00:29:47,020 --> 0:29:48,188
好像已经搭建成功了

681
00:29:50,891 --> 0:29:52,693
然后打开工具

682
00:29:54,027 --> 0:29:58,031
这里那个羊的app已经打开

683
00:29:58,365 --> 0:29:59,499
我不会最大化窗口

684
00:29:59,566 --> 0:30:02,102
因为我们要记在脑子里

685
00:29:59,566 --> 0:30:02,102
因为我们要记在脑子里

686
00:30:02,836 --> 0:30:04,838
我要做的是回到空白模板

687
00:30:05,639 --> 0:30:06,974
在右上角

688
00:30:07,040 --> 0:30:08,742
选择要添加的工具

689
00:30:08,809 --> 0:30:11,245
为此 打开这里

690
00:30:11,778 --> 0:30:15,582
查找移动主体 就是刚建的目标

691
00:30:17,184 --> 0:30:18,685
这里 如我所说

692
00:30:18,752 --> 0:30:21,255
日志叙述可动态开关

693
00:30:21,321 --> 0:30:22,589
通过工具查看器

694
00:30:22,656 --> 0:30:23,857
按下command I

695
00:30:24,191 --> 0:30:25,792
打开工具查看器

696
00:30:26,059 --> 0:30:28,629
这有个日志标签 默认为无

697
00:30:28,829 --> 0:30:30,397
但可以改成narrative

698
00:30:30,464 --> 0:30:32,266
这样就开启了日志叙述声明

699
00:30:33,133 --> 0:30:34,268
关闭它 继续

700
00:30:34,434 --> 0:30:36,036
代替所有进程

701
00:30:36,103 --> 0:30:37,804
现在切换到山羊的列表app

702
00:30:39,606 --> 0:30:40,641
现在开始记录

703
00:30:40,974 --> 0:30:42,809
在这个列表里可以进行一些操作

704
00:30:42,876 --> 0:30:44,811
比如给不同的列表排序

705
00:30:45,312 --> 0:30:47,414
你看到查看器里弹出一些活动

706
00:30:48,515 --> 0:30:50,884
再点一次 会有更多活动弹出

707
00:30:51,385 --> 0:30:53,220
我想这个点已经足够清楚了

708
00:30:54,655 --> 0:30:56,023
首先我们看这里

709
00:30:56,790 --> 0:30:59,293
显示不同的区间 我们之前讲过

710
00:30:59,359 --> 0:31:02,329
比如激活和移动等等

711
00:30:59,359 --> 0:31:02,329
比如激活和移动等等

712
00:31:03,063 --> 0:31:04,698
但在实际的叙述声明

713
00:31:04,765 --> 0:31:07,167
还是command I打开查看器

714
00:31:08,001 --> 0:31:10,737
有新的东西 这个模块日志表

715
00:31:11,004 --> 0:31:12,406
在这个表里

716
00:31:12,472 --> 0:31:14,308
存着所有日志叙述声明

717
00:31:14,675 --> 0:31:16,977
比如这个解析代理类型代码

718
00:31:17,044 --> 0:31:19,179
使用日志叙述的例子里看到过

719
00:31:19,646 --> 0:31:21,682
还有规则里的许多其他声明

720
00:31:23,550 --> 0:31:26,320
那如何从日志叙述切换到剖析呢

721
00:31:26,653 --> 0:31:28,956
还是在这个日志标签

722
00:31:29,022 --> 0:31:30,858
切换到profile 1

723
00:31:31,725 --> 0:31:33,260
关闭查看器

724
00:31:33,694 --> 0:31:35,128
再次运行工具

725
00:31:35,295 --> 0:31:36,363
再次记录轨迹

726
00:31:37,030 --> 0:31:39,233
这时看到列表已经排序过了

727
00:31:39,299 --> 0:31:41,969
但移动主体还是发生了一些活动

728
00:31:42,903 --> 0:31:44,905
这也足够说明问题了

729
00:31:45,873 --> 0:31:49,009
所以停止 再次打开查看器

730
00:31:49,943 --> 0:31:53,380
这里就不再有模块日志表

731
00:31:54,014 --> 0:31:56,450
但是如果打开这里的模块标签

732
00:31:57,017 --> 0:31:59,353
会看到整洁的描述性界面

733
00:31:59,419 --> 0:32:01,255
列出不同的剖析值

734
00:31:59,419 --> 0:32:01,255
列出不同的剖析值

735
00:32:01,555 --> 0:32:04,758
比如这个“查看未知执行站点”规则

736
00:32:05,092 --> 0:32:09,029
有7条记录

737
00:32:09,596 --> 0:32:12,232
还有其他建模过程中定义的规则

738
00:32:13,867 --> 0:32:15,035
在关闭这个界面之前

739
00:32:15,302 --> 0:32:17,404
我发现一些有趣的点

740
00:32:17,471 --> 0:32:18,705
我要再运行一次追踪

741
00:32:18,772 --> 0:32:21,108
因为我想再捕捉一次

742
00:32:22,109 --> 0:32:24,611
开启排序后 我看到不同的活动出现

743
00:32:25,245 --> 0:32:26,580
但如果我再次排序

744
00:32:26,647 --> 0:32:28,582
我注意到这些黄色的长区间

745
00:32:28,649 --> 0:32:29,716
出现在事实后面

746
00:32:29,783 --> 0:32:34,721
它们对实时描述或实时解读的跟踪

747
00:32:34,788 --> 0:32:36,023
我的预判

748
00:32:36,823 --> 0:32:38,525
为了找到原因

749
00:32:38,592 --> 0:32:41,562
搞清楚状况 并找到解决办法

750
00:32:41,828 --> 0:32:43,964
我要请回Chad 讲解推断

751
00:32:51,772 --> 0:32:53,106
谢谢Alejandro

752
00:32:54,208 --> 0:32:57,611
为了描述Alejandro

753
00:32:57,678 --> 0:32:58,579
并解决它

754
00:32:58,645 --> 0:33:00,814
就要引入一个概念 叫做推断

755
00:32:58,645 --> 0:33:00,814
就要引入一个概念 叫做推断

756
00:33:01,849 --> 0:33:03,383
这些区间怎么了？

757
00:33:03,650 --> 0:33:05,953
它们的特点 第一是长区间

758
00:33:06,019 --> 0:33:09,056
它们出现的时间

759
00:33:09,122 --> 0:33:10,524
这显而易见

760
00:33:11,124 --> 0:33:13,794
第二 真正的问题是

761
00:33:13,861 --> 0:33:15,796
对这些区间的记录

762
00:33:15,863 --> 0:33:17,764
只在模块的工作记忆中

763
00:33:17,998 --> 0:33:21,001
UI只看模块的输出表

764
00:33:21,068 --> 0:33:22,436
不会看这些

765
00:33:22,936 --> 0:33:26,807
所以不能把这些区间写入输出表

766
00:33:26,874 --> 0:33:28,108
它们关闭的时间

767
00:33:28,175 --> 0:33:30,878
这个例子就是这样

768
00:33:31,578 --> 0:33:33,113
现在要做的是

769
00:33:33,180 --> 0:33:35,782
写入临时或占位符行

770
00:33:35,849 --> 0:33:37,784
给模块的输出表

771
00:33:37,985 --> 0:33:40,721
为此就要介绍推断模式

772
00:33:41,922 --> 0:33:44,391
模块中的推断模式表示

773
00:33:44,458 --> 0:33:47,661
如果这是最后写入输入表的机会

774
00:33:48,028 --> 0:33:49,463
你要写什么？

775
00:33:49,897 --> 0:33:51,164
来看个例子

776
00:33:51,732 --> 0:33:55,102
假设模块处理了

777
00:33:55,169 --> 0:33:57,137
我们叫做视界

778
00:33:57,638 --> 0:34:01,308
视界是一个时间点

779
00:33:57,638 --> 0:34:01,308
视界是一个时间点

780
00:34:01,475 --> 0:34:04,144
原因可能是追踪停止了

781
00:34:04,478 --> 0:34:06,113
或者分析内核

782
00:34:06,180 --> 0:34:08,882
还没填入追踪部分

783
00:34:09,349 --> 0:34:11,552
没人知道线的另一边有什么

784
00:34:11,985 --> 0:34:14,288
如你所见 我们创建的区间写着

785
00:34:14,353 --> 0:34:15,489
移动到后台

786
00:34:15,688 --> 0:34:17,123
这样做是因为它夹在

787
00:34:17,190 --> 0:34:19,760
一对移动和执行

788
00:34:20,260 --> 0:34:23,797
但我们不知道

789
00:34:23,864 --> 0:34:26,132
因为它的结束事件在视界的另一边

790
00:34:26,699 --> 0:34:29,503
因此我们要进入推断模式

791
00:34:29,670 --> 0:34:32,706
只要在表中写入临时占位符事件

792
00:34:33,005 --> 0:34:34,842
UI就能看到些什么

793
00:34:35,475 --> 0:34:39,545
然运行区间从执行Signpost

794
00:34:39,780 --> 0:34:42,081
直到视界的当前值

795
00:34:43,283 --> 0:34:45,518
推断模式里的模块

796
00:34:45,585 --> 0:34:47,154
因为推断事实

797
00:34:47,221 --> 0:34:50,389
会被注入到工作记忆

798
00:34:51,123 --> 0:34:52,559
在记录规则中

799
00:34:52,626 --> 0:34:55,728
可以将推断事实

800
00:34:55,795 --> 0:34:59,466
把这些开区间写入表

801
00:34:59,533 --> 0:35:01,401
用捕捉到的视界时间戳

802
00:34:59,533 --> 0:35:01,401
用捕捉到的视界时间戳

803
00:35:02,503 --> 0:35:04,905
这里就是写入开区间的机会

804
00:35:05,873 --> 0:35:08,442
下面来看一个示例规则

805
00:35:08,976 --> 0:35:11,144
首先 将推断式的

806
00:35:11,512 --> 0:35:13,480
输出编写规则放入记录模块

807
00:35:13,547 --> 0:35:15,516
前缀为RECORDER::

808
00:35:16,750 --> 0:35:19,052
然后匹配推断事件

809
00:35:19,119 --> 0:35:21,121
捕捉视界的值

810
00:35:21,188 --> 0:35:24,625
这就有了区间的结束时间 理论上

811
00:35:25,459 --> 0:35:28,762
对工作记忆中的每个区间事实

812
00:35:28,829 --> 0:35:30,898
触发规则的右边

813
00:35:31,398 --> 0:35:32,633
我们这里要做的

814
00:35:32,699 --> 0:35:36,203
是基于结束时间

815
00:35:36,270 --> 0:35:38,605
和区间开始的时间

816
00:35:39,273 --> 0:35:42,376
然后写新的行 填写栏内容

817
00:35:42,442 --> 0:35:44,244
和正常的输出编写规则一样

818
00:35:44,311 --> 0:35:45,379
唯一区分

819
00:35:45,445 --> 0:35:48,415
正常的和推断式的输出编写规则

820
00:35:48,916 --> 0:35:53,020
在于当你测试或预测推断事实的规则

821
00:35:53,453 --> 0:35:56,657
你要查看开区间 而不是闭区间

822
00:35:56,723 --> 0:35:59,359
像往常编写输出表那样

823
00:36:00,661 --> 0:36:03,030
如果是即时模式

824
00:36:03,263 --> 0:36:06,300
在记录前进的过程中

825
00:36:06,867 --> 0:36:09,670
旧的推断性数据会被清洗

826
00:36:09,736 --> 0:36:11,872
模块会再次进入推断模式

827
00:36:11,939 --> 0:36:13,874
以新的视界值

828
00:36:14,174 --> 0:36:16,376
放回推断事件

829
00:36:16,643 --> 0:36:19,346
UI会跟往常一样更新

830
00:36:19,980 --> 0:36:24,751
追踪停止时

831
00:36:25,085 --> 0:36:26,386
但无论你写什么

832
00:36:26,453 --> 0:36:29,690
实际都记录在追踪数据中

833
00:36:29,857 --> 0:36:32,860
对下行模块可用 不仅是UI

834
00:36:33,827 --> 0:36:37,297
如果修改现有的工具

835
00:36:37,898 --> 0:36:39,433
它就会变成这样

836
00:36:39,766 --> 0:36:42,202
这是移动主体轨迹 你看到

837
00:36:42,269 --> 0:36:45,873
这个parking区间持续延长

838
00:36:46,440 --> 0:36:47,474
它会实时更新

839
00:36:47,541 --> 0:36:49,076
如果查看底部的细节表

840
00:36:49,142 --> 0:36:51,578
你会看到 时长也在增加

841
00:36:52,279 --> 0:36:55,115
现在如果按下停止键 终止记录

842
00:36:55,182 --> 0:36:56,950
你会看到区间停住了

843
00:36:57,017 --> 0:36:59,853
它实际上被记录为轨迹的一部分

844
00:37:01,321 --> 0:37:03,490
总结来说 编写自定义模块

845
00:37:03,557 --> 0:37:05,392
代表巨大的投入

846
00:37:05,459 --> 0:37:07,394
要投入时间学习新的技术

847
00:37:07,761 --> 0:37:10,831
但这是使用自定义工具的最好方式

848
00:37:10,898 --> 0:37:13,433
并智能化自定义工具

849
00:37:13,800 --> 0:37:15,969
我们看到 智能化工具

850
00:37:16,036 --> 0:37:18,572
意味着更高效的记录机制

851
00:37:18,639 --> 0:37:20,274
和更好的用户体验

852
00:37:21,975 --> 0:37:24,211
更多信息 请参见随附的样本代码

853
00:37:24,278 --> 0:37:27,981
以及本场演讲网站中的相关演讲

854
00:37:28,982 --> 0:37:30,884
以上就是今天的内容 谢谢大家

855
00:37:30,951 --> 0:37:31,852
请享受其余的讲演
