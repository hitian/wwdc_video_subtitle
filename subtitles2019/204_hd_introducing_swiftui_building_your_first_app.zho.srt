1
00:00:06,406 --> 0:00:09,376
（引入SwiftUI

2
00:00:15,616 --> 0:00:16,517
大家好

3
00:00:17,184 --> 0:00:20,320
我是Jacob Xiao 稍后

4
00:00:20,921 --> 0:00:23,357
我们要跟大家分享SwiftUI

5
00:00:23,423 --> 0:00:26,627
它是创建更好、更快的app的

6
00:00:28,295 --> 0:00:30,764
我们认为了解

7
00:00:30,831 --> 0:00:32,833
是实际创建一个app

8
00:00:34,001 --> 0:00:36,270
使用SwiftUI

9
00:00:36,336 --> 0:00:38,639
但为了让大家明白

10
00:00:39,206 --> 0:00:41,074
我想带大家一起看一下整个过程

11
00:00:41,141 --> 0:00:43,644
在SwiftUI中

12
00:00:45,412 --> 0:00:46,947
那么我们要做哪种app呢？

13
00:00:47,614 --> 0:00:48,882
嗯 让我来为你打好基础

14
00:00:49,616 --> 0:00:51,051
这里有人讨厌开会吗？

15
00:00:52,052 --> 0:00:54,087
是吗？嗯 我们也是

16
00:00:54,821 --> 0:00:57,858
但我和Kyle发现有些东西

17
00:00:57,925 --> 0:01:00,394
那就是在非常漂亮、

18
00:00:57,925 --> 0:01:00,394
那就是在非常漂亮、

19
00:01:01,495 --> 0:01:03,897
因此我们列出了一个

20
00:01:03,964 --> 0:01:06,433
并且我们想给它做一个app

21
00:01:08,101 --> 0:01:09,069
那么让我们开始吧

22
00:01:10,637 --> 0:01:13,674
好的 我要从创建新项目开始

23
00:01:17,177 --> 0:01:18,478
我们把它命名为Rooms

24
00:01:21,815 --> 0:01:23,784
并确保勾选了

25
00:01:30,090 --> 0:01:33,493
现在Xcode已经启动了

26
00:01:33,694 --> 0:01:36,463
通过这个视图我们就可以

27
00:01:40,634 --> 0:01:42,436
我们的代码在左侧

28
00:01:44,171 --> 0:01:45,606
右侧是Canvas

29
00:01:46,874 --> 0:01:50,077
如果你熟悉Interface Builder

30
00:01:50,143 --> 0:01:51,945
你可能会觉得这并不新鲜

31
00:01:52,012 --> 0:01:55,148
一侧有一些代码 然后另一侧

32
00:01:56,283 --> 0:01:57,951
嗯 有一个非常重要的不同点

33
00:01:58,652 --> 0:02:01,855
对于StoryBoards来说

34
00:01:58,652 --> 0:02:01,855
对于StoryBoards来说

35
00:02:02,222 --> 0:02:04,024
你要在使用可视化编辑器创建更好

36
00:02:04,391 --> 0:02:06,527
还是使用代码创建UI更好

37
00:02:07,394 --> 0:02:09,596
并且如果你选择了一个

38
00:02:10,197 --> 0:02:11,598
那么你就要重新开始

39
00:02:12,499 --> 0:02:14,501
但对于SwiftUI来说

40
00:02:15,435 --> 0:02:18,205
现在视图定义总会是Swift代码

41
00:02:18,705 --> 0:02:21,341
你总是可以选择直接编辑代码

42
00:02:21,708 --> 0:02:23,143
或使用可视化编辑器

43
00:02:23,510 --> 0:02:24,811
并且你总是可以来回切换

44
00:02:25,979 --> 0:02:27,881
因此如果我们在Canvas中

45
00:02:28,849 --> 0:02:31,251
那么也会在代码中反映出

46
00:02:32,152 --> 0:02:33,820
并且如果你修改了代码

47
00:02:34,922 --> 0:02:37,024
那么这个修改也会在Canvas中

48
00:02:37,524 --> 0:02:38,959
它们无缝衔接 共同发挥作用

49
00:02:40,794 --> 0:02:42,829
那么让我具体来讲讲该如何使用它

50
00:02:43,697 --> 0:02:46,333
Canvas给我们显示了

51
00:02:47,034 --> 0:02:49,403
它甚至帮助我们编辑和了解

52
00:02:50,304 --> 0:02:53,473
Xcode通过编译真实代码

53
00:02:53,640 --> 0:02:55,509
并运行它来生成结果

54
00:02:56,376 --> 0:02:58,145
但对于预览我最喜欢的事情之一是

55
00:02:58,212 --> 0:03:00,581
它们也可以使用

56
00:02:58,212 --> 0:03:00,581
它们也可以使用

57
00:03:00,981 --> 0:03:02,783
在这种情况下 代码在这里

58
00:03:04,785 --> 0:03:07,187
稍后 我们将了解它如何为我们

59
00:03:07,254 --> 0:03:08,722
来自定义预览

60
00:03:10,157 --> 0:03:12,860
现在我们的app

61
00:03:13,093 --> 0:03:14,695
那么让我们为列表创建网格吧

62
00:03:16,029 --> 0:03:18,532
我要添加这段文本的下方

63
00:03:18,799 --> 0:03:20,534
显示每间房间的更多详情

64
00:03:21,602 --> 0:03:24,938
我只需要把它

65
00:03:27,107 --> 0:03:30,611
并且Xcode甚至给我显示出

66
00:03:32,012 --> 0:03:33,313
现在当我释放它时

67
00:03:33,380 --> 0:03:37,317
预览会更新以显示我的新文本

68
00:03:37,718 --> 0:03:40,387
Xcode实际上编辑了我的代码

69
00:03:41,421 --> 0:03:44,324
Xcode把这些视图

70
00:03:44,391 --> 0:03:45,459
从而获得我想要的布局

71
00:03:46,493 --> 0:03:48,495
现在Vstack或垂直堆栈

72
00:03:48,562 --> 0:03:51,031
是SwiftUI中

73
00:03:51,732 --> 0:03:53,433
它可以让你垂直叠加视图

74
00:03:54,067 --> 0:03:56,670
还有一个Hstack水平叠加视图

75
00:03:57,738 --> 0:03:59,039
并且这些堆栈都是容器

76
00:03:59,473 --> 0:04:01,875
我可以在它们里边放入

77
00:03:59,473 --> 0:04:01,875
我可以在它们里边放入

78
00:04:03,844 --> 0:04:06,680
现在我要替换Xcode

79
00:04:06,747 --> 0:04:08,549
占位符内包含关于房间的更多信息

80
00:04:09,583 --> 0:04:11,285
我们要显示它所能容纳的人数

81
00:04:11,652 --> 0:04:13,720
现在 让我们使用一个硬编码的值

82
00:04:15,255 --> 0:04:17,958
接下来

83
00:04:19,426 --> 0:04:22,362
我可以在代码中进行编辑

84
00:04:22,696 --> 0:04:24,965
那么让我们在Hstack中

85
00:04:25,465 --> 0:04:27,467
我可以命令点击我的视图

86
00:04:28,035 --> 0:04:29,937
并选择嵌入一个HStack

87
00:04:31,038 --> 0:04:33,173
然后Xcode更新了代码

88
00:04:34,208 --> 0:04:36,643
现在我可以在Vstack旁边

89
00:04:37,444 --> 0:04:38,812
稍后我们要添加一些资产

90
00:04:39,112 --> 0:04:41,582
但现在我只使用一个SF象征图像

91
00:04:41,648 --> 0:04:42,950
让项目运作起来

92
00:04:47,621 --> 0:04:49,623
SF象征是iOS 13中的新东西

93
00:04:49,990 --> 0:04:51,892
它们是Apple提供的一大批图像

94
00:04:51,959 --> 0:04:53,260
你可以在你的app中使用

95
00:04:54,695 --> 0:04:56,964
我们已经有了一个基本版的网格

96
00:04:57,631 --> 0:05:00,667
现在我要使用Canvas给网格

97
00:04:57,631 --> 0:05:00,667
现在我要使用Canvas给网格

98
00:05:02,002 --> 0:05:03,604
我可以命令点击我的堆栈

99
00:05:04,404 --> 0:05:05,439
并选择检查

100
00:05:05,973 --> 0:05:08,275
用于了解我可以修改

101
00:05:09,443 --> 0:05:11,311
我要把它的对齐方式

102
00:05:13,280 --> 0:05:15,816
再一次 Xcode更新了我的代码

103
00:05:15,883 --> 0:05:16,783
从而实现那个修改

104
00:05:18,519 --> 0:05:21,488
现在我还可以命令点击我的文本

105
00:05:24,024 --> 0:05:25,659
让我们把字体变小点儿

106
00:05:26,860 --> 0:05:28,128
我要使用子标题

107
00:05:30,063 --> 0:05:32,599
对于Xcode修改代码的一件

108
00:05:32,966 --> 0:05:35,002
是它帮助我了解SwiftUI

109
00:05:36,370 --> 0:05:39,406
比如它在这里添加了这段代码

110
00:05:40,107 --> 0:05:42,109
我们把这种方法叫做修饰器

111
00:05:42,543 --> 0:05:46,146
它们在SwiftUI中用于

112
00:05:47,581 --> 0:05:49,816
我要在代码中添加另一个修饰器

113
00:05:50,517 --> 0:05:51,785
用于设置前景颜色…

114
00:05:53,053 --> 0:05:54,087
使它变成次生色

115
00:05:58,091 --> 0:05:59,026
好的

116
00:05:59,493 --> 0:06:01,728
现在网格做好了

117
00:05:59,493 --> 0:06:01,728
现在网格做好了

118
00:06:02,796 --> 0:06:05,332
为此 我要命令点击我的网格

119
00:06:06,333 --> 0:06:07,634
并选择转换为列表

120
00:06:08,836 --> 0:06:12,206
这将把我的网格打包到一个列表中

121
00:06:18,712 --> 0:06:20,214
操作起来如此简单真是太棒了

122
00:06:20,881 --> 0:06:23,650
这些代码就是在app中

123
00:06:23,984 --> 0:06:25,886
不需要什么委托或数据源

124
00:06:26,153 --> 0:06:27,588
就是列表中的视图

125
00:06:29,056 --> 0:06:30,757
接下来让我们把它与一些数据挂钩

126
00:06:32,526 --> 0:06:33,594
我要拖入…

127
00:06:34,695 --> 0:06:37,130
一些资产和我之前创建的一个

128
00:06:43,103 --> 0:06:45,672
现在我的模型有几个信息的字段

129
00:06:46,773 --> 0:06:48,842
并在SwiftUI中的列表中

130
00:06:49,209 --> 0:06:51,178
我只需把这个类型变成可识别即可

131
00:06:55,782 --> 0:06:58,285
这会告诉列表有什么东西进入了

132
00:06:59,219 --> 0:07:01,722
并且我所需要的就是一个ID属性

133
00:06:59,219 --> 0:07:01,722
并且我所需要的就是一个ID属性

134
00:07:03,457 --> 0:07:05,692
现在这个模型文件还包含一些

135
00:07:05,759 --> 0:07:07,094
我可以用来调试app

136
00:07:09,229 --> 0:07:10,531
现在让我们返回到我们的视图…

137
00:07:12,399 --> 0:07:13,534
让我们传入数据

138
00:07:14,635 --> 0:07:15,702
我要给房间…

139
00:07:16,937 --> 0:07:17,938
添加一个属性

140
00:07:21,575 --> 0:07:23,143
关于预览 其中一件非常棒的事

141
00:07:23,210 --> 0:07:24,745
就是它们可以使用

142
00:07:25,345 --> 0:07:27,347
因此我只需要在这里传入

143
00:07:30,784 --> 0:07:32,819
现在你可能已经注意到

144
00:07:32,886 --> 0:07:33,854
预览上方出现了这个横幅

145
00:07:34,888 --> 0:07:36,590
当我对键入内容做出重大修改时

146
00:07:36,890 --> 0:07:38,926
比如在视图中添加房间属性

147
00:07:39,426 --> 0:07:42,663
Xcode会暂停预览

148
00:07:43,463 --> 0:07:45,132
并且我只需要点击按钮来重新更新

149
00:07:46,867 --> 0:07:48,735
接下来让我们使用数据来驱动列表

150
00:07:49,536 --> 0:07:51,438
我们将向列表传入房间…

151
00:07:53,240 --> 0:07:55,709
然后我会更新文本以显示房间名称

152
00:07:57,244 --> 0:08:00,547
我们还要在文本中使用这里的功能

153
00:07:57,244 --> 0:08:00,547
我们还要在文本中使用这里的功能

154
00:08:07,120 --> 0:08:08,589
现在我们有真实的图片

155
00:08:08,655 --> 0:08:10,691
对于图片 让我们使用房间缩略图

156
00:08:16,864 --> 0:08:17,831
很棒

157
00:08:25,739 --> 0:08:27,908
你可能已经注意到

158
00:08:27,975 --> 0:08:28,876
当我们这样做时

159
00:08:29,343 --> 0:08:32,179
刚开始时我们的网格高度

160
00:08:33,080 --> 0:08:34,881
但当我们做了这些很大的修改之后

161
00:08:35,315 --> 0:08:38,085
网格自动扩展了

162
00:08:38,418 --> 0:08:39,453
而不需要做任何额外的工作

163
00:08:42,155 --> 0:08:43,155
非常酷

164
00:08:45,993 --> 0:08:47,761
现在这些图片已经在情境中了

165
00:08:48,061 --> 0:08:49,162
它们看起来有点儿格格不入

166
00:08:49,763 --> 0:08:51,598
因此让我们给图片添加圆角半径

167
00:08:51,665 --> 0:08:52,666
使用另一个修饰器

168
00:08:53,800 --> 0:08:56,203
如果你不确定有哪些修饰器可用

169
00:08:56,837 --> 0:08:59,706
你可以从修饰器列表中浏览和筛选

170
00:09:00,774 --> 0:09:03,944
让我们找到圆角半径

171
00:09:12,619 --> 0:09:13,921
然后我们可以修改值

172
00:09:14,388 --> 0:09:15,489
看起来有点儿太大了

173
00:09:17,157 --> 0:09:17,991
很棒

174
00:09:18,625 --> 0:09:20,627
现在我们的网格和列表

175
00:09:21,228 --> 0:09:23,597
接下来我们要做的就是能轻触网格

176
00:09:23,664 --> 0:09:24,598
以查看更多详情

177
00:09:25,599 --> 0:09:28,735
为此 让我们把列表打包到一个

178
00:09:30,404 --> 0:09:32,539
导航视图显示一个导航栏

179
00:09:33,040 --> 0:09:34,975
以及一个可以叠加视图的堆栈

180
00:09:36,343 --> 0:09:38,312
让我们也设置一个导航栏标题

181
00:09:39,112 --> 0:09:41,048
我们只需要一些文本

182
00:09:42,282 --> 0:09:43,684
在导航栏中显示房间

183
00:09:46,687 --> 0:09:48,922
现在让我们设置

184
00:09:50,090 --> 0:09:53,360
为此 我要把网格内容打包到一个

185
00:09:55,629 --> 0:09:57,564
导航按钮有一个目的地

186
00:09:58,232 --> 0:10:00,033
是一个要叠加到堆栈中的视图

187
00:09:58,232 --> 0:10:00,033
是一个要叠加到堆栈中的视图

188
00:10:01,101 --> 0:10:02,769
首先 我们要使用一些文本

189
00:10:03,070 --> 0:10:04,104
用于显示房间名称

190
00:10:05,205 --> 0:10:07,441
然后我们要把网格的全部内容

191
00:10:07,908 --> 0:10:09,309
放在那个导航按钮内…

192
00:10:10,878 --> 0:10:11,778
然后就搞定了

193
00:10:12,479 --> 0:10:14,414
请注意我们的UI已经进行了更新

194
00:10:14,481 --> 0:10:16,250
从而自动显示这些UI指示器

195
00:10:17,184 --> 0:10:19,820
SwiftUI会像这样

196
00:10:19,887 --> 0:10:21,955
因此我的UI在默认情况下

197
00:10:23,957 --> 0:10:26,059
现在让我们也检查

198
00:10:26,894 --> 0:10:29,096
我只需要点击预览中的播放按钮

199
00:10:29,563 --> 0:10:30,697
就会把我带到实时模式中

200
00:10:31,732 --> 0:10:33,867
此时 Xcode会编译我的代码

201
00:10:34,635 --> 0:10:35,903
并把它发送给模拟器

202
00:10:36,136 --> 0:10:38,539
运行它并显示全部结果

203
00:10:38,605 --> 0:10:39,673
就在Canvas中

204
00:10:40,007 --> 0:10:41,542
意思是我可以与视图进行交互

205
00:10:42,509 --> 0:10:45,512
因此我可以轻触一个网格来确保

206
00:10:45,579 --> 0:10:46,780
一切都像我期待的那样压入和取出

207
00:10:48,315 --> 0:10:49,750
并且如果我滑动

208
00:10:50,217 --> 0:10:53,320
你会注意到SwiftUI会为我

209
00:10:53,954 --> 0:10:55,455
我们的网格保持突显

210
00:10:55,956 --> 0:10:58,592
随着我的滑动

211
00:10:58,659 --> 0:10:59,960
而我们不需要做任何额外的操作

212
00:11:08,735 --> 0:11:10,037
好的 我们已经有了列表

213
00:11:10,404 --> 0:11:11,605
并且它已经能用了

214
00:11:12,439 --> 0:11:14,174
但这段视图代码现在变多了

215
00:11:14,875 --> 0:11:17,344
并且我非常希望把网格分解出来

216
00:11:18,145 --> 0:11:20,414
Xcode通过一个简单的操作

217
00:11:21,248 --> 0:11:23,784
我只需命令点击我想要的视图

218
00:11:23,851 --> 0:11:25,185
并选择提取子视图即可

219
00:11:28,021 --> 0:11:29,156
很神奇

220
00:11:33,293 --> 0:11:35,729
所有的视图代码都被提取到了这里

221
00:11:36,129 --> 0:11:38,065
我甚至可以为新视图选择名称

222
00:11:38,398 --> 0:11:39,499
让我们叫它Room Cell

223
00:11:43,570 --> 0:11:44,571
谢谢

224
00:11:45,806 --> 0:11:47,875
现在让我们给房间再添加一个属性

225
00:11:49,576 --> 0:11:50,878
我们要把它传到这里

226
00:11:54,515 --> 0:11:56,149
这是一个很神奇的流程改进

227
00:11:56,650 --> 0:11:58,986
通过SwiftUI

228
00:11:59,052 --> 0:12:01,121
因此你再也不用担心创建附加视图

229
00:11:59,052 --> 0:12:01,121
因此你再也不用担心创建附加视图

230
00:12:01,421 --> 0:12:03,257
来得到更好的压缩或分离逻辑了

231
00:12:05,092 --> 0:12:07,194
好的 接下来让我们创建详情视图

232
00:12:08,362 --> 0:12:09,796
我要创建一个新视图…

233
00:12:10,831 --> 0:12:12,399
并确保使用SwiftUI模板

234
00:12:13,901 --> 0:12:16,136
让我们把新视图命名为

235
00:12:20,240 --> 0:12:22,843
Xcode自动为我提供了一个

236
00:12:23,343 --> 0:12:25,212
以及要创建它的预览代码

237
00:12:26,413 --> 0:12:29,349
因为我希望这个详情视图

238
00:12:29,950 --> 0:12:31,218
我要为房间添加一个属性

239
00:12:33,487 --> 0:12:34,521
正如我之前所做的那样

240
00:12:34,788 --> 0:12:38,225
我要更新我的预览代码

241
00:12:38,292 --> 0:12:39,293
以便从房间的测试数据中

242
00:12:43,263 --> 0:12:45,132
然后让我们创建UI

243
00:12:46,233 --> 0:12:49,603
我们使用一张图片…

244
00:12:53,440 --> 0:12:54,975
好的 现在我们显示了图片

245
00:12:55,342 --> 0:12:56,977
但它对于视图来说有点儿太大了

246
00:12:57,678 --> 0:12:59,980
默认情况下

247
00:13:00,047 --> 0:13:01,248
显示全部图片…

248
00:13:01,715 --> 0:13:04,484
从而防止图片产生缩放的视觉效果

249
00:13:05,853 --> 0:13:07,020
但对于这样的照片来说

250
00:13:07,354 --> 0:13:08,922
我们希望能把它的尺寸变小

251
00:13:09,389 --> 0:13:11,658
我们可以使用一个图片专用的修饰器

252
00:13:12,392 --> 0:13:13,694
叫做Resizable来实现

253
00:13:15,128 --> 0:13:16,663
那么我只需把它拖到视图上…

254
00:13:18,732 --> 0:13:22,202
好的 现在它已经重新调整了尺寸

255
00:13:22,903 --> 0:13:25,873
但我们真的希望它保持原始长宽比

256
00:13:26,540 --> 0:13:28,075
这次我们可以通过另一个修饰器实现

257
00:13:28,876 --> 0:13:30,410
长宽比

258
00:13:33,080 --> 0:13:36,183
长宽比修饰器可以让我

259
00:13:37,017 --> 0:13:41,488
.fill扩展图片

260
00:13:42,656 --> 0:13:44,558
.fit确保图片匹配到框架内

261
00:13:46,927 --> 0:13:49,229
预览让我非常简明地看到和了解

262
00:13:49,296 --> 0:13:51,098
这些不同模式之间的不同点

263
00:13:51,798 --> 0:13:53,967
让我们使用.fit

264
00:13:55,569 --> 0:13:56,670
让我们返回到列表…

265
00:13:57,538 --> 0:13:59,406
并更新网格生成新详情视图

266
00:14:01,842 --> 0:14:03,143
我们要创建房间详情视图

267
00:14:04,378 --> 0:14:05,913
我们要传入当前房间

268
00:14:08,415 --> 0:14:10,717
现在我要把预览切换回实时模式

269
00:14:12,219 --> 0:14:14,254
我可以轻触网格查看图片

270
00:14:15,556 --> 0:14:16,890
但现在我正在这里预览

271
00:14:16,957 --> 0:14:19,626
我可以看到

272
00:14:20,327 --> 0:14:22,196
因此让我们返回详情视图修改一下

273
00:14:25,332 --> 0:14:26,366
跟以前一样

274
00:14:26,667 --> 0:14:29,903
我可以用导航栏标题来设置标题…

275
00:14:31,371 --> 0:14:33,841
我们要传入房间名称作为标题

276
00:14:35,309 --> 0:14:36,610
但在我之前的预览中

277
00:14:36,677 --> 0:14:37,978
我们只看到了视图自身

278
00:14:38,445 --> 0:14:40,614
我真的希望可以快速验证

279
00:14:41,682 --> 0:14:44,751
因为预览可以使用SwiftUI

280
00:14:45,018 --> 0:14:45,953
我们完全可以实现

281
00:14:47,221 --> 0:14:48,355
我可以把预览设置为…

282
00:14:48,989 --> 0:14:50,557
位于导航视图内…

283
00:14:51,258 --> 0:14:53,160
使用我能在其它任何地方

284
00:14:53,861 --> 0:14:56,797
现在视图的预览已经处于导航栏内了

285
00:15:04,438 --> 0:15:05,506
我看到它在这儿

286
00:15:05,572 --> 0:15:08,442
对于详情视图来说

287
00:15:09,209 --> 0:15:10,944
因此让我们更新一下导航栏标题

288
00:15:11,778 --> 0:15:13,313
把显示模式设置为行内显示

289
00:15:15,215 --> 0:15:16,250
好多了

290
00:15:17,050 --> 0:15:18,852
现在当我选择一间会议室时

291
00:15:19,186 --> 0:15:20,587
有一件事非常重要

292
00:15:21,522 --> 0:15:22,723
房间必须得有一张好桌子

293
00:15:23,423 --> 0:15:25,092
我不能集中注意力听某人在讲什么

294
00:15:25,158 --> 0:15:26,727
如果桌子的质量不好的话

295
00:15:29,096 --> 0:15:31,331
我可以看到这间房间内有一些桌子

296
00:15:31,899 --> 0:15:33,667
但我实际上不能很清楚地看到

297
00:15:34,601 --> 0:15:36,036
但当图片是.fill时

298
00:15:37,271 --> 0:15:38,438
我就可以近距离看到它很漂亮

299
00:15:38,872 --> 0:15:40,007
看那种木纹

300
00:15:42,242 --> 0:15:44,611
因此我希望能在.fill

301
00:15:44,878 --> 0:15:46,113
.fill可以查看房间详情

302
00:15:46,647 --> 0:15:48,549
.fit可以立刻了解一切

303
00:15:50,250 --> 0:15:53,020
但我到底该如何从视图内

304
00:15:53,320 --> 0:15:54,354
修改这个长宽比的内容模式呢？

305
00:15:55,189 --> 0:15:56,557
嗯 要了解如何实现

306
00:15:56,823 --> 0:16:00,127
我们一定要了解视图是如何

307
00:15:56,823 --> 0:16:00,127
我们一定要了解视图是如何

308
00:16:00,827 --> 0:16:03,564
因此我要邀请Kyle上台来谈谈

309
00:16:03,997 --> 0:16:04,831
Kyle？

310
00:16:05,365 --> 0:16:07,167
嗯 大家好

311
00:16:07,234 --> 0:16:08,402
视图的运作方式

312
00:16:12,773 --> 0:16:14,608
目前大家是怎么认为

313
00:16:17,177 --> 0:16:18,745
是的 我也非常激动

314
00:16:19,847 --> 0:16:21,014
有点儿不可思议

315
00:16:21,515 --> 0:16:23,450
那么在我们继续讲其它内容之前

316
00:16:23,517 --> 0:16:24,751
我们要退一步

317
00:16:25,185 --> 0:16:28,522
谈谈视图在SwiftUI中的

318
00:16:30,424 --> 0:16:32,860
那么我们刚才谈到了

319
00:16:34,094 --> 0:16:38,298
在SwiftUI中

320
00:16:38,765 --> 0:16:42,135
而不是和UI视图一样

321
00:16:43,403 --> 0:16:46,039
这意味着视图不会继承

322
00:16:46,673 --> 0:16:49,243
它分配在堆栈上并按值传递

323
00:16:50,577 --> 0:16:52,179
Room Detail

324
00:16:52,746 --> 0:16:54,681
那么它是一间房间的尺寸和比重

325
00:16:55,249 --> 0:16:58,018
没有任何额外的分配或引用计算在内

326
00:16:59,853 --> 0:17:01,989
在幕后 SwiftUI

327
00:16:59,853 --> 0:17:01,989
在幕后 SwiftUI

328
00:17:02,055 --> 0:17:03,824
把你的视图等级坍缩到

329
00:17:04,258 --> 0:17:06,260
一个很有效的数据结构中

330
00:17:07,094 --> 0:17:12,199
藉此 我们在SwiftUI中

331
00:17:12,633 --> 0:17:13,500
并且你们也可以

332
00:17:14,601 --> 0:17:17,436
我希望你们从最后几张幻灯片中

333
00:17:17,938 --> 0:17:21,909
SwiftUI中的视图

334
00:17:22,776 --> 0:17:23,877
正如Jacob所说的那样

335
00:17:23,944 --> 0:17:27,381
你永远不要犹豫

336
00:17:27,881 --> 0:17:31,518
因为提取子视图事实上不需要花时间

337
00:17:33,687 --> 0:17:35,289
是的 你可以为此而鼓掌 非常棒

338
00:17:35,355 --> 0:17:36,423
（一个视图定义了一个UI）

339
00:17:39,193 --> 0:17:43,397
那么SwiftUI中的视图

340
00:17:43,463 --> 0:17:44,965
实现的是同样的主要功能

341
00:17:45,699 --> 0:17:47,568
它们定义一个UI

342
00:17:49,503 --> 0:17:52,039
视图协议 只有一个要求：

343
00:17:52,439 --> 0:17:53,407
一个body属性

344
00:17:53,774 --> 0:17:54,975
它自身就是一个视图

345
00:17:56,743 --> 0:18:00,080
在SwiftUI中 通过把小视图

346
00:17:56,743 --> 0:18:00,080
在SwiftUI中 通过把小视图

347
00:18:00,681 --> 0:18:03,684
我们创建了Room Detail

348
00:18:04,251 --> 0:18:06,186
拥有原生分辨率的图片的视图…

349
00:18:07,654 --> 0:18:11,758
可调整大小

350
00:18:12,659 --> 0:18:16,196
以及长宽比 一个能恰当地缩放

351
00:18:17,965 --> 0:18:19,733
对你所创建的任意视图的渲染

352
00:18:20,033 --> 0:18:21,468
只是渲染它的主体

353
00:18:23,804 --> 0:18:26,840
因此如果你设置了分割点

354
00:18:28,876 --> 0:18:30,344
渲染的意思就是框架决定

355
00:18:30,410 --> 0:18:32,212
它需要渲染视图

356
00:18:34,915 --> 0:18:35,949
Tada

357
00:18:37,918 --> 0:18:39,753
好的 那么视图—

358
00:18:40,087 --> 0:18:43,257
框架知道何时取回视图的新渲染

359
00:18:43,624 --> 0:18:47,728
因为除了定义UI之外

360
00:18:47,794 --> 0:18:49,429
视图还决定自己的依赖关系

361
00:18:49,496 --> 0:18:50,731
（视图决定自己的依赖关系）

362
00:18:51,331 --> 0:18:54,301
让我们扩展Room Detail

363
00:18:54,601 --> 0:18:56,770
在适应…

364
00:18:58,338 --> 0:19:00,073
和填充可用空间之间进行切换

365
00:18:58,338 --> 0:19:00,073
和填充可用空间之间进行切换

366
00:19:00,407 --> 0:19:02,609
从而可以让Jacob

367
00:19:04,344 --> 0:19:07,047
因此我们所需要的第一个东西

368
00:19:07,381 --> 0:19:08,482
但它是个特别的属性

369
00:19:09,082 --> 0:19:12,319
它是一个状态属性

370
00:19:13,520 --> 0:19:16,390
当SwiftUI看到一个

371
00:19:16,456 --> 0:19:19,359
它会以视图的名义

372
00:19:19,826 --> 0:19:22,996
在这个Memory图表中

373
00:19:23,530 --> 0:19:25,866
紫色是SwiftUI所管理的内存

374
00:19:26,266 --> 0:19:29,837
那么放大变量的这个值

375
00:19:33,173 --> 0:19:36,677
因此如果根据那个变量

376
00:19:38,212 --> 0:19:41,148
那么当它放大时我们会得到一个

377
00:19:42,616 --> 0:19:43,650
当它不放大时就像这样子

378
00:19:45,853 --> 0:19:47,654
那么现在我们所需要的

379
00:19:50,157 --> 0:19:52,559
用于在两种状态之间来回切换

380
00:19:52,860 --> 0:19:55,562
那么如果轻触

381
00:19:57,631 --> 0:19:58,932
并被缩小用于适应

382
00:20:08,842 --> 0:20:13,580
那么当我们轻触这里

383
00:20:15,282 --> 0:20:18,151
嗯 状态变量的一个特别属性

384
00:20:18,552 --> 0:20:21,188
就是SwiftUI

385
00:20:21,788 --> 0:20:25,158
因为SwiftUI知道这里的那个

386
00:20:26,026 --> 0:20:28,095
它知道视图的渲染取决于它

387
00:20:28,595 --> 0:20:29,630
意思就是…

388
00:20:30,864 --> 0:20:32,165
当变量改变时

389
00:20:32,599 --> 0:20:34,768
框架会再次请求body…

390
00:20:35,435 --> 0:20:36,737
使用新状态值

391
00:20:38,639 --> 0:20:40,574
因此这一次它会刷新渲染

392
00:20:41,108 --> 0:20:42,409
以不同的内容模式

393
00:20:44,311 --> 0:20:45,579
（事实在哪里？）

394
00:20:46,113 --> 0:20:48,682
那么传统UI框架不区分

395
00:20:48,749 --> 0:20:51,351
状态变量和普通的旧属性

396
00:20:51,785 --> 0:20:54,988
但我发现这个区别非常清楚

397
00:20:57,357 --> 0:21:01,929
在SwiftUI中

398
00:20:57,357 --> 0:21:01,929
在SwiftUI中

399
00:21:02,529 --> 0:21:04,131
滚动视图的偏移

400
00:21:04,898 --> 0:21:06,133
按钮的不突显

401
00:21:07,568 --> 0:21:09,336
导航堆栈的内容

402
00:21:10,170 --> 0:21:12,606
它衍生自权威数据

403
00:21:13,073 --> 0:21:15,375
通常叫做事实来源

404
00:21:16,276 --> 0:21:19,046
状态变量和模型共同

405
00:21:19,346 --> 0:21:21,014
构成整个app的

406
00:21:21,281 --> 0:21:22,616
事实来源

407
00:21:24,351 --> 0:21:26,653
刚才我提到过对长宽比的调用

408
00:21:26,720 --> 0:21:27,588
会生成视图

409
00:21:28,789 --> 0:21:30,457
它的定义看起来类似这样

410
00:21:31,592 --> 0:21:34,728
内容模式是一个普通的

411
00:21:36,496 --> 0:21:38,699
你可以简洁地把每一个属性归类为

412
00:21:39,166 --> 0:21:42,336
一个事实来源或一个衍生值

413
00:21:43,537 --> 0:21:46,240
Zoom状态变量是一个事实来源

414
00:21:47,808 --> 0:21:50,310
Content Mode属性

415
00:21:52,079 --> 0:21:56,083
回调SwiftUI

416
00:21:56,483 --> 0:21:57,784
那么当其中一个发生变更时

417
00:21:57,851 --> 0:21:59,586
它就知道该刷新哪个渲染

418
00:22:00,854 --> 0:22:02,389
框架通过请求新body

419
00:22:02,689 --> 0:22:04,224
刷新渲染

420
00:22:04,892 --> 0:22:07,761
重新生成一个新的长宽比视图

421
00:22:08,328 --> 0:22:11,565
从而覆盖Content Mode

422
00:22:13,367 --> 0:22:17,004
这就是作用机制

423
00:22:17,070 --> 0:22:18,105
都保持是最新值

424
00:22:20,107 --> 0:22:23,544
那么我们已经了解了

425
00:22:23,977 --> 0:22:25,078
通过状态变量

426
00:22:26,513 --> 0:22:29,550
并且那个非常普通的旧属性

427
00:22:30,417 --> 0:22:32,352
我们就不在这里举例说明了

428
00:22:32,819 --> 0:22:34,788
但Swift为你提供了一个

429
00:22:36,056 --> 0:22:38,458
它是一个传递读写衍生值的好工具

430
00:22:39,293 --> 0:22:41,061
从技术角度来说任何常量

431
00:22:41,128 --> 0:22:44,164
都可以作为完美的只读事实来源

432
00:22:44,231 --> 0:22:46,600
正如我们在测试数据驱动预览时

433
00:22:47,668 --> 0:22:49,203
我还要指出另外一点

434
00:22:49,269 --> 0:22:52,973
我刚才提到状态变量

435
00:22:53,040 --> 0:22:55,976
和模型共同构成了

436
00:22:56,610 --> 0:22:58,846
那么我们有这个可绑定的对象协议

437
00:22:58,912 --> 0:23:00,180
Jacob刚才用过了

438
00:22:58,912 --> 0:23:00,180
Jacob刚才用过了

439
00:23:00,247 --> 0:23:04,017
从而告诉SwiftUI

440
00:23:06,420 --> 0:23:08,255
我们讲的可能很快

441
00:23:08,322 --> 0:23:11,725
本周稍后会有一整场演讲

442
00:23:11,792 --> 0:23:15,629
专门讲发展对不同流程基元的直觉

443
00:23:17,097 --> 0:23:18,065
（管理依赖关系很难）

444
00:23:18,131 --> 0:23:20,467
好的 让我们退回来接着讲

445
00:23:22,302 --> 0:23:23,470
这与你在传统框架中

446
00:23:23,904 --> 0:23:26,306
所做的非常不一样

447
00:23:26,773 --> 0:23:28,208
传统框架中的视图自身非常固执

448
00:23:28,475 --> 0:23:30,444
你最大努力地尝试

449
00:23:32,746 --> 0:23:33,947
你可能没从这方面思考过

450
00:23:34,214 --> 0:23:36,483
当你使用传统UI框架时

451
00:23:36,917 --> 0:23:39,686
但每一次视图读取数据时

452
00:23:40,120 --> 0:23:42,022
它都会创建一个隐性依赖关系

453
00:23:42,789 --> 0:23:45,092
它是一个依赖关系

454
00:23:45,792 --> 0:23:48,529
视图需要更新从而反映新值

455
00:23:49,096 --> 0:23:50,330
如果它失败了

456
00:23:51,265 --> 0:23:52,199
就说明有错误

457
00:23:53,267 --> 0:23:56,270
SwiftUI会以你的名义

458
00:23:57,337 --> 0:23:59,840
通过重新计算恰当的衍生值

459
00:23:59,907 --> 0:24:01,308
因此再也不会出现那种情况

460
00:23:59,907 --> 0:24:01,308
因此再也不会出现那种情况

461
00:24:08,682 --> 0:24:13,554
当然对于app中的单一依赖关系

462
00:24:14,121 --> 0:24:15,389
我们的app很大

463
00:24:16,223 --> 0:24:17,291
非常复杂

464
00:24:18,325 --> 0:24:20,360
当提到你要在脑子里记住多少东西

465
00:24:20,794 --> 0:24:22,763
以及犯错是多么容易

466
00:24:23,330 --> 0:24:25,699
提到我们目前

467
00:24:26,099 --> 0:24:27,034
那非常困难

468
00:24:27,768 --> 0:24:29,036
尽管我已经做了最大的努力

469
00:24:29,469 --> 0:24:33,173
我所发布的每个app的每次更新

470
00:24:34,107 --> 0:24:36,844
这些行上的每一个项

471
00:24:38,679 --> 0:24:39,780
而这只是个开始

472
00:24:42,115 --> 0:24:45,986
我觉得对于管理视图的复杂性来说

473
00:24:46,720 --> 0:24:50,290
就是处理所有不同回调函数

474
00:24:50,691 --> 0:24:54,394
这是一个老版

475
00:24:54,661 --> 0:24:56,563
它是通过UIKit实施的

476
00:24:58,565 --> 0:25:01,201
它与目前我们所看到的那个视图

477
00:24:58,565 --> 0:25:01,201
它与目前我们所看到的那个视图

478
00:25:01,535 --> 0:25:02,536
但它比那个还多一个功能

479
00:25:04,872 --> 0:25:05,973
有时

480
00:25:06,306 --> 0:25:08,375
当我们放大会议室图片时

481
00:25:08,876 --> 0:25:11,345
桌子上的木纹太模糊了

482
00:25:12,412 --> 0:25:15,349
因此我们决定添加一个特殊功能

483
00:25:15,749 --> 0:25:17,684
使用神经网络和机器学习

484
00:25:18,185 --> 0:25:21,221
因此我们可以在轻触时增强图片

485
00:25:21,588 --> 0:25:22,823
在后台线程上

486
00:25:23,857 --> 0:25:26,793
选择正确的会议室

487
00:25:29,630 --> 0:25:30,697
好的 是的

488
00:25:31,365 --> 0:25:32,499
过度设计了 是吗？

489
00:25:33,634 --> 0:25:35,435
那么对于这个功能来说

490
00:25:36,236 --> 0:25:37,504
就是它有一个错误

491
00:25:37,571 --> 0:25:39,873
我们得到了一份

492
00:25:40,174 --> 0:25:41,208
它从不停止运转

493
00:25:42,643 --> 0:25:43,644
这是怎么发生的呢？

494
00:25:44,111 --> 0:25:47,814
嗯 原来如果事件按特定顺序发生…

495
00:25:50,584 --> 0:25:52,386
我们忘记清理那个活动指示器了

496
00:25:53,020 --> 0:25:55,355
在这种情况下 如果用户执行放大

497
00:25:55,422 --> 0:25:59,026
并轻触增强按钮 它会消失

498
00:25:59,426 --> 0:26:01,228
活动指示器会卡住

499
00:25:59,426 --> 0:26:01,228
活动指示器会卡住

500
00:26:02,129 --> 0:26:05,732
我们很容易犯这种错误

501
00:26:06,033 --> 0:26:09,403
当你直接从事件处理器回调中

502
00:26:09,803 --> 0:26:11,972
而不是更新事实来源

503
00:26:12,840 --> 0:26:15,275
而不是更新事实来源并从中衍生UI

504
00:26:17,644 --> 0:26:20,681
我们犯这种错误是因为

505
00:26:20,747 --> 0:26:22,950
很容易只考虑到主逻辑

506
00:26:23,851 --> 0:26:25,185
就是那些很容易记起来的东西

507
00:26:26,720 --> 0:26:29,523
并且很容易忽略

508
00:26:30,123 --> 0:26:33,327
问题是随着视图要响应的

509
00:26:33,660 --> 0:26:36,730
可能的事件的数量的增加

510
00:26:37,097 --> 0:26:39,299
会暴露更多容易忽略的东西

511
00:26:40,868 --> 0:26:42,903
假如你拥有全部四个事件

512
00:26:43,770 --> 0:26:45,572
有多少可能存在的不同的顺序呢…

513
00:26:45,639 --> 0:26:46,773
可能的传入顺序？

514
00:26:47,908 --> 0:26:50,644
嗯 实际上有24种顺序

515
00:26:50,911 --> 0:26:52,212
对于任意四个事件来说

516
00:26:52,946 --> 0:26:54,882
实际情况更糟糕

517
00:26:55,249 --> 0:26:57,985
因为每个事件可以出现一次以上

518
00:26:58,519 --> 0:27:01,188
比如说用户多次轻触增强按钮

519
00:26:58,519 --> 0:27:01,188
比如说用户多次轻触增强按钮

520
00:27:02,456 --> 0:27:04,825
你们应该很熟悉这种情况

521
00:27:04,892 --> 0:27:07,694
如果你们曾经实施过

522
00:27:08,028 --> 0:27:10,964
完成处理器可能会在一个

523
00:27:12,366 --> 0:27:16,970
如果我能告诉五年前的自己

524
00:27:17,037 --> 0:27:20,574
那可能是UI编程非常难

525
00:27:20,941 --> 0:27:23,177
就和无日志并发一样困难

526
00:27:25,045 --> 0:27:27,347
你们中有多少人写过多线程代码？

527
00:27:28,448 --> 0:27:30,384
很可能有2000人 是的

528
00:27:30,817 --> 0:27:32,719
那么没有人认为它简单

529
00:27:33,287 --> 0:27:35,622
我花了好几个月的时间来解决

530
00:27:35,689 --> 0:27:37,691
某些多线程代码中的所有错误

531
00:27:37,758 --> 0:27:40,561
即便这样我仍然不能

532
00:27:42,129 --> 0:27:45,065
许多UI代码实际上就像那样

533
00:27:45,666 --> 0:27:47,301
只不过不会发生崩溃

534
00:27:47,968 --> 0:27:49,369
而是视图会出现在错误的地方

535
00:27:49,703 --> 0:27:50,737
或者丢失

536
00:27:51,305 --> 0:27:54,575
这是因为竞争条件和UI不一致性

537
00:27:54,842 --> 0:27:57,110
分担了同样潜在的复杂性来源

538
00:27:58,712 --> 0:28:00,447
这些容易忽略的顺序

539
00:27:58,712 --> 0:28:00,447
这些容易忽略的顺序

540
00:28:02,149 --> 0:28:03,750
我们大家都会使用的许多视图的

541
00:28:04,251 --> 0:28:06,587
事件远远多于四个

542
00:28:08,355 --> 0:28:10,858
你知道的 比如模型通知、

543
00:28:11,158 --> 0:28:13,026
委托方法、目标操作、

544
00:28:13,493 --> 0:28:15,529
完成处理器 这些都是事件

545
00:28:16,230 --> 0:28:21,034
有12个事件的视图所产生的

546
00:28:21,568 --> 0:28:22,936
几乎是五亿种

547
00:28:25,339 --> 0:28:27,908
我们都使用过

548
00:28:29,309 --> 0:28:32,012
那时你只能在你脑子里装太多东西

549
00:28:35,048 --> 0:28:38,852
是的 这条虚线是

550
00:28:40,854 --> 0:28:43,423
你们认为这两个点之间

551
00:28:45,492 --> 0:28:46,627
有人发言吗？

552
00:28:47,528 --> 0:28:48,962
那些是报错 是的

553
00:28:49,963 --> 0:28:51,798
随着新功能的添加

554
00:28:51,865 --> 0:28:54,735
我们需要考虑到的

555
00:28:55,602 --> 0:28:57,337
也会呈指数方式增长

556
00:28:57,404 --> 0:28:58,839
如果我们忽略了其中一个

557
00:29:00,140 --> 0:29:00,974
结果一样

558
00:29:01,275 --> 0:29:02,376
不可避免

559
00:29:04,311 --> 0:29:07,147
如今当你编程时

560
00:29:07,781 --> 0:29:11,485
那么我想你们中有许多人凭直觉

561
00:29:11,552 --> 0:29:12,519
找到了UIKit或AppKit中

562
00:29:12,819 --> 0:29:16,523
就是把所有视图更新代码

563
00:29:17,457 --> 0:29:19,159
然后从这些事件处理器回调中

564
00:29:19,426 --> 0:29:20,761
调用那个方法

565
00:29:21,428 --> 0:29:24,631
这可以很好地帮助你回避这种复杂性

566
00:29:25,332 --> 0:29:28,602
SwiftUI从这个最佳实践中

567
00:29:29,803 --> 0:29:33,774
如今当你以这种方式在UI中实施时

568
00:29:33,841 --> 0:29:35,909
你需要考虑许多棘手的情况

569
00:29:36,009 --> 0:29:38,345
比如从视图等级中添加或移除子视图

570
00:29:38,645 --> 0:29:40,480
或堆叠和溢放导航堆栈

571
00:29:40,881 --> 0:29:42,482
或更新表视图

572
00:29:42,916 --> 0:29:45,452
我从来没自己独立

573
00:29:45,519 --> 0:29:46,453
解决过这些情况

574
00:29:47,254 --> 0:29:50,691
嗯 我们已经花了很多时间

575
00:29:50,958 --> 0:29:54,595
并且我们也以你的名义把这个

576
00:29:55,195 --> 0:29:58,732
视图协议只有一个要求：body

577
00:29:58,799 --> 0:30:01,768
框架要调用一个单入口点

578
00:29:58,799 --> 0:30:01,768
框架要调用一个单入口点

579
00:30:02,236 --> 0:30:07,241
意思是只能以一种顺序调用

580
00:30:17,584 --> 0:30:20,554
由于这种为发生变更的UI部分

581
00:30:20,621 --> 0:30:22,189
简单地提取新视图的模式

582
00:30:23,123 --> 0:30:25,759
SwiftUI释放了你的大脑

583
00:30:26,593 --> 0:30:29,129
从根本上消除了UI不一致性

584
00:30:30,597 --> 0:30:31,598
好的

585
00:30:31,965 --> 0:30:34,568
让我们返回到演示中

586
00:30:35,068 --> 0:30:35,969
Jacob？

587
00:30:41,808 --> 0:30:43,143
好的 让我们完成这个app

588
00:30:44,411 --> 0:30:46,747
现在我们了解了

589
00:30:47,981 --> 0:30:49,183
我们添加了一个状态属性

590
00:30:52,219 --> 0:30:55,055
并且我们把它命名为Zoomed

591
00:30:56,523 --> 0:30:58,125
然后在长宽比中…

592
00:30:59,092 --> 0:31:00,327
我们要恰当地使用Zoomed

593
00:30:59,092 --> 0:31:00,327
我们要恰当地使用Zoomed

594
00:31:00,861 --> 0:31:03,897
在填充（当放大时）

595
00:31:05,265 --> 0:31:09,303
最后我们要添加tapAction

596
00:31:12,940 --> 0:31:14,708
现在让我们在实时模式中

597
00:31:19,346 --> 0:31:21,582
太棒了 我们可以在这两种

598
00:31:22,983 --> 0:31:24,418
但还缺点儿什么东西

599
00:31:24,885 --> 0:31:25,953
有人看出来了吗？

600
00:31:27,788 --> 0:31:29,289
是的 它需要一个动画

601
00:31:30,824 --> 0:31:33,293
对于SwiftUI来说

602
00:31:34,528 --> 0:31:37,297
我只需把变更打包到一个

603
00:31:42,102 --> 0:31:43,837
现在变更有动画效果了

604
00:31:51,111 --> 0:31:52,179
不仅如此

605
00:31:52,246 --> 0:31:54,348
动画是完全交互式并可中断的

606
00:31:54,781 --> 0:31:56,717
因此我总是可以

607
00:31:57,251 --> 0:31:58,819
并且它总是会显示在正确的位置

608
00:32:01,889 --> 0:32:02,890
是的 很棒

609
00:32:06,159 --> 0:32:08,128
接下来我要添加增强按钮

610
00:32:08,695 --> 0:32:11,098
但事实是Kyle培训模型的方式

611
00:32:11,164 --> 0:32:13,200
只能用于他所展示的那一张图片

612
00:32:15,402 --> 0:32:16,970
因此我要添加一些更有用的东西

613
00:32:17,938 --> 0:32:19,540
我们有一个伦敦的同事

614
00:32:19,907 --> 0:32:22,242
我们经常想要了解哪间房间内

615
00:32:23,210 --> 0:32:25,846
因此让我在详情视图顶部

616
00:32:27,214 --> 0:32:30,717
我可以用Zstack

617
00:32:34,521 --> 0:32:36,957
我要把当前图片放到

618
00:32:37,991 --> 0:32:39,660
然后我要添加另一张图片…

619
00:32:40,460 --> 0:32:42,696
显示一个图标

620
00:32:44,598 --> 0:32:45,866
我就用一张象征图像吧…

621
00:32:47,601 --> 0:32:48,936
然后我们使用Video.fill

622
00:32:51,538 --> 0:32:54,074
好的 这里有图标了 但它有点儿小

623
00:32:55,209 --> 0:32:58,312
但象征图像会自动使用当前字号

624
00:32:58,679 --> 0:33:01,582
因此我可以非常方便地通过修饰器

625
00:32:58,679 --> 0:33:01,582
因此我可以非常方便地通过修饰器

626
00:33:03,383 --> 0:33:06,220
我们把它拖动到代码中

627
00:33:07,287 --> 0:33:08,388
标题看起来不错

628
00:33:09,223 --> 0:33:10,490
现在我们有大图片了

629
00:33:11,425 --> 0:33:13,327
接下来我希望在左上方显示这张图片

630
00:33:13,994 --> 0:33:15,629
让我们把Zstack的

631
00:33:17,564 --> 0:33:18,665
topLeading

632
00:33:20,634 --> 0:33:22,636
好的 接下来让我们添加一些内边距

633
00:33:22,703 --> 0:33:24,438
从而避开这个边界

634
00:33:25,272 --> 0:33:27,074
再一次 我们可以使用修饰器来实现

635
00:33:28,475 --> 0:33:30,310
我们只需把它拖动到系统图片上即可

636
00:33:31,979 --> 0:33:34,481
看起来All Edges

637
00:33:35,649 --> 0:33:36,850
好的 很接近了

638
00:33:37,251 --> 0:33:40,654
但我真的很希望让这个图标

639
00:33:42,055 --> 0:33:44,825
我们可以通过把房间图片

640
00:33:44,892 --> 0:33:46,193
实现让视频图标在那里显示

641
00:33:47,127 --> 0:33:49,263
框架会伸展从而填充整个屏幕

642
00:33:50,063 --> 0:33:51,298
当它有空余空间时

643
00:33:51,365 --> 0:33:53,800
它会居中显示它的内容

644
00:33:54,735 --> 0:33:57,171
这意味着房间图片

645
00:33:58,205 --> 0:34:00,741
那么我要向图片中添加灵活性框架

646
00:33:58,205 --> 0:34:00,741
那么我要向图片中添加灵活性框架

647
00:34:03,177 --> 0:34:07,214
我们要使用最小宽度为零

648
00:34:08,849 --> 0:34:10,516
高度也一样

649
00:34:16,190 --> 0:34:17,123
好了

650
00:34:17,858 --> 0:34:20,860
如果你想了解关于

651
00:34:21,128 --> 0:34:23,362
请查看SwiftUI演讲中的

652
00:34:25,165 --> 0:34:26,266
现在我们有图标了

653
00:34:26,766 --> 0:34:29,603
但我们只希望

654
00:34:30,137 --> 0:34:31,205
那么我们该如何做呢？

655
00:34:32,105 --> 0:34:33,873
嗯 我们要用一个陈述性语法

656
00:34:34,074 --> 0:34:35,108
非常简单

657
00:34:35,576 --> 0:34:36,743
我们只需要使用一个if语句

658
00:34:37,610 --> 0:34:39,545
那么我要添加一个if语句并检查

659
00:34:40,013 --> 0:34:41,348
房间是否有视频会议

660
00:34:42,315 --> 0:34:44,284
只有当它为真时才会显示图片

661
00:34:46,652 --> 0:34:48,655
现在我们可以检查它是否是通过

662
00:34:48,722 --> 0:34:52,059
修改没有视频会议的房间的

663
00:34:52,559 --> 0:34:53,594
那很不错

664
00:34:54,127 --> 0:34:56,263
但如果我们可以同时设置预览

665
00:34:56,330 --> 0:34:58,632
来显示视频的多个版本更好

666
00:35:00,000 --> 0:35:03,504
为此 我只需要把这个视图

667
00:35:05,239 --> 0:35:07,107
现在这里有多个视图了

668
00:35:09,309 --> 0:35:10,844
那么让我们创建第二个版本…

669
00:35:12,045 --> 0:35:13,113
使用不同的测试数据

670
00:35:13,981 --> 0:35:17,117
现在一个版本是有视频会议的视图

671
00:35:17,751 --> 0:35:18,919
另一个版本是没有视频会议的视图

672
00:35:27,327 --> 0:35:28,595
现在让我们返回实时模式

673
00:35:31,231 --> 0:35:32,366
当我处于Zoom状态时

674
00:35:32,666 --> 0:35:35,335
那个图标显示在图片顶部

675
00:35:36,203 --> 0:35:38,472
所以让我们更新一下

676
00:35:39,306 --> 0:35:41,308
我们只需要更新就可以实现

677
00:35:47,481 --> 0:35:51,285
现在图标会在缩小和放大时

678
00:35:51,685 --> 0:35:54,087
但更好的是它在有动画效果

679
00:35:55,556 --> 0:35:57,691
并且我们还可以自定义动画行为

680
00:35:58,125 --> 0:35:59,660
通过把它设置为一个不同的转换

681
00:36:02,296 --> 0:36:05,399
让我们试试.move

682
00:36:07,901 --> 0:36:10,037
现在我们的图标会滑出和滑入

683
00:36:17,544 --> 0:36:19,379
让我把它变成一个长动画

684
00:36:19,947 --> 0:36:21,615
通过给自定义动画

685
00:36:22,182 --> 0:36:23,617
指定一个两秒的时长实现

686
00:36:25,352 --> 0:36:27,754
现在我们的动画更详细了

687
00:36:29,056 --> 0:36:31,058
并且我们还能看到

688
00:36:31,124 --> 0:36:32,459
当动画仍然在持续时

689
00:36:32,993 --> 0:36:34,428
它转了个方向并立即返回

690
00:36:35,596 --> 0:36:37,965
再一次 动画总是具有交互性

691
00:36:38,732 --> 0:36:41,034
并且我们可以一直轻触它

692
00:36:42,603 --> 0:36:43,704
那么这就是我们的详情视图

693
00:36:44,271 --> 0:36:45,606
让我们回顾一下

694
00:36:46,807 --> 0:36:49,710
我们的详情视图配置有一个

695
00:36:50,410 --> 0:36:52,079
请记住它是一个衍生值

696
00:36:52,145 --> 0:36:53,580
由父视图传入

697
00:36:54,848 --> 0:36:56,250
我们还有状态属性

698
00:36:56,884 --> 0:36:58,952
控制视图是否被缩小或放大

699
00:37:00,554 --> 0:37:01,989
并且由框架持续化

700
00:37:02,389 --> 0:37:03,724
并控制长宽比

701
00:37:06,293 --> 0:37:08,195
然后我们还有视频会议图标

702
00:37:09,296 --> 0:37:12,065
只有有视频会议的视图

703
00:37:12,132 --> 0:37:13,400
并且视图没被放大时才会显示

704
00:37:14,268 --> 0:37:16,170
我们还指定了它的转换方式

705
00:37:16,503 --> 0:37:17,938
图标滑入和滑出

706
00:37:19,273 --> 0:37:21,375
但在那个转换中到底发生了什么？

707
00:37:22,075 --> 0:37:23,610
嗯 当图标被移除时

708
00:37:24,411 --> 0:37:26,146
视频要动态地显示到新位置上

709
00:37:26,747 --> 0:37:29,349
并且SwiftUI会等待

710
00:37:29,716 --> 0:37:31,552
从而从等级中移除视图

711
00:37:32,619 --> 0:37:33,954
当图标再次显示时…

712
00:37:35,088 --> 0:37:36,790
SwiftUI在后台插入

713
00:37:36,857 --> 0:37:38,659
并以动画形式把它移回去

714
00:37:39,826 --> 0:37:42,329
我希望能长时间执行

715
00:37:42,396 --> 0:37:44,097
AddSubview和

716
00:37:44,464 --> 0:37:45,999
我们终于能实现了 我感到很激动

717
00:37:53,140 --> 0:37:55,442
回忆一下 动画总是具有交互性

718
00:37:55,509 --> 0:37:56,410
立等可用

719
00:37:57,144 --> 0:37:59,346
这就是成为数据驱动

720
00:37:59,413 --> 0:38:00,447
而不是事件驱动的闪光点

721
00:37:59,413 --> 0:38:00,447
而不是事件驱动的闪光点

722
00:38:00,514 --> 0:38:02,216
Kyle刚才谈到的全部事件

723
00:38:02,482 --> 0:38:03,817
都可能会发生 因为这个是动态的

724
00:38:04,451 --> 0:38:07,154
并且动画的开始和结束

725
00:38:07,888 --> 0:38:10,190
在事件驱动的世界中

726
00:38:10,257 --> 0:38:11,491
创建一个这样的动画非常困难

727
00:38:11,992 --> 0:38:13,894
但在SwiftUI中

728
00:38:17,030 --> 0:38:20,067
现在让我们返回到房间列表

729
00:38:23,937 --> 0:38:26,940
随时间流逝

730
00:38:27,441 --> 0:38:28,742
因此让我们添加一些编辑支持

731
00:38:29,710 --> 0:38:31,645
反正我们也在这里了

732
00:38:31,845 --> 0:38:32,679
变得更真实一些吧

733
00:38:33,514 --> 0:38:36,550
目前app中的数据是完全静态数据

734
00:38:38,418 --> 0:38:40,787
我们有这一组房间

735
00:38:40,854 --> 0:38:41,855
都是我们一直有的东西

736
00:38:42,856 --> 0:38:45,225
因此让我们更新模型

737
00:38:45,592 --> 0:38:48,262
容纳我们的房间并可以随时修改

738
00:38:50,097 --> 0:38:52,966
我要拖入一个预制模型文件

739
00:39:01,608 --> 0:39:04,144
请注意商店是一个可变的对象

740
00:39:04,411 --> 0:39:05,846
包含我们所需要的房间

741
00:39:06,580 --> 0:39:09,883
为此我们所需要做的全部操作就是

742
00:39:11,018 --> 0:39:13,787
为此 我要让它遵守

743
00:39:14,755 --> 0:39:16,857
它要求我拥有一个

744
00:39:23,030 --> 0:39:24,932
今年新增加了Combine框架

745
00:39:25,199 --> 0:39:26,867
它包含许多组件

746
00:39:26,934 --> 0:39:28,502
你可以用它把你的数据连接在一起

747
00:39:29,169 --> 0:39:31,238
在这里我们要使用

748
00:39:31,638 --> 0:39:33,173
它是来自Combine的

749
00:39:33,841 --> 0:39:36,476
为我们提供一个本地对象

750
00:39:36,543 --> 0:39:39,046
和给它发送更新 类似通知中心

751
00:39:41,982 --> 0:39:44,685
然后… 我们要更新房间…

752
00:39:46,086 --> 0:39:47,187
给它添加一个DidSet…

753
00:39:48,322 --> 0:39:50,557
从而使我们可以在房间发生变更时

754
00:39:55,295 --> 0:39:57,064
如果你有兴趣

755
00:39:57,130 --> 0:39:59,633
本周有两场演讲

756
00:40:01,301 --> 0:40:02,970
现在让我们返回到视图…

757
00:40:04,671 --> 0:40:05,873
并更新它 从而使用我们的商店

758
00:40:07,107 --> 0:40:09,943
我们要把这个Rooms属性

759
00:40:12,379 --> 0:40:13,814
我们要把它变成对象绑定的属性…

760
00:40:14,481 --> 0:40:16,984
从而告诉SwiftUI

761
00:40:17,918 --> 0:40:20,420
再一次 Kyle刚才提到的

762
00:40:20,487 --> 0:40:22,623
SwiftUI的数据流演讲有许多

763
00:40:22,689 --> 0:40:24,725
关于如何进行对象绑定

764
00:40:26,193 --> 0:40:28,829
让我们也更新一下预览

765
00:40:31,632 --> 0:40:32,733
使用我们的测试数据

766
00:40:34,568 --> 0:40:37,437
我们还要更新列表

767
00:40:39,973 --> 0:40:41,842
很棒 现在我们使用了新模型

768
00:40:41,909 --> 0:40:43,010
无论何时当它更新时

769
00:40:43,076 --> 0:40:44,578
视图都会创建一个新鲜的渲染

770
00:40:46,046 --> 0:40:47,948
这意味着我们已经准备好

771
00:40:48,815 --> 0:40:51,818
让我们从向列表中添加一个

772
00:40:53,220 --> 0:40:55,789
目前我们使用了单一集合来驱动列表

773
00:40:56,456 --> 0:40:58,559
对于完全是数据驱动的列表来说

774
00:40:59,159 --> 0:41:01,795
但当我需要更多时

775
00:40:59,159 --> 0:41:01,795
但当我需要更多时

776
00:41:02,062 --> 0:41:04,965
在列表中和其它容器中

777
00:41:06,633 --> 0:41:10,504
因此我可以用ForEach的集合

778
00:41:12,706 --> 0:41:15,475
ForEach为它的每个集合项

779
00:41:17,678 --> 0:41:21,215
因此现在我要在这个ForEach

780
00:41:22,716 --> 0:41:24,451
我要进入库并找到一个按钮

781
00:41:27,688 --> 0:41:30,624
然后我可以把它拖动到代码中

782
00:41:33,727 --> 0:41:35,762
让我们更新一下它的文本

783
00:41:37,130 --> 0:41:38,799
让我们添加一个新方法

784
00:41:43,504 --> 0:41:46,607
好的 我们要告诉Store

785
00:41:49,076 --> 0:41:50,677
就让我们使用我们所在的房间吧

786
00:41:52,513 --> 0:41:55,616
它叫做Hall 2

787
00:41:59,119 --> 0:42:02,055
最后 让我们更新按钮

788
00:41:59,119 --> 0:42:02,055
最后 让我们更新按钮

789
00:42:04,525 --> 0:42:06,760
好的 现在让我们进入实时模式

790
00:42:08,695 --> 0:42:10,230
它在那儿 就在数据旁边

791
00:42:11,031 --> 0:42:12,599
当我轻触它时 我们得到了新房间

792
00:42:13,500 --> 0:42:14,434
很棒

793
00:42:22,342 --> 0:42:25,212
那么就像那样

794
00:42:25,279 --> 0:42:26,947
在数据驱动的集合的旁边

795
00:42:27,981 --> 0:42:30,617
SwiftUI可以

796
00:42:31,285 --> 0:42:33,687
从而让创建复杂的列表UI

797
00:42:34,154 --> 0:42:35,756
再也不用担心索引路径报错了

798
00:42:38,892 --> 0:42:40,527
但我想调整一下它的样式

799
00:42:41,428 --> 0:42:43,797
让我们把Add按钮和全部内容

800
00:42:43,864 --> 0:42:44,865
都放到独立的分区中去

801
00:42:46,033 --> 0:42:47,601
我们可以修改列表的样式…

802
00:42:49,736 --> 0:42:50,637
让它分类显示…

803
00:42:53,473 --> 0:42:55,175
然后就有了这种

804
00:42:56,009 --> 0:42:58,946
然后我们要在按钮旁

805
00:43:02,583 --> 0:43:04,151
并在ForEach旁

806
00:43:07,354 --> 0:43:08,922
很棒 现在我们有独立的分区

807
00:43:10,591 --> 0:43:12,626
接下来让我们把删除与列表挂钩

808
00:43:13,694 --> 0:43:14,728
我们要添加一个方法…

809
00:43:16,463 --> 0:43:18,198
用来删除一组房间

810
00:43:18,999 --> 0:43:21,902
我们会传入一些

811
00:43:24,204 --> 0:43:25,606
然后我们就要告诉商店

812
00:43:26,540 --> 0:43:28,575
移除那些带有偏移量的房间

813
00:43:32,679 --> 0:43:36,283
然后我们在ForEach上添加

814
00:43:37,885 --> 0:43:41,388
并且我们可以向那个修饰器

815
00:43:43,123 --> 0:43:44,858
现在如果我们返回到实时模式中

816
00:43:46,860 --> 0:43:49,263
我们可以滑动其中一行并删除它

817
00:43:49,329 --> 0:43:50,163
就像那样

818
00:43:57,704 --> 0:44:00,607
这个ForEach现在的配置是

819
00:43:57,704 --> 0:44:00,607
这个ForEach现在的配置是

820
00:44:01,575 --> 0:44:03,610
无论何时当从中移除列表项时

821
00:44:04,411 --> 0:44:07,080
然后我们的回调函数就会

822
00:44:07,915 --> 0:44:08,916
然后视图更新

823
00:44:10,918 --> 0:44:12,986
好的 现在我们希望能把列表

824
00:44:13,053 --> 0:44:15,489
放在编辑模式中

825
00:44:16,456 --> 0:44:19,159
那么让我们设置一个导航栏项

826
00:44:19,626 --> 0:44:22,262
并且我们可以采用与设置导航栏

827
00:44:22,329 --> 0:44:23,363
用另一个修饰器

828
00:44:26,233 --> 0:44:27,434
并创建Edit按钮

829
00:44:27,768 --> 0:44:29,169
嗯 我们要创建一个Edit按钮

830
00:44:30,804 --> 0:44:31,905
它在那儿 在我们的UI中

831
00:44:33,140 --> 0:44:35,342
既然我们已经到这儿了

832
00:44:36,577 --> 0:44:39,880
再一次 我只需添加一个简单的方法

833
00:44:41,148 --> 0:44:42,583
我们要把它从源…

834
00:44:45,586 --> 0:44:46,620
移动到目的地

835
00:44:49,223 --> 0:44:51,358
我们只需调用

836
00:44:52,292 --> 0:44:53,227
并告诉它移动即可

837
00:44:57,331 --> 0:44:58,165
好的

838
00:44:58,632 --> 0:45:00,067
那么就跟以前一样

839
00:44:58,632 --> 0:45:00,067
那么就跟以前一样

840
00:45:00,367 --> 0:45:01,568
我们要添加另一个修饰器

841
00:45:01,635 --> 0:45:02,636
这次是Move

842
00:45:03,837 --> 0:45:06,340
并告诉它调用我们刚添加的方法

843
00:45:07,875 --> 0:45:09,276
现在让我们再次运行app

844
00:45:11,044 --> 0:45:12,513
我们可以切换列表的编辑模式

845
00:45:13,480 --> 0:45:16,149
请注意所有的数据行都有编辑控件

846
00:45:16,450 --> 0:45:17,451
但按钮却没有

847
00:45:18,151 --> 0:45:20,721
SwiftUI会在需要编辑控件的

848
00:45:21,421 --> 0:45:22,456
正确的位置上自动显示

849
00:45:22,956 --> 0:45:24,424
而我们不需要做任何额外的工作

850
00:45:27,227 --> 0:45:28,395
是的 很酷

851
00:45:30,864 --> 0:45:35,035
当然现在我们可以拖动来重排序

852
00:45:38,305 --> 0:45:39,206
谢谢

853
00:45:43,110 --> 0:45:44,811
那么让我们快速回顾一下

854
00:45:45,979 --> 0:45:48,582
我们自定义了列表使其显示多个分区

855
00:45:49,883 --> 0:45:51,485
并通过把它的列表样式设为

856
00:45:52,319 --> 0:45:53,687
并且我们把这个静态按钮

857
00:45:54,221 --> 0:45:56,990
与来自Rooms的数据驱动的集合

858
00:45:58,058 --> 0:46:00,394
我们还了解了

859
00:45:58,058 --> 0:46:00,394
我们还了解了

860
00:46:00,460 --> 0:46:02,462
向列表中迅速添加编辑操作

861
00:46:02,763 --> 0:46:04,698
以及几个修改数据的函数

862
00:46:06,500 --> 0:46:09,002
还记得我们之前是如何

863
00:46:09,837 --> 0:46:13,407
嗯 ForEach自动监测

864
00:46:13,841 --> 0:46:16,710
并合成正确的插入、删除

865
00:46:16,777 --> 0:46:17,711
和修改

866
00:46:18,111 --> 0:46:20,814
因此我们再也不用告诉列表

867
00:46:21,181 --> 0:46:22,416
这意味着我们再也不用担心

868
00:46:22,482 --> 0:46:24,551
数据源不一致异常了

869
00:46:26,353 --> 0:46:27,487
是 对

870
00:46:31,191 --> 0:46:32,192
那么这就是我们的列表

871
00:46:32,259 --> 0:46:34,228
我们仅通过这段非常少的视图代码

872
00:46:34,561 --> 0:46:36,763
制作了这整个复杂的列表UI

873
00:46:39,266 --> 0:46:42,436
好的 现在我们可以

874
00:46:43,237 --> 0:46:45,138
但你可能会想

875
00:46:45,205 --> 0:46:46,907
才能让它上线面对客户

876
00:46:47,708 --> 0:46:51,245
这些天、对动态类型的支持、

877
00:46:51,311 --> 0:46:53,881
这些都是app中所需要的东西

878
00:46:55,082 --> 0:46:58,285
但对于SwiftUI

879
00:46:59,086 --> 0:47:01,688
我们可以使用预览来进行

880
00:46:59,086 --> 0:47:01,688
我们可以使用预览来进行

881
00:47:02,890 --> 0:47:05,692
因此让我们打开预览

882
00:47:07,427 --> 0:47:10,330
再一次 我要添加一个群

883
00:47:12,332 --> 0:47:14,668
然后我要添加视图的另一个版本

884
00:47:16,403 --> 0:47:18,472
这一次我们要修改一下环境…

885
00:47:21,141 --> 0:47:25,546
使用一个尺寸类别

886
00:47:26,780 --> 0:47:27,814
让我们运行看看它是什么样子

887
00:47:28,248 --> 0:47:29,917
一切都很棒 都是自动的

888
00:47:31,785 --> 0:47:33,353
现在…是的

889
00:47:34,588 --> 0:47:35,756
我们能免费得到这些太好了

890
00:47:37,391 --> 0:47:40,561
现在环境是你

891
00:47:40,627 --> 0:47:43,197
情境信息与视图等级中的视图有关

892
00:47:43,263 --> 0:47:46,033
也是同时修改任意所包含的视图的

893
00:47:46,867 --> 0:47:49,002
修改大量视图很棒

894
00:47:49,436 --> 0:47:51,338
并且自定义预览也很棒

895
00:47:51,705 --> 0:47:53,240
可以在不同的情境中浏览视图

896
00:47:54,741 --> 0:47:56,476
让我们添加视图的另一个版本…

897
00:47:58,545 --> 0:47:59,713
并更新环境…

898
00:48:00,480 --> 0:48:02,482
把它的色系变成暗色

899
00:48:05,052 --> 0:48:06,520
一切都没问题

900
00:48:13,026 --> 0:48:15,229
最后 让我们再看看

901
00:48:15,295 --> 0:48:16,296
其它语种的app怎么样

902
00:48:17,598 --> 0:48:20,200
我有一些英文字符串文件

903
00:48:27,174 --> 0:48:29,009
并且我会告诉Xcode

904
00:48:34,114 --> 0:48:35,983
然后我进入我的项目文件…

905
00:48:38,051 --> 0:48:40,854
导出一个阿拉伯语的本地化文件

906
00:48:47,060 --> 0:48:48,262
现在让我们返回到视图中

907
00:48:48,562 --> 0:48:49,663
再添加一个预览

908
00:48:55,769 --> 0:49:00,140
现在如果我们先把布局方向

909
00:48:55,769 --> 0:49:00,140
现在如果我们先把布局方向

910
00:49:02,776 --> 0:49:05,245
我们可以看到它会自动生效

911
00:49:06,413 --> 0:49:08,282
但如果我把区域也设为…

912
00:49:11,518 --> 0:49:13,187
阿拉伯地区…

913
00:49:16,757 --> 0:49:18,425
你可以看到一切都被本地化了

914
00:49:26,233 --> 0:49:28,402
更棒的是 如果我们返回去看代码

915
00:49:28,669 --> 0:49:30,771
我们不需要任何额外的操作

916
00:49:31,505 --> 0:49:34,041
为了让文本可本地化

917
00:49:34,107 --> 0:49:35,776
哪些字符串需要进行本地化

918
00:49:36,276 --> 0:49:37,778
SwiftUI会自动推断

919
00:49:38,679 --> 0:49:41,949
对于使用字符串文字的文本

920
00:49:43,383 --> 0:49:45,485
对于那些通过传入字符串

921
00:49:45,919 --> 0:49:47,354
它默认就是按照原来的样子使用

922
00:49:48,222 --> 0:49:51,358
这意味着app的全部文本

923
00:49:51,692 --> 0:49:52,559
都能被本地化

924
00:49:53,060 --> 0:49:55,896
但我们的全部内容

925
00:49:56,697 --> 0:49:57,965
仍会被正确地传入

926
00:49:58,298 --> 0:50:01,168
但更好的是 你终于可以

927
00:49:58,298 --> 0:50:01,168
但更好的是 你终于可以

928
00:50:01,235 --> 0:50:02,569
并让它们正确地进行本地化

929
00:50:09,376 --> 0:50:11,144
我喜欢字符串插值 非常棒

930
00:50:12,746 --> 0:50:15,282
我们很期待你们通过SwiftUI

931
00:50:15,582 --> 0:50:17,551
你可以免费获得所有这些行为

932
00:50:17,618 --> 0:50:19,653
你可以着重关注app的独特部分

933
00:50:20,020 --> 0:50:22,055
并更快地为客户们创建更好的app

934
00:50:23,156 --> 0:50:24,625
我们在这里创建的是一个

935
00:50:25,259 --> 0:50:27,294
但你可以在全部Apple平台上

936
00:50:27,361 --> 0:50:28,729
使用同样的API和技巧

937
00:50:29,696 --> 0:50:31,431
并且你会在全部平台上

938
00:50:31,498 --> 0:50:32,432
获得诸如此类的自动化行为

939
00:50:33,934 --> 0:50:35,969
好的 让我们最后再看一次

940
00:50:36,036 --> 0:50:38,572
回顾一下我们创建了什么功能

941
00:50:39,907 --> 0:50:41,041
我是深色模式的忠实粉丝

942
00:50:41,441 --> 0:50:42,442
因此让我们使用深色模式

943
00:50:45,212 --> 0:50:46,547
好的 我们有房间列表

944
00:50:46,880 --> 0:50:48,081
我们可以轻触其中一项

945
00:50:48,549 --> 0:50:49,616
了解更多信息

946
00:50:50,450 --> 0:50:52,953
并且在详情视图中

947
00:50:53,287 --> 0:50:55,189
那会通过一个转换

948
00:50:55,956 --> 0:50:57,691
并且那个动画总是具有交互性

949
00:51:00,160 --> 0:51:02,729
并且我们还可以编辑列表做出修改

950
00:51:04,965 --> 0:51:06,033
让我们把这个移动到下边…

951
00:51:07,267 --> 0:51:09,770
我不认为有人会希望

952
00:51:13,640 --> 0:51:16,243
实际上我不确定Kyle为什么

953
00:51:16,310 --> 0:51:17,744
让我们把那个也去掉

954
00:51:18,779 --> 0:51:20,814
最后 让我们添加我们的会议室

955
00:51:21,715 --> 0:51:22,850
太棒了 这就是我们的app

956
00:51:30,190 --> 0:51:31,925
但我还要指出最后一点

957
00:51:31,992 --> 0:51:33,427
是我们没有看到的东西

958
00:51:33,961 --> 0:51:35,629
我们刚刚创建了整个app

959
00:51:35,996 --> 0:51:37,598
并测试了全部行为

960
00:51:37,965 --> 0:51:39,900
而一次也没有创建和运行app

961
00:51:40,601 --> 0:51:43,437
Xcode预览可以让我们浏览、

962
00:51:43,770 --> 0:51:45,472
比之前的速度更快

963
00:51:46,607 --> 0:51:47,708
那么谢谢大家

964
00:51:47,774 --> 0:51:49,710
我希望你们跟我一样

965
00:51:50,010 --> 0:51:50,844
很有意思

966
00:51:55,349 --> 0:51:59,553
那么我们对SwiftUI的目标是

967
00:51:59,620 --> 0:52:02,122
让你们创建

968
00:51:59,620 --> 0:52:02,122
让你们创建

969
00:52:03,223 --> 0:52:07,528
我们今天了解了SwiftUI的

970
00:52:07,794 --> 0:52:09,696
我们了解了它的陈述性语法

971
00:52:10,230 --> 0:52:13,066
可以唤起你所创建的UI

972
00:52:13,133 --> 0:52:15,035
并处理那些交互式细节

973
00:52:15,102 --> 0:52:16,637
比如以你的名义

974
00:52:16,937 --> 0:52:17,838
添加和移除子视图

975
00:52:18,472 --> 0:52:20,274
我们了解了组合

976
00:52:20,607 --> 0:52:23,243
以及如何把内容、修饰器和容器

977
00:52:23,310 --> 0:52:27,214
来创建你所期待的那个UI

978
00:52:28,348 --> 0:52:30,817
我们了解了你所得到的全部

979
00:52:31,151 --> 0:52:34,555
我们不需要做很多

980
00:52:35,255 --> 0:52:37,224
我们了解了SwiftUI如何

981
00:52:37,291 --> 0:52:39,626
让视图保持一致状态

982
00:52:39,927 --> 0:52:42,462
因此再也不会发生视图丢失

983
00:52:43,197 --> 0:52:45,265
当然了 我们还了解了

984
00:52:45,332 --> 0:52:47,134
很棒的可中断的动画

985
00:52:47,434 --> 0:52:49,336
那是我最喜欢的功能之一

986
00:52:49,403 --> 0:52:53,540
以前我总是感觉

987
00:52:53,941 --> 0:52:56,276
和随之而来的毁灭性的复杂度之间

988
00:52:56,343 --> 0:52:57,444
再也不会发生这种情况了

989
00:52:59,179 --> 0:53:01,915
SwiftUI的目标是 等一下

990
00:52:59,179 --> 0:53:01,915
SwiftUI的目标是 等一下

991
00:53:01,982 --> 0:53:02,883
它很酷 对吗？

992
00:53:03,350 --> 0:53:05,085
好的 SwiftUI的目标是

993
00:53:05,385 --> 0:53:06,987
以我们的名义替我们处理…

994
00:53:07,120 --> 0:53:11,425
每一个app都需要的基础功能

995
00:53:11,491 --> 0:53:13,060
因为当你创建app时

996
00:53:13,126 --> 0:53:15,329
你添加的并不只是基础功能

997
00:53:15,395 --> 0:53:18,131
你拥有特别的、独特的功能

998
00:53:18,198 --> 0:53:20,267
那样才能让app成为

999
00:53:21,068 --> 0:53:23,871
目标是替我们承担更多的责任

1000
00:53:24,438 --> 0:53:27,841
替我们分担每一个很棒的app

1001
00:53:29,076 --> 0:53:31,545
让你把时间更多地花在让你的app

1002
00:53:31,612 --> 0:53:32,713
变得更特别的东西上

1003
00:53:33,814 --> 0:53:37,518
我希望你们都喜欢

1004
00:53:37,751 --> 0:53:39,520
请参加我们的讨论会

1005
00:53:39,920 --> 0:53:42,089
我们今天下午会在那儿

1006
00:53:43,056 --> 0:53:45,726
我们还会主持其它演讲

1007
00:53:45,792 --> 0:53:47,060
和创建自定义视图

1008
00:53:47,127 --> 0:53:49,730
学习SwiftUI的下一站

1009
00:53:49,963 --> 0:53:51,832
应该是SwiftUI要领演讲

1010
00:53:52,099 --> 0:53:54,168
我们将会讲关于语法的方方面面

1011
00:53:54,535 --> 0:53:57,037
以及一切你可以组合在一起

1012
00:53:57,104 --> 0:53:58,539
让视图原汁原味地呈现的东西

1013
00:53:59,039 --> 0:54:00,374
那么我希望能在那里看到你们

1014
00:53:59,039 --> 0:54:00,374
那么我希望能在那里看到你们

1015
00:54:00,440 --> 0:54:04,311
希望大家度过一个愉快的WWDC
