1
00:00:00,506 --> 0:00:05,516
[音乐]

2
00:00:06,231 --> 0:00:08,231
[掌声]

3
00:00:08,446 --> 0:00:10,006
&gt;&gt; 我的名字是 Janum Trivedi

4
00:00:10,006 --> 0:00:11,466
我是 UIKit 框架团队的

5
00:00:11,496 --> 0:00:12,466
一名工程师

6
00:00:13,696 --> 0:00:15,666
首先 我们来谈一谈

7
00:00:15,666 --> 0:00:18,236
构建适用于多个窗口的 App

8
00:00:18,916 --> 0:00:20,786
在 iOS 13 中 支持多个窗口

9
00:00:20,786 --> 0:00:22,776
是一个很好的方法

10
00:00:22,776 --> 0:00:24,016
来使现有的 App 变得更有用

11
00:00:24,016 --> 0:00:26,006
同时大大提高

12
00:00:26,006 --> 0:00:27,556
用户的工作效率

13
00:00:30,056 --> 0:00:31,576
那么今天我们将讨论

14
00:00:31,576 --> 0:00:32,746
三个主要的话题

15
00:00:33,496 --> 0:00:34,666
首先 我们将会

16
00:00:34,666 --> 0:00:36,436
快速浏览一下

17
00:00:36,436 --> 0:00:38,176
对 App 生命周期的更改

18
00:00:38,226 --> 0:00:39,856
它将允许在 iOS 13 上

19
00:00:39,856 --> 0:00:41,236
出现多个窗口

20
00:00:42,456 --> 0:00:44,856
接着 我们会深入研究

21
00:00:44,856 --> 0:00:47,206
新的 UI Scene Delegate

22
00:00:47,206 --> 0:00:48,436
在那里我们还会讨论

23
00:00:48,436 --> 0:00:49,896
你需要完成的工作

24
00:00:50,486 --> 0:00:52,816
最后 我们会回顾一些

25
00:00:52,816 --> 0:00:54,386
ArchitectureKit 中的最佳范例

26
00:00:54,386 --> 0:00:55,346
这样你和你的团队就可以

27
00:00:55,346 --> 0:00:56,926
利用它们来保证

28
00:00:56,926 --> 0:00:57,906
可以给你的用户提供一个

29
00:00:57,906 --> 0:00:59,506
持续的 无缝的

30
00:00:59,506 --> 0:01:01,236
且多任务的体验

31
00:00:59,506 --> 0:01:01,236
且多任务的体验

32
00:01:01,796 --> 0:01:06,356
那么 首先让我们来看看

33
00:01:06,356 --> 0:01:07,866
在 iOS 12 及之前的版本中

34
00:01:07,866 --> 0:01:09,046
App 代理的一些

35
00:01:09,106 --> 0:01:10,976
作用和职责

36
00:01:10,976 --> 0:01:14,166
App 代理有两个主要的作用

37
00:01:14,166 --> 0:01:15,436
第一是将进程级事件

38
00:01:15,436 --> 0:01:17,716
通知给你的 App

39
00:01:18,046 --> 0:01:19,286
那么 系统会在进程

40
00:01:19,286 --> 0:01:20,476
启动或将要结束的时候

41
00:01:20,476 --> 0:01:22,656
通知你的 App 代理

42
00:01:23,256 --> 0:01:24,976
但它还有第二个作用

43
00:01:25,326 --> 0:01:26,846
就是让你的 App

44
00:01:26,846 --> 0:01:29,566
知道其 UI 的状态

45
00:01:31,266 --> 0:01:33,446
那么 通过一些方法

46
00:01:33,446 --> 0:01:34,776
如 didEnterForeground 和 willResignActive

47
00:01:34,776 --> 0:01:36,616
系统就会让你知道

48
00:01:36,616 --> 0:01:37,846
你的 UI 的状态

49
00:01:38,446 --> 0:01:41,586
这在 iOS 12 及之前的版本中

50
00:01:41,586 --> 0:01:42,666
都是没有问题的

51
00:01:42,906 --> 0:01:44,686
因为 App 有一个进程

52
00:01:44,686 --> 0:01:46,666
同时也只有一个用户界面实例

53
00:01:46,666 --> 0:01:48,366
来与它匹配

54
00:01:48,936 --> 0:01:51,096
那么 今天你的 App 代理

55
00:01:51,096 --> 0:01:53,976
可能看起来会像这样

56
00:01:53,976 --> 0:01:55,406
只是可能没这么短

57
00:01:55,406 --> 0:01:59,156
那么在 didFinishLaunchingWithOptions 中

58
00:01:59,156 --> 0:02:00,716
你完成了几件事

59
00:01:59,156 --> 0:02:00,716
你完成了几件事

60
00:02:00,716 --> 0:02:02,706
首先你完成了一些

61
00:02:02,706 --> 0:02:04,536
一次性的非 UI 全局设置

62
00:02:04,596 --> 0:02:05,856
比如连接到一个数据库

63
00:02:05,856 --> 0:02:07,376
或者初始化数据结构

64
00:02:07,996 --> 0:02:09,886
之后你立刻设置了

65
00:02:09,886 --> 0:02:11,136
你的用户界面

66
00:02:11,676 --> 0:02:14,756
而同样的 这在 iOS 12

67
00:02:14,756 --> 0:02:17,006
及之前的版本中完全有效

68
00:02:17,006 --> 0:02:18,156
但在 iOS 13 的模式中是无效的

69
00:02:18,956 --> 0:02:21,186
为什么呢 因为现在的 App

70
00:02:21,466 --> 0:02:23,176
虽然只共享一个进程

71
00:02:23,176 --> 0:02:25,026
但可能会有多个

72
00:02:25,026 --> 0:02:27,576
用户界面实例或场景会话

73
00:02:28,116 --> 0:02:32,406
这意味着 App 代理的职责

74
00:02:32,406 --> 0:02:33,846
需要做出一些改变

75
00:02:34,386 --> 0:02:35,496
它仍然会负责

76
00:02:35,496 --> 0:02:37,106
进程事件和生命周期

77
00:02:37,486 --> 0:02:38,796
但它不再负责任何

78
00:02:38,796 --> 0:02:40,756
与 UI 生命周期相关的事情

79
00:02:41,386 --> 0:02:43,186
相反 这些事情都将交给

80
00:02:43,456 --> 0:02:45,156
UI Scene Delegate 来处理

81
00:02:46,146 --> 0:02:47,716
那么 这对你来说意味着什么呢

82
00:02:48,346 --> 0:02:50,436
任何你曾在你的 App 代理中

83
00:02:50,436 --> 0:02:51,536
做过的 UI 设置或拆卸工作

84
00:02:51,536 --> 0:02:53,716
现在都需要迁移到

85
00:02:53,716 --> 0:02:56,076
Scene Delegate 中的相应方法

86
00:02:56,596 --> 0:02:59,986
事实上 在 iOS 13 中

87
00:02:59,986 --> 0:03:02,006
如果你的 App 采用新的

88
00:02:59,986 --> 0:03:02,006
如果你的 App 采用新的

89
00:03:02,006 --> 0:03:03,876
场景生命周期 那 UIKit

90
00:03:03,876 --> 0:03:05,276
将停止调用与 UI 状态相关的

91
00:03:05,276 --> 0:03:06,976
旧的 App 代理方法

92
00:03:07,686 --> 0:03:09,266
相反 我们将会调用新的

93
00:03:09,696 --> 0:03:11,806
Scene Delegate 方法

94
00:03:11,806 --> 0:03:12,936
这很简单 因为这些

95
00:03:13,406 --> 0:03:15,316
大多数都是一一对应的映射

96
00:03:16,246 --> 0:03:18,346
但是不要担心 如果你想要

97
00:03:18,346 --> 0:03:19,696
在 iOS 13 上采用多窗口支持

98
00:03:19,696 --> 0:03:21,146
这并不意味着你需要

99
00:03:21,146 --> 0:03:23,066
丢掉 iOS 12 及之前的支持

100
00:03:23,776 --> 0:03:25,366
如果你要向后部署

101
00:03:25,366 --> 0:03:26,676
你可以简单地将两组方法

102
00:03:26,676 --> 0:03:28,356
都保留下来 UIKit 就会

103
00:03:28,356 --> 0:03:30,586
在运行时调用正确的方法

104
00:03:31,106 --> 0:03:35,086
那么 在我们深入讨论

105
00:03:35,086 --> 0:03:36,886
具体的代理方法之前

106
00:03:36,886 --> 0:03:37,876
App 代理还有

107
00:03:37,876 --> 0:03:40,206
一个另外的职责

108
00:03:40,466 --> 0:03:41,756
即系统会通知

109
00:03:41,756 --> 0:03:43,436
你的 App 代理

110
00:03:43,436 --> 0:03:44,886
当创建一个新的场景会话

111
00:03:44,886 --> 0:03:48,176
或丢弃一个现有的场景会话时

112
00:03:48,176 --> 0:03:51,276
我们来将这个生命周期

113
00:03:51,326 --> 0:03:52,786
变得更具体一点

114
00:03:53,196 --> 0:03:54,316
假设我一直在做

115
00:03:54,316 --> 0:03:55,806
这个蓝色的 App 

116
00:03:55,806 --> 0:03:57,246
而现在我要首次将它启动

117
00:03:57,456 --> 0:03:58,556
我们来看看调用栈

118
00:03:59,606 --> 0:04:01,826
首先 你的 App 代理

119
00:03:59,606 --> 0:04:01,826
首先 你的 App 代理

120
00:04:01,826 --> 0:04:02,996
要进行相同的 

121
00:04:02,996 --> 0:04:04,016
didFinishLaunchingWithOptions 调用

122
00:04:04,246 --> 0:04:05,536
同样 在这里进行一次性的

123
00:04:05,536 --> 0:04:07,716
非 UI 设置 是没有问题的

124
00:04:08,276 --> 0:04:10,906
之后 系统会立即

125
00:04:10,906 --> 0:04:12,936
创建一个场景会话

126
00:04:13,906 --> 0:04:15,306
但在它创建具体的 UIScene 之前

127
00:04:15,306 --> 0:04:16,875
它会要求我们的 App

128
00:04:16,875 --> 0:04:19,685
进行 UIScene 配置

129
00:04:20,226 --> 0:04:21,946
这个配置会指定

130
00:04:22,156 --> 0:04:24,086
Scene Delegate 和 Storyboard

131
00:04:24,086 --> 0:04:25,606
以及假设你指定了

132
00:04:25,606 --> 0:04:27,106
你想要用什么场景子类

133
00:04:27,106 --> 0:04:28,116
来创建场景

134
00:04:29,366 --> 0:04:31,376
值得注意的是

135
00:04:31,376 --> 0:04:33,026
你可以定义

136
00:04:33,026 --> 0:04:34,046
这些场景配置

137
00:04:34,046 --> 0:04:36,136
可以动态地在代码中定义

138
00:04:36,136 --> 0:04:38,986
或静态地在 info.plist 中定义

139
00:04:40,326 --> 0:04:43,726
这也为你提供了选择正确的配置的机会

140
00:04:44,116 --> 0:04:45,266
你可以有一个主要的场景配置

141
00:04:45,266 --> 0:04:48,046
你也可以有一个附属场景

142
00:04:48,466 --> 0:04:49,306
那么 你应该看看

143
00:04:49,306 --> 0:04:50,466
这里提供的可选参数

144
00:04:50,466 --> 0:04:52,536
并将它作为上下文

145
00:04:52,536 --> 0:04:55,386
来选择正确的场景配置

146
00:04:55,886 --> 0:05:00,536
一旦你定义了这些

147
00:04:55,886 --> 0:05:00,536
一旦你定义了这些

148
00:05:00,536 --> 0:05:02,476
比如说在 info.plist 文件中

149
00:05:02,476 --> 0:05:04,136
这个很简单 你只需要按名称引用它

150
00:05:04,486 --> 0:05:06,436
确保你将传入的作用是

151
00:05:06,436 --> 0:05:08,196
引入的会话的作用

152
00:05:10,536 --> 0:05:12,886
好了 现在我们的 App 就启动了

153
00:05:13,146 --> 0:05:14,626
我们有一个场景会话

154
00:05:14,856 --> 0:05:16,026
但我们没有看到任何 UI

155
00:05:16,026 --> 0:05:17,606
这就是我们的 Scene Delegate

156
00:05:18,406 --> 0:05:21,066
连接到场景会话的地方

157
00:05:22,036 --> 0:05:23,406
我们来看看在这里

158
00:05:23,406 --> 0:05:23,966
我们应该做什么呢

159
00:05:23,966 --> 0:05:25,046
在这里 你用新指定的

160
00:05:25,046 --> 0:05:27,676
UI 窗口初始化器

161
00:05:27,756 --> 0:05:29,516
设置 UI 窗口

162
00:05:29,806 --> 0:05:31,126
我们会注意到我们传入了

163
00:05:31,126 --> 0:05:32,286
提供的窗口场景

164
00:05:32,976 --> 0:05:35,426
但重要的是我们还需要

165
00:05:35,426 --> 0:05:37,636
检查任何相关的

166
00:05:37,636 --> 0:05:40,626
用户活动或状态恢复

167
00:05:40,626 --> 0:05:42,806
以配置我们的窗口

168
00:05:43,376 --> 0:05:45,500
我们待会再详细讨论这个

169
00:05:47,046 --> 0:05:48,746
好 现在来看我们的 App

170
00:05:49,376 --> 0:05:50,856
那么 当我们的一个用户

171
00:05:50,856 --> 0:05:52,996
向上划动返回主页时会发生什么呢

172
00:05:54,426 --> 0:05:57,226
我们熟悉的 willResignActive

173
00:05:57,226 --> 0:05:58,746
和 didEnterBackground 方法

174
00:05:58,746 --> 0:06:01,306
会在你的 Scene Delegate 上被调用

175
00:05:58,746 --> 0:06:01,306
会在你的 Scene Delegate 上被调用

176
00:06:01,956 --> 0:06:03,266
但现在有一些有趣的事情

177
00:06:03,826 --> 0:06:05,586
在此之后的某个时刻

178
00:06:05,816 --> 0:06:07,456
你的场景可能会断开连接

179
00:06:07,736 --> 0:06:08,896
那么 这意味着什么呢

180
00:06:09,116 --> 0:06:10,276
好 为了回收资源

181
00:06:10,276 --> 0:06:13,036
系统可能会

182
00:06:13,036 --> 0:06:14,356
在你的场景

183
00:06:14,356 --> 0:06:15,826
进入后台的某个时候

184
00:06:15,826 --> 0:06:16,786
从内存中释放该场景

185
00:06:17,096 --> 0:06:18,616
这也意味着你的

186
00:06:18,616 --> 0:06:20,096
Scene Delegate 将会

187
00:06:20,386 --> 0:06:21,716
从内存中被释放

188
00:06:21,716 --> 0:06:23,206
而该代理中所持有的

189
00:06:23,436 --> 0:06:25,986
任何窗口层级或视图层级也将被释放

190
00:06:27,236 --> 0:06:29,126
这给你提供了机会

191
00:06:29,126 --> 0:06:31,016
来释放 App 中

192
00:06:31,016 --> 0:06:32,256
与此场景相关的 

193
00:06:32,256 --> 0:06:33,676
保留在其他地方的

194
00:06:33,676 --> 0:06:36,406
内存中的任何大型资源

195
00:06:37,276 --> 0:06:38,916
但是重要的是 不要用它

196
00:06:38,916 --> 0:06:40,336
来永久删除任何

197
00:06:40,336 --> 0:06:41,976
用户数据或状态

198
00:06:42,226 --> 0:06:43,926
因为该场景稍后可能会

199
00:06:43,926 --> 0:06:44,726
重新连接并返回

200
00:06:48,236 --> 0:06:49,966
接着我们讨论一下

201
00:06:49,966 --> 0:06:51,996
当我们的用户真的

202
00:06:51,996 --> 0:06:53,966
在切换器上上划一个场景会话

203
00:06:53,966 --> 0:06:55,436
并明确地想要销毁它时

204
00:06:55,436 --> 0:06:57,526
会发生什么呢

205
00:06:57,746 --> 0:06:59,326
那么 系统会调用我们的

206
00:06:59,326 --> 0:07:01,716
App 代理 didDiscardSceneSessions

207
00:06:59,326 --> 0:07:01,716
App 代理 didDiscardSceneSessions

208
00:07:04,016 --> 0:07:06,556
这让我们终于能够真正永久地

209
00:07:06,556 --> 0:07:08,106
代理任何与该场景有关的

210
00:07:08,106 --> 0:07:09,296
用户状态或数据

211
00:07:09,296 --> 0:07:11,326
比如一个文档编辑 App 中

212
00:07:11,326 --> 0:07:13,306
未保存的草稿

213
00:07:14,086 --> 0:07:16,176
现在 也有可能

214
00:07:16,176 --> 0:07:17,856
你的一个用户从切换器中

215
00:07:17,856 --> 0:07:19,356
移除了一个或多个 UI 场景

216
00:07:19,356 --> 0:07:21,176
通过在你的 App 进程

217
00:07:21,176 --> 0:07:22,446
还未真正运行时向上划动

218
00:07:23,316 --> 0:07:24,586
如果你的进程还没有运行

219
00:07:24,586 --> 0:07:25,746
系统就会记录下

220
00:07:25,746 --> 0:07:27,536
被丢弃的会话

221
00:07:27,536 --> 0:07:28,516
在你的 App 下次启动后

222
00:07:28,516 --> 0:07:29,796
快速调用该会话

223
00:07:34,726 --> 0:07:36,136
现在 我们来讨论一些

224
00:07:36,136 --> 0:07:37,616
构建模式 你可以考虑

225
00:07:37,616 --> 0:07:39,346
将它们融入你的 App 中

226
00:07:39,886 --> 0:07:44,476
我们首先来说说状态恢复

227
00:07:45,786 --> 0:07:48,086
在 iOS 13 中 状态恢复

228
00:07:48,086 --> 0:07:49,536
不再是一个好东西

229
00:07:50,136 --> 0:07:52,216
至关重要的是

230
00:07:52,216 --> 0:07:53,416
你的 App 要实现

231
00:07:53,416 --> 0:07:55,206
基于场景的状态恢复

232
00:07:55,926 --> 0:07:57,126
我们来看看这是为什么

233
00:07:58,426 --> 0:07:59,286
这是我们的 App 切换器

234
00:07:59,406 --> 0:08:01,286
我有一个文档 App

235
00:07:59,406 --> 0:08:01,286
我有一个文档 App

236
00:08:01,286 --> 0:08:02,356
我正在计划一次自驾游

237
00:08:02,436 --> 0:08:03,416
我现在打开了四个

238
00:08:03,416 --> 0:08:04,756
不同文档的不同会话

239
00:08:05,716 --> 0:08:07,006
但是我真正关注的

240
00:08:07,236 --> 0:08:08,506
是“行李清单”和“日程安排”

241
00:08:09,556 --> 0:08:12,176
在某一时刻 另外两个

242
00:08:12,176 --> 0:08:13,226
在后台上的“自驾游”

243
00:08:13,226 --> 0:08:14,486
和“出席者”的场景

244
00:08:14,486 --> 0:08:16,616
已经被系统断开连接并释放

245
00:08:17,466 --> 0:08:18,896
如果我在这里

246
00:08:18,896 --> 0:08:20,886
不实现状态恢复的话

247
00:08:20,886 --> 0:08:21,896
当我回到“自驾游”时

248
00:08:21,896 --> 0:08:23,546
我就不会回到之前

249
00:08:23,546 --> 0:08:24,256
所在的状态

250
00:08:24,256 --> 0:08:25,056
我不会回到我之前

251
00:08:25,056 --> 0:08:26,336
正在编辑的文档的场景

252
00:08:27,136 --> 0:08:28,176
而是会直接重新开始

253
00:08:28,176 --> 0:08:29,296
就像打开一个全新的窗口

254
00:08:29,296 --> 0:08:31,776
但这并不是一个很好的用户体验

255
00:08:33,196 --> 0:08:34,275
那么 如何解决这个问题呢

256
00:08:34,946 --> 0:08:36,645
iOS 13 有一个全新的

257
00:08:37,346 --> 0:08:39,806
基于场景的状态恢复的 API

258
00:08:40,155 --> 0:08:41,576
它非常简单

259
00:08:42,816 --> 0:08:47,486
就是不再对视图层级进行编码

260
00:08:47,606 --> 0:08:49,496
而是对允许重新

261
00:08:49,496 --> 0:08:51,996
创建窗口的状态进行编码

262
00:08:54,356 --> 0:08:56,946
这也全部都基于 NSUserActivity

263
00:08:56,946 --> 0:08:57,856
因此 如果你的 App

264
00:08:57,856 --> 0:08:59,376
利用了功能强大的技术

265
00:08:59,376 --> 0:09:00,696
比如聚焦搜索或接力

266
00:08:59,376 --> 0:09:00,696
比如聚焦搜索或接力

267
00:09:00,696 --> 0:09:02,336
那你就可以用这些相同的活动

268
00:09:02,336 --> 0:09:04,136
来对你 App 的状态进行编码

269
00:09:04,796 --> 0:09:06,076
我们也要注意

270
00:09:06,076 --> 0:09:08,196
在 iOS 13 中 你返回给

271
00:09:08,196 --> 0:09:09,646
系统的状态恢复存档

272
00:09:09,646 --> 0:09:13,236
将会匹配 App 中的其余部分的

273
00:09:13,236 --> 0:09:14,336
相同数据保护类

274
00:09:17,756 --> 0:09:20,906
这在代码中是怎样的呢

275
00:09:20,906 --> 0:09:22,156
那么 在我们的 Scene Delegate 中

276
00:09:22,156 --> 0:09:23,356
我们实现场景的

277
00:09:23,356 --> 0:09:25,796
状态恢复活动

278
00:09:25,796 --> 0:09:29,346
然后我调用一个方法

279
00:09:29,346 --> 0:09:31,506
来在现有的窗口中寻找

280
00:09:31,506 --> 0:09:33,496
最活跃的相关用户活动表

281
00:09:34,046 --> 0:09:35,526
然后我们回到该表

282
00:09:36,276 --> 0:09:38,366
过一些时候 当该场景

283
00:09:38,366 --> 0:09:41,746
重新进入前台且连接成功时

284
00:09:41,746 --> 0:09:43,176
我们检查该会话是否含有一个

285
00:09:43,176 --> 0:09:44,286
状态恢复活动

286
00:09:44,896 --> 0:09:47,076
如果有 我们就用该活动

287
00:09:47,586 --> 0:09:48,656
如果没有 我们可以创建一个

288
00:09:48,656 --> 0:09:50,776
全新的没有任何状态的窗口

289
00:09:51,886 --> 0:09:53,546
这意味着无论如何

290
00:09:54,026 --> 0:09:55,396
当场景在后台断开连接时

291
00:09:55,396 --> 0:09:57,026
我们的用户永远不会注意到

292
00:09:57,026 --> 0:09:58,626
因为这不应该被注意到

293
00:10:00,856 --> 0:10:03,156
最后 我们来说说

294
00:10:03,156 --> 0:10:05,346
在采用多个窗口的支持时

295
00:10:05,346 --> 0:10:06,816
你可能会遇到的

296
00:10:06,816 --> 0:10:08,026
一个更重要的问题

297
00:10:08,196 --> 0:10:09,756
也就是如何最大程度地

298
00:10:09,756 --> 0:10:11,496
保持 App 场景的同步

299
00:10:11,496 --> 0:10:13,656
让我来把它具体化

300
00:10:13,796 --> 0:10:15,256
我一直在做一个新的

301
00:10:15,256 --> 0:10:17,396
聊天 App 就在这里

302
00:10:17,396 --> 0:10:18,866
而我们可以看到

303
00:10:18,866 --> 0:10:20,456
我最近刚在 iOS 13 上添加了

304
00:10:20,456 --> 0:10:21,236
对多个窗口的支持

305
00:10:22,636 --> 0:10:23,666
我有一个与我的朋友

306
00:10:23,666 --> 0:10:25,786
Giovanni 的聊天

307
00:10:25,786 --> 0:10:27,086
几分钟后他将和我一起上台

308
00:10:27,736 --> 0:10:28,896
注意 我们正在同时

309
00:10:28,896 --> 0:10:30,046
查看相同的对话

310
00:10:30,046 --> 0:10:31,076
在两个不同的视图控制器

311
00:10:31,076 --> 0:10:32,886
及两个不同的场景中

312
00:10:34,036 --> 0:10:35,276
那么 我们假设我要

313
00:10:35,276 --> 0:10:36,826
给 Giovanni 发送一条信息

314
00:10:36,826 --> 0:10:37,846
告诉他我准备好吃午饭了

315
00:10:39,056 --> 0:10:41,376
那么 只有一个场景更新了

316
00:10:42,176 --> 0:10:43,706
所以这是为什么呢

317
00:10:44,876 --> 0:10:46,816
好 这是因为在 iOS 中

318
00:10:46,816 --> 0:10:47,976
许多 App 的结构都是这样

319
00:10:47,976 --> 0:10:49,486
视图控制器会

320
00:10:49,486 --> 0:10:51,026
接收一个事件

321
00:10:51,446 --> 0:10:52,766
可能是通过点击按钮

322
00:10:52,766 --> 0:10:53,846
即我按下发送按钮

323
00:10:54,426 --> 0:10:56,086
然后视图控制器本就

324
00:10:56,086 --> 0:10:57,786
就会更新它自己的 UI

325
00:10:58,716 --> 0:11:00,166
之后 我们的视图控制器

326
00:10:58,716 --> 0:11:00,166
之后 我们的视图控制器

327
00:11:00,166 --> 0:11:02,436
会通知模型或模型控制器

328
00:11:02,436 --> 0:11:05,266
而当我们只讨论

329
00:11:05,266 --> 0:11:07,046
一个用户界面实例时

330
00:11:07,046 --> 0:11:07,856
这基本上是没问题的

331
00:11:08,466 --> 0:11:10,146
但现在如果我们在一个

332
00:11:10,796 --> 0:11:11,816
显示相同数据的不同场景中

333
00:11:11,816 --> 0:11:13,166
引入第二个视图控制器

334
00:11:13,166 --> 0:11:15,296
那么无论什么时候

335
00:11:15,296 --> 0:11:16,666
这个新的视图控制器都不会

336
00:11:16,906 --> 0:11:18,916
收到通知来更新这个新数据

337
00:11:19,816 --> 0:11:20,446
这是一个问题

338
00:11:20,966 --> 0:11:24,556
那么我们可以解决这个问题

339
00:11:24,606 --> 0:11:25,976
在架构上 如果我们的

340
00:11:25,976 --> 0:11:27,186
视图控制器能够

341
00:11:27,186 --> 0:11:29,536
在接收到一个事件后

342
00:11:29,536 --> 0:11:31,356
立即并且只通知

343
00:11:31,736 --> 0:11:32,986
我们的模型控制器 

344
00:11:32,986 --> 0:11:35,416
那我们就可以让模型控制器

345
00:11:35,416 --> 0:11:36,686
通知任何相关的订阅者

346
00:11:36,686 --> 0:11:37,946
或者视图控制器

347
00:11:37,946 --> 0:11:39,996
来更新这个新数据

348
00:11:41,416 --> 0:11:43,196
有许多方法都可以完成这个

349
00:11:43,196 --> 0:11:45,046
我们可以使用代理和通知

350
00:11:45,376 --> 0:11:46,696
我们甚至可以用全新的

351
00:11:46,696 --> 0:11:48,836
今年发布的 Swift Combine 框架

352
00:11:49,716 --> 0:11:51,116
但我们先来看一个

353
00:11:51,116 --> 0:11:52,526
简单的 Swift 示例

354
00:11:52,526 --> 0:11:54,096
你可以考虑将其整合进你的 App 中

355
00:11:54,666 --> 0:11:55,976
这是现在的方法

356
00:11:55,976 --> 0:11:57,356
当我在发送信息时按下

357
00:11:57,566 --> 0:11:59,336
返回键时 它就会被调用

358
00:11:59,936 --> 0:12:01,426
我创建了一个信息模型对象

359
00:11:59,936 --> 0:12:01,426
我创建了一个信息模型对象

360
00:12:02,056 --> 0:12:03,306
我的视图控制器更新

361
00:12:03,306 --> 0:12:03,866
其自己的视图

362
00:12:04,446 --> 0:12:07,096
接着我们通知模型控制器

363
00:12:07,096 --> 0:12:08,746
来保存这个

364
00:12:09,286 --> 0:12:11,056
我们首先要做的

365
00:12:11,056 --> 0:12:11,916
就是让该视图控制器

366
00:12:12,236 --> 0:12:14,406
不改变它自己的视图状态

367
00:12:14,886 --> 0:12:16,646
相反 我们要去掉这些代码

368
00:12:16,746 --> 0:12:18,836
稍后我们会把它加回去

369
00:12:20,846 --> 0:12:22,706
现在 我们来看看

370
00:12:22,706 --> 0:12:25,446
该模型控制器 add() 方法到底在做什么

371
00:12:25,446 --> 0:12:26,576
其实很简单

372
00:12:27,206 --> 0:12:28,406
我们要做的就是

373
00:12:28,406 --> 0:12:29,176
保存该新消息

374
00:12:30,096 --> 0:12:31,286
但实际上我们想让

375
00:12:31,286 --> 0:12:33,556
模型控制器立刻进行通知

376
00:12:33,556 --> 0:12:34,526
如果任何其他视图控制器

377
00:12:34,526 --> 0:12:36,476
或连接的场景需要的更新的话

378
00:12:39,496 --> 0:12:41,186
我们如何发送这个更新呢

379
00:12:41,636 --> 0:12:43,936
我们需要一种结构化的方法

380
00:12:43,936 --> 0:12:46,276
来打包这个事件

381
00:12:46,276 --> 0:12:49,366
这样它就成为强类型

382
00:12:49,616 --> 0:12:51,166
且易于调试和测试

383
00:12:51,446 --> 0:12:52,576
那么 我们来继续创建

384
00:12:52,576 --> 0:12:54,116
一个新的类型

385
00:12:54,116 --> 0:12:55,206
我们称之为 UpdateEvent

386
00:12:55,206 --> 0:12:57,536
它是一个带有相关值的 Swift 枚举

387
00:12:58,066 --> 0:13:00,026
我们将添加一个新的消息类型

388
00:12:58,066 --> 0:13:00,026
我们将添加一个新的消息类型

389
00:13:00,676 --> 0:13:02,276
这是我们的模型控制器

390
00:13:02,276 --> 0:13:03,506
将要在接收新的消息时

391
00:13:03,506 --> 0:13:04,836
创建的对象

392
00:13:04,836 --> 0:13:06,626
然后会发送给任何的

393
00:13:06,626 --> 0:13:08,456
相关的视图控制器或场景

394
00:13:09,656 --> 0:13:10,896
因为我们想发送这个

395
00:13:10,896 --> 0:13:12,496
我们将用 NSNotificationCenter

396
00:13:12,716 --> 0:13:14,076
作为这个的备份存储

397
00:13:14,076 --> 0:13:15,826
因此 我们会添加这个便利的

398
00:13:15,826 --> 0:13:17,636
post() 方法 它允许我们在一行中

399
00:13:17,846 --> 0:13:19,286
创建一个新的更新事件

400
00:13:19,286 --> 0:13:20,896
然后将其发送给任何订阅者

401
00:13:21,456 --> 0:13:25,166
实现这个相当简单

402
00:13:25,236 --> 0:13:27,006
我们只要发送一个通知

403
00:13:27,006 --> 0:13:29,646
到新消息的通知名称通道

404
00:13:30,126 --> 0:13:31,376
但这里的技巧是

405
00:13:31,376 --> 0:13:32,696
我们要将更新事件对象本身

406
00:13:32,926 --> 0:13:35,766
包含在通知对象中

407
00:13:35,766 --> 0:13:37,096
这会派上用场

408
00:13:37,096 --> 0:13:41,446
我们很快就会看到

409
00:13:41,576 --> 0:13:42,956
现在 当我们的模型控制器

410
00:13:42,956 --> 0:13:44,166
被通知添加了一个新消息时

411
00:13:44,166 --> 0:13:45,926
在我们保存它之后

412
00:13:46,196 --> 0:13:47,166
我们就可以创建这个新事件

413
00:13:47,166 --> 0:13:49,066
并调用 post()

414
00:13:51,546 --> 0:13:53,466
接着 如果我们看看

415
00:13:53,496 --> 0:13:54,696
要如何改变我们的视图控制器

416
00:13:55,436 --> 0:13:57,396
我们会注意到这个新事件

417
00:13:57,676 --> 0:13:59,836
在本例里 就是新消息通知名称

418
00:14:00,286 --> 0:14:03,366
然后我们创建一个 handler() 方法

419
00:14:03,366 --> 0:14:06,066
从参数中获取通知

420
00:14:06,816 --> 0:14:08,126
记住 当我们将更新事件

421
00:14:08,126 --> 0:14:12,426
作为通知对象进行传递时

422
00:14:12,546 --> 0:14:14,076
我们现在就可以从通知中

423
00:14:14,076 --> 0:14:15,426
直接拉出该事件

424
00:14:15,946 --> 0:14:18,736
然后我们可以很容易地

425
00:14:18,736 --> 0:14:20,506
打开这种事件类型情况

426
00:14:21,796 --> 0:14:22,886
因为我们创建了一个相关枚举

427
00:14:22,886 --> 0:14:26,726
我们就可以把信息拉出来

428
00:14:26,986 --> 0:14:29,326
现在 我们可以更新这里的用户界面

429
00:14:32,536 --> 0:14:33,736
那么 让我们来看看

430
00:14:33,736 --> 0:14:34,896
在实现这个新的构架之后

431
00:14:34,896 --> 0:14:37,496
当我向 Giovanni 发送相同的消息时会发生什么呢

432
00:14:38,196 --> 0:14:39,696
好了 所有的场景都更新了

433
00:14:41,516 --> 0:14:45,876
[掌声]

434
00:14:46,376 --> 0:14:47,866
那么 我们今天讲了很多

435
00:14:48,076 --> 0:14:48,976
我们已经讲了一些

436
00:14:48,976 --> 0:14:51,736
App 代理和 Scene Delegate 的不同

437
00:14:51,736 --> 0:14:53,296
及其职责的不同

438
00:14:53,696 --> 0:14:54,806
我们之前还说了一些

439
00:14:54,806 --> 0:14:57,586
主要的 Scene Delegate 方法

440
00:14:57,586 --> 0:14:59,066
及你应该做的工作

441
00:15:00,156 --> 0:15:01,306
我们也讨论了为什么

442
00:15:01,306 --> 0:15:02,736
状态恢复在你使用

443
00:15:02,736 --> 0:15:04,616
iOS 13 时是如此的重要

444
00:15:04,616 --> 0:15:06,726
以及如何利用新的

445
00:15:06,896 --> 0:15:07,926
基于场景的 API 来完成它

446
00:15:08,606 --> 0:15:11,166
最后 我们说了一些

447
00:15:11,166 --> 0:15:12,596
创建一个单向数据流的

448
00:15:12,596 --> 0:15:14,066
高级的模式 这样我们

449
00:15:14,066 --> 0:15:15,296
就可以在共享相同的数据时

450
00:15:15,296 --> 0:15:17,716
保持所有的场景同步 谢谢

451
00:15:19,508 --> 0:15:21,508
[掌声]
