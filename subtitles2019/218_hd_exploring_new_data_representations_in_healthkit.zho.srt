1
00:00:06,139 --> 0:00:09,843
（在HealthKit中

2
00:00:12,212 --> 0:00:13,146
下午好

3
00:00:13,914 --> 0:00:15,249
我是Luke Spicer

4
00:00:15,315 --> 0:00:17,117
今天我和我的同事Divya

5
00:00:17,184 --> 0:00:20,454
要与大家分享HealthKit

6
00:00:20,521 --> 0:00:22,756
如何在iOS 13中扩展数据表达

7
00:00:25,192 --> 0:00:26,660
有许多人已经知道

8
00:00:27,027 --> 0:00:31,098
HealthKit针对健康和健身

9
00:00:31,598 --> 0:00:35,235
并且还为健康和健身app和体验

10
00:00:36,370 --> 0:00:38,872
如果你还不了解

11
00:00:39,239 --> 0:00:42,476
让我来提醒你一下

12
00:00:42,543 --> 0:00:44,578
健康与健身类中

13
00:00:44,978 --> 0:00:48,081
并且它们均可

14
00:00:48,148 --> 0:00:50,117
互操作性和功能性中受益

15
00:00:51,652 --> 0:00:53,287
今天我要讲一些

16
00:00:53,353 --> 0:00:55,155
数据表达相关的信息

17
00:00:55,889 --> 0:00:58,158
从回顾HealthKit

18
00:00:58,225 --> 0:00:59,059
（HealthKit数据模型）

19
00:00:59,126 --> 0:01:02,329
然后我要讲一些

20
00:00:59,126 --> 0:01:02,329
然后我要讲一些

21
00:01:03,664 --> 0:01:06,433
稍后Divya会上台

22
00:01:06,834 --> 0:01:07,835
心率事件

23
00:01:08,569 --> 0:01:11,572
和有关听力健康的全新的API

24
00:01:13,207 --> 0:01:16,310
让我们从HealthKit

25
00:01:17,945 --> 0:01:19,646
在HealthKit中

26
00:01:21,215 --> 0:01:23,317
在HealthKit中

27
00:01:23,884 --> 0:01:26,186
样本是在特定时间所进行的测量

28
00:01:26,553 --> 0:01:28,222
有一定的时间跨度

29
00:01:29,656 --> 0:01:32,759
绝大多数测量都是简单测量

30
00:01:33,160 --> 0:01:35,429
比如通过

31
00:01:36,530 --> 0:01:40,300
或通过已连接的Bluetooth

32
00:01:42,503 --> 0:01:44,605
其它测量更加丰富和复杂

33
00:01:45,038 --> 0:01:47,207
比如锻炼或临床病例

34
00:01:47,274 --> 0:01:49,176
可直接下载到iPhone上

35
00:01:51,645 --> 0:01:55,215
所有这些丰富的、复杂的数据表达

36
00:01:55,282 --> 0:01:56,350
都共享一个通用结构

37
00:01:56,817 --> 0:02:00,087
最高层级的样本

38
00:01:56,817 --> 0:02:00,087
最高层级的样本

39
00:02:01,188 --> 0:02:02,222
比如…

40
00:02:03,557 --> 0:02:06,960
血压测量可以表达为一个相关样本

41
00:02:07,528 --> 0:02:09,830
过敏资源来自病例

42
00:02:10,564 --> 0:02:13,567
健身路线来自一系列样本

43
00:02:14,134 --> 0:02:16,737
这些都是专业样本类型的示例

44
00:02:17,137 --> 0:02:19,540
都有各自独特的备份数据格式

45
00:02:20,641 --> 0:02:22,509
比如血压相关样本

46
00:02:22,576 --> 0:02:24,011
是一组血压测量

47
00:02:24,578 --> 0:02:26,947
过敏资源依赖于文件资源

48
00:02:28,282 --> 0:02:30,817
健身路线是CL位置数据的一个数组

49
00:02:31,618 --> 0:02:34,988
正因为HealthKit

50
00:02:35,055 --> 0:02:36,557
提供这些专业数据表达

51
00:02:37,191 --> 0:02:39,893
我们也针对最常见的测量类型

52
00:02:39,960 --> 0:02:41,461
对数据表达进行了扩展

53
00:02:41,828 --> 0:02:42,796
适用于量化数据

54
00:02:43,430 --> 0:02:45,933
我们继续讲一下量化数据

55
00:02:45,999 --> 0:02:47,301
（新的量化系列API）

56
00:02:48,502 --> 0:02:49,570
快速回顾一下

57
00:02:49,937 --> 0:02:53,540
HealthKit中的量化数据

58
00:02:54,908 --> 0:02:56,176
比如步行距离、

59
00:02:56,543 --> 0:02:58,145
身体质量和心率

60
00:02:59,046 --> 0:03:02,015
我们把所有这些概念

61
00:02:59,046 --> 0:03:02,015
我们把所有这些概念

62
00:03:02,816 --> 0:03:04,785
它们的测量看起来类似这样

63
00:03:06,720 --> 0:03:10,357
每个测量都包含一个量化数据

64
00:03:10,724 --> 0:03:13,160
和一个单位 以及一个时间区间

65
00:03:13,227 --> 0:03:15,629
那表明测量所发生的时间区间

66
00:03:16,496 --> 0:03:18,732
我们把每一个这样的测量

67
00:03:20,400 --> 0:03:22,536
根据这个描述 我们要讲

68
00:03:23,303 --> 0:03:25,005
量化类型和量化样本

69
00:03:25,305 --> 0:03:27,908
特别是如何有效地表达

70
00:03:27,975 --> 0:03:29,142
大量的量化数据

71
00:03:29,676 --> 0:03:31,712
但如果你想了解

72
00:03:32,045 --> 0:03:34,581
请参看我们2014年的演讲

73
00:03:34,982 --> 0:03:36,049
关于HealthKit的介绍

74
00:03:37,317 --> 0:03:38,886
为了继续推进我们对量化数据的讨论

75
00:03:38,952 --> 0:03:40,020
我想描述一个情境

76
00:03:40,988 --> 0:03:43,090
如果可以 请你想象一下

77
00:03:43,156 --> 0:03:45,092
我们正在做一个全新的app

78
00:03:45,926 --> 0:03:48,762
这个app连接了一个

79
00:03:49,029 --> 0:03:51,131
它被嵌入了一个视频游戏控制器中

80
00:03:52,132 --> 0:03:54,835
我们的任务是

81
00:03:54,902 --> 0:03:56,069
并把它们保存到

82
00:03:56,136 --> 0:03:58,138
从而用户可以了解他们的心率是多少

83
00:03:58,205 --> 0:03:59,806
当他们玩任意一款游戏时

84
00:04:01,875 --> 0:04:03,744
我们从传感器中收到的心率

85
00:04:03,810 --> 0:04:05,179
看起来就像这样

86
00:04:05,245 --> 0:04:07,548
一系列测量数据

87
00:04:07,814 --> 0:04:09,149
当用户玩游戏时

88
00:04:09,816 --> 0:04:11,952
我们需要决定如何表达这个数据

89
00:04:12,219 --> 0:04:13,353
我们可以把它

90
00:04:14,655 --> 0:04:15,956
我们可以采用的一种方法是

91
00:04:16,023 --> 0:04:18,125
使用单一量化样本

92
00:04:18,825 --> 0:04:20,327
看起来就像这样

93
00:04:21,394 --> 0:04:24,198
这个单一量化样本

94
00:04:24,631 --> 0:04:26,667
就是游戏的整个时长

95
00:04:27,067 --> 0:04:29,002
并通过单一量化来表达

96
00:04:29,069 --> 0:04:30,571
我们从传感器中接收的全部测量数据

97
00:04:30,938 --> 0:04:31,905
也许是平均值

98
00:04:33,273 --> 0:04:35,142
这个表达为我们提供了一个对象

99
00:04:35,742 --> 0:04:38,545
来表达我们所获取的测量数据

100
00:04:39,213 --> 0:04:42,282
但如果稍后我们想了解

101
00:04:42,349 --> 0:04:44,785
我们就没办法通过这种表达来实现

102
00:04:46,420 --> 0:04:47,955
我们可以采取的另一种表达是

103
00:04:48,322 --> 0:04:51,859
使用多个量化样本 看起来就像这样

104
00:04:52,459 --> 0:04:55,629
每一个测量都表达不同的量化样本

105
00:04:56,697 --> 0:04:59,566
这种表达允许我们保留

106
00:04:59,633 --> 0:05:00,701
由传感器测量的全部数据

107
00:04:59,633 --> 0:05:00,701
由传感器测量的全部数据

108
00:05:01,201 --> 0:05:05,339
但这种数据表达并没有那么有效率

109
00:05:05,973 --> 0:05:07,441
全部这些量化样本

110
00:05:07,508 --> 0:05:09,943
都有相同的元数据和设备信息

111
00:05:10,844 --> 0:05:13,480
我们不再拥有那个便利的单一对象了

112
00:05:13,547 --> 0:05:15,616
就是那个表达我们实际上

113
00:05:15,682 --> 0:05:17,317
在游戏过程中是心率

114
00:05:18,752 --> 0:05:21,121
谢天谢地 我们可以采用第三种方法

115
00:05:21,455 --> 0:05:23,090
我们把它叫做量化系列

116
00:05:24,091 --> 0:05:26,894
量化系列表达看起来像这样

117
00:05:28,028 --> 0:05:29,796
单一量化样本

118
00:05:29,863 --> 0:05:31,598
跨越了整个测量时间

119
00:05:32,432 --> 0:05:34,735
但在这种情况下

120
00:05:35,035 --> 0:05:37,037
而是多个量化数据

121
00:05:38,372 --> 0:05:41,808
这种表达利用了以上两种方法的优点

122
00:05:42,109 --> 0:05:43,944
用单一对象表达测量数据

123
00:05:44,611 --> 0:05:47,514
会保留从传感器中获取的

124
00:05:48,615 --> 0:05:52,085
请注意我们移除了

125
00:05:52,152 --> 0:05:54,688
之前存在于

126
00:05:54,755 --> 0:05:57,724
因此我们在量化系列样本层级

127
00:05:58,625 --> 0:06:01,328
我们都想尊重用户的设备存储

128
00:05:58,625 --> 0:06:01,328
我们都想尊重用户的设备存储

129
00:06:01,828 --> 0:06:03,130
和设备性能

130
00:06:03,197 --> 0:06:05,132
这种表达就可以让我们实现这个目的

131
00:06:07,000 --> 0:06:09,336
因为量化系列样本是一种量化样本

132
00:06:10,037 --> 0:06:14,508
我们需要一种方式来表达

133
00:06:15,242 --> 0:06:17,778
并且在HealthKit中

134
00:06:19,079 --> 0:06:22,783
我们有两个主要的聚合类型：

135
00:06:23,550 --> 0:06:24,818
积累聚合类型

136
00:06:25,152 --> 0:06:27,955
适用于一些很常见的量化类型

137
00:06:28,021 --> 0:06:29,156
卡路里和步数

138
00:06:30,090 --> 0:06:32,726
全部这些量化类型

139
00:06:32,793 --> 0:06:35,596
他们走更多的步数

140
00:06:35,662 --> 0:06:36,830
和移动更远的距离

141
00:06:37,865 --> 0:06:41,134
执行累积的最自然的方式—

142
00:06:41,201 --> 0:06:42,936
聚合多个量化数据的最自然的方式

143
00:06:44,872 --> 0:06:45,939
另一方面

144
00:06:46,240 --> 0:06:49,376
我们还有一些其它常见的量化类型

145
00:06:50,277 --> 0:06:52,846
比如心率、身体质量和身高

146
00:06:53,914 --> 0:06:55,883
如果合计在一起没有任何意义

147
00:06:55,949 --> 0:06:58,218
如果你一天量好几次心率

148
00:06:58,886 --> 0:06:59,953
你会得到一个荒谬的值

149
00:07:00,654 --> 0:07:04,258
像这样聚合量化类型会更自然

150
00:07:04,324 --> 0:07:07,294
取平均值 也许是其它聚合统计

151
00:07:07,661 --> 0:07:10,063
比如最小值、最大值和最新值

152
00:07:12,533 --> 0:07:17,037
再一次 我们可以看到

153
00:07:17,337 --> 0:07:19,306
可以通过合计来表达和聚合

154
00:07:20,207 --> 0:07:22,709
而一系列的离散量化数据比如心率

155
00:07:23,177 --> 0:07:26,513
将被聚合来产生一些统计数据

156
00:07:26,580 --> 0:07:29,316
比如最小值、最大值、

157
00:07:31,385 --> 0:07:33,787
在HealthKit中

158
00:07:33,854 --> 0:07:36,356
来提供指定量化类型的聚合类型

159
00:07:37,291 --> 0:07:38,425
并且在iOS 13中

160
00:07:39,026 --> 0:07:41,695
我们决定不使用离散聚合类型

161
00:07:41,762 --> 0:07:46,333
而使用一种新的离散算法聚合类型

162
00:07:47,067 --> 0:07:49,603
我们之所以这样做是为了明确

163
00:07:49,670 --> 0:07:52,606
所计算出来的平均值

164
00:07:53,674 --> 0:07:56,610
我们还引入了一些新的聚合类型

165
00:07:56,977 --> 0:07:59,179
让我们从

166
00:07:59,580 --> 0:08:02,616
它是一种特殊的聚合类型

167
00:07:59,580 --> 0:08:02,616
它是一种特殊的聚合类型

168
00:08:03,016 --> 0:08:05,085
应用于当我们聚合心率量化数据时

169
00:08:06,420 --> 0:08:09,456
我们还添加了

170
00:08:10,023 --> 0:08:13,460
它是一种特殊的聚合类型

171
00:08:14,361 --> 0:08:17,264
Divya稍后会具体讲音频暴露

172
00:08:19,633 --> 0:08:22,503
现在我们了解了如何聚合

173
00:08:23,203 --> 0:08:24,571
来生产统计数据

174
00:08:24,938 --> 0:08:27,774
我们需要一个地方来存储

175
00:08:28,909 --> 0:08:30,210
我们在iOS 13中

176
00:08:30,277 --> 0:08:32,980
通过引入两个新量化样本子类实现

177
00:08:33,046 --> 0:08:34,881
从累积量化样本开始

178
00:08:34,948 --> 0:08:36,149
它有一个合计属性

179
00:08:36,549 --> 0:08:37,885
并且离散量化样本

180
00:08:38,352 --> 0:08:39,419
它有

181
00:08:39,919 --> 0:08:42,890
平均值、最小值、最大值

182
00:08:43,991 --> 0:08:47,427
我们还把量化样本作为抽象基类

183
00:08:47,895 --> 0:08:50,898
意思是从现在起

184
00:08:50,964 --> 0:08:52,065
你所交互的量化样本的全部实体

185
00:08:52,366 --> 0:08:55,302
都将是这两个量化样本子类中的一个

186
00:08:55,369 --> 0:08:57,704
取决于量化类型的聚合类型

187
00:08:58,972 --> 0:09:00,407
并且我还想提醒一下

188
00:08:58,972 --> 0:09:00,407
并且我还想提醒一下

189
00:09:00,474 --> 0:09:03,577
全部量化样本都可以被看作是

190
00:09:03,944 --> 0:09:06,647
只不过其中有些恰好只有一个

191
00:09:07,948 --> 0:09:10,751
我们还为这两个新样本类型

192
00:09:11,018 --> 0:09:12,486
引入了相应的

193
00:09:14,188 --> 0:09:17,324
你可以查询这两种样本的相应属性

194
00:09:18,892 --> 0:09:20,894
返回到我们的量化系列样本例子中

195
00:09:21,695 --> 0:09:23,797
我们可以看到量化系列样本

196
00:09:23,864 --> 0:09:25,999
可以通过我们的聚合统计进行合计

197
00:09:26,066 --> 0:09:27,668
平均值、最小值、最大值和最新值

198
00:09:29,203 --> 0:09:32,039
现在我要讲如何创建这种量化系列

199
00:09:33,140 --> 0:09:34,241
（创建量化系列）

200
00:09:34,308 --> 0:09:35,843
我们要从测量开始时

201
00:09:35,909 --> 0:09:37,377
讲量化系列

202
00:09:37,878 --> 0:09:39,580
在这个情境中是指游戏开始

203
00:09:40,814 --> 0:09:43,150
然后我们将收到

204
00:09:43,217 --> 0:09:45,052
我们可以把它们插入到

205
00:09:45,485 --> 0:09:47,654
我们继续从传感器中获取测量数据

206
00:09:47,721 --> 0:09:49,256
并继续把它们插入到量化系列中

207
00:09:49,690 --> 0:09:51,158
一直到游戏结束

208
00:09:52,593 --> 0:09:54,127
最后当我们完成测量后

209
00:09:54,194 --> 0:09:55,796
我们就可以结束量化系列

210
00:09:55,863 --> 0:09:58,799
并返回合计的量化系列样本

211
00:10:01,635 --> 0:10:02,903
现在让我们看看代码

212
00:10:05,772 --> 0:10:07,975
所有HealthKit交互的

213
00:10:08,509 --> 0:10:12,045
都是请求

214
00:10:12,446 --> 0:10:15,182
在这个例子中我们要请求心率的授权

215
00:10:16,083 --> 0:10:17,484
一旦我们请求了授权

216
00:10:18,519 --> 0:10:21,555
我们就可以通过healthStore

217
00:10:21,622 --> 0:10:22,589
数据类型

218
00:10:22,956 --> 0:10:25,526
开始测量的时间和可选的HK设备

219
00:10:27,895 --> 0:10:30,197
然后 只要我们收到

220
00:10:30,264 --> 0:10:32,966
我们就可以把它们插入到

221
00:10:33,734 --> 0:10:35,536
最后在游戏结束时

222
00:10:35,903 --> 0:10:37,704
我们可以完成量化系列样本创建器

223
00:10:38,405 --> 0:10:40,807
通过可选的元数据和测量结束时间

224
00:10:42,910 --> 0:10:46,246
现在我们已经了解

225
00:10:46,313 --> 0:10:47,814
并把它作为量化系列

226
00:10:48,315 --> 0:10:51,084
我们还可以思考通过数据

227
00:10:51,151 --> 0:10:52,819
一旦数据被保存到

228
00:10:53,887 --> 0:10:57,457
也许我们想让app能记录

229
00:10:57,524 --> 0:10:58,458
除心率以外的卡路里信息

230
00:10:58,926 --> 0:11:02,262
因此我们可以给用户显示在某个时间

231
00:10:58,926 --> 0:11:02,262
因此我们可以给用户显示在某个时间

232
00:11:02,329 --> 0:11:05,933
或只呈现一些很漂亮的图表

233
00:11:06,233 --> 0:11:08,035
突显数据并帮助他们将数据可视化

234
00:11:08,101 --> 0:11:09,102
（量化数据的查询

235
00:11:09,169 --> 0:11:10,437
或者我们想指出平均值

236
00:11:10,504 --> 0:11:12,339
是在某一个时间段内记录的平均值

237
00:11:12,406 --> 0:11:13,373
（图表的数据

238
00:11:13,440 --> 0:11:14,341
（最小和最大心率）

239
00:11:14,408 --> 0:11:16,610
或帮助用户了解

240
00:11:16,677 --> 0:11:18,045
所达到的最小和最大心率值

241
00:11:19,146 --> 0:11:22,983
或我们只想保持UI活跃并在收到

242
00:11:23,050 --> 0:11:25,586
来自传感器的数据时

243
00:11:25,652 --> 0:11:26,787
（最新心率）

244
00:11:27,554 --> 0:11:30,958
我们可以实现这个功能并做得更好

245
00:11:33,427 --> 0:11:35,162
HKStatisticsCollectionQuery

246
00:11:36,597 --> 0:11:39,266
很多人已经熟悉

247
00:11:39,833 --> 0:11:41,401
它非常棒

248
00:11:41,468 --> 0:11:43,837
因此我只想重申它的功能

249
00:11:44,872 --> 0:11:48,709
StatisticsCollectionQuery

250
00:11:49,109 --> 0:11:50,878
可以通过资料来源分隔开

251
00:11:51,745 --> 0:11:54,014
并且只要有新数据

252
00:11:54,081 --> 0:11:55,782
你就可以收到那些统计的更新数据

253
00:11:55,849 --> 0:11:57,351
（生产多个统计

254
00:11:57,417 --> 0:11:58,585
如果那还不够

255
00:11:58,652 --> 0:12:01,154
我们还更新了

256
00:11:58,652 --> 0:12:01,154
我们还更新了

257
00:12:01,221 --> 0:12:03,590
用于支持新的聚合类型

258
00:12:04,157 --> 0:12:07,394
并自动包含

259
00:12:07,461 --> 0:12:08,762
（支持全部聚合类型）

260
00:12:09,062 --> 0:12:10,864
全部备份量化数据

261
00:12:10,931 --> 0:12:11,832
（自动包含量化系列数据）

262
00:12:12,165 --> 0:12:15,202
如果你想获得关于

263
00:12:15,269 --> 0:12:16,403
和HKStatistics的

264
00:12:16,837 --> 0:12:18,839
你可以参考关于

265
00:12:21,842 --> 0:12:23,544
虽然StatisticsCollectionQuery

266
00:12:24,044 --> 0:12:27,181
应该是我们的首选工具

267
00:12:27,247 --> 0:12:28,482
与保存在HealthKit中的

268
00:12:29,616 --> 0:12:33,287
有时我们真的想枚举

269
00:12:33,353 --> 0:12:34,688
存储在量化系列中的

270
00:12:35,589 --> 0:12:38,192
比如 如果我们想做一些比如绘制

271
00:12:38,458 --> 0:12:40,827
用户玩游戏时

272
00:12:40,894 --> 0:12:41,895
通过我们的app测量的每一个心率

273
00:12:43,096 --> 0:12:46,934
我们可以通过

274
00:12:48,068 --> 0:12:51,038
在iOS 13中我们改进了

275
00:12:51,104 --> 0:12:54,374
通过把NSPredicate中的

276
00:12:54,842 --> 0:12:56,210
替换为量化类型

277
00:12:58,111 --> 0:13:01,982
现在不再简单地枚举

278
00:12:58,111 --> 0:13:01,982
现在不再简单地枚举

279
00:13:02,282 --> 0:13:04,351
而是枚举多个量化样本

280
00:13:04,418 --> 0:13:05,886
及其全部备份量化数据

281
00:13:07,521 --> 0:13:10,457
我们还把时间参数升级为时间间隔

282
00:13:10,524 --> 0:13:12,893
从而你可以在每个单一量化数据

283
00:13:12,960 --> 0:13:13,861
获得它的完整时间间隔

284
00:13:14,828 --> 0:13:17,364
我们还有一个可选的量化样本参数

285
00:13:17,664 --> 0:13:21,401
可以提供当前被枚举的量化系列样本

286
00:13:24,371 --> 0:13:26,139
这个查询通过可视化数据

287
00:13:26,440 --> 0:13:27,574
因此我要给你们展示一下

288
00:13:28,442 --> 0:13:30,444
在这里我们有两个量化系列样本

289
00:13:31,111 --> 0:13:32,646
第一个量化系列样本

290
00:13:32,713 --> 0:13:35,415
包含由嵌入到

291
00:13:35,482 --> 0:13:36,917
心率传感器测量的量化数据

292
00:13:38,218 --> 0:13:41,522
第二个量化系列包含

293
00:13:42,189 --> 0:13:45,092
因为我们的用户恰好同时

294
00:13:45,859 --> 0:13:47,728
这两个量化系列适时地相互重叠

295
00:13:48,996 --> 0:13:51,131
默认情况下

296
00:13:51,198 --> 0:13:52,866
将以量化数据的开始时间为顺序

297
00:13:53,267 --> 0:13:56,303
枚举来自这两个量化系列的

298
00:13:56,670 --> 0:13:57,604
就像这样

299
00:13:58,338 --> 0:14:00,507
请注意在量化系列的末端

300
00:13:58,338 --> 0:14:00,507
请注意在量化系列的末端

301
00:14:01,875 --> 0:14:03,210
完成参数被设为真

302
00:14:05,312 --> 0:14:08,882
如果你需要获取

303
00:14:08,949 --> 0:14:11,552
比如设备信息、来源、版本号

304
00:14:11,919 --> 0:14:15,489
你可以在执行查询之前

305
00:14:16,156 --> 0:14:19,126
请注意 在这个例子中

306
00:14:19,760 --> 0:14:23,197
你可以在量化数据处理器中

307
00:14:26,967 --> 0:14:29,303
现在我们已经了解如何使用量化系列

308
00:14:29,369 --> 0:14:31,171
与量化数据进行有效地交互

309
00:14:31,238 --> 0:14:33,540
我想告诉你们在游戏中添加

310
00:14:33,807 --> 0:14:35,976
我们在本场演讲中所讲到的这种支持

311
00:14:36,677 --> 0:14:39,046
跟着我一起进入Xcode

312
00:14:44,484 --> 0:14:47,588
这是游戏现在的形式

313
00:14:48,789 --> 0:14:50,891
我实际上没有

314
00:14:50,958 --> 0:14:52,826
嵌入到视频游戏控制器中的

315
00:14:52,893 --> 0:14:55,195
但如果有人想做一个

316
00:14:56,330 --> 0:14:58,131
但我有另一个外部心率传感器

317
00:14:58,198 --> 0:15:00,501
我可以用来获取信息

318
00:14:58,198 --> 0:15:00,501
我可以用来获取信息

319
00:15:01,034 --> 0:15:02,703
请记住量化系列

320
00:15:02,769 --> 0:15:04,438
可适用于任意量化类型

321
00:15:04,505 --> 0:15:05,506
而不只是心率

322
00:15:05,839 --> 0:15:07,808
并且数据可以来自于外部传感器、

323
00:15:07,875 --> 0:15:10,110
外部数据库、磁盘上的文件

324
00:15:10,544 --> 0:15:13,046
或由app直接输入

325
00:15:14,381 --> 0:15:15,916
这个游戏有两个标签

326
00:15:16,917 --> 0:15:19,319
第一个是Play标签 它会提出

327
00:15:19,386 --> 0:15:20,387
我们可以开始游戏

328
00:15:21,221 --> 0:15:23,090
第二个标签是上一次游戏标签

329
00:15:23,156 --> 0:15:24,858
它会提出

330
00:15:24,925 --> 0:15:26,527
显示在上一次玩游戏时

331
00:15:26,593 --> 0:15:28,128
所测量的心率

332
00:15:31,198 --> 0:15:33,000
我要继续并切换回

333
00:15:33,066 --> 0:15:35,068
给你演示一局游戏该怎么玩

334
00:15:37,437 --> 0:15:39,473
在这个游戏中我要击中热狗

335
00:15:39,540 --> 0:15:40,607
而放过西兰花

336
00:15:41,141 --> 0:15:42,876
也许对于健康类app来说

337
00:15:43,477 --> 0:15:44,378
但是我只有这个

338
00:15:45,479 --> 0:15:47,981
每收获一个热狗就增加一分

339
00:15:48,048 --> 0:15:50,317
当我玩游戏时 我的心率会增加

340
00:15:51,652 --> 0:15:52,719
如果我切换回上一次游戏标签

341
00:15:52,786 --> 0:15:54,788
我可以看到我还没有收到

342
00:15:54,855 --> 0:15:56,390
在玩刚才的游戏时

343
00:15:56,857 --> 0:15:58,458
现在我们想给app添加那个支持

344
00:15:59,626 --> 0:16:01,328
我们的第一步是…

345
00:15:59,626 --> 0:16:01,328
我们的第一步是…

346
00:16:01,962 --> 0:16:03,830
让app请求授权

347
00:16:03,897 --> 0:16:05,232
就像我们在PPT中所看到的那样

348
00:16:06,099 --> 0:16:09,636
因为app总是会在用户玩游戏时

349
00:16:09,703 --> 0:16:10,671
读写心率数据

350
00:16:10,737 --> 0:16:12,773
我希望只要app启动完毕

351
00:16:13,774 --> 0:16:15,275
就请求授权

352
00:16:15,342 --> 0:16:17,110
那么我要在app中添加这个

353
00:16:17,177 --> 0:16:19,446
在app委托中添加

354
00:16:22,883 --> 0:16:24,117
在这里我正在请求…

355
00:16:24,484 --> 0:16:27,554
我正在创建一组专用于心率的

356
00:16:28,021 --> 0:16:30,891
我可以在

357
00:16:30,958 --> 0:16:32,025
请求这些样本类型的授权

358
00:16:33,727 --> 0:16:35,229
请求授权后

359
00:16:35,295 --> 0:16:37,030
我们会获取来自传感器的测量数据

360
00:16:37,097 --> 0:16:39,032
并把那个数据保存到量化系列中

361
00:16:40,200 --> 0:16:42,703
我已经创建了一个类

362
00:16:43,103 --> 0:16:44,137
用于压缩对外部传感器的连接

363
00:16:44,204 --> 0:16:45,606
并且如果你想了解它是如何运作的

364
00:16:45,672 --> 0:16:48,375
请参考与本场演讲相关联的示例项目

365
00:16:49,910 --> 0:16:51,979
我现在要转到

366
00:16:52,246 --> 0:16:54,648
因为我们想添加连接

367
00:16:54,948 --> 0:16:56,116
用于记录用户玩游戏时的心率

368
00:16:56,850 --> 0:16:58,085
我要打开项目导航器

369
00:16:58,151 --> 0:16:59,887
转到

370
00:17:01,321 --> 0:17:03,490
在PlayViewController中

371
00:17:03,557 --> 0:17:06,260
每当按下app中的开始游戏按钮时

372
00:17:06,926 --> 0:17:08,896
这里正适合我们创建

373
00:17:08,962 --> 0:17:10,163
对外部心率传感器的连接

374
00:17:10,464 --> 0:17:12,199
并开始量化系列…

375
00:17:12,266 --> 0:17:13,733
量化系列样本创建器

376
00:17:14,601 --> 0:17:16,603
首先我要创建对传感器的连接

377
00:17:20,574 --> 0:17:23,143
HeartSensorSession

378
00:17:23,210 --> 0:17:25,512
它会压缩对传感器的连接

379
00:17:25,811 --> 0:17:27,580
我把PlayViewController自身

380
00:17:27,915 --> 0:17:29,650
作为HeartSensorSession的委托

381
00:17:31,051 --> 0:17:34,154
现在我可以开始

382
00:17:37,057 --> 0:17:39,059
在这里我创建了一个

383
00:17:39,126 --> 0:17:40,994
healthStore

384
00:17:41,328 --> 0:17:42,996
测量的开始时间为当前时间

385
00:17:43,497 --> 0:17:46,600
我要从HeartSensorSession中

386
00:17:47,734 --> 0:17:50,304
HeartSensorSession

387
00:17:50,370 --> 0:17:52,339
与PlayViewController通讯

388
00:17:53,273 --> 0:17:54,374
HeartSensorSessionDelegate

389
00:17:54,675 --> 0:17:56,043
有以下两个方法：

390
00:17:56,643 --> 0:17:58,745
sessionDidReceiveHeartRate

391
00:18:00,047 --> 0:18:02,049
通过sessionDidEnd…

392
00:18:02,316 --> 0:18:05,919
HeartSensorSession

393
00:18:06,253 --> 0:18:08,088
这正是我们获取测量数据的好地方

394
00:18:08,155 --> 0:18:10,324
并且把它们插入到

395
00:18:16,930 --> 0:18:18,999
在这里我把从HeartSensorSession中

396
00:18:19,066 --> 0:18:21,368
和时间间隔插入到

397
00:18:21,435 --> 0:18:22,903
量化系列样本创建器中

398
00:18:24,805 --> 0:18:28,509
最后当游戏结束时

399
00:18:28,876 --> 0:18:30,878
由HeartSensorSession调用

400
00:18:31,578 --> 0:18:34,481
这是我们结束量化系列样本创建器的

401
00:18:34,781 --> 0:18:38,018
从而存留我们插入到HealthKit中的

402
00:18:38,785 --> 0:18:40,754
我们还可以关联

403
00:18:40,821 --> 0:18:42,322
用元数据所创建的量化系列

404
00:18:42,723 --> 0:18:44,525
在这个例子中 我要使用元数据

405
00:18:44,591 --> 0:18:47,828
把这些心率与我们刚刚玩的

406
00:18:47,895 --> 0:18:49,830
从而在ResultsViewController中

407
00:18:49,897 --> 0:18:53,000
我们可以查询

408
00:18:57,905 --> 0:19:01,975
在这里我要使用MetadataKey

409
00:18:57,905 --> 0:19:01,975
在这里我要使用MetadataKey

410
00:19:02,543 --> 0:19:04,845
我在心率传感器的UUID字符串中

411
00:19:05,646 --> 0:19:07,881
我终于完成了量化系列

412
00:19:07,948 --> 0:19:09,983
通过元数据

413
00:19:10,050 --> 0:19:11,718
和从HeartSensorSession中

414
00:19:14,154 --> 0:19:16,590
现在我们已经把心率数据

415
00:19:16,890 --> 0:19:19,927
我们想…

416
00:19:19,993 --> 0:19:21,128
我们想在ResultsViewController中

417
00:19:21,195 --> 0:19:22,863
那么让我们现在转到

418
00:19:28,969 --> 0:19:31,171
在ResultsViewController

419
00:19:31,238 --> 0:19:32,272
我有一个应用函数

420
00:19:32,773 --> 0:19:33,941
loadHeartRateQuanitites

421
00:19:34,274 --> 0:19:36,009
它会查询

422
00:19:36,076 --> 0:19:38,278
与上一次游戏会话相关联的心率数据

423
00:19:38,745 --> 0:19:41,982
并在表视图中生成一个

424
00:19:42,049 --> 0:19:43,483
每个量化数据的字符串表达

425
00:19:44,918 --> 0:19:49,089
让我们继续并从添加量化系列样本

426
00:19:49,156 --> 0:19:51,658
使其查询

427
00:19:51,725 --> 0:19:52,759
如果玩过游戏的话

428
00:19:56,463 --> 0:19:59,166
在这里要防范

429
00:20:00,367 --> 0:20:01,802
如果我们有一个游戏识别器

430
00:20:01,869 --> 0:20:04,371
我们可以继续并使用游戏识别器

431
00:20:04,438 --> 0:20:08,075
为MetadataExternalKeyUUID

432
00:20:08,642 --> 0:20:10,177
请记住 我们使用了这个元数据

433
00:20:10,244 --> 0:20:12,713
从而稍后可以进行查询

434
00:20:12,779 --> 0:20:14,381
与上一次游戏相关联的心率数据

435
00:20:16,717 --> 0:20:19,052
然后我可以创建量化系列样本

436
00:20:19,119 --> 0:20:21,421
使用我们上边创建的谓词

437
00:20:22,890 --> 0:20:24,324
在查询处理器内

438
00:20:24,391 --> 0:20:26,693
我要枚举

439
00:20:26,760 --> 0:20:27,961
与这个上一次游戏相关联的

440
00:20:29,029 --> 0:20:31,465
并且我要为每一个

441
00:20:31,532 --> 0:20:32,900
都创建一个字符串表达

442
00:20:33,333 --> 0:20:35,102
让我们继续并创建一组字符串

443
00:20:35,169 --> 0:20:38,005
用于存储这些结果字符串

444
00:20:41,508 --> 0:20:44,545
然后我们可以把它用在查询处理器中

445
00:20:48,248 --> 0:20:49,816
首先我要防范枚举过程中

446
00:20:49,883 --> 0:20:51,919
可能会返回的错误

447
00:20:52,553 --> 0:20:53,787
如果没有任何错误

448
00:20:53,854 --> 0:20:56,323
我就可以继续并使用

449
00:20:56,623 --> 0:20:58,892
和时间间隔创建一个

450
00:20:59,359 --> 0:21:01,094
并且我要把这些详情字符串分配给

451
00:20:59,359 --> 0:21:01,094
并且我要把这些详情字符串分配给

452
00:21:01,161 --> 0:21:02,529
heartRateStrings

453
00:21:03,597 --> 0:21:06,300
最后当枚举完成后

454
00:21:06,366 --> 0:21:07,935
完成参数将被设为真

455
00:21:08,368 --> 0:21:11,338
这正是取回主队列的好地方

456
00:21:11,638 --> 0:21:14,641
从而重新加载ResultsViewController

457
00:21:16,977 --> 0:21:19,613
现在我想重新运行app

458
00:21:19,680 --> 0:21:22,649
现在我们已经添加了

459
00:21:24,051 --> 0:21:26,520
请记住 当app启动时

460
00:21:26,587 --> 0:21:27,955
将是请求授权

461
00:21:30,891 --> 0:21:32,793
我要继续并打开授权

462
00:21:33,160 --> 0:21:34,294
从而读写心率数据

463
00:21:35,796 --> 0:21:37,431
现在我要再玩一局游戏

464
00:21:39,032 --> 0:21:41,301
请记住 我要击中热狗而放过西兰花

465
00:21:41,902 --> 0:21:43,770
哦 零分 再来一局

466
00:21:49,476 --> 0:21:52,045
哦 两分 但我仍可以看到心率如何

467
00:21:52,746 --> 0:21:53,714
好了

468
00:21:53,780 --> 0:21:56,550
我们拥有了一些心率数据

469
00:22:03,524 --> 0:22:04,992
（演示

470
00:22:05,392 --> 0:22:08,662
刚才我们了解的是

471
00:22:09,296 --> 0:22:11,632
有效率地保存量化数据

472
00:22:12,299 --> 0:22:15,702
以及如何使用QuantitySeries

473
00:22:16,603 --> 0:22:18,906
现在我要邀请我的同事

474
00:22:19,273 --> 0:22:22,743
她会讲HealthKit

475
00:22:22,809 --> 0:22:24,178
对表达进行了扩展

476
00:22:24,444 --> 0:22:26,513
以及我们如何迁入到

477
00:22:26,580 --> 0:22:28,215
谢谢大家

478
00:22:35,389 --> 0:22:37,424
那么我的同事Luke刚给你们讲了

479
00:22:37,491 --> 0:22:41,595
在iOS 13中存储HK

480
00:22:42,496 --> 0:22:45,866
并且HealthKit

481
00:22:45,933 --> 0:22:47,634
保存用户每日健康数据的仓库

482
00:22:48,468 --> 0:22:51,038
除了存储越来越多的数据

483
00:22:51,305 --> 0:22:53,207
我们还存储各种各样的数据

484
00:22:54,174 --> 0:22:57,578
今年 我们在现有的支持中

485
00:22:57,644 --> 0:22:59,479
并对听力健康添加了新支持

486
00:22:59,780 --> 0:23:01,248
（新的健康类型

487
00:22:59,780 --> 0:23:01,248
（新的健康类型

488
00:23:01,915 --> 0:23:06,086
我们的用户自iOS 8起

489
00:23:06,687 --> 0:23:09,056
他们可以从

490
00:23:09,356 --> 0:23:13,460
或从由你们开发人员创建的

491
00:23:13,861 --> 0:23:16,163
并在健康app中浏览全部数据

492
00:23:18,432 --> 0:23:20,901
HealthKit一直支持心率

493
00:23:21,568 --> 0:23:24,071
因此如果你的心率读数是这个

494
00:23:24,538 --> 0:23:27,241
你可以决定在五秒内

495
00:23:27,774 --> 0:23:30,978
平均心率是每分钟68次

496
00:23:32,112 --> 0:23:35,282
并且在HealthKit中

497
00:23:37,918 --> 0:23:41,722
在iOS 11中

498
00:23:41,788 --> 0:23:42,623
（心率变量SDNN）

499
00:23:42,689 --> 0:23:45,692
心率变量是心跳和心跳之间

500
00:23:45,759 --> 0:23:47,995
在时间间隔内的测量的变化

501
00:23:48,529 --> 0:23:51,732
并且SDNN代表的是

502
00:23:52,699 --> 0:23:55,435
因此Apple Watch

503
00:23:56,236 --> 0:23:58,739
并获取每次心跳之间的时间间隔

504
00:23:59,339 --> 0:24:01,241
来计算一个标准差

505
00:23:59,339 --> 0:24:01,241
来计算一个标准差

506
00:24:01,308 --> 0:24:03,977
并把它作为量化样本

507
00:24:05,179 --> 0:24:07,014
心率和心率变量

508
00:24:07,080 --> 0:24:10,517
对于心血管健康来说

509
00:24:10,984 --> 0:24:13,620
并且用户们也喜欢看一眼

510
00:24:13,687 --> 0:24:15,756
在日常工作生活中或更具体地

511
00:24:15,822 --> 0:24:16,890
比如当他们健身时

512
00:24:19,026 --> 0:24:21,395
那么让我们再看一次

513
00:24:21,461 --> 0:24:22,296
这同一个心率读数

514
00:24:22,930 --> 0:24:26,633
目前 我描述了我们可以总结

515
00:24:26,700 --> 0:24:27,734
这个心率数据的方式

516
00:24:28,235 --> 0:24:31,171
但有时候你想获得真实的底层数据

517
00:24:32,072 --> 0:24:34,308
那么假如我想获得时间…

518
00:24:34,775 --> 0:24:36,944
了解每次心跳所发生的时间

519
00:24:37,711 --> 0:24:39,546
返回到我们的情境中

520
00:24:39,880 --> 0:24:42,416
假如我们的游戏控制器有一个传感器

521
00:24:42,482 --> 0:24:45,419
可以在用户在玩游戏时

522
00:24:45,686 --> 0:24:46,854
有新的心跳进入时告诉我们

523
00:24:47,721 --> 0:24:51,158
那么在这里 第一次心跳发生在

524
00:24:51,558 --> 0:24:53,160
从数据收集开始的起始点

525
00:24:53,594 --> 0:24:56,063
第二次发生在第1.49秒

526
00:24:56,430 --> 0:24:59,132
并且我们可以得到——

527
00:24:59,399 --> 0:25:01,869
自数据收集开始起

528
00:24:59,399 --> 0:25:01,869
自数据收集开始起

529
00:25:02,936 --> 0:25:06,273
那么你可以注意到

530
00:25:06,607 --> 0:25:09,643
把它们放在一起就组成了

531
00:25:10,511 --> 0:25:12,246
要把这个数据

532
00:25:12,513 --> 0:25:15,182
我们有一个

533
00:25:15,582 --> 0:25:18,385
它会按照心跳发生的时间戳

534
00:25:18,452 --> 0:25:19,319
来保存一系列的心跳

535
00:25:20,587 --> 0:25:24,091
现在你可能注意到

536
00:25:24,157 --> 0:25:25,459
这与Luke之前讲过的系列API

537
00:25:26,260 --> 0:25:29,363
但有一个重点需要注意

538
00:25:29,429 --> 0:25:31,565
压缩衍生自HealthKit中

539
00:25:31,632 --> 0:25:34,301
其它样本类型的数据类型

540
00:25:35,068 --> 0:25:38,472
没有值或单位 比如HK量化数据

541
00:25:38,539 --> 0:25:41,241
它是量化系列背后的底层数据

542
00:25:41,675 --> 0:25:45,779
因此我们可以更有效地

543
00:25:46,113 --> 0:25:47,614
来表达一个心跳系列

544
00:25:47,681 --> 0:25:49,116
（健康系列VS量化系列

545
00:25:49,183 --> 0:25:50,117
（一系列时间戳）

546
00:25:50,184 --> 0:25:52,819
但因为我们仍然存储一系列数据

547
00:25:52,886 --> 0:25:55,455
那可能会非常大 我们有…

548
00:25:55,522 --> 0:25:59,560
我们设计了API来熟悉量化系列

549
00:26:00,394 --> 0:26:02,796
因此我们配备了这个

550
00:26:02,863 --> 0:26:04,698
有它自己的创建器和自定义查询

551
00:26:07,000 --> 0:26:08,435
与量化系列样本一样

552
00:26:08,702 --> 0:26:11,305
心跳系列样本也是由创建器所创建

553
00:26:11,371 --> 0:26:12,873
并当你完成保存数据后结束

554
00:26:13,740 --> 0:26:14,908
那么让我们用代码来创建一个

555
00:26:16,510 --> 0:26:18,011
第一步一如既往

556
00:26:18,078 --> 0:26:20,180
是请求恰当的授权

557
00:26:21,114 --> 0:26:24,585
对于这个例子

558
00:26:24,918 --> 0:26:28,322
以及我们从iOS 11中

559
00:26:28,388 --> 0:26:29,990
重新引入的量化类型

560
00:26:30,891 --> 0:26:32,593
你需要请求

561
00:26:32,659 --> 0:26:33,927
这两种类型的授权

562
00:26:33,994 --> 0:26:37,464
因为心率变量是一个

563
00:26:37,731 --> 0:26:39,099
可直接衍生自心跳系列的度量

564
00:26:39,166 --> 0:26:41,635
这样你的用户就清楚地了解

565
00:26:41,702 --> 0:26:43,937
他们到底与你分享了哪种数据

566
00:26:45,472 --> 0:26:47,407
一旦我们请求了授权

567
00:26:47,474 --> 0:26:51,078
我们可通过heathStore、

568
00:26:51,144 --> 0:26:52,913
和gameStartDate

569
00:26:52,980 --> 0:26:55,282
那会表明何时开始数据收集

570
00:26:56,950 --> 0:27:00,053
当游戏正在进行时

571
00:26:56,950 --> 0:27:00,053
当游戏正在进行时

572
00:27:00,454 --> 0:27:02,489
我们将向创建器中添加

573
00:27:02,556 --> 0:27:04,558
自系列开始的时间起

574
00:27:06,627 --> 0:27:08,662
但你可能会遇到这样的情况

575
00:27:08,929 --> 0:27:12,699
传感器当掉了

576
00:27:12,766 --> 0:27:14,334
在第二秒和第三秒之间

577
00:27:15,369 --> 0:27:18,572
现在看起来

578
00:27:18,639 --> 0:27:20,174
有一个1.99秒的缺口

579
00:27:20,240 --> 0:27:24,311
那会导致

580
00:27:25,579 --> 0:27:26,980
考虑到这个问题

581
00:27:27,047 --> 0:27:29,149
我们要把

582
00:27:29,416 --> 0:27:31,718
你可以对你所添加的每一个心跳

583
00:27:31,785 --> 0:27:34,221
如果你注意到数据收集中

584
00:27:34,288 --> 0:27:35,455
由于传感器当掉而存在缺口的话

585
00:27:37,724 --> 0:27:41,929
现在我可以在创建器中添加元数据

586
00:27:43,063 --> 0:27:44,831
当我完成数据保存之后

587
00:27:44,898 --> 0:27:48,869
我会结束系列 那将把心跳系列样本

588
00:27:51,305 --> 0:27:54,775
现在我已经在游戏中添加了

589
00:27:54,842 --> 0:27:58,045
并且我们已经准备好开始查询

590
00:28:00,480 --> 0:28:02,683
跟Luke之前讲过的一样

591
00:28:02,749 --> 0:28:05,719
我们可以与标准的HK查询进行交互

592
00:28:06,086 --> 0:28:10,490
以获取高层及样本

593
00:28:10,557 --> 0:28:12,159
与更精细的数据进行交互

594
00:28:13,627 --> 0:28:17,164
那么我的第一步就是

595
00:28:17,231 --> 0:28:19,499
以获取我感兴趣的心跳系列样本

596
00:28:20,834 --> 0:28:21,835
一旦完成

597
00:28:21,902 --> 0:28:24,738
我将用那个样本初始化心跳系列查询

598
00:28:25,005 --> 0:28:27,908
那会让我随时间枚举每一次心跳

599
00:28:29,977 --> 0:28:31,612
最后我要执行查询

600
00:28:34,014 --> 0:28:36,917
心跳系列对HealthKit来说

601
00:28:36,984 --> 0:28:39,620
但这并不是我们拥有的

602
00:28:40,754 --> 0:28:42,122
自iOS 12起

603
00:28:42,189 --> 0:28:45,092
Apple Watch

604
00:28:46,426 --> 0:28:50,197
当Apple Watch

605
00:28:50,264 --> 0:28:52,199
低于指定BPM临界值时

606
00:28:52,266 --> 0:28:53,100
（心率事件）

607
00:28:53,166 --> 0:28:55,536
当心率高于指定BPM临界值时

608
00:28:55,602 --> 0:28:57,471
发出高心率警告

609
00:28:58,639 --> 0:29:01,241
当Apple Watch检测到

610
00:28:58,639 --> 0:29:01,241
当Apple Watch检测到

611
00:29:01,308 --> 0:29:04,011
发出心律不齐警告

612
00:29:05,879 --> 0:29:06,980
嗯 在HealthKit中

613
00:29:07,047 --> 0:29:10,317
这些警告的形式是三个新的类别类型

614
00:29:10,817 --> 0:29:14,354
当Apple Watch检测到警告时

615
00:29:17,090 --> 0:29:19,359
除了全部这些强大的心脏支持

616
00:29:19,660 --> 0:29:23,397
我们在iOS 13中

617
00:29:24,131 --> 0:29:27,467
我非常激动地与你们一起分享

618
00:29:27,534 --> 0:29:28,669
听力健康在HealthKit中

619
00:29:28,735 --> 0:29:29,970
（听力健康）

620
00:29:30,237 --> 0:29:31,605
在你生命中的某个时间点

621
00:29:31,672 --> 0:29:33,574
你可能记得做过听力测试

622
00:29:33,841 --> 0:29:35,676
戴上耳机

623
00:29:36,043 --> 0:29:39,713
并听一系列的声音

624
00:29:39,780 --> 0:29:41,949
当某个声音大到你能听到它时

625
00:29:42,883 --> 0:29:45,485
嗯 这是纯音听力测试的一个例子

626
00:29:45,886 --> 0:29:48,422
纯音是指一个具有单一频率的声音

627
00:29:50,724 --> 0:29:53,794
纯音测试可以帮助识别

628
00:29:53,861 --> 0:29:56,129
在一组频率不同的声音中

629
00:29:56,196 --> 0:29:57,231
（纯音测试）

630
00:29:57,297 --> 0:30:00,133
并且它可以提供你可能具有的

631
00:29:57,297 --> 0:30:00,133
并且它可以提供你可能具有的

632
00:30:00,200 --> 0:30:01,468
听觉障碍或听力丧失的评估

633
00:30:03,036 --> 0:30:04,972
纯音测试的结果

634
00:30:05,038 --> 0:30:08,175
最常见的是显示在一个叫做

635
00:30:10,077 --> 0:30:12,346
这是一个有轻微听觉障碍的人的

636
00:30:12,412 --> 0:30:14,748
听力图的示例

637
00:30:15,382 --> 0:30:18,418
让我们放大这个图表 更清楚地了解

638
00:30:18,485 --> 0:30:21,021
听力图中所储存的数据

639
00:30:22,723 --> 0:30:24,324
那么在这里你可以看到两条线

640
00:30:24,758 --> 0:30:28,629
一条对应于左耳的纯音测试结果

641
00:30:28,896 --> 0:30:29,997
另一条对应的是右耳

642
00:30:30,531 --> 0:30:32,533
让我们先来看看

643
00:30:32,599 --> 0:30:34,034
位于125赫兹线上的前两个数据值

644
00:30:35,469 --> 0:30:39,907
这表示对于这个用户来说

645
00:30:40,274 --> 0:30:43,810
他们的左耳需要大概

646
00:30:44,111 --> 0:30:45,279
而右耳需要31分贝

647
00:30:46,246 --> 0:30:49,550
分贝听力单位测量的是

648
00:30:49,917 --> 0:30:52,920
相对于一个年轻、健康的个体

649
00:30:52,986 --> 0:30:53,954
所能听到的声音的密度

650
00:30:55,222 --> 0:30:57,558
因此我们可以获得

651
00:30:57,624 --> 0:30:59,159
与这个听力图相关联的其余数据值

652
00:30:59,626 --> 0:31:01,862
为了把这个数据存储到

653
00:30:59,626 --> 0:31:01,862
为了把这个数据存储到

654
00:31:02,129 --> 0:31:06,500
我们引入了 它会存储一组

655
00:31:06,567 --> 0:31:09,536
与听力测试相关联的听力敏度值

656
00:31:10,337 --> 0:31:12,472
那么让我们创建听力图样本和代码

657
00:31:14,408 --> 0:31:18,145
第一步是创建

658
00:31:18,579 --> 0:31:20,814
压缩双耳所能听到的

659
00:31:20,881 --> 0:31:23,717
指定频率的声音的密度

660
00:31:24,718 --> 0:31:29,556
那么我要用新的HK单位赫兹单位

661
00:31:30,257 --> 0:31:32,726
并用新的分贝听力单位来创建

662
00:31:32,793 --> 0:31:34,728
左耳和右耳敏度量化数据

663
00:31:36,230 --> 0:31:38,832
现在我已经准备好

664
00:31:39,800 --> 0:31:43,203
一旦你创建好一组听力图敏度值

665
00:31:43,670 --> 0:31:45,772
你就可以把它保存到

666
00:31:46,607 --> 0:31:49,576
现在一定要确保敏度值

667
00:31:49,643 --> 0:31:51,678
都是唯一的并且是按顺序排列的

668
00:31:52,079 --> 0:31:53,947
因为这是你稍后在分析或图表中

669
00:31:54,014 --> 0:31:56,717
与这个数据进行交互的方式

670
00:31:58,151 --> 0:32:01,188
最后我已经准备好把那个数据

671
00:31:58,151 --> 0:32:01,188
最后我已经准备好把那个数据

672
00:32:02,289 --> 0:32:05,626
开始创建听力图样本

673
00:32:05,692 --> 0:32:07,895
以及用HealthKit创建

674
00:32:08,929 --> 0:32:12,633
但听力图样本只代表

675
00:32:12,699 --> 0:32:15,102
当你做听力测试时的指定时间点的

676
00:32:16,203 --> 0:32:19,506
一天中的绝大多数时间

677
00:32:19,573 --> 0:32:22,309
这些声音来自耳机

678
00:32:22,776 --> 0:32:25,479
那都会影响我们的听力健康

679
00:32:27,347 --> 0:32:30,918
为了保持追踪来自耳机的音频暴露

680
00:32:31,218 --> 0:32:34,321
我们有一个读写量化类型

681
00:32:36,256 --> 0:32:37,457
在一天中剩下的时间

682
00:32:37,524 --> 0:32:41,562
当我们走在充斥着建筑工作声音

683
00:32:42,329 --> 0:32:46,400
Apple Watch可以捕捉

684
00:32:46,466 --> 0:32:47,701
并把它保存到HealthKit中

685
00:32:48,035 --> 0:32:50,637
为此我们有一个类似的读写量化类型

686
00:32:50,971 --> 0:32:52,306
environmentalAudioExposure

687
00:32:53,707 --> 0:32:57,311
如果环境中的音频暴露太高

688
00:32:57,978 --> 0:33:00,581
Apple Watch会生成一个

689
00:32:57,978 --> 0:33:00,581
Apple Watch会生成一个

690
00:33:00,647 --> 0:33:03,217
以确保你了解

691
00:33:03,283 --> 0:33:05,219
那可能对你的耳朵健康

692
00:33:05,986 --> 0:33:08,722
并且它会使用新audioExposureEvent

693
00:33:08,789 --> 0:33:12,059
把这个保存为类别样本

694
00:33:14,595 --> 0:33:17,598
那么我们讲了许多

695
00:33:17,664 --> 0:33:20,167
在HealthKit和

696
00:33:20,901 --> 0:33:25,072
从新的、有效率的系列表达

697
00:33:26,707 --> 0:33:30,577
现在你可以正式存储

698
00:33:30,911 --> 0:33:33,614
大多数冗余数据

699
00:33:33,680 --> 0:33:34,848
（总结）

700
00:33:34,915 --> 0:33:37,818
并且你可以表达更丰富的

701
00:33:38,352 --> 0:33:41,388
关于心脏和听力健康的数据的表达

702
00:33:41,455 --> 0:33:42,623
（有效率地存储大量HK量化数据）

703
00:33:42,990 --> 0:33:46,627
要获取更多信息以及你在这里

704
00:33:46,994 --> 0:33:51,532
你可以访问我们的演讲链接

705
00:33:51,598 --> 0:33:53,433
与我们在健康与

706
00:33:54,902 --> 0:33:57,471
谢谢大家 祝你们WWDC过得愉快
