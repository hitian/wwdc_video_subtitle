1
00:00:01,176 --> 0:00:04,500
[音乐]

2
00:00:11,516 --> 0:00:16,676
[掌声]

3
00:00:17,176 --> 0:00:18,086
&gt;&gt; 大家下午好

4
00:00:18,366 --> 0:00:19,926
我是 Frank Doepke 

5
00:00:19,926 --> 0:00:21,226
我将要探讨的是

6
00:00:21,226 --> 0:00:22,956
Vision 框架中的文本识别

7
00:00:23,506 --> 0:00:28,236
如今 熟悉 Vision 的人

8
00:00:28,236 --> 0:00:29,446
都知道我们已经有了

9
00:00:29,446 --> 0:00:32,735
VNDetectRectangleRequest

10
00:00:32,735 --> 0:00:34,796
它可以告诉你图像中的文本在哪里

11
00:00:36,176 --> 0:00:38,286
出于某些原因

12
00:00:38,286 --> 0:00:40,176
我们总会遇到一个问题

13
00:00:40,176 --> 0:00:41,086
文本是什么

14
00:00:41,806 --> 0:00:43,496
所以我们需要一些

15
00:00:43,696 --> 0:00:44,946
额外的代码来解答

16
00:00:45,156 --> 0:00:46,776
它将你的结果以数组存放

17
00:00:47,916 --> 0:00:50,206
然后你需要训练

18
00:00:50,206 --> 0:00:52,456
实际上可以读取这些内容的 

19
00:00:52,456 --> 0:00:53,606
Core ML 模型

20
00:00:55,076 --> 0:00:57,636
接下来运行 Core ML 模型

21
00:00:58,376 --> 0:01:01,256
滤除不好的特征

22
00:00:58,376 --> 0:01:01,256
滤除不好的特征

23
00:01:02,086 --> 0:01:03,156
你把所有这些字符

24
00:01:03,156 --> 0:01:05,336
放到一个字符串中

25
00:01:05,336 --> 0:01:06,646
然后想出一些

26
00:01:07,056 --> 0:01:08,926
启发性的方法并从中真正

27
00:01:08,926 --> 0:01:10,536
形成句子和单词

28
00:01:11,926 --> 0:01:12,956
所以现在你明白

29
00:01:12,956 --> 0:01:14,366
为什么我们需要一个完整的会议

30
00:01:14,366 --> 0:01:14,906
来讨论文本识别

31
00:01:15,436 --> 0:01:18,506
但今天我想让这更容易些

32
00:01:19,756 --> 0:01:21,536
我们带来了一些新东西

33
00:01:21,536 --> 0:01:23,606
那就是 VNRecognizedTextRequest

34
00:01:24,136 --> 0:01:26,556
也就是你在这里

35
00:01:26,556 --> 0:01:30,006
看到的一小段文本 [掌声]

36
00:01:30,886 --> 0:01:34,466
它让你从这样的图像中

37
00:01:34,466 --> 0:01:37,946
进入这样的可识别文本

38
00:01:38,036 --> 0:01:40,036
[掌声]

39
00:01:40,056 --> 0:01:46,436
谢谢 好的 那么今天

40
00:01:46,436 --> 0:01:49,256
我们要介绍什么呢 首先我们来谈一谈

41
00:01:49,256 --> 0:01:51,636
文本识别的工作原理

42
00:01:53,056 --> 0:01:54,266
我们有许多示例 App

43
00:01:54,266 --> 0:01:56,126
它们也都

44
00:01:56,126 --> 0:01:57,356
添加到了会议资料中

45
00:01:57,356 --> 0:01:58,696
因此你可以下载示例代码

46
00:02:00,156 --> 0:02:01,986
最后我们将介绍一些关于

47
00:02:02,046 --> 0:02:03,756
如何在 Vision 中使用文本识别技术

48
00:02:03,756 --> 0:02:04,296
来工作的最佳实践

49
00:02:04,866 --> 0:02:07,746
那么 文本识别是如何在 Vision 中实现的呢

50
00:02:08,446 --> 0:02:11,156
我们有两条路可供选择

51
00:02:11,246 --> 0:02:15,626
快速路径和精确路径

52
00:02:18,216 --> 0:02:21,446
快速路径实际上

53
00:02:21,446 --> 0:02:22,626
是通过查找字符来实现

54
00:02:22,626 --> 0:02:24,896
文本检测器之前所做的工作

55
00:02:25,626 --> 0:02:28,686
然后推进一个小型机器学习模型

56
00:02:28,686 --> 0:02:30,336
来实际地识别

57
00:02:30,336 --> 0:02:31,556
这些字符

58
00:02:31,896 --> 0:02:33,856
逐个识别

59
00:02:35,176 --> 0:02:36,796
而精确路径

60
00:02:36,796 --> 0:02:38,716
则使用最先进的

61
00:02:39,336 --> 0:02:41,976
神经网络

62
00:02:42,466 --> 0:02:44,056
通过首先以字符串和整行

63
00:02:44,056 --> 0:02:45,646
来识别文本

64
00:02:46,656 --> 0:02:49,646
然后将其识别为

65
00:02:49,866 --> 0:02:50,696
单词和句子

66
00:02:52,586 --> 0:02:54,826
因此它要求一个

67
00:02:54,826 --> 0:02:56,966
深度学习模型

68
00:02:56,966 --> 0:02:58,766
这要花费更多时间来计算

69
00:02:58,766 --> 0:03:00,536
但它读得更多

70
00:02:58,766 --> 0:03:00,536
但它读得更多

71
00:03:00,576 --> 0:03:01,716
就像我们实际阅读文本

72
00:03:02,936 --> 0:03:04,626
我们不逐字阅读

73
00:03:04,626 --> 0:03:05,456
我们以单词为单位阅读

74
00:03:05,456 --> 0:03:08,106
这有助于我们了解

75
00:03:08,106 --> 0:03:10,156
你也知道某些字符可能有点

76
00:03:10,156 --> 0:03:12,506
难以阅读

77
00:03:12,506 --> 0:03:13,726
这也是为什么

78
00:03:13,726 --> 0:03:15,076
当我们试图校对我们的文本时

79
00:03:15,076 --> 0:03:17,146
我们看不到错别字

80
00:03:17,326 --> 0:03:18,876
因为我们的大脑

81
00:03:18,876 --> 0:03:20,126
会对这些错误进行插补

82
00:03:20,506 --> 0:03:21,646
所以我们在精确路径中

83
00:03:21,646 --> 0:03:23,426
使用相同类型的技术

84
00:03:23,426 --> 0:03:24,996
来帮助我们克服

85
00:03:25,036 --> 0:03:26,466
一些识别错误

86
00:03:28,056 --> 0:03:30,716
之后的两个阶段

87
00:03:30,716 --> 0:03:32,126
实际上都会经历一个

88
00:03:32,126 --> 0:03:33,786
语言矫正阶段

89
00:03:33,836 --> 0:03:35,116
这有助于我们再次

90
00:03:35,116 --> 0:03:36,246
消除一些典型的误读

91
00:03:37,536 --> 0:03:39,426
我们得到了结果

92
00:03:40,066 --> 0:03:43,446
你可能认为这是一个复杂的机器

93
00:03:44,226 --> 0:03:47,066
但这一切都发生在设备上

94
00:03:48,516 --> 0:03:52,500
[掌声]

95
00:03:55,096 --> 0:03:56,286
下面我们一起来看一下

96
00:03:56,286 --> 0:03:57,976
快速路径与精确路径的区别

97
00:04:00,296 --> 0:04:01,526
我做了一个

98
00:04:01,526 --> 0:04:03,406
阅读这个文件的屏幕录制

99
00:04:04,286 --> 0:04:05,976
因为我是在一个相对较旧的 

100
00:04:05,976 --> 0:04:06,816
MacBook Pro 上做的

101
00:04:06,816 --> 0:04:07,856
所以你看到的时间

102
00:04:07,856 --> 0:04:09,286
不一定具有代表性

103
00:04:09,386 --> 0:04:11,466
不过我想给你一个直观感觉

104
00:04:11,466 --> 0:04:13,876
接下来我们看看快速路径有多快

105
00:04:15,696 --> 0:04:18,206
已经完成了

106
00:04:18,416 --> 0:04:19,716
下面再来看看

107
00:04:19,716 --> 0:04:20,426
精确路径需要多长时间

108
00:04:21,245 --> 0:04:22,856
你看到了过程吗

109
00:04:22,856 --> 0:04:24,766
它花的时间更长一点

110
00:04:25,346 --> 0:04:26,486
正如我所说 

111
00:04:26,486 --> 0:04:28,236
这些数字并不能说明一切 

112
00:04:28,306 --> 0:04:29,196
但它能给你一个直观感受

113
00:04:30,466 --> 0:04:31,846
另外你还可以看到

114
00:04:32,726 --> 0:04:34,356
在阅读整篇文章方面

115
00:04:34,406 --> 0:04:35,766
精确路径的效果更棒

116
00:04:35,936 --> 0:04:37,246
快速路径顶部的

117
00:04:37,246 --> 0:04:39,836
程式化字体有一点问题

118
00:04:40,956 --> 0:04:42,146
因此在这两条路径之间

119
00:04:42,146 --> 0:04:45,736
有一些方面需要权衡

120
00:04:45,736 --> 0:04:48,686
让我们来看看这些权衡

121
00:04:48,756 --> 0:04:50,726
快速路径是为了

122
00:04:50,726 --> 0:04:52,366
实时阅读

123
00:04:52,366 --> 0:04:53,366
并为此进行了优化

124
00:04:53,366 --> 0:04:55,106
但是精确路径

125
00:04:55,166 --> 0:04:56,676
更有可能以一种

126
00:04:56,676 --> 0:04:57,656
异步方式使用

127
00:04:58,236 --> 0:05:01,416
在内存预算方面

128
00:04:58,236 --> 0:05:01,416
在内存预算方面

129
00:05:01,776 --> 0:05:03,866
快速路径使用较少的内存

130
00:05:03,866 --> 0:05:05,976
因为它不需要运行大型神经网络

131
00:05:09,426 --> 0:05:11,236
但是当涉及到

132
00:05:11,236 --> 0:05:13,696
旋转文本或透视错位文本时

133
00:05:13,696 --> 0:05:16,336
精确路径会为你

134
00:05:16,336 --> 0:05:17,546
提供更广泛的支持

135
00:05:19,136 --> 0:05:21,256
当涉及到样式或字体时

136
00:05:21,336 --> 0:05:23,556
就如同你在示例中

137
00:05:23,556 --> 0:05:25,426
看到的那样

138
00:05:25,426 --> 0:05:26,736
当涉及到样式化文本时

139
00:05:26,736 --> 0:05:28,026
精确路径再次提供

140
00:05:28,026 --> 0:05:29,306
更广泛的支持

141
00:05:30,576 --> 0:05:34,306
最后 当涉及到自然语言的

142
00:05:34,306 --> 0:05:36,646
真实阅读时

143
00:05:36,646 --> 0:05:37,816
我们会推荐精确路径

144
00:05:37,816 --> 0:05:40,026
因为它在该部分

145
00:05:41,716 --> 0:05:41,856
表现最好

146
00:05:42,046 --> 0:05:44,046
那么你如何在这两者之间做出选择呢

147
00:05:45,266 --> 0:05:46,926
你所拥有的用例

148
00:05:47,556 --> 0:05:48,766
是实际驱动你

149
00:05:48,766 --> 0:05:50,256
想要如何使用请求的

150
00:05:50,256 --> 0:05:51,366
重要部分

151
00:05:52,516 --> 0:05:54,226
你还需要考虑一些事情

152
00:05:54,866 --> 0:05:55,796
比如我的输入是什么

153
00:05:56,216 --> 0:05:57,686
我是在使用相机

154
00:05:57,686 --> 0:06:00,096
还是已经在照片库中

155
00:05:57,686 --> 0:06:00,096
还是已经在照片库中

156
00:06:00,096 --> 0:06:01,506
得到了要处理的图像

157
00:06:03,726 --> 0:06:05,376
我的处理限制是什么

158
00:06:05,876 --> 0:06:08,076
我可以在这个请求上花费多少时间

159
00:06:08,266 --> 0:06:10,086
我有多少可用的内存

160
00:06:10,586 --> 0:06:11,966
一些进程可能会

161
00:06:11,966 --> 0:06:15,216
受到内存限制以及最后

162
00:06:15,216 --> 0:06:16,366
我将如何处理这些结果

163
00:06:16,876 --> 0:06:18,506
用它们来转录吗

164
00:06:18,796 --> 0:06:19,666
还是用来搜索呢

165
00:06:20,006 --> 0:06:22,156
或者只是根据我

166
00:06:22,156 --> 0:06:23,256
通过相机读取的内容执行操作

167
00:06:23,256 --> 0:06:26,956
下面我们再来谈谈

168
00:06:26,956 --> 0:06:28,406
相机捕捉的细节

169
00:06:29,916 --> 0:06:31,376
相机捕捉技术

170
00:06:31,376 --> 0:06:32,206
可以用作实时捕捉

171
00:06:32,236 --> 0:06:33,836
所以你现在实际上

172
00:06:33,836 --> 0:06:36,146
想要使用字符串读取

173
00:06:36,146 --> 0:06:37,076
并保持帧速率

174
00:06:37,366 --> 0:06:38,946
在这种情况下

175
00:06:38,946 --> 0:06:39,966
快速路径最有可能是

176
00:06:39,966 --> 0:06:40,446
你想要使用的路径

177
00:06:40,946 --> 0:06:43,796
不过这里也存在着

178
00:06:43,796 --> 0:06:44,916
机会性捕捉

179
00:06:45,256 --> 0:06:47,036
我的意思是 例如

180
00:06:47,036 --> 0:06:48,486
你拍了一张照片

181
00:06:48,486 --> 0:06:49,366
照片中的某个地方有文本

182
00:06:49,366 --> 0:06:50,316
你想处理它

183
00:06:50,316 --> 0:06:51,596
你不需要跟上

184
00:06:51,596 --> 0:06:52,586
相机的帧速率

185
00:06:52,586 --> 0:06:54,286
但你事实上希望

186
00:06:54,286 --> 0:06:55,626
使用它来读取文本

187
00:06:55,626 --> 0:06:56,936
因此精确路径

188
00:06:56,936 --> 0:06:58,236
最有可能提供更好的结果

189
00:06:59,856 --> 0:07:01,346
当我们谈论相机时

190
00:06:59,856 --> 0:07:01,346
当我们谈论相机时

191
00:07:01,346 --> 0:07:03,876
还有一件事要考虑

192
00:07:03,876 --> 0:07:06,246
我需要在我的 App 中

193
00:07:06,246 --> 0:07:07,326
设计使用哪种分辨率

194
00:07:07,326 --> 0:07:09,516
而文本大小

195
00:07:09,576 --> 0:07:11,626
实际上会驱动这个问题

196
00:07:11,626 --> 0:07:12,846
如果出于某种原因

197
00:07:12,846 --> 0:07:14,006
你想阅读

198
00:07:14,006 --> 0:07:15,756
法律文件的细则

199
00:07:15,756 --> 0:07:17,046
你可能真的需要

200
00:07:17,046 --> 0:07:18,336
增加相机的分辨率

201
00:07:18,636 --> 0:07:20,356
或者当你阅读

202
00:07:20,356 --> 0:07:22,016
带有大文字的广告牌时

203
00:07:22,016 --> 0:07:23,006
你实际上可以降低分辨率

204
00:07:23,006 --> 0:07:24,256
用更少的内存工作

205
00:07:24,256 --> 0:07:25,906
且速度实际上也会更快

206
00:07:28,256 --> 0:07:29,596
现在涉及到后期处理

207
00:07:29,596 --> 0:07:30,986
我们已经在一个文件中

208
00:07:31,036 --> 0:07:32,836
保存了图像

209
00:07:34,196 --> 0:07:35,276
你最有可能选用精确路径

210
00:07:35,276 --> 0:07:36,796
因为这样你可以

211
00:07:36,796 --> 0:07:38,856
实际使用更好的准确性

212
00:07:38,856 --> 0:07:40,976
而速度显得并不那么重要

213
00:07:44,396 --> 0:07:46,416
接下来 我们来谈谈语言处理

214
00:07:46,686 --> 0:07:47,946
正如我提到的

215
00:07:47,946 --> 0:07:49,166
语言处理

216
00:07:49,166 --> 0:07:50,426
是文本识别中

217
00:07:50,426 --> 0:07:51,086
可以使用的阶段之一

218
00:07:52,576 --> 0:07:54,106
它有利于帮助我们

219
00:07:54,106 --> 0:07:56,026
克服一些在阅读文本时

220
00:07:56,026 --> 0:07:57,446
可能会发生的典型误读

221
00:07:57,446 --> 0:08:00,066
但另一方面

222
00:07:57,446 --> 0:08:00,066
但另一方面

223
00:08:00,066 --> 0:08:00,456
它也会产生阻碍

224
00:08:01,216 --> 0:08:02,956
当我想读取

225
00:08:02,956 --> 0:08:04,276
代码或序列号时

226
00:08:04,276 --> 0:08:07,356
像 C001 这样的序列号

227
00:08:07,356 --> 0:08:08,976
它很容易被误认为是 Cool

228
00:08:12,126 --> 0:08:13,326
此外这种语言修正

229
00:08:13,326 --> 0:08:14,416
不是免费的

230
00:08:14,416 --> 0:08:15,636
它确实需要一些处理时间

231
00:08:15,636 --> 0:08:17,826
并且需要使用一点点内存

232
00:08:20,306 --> 0:08:21,226
现在我们已经掌握了

233
00:08:21,226 --> 0:08:22,626
一些基本的方法 

234
00:08:22,626 --> 0:08:25,126
接下来我们就来谈谈

235
00:08:25,126 --> 0:08:27,186
如何执行文本识别

236
00:08:28,896 --> 0:08:32,086
Vision 中的所有内容

237
00:08:32,086 --> 0:08:33,226
都从 ImageRequestHandler 开始 

238
00:08:34,586 --> 0:08:35,996
下面我创建我的请求

239
00:08:36,066 --> 0:08:39,506
我在上面设置了 completionHandler 

240
00:08:39,506 --> 0:08:40,746
这就是我

241
00:08:40,746 --> 0:08:41,586
处理结果的地方

242
00:08:41,586 --> 0:08:45,266
然后设置 recognitionLevel

243
00:08:45,526 --> 0:08:47,086
如我所说

244
00:08:47,086 --> 0:08:48,976
我可以在快速和精确之间切换

245
00:08:51,366 --> 0:08:53,516
接下来

246
00:08:53,516 --> 0:08:54,576
我建议你实际设置 revision

247
00:08:55,136 --> 0:08:58,736
当然这里只有一个修订版

248
00:08:58,736 --> 0:08:59,876
但是接下来我们将

249
00:08:59,876 --> 0:09:01,666
推出改进的版本

250
00:08:59,876 --> 0:09:01,666
推出改进的版本

251
00:09:01,736 --> 0:09:03,436
你可能已经将算法

252
00:09:03,436 --> 0:09:05,576
调到了我们拥有的特定行为

253
00:09:05,716 --> 0:09:06,976
如果不指定修订版

254
00:09:06,976 --> 0:09:08,256
你将始终获得最新版本

255
00:09:08,256 --> 0:09:10,076
这样的话

256
00:09:10,076 --> 0:09:11,726
可能会出现一些意外

257
00:09:12,796 --> 0:09:14,686
所以

258
00:09:14,686 --> 0:09:15,706
我建议你们

259
00:09:15,706 --> 0:09:16,096
了解如何使用修订版

260
00:09:16,506 --> 0:09:18,836
最后

261
00:09:18,836 --> 0:09:22,436
我可以打开和关闭语言修正

262
00:09:22,436 --> 0:09:23,926
当然我还需要

263
00:09:23,926 --> 0:09:25,446
执行我的请求

264
00:09:27,556 --> 0:09:31,856
当执行请求时 我们会得到结果 这些结果作为

265
00:09:31,856 --> 0:09:34,076
VNRecognizedTextObservation 返回

266
00:09:34,316 --> 0:09:35,656
我们得到的基本上

267
00:09:35,656 --> 0:09:37,606
就是我们要找的行和字符串

268
00:09:38,616 --> 0:09:40,576
因此我们需要迭代这些结果

269
00:09:40,876 --> 0:09:44,426
然后我们想要得出文本

270
00:09:44,426 --> 0:09:46,656
实际上我们有多种候选

271
00:09:46,656 --> 0:09:47,646
稍后我会谈一下

272
00:09:47,646 --> 0:09:48,746
其中一些候选

273
00:09:49,016 --> 0:09:50,466
为了简单起见

274
00:09:50,466 --> 0:09:52,646
我只得到了我的最佳候选 并且得到了自己的文本

275
00:09:52,996 --> 0:09:55,226
我可以获取边界框

276
00:09:55,226 --> 0:09:56,536
这帮助我

277
00:09:56,536 --> 0:09:58,326
把所有的文本

278
00:09:58,646 --> 0:10:01,756
放在屏幕上或屏幕上的图像中

279
00:09:58,646 --> 0:10:01,756
放在屏幕上或屏幕上的图像中

280
00:10:03,616 --> 0:10:04,956
但现在当我想使用搜索时

281
00:10:04,956 --> 0:10:06,446
例如用户键入

282
00:10:06,446 --> 0:10:08,676
在文档中读到的单词

283
00:10:08,976 --> 0:10:10,126
我们想在图像中

284
00:10:10,126 --> 0:10:11,796
再次找到

285
00:10:11,796 --> 0:10:13,706
这个单词的实际位置时

286
00:10:13,706 --> 0:10:15,936
我可以向候选询问

287
00:10:16,116 --> 0:10:17,486
我在结果中实际看到的

288
00:10:17,486 --> 0:10:19,156
这个字符串的

289
00:10:19,456 --> 0:10:20,796
边界框在哪里

290
00:10:24,066 --> 0:10:25,446
现在了解完整个理论

291
00:10:25,446 --> 0:10:26,836
我们来看一些例子

292
00:10:26,836 --> 0:10:28,836
做一些实时的文本识别

293
00:10:29,446 --> 0:10:31,596
这就是我们想要使用

294
00:10:31,596 --> 0:10:32,856
快速路径的时候

295
00:10:33,636 --> 0:10:36,096
这里使用的例子是

296
00:10:36,096 --> 0:10:37,046
我想读取序列号

297
00:10:37,046 --> 0:10:38,206
或代码之类的东西

298
00:10:39,096 --> 0:10:40,416
我在这里使用的序列号

299
00:10:40,416 --> 0:10:41,526
实际上是一个电话号码

300
00:10:41,526 --> 0:10:42,466
因为它对每个人来说

301
00:10:42,466 --> 0:10:44,086
都是最容易理解的

302
00:10:44,086 --> 0:10:45,516
我真的想

303
00:10:45,516 --> 0:10:46,716
像读条形码一样读它们

304
00:10:47,126 --> 0:10:49,836
有了这个

305
00:10:49,836 --> 0:10:50,986
我就可以限制相机

306
00:10:50,986 --> 0:10:53,756
如何实际地查找文本

307
00:10:53,756 --> 0:10:56,886
不过交互性是关键 因为它应该是活跃的

308
00:10:56,886 --> 0:10:57,846
它也应该很快

309
00:10:57,846 --> 0:10:59,956
以便可以引导用户 并立即读取文本

310
00:11:02,576 --> 0:11:04,756
所以这就是我为什么

311
00:11:04,756 --> 0:11:05,376
在这里选择快速路径

312
00:11:05,376 --> 0:11:07,936
然后我们来看看演示

313
00:11:16,596 --> 0:11:20,136
好了 我这里的示例代码

314
00:11:20,136 --> 0:11:21,306
就像我之前说的

315
00:11:21,306 --> 0:11:24,156
也附在这个会议资料中

316
00:11:24,156 --> 0:11:25,436
允许我读取电话号码

317
00:11:25,536 --> 0:11:27,126
所以当我扫描这个文本时

318
00:11:27,126 --> 0:11:28,926
你会看到一个小白框

319
00:11:28,926 --> 0:11:30,856
这意味着我找到了文本

320
00:11:30,856 --> 0:11:32,456
但我没有读它

321
00:11:32,456 --> 0:11:33,026
因为它不是电话号码

322
00:11:33,026 --> 0:11:34,576
甚至不是邮政编码

323
00:11:36,156 --> 0:11:37,336
但一旦我找到一个电话号码

324
00:11:37,336 --> 0:11:39,346
它就会读出来并停止扫描

325
00:11:39,346 --> 0:11:41,556
我再展示一次

326
00:11:42,516 --> 0:11:45,556
[掌声]

327
00:11:46,056 --> 0:11:47,466
它给人以互动感

328
00:11:47,466 --> 0:11:48,926
作为一个用户

329
00:11:48,926 --> 0:11:50,176
我很容易使用它

330
00:11:50,176 --> 0:11:52,516
即使我的手在颤抖

331
00:11:53,756 --> 0:11:55,376
那么这在代码中

332
00:11:55,376 --> 0:11:56,596
看起来如何呢

333
00:11:56,596 --> 0:11:57,496
因为这是真正有趣的部分

334
00:11:59,316 --> 0:12:01,796
所以我从创建文本请求开始

335
00:11:59,316 --> 0:12:01,796
所以我从创建文本请求开始

336
00:12:04,176 --> 0:12:06,076
正如我所说

337
00:12:06,076 --> 0:12:08,396
我将在这里使用快速路径

338
00:12:08,396 --> 0:12:09,296
我禁用了语言修正

339
00:12:09,326 --> 0:12:11,346
因为我知道 我正在寻找代码

340
00:12:11,346 --> 0:12:12,806
而不是在找自然文本

341
00:12:12,956 --> 0:12:16,466
然后我使用 regionOfInterest

342
00:12:16,466 --> 0:12:17,376
这是一个设想的概念

343
00:12:17,376 --> 0:12:18,706
并且普遍可用

344
00:12:19,176 --> 0:12:21,206
你会注意到

345
00:12:21,206 --> 0:12:22,476
在我的 App 中有一个小方框

346
00:12:22,476 --> 0:12:23,866
可以指导用户

347
00:12:23,866 --> 0:12:25,206
在想要的位置构建文本

348
00:12:25,206 --> 0:12:27,386
但是我也可以将这个区域

349
00:12:27,386 --> 0:12:29,546
作为兴趣区域

350
00:12:29,546 --> 0:12:31,126
这会使 Vision 

351
00:12:31,126 --> 0:12:32,256
只针对该特定对象

352
00:12:32,356 --> 0:12:36,276
这有助于我消除周围的所有噪音

353
00:12:36,276 --> 0:12:39,916
因为它需要处理的数据更少

354
00:12:39,916 --> 0:12:41,196
提高了性能

355
00:12:41,786 --> 0:12:44,756
现在我有我的请求

356
00:12:44,756 --> 0:12:46,356
我在这里使用 AVCapture 会话

357
00:12:47,576 --> 0:12:48,926
关于捕捉输出

358
00:12:48,926 --> 0:12:51,186
我所要做的就是

359
00:12:51,186 --> 0:12:53,316
从会话中获取我的图像

360
00:12:53,316 --> 0:12:57,166
创建 RequestHandler 并执行请求

361
00:12:57,166 --> 0:13:00,616
然后 这主要是框的绘制

362
00:12:57,166 --> 0:13:00,616
然后 这主要是框的绘制

363
00:13:00,616 --> 0:13:01,876
那还不是有趣的部分

364
00:13:03,026 --> 0:13:04,676
有趣的部分发生在

365
00:13:04,676 --> 0:13:05,556
我们的字符串工具中

366
00:13:05,666 --> 0:13:09,116
就像我说的

367
00:13:09,116 --> 0:13:10,536
我们关闭了语言修正

368
00:13:11,256 --> 0:13:13,686
我现在只能自己去修正其中的一些结果

369
00:13:13,686 --> 0:13:15,556
不过我能做好这一点

370
00:13:15,556 --> 0:13:16,766
因为我对这里

371
00:13:16,806 --> 0:13:19,206
需要解决的内容有内在的了解

372
00:13:19,206 --> 0:13:24,426
我知道我正在寻找电话号码

373
00:13:24,426 --> 0:13:25,826
而不是找其他字符

374
00:13:25,826 --> 0:13:28,266
我只是在寻找数字路径

375
00:13:28,266 --> 0:13:29,826
所以我可以简单地说

376
00:13:29,826 --> 0:13:31,936
如果它读取的内容类似于 S

377
00:13:31,936 --> 0:13:33,926
这将是一个 5

378
00:13:33,926 --> 0:13:35,576
或者如果我得到一个 L

379
00:13:35,576 --> 0:13:36,876
这应该是 1

380
00:13:36,876 --> 0:13:37,886
我使用我的领域知识

381
00:13:37,886 --> 0:13:38,956
来修正一些可能发生的典型错误

382
00:13:41,176 --> 0:13:42,846
因此这个方式

383
00:13:42,846 --> 0:13:44,556
帮助我们

384
00:13:44,606 --> 0:13:46,206
不让任何字母通过

385
00:13:46,206 --> 0:13:49,366
接下来是下一部分 我是如何区分

386
00:13:49,366 --> 0:13:50,546
邮政编码和电话号码的呢

387
00:13:50,646 --> 0:13:51,886
我知道其结构

388
00:13:52,546 --> 0:13:53,646
美国电话号码的结构

389
00:13:53,646 --> 0:13:55,586
非常简单

390
00:13:55,626 --> 0:13:57,236
我再次利用这些知识

391
00:13:57,386 --> 0:13:58,976
来过滤掉我不想要的结果

392
00:14:00,896 --> 0:14:03,816
最后是字符串跟踪器

393
00:14:03,816 --> 0:14:06,036
让我发现了这一点

394
00:14:06,036 --> 0:14:08,076
现在我在这里使用一个小技巧

395
00:14:08,646 --> 0:14:09,936
如果你曾经处理过

396
00:14:09,936 --> 0:14:11,206
从相机输入中读取的东西

397
00:14:11,206 --> 0:14:12,656
你会意识到

398
00:14:12,656 --> 0:14:14,406
从一帧到另一帧

399
00:14:14,406 --> 0:14:15,276
你会得到不同的结果

400
00:14:15,406 --> 0:14:16,816
由于噪音 灯光等原因

401
00:14:16,816 --> 0:14:19,086
它们略有波动

402
00:14:20,036 --> 0:14:21,696
但是如果我拨错了电话号码

403
00:14:21,696 --> 0:14:23,306
那就太糟糕了

404
00:14:23,776 --> 0:14:25,736
因此我会尽量避免

405
00:14:25,736 --> 0:14:27,186
显示错误结果

406
00:14:27,856 --> 0:14:29,166
我在这里使用了一种技术

407
00:14:29,166 --> 0:14:31,056
在其中我可实际查看

408
00:14:31,056 --> 0:14:32,596
多个帧并随着时间的推移

409
00:14:32,596 --> 0:14:33,716
建立证据

410
00:14:34,356 --> 0:14:35,526
随着时间的推移

411
00:14:35,526 --> 0:14:37,136
这种证据的建立意味着

412
00:14:37,136 --> 0:14:39,656
我只需存储电话号码

413
00:14:39,656 --> 0:14:41,406
最后 我所做的都非常简单

414
00:14:42,106 --> 0:14:43,906
如果相同的数字

415
00:14:43,906 --> 0:14:45,906
出现在 10 个连续的帧中

416
00:14:45,906 --> 0:14:47,246
我就知道我已经读过它

417
00:14:47,286 --> 0:14:48,496
并实际传播给了用户

418
00:14:49,116 --> 0:14:50,746
现在我们选择 10 

419
00:14:50,746 --> 0:14:52,646
作为实验数字

420
00:14:52,646 --> 0:14:53,416
它对我们来说非常有效

421
00:14:53,576 --> 0:14:56,776
有了这个

422
00:14:56,776 --> 0:14:58,666
我基本上过滤掉了

423
00:14:58,666 --> 0:15:00,226
所有的噪音

424
00:14:58,666 --> 0:15:00,226
所有的噪音

425
00:15:01,016 --> 0:15:02,636
这就是我们进行演示

426
00:15:02,636 --> 0:15:04,446
运行中需要做的

427
00:15:04,446 --> 0:15:05,916
现在我们回到幻灯片

428
00:15:10,336 --> 0:15:11,556
我们来快速回顾一下

429
00:15:11,556 --> 0:15:14,936
我使用快速路径

430
00:15:15,566 --> 0:15:17,216
来保持相机的帧速率

431
00:15:17,216 --> 0:15:20,376
我能够指导用户

432
00:15:20,376 --> 0:15:21,296
如何使用相机

433
00:15:22,216 --> 0:15:23,776
我通过感兴趣的区域

434
00:15:23,776 --> 0:15:25,326
裁剪出我真正

435
00:15:25,326 --> 0:15:26,756
想阅读的内容

436
00:15:26,756 --> 0:15:29,986
以消除周围的噪音并提高性能

437
00:15:30,736 --> 0:15:31,586
我关掉了语言修正

438
00:15:31,646 --> 0:15:32,776
因为我知道

439
00:15:32,776 --> 0:15:33,916
现在正在读代码

440
00:15:33,916 --> 0:15:36,486
我使用自己的领域知识

441
00:15:36,486 --> 0:15:37,566
来正确地读取它们

442
00:15:37,566 --> 0:15:38,636
这就像你和 App 开发人员

443
00:15:38,636 --> 0:15:40,336
对这个电话号码

444
00:15:40,336 --> 0:15:42,396
所做的一样

445
00:15:42,396 --> 0:15:46,626
最后 随着时间的推移

446
00:15:46,626 --> 0:15:48,976
我使用这些证据 来实际帮助减少一些噪音

447
00:15:52,386 --> 0:15:53,916
接下来我想介绍一下

448
00:15:54,056 --> 0:15:55,746
扫描文稿相机

449
00:15:57,476 --> 0:16:01,316
两年前 备忘录已经介绍了

450
00:15:57,476 --> 0:16:01,316
两年前 备忘录已经介绍了

451
00:16:01,316 --> 0:16:01,786
扫描文稿相机

452
00:16:02,066 --> 0:16:04,686
当你不需要 使用实时流捕捉它时

453
00:16:04,686 --> 0:16:07,006
它是一个非常好的伙伴

454
00:16:07,696 --> 0:16:08,956
今年你已经在

455
00:16:08,956 --> 0:16:11,356
备忘录邮箱文件

456
00:16:11,356 --> 0:16:11,916
和信息中看到过它

457
00:16:12,296 --> 0:16:15,836
它已经非常适合 阅读文档

458
00:16:16,066 --> 0:16:17,776
因为正如你在这里看到的

459
00:16:17,776 --> 0:16:19,826
它可以找到文档

460
00:16:19,826 --> 0:16:21,626
裁剪出来

461
00:16:21,626 --> 0:16:24,346
现在我可以简单地将其输入到我的文本识别请求中

462
00:16:25,096 --> 0:16:26,516
它是一个很好的伙伴

463
00:16:26,516 --> 0:16:28,716
因为它所做的

464
00:16:28,716 --> 0:16:30,166
只是对这些扫描的

465
00:16:30,166 --> 0:16:32,226
一个前瞻性的修正

466
00:16:32,226 --> 0:16:34,136
它均匀地照亮了图像

467
00:16:34,876 --> 0:16:36,116
这使得后续处理

468
00:16:36,116 --> 0:16:37,736
变得更加容易

469
00:16:39,036 --> 0:16:42,356
那么这在代码中看起来如何

470
00:16:42,556 --> 0:16:43,746
首先，我需要引入 VisionKit

471
00:16:43,746 --> 0:16:44,796
这是一个新的框架

472
00:16:44,796 --> 0:16:46,506
然后我创建了

473
00:16:46,506 --> 0:16:48,386
VNDocumentCameraViewController

474
00:16:49,366 --> 0:16:51,546
我把它呈现在屏幕上

475
00:16:51,546 --> 0:16:52,536
我的相机正在运行

476
00:16:54,046 --> 0:16:56,006
一旦用户完成了任务

477
00:16:56,006 --> 0:16:58,976
我将在我的 Delegate 中得到结果

478
00:16:58,976 --> 0:17:00,436
现在有一件事要记住

479
00:16:58,976 --> 0:17:00,436
现在有一件事要记住

480
00:17:01,196 --> 0:17:04,185
我们实际上可以

481
00:17:04,185 --> 0:17:05,546
一次扫描多个文档

482
00:17:05,546 --> 0:17:06,396
它们会以页面形式返回

483
00:17:08,036 --> 0:17:09,715
从每一个图像中

484
00:17:09,715 --> 0:17:12,256
我只需把我的 CG 图像

485
00:17:12,256 --> 0:17:14,465
输入到我的 Vision 请求中

486
00:17:14,465 --> 0:17:15,266
就可以得到相应结果

487
00:17:15,695 --> 0:17:18,185
下面

488
00:17:18,185 --> 0:17:19,556
关于一些最佳实践

489
00:17:19,556 --> 0:17:20,906
就由我的同事  

490
00:17:20,906 --> 0:17:22,215
Cedric Bray

491
00:17:22,215 --> 0:17:23,906
向大家介绍更多有关的详细信息 谢谢

492
00:17:24,516 --> 0:17:27,406
[掌声]

493
00:17:27,906 --> 0:17:29,466
&gt;&gt; 谢谢 Frank

494
00:17:30,166 --> 0:17:32,766
我很高兴我们今年

495
00:17:32,856 --> 0:17:34,426
能将文本识别

496
00:17:34,426 --> 0:17:35,636
纳入 Vision 框架当中 

497
00:17:35,636 --> 0:17:38,016
为了帮助你

498
00:17:38,016 --> 0:17:39,656
充分利用这个新 API

499
00:17:39,656 --> 0:17:41,946
我们将讨论最佳实践

500
00:17:44,696 --> 0:17:47,346
因此在本节中

501
00:17:47,346 --> 0:17:49,426
你将学习到语言知识

502
00:17:49,506 --> 0:17:50,466
以及如何利用

503
00:17:50,466 --> 0:17:52,416
语言知识获得最佳结果

504
00:17:53,016 --> 0:17:54,476
你还将学习

505
00:17:54,476 --> 0:17:56,466
如何在 App 中调优

506
00:17:56,466 --> 0:17:57,126
以获得更好的性能

507
00:17:57,596 --> 0:17:59,626
你将学习更多

508
00:17:59,626 --> 0:18:00,946
关于如何以最有效的方式

509
00:17:59,626 --> 0:18:00,946
关于如何以最有效的方式

510
00:18:00,946 --> 0:18:02,276
处理结果的知识

511
00:18:03,366 --> 0:18:07,746
所以你正在

512
00:18:07,746 --> 0:18:10,146
处理的图像

513
00:18:10,146 --> 0:18:11,486
可能使用了你

514
00:18:11,486 --> 0:18:12,196
已经识别的语言

515
00:18:12,856 --> 0:18:14,046
如果在这个

516
00:18:14,046 --> 0:18:15,486
特定的语言中存在

517
00:18:15,486 --> 0:18:17,326
那么你会想要利用这个信息

518
00:18:17,916 --> 0:18:20,456
为此你需要启用

519
00:18:20,456 --> 0:18:21,716
基于语言的集合

520
00:18:22,516 --> 0:18:23,786
首先你必须

521
00:18:23,786 --> 0:18:25,116
设定目标语言

522
00:18:25,466 --> 0:18:27,436
这里 我们支持英语

523
00:18:28,116 --> 0:18:31,146
一旦启用基于语言的校正 

524
00:18:31,146 --> 0:18:33,026
它将使用设备上的

525
00:18:33,026 --> 0:18:35,416
语言模型

526
00:18:35,416 --> 0:18:36,406
来改进结果的转录

527
00:18:36,856 --> 0:18:38,656
设备上的语言模型很棒

528
00:18:38,656 --> 0:18:40,196
它们有很大的

529
00:18:40,396 --> 0:18:41,066
通用覆盖范围

530
00:18:42,046 --> 0:18:44,416
但文档中可能会出现

531
00:18:44,556 --> 0:18:45,786
特定于域的单词

532
00:18:45,786 --> 0:18:49,456
特定于域的词汇表

533
00:18:49,986 --> 0:18:52,026
如医学术语

534
00:18:52,026 --> 0:18:53,556
或特定于业务的代码

535
00:18:53,556 --> 0:18:54,176
或文档中出现的引用

536
00:18:54,626 --> 0:18:58,526
我们可以通过

537
00:18:58,526 --> 0:19:00,306
将自定义词典

538
00:18:58,526 --> 0:19:00,306
将自定义词典

539
00:19:00,376 --> 0:19:03,336
传递给文本识别请求

540
00:19:03,736 --> 0:19:06,736
来指定此信息

541
00:19:06,736 --> 0:19:07,206
即此词汇表

542
00:19:08,486 --> 0:19:10,696
当这样做时

543
00:19:10,696 --> 0:19:13,166
这个自定义词汇表

544
00:19:13,166 --> 0:19:14,226
将补充基于语言的校正

545
00:19:14,766 --> 0:19:15,766
以便为你提供

546
00:19:16,006 --> 0:19:18,566
正确的转录

547
00:19:18,566 --> 0:19:20,286
即使在图像更具挑战性的情况下也是如此

548
00:19:21,596 --> 0:19:23,966
接下来让我们看看代码中的情况

549
00:19:25,446 --> 0:19:28,016
首先作为前提条件

550
00:19:28,016 --> 0:19:29,766
你需要检查

551
00:19:29,876 --> 0:19:31,586
基于语言的更正所支持的语言

552
00:19:32,796 --> 0:19:35,186
因此此受支持语言列表

553
00:19:35,186 --> 0:19:38,546
是针对识别级别

554
00:19:38,546 --> 0:19:40,956
和你要定位的

555
00:19:40,956 --> 0:19:45,116
API 版本的组合定义的

556
00:19:46,786 --> 0:19:49,756
启用基于语言的校正很简单

557
00:19:50,016 --> 0:19:51,626
只需在文本识别请求中

558
00:19:51,626 --> 0:19:54,436
将相应的属性设置为 true

559
00:19:55,126 --> 0:19:56,376
初始化自定义单词

560
00:19:56,806 --> 0:19:58,696
可以将此单词列表

561
00:19:58,696 --> 0:20:01,636
指定为字符串数组

562
00:19:58,696 --> 0:20:01,636
指定为字符串数组

563
00:20:02,316 --> 0:20:03,746
并在文本识别请求时

564
00:20:03,746 --> 0:20:06,726
传递给自定义单词属性

565
00:20:08,696 --> 0:20:12,996
因此这对于

566
00:20:12,996 --> 0:20:15,826
优化准确性 转录准确性非常有用

567
00:20:15,826 --> 0:20:17,496
但是性能呢

568
00:20:17,906 --> 0:20:20,206
还有一个很常见的情况

569
00:20:20,206 --> 0:20:22,286
你可能对

570
00:20:22,286 --> 0:20:24,586
图像中的较小文本不感兴趣

571
00:20:26,136 --> 0:20:28,876
对于这种情况

572
00:20:28,876 --> 0:20:30,976
我们建议你调整 minimumTextHeight

573
00:20:31,466 --> 0:20:34,496
它的工作方式是

574
00:20:34,496 --> 0:20:37,216
当设置这些 minimumTextHeight 时

575
00:20:37,216 --> 0:20:39,096
所有小于指定高度的文本

576
00:20:39,096 --> 0:20:40,836
都将被忽略

577
00:20:40,946 --> 0:20:42,156
它不会被处理

578
00:20:42,496 --> 0:20:44,436
不会成为结果的一部分

579
00:20:44,986 --> 0:20:46,736
输入图像会缩小

580
00:20:46,736 --> 0:20:51,906
执行时间也会缩短

581
00:20:51,906 --> 0:20:53,496
识别速度会更快

582
00:20:53,496 --> 0:20:55,976
内存使用率也会下降

583
00:20:57,456 --> 0:20:59,156
关于这个属性

584
00:20:59,706 --> 0:21:03,216
一个重要注意事项是

585
00:20:59,706 --> 0:21:03,216
一个重要注意事项是

586
00:21:03,556 --> 0:21:06,926
它表示为图像高度的一部分

587
00:21:07,436 --> 0:21:08,736
正如你在示例中看到的那样

588
00:21:08,736 --> 0:21:12,576
如果我说 0.5 

589
00:21:12,616 --> 0:21:15,086
则表示将返回大于

590
00:21:15,086 --> 0:21:16,886
或等于图像高度

591
00:21:16,966 --> 0:21:18,886
一半的文本

592
00:21:19,626 --> 0:21:22,486
当你想更快识别文本时

593
00:21:22,486 --> 0:21:24,006
就会出现这种情况

594
00:21:26,256 --> 0:21:28,256
但是如果文本识别

595
00:21:28,256 --> 0:21:30,756
不是 App 中最高优先级的任务呢

596
00:21:31,706 --> 0:21:33,056
也许你还有其他

597
00:21:33,056 --> 0:21:36,066
更高优先级的任务要运行

598
00:21:36,066 --> 0:21:38,276
例如在前景中运行的

599
00:21:38,986 --> 0:21:40,156
ARKit 视图可能是你 App 中的最高优先级

600
00:21:41,066 --> 0:21:43,676
或者例如你正在运行

601
00:21:44,056 --> 0:21:49,466
和实时处理的相机 AR 帧也可能是

602
00:21:49,676 --> 0:21:51,706
那么在后台任务的情况下

603
00:21:51,736 --> 0:21:56,396
我们只允许你

604
00:21:56,396 --> 0:21:59,026
在 CPU 上运行文本识别

605
00:21:59,026 --> 0:22:01,656
这样你可以将 GPU 资源

606
00:21:59,026 --> 0:22:01,656
这样你可以将 GPU 资源

607
00:22:01,656 --> 0:22:03,726
和可选的神经引擎

608
00:22:03,726 --> 0:22:06,196
保留给 App 的更高优先级任务

609
00:22:08,186 --> 0:22:09,476
你可以使用

610
00:22:09,476 --> 0:22:10,996
useCPUOnly 属性执行此操作

611
00:22:10,996 --> 0:22:12,246
它是一个可用于

612
00:22:12,246 --> 0:22:14,866
其他 VN 请求的属性

613
00:22:14,866 --> 0:22:16,916
也适用于所有

614
00:22:17,186 --> 0:22:18,646
其他 VN 请求和文本识别支持

615
00:22:19,996 --> 0:22:21,086
当你故意让文本识别

616
00:22:21,086 --> 0:22:22,256
运行得更慢的时候

617
00:22:22,256 --> 0:22:25,256
就会出现这种情况

618
00:22:25,406 --> 0:22:28,166
但也有一些情况下

619
00:22:28,166 --> 0:22:29,796
图像非常大

620
00:22:29,796 --> 0:22:32,206
文本和文本识别会很多

621
00:22:32,206 --> 0:22:34,346
需要的时间更长

622
00:22:34,346 --> 0:22:36,756
除非你提供进度管理

623
00:22:36,756 --> 0:22:41,046
否则用户会感到困惑

624
00:22:41,716 --> 0:22:44,076
我们强烈建议你

625
00:22:45,416 --> 0:22:47,946
在 App 中关注进度管理

626
00:22:48,826 --> 0:22:54,056
这是今年 Vision 的一个新概念

627
00:22:54,056 --> 0:22:55,436
文本识别完全实现了这一概念

628
00:22:56,056 --> 0:22:57,186
它有两种方式

629
00:22:58,086 --> 0:23:00,456
第一种你可以

630
00:22:58,086 --> 0:23:00,456
第一种你可以

631
00:23:00,526 --> 0:23:02,466
根据请求设置 ProgressHandler

632
00:23:03,886 --> 0:23:08,356
这样做时你将获得进度比率

633
00:23:08,356 --> 0:23:10,776
它是作为 ProgressHandler 的参数

634
00:23:12,336 --> 0:23:15,616
另外你也可以在 App 中支持取消

635
00:23:16,506 --> 0:23:17,836
例如如果向用户

636
00:23:17,836 --> 0:23:19,746
提供按钮

637
00:23:19,746 --> 0:23:21,746
则可以取消

638
00:23:21,746 --> 0:23:23,316
在其前面运行的文本识别

639
00:23:24,226 --> 0:23:26,586
所以这是一系列概念

640
00:23:26,586 --> 0:23:29,016
为了解释它们

641
00:23:29,016 --> 0:23:32,776
我想向你们

642
00:23:32,776 --> 0:23:34,166
展示一个示例 App 的演示

643
00:23:34,166 --> 0:23:35,896
我们也在会议资料中提供它

644
00:23:36,716 --> 0:23:38,866
我将它称为 My First Image Reade

645
00:23:39,566 --> 0:23:42,956
下面我们一起来看看这个 App

646
00:23:51,826 --> 0:23:53,836
所以正如你将看到的

647
00:23:53,836 --> 0:23:56,086
这个示例代码

648
00:23:56,086 --> 0:23:58,386
My First Image Reader

649
00:23:59,206 --> 0:24:01,396
作为主窗口

650
00:23:59,206 --> 0:24:01,396
作为主窗口

651
00:24:01,786 --> 0:24:02,866
以及一个转录面板

652
00:24:03,616 --> 0:24:04,836
主窗口将显示

653
00:24:04,926 --> 0:24:07,346
图像和结果的几何图形

654
00:24:08,016 --> 0:24:12,166
转录窗口将显示文本

655
00:24:13,036 --> 0:24:16,036
如果仔细看窗口顶部

656
00:24:17,406 --> 0:24:18,756
在工具栏上

657
00:24:18,826 --> 0:24:20,686
你会发现可以在精确

658
00:24:20,686 --> 0:24:23,046
和快速之间进行选择

659
00:24:23,526 --> 0:24:24,836
所以这真是一个非常好的

660
00:24:24,886 --> 0:24:26,276
简单的 App

661
00:24:26,346 --> 0:24:29,066
下面我们一起来看看 还有我们刚才

662
00:24:29,066 --> 0:24:31,186
提到的其他设置

663
00:24:32,086 --> 0:24:33,766
性能设置 最小文本高度

664
00:24:33,766 --> 0:24:35,076
稍后我会再回过头来看

665
00:24:35,076 --> 0:24:38,786
在此视图中

666
00:24:38,786 --> 0:24:40,696
你还可以

667
00:24:40,746 --> 0:24:43,576
访问语言设置

668
00:24:43,796 --> 0:24:45,776
启用语言模型

669
00:24:46,316 --> 0:24:48,106
以及自定义单词

670
00:24:48,796 --> 0:24:51,526
现在我用一个

671
00:24:52,566 --> 0:24:55,246
精心设计的示例快速向你展示

672
00:24:56,516 --> 0:24:59,646
假设我拿出一张

673
00:24:59,646 --> 0:25:02,606
我拍摄的图片

674
00:24:59,646 --> 0:25:02,606
我拍摄的图片

675
00:25:02,636 --> 0:25:04,776
并说这是一本书的封面

676
00:25:04,826 --> 0:25:07,876
上面有非常小的文本 恰好是我的名字

677
00:25:09,466 --> 0:25:12,196
你能发现你得到的文本非常小

678
00:25:12,236 --> 0:25:15,576
我的名字在这里被找到

679
00:25:15,576 --> 0:25:16,166
并被识别出来

680
00:25:16,166 --> 0:25:18,716
显然对于非常大的文本 亦是如此

681
00:25:19,826 --> 0:25:21,046
现在假设

682
00:25:21,046 --> 0:25:23,396
我有一堆这样的图片

683
00:25:23,706 --> 0:25:25,886
我只想索引这些图片的标题

684
00:25:26,386 --> 0:25:27,326
我不太关心小字体

685
00:25:27,326 --> 0:25:29,006
特别是我的名字

686
00:25:29,266 --> 0:25:31,346
因此我将调整

687
00:25:31,346 --> 0:25:33,486
最小文本高度

688
00:25:33,486 --> 0:25:34,896
以使识别运行更快

689
00:25:35,556 --> 0:25:39,756
你可以将其设置为 0.1 

690
00:25:40,436 --> 0:25:44,756
那么文本必须

691
00:25:44,756 --> 0:25:46,276
至少为图像高度的 90％

692
00:25:47,046 --> 0:25:50,256
这就是大文本 Desert Dunes 的情况

693
00:25:50,946 --> 0:25:54,346
下面将这些设回 0 

694
00:25:55,626 --> 0:25:57,396
我来向你展示语言设置

695
00:25:57,456 --> 0:26:00,786
特别是自定义单词的影响

696
00:25:57,456 --> 0:26:00,786
特别是自定义单词的影响

697
00:26:03,736 --> 0:26:06,736
如果我把这个传单拖到这里

698
00:26:06,736 --> 0:26:08,616
这个项目名为 Hill Side

699
00:26:08,756 --> 0:26:10,496
它也有一个可能的数字

700
00:26:11,066 --> 0:26:12,546
一个参考数字

701
00:26:12,796 --> 0:26:16,406
碰巧是 HI11

702
00:26:17,116 --> 0:26:18,816
所以这里可能存在混淆

703
00:26:18,956 --> 0:26:21,196
现在我来给你看转录结果

704
00:26:23,066 --> 0:26:25,926
可以看到参考数字实际上

705
00:26:26,046 --> 0:26:27,226
在这里被误识别了

706
00:26:28,606 --> 0:26:29,526
所以我们要不断改进

707
00:26:30,456 --> 0:26:38,106
如果因为 HI11 是

708
00:26:38,106 --> 0:26:39,366
已知的引用的一部分

709
00:26:39,366 --> 0:26:42,526
我将其指定为自定义单词

710
00:26:42,526 --> 0:26:43,936
那么我们通过修正

711
00:26:43,936 --> 0:26:45,166
完成了自定义

712
00:26:45,166 --> 0:26:46,466
尤其是自定义单词列表

713
00:26:46,596 --> 0:26:48,126
并为我们

714
00:26:48,276 --> 0:26:52,296
提供了正确的转录 回到幻灯片

715
00:26:53,016 --> 0:26:54,096
[掌声]

716
00:26:54,096 --> 0:26:58,500
谢谢 [掌声]

717
00:27:01,686 --> 0:27:02,886
快速回顾一下

718
00:27:05,356 --> 0:27:06,696
你需要选择

719
00:27:06,696 --> 0:27:08,996
最适合你 App 

720
00:27:08,996 --> 0:27:11,066
用例的识别级别

721
00:27:11,296 --> 0:27:13,516
快速 准确

722
00:27:13,516 --> 0:27:14,006
找到对的那个

723
00:27:14,976 --> 0:27:17,276
语言设置方面 

724
00:27:17,276 --> 0:27:19,616
我们建议你

725
00:27:19,616 --> 0:27:21,686
根据所拥有的文档类型进行检查

726
00:27:21,746 --> 0:27:22,806
如果存在明显的语言

727
00:27:22,956 --> 0:27:24,376
相邻语言修正

728
00:27:24,376 --> 0:27:26,956
如果你具有特定于域的词汇表

729
00:27:27,546 --> 0:27:29,766
请启用自定义词

730
00:27:29,766 --> 0:27:30,526
指定自定义词

731
00:27:31,616 --> 0:27:33,836
此外非常重要的是

732
00:27:33,836 --> 0:27:36,156
你需要在 App 中

733
00:27:36,156 --> 0:27:38,476
支持进度更新

734
00:27:38,476 --> 0:27:39,726
以获得最佳用户体验

735
00:27:41,086 --> 0:27:44,086
现在就算你

736
00:27:44,086 --> 0:27:46,926
遵循这个建议

737
00:27:46,926 --> 0:27:49,446
仍然有一个非常重要的方面

738
00:27:49,446 --> 0:27:49,906
需要去注意

739
00:27:51,546 --> 0:27:54,876
那就是你需要处理结果

740
00:27:56,136 --> 0:27:57,516
你还需要提供一个方法

741
00:27:57,516 --> 0:28:00,326
用自己的方法

742
00:27:57,516 --> 0:28:00,326
用自己的方法

743
00:28:00,356 --> 0:28:02,236
来向你的用户展示结果

744
00:28:03,186 --> 0:28:04,846
不过这个方法

745
00:28:05,956 --> 0:28:07,776
可能并不与字母相关

746
00:28:09,126 --> 0:28:11,346
我的意思是

747
00:28:11,346 --> 0:28:13,366
为了获得最佳用户体验

748
00:28:13,366 --> 0:28:18,376
你需要以最有效的方式处理结果

749
00:28:19,376 --> 0:28:24,506
那么我们来看看怎么做

750
00:28:25,706 --> 0:28:28,306
首先要声明很重要的一点

751
00:28:29,236 --> 0:28:32,686
你应该预料到输入中存在歧义

752
00:28:34,086 --> 0:28:35,126
这就是计算机视觉

753
00:28:35,596 --> 0:28:36,856
这是一个开放式问题

754
00:28:37,526 --> 0:28:40,886
我们的参数术语将影响你

755
00:28:41,146 --> 0:28:43,956
正在处理的图像的内容

756
00:28:43,986 --> 0:28:47,036
事实上

757
00:28:47,036 --> 0:28:48,576
这里的门牌号是很有趣的

758
00:28:49,606 --> 0:28:52,106
因为其中的一些非常风格化

759
00:28:53,016 --> 0:28:54,036
当你对它们运行

760
00:28:54,076 --> 0:28:55,786
生成文本识别器时 

761
00:28:55,846 --> 0:28:57,936
它们并不知道自己应该成为数字 对吗

762
00:28:57,936 --> 0:29:02,156
你得到的不是 101

763
00:28:57,936 --> 0:29:02,156
你得到的不是 101

764
00:29:02,856 --> 0:29:05,576
而是 lol 

765
00:29:05,816 --> 0:29:09,646
或者你可能得到文本表情

766
00:29:09,776 --> 0:29:14,566
一个快乐的人举起手 在那种情况下

767
00:29:14,566 --> 0:29:16,576
不知道你有没有听过

768
00:29:16,806 --> 0:29:19,946
但我们坚持认为

769
00:29:19,946 --> 0:29:21,826
从观察结果来看

770
00:29:21,856 --> 0:29:23,306
你需要利用候选名单

771
00:29:23,936 --> 0:29:25,996
拥有的最佳候选名单

772
00:29:26,616 --> 0:29:28,766
请参考此候选列表

773
00:29:28,766 --> 0:29:31,176
如果它适用于你的 App

774
00:29:31,346 --> 0:29:32,806
请查看前一个 前两个

775
00:29:32,806 --> 0:29:33,806
前三个或更多结果

776
00:29:33,806 --> 0:29:36,006
有一个典型的例子

777
00:29:36,006 --> 0:29:38,106
比如你想要

778
00:29:38,106 --> 0:29:40,416
索引图像的内容

779
00:29:40,416 --> 0:29:42,216
如果你想增加召回率

780
00:29:42,216 --> 0:29:44,716
你可以为每个结果

781
00:29:44,716 --> 0:29:45,396
索引更多的候选对象

782
00:29:45,686 --> 0:29:48,076
当然 以精度为代价

783
00:29:48,886 --> 0:29:52,856
对吗 所以这个候选名单

784
00:29:52,856 --> 0:29:54,826
我们需要深入研究

785
00:29:54,826 --> 0:29:56,286
但这只是一个维度

786
00:29:56,286 --> 0:30:00,306
这是预测置信规模

787
00:29:56,286 --> 0:30:00,306
这是预测置信规模

788
00:30:00,656 --> 0:30:02,156
其他维度怎么样呢

789
00:30:02,636 --> 0:30:05,056
那么图像空间呢

790
00:30:06,046 --> 0:30:08,916
我们建议你

791
00:30:09,876 --> 0:30:12,136
评估并重新考虑

792
00:30:12,136 --> 0:30:14,546
使用几何图形来映射结果

793
00:30:15,586 --> 0:30:18,126
你有边界框

794
00:30:18,576 --> 0:30:20,176
它为你提供空间信息

795
00:30:20,726 --> 0:30:22,056
你可以使用

796
00:30:22,056 --> 0:30:24,246
结果的位置 比例

797
00:30:24,246 --> 0:30:26,506
以及旋转

798
00:30:26,506 --> 0:30:27,116
将这些结果映射到一起

799
00:30:27,346 --> 0:30:29,366
我们在这里

800
00:30:29,366 --> 0:30:32,006
显示的示例

801
00:30:32,006 --> 0:30:34,346
如果是收据

802
00:30:34,346 --> 0:30:38,326
你可以将项目名称

803
00:30:39,156 --> 0:30:40,746
映射到价格

804
00:30:42,896 --> 0:30:45,146
这是几何的

805
00:30:45,816 --> 0:30:47,356
但是对于

806
00:30:47,356 --> 0:30:49,256
每个孤立的结果

807
00:30:49,306 --> 0:30:52,096
你还有机会

808
00:30:52,096 --> 0:30:53,286
使用解析器并尝试

809
00:30:53,286 --> 0:30:54,476
理解每个结果

810
00:30:54,476 --> 0:30:58,096
在这种情况下

811
00:30:58,096 --> 0:31:00,596
数据检测是你最好的朋友

812
00:30:58,096 --> 0:31:00,596
数据检测是你最好的朋友

813
00:31:00,596 --> 0:31:02,536
它会为你感兴趣的类型

814
00:31:02,536 --> 0:31:03,896
启动 NSDataDetectorr

815
00:31:04,266 --> 0:31:05,296
你也可能明白

816
00:31:05,296 --> 0:31:08,236
它支持地址 URL

817
00:31:08,336 --> 0:31:09,106
日期和电话号码

818
00:31:10,516 --> 0:31:11,746
在我的名片示例中

819
00:31:11,746 --> 0:31:14,186
我可以使用它

820
00:31:14,186 --> 0:31:15,916
来理解一些结果

821
00:31:16,526 --> 0:31:19,806
但是如果这还不够

822
00:31:20,186 --> 0:31:22,136
你可以使用自己的

823
00:31:22,866 --> 0:31:24,446
特定于域的功能

824
00:31:24,446 --> 0:31:26,316
拥有自己的词汇表

825
00:31:26,316 --> 0:31:27,726
来匹配字符串

826
00:31:28,146 --> 0:31:29,776
或者使用自己的正则表达式

827
00:31:32,856 --> 0:31:34,216
为了说明这些原则

828
00:31:34,276 --> 0:31:36,106
我们有另一个示例 App 

829
00:31:36,106 --> 0:31:37,866
这次是一个 iOS App 

830
00:31:37,906 --> 0:31:39,946
名为 Business Companion

831
00:31:43,256 --> 0:31:45,776
假设你因为想要

832
00:31:45,776 --> 0:31:47,396
收据扫描仪

833
00:31:47,396 --> 0:31:49,966
坐在房间里

834
00:31:50,506 --> 0:31:51,446
有人是这么想的吗

835
00:31:51,956 --> 0:31:56,436
也许吧 亦或是一台名片读卡器

836
00:31:57,226 --> 0:31:58,306
也可能是对名片感兴趣的人

837
00:31:59,736 --> 0:32:03,356
那么这个 App

838
00:31:59,736 --> 0:32:03,356
那么这个 App

839
00:32:03,546 --> 0:32:05,476
就是你真正要看的东西

840
00:32:06,006 --> 0:32:09,896
因为它将两个流混合到同一个 App 流中

841
00:32:09,896 --> 0:32:13,036
我来教你怎么做

842
00:32:14,916 --> 0:32:18,346
首先它有文档类别选择器

843
00:32:18,346 --> 0:32:19,866
很快就会看到它是如何工作的

844
00:32:20,126 --> 0:32:22,036
这只是第一个屏

845
00:32:22,036 --> 0:32:23,106
这样就可以选择

846
00:32:23,106 --> 0:32:24,166
你感兴趣的文档类型

847
00:32:24,906 --> 0:32:27,606
从那里进入你之前听说过的

848
00:32:27,606 --> 0:32:28,646
文稿扫描相机

849
00:32:28,646 --> 0:32:31,166
从文稿扫描相机那里

850
00:32:31,266 --> 0:32:34,026
我们运行文本识别

851
00:32:34,026 --> 0:32:35,326
从识别的结果中

852
00:32:35,966 --> 0:32:37,366
我们执行一些分析

853
00:32:37,366 --> 0:32:38,496
来理解这些结果

854
00:32:38,496 --> 0:32:39,696
这才是真正重要的

855
00:32:40,366 --> 0:32:42,476
因为基于这种分析

856
00:32:42,896 --> 0:32:44,106
我们将能获得一些

857
00:32:44,106 --> 0:32:46,246
收据名片的数据模型

858
00:32:46,246 --> 0:32:47,626
在本例中

859
00:32:47,626 --> 0:32:49,406
我们对文档类型进行了分析

860
00:32:50,326 --> 0:32:52,146
从这个结果分析中

861
00:32:52,146 --> 0:32:54,076
假设你了解数据

862
00:32:54,076 --> 0:32:57,536
在表格视图中

863
00:32:57,536 --> 0:32:59,346
显示收据的情况下

864
00:32:59,346 --> 0:33:00,626
你还可以更适当地

865
00:32:59,346 --> 0:33:00,626
你还可以更适当地

866
00:33:00,626 --> 0:33:01,746
将结果可视化

867
00:33:02,216 --> 0:33:03,976
如果我们有名片

868
00:33:04,076 --> 0:33:07,256
会显示联系人名片

869
00:33:07,456 --> 0:33:09,956
下面我来展示这个 App

870
00:33:18,436 --> 0:33:20,936
在这里切换到 iOS 设备

871
00:33:22,236 --> 0:33:24,336
所以这是 Business Companion

872
00:33:24,836 --> 0:33:26,746
正如我告诉你的

873
00:33:26,746 --> 0:33:29,136
我们可以在收据

874
00:33:29,136 --> 0:33:30,756
卡片和其他类型的文件

875
00:33:30,756 --> 0:33:31,216
之间进行选择

876
00:33:31,546 --> 0:33:33,386
我们从收据开始

877
00:33:33,696 --> 0:33:37,556
首先是扫描文稿相机

878
00:33:37,556 --> 0:33:39,736
我们在这里有一些挑战性的亮点

879
00:33:45,536 --> 0:33:48,166
当文档被捕捉和处理时

880
00:33:48,166 --> 0:33:53,966
是的 我们的结果

881
00:33:54,026 --> 0:33:56,026
是结构化的

882
00:33:56,086 --> 0:33:57,226
你可以看到项目名称

883
00:33:57,696 --> 0:33:59,416
你可以看到每个部分的

884
00:33:59,946 --> 0:34:01,826
类别名称和值

885
00:33:59,946 --> 0:34:01,826
类别名称和值

886
00:34:02,656 --> 0:34:08,126
现在假设我看一张名片

887
00:34:14,456 --> 0:34:18,686
同样我会分析

888
00:34:18,856 --> 0:34:20,206
名片的每个字段

889
00:34:20,206 --> 0:34:21,596
[掌声] 这就是我的迷你名片

890
00:34:21,596 --> 0:34:22,775
谢谢大家

891
00:34:26,255 --> 0:34:27,516
就像我说的这很好

892
00:34:27,516 --> 0:34:29,346
但看看这个前面的屏

893
00:34:29,346 --> 0:34:30,966
仍然需要你

894
00:34:30,966 --> 0:34:33,036
手动选择文档类型

895
00:34:33,906 --> 0:34:34,766
它并不是真的无缝

896
00:34:34,766 --> 0:34:37,065
你可以使它更加无缝

897
00:34:37,286 --> 0:34:39,686
对吧 实际上我们已经做到了

898
00:34:39,686 --> 0:34:42,096
现在我来展示

899
00:34:42,096 --> 0:34:43,996
这个 App 的进阶版本

900
00:34:43,996 --> 0:34:45,565
它被称为

901
00:34:45,606 --> 0:34:46,036
Better Business Companion

902
00:34:46,156 --> 0:34:50,775
其实我们所做的

903
00:34:50,775 --> 0:34:53,525
就是我们使用 Create ML 

904
00:34:53,525 --> 0:34:56,446
训练了一个分类器模型

905
00:34:56,446 --> 0:34:58,846
我们将这个分类器

906
00:34:58,846 --> 0:35:00,186
作为第一步

907
00:34:58,846 --> 0:35:00,186
作为第一步

908
00:35:00,186 --> 0:35:01,366
这样就不必指定文档类型了

909
00:35:01,956 --> 0:35:04,076
它将自动选中

910
00:35:04,076 --> 0:35:04,976
说得差不多了 我来演示一下

911
00:35:07,566 --> 0:35:11,506
很明显 第一个按钮从大按钮

912
00:35:11,506 --> 0:35:11,826
变成非常小的按钮

913
00:35:14,516 --> 0:35:16,136
这里只有 Scan 按钮

914
00:35:16,196 --> 0:35:18,096
我这里有收据

915
00:35:18,096 --> 0:35:21,856
你同样可以看到

916
00:35:26,856 --> 0:35:29,666
无需用户指定文档类型

917
00:35:31,296 --> 0:35:32,256
[掌声] 即可作为

918
00:35:32,306 --> 0:35:36,886
收据处理

919
00:35:38,086 --> 0:35:39,466
为了向你展示

920
00:35:39,466 --> 0:35:40,536
它如何与名片一起使用

921
00:35:40,536 --> 0:35:42,846
再次用我名片举例

922
00:35:47,506 --> 0:35:50,976
好的 我们正确处理了名片

923
00:35:51,516 --> 0:35:54,616
[掌声]

924
00:35:55,116 --> 0:35:56,656
我说过我们为这个

925
00:35:56,656 --> 0:35:58,376
集成了 Core ML 模型

926
00:35:58,506 --> 0:35:59,456
我想向你展示一下

927
00:36:06,156 --> 0:36:09,836
我们在这里进入 Xcode

928
00:36:10,296 --> 0:36:12,716
这是代码

929
00:36:12,776 --> 0:36:14,566
实际上这是我们

930
00:36:14,776 --> 0:36:18,586
从 Business Companion 修改的代码

931
00:36:18,586 --> 0:36:21,826
我们添加了一个插入

932
00:36:21,826 --> 0:36:24,026
Core ML 模型

933
00:36:24,986 --> 0:36:32,246
在这里 我们插入此 Core ML 模型

934
00:36:32,246 --> 0:36:34,826
以使用 completionHandler 

935
00:36:35,276 --> 0:36:36,776
设置请求

936
00:36:36,776 --> 0:36:40,666
作为处理程序的一部分

937
00:36:40,666 --> 0:36:42,146
你可以看到

938
00:36:42,146 --> 0:36:46,196
我们处理了 topObservation

939
00:36:46,196 --> 0:36:48,436
和标识符的日期 抱歉 topObservation 的标识符

940
00:36:48,436 --> 0:36:52,266
我们为 App 设置扫描模式

941
00:36:52,266 --> 0:36:53,966
以确定该 App 

942
00:36:53,966 --> 0:36:56,906
其余部分的流

943
00:36:56,906 --> 0:36:58,916
因此我们鼓励你

944
00:36:58,916 --> 0:37:00,396
思考如何使用文本识别

945
00:36:58,916 --> 0:37:00,396
思考如何使用文本识别

946
00:37:00,396 --> 0:37:02,286
来改进 App 流

947
00:37:02,286 --> 0:37:03,916
以及如何适当地

948
00:37:03,916 --> 0:37:05,056
处理结果

949
00:37:05,056 --> 0:37:12,016
同时利用像这样的 ML 模型

950
00:37:12,206 --> 0:37:14,696
好 再次回到幻灯片

951
00:37:15,206 --> 0:37:18,306
简单回顾一下

952
00:37:19,796 --> 0:37:22,396
正如我所提到的

953
00:37:22,396 --> 0:37:24,296
我们鼓励在有意义的时候

954
00:37:24,296 --> 0:37:25,026
使用几何信息

955
00:37:25,866 --> 0:37:27,796
通过使用数据检测器

956
00:37:27,796 --> 0:37:29,576
或自己的解析器

957
00:37:29,576 --> 0:37:30,646
来解析理解结果

958
00:37:31,456 --> 0:37:34,266
最重要的是 你要明白自己在创建什么

959
00:37:34,456 --> 0:37:35,736
你知道需要查看

960
00:37:35,736 --> 0:37:36,966
哪种类型的数据

961
00:37:36,966 --> 0:37:39,326
因此我们建议

962
00:37:39,326 --> 0:37:40,926
利用你的领域知识

963
00:37:40,926 --> 0:37:42,706
获得最佳用户体验

964
00:37:45,676 --> 0:37:48,096
我们也希望这能

965
00:37:48,096 --> 0:37:49,376
给你提供一个很好的参考

966
00:37:49,376 --> 0:37:50,656
帮助你将文本识别集成到

967
00:37:50,656 --> 0:37:51,656
你的 App 中

968
00:37:51,656 --> 0:37:53,336
我已迫不及待想看到

969
00:37:53,696 --> 0:37:54,826
你将用这项技术创建的

970
00:37:54,826 --> 0:37:56,686
所有精彩的 App

971
00:37:56,896 --> 0:37:59,716
如果你还有疑问

972
00:37:59,716 --> 0:38:01,056
可以访问机器学习实验室

973
00:37:59,716 --> 0:38:01,056
可以访问机器学习实验室

974
00:38:01,056 --> 0:38:02,326
明天还有一场

975
00:38:02,326 --> 0:38:03,976
谢谢大家

976
00:38:04,508 --> 0:38:06,508
[掌声]
