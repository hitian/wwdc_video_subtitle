1
00:00:00,506 --> 0:00:05,500
[音乐]

2
00:00:08,516 --> 0:00:11,546
[欢呼和掌声]

3
00:00:12,046 --> 0:00:12,376
&gt;&gt; 欢迎

4
00:00:15,496 --> 0:00:16,696
我是 Steve Breen

5
00:00:16,696 --> 0:00:18,256
我是 UIKit 团队的一名工程师

6
00:00:18,426 --> 0:00:19,586
今天我和我的同事

7
00:00:19,586 --> 0:00:21,186
来自 AppKit 团队的 Troy Stephens 

8
00:00:21,186 --> 0:00:22,456
和来自 App Store 团队的

9
00:00:22,456 --> 0:00:24,336
Jacob Klapper 一起

10
00:00:25,366 --> 0:00:27,096
今天我们要聊一些

11
00:00:27,216 --> 0:00:29,416
关于 UI 数据源的内容

12
00:00:30,296 --> 0:00:30,986
[笑声] 那么

13
00:00:30,986 --> 0:00:33,006
今天的演讲将分为四个部分

14
00:00:33,626 --> 0:00:34,656
首先我想谈谈

15
00:00:34,656 --> 0:00:35,936
目前的最新状况

16
00:00:36,076 --> 0:00:37,346
我们现在如何

17
00:00:37,346 --> 0:00:39,636
在平台上与数据源交互

18
00:00:40,636 --> 0:00:41,656
然后我们将讨论

19
00:00:41,656 --> 0:00:43,196
一种全新的方法

20
00:00:43,196 --> 0:00:45,856
将其引入 iOS tvOS 和 macOS

21
00:00:46,556 --> 0:00:48,156
接下来我们会过渡到一些演示

22
00:00:48,156 --> 0:00:50,146
获得一些关于这个

23
00:00:50,146 --> 0:00:51,926
全新 API 的实践

24
00:00:52,646 --> 0:00:54,236
最后我们将

25
00:00:54,236 --> 0:00:55,466
更详细地考虑

26
00:00:55,466 --> 0:00:56,576
如何充分利用

27
00:00:56,706 --> 0:00:59,466
这个新 API

28
00:01:00,256 --> 0:01:01,246
我们来谈谈

29
00:01:01,246 --> 0:01:02,636
目前最新的状况

30
00:01:02,636 --> 0:01:05,495
我们是如何在 UITableView

31
00:01:05,495 --> 0:01:07,206
和 UICollectionView 中与

32
00:01:07,206 --> 0:01:08,436
UI 数据源交互的呢?

33
00:01:09,836 --> 0:01:12,256
这里我们看到

34
00:01:12,256 --> 0:01:13,546
UICollectionView 数据源

35
00:01:13,546 --> 0:01:15,046
的一个示例的实现

36
00:01:15,926 --> 0:01:16,896
如果你用过

37
00:01:16,896 --> 0:01:18,456
UITableView 或 UICollectionViews

38
00:01:18,456 --> 0:01:19,346
那你以前见过这个

39
00:01:19,966 --> 0:01:21,886
这提供了三个方法

40
00:01:21,886 --> 0:01:24,496
包括协议必须的两个方法

41
00:01:24,496 --> 0:01:26,836
很简单 对吧

42
00:01:26,836 --> 0:01:28,466
我们已经询问了

43
00:01:28,466 --> 0:01:29,576
Section 的数量

44
00:01:29,576 --> 0:01:30,886
和每个 Section 中 Item 的数量

45
00:01:31,096 --> 0:01:32,676
在内容渲染方面

46
00:01:32,676 --> 0:01:33,796
我们会要求返回 Item 对应的 Cell

47
00:01:34,406 --> 0:01:38,136
非常简单 到现在它已经

48
00:01:38,136 --> 0:01:39,566
为我们服务十年了

49
00:01:39,796 --> 0:01:42,946
对吧 它有几个优点 超级简单

50
00:01:43,356 --> 0:01:44,486
你可以立刻推理出来

51
00:01:44,486 --> 0:01:46,296
如果你只想提供两个方法

52
00:01:46,296 --> 0:01:48,446
Section 中的 Item 数量

53
00:01:48,446 --> 0:01:50,426
如果你的数据源是一维的

54
00:01:50,426 --> 0:01:51,606
那就很简单了

55
00:01:52,576 --> 0:01:53,966
你可以很快地对它进行迭代

56
00:01:54,566 --> 0:01:56,566
但它也很灵活

57
00:01:56,636 --> 0:01:58,516
对吧 因为你不需要

58
00:01:58,596 --> 0:02:00,586
使用任何特定的数据结构

59
00:01:58,596 --> 0:02:00,586
使用任何特定的数据结构

60
00:02:00,586 --> 0:02:02,896
来支持你的数据源

61
00:02:04,116 --> 0:02:05,276
它可以像一维数组

62
00:02:05,346 --> 0:02:06,386
一样简单

63
00:02:07,426 --> 0:02:08,826
如果你的数据源

64
00:02:08,826 --> 0:02:10,906
有多个 Item 和 Section

65
00:02:10,906 --> 0:02:11,796
它可能是二维的对吧

66
00:02:11,796 --> 0:02:12,946
非常简单 非常直接

67
00:02:15,606 --> 0:02:17,926
App 通常

68
00:02:17,926 --> 0:02:19,146
比一维或二维数组

69
00:02:19,146 --> 0:02:20,706
要复杂一些

70
00:02:22,456 --> 0:02:24,216
而且 App 每年都变得越来越复杂

71
00:02:24,216 --> 0:02:25,166
它们做的事情更多

72
00:02:25,166 --> 0:02:26,886
我们的用户需要更多的功能

73
00:02:26,886 --> 0:02:29,576
通常这些数据源

74
00:02:29,576 --> 0:02:31,316
是由 App 内部的

75
00:02:31,316 --> 0:02:32,746
复杂控制器支持的

76
00:02:33,686 --> 0:02:35,946
这些控制器可以做很多事

77
00:02:35,946 --> 0:02:36,876
它们可以与 Core Data 交互

78
00:02:36,876 --> 0:02:39,186
还可以与 Web 服务对话

79
00:02:39,186 --> 0:02:40,546
它们做了

80
00:02:40,546 --> 0:02:41,426
很多不同的事情

81
00:02:41,626 --> 0:02:43,916
我将很快地进行展示

82
00:02:45,296 --> 0:02:46,906
让我们来看看

83
00:02:46,906 --> 0:02:49,166
UI 层和控制器层之前的对话

84
00:02:49,166 --> 0:02:50,166
这个控制器层做了很多

85
00:02:50,166 --> 0:02:51,576
繁重的工作

86
00:02:51,576 --> 0:02:52,786
来获取数据对吧

87
00:02:53,686 --> 0:02:55,576
对话一开始很礼貌

88
00:02:56,106 --> 0:02:57,946
就像是 “嘿 请告诉我 Section 中 Item 的数量

89
00:02:57,946 --> 0:02:59,456
或者在我们渲染内容时

90
00:02:59,456 --> 0:03:00,046
给我对应的 Cell“

91
00:02:59,456 --> 0:03:00,046
给我对应的 Cell“

92
00:03:00,486 --> 0:03:01,456
非常简单

93
00:03:01,526 --> 0:03:02,956
到目前为止一切顺利

94
00:03:06,056 --> 0:03:08,016
但随着时间的推移 事情会变得更加复杂对吧

95
00:03:08,016 --> 0:03:09,076
比如这个控制器

96
00:03:09,076 --> 0:03:10,516
有一个 Web 服务请求

97
00:03:10,516 --> 0:03:11,896
在这里得到响应

98
00:03:11,896 --> 0:03:14,196
对吧 就像是我有你的

99
00:03:14,196 --> 0:03:15,776
推特之类的数据 对吧

100
00:03:16,396 --> 0:03:18,096
现在这个控制器层

101
00:03:18,196 --> 0:03:19,716
它本身是复杂的

102
00:03:20,376 --> 0:03:21,926
要让世界知道

103
00:03:21,926 --> 0:03:23,226
嘿 我改变了 有一些地方变了

104
00:03:23,846 --> 0:03:25,546
这就是事情变得

105
00:03:25,546 --> 0:03:27,996
有点复杂的地方对吧

106
00:03:27,996 --> 0:03:31,066
现在由 UI 层决定

107
00:03:31,066 --> 0:03:33,486
嘿 事情变了

108
00:03:33,486 --> 0:03:34,856
我现在要根据这个改变

109
00:03:34,856 --> 0:03:37,816
对我们的 UI 层进行更新

110
00:03:38,486 --> 0:03:40,086
这包括所有针对

111
00:03:40,086 --> 0:03:41,426
TableView 和

112
00:03:41,426 --> 0:03:42,756
CollectionView 的变化

113
00:03:42,756 --> 0:03:44,246
可能会有点复杂

114
00:03:44,246 --> 0:03:46,076
我们在去年的

115
00:03:46,076 --> 0:03:48,236
UICollectionView 一览会议中

116
00:03:48,236 --> 0:03:51,436
讨论了这种复杂性以及如何正确

117
00:03:51,436 --> 0:03:53,726
构造批次更新

118
00:03:53,726 --> 0:03:54,976
以及如何修改备份储存 诸如此类的

119
00:03:57,586 --> 0:03:59,276
但是有时候 不管你怎么努力

120
00:04:00,516 --> 0:04:02,626
[笑声]

121
00:04:03,126 --> 0:04:04,226
你知道事情总不会顺利

122
00:04:04,606 --> 0:04:05,586
这是一个不完美的世界

123
00:04:07,186 --> 0:04:08,746
从笑声中可以看出

124
00:04:08,886 --> 0:04:10,006
你以前可能也遇到过这种情况

125
00:04:10,006 --> 0:04:12,336
对吧 这并不罕见

126
00:04:12,336 --> 0:04:13,756
这真的很令人沮丧

127
00:04:13,756 --> 0:04:14,726
对吧 你遇到这种情况 然后会想

128
00:04:14,726 --> 0:04:18,875
"好吧 我做错了什么?" 这是我本人

129
00:04:18,875 --> 0:04:20,616
当你深入研究你的代码后

130
00:04:20,616 --> 0:04:21,716
你在 Stack Overflow 上查询

131
00:04:21,716 --> 0:04:22,886
看看发生了什么

132
00:04:23,206 --> 0:04:25,146
最终你可能会灰心

133
00:04:25,146 --> 0:04:26,516
只能调用 reloadData

134
00:04:26,516 --> 0:04:27,806
我们去年讨论了这个

135
00:04:27,806 --> 0:04:30,266
很好 这是正确的做法

136
00:04:30,386 --> 0:04:31,616
你的 App 会正常运行

137
00:04:32,676 --> 0:04:33,736
当你调用 reloadData 时

138
00:04:33,736 --> 0:04:35,616
你会得到一个非动画效果

139
00:04:36,306 --> 0:04:38,446
它会降低用户体验

140
00:04:39,836 --> 0:04:41,356
所以这不好

141
00:04:44,046 --> 0:04:46,156
我想用这一张幻灯片来讲讲哲学

142
00:04:46,156 --> 0:04:48,716
就一张 我保证出了什么问题呢

143
00:04:49,636 --> 0:04:52,456
问题是 我们的真相在哪里

144
00:04:53,786 --> 0:04:55,386
你知道的 我的意思是谁造成了这一切

145
00:04:55,386 --> 0:04:56,696
谁能解决这些问题

146
00:04:57,806 --> 0:04:59,256
这里最大的问题是

147
00:04:59,256 --> 0:05:01,016
我们的数据控制器

148
00:04:59,256 --> 0:05:01,016
我们的数据控制器

149
00:05:01,016 --> 0:05:02,186
或者说是作为一个数据源

150
00:05:02,186 --> 0:05:03,356
有它自己版本的真相

151
00:05:03,356 --> 0:05:04,466
随着时间的推移而变化

152
00:05:04,946 --> 0:05:07,136
UI 有一个版本的真相

153
00:05:08,336 --> 0:05:09,866
UI 层代码负责

154
00:05:09,866 --> 0:05:11,256
调节两者

155
00:05:11,256 --> 0:05:12,796
确保它们总是同步的

156
00:05:13,526 --> 0:05:15,476
正如我们所看到的 有时候这很难

157
00:05:16,816 --> 0:05:19,036
所以我们目前的方法容易出错

158
00:05:19,726 --> 0:05:22,976
主要是因为没有集中真理的概念

159
00:05:26,626 --> 0:05:27,766
这就是最新的状况

160
00:05:27,766 --> 0:05:28,476
这就是我们今天的处境

161
00:05:28,476 --> 0:05:29,206
但是我们接下来会怎么样呢

162
00:05:30,546 --> 0:05:31,716
我很高兴地宣布

163
00:05:31,716 --> 0:05:33,726
对于 iOS tvOS 和 macOS 

164
00:05:33,726 --> 0:05:36,326
我们今年将推出一种全新的方式

165
00:05:37,106 --> 0:05:39,556
我们称这个为差量数据源

166
00:05:40,516 --> 0:05:44,546
[欢呼和掌声]

167
00:05:45,046 --> 0:05:45,976
好了让我们深入了解一下这是什么

168
00:05:49,076 --> 0:05:50,576
没有 performBatchUpdates 我们继续

169
00:05:51,056 --> 0:05:53,976
与此同时 所有的崩溃 困扰和繁杂

170
00:05:53,976 --> 0:05:54,776
所有你不想处理的东西

171
00:05:54,776 --> 0:05:56,726
都被抛弃了

172
00:05:57,806 --> 0:05:59,086
我们只有一个

173
00:05:59,086 --> 0:05:59,986
被称为 apply() 的方法

174
00:06:00,546 --> 0:06:01,196
什么是 apply()

175
00:06:01,806 --> 0:06:03,176
apply() 是简单的 自动的

176
00:06:03,176 --> 0:06:04,496
省事的差异化对比

177
00:06:07,386 --> 0:06:09,136
我们用一个全新的构造

178
00:06:09,136 --> 0:06:10,766
称之为快照

179
00:06:10,826 --> 0:06:12,156
这是一个非常简单的想法

180
00:06:12,296 --> 0:06:13,846
这实际上是

181
00:06:13,846 --> 0:06:14,826
当前 UI 状态的真相

182
00:06:15,536 --> 0:06:18,306
它不是 IndexPath

183
00:06:18,306 --> 0:06:20,076
而是一组

184
00:06:20,346 --> 0:06:24,066
唯一的 Section 标识符和 Item 标识符

185
00:06:25,336 --> 0:06:26,766
你不是使用 IndexPath 进行更新

186
00:06:26,766 --> 0:06:28,736
而是用标识符

187
00:06:29,486 --> 0:06:30,226
让我们来看看

188
00:06:30,226 --> 0:06:32,666
这里发生了什么

189
00:06:34,156 --> 0:06:35,276
我是个很有创意的人

190
00:06:35,276 --> 0:06:37,146
屏幕上有 FOO

191
00:06:37,226 --> 0:06:38,256
BAR 和 BIF 对吧

192
00:06:38,256 --> 0:06:39,486
这就是我们互动的对象

193
00:06:39,486 --> 0:06:41,736
这些是 App 中的标识符

194
00:06:43,146 --> 0:06:45,156
假设控制器改变了

195
00:06:45,156 --> 0:06:46,546
现在我们有了这个

196
00:06:46,606 --> 0:06:48,316
我们想应用的全新的快照

197
00:06:49,116 --> 0:06:50,316
但这是我们当前的快照

198
00:06:50,316 --> 0:06:52,676
我们如何从新的事实

199
00:06:53,686 --> 0:06:54,676
得到当前的快照

200
00:06:56,686 --> 0:06:57,916
我们可以看到

201
00:06:57,916 --> 0:06:59,486
用 BAR FOO 和 BAZ

202
00:06:59,486 --> 0:07:01,496
配置了一个全新的快照

203
00:06:59,486 --> 0:07:01,496
配置了一个全新的快照

204
00:07:01,496 --> 0:07:02,656
我们有些项目是

205
00:07:02,656 --> 0:07:03,656
一直存在的

206
00:07:03,656 --> 0:07:05,036
只是改变了顺序

207
00:07:05,036 --> 0:07:06,796
然后有个新的项目进来了

208
00:07:07,516 --> 0:07:10,136
从概念上来讲

209
00:07:10,136 --> 0:07:11,796
apply() 知道

210
00:07:11,796 --> 0:07:12,996
当前的状态和新状态

211
00:07:12,996 --> 0:07:14,566
然后应用到 

212
00:07:14,566 --> 0:07:14,976
UI 元素上的

213
00:07:17,356 --> 0:07:19,096
没有第二步 这就完成了

214
00:07:19,096 --> 0:07:21,336
那我们该如何实现呢

215
00:07:21,336 --> 0:07:23,206
我们在所有平台上

216
00:07:23,376 --> 0:07:24,576
有四个类

217
00:07:25,226 --> 0:07:26,836
对于 iOS 和 tvOS

218
00:07:26,836 --> 0:07:27,686
我们有 UICollectionViewDiffableDataSource

219
00:07:27,686 --> 0:07:31,666
以及 UITableViewDiffableDataSource

220
00:07:31,666 --> 0:07:33,256
在 Mac 上 

221
00:07:33,636 --> 0:07:35,276
我们有 NSCollectionViewDiffableDataSource

222
00:07:36,046 --> 0:07:37,696
所有平台都通用的是

223
00:07:37,756 --> 0:07:39,796
这个 Snapshot 类

224
00:07:39,796 --> 0:07:40,856
它负责当前的

225
00:07:40,856 --> 0:07:43,846
UI 状态的 NSDiffableDataSourceSnapshot

226
00:07:44,896 --> 0:07:46,456
背景就介绍到这里

227
00:07:46,456 --> 0:07:48,126
我们接下来看一些代码

228
00:07:48,186 --> 0:07:49,376
为此我会让我的同事

229
00:07:49,376 --> 0:07:51,536
Troy Stephens 出来

230
00:07:51,766 --> 0:07:54,266
Troy [掌声]

231
00:07:54,516 --> 0:07:55,456
&gt;&gt; 非常感谢 Steve

232
00:07:56,116 --> 0:07:57,706
今天我很高兴

233
00:07:57,706 --> 0:07:59,266
带大家一起看一些

234
00:07:59,266 --> 0:08:00,746
使用这个强大而又

235
00:07:59,266 --> 0:08:00,746
使用这个强大而又

236
00:08:00,746 --> 0:08:02,956
漂亮简单的新 API 的例子

237
00:08:03,286 --> 0:08:04,526
因此如果你还没有

238
00:08:04,526 --> 0:08:06,086
下载本讲座的示例项目

239
00:08:06,086 --> 0:08:08,746
请务必下载 这样你就可以

240
00:08:08,966 --> 0:08:10,116
在空闲的时候跟着学习

241
00:08:10,466 --> 0:08:12,616
最重要的是

242
00:08:12,616 --> 0:08:14,946
用这个例子来

243
00:08:14,946 --> 0:08:16,616
真正理解所有这些东西是如何工作的

244
00:08:16,776 --> 0:08:17,776
它没有很多代码

245
00:08:18,066 --> 0:08:19,186
其实很简单

246
00:08:19,556 --> 0:08:22,076
当你查看这个示例项目时

247
00:08:22,076 --> 0:08:23,416
你会注意到

248
00:08:23,416 --> 0:08:24,796
除了我们今天将要查看的

249
00:08:24,846 --> 0:08:26,336
三个使用 DiffableDataSource 

250
00:08:26,336 --> 0:08:27,406
的示例之外

251
00:08:27,926 --> 0:08:29,816
这个项目还包含了

252
00:08:29,816 --> 0:08:31,266
我们在 215 会议中引入的

253
00:08:31,266 --> 0:08:32,645
功能强大的

254
00:08:32,645 --> 0:08:35,645
新组合布局 API 的示例

255
00:08:36,046 --> 0:08:37,626
这些例子恰好使用了

256
00:08:37,626 --> 0:08:39,905
DiffableDataSource 

257
00:08:40,006 --> 0:08:41,905
作为一种非常简单的方法

258
00:08:41,905 --> 0:08:42,936
将示例内容填充至

259
00:08:42,936 --> 0:08:43,746
CollectionView 中

260
00:08:44,256 --> 0:08:45,636
让我们操作演示机器

261
00:08:45,636 --> 0:08:45,976
一起来看一看

262
00:08:49,416 --> 0:08:51,116
我们的演示 App 在这里

263
00:08:51,496 --> 0:08:52,926
当我们今天

264
00:08:52,926 --> 0:08:54,496
讲解不同的例子时

265
00:08:54,776 --> 0:08:56,566
我们会注意到一个重复的模式

266
00:08:56,566 --> 0:08:58,676
这是一个简单的三步过程

267
00:08:59,186 --> 0:09:00,986
任何时候你想

268
00:08:59,186 --> 0:09:00,986
任何时候你想

269
00:09:00,986 --> 0:09:02,186
把一组新变化 新数据

270
00:09:02,186 --> 0:09:04,296
放到有完整数据源的

271
00:09:04,296 --> 0:09:05,776
CollectionView 或 UITableView 中

272
00:09:05,776 --> 0:09:08,676
你只需创建一个快照

273
00:09:09,306 --> 0:09:10,846
用要在更新周期中

274
00:09:10,846 --> 0:09:12,296
显示的项目描述

275
00:09:12,296 --> 0:09:13,856
填充快照

276
00:09:13,906 --> 0:09:15,756
然后应用快照

277
00:09:16,116 --> 0:09:17,376
更改将自动被

278
00:09:17,376 --> 0:09:19,356
提交到 UI

279
00:09:19,356 --> 0:09:20,786
DiffableDataSource 负责

280
00:09:20,786 --> 0:09:22,386
所有对 UI 元素的差异化对比

281
00:09:22,386 --> 0:09:23,556
和发布 UI 元素的更改

282
00:09:24,426 --> 0:09:25,946
我们来看一个具体的例子

283
00:09:25,946 --> 0:09:27,946
我要打开 Mountain Search

284
00:09:29,046 --> 0:09:30,526
这是一个很典型的

285
00:09:30,526 --> 0:09:31,236
搜索 UI 对吧?

286
00:09:31,236 --> 0:09:33,966
我们都能看到它 并推断出它的作用

287
00:09:34,216 --> 0:09:35,826
例如你可能在

288
00:09:35,826 --> 0:09:37,006
联系人 App 中看到这一点

289
00:09:37,006 --> 0:09:38,736
而在本例中 我们正在查看

290
00:09:38,736 --> 0:09:39,776
世界各地的山峰

291
00:09:40,626 --> 0:09:42,666
你可以想象

292
00:09:42,666 --> 0:09:43,626
在顶部有个搜索框

293
00:09:43,626 --> 0:09:45,046
当我开始输入搜索字段时

294
00:09:45,046 --> 0:09:46,666
我们希望看到

295
00:09:46,666 --> 0:09:48,556
列表自动过滤

296
00:09:48,556 --> 0:09:49,606
只显示匹配项

297
00:09:49,676 --> 0:09:51,426
我们会看到如果我开始输入

298
00:09:51,426 --> 0:09:54,176
我们做到了这一点

299
00:09:54,506 --> 0:09:55,456
这一切都是

300
00:09:55,456 --> 0:09:57,456
自动发生的

301
00:09:57,546 --> 0:09:58,356
还伴有优秀的动画

302
00:09:59,656 --> 0:10:01,626
这都是非常容易做到的

303
00:09:59,656 --> 0:10:01,626
这都是非常容易做到的

304
00:10:01,626 --> 0:10:03,896
用非常少的代码

305
00:10:03,976 --> 0:10:05,336
使用 DiffableDataSource 实现

306
00:10:05,336 --> 0:10:06,696
我们来看看它是如何工作的

307
00:10:08,336 --> 0:10:09,976
对于本例

308
00:10:09,976 --> 0:10:11,746
查看 MountainsViewController 源文件

309
00:10:13,486 --> 0:10:15,386
所有的行动都是从

310
00:10:15,386 --> 0:10:16,586
用户在搜索栏中进行输入

311
00:10:16,586 --> 0:10:17,136
开始的对吗

312
00:10:17,936 --> 0:10:19,256
这里有一个回调

313
00:10:19,256 --> 0:10:20,876
searchBarTextDidChange

314
00:10:20,876 --> 0:10:22,826
它将被发送至控制器

315
00:10:24,316 --> 0:10:25,796
从那里我们调用

316
00:10:25,836 --> 0:10:27,556
我们自己的 performQuery 函数

317
00:10:27,736 --> 0:10:29,466
传入的参数是

318
00:10:29,466 --> 0:10:30,926
我们从那个搜索栏得到搜索文本

319
00:10:31,306 --> 0:10:33,096
performQuery 本身

320
00:10:33,096 --> 0:10:34,116
非常简单

321
00:10:34,676 --> 0:10:37,236
我们所做的就是调用

322
00:10:37,236 --> 0:10:38,106
我们的 mountainsController

323
00:10:38,106 --> 0:10:39,566
这是我们模型层的对象

324
00:10:40,186 --> 0:10:42,106
我们要它提供一个经过过滤的

325
00:10:42,106 --> 0:10:44,266
排序的山峰列表

326
00:10:44,266 --> 0:10:45,636
与我们的搜索词相匹配

327
00:10:46,356 --> 0:10:48,126
我们现在有了这个山峰列表

328
00:10:49,616 --> 0:10:51,046
我们经历了我提到的

329
00:10:51,046 --> 0:10:52,156
三个步骤

330
00:10:52,196 --> 0:10:55,536
我们创建了一个新的

331
00:10:56,476 --> 0:10:58,566
这个快照最初是空的

332
00:10:58,556 --> 0:10:59,456
里面什么也没有

333
00:10:59,456 --> 0:11:01,136
所以由我们来填充

334
00:10:59,456 --> 0:11:01,136
所以由我们来填充

335
00:11:01,136 --> 0:11:03,466
我们想要的 Section 和 Item

336
00:11:04,296 --> 0:11:06,646
在本例中 我们只显示一个 Section

337
00:11:07,216 --> 0:11:08,436
我们只需添加一个 Section

338
00:11:08,716 --> 0:11:09,896
我们可以称它为

339
00:11:09,896 --> 0:11:11,976
主 Section

340
00:11:14,336 --> 0:11:17,356
接下来我们添加

341
00:11:17,356 --> 0:11:18,796
在此次更新中显示

342
00:11:18,796 --> 0:11:20,386
Item 标识符

343
00:11:21,156 --> 0:11:22,376
从形式上来讲

344
00:11:22,376 --> 0:11:23,446
我们通常在这里传递

345
00:11:23,446 --> 0:11:24,386
一个标识符数组

346
00:11:24,896 --> 0:11:27,126
但是在 Swift 中你也可以

347
00:11:27,126 --> 0:11:29,196
通过使用你自己原生的类型

348
00:11:29,366 --> 0:11:31,646
使传参变得更加优雅

349
00:11:31,646 --> 0:11:32,916
如果你有一个原生类型

350
00:11:32,916 --> 0:11:34,456
它甚至可以是一个值类型

351
00:11:34,456 --> 0:11:36,486
比如一个结构体或一个枚举

352
00:11:36,796 --> 0:11:38,396
如果该类型是可哈希的

353
00:11:38,506 --> 0:11:39,756
那你就可以根据

354
00:11:39,756 --> 0:11:41,076
你所做的 Swift 语义传递

355
00:11:41,076 --> 0:11:42,716
你的原生对象

356
00:11:42,716 --> 0:11:43,796
我们过一会儿会

357
00:11:43,796 --> 0:11:46,166
了解它是如何工作的

358
00:11:46,526 --> 0:11:48,286
我们现在已经构建了快照

359
00:11:48,286 --> 0:11:49,036
可以进行下一步了

360
00:11:49,796 --> 0:11:51,876
我们所要做的就是调用

361
00:11:51,876 --> 0:11:53,126
我们的 DiffableDataSource

362
00:11:53,126 --> 0:11:54,766
让它应用快照

363
00:11:55,196 --> 0:11:56,196
将差异展现出来

364
00:11:56,196 --> 0:11:57,776
DiffableDataSource 运行时

365
00:11:57,776 --> 0:11:59,606
会自动找出

366
00:11:59,606 --> 0:12:00,906
上一次更新和

367
00:11:59,606 --> 0:12:00,906
上一次更新和

368
00:12:00,906 --> 0:12:01,866
下一次更新之间的变化

369
00:12:02,276 --> 0:12:03,496
请注意这里根本没有代码

370
00:12:03,496 --> 0:12:05,296
我们不需要停下来并找出

371
00:12:05,296 --> 0:12:07,186
上一个更新周期中

372
00:12:07,186 --> 0:12:08,286
在用户输入当前字符之前

373
00:12:08,286 --> 0:12:12,206
显示的内容是什么

374
00:12:12,206 --> 0:12:13,176
一切都是自动处理的

375
00:12:13,176 --> 0:12:14,226
没什么好担心的

376
00:12:14,226 --> 0:12:16,976
我们不是在处理 IndexPaths

377
00:12:16,976 --> 0:12:18,046
它们脆弱又短暂对吧

378
00:12:18,086 --> 0:12:19,426
它们指的是

379
00:12:19,616 --> 0:12:20,856
某个特定的更新

380
00:12:20,856 --> 0:12:21,536
在不同的更新中

381
00:12:21,536 --> 0:12:22,306
有着不同的含义

382
00:12:22,716 --> 0:12:24,166
我们处理的标识符

383
00:12:24,166 --> 0:12:26,446
是鲁棒和持久的

384
00:12:26,566 --> 0:12:29,236
所以这里的操作 非常简单

385
00:12:30,636 --> 0:12:31,686
在我们离开这段代码之前

386
00:12:31,686 --> 0:12:32,726
我希望你注意到一些

387
00:12:32,726 --> 0:12:34,376
关于 Snapshot 的事情

388
00:12:34,376 --> 0:12:35,326
你可能已经注意到了

389
00:12:35,326 --> 0:12:37,816
它是 Swift 中的一个泛型类

390
00:12:37,816 --> 0:12:39,916
所以它的参数是

391
00:12:39,916 --> 0:12:42,126
我们决定使用的

392
00:12:42,126 --> 0:12:43,846
Section 标识符类型和

393
00:12:43,846 --> 0:12:44,696
Item 标识符类型

394
00:12:45,246 --> 0:12:48,816
首先看 Section 标识符类型这比较琐碎

395
00:12:48,816 --> 0:12:50,146
在一般情况下

396
00:12:50,576 --> 0:12:51,906
这是一种非常方便的技术

397
00:12:51,906 --> 0:12:52,906
你只需要一个 Section

398
00:12:52,906 --> 0:12:54,936
对吧 你可以为此声明

399
00:12:54,936 --> 0:12:55,606
一个枚举类型

400
00:12:56,166 --> 0:12:57,436
Swift 中枚举类型的一个好处是

401
00:12:57,436 --> 0:12:59,796
它们是 自动可哈希的

402
00:12:59,796 --> 0:13:01,536
为它们添加了可哈希性

403
00:12:59,796 --> 0:13:01,536
为它们添加了可哈希性

404
00:13:01,976 --> 0:13:03,246
我们这里有一个枚举

405
00:13:03,246 --> 0:13:05,976
和一个 case 语句 没有其他的了

406
00:13:09,046 --> 0:13:10,076
对于我们的 Mountain 类型

407
00:13:10,076 --> 0:13:13,566
我们将查看 MountainsController

408
00:13:13,566 --> 0:13:14,276
也就是模型层

409
00:13:14,866 --> 0:13:16,586
我们在这把 Mountain 

410
00:13:16,586 --> 0:13:18,746
声明为一个 Swift 结构

411
00:13:19,296 --> 0:13:21,066
我们声明结构类型

412
00:13:21,066 --> 0:13:23,076
为 Hashable

413
00:13:23,076 --> 0:13:24,186
这样我们可以将它与 

414
00:13:24,186 --> 0:13:25,586
DiffableDataSource 一起使用

415
00:13:25,586 --> 0:13:26,966
而不是传递标识符

416
00:13:27,356 --> 0:13:28,816
重要的要求是

417
00:13:28,816 --> 0:13:31,186
每一座山都要用

418
00:13:31,246 --> 0:13:33,516
它的哈希值进行唯一识别

419
00:13:34,086 --> 0:13:36,866
所以我们通过给每座山

420
00:13:36,866 --> 0:13:38,726
自动生成唯一标识符

421
00:13:38,726 --> 0:13:40,786
来实现这一点

422
00:13:43,016 --> 0:13:48,606
在这里我们遵循了承诺的可哈希性

423
00:13:48,606 --> 0:13:50,916
我们只用那个标识符来

424
00:13:50,916 --> 0:13:51,666
提供哈希值

425
00:13:52,246 --> 0:13:53,156
这样我们就可以

426
00:13:53,156 --> 0:13:54,496
找到每一座山

427
00:13:54,636 --> 0:13:56,206
虽然每座山是值类型

428
00:13:56,206 --> 0:13:58,096
只是通过复制来传递

429
00:13:58,356 --> 0:13:59,746
没有可供引用的指针

430
00:14:00,026 --> 0:14:01,766
但是标识符和

431
00:14:01,766 --> 0:14:02,886
特定于该标识符的哈希值

432
00:14:02,886 --> 0:14:04,716
是它们足够独特

433
00:14:04,716 --> 0:14:06,056
以便 DiffableDataSource 

434
00:14:06,056 --> 0:14:07,376
可以追踪它们 从一个更新

435
00:14:07,376 --> 0:14:08,296
到下一个更新

436
00:14:08,506 --> 0:14:09,926
作为可哈希性的一部分

437
00:14:09,926 --> 0:14:11,486
我们也在这里进行了

438
00:14:11,486 --> 0:14:12,466
相等测试

439
00:14:12,946 --> 0:14:14,826
因此我们已经了解如何

440
00:14:14,826 --> 0:14:16,216
对 DiffableDataSource 发布更改

441
00:14:19,146 --> 0:14:20,166
让我们回到

442
00:14:20,166 --> 0:14:21,176
MountainsViewController

443
00:14:23,936 --> 0:14:25,636
非常方便的是

444
00:14:25,636 --> 0:14:26,766
我们创建了一个名为

445
00:14:26,906 --> 0:14:28,066
ConfigureDataSource 的函数

446
00:14:28,066 --> 0:14:29,376
我们在其中配置数据源

447
00:14:29,726 --> 0:14:30,806
代码量

448
00:14:30,806 --> 0:14:31,516
真的很少

449
00:14:33,106 --> 0:14:34,146
在本例中

450
00:14:34,146 --> 0:14:35,666
我们使用的是 UICollectionView

451
00:14:35,666 --> 0:14:36,666
所以我们实例化一个

452
00:14:36,666 --> 0:14:38,966
UICollectionViewDiffableDataSource

453
00:14:39,446 --> 0:14:41,886
我们传递的参数是

454
00:14:41,886 --> 0:14:43,696
Section 和 Item 类型

455
00:14:44,656 --> 0:14:45,866
把一个指向

456
00:14:45,866 --> 0:14:46,886
我们想要使用的 CollectionView 的指针

457
00:14:46,886 --> 0:14:47,286
也传递过去

458
00:14:47,956 --> 0:14:49,236
DiffableDataSource 会接受

459
00:14:49,236 --> 0:14:50,546
那个指针并自动

460
00:14:50,546 --> 0:14:52,586
接通自身作为

461
00:14:52,586 --> 0:14:53,746
CollectionView 的数据源

462
00:14:53,746 --> 0:14:54,906
我们不需要继续操作

463
00:14:57,406 --> 0:14:59,226
最后我们有这个

464
00:14:59,226 --> 0:15:00,586
尾随闭包参数

465
00:14:59,226 --> 0:15:00,586
尾随闭包参数

466
00:15:00,586 --> 0:15:02,226
用于 DiffableDataSource 的初始化

467
00:15:02,746 --> 0:15:04,366
所有这些

468
00:15:04,366 --> 0:15:06,256
都是你通常需要写的代码

469
00:15:06,256 --> 0:15:07,726
如果你从头开始

470
00:15:07,726 --> 0:15:09,396
实现你自己的数据源

471
00:15:09,396 --> 0:15:11,766
你将要实现 cellForItem(at: IndexPath) 方法

472
00:15:12,156 --> 0:15:13,896
这是数据源回调方法

473
00:15:13,896 --> 0:15:15,426
和我们在此处做的工作

474
00:15:15,426 --> 0:15:16,806
一模一样

475
00:15:17,236 --> 0:15:18,946
我们回调至

476
00:15:18,946 --> 0:15:22,226
CollectionView 并请求它

477
00:15:22,226 --> 0:15:24,246
提供适当类型的 Cell

478
00:15:24,246 --> 0:15:25,766
显示我们想要的数据

479
00:15:25,766 --> 0:15:28,296
我们用想要显示的内容

480
00:15:28,296 --> 0:15:29,276
填充该 Cell

481
00:15:29,276 --> 0:15:30,386
然后将其返回

482
00:15:30,526 --> 0:15:31,786
所以这只是使用了

483
00:15:31,786 --> 0:15:34,116
cellForItem(at: IndexPath) 代码

484
00:15:34,256 --> 0:15:35,526
并方便地将其移植到

485
00:15:35,526 --> 0:15:36,906
一个很好的闭包封装中

486
00:15:36,906 --> 0:15:38,646
是我们在实例化数据源时

487
00:15:38,646 --> 0:15:40,046
传递的

488
00:15:40,726 --> 0:15:41,766
有一个很好很方便的

489
00:15:41,766 --> 0:15:44,346
不同在于 除了提供我们

490
00:15:44,346 --> 0:15:46,186
要求的 Item

491
00:15:46,186 --> 0:15:47,866
IndexPath 之外

492
00:15:47,866 --> 0:15:49,846
也提供了其标识符

493
00:15:49,846 --> 0:15:52,486
在本例中 

494
00:15:52,546 --> 0:15:54,376
是原生的 Swift 值类型

495
00:15:54,536 --> 0:15:55,686
这对应于我们想要

496
00:15:55,686 --> 0:15:56,566
显示的特定 Item

497
00:15:57,506 --> 0:15:59,636
所以我们把 mountain 作为参数传递

498
00:15:59,636 --> 0:16:00,746
没有更多的工作要做

499
00:15:59,636 --> 0:16:00,746
没有更多的工作要做

500
00:16:00,746 --> 0:16:02,086
我们不必使用

501
00:16:02,086 --> 0:16:04,326
IndexPath 去查找

502
00:16:04,326 --> 0:16:07,146
它属于哪个模型层对象

503
00:16:07,456 --> 0:16:09,436
我们只是把 mountain 作为参数传递

504
00:16:09,436 --> 0:16:10,756
我们获取到山的名称

505
00:16:10,756 --> 0:16:13,096
并将其设置为该 Cell 的

506
00:16:13,096 --> 0:16:14,676
标签文本

507
00:16:15,676 --> 0:16:17,096
这就是全部内容

508
00:16:17,416 --> 0:16:18,916
关于如何设置

509
00:16:18,916 --> 0:16:20,196
和配置 CollectionView

510
00:16:20,196 --> 0:16:22,636
的所有其他内容都与之前相同

511
00:16:22,906 --> 0:16:24,666
在这个示例代码中

512
00:16:24,666 --> 0:16:25,826
没有隐藏任何

513
00:16:25,826 --> 0:16:26,556
performBatchUpdates() 代码

514
00:16:26,966 --> 0:16:27,916
这就是所有内容

515
00:16:27,916 --> 0:16:29,976
非常简单 来看看另一个例子

516
00:16:34,066 --> 0:16:36,536
这里我们有一个来自 iOS

517
00:16:36,536 --> 0:16:39,526
熟悉的 Wi-Fi 设置 UI 模型

518
00:16:39,526 --> 0:16:41,266
这个只比上一个

519
00:16:41,266 --> 0:16:42,626
稍微复杂一点

520
00:16:42,626 --> 0:16:43,936
因为我们在这里

521
00:16:43,936 --> 0:16:46,006
有两个不同的部分

522
00:16:46,396 --> 0:16:47,906
我们在顶部有个

523
00:16:47,906 --> 0:16:49,466
叫 Config 的部分

524
00:16:49,466 --> 0:16:51,686
其中有 Wi-Fi 启用/禁用开关

525
00:16:52,056 --> 0:16:53,966
并显示我们

526
00:16:53,966 --> 0:16:55,646
连接的当前网络

527
00:16:55,816 --> 0:16:58,136
在这下面我们有另一个动态更新的部分

528
00:16:58,136 --> 0:17:00,386
向我们展示了

529
00:16:58,136 --> 0:17:00,386
向我们展示了

530
00:17:00,386 --> 0:17:02,446
检测网络的列表

531
00:17:02,476 --> 0:17:03,986
供我们连接

532
00:17:05,205 --> 0:17:06,386
另外需要注意的是

533
00:17:06,386 --> 0:17:07,626
如果我们点击 Wi-Fi

534
00:17:07,626 --> 0:17:10,286
禁用开关

535
00:17:10,286 --> 0:17:11,646
或重新打开

536
00:17:12,556 --> 0:17:15,546
我们会看到一个流畅的 动画的

537
00:17:15,546 --> 0:17:16,136
UI 折叠或展开

538
00:17:16,136 --> 0:17:17,846
所有这些都可以使用

539
00:17:17,846 --> 0:17:18,826
DiffableDataSource 轻松实现

540
00:17:18,965 --> 0:17:20,746
让我们来看看这个

541
00:17:20,746 --> 0:17:22,356
动态 UI 是如何实现的

542
00:17:23,626 --> 0:17:25,906
转到我们的 WiFiSettingsViewController

543
00:17:28,036 --> 0:17:31,186
我们将查看 updateUI 函数

544
00:17:31,186 --> 0:17:32,586
我们将该函数命名为 updateUI

545
00:17:32,586 --> 0:17:34,046
我们已经注意到确保

546
00:17:34,046 --> 0:17:35,286
在我们需要显示的内容

547
00:17:35,626 --> 0:17:38,486
发生变化时它都会被调用

548
00:17:38,936 --> 0:17:39,896
大多数时候

549
00:17:39,896 --> 0:17:41,436
可能是因为我们检测到的

550
00:17:41,436 --> 0:17:43,186
当前可用的网络集合发生了变化

551
00:17:43,186 --> 0:17:44,406
但也可能是因为

552
00:17:44,406 --> 0:17:46,056
用户切换了 Wi-Fi

553
00:17:46,056 --> 0:17:47,096
启用/禁用 按钮

554
00:17:47,366 --> 0:17:48,566
出现任何改变我们 UI 的东西

555
00:17:48,566 --> 0:17:50,386
我们都确保会调用它

556
00:17:51,786 --> 0:17:53,456
所以我们在这里仍然有

557
00:17:53,456 --> 0:17:54,806
相同的三步过程

558
00:17:55,316 --> 0:17:57,266
获得我们想要显示的数据后

559
00:17:57,266 --> 0:17:58,776
我们从获取

560
00:17:58,776 --> 0:18:00,106
配置项目开始

561
00:17:58,776 --> 0:18:00,106
配置项目开始

562
00:18:00,106 --> 0:18:01,606
因为我们通常需要这些

563
00:18:02,206 --> 0:18:04,146
我们继续创建一个快照

564
00:18:04,736 --> 0:18:06,726
这个快照最初也是空的

565
00:18:06,726 --> 0:18:07,566
那就让我们用我们想要

566
00:18:07,566 --> 0:18:07,976
展示的东西填充它

567
00:18:10,776 --> 0:18:12,366
我们添加的第一个 Section

568
00:18:12,366 --> 0:18:14,016
出现在顶端的配置部分

569
00:18:15,046 --> 0:18:16,386
我们添加它的 Item

570
00:18:16,386 --> 0:18:18,376
所以会有一个或两个 Item 是取决于

571
00:18:18,376 --> 0:18:19,326
Wi-Fi 是否启用

572
00:18:21,476 --> 0:18:23,076
如果现在启用了 Wi-Fi 

573
00:18:23,076 --> 0:18:25,026
我们也会想和后端

574
00:18:25,026 --> 0:18:25,716
和模型层交流

575
00:18:25,716 --> 0:18:28,836
索要可用网络的列表

576
00:18:29,396 --> 0:18:31,806
我们将把这个列表

577
00:18:31,806 --> 0:18:34,226
包装成一些我们

578
00:18:34,226 --> 0:18:35,946
在稍后会看到的项目类型中

579
00:18:38,256 --> 0:18:39,916
我们为该网络列表

580
00:18:39,916 --> 0:18:40,886
添加一个 Section

581
00:18:41,316 --> 0:18:43,326
然后我们要添加

582
00:18:43,326 --> 0:18:44,876
那个 Section 中的 Item

583
00:18:45,396 --> 0:18:46,246
请注意

584
00:18:46,246 --> 0:18:47,296
我们在这里有

585
00:18:47,396 --> 0:18:49,266
两个不同的 Section

586
00:18:49,266 --> 0:18:51,983
我们可以明确哪个 Section 添加了 Item

587
00:18:55,056 --> 0:18:56,316
就是这样 我们准备好了

588
00:18:56,316 --> 0:18:58,086
我们已经描述了所有我们想展示的内容

589
00:18:58,336 --> 0:18:59,266
所以我们只需让

590
00:18:59,266 --> 0:19:00,756
DiffableDataSource 

591
00:18:59,266 --> 0:19:00,756
DiffableDataSource 

592
00:19:00,756 --> 0:19:02,636
应用这些更改

593
00:19:02,666 --> 0:19:03,796
可以以动画的形式展现差异

594
00:19:04,236 --> 0:19:05,596
可能有时候

595
00:19:05,596 --> 0:19:06,816
你想要选择

596
00:19:06,816 --> 0:19:07,386
不用动画展现差异

597
00:19:07,386 --> 0:19:08,626
例如

598
00:19:08,626 --> 0:19:09,776
当你第一次打开 UI

599
00:19:09,776 --> 0:19:11,306
并显示初始数据集时

600
00:19:11,626 --> 0:19:13,116
你可能想 也可能不想要动画

601
00:19:13,396 --> 0:19:15,306
通常你希望它是即时的

602
00:19:15,536 --> 0:19:16,506
因此你可以将

603
00:19:16,636 --> 0:19:17,516
animatingDifferences 设为 false

604
00:19:17,516 --> 0:19:17,976
就像我们在本例中做的一样

605
00:19:22,436 --> 0:19:23,826
看我们这里使用的类型

606
00:19:23,826 --> 0:19:24,596
我们将一个 Section 类型

607
00:19:24,596 --> 0:19:26,166
和一个 Item 类型

608
00:19:26,166 --> 0:19:27,466
作为参数提供给

609
00:19:27,466 --> 0:19:28,426
DiffableDataSource

610
00:19:29,226 --> 0:19:30,606
回到顶部我们可以看到

611
00:19:30,606 --> 0:19:31,646
正如我们想象的一样

612
00:19:31,646 --> 0:19:33,066
Section 仍然是枚举类型

613
00:19:33,066 --> 0:19:34,286
我们在这里需要

614
00:19:34,286 --> 0:19:35,666
两个不同的 Section

615
00:19:37,106 --> 0:19:39,586
再次 作为枚举类型的 Section

616
00:19:39,586 --> 0:19:40,836
在 Swift 中是自动可哈希的

617
00:19:40,836 --> 0:19:41,976
所以我们很高兴

618
00:19:44,206 --> 0:19:45,796
然后我们在这里声明了一个 Item 类型

619
00:19:45,866 --> 0:19:47,306
这是一种结构体类型

620
00:19:47,306 --> 0:19:47,966
与 Mountains 一样

621
00:19:48,296 --> 0:19:50,046
我们声明它是可哈希的

622
00:19:50,756 --> 0:19:52,226
声明这个类型的原因是

623
00:19:52,226 --> 0:19:53,536
当我们查看列表时

624
00:19:53,536 --> 0:19:55,416
它主要包含列表是

625
00:19:55,416 --> 0:19:57,736
其中的网络项目

626
00:19:57,736 --> 0:19:58,766
但除此之外

627
00:19:58,766 --> 0:20:00,406
上面还有个不同的项目

628
00:19:58,766 --> 0:20:00,406
上面还有个不同的项目

629
00:20:00,406 --> 0:20:02,136
就是 Wi-Fi 启用/禁用开关

630
00:20:02,136 --> 0:20:03,236
那不是网络项目

631
00:20:03,236 --> 0:20:04,826
所以我们这里有一个异构列表

632
00:20:05,126 --> 0:20:06,266
我们所做的就是

633
00:20:06,266 --> 0:20:08,336
用这种通用包装器类型

634
00:20:08,336 --> 0:20:09,586
封装每个 Item

635
00:20:10,446 --> 0:20:11,946
但是由于这个包装器类型

636
00:20:11,946 --> 0:20:13,556
是我们要传递给 DiffableDataSource

637
00:20:13,556 --> 0:20:14,666
的项目类型

638
00:20:14,666 --> 0:20:16,236
我们必须注意确保

639
00:20:16,236 --> 0:20:17,696
它是可哈希的并且

640
00:20:17,696 --> 0:20:18,686
项目是由哈希值

641
00:20:18,686 --> 0:20:20,186
唯一标识的

642
00:20:21,026 --> 0:20:23,796
所以对于网络项目

643
00:20:23,796 --> 0:20:25,866
我们可以从 netowrk Item

644
00:20:25,866 --> 0:20:26,816
得到唯一标识符

645
00:20:26,816 --> 0:20:29,306
移植到 Network Item 中

646
00:20:30,786 --> 0:20:32,146
对于配置项目

647
00:20:32,146 --> 0:20:33,606
我们只是动态

648
00:20:33,606 --> 0:20:34,426
生成 UUID

649
00:20:36,866 --> 0:20:38,026
再看看我们的

650
00:20:38,026 --> 0:20:40,296
哈希函数

651
00:20:40,366 --> 0:20:42,176
它只是基于唯一标识符

652
00:20:42,176 --> 0:20:43,406
计算哈希值

653
00:20:43,406 --> 0:20:44,616
而这就是

654
00:20:44,616 --> 0:20:45,916
DiffableDataSource 能够

655
00:20:45,916 --> 0:20:47,516
识别从一个更新周期

656
00:20:47,516 --> 0:20:50,176
到下一个更新周期时相同的项目所需的全部内容

657
00:20:51,616 --> 0:20:52,816
让我们看看

658
00:20:52,816 --> 0:20:53,696
配置数据源的位置

659
00:20:55,616 --> 0:20:57,486
这与之前非常相似

660
00:20:57,486 --> 0:20:59,256
除了这次

661
00:20:59,256 --> 0:21:00,886
我们用的是 UITableView

662
00:20:59,256 --> 0:21:00,886
我们用的是 UITableView

663
00:21:01,306 --> 0:21:02,696
从创建和提交 

664
00:21:02,766 --> 0:21:04,886
快照的角度来看

665
00:21:04,886 --> 0:21:06,336
这并不重要

666
00:21:06,336 --> 0:21:07,396
API 非常相似

667
00:21:07,396 --> 0:21:08,986
但对于设置

668
00:21:08,986 --> 0:21:10,236
我们必须实例化正确类型的

669
00:21:10,266 --> 0:21:11,186
DiffableDataSource

670
00:21:11,286 --> 0:21:13,496
我们有一个 UITableViewDiffableDataSource

671
00:21:14,406 --> 0:21:16,066
我们用将要使用的

672
00:21:16,066 --> 0:21:18,506
Section 和 Item 类型作为参数

673
00:21:18,506 --> 0:21:19,486
然后传递一个

674
00:21:19,486 --> 0:21:20,996
指向 TableView 的指针

675
00:21:21,066 --> 0:21:24,056
它将进行连接

676
00:21:24,056 --> 0:21:26,196
把 DiffableDataSource 作为数据源

677
00:21:27,646 --> 0:21:29,326
最后我们得到了

678
00:21:29,356 --> 0:21:30,526
提供 Item 的尾随闭包

679
00:21:30,696 --> 0:21:32,926
乍一看起来

680
00:21:32,926 --> 0:21:35,126
这更复杂

681
00:21:35,126 --> 0:21:36,386
但实际上只是因为

682
00:21:36,386 --> 0:21:37,896
我们有各种不同类型的项目

683
00:21:37,896 --> 0:21:39,606
我们要显示的项目是异质的

684
00:21:39,606 --> 0:21:41,056
基本上有三种类型的项目

685
00:21:41,396 --> 0:21:42,646
我们以不同的方式处理它们

686
00:21:43,696 --> 0:21:44,626
但是这段代码中

687
00:21:44,626 --> 0:21:45,036
即使我们没有使用

688
00:21:45,036 --> 0:21:46,106
DiffableDataSource 

689
00:21:46,106 --> 0:21:46,366
它也会存在

690
00:21:46,366 --> 0:21:47,886
它会在 cellForItem(at: IndexPath)

691
00:21:47,966 --> 0:21:49,486
方法中出现

692
00:21:50,166 --> 0:21:52,846
设置这个 UI 很简单

693
00:21:52,846 --> 0:21:54,346
甚至配置

694
00:21:54,346 --> 0:21:55,976
DiffableDataSource 也不是那么难

695
00:21:57,416 --> 0:22:00,166
最后一个例子

696
00:21:57,416 --> 0:22:00,166
最后一个例子

697
00:22:00,166 --> 0:22:01,226
可能是最有趣的

698
00:22:01,556 --> 0:22:02,566
这里我们有一个

699
00:22:02,566 --> 0:22:05,036
UICollectionView 

700
00:22:05,036 --> 0:22:06,286
它显示的项目

701
00:22:06,286 --> 0:22:08,276
表示为色卡

702
00:22:08,746 --> 0:22:09,786
它们一开始是

703
00:22:09,786 --> 0:22:12,036
随机混色的

704
00:22:12,626 --> 0:22:14,916
如果我点击 Sort 按钮

705
00:22:14,916 --> 0:22:16,666
我们可以看着它们被迭代排序

706
00:22:16,806 --> 0:22:18,426
为频谱顺序

707
00:22:19,316 --> 0:22:20,976
所以除了观看时令人着迷

708
00:22:20,976 --> 0:22:21,976
和有趣之外

709
00:22:21,976 --> 0:22:22,043
[笑声]

710
00:22:22,543 --> 0:22:25,576
[掌声]

711
00:22:26,076 --> 0:22:27,516
这要归功于 Steve

712
00:22:28,666 --> 0:22:29,806
除了观看时非常迷人

713
00:22:29,806 --> 0:22:31,466
和有趣之外

714
00:22:31,726 --> 0:22:33,256
这个例子与我们在其他例子中

715
00:22:33,256 --> 0:22:34,776
构建和提交

716
00:22:34,776 --> 0:22:36,706
更新的方式

717
00:22:36,706 --> 0:22:38,346
略有不同

718
00:22:39,036 --> 0:22:41,786
所以如果我们想

719
00:22:41,786 --> 0:22:42,976
如果我们的目标只是

720
00:22:42,976 --> 0:22:44,396
把所有的东西排序然后

721
00:22:44,396 --> 0:22:46,116
跳到最终状态 我们可以这么做对吧

722
00:22:46,386 --> 0:22:48,296
这个演示程序的设置

723
00:22:48,296 --> 0:22:51,006
使我们能够在

724
00:22:51,046 --> 0:22:52,296
每个中间阶段观察

725
00:22:52,326 --> 0:22:53,536
迭代排序过程

726
00:22:54,136 --> 0:22:55,586
为了做到这一点

727
00:22:55,586 --> 0:22:57,146
我们的排序功能

728
00:22:57,146 --> 0:22:58,176
会经过每个阶段

729
00:22:58,176 --> 0:22:59,646
并一步步给我们提供结果

730
00:22:59,646 --> 0:23:01,366
它为我们提供了

731
00:22:59,646 --> 0:23:01,366
它为我们提供了

732
00:23:01,366 --> 0:23:03,356
每个连续的新状态 

733
00:23:03,356 --> 0:23:05,286
每次发生更新时

734
00:23:05,286 --> 0:23:06,536
我们都会创建一个快照

735
00:23:06,536 --> 0:23:07,146
并应用快照

736
00:23:07,146 --> 0:23:08,286
才有了这个

737
00:23:08,336 --> 0:23:09,876
美好有趣的动画视图

738
00:23:10,936 --> 0:23:11,786
来看看我们是

739
00:23:11,786 --> 0:23:12,686
如何实现它的

740
00:23:12,686 --> 0:23:12,976
以及它的不同之处

741
00:23:16,996 --> 0:23:17,776
我们将在这里查看

742
00:23:17,776 --> 0:23:19,496
InsertionSortViewController

743
00:23:21,576 --> 0:23:23,126
所有有趣的动作

744
00:23:23,126 --> 0:23:25,666
都发生在 PerformSortStep 函数中

745
00:23:26,876 --> 0:23:29,006
正如我所说

746
00:23:29,006 --> 0:23:30,266
总是有三步循环

747
00:23:30,266 --> 0:23:31,356
我们将获得一个快照

748
00:23:31,356 --> 0:23:33,506
填充它然后应用它

749
00:23:33,626 --> 0:23:36,916
但在这种情况下

750
00:23:36,916 --> 0:23:38,166
我们没有创建

751
00:23:38,166 --> 0:23:39,736
新的空快照

752
00:23:39,736 --> 0:23:41,016
而是利用 DiffableDataSource 的功能

753
00:23:41,436 --> 0:23:43,986
请求当前的快照

754
00:23:44,386 --> 0:23:46,046
现在这个快照

755
00:23:46,076 --> 0:23:47,766
预先填充了

756
00:23:47,856 --> 0:23:49,376
当前 CollectionView

757
00:23:49,376 --> 0:23:50,596
看到的 UICollectionView 中

758
00:23:50,596 --> 0:23:51,526
显示的内容的真实情况

759
00:23:52,576 --> 0:23:54,626
所以我们不必从头开始

760
00:23:54,776 --> 0:23:56,306
我们可以从该状态

761
00:23:56,306 --> 0:23:58,096
开始并计算下一个

762
00:23:58,556 --> 0:24:01,496
中间状态在这里

763
00:23:58,556 --> 0:24:01,496
中间状态在这里

764
00:24:01,496 --> 0:24:02,786
我们填充 Snapshot

765
00:24:02,786 --> 0:24:05,156
我们将看到熟悉的 appendItems 

766
00:24:05,156 --> 0:24:05,726
函数被调用

767
00:24:05,726 --> 0:24:07,936
但我们这里也有一个 deleteItems 函数

768
00:24:08,236 --> 0:24:09,576
当你查看到

769
00:24:09,576 --> 0:24:10,986
Snapshot API 时

770
00:24:10,986 --> 0:24:12,296
你将会看到有各种各样的

771
00:24:12,296 --> 0:24:13,596
功能可以在你

772
00:24:13,596 --> 0:24:14,756
进行此类用法时

773
00:24:14,756 --> 0:24:15,786
修改现有 Snapshot

774
00:24:15,786 --> 0:24:17,356
你可以将 Item 从一个地方

775
00:24:17,356 --> 0:24:18,816
移到另一个地方 以此类推

776
00:24:19,656 --> 0:24:20,656
但在其他方面

777
00:24:20,706 --> 0:24:21,666
和之前没有什么区别

778
00:24:21,666 --> 0:24:22,736
我们只是想

779
00:24:22,736 --> 0:24:24,996
设置我们想要显示的新的最终状态

780
00:24:24,996 --> 0:24:27,066
我们使用的是标识符

781
00:24:27,066 --> 0:24:28,866
而不是 IndexPath

782
00:24:28,866 --> 0:24:29,776
这点很好

783
00:24:30,566 --> 0:24:33,386
最后当我们完成时

784
00:24:33,386 --> 0:24:35,176
我们所要做的就是

785
00:24:35,176 --> 0:24:36,706
将 Snapshot 应用于

786
00:24:36,706 --> 0:24:37,726
我们的 DiffableDataSource

787
00:24:38,556 --> 0:24:39,756
我们得到了这个好看的

788
00:24:40,446 --> 0:24:42,976
渐进式排序 非常好

789
00:24:43,041 --> 0:24:45,041
[掌声]

790
00:24:45,066 --> 0:24:49,556
谢谢 [掌声]

791
00:24:50,056 --> 0:24:51,286
这就是我们设置

792
00:24:51,286 --> 0:24:52,226
DiffableDataSource 的地方

793
00:24:52,226 --> 0:24:54,246
这是用于 UICollectionView

794
00:24:54,606 --> 0:24:56,436
我们指定我们使用的类型

795
00:24:56,436 --> 0:24:58,546
CollectionView

796
00:24:58,546 --> 0:25:00,026
我们还有提供 Item 的闭包

797
00:24:58,546 --> 0:25:00,026
我们还有提供 Item 的闭包

798
00:25:00,026 --> 0:25:01,596
也很简单

799
00:25:01,596 --> 0:25:02,636
因为我们只是

800
00:25:02,636 --> 0:25:03,716
显示这些色卡

801
00:25:04,926 --> 0:25:06,196
所以通过这三个例子

802
00:25:06,196 --> 0:25:08,866
我们可以看出

803
00:25:08,866 --> 0:25:11,306
创建这些

804
00:25:11,306 --> 0:25:13,046
动态 UI 所需的代码很少很简单

805
00:25:13,536 --> 0:25:15,986
这些 UI 对更改也有非常强的鲁棒性

806
00:25:15,986 --> 0:25:17,586
我们可以进行更改

807
00:25:17,586 --> 0:25:18,826
而不必担心在代码中

808
00:25:18,826 --> 0:25:20,086
出现奇怪的异常

809
00:25:20,086 --> 0:25:21,096
它们的鲁棒性都很强

810
00:25:21,096 --> 0:25:23,086
已经融入到了 API

811
00:25:23,086 --> 0:25:23,496
的工作原理中

812
00:25:24,166 --> 0:25:25,256
我们现在确实触及了一些

813
00:25:25,286 --> 0:25:27,066
有趣的细微差别

814
00:25:27,066 --> 0:25:29,096
特别是对象

815
00:25:29,096 --> 0:25:30,826
唯一标识的重要性

816
00:25:30,826 --> 0:25:31,946
如果你使用的是 Swift 类型

817
00:25:31,946 --> 0:25:34,276
这些 Swift 类型需要

818
00:25:34,276 --> 0:25:35,456
符合的要求是

819
00:25:35,456 --> 0:25:36,646
必须可哈希

820
00:25:37,096 --> 0:25:38,886
让我们进入更深的研究

821
00:25:38,886 --> 0:25:40,286
使这些问题成为

822
00:25:40,286 --> 0:25:40,836
讨论的焦点

823
00:25:40,926 --> 0:25:41,966
我现在要邀请我的同事

824
00:25:41,966 --> 0:25:43,656
Steve 再次上台

825
00:25:43,656 --> 0:25:47,626
谢谢 [掌声]

826
00:25:48,126 --> 0:25:50,356
&gt;&gt; 通过所有的演示

827
00:25:50,436 --> 0:25:52,836
我对这个 UI 是如何工作的

828
00:25:52,836 --> 0:25:53,816
有了一些了解

829
00:25:54,156 --> 0:25:56,046
我想对如何充分利用

830
00:25:56,046 --> 0:25:57,276
这个 API 进行

831
00:25:57,276 --> 0:25:58,976
更详细的讨论

832
00:26:02,656 --> 0:26:04,346
好的 首先

833
00:26:04,346 --> 0:26:05,236
正如我们在整个演示中看到的

834
00:26:05,236 --> 0:26:06,396
基本上有三个步骤

835
00:26:06,666 --> 0:26:07,856
你希望创建一个 Snapshot

836
00:26:08,906 --> 0:26:10,246
根据你的需要来配置它

837
00:26:10,246 --> 0:26:13,096
然后应用它 所以你总是希望调用

838
00:26:13,096 --> 0:26:13,806
apply() 方法

839
00:26:14,256 --> 0:26:15,576
而你不需要再

840
00:26:15,576 --> 0:26:16,766
调用 performBatchUpdates 方法了

841
00:26:16,986 --> 0:26:17,646
那已经过时了

842
00:26:17,946 --> 0:26:19,766
也不需要 insertItems 都没有了

843
00:26:19,946 --> 0:26:21,266
如果你调用这些函数

844
00:26:21,266 --> 0:26:22,066
框架会抱怨

845
00:26:22,296 --> 0:26:23,846
你知道

846
00:26:23,846 --> 0:26:28,306
你会看到的创建快照

847
00:26:28,306 --> 0:26:29,706
有两种方法

848
00:26:29,766 --> 0:26:31,276
最常见的方法

849
00:26:31,276 --> 0:26:32,486
是创建一个空的快照

850
00:26:32,706 --> 0:26:33,816
在这里我们看到

851
00:26:33,816 --> 0:26:35,206
我们用 Section 和 Item 类型

852
00:26:35,206 --> 0:26:36,996
构建 Snapshot 

853
00:26:38,376 --> 0:26:39,736
你也可以创建一个

854
00:26:39,736 --> 0:26:40,696
就像我们在最后一个

855
00:26:40,696 --> 0:26:41,896
演示中看到的那样

856
00:26:41,896 --> 0:26:42,766
当某个动作发生

857
00:26:42,766 --> 0:26:44,196
你需要修改

858
00:26:44,196 --> 0:26:45,326
一个小地方时

859
00:26:45,326 --> 0:26:50,036
这非常有用 现在当你创建它时

860
00:26:50,036 --> 0:26:50,936
你将得到一份副本

861
00:26:51,056 --> 0:26:52,696
所以你可以随意改变它

862
00:26:52,696 --> 0:26:54,066
它不会影响

863
00:26:54,206 --> 0:26:55,976
它的数据源

864
00:26:58,186 --> 0:26:59,456
一旦你有了这个快照

865
00:26:59,456 --> 0:27:00,836
如果你提出了一些问题

866
00:26:59,456 --> 0:27:00,836
如果你提出了一些问题

867
00:27:00,836 --> 0:27:01,856
比如 Item 的数量是多少

868
00:27:01,856 --> 0:27:02,746
Section 的数量是多少

869
00:27:02,846 --> 0:27:03,946
识别标识符

870
00:27:04,286 --> 0:27:06,296
你都可以做到 你可以在 SDK 中

871
00:27:06,296 --> 0:27:07,976
查看到很多 API 这里只展示了一些

872
00:27:11,156 --> 0:27:12,296
我保证过

873
00:27:12,296 --> 0:27:13,146
不再有 IndexPath

874
00:27:13,146 --> 0:27:14,456
因此当我们配置

875
00:27:14,456 --> 0:27:16,496
这些快照时

876
00:27:16,496 --> 0:27:18,666
你将永远不会通过显示的 API 

877
00:27:18,666 --> 0:27:20,516
看到 IndexPath

878
00:27:21,066 --> 0:27:22,506
所以到目前为止

879
00:27:22,506 --> 0:27:23,846
我们已经看到了一种

880
00:27:23,846 --> 0:27:25,226
非常常见的添加 Section 和 Item 的模式

881
00:27:25,226 --> 0:27:26,026
诸如此类

882
00:27:26,026 --> 0:27:27,026
但你也可以执行

883
00:27:27,026 --> 0:27:28,456
插入 移动 和删除等操作

884
00:27:29,246 --> 0:27:31,226
所有这些 API 都采用

885
00:27:31,456 --> 0:27:34,276
其他相对标识符

886
00:27:34,276 --> 0:27:35,596
来进行标示

887
00:27:35,596 --> 0:27:37,426
如果我想插入 20 个

888
00:27:37,426 --> 0:27:38,746
唯一的新标识符

889
00:27:39,686 --> 0:27:40,776
在另一个标识符之前或之后插入

890
00:27:40,776 --> 0:27:42,736
我们完成任务的

891
00:27:42,736 --> 0:27:43,336
明确的 API

892
00:27:43,336 --> 0:27:44,256
所以你会说

893
00:27:44,256 --> 0:27:45,566
在这个标识符之前

894
00:27:45,566 --> 0:27:46,236
插入这些标识符

895
00:27:47,056 --> 0:27:49,246
现在如果你在特定 Section 中

896
00:27:49,246 --> 0:27:50,316
没有任何内容

897
00:27:50,316 --> 0:27:51,536
则没有标识符可以

898
00:27:51,536 --> 0:27:53,086
锚定插入或移动

899
00:27:53,696 --> 0:27:55,356
这就是我们提供 append API 的原因

900
00:27:55,356 --> 0:27:57,586
你可以添加 Section 和 Item

901
00:27:58,836 --> 0:28:00,316
现在在你熟悉的路径中

902
00:27:58,836 --> 0:28:00,316
现在在你熟悉的路径中

903
00:28:00,316 --> 0:28:01,106
你有许多 Section

904
00:28:01,106 --> 0:28:03,386
你在这里配置你的快照

905
00:28:03,386 --> 0:28:04,866
你可以循环遍历 Section 数据

906
00:28:04,866 --> 0:28:05,996
在这种情况下

907
00:28:05,996 --> 0:28:08,316
可以在不指定 Section 的情况下添加 Item

908
00:28:08,316 --> 0:28:09,456
Swift 中有一个

909
00:28:09,456 --> 0:28:11,426
默认参数指定为 null

910
00:28:11,666 --> 0:28:13,246
在这种情况下

911
00:28:13,246 --> 0:28:14,966
是默认添加到最后一个已知的 Section

912
00:28:14,966 --> 0:28:15,976
这使得代码非常美观

913
00:28:19,066 --> 0:28:21,246
我们再来谈谈标识符

914
00:28:21,986 --> 0:28:22,896
这些必须是唯一的

915
00:28:23,386 --> 0:28:25,726
这不是一个大问题

916
00:28:25,726 --> 0:28:26,896
因为大多数 App 

917
00:28:26,896 --> 0:28:28,616
在其模型对象中都有

918
00:28:28,616 --> 0:28:29,426
某种身份概念

919
00:28:29,916 --> 0:28:31,456
因此使用该唯一标识符

920
00:28:31,456 --> 0:28:32,976
是很自然的步骤

921
00:28:35,046 --> 0:28:35,936
现在在 Swift 中

922
00:28:35,936 --> 0:28:37,096
需要符合可哈希的要求

923
00:28:37,526 --> 0:28:38,976
这很方便

924
00:28:38,976 --> 0:28:39,926
Swift 中的很多东西

925
00:28:39,926 --> 0:28:40,536
都会自动完成

926
00:28:40,536 --> 0:28:42,356
我们在枚举类型中

927
00:28:42,356 --> 0:28:42,976
看到了这种自动合成

928
00:28:45,646 --> 0:28:47,466
我们有字符串

929
00:28:47,466 --> 0:28:48,956
整数和 UUID

930
00:28:48,956 --> 0:28:50,456
所有这些可用于

931
00:28:50,456 --> 0:28:51,286
DiffableDataSource 的东西

932
00:28:52,746 --> 0:28:54,636
现在我们看到了

933
00:28:54,636 --> 0:28:56,266
你可以将一些模型数据

934
00:28:56,266 --> 0:28:57,396
引入这些标识符

935
00:28:57,496 --> 0:28:58,626
这真的很方便

936
00:28:58,996 --> 0:29:00,266
现在你的身份需要来自

937
00:28:58,996 --> 0:29:00,266
现在你的身份需要来自

938
00:29:00,266 --> 0:29:01,506
某个唯一的标识符

939
00:29:01,856 --> 0:29:03,816
但你也可以引入其他属性

940
00:29:03,816 --> 0:29:05,536
当我们看到山峰的名字时

941
00:29:05,536 --> 0:29:07,666
也可以找到我们例子中的对象

942
00:29:08,536 --> 0:29:09,426
这非常方便

943
00:29:09,426 --> 0:29:10,656
因为当你配置你的 Cell 时

944
00:29:10,656 --> 0:29:11,866
你所需要的所有东西

945
00:29:11,866 --> 0:29:12,966
都在这里

946
00:29:12,966 --> 0:29:13,926
别去别的地方找了

947
00:29:18,056 --> 0:29:19,816
这是一个小的快速模版

948
00:29:19,816 --> 0:29:20,886
我们在整个示例中一直有看到

949
00:29:20,886 --> 0:29:22,086
关于如何

950
00:29:22,086 --> 0:29:26,966
在 Swift 创建可哈希的结构体非常直观

951
00:29:30,506 --> 0:29:31,246
那么基于 IndexPath 的

952
00:29:31,466 --> 0:29:32,636
API 要怎么处理呢

953
00:29:32,636 --> 0:29:34,926
我们有 CollectionView 和 TableView

954
00:29:34,926 --> 0:29:36,656
它们有大量基于 IndexPath 的 API

955
00:29:36,656 --> 0:29:38,276
其中很多都在 Delegate 方法中

956
00:29:38,276 --> 0:29:40,176
因此如果用户与内容交互

957
00:29:40,176 --> 0:29:41,776
并点击某个项目

958
00:29:42,476 --> 0:29:43,356
你将得到这个熟悉的

959
00:29:43,356 --> 0:29:46,006
Delegate 消息 didSelectItemAt indexPath

960
00:29:47,126 --> 0:29:48,536
但是我们已经进入了这个

961
00:29:48,536 --> 0:29:49,636
基于标识符的新世界

962
00:29:49,636 --> 0:29:50,236
我们将如何处理

963
00:29:50,236 --> 0:29:51,066
这个 IndexPath

964
00:29:51,066 --> 0:29:51,906
你知道那是老一套

965
00:29:51,906 --> 0:29:54,236
所以我们这里有新的 API

966
00:29:54,296 --> 0:29:55,356
让你在标识符

967
00:29:55,356 --> 0:29:57,716
和 IndexPaths 之间进行转换

968
00:29:57,716 --> 0:29:59,196
然后从 IndexPaths 

969
00:29:59,196 --> 0:29:59,926
转化为标识符

970
00:29:59,926 --> 0:30:01,046
所以这里我们看一个例子

971
00:29:59,926 --> 0:30:01,046
所以这里我们看一个例子

972
00:30:01,556 --> 0:30:04,606
我们正在使用过去的 IndexPath 

973
00:30:04,606 --> 0:30:06,746
并将其转换回标识符

974
00:30:06,746 --> 0:30:07,736
这会在常数时间内完成

975
00:30:07,846 --> 0:30:08,976
这非常非常快

976
00:30:12,426 --> 0:30:13,886
说到性能

977
00:30:14,906 --> 0:30:17,406
我们做了大量的工作

978
00:30:17,406 --> 0:30:19,516
让它尽可能更快

979
00:30:19,656 --> 0:30:20,606
还有很多

980
00:30:20,606 --> 0:30:21,976
低层次的东西非常重要

981
00:30:25,266 --> 0:30:26,646
如果你学过

982
00:30:26,646 --> 0:30:27,746
计算机科学

983
00:30:27,746 --> 0:30:29,176
关于差异对比是如何发生的整个概念

984
00:30:29,176 --> 0:30:30,516
你会知道这是

985
00:30:30,516 --> 0:30:31,606
一个 O(N) 的线性运算

986
00:30:31,606 --> 0:30:34,236
而简单来说

987
00:30:34,236 --> 0:30:35,276
它只是意味着你的 Item 越多

988
00:30:35,276 --> 0:30:36,976
你进行差异对比的时间越长

989
00:30:39,106 --> 0:30:40,236
因此在开发过程中

990
00:30:40,236 --> 0:30:42,006
衡量 App 很重要

991
00:30:42,006 --> 0:30:43,836
我们都知道这一点 我们希望确保

992
00:30:43,836 --> 0:30:46,076
主队列尽可能空闲

993
00:30:46,106 --> 0:30:48,766
以便真正响应用户事件

994
00:30:48,766 --> 0:30:50,376
我们渲染的非常快

995
00:30:50,896 --> 0:30:52,746
所以当你在测试你的 App 时

996
00:30:52,796 --> 0:30:53,536
你们都会测试 App

997
00:30:53,906 --> 0:30:55,566
在开发过程中 尤其是在结束时

998
00:30:55,746 --> 0:30:58,776
我想确保主队列上的尽可能的没有内容

999
00:30:59,906 --> 0:31:01,036
如果你发现线性差异对比中

1000
00:30:59,906 --> 0:31:01,036
如果你发现线性差异对比中

1001
00:31:01,036 --> 0:31:02,426
有大量 Item 需要花费

1002
00:31:02,426 --> 0:31:03,526
额外的时间

1003
00:31:03,526 --> 0:31:05,656
那么从后台队列

1004
00:31:05,656 --> 0:31:06,966
调用 apply() 方法会比较安全

1005
00:31:07,516 --> 0:31:14,336
[掌声]

1006
00:31:14,836 --> 0:31:15,926
真正酷的是

1007
00:31:15,986 --> 0:31:17,286
我们为了支持而使用的

1008
00:31:17,286 --> 0:31:18,486
API 的数量

1009
00:31:18,486 --> 0:31:19,376
没有 API

1010
00:31:20,016 --> 0:31:21,046
[笑声]

1011
00:31:21,046 --> 0:31:21,976
这就是最好的 API

1012
00:31:22,031 --> 0:31:24,031
[欢呼声和掌声]

1013
00:31:24,046 --> 0:31:28,046
对吗 那么如果从后台队列

1014
00:31:28,046 --> 0:31:29,586
调用 apply() 会发生什么

1015
00:31:29,586 --> 0:31:30,886
实际上

1016
00:31:30,886 --> 0:31:31,966
框架足够聪明可以知道

1017
00:31:31,966 --> 0:31:32,856
现在不在主队列中

1018
00:31:32,856 --> 0:31:34,056
它会说 让我们继续

1019
00:31:34,056 --> 0:31:35,076
在这里进行差异对比

1020
00:31:36,126 --> 0:31:37,716
一旦计算出差异

1021
00:31:37,956 --> 0:31:39,086
我们就会跳到主队列

1022
00:31:39,086 --> 0:31:40,926
应用我们差异对比的结果

1023
00:31:40,926 --> 0:31:41,966
程序就像往常一样继续

1024
00:31:45,256 --> 0:31:46,706
只有一个忠告

1025
00:31:46,706 --> 0:31:47,696
我保证就一个

1026
00:31:48,406 --> 0:31:51,136
如果选择此模型从

1027
00:31:51,136 --> 0:31:52,466
后台调用 apply() 

1028
00:31:52,606 --> 0:31:53,226
则应保持一致

1029
00:31:53,626 --> 0:31:55,236
永远都从后台队列中调用它

1030
00:31:55,286 --> 0:31:56,486
你永远不希望发生混乱

1031
00:31:56,526 --> 0:31:58,226
一会从后台队列

1032
00:31:58,326 --> 0:32:00,786
一会儿从主队列调用它 请始终用同样的方法

1033
00:31:58,326 --> 0:32:00,786
一会儿从主队列调用它 请始终用同样的方法

1034
00:32:02,496 --> 0:32:03,566
我们是好公民

1035
00:32:03,566 --> 0:32:05,656
如果你弄错了 我们会抱怨的

1036
00:32:06,536 --> 0:32:08,016
所以在 Apple 公司

1037
00:32:08,216 --> 0:32:09,716
合作是很重要的一部分

1038
00:32:09,716 --> 0:32:11,166
这是我们组织的主要力量

1039
00:32:11,166 --> 0:32:12,666
是我们彼此交谈

1040
00:32:12,666 --> 0:32:14,616
和共同解决问题的方法

1041
00:32:15,286 --> 0:32:16,976
作为框架的作者

1042
00:32:16,976 --> 0:32:18,146
这其中的一部分是

1043
00:32:18,146 --> 0:32:19,456
确保你所有的客户

1044
00:32:19,456 --> 0:32:20,796
或者你经常与之交谈的人

1045
00:32:20,796 --> 0:32:22,366
找到困扰他们的问题所在

1046
00:32:22,756 --> 0:32:24,536
这显然是正在困扰他们的问题之一

1047
00:32:25,106 --> 0:32:27,636
在这期间我们和那些正在制作

1048
00:32:27,636 --> 0:32:29,146
Share Sheet 的人聊了聊

1049
00:32:29,146 --> 0:32:30,966
这是 iOS 13 中

1050
00:32:30,966 --> 0:32:33,786
重新设计的新 Share Sheet

1051
00:32:34,776 --> 0:32:36,076
具有出色的隔空投送扩展功能

1052
00:32:36,076 --> 0:32:38,026
当他们拥有这个全新的设计时 他们才发现

1053
00:32:38,026 --> 0:32:39,216
他们说 哦 这看起来很棒

1054
00:32:39,216 --> 0:32:40,976
我们需要这个 他们确实做到了

1055
00:32:41,016 --> 0:32:42,996
因此我想让一位

1056
00:32:42,996 --> 0:32:44,526
来自 Share Sheet 的同事

1057
00:32:44,526 --> 0:32:46,876
Jacob Klapper 来指导

1058
00:32:46,876 --> 0:32:48,546
我们完成这项工作 Jacob

1059
00:32:49,516 --> 0:32:54,426
[掌声]

1060
00:32:54,926 --> 0:32:57,596
&gt;&gt; 大家好 我很高兴向你们

1061
00:32:57,596 --> 0:32:58,586
展示 Share Sheet 

1062
00:32:58,586 --> 0:32:59,966
如何利用 iOS 13 中

1063
00:32:59,966 --> 0:33:02,976
新的 CollectionView API

1064
00:32:59,966 --> 0:33:02,976
新的 CollectionView API

1065
00:33:05,046 --> 0:33:06,066
我们在全新的

1066
00:33:06,066 --> 0:33:07,126
Share Sheet 中

1067
00:33:07,816 --> 0:33:08,786
Share Sheet 实际上

1068
00:33:08,786 --> 0:33:10,306
利用了新的

1069
00:33:10,306 --> 0:33:12,086
组合布局 API

1070
00:33:12,086 --> 0:33:13,406
和 DiffableDataSource

1071
00:33:13,406 --> 0:33:14,646
但 DiffableDataSource

1072
00:33:14,646 --> 0:33:16,126
真正闪耀的地方在于

1073
00:33:16,126 --> 0:33:17,446
全新的隔空投送扩展

1074
00:33:18,696 --> 0:33:21,176
因此隔空投送扩展程序

1075
00:33:21,176 --> 0:33:22,846
有一个浏览设备的浏览器

1076
00:33:23,156 --> 0:33:24,576
实际上我们已经

1077
00:33:24,576 --> 0:33:26,606
使用 UUID 来唯一标识

1078
00:33:26,606 --> 0:33:27,656
发现的每个设备

1079
00:33:28,166 --> 0:33:30,206
因此当发现新设备时

1080
00:33:30,206 --> 0:33:31,876
我们可以创建

1081
00:33:31,876 --> 0:33:34,036
一个空的快照啊

1082
00:33:34,036 --> 0:33:35,506
附加我们的 Section 和 Item

1083
00:33:35,506 --> 0:33:36,536
并应用差异对比

1084
00:33:36,876 --> 0:33:39,056
DiffableDataSource 负责其余部分

1085
00:33:39,056 --> 0:33:40,056
无论移除或

1086
00:33:40,056 --> 0:33:41,826
删除多少 Item

1087
00:33:41,826 --> 0:33:43,736
动画都很漂亮

1088
00:33:44,276 --> 0:33:46,196
DiffableDataSource 对我们来说

1089
00:33:46,196 --> 0:33:47,316
已经改变了游戏规则

1090
00:33:47,626 --> 0:33:48,986
我们迫不及待地想看看

1091
00:33:48,986 --> 0:33:50,566
你在 App 中用它做什么

1092
00:33:50,646 --> 0:33:51,866
现在舞台还给 Troy

1093
00:33:51,866 --> 0:33:53,486
听听他最后的想法

1094
00:33:55,516 --> 0:33:57,556
[掌声]

1095
00:33:58,056 --> 0:33:59,426
&gt;&gt; 天呐

1096
00:33:59,426 --> 0:34:00,456
听到 DiffableDataSource 

1097
00:33:59,426 --> 0:34:00,456
听到 DiffableDataSource 

1098
00:34:00,456 --> 0:34:02,146
在我们自己的 App 中

1099
00:34:02,196 --> 0:34:03,566
发挥了如此大的作用

1100
00:34:03,566 --> 0:34:05,106
我非常兴奋

1101
00:34:05,106 --> 0:34:06,526
我们非常高兴

1102
00:34:06,526 --> 0:34:08,606
让我们内部采用的 API 

1103
00:34:08,606 --> 0:34:09,866
能够在我们的

1104
00:34:10,146 --> 0:34:12,976
平台上供开发者使用

1105
00:34:21,045 --> 0:34:22,505
我们今天已经看到

1106
00:34:22,505 --> 0:34:24,485
DiffableDataSource 极大地

1107
00:34:24,485 --> 0:34:26,416
简化了将模型数据

1108
00:34:26,416 --> 0:34:28,485
放到 CollectionViews 

1109
00:34:28,485 --> 0:34:31,676
和 UITableViews 中的工作

1110
00:34:31,976 --> 0:34:33,596
我们认为这真正改变了游戏规则

1111
00:34:33,596 --> 0:34:36,476
它使这个过程非常简单和鲁棒

1112
00:34:36,755 --> 0:34:38,516
不会再有令人困惑的异常

1113
00:34:38,696 --> 0:34:40,126
在调试和难以编写的

1114
00:34:40,186 --> 0:34:42,216
批处理代码中出现

1115
00:34:42,216 --> 0:34:44,025
你可以专注于

1116
00:34:44,025 --> 0:34:46,496
你想让你的 App 做什么上

1117
00:34:46,496 --> 0:34:49,315
把其他的留给框架 今天你可以在 iOS

1118
00:34:49,426 --> 0:34:53,186
tvOS 和 macOS 上

1119
00:34:53,186 --> 0:34:54,606
使用 DiffableDataSource 

1120
00:34:55,176 --> 0:34:57,016
除了为你计算差异对比

1121
00:34:57,016 --> 0:34:58,676
并自动将它

1122
00:34:58,906 --> 0:35:00,236
提交给 UI

1123
00:34:58,906 --> 0:35:00,236
提交给 UI

1124
00:35:00,236 --> 0:35:01,936
你能得到这些

1125
00:35:01,936 --> 0:35:03,946
漂亮的动画对吧

1126
00:35:03,946 --> 0:35:05,516
你不需要做额外的工作

1127
00:35:05,516 --> 0:35:07,476
就能得到那种

1128
00:35:07,786 --> 0:35:09,316
令人愉快的用户交互效果

1129
00:35:10,126 --> 0:35:12,566
内置的差异对比很快

1130
00:35:12,566 --> 0:35:14,556
它经受了严峻的压力测试

1131
00:35:14,906 --> 0:35:17,296
DiffableDataSource 是一个鲁棒的 API 

1132
00:35:17,296 --> 0:35:19,086
你可以使用它

1133
00:35:19,086 --> 0:35:20,186
并运行它

1134
00:35:20,656 --> 0:35:22,686
快行动起来吧

1135
00:35:22,946 --> 0:35:24,526
在你的 App 中使用

1136
00:35:24,526 --> 0:35:25,656
DiffableDataSource

1137
00:35:25,986 --> 0:35:27,266
我们迫不及待地想要看到

1138
00:35:27,266 --> 0:35:28,356
这将减轻你的负担

1139
00:35:28,356 --> 0:35:31,176
你将能够用更少的时间

1140
00:35:31,176 --> 0:35:32,206
更少的烦恼

1141
00:35:32,206 --> 0:35:34,176
来创造令人愉快的用户体验

1142
00:35:36,636 --> 0:35:37,896
如果你觉得这个讲座有趣

1143
00:35:37,896 --> 0:35:39,256
而且你正在使用

1144
00:35:39,256 --> 0:35:40,426
CollectionViews

1145
00:35:40,426 --> 0:35:43,166
我们还有另一个 你会非常喜欢的会议名为

1146
00:35:43,166 --> 0:35:44,616
Advances in Collection View Layout

1147
00:35:44,976 --> 0:35:47,176
我们描述了一个全新的

1148
00:35:47,176 --> 0:35:48,706
布局系统

1149
00:35:48,706 --> 0:35:50,276
它可以简单地描述

1150
00:35:50,276 --> 0:35:51,736
你想要在 CollectionView 中

1151
00:35:51,736 --> 0:35:52,666
拥有的任何自定义布局

1152
00:35:52,986 --> 0:35:53,906
并且能够看到

1153
00:35:53,906 --> 0:35:55,356
它的实现

1154
00:35:55,356 --> 0:35:57,666
而不需要任何高性能的结果

1155
00:35:57,666 --> 0:35:58,916
所以我们觉得你会喜欢的

1156
00:35:58,916 --> 0:36:00,346
一定要参加那个会议

1157
00:35:58,916 --> 0:36:00,346
一定要参加那个会议

1158
00:36:01,316 --> 0:36:02,976
谢谢大家今天的收看

1159
00:36:03,516 --> 0:36:08,500
[掌声]
