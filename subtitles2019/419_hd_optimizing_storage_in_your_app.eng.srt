1
00:00:01,176 --> 0:00:04,500
[ Music ]

2
00:00:11,516 --> 0:00:15,616
[ Applause ]

3
00:00:16,116 --> 0:00:18,866
&gt;&gt; Hi, I'm Kai Kaahaaina and

4
00:00:18,866 --> 0:00:19,976
today along with Alejandro

5
00:00:19,976 --> 0:00:21,316
Lucena we'll be discussing how

6
00:00:21,316 --> 0:00:23,316
to optimize storage for your

7
00:00:23,426 --> 0:00:23,956
app.

8
00:00:24,866 --> 0:00:27,126
Just like CPU memory, storage is

9
00:00:27,126 --> 0:00:28,216
a finite resource.

10
00:00:29,386 --> 0:00:30,756
When an app makes optimal use of

11
00:00:30,756 --> 0:00:32,436
storage, we can help better

12
00:00:32,436 --> 0:00:35,316
ensure long battery life,

13
00:00:36,686 --> 0:00:37,526
better performance,

14
00:00:39,486 --> 0:00:40,486
reduced app footprint,

15
00:00:41,676 --> 0:00:43,246
and good device health.

16
00:00:45,136 --> 0:00:46,786
Our main optimization topics

17
00:00:46,786 --> 0:00:48,386
today will be efficient image

18
00:00:48,386 --> 0:00:50,756
assets, syncing to disk,

19
00:00:51,686 --> 0:00:54,316
serialized data files, Core

20
00:00:54,316 --> 0:00:55,696
Data, and SQLite.

21
00:00:56,356 --> 0:01:00,196
First up, efficient image

22
00:00:56,356 --> 0:01:00,196
First up, efficient image

23
00:01:00,196 --> 0:01:00,666
assets.

24
00:01:01,066 --> 0:01:02,156
As screen sizes have gotten

25
00:01:02,156 --> 0:01:02,946
larger there's been a

26
00:01:02,946 --> 0:01:04,336
corresponding increase in the

27
00:01:04,336 --> 0:01:06,556
size of image assets.

28
00:01:08,866 --> 0:01:10,246
For our session we've created a

29
00:01:10,246 --> 0:01:11,966
very simple demo app for

30
00:01:11,966 --> 0:01:13,646
cataloging and favoriting

31
00:01:14,186 --> 0:01:14,366
photos.

32
00:01:15,096 --> 0:01:16,606
However, even when preloaded

33
00:01:16,606 --> 0:01:18,116
with just a few photos, our app

34
00:01:18,116 --> 0:01:19,736
has already grown to 24.6

35
00:01:19,736 --> 0:01:20,726
megabytes in size.

36
00:01:21,806 --> 0:01:23,176
We'll now talk about two ways we

37
00:01:23,176 --> 0:01:25,846
can reduce the size of our app.

38
00:01:27,016 --> 0:01:28,566
The first is HEIC.

39
00:01:29,006 --> 0:01:30,826
HEIC, also referred to as HEIF

40
00:01:30,826 --> 0:01:32,746
sometimes, is a more efficient

41
00:01:32,746 --> 0:01:36,356
and capable alternative to JPEG.

42
00:01:36,556 --> 0:01:38,226
HEIC offers 50 percent smaller

43
00:01:38,306 --> 0:01:40,156
files at comparable quality to

44
00:01:40,156 --> 0:01:42,926
JPEG which of course means a

45
00:01:42,926 --> 0:01:45,316
smaller on disk footprint, and

46
00:01:45,456 --> 0:01:46,636
smaller files could be more

47
00:01:46,636 --> 0:01:48,466
easily moved up and down the

48
00:01:48,896 --> 0:01:49,086
network.

49
00:01:49,796 --> 0:01:51,096
They can also be more quickly

50
00:01:51,096 --> 0:01:55,526
loaded and saved to disk.

51
00:01:55,706 --> 0:01:57,066
HEIC also offers many features

52
00:01:57,066 --> 0:01:58,516
not available in JPEG such as

53
00:01:58,516 --> 0:01:59,626
the ability to store auxiliary

54
00:01:59,626 --> 0:02:01,316
images that contain depth and

55
00:01:59,626 --> 0:02:01,316
images that contain depth and

56
00:02:01,316 --> 0:02:02,236
disparity information.

57
00:02:03,776 --> 0:02:06,056
HEIC also supports alpha and

58
00:02:06,056 --> 0:02:07,026
lossless compression.

59
00:02:07,636 --> 0:02:10,346
HEIC even allows you to store

60
00:02:10,346 --> 0:02:12,496
multiple images in a single

61
00:02:12,496 --> 0:02:12,906
container.

62
00:02:15,336 --> 0:02:17,376
iOS has supported HEIC since iOS

63
00:02:17,376 --> 0:02:19,266
11 and macOS has supported HEIC

64
00:02:19,266 --> 0:02:20,456
since macOS High Sierra.

65
00:02:21,476 --> 0:02:22,396
It's also available in other

66
00:02:22,396 --> 0:02:22,946
operating systems.

67
00:02:26,366 --> 0:02:28,066
So going back to our demo app we

68
00:02:28,066 --> 0:02:29,606
start off using JPEG assets and

69
00:02:29,606 --> 0:02:31,786
had an on disk footprint of 24.6

70
00:02:31,786 --> 0:02:32,346
megabytes.

71
00:02:32,956 --> 0:02:35,596
By simply adopting HEIC instead

72
00:02:35,596 --> 0:02:36,896
of JPEG, we were able to reduce

73
00:02:36,896 --> 0:02:38,736
the size of this app to 17.9

74
00:02:38,736 --> 0:02:39,296
megabytes.

75
00:02:39,986 --> 0:02:41,576
That's a 27 percent reduction

76
00:02:41,626 --> 0:02:43,506
simply by adopting HEIC.

77
00:02:46,256 --> 0:02:47,566
The other way we can reduce the

78
00:02:47,566 --> 0:02:48,966
footprint of our app is by using

79
00:02:48,966 --> 0:02:49,896
Asset Catalogs.

80
00:02:50,506 --> 0:02:52,086
Asset Catalogs are a great way

81
00:02:52,306 --> 0:02:54,116
of organizing the assets for

82
00:02:54,116 --> 0:02:55,246
your app.

83
00:02:55,246 --> 0:02:57,246
Assets such as the app icon and

84
00:02:58,196 --> 0:02:59,886
device and scale variants to

85
00:02:59,886 --> 0:03:00,456
your images.

86
00:02:59,886 --> 0:03:00,456
your images.

87
00:03:01,046 --> 0:03:02,446
Asset Catalogs provide a very

88
00:03:02,446 --> 0:03:03,786
easy way of storing multiple

89
00:03:03,786 --> 0:03:05,236
resolutions of the same image

90
00:03:05,966 --> 0:03:07,086
which makes it very easy to

91
00:03:07,086 --> 0:03:08,386
support a wide variety of

92
00:03:08,386 --> 0:03:08,936
devices.

93
00:03:11,046 --> 0:03:12,446
We also can use Asset Catalogs

94
00:03:12,446 --> 0:03:14,946
to tag on demand resources so

95
00:03:14,946 --> 0:03:15,996
the user doesn't need to see

96
00:03:15,996 --> 0:03:17,586
them downloaded until they're

97
00:03:17,586 --> 0:03:18,896
ready to use them.

98
00:03:21,316 --> 0:03:22,646
We get both storage and

99
00:03:22,646 --> 0:03:23,776
performance benefits through the

100
00:03:23,776 --> 0:03:25,006
use of Asset Catalogs.

101
00:03:25,536 --> 0:03:28,316
We first get to reduce our on

102
00:03:28,316 --> 0:03:29,566
disk footprint because Asset

103
00:03:29,566 --> 0:03:31,036
Catalogs store all of our image

104
00:03:31,036 --> 0:03:32,466
assets in a single optimized

105
00:03:32,466 --> 0:03:33,946
format instead of individual

106
00:03:33,946 --> 0:03:34,456
files.

107
00:03:34,996 --> 0:03:38,106
And the App Store also uses

108
00:03:38,106 --> 0:03:39,726
metadata from your Asset Catalog

109
00:03:39,726 --> 0:03:41,026
to help support app slicing for

110
00:03:41,026 --> 0:03:41,836
your iOS apps.

111
00:03:43,326 --> 0:03:44,236
This way when a customer

112
00:03:44,236 --> 0:03:45,046
downloads your app from the

113
00:03:45,046 --> 0:03:46,866
store, they get only the assets

114
00:03:46,866 --> 0:03:47,966
they need for their particular

115
00:03:47,966 --> 0:03:48,386
device.

116
00:03:48,766 --> 0:03:50,056
This makes the download smaller

117
00:03:50,056 --> 0:03:51,516
and the user has to wait less

118
00:03:51,516 --> 0:03:53,056
time for the app to download and

119
00:03:53,056 --> 0:03:54,106
they can start enjoying your app

120
00:03:54,376 --> 0:03:54,816
much sooner.

121
00:03:57,306 --> 0:03:58,536
We also get performance wins.

122
00:03:59,426 --> 0:04:00,966
Again, owing to the optimized

123
00:03:59,426 --> 0:04:00,966
Again, owing to the optimized

124
00:04:00,966 --> 0:04:02,576
format that Asset Catalogs saves

125
00:04:02,576 --> 0:04:04,746
our image assets in, images can

126
00:04:04,746 --> 0:04:05,586
be loaded more quickly.

127
00:04:05,946 --> 0:04:07,306
This is especially beneficial

128
00:04:07,806 --> 0:04:08,636
for app launch time.

129
00:04:09,526 --> 0:04:10,896
Particularly on Macs with hard

130
00:04:10,896 --> 0:04:11,856
drives where we've seen up to a

131
00:04:11,956 --> 0:04:13,886
10 percent improvement on app

132
00:04:13,946 --> 0:04:14,686
launch performance.

133
00:04:17,486 --> 0:04:18,926
Asset Catalogs also make it

134
00:04:18,926 --> 0:04:20,805
really easy to adopt GPU-based

135
00:04:20,805 --> 0:04:21,276
compression.

136
00:04:22,196 --> 0:04:23,406
This compression is lossless by

137
00:04:23,406 --> 0:04:26,516
default, but lossy image options

138
00:04:26,676 --> 0:04:27,376
are available.

139
00:04:29,826 --> 0:04:31,266
All enjoy hardware accelerated

140
00:04:31,266 --> 0:04:33,896
decompression, and one option

141
00:04:34,256 --> 0:04:35,716
even provides a way of lowering

142
00:04:36,176 --> 0:04:37,496
the in-memory footprint of your

143
00:04:37,496 --> 0:04:37,976
image assets.

144
00:04:42,046 --> 0:04:43,116
So going back to our demo app,

145
00:04:43,116 --> 0:04:44,126
earlier we saw we were able to

146
00:04:44,126 --> 0:04:45,256
reduce the size of the app to

147
00:04:45,256 --> 0:04:47,526
17.9 megabytes by adopting HEIC.

148
00:04:48,906 --> 0:04:50,396
Now, by having also adopted

149
00:04:50,396 --> 0:04:52,376
Asset Catalogs, primarily though

150
00:04:52,826 --> 0:04:53,896
the app slicing feature, we're

151
00:04:53,896 --> 0:04:54,936
able to further reduce the

152
00:04:55,146 --> 0:04:56,786
footprint of this app to 14.9

153
00:04:56,786 --> 0:04:57,236
megabytes.

154
00:04:58,556 --> 0:04:59,956
That's a 40 percent reduction in

155
00:04:59,956 --> 0:05:00,976
footprint since we started

156
00:04:59,956 --> 0:05:00,976
footprint since we started

157
00:05:01,246 --> 0:05:02,796
simply by adopting HEIC and

158
00:05:02,796 --> 0:05:03,666
Asset Catalogs.

159
00:05:05,896 --> 0:05:07,126
So if you aren't already using

160
00:05:07,126 --> 0:05:08,356
HEIC for your image assets and

161
00:05:08,356 --> 0:05:09,776
Asset Catalogs to help organize

162
00:05:09,776 --> 0:05:11,276
your assets, we highly recommend

163
00:05:11,276 --> 0:05:11,986
looking into using them.

164
00:05:11,986 --> 0:05:13,146
They're a great and easy way of

165
00:05:13,146 --> 0:05:14,496
getting a more efficient and

166
00:05:14,496 --> 0:05:15,456
smaller app footprint.

167
00:05:19,206 --> 0:05:20,816
Next up I'd like to talk a

168
00:05:20,816 --> 0:05:22,006
little about file system

169
00:05:25,116 --> 0:05:25,496
metadata.

170
00:05:25,496 --> 0:05:26,946
Our demo app maintains a small

171
00:05:26,946 --> 0:05:28,366
plist that just keeps track of

172
00:05:28,366 --> 0:05:29,076
the last time the app was

173
00:05:29,076 --> 0:05:29,606
launched.

174
00:05:30,276 --> 0:05:31,546
Each time the app is launched,

175
00:05:31,636 --> 0:05:33,506
we read in this plist, update

176
00:05:33,506 --> 0:05:34,496
the last app launch time

177
00:05:34,496 --> 0:05:36,036
property, and write the updated

178
00:05:36,436 --> 0:05:39,346
plist back out to disk.

179
00:05:39,346 --> 0:05:40,576
If we observe what this behavior

180
00:05:40,576 --> 0:05:41,726
looks like using the File

181
00:05:41,726 --> 0:05:42,996
Activity instrument Alejandro

182
00:05:42,996 --> 0:05:43,766
will be discussing a little bit

183
00:05:43,766 --> 0:05:45,606
later in the talk, we can see

184
00:05:45,606 --> 0:05:46,756
that this behavior causes one

185
00:05:46,756 --> 0:05:48,316
read which makes a lot of sense,

186
00:05:48,316 --> 0:05:50,806
we read the plist in, but it

187
00:05:50,806 --> 0:05:52,286
causes three write operations

188
00:05:52,436 --> 0:05:53,556
which might be a bit surprising

189
00:05:53,556 --> 0:05:54,836
since we're only writing out one

190
00:05:54,866 --> 0:05:55,246
file.

191
00:05:55,816 --> 0:05:58,316
We also see an fsync operation

192
00:05:58,316 --> 0:05:59,876
and these can be expensive and

193
00:05:59,876 --> 0:06:00,906
we'll talk a little bit more

194
00:05:59,876 --> 0:06:00,906
we'll talk a little bit more

195
00:06:00,906 --> 0:06:01,966
about why that can be expensive

196
00:06:02,156 --> 0:06:04,436
a bit later.

197
00:06:04,666 --> 0:06:06,216
So why three writes instead of

198
00:06:06,216 --> 0:06:06,516
one?

199
00:06:07,196 --> 0:06:08,596
Well the answer is file system

200
00:06:08,596 --> 0:06:09,046
metadata.

201
00:06:10,036 --> 0:06:12,606
File system metadata is data

202
00:06:12,606 --> 0:06:13,686
that the file system needs to

203
00:06:13,686 --> 0:06:14,956
update every time we create a

204
00:06:14,986 --> 0:06:15,996
file or delete a file.

205
00:06:16,126 --> 0:06:17,386
So in this case, our writing a

206
00:06:17,386 --> 0:06:19,206
plist, creating a file, causes

207
00:06:19,946 --> 0:06:21,546
extra overhead.

208
00:06:23,316 --> 0:06:25,116
So what is file system metadata?

209
00:06:25,646 --> 0:06:26,706
File system metadata is the

210
00:06:26,706 --> 0:06:27,776
information the file system

211
00:06:27,776 --> 0:06:29,436
needs to track about our files.

212
00:06:29,656 --> 0:06:31,016
Things such as the file name,

213
00:06:31,836 --> 0:06:36,356
size, location, and dates like

214
00:06:36,586 --> 0:06:38,086
date created or last modified.

215
00:06:38,896 --> 0:06:39,716
And a lot more.

216
00:06:40,326 --> 0:06:42,936
To get a better understanding of

217
00:06:42,936 --> 0:06:44,126
what the file system has to do

218
00:06:44,126 --> 0:06:45,186
every time we create a file,

219
00:06:45,486 --> 0:06:47,406
let's walk through what APFS has

220
00:06:47,436 --> 0:06:48,686
to do when we go to write our

221
00:06:48,686 --> 0:06:51,016
NSDictionary file to disk.

222
00:06:51,746 --> 0:06:52,726
Well the first thing that APFS

223
00:06:52,726 --> 0:06:54,906
is going to do is update the

224
00:06:54,906 --> 0:06:56,506
file system tree and it's going

225
00:06:56,506 --> 0:06:57,556
to do this by updating one of

226
00:06:57,556 --> 0:06:58,106
its nodes.

227
00:06:59,246 --> 0:07:00,966
However, owing to the copy on

228
00:06:59,246 --> 0:07:00,966
However, owing to the copy on

229
00:07:00,966 --> 0:07:03,186
write nature of APFS we don't

230
00:07:03,186 --> 0:07:05,216
actually update an existing

231
00:07:05,216 --> 0:07:06,456
node, we create a copy of an

232
00:07:06,456 --> 0:07:07,036
existing node.

233
00:07:07,476 --> 0:07:08,496
Let's look at this in detail.

234
00:07:09,616 --> 0:07:10,756
So here's our existing file

235
00:07:10,756 --> 0:07:13,336
system tree.

236
00:07:13,556 --> 0:07:15,366
And we see a copy made of an

237
00:07:15,366 --> 0:07:16,766
existing node.

238
00:07:18,016 --> 0:07:19,516
How this new node differs from

239
00:07:19,516 --> 0:07:20,546
the original isn't in the node

240
00:07:20,546 --> 0:07:21,786
name, it's actually the same as

241
00:07:21,786 --> 0:07:23,396
the original node, but the new

242
00:07:23,396 --> 0:07:24,686
node has an incremented or at

243
00:07:24,686 --> 0:07:26,166
least different transaction ID.

244
00:07:26,166 --> 0:07:27,506
And it's this different

245
00:07:27,506 --> 0:07:28,856
transaction ID that allows APFS

246
00:07:28,856 --> 0:07:30,786
to support advanced features

247
00:07:30,786 --> 0:07:33,406
such as snapshots.

248
00:07:33,476 --> 0:07:34,986
So going back up a level, now

249
00:07:34,986 --> 0:07:37,086
that we have our updated file

250
00:07:37,086 --> 0:07:38,926
system tree, APFS needs to

251
00:07:38,956 --> 0:07:40,686
update the object map so it's

252
00:07:40,686 --> 0:07:41,486
aware of the new node.

253
00:07:42,016 --> 0:07:44,036
So in total, to support writing

254
00:07:44,036 --> 0:07:45,966
this new file, APFS had to do

255
00:07:45,966 --> 0:07:47,226
two separate operations that

256
00:07:48,466 --> 0:07:52,166
totaled 8K of write I/O, 4K to

257
00:07:52,166 --> 0:07:53,356
update the file system tree,

258
00:07:54,536 --> 0:07:55,876
another 4K to update the object

259
00:07:55,876 --> 0:07:56,066
map.

260
00:07:56,566 --> 0:07:58,556
And we still need to write the

261
00:07:58,556 --> 0:08:00,746
file itself which, in this case

262
00:07:58,556 --> 0:08:00,746
file itself which, in this case

263
00:08:00,746 --> 0:08:02,096
even though it's only 240 bytes

264
00:08:02,096 --> 0:08:04,196
of NSDictionary data, the

265
00:08:04,196 --> 0:08:05,426
smallest file we can write to

266
00:08:05,426 --> 0:08:07,966
disk on an iOS device is 4K so

267
00:08:07,966 --> 0:08:09,346
it gets rounded up.

268
00:08:10,196 --> 0:08:12,496
So in total we had to write 12K

269
00:08:12,496 --> 0:08:14,516
of data to disk to store a 240

270
00:08:14,516 --> 0:08:15,816
byte NSDictionary.

271
00:08:17,186 --> 0:08:18,036
That's about 2 percent

272
00:08:18,036 --> 0:08:18,546
efficiency.

273
00:08:19,226 --> 0:08:20,496
So not only does the example

274
00:08:20,496 --> 0:08:21,886
show us the work that APFS needs

275
00:08:21,886 --> 0:08:23,576
to do to track file creation, it

276
00:08:23,576 --> 0:08:25,166
also highlights how expensive it

277
00:08:25,166 --> 0:08:26,846
can be to store small amounts of

278
00:08:26,846 --> 0:08:28,696
data in individual files on the

279
00:08:28,696 --> 0:08:29,746
file system.

280
00:08:33,275 --> 0:08:34,416
So in the example we just walked

281
00:08:34,416 --> 0:08:35,326
through we saw that we had to do

282
00:08:35,326 --> 0:08:37,706
8K of I/O to support creating a

283
00:08:37,706 --> 0:08:39,456
file on APFS.

284
00:08:40,155 --> 0:08:41,496
Well what about deleting a file?

285
00:08:41,616 --> 0:08:42,256
That's 8K.

286
00:08:42,736 --> 0:08:44,135
Other common operations such as

287
00:08:44,135 --> 0:08:46,156
renaming a file is 16K.

288
00:08:46,876 --> 0:08:49,296
Modifying an existing file is

289
00:08:50,016 --> 0:08:50,136
8K.

290
00:08:51,996 --> 0:08:53,286
The big take away from this is

291
00:08:53,286 --> 0:08:54,936
that file system updates aren't

292
00:08:54,936 --> 0:08:55,116
free.

293
00:08:55,376 --> 0:08:56,786
In fact, they can involve more

294
00:08:56,786 --> 0:08:58,266
I/O usage than the data being

295
00:08:58,266 --> 0:08:58,616
stored.

296
00:08:58,616 --> 0:09:00,656
So as a result, we need to be

297
00:08:58,616 --> 0:09:00,656
So as a result, we need to be

298
00:09:00,656 --> 0:09:01,626
selective about how we create

299
00:09:01,626 --> 0:09:03,076
and modify and delete files.

300
00:09:04,056 --> 0:09:05,026
We want to try to avoid

301
00:09:05,026 --> 0:09:06,266
expensive behaviors such as

302
00:09:06,356 --> 0:09:07,816
rapidly creating and deleting

303
00:09:07,816 --> 0:09:07,976
files.

304
00:09:11,886 --> 0:09:12,946
If we have a use case where we

305
00:09:12,946 --> 0:09:14,196
do need to keep temporary data

306
00:09:14,196 --> 0:09:15,596
on the file system, here's a

307
00:09:15,596 --> 0:09:16,586
great way of trying to reduce

308
00:09:16,616 --> 0:09:18,096
the cost to the system for that

309
00:09:18,096 --> 0:09:18,756
temporary data.

310
00:09:19,246 --> 0:09:22,036
First, create your file but keep

311
00:09:22,246 --> 0:09:25,546
it open and unlinked, and do not

312
00:09:25,546 --> 0:09:26,316
call fsync on it.

313
00:09:26,956 --> 0:09:27,896
Doing this will give the file

314
00:09:27,896 --> 0:09:29,086
system the hints it needs to

315
00:09:29,086 --> 0:09:30,446
keep the temporary file in the

316
00:09:30,446 --> 0:09:32,206
OS cache as long as possible and

317
00:09:32,206 --> 0:09:33,566
not write out to disk as

318
00:09:33,566 --> 0:09:37,056
frequently as it might have to.

319
00:09:37,256 --> 0:09:37,986
If you'd like to learn more

320
00:09:37,986 --> 0:09:39,306
about file system metadata in

321
00:09:39,306 --> 0:09:41,086
APFS we have a great reference

322
00:09:41,086 --> 0:09:42,026
document on our developer

323
00:09:42,026 --> 0:09:43,356
website and I highly recommend

324
00:09:43,356 --> 0:09:48,386
checking it out.

325
00:09:48,486 --> 0:09:50,246
Next up, syncing to disk.

326
00:09:52,436 --> 0:09:53,856
When it comes to managing where

327
00:09:53,856 --> 0:09:55,406
our data lives, we want to keep

328
00:09:55,406 --> 0:09:57,156
our data in the cache closest to

329
00:09:57,226 --> 0:09:58,786
the CPU for best performance,

330
00:09:59,636 --> 0:10:02,306
but we also want to ensure that

331
00:09:59,636 --> 0:10:02,306
but we also want to ensure that

332
00:10:02,306 --> 0:10:04,176
our data gets to disk when we

333
00:10:04,176 --> 0:10:04,606
need it to.

334
00:10:05,736 --> 0:10:06,596
First let's talk about the

335
00:10:06,596 --> 0:10:07,766
various caches that we have.

336
00:10:09,416 --> 0:10:10,616
First there's the OS cache.

337
00:10:10,756 --> 0:10:11,936
This is where we want to keep

338
00:10:12,136 --> 0:10:13,386
our data for best performance.

339
00:10:14,836 --> 0:10:16,106
Reads and writes to the OS cache

340
00:10:16,106 --> 0:10:17,416
are referred to as logical I/O.

341
00:10:18,216 --> 0:10:19,356
As this cache is backed by

342
00:10:19,356 --> 0:10:21,326
memory, logical I/O operations

343
00:10:21,326 --> 0:10:22,486
complete very quickly.

344
00:10:23,326 --> 0:10:24,696
Keeping data in the OS cache is

345
00:10:24,696 --> 0:10:25,746
often advantageous for

346
00:10:25,876 --> 0:10:27,406
frequently used and modified

347
00:10:27,406 --> 0:10:27,686
data.

348
00:10:28,206 --> 0:10:31,826
Next, we have the disk cache and

349
00:10:31,826 --> 0:10:32,616
the disk cache is actually

350
00:10:32,616 --> 0:10:33,926
physically located on the

351
00:10:33,926 --> 0:10:34,686
storage device.

352
00:10:36,506 --> 0:10:37,916
And lastly, we have permanent

353
00:10:37,916 --> 0:10:38,386
storage.

354
00:10:38,386 --> 0:10:39,496
This is the actual physical

355
00:10:39,496 --> 0:10:40,666
medium which will be persisting

356
00:10:40,666 --> 0:10:41,876
the data long term.

357
00:10:42,366 --> 0:10:43,776
In the case of iOS devices and

358
00:10:43,776 --> 0:10:48,006
most Macs, this is NAND.

359
00:10:48,166 --> 0:10:49,346
Physical I/Os are reads and

360
00:10:49,346 --> 0:10:50,826
writes to and from the physical

361
00:10:50,826 --> 0:10:51,286
storage.

362
00:10:51,536 --> 0:10:54,876
These I/Os may be to the or from

363
00:10:54,876 --> 0:10:56,356
the disk cache or the permanent

364
00:10:56,356 --> 0:10:56,736
storage.

365
00:10:56,736 --> 0:10:59,196
So now that we have talked a

366
00:10:59,196 --> 0:11:01,086
little about the caches and

367
00:10:59,196 --> 0:11:01,086
little about the caches and

368
00:11:01,086 --> 0:11:02,516
permanent storage, let's talk

369
00:11:02,516 --> 0:11:03,856
about the most common APIs we

370
00:11:03,856 --> 0:11:05,196
use to move data from the OS

371
00:11:05,196 --> 0:11:06,826
cache to the storage device.

372
00:11:07,046 --> 0:11:08,856
First up is fsync.

373
00:11:08,856 --> 0:11:12,076
fsync causes data to be moved

374
00:11:12,076 --> 0:11:14,426
from the OS cache to the disk

375
00:11:14,426 --> 0:11:14,716
cache.

376
00:11:15,296 --> 0:11:17,626
It doesn't however guarantee

377
00:11:17,626 --> 0:11:19,236
that the data will be written to

378
00:11:19,236 --> 0:11:20,366
permanent storage immediately.

379
00:11:20,986 --> 0:11:21,916
Without further input from

380
00:11:21,916 --> 0:11:23,636
software, it's up to the

381
00:11:23,636 --> 0:11:24,896
device's firmware to determine

382
00:11:24,896 --> 0:11:25,856
when data gets moved from the

383
00:11:25,856 --> 0:11:27,146
disk cache to permanent storage.

384
00:11:28,636 --> 0:11:29,886
It also doesn't guarantee write

385
00:11:29,886 --> 0:11:30,266
ordering.

386
00:11:31,036 --> 0:11:32,276
That's to say, the order in

387
00:11:32,276 --> 0:11:33,726
which data's written from the OS

388
00:11:33,726 --> 0:11:35,086
cache to the disk cache may not

389
00:11:35,086 --> 0:11:36,346
necessarily be the same order in

390
00:11:36,346 --> 0:11:37,566
which data is written from the

391
00:11:37,566 --> 0:11:39,226
disk cache to permanent storage.

392
00:11:39,636 --> 0:11:42,546
fsync can also be expensive if

393
00:11:42,546 --> 0:11:43,426
it's overused.

394
00:11:43,426 --> 0:11:45,236
When we had our data in the OS

395
00:11:45,236 --> 0:11:46,716
cache, the OS cache was able to

396
00:11:46,976 --> 0:11:49,646
easily absorb overwrites or

397
00:11:49,646 --> 0:11:50,946
modifications to the same data.

398
00:11:51,316 --> 0:11:52,766
Once we used fsync it got moved

399
00:11:52,766 --> 0:11:53,416
to the disk cache.

400
00:11:54,446 --> 0:11:55,816
And depending on the cadence in

401
00:11:55,816 --> 0:11:56,806
which we need to ensure our data

402
00:11:56,806 --> 0:11:57,826
gets moved to the disk cache,

403
00:11:58,426 --> 0:11:59,966
calling fsync manually may not

404
00:11:59,966 --> 0:12:01,196
even be necessary as it's done

405
00:11:59,966 --> 0:12:01,196
even be necessary as it's done

406
00:12:01,196 --> 0:12:03,646
periodically for us by the OS.

407
00:12:07,596 --> 0:12:09,806
The primary way data gets moved

408
00:12:09,806 --> 0:12:11,696
all the way from the OS cache to

409
00:12:11,696 --> 0:12:12,676
permanent storage is through the

410
00:12:12,676 --> 0:12:14,516
use of F controls, FFULLFSYNC.

411
00:12:15,606 --> 0:12:16,886
This causes the data in the

412
00:12:16,886 --> 0:12:18,276
drive's disk cache to get

413
00:12:18,276 --> 0:12:18,586
flushed.

414
00:12:18,976 --> 0:12:21,366
However this causes all of the

415
00:12:21,366 --> 0:12:22,466
data in the disk cache to get

416
00:12:22,466 --> 0:12:24,406
flushed so not only is the data

417
00:12:24,406 --> 0:12:25,616
that we were interested in

418
00:12:25,616 --> 0:12:26,696
moving all the way to permanent

419
00:12:26,696 --> 0:12:28,866
storage get moved to permanent

420
00:12:28,866 --> 0:12:30,666
storage, all the data in the

421
00:12:30,706 --> 0:12:31,426
disk cache does.

422
00:12:32,206 --> 0:12:33,756
As a result, it's expensive

423
00:12:34,186 --> 0:12:34,956
because this could be a lot of

424
00:12:34,956 --> 0:12:36,116
data and it could take a lot of

425
00:12:36,116 --> 0:12:36,376
time.

426
00:12:37,916 --> 0:12:39,166
And again, it might actually not

427
00:12:39,166 --> 0:12:40,106
even be necessary to do this

428
00:12:40,106 --> 0:12:41,686
manually as this is done

429
00:12:41,686 --> 0:12:43,696
periodically for us by the OS.

430
00:12:46,356 --> 0:12:48,406
If the primary reason we were

431
00:12:48,406 --> 0:12:49,966
using FFULLFSYNC was to ensure

432
00:12:49,966 --> 0:12:51,646
I/O ordering, a great and much

433
00:12:51,646 --> 0:12:52,706
more efficient alternative is

434
00:12:52,706 --> 0:12:53,966
using F BARRIERFSYNC.

435
00:12:54,716 --> 0:12:56,966
F BARRIERFSYNC enforces I/O

436
00:12:56,966 --> 0:12:57,316
ordering.

437
00:12:57,856 --> 0:13:00,346
F BARRIERFSYNC is probably best

438
00:12:57,856 --> 0:13:00,346
F BARRIERFSYNC is probably best

439
00:13:00,346 --> 0:13:01,546
thought of as being basically an

440
00:13:01,546 --> 0:13:03,186
fsync with a barrier and the

441
00:13:03,396 --> 0:13:04,986
barrier is a hint to the Apple

442
00:13:04,986 --> 0:13:06,786
SSD to execute all the iOS that

443
00:13:06,786 --> 0:13:08,526
were received before the barrier

444
00:13:08,856 --> 0:13:10,846
before executing any of the iOS

445
00:13:10,846 --> 0:13:12,266
which were received after the

446
00:13:12,266 --> 0:13:12,696
barrier.

447
00:13:13,236 --> 0:13:15,496
As a result, it's a lot less

448
00:13:15,496 --> 0:13:17,696
expensive than F FULLFSYNC as we

449
00:13:17,696 --> 0:13:18,976
get the same result we wanted

450
00:13:19,046 --> 0:13:20,536
without having to push all the

451
00:13:20,536 --> 0:13:22,176
data in the disk cache to

452
00:13:22,176 --> 0:13:22,926
permanent storage.

453
00:13:23,476 --> 0:13:25,836
So if you're concerned about I/O

454
00:13:25,836 --> 0:13:26,966
ordering, please use F

455
00:13:26,966 --> 0:13:28,296
BARRIERFSYNC and not F

456
00:13:28,296 --> 0:13:28,856
FULLFSYNC.

457
00:13:28,926 --> 0:13:30,466
It's a much faster and efficient

458
00:13:30,736 --> 0:13:31,696
way of getting your data to

459
00:13:31,696 --> 0:13:31,966
disk.

460
00:13:37,046 --> 0:13:38,286
Serialized data files.

461
00:13:39,076 --> 0:13:40,766
Files such as plist, XML and

462
00:13:40,766 --> 0:13:41,776
JSON, they're great.

463
00:13:42,066 --> 0:13:43,276
They're convenient to use.

464
00:13:43,666 --> 0:13:45,516
They're a great way of storing

465
00:13:45,516 --> 0:13:47,076
infrequently modified data and

466
00:13:48,006 --> 0:13:49,416
they're extremely easy to parse.

467
00:13:50,496 --> 0:13:51,586
However, all this ease of use

468
00:13:51,586 --> 0:13:52,686
comes with a few tradeoffs.

469
00:13:53,186 --> 0:13:57,036
Any time we make a single change

470
00:13:57,126 --> 0:13:58,756
to the file, the entire file has

471
00:13:58,756 --> 0:14:00,216
to be re-serialized and

472
00:13:58,756 --> 0:14:00,216
to be re-serialized and

473
00:14:00,216 --> 0:14:01,006
rewritten to disk.

474
00:14:02,096 --> 0:14:03,736
As a result, they scale poorly.

475
00:14:04,966 --> 0:14:05,806
And since they're so easy to

476
00:14:05,806 --> 0:14:07,646
use, they can be easy to misuse.

477
00:14:08,756 --> 0:14:09,476
And because we're having to

478
00:14:09,476 --> 0:14:10,546
replace the file with every

479
00:14:10,546 --> 0:14:11,606
single change, they're very

480
00:14:11,606 --> 0:14:13,056
system file metadata intensive.

481
00:14:13,596 --> 0:14:17,086
And they're very much not meant

482
00:14:17,086 --> 0:14:18,316
to be a database replacement.

483
00:14:18,856 --> 0:14:22,106
Looking at a screenshot from the

484
00:14:22,106 --> 0:14:23,746
file activity Instruments we can

485
00:14:23,746 --> 0:14:24,806
see that the act of creating,

486
00:14:24,806 --> 0:14:26,876
reading, and modifying the plist

487
00:14:27,496 --> 0:14:28,956
causes 12 separate I/O

488
00:14:28,956 --> 0:14:30,826
operations which is quite a bit

489
00:14:30,826 --> 0:14:32,136
for what is probably four lines

490
00:14:32,136 --> 0:14:32,976
of code.

491
00:14:34,296 --> 0:14:35,346
And if we look at this in a

492
00:14:35,346 --> 0:14:36,286
slightly different view, then we

493
00:14:36,286 --> 0:14:37,146
see every time we call

494
00:14:37,146 --> 0:14:38,316
NSDictionary to write to file

495
00:14:38,316 --> 0:14:41,566
atomically, the operation ends

496
00:14:41,676 --> 0:14:42,786
with an fsync operation.

497
00:14:43,256 --> 0:14:44,226
This means that all the data

498
00:14:44,226 --> 0:14:45,286
we're storing in this

499
00:14:45,286 --> 0:14:46,186
NSDictionary we're pushing to

500
00:14:46,186 --> 0:14:47,336
disk is never enjoying the

501
00:14:47,336 --> 0:14:48,806
benefit of the OS cache.

502
00:14:49,356 --> 0:14:53,126
As a result, really large data

503
00:14:53,126 --> 0:14:54,376
sets or data sets which are

504
00:14:54,516 --> 0:14:56,196
modified frequently aren't

505
00:14:56,196 --> 0:14:58,726
really efficient in a serialized

506
00:14:58,726 --> 0:14:59,376
plist format.

507
00:14:59,926 --> 0:15:02,906
If the amount of data you have

508
00:14:59,926 --> 0:15:02,906
If the amount of data you have

509
00:15:02,906 --> 0:15:04,066
is either too large or too

510
00:15:04,066 --> 0:15:05,516
frequently modified, Core Data

511
00:15:05,516 --> 0:15:06,786
is a really good alternative.

512
00:15:07,216 --> 0:15:10,716
Core Data management is built on

513
00:15:10,766 --> 0:15:12,346
SQLite and provides a great

514
00:15:12,346 --> 0:15:13,936
abstraction layer between an

515
00:15:14,026 --> 0:15:15,576
SQLite data source and the model

516
00:15:15,576 --> 0:15:18,256
layer for your app.

517
00:15:18,476 --> 0:15:20,056
Core Data automatically manages

518
00:15:20,056 --> 0:15:21,336
object graphs and relationships,

519
00:15:21,876 --> 0:15:24,736
support for change tracking and

520
00:15:24,736 --> 0:15:28,316
notifications, automatic version

521
00:15:28,316 --> 0:15:29,606
tracking and multi-writer

522
00:15:29,606 --> 0:15:30,506
conflict resolution.

523
00:15:30,926 --> 0:15:31,706
Core Data will even

524
00:15:31,706 --> 0:15:34,456
automatically pool connections

525
00:15:34,596 --> 0:15:35,636
for multiple concurrent

526
00:15:35,636 --> 0:15:36,246
operations.

527
00:15:36,756 --> 0:15:39,646
And new with iOS13, Core Data

528
00:15:40,126 --> 0:15:41,756
supports CloudKit integration

529
00:15:41,826 --> 0:15:42,976
which is a huge win for Core

530
00:15:42,976 --> 0:15:43,706
Data adopters.

531
00:15:44,236 --> 0:15:46,786
And Core Data also supports live

532
00:15:46,786 --> 0:15:47,846
queries which allows you to

533
00:15:47,846 --> 0:15:49,986
generate queries on the fly so

534
00:15:49,986 --> 0:15:51,156
you don't have to hand code in

535
00:15:51,156 --> 0:15:52,786
advance all the SQLite queries

536
00:15:52,786 --> 0:15:53,656
you think you might need.

537
00:15:54,196 --> 0:15:57,476
Core Data also offers automatic

538
00:15:57,476 --> 0:16:00,086
memory management, statement

539
00:15:57,476 --> 0:16:00,086
memory management, statement

540
00:16:00,086 --> 0:16:03,166
aggregation and transactions,

541
00:16:03,166 --> 0:16:06,466
schema migrations, and new in

542
00:16:06,466 --> 0:16:08,896
iOS 13, data denormalization,

543
00:16:10,246 --> 0:16:12,776
and so much more.

544
00:16:12,986 --> 0:16:13,916
We've also observed that

545
00:16:13,916 --> 0:16:15,286
adopters of Core Data have to

546
00:16:15,286 --> 0:16:17,276
write 50 to 70 percent less code

547
00:16:17,416 --> 0:16:18,576
to support their model layer.

548
00:16:19,306 --> 0:16:20,326
That's code that never needs to

549
00:16:20,326 --> 0:16:22,116
be written, modified, or

550
00:16:22,116 --> 0:16:22,506
debugged.

551
00:16:23,016 --> 0:16:24,166
If, however you have a use case

552
00:16:24,166 --> 0:16:25,606
which requires the direct use of

553
00:16:25,606 --> 0:16:27,026
SQLite, we do have some best

554
00:16:27,026 --> 0:16:28,266
practices we'd like to share.

555
00:16:28,806 --> 0:16:31,136
This is a bigger topic so we

556
00:16:31,136 --> 0:16:32,436
have some subtopics including

557
00:16:32,436 --> 0:16:34,126
connections, journaling,

558
00:16:34,366 --> 0:16:36,726
transactions, file size and

559
00:16:36,726 --> 0:16:39,026
privacy, and partial indexes or

560
00:16:40,516 --> 0:16:41,686
subconnections.

561
00:16:42,196 --> 0:16:44,566
The robustness guarantees of

562
00:16:44,566 --> 0:16:45,506
SQLite aren't free.

563
00:16:45,966 --> 0:16:47,186
Opening and closing a database

564
00:16:47,186 --> 0:16:48,746
can cause expensive operations

565
00:16:48,746 --> 0:16:50,176
such as consistency checking,

566
00:16:50,486 --> 0:16:51,886
journal recovery, and journal

567
00:16:51,886 --> 0:16:52,386
checkpointing.

568
00:16:52,936 --> 0:16:55,766
As a result, we actually

569
00:16:55,766 --> 0:16:56,886
recommend not using a more

570
00:16:56,886 --> 0:16:58,146
traditional model of opening and

571
00:16:58,146 --> 0:16:59,606
closing a database each time

572
00:16:59,606 --> 0:17:00,086
it's needed.

573
00:16:59,606 --> 0:17:00,086
it's needed.

574
00:17:01,126 --> 0:17:02,066
Instead we recommend the

575
00:17:02,066 --> 0:17:02,456
inverse.

576
00:17:03,126 --> 0:17:04,486
Keep the database open as long

577
00:17:04,486 --> 0:17:05,766
as possible and close

578
00:17:05,766 --> 0:17:07,165
connections only when necessary.

579
00:17:08,026 --> 0:17:09,336
For multi-threaded processes,

580
00:17:09,486 --> 0:17:10,996
pool connections so that so long

581
00:17:10,996 --> 0:17:12,406
as one thread still needs the

582
00:17:12,406 --> 0:17:13,675
database the database can remain

583
00:17:13,675 --> 0:17:14,036
open.

584
00:17:14,816 --> 0:17:16,086
This really helps amortize the

585
00:17:16,086 --> 0:17:17,306
cost of opening and closing a

586
00:17:17,306 --> 0:17:18,516
database over time.

587
00:17:22,046 --> 0:17:22,876
Next up, journaling.

588
00:17:23,366 --> 0:17:25,976
Delete mode journaling is the

589
00:17:25,976 --> 0:17:27,165
default journaling mode for

590
00:17:27,165 --> 0:17:28,896
SQLite but it isn't necessarily

591
00:17:28,896 --> 0:17:29,686
the most efficient.

592
00:17:30,146 --> 0:17:31,906
To see why let's take a look at

593
00:17:31,906 --> 0:17:33,486
how delete mode journaling

594
00:17:33,486 --> 0:17:33,846
works.

595
00:17:34,376 --> 0:17:36,486
Let's say we have a database and

596
00:17:36,486 --> 0:17:37,956
we want to modify four pages in

597
00:17:38,516 --> 0:17:38,586
it.

598
00:17:39,176 --> 0:17:40,506
The first thing that happens, we

599
00:17:40,506 --> 0:17:42,066
end up copying those four pages

600
00:17:42,266 --> 0:17:45,746
to a journal file.

601
00:17:45,946 --> 0:17:47,366
We then can modify the four

602
00:17:47,366 --> 0:17:48,486
pages within the database.

603
00:17:49,466 --> 0:17:51,646
And once that's completed, the

604
00:17:51,646 --> 0:17:52,716
journal file gets deleted.

605
00:17:53,436 --> 0:17:54,606
So if we think about that, we

606
00:17:54,606 --> 0:17:57,066
had to write twice the number of

607
00:17:57,066 --> 0:17:59,226
pages we meant to modify and we

608
00:17:59,226 --> 0:18:00,586
had all the file system overhead

609
00:17:59,226 --> 0:18:00,586
had all the file system overhead

610
00:18:00,586 --> 0:18:01,876
of this short-lived journal file

611
00:18:01,876 --> 0:18:02,696
that we kept around just for a

612
00:18:02,696 --> 0:18:03,606
single transaction.

613
00:18:05,576 --> 0:18:07,086
Fortunately, SQLite provides a

614
00:18:07,086 --> 0:18:08,236
much more efficient alternative

615
00:18:09,126 --> 0:18:10,986
in Write Ahead Log or WAL Mode

616
00:18:10,986 --> 0:18:11,406
Journaling.

617
00:18:11,946 --> 0:18:13,776
WAL Mode Journaling provides a

618
00:18:13,776 --> 0:18:15,086
great way of reducing writes.

619
00:18:15,086 --> 0:18:16,786
It allows us to combine writes

620
00:18:16,786 --> 0:18:18,456
to the -- multiple writes to the

621
00:18:18,456 --> 0:18:18,986
same page.

622
00:18:18,986 --> 0:18:20,476
It uses fewer barriers.

623
00:18:21,316 --> 0:18:22,476
It can support multiple readers

624
00:18:22,476 --> 0:18:23,516
at the same time as a writer,

625
00:18:24,016 --> 0:18:25,086
and supports snapshots.

626
00:18:26,116 --> 0:18:27,156
Let's take a look at how WAL

627
00:18:27,156 --> 0:18:27,706
Mode works.

628
00:18:29,146 --> 0:18:29,966
So let's say again we have a

629
00:18:29,966 --> 0:18:30,986
database and we want to modify

630
00:18:30,986 --> 0:18:31,506
four pages.

631
00:18:32,186 --> 0:18:33,306
Instead of modifying pages

632
00:18:33,306 --> 0:18:34,786
directly in the database, they

633
00:18:34,786 --> 0:18:35,646
just get written to the Write

634
00:18:35,646 --> 0:18:37,906
Ahead Log file and, as we have

635
00:18:37,906 --> 0:18:40,006
additional transactions, those

636
00:18:40,006 --> 0:18:41,096
pages get added to the Write

637
00:18:41,096 --> 0:18:43,146
Ahead Log file too until the

638
00:18:43,146 --> 0:18:44,096
Write Ahead Log file gets

639
00:18:44,096 --> 0:18:45,226
sufficiently large and it makes

640
00:18:45,226 --> 0:18:46,096
sense to checkpoint it.

641
00:18:47,516 --> 0:18:49,126
And, when we checkpoint it we

642
00:18:49,126 --> 0:18:50,266
get one of the huge wins of WAL

643
00:18:50,266 --> 0:18:52,036
Mode, pages which would've been

644
00:18:52,036 --> 0:18:54,866
modified multiple times in a

645
00:18:54,866 --> 0:18:56,536
Delete Mode database, all those

646
00:18:56,536 --> 0:18:57,816
changes to the same page get

647
00:18:57,816 --> 0:18:59,776
merged during the WAL checkpoint

648
00:18:59,776 --> 0:19:01,006
and that same page only needs to

649
00:18:59,776 --> 0:19:01,006
and that same page only needs to

650
00:19:01,006 --> 0:19:02,096
be written out once.

651
00:19:02,776 --> 0:19:06,136
And when we're done, a simple

652
00:19:06,136 --> 0:19:06,976
overwrite of the header of the

653
00:19:06,976 --> 0:19:08,476
WAL file is all that's needed to

654
00:19:08,476 --> 0:19:09,916
make it available for future use

655
00:19:10,226 --> 0:19:11,416
thus reducing the file system

656
00:19:11,416 --> 0:19:12,596
cost of maintaining this Write

657
00:19:12,596 --> 0:19:13,336
Ahead Log file.

658
00:19:13,906 --> 0:19:17,536
So we can see WAL Mode is more

659
00:19:17,536 --> 0:19:19,306
efficient for most use cases of

660
00:19:19,306 --> 0:19:19,726
SQLite.

661
00:19:19,856 --> 0:19:21,136
If you weren't already using WAL

662
00:19:21,136 --> 0:19:22,536
Mode for your SQLite databases,

663
00:19:22,646 --> 0:19:23,936
we highly recommend switching

664
00:19:23,936 --> 0:19:24,646
over to WAL Mode.

665
00:19:24,646 --> 0:19:26,306
It can be a great way of getting

666
00:19:26,306 --> 0:19:27,986
some huge performance wins for

667
00:19:27,986 --> 0:19:28,446
your app.

668
00:19:29,626 --> 0:19:31,076
Using multiple INSERT and UPDATE

669
00:19:31,076 --> 0:19:32,036
and DELETE statements in a

670
00:19:32,036 --> 0:19:33,386
single transaction is a great

671
00:19:33,386 --> 0:19:34,906
way of giving SQLite more

672
00:19:34,906 --> 0:19:36,176
information so that it can make

673
00:19:36,176 --> 0:19:37,526
more efficient operations on

674
00:19:37,526 --> 0:19:37,956
your behalf.

675
00:19:39,116 --> 0:19:41,076
Pages that are changed multiple

676
00:19:41,146 --> 0:19:42,616
times by, in the same

677
00:19:42,616 --> 0:19:43,536
transaction by multiple

678
00:19:43,536 --> 0:19:44,906
statements, only get written out

679
00:19:44,906 --> 0:19:45,576
to disk once.

680
00:19:46,086 --> 0:19:48,176
Let's say in this example we

681
00:19:48,176 --> 0:19:48,856
have three separate

682
00:19:48,856 --> 0:19:50,266
transactions, each with one

683
00:19:50,266 --> 0:19:51,476
statement that modify the same

684
00:19:51,476 --> 0:19:52,296
page in the database.

685
00:19:53,076 --> 0:19:54,036
We'll see the same page in the

686
00:19:54,036 --> 0:19:55,556
database get modified three

687
00:19:55,556 --> 0:19:55,976
times.

688
00:19:56,576 --> 0:19:58,856
If, however, we had a single

689
00:19:58,856 --> 0:20:00,336
transaction with those three

690
00:19:58,856 --> 0:20:00,336
transaction with those three

691
00:20:00,336 --> 0:20:02,506
statements, all those changes

692
00:20:02,506 --> 0:20:03,786
would get combined and the page

693
00:20:03,786 --> 0:20:04,666
in the database would only get

694
00:20:04,666 --> 0:20:06,026
written out once.

695
00:20:07,356 --> 0:20:08,956
As a result, using multiple

696
00:20:08,956 --> 0:20:10,456
statements in a single SQLite

697
00:20:10,456 --> 0:20:11,776
transaction is a great way for

698
00:20:11,776 --> 0:20:13,546
aggregating changes over time.

699
00:20:17,746 --> 0:20:18,906
File size and privacy.

700
00:20:18,906 --> 0:20:22,106
So what happens when we delete

701
00:20:22,106 --> 0:20:22,996
data from the database?

702
00:20:23,846 --> 0:20:25,146
Space containing the deleted

703
00:20:25,146 --> 0:20:27,396
data is marked as free and while

704
00:20:27,396 --> 0:20:28,176
it's no longer part of the

705
00:20:28,176 --> 0:20:29,706
database, it's still technically

706
00:20:29,706 --> 0:20:30,176
on disk.

707
00:20:31,406 --> 0:20:32,786
So how do we securely delete

708
00:20:32,846 --> 0:20:34,146
sensitive information in an

709
00:20:34,146 --> 0:20:35,476
efficient manner?

710
00:20:36,996 --> 0:20:38,466
We recommend using secure

711
00:20:38,466 --> 0:20:39,386
delete=fast.

712
00:20:39,976 --> 0:20:41,306
secure delete=fast is great.

713
00:20:41,856 --> 0:20:44,116
It automatically zeroes deleted

714
00:20:44,116 --> 0:20:45,986
data and there is no cost for

715
00:20:45,986 --> 0:20:47,186
data that was in the same page

716
00:20:47,186 --> 0:20:48,156
as the header file that we had

717
00:20:48,156 --> 0:20:49,256
to modify to mark the data as

718
00:20:49,256 --> 0:20:49,696
being free.

719
00:20:49,696 --> 0:20:51,766
And it's also now the default

720
00:20:51,766 --> 0:20:53,336
behavior for SQLite in the iOS

721
00:20:53,336 --> 0:20:53,786
13.

722
00:20:54,716 --> 0:20:55,886
If you need it for older builds

723
00:20:55,886 --> 0:20:58,366
of iOS, please specify the

724
00:20:58,366 --> 0:21:00,516
secure delete=fast pragma.

725
00:20:58,366 --> 0:21:00,516
secure delete=fast pragma.

726
00:21:04,056 --> 0:21:05,056
When it comes to managing the

727
00:21:05,056 --> 0:21:06,906
size of our database files, we

728
00:21:06,906 --> 0:21:08,576
highly recommend not using

729
00:21:08,576 --> 0:21:09,046
VACUUM.

730
00:21:10,326 --> 0:21:12,716
VACUUM is a very slow memory and

731
00:21:12,716 --> 0:21:13,996
I/O intensive operation.

732
00:21:14,246 --> 0:21:15,376
To better understand why let's

733
00:21:15,376 --> 0:21:17,276
take a look at how VACUUM for

734
00:21:17,276 --> 0:21:18,346
SQLite databases work.

735
00:21:18,346 --> 0:21:20,956
So let's say we have a database

736
00:21:20,956 --> 0:21:21,936
and we wanted to VACUUM out all

737
00:21:21,936 --> 0:21:22,596
the free pages.

738
00:21:23,106 --> 0:21:24,896
What happens is we end up

739
00:21:24,896 --> 0:21:26,426
opening up a cache door to our

740
00:21:26,426 --> 0:21:27,786
database, a journal file gets

741
00:21:27,786 --> 0:21:29,046
created, then we end up

742
00:21:29,086 --> 0:21:31,096
performing an SQLite dump from

743
00:21:31,096 --> 0:21:32,416
the database to the journal file

744
00:21:32,936 --> 0:21:34,416
copying all of the valid data

745
00:21:34,416 --> 0:21:35,916
from our database to the journal

746
00:21:35,916 --> 0:21:36,236
file.

747
00:21:37,676 --> 0:21:38,816
Then later when it's time to

748
00:21:38,816 --> 0:21:40,596
checkpoint the journal file, the

749
00:21:40,596 --> 0:21:42,056
database gets truncated to the

750
00:21:42,056 --> 0:21:44,686
size of the journal file and all

751
00:21:44,686 --> 0:21:46,226
the data from the journal gets

752
00:21:46,226 --> 0:21:47,526
reinserted back to the database.

753
00:21:48,516 --> 0:21:49,886
And then when that's complete,

754
00:21:50,006 --> 0:21:51,396
the journal file gets discarded.

755
00:21:54,076 --> 0:21:55,136
As we can see, this is pretty

756
00:21:55,136 --> 0:21:56,686
expensive as all of the valid

757
00:21:56,686 --> 0:21:57,706
data we had in our database had

758
00:21:57,706 --> 0:21:58,946
to be written at least twice,

759
00:21:59,146 --> 0:22:00,336
once to the journal file and

760
00:21:59,146 --> 0:22:00,336
once to the journal file and

761
00:22:00,336 --> 0:22:01,876
then once again back into the

762
00:22:01,876 --> 0:22:02,366
database.

763
00:22:02,956 --> 0:22:06,056
And if the working side of the

764
00:22:06,056 --> 0:22:07,576
database is too big to fit into

765
00:22:07,576 --> 0:22:09,726
memory, SQLite actually has to

766
00:22:09,726 --> 0:22:11,416
utilize spill files to help

767
00:22:11,416 --> 0:22:13,466
manage the extra data until the

768
00:22:13,466 --> 0:22:14,506
operation is complete.

769
00:22:18,236 --> 0:22:19,136
Again, fortunately there's a

770
00:22:19,136 --> 0:22:20,466
much more efficient alternative

771
00:22:20,826 --> 0:22:22,726
in SQLite and in this case

772
00:22:22,946 --> 0:22:24,356
that's auto vacuum=INCREMENTAL.

773
00:22:24,916 --> 0:22:26,596
auto VACUUM incremental is great

774
00:22:26,596 --> 0:22:27,556
because not only does it allow

775
00:22:27,556 --> 0:22:28,586
us a more efficient way of

776
00:22:28,806 --> 0:22:29,966
managing the size of the

777
00:22:29,966 --> 0:22:32,076
database file, it lets us

778
00:22:32,076 --> 0:22:33,406
specify the number of pages we

779
00:22:33,406 --> 0:22:34,346
want to vacuum out of the

780
00:22:34,346 --> 0:22:36,446
database providing an option for

781
00:22:36,446 --> 0:22:37,766
leaving some free pages in the

782
00:22:37,766 --> 0:22:39,276
database for future use.

783
00:22:43,216 --> 0:22:44,406
Let's take a look at how auto

784
00:22:44,406 --> 0:22:46,766
vacuum=INCREMENTAL works.

785
00:22:46,856 --> 0:22:48,636
So in this example we're going

786
00:22:48,636 --> 0:22:49,546
to vacuum out the two free

787
00:22:49,546 --> 0:22:49,966
pages.

788
00:22:50,876 --> 0:22:52,066
Whereas before we would have had

789
00:22:52,066 --> 0:22:53,296
to move all of our data from the

790
00:22:53,296 --> 0:22:55,836
database in the WAL file, for

791
00:22:55,986 --> 0:22:57,466
incremental auto vacuum, all we

792
00:22:57,466 --> 0:22:59,496
do is migrate two pages from the

793
00:22:59,496 --> 0:23:00,886
end of the database into the

794
00:22:59,496 --> 0:23:00,886
end of the database into the

795
00:23:00,886 --> 0:23:04,066
Write Ahead Log and any parent

796
00:23:04,066 --> 0:23:06,156
nodes that get modified during

797
00:23:06,156 --> 0:23:07,576
the rebalance of the database

798
00:23:07,576 --> 0:23:08,786
tree also get written to the

799
00:23:08,786 --> 0:23:09,416
Write Ahead Log.

800
00:23:10,356 --> 0:23:12,246
Then, when the Write Ahead Log

801
00:23:12,246 --> 0:23:14,776
gets checkpointed, the database

802
00:23:14,776 --> 0:23:16,126
file itself gets truncated, the

803
00:23:16,126 --> 0:23:18,566
pages we migrated from the end

804
00:23:18,566 --> 0:23:19,606
of the database go to where the

805
00:23:19,606 --> 0:23:21,056
free pages used to be, and any

806
00:23:21,056 --> 0:23:22,686
updated parent nodes get written

807
00:23:22,686 --> 0:23:23,416
to the database.

808
00:23:24,286 --> 0:23:25,386
So as you can see, whereas

809
00:23:25,386 --> 0:23:26,466
before we had to move all of our

810
00:23:26,466 --> 0:23:27,616
data in and out of the database,

811
00:23:27,726 --> 0:23:29,056
now we're simply modifying a

812
00:23:29,056 --> 0:23:30,576
subset of the pages within the

813
00:23:30,576 --> 0:23:30,976
database.

814
00:23:31,956 --> 0:23:33,146
This is much more efficient.

815
00:23:34,476 --> 0:23:35,436
There's all -- we highly

816
00:23:35,436 --> 0:23:37,726
recommend using incremental auto

817
00:23:37,726 --> 0:23:39,426
vacuum and fast secure delete to

818
00:23:39,426 --> 0:23:40,796
manage both file size and

819
00:23:40,796 --> 0:23:42,006
privacy for your SQLite

820
00:23:42,006 --> 0:23:42,546
databases.

821
00:23:48,166 --> 0:23:48,946
Partial indexes.

822
00:23:51,856 --> 0:23:52,686
Indexes are great.

823
00:23:53,066 --> 0:23:54,686
Indexes allow for faster ORDER

824
00:23:54,686 --> 0:23:56,356
BY, GROUP BY, and WHERE clauses.

825
00:23:57,126 --> 0:23:58,366
Unfortunately, they aren't free.

826
00:23:58,586 --> 0:23:59,416
There's a certain amount of

827
00:23:59,416 --> 0:24:00,486
overhead the database needs to

828
00:23:59,416 --> 0:24:00,486
overhead the database needs to

829
00:24:00,486 --> 0:24:01,876
do to support these indexes.

830
00:24:02,576 --> 0:24:03,986
And after we add more indexes,

831
00:24:04,256 --> 0:24:06,326
each new write of data to the

832
00:24:06,326 --> 0:24:07,446
database can become more

833
00:24:07,446 --> 0:24:07,966
expensive.

834
00:24:09,656 --> 0:24:10,786
Fortunately, there's a more

835
00:24:10,786 --> 0:24:11,686
efficient alternative in the

836
00:24:11,686 --> 0:24:12,886
form of partial indexes.

837
00:24:13,566 --> 0:24:14,806
Partial indexes allow you to

838
00:24:14,806 --> 0:24:16,336
describe where you'd want to pay

839
00:24:16,336 --> 0:24:17,796
the price of your index using a

840
00:24:17,796 --> 0:24:19,846
WHERE clause which is great

841
00:24:19,846 --> 0:24:21,686
because now you can get the

842
00:24:21,686 --> 0:24:23,186
benefits of an index when you

843
00:24:23,186 --> 0:24:25,236
want it, but not -- but not

844
00:24:25,236 --> 0:24:26,296
necessarily having to pay the

845
00:24:26,296 --> 0:24:27,556
price of the index when it won't

846
00:24:27,556 --> 0:24:27,976
do you any benefit.

847
00:24:33,526 --> 0:24:35,526
So in summary for SQLite, please

848
00:24:36,796 --> 0:24:38,706
keep database connections open

849
00:24:38,746 --> 0:24:41,436
as long as possible.

850
00:24:41,526 --> 0:24:43,086
Use WAL journaling mode instead

851
00:24:43,086 --> 0:24:44,706
of delete journaling mode.

852
00:24:45,656 --> 0:24:47,216
Whenever possible, use multiple

853
00:24:47,216 --> 0:24:48,626
statements per transaction so

854
00:24:48,626 --> 0:24:50,536
SQLite can do some optimizations

855
00:24:50,606 --> 0:24:51,686
for us.

856
00:24:53,076 --> 0:24:54,416
Use fast secure delete and auto

857
00:24:54,416 --> 0:24:56,116
vacuum incremental to manage

858
00:24:56,166 --> 0:24:57,416
both file size and privacy for

859
00:24:57,416 --> 0:24:58,166
your databases.

860
00:24:59,346 --> 0:25:01,246
And, when it's practical, use

861
00:24:59,346 --> 0:25:01,246
And, when it's practical, use

862
00:25:01,286 --> 0:25:02,546
partial indexes instead of

863
00:25:02,546 --> 0:25:03,206
regular indexes.

864
00:25:04,726 --> 0:25:07,586
And if you'd really rather not

865
00:25:07,836 --> 0:25:09,286
worry about these details in

866
00:25:09,286 --> 0:25:11,066
SQLite, we highly recommend just

867
00:25:11,066 --> 0:25:11,906
using Core Data.

868
00:25:11,906 --> 0:25:13,226
Core Data handles all this heavy

869
00:25:13,226 --> 0:25:15,806
lifting for you and as Core Data

870
00:25:15,806 --> 0:25:17,206
gets improved over time,

871
00:25:17,656 --> 0:25:19,246
adopters of Core Data will also

872
00:25:19,246 --> 0:25:20,496
get those benefits for free.

873
00:25:24,946 --> 0:25:26,756
Next up Alejandro will show us

874
00:25:26,756 --> 0:25:28,036
how we can use the updated File

875
00:25:28,036 --> 0:25:29,866
Activity instrument and show us

876
00:25:29,866 --> 0:25:30,956
real-world examples of how we

877
00:25:30,956 --> 0:25:32,686
can profile and optimize I/O for

878
00:25:32,686 --> 0:25:32,956
apps.

879
00:25:33,596 --> 0:25:33,946
Alejandro.

880
00:25:34,516 --> 0:25:41,256
[ Applause ]

881
00:25:41,756 --> 0:25:42,816
&gt;&gt; All right thank you Kai.

882
00:25:43,216 --> 0:25:44,646
And good morning everyone.

883
00:25:44,646 --> 0:25:45,596
Thank you for attending this

884
00:25:45,596 --> 0:25:46,946
session on optimizing storage.

885
00:25:47,796 --> 0:25:49,456
What I'd like to do is talk

886
00:25:49,456 --> 0:25:50,536
about some of the improvements

887
00:25:50,536 --> 0:25:51,696
we've made to the File Activity

888
00:25:51,696 --> 0:25:53,216
instrument to see how we can use

889
00:25:53,216 --> 0:25:55,036
that to optimize storage in our

890
00:25:55,036 --> 0:25:55,156
app.

891
00:25:55,906 --> 0:25:56,616
So let's get started.

892
00:25:57,366 --> 0:25:58,606
What changed with the File

893
00:25:58,606 --> 0:25:59,866
Activity instrument?

894
00:26:00,776 --> 0:26:02,206
Well, one of the first things we

895
00:26:02,206 --> 0:26:03,706
did was we added support for all

896
00:26:03,706 --> 0:26:04,476
Apple devices.

897
00:26:04,876 --> 0:26:05,786
So this means you can have the

898
00:26:05,786 --> 0:26:07,026
same uniform profiling

899
00:26:07,026 --> 0:26:08,636
experience across your iOS

900
00:26:08,636 --> 0:26:11,426
device, Mac, Watch, TV,

901
00:26:11,526 --> 0:26:11,976
etcetera.

902
00:26:15,426 --> 0:26:16,406
The File Activity instrument

903
00:26:16,406 --> 0:26:18,066
also lets you support tracing

904
00:26:18,066 --> 0:26:18,846
for not just your own

905
00:26:18,846 --> 0:26:20,176
application but also for the

906
00:26:20,176 --> 0:26:22,126
entire system so you can see how

907
00:26:22,126 --> 0:26:23,866
your application behaves with

908
00:26:24,096 --> 0:26:25,856
regards to the I/O subsystem

909
00:26:26,106 --> 0:26:27,736
alone and how it interacts with

910
00:26:27,796 --> 0:26:28,986
the rest of the system so you

911
00:26:28,986 --> 0:26:29,976
can see different interactions

912
00:26:29,976 --> 0:26:30,316
going on.

913
00:26:30,806 --> 0:26:34,156
Next as Kai mentioned, there is

914
00:26:34,156 --> 0:26:35,496
the distinction between logical

915
00:26:35,496 --> 0:26:36,286
and physical I/O.

916
00:26:36,696 --> 0:26:37,616
And understanding how they

917
00:26:37,616 --> 0:26:38,566
interact with each other is

918
00:26:38,566 --> 0:26:40,346
actually really important for --

919
00:26:40,346 --> 0:26:42,116
to understand your I/O usage.

920
00:26:42,396 --> 0:26:43,526
So the File Activity instrument

921
00:26:43,526 --> 0:26:44,786
lets us see both of these

922
00:26:44,786 --> 0:26:45,156
together.

923
00:26:45,686 --> 0:26:48,796
And lastly, we also added

924
00:26:48,796 --> 0:26:50,176
support for automated reasoning.

925
00:26:50,596 --> 0:26:51,856
And the automated reasoning

926
00:26:51,856 --> 0:26:52,946
comes in a variety of different

927
00:26:52,946 --> 0:26:54,186
mechanisms, so I'd like to talk

928
00:26:54,186 --> 0:26:55,256
about this very briefly.

929
00:26:55,736 --> 0:26:58,666
First and foremost, one of the

930
00:26:58,666 --> 0:27:00,336
automated reasoning anti-pattern

931
00:26:58,666 --> 0:27:00,336
automated reasoning anti-pattern

932
00:27:00,336 --> 0:27:01,346
detections that we added was

933
00:27:01,346 --> 0:27:02,406
actually that for excessive

934
00:27:02,406 --> 0:27:03,156
physical writes.

935
00:27:03,596 --> 0:27:04,726
So the File Activity instrument

936
00:27:04,726 --> 0:27:06,316
will actually notify you while

937
00:27:06,316 --> 0:27:08,046
you're tracing that it detected

938
00:27:08,046 --> 0:27:09,596
some sort of excessive activity

939
00:27:09,796 --> 0:27:10,946
in your application and you can

940
00:27:10,946 --> 0:27:12,366
go in directly from instruments

941
00:27:12,366 --> 0:27:14,266
and see what may have caused it.

942
00:27:16,396 --> 0:27:18,086
We also added support for seeing

943
00:27:18,086 --> 0:27:19,706
when certain I/O related system

944
00:27:19,706 --> 0:27:20,796
calls that either you call

945
00:27:20,796 --> 0:27:22,176
directly or maybe are called on

946
00:27:22,176 --> 0:27:23,116
your behalf because of a

947
00:27:23,116 --> 0:27:24,606
framework have failed.

948
00:27:24,606 --> 0:27:25,806
And these are important to

949
00:27:25,806 --> 0:27:27,836
understand, not just for I/O but

950
00:27:27,836 --> 0:27:28,906
also for correctness in your

951
00:27:28,906 --> 0:27:29,336
application.

952
00:27:29,926 --> 0:27:33,196
And lastly, to Kai's points

953
00:27:33,196 --> 0:27:34,986
about fsync and F control with F

954
00:27:34,986 --> 0:27:36,886
FULLFSYNC, we also have a

955
00:27:36,886 --> 0:27:37,876
mechanism for detecting

956
00:27:37,876 --> 0:27:39,686
suboptimal caching so you can

957
00:27:39,686 --> 0:27:41,276
see when your application might

958
00:27:41,276 --> 0:27:42,696
be performing certain behaviors

959
00:27:42,946 --> 0:27:43,966
that aren't making the best

960
00:27:43,966 --> 0:27:45,286
utilization of the OS cache.

961
00:27:46,056 --> 0:27:46,946
So let's get started with File

962
00:27:46,946 --> 0:27:48,226
Activity instrument and see what

963
00:27:48,226 --> 0:27:49,546
it looks like.

964
00:27:49,816 --> 0:27:50,996
With Instruments 11, when we

965
00:27:50,996 --> 0:27:52,836
open up the instruments, we see

966
00:27:52,836 --> 0:27:54,336
the file activity still has

967
00:27:54,456 --> 0:27:55,856
roughly the same icon but we get

968
00:27:55,856 --> 0:27:57,216
a new string at the bottom which

969
00:27:57,216 --> 0:27:58,106
kind of sums up what it's

970
00:27:58,106 --> 0:27:58,826
capable of doing.

971
00:27:58,996 --> 0:28:00,906
And if we go ahead and select

972
00:27:58,996 --> 0:28:00,906
And if we go ahead and select

973
00:28:00,906 --> 0:28:02,466
it, we're presented with some

974
00:28:02,466 --> 0:28:03,076
new tracks.

975
00:28:03,856 --> 0:28:04,996
First and foremost is the file

976
00:28:04,996 --> 0:28:06,166
system suggestions track.

977
00:28:06,536 --> 0:28:07,986
And this track is where all of

978
00:28:07,986 --> 0:28:08,926
these anti-patterns and

979
00:28:08,926 --> 0:28:10,446
automated reasoning suggestions

980
00:28:10,446 --> 0:28:11,706
will live.

981
00:28:12,016 --> 0:28:13,186
Directly beneath it we have file

982
00:28:13,186 --> 0:28:14,846
system activity and the file

983
00:28:14,846 --> 0:28:16,076
system activity will be broken

984
00:28:16,076 --> 0:28:17,236
down for logical reads and

985
00:28:17,236 --> 0:28:19,006
logical writes and it'll show

986
00:28:19,006 --> 0:28:20,306
you a count of how many of these

987
00:28:20,306 --> 0:28:21,236
operations happened.

988
00:28:21,596 --> 0:28:22,826
And you're also able to see in

989
00:28:22,826 --> 0:28:24,376
more depth how many calls were

990
00:28:24,376 --> 0:28:25,996
made, who called them, and

991
00:28:25,996 --> 0:28:27,006
certain other statistics.

992
00:28:27,906 --> 0:28:29,696
Similarly, right beneath it is

993
00:28:29,696 --> 0:28:30,926
disk usage where you can get the

994
00:28:30,926 --> 0:28:32,436
same sort of read and write

995
00:28:32,436 --> 0:28:33,836
distinction but for the physical

996
00:28:33,836 --> 0:28:34,156
layer.

997
00:28:34,986 --> 0:28:36,756
And lastly, the disk I/O latency

998
00:28:36,756 --> 0:28:38,116
so we can see just how long

999
00:28:38,116 --> 0:28:39,436
certain physical I/Os took.

1000
00:28:40,296 --> 0:28:41,456
So let's get started and I'll

1001
00:28:41,456 --> 0:28:43,786
refer back to this demo app.

1002
00:28:43,786 --> 0:28:44,676
And the first thing I'd like to

1003
00:28:44,676 --> 0:28:46,286
implement is actually favoriting

1004
00:28:46,286 --> 0:28:46,936
of photos.

1005
00:28:47,416 --> 0:28:48,236
So in the bottom right-hand

1006
00:28:48,236 --> 0:28:49,446
corner of each of these images

1007
00:28:49,536 --> 0:28:50,896
there's a star and what I'd like

1008
00:28:50,896 --> 0:28:51,856
to implement is being able to

1009
00:28:51,856 --> 0:28:53,476
select that star to consider an

1010
00:28:53,476 --> 0:28:54,236
image a favorite.

1011
00:28:54,946 --> 0:28:56,376
As an example, I can select a

1012
00:28:56,376 --> 0:28:59,606
banana slug as a favorite as

1013
00:28:59,606 --> 0:29:00,536
well as these skyscrapers.

1014
00:28:59,606 --> 0:29:00,536
well as these skyscrapers.

1015
00:29:00,536 --> 0:29:02,296
And the very first approach that

1016
00:29:02,296 --> 0:29:03,986
I'll take is implementing this

1017
00:29:03,986 --> 0:29:05,106
by opening and closing the

1018
00:29:05,106 --> 0:29:06,506
database every time that we have

1019
00:29:06,506 --> 0:29:07,076
a favoriting.

1020
00:29:07,736 --> 0:29:09,066
Now Kai told us that this isn't

1021
00:29:09,236 --> 0:29:10,566
the best pattern but I still

1022
00:29:10,566 --> 0:29:11,736
think it's useful to get this

1023
00:29:11,736 --> 0:29:12,946
into a File Activity instrument

1024
00:29:12,946 --> 0:29:14,456
trace so we have a baseline and

1025
00:29:14,456 --> 0:29:15,526
we can see what sorts of things

1026
00:29:15,526 --> 0:29:15,936
are happening.

1027
00:29:17,736 --> 0:29:19,546
So here behind me I have exactly

1028
00:29:19,546 --> 0:29:19,826
that.

1029
00:29:19,826 --> 0:29:21,456
I ran the File Activity

1030
00:29:21,456 --> 0:29:22,616
instrument against this same

1031
00:29:22,616 --> 0:29:24,136
workload by opening and closing

1032
00:29:24,136 --> 0:29:25,296
the database per operation.

1033
00:29:25,916 --> 0:29:26,926
And the first track I'd like to

1034
00:29:26,926 --> 0:29:28,336
focus on is disk usage because

1035
00:29:28,336 --> 0:29:29,366
this is where all the physical

1036
00:29:29,366 --> 0:29:30,326
I/O information will live.

1037
00:29:31,016 --> 0:29:32,966
Here we see in the physical

1038
00:29:32,966 --> 0:29:34,376
writes column or the physical

1039
00:29:34,376 --> 0:29:35,876
writes row, we see the different

1040
00:29:35,876 --> 0:29:36,966
amount of physical I/Os that

1041
00:29:36,966 --> 0:29:37,346
happen.

1042
00:29:37,346 --> 0:29:38,926
In this case in the tool tip

1043
00:29:38,926 --> 0:29:40,836
text we have 54 for this

1044
00:29:40,836 --> 0:29:41,566
particular column.

1045
00:29:42,186 --> 0:29:43,056
But right beneath it is the

1046
00:29:43,056 --> 0:29:44,306
detail view and the detail view

1047
00:29:44,306 --> 0:29:45,146
is where all of the extra

1048
00:29:45,146 --> 0:29:46,256
statistics will live so I'm

1049
00:29:46,256 --> 0:29:47,476
going to go into here so we can

1050
00:29:47,476 --> 0:29:48,816
see what sort of things we're

1051
00:29:49,456 --> 0:29:49,646
getting.

1052
00:29:50,676 --> 0:29:52,786
By zooming in I'd like to point

1053
00:29:52,786 --> 0:29:54,946
out that for this workload of

1054
00:29:54,946 --> 0:29:57,006
favoriting these photos with the

1055
00:29:57,006 --> 0:29:58,296
opening and closing database per

1056
00:29:58,296 --> 0:30:00,426
operation, we had 1,002

1057
00:29:58,296 --> 0:30:00,426
operation, we had 1,002

1058
00:30:00,426 --> 0:30:01,406
different physical I/O

1059
00:30:01,406 --> 0:30:03,076
operations totaling just under 6

1060
00:30:03,076 --> 0:30:03,976
megabytes of total footprint.

1061
00:30:04,046 --> 0:30:06,466
And this may not seem like that

1062
00:30:06,466 --> 0:30:07,666
much but when we compare it to

1063
00:30:07,666 --> 0:30:08,546
some of the other ones, we'll

1064
00:30:08,546 --> 0:30:09,606
get a better understanding of

1065
00:30:09,666 --> 0:30:11,556
why this is perhaps as bad as it

1066
00:30:11,556 --> 0:30:11,816
is.

1067
00:30:12,816 --> 0:30:13,946
So here we get some statistics

1068
00:30:13,946 --> 0:30:15,486
about, you know, latency and

1069
00:30:15,486 --> 0:30:16,476
average latencies as well.

1070
00:30:17,286 --> 0:30:18,476
But I would like to switch back

1071
00:30:18,476 --> 0:30:20,356
to the overall view because I

1072
00:30:20,356 --> 0:30:21,426
also noticed that in the file

1073
00:30:21,426 --> 0:30:22,936
system suggestions track, we do

1074
00:30:22,936 --> 0:30:24,476
have some notifications that the

1075
00:30:24,476 --> 0:30:26,136
instrument told us and I'd like

1076
00:30:26,136 --> 0:30:27,866
to go into these as well so we

1077
00:30:27,866 --> 0:30:28,686
can see just what happened.

1078
00:30:29,646 --> 0:30:31,026
Again, at the bottom we have the

1079
00:30:31,026 --> 0:30:32,306
detail view, and here the detail

1080
00:30:32,306 --> 0:30:33,846
view in that count column is

1081
00:30:33,846 --> 0:30:35,466
telling us that we had 12 total

1082
00:30:35,466 --> 0:30:36,356
notifications.

1083
00:30:37,686 --> 0:30:39,576
And if we go into that dropdown,

1084
00:30:39,656 --> 0:30:40,906
we see that these notifications

1085
00:30:40,906 --> 0:30:42,296
were precisely for excessive

1086
00:30:42,296 --> 0:30:43,076
physical writes.

1087
00:30:43,706 --> 0:30:44,756
And we know that opening and

1088
00:30:44,756 --> 0:30:45,876
closing the database isn't

1089
00:30:45,876 --> 0:30:47,406
necessarily a good thing and

1090
00:30:47,406 --> 0:30:48,266
we're going to try different

1091
00:30:48,266 --> 0:30:49,526
techniques so we can get this.

1092
00:30:49,816 --> 0:30:50,676
But I like to start off with

1093
00:30:50,676 --> 0:30:51,776
this baseline of 12

1094
00:30:51,776 --> 0:30:52,796
notifications from the file

1095
00:30:52,796 --> 0:30:53,986
system -- File Activity

1096
00:30:53,986 --> 0:30:54,376
instrument.

1097
00:30:55,436 --> 0:30:58,686
And lastly, I also want to talk

1098
00:30:58,686 --> 0:31:00,066
about the actual file system

1099
00:30:58,686 --> 0:31:00,066
about the actual file system

1100
00:31:00,066 --> 0:31:01,786
activity track where we can see

1101
00:31:01,786 --> 0:31:02,986
statistics about which

1102
00:31:02,986 --> 0:31:04,526
operations were called such as

1103
00:31:04,526 --> 0:31:05,896
writes and reads and so forth,

1104
00:31:06,506 --> 0:31:08,946
but also in this table here we

1105
00:31:08,946 --> 0:31:10,126
get different views of the

1106
00:31:10,126 --> 0:31:11,056
logical I/Os that our

1107
00:31:11,056 --> 0:31:11,826
application did.

1108
00:31:12,346 --> 0:31:13,286
Here are the default is file

1109
00:31:13,286 --> 0:31:14,556
system statistics but we can

1110
00:31:14,556 --> 0:31:16,176
also go down to file descriptor

1111
00:31:16,516 --> 0:31:17,446
information as well.

1112
00:31:21,046 --> 0:31:22,056
All right so with that in mind,

1113
00:31:22,346 --> 0:31:23,556
now I want to go and switch to a

1114
00:31:23,556 --> 0:31:24,796
different model which is opening

1115
00:31:24,796 --> 0:31:25,926
and closing the database as

1116
00:31:25,966 --> 0:31:26,276
needed.

1117
00:31:27,106 --> 0:31:28,486
Specifically I'll go back into

1118
00:31:28,486 --> 0:31:29,926
the disk usage detail view and

1119
00:31:30,576 --> 0:31:31,536
the first thing that I'd like to

1120
00:31:31,616 --> 0:31:33,246
point out is we're down from

1121
00:31:33,246 --> 0:31:35,526
1,002 physical I/O operations

1122
00:31:35,526 --> 0:31:37,736
down to 54 and we're down from

1123
00:31:37,736 --> 0:31:39,196
just under 6 megabytes of disk

1124
00:31:39,196 --> 0:31:41,976
footprint to 288 kilobytes which

1125
00:31:41,976 --> 0:31:43,336
is quite a significant win and

1126
00:31:43,336 --> 0:31:44,866
this was simply just by changing

1127
00:31:44,866 --> 0:31:46,686
the usage model of when we open

1128
00:31:46,686 --> 0:31:47,846
and close our database.

1129
00:31:49,306 --> 0:31:51,266
Furthermore, focusing again on

1130
00:31:51,266 --> 0:31:52,976
file system suggestions, we

1131
00:31:52,976 --> 0:31:54,636
started off with 12 in the

1132
00:31:54,636 --> 0:31:56,506
previous version of doing this

1133
00:31:57,886 --> 0:31:58,886
but now we're down to 3.

1134
00:31:59,356 --> 0:32:00,566
And while this still isn't the

1135
00:31:59,356 --> 0:32:00,566
And while this still isn't the

1136
00:32:00,566 --> 0:32:02,046
ideal case, we are making

1137
00:32:02,046 --> 0:32:02,586
progress.

1138
00:32:02,586 --> 0:32:03,776
And as we implement different

1139
00:32:03,776 --> 0:32:05,396
behavior such as journaling,

1140
00:32:05,396 --> 0:32:06,386
we'll see this number change.

1141
00:32:07,896 --> 0:32:09,536
Speaking of which, let's start

1142
00:32:09,536 --> 0:32:10,386
with Delete Mode Journaling.

1143
00:32:10,616 --> 0:32:11,566
Now as Kai mentioned, Delete

1144
00:32:11,566 --> 0:32:12,686
Mode Journaling is the default

1145
00:32:12,686 --> 0:32:15,126
for SQLite and so this

1146
00:32:15,126 --> 0:32:16,566
statistics page that I have here

1147
00:32:16,566 --> 0:32:17,966
is actually the same exact one

1148
00:32:17,966 --> 0:32:18,996
that I showed where we were

1149
00:32:18,996 --> 0:32:20,176
opening and closing the database

1150
00:32:20,176 --> 0:32:20,726
as needed.

1151
00:32:21,026 --> 0:32:22,866
So I won't show the entire trace

1152
00:32:22,866 --> 0:32:24,306
again but I do want to recall

1153
00:32:24,306 --> 0:32:24,796
the numbers.

1154
00:32:25,106 --> 0:32:26,716
54 physical I/O operations

1155
00:32:26,716 --> 0:32:28,196
totaling 288 kilobytes.

1156
00:32:31,046 --> 0:32:32,096
But when we switch to a model

1157
00:32:32,096 --> 0:32:33,306
that uses WAL Mode Journaling

1158
00:32:33,446 --> 0:32:34,186
there are some interesting

1159
00:32:34,186 --> 0:32:35,176
observations that I'd like to

1160
00:32:35,176 --> 0:32:36,206
point out.

1161
00:32:36,956 --> 0:32:38,576
First and foremost is that now

1162
00:32:38,576 --> 0:32:40,506
we have zero suggestions on the

1163
00:32:40,506 --> 0:32:41,716
file systems suggestions track.

1164
00:32:42,316 --> 0:32:44,026
We started at 12, ended up at 3,

1165
00:32:44,026 --> 0:32:45,306
and now we're at zero so this is

1166
00:32:45,356 --> 0:32:46,536
very significant gains that

1167
00:32:46,536 --> 0:32:48,276
we're making by simply adopting

1168
00:32:48,276 --> 0:32:49,126
the WAL Mode Journaling.

1169
00:32:50,326 --> 0:32:51,856
And secondly, this is the

1170
00:32:51,856 --> 0:32:53,246
interaction between the logical

1171
00:32:53,246 --> 0:32:54,406
and physical I/O that I'd also

1172
00:32:54,406 --> 0:32:54,996
like to point out.

1173
00:32:55,676 --> 0:32:57,346
Specifically, here in the file

1174
00:32:57,346 --> 0:32:58,976
system activity track we see a

1175
00:32:58,976 --> 0:33:00,636
lot of logical I/Os happening,

1176
00:32:58,976 --> 0:33:00,636
lot of logical I/Os happening,

1177
00:33:00,636 --> 0:33:02,916
but we don't get a physical I/O

1178
00:33:02,916 --> 0:33:04,516
until we stop the trace of the

1179
00:33:04,516 --> 0:33:05,136
application.

1180
00:33:05,786 --> 0:33:06,816
And why is this significant?

1181
00:33:07,296 --> 0:33:08,486
Well when we compare it to what

1182
00:33:08,486 --> 0:33:09,936
we had previously with the

1183
00:33:09,936 --> 0:33:12,706
Delete Mode Journaling, notice

1184
00:33:12,706 --> 0:33:13,666
how in Delete Mode Journaling

1185
00:33:13,666 --> 0:33:14,726
every time that we had file

1186
00:33:14,726 --> 0:33:16,436
system activity, so logical I/O,

1187
00:33:16,656 --> 0:33:17,786
we also had a corresponding

1188
00:33:17,786 --> 0:33:18,986
physical I/O to go with it.

1189
00:33:19,516 --> 0:33:20,766
Whereas with WAL Mode Journaling

1190
00:33:20,766 --> 0:33:22,256
it's making really great use of

1191
00:33:22,256 --> 0:33:23,496
the OS cache and getting us a

1192
00:33:23,496 --> 0:33:24,446
lot of great performance

1193
00:33:24,446 --> 0:33:25,246
benefits.

1194
00:33:26,476 --> 0:33:27,646
To see this in a little more

1195
00:33:27,646 --> 0:33:28,896
detail we can go into that file

1196
00:33:28,896 --> 0:33:30,616
system activity track again and

1197
00:33:30,616 --> 0:33:31,706
focus on the detail view.

1198
00:33:32,946 --> 0:33:34,216
With WAL Mode journaling we only

1199
00:33:34,216 --> 0:33:35,866
had a single fsync call whereas

1200
00:33:36,026 --> 0:33:37,426
with Delete Mode Journaling we

1201
00:33:37,426 --> 0:33:38,916
were all the way up to 16.

1202
00:33:39,746 --> 0:33:41,286
So WAL Mode is definitely making

1203
00:33:41,286 --> 0:33:42,796
a lot of great use of the OS

1204
00:33:42,796 --> 0:33:42,916
cache.

1205
00:33:46,416 --> 0:33:47,496
Now the next thing I'd like to

1206
00:33:47,496 --> 0:33:48,756
talk about is how we're going to

1207
00:33:48,756 --> 0:33:50,146
implement deleting of photos.

1208
00:33:50,146 --> 0:33:51,056
We talked about favoriting, but

1209
00:33:51,056 --> 0:33:52,126
we also want a way to remove

1210
00:33:52,126 --> 0:33:53,656
photos from the application.

1211
00:33:54,516 --> 0:33:55,736
And the first approach that

1212
00:33:55,736 --> 0:33:56,676
we'll talk about is actually

1213
00:33:56,676 --> 0:33:57,496
using what's called single

1214
00:33:57,496 --> 0:33:58,586
statement transactions and Kai

1215
00:33:58,586 --> 0:33:59,406
mentioned this as well.

1216
00:34:00,406 --> 0:34:01,526
Specifically, when we want to

1217
00:34:01,526 --> 0:34:02,786
select a photo for deletion,

1218
00:34:02,786 --> 0:34:03,736
we'll select the checkmark at

1219
00:34:03,736 --> 0:34:05,326
the bottom left corner, and

1220
00:34:05,326 --> 0:34:06,886
we'll issue a delete query to

1221
00:34:06,886 --> 0:34:08,085
the database.

1222
00:34:08,156 --> 0:34:09,016
Now we could think of this as a

1223
00:34:09,016 --> 0:34:10,186
single statement transaction

1224
00:34:10,186 --> 0:34:11,606
because we're executing this

1225
00:34:11,606 --> 0:34:13,366
delete query per photo and we're

1226
00:34:13,366 --> 0:34:14,856
not doing any sort of coalescing

1227
00:34:14,856 --> 0:34:17,485
on our own.

1228
00:34:17,746 --> 0:34:18,626
With this model here's the

1229
00:34:18,626 --> 0:34:19,726
single statement transaction

1230
00:34:19,726 --> 0:34:21,255
approach and we do have some

1231
00:34:21,255 --> 0:34:22,576
file system activity to point

1232
00:34:22,576 --> 0:34:23,856
out as well as some disk usage.

1233
00:34:24,596 --> 0:34:26,186
But one thing to focus on is

1234
00:34:26,186 --> 0:34:27,985
with this approach we had 111

1235
00:34:28,065 --> 0:34:29,446
different file system operations

1236
00:34:29,946 --> 0:34:32,565
and going over to the disk usage

1237
00:34:32,565 --> 0:34:34,856
track we had 12 writes for a

1238
00:34:34,856 --> 0:34:36,335
total of 72 kilobytes of total

1239
00:34:36,335 --> 0:34:36,726
footprint.

1240
00:34:37,096 --> 0:34:40,835
Next, I'd like to talk about

1241
00:34:40,835 --> 0:34:42,106
multiple statement transactions

1242
00:34:42,106 --> 0:34:43,556
and this is by taking the idea

1243
00:34:43,556 --> 0:34:45,166
that each of these photos, even

1244
00:34:45,166 --> 0:34:46,726
from a logical perspective, we

1245
00:34:46,726 --> 0:34:48,106
don't want to delete these

1246
00:34:48,106 --> 0:34:49,505
photos one at a time.

1247
00:34:49,536 --> 0:34:50,636
Logically we want to get them

1248
00:34:50,636 --> 0:34:52,456
all deleted at the same time and

1249
00:34:52,456 --> 0:34:53,585
we have an analog for this

1250
00:34:53,585 --> 0:34:55,545
within SQLite by merging all

1251
00:34:55,545 --> 0:34:56,876
these delete statements into one

1252
00:34:56,876 --> 0:34:57,456
transaction.

1253
00:34:57,736 --> 0:34:58,746
So we have multiple statements

1254
00:34:58,746 --> 0:34:59,626
in a single transaction.

1255
00:35:00,456 --> 0:35:02,586
And if we do this, we're down to

1256
00:35:02,586 --> 0:35:04,266
37 file system operations.

1257
00:35:04,266 --> 0:35:05,296
So we're doing significantly

1258
00:35:05,296 --> 0:35:07,616
less work but in addition to

1259
00:35:07,616 --> 0:35:09,146
that if we look at the disk

1260
00:35:09,146 --> 0:35:12,076
usage we're down to 4 total

1261
00:35:12,076 --> 0:35:14,046
writes and 24 kilobytes of

1262
00:35:14,046 --> 0:35:14,496
footprint.

1263
00:35:14,496 --> 0:35:17,596
Looking at these side by side,

1264
00:35:18,186 --> 0:35:19,856
we started with 111 for single

1265
00:35:19,856 --> 0:35:21,016
statement transactions of total

1266
00:35:21,016 --> 0:35:22,756
file system activity, we're down

1267
00:35:22,756 --> 0:35:24,656
to 37 with multiple statement

1268
00:35:24,656 --> 0:35:25,226
transactions.

1269
00:35:26,266 --> 0:35:27,056
And looking to how this

1270
00:35:27,056 --> 0:35:28,506
translates to actual physical

1271
00:35:28,506 --> 0:35:31,016
disk usage, we started at 12

1272
00:35:31,016 --> 0:35:33,316
writes totaling 72 kilobytes and

1273
00:35:33,316 --> 0:35:34,486
now we're down to 4 writes

1274
00:35:34,486 --> 0:35:35,816
totaling 24 kilobytes with

1275
00:35:35,816 --> 0:35:36,966
multiple statement transactions.

1276
00:35:37,226 --> 0:35:40,006
And while we're on the topic of

1277
00:35:40,006 --> 0:35:41,596
deleting, we should also mention

1278
00:35:41,596 --> 0:35:42,606
vacuuming because we want to

1279
00:35:42,606 --> 0:35:44,046
keep our database compressed or,

1280
00:35:44,126 --> 0:35:45,236
you know, compact as possible.

1281
00:35:45,926 --> 0:35:46,966
And we'll start off with a full

1282
00:35:46,966 --> 0:35:47,416
vacuum.

1283
00:35:47,956 --> 0:35:49,036
In this case we'll be issuing a

1284
00:35:49,036 --> 0:35:50,726
vacuum statement every time that

1285
00:35:50,726 --> 0:35:51,566
we issue a delete.

1286
00:35:52,116 --> 0:35:53,166
And Kai told us that full

1287
00:35:53,166 --> 0:35:54,916
vacuuming isn't the most optimal

1288
00:35:54,916 --> 0:35:56,316
way of doing it, but we can see

1289
00:35:56,316 --> 0:35:57,586
how this exactly works within

1290
00:35:57,586 --> 0:35:58,696
the File Activity instrument.

1291
00:35:59,756 --> 0:36:01,896
Specifically, by doing this we

1292
00:35:59,756 --> 0:36:01,896
Specifically, by doing this we

1293
00:36:01,896 --> 0:36:04,116
have a total of 27 different I/O

1294
00:36:04,116 --> 0:36:05,766
operations totaling 168

1295
00:36:05,766 --> 0:36:06,796
kilobytes by issuing a full

1296
00:36:06,796 --> 0:36:10,476
vacuum, but if we switch this

1297
00:36:10,476 --> 0:36:11,956
over to using incremental

1298
00:36:11,956 --> 0:36:14,206
vacuum, we have some different

1299
00:36:14,206 --> 0:36:14,776
numbers.

1300
00:36:15,356 --> 0:36:17,416
We have 12 total I/O operations

1301
00:36:17,496 --> 0:36:18,926
for 72 kilobytes of total

1302
00:36:18,926 --> 0:36:19,336
footprint.

1303
00:36:22,556 --> 0:36:23,616
Again, looking at these side by

1304
00:36:23,616 --> 0:36:26,256
side, we're down from 27 I/O

1305
00:36:26,256 --> 0:36:27,556
operations with a full vacuum

1306
00:36:27,656 --> 0:36:29,216
down to 12 by using incremental

1307
00:36:29,216 --> 0:36:32,566
vacuum and from 168K of total

1308
00:36:32,566 --> 0:36:34,216
disk footprint for the full

1309
00:36:34,216 --> 0:36:35,296
vacuum down to 72.

1310
00:36:35,296 --> 0:36:37,166
So it's pretty significant gains

1311
00:36:37,166 --> 0:36:38,226
that we're making by adopting

1312
00:36:38,226 --> 0:36:39,296
these sorts of patterns within

1313
00:36:39,326 --> 0:36:39,736
SQLite.

1314
00:36:43,916 --> 0:36:45,126
So what I'd like to do now is

1315
00:36:45,126 --> 0:36:46,826
sort of summarize and one of the

1316
00:36:46,826 --> 0:36:48,636
first points is we want you to

1317
00:36:48,636 --> 0:36:49,746
apply these lessons, whether

1318
00:36:49,746 --> 0:36:51,936
you're using Core Data or SQLite

1319
00:36:51,936 --> 0:36:53,476
or plist and so forth, we want

1320
00:36:53,476 --> 0:36:55,336
you to apply these lessons but

1321
00:36:55,336 --> 0:36:56,166
don't just apply them.

1322
00:36:56,166 --> 0:36:57,886
We also want you to verify them

1323
00:36:57,916 --> 0:36:58,736
with the File Activity

1324
00:36:58,736 --> 0:36:59,146
instrument.

1325
00:36:59,666 --> 0:37:00,676
Now the File Activity instrument

1326
00:36:59,666 --> 0:37:00,676
Now the File Activity instrument

1327
00:37:00,676 --> 0:37:01,826
may be able to help you by

1328
00:37:01,826 --> 0:37:03,606
proving these points but also

1329
00:37:03,606 --> 0:37:04,396
you may have some other

1330
00:37:04,396 --> 0:37:05,626
suggestions that you don't even

1331
00:37:05,626 --> 0:37:06,886
know about and perhaps the File

1332
00:37:06,886 --> 0:37:08,286
Activity instrument can help

1333
00:37:08,286 --> 0:37:09,586
bring those into vision for you

1334
00:37:09,586 --> 0:37:10,496
and help you notice them.

1335
00:37:12,146 --> 0:37:14,066
And with that in mind, we also

1336
00:37:14,066 --> 0:37:15,116
want you to continue optimizing

1337
00:37:15,116 --> 0:37:15,546
storage.

1338
00:37:15,886 --> 0:37:17,336
There's a lot more than just

1339
00:37:17,336 --> 0:37:18,436
meets the eye and we hope that

1340
00:37:18,436 --> 0:37:19,406
with these lessons and with the

1341
00:37:19,406 --> 0:37:20,746
tools that we're providing it

1342
00:37:20,746 --> 0:37:21,896
could be a great experience for

1343
00:37:21,896 --> 0:37:22,196
everyone.

1344
00:37:24,516 --> 0:37:25,546
For more information we have a

1345
00:37:25,546 --> 0:37:27,226
lab later on today for

1346
00:37:27,226 --> 0:37:28,716
performance and we also had a

1347
00:37:28,716 --> 0:37:30,866
session this year at WWDC '19

1348
00:37:31,116 --> 0:37:32,256
for making apps with Core Data

1349
00:37:32,256 --> 0:37:33,106
if you'd like to learn a little

1350
00:37:33,106 --> 0:37:34,486
bit more about how exactly to

1351
00:37:34,486 --> 0:37:34,976
adopt this.

1352
00:37:37,376 --> 0:37:38,326
Thank you everyone for

1353
00:37:38,326 --> 0:37:38,676
attending.

1354
00:37:38,676 --> 0:37:39,626
Enjoy the rest of the session.

1355
00:37:40,516 --> 0:37:43,500
[ Applause ]
