1
00:00:07,007 --> 0:00:11,945
（提交优化的Metal app

2
00:00:15,582 --> 0:00:17,251
早上好 欢迎大家来参加演讲

3
00:00:17,317 --> 0:00:20,587
我是Guillem Vinals Gangolells

4
00:00:21,054 --> 0:00:24,291
去年我们和许多游戏开发人员

5
00:00:24,525 --> 0:00:26,527
并认识到了一些常见问题

6
00:00:26,860 --> 0:00:29,930
结果是我们决定把它们放在一起

7
00:00:30,430 --> 0:00:34,168
今天我总共会讲18个最佳实践

8
00:00:34,234 --> 0:00:35,936
帮助你改善你的Metal app

9
00:00:37,471 --> 0:00:40,707
请注意 我不会展示一些不错的范例

10
00:00:41,508 --> 0:00:43,610
或可接受的范例

11
00:00:44,211 --> 0:00:48,081
非常肯定不是那些能迎刃而解的范例

12
00:00:49,049 --> 0:00:52,519
今天的主要内容是关于

13
00:00:52,586 --> 0:00:53,820
请按照最佳实践去做

14
00:00:53,887 --> 0:00:55,923
（Metal最佳实践）

15
00:00:55,989 --> 0:00:57,024
在我们开始之前

16
00:00:57,090 --> 0:00:59,793
我想感谢来自

17
00:00:59,860 --> 0:01:02,129
Digital Legends

18
00:00:59,860 --> 0:01:02,129
Digital Legends

19
00:01:02,496 --> 0:01:04,864
他们开发了Afterpulse

20
00:01:05,232 --> 0:01:08,068
Afterpulse

21
00:01:08,402 --> 0:01:12,339
它使用了许多渲染技术

22
00:01:12,406 --> 0:01:14,208
功能完备的延迟渲染

23
00:01:14,474 --> 0:01:17,477
以及后置处理

24
00:01:18,345 --> 0:01:20,948
我们将在本场演讲中 全程使用

25
00:01:21,014 --> 0:01:23,984
用于演示我们的工具

26
00:01:24,051 --> 0:01:25,118
（Afterpulse

27
00:01:25,185 --> 0:01:27,487
我们把这场演讲分为三个部分

28
00:01:27,821 --> 0:01:29,056
通用性能

29
00:01:29,590 --> 0:01:30,724
内存带宽

30
00:01:31,258 --> 0:01:32,492
和内存占用

31
00:01:33,026 --> 0:01:36,096
让我们从通用性能开始讲

32
00:01:36,163 --> 0:01:40,000
（通用性能）

33
00:01:40,067 --> 0:01:40,934
在这部分中

34
00:01:41,001 --> 0:01:44,171
我会讲选择正确的分辨率

35
00:01:44,605 --> 0:01:45,639
避免过度绘制

36
00:01:45,706 --> 0:01:49,176
减少所写入的每个像素的

37
00:01:49,877 --> 0:01:53,146
我们还会讲GPU提交、资源传输

38
00:01:53,213 --> 0:01:54,882
以及热感

39
00:01:54,948 --> 0:01:55,883
（最佳实践）

40
00:01:55,949 --> 0:01:58,285
让我们开始讲第一个最佳实践

41
00:01:58,552 --> 0:02:00,020
选择正确的分辨率

42
00:01:58,552 --> 0:02:00,020
选择正确的分辨率

43
00:02:00,988 --> 0:02:04,925
请注意你游戏中的每个效果

44
00:02:05,325 --> 0:02:07,794
因此考虑每个分辨率的图片品质

45
00:02:07,861 --> 0:02:10,597
和性能权衡非常重要

46
00:02:10,663 --> 0:02:12,165
并谨慎选择

47
00:02:12,599 --> 0:02:17,871
同时以原生分辨率

48
00:02:18,172 --> 0:02:21,308
从而使UI看起来清晰

49
00:02:22,609 --> 0:02:25,579
我们可以用Metal帧调试器

50
00:02:26,647 --> 0:02:30,350
在Metal帧调试器内

51
00:02:30,651 --> 0:02:32,986
它会显示每个渲染通道的图表

52
00:02:33,453 --> 0:02:36,390
在这个例子中

53
00:02:37,191 --> 0:02:40,127
要获取依存查看器

54
00:02:41,962 --> 0:02:43,597
在这个例子中 你可以看到

55
00:02:43,664 --> 0:02:47,267
这个示例Metal app

56
00:02:47,334 --> 0:02:49,336
分辨率都不同

57
00:02:49,903 --> 0:02:52,706
比如阴影映射和SSAO

58
00:02:52,773 --> 0:02:55,275
与主光通道的分辨率不同

59
00:02:55,742 --> 0:02:58,378
同时UI由原生分辨率合成

60
00:02:58,445 --> 0:02:59,646
因此它总是看起来很尖锐

61
00:03:00,647 --> 0:03:02,115
这些分辨率看起来不错

62
00:03:02,516 --> 0:03:05,085
对于这个Metal app来说

63
00:03:05,152 --> 0:03:08,222
我们希望你能在做你的游戏时

64
00:03:08,922 --> 0:03:11,258
让我们继续看第二个最佳实践

65
00:03:12,259 --> 0:03:14,261
最小化不透明过度绘制

66
00:03:15,062 --> 0:03:17,698
过度绘制是片段着色器

67
00:03:17,764 --> 0:03:19,099
对每个写入的像素的处理次数

68
00:03:19,666 --> 0:03:23,504
iOS GPU极其擅长减少

69
00:03:23,570 --> 0:03:25,305
我们只需要提供一丁点帮助

70
00:03:26,640 --> 0:03:29,843
这里的最佳实践是

71
00:03:30,143 --> 0:03:31,912
稍后渲染半透明网格

72
00:03:32,312 --> 0:03:36,350
同时不要渲染全透明或不可见的网格

73
00:03:37,184 --> 0:03:40,254
我们将再次使用Metal帧调试器

74
00:03:40,621 --> 0:03:43,891
这一次我们将查看GPU计数器

75
00:03:43,957 --> 0:03:46,660
用于验证指定渲染通道的过度绘制

76
00:03:47,261 --> 0:03:49,363
我们聚焦于

77
00:03:49,429 --> 0:03:51,131
主光通道

78
00:03:52,332 --> 0:03:54,201
为了计算过度绘制

79
00:03:54,501 --> 0:03:56,937
我们将用片段着色器调用次数

80
00:03:57,004 --> 0:03:59,072
除以像素存储器数量

81
00:03:59,506 --> 0:04:01,208
我们可以使用底部的筛选条

82
00:03:59,506 --> 0:04:01,208
我们可以使用底部的筛选条

83
00:04:01,275 --> 0:04:03,944
迅速查找我们所寻求的性能计数器

84
00:04:05,579 --> 0:04:09,483
在这个例子中是全透明情境

85
00:04:09,550 --> 0:04:11,652
没有过度绘制 我们准备好继续了

86
00:04:11,952 --> 0:04:14,655
我们也要求你们在你的游戏中

87
00:04:14,721 --> 0:04:16,690
并验证你也准备好继续了

88
00:04:17,624 --> 0:04:19,927
那么让我们继续讲下一个最佳实践

89
00:04:21,862 --> 0:04:23,664
提早提交GPU工作

90
00:04:26,133 --> 0:04:30,037
提早安排好后台GPU工作非常重要

91
00:04:30,103 --> 0:04:33,173
它将改善游戏的延迟性和响应性

92
00:04:33,240 --> 0:04:36,810
并允许系统更好地适应工作量

93
00:04:37,444 --> 0:04:40,180
因此 在帧中拥有多个GPU提交

94
00:04:40,247 --> 0:04:41,215
非常重要

95
00:04:41,481 --> 0:04:44,852
特别是你要在获得可绘制物之前

96
00:04:44,918 --> 0:04:49,723
并且有些可绘制物会拖延渲染

97
00:04:50,390 --> 0:04:52,359
当你在帧中获得可绘制物之后

98
00:04:52,426 --> 0:04:54,761
最好是尽可能晚的获得它们

99
00:04:54,828 --> 0:04:58,031
然后你就会出现延迟GPU提交

100
00:04:58,098 --> 0:05:00,300
你需要安排好所有前台工作

101
00:04:58,098 --> 0:05:00,300
你需要安排好所有前台工作

102
00:05:00,367 --> 0:05:02,469
潜在的有UI合成通道

103
00:05:03,470 --> 0:05:06,306
因为要解释这个问题有点棘手

104
00:05:06,707 --> 0:05:07,941
因此让我们快速看一个演示

105
00:05:08,008 --> 0:05:10,978
我会告诉你如何用Metal

106
00:05:11,044 --> 0:05:12,212
（演示）

107
00:05:13,981 --> 0:05:14,815
很酷

108
00:05:15,082 --> 0:05:17,918
我们在这里看到的是

109
00:05:17,985 --> 0:05:21,321
是我们去年在老版游戏上捕捉到的

110
00:05:21,655 --> 0:05:24,291
这是用游戏性能模板捕捉到的

111
00:05:24,591 --> 0:05:26,493
我们去年引入了这个模板

112
00:05:26,760 --> 0:05:29,663
因此你已经熟悉其中一些工具了

113
00:05:29,963 --> 0:05:32,299
今年我们新添加了热状态

114
00:05:32,566 --> 0:05:34,601
以及Metal资源分配

115
00:05:34,668 --> 0:05:36,270
我们稍后会讲到这个

116
00:05:36,803 --> 0:05:41,041
现在我们主要讲潜在的问题

117
00:05:41,375 --> 0:05:43,644
在这个例子中我们想查看显示面板

118
00:05:43,710 --> 0:05:46,947
并了解底部是否有大量事件

119
00:05:47,014 --> 0:05:50,484
界面显示在前台的时间

120
00:05:50,551 --> 0:05:52,786
那么也许这是个问题

121
00:05:53,120 --> 0:05:56,023
我们要做的就是进入其中一个区域

122
00:05:56,089 --> 0:05:58,325
按住“选项”键

123
00:05:58,959 --> 0:06:02,062
并在这个区域上拖动游标

124
00:05:58,959 --> 0:06:02,062
并在这个区域上拖动游标

125
00:06:03,363 --> 0:06:07,234
那么在这个例子中

126
00:06:07,301 --> 0:06:10,470
看起来比预期的要晚

127
00:06:11,171 --> 0:06:14,441
同时GPU有很长时间都处于

128
00:06:14,775 --> 0:06:17,177
那可能就是导致

129
00:06:17,244 --> 0:06:18,345
我们正在尝试调试的问题的原因

130
00:06:18,412 --> 0:06:20,013
那么让我们具体看一下

131
00:06:20,614 --> 0:06:24,318
我们通过披露你已经熟悉的

132
00:06:24,384 --> 0:06:26,420
Metal系统追踪中的

133
00:06:26,954 --> 0:06:32,226
我们在这里所看到的是

134
00:06:32,292 --> 0:06:34,995
以及GPU如何处理这个工作

135
00:06:35,262 --> 0:06:37,264
让我们聚焦于这个橘色帧

136
00:06:37,764 --> 0:06:38,632
正如你在这里所看到的

137
00:06:38,699 --> 0:06:41,401
app编码了大量工作

138
00:06:41,468 --> 0:06:44,104
因此我们有阴影映像、延迟通道

139
00:06:44,671 --> 0:06:47,007
以及部分全屏反光链等等

140
00:06:47,474 --> 0:06:48,308
因此…

141
00:06:48,809 --> 0:06:51,345
GPU实际上并没有处理那个工作

142
00:06:51,612 --> 0:06:53,046
同时

143
00:06:53,347 --> 0:06:56,083
可绘制物正在出现危机

144
00:06:56,149 --> 0:06:58,252
因此这就是导致这个

145
00:06:58,685 --> 0:07:02,422
但我们已经编码了一些工作

146
00:06:58,685 --> 0:07:02,422
但我们已经编码了一些工作

147
00:07:03,190 --> 0:07:05,259
这就是最佳实践

148
00:07:05,692 --> 0:07:08,061
你在获得可绘制物之前

149
00:07:08,128 --> 0:07:11,532
提交全部提前编码的后台工作

150
00:07:11,865 --> 0:07:14,935
因此 方案是执行一次GPU提交

151
00:07:15,269 --> 0:07:17,371
请注意只有一次GPU提交

152
00:07:17,437 --> 0:07:20,240
我们可以从这里的帧末端看到

153
00:07:20,307 --> 0:07:23,277
所有GPU工作都发生在最后

154
00:07:24,444 --> 0:07:27,614
谢天谢地 这个很容易解决

155
00:07:27,681 --> 0:07:30,250
Digital Legends

156
00:07:30,317 --> 0:07:33,687
让我们看看Afterpulse

157
00:07:34,855 --> 0:07:36,723
好的 那么 让我们具体来看

158
00:07:37,524 --> 0:07:40,594
在这个例子中

159
00:07:40,661 --> 0:07:42,329
当我们正在等待获得可绘制物时

160
00:07:42,829 --> 0:07:44,998
因此让我们披露

161
00:07:45,065 --> 0:07:46,233
正如我们之前所做的那样

162
00:07:47,201 --> 0:07:49,536
在这个例子中 我们可以看到GPU

163
00:07:49,903 --> 0:07:52,940
正在处理我们在获得可绘制物之前

164
00:07:53,507 --> 0:07:55,642
安排好的工作

165
00:07:56,310 --> 0:07:59,713
因此在这个例子中 闲置时间较少

166
00:07:59,780 --> 0:08:02,983
因此这就允许系统

167
00:07:59,780 --> 0:08:02,983
因此这就允许系统

168
00:08:03,283 --> 0:08:04,785
并且不会出现任何问题

169
00:08:05,953 --> 0:08:08,388
做完这个操作之后

170
00:08:08,655 --> 0:08:12,559
并且我们已经拥有多个GPU提交

171
00:08:12,960 --> 0:08:14,228
并且不会导致任何拖延

172
00:08:14,294 --> 0:08:16,496
因为我们在等待获取可绘制物之前

173
00:08:16,563 --> 0:08:17,931
让我们返回到幻灯片中

174
00:08:17,998 --> 0:08:19,166
（演示）

175
00:08:19,733 --> 0:08:22,569
好的 修复那个问题其实非常简单

176
00:08:22,636 --> 0:08:25,339
比解释这个问题简单多了

177
00:08:25,906 --> 0:08:26,907
我们要做的就是

178
00:08:26,974 --> 0:08:29,843
简单地给每个帧

179
00:08:30,344 --> 0:08:32,479
因此我们首先要创建命令缓冲区

180
00:08:32,546 --> 0:08:37,618
来编码所有后台工作

181
00:08:37,683 --> 0:08:42,054
我们将委托命令缓冲区

182
00:08:42,121 --> 0:08:43,624
那将会拖延我们的线程

183
00:08:44,558 --> 0:08:48,896
在我们获得可绘制物之后

184
00:08:48,962 --> 0:08:51,365
我们将在命令缓冲区中

185
00:08:51,431 --> 0:08:52,833
并呈现可绘制物

186
00:08:53,467 --> 0:08:56,737
这将作为最后一次GPU提交

187
00:08:57,271 --> 0:08:59,606
并且这还将确保帧的工作流程

188
00:08:59,673 --> 0:09:01,375
真的足够好

189
00:08:59,673 --> 0:09:01,375
真的足够好

190
00:09:02,976 --> 0:09:05,946
就那么简单

191
00:09:06,480 --> 0:09:08,849
让我们继续看第四个最佳实践：

192
00:09:09,316 --> 0:09:11,118
高效地传输资源

193
00:09:11,785 --> 0:09:14,054
资源分配真的很占时间

194
00:09:14,454 --> 0:09:16,757
并且从渲染线程中传输资源

195
00:09:16,823 --> 0:09:18,025
可能会导致拖延

196
00:09:18,358 --> 0:09:21,094
因此 这里的最佳实践是考虑内存

197
00:09:21,161 --> 0:09:24,665
和资源传输算法的性能权衡

198
00:09:24,965 --> 0:09:28,602
并确保你在启动时分配并加载

199
00:09:28,669 --> 0:09:31,305
因为你不需要在运行时分配它们

200
00:09:31,905 --> 0:09:34,775
任何需要在运行时传输的资源

201
00:09:34,842 --> 0:09:37,411
请一定要在专用线程上这样做

202
00:09:37,744 --> 0:09:41,048
这样做可以避免拖延 这非常重要

203
00:09:42,049 --> 0:09:44,284
我们稍后再重新讲资源传输

204
00:09:44,351 --> 0:09:46,286
在内存占用部分

205
00:09:46,353 --> 0:09:49,089
以及重新评估内存和性能权衡

206
00:09:49,656 --> 0:09:53,760
现在 让我们使用Metal

207
00:09:54,494 --> 0:09:57,197
今年我们新增加了分配追踪

208
00:09:57,464 --> 0:10:00,334
那会为你显示每一个

209
00:09:57,464 --> 0:10:00,334
那会为你显示每一个

210
00:10:00,400 --> 0:10:04,371
以及同一时间线上

211
00:10:04,872 --> 0:10:07,474
这将允许你识别

212
00:10:07,541 --> 0:10:10,010
从主渲染线程上传输的

213
00:10:10,077 --> 0:10:11,945
所有可能导致拖延的资源

214
00:10:12,012 --> 0:10:13,614
（Metal系统追踪）

215
00:10:13,680 --> 0:10:16,984
还有一个应该调整的东西即热感

216
00:10:17,351 --> 0:10:21,088
这对于保持游戏的持久性能来说

217
00:10:21,154 --> 0:10:23,991
这会改善系统的整体温度

218
00:10:24,057 --> 0:10:26,960
以及游戏的稳定性和响应性

219
00:10:27,494 --> 0:10:30,664
最佳实践就是在严峻的热状态下

220
00:10:30,731 --> 0:10:32,399
测试游戏

221
00:10:32,866 --> 0:10:36,637
同时考虑针对这种严峻的热状态

222
00:10:36,703 --> 0:10:40,440
因为那很有可能会帮助你了解热节流

223
00:10:40,507 --> 0:10:41,875
（最佳实践）

224
00:10:41,942 --> 0:10:46,380
今年我们在Xcode中新增加了

225
00:10:46,446 --> 0:10:49,283
那将允许你直接从设备的窗口中

226
00:10:49,616 --> 0:10:51,685
设置严峻的热状态

227
00:10:52,586 --> 0:10:54,054
在底部有一场演讲

228
00:10:54,121 --> 0:10:56,223
我们将具体讲这个话题

229
00:10:56,290 --> 0:10:57,791
我建议你们来参加

230
00:10:57,858 --> 0:10:59,026
（设备状况）

231
00:10:59,893 --> 0:11:02,429
我们还可以使用Xcode能量计

232
00:10:59,893 --> 0:11:02,429
我们还可以使用Xcode能量计

233
00:11:02,496 --> 0:11:05,432
来验证设备运行时所处的热状态

234
00:11:05,966 --> 0:11:06,834
在这个例子中

235
00:11:06,900 --> 0:11:10,003
我们让设备处于严峻的热状态下运行

236
00:11:10,370 --> 0:11:11,839
并且我们有效地验证了

237
00:11:11,905 --> 0:11:14,374
设备正在陷入严峻的热状态

238
00:11:14,441 --> 0:11:16,944
只需要数秒钟就可以

239
00:11:17,010 --> 0:11:17,845
（Xcode能量计）

240
00:11:17,911 --> 0:11:21,081
很酷 现在让我们继续

241
00:11:21,815 --> 0:11:24,751
在这个部分中 我们会讲内存带宽

242
00:11:24,818 --> 0:11:26,220
（内存带宽）

243
00:11:27,020 --> 0:11:28,989
内存带宽非常重要

244
00:11:29,256 --> 0:11:31,859
那是因为内存传输非常昂贵

245
00:11:32,159 --> 0:11:34,428
它们消耗能量并产生热量

246
00:11:35,195 --> 0:11:36,663
为了帮助减轻这种现象

247
00:11:36,930 --> 0:11:41,201
iOS设备在CPU和GPU之间

248
00:11:41,502 --> 0:11:44,671
以及GPU专用的

249
00:11:45,339 --> 0:11:48,475
Metal会帮助你对两者进行平衡

250
00:11:49,009 --> 0:11:52,379
因此现在让我们从纹理开始看起

251
00:11:52,446 --> 0:11:53,313
（纹理）

252
00:11:53,380 --> 0:11:56,683
纹理采样很可能是游戏中

253
00:11:56,750 --> 0:11:57,651
主要消耗带宽的功能

254
00:11:57,951 --> 0:12:01,655
因此我们有一些最佳实践

255
00:11:57,951 --> 0:12:01,655
因此我们有一些最佳实践

256
00:12:02,389 --> 0:12:03,223
在这个部分中

257
00:12:03,290 --> 0:12:06,627
我们要讲游戏资产的离线纹理压缩

258
00:12:06,994 --> 0:12:08,896
GPU纹理压缩

259
00:12:08,962 --> 0:12:11,498
以及如何选择正确的像素格式

260
00:12:11,932 --> 0:12:13,667
让我们从纹理资产开始讲

261
00:12:13,734 --> 0:12:15,269
（最佳实践）

262
00:12:15,335 --> 0:12:18,372
压缩纹理资产非常重要

263
00:12:18,839 --> 0:12:22,809
那是因为大纹理的采样效率可能很低

264
00:12:22,876 --> 0:12:25,312
并且资产可能也是任意大

265
00:12:25,712 --> 0:12:27,614
因此确保它们都被压缩了

266
00:12:27,881 --> 0:12:28,882
并且

267
00:12:28,949 --> 0:12:32,286
还为所有可能被缩小了的纹理

268
00:12:32,986 --> 0:12:35,756
让我们看一下纹理压缩如何节约内存

269
00:12:35,822 --> 0:12:37,024
（纹理压缩的内存节约）

270
00:12:37,090 --> 0:12:39,826
这是Afterpulse

271
00:12:40,460 --> 0:12:43,263
如果我们不压缩这个纹理

272
00:12:43,664 --> 0:12:46,767
它可能需要占用16MB的内存

273
00:12:47,801 --> 0:12:51,371
通过使用纹理压缩

274
00:12:51,438 --> 0:12:55,375
小于3MB 包含完整的纹理映射链

275
00:12:55,876 --> 0:12:57,711
那极大地节约了内存

276
00:12:58,512 --> 0:13:01,982
但请注意 Afterpulse

277
00:12:58,512 --> 0:13:01,982
但请注意 Afterpulse

278
00:13:02,049 --> 0:13:06,320
因为它在A7设备上运行

279
00:13:07,054 --> 0:13:10,691
如果你的游戏投放范围是

280
00:13:10,757 --> 0:13:14,027
因为它在图片品质方面

281
00:13:15,195 --> 0:13:17,865
为了验证我们的资产是否进行了

282
00:13:18,165 --> 0:13:20,000
我们可以使用内存查看器

283
00:13:20,067 --> 0:13:20,968
（Metal内存查看器）

284
00:13:21,034 --> 0:13:22,870
Metal内存查看器

285
00:13:22,936 --> 0:13:25,772
我将在内存占用部分

286
00:13:26,139 --> 0:13:30,310
现在我们要用它来检验

287
00:13:30,577 --> 0:13:34,448
我们可以双重检验它们是否被压缩、

288
00:13:36,216 --> 0:13:41,655
但对于那些不能提前压缩的纹理来说

289
00:13:42,122 --> 0:13:45,959
比如渲染目标或运行时

290
00:13:46,026 --> 0:13:47,427
（无损耗纹理压缩）

291
00:13:47,494 --> 0:13:50,797
最新的iOS GPU

292
00:13:51,131 --> 0:13:54,268
允许GPU压缩纹理

293
00:13:55,569 --> 0:13:58,872
因此 下一个最佳实践是优化纹理

294
00:13:58,939 --> 0:14:00,974
从而GPU可以拥有较快的访问速度

295
00:13:58,939 --> 0:14:00,974
从而GPU可以拥有较快的访问速度

296
00:14:01,642 --> 0:14:04,711
正确地配置纹理非常重要

297
00:14:05,078 --> 0:14:07,514
你可以使用私有存储模式

298
00:14:07,581 --> 0:14:10,517
因此只有GPU拥有

299
00:14:10,584 --> 0:14:12,853
并允许它对内容进行优化

300
00:14:12,920 --> 0:14:15,889
同时 不要设置未知的使用标志

301
00:14:15,956 --> 0:14:20,460
并避免设置不必要的使用标志

302
00:14:20,727 --> 0:14:23,130
因为那些可能会禁用压缩功能

303
00:14:23,197 --> 0:14:24,231
（最佳实践）

304
00:14:24,298 --> 0:14:27,968
可通过CPU和GPU

305
00:14:28,268 --> 0:14:32,906
应该当每次CPU升级数据后

306
00:14:32,973 --> 0:14:34,908
这也非常重要

307
00:14:35,175 --> 0:14:38,011
让我们看看如何用几行代码

308
00:14:38,812 --> 0:14:40,781
真的只需要几行代码

309
00:14:41,048 --> 0:14:42,916
要创建最优纹理

310
00:14:42,983 --> 0:14:45,185
我们要把存储模式设为私有

311
00:14:45,252 --> 0:14:47,321
因此只有GPU有访问权限

312
00:14:48,255 --> 0:14:53,694
并且我们要设置

313
00:14:54,728 --> 0:14:57,998
在这个例子中

314
00:14:58,065 --> 0:15:00,133
从而我们不需要任何其它使用标志

315
00:14:58,065 --> 0:15:00,133
从而我们不需要任何其它使用标志

316
00:15:01,702 --> 0:15:03,237
但对于共享纹理来说怎么样呢？

317
00:15:03,971 --> 0:15:05,372
嗯 那更加棘手

318
00:15:05,706 --> 0:15:09,776
因此 CPU和GPU可共同访问

319
00:15:10,377 --> 0:15:13,614
因此如果CPU更新了纹理的一部分

320
00:15:13,680 --> 0:15:15,315
或任何纹理数据

321
00:15:16,216 --> 0:15:20,487
我们可能需要明确要求GPU

322
00:15:21,021 --> 0:15:22,523
请注意这里有一个权衡

323
00:15:22,589 --> 0:15:25,459
在CPU更新数据的次数

324
00:15:25,526 --> 0:15:28,662
和GPU稍后需要访问它的次数之间

325
00:15:30,597 --> 0:15:33,634
内存查看器实际上是一个很好的工具

326
00:15:33,700 --> 0:15:34,968
它可以帮助我们解决这个问题

327
00:15:35,369 --> 0:15:38,372
那是因为我们可以配置内存查看器

328
00:15:38,438 --> 0:15:42,075
使其显示所有纹理的存储模式

329
00:15:42,543 --> 0:15:46,113
从这一个屏幕上我们可以看到

330
00:15:46,180 --> 0:15:49,783
并识别所有纹理的配置都正确

331
00:15:50,417 --> 0:15:51,552
它是个很棒的工具

332
00:15:52,519 --> 0:15:56,056
从这点上来说我们几乎已经完成了

333
00:15:56,523 --> 0:15:59,126
我们只需选择正确的像素格式即可

334
00:16:00,360 --> 0:16:03,130
较大的像素格式使用较多的带宽

335
00:16:03,197 --> 0:16:05,132
因此最佳实践就是

336
00:16:05,399 --> 0:16:08,502
避免使用带有不必要频道的像素格式

337
00:16:08,802 --> 0:16:11,605
并尽可能尝试降低精度

338
00:16:12,673 --> 0:16:14,808
但请注意 采样率自身

339
00:16:14,875 --> 0:16:17,377
也取决于像素格式

340
00:16:18,145 --> 0:16:21,348
在这个例子中

341
00:16:21,415 --> 0:16:23,984
直接影响

342
00:16:24,051 --> 0:16:25,185
GPU的纹理采样率

343
00:16:25,619 --> 0:16:30,858
你要特别注意128位格式

344
00:16:30,924 --> 0:16:35,495
比如RGBA 32位浮点型 因为

345
00:16:36,129 --> 0:16:40,100
这些高精度格式经常用于噪音纹理

346
00:16:40,167 --> 0:16:42,769
或为后处理效果查找表

347
00:16:44,404 --> 0:16:47,541
再一次 我们可以使用内存观察器

348
00:16:48,108 --> 0:16:50,277
内存观察器将允许我们

349
00:16:50,344 --> 0:16:52,045
按名称或像素格式筛选纹理

350
00:16:52,713 --> 0:16:57,050
因此我们将验证

351
00:16:57,117 --> 0:16:58,952
对SSAO实施使用了16位格式

352
00:16:59,520 --> 0:17:01,989
这对于噪音纹理来说非常重要

353
00:16:59,520 --> 0:17:01,989
这对于噪音纹理来说非常重要

354
00:17:02,055 --> 0:17:02,956
（Metal内存观察器）

355
00:17:03,023 --> 0:17:04,391
还有一点要注意

356
00:17:05,157 --> 0:17:06,859
在这个例子中

357
00:17:07,227 --> 0:17:09,930
绝大多数纹理实际上是渲染目标

358
00:17:10,696 --> 0:17:14,667
因此随着游戏变得越来越复杂

359
00:17:14,734 --> 0:17:17,538
实际上可能会消耗大量带宽

360
00:17:17,604 --> 0:17:19,071
让我们具体看一下

361
00:17:20,574 --> 0:17:23,810
在这个部分中 我们将回顾

362
00:17:24,178 --> 0:17:28,916
密切关注MSAA并稍微提一下

363
00:17:29,883 --> 0:17:33,220
让我们从优化加载和存储操作开始讲

364
00:17:34,888 --> 0:17:38,625
你应该避免加载或存储

365
00:17:39,359 --> 0:17:42,863
渲染目标加载和存储操作

366
00:17:42,930 --> 0:17:45,566
但可能很快就会成为一个问题

367
00:17:45,999 --> 0:17:48,869
请一定要检查它们

368
00:17:49,536 --> 0:17:51,438
实际上很简单

369
00:17:51,505 --> 0:17:53,740
只需要几行代码

370
00:17:54,474 --> 0:17:57,444
在这个例子中

371
00:17:57,511 --> 0:18:00,113
我们希望那个颜色缓冲区是临时的

372
00:17:57,511 --> 0:18:00,113
我们希望那个颜色缓冲区是临时的

373
00:18:00,180 --> 0:18:02,916
意思就是我们不想从它里头

374
00:18:03,383 --> 0:18:07,354
它与设置正确的加载和存储操作

375
00:18:07,688 --> 0:18:11,391
我们希望加载操作明确

376
00:18:12,025 --> 0:18:13,327
芯片级GPU

377
00:18:13,660 --> 0:18:17,331
我们希望存储操作是

378
00:18:17,664 --> 0:18:21,101
因此不需要在渲染路径末端写入数据

379
00:18:21,502 --> 0:18:22,836
就这些了

380
00:18:23,370 --> 0:18:25,305
验证我们拥有对的东西

381
00:18:25,372 --> 0:18:26,707
也非常简单

382
00:18:27,241 --> 0:18:29,076
我们可以使用依存查看器

383
00:18:30,811 --> 0:18:34,882
在这个例子中

384
00:18:34,948 --> 0:18:36,650
即使以后用不到了

385
00:18:37,251 --> 0:18:39,419
依存查看器会显示一个问题图标

386
00:18:39,486 --> 0:18:40,988
来突显这个问题

387
00:18:41,722 --> 0:18:44,291
我们应该设置

388
00:18:44,358 --> 0:18:46,460
在刚才的幻灯片上所看到的

389
00:18:46,760 --> 0:18:48,195
问题就解决了

390
00:18:48,529 --> 0:18:50,330
真的就是这么简单

391
00:18:51,965 --> 0:18:54,101
这对于多重采样的渲染目标来说

392
00:18:54,701 --> 0:18:56,837
尤其重要

393
00:18:58,071 --> 0:19:00,741
iOS设备的MSAA非常快

394
00:18:58,071 --> 0:19:00,741
iOS设备的MSAA非常快

395
00:19:01,074 --> 0:19:04,178
那是因为Tile Memory

396
00:19:04,244 --> 0:19:06,647
不会消耗任何额外的带宽

397
00:19:07,314 --> 0:19:08,282
这也允许我们

398
00:19:08,348 --> 0:19:11,518
声明多重采样的纹理完全是临时的

399
00:19:11,852 --> 0:19:14,421
事实上我们起初甚至不需要

400
00:19:14,488 --> 0:19:15,923
对它进行备份

401
00:19:16,557 --> 0:19:19,226
因此最佳实践是

402
00:19:19,293 --> 0:19:21,929
因为效率很高

403
00:19:22,296 --> 0:19:26,133
同时 一定不要加载或存储

404
00:19:26,700 --> 0:19:28,468
因为你把多重采样纹理的存储模式

405
00:19:28,535 --> 0:19:30,938
设为了不耗内存

406
00:19:31,772 --> 0:19:34,208
我稍后会具体介绍不耗内存

407
00:19:34,274 --> 0:19:37,377
现在让我们看看

408
00:19:37,444 --> 0:19:39,213
以及它所使用的渲染路径

409
00:19:40,881 --> 0:19:43,851
在这个例子中我们只需要设置

410
00:19:44,518 --> 0:19:47,554
并确保渲染路径使用它

411
00:19:47,888 --> 0:19:50,891
清理它的内容并丢弃采样

412
00:19:51,258 --> 0:19:54,962
我们只希望从多重采样纹理中

413
00:19:55,028 --> 0:19:56,463
我们不需要存储它

414
00:19:56,530 --> 0:19:59,032
我们不想存储中间数据

415
00:19:59,433 --> 0:20:02,469
应该只存储最终解决的纹理

416
00:19:59,433 --> 0:20:02,469
应该只存储最终解决的纹理

417
00:20:03,303 --> 0:20:05,939
我们可以再一次使用依存查看器

418
00:20:06,006 --> 0:20:08,542
来帮助我们验证我们做了正确的操作

419
00:20:10,143 --> 0:20:12,613
在这个例子中

420
00:20:12,679 --> 0:20:16,650
和启动多重采样纹理 损耗很大

421
00:20:17,518 --> 0:20:20,254
在设置正确的标志之后

422
00:20:20,687 --> 0:20:27,194
我们将节约超过85MB的内存带宽

423
00:20:27,261 --> 0:20:28,762
以及内存占用

424
00:20:29,530 --> 0:20:33,200
这对于验证多重采样缓冲区来说

425
00:20:33,800 --> 0:20:34,635
但请注意

426
00:20:35,202 --> 0:20:38,539
产生这样的节约只因为

427
00:20:38,605 --> 0:20:41,642
因为我们通过使用MSAA

428
00:20:42,209 --> 0:20:44,645
暗中权衡Tile Memory

429
00:20:45,279 --> 0:20:49,383
因此下一个最佳实践是

430
00:20:50,150 --> 0:20:53,420
Metal针对某些功能提供

431
00:20:53,487 --> 0:20:57,524
比如程控混合、图像块和扁平着色器

432
00:20:57,991 --> 0:21:01,795
最佳实践就是明确利用它

433
00:20:57,991 --> 0:21:01,795
最佳实践就是明确利用它

434
00:21:02,095 --> 0:21:06,166
特别是实施更先进的渲染技术

435
00:21:06,900 --> 0:21:08,635
在使用Metal

436
00:21:08,702 --> 0:21:12,206
具体讲了其中一些技术

437
00:21:13,073 --> 0:21:16,210
现在我们只快速了解一下延迟着色

438
00:21:16,276 --> 0:21:17,644
（传统的延迟着色）

439
00:21:17,711 --> 0:21:21,315
延迟着色被认为很消耗带宽

440
00:21:21,949 --> 0:21:25,485
那是因为从传统上它要求app

441
00:21:25,552 --> 0:21:28,655
存储集合图形信息

442
00:21:28,722 --> 0:21:32,392
因为一组纹理代表许多像素属性

443
00:21:32,993 --> 0:21:36,296
然后在第二光通道中采样那些纹理

444
00:21:36,563 --> 0:21:39,733
最终颜色堆积在渲染目标中

445
00:21:40,300 --> 0:21:44,505
请注意我们存储

446
00:21:44,571 --> 0:21:47,374
因此这就是为什么会消耗带宽的原因

447
00:21:48,375 --> 0:21:51,278
iOS让你效率更高

448
00:21:52,713 --> 0:21:53,547
（单一路径延迟着色）

449
00:21:53,614 --> 0:21:56,316
在iOS上 我们可以权衡程控混合

450
00:21:56,383 --> 0:22:00,754
它允许片段着色器

451
00:21:56,383 --> 0:22:00,754
它允许片段着色器

452
00:22:00,821 --> 0:22:02,089
直接从Tile Memory

453
00:22:02,656 --> 0:22:06,527
这意味着G-buffer数据

454
00:22:06,593 --> 0:22:11,765
并通过全部光积聚着色器在同一个

455
00:22:12,165 --> 0:22:14,134
它是个强大的功能

456
00:22:15,102 --> 0:22:18,272
Digital Legends

457
00:22:18,772 --> 0:22:22,042
这就是通过依存查看器看到的

458
00:22:22,309 --> 0:22:24,444
Afterpulse的

459
00:22:24,511 --> 0:22:25,579
很漂亮

460
00:22:25,879 --> 0:22:28,682
四个G-Buffer缓冲区

461
00:22:28,749 --> 0:22:31,485
只存储了最终颜色和深度

462
00:22:31,552 --> 0:22:34,087
不仅漂亮 而且高效

463
00:22:34,655 --> 0:22:37,124
现在请让我们欢迎

464
00:22:37,191 --> 0:22:39,092
演示依存查看器

465
00:22:39,159 --> 0:22:43,697
（演示）

466
00:22:48,902 --> 0:22:49,803
谢谢Guillem

467
00:22:50,103 --> 0:22:52,773
我们刚才了解了老版的

468
00:22:52,840 --> 0:22:54,975
想看看是否可以进行一些优化

469
00:22:55,042 --> 0:22:57,477
来改善它的性能

470
00:22:58,545 --> 0:23:02,416
现在我要使用Metal

471
00:22:58,545 --> 0:23:02,416
现在我要使用Metal

472
00:23:02,482 --> 0:23:05,152
来讲一下Guillem

473
00:23:06,920 --> 0:23:09,790
要开始 让我们点击

474
00:23:09,857 --> 0:23:11,592
打开依存查看器

475
00:23:15,128 --> 0:23:18,065
依存查看器给我们显示了

476
00:23:18,131 --> 0:23:19,499
由app编码的所有GPU通道

477
00:23:20,901 --> 0:23:23,804
我们可以看到Afterpulse

478
00:23:24,137 --> 0:23:26,840
并以渲染阴影图开始它的帧

479
00:23:27,341 --> 0:23:28,876
然后是相位延迟

480
00:23:30,310 --> 0:23:32,613
这会注入亮度计算

481
00:23:32,880 --> 0:23:35,315
粒子模拟和布尔链

482
00:23:35,883 --> 0:23:38,285
并由最终屏幕通道使用

483
00:23:39,520 --> 0:23:42,055
今年依存压缩器变得更紧凑了

484
00:23:42,122 --> 0:23:43,023
如果你有群

485
00:23:43,423 --> 0:23:45,759
那从高层级看帧如何被渲染

486
00:23:45,826 --> 0:23:47,294
非常简单

487
00:23:47,995 --> 0:23:51,832
我们甚至可以更深入到任意群

488
00:23:52,366 --> 0:23:56,670
因此 实际上这个布尔链

489
00:23:58,939 --> 0:24:00,707
现在依存查看器是查找

490
00:23:58,939 --> 0:24:00,707
现在依存查看器是查找

491
00:24:00,774 --> 0:24:02,943
Guillem刚提到过的

492
00:24:03,243 --> 0:24:05,846
并且我们可以在这个

493
00:24:06,613 --> 0:24:09,483
让我们点击问题图标查找更多问题

494
00:24:11,552 --> 0:24:14,254
看起来与

495
00:24:14,321 --> 0:24:15,856
一个加载存储操作问题很像

496
00:24:16,456 --> 0:24:18,659
他们已经把存储操作设置为存储

497
00:24:19,059 --> 0:24:21,528
但他们没有在帧中再次使用这个纹理

498
00:24:22,062 --> 0:24:25,866
因此这个问题建议我们

499
00:24:26,333 --> 0:24:29,570
然后我们将节约差不多14MB

500
00:24:29,837 --> 0:24:31,471
针对这两个联合的纹理

501
00:24:33,140 --> 0:24:37,044
今年我们把这个过程变得更简单了

502
00:24:37,611 --> 0:24:40,747
只需要点击右下方的新问题按钮

503
00:24:40,814 --> 0:24:42,082
即可获得一个问题列表

504
00:24:46,453 --> 0:24:48,288
Guillem刚才提到的

505
00:24:48,355 --> 0:24:50,958
选择正确的像素格式

506
00:24:51,525 --> 0:24:55,329
因此今年在iOS上

507
00:24:55,929 --> 0:24:59,900
让我们使用新搜索来查找

508
00:25:03,270 --> 0:25:06,373
看起来它们占用了36MB内存

509
00:25:06,440 --> 0:25:07,875
针对阴影图纹理

510
00:25:08,509 --> 0:25:12,479
因此当Digital Legends团队

511
00:25:12,546 --> 0:25:17,451
他们研究使用这个新格式

512
00:25:17,518 --> 0:25:19,486
如果他们的阴影需求允许的话

513
00:25:20,721 --> 0:25:22,789
如果我们继续通过图表进行搜索

514
00:25:23,423 --> 0:25:26,727
你可以看到由大量潜在的内存节约

515
00:25:28,228 --> 0:25:31,164
如果你使用Metal帧调试器中的

516
00:25:31,231 --> 0:25:35,502
来查找和诊断老版

517
00:25:36,103 --> 0:25:37,004
Digital Legends

518
00:25:37,070 --> 0:25:39,306
其实已经做了一些改善

519
00:25:39,373 --> 0:25:40,607
让我们快速看一下

520
00:25:42,509 --> 0:25:43,644
我们可以立即看到

521
00:25:43,710 --> 0:25:45,879
它们现在使用了多个命令缓冲区

522
00:25:46,346 --> 0:25:48,949
那么这将修复Guillem

523
00:25:49,016 --> 0:25:52,119
CPU因为要等待下一个可绘制物

524
00:25:52,186 --> 0:25:53,520
而GPU处于闲置状态

525
00:25:54,855 --> 0:25:56,990
如果我们具体看一下最终屏幕通道

526
00:25:57,891 --> 0:26:00,527
我们可以看到他们已经修复了

527
00:25:57,891 --> 0:26:00,527
我们可以看到他们已经修复了

528
00:26:01,395 --> 0:26:04,665
事实上

529
00:26:04,731 --> 0:26:07,000
并且他们已经把存储模式设置为

530
00:26:07,367 --> 0:26:09,870
他们将不使用任何系统内存

531
00:26:11,004 --> 0:26:15,909
因此 依存真的是一个

532
00:26:16,476 --> 0:26:19,813
舞台交还给Guillem

533
00:26:19,880 --> 0:26:22,216
关于优化app内存占用的最佳实践

534
00:26:28,188 --> 0:26:29,857
（演示）

535
00:26:29,923 --> 0:26:31,792
谢谢Sam 演示很棒

536
00:26:31,859 --> 0:26:34,328
我希望你们也可以使用依存查看器

537
00:26:35,262 --> 0:26:38,198
很酷 那么让我们继续进入

538
00:26:38,498 --> 0:26:39,633
内存占用

539
00:26:39,933 --> 0:26:40,767
（内存占用）

540
00:26:40,834 --> 0:26:43,003
内存占用其实对于你的游戏来说

541
00:26:43,070 --> 0:26:43,971
非常重要

542
00:26:44,671 --> 0:26:48,809
那是因为iOS强制执行

543
00:26:48,876 --> 0:26:52,346
以便保持系统在app上的响应性

544
00:26:52,412 --> 0:26:53,580
（app内存限制）

545
00:26:53,981 --> 0:26:55,849
有些人可能已经注意到了

546
00:26:55,916 --> 0:27:00,053
iOS 12在内存计算方面

547
00:26:55,916 --> 0:27:00,053
iOS 12在内存计算方面

548
00:27:00,787 --> 0:27:04,191
计算方式的修改影响了绝大多数

549
00:27:04,958 --> 0:27:07,661
Metal资源 比如缓冲区或纹理

550
00:27:07,928 --> 0:27:10,898
也许是大多数app的内存占用

551
00:27:10,964 --> 0:27:14,368
因此衡量游戏的内存占用对你来说

552
00:27:14,935 --> 0:27:17,771
你可以使用Xcode内存计

553
00:27:17,838 --> 0:27:18,672
（Xcode 11）

554
00:27:18,739 --> 0:27:22,376
Xcode内存计

555
00:27:22,442 --> 0:27:25,812
游戏的内存占用的数值

556
00:27:26,380 --> 0:27:30,284
用它来验证游戏的状态非常重要

557
00:27:31,151 --> 0:27:35,122
今年它还将显示app内存限制

558
00:27:35,422 --> 0:27:37,224
如果游戏所占用的内存

559
00:27:38,892 --> 0:27:41,628
但如果我们想特别关注

560
00:27:42,162 --> 0:27:44,731
我们的Metal资源所使用的内存

561
00:27:46,800 --> 0:27:49,570
今年我们引入了内存查看器

562
00:27:50,470 --> 0:27:53,207
我们把它添加到

563
00:27:53,273 --> 0:27:54,241
（Metal内存查看器）

564
00:27:54,308 --> 0:27:56,610
内存查看器自身有两个部分

565
00:27:56,910 --> 0:27:59,179
第一部分是顶部的条形图

566
00:27:59,646 --> 0:28:05,719
显示按类别显示资源

567
00:27:59,646 --> 0:28:05,719
显示按类别显示资源

568
00:28:06,253 --> 0:28:08,255
我们还可以用这个条形图

569
00:28:08,755 --> 0:28:11,091
在最大的资源中进行快速导航

570
00:28:11,158 --> 0:28:13,827
并在显示时把它们突显出来

571
00:28:14,695 --> 0:28:17,064
第二部分是底部有一个表

572
00:28:17,331 --> 0:28:20,000
显示我们所筛选的资源

573
00:28:20,701 --> 0:28:24,471
它包含资源类型的一些专有属性

574
00:28:24,538 --> 0:28:27,441
比如纹理的像素格式和分辨率

575
00:28:28,041 --> 0:28:30,344
底部还有一个筛选条

576
00:28:30,611 --> 0:28:33,413
可以帮助你做进一步的筛选

577
00:28:33,914 --> 0:28:37,651
它是个强大的工具

578
00:28:37,718 --> 0:28:41,622
来了解全部GPU资源的内存占用

579
00:28:43,023 --> 0:28:47,060
同时 我们今年引入的另一个

580
00:28:47,127 --> 0:28:49,930
Metal资源分配工具

581
00:28:49,997 --> 0:28:51,031
（Metal资源分配工具）

582
00:28:51,098 --> 0:28:52,900
它有三个不同的组成部分：

583
00:28:53,800 --> 0:28:55,769
Metal资源分配追踪

584
00:28:55,836 --> 0:28:59,206
显示游戏的当前Metal内存占用

585
00:29:00,007 --> 0:29:01,608
分配追踪

586
00:29:01,675 --> 0:29:05,345
针对每个资源分配和再分配

587
00:29:05,412 --> 0:29:07,047
以及一些信息

588
00:29:08,348 --> 0:29:10,450
还有详情表视图

589
00:29:10,517 --> 0:29:14,421
显示所捕捉到的所有分配的更多信息

590
00:29:15,155 --> 0:29:19,293
这些工具都很强大 让你很好地了解

591
00:29:19,626 --> 0:29:23,931
游戏中的内存占用概况

592
00:29:25,232 --> 0:29:27,968
但有些人还要求添加其它功能

593
00:29:28,268 --> 0:29:31,371
特别是其中有一个功能

594
00:29:31,672 --> 0:29:34,041
今年我要很高兴地向大家宣布

595
00:29:34,107 --> 0:29:38,011
我们有基于C的API

596
00:29:38,579 --> 0:29:42,216
这会让你的游戏更有效地传输资源

597
00:29:42,282 --> 0:29:45,252
并避免内存尖峰

598
00:29:45,319 --> 0:29:48,755
内存尖峰将导致游戏

599
00:29:48,822 --> 0:29:50,023
（可用的内存）

600
00:29:50,090 --> 0:29:52,793
今年我们引入的

601
00:29:52,860 --> 0:29:54,995
设备上的GPU捕捉

602
00:29:55,262 --> 0:29:58,532
允许你以编程方式触发GPU捕捉

603
00:29:58,832 --> 0:30:01,068
不需要Xcode

604
00:29:58,832 --> 0:30:01,068
不需要Xcode

605
00:30:01,435 --> 0:30:04,905
我们认为它对处于QA过程的

606
00:30:05,439 --> 0:30:06,273
要启动它

607
00:30:06,540 --> 0:30:09,910
你只需要向info.plist中添加

608
00:30:09,977 --> 0:30:11,144
非常简单

609
00:30:11,211 --> 0:30:12,045
（设备上的GPU捕捉）

610
00:30:12,112 --> 0:30:17,584
现在让我们看看如何把这两个API

611
00:30:18,719 --> 0:30:21,121
在这个例子中我们想检查

612
00:30:21,188 --> 0:30:23,457
app所占用的内存

613
00:30:23,524 --> 0:30:25,325
也许由于内存尖峰

614
00:30:25,726 --> 0:30:27,661
捕捉到游戏的GPU追踪

615
00:30:27,728 --> 0:30:30,364
因此我们可以使用内存查看器

616
00:30:30,764 --> 0:30:31,798
让我们开始吧

617
00:30:32,132 --> 0:30:35,903
首先我们要检查app的内存占用

618
00:30:36,770 --> 0:30:37,671
如果接近

619
00:30:37,738 --> 0:30:40,474
我们要捕捉下一个帧

620
00:30:41,074 --> 0:30:44,545
我们只会进行正常渲染

621
00:30:45,712 --> 0:30:48,448
在这一个帧结束后

622
00:30:48,849 --> 0:30:52,286
我们会停止捕捉并处理GPU追踪

623
00:30:52,352 --> 0:30:54,955
由你来决定如何处理GPU追踪

624
00:30:55,489 --> 0:30:58,992
潜在地 你可能还想退出游戏

625
00:30:59,059 --> 0:31:01,728
或禁用这个会话的GPU捕捉

626
00:30:59,059 --> 0:31:01,728
或禁用这个会话的GPU捕捉

627
00:31:01,795 --> 0:31:05,299
因为你可能不想在那点上

628
00:31:06,233 --> 0:31:10,270
这会为你提供一个

629
00:31:10,604 --> 0:31:13,173
比如进一步深究内存占用

630
00:31:13,240 --> 0:31:16,243
那很棒 因此让我们来做一下吧

631
00:31:16,310 --> 0:31:19,479
让我们看一下如何减少内存占用

632
00:31:19,813 --> 0:31:22,816
为此 我们还有一堆最佳实践

633
00:31:23,517 --> 0:31:27,154
在这部分我们要讲

634
00:31:27,221 --> 0:31:28,322
资源传输

635
00:31:28,956 --> 0:31:32,826
再提一下游戏资产

636
00:31:33,393 --> 0:31:36,563
让我们从不耗内存的渲染目标开始讲

637
00:31:36,630 --> 0:31:37,664
（最佳实践）

638
00:31:37,731 --> 0:31:40,868
这大概就是我们在讲

639
00:31:42,102 --> 0:31:46,507
请注意系统内存上不加载或存储

640
00:31:47,474 --> 0:31:51,345
因此它们实际上不需要系统内存分配

641
00:31:51,879 --> 0:31:54,214
这就是为什么你应该使用

642
00:31:54,581 --> 0:31:57,584
特别是对于

643
00:31:58,318 --> 0:32:01,788
让我们看看该如何实现 再一次

644
00:31:58,318 --> 0:32:01,788
让我们看看该如何实现 再一次

645
00:32:03,123 --> 0:32:03,957
在这个例子中

646
00:32:04,024 --> 0:32:07,294
与给纹理描述符设置不耗内存

647
00:32:07,895 --> 0:32:09,863
并且我们要确保

648
00:32:09,930 --> 0:32:13,767
渲染通道把渲染目标配置为完全临时

649
00:32:14,067 --> 0:32:14,968
在这个例子中

650
00:32:15,235 --> 0:32:17,371
我们把G-Buffer配置为临时

651
00:32:17,437 --> 0:32:20,107
我们只需要把加载操作设置为清理

652
00:32:20,174 --> 0:32:21,808
并把存储操作设置为

653
00:32:22,075 --> 0:32:24,178
因此我们没有存储G-Buffer

654
00:32:25,512 --> 0:32:29,850
我们可以通过Afterpulse再看看

655
00:32:30,517 --> 0:32:33,854
在顶部我们可以看到

656
00:32:34,555 --> 0:32:39,059
它有临时G-Buffer

657
00:32:40,160 --> 0:32:41,094
在底部

658
00:32:41,161 --> 0:32:45,899
我们看到新版Afterpulse

659
00:32:47,000 --> 0:32:49,803
但这个G-Buffer

660
00:32:49,870 --> 0:32:53,674
这一次系统内存没有对它进行备份

661
00:32:53,740 --> 0:32:56,176
他们对所有中间的

662
00:32:56,577 --> 0:32:58,846
都使用了不耗内存存储模式

663
00:32:59,413 --> 0:33:02,382
这很棒

664
00:32:59,413 --> 0:33:02,382
这很棒

665
00:33:02,716 --> 0:33:06,153
节约了大概60MB的内存占用

666
00:33:06,220 --> 0:33:08,121
仅通过设置那一个标志

667
00:33:08,755 --> 0:33:09,590
太棒了

668
00:33:10,090 --> 0:33:12,292
并且没有做出任何妥协

669
00:33:12,626 --> 0:33:15,796
这儿什么也没少 也没有任何权衡

670
00:33:15,863 --> 0:33:17,798
它就是起作用了 很棒

671
00:33:18,498 --> 0:33:21,101
那么现在让我们继续看

672
00:33:21,168 --> 0:33:22,536
（最佳实践）

673
00:33:22,603 --> 0:33:25,539
其中一些涉及

674
00:33:25,939 --> 0:33:29,810
内存和性能权衡

675
00:33:30,344 --> 0:33:33,013
在这个例子中

676
00:33:34,081 --> 0:33:36,583
请注意 把所有资产都加载到内存中

677
00:33:36,650 --> 0:33:38,452
将增加内存占用

678
00:33:38,519 --> 0:33:41,622
因此你应该考虑内存和性能的权衡

679
00:33:42,055 --> 0:33:44,925
并只加载全部你知道的

680
00:33:44,992 --> 0:33:47,194
特别是当你接近内存限制时

681
00:33:48,028 --> 0:33:50,864
并且你可能还想释放所有资源

682
00:33:50,931 --> 0:33:53,667
一旦不再使用它们

683
00:33:53,734 --> 0:33:56,270
潜在的比如启动画面或教程UI

684
00:33:56,336 --> 0:33:58,038
都是很好的例子

685
00:33:59,339 --> 0:34:01,508
这个决定很困难

686
00:33:59,339 --> 0:34:01,508
这个决定很困难

687
00:34:01,942 --> 0:34:05,512
幸运的是内存查看器会帮助我们处理

688
00:34:05,579 --> 0:34:06,847
（Metal内存查看器）

689
00:34:06,914 --> 0:34:11,118
我们可以使用筛选器快速查找

690
00:34:11,952 --> 0:34:15,121
通过这样的操作会更新底部的表

691
00:34:15,188 --> 0:34:17,591
然后我们可以查看在这个帧中

692
00:34:17,658 --> 0:34:19,426
不使用的所有资源

693
00:34:20,159 --> 0:34:23,397
在本场演讲的最后Onyechi

694
00:34:23,463 --> 0:34:24,797
会在内存查看器的演示中

695
00:34:25,666 --> 0:34:28,467
那么现在让我们继续看

696
00:34:28,969 --> 0:34:30,737
使用较小的资产

697
00:34:32,039 --> 0:34:35,676
事实上你应该只在必要时扩充资产

698
00:34:36,275 --> 0:34:39,179
并再次考虑资产尺寸的图像品质

699
00:34:39,246 --> 0:34:40,746
和内存权衡

700
00:34:40,813 --> 0:34:43,684
确保既压缩了纹理又压缩了网格

701
00:34:44,217 --> 0:34:46,853
潜在地 如果你接近了内存限制

702
00:34:47,321 --> 0:34:49,022
你可能希望只加载

703
00:34:49,289 --> 0:34:51,625
较小的纹理映射等级

704
00:34:52,292 --> 0:34:54,628
或较低的网格LOD

705
00:34:56,096 --> 0:34:58,131
但这里有一个权衡

706
00:34:58,198 --> 0:35:00,067
在图像品质和内存之间

707
00:34:58,198 --> 0:35:00,067
在图像品质和内存之间

708
00:35:00,133 --> 0:35:03,370
由你来决定何时采取这种操作

709
00:35:04,805 --> 0:35:08,342
下一个最佳实践

710
00:35:09,209 --> 0:35:12,679
我们想简化内存密集型效果

711
00:35:14,047 --> 0:35:17,084
有些效果需要大的后台缓冲区

712
00:35:17,484 --> 0:35:19,620
比如阴影图和SSAO

713
00:35:20,354 --> 0:35:21,321
因此最佳实践是

714
00:35:21,388 --> 0:35:24,658
考虑所有效果的

715
00:35:24,725 --> 0:35:26,059
图像品质和内存权衡

716
00:35:27,094 --> 0:35:30,731
潜在地

717
00:35:31,298 --> 0:35:33,500
并且如果你接近内存限制

718
00:35:33,767 --> 0:35:36,303
就同时禁用全部效果

719
00:35:37,471 --> 0:35:41,175
这要做出权衡

720
00:35:41,241 --> 0:35:43,143
但有时候我们没有其它选择

721
00:35:44,845 --> 0:35:47,981
我们要将的下一个最佳实践

722
00:35:48,048 --> 0:35:49,516
稍微有点不一样

723
00:35:50,117 --> 0:35:52,119
在这个最后一部分中

724
00:35:52,553 --> 0:35:55,389
我要介绍一些更先进的概念

725
00:35:55,455 --> 0:35:58,859
从而帮助我们进一步减少内存占用

726
00:35:59,493 --> 0:36:02,029
我们会讲到Metal资源堆积

727
00:35:59,493 --> 0:36:02,029
我们会讲到Metal资源堆积

728
00:36:03,564 --> 0:36:06,733
可清除的内存以及管线状态对象

729
00:36:07,901 --> 0:36:10,204
让我们从Metal资源堆积开始讲

730
00:36:10,270 --> 0:36:11,171
（Metal资源堆积）

731
00:36:11,238 --> 0:36:13,507
Metal资源堆积将允许app

732
00:36:13,574 --> 0:36:17,845
明确控制在前台发生的

733
00:36:17,911 --> 0:36:19,213
大的内存分配

734
00:36:19,980 --> 0:36:23,250
在这个例子中

735
00:36:23,317 --> 0:36:24,918
它们分别有自己的分配

736
00:36:25,285 --> 0:36:29,056
放到一个Metal资源堆积中

737
00:36:29,122 --> 0:36:31,825
那会分别包含这三个纹理

738
00:36:32,526 --> 0:36:35,996
这还将允许系统把那些纹理

739
00:36:36,063 --> 0:36:38,065
从而节约一些内存

740
00:36:38,899 --> 0:36:39,733
（最佳实践）

741
00:36:39,800 --> 0:36:45,372
但最节约内存的是使用别名

742
00:36:46,106 --> 0:36:50,544
请注意渲染帧可能需要

743
00:36:50,978 --> 0:36:54,481
特别是你的游戏向内扩展后处理管线

744
00:36:55,048 --> 0:36:57,885
因此针对那些效果使用

745
00:36:57,951 --> 0:37:01,922
并尽可能地使用别名非常重要

746
00:36:57,951 --> 0:37:01,922
并尽可能地使用别名非常重要

747
00:37:02,356 --> 0:37:06,126
比如你可能想针对

748
00:37:06,193 --> 0:37:07,761
重新使用内存

749
00:37:08,262 --> 0:37:11,999
潜在地 比如在SSAO

750
00:37:13,667 --> 0:37:16,170
现在让我们看看那看起来如何

751
00:37:16,537 --> 0:37:19,239
在这个例子中 我们拥有

752
00:37:19,306 --> 0:37:20,207
跟以前一样的Metal资源堆积

753
00:37:21,074 --> 0:37:24,611
但如果没有同时使用那三个纹理

754
00:37:24,678 --> 0:37:26,480
我们可以潜在地给它们取个别名

755
00:37:26,813 --> 0:37:29,283
通过这样做 我们会节约大量内存

756
00:37:30,150 --> 0:37:33,153
这真的会帮助你的游戏

757
00:37:33,220 --> 0:37:36,023
形成更复杂的后处理管线

758
00:37:36,356 --> 0:37:40,961
而不需要为所有中间的渲染目标

759
00:37:41,028 --> 0:37:42,596
和所有中间的内存付出巨大的代价

760
00:37:43,263 --> 0:37:46,800
因此它是个很棒的功能

761
00:37:46,867 --> 0:37:47,935
（Metal资源堆积）

762
00:37:48,001 --> 0:37:50,337
现在让我们谈谈另一个先进概念

763
00:37:50,404 --> 0:37:52,105
即可清除的内存

764
00:37:52,172 --> 0:37:53,207
（可清除的内存）

765
00:37:53,273 --> 0:37:55,442
可清除的内存有三个状态：

766
00:37:55,976 --> 0:37:59,546
非易失性、易失性和空

767
00:38:00,514 --> 0:38:03,617
请注意易失性和空分配

768
00:38:03,684 --> 0:38:07,120
不计入app的内存占用

769
00:38:07,855 --> 0:38:09,223
那是因为系统

770
00:38:09,289 --> 0:38:11,692
可以在某个时刻回收那个内存

771
00:38:11,758 --> 0:38:13,160
如果是易失性情况的话

772
00:38:13,460 --> 0:38:17,130
或者之前已经回收它了

773
00:38:17,197 --> 0:38:19,833
因此你可能需要重新生成那些资源

774
00:38:21,068 --> 0:38:25,506
但使得这种内存非常合适资源缓存

775
00:38:26,707 --> 0:38:31,078
因此最佳实践 第17个范例就是

776
00:38:31,645 --> 0:38:34,448
易失性资源可能会占用

777
00:38:34,515 --> 0:38:35,849
游戏的内存占用的大部分

778
00:38:36,917 --> 0:38:40,153
并且Metal允许你

779
00:38:40,220 --> 0:38:43,891
明确设置所有资源的可清除状态

780
00:38:44,658 --> 0:38:47,060
因此你要注意缓存

781
00:38:47,394 --> 0:38:50,597
特别是占用绝大部分闲置内存的

782
00:38:50,898 --> 0:38:53,333
并谨慎管理它们的可清除状态

783
00:38:53,700 --> 0:38:56,203
从而使它们不计入

784
00:38:56,970 --> 0:39:00,040
让我们来看一段很短的代码

785
00:38:56,970 --> 0:39:00,040
让我们来看一段很短的代码

786
00:39:00,474 --> 0:39:02,576
那会给你提供一个如何实现的例示例

787
00:39:03,010 --> 0:39:07,080
在这个例子中 我们有纹理缓存

788
00:39:08,115 --> 0:39:10,484
我们要把那个缓存中

789
00:39:10,551 --> 0:39:16,123
设置为易失性 因为我们知道

790
00:39:16,190 --> 0:39:20,127
我们偶尔只使用一个纹理

791
00:39:21,228 --> 0:39:23,830
因此如果我们需要使用

792
00:39:24,231 --> 0:39:26,900
我们需要把它标记为非易失性

793
00:39:27,267 --> 0:39:31,104
那将确保系统不会移除它的备份数据

794
00:39:32,172 --> 0:39:34,341
在这个例子中 它是空

795
00:39:34,641 --> 0:39:38,045
就是我们刚才讲到过的一个状态

796
00:39:38,545 --> 0:39:41,081
我们实际上可能需要重新生成数据

797
00:39:41,715 --> 0:39:42,616
可能不需要生成

798
00:39:42,683 --> 0:39:45,118
取决于你所管理的缓存类型

799
00:39:45,452 --> 0:39:46,687
但在我们这样做之后

800
00:39:47,087 --> 0:39:50,457
我们就可以正常使用资源

801
00:39:52,226 --> 0:39:56,063
还有一个很好的范例就是

802
00:39:56,129 --> 0:39:59,633
查看公共缓冲区的完成情况

803
00:40:00,300 --> 0:40:03,537
并当公共缓冲区完成后就着手处理

804
00:40:03,604 --> 0:40:05,072
潜在地

805
00:40:05,873 --> 0:40:08,141
再一次把那个资源标记为易失性

806
00:40:08,475 --> 0:40:11,545
因此它不会计入你的内存占用内

807
00:40:12,479 --> 0:40:16,116
你可以非常明确地执行 并且事实上

808
00:40:16,183 --> 0:40:20,053
特别是当你有大量多数时候

809
00:40:21,588 --> 0:40:26,527
那么让我们介绍最后一个概念

810
00:40:26,593 --> 0:40:27,427
（管线状态对象(PSO)）

811
00:40:27,494 --> 0:40:29,596
大多数人已经很熟悉那些了

812
00:40:29,897 --> 0:40:33,534
PSO封装大部分

813
00:40:34,268 --> 0:40:36,537
它们由描述符构建

814
00:40:36,603 --> 0:40:39,239
包含顶点函数和片段函数

815
00:40:39,606 --> 0:40:42,509
以及其它状态 比如混合状态

816
00:40:42,776 --> 0:40:44,211
和顶点描述符

817
00:40:45,012 --> 0:40:48,515
所有这些都被编译到

818
00:40:49,650 --> 0:40:53,987
我们只需要用这个最终的

819
00:40:54,688 --> 0:40:58,725
因此下一个最佳实践是

820
00:40:59,459 --> 0:41:01,261
因为Metal允许你的app

821
00:40:59,459 --> 0:41:01,261
因为Metal允许你的app

822
00:41:01,328 --> 0:41:03,964
提前加载大多数渲染状态

823
00:41:04,031 --> 0:41:05,098
你也应该这样做

824
00:41:05,365 --> 0:41:07,334
那会很大地提高性能

825
00:41:07,935 --> 0:41:10,971
然后 如果你那样做

826
00:41:11,638 --> 0:41:16,610
如果你的内存有限

827
00:41:16,910 --> 0:41:19,079
一定不要抓住那些

828
00:41:19,613 --> 0:41:21,481
并且这一点也很重要

829
00:41:21,548 --> 0:41:26,653
不要在你创建PSO缓存之后

830
00:41:26,920 --> 0:41:31,124
因为渲染不再需要它们了

831
00:41:32,292 --> 0:41:35,495
让我们通过再看一下描述符

832
00:41:36,063 --> 0:41:37,831
这是管线状态对象

833
00:41:37,898 --> 0:41:40,300
以及管线状态对象描述符

834
00:41:40,367 --> 0:41:42,669
并且这个最佳实践就是

835
00:41:43,136 --> 0:41:46,406
在你创建PSO之后

836
00:41:46,473 --> 0:41:48,475
释放顶点函数和片段函数的引用

837
00:41:48,542 --> 0:41:51,578
潜在地 仅抓住那些当在加载时

838
00:41:51,912 --> 0:41:54,081
填充主PSO缓存的那些引用

839
00:41:54,882 --> 0:41:58,418
然后也要考虑释放PSO自身

840
00:41:58,485 --> 0:42:00,420
当你的内存接近内存限制时

841
00:41:58,485 --> 0:42:00,420
当你的内存接近内存限制时

842
00:42:00,487 --> 0:42:03,056
如果你知道不再需要那个PSO的话

843
00:42:04,591 --> 0:42:09,162
现在请欢迎Onyechi上台来

844
00:42:09,229 --> 0:42:12,366
（演示）

845
00:42:15,569 --> 0:42:17,838
谢谢Guillem 大家好

846
00:42:19,239 --> 0:42:21,608
你们已经从之前的幻灯片中

847
00:42:21,675 --> 0:42:23,443
内存查看器

848
00:42:23,810 --> 0:42:27,114
现在我要给你们演示

849
00:42:27,381 --> 0:42:29,516
这是为了获得更好的内存性能

850
00:42:31,618 --> 0:42:33,787
在这里我们再一次捕获

851
00:42:33,854 --> 0:42:37,224
来自Afterpulse早期版本

852
00:42:37,791 --> 0:42:39,893
然后左上方有调试导航器

853
00:42:39,960 --> 0:42:41,695
你可以找到一个新的内存计

854
00:42:42,396 --> 0:42:43,664
当我点击它时

855
00:42:44,331 --> 0:42:45,832
它会把我带入内存查看器中

856
00:42:46,834 --> 0:42:49,770
这给我们显示了所捕捉的帧的

857
00:42:49,837 --> 0:42:50,904
所有活跃的Metal资源

858
00:42:51,405 --> 0:42:54,775
我的目标是找机会减少它的内存占用

859
00:42:55,475 --> 0:42:56,343
因此开始

860
00:42:56,944 --> 0:42:59,213
让我们先看看图表中的橘色条

861
00:42:59,813 --> 0:43:02,749
这些显示了资源是如何

862
00:42:59,813 --> 0:43:02,749
这些显示了资源是如何

863
00:43:03,350 --> 0:43:06,520
我们可以看到纹理构成了最大的部分

864
00:43:07,154 --> 0:43:09,423
大概有440MB

865
00:43:09,489 --> 0:43:11,225
现在我想关注这些部分

866
00:43:11,291 --> 0:43:14,928
我可以通过点击筛选按钮实现

867
00:43:16,096 --> 0:43:19,266
现在图标和表都已经更新了

868
00:43:19,333 --> 0:43:20,567
只显示纹理

869
00:43:21,635 --> 0:43:23,170
那么接下来 Guillem提到了

870
00:43:23,237 --> 0:43:25,205
当查看如何减少内存占用时

871
00:43:25,806 --> 0:43:29,476
要从未使用的资源开始

872
00:43:29,543 --> 0:43:30,377
因此

873
00:43:30,677 --> 0:43:32,846
让我们实现它吧

874
00:43:34,147 --> 0:43:35,949
它代表我们的使用

875
00:43:36,383 --> 0:43:38,352
并且我们看到我们有大约200MB

876
00:43:38,418 --> 0:43:39,753
那么是不用的纹理

877
00:43:40,487 --> 0:43:42,422
因此作为提醒

878
00:43:43,023 --> 0:43:46,159
不使用的资源是指不会对这个

879
00:43:46,226 --> 0:43:47,661
做出贡献的资源

880
00:43:48,028 --> 0:43:50,297
那意味着GPU不能访问它们

881
00:43:51,765 --> 0:43:52,599
好的

882
00:43:52,900 --> 0:43:56,036
那么我可以再一次

883
00:43:56,103 --> 0:43:58,338
我们现在正在看的就是不用的纹理

884
00:43:59,640 --> 0:44:02,309
接下来我会按所分配的尺寸

885
00:43:59,640 --> 0:44:02,309
接下来我会按所分配的尺寸

886
00:44:02,643 --> 0:44:04,711
从而我们只关注最大的纹理

887
00:44:05,746 --> 0:44:08,482
并且我们可以立刻看到最大的纹理

888
00:44:08,549 --> 0:44:11,618
是大约13MB 有一个问题

889
00:44:12,186 --> 0:44:14,755
这里的问题与你在之前的演示中的

890
00:44:14,821 --> 0:44:16,456
依存查看器中的问题差不多

891
00:44:16,723 --> 0:44:18,525
让我们点击它来查看它是关于什么的

892
00:44:20,360 --> 0:44:22,863
好的 那么它说我们有一个

893
00:44:23,497 --> 0:44:25,199
CPU不对它进行访问

894
00:44:25,566 --> 0:44:27,835
并且从未被绑定到命令编码器中

895
00:44:28,302 --> 0:44:31,171
以避免加载资源

896
00:44:31,238 --> 0:44:32,873
或把它变为易失性资源

897
00:44:33,774 --> 0:44:36,710
我们还可以有另一种解决方式

898
00:44:36,777 --> 0:44:39,213
CPU访问和自上次绑定之后的时间

899
00:44:39,513 --> 0:44:42,850
我们可以明显看到这部分绝对没有

900
00:44:42,916 --> 0:44:45,118
被CPU或GPU访问过

901
00:44:45,419 --> 0:44:46,820
因此我们可以自信地说

902
00:44:46,887 --> 0:44:49,556
这是一个应该被释放的资源

903
00:44:49,623 --> 0:44:50,891
除非我们实际需要它

904
00:44:52,059 --> 0:44:53,026
好的 这非常鼓舞人心

905
00:44:53,093 --> 0:44:56,330
我们会非常迅速的节约

906
00:44:57,097 --> 0:44:58,465
让我们查看下一个问题

907
00:44:59,967 --> 0:45:02,169
在这个例子中 纹理被识别为

908
00:44:59,967 --> 0:45:02,169
在这个例子中 纹理被识别为

909
00:45:02,236 --> 0:45:03,770
临时资源

910
00:45:03,837 --> 0:45:05,506
CPU不对它进行访问

911
00:45:05,572 --> 0:45:07,407
并且在过去的47秒内

912
00:45:07,474 --> 0:45:09,142
它从未被绑定到命令编码器上

913
00:45:09,710 --> 0:45:12,412
因此换句话说

914
00:45:12,479 --> 0:45:15,082
没有使用这个帧或任意其它帧

915
00:45:15,516 --> 0:45:18,051
因此这是一个

916
00:45:18,118 --> 0:45:20,754
如果可以的话

917
00:45:20,821 --> 0:45:23,190
因为它只是偶尔对帧做贡献

918
00:45:23,790 --> 0:45:25,192
好的 这非常好

919
00:45:27,394 --> 0:45:32,699
我们非常迅速地找回了

920
00:45:34,201 --> 0:45:37,137
的确 当我们要减少内存占用时

921
00:45:37,204 --> 0:45:40,107
查看不用的资源是个良好的开端

922
00:45:40,374 --> 0:45:42,442
并且问题会帮助你快速识别

923
00:45:42,509 --> 0:45:44,211
最需要移除的资源

924
00:45:44,978 --> 0:45:47,347
但你还应该注意一下属性

925
00:45:47,981 --> 0:45:50,150
自上次启动之后的时间

926
00:45:50,951 --> 0:45:52,753
来了解哪个不用的资源

927
00:45:52,819 --> 0:45:54,788
从未被提交给GPU

928
00:45:54,855 --> 0:45:57,457
即使CPU可能会对它们进行访问

929
00:45:59,193 --> 0:46:00,661
好的 让我们换个话题吧

930
00:45:59,193 --> 0:46:00,661
好的 让我们换个话题吧

931
00:46:01,161 --> 0:46:03,297
看看我们可以发现哪些问题

932
00:46:03,363 --> 0:46:06,700
当纹理在使用中时

933
00:46:07,768 --> 0:46:09,636
好的 这一次我要切换到

934
00:46:09,703 --> 0:46:11,371
从而我们可以查看使用的纹理

935
00:46:11,939 --> 0:46:13,841
我们可以看到其中一个最大的纹理

936
00:46:13,907 --> 0:46:16,677
大约是18MB 有两个问题

937
00:46:17,344 --> 0:46:18,679
让我们来看看分别是什么

938
00:46:20,247 --> 0:46:22,783
好的 第一个是关于无损压缩

939
00:46:23,417 --> 0:46:25,686
纹理选择退出无损压缩

940
00:46:25,752 --> 0:46:28,488
由于ShaderWrite

941
00:46:28,989 --> 0:46:31,959
即使它被唯一地用作渲染目标

942
00:46:32,960 --> 0:46:35,395
第二个问题是关于存储模式

943
00:46:36,530 --> 0:46:40,133
我们的纹理 即渲染目标

944
00:46:40,400 --> 0:46:42,503
很明显意味着针对这个纹理

945
00:46:42,569 --> 0:46:43,871
没有任何加载或存储操作

946
00:46:44,171 --> 0:46:46,874
但很遗憾 它有共享的存储模式

947
00:46:46,940 --> 0:46:48,809
当它真的应该是不耗内存的时候

948
00:46:49,877 --> 0:46:52,746
我们在这里有两个不同的推荐

949
00:46:53,547 --> 0:46:56,650
如果你思考一下

950
00:46:57,584 --> 0:47:00,687
但在这一点上

951
00:46:57,584 --> 0:47:00,687
但在这一点上

952
00:47:00,754 --> 0:47:02,256
都由内存查看器提供

953
00:47:02,322 --> 0:47:05,292
都是基于把数据收集到当前帧中

954
00:47:05,926 --> 0:47:09,229
然而 你更清楚

955
00:47:09,296 --> 0:47:10,631
使用你的资源

956
00:47:11,431 --> 0:47:12,833
因此

957
00:47:13,534 --> 0:47:16,370
如果我们确定这个纹理

958
00:47:16,737 --> 0:47:18,939
比如将来的渲染通道

959
00:47:19,006 --> 0:47:21,642
然后切换到不耗内存状态

960
00:47:21,708 --> 0:47:24,344
这样会减少纹理尺寸的内存占用

961
00:47:24,411 --> 0:47:26,947
即18MB

962
00:47:27,681 --> 0:47:29,149
如果 在另一方面

963
00:47:29,216 --> 0:47:33,453
我们的纹理在将来的渲染通道中

964
00:47:33,820 --> 0:47:37,457
那么我们应该认真考虑

965
00:47:37,824 --> 0:47:39,860
因为那样会对我们的内存带宽

966
00:47:39,927 --> 0:47:42,296
刚才Guillem曾建议过

967
00:47:43,163 --> 0:47:43,997
在这个例子中

968
00:47:44,331 --> 0:47:46,800
移除冗余的

969
00:47:46,867 --> 0:47:47,868
就可以了

970
00:47:49,636 --> 0:47:50,470
那么

971
00:47:51,972 --> 0:47:54,174
我们只是披露了用内存查看器

972
00:47:54,241 --> 0:47:55,209
可能实现的一部分功能

973
00:47:55,509 --> 0:47:57,110
你已经了解如何使用它

974
00:47:57,177 --> 0:47:59,346
它可以让你轻松地

975
00:47:59,413 --> 0:48:00,514
了解你的内存使用情况

976
00:47:59,413 --> 0:48:00,514
了解你的内存使用情况

977
00:48:00,581 --> 0:48:03,483
同时它还可以让你快速识别

978
00:48:03,550 --> 0:48:06,353
那些可能会影响你的性能的

979
00:48:06,920 --> 0:48:08,655
然后我要欢迎Guillem

980
00:48:08,722 --> 0:48:09,623
回到舞台上来

981
00:48:09,957 --> 0:48:10,791
谢谢

982
00:48:15,362 --> 0:48:17,798
谢谢Onyechi

983
00:48:17,865 --> 0:48:18,765
（演示）

984
00:48:18,832 --> 0:48:19,666
很酷

985
00:48:19,733 --> 0:48:23,237
那么我们今天讲了很多最佳实践

986
00:48:23,303 --> 0:48:24,137
我们…

987
00:48:24,571 --> 0:48:26,173
总共讲了18个

988
00:48:26,240 --> 0:48:28,775
内容真的非常多

989
00:48:29,409 --> 0:48:33,180
请注意大部分最佳实践

990
00:48:33,247 --> 0:48:36,250
绝大部分内存带宽最佳实践

991
00:48:36,316 --> 0:48:39,219
还会帮助你减少内存占用

992
00:48:39,887 --> 0:48:40,721
因此…

993
00:48:41,054 --> 0:48:44,858
也许思考所有这些内容的最佳方式

994
00:48:45,359 --> 0:48:49,396
是这个针对你的Metal游戏

995
00:48:50,364 --> 0:48:55,102
当你认真思考每一个元素时

996
00:48:55,435 --> 0:48:59,339
你一定会提交

997
00:48:59,406 --> 0:49:02,142
这就是本场演讲所讲的内容

998
00:48:59,406 --> 0:49:02,142
这就是本场演讲所讲的内容

999
00:49:03,377 --> 0:49:06,647
要获取更多信息

1000
00:49:06,947 --> 0:49:09,583
并在今天下午3点参加我们的演讲

1001
00:49:10,450 --> 0:49:13,253
非常感谢

1002
00:49:13,320 --> 0:49:14,154
谢谢
