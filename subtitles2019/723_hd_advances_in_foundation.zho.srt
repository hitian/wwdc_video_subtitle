1
00:00:07,007 --> 0:00:12,079
（Foundation进阶）

2
00:00:12,813 --> 0:00:14,014
大家好

3
00:00:14,381 --> 0:00:15,682
我是Tina

4
00:00:16,183 --> 0:00:18,585
我是Foundation团队的

5
00:00:18,652 --> 0:00:22,689
我将会讲解我们为Foundation

6
00:00:22,756 --> 0:00:25,325
现在 我们开始介绍

7
00:00:25,859 --> 0:00:29,029
我们今天会介绍很多不同的内容

8
00:00:31,665 --> 0:00:34,034
我们从有序集合的diff比较开始

9
00:00:34,535 --> 0:00:38,071
它是一个API

10
00:00:38,138 --> 0:00:40,874
计算 编码以及比较之间的差异

11
00:00:41,642 --> 0:00:44,411
我用一个故事来向你们说明

12
00:00:44,912 --> 0:00:48,615
一个bear字符非常

13
00:00:49,183 --> 0:00:50,684
我们来了解如何实现

14
00:00:50,751 --> 0:00:52,319
（有序集合的diff比较）

15
00:00:52,386 --> 0:00:56,723
我们注意到bird中

16
00:00:57,558 --> 0:01:00,794
它还需要bird中的I和D

17
00:00:57,558 --> 0:01:00,794
它还需要bird中的I和D

18
00:01:01,962 --> 0:01:05,199
那么 我们来移掉E和A

19
00:01:05,766 --> 0:01:07,634
在中间插入一个I

20
00:01:08,302 --> 0:01:09,570
在最后插入一个D

21
00:01:10,771 --> 0:01:13,807
这样我们移除了两个

22
00:01:13,874 --> 0:01:16,543
来将bear变为bird

23
00:01:18,545 --> 0:01:22,282
使用有序集合diff比较的API

24
00:01:24,418 --> 0:01:27,287
这里的diff是一个集合的

25
00:01:27,855 --> 0:01:30,791
它是插入和移除的一个集合

26
00:01:31,058 --> 0:01:34,661
表示插入和移除的元素

27
00:01:35,262 --> 0:01:37,898
以及集合中元素的偏移量

28
00:01:38,765 --> 0:01:42,769
你刚才看到的 它包含了两个

29
00:01:45,105 --> 0:01:48,742
我们可以在bear上使用diff

30
00:01:49,476 --> 0:01:53,447
这是一个非常强大的API

31
00:01:53,714 --> 0:01:55,048
任何集合类型都可以

32
00:01:55,115 --> 0:01:57,084
这就是有序集合的diff比较

33
00:01:57,451 --> 0:01:59,953
下面 我们来讲一下数据和连续性

34
00:02:00,020 --> 0:02:01,054
（数据连续性）

35
00:02:01,121 --> 0:02:05,292
你的app可能会在硬盘里创建

36
00:02:05,859 --> 0:02:09,963
通常 这些样式的数据

37
00:02:10,030 --> 0:02:12,366
能很容易地在内存中相连区中展示

38
00:02:14,001 --> 0:02:15,102
另一方面

39
00:02:15,435 --> 0:02:18,172
你的app可能使用比如调度数据

40
00:02:18,238 --> 0:02:21,608
从互联网上下载数据

41
00:02:22,309 --> 0:02:23,610
这会产生字节

42
00:02:23,677 --> 0:02:26,547
在不同时间产生多个块

43
00:02:26,813 --> 0:02:29,950
占据内存中的相连区域

44
00:02:32,219 --> 0:02:33,754
在Swift 5以前

45
00:02:34,021 --> 0:02:38,192
数据结构表示连续和不连续区域

46
00:02:38,825 --> 0:02:41,929
这个统一的界面使用起来很简单

47
00:02:42,663 --> 0:02:45,532
但是它也代表将整个缓存

48
00:02:45,599 --> 0:02:47,267
放置底层原始字节

49
00:02:47,601 --> 0:02:51,305
我们需要复制这个区域

50
00:02:53,106 --> 0:02:56,677
这意味着有时候会有无法预知的

51
00:02:57,277 --> 0:03:01,415
事实上 我们知道数据真实使用情况

52
00:02:57,277 --> 0:03:01,415
事实上 我们知道数据真实使用情况

53
00:03:02,015 --> 0:03:03,884
每个不连续的数据

54
00:03:03,951 --> 0:03:06,620
在它的生命周期中有时畅通无阻

55
00:03:09,022 --> 0:03:13,660
所以 从Swift 5开始

56
00:03:13,727 --> 0:03:15,562
一个连续的缓存类型

57
00:03:16,296 --> 0:03:21,935
为在语法中施行该协议 我们引入了

58
00:03:23,203 --> 0:03:25,372
为了遵循这个协议

59
00:03:25,439 --> 0:03:29,309
这个类型提供以直接

60
00:03:29,610 --> 0:03:31,078
连续的方式进入底层原始字节

61
00:03:31,545 --> 0:03:32,913
所以 你再也不必担心

62
00:03:32,980 --> 0:03:35,749
意外地接触到你的数据了

63
00:03:37,084 --> 0:03:40,320
现在 我们是如何处理其他

64
00:03:40,387 --> 0:03:42,289
不连续的缓存类型的呢？

65
00:03:44,424 --> 0:03:49,329
我们介绍了两个新的协议

66
00:03:49,596 --> 0:03:51,865
将结构数据的界面从独立变为连续

67
00:03:52,132 --> 0:03:55,068
将它推广到不同的缓存类型

68
00:03:55,469 --> 0:03:58,005
我们来看DataProtocol

69
00:03:58,705 --> 0:04:02,943
这是一个字节的集合

70
00:03:58,705 --> 0:04:02,943
这是一个字节的集合

71
00:04:03,277 --> 0:04:05,946
提供了额外的多变性保证

72
00:04:08,882 --> 0:04:13,020
Buffer类型是由Swift

73
00:04:13,086 --> 0:04:16,790
调度框架采用了这些协议

74
00:04:17,524 --> 0:04:19,692
你可能已经用过其中的一些类型

75
00:04:19,760 --> 0:04:24,298
包括Data、UInt8数组和

76
00:04:25,465 --> 0:04:28,936
我们建议你也在你的类型或方法

77
00:04:29,002 --> 0:04:30,637
作为一个通用的约束

78
00:04:33,974 --> 0:04:35,709
现在我们来看一下约束

79
00:04:36,743 --> 0:04:40,380
通常 你想要将你的数据

80
00:04:41,081 --> 0:04:42,482
你的app可能在有限的

81
00:04:42,549 --> 0:04:45,652
磁盘空间的设备上运行

82
00:04:46,053 --> 0:04:49,590
或者你需要在网上

83
00:04:51,325 --> 0:04:53,093
这是一个非常常见的任务

84
00:04:53,460 --> 0:04:56,730
所以我们在Swift上的数据

85
00:04:57,397 --> 0:04:58,899
它现在很简单

86
00:04:59,600 --> 0:05:00,434
谢谢

87
00:04:59,600 --> 0:05:00,434
谢谢

88
00:05:03,136 --> 0:05:05,572
它只是一行代码

89
00:05:07,541 --> 0:05:10,844
这个API也支持4种压缩算法

90
00:05:11,411 --> 0:05:14,648
基于速度 内存和压缩率

91
00:05:14,715 --> 0:05:16,850
来为你提供不同的平衡区

92
00:05:17,451 --> 0:05:20,587
我相信你能从中找到

93
00:05:22,489 --> 0:05:23,323
（单元）

94
00:05:23,390 --> 0:05:25,025
现在 我们来讲单元

95
00:05:25,759 --> 0:05:30,531
Foundation已经支持了

96
00:05:30,898 --> 0:05:33,934
比如长度 速度和时长

97
00:05:35,102 --> 0:05:39,840
我们扩展了单元时长类型

98
00:05:39,907 --> 0:05:41,542
将亚秒单元提升至了皮秒

99
00:05:41,942 --> 0:05:44,278
这是万亿分之一秒

100
00:05:45,445 --> 0:05:49,650
现在 单元频率类型使用赫兹

101
00:05:50,150 --> 0:05:52,786
今年 我们引入了

102
00:05:53,687 --> 0:05:55,956
它和赫兹的功能相同

103
00:05:56,390 --> 0:06:01,628
但它非常适合度量设备的FPS

104
00:05:56,390 --> 0:06:01,628
但它非常适合度量设备的FPS

105
00:06:04,364 --> 0:06:07,100
UnitInformationStorage

106
00:06:07,968 --> 0:06:11,605
它能被用来表示数码信息的数量

107
00:06:12,639 --> 0:06:15,909
基本单元是位 字节和四位元

108
00:06:16,643 --> 0:06:22,850
通常使用的前缀为

109
00:06:22,916 --> 0:06:26,520
从kilo和kibi

110
00:06:27,721 --> 0:06:31,058
使用MeasurementFormatter一起

111
00:06:31,124 --> 0:06:33,293
来设计格式 比如数据大小

112
00:06:33,760 --> 0:06:38,165
或使用ByteCountFormatter

113
00:06:40,400 --> 0:06:42,236
我们为你提供了更多的格式器

114
00:06:42,302 --> 0:06:43,237
（展示一个日期或时间）

115
00:06:43,303 --> 0:06:46,473
你可能每天都看到过这些字符串

116
00:06:47,074 --> 0:06:50,777
比如 一则你发送的消息状态

117
00:06:51,278 --> 0:06:53,947
或是明天的一项付款

118
00:06:54,481 --> 0:06:58,886
它是当前展示的

119
00:07:00,053 --> 0:07:00,888
它是

120
00:07:00,954 --> 0:07:04,258
对于所有语言环境来说

121
00:07:04,992 --> 0:07:08,529
我们引入了RelativeDateTimeFormatter

122
00:07:14,635 --> 0:07:15,469
谢谢

123
00:07:15,836 --> 0:07:20,174
和其他格式器类似

124
00:07:20,440 --> 0:07:22,910
你可以选择的类型有很多

125
00:07:23,243 --> 0:07:24,378
（相对的时间日期格式器）

126
00:07:24,912 --> 0:07:27,581
你想要的另一个样式可能是一个列表

127
00:07:28,415 --> 0:07:32,519
我们也引入了ListFormatter

128
00:07:32,586 --> 0:07:37,324
（列表格式器）

129
00:07:37,391 --> 0:07:41,328
它将使用正确的分隔符将

130
00:07:41,395 --> 0:07:43,630
连接了所有的语言环境

131
00:07:44,831 --> 0:07:46,266
这是另一个例子

132
00:07:46,934 --> 0:07:48,836
一个事件会在

133
00:07:48,902 --> 0:07:51,071
三个不同的日期发生

134
00:07:51,638 --> 0:07:54,975
所以你会想要展现一个像上面的或是

135
00:07:55,742 --> 0:07:57,077
下面的字符串

136
00:07:57,144 --> 0:08:00,514
在你的事件页面罗列出月份

137
00:07:57,144 --> 0:08:00,514
在你的事件页面罗列出月份

138
00:08:02,249 --> 0:08:04,218
以及 当然 你会想要使用

139
00:08:04,284 --> 0:08:08,088
和不同语言环境的本地化名字来展示

140
00:08:08,689 --> 0:08:11,992
这很重要 因为 比如

141
00:08:12,559 --> 0:08:15,395
通常在书面形式上

142
00:08:16,663 --> 0:08:19,766
也可用ListFormatter

143
00:08:22,102 --> 0:08:25,038
它有一个属性叫做

144
00:08:25,405 --> 0:08:28,342
规定列表上的每一项的格式

145
00:08:28,909 --> 0:08:31,945
在这种情况下 我想要

146
00:08:32,779 --> 0:08:35,582
我们知道Foundation的

147
00:08:35,649 --> 0:08:37,083
支持日期格式化

148
00:08:37,751 --> 0:08:40,754
所以 我们使用它作为我们日期的

149
00:08:41,922 --> 0:08:43,390
这就是我们想要的

150
00:08:43,823 --> 0:08:44,892
完成了

151
00:08:45,792 --> 0:08:49,763
这就是示例底部的本地化字符串

152
00:08:53,133 --> 0:08:57,371
你很容易通过设置DateFormatter

153
00:08:58,238 --> 0:09:02,676
ListFormatter适用于

154
00:08:58,238 --> 0:09:02,676
ListFormatter适用于

155
00:09:02,743 --> 0:09:06,914
为你的app提供更好的

156
00:09:10,150 --> 0:09:11,718
这就是格式器

157
00:09:12,152 --> 0:09:14,254
下面 我们来介绍操作队列

158
00:09:14,321 --> 0:09:15,389
（操作队列）

159
00:09:15,455 --> 0:09:16,723
想象一下 在你的app中

160
00:09:16,990 --> 0:09:20,127
有一些后台任务在同时运行

161
00:09:21,762 --> 0:09:22,763
现在

162
00:09:23,096 --> 0:09:25,899
用户想保存这个运行中app的状态

163
00:09:26,466 --> 0:09:27,935
那么 你要如何实现呢

164
00:09:28,936 --> 0:09:32,105
那么 你想要确认所有运行中的

165
00:09:32,172 --> 0:09:33,540
任务在你能保存之前会结束

166
00:09:34,341 --> 0:09:37,477
所以它可能需要这样实现

167
00:09:39,446 --> 0:09:42,416
你检查当前队列中

168
00:09:42,482 --> 0:09:43,750
运行操作的数量

169
00:09:44,318 --> 0:09:45,986
如果没有

170
00:09:46,053 --> 0:09:49,223
它就说明我们之前规划的任务

171
00:09:49,590 --> 0:09:51,325
所以我们可以保存了 是吗？

172
00:09:52,192 --> 0:09:53,727
不是的

173
00:09:54,161 --> 0:09:55,495
请不要这么做

174
00:09:58,465 --> 0:10:00,501
在它们所有的线程中

175
00:09:58,465 --> 0:10:00,501
在它们所有的线程中

176
00:10:00,567 --> 0:10:03,604
其他的任务有可能在同时运行

177
00:10:03,904 --> 0:10:08,342
比如 它在检查之后

178
00:10:09,710 --> 0:10:14,648
你这里需要的是一个屏障

179
00:10:14,715 --> 0:10:19,586
在app状态被保存时

180
00:10:20,621 --> 0:10:21,688
像这样

181
00:10:24,191 --> 0:10:28,962
所以 我们很兴奋地告诉你

182
00:10:29,563 --> 0:10:31,398
你应添加BarrierBlock

183
00:10:31,465 --> 0:10:34,401
在屏障内进行保存操作

184
00:10:35,102 --> 0:10:37,638
这会保证在那段特定的时间

185
00:10:37,704 --> 0:10:41,542
保存操作是唯一在运行的任务

186
00:10:42,242 --> 0:10:46,313
以及 它只会在所有任务运行结束后

187
00:10:46,747 --> 0:10:50,918
在它结束前不会有其他

188
00:10:57,958 --> 0:11:01,562
操作队列另一个更新的点是

189
00:10:57,958 --> 0:11:01,562
操作队列另一个更新的点是

190
00:11:02,396 --> 0:11:04,965
有时你可能想要追踪你当前

191
00:11:05,032 --> 0:11:06,533
所有任务的所有的进程

192
00:11:06,834 --> 0:11:09,670
在你的UI中展示一个进度栏

193
00:11:10,370 --> 0:11:13,774
你现在可以通过设置操作队列中的

194
00:11:13,841 --> 0:11:17,177
进程属性

195
00:11:17,244 --> 0:11:18,312
（操作队列）

196
00:11:18,378 --> 0:11:21,381
你在操作队列上加入的

197
00:11:21,448 --> 0:11:25,485
在操作结束后 计数器为所有的

198
00:11:25,552 --> 0:11:27,221
进程创建一个完成单元

199
00:11:32,626 --> 0:11:34,127
接下来是文件系统

200
00:11:34,194 --> 0:11:35,128
（为iOS上的

201
00:11:35,195 --> 0:11:40,300
iOS现在支持USB和SMB卷

202
00:11:41,101 --> 0:11:43,904
这代表着你应该为处理可能在

203
00:11:43,971 --> 0:11:46,006
其他卷上的文件做好准备

204
00:11:46,940 --> 0:11:50,844
在如下场景 请确保使用FileManager

205
00:11:51,111 --> 0:11:54,414
当你为写入新的文件内容选择地方时

206
00:11:54,481 --> 0:11:57,484
当你操作原子级的安全保存时

207
00:11:59,620 --> 0:12:03,390
接下来 如果用户弹出USB设备

208
00:11:59,620 --> 0:12:03,390
接下来 如果用户弹出USB设备

209
00:12:03,457 --> 0:12:07,995
或失去与SMB服务器网络连接

210
00:12:08,061 --> 0:12:09,496
你要在卷完全消失之前做好准备

211
00:12:10,631 --> 0:12:14,268
如果你在读取数据对象时

212
00:12:14,835 --> 0:12:18,839
确保使用mappedIfSafe

213
00:12:19,673 --> 0:12:23,577
这会允许系统映射文件至虚拟内存中

214
00:12:24,144 --> 0:12:28,215
但仅当文件处于不可移动的卷时

215
00:12:28,815 --> 0:12:33,187
从USB或SMB盘上读取文件

216
00:12:33,253 --> 0:12:35,856
内置存储器慢很多

217
00:12:36,890 --> 0:12:38,692
所以 如果你还没有实现它

218
00:12:39,059 --> 0:12:42,629
请将文件系统放置到非主线程里

219
00:12:42,696 --> 0:12:45,232
来保持你的app持续相应

220
00:12:46,800 --> 0:12:50,571
在使用它们之前 你可能需要测试

221
00:12:51,371 --> 0:12:52,372
比如

222
00:12:52,773 --> 0:12:56,243
你熟悉的APFS功能 比如克隆

223
00:12:57,044 --> 0:13:00,547
在当你通过USB或SMB

224
00:12:57,044 --> 0:13:00,547
在当你通过USB或SMB

225
00:13:00,614 --> 0:13:02,549
访问其他卷时可能不可用

226
00:13:03,784 --> 0:13:06,720
你可以通过

227
00:13:06,787 --> 0:13:09,223
大量的URL资源关键字事件

228
00:13:09,957 --> 0:13:14,695
或在处理收取错误时做好准备

229
00:13:15,696 --> 0:13:18,131
你可以在文件管理

230
00:13:18,198 --> 0:13:22,102
的演讲上了解关于它的更多信息

231
00:13:25,706 --> 0:13:27,407
接下来 Swift更新

232
00:13:27,474 --> 0:13:28,642
（Swift更新了扫描仪）

233
00:13:28,709 --> 0:13:33,280
一些Swift的API最开始基于

234
00:13:34,047 --> 0:13:37,651
我们这些年在不断提升它们

235
00:13:38,452 --> 0:13:39,720
首先是扫描仪

236
00:13:41,588 --> 0:13:43,690
这是Swift 4上的API

237
00:13:44,458 --> 0:13:46,426
它之前被用来使用NSString

238
00:13:47,528 --> 0:13:49,496
和通过引用返回对象

239
00:13:51,265 --> 0:13:56,904
在Swift 5.1

240
00:13:58,639 --> 0:14:03,443
以及这个新的API使用了

241
00:13:58,639 --> 0:14:03,443
以及这个新的API使用了

242
00:14:03,977 --> 0:14:06,880
字符串是图新的集合

243
00:14:06,947 --> 0:14:08,582
而不是代码点

244
00:14:09,349 --> 0:14:12,519
这意味着使用新的扫描仪的API

245
00:14:12,586 --> 0:14:16,623
你现在能处理复杂的序列

246
00:14:18,659 --> 0:14:19,893
（SWIFT更新了文件句柄）

247
00:14:19,960 --> 0:14:22,095
另一个提升的地方是文件句柄

248
00:14:22,996 --> 0:14:25,799
它以前被用来处理当错误发生时

249
00:14:25,866 --> 0:14:28,268
在底层的文件描述符抛出异常

250
00:14:29,269 --> 0:14:32,406
今年 我们引入了基于错误的API

251
00:14:32,840 --> 0:14:36,577
现在你能立刻调用站点处理错误

252
00:14:37,878 --> 0:14:41,748
这个为写入数据创建的API

253
00:14:42,316 --> 0:14:45,719
它也为非连续数据做了优化

254
00:14:48,455 --> 0:14:51,091
这些就是新API的亮点

255
00:14:51,725 --> 0:14:56,263
我们鼓励你在新的Xcode中

256
00:14:56,330 --> 0:14:57,164
（试一试）

257
00:14:57,231 --> 0:15:00,300
当使用二进制数据创建新方法时

258
00:14:57,231 --> 0:15:00,300
当使用二进制数据创建新方法时

259
00:15:00,934 --> 0:15:04,004
考虑为它们绑定数据协议类型

260
00:15:04,404 --> 0:15:09,243
而不是请求特殊的集合

261
00:15:10,477 --> 0:15:15,382
如果你在UI上以字符串的形式

262
00:15:16,550 --> 0:15:20,754
使用RelativeDateTimeFormatter

263
00:15:20,821 --> 0:15:23,524
来让字符串在每个语言环境都能

264
00:15:25,225 --> 0:15:28,328
我们强烈向你推荐操作队列的屏障

265
00:15:28,395 --> 0:15:30,197
来避免竞太条件

266
00:15:31,131 --> 0:15:34,601
如果你使用了一些进程报告机制

267
00:15:35,135 --> 0:15:38,138
转换成操作队列提供的那个吧

268
00:15:38,972 --> 0:15:39,806
谢谢

269
00:15:42,109 --> 0:15:45,812
（更多信息）
