1
00:00:06,640 --> 0:00:07,741
（LLDB：不止“PO”）

2
00:00:07,808 --> 0:00:09,810
大家好 我是Davide

3
00:00:09,877 --> 0:00:10,811
我是一名工程师

4
00:00:10,878 --> 0:00:13,480
来自Apple调试技术团队

5
00:00:13,914 --> 0:00:16,015
今天我将与我的同事

6
00:00:16,350 --> 0:00:21,054
你们可能很熟悉po了 它是一种

7
00:00:21,421 --> 0:00:24,491
今天我们就来谈谈po及其运行方式

8
00:00:25,125 --> 0:00:29,329
我们也会介绍其他方法

9
00:00:29,396 --> 0:00:33,033
以及进行格式化输出的机制

10
00:00:34,134 --> 0:00:38,505
LLDB是为Xcode中的

11
00:00:39,473 --> 0:00:42,876
你可以看到定义的变量及其类型

12
00:00:43,243 --> 0:00:44,912
在Xcode进行调试时

13
00:00:44,978 --> 0:00:47,047
你可以在窗口右下方

14
00:00:47,114 --> 0:00:49,850
直接发送命令

15
00:00:49,917 --> 0:00:52,052
并通过控制台与LLDB进行交互

16
00:00:52,519 --> 0:00:55,622
它可以你检查app中的错误时

17
00:00:55,689 --> 0:00:57,624
同时打印出定义

18
00:00:57,691 --> 0:01:00,260
源代码的变量值

19
00:00:57,691 --> 0:01:00,260
源代码的变量值

20
00:01:00,594 --> 0:01:04,397
LLDB可以有多种方式

21
00:01:04,464 --> 0:01:07,568
而每种方式都有不同的权衡取舍

22
00:01:07,634 --> 0:01:08,869
我们来看

23
00:01:09,436 --> 0:01:10,604
在这个例子中

24
00:01:10,671 --> 0:01:13,574
假设我们有一个代表Trip的结构

25
00:01:13,774 --> 0:01:16,844
由名和目的站组成

26
00:01:17,177 --> 0:01:19,746
接下来让我们仔细看看

27
00:01:20,948 --> 0:01:24,751
我们要探究的第一个命令是po

28
00:01:24,818 --> 0:01:28,455
你可以把它看作是打印对象描述

29
00:01:28,522 --> 0:01:30,023
当我们运用这个命令时

30
00:01:30,090 --> 0:01:33,427
我们得到的返回就是对象描述

31
00:01:33,493 --> 0:01:36,997
也就是你打印实例的文本表达

32
00:01:37,531 --> 0:01:40,367
系统运行时会提供一个默认值

33
00:01:40,434 --> 0:01:42,536
但也是可以自定义的

34
00:01:43,170 --> 0:01:45,839
我们可以将一致性

35
00:01:45,906 --> 0:01:49,109
加入至CustomDebugStringConvertible

36
00:01:49,743 --> 0:01:54,114
这需要一种叫

37
00:01:55,048 --> 0:01:58,919
现在如果我们在调试工具中

38
00:01:59,152 --> 0:02:03,123
我们就可以看到我们规定的描述

39
00:01:59,152 --> 0:02:03,123
我们就可以看到我们规定的描述

40
00:02:03,557 --> 0:02:06,493
此项更改仅影响顶级描述

41
00:02:07,928 --> 0:02:10,163
如果你需要修改子结构

42
00:02:10,229 --> 0:02:14,168
就查看CustomerReflectable

43
00:02:14,434 --> 0:02:17,304
也可以通过

44
00:02:17,371 --> 0:02:19,740
实现描述方法

45
00:02:21,175 --> 0:02:24,344
但是po能做的不仅仅是打印变量

46
00:02:24,411 --> 0:02:25,579
比如

47
00:02:25,646 --> 0:02:27,581
你可以得到漫游名称

48
00:02:27,648 --> 0:02:30,150
并计算出它的大写版本

49
00:02:30,484 --> 0:02:34,488
或者是按字母排序的漫游目的站

50
00:02:35,289 --> 0:02:39,426
一般来说 它可以评估任何表达方式

51
00:02:39,493 --> 0:02:43,263
所以 任意给定命令提示符中

52
00:02:43,330 --> 0:02:45,799
都可以作为参数传递给注释

53
00:02:46,867 --> 0:02:47,734
实际上

54
00:02:47,801 --> 0:02:51,638
po是一个名为表达的命令的别名

55
00:02:51,705 --> 0:02:54,575
含有能够打印对象描述的参数

56
00:02:55,209 --> 0:02:59,179
LECC和LLDB都是让你

57
00:03:00,047 --> 0:03:03,617
比如说 你想自己实现po

58
00:03:03,684 --> 0:03:05,285
你就可以用alias命令

59
00:03:05,352 --> 0:03:08,589
将你的命令名称指定为第一个参数

60
00:03:08,655 --> 0:03:11,091
再按照你想进行

61
00:03:11,391 --> 0:03:12,960
确定好之后

62
00:03:13,026 --> 0:03:15,963
你就可以像LLDB中其他命令一样

63
00:03:17,231 --> 0:03:19,199
现在我们了解了po可以做什么

64
00:03:19,266 --> 0:03:21,568
我们再来深入看看它是怎么运行的

65
00:03:22,302 --> 0:03:26,306
让我们来看看po要传输一个值时

66
00:03:26,607 --> 0:03:30,043
为了让你现在使用的语言

67
00:03:30,110 --> 0:03:33,814
LLDB不会解析和评估表达本身

68
00:03:34,214 --> 0:03:37,718
相反 它一开始会生成一串源代码

69
00:03:37,784 --> 0:03:40,721
这些代码是由你所给定的表达编译的

70
00:03:40,988 --> 0:03:43,423
跟这里展示的片段很像

71
00:03:43,490 --> 0:03:46,760
之后它会运用嵌入式Swift

72
00:03:46,827 --> 0:03:48,095
来编译代码

73
00:03:48,161 --> 0:03:52,266
之后会在你

74
00:03:52,866 --> 0:03:55,035
一旦执行完成

75
00:03:55,102 --> 0:03:57,971
LLDB就要访问结果值

76
00:04:00,140 --> 0:04:02,609
从结果值 你要得到对象描述

77
00:04:02,676 --> 0:04:07,781
为此 LLDB将前一结果

78
00:04:08,115 --> 0:04:12,953
这也会被编译并在

79
00:04:13,387 --> 0:04:17,624
执行结果是LLDB

80
00:04:17,690 --> 0:04:19,860
显示的字符串

81
00:04:19,927 --> 0:04:22,029
po只是三种方式中的一种

82
00:04:22,095 --> 0:04:24,865
我们要介绍

83
00:04:24,932 --> 0:04:26,633
我们再来看看其他方式

84
00:04:26,700 --> 0:04:29,703
第二种在LLDB中打印变量的方式

85
00:04:29,770 --> 0:04:31,004
叫p命令

86
00:04:31,371 --> 0:04:35,042
可以把它想象成是一种

87
00:04:35,409 --> 0:04:36,910
让我们来看看它的输出

88
00:04:37,611 --> 0:04:38,879
要注意的第一点是

89
00:04:38,946 --> 0:04:41,315
它与在po中的表达

90
00:04:41,381 --> 0:04:43,550
略有不同之处

91
00:04:43,617 --> 0:04:47,321
但它们包含的是同样的信息

92
00:04:47,821 --> 0:04:49,089
需要注意的第二点

93
00:04:49,156 --> 0:04:53,293
是结果值已被命名为$R0

94
00:04:53,894 --> 0:04:56,430
这是LLDB中的特殊约定

95
00:04:56,730 --> 0:05:00,067
每个表达的结果都要被赋予增值名称

96
00:04:56,730 --> 0:05:00,067
每个表达的结果都要被赋予增值名称

97
00:05:00,133 --> 0:05:03,704
比如$R1和$R2

98
00:05:03,770 --> 0:05:07,307
这些名称在LLDB

99
00:05:07,574 --> 0:05:10,143
你可以参考$R0

100
00:05:10,210 --> 0:05:13,180
与你的项目中其他变量西欧昂通

101
00:05:13,580 --> 0:05:16,717
比如说 你可以打印损坏字段

102
00:05:17,184 --> 0:05:18,652
与po类似

103
00:05:18,719 --> 0:05:21,588
P在LLDB中也并不是顶级命令

104
00:05:21,655 --> 0:05:24,558
它只是表达命令的别名

105
00:05:24,625 --> 0:05:28,095
但是后面不用加--对象描述

106
00:05:28,762 --> 0:05:30,697
就像刚刚的po一样

107
00:05:30,764 --> 0:05:33,500
我们具体来看p是如何运作的

108
00:05:35,235 --> 0:05:37,571
因为p不需要获取表述

109
00:05:37,638 --> 0:05:39,840
它也就没有那么复杂

110
00:05:39,907 --> 0:05:43,744
你可以从之前我对po的介绍中

111
00:05:44,011 --> 0:05:46,046
实际上 第一部分

112
00:05:46,113 --> 0:05:48,549
编译和评估表达

113
00:05:48,615 --> 0:05:50,918
对于这两种命令是完全一样的

114
00:05:51,285 --> 0:05:53,253
但当它得到结果后

115
00:05:53,320 --> 0:05:57,024
LLDB会执行一项

116
00:05:57,558 --> 0:05:59,793
说得更具体一些

117
00:06:00,160 --> 0:06:01,461
为了做到这一点

118
00:06:01,528 --> 0:06:04,198
我们要对例子进行一些修改

119
00:06:04,498 --> 0:06:05,599
我们来看看是怎么做的

120
00:06:06,400 --> 0:06:08,268
我们更改Trip结构

121
00:06:08,335 --> 0:06:10,971
以符合协议名称活动

122
00:06:11,705 --> 0:06:15,275
在Swift中

123
00:06:15,342 --> 0:06:17,377
和运行时的动态类型

124
00:06:17,444 --> 0:06:19,379
不一定是相同的

125
00:06:19,813 --> 0:06:20,747
例如

126
00:06:20,814 --> 0:06:24,418
变量可声明使用该种类型协议

127
00:06:25,018 --> 0:06:26,453
在该例中

128
00:06:26,520 --> 0:06:28,722
变量是静态的漫游活动

129
00:06:29,189 --> 0:06:30,557
但在运行时

130
00:06:30,624 --> 0:06:33,560
该变量又会具有Trip类型实例

131
00:06:33,994 --> 0:06:35,462
既动态

132
00:06:36,530 --> 0:06:38,165
如果我们打印漫游值

133
00:06:38,232 --> 0:06:40,601
我们会得到Trip类型对象

134
00:06:40,667 --> 0:06:43,237
因为LLDB重新生成了结果元数据

135
00:06:43,303 --> 0:06:44,872
在给定的程序点显示

136
00:06:44,938 --> 0:06:47,774
给定变量的最准确类型

137
00:06:48,208 --> 0:06:50,944
这也就是我们所说的动态类型解析

138
00:06:51,144 --> 0:06:52,679
在p命令里

139
00:06:52,746 --> 0:06:57,484
动态类型解析仅会对表达结果执行

140
00:06:57,818 --> 0:07:00,754
假设我们要访问一个漫游字段

141
00:06:57,818 --> 0:07:00,754
假设我们要访问一个漫游字段

142
00:07:01,054 --> 0:07:04,558
当LLDB想通过p

143
00:07:04,625 --> 0:07:07,494
我们看到漫游是一个活动类型对象

144
00:07:07,861 --> 0:07:09,830
也没有叫name的成员

145
00:07:10,197 --> 0:07:12,266
出现错误 评估失败

146
00:07:12,599 --> 0:07:15,302
原因是 如果你还记得的话

147
00:07:15,669 --> 0:07:18,205
LLDB在p命令运行位置编译代码

148
00:07:18,272 --> 0:07:21,475
且唯一可识别的代码类型

149
00:07:21,542 --> 0:07:22,776
也就是静态类型

150
00:07:23,243 --> 0:07:25,345
如果你在源代码中打出

151
00:07:25,412 --> 0:07:27,814
cruise.name的

152
00:07:27,881 --> 0:07:30,817
静态编译器会报错并拒绝执行

153
00:07:31,785 --> 0:07:34,688
如果你想评估表达且不被报错

154
00:07:34,755 --> 0:07:39,059
首先你需要将对象转化为其动态类型

155
00:07:39,126 --> 0:07:41,361
然后再访问结果字段

156
00:07:41,662 --> 0:07:44,998
这在调试工具和你的源代码中都一样

157
00:07:46,567 --> 0:07:48,836
到这里p命令还没有结束

158
00:07:49,102 --> 0:07:52,840
在结果中执行动态解析后

159
00:07:52,906 --> 0:07:57,044
LLDB将生成的对象传递给

160
00:07:57,110 --> 0:07:58,412
这也是LLDB要做的事

161
00:07:58,478 --> 0:08:02,916
打印出人能够看懂的对象描述

162
00:07:58,478 --> 0:08:02,916
打印出人能够看懂的对象描述

163
00:08:02,983 --> 0:08:04,017
让我们来细看

164
00:08:05,452 --> 0:08:07,321
为了展示格式化是如何进行的

165
00:08:07,387 --> 0:08:09,990
我将展示它的输入和输出

166
00:08:10,757 --> 0:08:12,526
如果没有格式化

167
00:08:12,593 --> 0:08:14,928
字符串就会是这样的

168
00:08:15,629 --> 0:08:17,197
如果你想自己尝试

169
00:08:17,264 --> 0:08:19,900
你可以给p命令传递--原始选项

170
00:08:20,367 --> 0:08:22,069
标准库类型

171
00:08:22,135 --> 0:08:24,538
即使是像字符串和整数

172
00:08:24,605 --> 0:08:26,707
都有复杂的表达

173
00:08:26,773 --> 0:08:29,443
因为它们针对速度和大小

174
00:08:30,477 --> 0:08:32,645
在进行格式化操作之后

175
00:08:32,712 --> 0:08:34,982
字符串看起来就如你所想

176
00:08:35,048 --> 0:08:36,817
一串字母

177
00:08:37,518 --> 0:08:41,255
LLDB了解许多常用类型

178
00:08:41,321 --> 0:08:43,524
也可以将它们格式化

179
00:08:43,823 --> 0:08:46,660
你还可以自己编写自定义格式化程序

180
00:08:46,727 --> 0:08:48,529
我们简单说说

181
00:08:49,363 --> 0:08:51,798
我们刚刚介绍了po和p

182
00:08:52,332 --> 0:08:56,703
现在来介绍LLDB中

183
00:08:56,770 --> 0:08:57,838
v命令

184
00:08:59,206 --> 0:09:00,607
v命令的输出

185
00:08:59,206 --> 0:09:00,607
v命令的输出

186
00:09:00,674 --> 0:09:02,676
和p是完全一样的

187
00:09:02,743 --> 0:09:05,746
因为它靠的也是

188
00:09:06,914 --> 0:09:08,615
像其他两个命令一样

189
00:09:08,682 --> 0:09:12,619
v也是我们在Xcode 10.2

190
00:09:12,686 --> 0:09:14,888
帧变量命令的一个别名

191
00:09:14,955 --> 0:09:16,957
但他不像刚刚两个命令

192
00:09:17,024 --> 0:09:20,194
v命令并不编译和执行代码

193
00:09:20,260 --> 0:09:22,029
所以它非常快

194
00:09:22,930 --> 0:09:24,865
由于v命令不编译代码

195
00:09:24,932 --> 0:09:26,567
它有自己的语法

196
00:09:26,633 --> 0:09:30,437
它的语法可能和你在调试中

197
00:09:30,704 --> 0:09:34,708
例如 它用点和下标符

198
00:09:34,775 --> 0:09:36,610
来访问字段

199
00:09:36,677 --> 0:09:39,213
但他在解析时并不会过载运行

200
00:09:39,279 --> 0:09:42,216
也无法评估计算属性

201
00:09:42,549 --> 0:09:45,586
由于它要执行代码

202
00:09:46,086 --> 0:09:49,423
你可以用p或po

203
00:09:49,723 --> 0:09:50,924
你可能也想到了

204
00:09:51,158 --> 0:09:54,328
v命令与其他两种打印变量的

205
00:09:54,394 --> 0:09:55,929
运行方式大相径庭

206
00:09:56,230 --> 0:09:59,099
我们详细来看

207
00:09:59,166 --> 0:10:03,103
在图中 这是v命令

208
00:09:59,166 --> 0:10:03,103
在图中 这是v命令

209
00:10:03,504 --> 0:10:05,339
我们要打印变量

210
00:10:05,405 --> 0:10:06,440
为此

211
00:10:06,507 --> 0:10:10,811
v命令会首先查询程序状态

212
00:10:10,878 --> 0:10:14,348
之后 它在内存中读取变量值

213
00:10:14,414 --> 0:10:17,484
然后对其进行动态类型解析

214
00:10:17,551 --> 0:10:20,320
如果用户要求访问子字段

215
00:10:20,387 --> 0:10:23,390
它会在子字段中重复上述步骤

216
00:10:23,457 --> 0:10:26,627
每次都会进行动态变量解析

217
00:10:26,960 --> 0:10:28,362
完成之后

218
00:10:28,428 --> 0:10:31,932
它就会传递数据格式化子系统的结果

219
00:10:32,399 --> 0:10:35,369
v命令可能多次进行

220
00:10:35,435 --> 0:10:37,337
动态类型解析

221
00:10:37,404 --> 0:10:39,606
这是我们需要记住的一点

222
00:10:39,673 --> 0:10:43,210
也是p命令和v命令运行中

223
00:10:43,277 --> 0:10:47,247
格式化程序只执行一次动态类型解析

224
00:10:47,314 --> 0:10:50,050
我们来看这些情况

225
00:10:51,185 --> 0:10:52,886
回到我们的例子

226
00:10:52,953 --> 0:10:55,956
p命令无法访问漫游成员的地方

227
00:10:56,323 --> 0:11:00,861
通过在解释的每个步骤中

228
00:10:56,323 --> 0:11:00,861
通过在解释的每个步骤中

229
00:11:00,928 --> 0:11:04,665
v命令知道漫游是

230
00:11:04,965 --> 0:11:06,900
能够从内存中访问它的字段

231
00:11:07,901 --> 0:11:11,538
这是它比P命令要好的一点

232
00:11:11,605 --> 0:11:13,407
它可以让你查看

233
00:11:13,473 --> 0:11:16,210
p命令没有转化的类型

234
00:11:17,177 --> 0:11:19,413
我们说完了这三种

235
00:11:19,479 --> 0:11:21,982
在LLDB中打印变量的方式

236
00:11:23,383 --> 0:11:24,651
我们来回顾一下

237
00:11:24,718 --> 0:11:29,890
以及对比po、p和v命令的不同

238
00:11:30,524 --> 0:11:32,059
要说的第一点是

239
00:11:32,125 --> 0:11:34,561
对象是如何呈现的

240
00:11:35,362 --> 0:11:38,298
po命令运用的是对象描述

241
00:11:38,365 --> 0:11:40,701
而p和v命令

242
00:11:40,767 --> 0:11:43,437
运用的是格式化程序来呈现对象

243
00:11:44,037 --> 0:11:47,074
我们也要记住计算结果的方式

244
00:11:47,441 --> 0:11:49,810
po和p都会编译表达

245
00:11:49,877 --> 0:11:51,812
并且可以访问完整的语言

246
00:11:52,179 --> 0:11:54,381
而v命令有自己的语法

247
00:11:54,448 --> 0:11:56,216
解释和表达

248
00:11:56,283 --> 0:12:00,721
并在解释的每步中

249
00:11:56,283 --> 0:12:00,721
并在解释的每步中

250
00:12:02,322 --> 0:12:06,693
我们刚才也提过

251
00:12:06,760 --> 0:12:08,262
接下来我们也会详细讲到

252
00:12:08,328 --> 0:12:10,297
有请我的同事Jonas

253
00:12:10,364 --> 0:12:12,199
大家好 我是Jonas

254
00:12:12,566 --> 0:12:15,736
我也是调试技术团队的一名工程师

255
00:12:16,069 --> 0:12:17,304
在LLDB中

256
00:12:17,371 --> 0:12:20,140
在调试工具中的数据格式化程序

257
00:12:20,207 --> 0:12:21,275
定义了变量的显示方式

258
00:12:22,776 --> 0:12:25,546
建立格式化程序有几种常见的类型

259
00:12:25,612 --> 0:12:26,880
在实例中

260
00:12:26,947 --> 0:12:28,348
当我们运用v命令时

261
00:12:28,415 --> 0:12:30,651
我们可以打印漫游的目的地

262
00:12:30,717 --> 0:12:33,854
以及以可读形式显示的数组元素

263
00:12:34,421 --> 0:12:38,992
通常 默认的格式化程序在

264
00:12:39,059 --> 0:12:41,261
和标准库中的类型里都能运行

265
00:12:41,728 --> 0:12:44,765
但有时 你可能要调整

266
00:12:45,065 --> 0:12:46,266
或者自己找一个

267
00:12:48,001 --> 0:12:49,069
你也可以做到

268
00:12:49,136 --> 0:12:52,973
因为LLDB中的数据格式化程序

269
00:12:53,273 --> 0:12:55,776
每种类型都有自己的表达

270
00:12:56,143 --> 0:12:58,478
为了帮助你自定义这些表达

271
00:12:58,545 --> 0:13:02,816
LLDB会提供过滤器

272
00:12:58,545 --> 0:13:02,816
LLDB会提供过滤器

273
00:13:04,418 --> 0:13:08,121
过滤器用于限制

274
00:13:08,188 --> 0:13:11,124
现在我们的Trip只有几个目的地

275
00:13:11,191 --> 0:13:14,795
但随着数量的增加

276
00:13:15,662 --> 0:13:16,964
通过过滤器

277
00:13:17,030 --> 0:13:20,167
我们就能指定只显示Trip名称

278
00:13:20,934 --> 0:13:23,871
这不仅只影响控制台

279
00:13:23,937 --> 0:13:25,906
同时也影响Xcode中的变量

280
00:13:26,573 --> 0:13:29,309
在我们继续之前先把过滤器去掉

281
00:13:30,644 --> 0:13:33,680
摘要能够提供一种类型的字符串表达

282
00:13:33,747 --> 0:13:36,450
为了一目了然地显示

283
00:13:36,517 --> 0:13:39,319
他们的数据格式化程序

284
00:13:39,386 --> 0:13:41,455
和你在用po的时候是一样的

285
00:13:41,955 --> 0:13:43,223
加上过滤器之后

286
00:13:43,290 --> 0:13:45,459
它也可以影响Xcode中

287
00:13:46,193 --> 0:13:48,562
Trip种的所有成员都是有摘要的

288
00:13:48,629 --> 0:13:49,930
但Trip本身是没有的

289
00:13:50,197 --> 0:13:51,298
我们改一下

290
00:13:52,566 --> 0:13:55,836
一个好的摘要应该是

291
00:13:56,236 --> 0:13:58,805
摘要字符串包括常规文本

292
00:13:58,872 --> 0:13:59,840
和特殊变量

293
00:13:59,907 --> 0:14:02,709
这些内容能够访问正在打印的字段

294
00:13:59,907 --> 0:14:02,709
这些内容能够访问正在打印的字段

295
00:14:03,143 --> 0:14:05,112
该变量以美元标志开始

296
00:14:05,179 --> 0:14:06,980
用花括号括起来

297
00:14:07,314 --> 0:14:09,783
它们的语法和v命令一致

298
00:14:10,217 --> 0:14:12,953
摘要定义的当前类型

299
00:14:13,020 --> 0:14:14,588
以var形式进行访问

300
00:14:14,988 --> 0:14:18,525
该摘要以var.name

301
00:14:18,592 --> 0:14:21,862
以var.destinations

302
00:14:22,563 --> 0:14:24,531
但这样的摘要有一个问题

303
00:14:24,598 --> 0:14:28,302
它只有在包含这三种特定目的地的

304
00:14:28,669 --> 0:14:31,071
因为格式化程序无法访问计算变量

305
00:14:31,138 --> 0:14:32,472
比如一个数组

306
00:14:32,539 --> 0:14:35,108
我们必须对最后一个元素的

307
00:14:36,543 --> 0:14:39,880
幸运的是 我们还有其他有用的工具

308
00:14:40,113 --> 0:14:42,482
我们可以在Python里定义摘要

309
00:14:43,083 --> 0:14:46,086
Python的格式化程序

310
00:14:46,153 --> 0:14:49,890
而且它可以完全访问

311
00:14:50,224 --> 0:14:51,792
还可以提供用于

312
00:14:51,859 --> 0:14:54,895
访问当前调试会话状态的对象

313
00:14:56,463 --> 0:14:59,666
目标是当前正在调试的程序

314
00:14:59,733 --> 0:15:02,402
进程 线程和框架

315
00:14:59,733 --> 0:15:02,402
进程 线程和框架

316
00:15:02,469 --> 0:15:05,506
都为对应运行时信息提供访问

317
00:15:06,507 --> 0:15:10,377
变量 寄存器和表达的值

318
00:15:10,444 --> 0:15:13,347
都由SB值类进行表示

319
00:15:13,413 --> 0:15:16,617
这对数据格式化程序来说十分有趣

320
00:15:16,683 --> 0:15:19,920
因为其可以用来定位

321
00:15:20,354 --> 0:15:23,357
更多详细信息请查看在线文档

322
00:15:25,158 --> 0:15:26,760
从Xcode 11开始

323
00:15:26,827 --> 0:15:28,529
脚本使用的是Python 3

324
00:15:28,962 --> 0:15:30,931
如果你用的是

325
00:15:30,998 --> 0:15:32,666
请查看Xcode的发行说明

326
00:15:32,733 --> 0:15:35,402
上面有如何转换到

327
00:15:38,038 --> 0:15:40,140
让我们来探究LDB API

328
00:15:40,841 --> 0:15:42,442
执行脚本命令

329
00:15:42,509 --> 0:15:45,445
将其放入交互式

330
00:15:46,046 --> 0:15:49,850
lldb.frame变量

331
00:15:50,217 --> 0:15:52,352
返回为一个SBFrame实例

332
00:15:52,819 --> 0:15:55,822
我们知道当前框架

333
00:15:56,089 --> 0:16:00,394
因此我们可以用

334
00:15:56,089 --> 0:16:00,394
因此我们可以用

335
00:16:01,161 --> 0:16:04,298
由于这些对象为

336
00:16:04,364 --> 0:16:06,133
所以将它们打印出来

337
00:16:06,200 --> 0:16:09,503
看起来与其对应的

338
00:16:11,438 --> 0:16:14,942
我们也知道该漫游有一个叫

339
00:16:15,008 --> 0:16:18,145
我们可以通过调用

340
00:16:18,779 --> 0:16:23,083
结果是另一个表示目标数组的SB值

341
00:16:24,618 --> 0:16:27,888
让我们用Python

342
00:16:27,955 --> 0:16:30,991
这一次最后一个元素的索引

343
00:16:31,425 --> 0:16:34,828
我们可以在SB值目的地

344
00:16:34,895 --> 0:16:36,530
来获取元素数量

345
00:16:36,964 --> 0:16:38,332
通过GetChildAtIndex

346
00:16:38,398 --> 0:16:41,735
我们可以访问第一和最后一个元素

347
00:16:42,369 --> 0:16:45,339
请注意 打印值

348
00:16:45,405 --> 0:16:47,407
它们包含了数组中的索引

349
00:16:47,808 --> 0:16:51,545
SB值实例维持着

350
00:16:52,579 --> 0:16:55,649
现在 我们可以将所有东西

351
00:16:55,949 --> 0:16:58,852
然而结果并不是我们想要的

352
00:16:59,152 --> 0:17:01,288
通过打印开始和结束

353
00:16:59,152 --> 0:17:01,288
通过打印开始和结束

354
00:17:01,355 --> 0:17:03,957
我们获取到了SB值对象的描述

355
00:17:04,223 --> 0:17:06,760
但是我们想要的是它们的摘要

356
00:17:07,294 --> 0:17:10,531
我们可以使用GetSummary

357
00:17:10,597 --> 0:17:11,765
并使用它们

358
00:17:12,165 --> 0:17:13,233
现在的结果

359
00:17:13,300 --> 0:17:15,836
只有目标字符串本身

360
00:17:17,104 --> 0:17:18,739
现在我们把所有都综合到一起

361
00:17:18,805 --> 0:17:22,075
格式化程序可以在

362
00:17:22,142 --> 0:17:25,012
或者你可以创建一个文件

363
00:17:25,279 --> 0:17:28,415
我们创建一个

364
00:17:28,949 --> 0:17:30,884
当在文件中定义提供程序时

365
00:17:30,951 --> 0:17:34,354
无需使用当前框架

366
00:17:34,421 --> 0:17:38,058
SB值会作为输入参数传递给函数

367
00:17:38,659 --> 0:17:40,060
接下来的步骤

368
00:17:40,127 --> 0:17:43,063
就和之前的类似

369
00:17:43,630 --> 0:17:46,800
用Python来定义

370
00:17:46,867 --> 0:17:48,302
我们有控制流程

371
00:17:48,735 --> 0:17:50,537
如果该Trip没有目的地

372
00:17:50,604 --> 0:17:52,773
我们就可以打印为空Trip

373
00:17:53,307 --> 0:17:55,976
我们可以获取第一和最后一个目的地

374
00:17:56,043 --> 0:17:57,644
并返回为摘要字符串

375
00:17:58,912 --> 0:18:02,449
现在 我们要将新的摘要提供程序

376
00:17:58,912 --> 0:18:02,449
现在 我们要将新的摘要提供程序

377
00:18:02,749 --> 0:18:05,853
可以使用脚本导入命令完成

378
00:18:06,320 --> 0:18:09,089
接下来

379
00:18:09,156 --> 0:18:11,558
之前用于Trip类型的那个

380
00:18:11,625 --> 0:18:13,227
使用类型摘要添加

381
00:18:13,293 --> 0:18:15,295
并提供要格式化的类型

382
00:18:15,362 --> 0:18:17,197
及要使用的提供程序函数

383
00:18:17,698 --> 0:18:20,400
在这里 使用完全限定类型非常重要

384
00:18:20,801 --> 0:18:22,169
一切都搞定之后

385
00:18:22,236 --> 0:18:25,806
v命令会用Python

386
00:18:27,274 --> 0:18:29,443
该摘要不仅会在控制台显示

387
00:18:29,510 --> 0:18:32,045
也会也显示在Xcode变量视图中

388
00:18:33,180 --> 0:18:35,215
我们讲到了过滤器和摘要

389
00:18:35,282 --> 0:18:37,718
最后一种自定义类型显示的方法

390
00:18:37,784 --> 0:18:39,453
就是将合成子项

391
00:18:39,820 --> 0:18:44,191
这可以使你自定义类型的子项

392
00:18:44,258 --> 0:18:47,661
例如当你在Xcode中

393
00:18:48,195 --> 0:18:52,633
在Python中 各子项都有一个

394
00:18:54,434 --> 0:18:56,637
定义自己的合成子项提供程序

395
00:18:56,703 --> 0:18:59,006
与定义摘要提供程序类似

396
00:18:59,072 --> 0:19:00,340
但是我们不定义函数

397
00:18:59,072 --> 0:19:00,340
但是我们不定义函数

398
00:19:00,407 --> 0:19:03,143
而是定义特定实现方法的类

399
00:19:03,477 --> 0:19:04,778
除了init之外

400
00:19:04,845 --> 0:19:07,681
你还提供了获取子项总数的方法

401
00:19:07,748 --> 0:19:09,449
合成子项本身

402
00:19:09,516 --> 0:19:11,151
及给定名称的索引

403
00:19:11,652 --> 0:19:15,556
此期的资源链接中有完整示例

404
00:19:18,025 --> 0:19:19,026
和刚才一样

405
00:19:19,092 --> 0:19:23,030
使用脚本导入命令将Python

406
00:19:23,363 --> 0:19:24,198
在这个例子中

407
00:19:24,264 --> 0:19:26,166
我们在刚刚已经加载了过滤器

408
00:19:26,233 --> 0:19:28,635
再次运行该命令会重新加载文件

409
00:19:29,970 --> 0:19:33,006
指定用于合成子项的格式化程序

410
00:19:33,073 --> 0:19:34,842
运用类型合成添加

411
00:19:34,908 --> 0:19:37,811
并提供要格式化的类型和要使用的类

412
00:19:39,513 --> 0:19:42,983
在定义好我们自定义的提供程序后

413
00:19:43,050 --> 0:19:45,719
我们不希望在

414
00:19:46,253 --> 0:19:48,088
你在控制台的所有命令

415
00:19:48,155 --> 0:19:52,259
可以永久保存在主目录中的

416
00:19:52,759 --> 0:19:56,396
在调试会话开始时

417
00:19:58,665 --> 0:20:00,734
LLDB具有多种功能

418
00:19:58,665 --> 0:20:00,734
LLDB具有多种功能

419
00:20:00,801 --> 0:20:03,737
可助你在调试时查看程序的状态

420
00:20:03,971 --> 0:20:07,541
运用v、p还是po命令来打印变量

421
00:20:07,608 --> 0:20:10,143
取决于你是否需要只显示其值

422
00:20:10,210 --> 0:20:13,213
要执行命令还是获取对象描是

423
00:20:13,580 --> 0:20:15,949
自定义或定义

424
00:20:16,016 --> 0:20:19,620
可以使用过滤器 摘要和合成子项

425
00:20:20,087 --> 0:20:23,156
最后 如果你用的是

426
00:20:23,223 --> 0:20:25,659
请更新

427
00:20:25,726 --> 0:20:29,229
LLDB使用的版本

428
00:20:30,864 --> 0:20:32,065
欲知更多信息

429
00:20:32,132 --> 0:20:35,602
请登录developer.apple.com
