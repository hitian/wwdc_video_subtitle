1
00:00:01,176 --> 0:00:04,500
[音乐]

2
00:00:10,516 --> 0:00:14,996
[掌声]

3
00:00:15,496 --> 0:00:17,416
&gt;&gt; 女士们 先生们下午好

4
00:00:18,106 --> 0:00:19,746
欢迎来到 Filesystem 的会议

5
00:00:20,666 --> 0:00:22,556
在本次会议中

6
00:00:22,556 --> 0:00:25,676
我们将介绍与 Filesystem 相关的几个主题

7
00:00:25,866 --> 0:00:27,946
首先 我们将了解

8
00:00:27,946 --> 0:00:30,306
文件系统在保护 macOS 上的

9
00:00:30,376 --> 0:00:33,106
系统软件中

10
00:00:33,106 --> 0:00:34,616
所起的作用

11
00:00:36,336 --> 0:00:38,876
我们将描述卷复制

12
00:00:38,876 --> 0:00:41,766
在 APFS 中的工作原理

13
00:00:42,636 --> 0:00:45,426
最后 我们将讨论

14
00:00:45,946 --> 0:00:47,936
即将迎来的 

15
00:00:47,936 --> 0:00:49,566
运行 iOS 和 iPadOS 设备的

16
00:00:49,566 --> 0:00:52,736
新的和非常令人兴奋的功能

17
00:00:53,376 --> 0:00:55,516
即访问外部媒体上

18
00:00:55,916 --> 0:00:57,326
的外部文件

19
00:00:57,846 --> 0:01:03,146
但在我们开始之前

20
00:00:57,846 --> 0:01:03,146
但在我们开始之前

21
00:01:03,706 --> 0:01:06,166
让我们回顾最近 APFS 发生的事情

22
00:01:06,536 --> 0:01:09,426
APFS 一直是默认的文件系统

23
00:01:09,546 --> 0:01:12,556
-- 自 10.3 以来在 iOS 和 tvOS 上

24
00:01:12,556 --> 0:01:17,766
以及自 High Sierra 

25
00:01:17,846 --> 0:01:18,736
以来的 macOS 上

26
00:01:22,576 --> 0:01:24,316
APFS 引入的功能之一是

27
00:01:24,316 --> 0:01:28,546
内置卷管理器

28
00:01:30,436 --> 0:01:32,506
卷的概念对 APFS 来说

29
00:01:32,506 --> 0:01:33,836
并不陌生 

30
00:01:34,326 --> 0:01:36,626
它们存在于 HFS Plus 中

31
00:01:37,876 --> 0:01:41,206
HFS Plus 卷是此分区上的

32
00:01:41,206 --> 0:01:44,336
一对一映射

33
00:01:45,006 --> 0:01:49,426
它占用磁盘上连续的块范围

34
00:01:50,756 --> 0:01:52,236
由于这种

35
00:01:52,236 --> 0:01:55,736
一对一映射到分区

36
00:01:55,736 --> 0:01:58,756
和 HFS Plus 卷无法轻松添加

37
00:01:59,106 --> 0:02:02,266
要将新卷添加到分区磁盘

38
00:01:59,106 --> 0:02:02,266
要将新卷添加到分区磁盘

39
00:02:02,266 --> 0:02:05,576
你们首先需要

40
00:02:05,576 --> 0:02:08,156
缩小现有卷

41
00:02:08,395 --> 0:02:12,346
然后你们可以添加新卷

42
00:02:12,346 --> 0:02:14,386
APFS 卷更灵活

43
00:02:14,386 --> 0:02:17,496
因为它们与兄弟卷

44
00:02:17,816 --> 0:02:19,466
共享自己的

45
00:02:20,256 --> 0:02:21,506
磁盘分区空间

46
00:02:22,816 --> 0:02:26,486
而且这种灵活性

47
00:02:27,406 --> 0:02:30,686
允许更高级别的

48
00:02:31,766 --> 0:02:33,386
系统实现无法

49
00:02:33,386 --> 0:02:35,546
用旧式卷

50
00:02:35,546 --> 0:02:38,316
实现的功能

51
00:02:39,876 --> 0:02:41,966
我们要介绍中的一个 - 我们

52
00:02:42,006 --> 0:02:44,426
将实施的功能之一是

53
00:02:44,816 --> 0:02:47,236
保护系统软件免受

54
00:02:47,466 --> 0:02:49,806
恶意或意外更新

55
00:02:52,716 --> 0:02:54,626
你们可能还记得

56
00:02:54,816 --> 0:02:57,376
在 macOS El Capitan 时代

57
00:02:57,376 --> 0:03:01,966
我们介绍了系统完整性保护的概念

58
00:02:57,376 --> 0:03:01,966
我们介绍了系统完整性保护的概念

59
00:03:03,596 --> 0:03:08,126
它用于控制对目录层次结构的

60
00:03:08,436 --> 0:03:11,656
一部分的访问

61
00:03:12,816 --> 0:03:14,556
某些目录将被写保护

62
00:03:14,836 --> 0:03:16,716
而文件系统的其他部分

63
00:03:16,716 --> 0:03:19,816
将被允许更改

64
00:03:20,466 --> 0:03:23,616
今年 我们更进一步

65
00:03:23,616 --> 0:03:29,306
我们将整个根文件系统设为只读

66
00:03:30,516 --> 0:03:35,936
[欢呼和掌声]

67
00:03:36,436 --> 0:03:38,796
显然 无法安装

68
00:03:38,846 --> 0:03:41,176
新软件或用户无法

69
00:03:41,176 --> 0:03:43,906
保存数据的系统

70
00:03:43,906 --> 0:03:45,536
并不是特别有用

71
00:03:47,996 --> 0:03:49,346
为了实现我们

72
00:03:49,346 --> 0:03:50,666
如何协调这两个

73
00:03:50,666 --> 0:03:53,516
相互冲突的目标

74
00:03:53,516 --> 0:03:54,916
同时只读和可写

75
00:03:55,606 --> 0:03:57,186
让我们来看看

76
00:03:57,276 --> 0:03:59,026
当我们从 macOS Mojave 升级到

77
00:03:59,266 --> 0:04:01,166
macOS Catalina 时会发生什么

78
00:03:59,266 --> 0:04:01,166
macOS Catalina 时会发生什么

79
00:04:01,706 --> 0:04:06,196
macOS Mojave 上的

80
00:04:06,196 --> 0:04:08,596
一个典型容器具有一个主卷

81
00:04:08,596 --> 0:04:11,906
并且服务量很少

82
00:04:11,906 --> 0:04:13,996
例如 VM

83
00:04:14,406 --> 0:04:17,146
主卷用于存储

84
00:04:17,146 --> 0:04:20,736
用户的数据和系统软件

85
00:04:22,436 --> 0:04:24,436
当我们开始升级时 --

86
00:04:30,126 --> 0:04:32,036
当我们开始升级到 

87
00:04:32,426 --> 0:04:36,566
macOS Catalina 时

88
00:04:36,566 --> 0:04:38,596
我们首先更改主卷的职能

89
00:04:38,596 --> 0:04:40,286
并将其标记为数据卷

90
00:04:41,776 --> 0:04:44,956
然后 我们可以修剪

91
00:04:44,956 --> 0:04:46,806
仅包含系统软件的

92
00:04:46,806 --> 0:04:48,946
指令层次结构的某些部分

93
00:04:50,426 --> 0:04:53,986
一经完成后

94
00:04:54,206 --> 0:04:56,216
我们就可以进入下一个阶段

95
00:04:56,216 --> 0:04:58,696
我们将创建一个新的空卷

96
00:04:58,696 --> 0:05:02,456
该卷仅用于存储系统软件

97
00:04:58,696 --> 0:05:02,456
该卷仅用于存储系统软件

98
00:05:02,666 --> 0:05:05,396
我们将使用系统

99
00:05:05,396 --> 0:05:06,406
内容填充该卷

100
00:05:06,986 --> 0:05:09,026
一旦这个过程完成

101
00:05:09,836 --> 0:05:11,706
我们就可以在保护方面宣布成功

102
00:05:12,056 --> 0:05:13,696
我们是只读的 我们受到保护

103
00:05:14,016 --> 0:05:16,976
这很好 但还不够

104
00:05:19,256 --> 0:05:21,846
我们仍然需要以某种方式

105
00:05:21,846 --> 0:05:25,406
将新系统内容与用户内容联系起来

106
00:05:25,866 --> 0:05:27,896
为此 我们介绍了

107
00:05:27,896 --> 0:05:29,286
卷组的概念

108
00:05:30,046 --> 0:05:32,626
卷组是由一个数据卷

109
00:05:32,626 --> 0:05:34,846
和一个系统卷组成的

110
00:05:35,196 --> 0:05:36,586
他们将其视为一个

111
00:05:36,586 --> 0:05:37,616
单一的实体

112
00:05:38,746 --> 0:05:42,496
UI 将其显示为单个磁盘

113
00:05:43,126 --> 0:05:45,036
它们共享加密状态

114
00:05:45,796 --> 0:05:48,016
如果你们的卷已加密

115
00:05:48,016 --> 0:05:50,086
则可以使用相同的密码

116
00:05:50,086 --> 0:05:51,766
来解锁这两个卷

117
00:05:52,566 --> 0:05:55,516
几乎所有东西看起来

118
00:05:55,516 --> 0:05:58,726
都是一个统一的实体

119
00:05:59,936 --> 0:06:01,946
有一件事是 我们还没做的

120
00:05:59,936 --> 0:06:01,946
有一件事是 我们还没做的

121
00:06:02,186 --> 0:06:04,326
我们仍然需要以某种方式提供

122
00:06:04,326 --> 0:06:07,066
单个目录层次结构的错觉

123
00:06:08,026 --> 0:06:10,916
传统上 

124
00:06:11,406 --> 0:06:14,666
它是通过在根文件系统中的

125
00:06:14,666 --> 0:06:16,866
目录之上安装文件系统来完成的

126
00:06:18,226 --> 0:06:20,266
由于我们需要引入

127
00:06:20,266 --> 0:06:21,636
许多交叉点

128
00:06:21,636 --> 0:06:24,946
以及文件系统中

129
00:06:25,026 --> 0:06:26,246
所需的卷数之多

130
00:06:26,246 --> 0:06:28,176
这种方法变得

131
00:06:28,246 --> 0:06:29,426
相当具有消耗性

132
00:06:29,916 --> 0:06:32,296
因此 为了解决这个问题

133
00:06:32,296 --> 0:06:34,926
我们引入了一个名为 Firmlink 的新概念

134
00:06:35,416 --> 0:06:39,616
Firmlink 是一个新的文件系统对象

135
00:06:40,776 --> 0:06:42,316
它与 Symlink 类似

136
00:06:42,876 --> 0:06:46,136
但与 Symlink 不同

137
00:06:46,526 --> 0:06:50,426
Firmlink 支持向后和

138
00:06:51,046 --> 0:06:53,326
向前路径反转

139
00:06:53,936 --> 0:06:57,246
这在其表示中是一致的

140
00:06:58,036 --> 0:07:00,886
而且这种一致性非常重要

141
00:06:58,036 --> 0:07:00,886
而且这种一致性非常重要

142
00:07:00,926 --> 0:07:02,476
如果你曾经不得不处理一个 App

143
00:07:02,476 --> 0:07:04,966
而绝对需要它

144
00:07:04,966 --> 0:07:06,936
必须存在于

145
00:07:06,936 --> 0:07:08,416
特定的目录中

146
00:07:08,416 --> 0:07:09,686
比如在 App 目录下

147
00:07:10,096 --> 0:07:12,066
你们知道 

148
00:07:12,096 --> 0:07:15,096
你们必须能够

149
00:07:15,096 --> 0:07:16,676
从文件系统的顶部或者从道路

150
00:07:16,676 --> 0:07:18,586
向下走到支路上

151
00:07:18,586 --> 0:07:21,186
并且能够得到相同的路径

152
00:07:21,736 --> 0:07:22,976
我们可以用 Firmlink 做到这一点

153
00:07:29,216 --> 0:07:34,116
Firmlink 是从

154
00:07:34,116 --> 0:07:36,436
系统卷上的目录到数

155
00:07:36,436 --> 0:07:40,866
据卷上的目录的遍历点

156
00:07:42,246 --> 0:07:44,916
它们只有一对一的映射 一个来源

157
00:07:45,036 --> 0:07:45,716
一个目标的映射

158
00:07:47,066 --> 0:07:48,896
你们不能使用 Firmlink

159
00:07:48,896 --> 0:07:50,976
跨越卷组的边界

160
00:07:54,256 --> 0:07:56,116
Firmlink 对于

161
00:07:56,116 --> 0:07:58,336
用户和 App 非常易懂

162
00:07:58,726 --> 0:08:00,436
它们是在安装时

163
00:07:58,726 --> 0:08:00,436
它们是在安装时

164
00:08:00,436 --> 0:08:01,426
通过 install 创建的 

165
00:08:01,946 --> 0:08:03,976
它们一般不会被注意到

166
00:08:08,256 --> 0:08:10,246
一旦我们得到这个新工具

167
00:08:10,246 --> 0:08:13,426
我们就可以用它来拼凑卷

168
00:08:13,426 --> 0:08:16,976
安装程序将在系统卷上创建条目

169
00:08:22,426 --> 0:08:24,446
并将它们指向

170
00:08:24,446 --> 0:08:27,976
数据卷上的相应卷

171
00:08:31,576 --> 0:08:34,346
一旦完成后 

172
00:08:34,346 --> 0:08:36,976
我们就有了统一的目录层次结构

173
00:08:37,686 --> 0:08:40,155
我们可以重新启动

174
00:08:40,155 --> 0:08:42,006
以只读方式挂载 root

175
00:08:42,006 --> 0:08:42,976
并享受它给我们的保护

176
00:08:49,686 --> 0:08:50,726
生活很美好

177
00:08:51,446 --> 0:08:52,496
一切都受到保护了

178
00:08:53,066 --> 0:08:53,986
一切都在运行

179
00:08:54,726 --> 0:08:56,556
但你们仍需记住

180
00:08:58,026 --> 0:09:01,356
在安装过程中拆分卷

181
00:08:58,026 --> 0:09:01,356
在安装过程中拆分卷

182
00:09:01,726 --> 0:09:03,446
没有办法避免它

183
00:09:03,786 --> 0:09:04,516
它会发生的

184
00:09:05,116 --> 0:09:09,626
在开发人员的预览中 

185
00:09:09,626 --> 0:09:12,166
我们选择保留

186
00:09:12,296 --> 0:09:14,606
根文件系统可写

187
00:09:14,606 --> 0:09:16,736
以便你们更轻松地测试 App 

188
00:09:17,596 --> 0:09:19,026
如果你们想模仿

189
00:09:19,026 --> 0:09:21,796
将来实现的行为

190
00:09:22,966 --> 0:09:24,636
你们则可以

191
00:09:24,636 --> 0:09:26,586
在根目录中创建

192
00:09:26,586 --> 0:09:30,026
一个特殊文件 并在重新启动时

193
00:09:30,026 --> 0:09:32,256
你们的卷将会以只读方式挂载

194
00:09:33,506 --> 0:09:35,066
这将在下一个种子的

195
00:09:35,066 --> 0:09:37,786
下一次构建中发生变化

196
00:09:42,256 --> 0:09:45,496
在发布版本中 

197
00:09:45,496 --> 0:09:48,196
如果禁用系统完整性保护

198
00:09:48,196 --> 0:09:51,516
你们仍然可以

199
00:09:51,516 --> 0:09:53,426
将根文件系统挂载为读写

200
00:09:54,896 --> 0:09:57,616
但这不是一个持久的变化

201
00:09:58,016 --> 0:10:00,566
在重新启动时 

202
00:09:58,016 --> 0:10:00,566
在重新启动时 

203
00:10:00,566 --> 0:10:03,296
它将恢复为只读状态

204
00:10:03,866 --> 0:10:06,216
你们可以再一次将其重新安装为只读

205
00:10:06,216 --> 0:10:07,806
读写状态

206
00:10:08,886 --> 0:10:10,116
同样的 它将在重新启动时

207
00:10:10,116 --> 0:10:11,686
恢复到相同的状态

208
00:10:13,306 --> 0:10:14,906
你们可以想象 

209
00:10:14,906 --> 0:10:17,366
这是 macOS 形状和安装方式

210
00:10:17,516 --> 0:10:20,016
的一个相当大的变化

211
00:10:20,886 --> 0:10:23,986
它可以捕获一些 App

212
00:10:24,816 --> 0:10:25,806
例如 如果你们的 App 

213
00:10:25,806 --> 0:10:27,946
在文件系统上

214
00:10:27,946 --> 0:10:30,536
使用复杂布局

215
00:10:30,736 --> 0:10:32,666
或附带安装程序包

216
00:10:32,666 --> 0:10:35,576
请确保它适用于

217
00:10:35,576 --> 0:10:38,976
新的只读根分区

218
00:10:42,046 --> 0:10:43,376
如果你们正在编写备份实用程序

219
00:10:43,376 --> 0:10:47,246
该实用程序关注 inode 编号

220
00:10:47,246 --> 0:10:49,996
文件系统 ID 等

221
00:10:49,996 --> 0:10:52,286
请确保对其进行测试

222
00:10:52,286 --> 0:10:53,896
因为你们之前

223
00:10:53,896 --> 0:10:56,836
可能具有的假设也许不正确

224
00:10:57,276 --> 0:11:01,006
所以底线是测试 测试 测试

225
00:10:57,276 --> 0:11:01,006
所以底线是测试 测试 测试

226
00:11:01,946 --> 0:11:03,846
接下来 

227
00:11:03,846 --> 0:11:06,426
我将交给 Jon Becker 由他来说说卷复制

228
00:11:08,516 --> 0:11:12,500
[掌声]

229
00:11:16,166 --> 0:11:19,576
&gt;&gt; 谢谢你 Max 大家下午好

230
00:11:20,436 --> 0:11:21,556
我的名字是 Jon

231
00:11:21,556 --> 0:11:22,646
我将讨论使用 APFS 

232
00:11:22,646 --> 0:11:24,326
进行卷复制

233
00:11:24,836 --> 0:11:26,306
不妨让我们直接进入

234
00:11:26,796 --> 0:11:28,276
什么是卷复制

235
00:11:29,296 --> 0:11:31,606
嗯 基本的想法很简单

236
00:11:31,606 --> 0:11:34,296
我们想要将一个卷 复制到另一个卷

237
00:11:35,366 --> 0:11:39,536
这听起来很简单 但这一点的重要方面

238
00:11:39,806 --> 0:11:41,286
是我们希望这个副本的

239
00:11:41,286 --> 0:11:42,966
保真度尽可能高

240
00:11:43,756 --> 0:11:45,946
通常 只进行

241
00:11:45,946 --> 0:11:48,016
逐个文件复制是不够的

242
00:11:48,306 --> 0:11:52,046
我们希望复制所有卷内容

243
00:11:52,456 --> 0:11:56,036
复制所有数据 所有元数据 卷属性

244
00:11:56,326 --> 0:11:58,056
如果源卷包含可启动的 OS 

245
00:11:58,056 --> 0:12:00,126
我们希望复制

246
00:11:58,056 --> 0:12:00,126
我们希望复制

247
00:12:00,126 --> 0:12:01,666
使该卷可启动的元数据

248
00:12:01,666 --> 0:12:03,356
以便我们的

249
00:12:03,396 --> 0:12:06,086
副本目标也可以启动

250
00:12:06,086 --> 0:12:08,156
现在 我将讨论

251
00:12:08,156 --> 0:12:10,586
Apple 软件在 Restore 命令行实用程序

252
00:12:10,586 --> 0:12:12,346
或 ASR 环境中

253
00:12:12,346 --> 0:12:14,186
的复制

254
00:12:14,186 --> 0:12:17,486
ASR 已经存在了很长时间

255
00:12:17,486 --> 0:12:19,406
你们中的许多人可能都熟悉它

256
00:12:19,406 --> 0:12:20,906
它的主要功能是

257
00:12:20,906 --> 0:12:22,266
进行卷复制

258
00:12:23,646 --> 0:12:25,206
现在 有了 ASR 对于我们的

259
00:12:25,206 --> 0:12:26,606
复制源而言很常见的

260
00:12:26,606 --> 0:12:29,096
是磁盘映像

261
00:12:29,096 --> 0:12:30,986
在这种情况下

262
00:12:30,986 --> 0:12:33,216
我们经常会参考执行

263
00:12:33,216 --> 0:12:34,786
此复制的过程 - 将目标卷

264
00:12:34,786 --> 0:12:37,656
恢复(Restore)为目标卷

265
00:12:38,056 --> 0:12:39,786
这就是 Apple Software Restore 名字的由来

266
00:12:40,156 --> 0:12:41,966
但你会听到我使用的

267
00:12:42,026 --> 0:12:44,026
恢复和复制的专业术语

268
00:12:44,026 --> 0:12:45,036
几乎可以互换

269
00:12:46,696 --> 0:12:50,796
那么谁想要这个呢

270
00:12:50,796 --> 0:12:52,336
谁需要这个功能呢

271
00:12:53,576 --> 0:12:56,186
好吧 如果你在教育

272
00:12:56,186 --> 0:12:58,436
或企业 IT 如果你做的事情

273
00:12:58,436 --> 0:13:00,866
类似配置有大量机器的大型实验室

274
00:12:58,436 --> 0:13:00,866
类似配置有大量机器的大型实验室

275
00:13:00,866 --> 0:13:02,636
或者如果你编写

276
00:13:02,636 --> 0:13:04,156
备份实用程序

277
00:13:04,156 --> 0:13:06,166
那么复制是一个

278
00:13:06,206 --> 0:13:08,526
你可能需要或想要定期

279
00:13:08,526 --> 0:13:09,576
使用的功能

280
00:13:10,296 --> 0:13:12,816
正如我们将看到的

281
00:13:12,816 --> 0:13:14,496
APFS 的一些新功能

282
00:13:14,526 --> 0:13:15,756
对我们如何进行复制

283
00:13:15,756 --> 0:13:16,396
提出了挑战

284
00:13:17,536 --> 0:13:19,406
另一方面 同样也看到 

285
00:13:19,406 --> 0:13:21,486
这些新功能还

286
00:13:21,486 --> 0:13:23,586
提供了使复制

287
00:13:23,586 --> 0:13:25,596
成为更强大 更灵活的

288
00:13:25,596 --> 0:13:26,656
操作的可能

289
00:13:27,706 --> 0:13:29,416
所以我想稍微备份一下

290
00:13:29,416 --> 0:13:32,096
然后再谈谈复制

291
00:13:32,096 --> 0:13:33,446
在过去 APFS 之前

292
00:13:33,446 --> 0:13:35,066
看起来如何

293
00:13:35,566 --> 0:13:37,596
现在正如 Max 所展示的那样

294
00:13:38,136 --> 0:13:40,886
对于以前的文件系统 

295
00:13:41,636 --> 0:13:43,656
如 HFS Plus 文件系统

296
00:13:43,656 --> 0:13:45,176
或者我应该说的卷

297
00:13:45,176 --> 0:13:46,706
与包含它的分区是

298
00:13:46,706 --> 0:13:48,056
一对一的关系

299
00:13:48,536 --> 0:13:49,896
这意味着该卷

300
00:13:49,896 --> 0:13:52,936
由一个连续的块设备支持

301
00:13:53,496 --> 0:13:55,886
因此 复制实际上

302
00:13:55,886 --> 0:13:58,366
只涉及对整个分区

303
00:13:58,846 --> 0:14:00,256
进行块复制

304
00:13:58,846 --> 0:14:00,256
进行块复制

305
00:14:00,896 --> 0:14:04,476
当然 如果我们要

306
00:14:04,476 --> 0:14:06,986
复制整个块设备

307
00:14:06,986 --> 0:14:08,416
我们将复制该卷中的

308
00:14:08,416 --> 0:14:09,556
所有文件系统信息

309
00:14:09,556 --> 0:14:11,386
现在可能会出现

310
00:14:11,386 --> 0:14:12,866
一些复杂情况

311
00:14:12,866 --> 0:14:13,436
如图中所示

312
00:14:13,766 --> 0:14:16,826
我们的源和目标分区的大小不同

313
00:14:17,066 --> 0:14:18,686
但有一些方法可以解决这个问题

314
00:14:18,686 --> 0:14:20,856
总的来说 块复制是

315
00:14:20,856 --> 0:14:23,546
一种非常有效且

316
00:14:23,546 --> 0:14:25,656
相对简单的复制方式

317
00:14:26,636 --> 0:14:30,236
但是 当然 有了 APFS

318
00:14:30,236 --> 0:14:31,976
就有一些新功能 使这张图片复杂化

319
00:14:34,416 --> 0:14:36,626
因此 正如 Max 告诉你们的那样

320
00:14:36,726 --> 0:14:38,156
APFS 具有一些功能

321
00:14:38,156 --> 0:14:39,336
如卷管理和空间共享

322
00:14:39,336 --> 0:14:42,886
正如我们所看到的

323
00:14:42,886 --> 0:14:44,766
如果我们看一下

324
00:14:44,766 --> 0:14:46,556
图中的第 1 卷 它就会

325
00:14:46,556 --> 0:14:47,536
分散在容器分区周围

326
00:14:47,836 --> 0:14:49,966
所以它不是一个连续的块设备

327
00:14:51,166 --> 0:14:52,536
它可能是 - 它的数据可能

328
00:14:52,536 --> 0:14:56,216
散布在同一容器中

329
00:14:56,216 --> 0:14:57,306
另一个卷的数据中

330
00:14:57,306 --> 0:14:59,396
如本例中的第 2 卷

331
00:15:00,616 --> 0:15:02,076
此外 我们当然关心

332
00:15:02,076 --> 0:15:03,496
安全和隐私

333
00:15:04,116 --> 0:15:05,736
所以我们必须考虑加密

334
00:15:06,556 --> 0:15:08,356
现在使用 APFS 

335
00:15:08,356 --> 0:15:10,016
加密会在文件系统级别完成

336
00:15:10,526 --> 0:15:12,996
而且 在拥有用于

337
00:15:12,996 --> 0:15:15,736
内部存储设备的 

338
00:15:16,286 --> 0:15:18,276
T2 安全芯片的 Mac 上

339
00:15:18,276 --> 0:15:19,686
加密始终处于开启状态

340
00:15:20,396 --> 0:15:22,316
它直接与硬件绑定

341
00:15:22,316 --> 0:15:23,926
这意味着它

342
00:15:23,926 --> 0:15:27,316
特定于该 Mac 中的存储设备

343
00:15:28,106 --> 0:15:29,366
因此 如果我们尝试

344
00:15:29,366 --> 0:15:31,346
复制该卷的块

345
00:15:31,346 --> 0:15:32,236
并将其带到其他地方

346
00:15:32,236 --> 0:15:33,176
它们将无法被解密

347
00:15:34,206 --> 0:15:36,166
所以这里的结果是

348
00:15:36,166 --> 0:15:37,456
块拷贝实际上不是

349
00:15:37,456 --> 0:15:39,986
一种用 APFS 卷进行复制的可能方式

350
00:15:40,566 --> 0:15:44,136
那么我们如何将这与

351
00:15:44,136 --> 0:15:46,906
我们的需求相协调呢

352
00:15:47,106 --> 0:15:48,846
好吧 在 macOS Catalina 上一同更新的 

353
00:15:48,946 --> 0:15:51,116
我们正在推出

354
00:15:51,116 --> 0:15:52,846
带 ASR 的 APFS 卷复制

355
00:15:53,576 --> 0:15:55,176
带 ASR 和 APFS 的

356
00:15:56,176 --> 0:15:57,086
是这样 谢谢

357
00:15:57,086 --> 0:15:59,336
ASR 和 APFS 紧密集成

358
00:15:59,566 --> 0:16:02,296
并且 ASR 可以让 APFS 

359
00:15:59,566 --> 0:16:02,296
并且 ASR 可以让 APFS 

360
00:16:02,296 --> 0:16:03,966
从源卷生成流

361
00:16:03,966 --> 0:16:06,506
然后该流被写入目标卷

362
00:16:07,066 --> 0:16:10,266
现在因为 APFS 正在

363
00:16:10,266 --> 0:16:11,636
生成此流

364
00:16:11,636 --> 0:16:13,126
它知道在何处需要读取

365
00:16:13,126 --> 0:16:13,856
源卷的各个部分

366
00:16:15,276 --> 0:16:16,626
因此 源卷不是

367
00:16:16,626 --> 0:16:17,646
连续的块设备

368
00:16:17,646 --> 0:16:18,976
也不是问题

369
00:16:22,376 --> 0:16:24,276
就加密而言

370
00:16:24,276 --> 0:16:25,376
如果卷的源是加密的

371
00:16:25,376 --> 0:16:28,606
那么它将是 --

372
00:16:28,756 --> 0:16:30,366
来自它的数据

373
00:16:30,366 --> 0:16:32,106
将在生成流时

374
00:16:32,106 --> 0:16:33,116
被动态解密

375
00:16:33,776 --> 0:16:34,996
当然 如果源卷

376
00:16:34,996 --> 0:16:35,786
受 FileVault 保护

377
00:16:35,786 --> 0:16:37,516
则它需要在

378
00:16:37,516 --> 0:16:39,276
进行此复制之前

379
00:16:39,276 --> 0:16:40,766
通过用户操作解锁

380
00:16:41,536 --> 0:16:43,726
如果目标卷本身已加密

381
00:16:43,726 --> 0:16:45,976
则数据处于 - 或者

382
00:16:45,976 --> 0:16:47,776
数据在从流

383
00:16:47,776 --> 0:16:49,926
写入目标卷时被加密

384
00:16:50,356 --> 0:16:52,616
因此 在这种情况下 

385
00:16:52,616 --> 0:16:54,286
该数据在到达

386
00:16:54,286 --> 0:16:55,836
目标卷时从 get go 加密

387
00:16:56,546 --> 0:16:59,606
懂了吗

388
00:16:59,606 --> 0:17:01,766
此复制的另一个不错的功能是

389
00:16:59,606 --> 0:17:01,766
此复制的另一个不错的功能是

390
00:17:01,766 --> 0:17:03,466
在生成流时

391
00:17:03,466 --> 0:17:05,636
会立即对卷数据进行碎片整理

392
00:17:05,636 --> 0:17:07,705
元数据被压缩

393
00:17:07,705 --> 0:17:09,486
因此生成的流

394
00:17:09,486 --> 0:17:10,935
以及由此产生的

395
00:17:10,935 --> 0:17:12,465
目标卷得到了非常好的优化

396
00:17:12,766 --> 0:17:17,066
这可能是一个很好的方法 --

397
00:17:17,066 --> 0:17:18,896
例如去掌握图像

398
00:17:19,856 --> 0:17:20,986
如果你们正在掌握图像

399
00:17:21,266 --> 0:17:22,445
并且最后一步是

400
00:17:22,445 --> 0:17:24,126
执行复制操作

401
00:17:24,126 --> 0:17:25,976
那么你们的图像卷将得到非常好的优化

402
00:17:30,076 --> 0:17:31,436
因此 当我们进行恢复 

403
00:17:32,736 --> 0:17:34,596
复制时 无论你们想说什么

404
00:17:34,596 --> 0:17:37,376
我们都可以使用多种选项

405
00:17:37,696 --> 0:17:39,676
我只是想说出其中几个

406
00:17:39,826 --> 0:17:41,306
第一个真的非常像

407
00:17:41,306 --> 0:17:43,456
我们习惯的恢复

408
00:17:43,916 --> 0:17:46,076
我们可以指定一个源卷

409
00:17:46,306 --> 0:17:48,276
你们可以指定一个目标卷

410
00:17:48,866 --> 0:17:50,546
并且我们的想法是目标卷

411
00:17:50,546 --> 0:17:53,206
将被完全擦除和替换

412
00:17:53,436 --> 0:17:55,086
或者其内容由

413
00:17:55,086 --> 0:17:56,166
源卷的内容替换

414
00:17:56,396 --> 0:17:58,456
现在在这种情况下

415
00:17:58,456 --> 0:18:00,646
我们将第 2 卷作为目标卷

416
00:17:58,456 --> 0:18:00,646
我们将第 2 卷作为目标卷

417
00:18:00,646 --> 0:18:01,696
所以我们的恢复

418
00:18:01,696 --> 0:18:02,526
看起来像这样

419
00:18:02,716 --> 0:18:03,806
你会在这里看到一个

420
00:18:03,806 --> 0:18:04,446
示例命令行

421
00:18:05,526 --> 0:18:08,056
结果是第 2 卷的

422
00:18:08,056 --> 0:18:09,546
内容被删除

423
00:18:09,966 --> 0:18:11,316
取而代之的是源卷的内容

424
00:18:11,316 --> 0:18:12,306
因此恢复的卷

425
00:18:12,306 --> 0:18:14,526
和源卷是相同的

426
00:18:14,526 --> 0:18:15,666
顺便提一下

427
00:18:15,666 --> 0:18:17,666
请注意 在此示例中 

428
00:18:17,666 --> 0:18:18,986
目标容器中还包含另一个卷

429
00:18:19,076 --> 0:18:20,836
而且这个数量是独一无二的

430
00:18:20,836 --> 0:18:21,976
它的内容得以保留

431
00:18:22,206 --> 0:18:23,926
它不以任何方式

432
00:18:24,016 --> 0:18:25,726
形成复制操作的一部分

433
00:18:26,766 --> 0:18:28,566
但是我们还有另一个选择

434
00:18:28,566 --> 0:18:30,816
即不必指定

435
00:18:30,876 --> 0:18:35,366
目标卷和删除它

436
00:18:35,366 --> 0:18:37,796
我们可以生成

437
00:18:37,796 --> 0:18:39,736
一个全新的卷作为动态目标

438
00:18:40,146 --> 0:18:42,596
我们通过将整个容器指定为

439
00:18:42,596 --> 0:18:44,516
目标来完成此操作

440
00:18:44,956 --> 0:18:46,646
这告诉 ASR 我们

441
00:18:46,646 --> 0:18:48,446
真正想要的是

442
00:18:48,446 --> 0:18:50,356
生成一个全新的卷并恢复到那个

443
00:18:50,416 --> 0:18:51,866
你们可以看到另一个示例命令行

444
00:18:51,866 --> 0:18:53,706
结果是创建并恢复了

445
00:18:53,706 --> 0:18:55,766
一个新卷

446
00:18:56,026 --> 0:18:57,306
因此 在这种情况下

447
00:18:57,306 --> 0:18:57,976
第 1 卷和第 2 卷都是独立的

448
00:19:02,186 --> 0:19:03,836
现在我想移步复制

449
00:19:03,836 --> 0:19:07,696
一会儿 我想谈谈

450
00:19:08,086 --> 0:19:09,726
APFS 中的快照

451
00:19:10,176 --> 0:19:12,016
那么 快照只是

452
00:19:12,056 --> 0:19:14,496
所有卷状态的时间点捕获

453
00:19:15,256 --> 0:19:16,466
例如 我们可能有

454
00:19:16,466 --> 0:19:17,986
一个包含大量文件的卷

455
00:19:18,266 --> 0:19:20,416
我们可以拍摄该卷的快照

456
00:19:21,126 --> 0:19:24,366
结果是一次捕获

457
00:19:24,366 --> 0:19:25,706
一个冻结帧

458
00:19:25,706 --> 0:19:27,226
表示在拍摄快照时

459
00:19:27,226 --> 0:19:28,366
该卷的样子

460
00:19:28,676 --> 0:19:30,146
如果我们对卷

461
00:19:30,146 --> 0:19:31,666
进行后续更改

462
00:19:31,756 --> 0:19:33,696
例如 删除文件或

463
00:19:33,696 --> 0:19:36,576
添加一些新文件

464
00:19:36,576 --> 0:19:38,796
则快照仍然包含

465
00:19:38,796 --> 0:19:40,686
创建时存在的所有状态

466
00:19:41,816 --> 0:19:43,456
因此 在这种情况下 

467
00:19:43,456 --> 0:19:45,276
如果我们查看实时卷

468
00:19:45,276 --> 0:19:47,466
则看起来已删除的文件不存在

469
00:19:47,796 --> 0:19:49,016
但从某种意义上说 它仍然存在

470
00:19:49,016 --> 0:19:50,886
因为它是快照的一部分

471
00:19:52,016 --> 0:19:53,276
所以你可能会好奇

472
00:19:53,276 --> 0:19:54,656
“嗯 这与复制有什么关系？”

473
00:19:55,416 --> 0:19:57,156
那么 再一次 

474
00:19:57,156 --> 0:19:59,386
有了 macOS Catalina 的新功能

475
00:20:00,486 --> 0:20:02,796
我们现在可以对快照

476
00:20:02,796 --> 0:20:06,043
进行恢复 复制 所以要理解这意味着什么 --

477
00:20:06,043 --> 0:20:07,346
[掌声] 谢谢你们

478
00:20:09,056 --> 0:20:10,236
要了解这意味着什么

479
00:20:10,236 --> 0:20:12,236
请在左侧考虑此卷

480
00:20:12,236 --> 0:20:14,876
它里面有两个快照 Snap 1 和 Snap 2

481
00:20:15,436 --> 0:20:16,596
它们包含一些共同的文件

482
00:20:16,596 --> 0:20:19,926
那些黄颜色的文件一些快照

483
00:20:19,926 --> 0:20:21,066
而不是另一个快照的文件

484
00:20:21,066 --> 0:20:22,066
一些文件在另一个文件中

485
00:20:22,066 --> 0:20:24,286
而不是在这个 以及该文件不是任何一个快照

486
00:20:24,886 --> 0:20:30,416
我可以将此卷恢复到

487
00:20:30,416 --> 0:20:32,646
右侧的目标卷

488
00:20:32,646 --> 0:20:33,626
它目前是空的

489
00:20:34,376 --> 0:20:35,536
当然 在那里的想法是

490
00:20:35,536 --> 0:20:37,326
在恢复结束时

491
00:20:37,326 --> 0:20:39,836
目标卷看起来像源卷

492
00:20:40,036 --> 0:20:42,456
但是 不是恢复排序

493
00:20:42,456 --> 0:20:44,356
-- 源卷的实时版本

494
00:20:44,356 --> 0:20:45,526
而是当前的样式

495
00:20:45,526 --> 0:20:48,236
我可以改为恢复快照

496
00:20:48,526 --> 0:20:49,716
因此 例如 如果

497
00:20:49,716 --> 0:20:53,296
我想恢复 Snap 1

498
00:20:53,456 --> 0:20:54,946
我可以指定我想恢复的快照

499
00:20:55,966 --> 0:20:58,436
结果是我的目标

500
00:20:58,436 --> 0:20:59,996
现在看起来像 Snap 1

501
00:21:00,726 --> 0:21:02,546
特别注意那两个

502
00:21:02,546 --> 0:21:03,836
从源卷中

503
00:21:03,836 --> 0:21:05,646
删除的文件

504
00:21:05,646 --> 0:21:07,676
他们已经在目标卷中起死回生了

505
00:21:10,216 --> 0:21:12,336
完成后

506
00:21:12,336 --> 0:21:13,556
我可能想在目标卷中

507
00:21:13,556 --> 0:21:14,326
添加一些新文件

508
00:21:14,696 --> 0:21:17,306
但是 也许现在

509
00:21:17,306 --> 0:21:20,056
我想将 Snap 2 恢复到目标卷

510
00:21:20,586 --> 0:21:23,366
当然 同样的想法是 

511
00:21:23,366 --> 0:21:24,306
在该操作结束时

512
00:21:24,306 --> 0:21:25,596
实时目标卷

513
00:21:25,596 --> 0:21:28,246
应该看起来像源卷中的 Snap 2

514
00:21:29,276 --> 0:21:31,756
但请注意 

515
00:21:31,756 --> 0:21:33,206
源卷和目标卷上

516
00:21:33,386 --> 0:21:35,216
都已有 Snap 1

517
00:21:35,456 --> 0:21:37,726
如果不需要

518
00:21:37,726 --> 0:21:39,436
复制 Snap 2 中的一切

519
00:21:39,436 --> 0:21:40,636
我只需要复制 Snap 1 

520
00:21:40,636 --> 0:21:42,336
和 Snap 2 之间不同的东西

521
00:21:42,336 --> 0:21:43,096
那难道不是很好吗

522
00:21:44,036 --> 0:21:44,836
嗯 我确实可以做到

523
00:21:45,076 --> 0:21:46,456
我们将两个快照之间的区别

524
00:21:46,456 --> 0:21:48,296
称为快照增量

525
00:21:49,076 --> 0:21:51,646
我的想法是当我恢复

526
00:21:51,646 --> 0:21:53,906
快照增量时

527
00:21:53,906 --> 0:21:55,016
我正在指定我想要

528
00:21:55,016 --> 0:21:57,466
采取的两个快照

529
00:21:57,676 --> 0:21:58,806
我执行还原

530
00:21:59,486 --> 0:22:00,506
当然最后 

531
00:21:59,486 --> 0:22:00,506
当然最后 

532
00:22:00,506 --> 0:22:02,146
实时目标卷从源头

533
00:22:02,886 --> 0:22:04,296
看起来像 Snap 2

534
00:22:04,556 --> 0:22:05,716
但是我想让你

535
00:22:05,716 --> 0:22:07,796
注意到有关这个

536
00:22:07,796 --> 0:22:08,386
目标卷的三件事

537
00:22:08,386 --> 0:22:10,986
第一 所有那些

538
00:22:10,986 --> 0:22:11,926
不属于目标快照的

539
00:22:11,926 --> 0:22:13,826
文件都被丢弃了

540
00:22:15,156 --> 0:22:17,286
第二个 在 Snap 1 中

541
00:22:17,286 --> 0:22:20,416
但不在 Snap 2 中的文件

542
00:22:20,456 --> 0:22:23,146
已从实时目标卷中丢弃

543
00:22:23,146 --> 0:22:24,556
当然 它们仍然

544
00:22:24,556 --> 0:22:25,946
存在于目标卷上的 Snap 1 中

545
00:22:26,966 --> 0:22:28,416
第三 我们需要

546
00:22:28,416 --> 0:22:30,026
复制的唯一内容

547
00:22:30,566 --> 0:22:31,656
是那些属于 Snap 2

548
00:22:31,656 --> 0:22:33,836
但不属于 Snap 1 的文件

549
00:22:35,246 --> 0:22:37,096
好了吗 现在这是一个

550
00:22:37,096 --> 0:22:38,026
非常强大的功能

551
00:22:38,026 --> 0:22:39,746
这是增加发布的

552
00:22:39,746 --> 0:22:40,856
一个好方法

553
00:22:41,046 --> 0:22:42,846
想象一下 你们正在更新一个

554
00:22:42,846 --> 0:22:44,446
装满 100 台机器的实验室

555
00:22:44,446 --> 0:22:45,856
如果你们只是复制

556
00:22:45,856 --> 0:22:47,566
源图像上几个

557
00:22:47,566 --> 0:22:48,636
快照之间的差异

558
00:22:48,636 --> 0:22:49,816
则可以节省大量时间

559
00:22:49,816 --> 0:22:51,696
和大量网络带宽

560
00:22:55,146 --> 0:22:56,076
这就是我对

561
00:22:56,076 --> 0:22:57,146
复制的看法

562
00:22:57,326 --> 0:22:58,496
在这里做点笔记

563
00:22:59,126 --> 0:23:02,556
一个更复杂的文件系统

564
00:22:59,126 --> 0:23:02,556
一个更复杂的文件系统

565
00:23:02,556 --> 0:23:03,776
需要更复杂的

566
00:23:03,776 --> 0:23:04,976
复制机制

567
00:23:10,046 --> 0:23:11,066
APFS 卷复制

568
00:23:11,066 --> 0:23:12,986
最好使用 ASR 完成 

569
00:23:12,986 --> 0:23:14,636
因为它提供

570
00:23:14,736 --> 0:23:15,986
最高保真度的副本

571
00:23:16,346 --> 0:23:18,146
它会将加密作为必需处理

572
00:23:18,596 --> 0:23:20,746
最后 我们现在可以

573
00:23:20,746 --> 0:23:23,506
使用 ASR 恢复快照增量中的快照

574
00:23:24,196 --> 0:23:25,586
那么有了这一点之后 

575
00:23:25,586 --> 0:23:26,716
我将把话筒转交给 Bill 

576
00:23:26,716 --> 0:23:28,976
他将讨论 iOS 的外部文件访问 谢谢

577
00:23:29,516 --> 0:23:34,376
[掌声]

578
00:23:34,876 --> 0:23:35,396
&gt;&gt; 谢谢你 Jon

579
00:23:36,006 --> 0:23:37,046
大家下午好

580
00:23:37,856 --> 0:23:40,196
你们可能记得两年前

581
00:23:40,196 --> 0:23:42,276
我们介绍了文件 App 和一个新的

582
00:23:42,276 --> 0:23:43,316
文件提供程序 API

583
00:23:44,396 --> 0:23:45,726
它们共同为

584
00:23:45,726 --> 0:23:47,106
基于云的文档

585
00:23:47,106 --> 0:23:48,376
提供了出色的体验

586
00:23:49,576 --> 0:23:51,516
今年 我们认为我们可以做得更多

587
00:23:52,706 --> 0:23:54,186
所以今年

588
00:23:54,186 --> 0:23:57,296
我们很高兴宣布

589
00:23:57,296 --> 0:23:59,916
支持 iOS 访问网络共享

590
00:23:59,916 --> 0:24:03,106
和 USB 存储上的文件

591
00:23:59,916 --> 0:24:03,106
和 USB 存储上的文件

592
00:24:04,516 --> 0:24:08,500
[欢呼和鼓掌]

593
00:24:10,926 --> 0:24:13,546
对于 USB 存储

594
00:24:13,546 --> 0:24:15,936
我们支持从紧凑型闪存和 CF

595
00:24:16,216 --> 0:24:19,766
卡和棒 再到 

596
00:24:19,866 --> 0:24:21,466
USB raid 盒的所有功能

597
00:24:22,906 --> 0:24:24,616
我们支持许多文件系统

598
00:24:25,026 --> 0:24:27,576
我们支持未加密的 APFS

599
00:24:28,766 --> 0:24:32,356
未加密的 HFS Plus

600
00:24:32,356 --> 0:24:34,976
我们支持 FAT 和 ExFAT

601
00:24:35,516 --> 0:24:39,086
[掌声]

602
00:24:39,586 --> 0:24:41,926
所有 iOS 和 iPadOS 设备

603
00:24:41,926 --> 0:24:44,126
均提供此功能

604
00:24:44,976 --> 0:24:47,296
它可以在带有 USB-C 的 

605
00:24:47,296 --> 0:24:47,936
iPad Pro 上使用

606
00:24:48,726 --> 0:24:50,586
对于闪电设备

607
00:24:50,586 --> 0:24:52,666
可以使用适当的适配器

608
00:24:56,746 --> 0:24:59,156
继续使用网络共享

609
00:24:59,156 --> 0:25:02,416
我们支持连接到 

610
00:24:59,156 --> 0:25:02,416
我们支持连接到 

611
00:25:02,416 --> 0:25:02,966
SMB 3.0 服务器

612
00:25:05,476 --> 0:25:06,886
我们支持通过 WiFi

613
00:25:06,886 --> 0:25:10,346
蜂窝和以太网连接

614
00:25:11,426 --> 0:25:13,346
这里有很多令人兴奋的功能

615
00:25:13,346 --> 0:25:15,266
但我们想要提到的

616
00:25:15,266 --> 0:25:18,186
是我们的 iOS 设备

617
00:25:18,186 --> 0:25:19,306
和 iPadOS 设备

618
00:25:19,626 --> 0:25:21,786
我们支持使用 

619
00:25:21,786 --> 0:25:23,166
Windows 搜索协议进行搜索

620
00:25:24,446 --> 0:25:26,156
因此 如果它支持 WSP 协议

621
00:25:26,156 --> 0:25:27,766
所有这些设备都可以

622
00:25:28,536 --> 0:25:29,636
搜索你们的 SMB 服务器

623
00:25:30,896 --> 0:25:32,926
我们也非常高兴地

624
00:25:32,926 --> 0:25:34,266
宣布它包括

625
00:25:34,546 --> 0:25:36,636
SMB 服务器和 macOS Catalina

626
00:25:41,526 --> 0:25:43,186
在继续之前

627
00:25:43,186 --> 0:25:44,486
我想谈谈安全问题

628
00:25:45,296 --> 0:25:47,126
安全性是用户期望

629
00:25:47,126 --> 0:25:48,966
从 iOS 获得的功能

630
00:25:49,856 --> 0:25:51,956
我们用于帮助

631
00:25:51,956 --> 0:25:54,366
实现此安全性的

632
00:25:54,706 --> 0:25:56,806
两个工具是进程

633
00:25:56,806 --> 0:25:57,436
分离和权限分离

634
00:25:57,986 --> 0:26:00,196
在开发此功能时

635
00:25:57,986 --> 0:26:00,196
在开发此功能时

636
00:26:00,296 --> 0:26:01,446
我们始终牢记这一点

637
00:26:01,446 --> 0:26:03,206
并将其从头开始合并

638
00:26:04,446 --> 0:26:06,756
因此 对于我们

639
00:26:06,756 --> 0:26:08,306
所有的卷和共享

640
00:26:08,306 --> 0:26:10,586
文件系统操作

641
00:26:10,636 --> 0:26:12,466
不是发生在内核上

642
00:26:12,496 --> 0:26:13,456
而是发生在专用的进程空间中

643
00:26:14,226 --> 0:26:16,906
这种分离有助于

644
00:26:17,126 --> 0:26:19,746
我们提供 iOS 用户期望的安全性

645
00:26:22,616 --> 0:26:23,976
现在 让我们在一个实际操作中看到它

646
00:26:27,196 --> 0:26:28,976
好的 我有一台 iPad

647
00:26:35,206 --> 0:26:37,936
那么我不知道 - 你们可能看不到它

648
00:26:37,936 --> 0:26:39,326
但我连接了 USB

649
00:26:40,546 --> 0:26:41,566
我有邮件

650
00:26:42,266 --> 0:26:46,356
在文件的左侧

651
00:26:46,356 --> 0:26:48,066
你们可以看到它的位置

652
00:26:48,676 --> 0:26:49,786
iCloud Drive

653
00:26:50,316 --> 0:26:51,676
如果我们有第三方云提供商

654
00:26:51,676 --> 0:26:53,486
我们也会在那里把他们列出

655
00:26:53,486 --> 0:26:57,336
我们看到了我们的 USB 设备的目的地

656
00:26:57,926 --> 0:27:01,316
当我们选择它时

657
00:26:57,926 --> 0:27:01,316
当我们选择它时

658
00:27:01,506 --> 0:27:04,146
我们会看到我们的照片

659
00:27:04,146 --> 0:27:05,906
文档 所有文件和目录

660
00:27:06,516 --> 0:27:10,866
我们可以像文件 App 中的

661
00:27:10,866 --> 0:27:13,246
任何其他文件一样操纵它们

662
00:27:13,246 --> 0:27:16,516
因此 要复制一个 你们只需选择它

663
00:27:16,516 --> 0:27:18,846
准备拖放 

664
00:27:18,846 --> 0:27:21,316
选择目的地

665
00:27:21,986 --> 0:27:23,966
拖动它 然后放下它

666
00:27:24,436 --> 0:27:25,356
你现在可以看到它

667
00:27:25,356 --> 0:27:25,916
已经在文件夹中了

668
00:27:28,826 --> 0:27:30,016
我们喜欢用设备做的

669
00:27:30,016 --> 0:27:33,266
另一件事就是让照片复制

670
00:27:33,766 --> 0:27:35,016
到它们上面

671
00:27:35,226 --> 0:27:37,136
照片 我有一张

672
00:27:37,136 --> 0:27:38,726
我朋友在印度吃西红柿的照片

673
00:27:40,366 --> 0:27:43,146
我们将它保存到 USB 中

674
00:27:43,406 --> 0:27:44,986
为此 我们只需选择文档

675
00:27:44,986 --> 0:27:50,156
转到“分享”

676
00:27:50,156 --> 0:27:52,196
然后在列表中下载以“保存到文件”

677
00:27:53,056 --> 0:27:55,106
你们可以看到 作为目的地

678
00:27:55,106 --> 0:27:56,836
我们列出了 USB

679
00:27:57,436 --> 0:27:59,226
我们只是选择了它

680
00:27:59,226 --> 0:27:59,986
它已经是了

681
00:28:00,036 --> 0:28:00,806
我们点击了保存

682
00:28:01,496 --> 0:28:02,856
然后它就被复制了

683
00:28:03,516 --> 0:28:08,666
[欢呼和掌声]

684
00:28:09,166 --> 0:28:10,906
我希望你们很多人

685
00:28:10,906 --> 0:28:12,176
都是 App 开发人员

686
00:28:12,226 --> 0:28:13,216
而且你们想知道 

687
00:28:13,216 --> 0:28:15,026
你们的 App 如何利用这一点

688
00:28:15,946 --> 0:28:17,776
此功能适用于

689
00:28:17,776 --> 0:28:19,556
在 iOS 13 上或之后链接的

690
00:28:19,616 --> 0:28:21,266
任何所有 App

691
00:28:22,326 --> 0:28:23,706
因此 请重新构建 App

692
00:28:24,116 --> 0:28:25,166
你可以开始利用

693
00:28:26,626 --> 0:28:28,636
为了实现这一点

694
00:28:28,636 --> 0:28:29,356
我们来看看 Numbers 表格

695
00:28:29,986 --> 0:28:32,926
当我打开 Numbers 表格时

696
00:28:32,926 --> 0:28:34,146
它就开始了 -- 它是从我的

697
00:28:34,146 --> 0:28:34,796
iCloud Drive 开始的

698
00:28:35,966 --> 0:28:37,736
USB 被列为目的地

699
00:28:38,396 --> 0:28:39,976
我们选择它

700
00:28:43,166 --> 0:28:44,446
在那里 我们可以看到

701
00:28:44,446 --> 0:28:45,066
我们所有的文件

702
00:28:45,146 --> 0:28:47,846
我们可以看到我们的照片变暗

703
00:28:48,056 --> 0:28:49,596
因为它们不是 Numbers 表格

704
00:28:49,876 --> 0:28:51,586
然后我们看到我们在这个驱动器上

705
00:28:51,896 --> 0:28:54,126
有两个 Numbers 表格

706
00:28:55,266 --> 0:28:56,806
让我们打开其中一个

707
00:28:56,806 --> 0:28:59,186
这是一项贷款比较

708
00:28:59,186 --> 0:29:00,616
比较两种不同的贷款金额

709
00:28:59,186 --> 0:29:00,616
比较两种不同的贷款金额

710
00:29:00,616 --> 0:29:01,656
和两种不同的利率

711
00:29:02,836 --> 0:29:03,976
仅仅为了比较

712
00:29:03,976 --> 0:29:04,546
让我们看看如果我们

713
00:29:04,546 --> 0:29:09,246
提高利率会发生什么 不 Oh

714
00:29:10,016 --> 0:29:11,056
[笑声]

715
00:29:11,056 --> 0:29:11,976
把它设置为 20 而不是 200

716
00:29:18,046 --> 0:29:21,856
哦 不 好吧 这太疯狂了

717
00:29:22,508 --> 0:29:24,508
[笑声]

718
00:29:27,056 --> 0:29:28,926
你可以看到 - 

719
00:29:28,926 --> 0:29:30,956
现场可以看到利率正在变化

720
00:29:38,396 --> 0:29:42,246
那么这对开发者来说意味着什么呢

721
00:29:43,306 --> 0:29:46,546
正如我所说的 如果你们在 

722
00:29:46,546 --> 0:29:47,966
iOS 13 上或之后进行链接

723
00:29:47,966 --> 0:29:48,526
则可以使用它

724
00:29:48,686 --> 0:29:50,586
因此 请重新构建 App 并进行测试

725
00:29:55,346 --> 0:29:56,726
我们在 iOS 中添加了

726
00:29:56,726 --> 0:29:58,956
五种不同的文件系统类型

727
00:29:59,836 --> 0:30:01,636
这些文件系统

728
00:29:59,836 --> 0:30:01,636
这些文件系统

729
00:30:01,636 --> 0:30:03,876
与内部闪存存储上的

730
00:30:03,876 --> 0:30:05,216
APFS 略有不同

731
00:30:07,216 --> 0:30:09,836
一个区别是 iOS 总是有

732
00:30:09,836 --> 0:30:11,896
区分大小写的文件系统

733
00:30:12,796 --> 0:30:14,076
FAT 和 ExFAT 

734
00:30:14,366 --> 0:30:15,636
不区分大小写

735
00:30:16,716 --> 0:30:18,816
并且可以以任何方式

736
00:30:18,816 --> 0:30:19,996
配置 HFS 和 APFS

737
00:30:21,636 --> 0:30:24,056
克隆系统调用

738
00:30:24,056 --> 0:30:24,876
可能并不总是可用的

739
00:30:26,246 --> 0:30:28,206
因此 这些差异是 -- 

740
00:30:28,326 --> 0:30:29,386
如果这些差异对你们或

741
00:30:29,386 --> 0:30:30,926
确实很重要

742
00:30:31,646 --> 0:30:33,676
请注意卷功能

743
00:30:34,656 --> 0:30:37,106
有两种不同的 API 或

744
00:30:37,106 --> 0:30:38,966
几种 API 可以为你们提供

745
00:30:39,746 --> 0:30:41,826
我想要调用的是

746
00:30:41,826 --> 0:30:44,406
NSURL 中的 resourceValues

747
00:30:45,576 --> 0:30:47,726
这些可以为你们

748
00:30:47,726 --> 0:30:48,976
正在使用的文件系统提供参数

749
00:30:52,296 --> 0:30:53,756
另一个重点是

750
00:30:54,176 --> 0:30:58,006
文件移动可能需要一些时间

751
00:30:58,186 --> 0:31:00,006
所以请将临时文件

752
00:30:58,186 --> 0:31:00,006
所以请将临时文件

753
00:31:00,006 --> 0:31:02,066
放在工作文件附近

754
00:31:02,696 --> 0:31:05,226
如果你不这么做

755
00:31:05,226 --> 0:31:09,706
这很有帮助 因为保存 -- 保存

756
00:31:09,946 --> 0:31:12,136
在最后使用重命名 以便用户

757
00:31:12,136 --> 0:31:13,496
总能看到一个好的文件

758
00:31:13,666 --> 0:31:15,456
他们要么看到

759
00:31:15,456 --> 0:31:17,216
他们开始的文件

760
00:31:17,276 --> 0:31:18,046
要么看到新的保存

761
00:31:19,356 --> 0:31:21,146
为此 我们需要重命名

762
00:31:21,496 --> 0:31:22,466
只有当它们都在同一个

763
00:31:22,466 --> 0:31:23,936
文件系统上时才有效

764
00:31:25,466 --> 0:31:26,806
此外 如果你们对

765
00:31:26,806 --> 0:31:28,036
临时文件不小心

766
00:31:28,036 --> 0:31:29,986
它们可能会在内部存储的

767
00:31:29,986 --> 0:31:31,116
容器中结束

768
00:31:31,766 --> 0:31:32,686
这将导致许多

769
00:31:32,686 --> 0:31:33,976
不必要的 IO

770
00:31:38,016 --> 0:31:39,786
文件管理器可以帮助你们解决此问题

771
00:31:40,286 --> 0:31:42,796
如果你们要求提供

772
00:31:42,796 --> 0:31:44,496
适合你们的文档的

773
00:31:44,766 --> 0:31:46,456
itemReplacementDirectory 的 URL

774
00:31:46,706 --> 0:31:48,106
它将在同一文件系统上

775
00:31:48,106 --> 0:31:49,976
为你们提供一个临时目录

776
00:31:55,406 --> 0:31:56,856
另一件事是

777
00:31:56,856 --> 0:31:58,016
外部设备可能会消失

778
00:31:59,416 --> 0:32:01,206
网络可能超出范围

779
00:31:59,416 --> 0:32:01,206
网络可能超出范围

780
00:32:02,226 --> 0:32:03,876
文件服务器可能会关闭

781
00:32:04,486 --> 0:32:05,826
甚至一只猫可能会咬开电缆

782
00:32:07,236 --> 0:32:08,556
这些事情都可能发生

783
00:32:08,916 --> 0:32:10,106
并且你们的 App 需要

784
00:32:10,106 --> 0:32:12,126
在面对它时是结实的

785
00:32:12,666 --> 0:32:13,886
我特别想指出的一点

786
00:32:13,886 --> 0:32:16,656
是 mmap 可能很危险

787
00:32:17,366 --> 0:32:18,666
它真的很强大

788
00:32:18,986 --> 0:32:20,826
但是如果文件消失了

789
00:32:20,826 --> 0:32:22,096
内核可以告诉你的唯一方法

790
00:32:22,096 --> 0:32:23,666
就是报告 BUS 错误

791
00:32:25,536 --> 0:32:28,586
所以有一件事

792
00:32:28,646 --> 0:32:31,066
如果你正在使用 NSData 你可以

793
00:32:31,066 --> 0:32:33,606
提供一个提示 如果它是安全的

794
00:32:33,636 --> 0:32:34,966
你可以从文件中读出 mmap 这个数据

795
00:32:40,086 --> 0:32:41,346
最后一点是外部设备

796
00:32:41,346 --> 0:32:42,796
所有这些设备

797
00:32:42,886 --> 0:32:44,626
在内部闪存存储器上

798
00:32:44,666 --> 0:32:46,376
具有比 APFS 更高的延迟

799
00:32:47,566 --> 0:32:50,236
因此 如果你们正在进行大规模的 IO 

800
00:32:50,236 --> 0:32:53,226
请立即保留多个操作

801
00:32:53,396 --> 0:32:53,976
未完成状态

802
00:32:58,336 --> 0:33:00,206
因此 为了总结今天的演讲

803
00:32:58,336 --> 0:33:00,206
因此 为了总结今天的演讲

804
00:33:01,696 --> 0:33:03,116
Max 与我们讨论了

805
00:33:03,116 --> 0:33:06,086
如何使根卷只读

806
00:33:06,456 --> 0:33:07,376
以增强安全性

807
00:33:08,046 --> 0:33:12,296
Jon 与我们讨论了 ASR 以及

808
00:33:12,296 --> 0:33:14,246
如何使用 ASR 复制卷

809
00:33:14,246 --> 0:33:16,506
包括快照增量

810
00:33:17,106 --> 0:33:19,926
我和你们谈了

811
00:33:19,926 --> 0:33:20,846
我们如何在 iOS 和 

812
00:33:20,846 --> 0:33:22,856
iPadOS 上添加对外部文件的支持

813
00:33:22,856 --> 0:33:25,206
以及如何让你

814
00:33:25,546 --> 0:33:28,316
访问 USB 存储和网络共享上的文件

815
00:33:30,346 --> 0:33:32,356
有关更多信息 我们在

816
00:33:32,356 --> 0:33:34,126
本次会议后有一次实验室

817
00:33:34,726 --> 0:33:37,286
另外明天 有一个

818
00:33:38,906 --> 0:33:40,656
Foundation 中的 Combine 和 Advances

819
00:33:40,696 --> 0:33:41,866
的演讲 他们将

820
00:33:41,866 --> 0:33:43,456
更多地谈论你可以在

821
00:33:43,456 --> 0:33:45,736
外部媒体上做什么

822
00:33:45,876 --> 0:33:48,046
此外 还有一个视频会话

823
00:33:48,046 --> 0:33:52,606
文件管理和 Quick Look 的新内容

824
00:33:52,746 --> 0:33:57,406
将更多地讨论本演讲 UI 文档方面的内容 谢谢大家

825
00:33:58,516 --> 0:34:04,500
[掌声]
