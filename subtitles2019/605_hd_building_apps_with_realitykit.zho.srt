1
00:00:00,506 --> 0:00:04,500
[音乐]

2
00:00:09,016 --> 0:00:10,236
[掌声]

3
00:00:10,236 --> 0:00:13,766
&gt;&gt; 大家好

4
00:00:13,766 --> 0:00:14,886
我叫 Ross

5
00:00:14,886 --> 0:00:16,666
是 Apple RealityKit 团队的工程师

6
00:00:16,666 --> 0:00:18,686
欢迎来到通过 RealityKit 构建 App

7
00:00:19,766 --> 0:00:23,076
本场会议是一个后续会议

8
00:00:23,076 --> 0:00:24,786
你可能需要先查看一下先前的会议

9
00:00:24,786 --> 0:00:27,206
RealityKit 和 Reality Composer 的介绍

10
00:00:27,686 --> 0:00:28,596
今天我们要讲的是

11
00:00:28,596 --> 0:00:30,216
RealityKit 的应用方法

12
00:00:30,216 --> 0:00:31,136
我们将指导你

13
00:00:31,136 --> 0:00:32,226
创建增强现实 App

14
00:00:32,226 --> 0:00:33,686
告诉你如何使用

15
00:00:33,686 --> 0:00:35,156
很多框架的关键功能

16
00:00:35,706 --> 0:00:36,856
在深入了解之前 先简单回顾一下

17
00:00:36,856 --> 0:00:38,386
RealityKit 是什么

18
00:00:39,056 --> 0:00:40,916
RealityKit 是 Apple 的新框架

19
00:00:40,916 --> 0:00:43,986
用于构建 AR App

20
00:00:44,076 --> 0:00:46,296
致力于为所有开发人员

21
00:00:46,296 --> 0:00:48,066
提供简单直观的体验

22
00:00:48,726 --> 0:00:50,636
可以让你从零开始使用 AR

23
00:00:50,636 --> 0:00:52,096
可以将渲染过的内容

24
00:00:52,096 --> 0:00:54,436
和真实世界的场景无缝融合

25
00:00:54,436 --> 0:00:57,126
它的 Swift API 操作简单

26
00:00:57,126 --> 0:00:58,536
功能强大 只需几行代码

27
00:00:58,536 --> 0:00:59,716
就可以帮你完成很多工作

28
00:01:00,586 --> 0:01:01,696
好了 让我们构建一个 App

29
00:01:02,956 --> 0:01:03,826
我们今天要构建的 App

30
00:01:03,826 --> 0:01:05,556
名字叫做 Memory Cards

31
00:01:05,816 --> 0:01:06,766
顾名思义

32
00:01:06,766 --> 0:01:08,476
就是一款卡片匹配游戏

33
00:01:09,736 --> 0:01:10,806
点按这张卡片选择它

34
00:01:10,806 --> 0:01:12,476
就可以看到它的图像

35
00:01:12,986 --> 0:01:14,946
选择另一张卡片 显示图像

36
00:01:14,946 --> 0:01:16,276
如果这对卡片是匹配的

37
00:01:16,276 --> 0:01:17,006
它们就被移除

38
00:01:17,726 --> 0:01:19,106
如果这两张卡片不匹配

39
00:01:19,106 --> 0:01:20,506
卡片就会翻过去

40
00:01:20,506 --> 0:01:21,226
你可以选择下一对

41
00:01:21,926 --> 0:01:23,636
这个游戏很简单

42
00:01:23,636 --> 0:01:24,726
但可以让我们关注和讨论

43
00:01:24,726 --> 0:01:26,016
很多 RealityKit 有用的功能

44
00:01:26,016 --> 0:01:28,186
我们将分四个阶段

45
00:01:28,186 --> 0:01:29,306
构建  Memory Cards

46
00:01:30,156 --> 0:01:30,876
首先 我们要合成一个原型

47
00:01:30,876 --> 0:01:33,226
能将我们的内容

48
00:01:33,226 --> 0:01:34,796
放在 AR 里

49
00:01:34,796 --> 0:01:35,976
还能做一些简单交互

50
00:01:37,596 --> 0:01:38,896
接下来我们要进行润色

51
00:01:38,896 --> 0:01:40,306
加一些精致的艺术元素

52
00:01:40,306 --> 0:01:41,916
提高性能和 AR 渲染

53
00:01:43,176 --> 0:01:46,406
然后利用实体组件系统来追踪

54
00:01:46,406 --> 0:01:47,186
用户状态信息

55
00:01:48,596 --> 0:01:49,706
最后我们向你展示

56
00:01:49,706 --> 0:01:50,706
如何使用 RealityKit 的内置网络支持

57
00:01:50,706 --> 0:01:53,576
在游戏中添加多人游戏

58
00:01:55,396 --> 0:01:57,226
好了 开始制作我们的原型

59
00:01:57,886 --> 0:01:59,856
在之前的介绍会议中提过

60
00:01:59,856 --> 0:02:01,346
有四个对象

61
00:01:59,856 --> 0:02:01,346
有四个对象

62
00:02:01,346 --> 0:02:07,446
在每个 RealityKit App 中都会用到  

63
00:02:07,446 --> 0:02:11,636
ARView 场景 锚点 和 实体

64
00:02:12,206 --> 0:02:15,056
ARView 是你进入

65
00:02:15,056 --> 0:02:15,736
AR 世界的窗口

66
00:02:16,146 --> 0:02:17,946
也是使用 RealityKit 的起点

67
00:02:18,606 --> 0:02:19,896
它是一个视图

68
00:02:19,896 --> 0:02:21,136
属于 App 的视图层次结构

69
00:02:21,696 --> 0:02:24,106
场景包含虚拟内容

70
00:02:24,106 --> 0:02:25,086
用于构建你的 App

71
00:02:25,086 --> 0:02:26,816
它属于 ARView

72
00:02:29,506 --> 0:02:31,146
在 RealityKit 中 锚点描述

73
00:02:31,146 --> 0:02:32,846
对象与真实世界的关联

74
00:02:33,156 --> 0:02:34,116
需要有它们

75
00:02:34,316 --> 0:02:35,716
才能放置你的虚拟内容

76
00:02:36,326 --> 0:02:37,766
放置锚点的方法

77
00:02:37,766 --> 0:02:39,076
是将其添加在场景中

78
00:02:39,076 --> 0:02:40,406
如果合适的目标出现

79
00:02:40,406 --> 0:02:42,546
锚点将自动被放置在世界中

80
00:02:43,436 --> 0:02:44,636
对 Memory Cards 这个游戏

81
00:02:44,636 --> 0:02:45,656
我们用一个锚点

82
00:02:45,656 --> 0:02:46,886
将游戏面板放在水平面上

83
00:02:47,836 --> 0:02:49,606
实体用于表示

84
00:02:49,606 --> 0:02:50,916
你的虚拟内容

85
00:02:51,136 --> 0:02:52,676
也是构建场景的基本单位

86
00:02:53,196 --> 0:02:54,876
在 Memory Cards 中

87
00:02:54,876 --> 0:02:56,586
每张卡片都由一个实体表示

88
00:02:57,186 --> 0:02:58,716
你的游戏有 16 张卡片

89
00:02:58,716 --> 0:03:00,206
我们就需要 16 个实体

90
00:02:58,716 --> 0:03:00,206
我们就需要 16 个实体

91
00:03:01,656 --> 0:03:02,996
我们现在已经知道了

92
00:03:02,996 --> 0:03:05,656
App 中所需要的重要元素

93
00:03:05,656 --> 0:03:07,216
现在谈谈如何创建锚点

94
00:03:07,216 --> 0:03:08,846
来将虚拟游戏面板

95
00:03:08,846 --> 0:03:11,126
放到现实世界中

96
00:03:12,216 --> 0:03:13,266
RealityKit 的锚定 

97
00:03:13,266 --> 0:03:14,976
基于 ARKit 并与之整合而成

98
00:03:14,976 --> 0:03:17,246
所以你可以使用它的完整功能集

99
00:03:18,516 --> 0:03:20,366
要定义锚点的内容

100
00:03:20,366 --> 0:03:21,446
你要创建一个锚点实体

101
00:03:22,146 --> 0:03:25,616
明确你要用的锚点类型

102
00:03:25,616 --> 0:03:27,076
然后把锚点实体加到场景中

103
00:03:27,556 --> 0:03:30,236
一旦 ARKit 发现合适目标

104
00:03:30,236 --> 0:03:33,426
锚点实体就会自动跟踪

105
00:03:33,426 --> 0:03:34,986
让你的虚拟内容

106
00:03:34,986 --> 0:03:35,956
如同在现实世界一样

107
00:03:35,956 --> 0:03:38,586
随着你设备的移动而移动

108
00:03:40,266 --> 0:03:41,276
像介绍会议中所说的

109
00:03:41,276 --> 0:03:43,016
RealityKit 支持

110
00:03:43,016 --> 0:03:44,026
ARKit 中所有类型的锚点

111
00:03:44,026 --> 0:03:45,206
能让我们能够锚定

112
00:03:45,206 --> 0:03:46,516
平面 人脸 图像 物体 

113
00:03:46,856 --> 0:03:49,696
新的 ARKit 3 

114
00:03:49,696 --> 0:03:51,836
还有身体锚点

115
00:03:53,376 --> 0:03:54,816
在 Memory Cards 中 我们只需要

116
00:03:54,816 --> 0:03:56,516
一个锚点放置游戏面板

117
00:03:57,686 --> 0:03:58,706
我们需要把它放在一个

118
00:03:58,706 --> 0:04:00,006
有足够空间的水平面上

119
00:03:58,706 --> 0:04:00,006
有足够空间的水平面上

120
00:04:00,006 --> 0:04:01,236
能放下所有卡片

121
00:04:01,236 --> 0:04:03,286
大约为 20 平方厘米

122
00:04:04,346 --> 0:04:05,416
这个锚点就代表

123
00:04:05,416 --> 0:04:07,176
在世界中的游戏面板

124
00:04:07,176 --> 0:04:08,626
我们把内容放在上面

125
00:04:09,416 --> 0:04:10,526
为此 我们需要写一些代码

126
00:04:11,706 --> 0:04:14,076
这是 Memory Cards 原型的视图控制器

127
00:04:14,586 --> 0:04:15,996
我们在视图层次结构中

128
00:04:15,996 --> 0:04:17,426
放置一个 ARView 

129
00:04:17,426 --> 0:04:18,706
我们已经准备好找锚点

130
00:04:18,706 --> 0:04:19,946
创建我们的虚拟内容

131
00:04:20,636 --> 0:04:23,606
我们将在 viewDidLoad 方法中创建

132
00:04:25,366 --> 0:04:26,946
为了定义我们的锚

133
00:04:26,946 --> 0:04:28,856
我们创建一个锚实体

134
00:04:28,856 --> 0:04:30,266
利用这个便捷的初始程序

135
00:04:30,266 --> 0:04:32,526
我们可以指定锚定的平面类型

136
00:04:32,526 --> 0:04:34,216
这个例子里是水平平面

137
00:04:35,336 --> 0:04:38,476
我们可以输入需要的最小面积

138
00:04:38,476 --> 0:04:39,326
20 平方厘米

139
00:04:40,246 --> 0:04:41,496
RealityKit 的单位是米

140
00:04:41,786 --> 0:04:44,166
所以 20 厘米乘以 20 厘米

141
00:04:44,166 --> 0:04:47,626
就应该是 0.2 乘以 0.2

142
00:04:48,086 --> 0:04:50,316
然后我们把锚点放在场景中

143
00:04:50,316 --> 0:04:51,566
只要 RealityKit 发现一个

144
00:04:51,566 --> 0:04:52,786
大于 20 平方厘米的水平平面

145
00:04:52,786 --> 0:04:54,656
我们放在这个锚点上的

146
00:04:54,656 --> 0:04:55,756
虚拟内容就会

147
00:04:55,756 --> 0:04:56,306
出现在 AR 里

148
00:04:56,946 --> 0:04:59,356
现在已经建好了锚点

149
00:04:59,356 --> 0:05:00,686
让我们加一些虚拟内容

150
00:04:59,356 --> 0:05:00,686
让我们加一些虚拟内容

151
00:05:01,346 --> 0:05:02,576
首先我们需要加载模型

152
00:05:03,326 --> 0:05:04,586
RealityKit 原生支持

153
00:05:04,586 --> 0:05:06,386
USDZ 格式的素材

154
00:05:06,516 --> 0:05:07,696
以及新的 Reality File 格式

155
00:05:08,766 --> 0:05:09,326
加载可以同步完成

156
00:05:09,326 --> 0:05:10,866
也可以异步完成

157
00:05:11,036 --> 0:05:13,176
现在我们从同步加载开始

158
00:05:13,176 --> 0:05:16,456
稍后 我们会仔细讲解

159
00:05:16,456 --> 0:05:18,236
当你加载 USDZ

160
00:05:18,236 --> 0:05:19,586
或者 Reality File 素材时

161
00:05:19,586 --> 0:05:20,956
RealityKit 会自动导入

162
00:05:20,956 --> 0:05:23,126
实体层次结构

163
00:05:23,126 --> 0:05:25,806
使用的网格 它的材料

164
00:05:25,806 --> 0:05:27,726
以及可能使用的动画

165
00:05:29,886 --> 0:05:31,396
让我们加载基本的卡片素材

166
00:05:31,966 --> 0:05:34,396
要加载模型

167
00:05:34,396 --> 0:05:36,026
你只需要调用 Entity.loadModel 方法

168
00:05:36,216 --> 0:05:37,196
并提供素材名称

169
00:05:37,866 --> 0:05:38,816
如果素材在你的 App 包里

170
00:05:38,816 --> 0:05:41,146
就不需要指定文件扩展名

171
00:05:42,426 --> 0:05:43,556
如果 RealityKit 可以加载素材

172
00:05:43,556 --> 0:05:44,766
它就会自动创建一个

173
00:05:44,766 --> 0:05:47,326
随时可用的实体供你使用

174
00:05:47,986 --> 0:05:49,146
我们在这里加载了

175
00:05:49,146 --> 0:05:50,666
八个基本的卡片模型

176
00:05:50,666 --> 0:05:51,316
存储在数组中

177
00:05:51,926 --> 0:05:55,376
Memory Cards 共有 16 张卡片

178
00:05:56,366 --> 0:05:57,876
有八种不同的卡片

179
00:05:57,876 --> 0:05:58,586
每种的图像不同

180
00:05:58,916 --> 0:06:00,666
每种类型需要有两个实例

181
00:05:58,916 --> 0:06:00,666
每种类型需要有两个实例

182
00:06:00,666 --> 0:06:03,536
才能帮助我们创建八对卡片

183
00:06:04,436 --> 0:06:05,496
现在只加载了八个类型的模型

184
00:06:05,526 --> 0:06:07,346
另外八个模型应该怎么做呢

185
00:06:08,496 --> 0:06:10,466
我们可以再调用一次

186
00:06:10,466 --> 0:06:12,196
Entity.loadModel 方法

187
00:06:12,196 --> 0:06:13,476
之前我们在所有卡片上进行的设置

188
00:06:13,476 --> 0:06:14,846
也要在这些卡片上

189
00:06:14,846 --> 0:06:15,306
都进行一遍

190
00:06:16,746 --> 0:06:17,826
RealityKit 提供了更方便的解决方法

191
00:06:17,826 --> 0:06:19,616
实体克隆

192
00:06:20,206 --> 0:06:22,646
创建一个克隆体

193
00:06:22,646 --> 0:06:23,616
需要调用 Entity.clone 方法

194
00:06:24,966 --> 0:06:26,146
可以创建一个

195
00:06:26,146 --> 0:06:27,646
和原来一模一样的实体

196
00:06:28,996 --> 0:06:29,976
它引用的所有素材

197
00:06:29,976 --> 0:06:32,576
都和原实体一样

198
00:06:32,576 --> 0:06:33,486
克隆也可以递归完成

199
00:06:33,626 --> 0:06:36,176
这样可以克隆实体的所有子实体

200
00:06:36,176 --> 0:06:37,996
这在处理

201
00:06:37,996 --> 0:06:39,076
具有多层次机构的

202
00:06:39,136 --> 0:06:41,366
复杂场景时非常有用

203
00:06:41,996 --> 0:06:44,146
需要注意的是

204
00:06:44,146 --> 0:06:45,876
克隆实体是原实体的副本

205
00:06:45,876 --> 0:06:48,386
而不是实例

206
00:06:48,386 --> 0:06:49,906
如果你对原实体

207
00:06:49,906 --> 0:06:51,246
做了一些改变 比方说

208
00:06:51,246 --> 0:06:53,106
移除了一个子实体

209
00:06:53,106 --> 0:06:54,226
这个改变不会出现在

210
00:06:54,226 --> 0:06:55,366
已经存在的克隆体中

211
00:06:56,466 --> 0:06:57,866
让我们开始克隆

212
00:06:57,866 --> 0:06:58,506
制作卡片对

213
00:06:59,086 --> 0:07:01,836
我们在这里克隆了

214
00:06:59,086 --> 0:07:01,836
我们在这里克隆了

215
00:07:01,836 --> 0:07:03,236
每种卡片类型的两个实例

216
00:07:03,236 --> 0:07:04,676
把它们储存在

217
00:07:04,676 --> 0:07:06,266
两个数组中

218
00:07:06,266 --> 0:07:07,096
用于构建我们的游戏面板

219
00:07:08,406 --> 0:07:09,696
我们可以使用原始的卡片模版

220
00:07:09,696 --> 0:07:10,626
只克隆一个新的实例

221
00:07:10,626 --> 0:07:12,206
但是这样将卡片模版单独保留

222
00:07:12,206 --> 0:07:13,286
稍后 我们可以

223
00:07:13,286 --> 0:07:14,456
轻松地再次引用

224
00:07:14,456 --> 0:07:15,616
重新创建游戏面板

225
00:07:15,856 --> 0:07:17,796
而不需要从头开始加载模版

226
00:07:19,916 --> 0:07:21,426
你现在有 16 张卡片

227
00:07:21,426 --> 0:07:22,806
我们需要把它们

228
00:07:22,806 --> 0:07:23,596
放在游戏面板中

229
00:07:24,336 --> 0:07:26,576
锚点居于游戏区域的中心位置

230
00:07:26,576 --> 0:07:27,706
我们把卡片摆成

231
00:07:27,826 --> 0:07:30,266
四乘四的网格状

232
00:07:30,706 --> 0:07:31,916
下面我们需要

233
00:07:31,916 --> 0:07:33,056
把每张卡片与锚点联系起来

234
00:07:33,056 --> 0:07:34,386
它们就会出现在 AR 里

235
00:07:35,026 --> 0:07:38,036
为此 我们需要计算

236
00:07:38,036 --> 0:07:39,426
每张卡片的位置

237
00:07:39,426 --> 0:07:41,286
根据其下标和数组

238
00:07:41,286 --> 0:07:42,496
确定它的位置属性

239
00:07:43,226 --> 0:07:45,336
当我们在锚点上

240
00:07:45,336 --> 0:07:47,066
添加卡片时

241
00:07:47,096 --> 0:07:48,156
锚点就相当于父项目

242
00:07:48,816 --> 0:07:51,376
这就是我们需要做的

243
00:07:51,376 --> 0:07:52,906
在 AR 中排列我们的卡片

244
00:07:52,956 --> 0:07:54,066
并进行渲染

245
00:07:54,736 --> 0:07:56,366
现在我们把卡片放在

246
00:07:56,366 --> 0:07:58,006
AR 中的一个平面上 

247
00:07:58,006 --> 0:07:59,186
但它们什么都做不了

248
00:07:59,186 --> 0:07:59,976
让我们添加交互

249
00:08:00,656 --> 0:08:02,946
我们希望点按它们的时候

250
00:08:02,946 --> 0:08:05,106
卡片翻转 为了达到这个效果

251
00:08:05,106 --> 0:08:06,466
我们需要把

252
00:08:06,466 --> 0:08:08,126
设备屏幕上的点按 

253
00:08:08,126 --> 0:08:09,836
转换为 AR 世界里的点按 这样

254
00:08:09,876 --> 0:08:11,486
我们就知道 点按的是什么

255
00:08:12,316 --> 0:08:13,156
RealityKit提供了一个点触检测

256
00:08:13,156 --> 0:08:14,966
来解决这个问题

257
00:08:16,386 --> 0:08:18,116
点触检测的工作原理

258
00:08:18,116 --> 0:08:19,556
是将设备屏幕上

259
00:08:19,556 --> 0:08:21,526
点按的 2D 点转换为

260
00:08:21,526 --> 0:08:22,396
虚拟场景中的光线

261
00:08:23,236 --> 0:08:24,826
然后将光线投射到场景中

262
00:08:24,826 --> 0:08:26,556
RealityKit 找到

263
00:08:26,556 --> 0:08:28,786
光线指向的所有对象

264
00:08:29,286 --> 0:08:31,086
并返回

265
00:08:31,086 --> 0:08:32,385
光线指向的

266
00:08:32,385 --> 0:08:34,256
所有实体

267
00:08:34,256 --> 0:08:35,606
让你知道点按的对象是什么

268
00:08:37,145 --> 0:08:38,405
ARView 提供了

269
00:08:38,405 --> 0:08:38,986
点触检测的方法

270
00:08:39,285 --> 0:08:40,535
entity(at point:)返回

271
00:08:40,535 --> 0:08:42,106
所给点距摄像头最近的实体

272
00:08:42,106 --> 0:08:44,066
entities(at point:)

273
00:08:44,066 --> 0:08:45,516
返回所给点处

274
00:08:45,516 --> 0:08:47,006
光线指向的

275
00:08:47,136 --> 0:08:48,146
所有实体

276
00:08:48,616 --> 0:08:51,196
我们可以轻松地将其

277
00:08:51,196 --> 0:08:52,216
集成到我们的 Memory Cards App 中

278
00:08:53,076 --> 0:08:54,746
我们有一个方法响应

279
00:08:54,786 --> 0:08:56,496
点按手势识别器

280
00:08:57,116 --> 0:08:58,556
我们在 ARView 中

281
00:08:58,556 --> 0:09:00,206
确定点按的位置 

282
00:08:58,556 --> 0:09:00,206
确定点按的位置 

283
00:09:00,206 --> 0:09:01,806
然后传递 entity(at:)

284
00:09:01,806 --> 0:09:03,456
因为我们只想获得

285
00:09:03,566 --> 0:09:04,626
最靠近设备的实体

286
00:09:05,596 --> 0:09:06,876
如果点按位置下有一个实体

287
00:09:06,876 --> 0:09:09,636
这个方法就会返回实体

288
00:09:09,636 --> 0:09:10,896
我们就可以

289
00:09:10,896 --> 0:09:12,616
和它进行交互

290
00:09:13,436 --> 0:09:14,506
但仍需要再做一件事

291
00:09:14,506 --> 0:09:15,586
才能使点按检测

292
00:09:15,586 --> 0:09:16,966
正常工作

293
00:09:18,646 --> 0:09:20,026
对点按检测的实体来说

294
00:09:20,086 --> 0:09:21,426
它们需要一个可碰撞的形状

295
00:09:22,926 --> 0:09:24,636
碰撞形状是一个简化的几何形状

296
00:09:24,636 --> 0:09:26,356
通常是个盒子

297
00:09:27,086 --> 0:09:28,346
它们很容易检测

298
00:09:28,346 --> 0:09:30,236
也可以进行有效的交叉

299
00:09:30,236 --> 0:09:31,736
和碰撞计算

300
00:09:32,426 --> 0:09:34,326
更重要的是

301
00:09:34,326 --> 0:09:36,086
没有碰撞形状

302
00:09:36,086 --> 0:09:37,296
实体则无法进行点按检测

303
00:09:37,516 --> 0:09:39,086
所以让我们给卡片增加形状

304
00:09:39,826 --> 0:09:43,426
这个代码和之前制作模型 

305
00:09:43,426 --> 0:09:44,766
创建卡片模版的代码相同

306
00:09:45,336 --> 0:09:47,836
我们在这里做一个小改动

307
00:09:47,836 --> 0:09:50,216
加上实体生成

308
00:09:50,276 --> 0:09:51,236
碰撞形状的方法

309
00:09:52,086 --> 0:09:53,446
这将自动为实体生成

310
00:09:53,676 --> 0:09:55,346
简单的盒子碰撞形状

311
00:09:55,346 --> 0:09:58,476
利用实体的视觉边界

312
00:09:59,016 --> 0:10:00,516
可以看到 与克隆相似

313
00:09:59,016 --> 0:10:00,516
可以看到 与克隆相似

314
00:10:00,516 --> 0:10:01,886
这个方法可以递归地

315
00:10:01,966 --> 0:10:05,086
为实体所有的子实体

316
00:10:05,086 --> 0:10:06,176
创建碰撞形状

317
00:10:07,206 --> 0:10:08,126
说到克隆

318
00:10:08,446 --> 0:10:09,686
碰撞形状包含在

319
00:10:09,686 --> 0:10:10,986
实体克隆时

320
00:10:10,986 --> 0:10:11,886
复制的数据中

321
00:10:12,656 --> 0:10:13,806
由于我们已经准备好

322
00:10:13,806 --> 0:10:14,696
克隆卡片模版

323
00:10:14,696 --> 0:10:15,586
来构建游戏面板

324
00:10:15,586 --> 0:10:17,496
因此它们也就自动包含了

325
00:10:17,496 --> 0:10:18,446
这些碰撞形状

326
00:10:18,656 --> 0:10:21,346
现在我们可以弄清楚

327
00:10:21,346 --> 0:10:22,806
我们互动的实体是什么

328
00:10:22,976 --> 0:10:24,196
让我们加上一个动画

329
00:10:24,196 --> 0:10:25,266
点按卡片的时候就会播放

330
00:10:26,056 --> 0:10:27,946
RealityKit 支持两种动画

331
00:10:28,156 --> 0:10:30,356
第一个是变换动画

332
00:10:30,356 --> 0:10:31,776
可以让你在代码中

333
00:10:32,016 --> 0:10:36,446
为实体的位置 旋转 和缩放

334
00:10:36,446 --> 0:10:37,566
设计动画

335
00:10:38,186 --> 0:10:40,686
第二个是素材动画

336
00:10:40,686 --> 0:10:41,966
它播放的动画

337
00:10:41,966 --> 0:10:43,226
是嵌入到

338
00:10:43,226 --> 0:10:44,716
从 USDZ 或者 Reality File 中

339
00:10:44,716 --> 0:10:46,896
加载的素材里的

340
00:10:47,526 --> 0:10:49,506
RealityKit 还提供了

341
00:10:49,506 --> 0:10:50,856
完成处理器

342
00:10:50,856 --> 0:10:52,376
可应用于这两种动画

343
00:10:52,376 --> 0:10:54,006
让你知道 动画何时结束

344
00:10:55,166 --> 0:10:57,566
一旦我们的卡片素材

345
00:10:57,566 --> 0:10:59,236
没有嵌入的动画

346
00:10:59,236 --> 0:11:00,186
那么为了翻转卡片 

347
00:10:59,236 --> 0:11:00,186
那么为了翻转卡片 

348
00:11:00,186 --> 0:11:02,136
我们将在卡片实体上使用变换动画

349
00:11:05,206 --> 0:11:06,506
变换动画可以使用

350
00:11:06,506 --> 0:11:07,696
多种多样的计时功能

351
00:11:07,696 --> 0:11:10,316
来控制动画的播放速度

352
00:11:11,306 --> 0:11:12,536
这是线性 以恒定速率

353
00:11:12,536 --> 0:11:13,776
播放动画

354
00:11:13,996 --> 0:11:15,306
加速和减速

355
00:11:15,306 --> 0:11:16,386
都是瞬时完成的

356
00:11:16,686 --> 0:11:19,116
这是渐入

357
00:11:19,116 --> 0:11:20,536
在持续的时间内

358
00:11:20,576 --> 0:11:21,626
逐渐提高动画速度

359
00:11:22,296 --> 0:11:24,696
渐出与渐入相反

360
00:11:24,696 --> 0:11:25,816
会使动画减速

361
00:11:25,816 --> 0:11:27,126
直至完成

362
00:11:27,796 --> 0:11:30,436
渐入渐出还可以

363
00:11:30,686 --> 0:11:32,056
结合使用

364
00:11:32,056 --> 0:11:33,056
将动画加速到时间轴的中点

365
00:11:33,056 --> 0:11:34,586
然后减速

366
00:11:34,586 --> 0:11:35,976
直至完成

367
00:11:36,546 --> 0:11:38,836
还有一个贝塞尔曲线

368
00:11:38,836 --> 0:11:40,436
可以定制你的

369
00:11:40,436 --> 0:11:41,126
计时功能

370
00:11:41,636 --> 0:11:43,346
让我们为翻转卡片

371
00:11:43,346 --> 0:11:43,886
创建一个动画

372
00:11:44,556 --> 0:11:46,966
我们首先要复制一下

373
00:11:47,076 --> 0:11:49,276
卡片当前的形状

374
00:11:49,936 --> 0:11:51,376
这可以确保 

375
00:11:51,376 --> 0:11:52,596
保留当前实体的

376
00:11:52,596 --> 0:11:54,196
比例和变化

377
00:11:54,296 --> 0:11:55,636
这是我们不想改变的

378
00:11:57,456 --> 0:11:59,346
接下来我们将使用四元参数

379
00:11:59,346 --> 0:12:01,566
将变换设置为

380
00:11:59,346 --> 0:12:01,566
将变换设置为

381
00:12:01,566 --> 0:12:03,616
围绕 X 轴的 180 度旋转

382
00:12:03,966 --> 0:12:05,596
这样就可以翻转卡片

383
00:12:05,596 --> 0:12:06,576
使图像朝上

384
00:12:06,656 --> 0:12:09,976
现在开始制作动画

385
00:12:10,606 --> 0:12:12,216
变换动画

386
00:12:12,216 --> 0:12:13,786
使用实体的 move(to:) 方法

387
00:12:15,136 --> 0:12:16,096
RealityKit 可以让

388
00:12:16,096 --> 0:12:17,176
加了动画的实体

389
00:12:17,176 --> 0:12:18,386
在当前状态和方法中的变换

390
00:12:18,386 --> 0:12:19,466
流畅过渡

391
00:12:19,986 --> 0:12:20,946
使用请求的计时功能

392
00:12:20,946 --> 0:12:22,556
在这个例子中

393
00:12:22,556 --> 0:12:24,566
是在给定的时间长度内执行 easeInOut

394
00:12:25,626 --> 0:12:27,406
这给了我们

395
00:12:27,406 --> 0:12:28,926
卡片翻转至正面向上所需的动画

396
00:12:29,386 --> 0:12:32,646
实体的 move 方法

397
00:12:32,646 --> 0:12:33,576
提供了播放控制器

398
00:12:33,576 --> 0:12:37,886
可以让你暂停 恢复 或停止动画或接收

399
00:12:37,886 --> 0:12:39,006
动画完成的通知

400
00:12:39,006 --> 0:12:40,426
就像我们现在做的一样

401
00:12:41,026 --> 0:12:43,806
然后翻转卡片

402
00:12:43,806 --> 0:12:45,236
使其正面向下

403
00:12:45,236 --> 0:12:46,976
我们只需要做个小调整

404
00:12:46,976 --> 0:12:49,096
让变换的旋转设置归零

405
00:12:49,296 --> 0:12:50,786
当我们调用这个 move 方法

406
00:12:50,786 --> 0:12:51,986
卡片就可以

407
00:12:51,986 --> 0:12:53,356
翻转朝下

408
00:12:55,406 --> 0:12:56,756
现在我们的 App

409
00:12:56,756 --> 0:12:58,056
能够互动了

410
00:12:58,056 --> 0:12:59,396
使用点按检测

411
00:12:59,396 --> 0:13:01,266
检查用户选择的对象

412
00:12:59,396 --> 0:13:01,266
检查用户选择的对象

413
00:13:01,266 --> 0:13:02,976
用变换动画隐藏卡片

414
00:13:06,046 --> 0:13:07,056
现在我们完成了基本的工作

415
00:13:07,056 --> 0:13:08,326
让我们增加一些细节

416
00:13:08,326 --> 0:13:10,146
来改进一下

417
00:13:10,716 --> 0:13:12,976
我们已经加载了简单的卡片模型

418
00:13:12,976 --> 0:13:14,966
并把它们放在了 AR 里

419
00:13:14,966 --> 0:13:17,076
但卡片上的 2D 图像有些无趣

420
00:13:18,056 --> 0:13:19,176
感谢我们的美术团队

421
00:13:19,176 --> 0:13:20,366
创作了一系列高质量的模型

422
00:13:20,366 --> 0:13:21,866
我们把它们添加到组合中

423
00:13:21,866 --> 0:13:24,096
让我们的 App 更加立体

424
00:13:24,656 --> 0:13:27,156
我们可以用之前

425
00:13:27,156 --> 0:13:28,696
同步加载的 Entity.load 方法

426
00:13:28,696 --> 0:13:30,556
加载这些新的素材

427
00:13:31,076 --> 0:13:32,436
但是这些模型

428
00:13:32,436 --> 0:13:34,396
比之前简单的卡片素材

429
00:13:34,396 --> 0:13:35,226
复杂的多

430
00:13:35,226 --> 0:13:36,756
加载这些更大的素材

431
00:13:36,756 --> 0:13:37,446
需要更长时间

432
00:13:37,926 --> 0:13:40,096
加载可能会很快

433
00:13:40,096 --> 0:13:41,446
但加载的同时

434
00:13:41,446 --> 0:13:41,946
App 也可能会阻塞

435
00:13:42,926 --> 0:13:44,226
如果你正在加载大量素材

436
00:13:44,226 --> 0:13:45,186
而这些会累积起来

437
00:13:45,186 --> 0:13:47,316
造成明显延迟影响体验

438
00:13:48,136 --> 0:13:49,436
我们能做些什么改善情况呢

439
00:13:50,726 --> 0:13:51,806
还好我们之前提过

440
00:13:51,806 --> 0:13:53,106
RealityKit 支持

441
00:13:53,106 --> 0:13:54,786
同步加载和异步加载

442
00:13:55,576 --> 0:13:56,446
我们可以通过调用

443
00:13:56,446 --> 0:13:57,666
Entity.loadModelAsync 方法

444
00:13:57,666 --> 0:14:00,896
异步加载模型

445
00:13:57,666 --> 0:14:00,896
异步加载模型

446
00:14:01,046 --> 0:14:02,106
使用异步加载

447
00:14:02,556 --> 0:14:03,396
素材可以在后台加载

448
00:14:03,396 --> 0:14:05,836
这样就可以解放 App

449
00:14:05,836 --> 0:14:07,076
使它继续运行而不被干扰

450
00:14:07,116 --> 0:14:08,506
让你的 App

451
00:14:08,506 --> 0:14:10,266
响应流畅

452
00:14:10,266 --> 0:14:14,216
也让 ARKit 继续观察世界的情况

453
00:14:14,536 --> 0:14:16,266
当异步加载完成

454
00:14:16,266 --> 0:14:17,676
你会收到一个回调

455
00:14:17,676 --> 0:14:18,566
然后就可以使用你的素材

456
00:14:18,566 --> 0:14:21,136
就像在同步加载时所做的一样

457
00:14:21,946 --> 0:14:23,486
此外 你还可以把

458
00:14:23,486 --> 0:14:24,636
加载请求结合起来

459
00:14:24,636 --> 0:14:26,446
同时执行它们

460
00:14:26,726 --> 0:14:28,056
在所有素材加载完成以后

461
00:14:28,056 --> 0:14:29,136
接收通知

462
00:14:29,306 --> 0:14:30,186
所以你不需要一点一点地

463
00:14:30,186 --> 0:14:31,326
下载素材

464
00:14:32,136 --> 0:14:33,186
让我们编写一些代码

465
00:14:33,186 --> 0:14:34,796
异步加载我们的新模型

466
00:14:36,056 --> 0:14:37,426
我们首先异步加载

467
00:14:37,516 --> 0:14:39,046
单个模型

468
00:14:39,846 --> 0:14:41,516
Entity.loadModelAsync 方法

469
00:14:41,686 --> 0:14:43,176
需要素材的名称

470
00:14:43,436 --> 0:14:44,966
就像同步加载一样

471
00:14:45,656 --> 0:14:48,276
它会返回一个加载请求

472
00:14:48,276 --> 0:14:49,316
用于当模型加载完成并

473
00:14:49,316 --> 0:14:52,016
可以投入使用时接收通知

474
00:14:52,596 --> 0:14:54,546
我们采用闭包

475
00:14:54,546 --> 0:14:56,056
调用 sink 方法

476
00:14:56,056 --> 0:14:57,266
在素材准备完成时执行

477
00:14:58,246 --> 0:15:00,456
加载请求使用的 API

478
00:14:58,246 --> 0:15:00,456
加载请求使用的 API

479
00:15:00,456 --> 0:15:01,536
是从新的 Swift 框架

480
00:15:01,536 --> 0:15:02,416
Combine 中引入的

481
00:15:02,816 --> 0:15:03,696
因此我推荐大家

482
00:15:03,696 --> 0:15:05,216
查看一下 Introducing Combine 和

483
00:15:05,216 --> 0:15:06,346
Advances in Foundation 两场会议

484
00:15:06,346 --> 0:15:08,656
这就是实现

485
00:15:08,656 --> 0:15:10,356
异步加载内容的操作

486
00:15:10,706 --> 0:15:11,856
现在你可以像这样

487
00:15:11,856 --> 0:15:13,416
分开下载所有的素材

488
00:15:13,856 --> 0:15:14,966
你也可以将多个加载请求

489
00:15:14,966 --> 0:15:16,716
合并为一个

490
00:15:19,046 --> 0:15:19,896
我们可以通过简单地

491
00:15:19,956 --> 0:15:21,146
将另一个加载请求

492
00:15:21,276 --> 0:15:22,126
附加在第一个上

493
00:15:22,676 --> 0:15:25,316
然后调用 collect

494
00:15:25,316 --> 0:15:26,326
将两个加载请求组合起来

495
00:15:26,876 --> 0:15:28,876
之后我们调用 sink

496
00:15:29,036 --> 0:15:30,506
当两个模型加载完成

497
00:15:30,506 --> 0:15:31,956
闭包就开始执行

498
00:15:31,956 --> 0:15:33,466
打包到数组

499
00:15:33,466 --> 0:15:35,896
参数模型中以便处理

500
00:15:38,256 --> 0:15:39,766
我们可以根据自己的需要进行扩展

501
00:15:40,356 --> 0:15:41,676
我们集合了

502
00:15:41,676 --> 0:15:43,046
八个复杂的卡片模型

503
00:15:43,046 --> 0:15:44,426
做成一个加载请求

504
00:15:45,916 --> 0:15:46,816
我们的 sink 闭包

505
00:15:46,816 --> 0:15:48,146
会在八个卡片模型加载结束后

506
00:15:48,396 --> 0:15:49,026
开始执行

507
00:15:49,656 --> 0:15:50,756
组合和加载请求的闭包

508
00:15:50,756 --> 0:15:52,346
让内容管理更加简单

509
00:15:55,106 --> 0:15:55,866
我们展示一下

510
00:15:55,866 --> 0:15:57,266
同步加载和异步加载的对比

511
00:15:57,266 --> 0:16:00,466
左边的 App 使用的是同步加载

512
00:15:57,266 --> 0:16:00,466
左边的 App 使用的是同步加载

513
00:16:00,466 --> 0:16:01,566
右边是异步加载

514
00:16:01,566 --> 0:16:03,306
一旦同步的 App 

515
00:16:03,306 --> 0:16:04,836
开始加载 其他的工作都停了

516
00:16:04,836 --> 0:16:06,596
因为 App 被阻塞

517
00:16:06,596 --> 0:16:07,556
直到加载完成

518
00:16:08,216 --> 0:16:09,806
作为对比 异步的 App

519
00:16:09,806 --> 0:16:11,076
还能继续响应

520
00:16:11,386 --> 0:16:12,506
用户的输入

521
00:16:12,506 --> 0:16:14,766
更新摄像头

522
00:16:14,766 --> 0:16:15,706
你还可以继续

523
00:16:15,706 --> 0:16:18,006
观察摄像头前的世界

524
00:16:18,196 --> 0:16:19,046
这两个 App 加载的时间

525
00:16:19,046 --> 0:16:20,836
都是相同的

526
00:16:20,836 --> 0:16:22,256
但使用异步加载的设备

527
00:16:22,256 --> 0:16:23,286
可以首先显示内容

528
00:16:23,606 --> 0:16:24,746
因为它可以让你

529
00:16:24,746 --> 0:16:26,076
在加载的同时

530
00:16:26,356 --> 0:16:26,986
继续观察世界的情况

531
00:16:27,186 --> 0:16:27,956
但使用同步加载的设备

532
00:16:27,956 --> 0:16:29,636
则无法做到

533
00:16:29,876 --> 0:16:31,706
所以异步加载更适合

534
00:16:31,706 --> 0:16:33,256
与 AR 一起使用

535
00:16:35,006 --> 0:16:35,626
所以 我们需要

536
00:16:35,626 --> 0:16:36,396
加载复杂模型

537
00:16:36,396 --> 0:16:37,506
而不用暂停 App

538
00:16:37,826 --> 0:16:39,526
但是精明的观察者

539
00:16:39,526 --> 0:16:40,446
可能已经注意到了

540
00:16:40,446 --> 0:16:42,076
卡片朝下时 还是能看到模型

541
00:16:43,356 --> 0:16:44,366
当卡片朝下时

542
00:16:44,366 --> 0:16:45,436
我们可以简单地隐藏模型

543
00:16:45,436 --> 0:16:46,356
但我们无法阻止

544
00:16:46,356 --> 0:16:47,626
用户弯腰查看

545
00:16:47,626 --> 0:16:48,996
卡片下面的内容

546
00:16:48,996 --> 0:16:49,876
查找配对的卡片

547
00:16:50,126 --> 0:16:52,606
而不是翻转卡片

548
00:16:52,716 --> 0:16:54,386
所以 RealityKit 有一个

549
00:16:54,386 --> 0:16:56,696
特别有用的方法来解决遮挡材料

550
00:16:57,396 --> 0:16:58,496
遮挡材料是不可见的

551
00:16:58,496 --> 0:17:00,056
当应用在场景中的

552
00:16:58,496 --> 0:17:00,056
当应用在场景中的

553
00:17:00,056 --> 0:17:01,516
几何体上时

554
00:17:01,516 --> 0:17:03,136
就会隐藏后面的虚拟内容

555
00:17:03,886 --> 0:17:05,146
显示穿过虚拟内容的影像

556
00:17:05,685 --> 0:17:06,836
这里你们可以看到

557
00:17:06,836 --> 0:17:07,896
我们在场景中

558
00:17:07,896 --> 0:17:09,086
加了遮挡几何体

559
00:17:09,086 --> 0:17:10,256
还有一些标记

560
00:17:10,256 --> 0:17:11,705
将不可见物体的

561
00:17:11,796 --> 0:17:12,675
形状显示出来

562
00:17:13,476 --> 0:17:15,356
在遮挡动画上下移动时

563
00:17:15,356 --> 0:17:16,566
它与机器人相交的部分被隐藏

564
00:17:16,656 --> 0:17:18,175
而背后的真实世界

565
00:17:18,445 --> 0:17:19,455
显示出来

566
00:17:20,616 --> 0:17:21,576
遮挡材料非常适合

567
00:17:21,576 --> 0:17:22,796
模仿真实世界的物体

568
00:17:22,796 --> 0:17:24,215
这些物体会阻挡

569
00:17:24,215 --> 0:17:26,086
虚拟物体 

570
00:17:26,086 --> 0:17:26,856
就像桌子和墙

571
00:17:27,276 --> 0:17:29,066
在我们的 App 中使用一下

572
00:17:30,076 --> 0:17:31,346
首先在我们的游戏面板上

573
00:17:31,346 --> 0:17:32,956
加一个遮挡面

574
00:17:33,526 --> 0:17:34,756
我们要创建一个

575
00:17:34,756 --> 0:17:36,216
半米宽半米深的平面网格

576
00:17:37,476 --> 0:17:38,436
然后创建遮挡材料

577
00:17:38,436 --> 0:17:41,346
再接着创建一个模型实体

578
00:17:41,346 --> 0:17:43,176
把它用在平面网格上

579
00:17:43,876 --> 0:17:45,276
把它放在游戏面板

580
00:17:45,276 --> 0:17:46,206
下面一点

581
00:17:46,206 --> 0:17:48,166
就不会与我们模型底部交叉

582
00:17:49,106 --> 0:17:50,196
之后 把它添加在锚点上

583
00:17:50,196 --> 0:17:51,736
以便把遮挡材料

584
00:17:51,786 --> 0:17:52,856
放在场景中

585
00:17:54,366 --> 0:17:56,876
这里我们能看到遮挡平面在工作

586
00:17:57,106 --> 0:17:59,166
粗略一看 好像很好的解决了问题

587
00:17:59,166 --> 0:18:00,456
但当我们

588
00:17:59,166 --> 0:18:00,456
但当我们

589
00:18:00,456 --> 0:18:02,046
向下移动设备时

590
00:18:02,046 --> 0:18:03,676
可以看到遮挡平面的边缘

591
00:18:03,676 --> 0:18:04,896
看到桌子里

592
00:18:04,896 --> 0:18:06,456
虚拟内容的渲染

593
00:18:06,456 --> 0:18:08,016
所以 游戏面板之上

594
00:18:08,016 --> 0:18:09,396
这个平面做的很好

595
00:18:09,396 --> 0:18:10,406
但这种情况下

596
00:18:10,406 --> 0:18:13,476
我们需要在任意角度都要遮挡

597
00:18:13,646 --> 0:18:14,976
解决方案是使用

598
00:18:14,976 --> 0:18:16,466
遮挡盒子而非遮挡平面

599
00:18:16,986 --> 0:18:20,016
我们要生成一个遮挡盒子

600
00:18:20,016 --> 0:18:20,846
使用相同的遮挡材料

601
00:18:20,846 --> 0:18:23,036
然后创造一个模型实体

602
00:18:23,036 --> 0:18:24,566
使用遮挡盒子

603
00:18:24,566 --> 0:18:25,336
取代遮挡平面

604
00:18:26,806 --> 0:18:28,256
生成的几何对象

605
00:18:28,256 --> 0:18:30,106
默认位于锚点中心

606
00:18:30,106 --> 0:18:31,176
所以我们要将它下移半个盒子的距离

607
00:18:31,176 --> 0:18:31,716
再下移一点点

608
00:18:31,716 --> 0:18:32,806
这样盒子的顶部

609
00:18:32,806 --> 0:18:34,096
就刚好位于

610
00:18:34,096 --> 0:18:35,006
游戏板底部的下方

611
00:18:36,376 --> 0:18:38,246
我们再次把它

612
00:18:38,246 --> 0:18:39,266
加到锚点上

613
00:18:39,266 --> 0:18:42,496
将遮挡盒子放在场景中

614
00:18:43,136 --> 0:18:44,696
表面看来

615
00:18:44,696 --> 0:18:46,656
和遮挡平面作用相同

616
00:18:46,656 --> 0:18:48,096
但当我们开始向下移动设备

617
00:18:48,736 --> 0:18:50,716
我们会看到

618
00:18:50,716 --> 0:18:52,096
已经看不到我们的虚拟内容了

619
00:18:52,746 --> 0:18:54,026
我们的遮挡盒子可以阻止

620
00:18:54,026 --> 0:18:55,396
内容在桌子内渲染

621
00:18:55,396 --> 0:18:57,046
在虚拟场景中

622
00:18:57,046 --> 0:18:58,856
模拟出了真实世界的对象

623
00:19:00,226 --> 0:19:01,266
现在我们的 App

624
00:19:01,266 --> 0:19:02,386
可以将虚拟卡片放在

625
00:19:02,386 --> 0:19:03,896
现实世界里 进行互动

626
00:19:03,896 --> 0:19:06,366
我们采用异步加载资源

627
00:19:06,366 --> 0:19:07,736
利用遮挡几何模拟

628
00:19:07,736 --> 0:19:08,916
虚拟内容

629
00:19:08,916 --> 0:19:10,906
被真实世界对象遮住

630
00:19:11,566 --> 0:19:13,116
现在我想邀请

631
00:19:13,116 --> 0:19:14,236
我的同事 Courtland

632
00:19:14,236 --> 0:19:16,036
讲讲追踪游戏状态 Courtland

633
00:19:17,016 --> 0:19:21,500
[掌声]

634
00:19:25,236 --> 0:19:25,816
&gt;&gt; 谢谢 Ross

635
00:19:26,476 --> 0:19:27,776
大家好 我是 Courtland

636
00:19:27,776 --> 0:19:29,666
Apple RealityKit 团队的工程师

637
00:19:30,396 --> 0:19:31,766
我们刚刚了解了

638
00:19:31,766 --> 0:19:33,756
如何为一个 AR 游戏制作原型

639
00:19:33,756 --> 0:19:36,006
添加互动 增加艺术素材

640
00:19:36,876 --> 0:19:38,056
现在我想向大家展示

641
00:19:38,056 --> 0:19:39,396
如何利用自定义组件和实体

642
00:19:39,396 --> 0:19:40,796
追踪你的状态 

643
00:19:41,146 --> 0:19:42,916
以及最后的如何添加多人游戏

644
00:19:43,896 --> 0:19:45,446
我们先说追踪状态

645
00:19:46,606 --> 0:19:48,106
正如在介绍会议中所讲

646
00:19:48,106 --> 0:19:49,936
RealityKit 使用

647
00:19:49,936 --> 0:19:51,296
实体—组件设计模式

648
00:19:51,446 --> 0:19:53,306
在虚拟世界中构建对象

649
00:19:53,476 --> 0:19:56,326
实体本身由称为

650
00:19:56,326 --> 0:19:57,676
组件的部分组成

651
00:19:58,616 --> 0:20:00,396
这些组件可以定义

652
00:19:58,616 --> 0:20:00,396
这些组件可以定义

653
00:20:00,396 --> 0:20:02,536
添加到各个实体的

654
00:20:02,536 --> 0:20:03,856
特定行为和数据

655
00:20:04,846 --> 0:20:06,546
使用实体和组件

656
00:20:06,546 --> 0:20:08,286
可以重复使用代码

657
00:20:08,286 --> 0:20:09,126
而且使用灵活

658
00:20:09,786 --> 0:20:10,956
我们来看一下

659
00:20:10,956 --> 0:20:11,806
怎么运用组件

660
00:20:12,356 --> 0:20:14,986
我们用 RealityKit 的模型实体

661
00:20:14,986 --> 0:20:16,646
来代表我们的卡片

662
00:20:17,096 --> 0:20:18,226
它给我们提供了

663
00:20:18,226 --> 0:20:19,806
一组组件

664
00:20:19,806 --> 0:20:22,196
可表示常见的虚拟对象

665
00:20:22,946 --> 0:20:24,306
我们将模型组件

666
00:20:24,306 --> 0:20:25,796
应用于视觉外观

667
00:20:25,796 --> 0:20:28,276
将碰撞组件应用于点按检测

668
00:20:29,436 --> 0:20:30,936
模型实体还包含

669
00:20:30,936 --> 0:20:32,626
一个物理组件

670
00:20:32,626 --> 0:20:34,326
能让实体

671
00:20:34,326 --> 0:20:35,736
以物理逼真的方式

672
00:20:35,816 --> 0:20:37,496
移动以及与其他对象互动

673
00:20:37,496 --> 0:20:38,246
虽然这里没有使用

674
00:20:39,836 --> 0:20:40,996
RealityKit 可以让你

675
00:20:40,996 --> 0:20:42,006
自定义实体

676
00:20:42,626 --> 0:20:43,866
通过使用实体组件设计

677
00:20:43,866 --> 0:20:45,206
你可以留下想要的行为

678
00:20:45,206 --> 0:20:47,116
排除那些

679
00:20:47,116 --> 0:20:49,296
你不需要的

680
00:20:49,296 --> 0:20:50,166
增加你自己的新行为

681
00:20:51,196 --> 0:20:52,926
让我们为卡片定制

682
00:20:53,636 --> 0:20:54,826
这个实体

683
00:20:54,966 --> 0:20:56,746
模型实体有我们需要的大部分内容

684
00:20:57,476 --> 0:20:58,996
我们需要移除物理

685
00:20:58,996 --> 0:20:59,506
因为我们没有使用

686
00:21:00,746 --> 0:21:01,986
我们想储存卡片属性

687
00:21:01,986 --> 0:21:03,716
表明它是显示还是隐藏状态

688
00:21:03,826 --> 0:21:06,076
还有卡片种类

689
00:21:06,116 --> 0:21:07,616
用来确定两张卡片是否配对

690
00:21:08,736 --> 0:21:10,286
为此我们需要创建

691
00:21:10,286 --> 0:21:12,226
一个具有这些属性的

692
00:21:12,226 --> 0:21:13,296
新卡片组件

693
00:21:13,296 --> 0:21:13,956
把它加到实体中

694
00:21:15,266 --> 0:21:16,906
究竟什么是组件

695
00:21:17,626 --> 0:21:20,196
一个 RealityKit 组件是一个

696
00:21:20,196 --> 0:21:22,046
包含属性的 Swift 结构体

697
00:21:23,046 --> 0:21:24,366
它符合组件协议

698
00:21:24,366 --> 0:21:27,086
可以被添加到实体上

699
00:21:28,466 --> 0:21:30,376
遵循 Codable 也是一个好主意

700
00:21:30,376 --> 0:21:32,556
我们在多人游戏部分将会看到

701
00:21:33,496 --> 0:21:34,066
我们开始动手做

702
00:21:35,076 --> 0:21:37,506
首先声明我们的结构体

703
00:21:37,866 --> 0:21:38,936
命名为 CardComponent

704
00:21:39,966 --> 0:21:42,036
我们采用了 Codable 协议中的 Component

705
00:21:44,066 --> 0:21:45,086
接下来 加上两个属性

706
00:21:45,086 --> 0:21:46,626
一个名为 revealed 的布尔值

707
00:21:46,626 --> 0:21:48,066
表示卡片的内容

708
00:21:48,066 --> 0:21:49,226
是隐藏还是显示

709
00:21:49,226 --> 0:21:51,006
还有一个字符串 kind

710
00:21:51,496 --> 0:21:52,946
可以用来匹配两张卡片

711
00:21:53,726 --> 0:21:54,476
这就是所有类型

712
00:21:55,396 --> 0:21:56,476
我们先从之前 Ross

713
00:21:56,476 --> 0:21:57,826
加载的一个卡片模型开始

714
00:21:58,446 --> 0:22:01,106
为了演示目的

715
00:21:58,446 --> 0:22:01,106
为了演示目的

716
00:22:01,106 --> 0:22:02,226
我将展示如何删除

717
00:22:02,256 --> 0:22:02,936
physicBody 组件

718
00:22:03,696 --> 0:22:05,036
模型实体提供了

719
00:22:05,036 --> 0:22:06,346
一个 physicBody 属性

720
00:22:06,346 --> 0:22:07,156
这就简单多了

721
00:22:08,016 --> 0:22:11,806
我们赋值为 nil 就完成了

722
00:22:12,026 --> 0:22:13,986
现在我们加载卡片组件

723
00:22:13,986 --> 0:22:16,336
通过赋值给组件类型索引的

724
00:22:16,336 --> 0:22:17,236
组件数组来完成

725
00:22:18,246 --> 0:22:19,376
这一操作将增加组件

726
00:22:19,376 --> 0:22:21,006
如果实体上

727
00:22:21,816 --> 0:22:23,046
原来没有这一组件的话

728
00:22:23,246 --> 0:22:24,756
更改 kind 属性也是一样的

729
00:22:25,726 --> 0:22:28,666
索引到实体组件数组

730
00:22:28,666 --> 0:22:29,476
赋值给 kind 属性

731
00:22:30,406 --> 0:22:31,766
不是每个实体

732
00:22:31,766 --> 0:22:33,506
都有一个卡片组件

733
00:22:33,506 --> 0:22:36,216
访问器将返回一个备选值

734
00:22:37,266 --> 0:22:38,846
对于你游戏中

735
00:22:38,876 --> 0:22:40,056
使用的组件通用配置

736
00:22:40,056 --> 0:22:41,566
我们可以更进一步

737
00:22:41,566 --> 0:22:42,736
创建我们自己的

738
00:22:42,806 --> 0:22:43,476
自定义实体

739
00:22:44,466 --> 0:22:45,746
RealityKit 附带有很多

740
00:22:45,746 --> 0:22:47,346
实体配置

741
00:22:47,346 --> 0:22:49,306
如平行光和模型实体

742
00:22:49,816 --> 0:22:51,166
你可以轻松制作自己的配置

743
00:22:51,926 --> 0:22:53,156
我们在游戏中随处可见卡片

744
00:22:53,156 --> 0:22:55,336
所以把它转化为实体

745
00:22:55,336 --> 0:22:56,866
是一个理想的候选

746
00:22:58,006 --> 0:22:59,386
我们将获得这些对象的

747
00:22:59,386 --> 0:23:00,836
编译时输入检查

748
00:22:59,386 --> 0:23:00,836
编译时输入检查

749
00:23:00,836 --> 0:23:01,496
和代码补全

750
00:23:01,996 --> 0:23:03,346
也可以添加方法

751
00:23:03,346 --> 0:23:05,366
封装功能

752
00:23:06,726 --> 0:23:08,126
这特别有用

753
00:23:08,126 --> 0:23:11,106
当你需要同时更改多个组件时

754
00:23:11,106 --> 0:23:12,156
比如在掀开卡片的同时

755
00:23:12,156 --> 0:23:14,146
将卡片状态改为

756
00:23:14,146 --> 0:23:16,326
revealed

757
00:23:16,576 --> 0:23:18,486
创造新实体只需几步

758
00:23:19,736 --> 0:23:21,266
首先需要一个新的类

759
00:23:21,296 --> 0:23:24,196
代表我们的实体

760
00:23:24,406 --> 0:23:25,906
然后添加我们需要的

761
00:23:25,906 --> 0:23:27,566
RealityKit 组件

762
00:23:28,696 --> 0:23:31,016
然后添加任意的自定义组件

763
00:23:31,226 --> 0:23:32,136
我们之前看到了

764
00:23:32,136 --> 0:23:33,316
模型实体上的

765
00:23:33,316 --> 0:23:34,816
physicBody 属性

766
00:23:34,816 --> 0:23:36,356
这是访问 physicBody 属性

767
00:23:36,356 --> 0:23:37,496
简便的语法

768
00:23:38,066 --> 0:23:39,966
我们将对卡片进行相同操作

769
00:23:40,976 --> 0:23:42,516
我们之前扩展了

770
00:23:43,646 --> 0:23:45,366
reveal 和 hide 方法

771
00:23:46,466 --> 0:23:49,246
因此我们创建了派生于实体的

772
00:23:49,246 --> 0:23:51,136
卡片实体类

773
00:23:52,666 --> 0:23:54,726
接下来要添加 RealityKit 组件

774
00:23:55,356 --> 0:23:57,136
我们加上 HasModel

775
00:23:57,136 --> 0:23:58,386
还有 HasCollision 协议

776
00:23:59,146 --> 0:24:01,766
这些协议让我们通过属性

777
00:23:59,146 --> 0:24:01,766
这些协议让我们通过属性

778
00:24:01,766 --> 0:24:04,056
或它们提供的其他方法

779
00:24:04,056 --> 0:24:05,186
比如生成碰撞形状

780
00:24:05,466 --> 0:24:06,996
来访问模型和碰撞组件

781
00:24:07,496 --> 0:24:10,356
最后我们添加一个卡片属性

782
00:24:10,816 --> 0:24:11,936
可以返回 CardComponent

783
00:24:12,626 --> 0:24:13,976
因为所有卡片都需要卡片组件

784
00:24:13,976 --> 0:24:15,636
所以将其设置为非可选

785
00:24:16,276 --> 0:24:19,246
get 可以从数组中

786
00:24:19,246 --> 0:24:20,096
获取我们的

787
00:24:20,096 --> 0:24:20,706
CardComponent

788
00:24:21,686 --> 0:24:22,736
如果我们没有准备好卡片

789
00:24:22,736 --> 0:24:24,466
就使用空合运算符

790
00:24:24,466 --> 0:24:25,996
返回默认值

791
00:24:27,236 --> 0:24:28,986
set 将复制新值

792
00:24:28,986 --> 0:24:29,626
到组件数组中

793
00:24:29,626 --> 0:24:32,776
现在我们有了类

794
00:24:32,776 --> 0:24:33,566
并用方法进行了扩展

795
00:24:34,276 --> 0:24:37,926
我用 reveal 方法

796
00:24:38,086 --> 0:24:39,466
来展示轻松地

797
00:24:39,466 --> 0:24:40,596
协调多个更新 

798
00:24:41,756 --> 0:24:43,366
我们首先更新卡片的状态

799
00:24:43,456 --> 0:24:44,646
表示它是显示的

800
00:24:45,596 --> 0:24:46,986
我们立即执行此操作

801
00:24:46,986 --> 0:24:48,196
而不是等到动画结束之后

802
00:24:48,576 --> 0:24:50,626
是为了防止你在动画播放时再次点按

803
00:24:51,886 --> 0:24:53,596
接下来 我们使用

804
00:24:53,596 --> 0:24:55,016
Ross 之前使用的代码

805
00:24:55,016 --> 0:24:56,126
来翻转卡片

806
00:24:57,006 --> 0:24:58,406
就是这样

807
00:24:58,506 --> 0:24:59,816
hide 方法是相反的

808
00:25:00,436 --> 0:25:02,016
设置 revealed 为假

809
00:25:02,016 --> 0:25:03,066
翻转卡片向下

810
00:25:04,106 --> 0:25:05,756
我们看看现在使用是什么样

811
00:25:07,156 --> 0:25:08,676
我们回到 onTap 处理器

812
00:25:09,866 --> 0:25:11,636
调用相同的 arView.entity(at:)方法

813
00:25:11,636 --> 0:25:13,756
但是这次需要

814
00:25:13,756 --> 0:25:15,206
将结果投射到卡片实体

815
00:25:16,136 --> 0:25:18,896
虽然我们的游戏中只有卡片

816
00:25:18,896 --> 0:25:19,676
但你的 App 中可能有多种实体

817
00:25:20,926 --> 0:25:22,596
转换为卡片实体

818
00:25:22,856 --> 0:25:24,716
可以执行对卡片的特定操作

819
00:25:26,186 --> 0:25:27,546
有新的卡片实体和组件

820
00:25:27,546 --> 0:25:29,106
我们可以询问

821
00:25:29,106 --> 0:25:30,346
卡片是否显示

822
00:25:30,346 --> 0:25:32,366
如果它当前是显示的

823
00:25:32,846 --> 0:25:34,136
我们就隐藏

824
00:25:34,256 --> 0:25:37,926
反之 就显示隐藏和显示被封装

825
00:25:37,926 --> 0:25:39,226
为实体的方法

826
00:25:39,226 --> 0:25:40,726
我们不需要关注

827
00:25:40,726 --> 0:25:42,076
隐藏和显示

828
00:25:42,076 --> 0:25:43,606
卡片的具体操作

829
00:25:44,226 --> 0:25:46,726
我们让代码清晰明了

830
00:25:46,726 --> 0:25:48,136
通过在实体中

831
00:25:48,136 --> 0:25:50,056
添加自定义组件

832
00:25:50,056 --> 0:25:51,336
并在此做了一项重要功能性改进

833
00:25:52,426 --> 0:25:53,686
我们现在知道 一张显示的卡片

834
00:25:53,686 --> 0:25:55,536
点按之后就可隐藏起来

835
00:25:55,536 --> 0:25:57,186
如果它不是

836
00:25:57,186 --> 0:25:57,996
你记住的卡片

837
00:25:58,686 --> 0:26:00,906
我们已经为状态构建

838
00:25:58,686 --> 0:26:00,906
我们已经为状态构建

839
00:26:00,906 --> 0:26:02,386
组件和实体

840
00:26:02,386 --> 0:26:04,786
现在该进入游戏的下一阶段

841
00:26:05,316 --> 0:26:06,506
还能添什么简单的东西呢

842
00:26:11,086 --> 0:26:12,436
只需添加多人游戏了

843
00:26:15,636 --> 0:26:17,706
AR 游戏很有意思

844
00:26:17,706 --> 0:26:19,286
能和朋友一起玩更有意思

845
00:26:20,666 --> 0:26:21,986
多人游戏能将简单的

846
00:26:21,986 --> 0:26:23,386
卡片配对游戏变成

847
00:26:23,386 --> 0:26:25,766
一场比赛

848
00:26:25,766 --> 0:26:27,576
但是制作多人 AR 游戏

849
00:26:27,576 --> 0:26:28,986
有很多其他的挑战

850
00:26:28,986 --> 0:26:30,886
在非 AR 游戏中不会遇到

851
00:26:32,076 --> 0:26:33,356
当他们把虚拟对象

852
00:26:33,356 --> 0:26:35,056
放到真实世界里

853
00:26:35,056 --> 0:26:36,516
我们希望所有玩家

854
00:26:36,516 --> 0:26:37,316
看到对象都在同一个位置

855
00:26:37,316 --> 0:26:39,966
因为所有人都在一个地方

856
00:26:39,966 --> 0:26:41,496
我们希望设备之间的

857
00:26:41,536 --> 0:26:43,286
更新速度可以很快

858
00:26:43,286 --> 0:26:45,236
以保持现实的共享

859
00:26:46,376 --> 0:26:47,506
为了实现这一点

860
00:26:47,506 --> 0:26:49,276
我们从头开发了 RealityKit 

861
00:26:49,276 --> 0:26:50,446
去支持多人 AR 游戏

862
00:26:51,386 --> 0:26:52,226
结合 ARKit 的 Collaborative Session

863
00:26:52,226 --> 0:26:53,826
今年的会议也有介绍

864
00:26:53,826 --> 0:26:55,576
它提供了一个工具

865
00:26:55,576 --> 0:26:57,146
可以给你的 AR 体验

866
00:26:57,146 --> 0:26:59,506
增加多用户的支持

867
00:27:00,916 --> 0:27:02,146
我们先看一下多人游戏

868
00:27:02,146 --> 0:27:04,816
对我们的游戏意味着什么

869
00:27:04,956 --> 0:27:05,976
玩家会同时在游戏中

870
00:27:05,976 --> 0:27:07,986
可能在任何时间

871
00:27:07,986 --> 0:27:09,156
翻转卡片

872
00:27:10,486 --> 0:27:11,986
每个人都会看到显示的卡片

873
00:27:12,146 --> 0:27:13,896
因此 如果你关注

874
00:27:13,896 --> 0:27:15,096
其他玩家的情况

875
00:27:15,096 --> 0:27:16,346
就会获得一定优势

876
00:27:16,346 --> 0:27:18,726
我们加上一个白色的小圈

877
00:27:18,726 --> 0:27:20,366
用来提示玩家

878
00:27:20,636 --> 0:27:21,976
他们正在翻转的卡片

879
00:27:25,176 --> 0:27:26,616
我们看一下 RealityKit 中的

880
00:27:26,816 --> 0:27:27,456
多人游戏功能

881
00:27:28,236 --> 0:27:29,786
RealityKit 提供

882
00:27:29,916 --> 0:27:30,836
场景自动同步

883
00:27:31,676 --> 0:27:33,276
更改会在所有设备上

884
00:27:33,276 --> 0:27:35,206
自动更新

885
00:27:36,576 --> 0:27:38,136
提升了 MultipeerConnectivity

886
00:27:38,136 --> 0:27:39,836
的设备发现和连接

887
00:27:40,856 --> 0:27:42,316
这样就能轻松查找

888
00:27:42,316 --> 0:27:43,406
并连接附近设备

889
00:27:44,096 --> 0:27:45,756
而无需维护服务器

890
00:27:45,756 --> 0:27:46,846
甚至无需连接到

891
00:27:46,846 --> 0:27:47,476
相同的 Wi-Fi 网络

892
00:27:48,016 --> 0:27:49,966
它提供了一个易于使用的

893
00:27:49,966 --> 0:27:51,406
所有权模型

894
00:27:51,406 --> 0:27:52,826
能让你控制

895
00:27:52,826 --> 0:27:54,376
允许哪个玩家更改哪个实体

896
00:27:55,006 --> 0:27:57,986
即使是网络繁忙的 Wi-Fi

897
00:27:57,986 --> 0:27:59,466
也能降低延迟

898
00:27:59,466 --> 0:28:01,496
这对加强 AR 体验十分重要

899
00:27:59,466 --> 0:28:01,496
这对加强 AR 体验十分重要

900
00:28:04,256 --> 0:28:05,826
下面进行下一步

901
00:28:05,826 --> 0:28:07,356
为我们游戏增加多人游戏

902
00:28:08,386 --> 0:28:10,156
首先需要指定一个发起人

903
00:28:10,526 --> 0:28:11,406
我们来放置游戏面板

904
00:28:12,696 --> 0:28:13,826
在游戏的主菜单上

905
00:28:13,826 --> 0:28:15,756
请用户选择

906
00:28:16,686 --> 0:28:18,486
然后把会话连起来

907
00:28:18,486 --> 0:28:20,426
它们之间就可以相互交流

908
00:28:21,686 --> 0:28:23,776
我们还使用 ARKit 的

909
00:28:23,776 --> 0:28:25,326
Collaborative Session

910
00:28:25,326 --> 0:28:26,386
可以让我们的玩家

911
00:28:26,386 --> 0:28:27,726
创建一个共享的环境地图

912
00:28:28,826 --> 0:28:30,136
我们创建一个同步锚点

913
00:28:30,136 --> 0:28:31,966
它可以将我们的游戏面板

914
00:28:31,966 --> 0:28:33,786
连接到世界的特定位置

915
00:28:33,786 --> 0:28:35,956
并在玩家之间进行协调

916
00:28:36,786 --> 0:28:38,476
最后 我们利用所有权

917
00:28:38,476 --> 0:28:39,676
对游戏面板进行更改

918
00:28:40,076 --> 0:28:42,316
例如翻转卡片 移除卡片

919
00:28:43,126 --> 0:28:45,166
我们请用户在主菜单中

920
00:28:45,166 --> 0:28:46,676
选择发起 或加入

921
00:28:47,406 --> 0:28:49,056
现在我们需要建立一个连接

922
00:28:50,286 --> 0:28:51,506
我们使用 MultipeerConnectivity 框架

923
00:28:51,506 --> 0:28:54,396
进行连接

924
00:28:54,396 --> 0:28:56,356
我们不会过多介绍

925
00:28:56,356 --> 0:28:57,416
MultipeerConnectivity 的细节

926
00:28:57,416 --> 0:28:58,946
如果你想了解

927
00:28:58,946 --> 0:29:02,246
请查看 2014 年的会议

928
00:28:58,946 --> 0:29:02,246
请查看 2014 年的会议

929
00:29:02,306 --> 0:29:03,006
Cross Platform Nearby Networking

930
00:29:04,186 --> 0:29:06,876
首先创建一个 MCPeerID 和 MCSession

931
00:29:07,976 --> 0:29:09,426
一定要启用加密

932
00:29:09,426 --> 0:29:11,116
因为要和 RealityKit 一起使用

933
00:29:14,036 --> 0:29:14,966
在继续推进之前

934
00:29:14,966 --> 0:29:15,696
我们先检查用户角色

935
00:29:16,426 --> 0:29:17,586
如果他们选择发起

936
00:29:17,586 --> 0:29:19,266
我们将使用

937
00:29:19,316 --> 0:29:21,166
MCNearbyServiceAdvertiser 传播会话

938
00:29:21,906 --> 0:29:23,046
这说明我们有一个

939
00:29:23,046 --> 0:29:23,766
可用的会话

940
00:29:24,416 --> 0:29:26,316
客户端创建了一个

941
00:29:26,396 --> 0:29:28,366
MCNearbyServiceBrowser 

942
00:29:28,366 --> 0:29:29,066
开始查找会话

943
00:29:29,936 --> 0:29:30,786
现在我们有了一个 MCSession 

944
00:29:30,836 --> 0:29:32,796
我们需要让

945
00:29:32,796 --> 0:29:34,586
RealityKit 使用进行同步

946
00:29:35,406 --> 0:29:36,766
我们创建一个 MultipeerConnectivityService

947
00:29:36,806 --> 0:29:38,706
来实现这一点

948
00:29:38,706 --> 0:29:40,496
该服务是一个 RealityKit 类

949
00:29:40,546 --> 0:29:42,126
它包含着 MCSession 

950
00:29:42,126 --> 0:29:43,726
使其可应用于场景同步

951
00:29:44,626 --> 0:29:45,966
我们创建一个该服务

952
00:29:45,966 --> 0:29:47,316
并把它赋值给场景中的

953
00:29:47,416 --> 0:29:50,136
synchronizationService 属性

954
00:29:50,316 --> 0:29:51,246
现在我们连接了两个设备

955
00:29:51,246 --> 0:29:52,836
同步了他们的场景

956
00:29:53,786 --> 0:29:55,246
但是他们还不知道

957
00:29:55,246 --> 0:29:56,426
他们在物理世界中

958
00:29:56,426 --> 0:29:57,896
相对于彼此的位置

959
00:29:59,076 --> 0:30:00,056
让我们使用

960
00:29:59,076 --> 0:30:00,056
让我们使用

961
00:30:00,056 --> 0:30:01,466
ARKit 3 的 Collaborative Session

962
00:30:01,466 --> 0:30:03,976
RealityKit 提供了对其原生的支持

963
00:30:05,486 --> 0:30:06,786
Collaborative Session 可以让我们

964
00:30:06,786 --> 0:30:07,966
更快地建立世界

965
00:30:08,266 --> 0:30:09,776
让多用户可以共享

966
00:30:09,776 --> 0:30:10,956
相同的世界体验

967
00:30:10,956 --> 0:30:13,646
因为我们想要协作映射

968
00:30:13,646 --> 0:30:15,006
就需要打开它

969
00:30:15,646 --> 0:30:17,236
我们在 viewDidLoad 的最后来做

970
00:30:18,226 --> 0:30:19,976
我们要创建一个新的

971
00:30:19,976 --> 0:30:20,756
WorldTrackingConfiguration

972
00:30:21,876 --> 0:30:24,016
设置 isCollaborationEnabled 为真

973
00:30:25,066 --> 0:30:27,916
指示 AR 会话去运行我们的配置

974
00:30:29,176 --> 0:30:30,736
现在我们有 Collaborative Session

975
00:30:30,736 --> 0:30:32,346
可以让我们创建一个

976
00:30:32,346 --> 0:30:33,856
同步锚点

977
00:30:34,616 --> 0:30:36,436
之前我们创建了一个

978
00:30:36,436 --> 0:30:38,266
锚实体 

979
00:30:38,266 --> 0:30:39,536
要求有一个

980
00:30:39,536 --> 0:30:40,536
不小于 20 平方厘米的水平面

981
00:30:41,386 --> 0:30:42,556
因为现在是多玩家 我们希望

982
00:30:42,556 --> 0:30:43,586
游戏面板放在一个好位置上

983
00:30:43,626 --> 0:30:45,206
能让两个玩家使用

984
00:30:45,676 --> 0:30:46,996
为达到这个效果 我们让

985
00:30:46,996 --> 0:30:47,886
游戏发起人放置游戏面板

986
00:30:48,676 --> 0:30:49,926
因为希望所有玩家看到

987
00:30:49,926 --> 0:30:51,636
相同的世界位置

988
00:30:51,636 --> 0:30:53,376
我们让 ARKit 同步锚点

989
00:30:54,396 --> 0:30:54,976
那应该怎么做呢

990
00:30:58,416 --> 0:31:00,516
发起人这端 我们使用

991
00:30:58,416 --> 0:31:00,516
发起人这端 我们使用

992
00:31:00,516 --> 0:31:02,066
之前用过的 onTap 控制器

993
00:31:03,106 --> 0:31:04,816
我们想挑选一个点适合所有人

994
00:31:05,076 --> 0:31:06,736
我们将光线投射到现实世界

995
00:31:07,926 --> 0:31:09,416
这和 Ross 之前展示过的

996
00:31:09,416 --> 0:31:11,296
点按检测相似

997
00:31:11,496 --> 0:31:12,546
但这个是针对

998
00:31:12,546 --> 0:31:14,006
现实世界判断

999
00:31:14,456 --> 0:31:15,696
而不是虚拟对象来运行的

1000
00:31:16,236 --> 0:31:17,926
我们的游戏面板需要

1001
00:31:17,926 --> 0:31:19,726
一个平坦的表面

1002
00:31:19,726 --> 0:31:20,916
所以我们要找一个水平面

1003
00:31:21,576 --> 0:31:24,226
如果它找到一个水平面

1004
00:31:24,696 --> 0:31:25,976
我们就采用 worldTransform

1005
00:31:25,976 --> 0:31:27,516
创建一个 AR 锚点

1006
00:31:28,206 --> 0:31:30,146
这是一个 ARKit 锚点

1007
00:31:30,146 --> 0:31:32,286
我们将其添加到视图提供的 AR 会话

1008
00:31:33,126 --> 0:31:34,516
这会创建一个同步锚点

1009
00:31:34,516 --> 0:31:36,796
它在真实世界的位置

1010
00:31:36,796 --> 0:31:38,266
会由 ARKit 协调

1011
00:31:39,696 --> 0:31:41,416
使用那个 AR 锚点

1012
00:31:41,416 --> 0:31:42,356
我们创建了一个

1013
00:31:42,356 --> 0:31:42,736
RealityKit 锚点实体

1014
00:31:43,426 --> 0:31:44,936
这是 ARKit 和 RealityKit 

1015
00:31:45,106 --> 0:31:47,706
之间的桥梁 允许我们添加卡片

1016
00:31:47,706 --> 0:31:50,086
我们已经有 Ross 之前展示过的

1017
00:31:50,236 --> 0:31:51,276
游戏面板了

1018
00:31:52,326 --> 0:31:54,326
只有发起人需要建立随机游戏面板

1019
00:31:55,146 --> 0:31:56,116
其他人通过

1020
00:31:56,116 --> 0:31:58,266
网络同步自动接收

1021
00:31:59,526 --> 0:32:00,636
我们加载的模型

1022
00:31:59,526 --> 0:32:00,636
我们加载的模型

1023
00:32:00,636 --> 0:32:01,716
不会作为场景的一部分

1024
00:32:01,716 --> 0:32:02,996
进行同步 

1025
00:32:02,996 --> 0:32:03,506
因为数据量太大

1026
00:32:04,446 --> 0:32:05,666
还记得 Ross 向我们展示

1027
00:32:05,666 --> 0:32:07,286
如何加载卡片模板吗

1028
00:32:07,606 --> 0:32:09,296
保证我们在所有的外观上都这样做

1029
00:32:10,046 --> 0:32:11,166
这就足够让我们的游戏

1030
00:32:11,166 --> 0:32:12,396
开始运行

1031
00:32:15,206 --> 0:32:16,676
在左边 我们能看到

1032
00:32:16,676 --> 0:32:17,766
发起人放置了游戏面板

1033
00:32:18,056 --> 0:32:18,986
参与者也看到了

1034
00:32:19,476 --> 0:32:20,676
在真实世界里的位置

1035
00:32:20,676 --> 0:32:21,106
是相同的

1036
00:32:22,076 --> 0:32:23,386
看发起人翻动卡片

1037
00:32:23,386 --> 0:32:24,846
然后是另一张

1038
00:32:25,456 --> 0:32:26,536
好吧 不是一对

1039
00:32:27,206 --> 0:32:28,226
可以看到它在参与者这边

1040
00:32:28,226 --> 0:32:29,656
是自动反应的

1041
00:32:29,656 --> 0:32:30,856
动画也非常流畅	

1042
00:32:31,526 --> 0:32:32,796
不需要网络程序

1043
00:32:33,776 --> 0:32:35,836
现在来看参与者翻转卡片

1044
00:32:36,396 --> 0:32:38,626
参与者的屏幕上翻转了

1045
00:32:39,076 --> 0:32:40,266
但发起人的屏幕上没有

1046
00:32:40,776 --> 0:32:41,926
为了解释这一现象

1047
00:32:41,926 --> 0:32:43,476
需要先解释一下所有权

1048
00:32:44,046 --> 0:32:45,696
所有权是什么？

1049
00:32:46,596 --> 0:32:48,386
它是修改实体的权利

1050
00:32:49,636 --> 0:32:51,496
在一个共享会话中

1051
00:32:51,496 --> 0:32:53,536
一个实体一次只有一个所有者

1052
00:32:53,536 --> 0:32:55,256
默认为是创造这个实体的人

1053
00:32:56,056 --> 0:32:58,246
在我们的例子中就是发起人

1054
00:33:00,226 --> 0:33:02,276
所有权是可以转移的

1055
00:33:02,276 --> 0:33:03,086
这也是允许其他玩家

1056
00:33:03,176 --> 0:33:04,216
作出更改的方法

1057
00:33:05,006 --> 0:33:06,266
所有权的转移是可配置的

1058
00:33:06,266 --> 0:33:08,486
所以你可以决定

1059
00:33:08,486 --> 0:33:09,196
哪些实体可以转移

1060
00:33:09,196 --> 0:33:10,836
什么时间转移

1061
00:33:11,926 --> 0:33:13,416
为了阐明所有权

1062
00:33:13,416 --> 0:33:14,686
我们看看在游戏中发生了什么

1063
00:33:17,006 --> 0:33:18,096
发起人创建了卡片

1064
00:33:18,546 --> 0:33:19,546
说明他拥有这些卡片

1065
00:33:20,126 --> 0:33:22,106
这些卡片会自动出现在

1066
00:33:22,106 --> 0:33:22,866
参与者屏幕上

1067
00:33:23,426 --> 0:33:25,506
当实体的所有者

1068
00:33:25,506 --> 0:33:27,146
进行更改 比如

1069
00:33:27,146 --> 0:33:29,306
翻转卡片 这个改变

1070
00:33:29,306 --> 0:33:30,786
会发送给参与者

1071
00:33:30,786 --> 0:33:31,316
反映在他们的场景中

1072
00:33:32,486 --> 0:33:33,666
由于 RealityKit 从头开始

1073
00:33:33,666 --> 0:33:34,696
构建多人游戏

1074
00:33:34,696 --> 0:33:37,326
我们只能将指令同步到动画

1075
00:33:37,326 --> 0:33:39,906
而不能转换每一帧

1076
00:33:40,506 --> 0:33:41,876
所以在参与者界面上

1077
00:33:41,876 --> 0:33:42,406
看起来十分流畅

1078
00:33:43,126 --> 0:33:45,476
现在参与者翻转卡片

1079
00:33:46,506 --> 0:33:47,756
由于参与者不是

1080
00:33:47,756 --> 0:33:49,756
实体的拥有者

1081
00:33:49,756 --> 0:33:50,466
因此不会同步更改

1082
00:33:51,616 --> 0:33:52,596
虽然还是可以在

1083
00:33:52,626 --> 0:33:53,956
本地做出更改

1084
00:33:53,956 --> 0:33:55,696
但下次所有者发送更新时

1085
00:33:55,696 --> 0:33:57,076
它们可能会被覆盖

1086
00:33:58,096 --> 0:33:59,456
这会陷入两难境地

1087
00:33:59,456 --> 0:34:00,956
因为我们确实希望对卡片做些改变

1088
00:33:59,456 --> 0:34:00,956
因为我们确实希望对卡片做些改变

1089
00:34:01,696 --> 0:34:03,036
让我们退一步

1090
00:34:03,036 --> 0:34:04,746
退到参与者翻转机器人卡片之前

1091
00:34:05,956 --> 0:34:06,796
我之前提过

1092
00:34:07,716 --> 0:34:08,766
所有权可以转移

1093
00:34:09,476 --> 0:34:11,896
任何参与者都可以请求实体的所有权

1094
00:34:12,726 --> 0:34:13,815
在更改之前

1095
00:34:13,815 --> 0:34:15,275
我们让参与者请求

1096
00:34:15,626 --> 0:34:16,806
黄色机器人卡片的所有权

1097
00:34:18,106 --> 0:34:19,456
它向发起人发送了请求

1098
00:34:19,806 --> 0:34:20,726
要求所有权

1099
00:34:21,826 --> 0:34:23,036
实体的所有者决定

1100
00:34:23,036 --> 0:34:24,166
是否转移所有权

1101
00:34:24,755 --> 0:34:26,076
他可能会拒绝

1102
00:34:26,076 --> 0:34:28,186
如果存在另一名参与者请求所有权

1103
00:34:28,186 --> 0:34:29,826
或者对象的转移模式发生改变

1104
00:34:30,835 --> 0:34:32,565
在默认状态 

1105
00:34:32,565 --> 0:34:34,496
发起人接受请求

1106
00:34:34,496 --> 0:34:36,176
将所有权转移给参与者

1107
00:34:37,286 --> 0:34:38,856
参与者现在可以

1108
00:34:38,856 --> 0:34:39,726
随意更改卡片

1109
00:34:40,505 --> 0:34:42,136
我们可以显示卡片

1110
00:34:42,136 --> 0:34:44,186
发起人那里也会显示更改

1111
00:34:45,206 --> 0:34:46,716
我们让这一过程易于实现

1112
00:34:47,255 --> 0:34:50,306
参与者开始请求

1113
00:34:50,306 --> 0:34:51,496
实体的所有权

1114
00:34:52,485 --> 0:34:54,516
如果我们已经拥有这个对象就没问题

1115
00:34:55,176 --> 0:34:56,246
该请求将被通过

1116
00:34:56,246 --> 0:34:58,266
不需进行额外工作

1117
00:34:59,236 --> 0:35:00,106
请求所有权的信息返回时

1118
00:34:59,236 --> 0:35:00,106
请求所有权的信息返回时

1119
00:35:00,106 --> 0:35:01,586
我们就会知道

1120
00:35:01,586 --> 0:35:03,266
请求有没有被批准

1121
00:35:04,046 --> 0:35:05,846
如果被批准了

1122
00:35:05,846 --> 0:35:06,966
对卡片调用 reveal 翻转卡片

1123
00:35:07,996 --> 0:35:09,156
但是 如果请求被拒绝了

1124
00:35:09,196 --> 0:35:10,676
比如说 其他人

1125
00:35:10,676 --> 0:35:12,166
翻转了卡片

1126
00:35:12,166 --> 0:35:14,176
我们会给用户选择其他不同卡片的机会

1127
00:35:15,246 --> 0:35:16,246
这就是我们要做的 

1128
00:35:16,246 --> 0:35:18,096
翻转卡片并在让所有游戏玩家看到

1129
00:35:18,676 --> 0:35:20,006
但是我们还想再进一步

1130
00:35:21,006 --> 0:35:22,466
当卡片处于显示状态时

1131
00:35:22,466 --> 0:35:24,236
我们希望它的所有权不会改变

1132
00:35:24,966 --> 0:35:26,666
当卡片处于显示状态时

1133
00:35:26,666 --> 0:35:28,196
我们想拒绝

1134
00:35:28,196 --> 0:35:28,606
对这张卡片所有权的全部请求

1135
00:35:29,576 --> 0:35:30,956
我们回到 reveal 方法

1136
00:35:33,066 --> 0:35:34,656
我们之前将

1137
00:35:34,826 --> 0:35:36,116
revealed 属性设为真

1138
00:35:37,166 --> 0:35:38,436
因为我们在卡片组件上

1139
00:35:38,436 --> 0:35:40,856
采用了 Codable 协议

1140
00:35:40,926 --> 0:35:42,686
它将自动在参与者界面上更新

1141
00:35:42,936 --> 0:35:43,896
不需要额外做什么

1142
00:35:44,546 --> 0:35:46,726
我们把卡片的 revealed 属性

1143
00:35:46,726 --> 0:35:48,916
设置为真

1144
00:35:48,916 --> 0:35:50,316
所有权转移模式设置为 manual

1145
00:35:51,036 --> 0:35:52,936
这会自动拒绝

1146
00:35:52,936 --> 0:35:56,226
任何实体所有权转移的请求

1147
00:35:56,486 --> 0:35:57,756
当我们翻转卡片 将状态改为隐藏

1148
00:35:57,756 --> 0:35:59,096
我们想开始

1149
00:35:59,096 --> 0:36:00,656
接受所有权转移的请求

1150
00:35:59,096 --> 0:36:00,656
接受所有权转移的请求

1151
00:36:02,036 --> 0:36:03,566
hide 方法看起来就是这个样子

1152
00:36:04,856 --> 0:36:05,846
把 revealed 属性设置为假

1153
00:36:05,896 --> 0:36:07,776
我们把所有权转移模式

1154
00:36:07,776 --> 0:36:09,476
设置为 autoAccept

1155
00:36:10,286 --> 0:36:11,776
这将指示 RealityKit

1156
00:36:11,776 --> 0:36:13,126
自动接受

1157
00:36:13,126 --> 0:36:14,806
实体所有权转移的请求

1158
00:36:16,096 --> 0:36:17,056
我需要指出一件事

1159
00:36:17,056 --> 0:36:19,166
对所有权来说

1160
00:36:19,296 --> 0:36:20,196
发起人并不是特殊的

1161
00:36:21,036 --> 0:36:22,786
他放置了游戏面板

1162
00:36:22,926 --> 0:36:24,506
初始时拥有所有的卡片

1163
00:36:25,096 --> 0:36:26,756
但其他方面和参与者

1164
00:36:26,756 --> 0:36:28,086
没有差别

1165
00:36:28,406 --> 0:36:29,676
一旦实体的所有权转移

1166
00:36:29,886 --> 0:36:30,946
如果发起人想要翻转

1167
00:36:30,946 --> 0:36:32,836
他也需要请求

1168
00:36:34,006 --> 0:36:36,046
可以使用所有权转移模式 改变这个行为

1169
00:36:36,046 --> 0:36:37,306
以适应你的 App

1170
00:36:38,336 --> 0:36:39,636
我们的 App 还有

1171
00:36:40,336 --> 0:36:41,136
最后一个细节

1172
00:36:41,396 --> 0:36:42,326
当你和两个或更多玩家

1173
00:36:42,326 --> 0:36:43,596
一起玩游戏 你会发现

1174
00:36:43,596 --> 0:36:44,976
游戏板会让人困惑

1175
00:36:45,516 --> 0:36:47,096
你很难知道

1176
00:36:47,096 --> 0:36:48,296
你选择了哪张卡

1177
00:36:48,296 --> 0:36:49,586
别人选择了哪张

1178
00:36:50,246 --> 0:36:51,636
我们想添加一个透明圆圈

1179
00:36:51,636 --> 0:36:53,026
显示我们的选择

1180
00:36:53,936 --> 0:36:55,946
正如我们所见

1181
00:36:55,946 --> 0:36:56,296
一切都是共享的

1182
00:36:56,596 --> 0:36:57,846
这会显示给所有人

1183
00:36:57,846 --> 0:36:59,076
与它的意图不符

1184
00:37:00,426 --> 0:37:02,256
幸运的是 RealityKit

1185
00:37:02,256 --> 0:37:03,366
支持仅本地可见的实体

1186
00:37:04,206 --> 0:37:05,636
这非常适合展示

1187
00:37:05,636 --> 0:37:07,086
选择的标志或隐藏的信息

1188
00:37:07,086 --> 0:37:08,916
就像玩扑克的手

1189
00:37:09,876 --> 0:37:12,926
为此 我们移除了同步组件

1190
00:37:12,926 --> 0:37:14,566
在其他功能上

1191
00:37:14,566 --> 0:37:15,266
和别的实体一样

1192
00:37:15,896 --> 0:37:19,166
如果实体有子实体

1193
00:37:19,166 --> 0:37:20,286
它们也不会被共享

1194
00:37:20,776 --> 0:37:21,866
这对于将一整个实体树

1195
00:37:21,866 --> 0:37:23,996
设为本地可见十分有用

1196
00:37:25,316 --> 0:37:26,936
这里我就不展示了

1197
00:37:26,936 --> 0:37:28,346
我创建了一个 SelectionEntity 类

1198
00:37:28,346 --> 0:37:30,036
可以代表我们的选择

1199
00:37:30,736 --> 0:37:32,186
它的初始化增加了

1200
00:37:32,466 --> 0:37:33,746
一个略透明的白色圆圈

1201
00:37:35,046 --> 0:37:35,986
我们将它添加到

1202
00:37:35,986 --> 0:37:37,536
之前的 reveal 方法中

1203
00:37:38,176 --> 0:37:40,606
我们创建了实体和位置

1204
00:37:40,606 --> 0:37:42,316
稍微高于这个卡片

1205
00:37:43,516 --> 0:37:45,166
然后我们把同步组件

1206
00:37:45,166 --> 0:37:46,196
设置为 nil 

1207
00:37:46,866 --> 0:37:48,176
这将指示 RealityKit

1208
00:37:48,176 --> 0:37:49,466
我们不想分享这个实体

1209
00:37:50,226 --> 0:37:51,756
我们把子实体正常

1210
00:37:52,196 --> 0:37:53,106
加入层次结构中

1211
00:37:54,206 --> 0:37:55,416
现在已经添加到了 reveal 中

1212
00:37:55,416 --> 0:37:57,806
我们也需要在隐藏卡片时移除它

1213
00:37:58,336 --> 0:38:01,506
这是之前的 hide 方法

1214
00:37:58,336 --> 0:38:01,506
这是之前的 hide 方法

1215
00:38:02,766 --> 0:38:04,026
更改其他属性后

1216
00:38:04,316 --> 0:38:05,486
我们将使用 for 循环

1217
00:38:05,746 --> 0:38:06,416
迭代子实体

1218
00:38:07,256 --> 0:38:08,796
我们可以使用 where 子句

1219
00:38:08,796 --> 0:38:11,026
查找类型为 selection 的实体

1220
00:38:12,206 --> 0:38:14,556
一旦找到 就会从父实体中移除

1221
00:38:15,416 --> 0:38:16,336
因为我们知道

1222
00:38:16,336 --> 0:38:17,896
只会有一个 selection 实体

1223
00:38:17,896 --> 0:38:21,126
我们将跳出循环 就是这样

1224
00:38:21,456 --> 0:38:22,266
我们正确处理了所有权

1225
00:38:22,266 --> 0:38:23,926
为选择而添加或移除了

1226
00:38:23,926 --> 0:38:25,656
本地实体

1227
00:38:25,966 --> 0:38:27,886
现在我们的游戏

1228
00:38:27,886 --> 0:38:28,816
在两个设备上正常运行

1229
00:38:29,706 --> 0:38:30,966
我们的演示为求简单

1230
00:38:30,966 --> 0:38:33,446
只使用两个设备进行游戏

1231
00:38:33,446 --> 0:38:35,676
事实上我们还能支持更多设备

1232
00:38:35,676 --> 0:38:36,906
而不需增加代码

1233
00:38:42,906 --> 0:38:43,996
让我们回顾一下

1234
00:38:44,036 --> 0:38:44,316
我们学了什么

1235
00:38:44,876 --> 0:38:46,236
我们今天展示了

1236
00:38:46,236 --> 0:38:47,696
RealityKit 如何简单快速的

1237
00:38:47,696 --> 0:38:49,236
构建 AR App

1238
00:38:50,486 --> 0:38:51,506
我们介绍了 

1239
00:38:51,506 --> 0:38:53,656
如何用锚放置内容

1240
00:38:53,656 --> 0:38:55,246
同步和异步

1241
00:38:55,246 --> 0:38:57,446
加载素材

1242
00:38:57,446 --> 0:38:59,176
在点按检测中集成交互

1243
00:39:00,266 --> 0:39:03,196
实体中创建自定义组件

1244
00:39:03,196 --> 0:39:05,506
以及如何在 AR 体验中增加多玩家

1245
00:39:06,506 --> 0:39:07,506
我希望能让你们更了解

1246
00:39:07,506 --> 0:39:08,746
RealityKit 是什么

1247
00:39:08,746 --> 0:39:10,626
能做什么

1248
00:39:11,386 --> 0:39:12,846
我们迫不及待地想看看

1249
00:39:12,846 --> 0:39:13,806
你们能用它做什么

1250
00:39:14,616 --> 0:39:16,246
获取更多信息

1251
00:39:16,296 --> 0:39:18,036
以及会议视频

1252
00:39:18,036 --> 0:39:18,966
请查看会议的网站

1253
00:39:19,916 --> 0:39:22,686
并查看 Introducing RealityKit and Reality Composer

1254
00:39:22,956 --> 0:39:25,526
获取更多 RealityKit 的相关信息

1255
00:39:25,526 --> 0:39:27,506
不要错过 Introducing ARKit 3

1256
00:39:27,506 --> 0:39:28,816
可以了解 Collaborative Session

1257
00:39:29,146 --> 0:39:30,116
和其他新功能的更多信息

1258
00:39:31,326 --> 0:39:32,276
请一定要来我们的实验室

1259
00:39:32,276 --> 0:39:34,886
时间是今天下午以及

1260
00:39:34,886 --> 0:39:35,506
明天下午 3 点

1261
00:39:36,966 --> 0:39:38,976
谢谢大家 请好好享受接下来的会议

1262
00:39:39,516 --> 0:39:42,500
[掌声]
