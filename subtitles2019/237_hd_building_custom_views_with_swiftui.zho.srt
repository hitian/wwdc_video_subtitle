1
00:00:07,808 --> 0:00:10,844
（在SwiftUI中创建自定义视

2
00:00:15,849 --> 0:00:19,920
大家好 很高兴再次在WWDC

3
00:00:20,687 --> 0:00:25,526
我是Dave 如果你曾看过

4
00:00:25,592 --> 0:00:29,763
你就知道把app的

5
00:00:29,830 --> 0:00:30,931
并让app开始运行是多么简单

6
00:00:31,765 --> 0:00:36,570
今天我和John要介绍如何实现

7
00:00:36,637 --> 0:00:41,742
从创建功能性app

8
00:00:42,075 --> 0:00:45,579
漂亮的图形和一些很酷的动画

9
00:00:47,915 --> 0:00:50,784
我们会介绍SwiftUI的

10
00:00:51,752 --> 0:00:55,022
然后John会上台来

11
00:00:56,256 --> 0:00:57,224
让我们开始吧

12
00:00:57,658 --> 0:01:03,764
从你着手使用SwiftUI开始

13
00:00:57,658 --> 0:01:03,764
从你着手使用SwiftUI开始

14
00:01:03,830 --> 0:01:04,831
布局系统了

15
00:01:05,265 --> 0:01:08,535
你在预览编辑器中的文本四周

16
00:01:09,136 --> 0:01:10,571
是它的边界

17
00:01:11,004 --> 0:01:13,807
布局就是在屏幕上

18
00:01:14,975 --> 0:01:18,178
让我们用这个例子

19
00:01:18,245 --> 0:01:19,279
看一下底层发生了什么

20
00:01:21,582 --> 0:01:24,451
从技术上说 这里有三个视图

21
00:01:25,018 --> 0:01:27,921
分别是视图等级底部的文本

22
00:01:29,923 --> 0:01:34,995
你的内容视图 它总是拥有

23
00:01:35,996 --> 0:01:40,868
最后是根视图

24
00:01:40,934 --> 0:01:43,971
减去安全区域尺寸

25
00:01:44,638 --> 0:01:47,441
那么如果你在手机顶部

26
00:01:47,841 --> 0:01:49,176
比如它不含在内

27
00:01:51,144 --> 0:01:57,618
小技巧 你仍可在那个区中安排东西

28
00:01:57,951 --> 0:02:00,120
但默认情况下 你处于安全区

29
00:01:57,951 --> 0:02:00,120
但默认情况下 你处于安全区

30
00:02:01,388 --> 0:02:07,794
我们总是把任意带有主体的

31
00:02:08,228 --> 0:02:11,899
因此它的边界

32
00:02:11,965 --> 0:02:13,333
对它们的操作一样

33
00:02:13,767 --> 0:02:16,103
因此你真的可以为了布局目的

34
00:02:16,170 --> 0:02:17,871
把它们当作同一个视图

35
00:02:18,572 --> 0:02:21,675
因此这里其实只有两个视图

36
00:02:22,042 --> 0:02:24,478
布局过程有三个步骤

37
00:02:26,346 --> 0:02:30,684
第一步 根视图提供文本、推荐尺寸

38
00:02:31,185 --> 0:02:33,620
由那两个又大又宽的箭头表示

39
00:02:34,288 --> 0:02:38,458
因为它是根视图

40
00:02:40,427 --> 0:02:43,697
下一步 文本回应

41
00:02:43,764 --> 0:02:46,533
但我真的 我只能做这么大

42
00:02:47,134 --> 0:02:52,206
在SwiftUI中 不能给子视图

43
00:02:52,272 --> 0:02:54,141
而是由父视图来决定

44
00:02:56,210 --> 0:03:00,447
现在根视图说了

45
00:02:56,210 --> 0:03:00,447
现在根视图说了

46
00:03:00,714 --> 0:03:02,182
那么我要把你放在中间

47
00:03:03,951 --> 0:03:04,952
那么就是这样

48
00:03:05,485 --> 0:03:09,556
这是个简单的例子

49
00:03:09,623 --> 0:03:13,026
在父视图和子视图之间

50
00:03:13,327 --> 0:03:15,696
并且整个布局的行为

51
00:03:15,896 --> 0:03:18,599
从这些父-子视图交互中浮现出来

52
00:03:20,868 --> 0:03:23,437
但我想强调一下第二步

53
00:03:23,670 --> 0:03:26,473
因为它与你所熟悉的不一样

54
00:03:27,007 --> 0:03:29,443
它对你非常重要

55
00:03:30,611 --> 0:03:33,680
它意味着你的视图有尺寸调整行为

56
00:03:35,649 --> 0:03:40,420
因为每个视图都控制自己的尺寸

57
00:03:40,721 --> 0:03:43,657
你就要决定

58
00:03:44,391 --> 0:03:49,730
比如 这个视图是不可修正的

59
00:03:50,063 --> 0:03:53,033
由于它的根视图中框架尺寸是固定的

60
00:03:54,501 --> 0:03:59,806
而这个是可灵活调整的视图

61
00:04:00,574 --> 0:04:03,043
因此它的长宽比总是一比一

62
00:04:03,510 --> 0:04:06,880
因此尺寸被封装到了视图定义中

63
00:04:08,415 --> 0:04:10,384
我们还看到它也适用于文本

64
00:04:11,485 --> 0:04:16,356
那么在SwiftUI中

65
00:04:16,423 --> 0:04:18,257
它所显示的行的高度和宽度

66
00:04:18,759 --> 0:04:21,894
我们稍后讲堆栈时再了解

67
00:04:23,530 --> 0:04:29,870
在布局中还有最后一步

68
00:04:29,937 --> 0:04:35,175
在SwiftUI中

69
00:04:35,242 --> 0:04:39,947
因为我们会替你处理

70
00:04:40,013 --> 0:04:42,816
把你的视图圆角化为一个

71
00:04:43,483 --> 0:04:49,923
你不会得到像这样锯齿形的边

72
00:04:50,791 --> 0:04:55,529
这只是每个好app

73
00:04:56,196 --> 0:05:00,167
但SwiftUI会替你分担

74
00:04:56,196 --> 0:05:00,167
但SwiftUI会替你分担

75
00:05:03,704 --> 0:05:06,773
从而你可以重点关注

76
00:05:08,041 --> 0:05:13,647
好的 现在我们了解了基础知识

77
00:05:13,714 --> 0:05:15,415
是否可以把它变得更好

78
00:05:17,150 --> 0:05:21,755
我要把示例中的文本

79
00:05:22,322 --> 0:05:25,325
我不知道

80
00:05:26,727 --> 0:05:27,728
你们饿了吗？

81
00:05:28,929 --> 0:05:32,599
不饿？好的

82
00:05:33,000 --> 0:05:35,068
我要在这里添加漂亮的绿色背景

83
00:05:35,936 --> 0:05:42,242
现在这个背景修饰器在背景视图中

84
00:05:42,609 --> 0:05:44,811
颜色视图作为第二子视图

85
00:05:47,481 --> 0:05:51,818
现在绿色背景精准匹配文本的边界

86
00:05:52,886 --> 0:05:58,425
第二个小技巧

87
00:05:58,592 --> 0:06:02,329
是个非常有用的技巧

88
00:05:58,592 --> 0:06:02,329
是个非常有用的技巧

89
00:06:02,563 --> 0:06:04,965
并且没有便利的预览画布的话

90
00:06:06,300 --> 0:06:11,205
好的 现在我想在绿框内的文本四周

91
00:06:11,271 --> 0:06:15,409
因此我要在那插入一些内边距

92
00:06:17,444 --> 0:06:23,116
现在SwiftUI选择了许多

93
00:06:23,183 --> 0:06:25,319
动态类型尺寸和环境的内边距

94
00:06:26,420 --> 0:06:30,290
当你不传递任何参数时

95
00:06:30,557 --> 0:06:36,330
与SwiftUI适应性地调整

96
00:06:36,396 --> 0:06:37,931
取决于它所处的情境

97
00:06:39,233 --> 0:06:42,836
并且如果我们只想适应性地填充

98
00:06:43,337 --> 0:06:44,705
嗯 我们也可以实现

99
00:06:46,607 --> 0:06:50,444
适应性修饰器是调整布局的最佳方式

100
00:06:50,711 --> 0:06:54,715
因为你避免了把代码复杂化

101
00:06:54,781 --> 0:06:56,049
在一些细节上浪费时间

102
00:06:56,350 --> 0:06:59,119
并避免硬编码常量

103
00:07:00,787 --> 0:07:06,193
但因为我们在这里控制着这些细节

104
00:07:06,260 --> 0:07:10,497
要求所有内边距都是十个点

105
00:07:11,732 --> 0:07:13,166
好的 你可以明确地写出来

106
00:07:14,635 --> 0:07:18,739
这个例子比Hello World

107
00:07:19,373 --> 0:07:22,476
让我们在这个例子中看看

108
00:07:23,911 --> 0:07:28,882
首先 根视图为背景视图提供了

109
00:07:29,716 --> 0:07:35,189
与吐司视图类似

110
00:07:35,722 --> 0:07:38,225
因此它会把那个建议尺寸

111
00:07:38,292 --> 0:07:40,394
传递给内边距视图

112
00:07:42,696 --> 0:07:48,235
内边距视图知道它要给它子视图的

113
00:07:48,435 --> 0:07:53,240
因此它给它的子视图文本视图

114
00:07:55,309 --> 0:07:59,513
文本占据了它所需要的宽度

115
00:08:00,614 --> 0:08:04,852
内边距视图就知道每一边都要

116
00:08:04,918 --> 0:08:08,589
并且它把文本恰当地放到了

117
00:08:11,158 --> 0:08:14,061
现在我们说过背景视图是中性布局

118
00:08:14,127 --> 0:08:16,230
因此它只需要向上报告那个尺寸即可

119
00:08:16,563 --> 0:08:22,936
但在此之前 它把那个尺寸提供给

120
00:08:24,605 --> 0:08:28,775
颜色在布局时非常顺从

121
00:08:29,142 --> 0:08:31,378
它们接受提供给它们的尺寸

122
00:08:31,545 --> 0:08:35,649
因此尺寸的颜色与内边距视图的一样

123
00:08:36,984 --> 0:08:40,153
最后背景视图把它的尺寸

124
00:08:40,587 --> 0:08:44,825
并且根视图会跟以前一样

125
00:08:45,158 --> 0:08:46,493
这就是整个过程

126
00:08:47,728 --> 0:08:49,029
准备好看另一个例子了吗？

127
00:08:49,263 --> 0:08:52,299
这个例子更简单 但它很重要

128
00:08:53,734 --> 0:09:00,040
那么在这个例子中 视图的主题

129
00:08:53,734 --> 0:09:00,040
那么在这个例子中 视图的主题

130
00:09:01,275 --> 0:09:07,281
SwiftUI中 除非在资产目录

131
00:09:07,514 --> 0:09:09,750
否则就是固定尺寸

132
00:09:10,951 --> 0:09:15,489
现在我希望视图

133
00:09:15,656 --> 0:09:19,660
让我们添加一个30乘30的

134
00:09:21,495 --> 0:09:26,700
现在你可能注意到了

135
00:09:26,767 --> 0:09:30,470
图片虽然确实很可口

136
00:09:32,306 --> 0:09:34,208
但不应该太惊讶 是吗？

137
00:09:34,508 --> 0:09:35,843
我们说过它是固定尺寸

138
00:09:37,277 --> 0:09:40,814
在它周围你会发现一个

139
00:09:41,348 --> 0:09:45,185
那是视图主体的尺寸

140
00:09:45,252 --> 0:09:49,590
实际上比我们之前添加的修饰器

141
00:09:51,725 --> 0:09:56,330
因此框架尺寸与图片尺寸不匹配

142
00:09:56,396 --> 0:09:57,497
这是个矛盾吗？

143
00:09:59,132 --> 0:10:00,234
实际上不是

144
00:09:59,132 --> 0:10:00,234
实际上不是

145
00:10:00,968 --> 0:10:03,570
这是布局系统正在做它应该做的事

146
00:10:04,805 --> 0:10:10,644
认出框架不是SwiftUI中的

147
00:10:11,311 --> 0:10:12,412
它只是个视图

148
00:10:12,479 --> 0:10:14,982
你可以把它看作是一个图片框架

149
00:10:16,450 --> 0:10:21,889
它给它的子视图推荐固定尺寸

150
00:10:21,955 --> 0:10:24,925
子视图最终会选择自己的尺寸

151
00:10:26,126 --> 0:10:32,299
从这层意义上来说 SwiftUI

152
00:10:33,567 --> 0:10:37,304
好处是

153
00:10:37,371 --> 0:10:42,276
或超出约束的系统

154
00:10:42,342 --> 0:10:43,744
都拥有一个定义良好的效果

155
00:10:45,078 --> 0:10:48,081
那么完全没有什么不正确的布局

156
00:10:48,715 --> 0:10:50,317
除非你不喜欢你所得到的结果

157
00:10:52,486 --> 0:10:55,455
好的 现在我们了解了一些基础信息

158
00:10:56,089 --> 0:10:58,926
让我们讨论一下强大的工具 堆栈

159
00:11:00,494 --> 0:11:06,400
现在HStack和VStack

160
00:11:06,466 --> 0:11:07,668
分别以行或列安排它们的子视图

161
00:11:08,635 --> 0:11:11,538
我把这个列表网格和四个堆栈

162
00:11:11,605 --> 0:11:13,106
只需要几行代码就能实现

163
00:11:14,641 --> 0:11:15,943
这是那个布局的代码

164
00:11:17,110 --> 0:11:22,015
顶层是HStack有两个子视图

165
00:11:22,282 --> 0:11:26,253
第一个是VStack约束星形评级

166
00:11:28,856 --> 0:11:34,795
另一个子视图还是一个VStack

167
00:11:36,330 --> 0:11:39,299
其中第一个子视图

168
00:11:40,067 --> 0:11:46,240
约束标题、有弹性的间隔器

169
00:11:48,809 --> 0:11:51,211
好了 四个堆栈

170
00:11:51,879 --> 0:11:52,980
让我们把它们重新放到一起

171
00:12:01,555 --> 0:12:05,926
我希望你注意到

172
00:12:05,993 --> 0:12:06,994
把堆栈的子视图都堆砌在一起

173
00:12:07,361 --> 0:12:12,499
它在两个子视图之间留出了一些空间

174
00:12:13,800 --> 0:12:17,304
你还会发现的邻近文本的

175
00:12:17,938 --> 0:12:23,010
与Apple的人性化界面指南

176
00:12:24,111 --> 0:12:26,413
而基线到边界的空间也一样

177
00:12:26,947 --> 0:12:30,951
因为我们把这些规则加密到了

178
00:12:32,519 --> 0:12:37,357
这里的一般规则是最简单、

179
00:12:37,558 --> 0:12:41,028
也可以产生漂亮的结果

180
00:12:42,462 --> 0:12:48,702
但如果你需要控制

181
00:12:49,136 --> 0:12:52,272
它有旋钮 你可以打开或关闭

182
00:12:54,708 --> 0:12:59,313
哦 我几乎忘了

183
00:12:59,780 --> 0:13:04,985
若你的app定位在一个从右到左的

184
00:12:59,780 --> 0:13:04,985
若你的app定位在一个从右到左的

185
00:13:05,385 --> 0:13:06,854
并且你修改了系统语言

186
00:13:08,021 --> 0:13:11,091
SwiftUI会替你调整水平坐标

187
00:13:11,558 --> 0:13:13,293
因此你不需要重新编写布局

188
00:13:19,499 --> 0:13:24,104
如果你一直在思考 我们为什么说

189
00:13:24,338 --> 0:13:26,740
而不是left和right

190
00:13:27,307 --> 0:13:29,676
这样你的布局

191
00:13:29,743 --> 0:13:31,044
会自动国际化

192
00:13:32,713 --> 0:13:36,550
好的 让我们具体看看堆栈布局

193
00:13:37,584 --> 0:13:43,323
现在 我们目前所看到的

194
00:13:43,390 --> 0:13:44,391
实际上都是子视图的直链

195
00:13:44,658 --> 0:13:46,326
但堆栈很有意思

196
00:13:46,660 --> 0:13:50,931
因为子视图必须平等竞争一个空间

197
00:13:52,165 --> 0:13:58,839
在这个堆栈中 我们已经说过

198
00:14:00,541 --> 0:14:05,812
意思是如果堆栈被要求适应

199
00:14:07,581 --> 0:14:09,950
嗯 文本将被缩短以适应它

200
00:14:11,151 --> 0:14:14,621
但让我们从父视图

201
00:14:14,688 --> 0:14:16,957
提供了足够空间的情况开始看好吗？

202
00:14:18,158 --> 0:14:22,529
首先堆栈要计算出内部空间需求

203
00:14:23,397 --> 0:14:30,070
并从建议宽度中提取那个信息

204
00:14:30,404 --> 0:14:34,241
现在我们有三个子视图

205
00:14:36,210 --> 0:14:41,315
因此我们决定把空间平均分成三等份

206
00:14:41,548 --> 0:14:45,986
然后我们提议把其中一份作为

207
00:14:47,187 --> 0:14:50,224
现在 我们说过图片是固定尺寸

208
00:14:50,591 --> 0:14:53,060
那它就是最不灵活的那个

209
00:14:54,595 --> 0:15:01,401
那么图片占据了这么多空间

210
00:14:54,595 --> 0:15:01,401
那么图片占据了这么多空间

211
00:15:01,735 --> 0:15:05,205
我们把那个尺寸从未分配空间中扣除

212
00:15:07,107 --> 0:15:08,108
并重复这个过程

213
00:15:08,709 --> 0:15:14,147
好的 我们现在有两个

214
00:15:14,214 --> 0:15:19,152
因此我们把余下的空间分成两份

215
00:15:19,219 --> 0:15:20,921
没有尺寸的较不灵活的子视图

216
00:15:22,489 --> 0:15:27,261
Delicious占了这么多空间

217
00:15:27,694 --> 0:15:28,695
记住这一点

218
00:15:30,364 --> 0:15:34,134
把它从未分配空间中扣除

219
00:15:34,668 --> 0:15:39,206
给Avocado Toast

220
00:15:39,640 --> 0:15:41,008
你可以看到 空间充足

221
00:15:42,576 --> 0:15:44,378
好的 最后一步

222
00:15:46,380 --> 0:15:49,249
现在所有子视图都有尺寸了

223
00:15:50,184 --> 0:15:53,754
堆栈通过之前的间隔

224
00:15:54,922 --> 0:15:57,658
因为代码没有指定对齐方式

225
00:15:58,125 --> 0:16:00,060
默认生效的是居中对齐

226
00:15:58,125 --> 0:16:00,060
默认生效的是居中对齐

227
00:16:00,861 --> 0:16:04,665
因此堆栈使用居中对齐

228
00:16:04,731 --> 0:16:05,999
把所有子视图垂直地居中显示

229
00:16:07,768 --> 0:16:13,240
最后堆栈选择自己的尺寸

230
00:16:15,075 --> 0:16:18,846
现在如果你思考一下 你可能会想

231
00:16:18,912 --> 0:16:22,349
为什么文本的边界不会超出

232
00:16:23,584 --> 0:16:28,488
请看 如果Delicious

233
00:16:28,555 --> 0:16:31,859
减少为Avocado Toast

234
00:16:32,292 --> 0:16:37,097
尽管事实是一切都要合适

235
00:16:38,765 --> 0:16:41,201
实际上 相对于这里的两段文本

236
00:16:41,602 --> 0:16:44,938
Avocado Toast

237
00:16:45,172 --> 0:16:46,173
它是主题

238
00:16:46,907 --> 0:16:49,810
Delicious只是个附属

239
00:16:51,979 --> 0:16:53,380
因此这并不是个好结果

240
00:16:54,481 --> 0:16:59,219
但现在我想了一下

241
00:16:59,286 --> 0:17:02,856
所提供的空间比理想空间小

242
00:16:59,286 --> 0:17:02,856
所提供的空间比理想空间小

243
00:17:03,524 --> 0:17:08,095
我们之前见过的截短行为很可能

244
00:17:09,530 --> 0:17:11,365
如果提供这么窄的空间

245
00:17:11,431 --> 0:17:13,733
我们宁愿保留主题完整

246
00:17:14,101 --> 0:17:16,770
并截短附属物

247
00:17:18,571 --> 0:17:20,907
好的 为此我们有另一个

248
00:17:21,508 --> 0:17:27,146
我们把Avocado Toast

249
00:17:27,580 --> 0:17:28,582
提高到一

250
00:17:34,922 --> 0:17:38,225
因此当堆栈中的子视图

251
00:17:38,592 --> 0:17:41,228
堆栈获取未分配的空间

252
00:17:41,995 --> 0:17:46,600
它给所有优先级较低的子视图

253
00:17:47,067 --> 0:17:51,438
然后把其余空间分配给

254
00:17:52,973 --> 0:17:55,676
在这个例子中只有一个是最高优先级

255
00:17:57,878 --> 0:18:01,048
并且会给它提供全部可用空间

256
00:17:57,878 --> 0:18:01,048
并且会给它提供全部可用空间

257
00:18:01,381 --> 0:18:06,486
扣除图片宽度

258
00:18:06,553 --> 0:18:09,456
和把Delicious缩减到

259
00:18:11,091 --> 0:18:16,029
好的 通过最高级布局优先级

260
00:18:16,096 --> 0:18:20,234
堆栈继续给下一个

261
00:18:20,467 --> 0:18:23,203
布局优先级最高的子视图

262
00:18:24,671 --> 0:18:28,609
好的 我还要给你们展示最后一个

263
00:18:30,010 --> 0:18:31,011
对齐

264
00:18:31,845 --> 0:18:37,484
现在我知道你对于我们能底边对齐

265
00:18:39,987 --> 0:18:41,722
那样看起来很不错 对吧？

266
00:18:42,990 --> 0:18:48,629
但请考虑一下

267
00:18:48,695 --> 0:18:49,863
改小时会怎么样

268
00:18:52,432 --> 0:18:55,169
嗯 我觉得还不错 但我知道什么？

269
00:18:55,769 --> 0:18:57,070
我只是个app开发人员

270
00:18:57,738 --> 0:19:02,242
我很确定我的UI设计师

271
00:18:57,738 --> 0:19:02,242
我很确定我的UI设计师

272
00:19:06,880 --> 0:19:08,749
是的 他会一直放大

273
00:19:08,815 --> 0:19:11,185
并开始像这样选择详细信息

274
00:19:12,252 --> 0:19:16,723
他会说 Bucky 首先你有

275
00:19:17,357 --> 0:19:20,127
然后图片的底边在下边

276
00:19:20,694 --> 0:19:24,831
然后Avocado Toast的

277
00:19:25,265 --> 0:19:28,402
没有一个对齐的 我是怎么教你的？

278
00:19:33,607 --> 0:19:36,743
幸运的是我们可以

279
00:19:37,878 --> 0:19:40,614
基于文本的排列工具始终是对齐

280
00:19:40,848 --> 0:19:43,617
比如上下对齐

281
00:19:45,552 --> 0:19:51,258
如果我们以文本的基线对齐文本

282
00:19:57,764 --> 0:19:58,832
那图片怎么办呢？

283
00:19:59,499 --> 0:20:04,671
请看 图片中没有文本

284
00:19:59,499 --> 0:20:04,671
请看 图片中没有文本

285
00:20:04,938 --> 0:20:07,808
并且最后一行文本基线的默认值

286
00:20:07,875 --> 0:20:12,613
正是视图的底边 那我就得到了

287
00:20:12,679 --> 0:20:14,014
Crusty要求我实现的效果

288
00:20:15,549 --> 0:20:22,356
哦 哦 再看一下

289
00:20:22,422 --> 0:20:26,627
我非常确定他会告诉我说

290
00:20:26,827 --> 0:20:29,530
距离底部还有87.4%的距离

291
00:20:31,365 --> 0:20:37,971
通过告诉SwiftUI 如何给

292
00:20:38,405 --> 0:20:41,775
按照它的其它对齐方式

293
00:20:42,809 --> 0:20:43,810
很酷 对吗？

294
00:20:48,815 --> 0:20:51,285
但我们还没有完全利用

295
00:20:52,085 --> 0:20:54,321
让我们返回到内嵌堆栈例子中

296
00:20:55,756 --> 0:21:01,562
假如我们想对齐这些星星

297
00:20:55,756 --> 0:21:01,562
假如我们想对齐这些星星

298
00:21:05,432 --> 0:21:11,104
现在请记住 讨论中的文本

299
00:21:11,371 --> 0:21:12,573
嵌在视图等级的两个不同的分支中

300
00:21:14,875 --> 0:21:19,346
那么 嗯 居中对齐

301
00:21:19,413 --> 0:21:23,951
并不会切割它

302
00:21:24,017 --> 0:21:25,586
那么我们已经快搞定了

303
00:21:25,652 --> 0:21:27,521
你可以看到那些子视图已经对齐了

304
00:21:28,222 --> 0:21:34,962
不 我们要的对齐方式

305
00:21:35,028 --> 0:21:36,830
标记星星的中间位置

306
00:21:38,298 --> 0:21:42,903
我们需要定义自己的对齐方式

307
00:21:43,504 --> 0:21:47,708
只需要六行代码就能实现

308
00:21:49,610 --> 0:21:54,515
首先我们定义遵循对齐ID的枚举

309
00:21:55,148 --> 0:21:56,917
有一个要求

310
00:21:57,851 --> 0:22:00,921
告诉SwiftUI如何计算默认值

311
00:21:57,851 --> 0:22:00,921
告诉SwiftUI如何计算默认值

312
00:22:03,757 --> 0:22:07,995
现在在这个例子中

313
00:22:08,061 --> 0:22:11,565
因为默认值不会超出那些内部的堆栈

314
00:22:12,099 --> 0:22:17,337
但我把这个默认定义为底部

315
00:22:17,404 --> 0:22:23,310
它就像定义对齐指南修饰器一样

316
00:22:24,011 --> 0:22:28,715
最后我们定义垂直对齐的静态实体

317
00:22:29,283 --> 0:22:32,686
把枚举类型作为它的参数

318
00:22:35,455 --> 0:22:38,425
现在我们可以用它来对齐堆栈

319
00:22:40,093 --> 0:22:45,666
明确地把它设定到

320
00:22:48,769 --> 0:22:53,106
现在我们所设置的明确的对齐值

321
00:22:53,173 --> 0:22:57,778
穿过了所嵌入的堆栈的两个层

322
00:22:57,845 --> 0:22:58,846
对齐那些内部的部分

323
00:23:00,013 --> 0:23:01,348
那么这就是自定义对齐

324
00:23:07,754 --> 0:23:12,593
一个强大的工具

325
00:23:13,460 --> 0:23:17,664
现在我要邀请

326
00:23:17,731 --> 0:23:20,467
讲讲SwiftUI中的图形效果

327
00:23:25,806 --> 0:23:26,807
谢谢Dave

328
00:23:27,274 --> 0:23:30,844
是的 我要讲

329
00:23:30,911 --> 0:23:35,482
以及如何使用它们在app中

330
00:23:35,549 --> 0:23:36,550
创建交互性控制

331
00:23:38,085 --> 0:23:41,421
这是我们想要创建的效果的示例

332
00:23:41,655 --> 0:23:45,826
你之前见过 但只是几个普通的控制

333
00:23:45,893 --> 0:23:50,931
然后在中间有这个大戒指的图形

334
00:23:51,131 --> 0:23:52,366
底部是一个条形图

335
00:23:52,432 --> 0:23:56,537
如果你想在app中实现这种效果

336
00:23:56,603 --> 0:24:00,207
你必须深入到图形系统内部

337
00:23:56,603 --> 0:24:00,207
你必须深入到图形系统内部

338
00:24:02,209 --> 0:24:05,612
我们认为在SwiftUI中

339
00:24:05,679 --> 0:24:09,283
我们先看个小例子

340
00:24:09,349 --> 0:24:12,286
但在我们做任何复杂的操作之前

341
00:24:13,020 --> 0:24:15,756
如果我们想绘制一个红色圆圈

342
00:24:16,123 --> 0:24:17,925
嗯 我们首先要创建一个

343
00:24:17,991 --> 0:24:19,560
因为我们知道所有一切都是视图

344
00:24:20,294 --> 0:24:23,497
然后我们要把像这样的东西放进去

345
00:24:23,564 --> 0:24:27,901
如果给我一个图形和颜色

346
00:24:27,968 --> 0:24:30,137
屏幕上有一个红色的圆圈了

347
00:24:31,772 --> 0:24:34,441
但这里有个非常有意思的事

348
00:24:34,508 --> 0:24:38,378
那是因为我们依赖于布局系统来实现

349
00:24:38,445 --> 0:24:41,682
就是Dave讲的那些

350
00:24:41,748 --> 0:24:43,450
即使我们就在这个绘图模型中

351
00:24:44,451 --> 0:24:51,158
那么图形会反应给布局系统

352
00:24:51,225 --> 0:24:54,561
事实上 现在我们的绘图核心

353
00:24:54,628 --> 0:24:58,198
实际上只是视图 然后那其实意味着

354
00:24:58,265 --> 0:25:01,001
因为SwiftUI中的

355
00:24:58,265 --> 0:25:01,001
因为SwiftUI中的

356
00:25:01,335 --> 0:25:05,506
因此你所看到的全部修饰器

357
00:25:05,572 --> 0:25:09,610
一切的一切所适用的绘图方式

358
00:25:10,110 --> 0:25:13,914
但类似地 我们添加了大量的

359
00:25:14,147 --> 0:25:16,750
专用于图形绘制 比如模糊和阴影

360
00:25:17,551 --> 0:25:21,321
但因为绘制的图形只是个视图

361
00:25:21,388 --> 0:25:22,589
以及图形视图

362
00:25:23,423 --> 0:25:27,394
因此 我们认为这种统一的常规控制

363
00:25:27,461 --> 0:25:30,063
会随着我们的进步变得非常强大

364
00:25:31,331 --> 0:25:33,700
好的 但让我们具体看一下

365
00:25:34,301 --> 0:25:39,706
基础模型是有一个形状和一个样式、

366
00:25:39,907 --> 0:25:42,209
其中两者的结合产生一个视图

367
00:25:42,943 --> 0:25:47,414
我们在这里有一些形状

368
00:25:47,481 --> 0:25:48,482
并得到一个红色圆圈

369
00:25:49,416 --> 0:25:52,386
但同时我们可以使用不同的操作

370
00:25:52,452 --> 0:25:55,122
和胶囊 比如用红色描绘

371
00:25:55,556 --> 0:25:57,357
在那种情况下

372
00:25:57,424 --> 0:25:59,226
我们填充的是形状的轮廓

373
00:26:00,794 --> 0:26:04,264
但这就是我们经常想要得到的

374
00:26:04,331 --> 0:26:08,068
稍微有些不同的描绘 因此我们还可

375
00:26:08,135 --> 0:26:10,237
而不是描绘形状

376
00:26:10,637 --> 0:26:11,638
这只是个变体

377
00:26:13,173 --> 0:26:16,009
这也表示所有这些描绘操作

378
00:26:16,076 --> 0:26:19,947
都可以要么像第一个例子一样

379
00:26:20,013 --> 0:26:23,617
要么都是标准的描绘参数 比如

380
00:26:23,684 --> 0:26:26,887
破折号和终止符以及线段连接符

381
00:26:28,522 --> 0:26:31,058
好的 那么我们已经了解了图形

382
00:26:31,592 --> 0:26:33,393
但在这一点上 我们只使用了颜色

383
00:26:34,127 --> 0:26:36,763
但其实还有其它

384
00:26:37,264 --> 0:26:41,068
我们可以使用拼接图片

385
00:26:42,703 --> 0:26:43,804
来填充图形

386
00:26:44,805 --> 0:26:47,107
这是一个使用渐变色的例子

387
00:26:47,474 --> 0:26:51,545
所有渐变色样式都使用了这个

388
00:26:51,778 --> 0:26:54,014
它只提供了一维的颜色梯度

389
00:26:54,448 --> 0:26:56,783
在这个例子中

390
00:26:56,850 --> 0:26:59,052
它将平均地把它们排列到连续线上

391
00:26:59,253 --> 0:27:00,721
正好为我们提供了梯度

392
00:26:59,253 --> 0:27:00,721
正好为我们提供了梯度

393
00:27:01,255 --> 0:27:04,258
一旦完成 我们可以选择

394
00:27:04,324 --> 0:27:06,727
在这个例子中 我们要使用角渐变

395
00:27:07,261 --> 0:27:10,564
我们为它提供颜色梯度 然后我们

396
00:27:10,631 --> 0:27:13,300
我们为它提供中心点以及起始角

397
00:27:13,734 --> 0:27:17,905
然后它就会在那个圆圈周围填充颜色

398
00:27:17,971 --> 0:27:22,743
并把它们推到无穷以提供颜色填充

399
00:27:23,243 --> 0:27:27,347
但很明显 我们可使用刚做好的样式

400
00:27:27,714 --> 0:27:29,550
在这个例子中 执行填充

401
00:27:29,616 --> 0:27:31,084
现在我们拥有这个颜色漂亮的轮子

402
00:27:31,151 --> 0:27:32,519
而不是红色圆圈

403
00:27:33,520 --> 0:27:37,124
但当然了 填充只是其中一个操作

404
00:27:37,191 --> 0:27:39,359
同样地 我们刚才也只提到描绘边框

405
00:27:47,734 --> 0:27:51,638
好的 这就是基础信息

406
00:27:52,039 --> 0:27:54,274
但现在我们想继续

407
00:27:54,341 --> 0:27:56,476
创建更复杂的东西 多个视图

408
00:27:57,277 --> 0:27:59,680
这是我们要在接下来的演讲中

409
00:27:59,746 --> 0:28:02,149
它其实是一段时期代码

410
00:27:59,746 --> 0:28:02,149
它其实是一段时期代码

411
00:28:02,349 --> 0:28:04,952
并且它是个交互性的饼图

412
00:28:05,886 --> 0:28:08,822
它由一群颜色楔形构成

413
00:28:08,889 --> 0:28:10,824
它们可以动态出入

414
00:28:12,292 --> 0:28:16,964
好的 在我们了解如何绘制它之前

415
00:28:17,564 --> 0:28:22,569
我们的示例app给我们提供了一个

416
00:28:22,636 --> 0:28:26,106
它只是个卡扣 代表其中一个楔形

417
00:28:26,740 --> 0:28:30,310
并且每个楔形都包含代表

418
00:28:30,377 --> 0:28:31,845
一些属性

419
00:28:32,346 --> 0:28:35,649
然后我们有一大堆楔形

420
00:28:35,716 --> 0:28:38,952
最后是一组ID

421
00:28:39,019 --> 0:28:40,020
把它们绘制进去

422
00:28:40,454 --> 0:28:42,689
现在我们可以继续并考虑如何绘制了

423
00:28:44,691 --> 0:28:48,228
正如我们之前所看到的

424
00:28:48,695 --> 0:28:52,699
因此我们要假设整个整个控制

425
00:28:53,700 --> 0:28:56,670
因为我们希望它能重新调整尺寸

426
00:28:57,337 --> 0:28:59,840
如果你思考一下要如何实现

427
00:29:00,007 --> 0:29:02,643
我们可以分别绘制

428
00:29:02,910 --> 0:29:05,312
只要它们适合同一个布局边界即可

429
00:29:05,379 --> 0:29:09,082
然后我们把它们组合到一起

430
00:29:10,317 --> 0:29:12,486
那其实意味着我们只需要

431
00:29:13,554 --> 0:29:16,990
我们之前看到过这样的东西了

432
00:29:17,057 --> 0:29:18,091
填充了一些渐变色

433
00:29:18,892 --> 0:29:20,594
在这个例子中 一个这样的图形

434
00:29:21,395 --> 0:29:25,265
但我们其实不想要这个在

435
00:29:25,332 --> 0:29:29,069
但那不是问题 我们可以继续

436
00:29:29,136 --> 0:29:30,137
并定义一个自定义图形

437
00:29:31,138 --> 0:29:34,041
自定义图形与自定义视图很相似

438
00:29:34,508 --> 0:29:36,944
是遵守协议的类型

439
00:29:37,411 --> 0:29:39,713
除了 在这个例子中

440
00:29:39,780 --> 0:29:41,248
我们使用图形协议

441
00:29:42,015 --> 0:29:43,917
形状协议有一个的要求

442
00:29:43,984 --> 0:29:45,886
就是路径和矩形函数

443
00:29:46,386 --> 0:29:48,922
你在这里看到的矩形是布局边界

444
00:29:49,323 --> 0:29:50,324
或引用框架 我猜是这样

445
00:29:50,724 --> 0:29:52,426
然后它会返回贝塞尔曲线路径

446
00:29:53,560 --> 0:29:57,064
因此对于自定义图形来说

447
00:29:57,130 --> 0:29:59,399
即楔形描述 包含几何图形

448
00:30:00,100 --> 0:30:02,936
此外 我们只需要创建一条空路径

449
00:30:03,003 --> 0:30:04,571
因为我们要在它里面放东西

450
00:30:05,539 --> 0:30:10,177
为了稍微简化这个过程

451
00:30:10,244 --> 0:30:14,681
它提取了我们要绘制的图形的

452
00:30:14,748 --> 0:30:16,016
只是为了隐藏正弦和余弦

453
00:30:16,083 --> 0:30:19,386
因为这是圆形 以及诸如此类的操作

454
00:30:19,720 --> 0:30:21,989
但它定义了某些变量

455
00:30:22,155 --> 0:30:25,259
我们接下来可以在这个函数中使用

456
00:30:26,727 --> 0:30:29,329
首先我们要添加一个内弧形

457
00:30:30,264 --> 0:30:34,134
然后在路径中添加一条线

458
00:30:35,035 --> 0:30:37,604
然后另一个弧线 在外侧

459
00:30:38,272 --> 0:30:41,308
最后 我们就可以告诉路径说

460
00:30:41,542 --> 0:30:44,344
那将会把终点和起点连接起来

461
00:30:44,745 --> 0:30:45,746
然后我们就画好形状了

462
00:30:47,648 --> 0:30:49,516
现在我们可以继续

463
00:30:50,017 --> 0:30:54,121
我们可以填充渐变色

464
00:30:54,788 --> 0:30:56,190
但我们还有一件事要做

465
00:30:56,723 --> 0:30:59,626
我们在动画中看到了

466
00:31:00,327 --> 0:31:02,229
如果我们只按原样使用图形

467
00:31:02,596 --> 0:31:05,832
SwiftUI没办法让它动起来

468
00:31:05,899 --> 0:31:06,900
因为它不了解足够多的类型

469
00:31:07,367 --> 0:31:10,871
因此我们可以继续并给我们的自定义

470
00:31:10,938 --> 0:31:12,306
叫做可动画数据

471
00:31:12,673 --> 0:31:16,610
这会提供一个矢量 包含浮点型数字

472
00:31:16,810 --> 0:31:19,346
是系统可以插入的矢量

473
00:31:20,013 --> 0:31:23,650
在这个例子中 我们要把这个责任

474
00:31:23,717 --> 0:31:26,253
因为它替我们实施这个属性

475
00:31:26,320 --> 0:31:28,856
但其实非常简单

476
00:31:28,922 --> 0:31:32,826
获取三个属性和楔形描述

477
00:31:32,893 --> 0:31:35,495
然后把它们结合到一个

478
00:31:37,064 --> 0:31:40,501
好的 现在我们的图形其实已完成

479
00:31:41,201 --> 0:31:44,505
我们可以退一步思考我们如何

480
00:31:45,973 --> 0:31:49,943
我们可以看到我们可以使用渐变色

481
00:31:50,143 --> 0:31:51,144
用它来填充我们的图形

482
00:31:51,812 --> 0:31:52,813
但这只是其中一个形状

483
00:31:52,880 --> 0:31:57,050
我们想要要八个形状

484
00:31:57,284 --> 0:32:02,022
我们可以通过一个

485
00:31:57,284 --> 0:32:02,022
我们可以通过一个

486
00:32:02,089 --> 0:32:05,359
类似Dave讲过的HStack和

487
00:32:05,425 --> 0:32:07,928
深度对应空间

488
00:32:08,862 --> 0:32:12,799
我们要创建另一个自定义视图

489
00:32:12,866 --> 0:32:14,201
将通过环境获取数据模型

490
00:32:14,268 --> 0:32:15,602
我们已经在其它地方设置好了

491
00:32:16,336 --> 0:32:17,971
我们要从创建Zstack开始

492
00:32:19,106 --> 0:32:24,044
现在我们看到在数据模型上

493
00:32:25,512 --> 0:32:29,483
因此我们可以在SwiftUI中

494
00:32:29,750 --> 0:32:34,087
那会映像到那组ID

495
00:32:34,321 --> 0:32:37,624
并为每一个我们想要创建的楔形

496
00:32:38,292 --> 0:32:40,327
这个楔形视图非常简单

497
00:32:40,394 --> 0:32:45,799
它其实只是一个陈述视图

498
00:32:45,866 --> 0:32:46,867
并填充渐变色

499
00:32:48,468 --> 0:32:50,370
好的 几乎要完成了

500
00:32:51,104 --> 0:32:53,440
由于SwiftUI

501
00:32:53,507 --> 0:32:55,876
当我们的数据模型更新时

502
00:32:55,943 --> 0:32:59,179
因为Zstack

503
00:32:59,346 --> 0:33:01,949
它们会干净利落地淡入和淡出

504
00:32:59,346 --> 0:33:01,949
它们会干净利落地淡入和淡出

505
00:33:02,216 --> 0:33:04,818
这对于这样一个app来说非常好

506
00:33:04,885 --> 0:33:06,854
但我们还要做一些其它的操作

507
00:33:07,654 --> 0:33:10,591
我们在动画中看到了

508
00:33:10,657 --> 0:33:11,725
删除它

509
00:33:13,126 --> 0:33:14,862
我们可以添加一个

510
00:33:15,095 --> 0:33:17,197
这是视图的一个事件处理器

511
00:33:17,497 --> 0:33:22,035
它表达的是如果你轻触

512
00:33:22,302 --> 0:33:26,406
在那种情况下

513
00:33:26,473 --> 0:33:29,142
然后请求数据模型说

514
00:33:29,743 --> 0:33:31,712
一旦我们完成

515
00:33:33,013 --> 0:33:34,982
现在我还要在这里做最后一个操作

516
00:33:35,182 --> 0:33:38,519
我说过默认转换是淡入淡出效果

517
00:33:38,785 --> 0:33:40,954
这对于许多东西来说都很不错

518
00:33:41,021 --> 0:33:44,725
我们想要实现更有趣的效果

519
00:33:44,791 --> 0:33:45,893
并淡出它们

520
00:33:46,627 --> 0:33:49,796
我们可以通过添加一个叫做

521
00:33:50,364 --> 0:33:52,466
这是需要我们自己创建的东西

522
00:33:53,767 --> 0:33:56,837
好的 思考一下这个转换是什么效果

523
00:33:57,337 --> 0:34:01,108
我们希望当添加视图时

524
00:33:57,337 --> 0:34:01,108
我们希望当添加视图时

525
00:34:01,175 --> 0:34:05,012
并淡出 以动画效果进入

526
00:34:05,412 --> 0:34:06,613
它们将进入并放大到常规状态

527
00:34:07,247 --> 0:34:08,415
然而它们位于视图等级中

528
00:34:08,482 --> 0:34:11,784
它们正好会坐落在那里

529
00:34:11,851 --> 0:34:13,320
最后当移除它们时

530
00:34:14,221 --> 0:34:17,324
如果你思考一下 很明显

531
00:34:17,391 --> 0:34:19,493
因为我们有动画系统

532
00:34:20,027 --> 0:34:23,463
因此我们只需要定义结束状态

533
00:34:23,530 --> 0:34:24,531
动画系统会替我们执行其余操作

534
00:34:25,199 --> 0:34:29,570
但当然了 在这个例子中

535
00:34:29,969 --> 0:34:31,605
因此我们实际上有两个结束状态

536
00:34:31,672 --> 0:34:36,109
我们设置了转换和移除状态

537
00:34:36,476 --> 0:34:39,179
并且我们有常规状态

538
00:34:40,614 --> 0:34:43,784
那么现在我们知道要定义哪个状态

539
00:34:44,784 --> 0:34:47,688
在SwiftUI中我们的实现方式

540
00:34:48,188 --> 0:34:50,924
现在视图修饰器有点像视图一样

541
00:34:50,991 --> 0:34:53,126
在视图修饰器中定义了一些视图等级

542
00:34:53,460 --> 0:34:56,362
但它是根据一些其它视图进行定义的

543
00:34:56,897 --> 0:35:00,000
这就是它所表达的东西

544
00:35:00,567 --> 0:35:03,604
它有主体方法

545
00:35:03,971 --> 0:35:06,840
但在这个例子中

546
00:35:06,907 --> 0:35:08,675
这就是内容参数

547
00:35:09,176 --> 0:35:13,413
在这里我们可以做的是把这个应用到

548
00:35:13,747 --> 0:35:16,450
在我们的例子中我们想要转换效果

549
00:35:16,817 --> 0:35:20,187
我们有两个转换状态

550
00:35:20,254 --> 0:35:21,588
比如转换是活跃的吗？

551
00:35:22,189 --> 0:35:26,960
当转换是活跃的时

552
00:35:27,394 --> 0:35:31,198
来修改即将进入的视图

553
00:35:31,265 --> 0:35:33,734
我们把那叫做按比例缩小

554
00:35:33,800 --> 0:35:36,770
并且当它设置妥了之后就让它淡出

555
00:35:38,305 --> 0:35:41,408
好的 这就是如何定义转换

556
00:35:41,475 --> 0:35:43,110
但我们还有最后一步

557
00:35:44,444 --> 0:35:47,714
我们现在有视图修饰器 但我们需要

558
00:35:47,781 --> 0:35:51,351
活跃值和不活跃值

559
00:35:51,718 --> 0:35:55,889
从而SwiftUI可以

560
00:35:56,089 --> 0:35:57,591
然后当添加或移除时

561
00:35:57,658 --> 0:36:01,028
选择正确的值在正确的时间应用

562
00:35:57,658 --> 0:36:01,028
选择正确的值在正确的时间应用

563
00:36:01,094 --> 0:36:02,529
然后在动画过程中

564
00:36:03,864 --> 0:36:06,033
这就是我们可以继续并使用的东西

565
00:36:06,633 --> 0:36:08,836
完成上述一切操作之后

566
00:36:09,036 --> 0:36:10,037
作为一个演示

567
00:36:11,538 --> 0:36:17,144
好的 你可以下载这个app

568
00:36:17,211 --> 0:36:18,412
那么这里是窗口

569
00:36:20,047 --> 0:36:22,115
目前是空的 因为数据模型是空的

570
00:36:22,549 --> 0:36:23,750
但我可以添加

571
00:36:24,518 --> 0:36:26,320
你可以看到它们正在采用

572
00:36:26,386 --> 0:36:28,755
它们按比例放大并淡入

573
00:36:29,289 --> 0:36:33,327
最棒的是我们可以轻触并移除它们

574
00:36:33,627 --> 0:36:36,797
正如你所看到的 当我从中间移除

575
00:36:36,864 --> 0:36:38,999
这是由于我们定义形状的方式

576
00:36:39,666 --> 0:36:41,835
然后我可以开启这里的背景动画

577
00:36:42,870 --> 0:36:46,106
然后在背景动画上运行着

578
00:36:46,507 --> 0:36:49,910
它随机穿行在参数空间中

579
00:36:51,411 --> 0:36:52,880
这是个很好的小app

580
00:36:53,213 --> 0:36:55,616
即使它是动态的

581
00:36:55,682 --> 0:36:58,619
测试是正确地运行

582
00:36:59,219 --> 0:37:03,457
有意思的是当你思考

583
00:36:59,219 --> 0:37:03,457
有意思的是当你思考

584
00:37:03,991 --> 0:37:07,528
SwiftUI会为出现在屏幕上的

585
00:37:07,594 --> 0:37:11,298
都创建一个原生的平台视图

586
00:37:11,832 --> 0:37:13,901
因此这与按钮类似

587
00:37:14,401 --> 0:37:18,005
一般来说 这就是我们想要的效果

588
00:37:18,071 --> 0:37:20,040
处理常规控件之类的东西

589
00:37:20,908 --> 0:37:25,045
但对于诸如所显示的这个图形

590
00:37:25,546 --> 0:37:29,216
如果你在UIKit或

591
00:37:29,283 --> 0:37:32,052
这很可能不是你会做的事

592
00:37:32,119 --> 0:37:34,321
为每一个元素都创建

593
00:37:34,621 --> 0:37:36,890
原因是

594
00:37:37,491 --> 0:37:39,293
性能可能会很差

595
00:37:39,359 --> 0:37:40,827
这并不是个问题

596
00:37:40,894 --> 0:37:43,230
因为我们并不打算

597
00:37:44,198 --> 0:37:46,466
我们在SwiftUI中有个方案

598
00:37:47,167 --> 0:37:50,871
就是我们可以把一切

599
00:37:51,905 --> 0:37:53,473
放在一个绘制小组内

600
00:37:54,341 --> 0:37:56,543
绘制小组是一种特殊的渲染方式

601
00:37:56,877 --> 0:37:58,312
仅适用于诸如图形这样的元素

602
00:37:58,545 --> 0:38:00,814
那么图形和文本和图片 类似这样的

603
00:37:58,545 --> 0:38:00,814
那么图形和文本和图片 类似这样的

604
00:38:01,348 --> 0:38:04,985
当我们这么做之后 我们实际上

605
00:38:05,052 --> 0:38:09,056
扁平化到NSViewer UI视图中

606
00:38:09,523 --> 0:38:12,125
因此当我开始这样做时

607
00:38:12,192 --> 0:38:14,695
因为它不是行为上的变化

608
00:38:15,329 --> 0:38:18,732
但一旦我开始增加元素的数量时

609
00:38:18,799 --> 0:38:20,300
性能变得更好了 因为…

610
00:38:28,208 --> 0:38:32,846
这仅仅是因为只有一个视图

611
00:38:33,046 --> 0:38:39,219
但所发生的绘制

612
00:38:40,821 --> 0:38:43,357
那么我想这就是全部内容了 很酷

613
00:38:55,636 --> 0:38:59,506
好的 在本场演讲中

614
00:38:59,573 --> 0:39:02,543
但我想指出其实还有更多修饰器

615
00:38:59,573 --> 0:39:02,543
但我想指出其实还有更多修饰器

616
00:39:02,910 --> 0:39:06,113
我们做了很多工作来实施

617
00:39:06,180 --> 0:39:07,681
你能在常规的2D绘图系统中

618
00:39:08,048 --> 0:39:10,484
正如我们所说的 它们都适用于视图

619
00:39:10,751 --> 0:39:14,354
因此如果这个 如果你需要

620
00:39:15,989 --> 0:39:20,027
我认为这真的清晰地讲明了

621
00:39:20,093 --> 0:39:26,166
并且我们想使用这些图形

622
00:39:26,233 --> 0:39:28,902
但是要与其余的API一起使用

623
00:39:28,969 --> 0:39:32,005
比如布局、动画和交互

624
00:39:32,072 --> 0:39:35,776
SwiftUI的主旨就是我们围绕

625
00:39:35,843 --> 0:39:40,147
在同样的程序包中我你提供一切功能

626
00:39:40,981 --> 0:39:44,651
我们认为这将非常强大

627
00:39:44,718 --> 0:39:46,053
你们即将把它带到哪里去

628
00:39:46,386 --> 0:39:47,387
谢谢大家

629
00:39:54,628 --> 0:39:55,929
我们今天还有一场演讲

630
00:39:55,996 --> 0:39:59,800
距离开始不到一小时了

631
00:39:59,867 --> 0:40:02,135
请参加我们的演讲 谢谢
