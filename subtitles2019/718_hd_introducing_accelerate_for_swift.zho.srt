1
00:00:06,974 --> 0:00:08,942
你好

2
00:00:09,009 --> 0:00:11,011
我是矢量和数字团队的一员

3
00:00:11,345 --> 0:00:14,515
在本次演讲中

4
00:00:14,581 --> 0:00:17,718
第一是我们为Accelerate

5
00:00:17,784 --> 0:00:20,320
第二个是使用LINPACK

6
00:00:20,387 --> 0:00:22,122
的性能表现

7
00:00:22,189 --> 0:00:24,224
在我们深入了解

8
00:00:24,291 --> 0:00:28,028
我们来确切地回顾一下

9
00:00:29,229 --> 0:00:31,098
Accelerate的主要使用

10
00:00:31,164 --> 0:00:34,034
目的是提供许多

11
00:00:34,101 --> 0:00:37,704
它在CPU上运行

12
00:00:37,771 --> 0:00:41,375
向量运算 线性代数

13
00:00:41,808 --> 0:00:46,180
这些基元大多数是通过手动调整

14
00:00:46,246 --> 0:00:48,715
这意味着我们获取了极佳的性能表现

15
00:00:48,782 --> 0:00:53,053
这个性能表现会直接转变为节能

16
00:00:53,620 --> 0:00:54,888
那么 如果你是一个app开发者

17
00:00:54,955 --> 0:00:56,757
使用Accelerate框架

18
00:00:56,823 --> 0:00:59,393
不仅会让你的app运行更快

19
00:00:59,459 --> 0:01:02,062
你的电池寿命也会更长

20
00:00:59,459 --> 0:01:02,062
你的电池寿命也会更长

21
00:01:03,497 --> 0:01:07,000
我们提供的基元能

22
00:01:07,067 --> 0:01:11,305
这不只包含macOS和iOS

23
00:01:11,371 --> 0:01:15,075
也同样支持

24
00:01:15,742 --> 0:01:20,080
这意味着你的用户能

25
00:01:21,582 --> 0:01:23,951
Accelerate库非常强大

26
00:01:24,017 --> 0:01:24,952
但到现在为止

27
00:01:25,018 --> 0:01:28,355
它们的用户界面对

28
00:01:28,822 --> 0:01:30,190
我们来看一下四个库

29
00:01:30,257 --> 0:01:32,693
以及新创建的对

30
00:01:32,759 --> 0:01:36,096
来使得在Swift项目中使用

31
00:01:36,496 --> 0:01:39,099
关于这四个库 我们将主要关注：

32
00:01:39,433 --> 0:01:42,970
vDSP提供的

33
00:01:43,036 --> 0:01:46,773
包括对大向量的运算

34
00:01:46,840 --> 0:01:50,110
双二次过滤

35
00:01:51,278 --> 0:01:54,882
vForce提供的运算和超越函数

36
00:01:54,948 --> 0:01:58,118
包括三角和对数运算

37
00:01:58,785 --> 0:02:03,123
正交提供的函数的数值积分

38
00:01:58,785 --> 0:02:03,123
正交提供的函数的数值积分

39
00:02:03,891 --> 0:02:07,961
vImage提供了一个多种类

40
00:02:08,027 --> 0:02:11,131
它已被集成至Core Graphics

41
00:02:12,232 --> 0:02:16,136
Accelerate通过向量化

42
00:02:17,304 --> 0:02:18,839
为了了解向量化

43
00:02:18,906 --> 0:02:21,074
我们首先来看一下一个简单的运算

44
00:02:21,141 --> 0:02:24,144
在一个数组的元素中使用标量的代码

45
00:02:24,745 --> 0:02:26,914
如果 比如你写的代码

46
00:02:26,980 --> 0:02:31,952
一个数组中的每个元素和

47
00:02:32,019 --> 0:02:33,854
你使用了一个for循环

48
00:02:33,921 --> 0:02:36,123
每对元素都被分散地加载

49
00:02:36,190 --> 0:02:39,159
相互相乘

50
00:02:39,526 --> 0:02:42,829
那么 当a和b中的第一个元素

51
00:02:42,896 --> 0:02:45,332
成为c的第一个元素

52
00:02:45,399 --> 0:02:47,167
第二对被处理了

53
00:02:48,068 --> 0:02:49,169
接着 是第三对

54
00:02:49,970 --> 0:02:52,172
以及 最后是第四对

55
00:02:55,042 --> 0:02:57,411
不过 如果你在

56
00:02:57,477 --> 0:02:58,612
使用Accelerate

57
00:02:58,679 --> 0:03:02,449
你的运算会在

58
00:02:58,679 --> 0:03:02,449
你的运算会在

59
00:03:02,516 --> 0:03:04,184
或simD寄存器

60
00:03:04,651 --> 0:03:06,820
这些寄存器能

61
00:03:06,887 --> 0:03:08,689
在多个数据项中执行相同的指令

62
00:03:08,755 --> 0:03:11,792
通过将多个这些物件打包成

63
00:03:12,125 --> 0:03:15,462
比如一个单个128位的寄存器

64
00:03:15,529 --> 0:03:19,833
实际上能存储

65
00:03:19,900 --> 0:03:21,768
所以 一个矢量乘法操作

66
00:03:21,835 --> 0:03:25,706
能同时相乘4对元素

67
00:03:26,306 --> 0:03:29,042
这意味着这个任务不仅会被加速执行

68
00:03:29,109 --> 0:03:32,212
它也会更显著地节能

69
00:03:34,581 --> 0:03:36,316
我们刚才看到的乘法函数

70
00:03:36,383 --> 0:03:40,721
是Accelerate的数字

71
00:03:40,787 --> 0:03:43,690
那么 我们从新的Swift

72
00:03:43,757 --> 0:03:46,260
使用vDSP简化使用方式来开始吧

73
00:03:48,529 --> 0:03:52,466
vDSP提供了矢量化数字

74
00:03:52,533 --> 0:03:54,601
包括傅里叶变换

75
00:03:54,935 --> 0:03:56,570
双二次过滤

76
00:03:56,937 --> 0:03:59,239
卷积和相关

77
00:03:59,740 --> 0:04:04,011
更进一步 vDSP也提供了

78
00:03:59,740 --> 0:04:04,011
更进一步 vDSP也提供了

79
00:04:04,077 --> 0:04:08,248
包括元素级算术和类型转换

80
00:04:09,082 --> 0:04:11,652
所以 即使你还没有一个迫切需求

81
00:04:11,718 --> 0:04:14,621
比如计算两个信号之间的连贯性

82
00:04:14,688 --> 0:04:18,524
你可能会发现

83
00:04:18,591 --> 0:04:21,862
为你app的性能表现

84
00:04:24,665 --> 0:04:27,301
我们来看看一些基本的运算

85
00:04:27,367 --> 0:04:28,869
一个例子：

86
00:04:28,936 --> 0:04:31,972
已知4个单精度值的数组

87
00:04:32,039 --> 0:04:33,006
你需要计算

88
00:04:33,073 --> 0:04:35,275
数组的二乘二的元素和

89
00:04:35,642 --> 0:04:37,711
其他两个的各个元素都不同

90
00:04:37,778 --> 0:04:40,280
使用一个for循环

91
00:04:41,682 --> 0:04:42,549
来互乘这些结果

92
00:04:42,616 --> 0:04:45,185
是这个问题的一个非常合理的选择

93
00:04:45,252 --> 0:04:47,621
以及计算这些预期结果

94
00:04:48,422 --> 0:04:53,060
这是你如何使用vDSP

95
00:04:53,560 --> 0:04:58,298
使用vDSP大约比for

96
00:04:59,566 --> 0:05:03,937
这是使用我们新的为vDSP

97
00:04:59,566 --> 0:05:03,937
这是使用我们新的为vDSP

98
00:05:04,438 --> 0:05:06,773
我们暴露了

99
00:05:06,840 --> 0:05:08,609
通过我们的vDSP的命名空间

100
00:05:08,675 --> 0:05:12,312
你能看到函数和

101
00:05:12,946 --> 0:05:15,115
因为新的函数使用了相似的类型

102
00:05:15,182 --> 0:05:18,151
包括数组和数组分片

103
00:05:18,218 --> 0:05:21,088
你不再需要明确地传递数值

104
00:05:21,255 --> 0:05:25,325
所以整个函数调用更直观

105
00:05:27,027 --> 0:05:28,996
传递一个初始化结果数组

106
00:05:29,062 --> 0:05:30,731
提供了最好的性能表现

107
00:05:30,797 --> 0:05:33,934
为了进一步的性能提升

108
00:05:34,001 --> 0:05:36,336
重复使用那个数组

109
00:05:37,137 --> 0:05:41,074
不过 我们也提供了

110
00:05:41,141 --> 0:05:46,180
这些利用了Swift新的功能

111
00:05:46,246 --> 0:05:48,682
返回运算的结果

112
00:05:49,183 --> 0:05:52,219
虽然没有传递

113
00:05:52,286 --> 0:05:54,421
它还是比标量方式要快的

114
00:05:54,488 --> 0:05:57,891
以及 在一些使用场景

115
00:06:00,194 --> 0:06:02,796
另一个常见的任务是

116
00:06:02,863 --> 0:06:04,498
是类型转换

117
00:06:04,565 --> 0:06:08,335
这个例子将一个具有双精度值

118
00:06:08,402 --> 0:06:12,940
16位的无符号整数的值

119
00:06:14,875 --> 0:06:18,378
标量版本使用了显式四舍五入映射

120
00:06:18,445 --> 0:06:21,682
再一次 这是一个

121
00:06:21,748 --> 0:06:25,786
但vDSP能矢量化这个任务来

122
00:06:27,254 --> 0:06:28,222
在这个例子中

123
00:06:28,288 --> 0:06:34,061
vDSP大约比之前的

124
00:06:35,996 --> 0:06:40,400
vDSP函数所在的新的Swift

125
00:06:40,634 --> 0:06:42,903
这个函数获取一个源函数

126
00:06:42,970 --> 0:06:45,806
你应该将每个元素转换成整型

127
00:06:45,873 --> 0:06:48,408
和一个枚举来指定rounding

128
00:06:51,979 --> 0:06:54,381
vDSP提供了傅里叶变换

129
00:06:54,448 --> 0:06:57,651
在时域和频域之间

130
00:06:57,718 --> 0:07:00,187
将一维数据转换至二维数据

131
00:06:57,718 --> 0:07:00,187
将一维数据转换至二维数据

132
00:07:01,588 --> 0:07:03,891
一个信号的正向傅里叶变换

133
00:07:03,957 --> 0:07:06,860
分解它成为它的组件的信号波

134
00:07:06,927 --> 0:07:09,429
那就是频域所代表的

135
00:07:10,030 --> 0:07:14,134
相反地 一个频域所展现的逆变换

136
00:07:14,201 --> 0:07:16,036
重建了原始信号

137
00:07:16,103 --> 0:07:18,438
那是时域所展现的

138
00:07:19,273 --> 0:07:23,377
傅里叶变换在信号和

139
00:07:23,443 --> 0:07:27,114
比如只要一个音频信号被正向转换了

140
00:07:27,181 --> 0:07:31,919
你可以很容易的减小或

141
00:07:33,253 --> 0:07:35,689
经典的API是易于理解的

142
00:07:35,756 --> 0:07:37,124
如果你对它熟悉

143
00:07:37,191 --> 0:07:39,293
你从创建设置对象开始

144
00:07:39,359 --> 0:07:43,096
指定元素的数量

145
00:07:43,430 --> 0:07:46,466
接着

146
00:07:46,533 --> 0:07:48,368
你调用执行函数

147
00:07:48,435 --> 0:07:50,904
只要你在结束之后

148
00:07:50,971 --> 0:07:53,473
来释放为它分配的资源

149
00:07:54,808 --> 0:07:58,946
新的API简化了设置对象的实例化

150
00:07:59,413 --> 0:08:02,583
转换本身是一个带有

151
00:07:59,413 --> 0:08:02,583
转换本身是一个带有

152
00:08:02,649 --> 0:08:04,484
DFT实例参数名字的方法

153
00:08:04,551 --> 0:08:07,588
现在 你不需要担心释放资源

154
00:08:07,654 --> 0:08:09,122
我们会为你实现

155
00:08:11,024 --> 0:08:13,794
就像我们看到的vDSP函数

156
00:08:13,861 --> 0:08:16,997
它有一个自调度版本的转换函数

157
00:08:17,064 --> 0:08:20,501
它为你创建和返回返回值的数组

158
00:08:24,004 --> 0:08:25,506
如果你使用音频数据

159
00:08:25,572 --> 0:08:29,243
你可能会熟悉双二次或

160
00:08:29,643 --> 0:08:32,044
双二阶滤波器能用来平衡音频

161
00:08:32,111 --> 0:08:33,746
来形成频率响应

162
00:08:33,813 --> 0:08:38,519
比如 它允许你能

163
00:08:39,720 --> 0:08:41,421
vDSP的双二阶功能

164
00:08:41,488 --> 0:08:44,458
处理单个或多声道信号

165
00:08:44,525 --> 0:08:46,793
使用一组单个过滤器

166
00:08:46,860 --> 0:08:48,262
叫做sections的对象

167
00:08:48,328 --> 0:08:49,696
过滤器是级联的

168
00:08:49,763 --> 0:08:51,832
就是说它们是按顺序排列的

169
00:08:51,899 --> 0:08:55,536
整个信号依次通过每个过滤器

170
00:08:56,003 --> 0:08:58,605
过滤器被定义为一系列系数

171
00:08:58,672 --> 0:09:00,541
它会被代入这里的这个方程中

172
00:08:58,672 --> 0:09:00,541
它会被代入这里的这个方程中

173
00:09:03,544 --> 0:09:06,713
在这里例子中

174
00:09:06,780 --> 0:09:09,683
就是说

175
00:09:09,750 --> 0:09:12,853
这是使用vDSP经典的API代码

176
00:09:12,920 --> 0:09:14,321
来创建双二阶设置

177
00:09:14,388 --> 0:09:17,057
使用之前的幻灯片的系数

178
00:09:18,091 --> 0:09:18,959
这里是

179
00:09:19,026 --> 0:09:22,496
运用双二阶过滤器

180
00:09:22,563 --> 0:09:25,566
返回返回值到一个

181
00:09:26,099 --> 0:09:30,170
我们来看一下使用一个

182
00:09:32,072 --> 0:09:33,240
如你所见

183
00:09:33,307 --> 0:09:37,244
新的API大大地简化了

184
00:09:37,644 --> 0:09:40,781
你很容易地传递

185
00:09:40,848 --> 0:09:43,584
指定频道的数量和部分

186
00:09:45,018 --> 0:09:48,589
将双二阶过滤器运用到一个信号

187
00:09:52,693 --> 0:09:55,996
现在我们来看一下新的API

188
00:09:56,063 --> 0:10:00,601
和对大的数组

189
00:09:56,063 --> 0:10:00,601
和对大的数组

190
00:10:01,969 --> 0:10:06,273
vForce提供了vDSP

191
00:10:06,540 --> 0:10:10,611
这些包括指数 对数和三角操作

192
00:10:12,279 --> 0:10:13,981
一个vForce的典型的例子

193
00:10:14,047 --> 0:10:17,618
可能被用来计算一个大数组中

194
00:10:18,018 --> 0:10:20,621
这段代码的标量版本可以使用映射

195
00:10:22,256 --> 0:10:26,393
vForce提供了一个矢量化函数

196
00:10:26,460 --> 0:10:29,563
在一些使用场合 它会

197
00:10:29,630 --> 0:10:31,632
比标量的实现快10倍以上

198
00:10:33,166 --> 0:10:34,501
新的Swift Overlay

199
00:10:34,568 --> 0:10:38,639
提供了一个和vDSP

200
00:10:38,705 --> 0:10:41,742
提供了向量化的性能表现

201
00:10:41,808 --> 0:10:43,243
和能源效率的好处

202
00:10:45,245 --> 0:10:46,613
就和我们早些时候看到的很类似

203
00:10:46,680 --> 0:10:49,783
这是一个自调度版本

204
00:10:49,850 --> 0:10:52,986
包含了提供的数组中

205
00:10:57,057 --> 0:11:01,161
接下来 我们来看看我们

206
00:10:57,057 --> 0:11:01,161
接下来 我们来看看我们

207
00:11:02,596 --> 0:11:06,667
正交是判定一条曲线下区域

208
00:11:07,367 --> 0:11:10,737
它提供了一个在有限或无限区间内

209
00:11:10,804 --> 0:11:13,674
近似明确的集成函数

210
00:11:14,274 --> 0:11:18,579
在示例中 我们会使用

211
00:11:18,645 --> 0:11:22,683
这里的绿色的部分

212
00:11:25,352 --> 0:11:27,855
很像vDSP的双二阶代码

213
00:11:27,921 --> 0:11:32,693
需要相当多的代码来使用

214
00:11:33,293 --> 0:11:38,198
第一步是定义一个

215
00:11:40,100 --> 0:11:42,936
第二步是定义集成选项

216
00:11:43,003 --> 0:11:45,239
包括集成算法

217
00:11:46,607 --> 0:11:49,643
最后

218
00:11:49,710 --> 0:11:53,714
你能使用正交积分函数来进行整合

219
00:11:56,416 --> 0:11:58,919
新的API简化了代码

220
00:11:58,986 --> 0:12:02,022
好处之一是你能指定被积函数

221
00:11:58,986 --> 0:12:02,022
好处之一是你能指定被积函数

222
00:12:02,089 --> 0:12:04,157
就是说 被集成的函数

223
00:12:04,224 --> 0:12:07,661
作为一个交易的闭包

224
00:12:07,728 --> 0:12:10,731
这意味着你能很容易的传值到

225
00:12:12,266 --> 0:12:16,670
你也要留意积分器现在

226
00:12:16,737 --> 0:12:20,007
所以每次间隔无需提供没有必要的点

227
00:12:20,073 --> 0:12:21,742
或是这里的最大间隔

228
00:12:23,143 --> 0:12:24,178
比如

229
00:12:24,244 --> 0:12:27,514
你可以传递枚举给全局自适应积分器

230
00:12:27,581 --> 0:12:31,318
为间隔和最大间隔指定点

231
00:12:35,155 --> 0:12:37,424
现在

232
00:12:37,491 --> 0:12:40,761
Accelerate图像处理库

233
00:12:41,929 --> 0:12:43,497
vImage是一个包含了

234
00:12:43,564 --> 0:12:46,333
丰富的图片处理工具集的库

235
00:12:46,667 --> 0:12:52,139
它被设计在Core Graphics

236
00:12:52,873 --> 0:12:55,776
它包含了比如阿尔法混合

237
00:12:56,510 --> 0:12:58,612
格式转换

238
00:12:58,679 --> 0:13:00,781
直方图操作

239
00:12:58,679 --> 0:13:00,781
直方图操作

240
00:13:00,848 --> 0:13:02,583
卷积

241
00:13:02,649 --> 0:13:04,017
几何学

242
00:13:04,084 --> 0:13:05,786
以及形态的操作

243
00:13:08,355 --> 0:13:11,391
我们新的Swift API

244
00:13:11,458 --> 0:13:15,562
来让大家在Swift中

245
00:13:15,629 --> 0:13:17,798
我们实现了一个选项集标记

246
00:13:18,232 --> 0:13:20,801
vImages

247
00:13:20,868 --> 0:13:23,370
我们隐藏了一些可变性的需求

248
00:13:23,437 --> 0:13:25,806
以及处理非托管类型

249
00:13:27,674 --> 0:13:29,810
如果你在使用

250
00:13:29,877 --> 0:13:31,011
这是一个常见的工作流

251
00:13:31,078 --> 0:13:33,814
来将图片数据传入到

252
00:13:35,115 --> 0:13:39,453
首先 你需要创建一个

253
00:13:40,320 --> 0:13:42,823
接下

254
00:13:43,390 --> 0:13:45,425
在图片中初始化那个缓冲

255
00:13:45,492 --> 0:13:48,829
最后

256
00:13:49,129 --> 0:13:52,833
对于一个常见的操作

257
00:13:54,034 --> 0:13:59,173
新的API将所有的那段代码

258
00:14:00,574 --> 0:14:04,344
不过 因为我们等会将要使用一个

259
00:14:04,411 --> 0:14:08,849
这是一个使用新的API

260
00:14:09,349 --> 0:14:13,720
我们使用一个CGImage为CGImageFormat

261
00:14:13,787 --> 0:14:16,056
和一个额外的缓冲初始化器

262
00:14:16,123 --> 0:14:19,860
它接受了一个CGImage

263
00:14:21,461 --> 0:14:23,497
只要你完成了一个缓冲

264
00:14:23,564 --> 0:14:25,098
这是经典的vImage函数

265
00:14:25,165 --> 0:14:28,335
用来在缓冲的内容中

266
00:14:28,802 --> 0:14:32,072
以及我们的新API

267
00:14:32,139 --> 0:14:34,341
来简化了那个操作

268
00:14:34,408 --> 0:14:37,277
它使用了我们刚从图片生成的形式

269
00:14:38,846 --> 0:14:40,781
vImage有一个重要的用例

270
00:14:40,848 --> 0:14:44,585
就是在不同的域和形式之间转换

271
00:14:44,651 --> 0:14:46,620
vImage

272
00:14:46,687 --> 0:14:49,289
能在Core Video和

273
00:14:49,656 --> 0:14:52,893
且在不同Core Graphics

274
00:14:53,961 --> 0:14:59,900
比如 你可能想要转换一个CMYK

275
00:15:02,035 --> 0:15:04,204
这个已有的API创建了一个转换器

276
00:15:04,271 --> 0:15:07,708
接受转换的源和目标格式

277
00:15:07,774 --> 0:15:09,910
返回一个非托管转换器

278
00:15:11,044 --> 0:15:13,213
你获取到转换器的托管引用

279
00:15:13,280 --> 0:15:15,916
传递它给实现转换的函数

280
00:15:17,918 --> 0:15:20,654
我们的新API为已有的转换器类型

281
00:15:20,721 --> 0:15:24,925
它会返回一个转换器实例

282
00:15:26,193 --> 0:15:28,395
转换由转换器实例的

283
00:15:28,462 --> 0:15:30,330
转换方法完成

284
00:15:31,131 --> 0:15:35,502
最后 我们来了解使用

285
00:15:35,569 --> 0:15:37,004
在一个典型的例子中

286
00:15:37,070 --> 0:15:39,773
你可能想要从

287
00:15:39,840 --> 0:15:44,545
像素缓冲中创建一个图片格式描述

288
00:15:45,445 --> 0:15:48,715
这是经典的vImage API

289
00:15:48,782 --> 0:15:51,618
创建一个图片形式描述的代码

290
00:15:51,685 --> 0:15:53,153
以及获取它的通道数量

291
00:15:54,421 --> 0:15:56,723
新的API用两行代码

292
00:15:56,790 --> 0:15:58,425
提供了相同的功能

293
00:15:58,792 --> 0:16:01,428
你使用一个新的静态make函数

294
00:15:58,792 --> 0:16:01,428
你使用一个新的静态make函数

295
00:16:01,495 --> 0:16:04,965
缓冲的Core Video

296
00:16:05,532 --> 0:16:08,969
很简单的就访问到它的通道数量属性

297
00:16:13,307 --> 0:16:16,777
这是新的API一小部分的简略介绍

298
00:16:16,844 --> 0:16:19,146
我们现在来看一下

299
00:16:19,213 --> 0:16:21,982
来看看它和Accelerate比

300
00:16:22,049 --> 0:16:23,517
有多快和多节能

301
00:16:24,184 --> 0:16:26,887
LINPACK基准

302
00:16:26,954 --> 0:16:28,622
它开始是一组例程

303
00:16:28,689 --> 0:16:31,992
来提供快速的计算机线性代数

304
00:16:32,993 --> 0:16:35,829
它之后被包含在一个叫做

305
00:16:35,896 --> 0:16:37,998
它代表着线性代数软件包

306
00:16:38,899 --> 0:16:41,835
LApack被设计用来在调用

307
00:16:41,902 --> 0:16:43,403
缓存时利用好这些新的功能

308
00:16:43,837 --> 0:16:46,974
LApack是由许多阻塞算法组成

309
00:16:47,040 --> 0:16:50,043
这些算法创建在另一个叫做

310
00:16:50,110 --> 0:16:53,013
它代表着基本的线性代数子例程

311
00:16:53,981 --> 0:16:56,750
我们会在之后的演讲中了解

312
00:16:56,817 --> 0:16:59,853
现在 请记住LINPACK基准

313
00:16:59,920 --> 0:17:03,023
在LApack顶部运行

314
00:16:59,920 --> 0:17:03,023
在LApack顶部运行

315
00:17:05,959 --> 0:17:08,161
LINPACK基准衡量

316
00:17:08,228 --> 0:17:12,132
一般线性方程组

317
00:17:12,199 --> 0:17:14,067
它包含两个步骤

318
00:17:14,134 --> 0:17:16,036
矩阵分解步骤

319
00:17:16,103 --> 0:17:18,038
接下来的一步是倒推法

320
00:17:18,472 --> 0:17:19,705
通过修正算法

321
00:17:19,772 --> 0:17:22,041
我们能看到不同平台

322
00:17:22,108 --> 0:17:23,644
运行算法时的效果如何

323
00:17:24,077 --> 0:17:27,513
它为我们提供了一个比较

324
00:17:27,881 --> 0:17:30,417
LINPACK基准随着时间在

325
00:17:30,684 --> 0:17:34,021
最初 它解决了一个

326
00:17:34,087 --> 0:17:37,057
之后是1000x1000的系统

327
00:17:38,125 --> 0:17:42,062
现在最经常使用的变量

328
00:17:42,296 --> 0:17:45,065
问题的尺寸可以是你想要的任何大小

329
00:17:45,432 --> 0:17:48,068
这是我们今天会运行的变量

330
00:17:49,770 --> 0:17:54,074
我们将在一部iPhone 10S

331
00:17:54,141 --> 0:17:55,709
最上面 橘色的那个

332
00:17:55,776 --> 0:17:58,545
我们将会运行一个未经优化

333
00:17:59,046 --> 0:18:00,247
这个Linpack基准

334
00:17:59,046 --> 0:18:00,247
这个Linpack基准

335
00:18:00,314 --> 0:18:02,683
没有使用accelerate框架

336
00:18:02,983 --> 0:18:07,087
它依赖没有优化正在运行

337
00:18:07,154 --> 0:18:09,089
我们来看看它是怎样的

338
00:18:11,058 --> 0:18:14,361
我们会将它和使用

339
00:18:14,428 --> 0:18:18,732
也就是说 我们将会在相同的

340
00:18:18,799 --> 0:18:22,836
但使用Accelerate框架

341
00:18:25,906 --> 0:18:28,775
我们能看到使用了

342
00:18:28,842 --> 0:18:31,478
快了超过24倍

343
00:18:31,879 --> 0:18:33,614
这不仅会节约时间

344
00:18:33,680 --> 0:18:36,550
也节能 它会延长电池使用寿命

345
00:18:36,984 --> 0:18:38,385
我们现在来改变方式

346
00:18:38,452 --> 0:18:40,621
来看一下LINPACK基准

347
00:18:40,687 --> 0:18:43,123
GEMM的主要使用日常

348
00:18:45,092 --> 0:18:48,729
如我所说 LINPACK

349
00:18:48,795 --> 0:18:50,631
创建在BLAS上面

350
00:18:51,131 --> 0:18:53,200
BLAS里的一个叫做

351
00:18:53,267 --> 0:18:56,136
它代表着一般的矩阵乘法器

352
00:18:56,937 --> 0:19:01,208
这个例程被用来实现BLAS

353
00:18:56,937 --> 0:19:01,208
这个例程被用来实现BLAS

354
00:19:01,275 --> 0:19:04,611
它们在LApack的

355
00:19:04,678 --> 0:19:08,715
最显著的是矩阵分解和解算器例程

356
00:19:09,616 --> 0:19:10,584
因此

357
00:19:10,651 --> 0:19:13,754
GEMM有时被用来

358
00:19:14,021 --> 0:19:15,022
为了本次演讲

359
00:19:15,088 --> 0:19:19,159
我们要特别地来看一下GEMM

360
00:19:20,527 --> 0:19:23,530
这里 我们将要比较Eigen库

361
00:19:23,597 --> 0:19:25,165
和Accelerate的性能表现

362
00:19:25,465 --> 0:19:28,335
Eigen库

363
00:19:28,402 --> 0:19:30,704
会在一部

364
00:19:30,971 --> 0:19:34,174
它们都会运行一个单精度

365
00:19:34,641 --> 0:19:36,844
我们来看看Eigen的表现

366
00:19:38,512 --> 0:19:41,315
Eigen的最高速度约为510

367
00:19:41,381 --> 0:19:44,184
现在我们来看一下

368
00:19:46,153 --> 0:19:49,957
可以看到Accelerate框架

369
00:19:50,023 --> 0:19:52,192
大概比Eigen快了2.5倍

370
00:19:52,659 --> 0:19:56,663
这是因为Accelerate

371
00:19:56,730 --> 0:20:00,200
它允许我们能完全利用好平台

372
00:19:56,730 --> 0:20:00,200
它允许我们能完全利用好平台

373
00:20:01,101 --> 0:20:03,270
那么 如果你是一个开发者

374
00:20:03,337 --> 0:20:06,473
在app中用Accelerate

375
00:20:06,540 --> 0:20:08,876
这个性能表现更节能

376
00:20:08,942 --> 0:20:10,644
它意味着更长的电池寿命

377
00:20:10,711 --> 0:20:14,214
和一个对用户整体更好的体验

378
00:20:15,616 --> 0:20:16,817
总结

379
00:20:16,884 --> 0:20:18,385
Accelerat提供了

380
00:20:18,452 --> 0:20:21,655
大规模的数学计算的功能

381
00:20:21,722 --> 0:20:25,225
更快和节能的图像点运算

382
00:20:25,692 --> 0:20:28,695
现在我们加入了一个

383
00:20:28,762 --> 0:20:31,365
它让Accelerate库更易用

384
00:20:31,431 --> 0:20:35,669
这样你的用户会从

385
00:20:36,570 --> 0:20:39,373
请访问我们的网站

386
00:20:39,439 --> 0:20:41,341
和广泛覆盖了整个

387
00:20:41,408 --> 0:20:44,244
Accelerate框架的

388
00:20:44,311 --> 0:20:45,879
非常感谢大家
