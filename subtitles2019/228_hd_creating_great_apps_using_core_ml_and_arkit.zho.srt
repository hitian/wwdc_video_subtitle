1
00:00:00,506 --> 0:00:05,500
[音乐]

2
00:00:12,496 --> 0:00:14,496
[掌声]

3
00:00:14,976 --> 0:00:16,666
&gt;&gt; 各位早上好

4
00:00:16,666 --> 0:00:17,616
感谢各位来参加我们的会议

5
00:00:19,206 --> 0:00:21,996
在 Apple 我们开发技术

6
00:00:22,936 --> 0:00:24,436
我们开发的技术用于让各位

7
00:00:24,436 --> 0:00:27,356
创造具有惊人体验的优质 App

8
00:00:27,886 --> 0:00:30,916
我最喜爱的 App 是那些

9
00:00:30,916 --> 0:00:32,296
无缝地融入技术

10
00:00:32,296 --> 0:00:34,096
并且让我们能在使用时

11
00:00:34,096 --> 0:00:35,166
沉浸其中的 App

12
00:00:36,956 --> 0:00:39,496
今天我想与各位探讨的是

13
00:00:39,496 --> 0:00:40,946
其中两个技术

14
00:00:41,446 --> 0:00:43,036
Core ML 和 ARKit

15
00:00:43,586 --> 0:00:47,026
这两个技术共同帮助

16
00:00:47,116 --> 0:00:48,666
我们的设备更深入

17
00:00:48,666 --> 0:00:50,466
认识周围的世界

18
00:00:51,696 --> 0:00:54,216
它们帮助我们将虚拟世界

19
00:00:54,216 --> 0:00:54,976
和现实世界融合在一起

20
00:00:57,216 --> 0:00:58,646
今天我们将带各位

21
00:00:58,646 --> 0:00:59,926
领略如何开发出 App

22
00:00:59,926 --> 0:01:02,046
实现以上目的

23
00:00:59,926 --> 0:01:02,046
实现以上目的

24
00:01:02,516 --> 0:01:04,245
在此过程中我们将探讨一些

25
00:01:04,245 --> 0:01:05,296
将会遇到的挑战

26
00:01:05,296 --> 0:01:07,076
以及怎样克服它们

27
00:01:07,636 --> 0:01:09,136
并且我们还将探讨

28
00:01:09,136 --> 0:01:11,266
在面对困难时

29
00:01:11,266 --> 0:01:12,066
衍生的一些主题

30
00:01:13,836 --> 0:01:17,596
首先我们的第一个问题是

31
00:01:17,676 --> 0:01:19,486
机器学习是否有帮助

32
00:01:20,656 --> 0:01:23,016
当然如果我说没有帮助的话

33
00:01:23,016 --> 0:01:24,166
今天的会议将会非常短暂

34
00:01:24,806 --> 0:01:27,286
但我不能简单地肯定这一观点

35
00:01:27,286 --> 0:01:29,946
因为这一问题的答案

36
00:01:29,946 --> 0:01:31,996
取决于你正在解决的问题

37
00:01:31,996 --> 0:01:33,396
以及你必须去处理

38
00:01:33,396 --> 0:01:34,836
的有关数据

39
00:01:36,276 --> 0:01:37,366
因为机器学习的内容

40
00:01:37,366 --> 0:01:38,646
就是理解你所拥有的信息

41
00:01:38,646 --> 0:01:40,506
机器学习有关于

42
00:01:40,596 --> 0:01:42,486
理解数据内部的模式

43
00:01:42,486 --> 0:01:44,476
这些模式可能很难用

44
00:01:44,476 --> 0:01:45,816
程序化的语言去描述

45
00:01:46,246 --> 0:01:48,876
而且这些数据是存在于

46
00:01:49,556 --> 0:01:49,746
你的 App 中的

47
00:01:50,106 --> 0:01:51,576
你的用户每天都在输入数据

48
00:01:52,236 --> 0:01:53,836
他们使用键盘

49
00:01:53,836 --> 0:01:55,246
来输入文本信息

50
00:01:56,216 --> 0:01:57,706
他们使用麦克风

51
00:01:57,706 --> 0:01:58,536
来记录声音信息

52
00:02:00,456 --> 0:02:01,976
他们使用摄像头

53
00:02:01,976 --> 0:02:03,726
记录照片和视频

54
00:02:04,246 --> 0:02:07,006
所以当我们遇到问题的时候

55
00:02:07,006 --> 0:02:08,466
机器学习有帮助吗

56
00:02:08,466 --> 0:02:10,265
这是一个很好的问题

57
00:02:10,705 --> 0:02:12,536
所以你需要认真审视你所要

58
00:02:12,536 --> 0:02:13,256
解决问题的类型

59
00:02:13,256 --> 0:02:15,016
以及你目前可以用于

60
00:02:15,016 --> 0:02:16,726
解决这个问题的数据有哪些

61
00:02:19,656 --> 0:02:20,986
我们今天要了解的第二个主题

62
00:02:20,986 --> 0:02:22,806
是去理解你的

63
00:02:22,806 --> 0:02:25,076
模型具有的行为

64
00:02:25,996 --> 0:02:28,276
这些模型被训练为接收

65
00:02:28,276 --> 0:02:30,326
特定格式的输入

66
00:02:30,326 --> 0:02:33,376
然后提供

67
00:02:33,426 --> 0:02:35,036
特定格式的输出

68
00:02:35,616 --> 0:02:38,806
也就是说如果你的输入并不是

69
00:02:38,806 --> 0:02:40,176
模型预期的特定格式

70
00:02:40,176 --> 0:02:42,856
那么它的输出也将是

71
00:02:42,856 --> 0:02:44,046
你所无法预计的

72
00:02:44,046 --> 0:02:48,046
而要说到输出

73
00:02:48,046 --> 0:02:49,026
如果你不知道你的模型输出什么

74
00:02:49,026 --> 0:02:50,326
那么要在你的应用中

75
00:02:50,326 --> 0:02:51,736
实现神奇的用户体验

76
00:02:52,176 --> 0:02:54,886
可能是会非常难的

77
00:02:56,136 --> 0:02:57,396
我们将通过几种方式

78
00:02:57,396 --> 0:02:59,316
来让你将某些模型的

79
00:02:59,316 --> 0:03:01,726
输入和输出可视化

80
00:02:59,316 --> 0:03:01,726
输入和输出可视化

81
00:03:02,206 --> 0:03:05,116
但是现在 先继续我们的旅程

82
00:03:06,166 --> 0:03:07,666
我们说过我们将利用

83
00:03:07,666 --> 0:03:09,456
一系列技术的组合

84
00:03:09,456 --> 0:03:10,776
来融合虚拟世界和现实世界

85
00:03:10,836 --> 0:03:12,786
那除了 App 之外

86
00:03:12,786 --> 0:03:14,606
还有什么内容更适合完成这一目的呢

87
00:03:14,706 --> 0:03:16,986
我们认为为儿童构建一个

88
00:03:17,276 --> 0:03:18,716
教育类的游戏

89
00:03:18,806 --> 0:03:20,526
来练习他们的数学技巧

90
00:03:20,526 --> 0:03:23,376
像是计数和加减乘除

91
00:03:23,376 --> 0:03:24,986
这个想法非常有趣

92
00:03:25,796 --> 0:03:28,306
并且我们知道孩子们有时候

93
00:03:28,306 --> 0:03:30,266
会利用骰子来练习这些技能

94
00:03:30,906 --> 0:03:32,266
那现在我们就可以把

95
00:03:32,616 --> 0:03:35,036
虚拟的骰子放进 App 中

96
00:03:35,036 --> 0:03:36,406
让这些骰子在屏幕上滚动

97
00:03:36,656 --> 0:03:37,806
但我们想更有趣的方式会是

98
00:03:37,806 --> 0:03:39,946
如果能让孩子们在现实中

99
00:03:39,946 --> 0:03:41,236
在桌面上投实体的骰子

100
00:03:41,236 --> 0:03:42,856
并且让这些骰子能与

101
00:03:43,396 --> 0:03:45,086
我们的 App 交互

102
00:03:46,336 --> 0:03:47,996
所以这就是我们所做的

103
00:03:48,296 --> 0:03:50,586
我们遇到的第一个挑战是

104
00:03:50,586 --> 0:03:55,646
如何让我们的应用识别出骰子

105
00:03:56,146 --> 0:03:59,306
这里有几种方法

106
00:04:00,266 --> 0:04:01,906
让我们以编程方式开始

107
00:04:02,526 --> 0:04:05,306
但这会有一些困难

108
00:04:06,616 --> 0:04:08,106
如果我们将问题限制在

109
00:04:08,106 --> 0:04:10,256
识别六面骰

110
00:04:10,256 --> 0:04:11,726
我们就可以开始研究骰子的属性

111
00:04:12,536 --> 0:04:14,666
比如看我身后的骰子

112
00:04:14,666 --> 0:04:15,606
它的颜色是灰色的

113
00:04:16,935 --> 0:04:19,466
但并非所有骰子都是灰色的

114
00:04:19,466 --> 0:04:21,536
所以这并不一定有用

115
00:04:22,856 --> 0:04:24,926
如果你在 2D 平面上观察它

116
00:04:25,476 --> 0:04:26,876
它是一个六边形的形状

117
00:04:26,986 --> 0:04:28,596
由三个斜矩形构成

118
00:04:30,206 --> 0:04:31,926
但随着骰子在桌面上滚动

119
00:04:31,926 --> 0:04:33,176
这些形状将会发生变化

120
00:04:33,836 --> 0:04:36,416
如果我们仔细观察每一面

121
00:04:36,416 --> 0:04:38,396
它们上面会有很多点

122
00:04:38,396 --> 0:04:40,096
但是这也会因为

123
00:04:40,256 --> 0:04:41,426
你所看的面的变化以及

124
00:04:41,426 --> 0:04:42,966
观察角度变化

125
00:04:42,966 --> 0:04:44,236
而有所改变

126
00:04:45,426 --> 0:04:47,066
所以随着这些属性的改变

127
00:04:47,346 --> 0:04:49,476
要编写程序来识别骰子

128
00:04:49,476 --> 0:04:52,476
将会是一件困难的事情

129
00:04:52,866 --> 0:04:56,106
所以让我们来看看

130
00:04:56,106 --> 0:04:56,976
机器学习的方法

131
00:05:00,536 --> 0:05:02,376
我们可以训练图像分类模型

132
00:05:02,376 --> 0:05:06,146
来识别出图像中的骰子

133
00:05:06,706 --> 0:05:10,996
但我们想知道图像中有多少骰子

134
00:05:10,996 --> 0:05:12,766
而不仅仅是判断

135
00:05:12,766 --> 0:05:14,706
图像中是否有骰子存在

136
00:05:15,896 --> 0:05:17,356
因此我们考虑使用

137
00:05:17,356 --> 0:05:18,426
对象检测模型

138
00:05:18,986 --> 0:05:21,056
对象检测模型将告诉我们

139
00:05:21,056 --> 0:05:22,316
图像中是否有骰子存在

140
00:05:22,316 --> 0:05:24,366
并且还将告诉我们骰子的位置

141
00:05:24,366 --> 0:05:26,076
如果我们知道骰子在图像中的位置

142
00:05:26,076 --> 0:05:27,176
那我们就可以

143
00:05:27,176 --> 0:05:30,606
计算图像里骰子的个数

144
00:05:30,786 --> 0:05:32,596
要做到这一点

145
00:05:32,596 --> 0:05:34,846
我们需要获取数据

146
00:05:34,846 --> 0:05:37,336
所以我们将一堆骰子

147
00:05:37,606 --> 0:05:38,116
放在桌面上滚动

148
00:05:38,606 --> 0:05:41,436
接下来我们拍摄这些图片

149
00:05:41,436 --> 0:05:43,286
然后用边界框标记他们

150
00:05:43,286 --> 0:05:44,886
这些边界框标注出

151
00:05:44,886 --> 0:05:45,906
骰子在图像中的位置

152
00:05:46,226 --> 0:05:49,486
之后我们利用新的

153
00:05:49,486 --> 0:05:51,276
Create ML 来训练我们的

154
00:05:51,276 --> 0:05:52,246
对象检测模型

155
00:05:54,716 --> 0:05:56,026
如果你想了解更多有关

156
00:05:56,026 --> 0:05:57,966
训练的信息

157
00:05:57,966 --> 0:05:59,046
可以参阅 Create ML for Object Detection

158
00:05:59,046 --> 0:06:00,876
and Sound Classification 这一会议

159
00:05:59,046 --> 0:06:00,876
and Sound Classification 这一会议

160
00:06:00,876 --> 0:06:04,806
现在我想邀请 Scott

161
00:06:04,806 --> 0:06:06,356
来实际展示

162
00:06:07,596 --> 0:06:13,036
Scott [鼓掌]

163
00:06:13,536 --> 0:06:14,496
&gt;&gt; 大家早上好

164
00:06:14,936 --> 0:06:15,176
&gt;&gt; 早上好

165
00:06:17,136 --> 0:06:18,246
&gt;&gt; 正如 Brent 讨论的那样

166
00:06:18,246 --> 0:06:19,916
我们将探索使用被称为对象检测

167
00:06:19,916 --> 0:06:21,516
的机器学习技术

168
00:06:21,516 --> 0:06:23,006
来增加我们的 App 

169
00:06:23,006 --> 0:06:24,446
识别骰子能力的方法

170
00:06:25,066 --> 0:06:26,396
而且我相信你们都想

171
00:06:26,396 --> 0:06:27,726
看到这一方法可以奏效

172
00:06:27,726 --> 0:06:29,000
所以让我们开始吧

173
00:06:38,536 --> 0:06:40,736
在这里我们有一个简单的 App

174
00:06:40,946 --> 0:06:41,996
这一 App 连接了实时摄像机视图

175
00:06:41,996 --> 0:06:43,586
并且我们添加了

176
00:06:43,586 --> 0:06:44,866
已经训练好的

177
00:06:44,866 --> 0:06:46,706
对象检测器来对骰子计数

178
00:06:47,196 --> 0:06:48,236
所以让我们来看看

179
00:06:48,236 --> 0:06:49,366
当画面中增加骰子时会发生什么

180
00:06:50,766 --> 0:06:55,896
一二三四

181
00:06:56,056 --> 0:06:59,366
我们可以掷骰子来让这变得更有趣

182
00:07:00,066 --> 0:07:02,416
所以这是很棒的

183
00:07:02,416 --> 0:07:04,446
我们的 App 能够使用

184
00:07:04,786 --> 0:07:05,866
对象检测器来识别骰子

185
00:07:06,476 --> 0:07:07,836
但是我们今天要讨论的主题

186
00:07:07,836 --> 0:07:09,066
之一是理解

187
00:07:09,066 --> 0:07:10,966
你的模型的行为

188
00:07:11,416 --> 0:07:13,616
因此让我们实际看一下

189
00:07:13,616 --> 0:07:15,286
模型所看到内容的

190
00:07:15,286 --> 0:07:16,436
通过调试可视化能得到什么

191
00:07:17,006 --> 0:07:18,096
正如你所见的

192
00:07:18,096 --> 0:07:20,066
我们在每个检测到的对象

193
00:07:20,066 --> 0:07:21,926
周围都绘制了边界框

194
00:07:21,926 --> 0:07:23,576
在这一场景下对象是桌上的骰子

195
00:07:23,576 --> 0:07:25,216
如果我们移动它们

196
00:07:25,566 --> 0:07:28,396
那么这些边界框也会随之移动

197
00:07:28,606 --> 0:07:30,346
这对你来说非常重要

198
00:07:30,346 --> 0:07:32,756
因为如果你正在训练一个

199
00:07:32,756 --> 0:07:34,606
对象检测器模型

200
00:07:34,606 --> 0:07:35,946
并且你没有在

201
00:07:35,946 --> 0:07:37,416
你不想检测的其他物体

202
00:07:37,416 --> 0:07:38,556
看到有边界框存在

203
00:07:38,556 --> 0:07:40,826
或者你并没有看到

204
00:07:40,886 --> 0:07:42,156
在你想要检测的物体上

205
00:07:42,156 --> 0:07:43,436
出现你想要的边界框

206
00:07:43,846 --> 0:07:45,276
这可能是你在这种

207
00:07:45,276 --> 0:07:46,536
光照条件下收集更多数据的

208
00:07:46,536 --> 0:07:47,866
一次很好的机会

209
00:07:48,376 --> 0:07:49,746
你可能会想收集

210
00:07:49,746 --> 0:07:50,726
不同背景下

211
00:07:50,726 --> 0:07:52,786
不同光照以及

212
00:07:53,096 --> 0:07:54,276
不同数量对象的更多数据

213
00:07:54,276 --> 0:07:55,756
在这个场景下我们有四个

214
00:07:55,836 --> 0:07:56,716
但你有可能想使用

215
00:07:56,716 --> 0:07:58,486
五个或者六个甚至多达十个

216
00:07:58,486 --> 0:08:00,706
或者更少甚至没有骰子

217
00:07:58,486 --> 0:08:00,706
或者更少甚至没有骰子

218
00:08:00,706 --> 0:08:02,066
的图片来训练模型

219
00:08:02,066 --> 0:08:03,746
使之不会识别错误

220
00:08:07,076 --> 0:08:09,116
让我们来看看一些

221
00:08:09,116 --> 0:08:11,346
实现这一目的的代码

222
00:08:11,506 --> 0:08:12,566
当你处理使用 Create ML

223
00:08:12,566 --> 0:08:13,536
在 Vision 框架下

224
00:08:13,536 --> 0:08:15,186
训练过的对象检测器时

225
00:08:15,186 --> 0:08:16,796
你得到的结果是

226
00:08:16,796 --> 0:08:19,586
VNRecognizedObjectObeservation 列表

227
00:08:20,316 --> 0:08:21,536
因此这里我们有一个函数

228
00:08:21,536 --> 0:08:22,846
处理这些观测结果

229
00:08:22,846 --> 0:08:23,946
并且完成一些功能

230
00:08:24,526 --> 0:08:25,746
第一个也是最简单的

231
00:08:26,286 --> 0:08:27,146
我们只计数骰子的个数

232
00:08:27,606 --> 0:08:29,806
这就和观察结果的数量是一样的

233
00:08:29,806 --> 0:08:31,766
因为每个骰子只计数 1

234
00:08:32,326 --> 0:08:34,716
接下来我们有几个辅助函数

235
00:08:34,716 --> 0:08:36,035
可以根据这些已经识别的对象

236
00:08:36,035 --> 0:08:37,566
的观测结果来在图片上

237
00:08:37,676 --> 0:08:40,346
绘制边界框

238
00:08:40,936 --> 0:08:43,145
第一个函数的功能是

239
00:08:43,145 --> 0:08:44,636
为每一个识别出来的对象观测结果

240
00:08:44,636 --> 0:08:46,316
绘制需要的边界框

241
00:08:46,316 --> 0:08:47,826
这一边界根据你提供给 Vision

242
00:08:47,966 --> 0:08:50,186
的输入图像输出

243
00:08:50,186 --> 0:08:51,656
标准化之后的坐标

244
00:08:51,656 --> 0:08:53,936
以便该函数将这些

245
00:08:54,006 --> 0:08:55,316
结果映射回我们的

246
00:08:55,316 --> 0:08:56,496
视图控制器中的视图坐标系

247
00:08:56,496 --> 0:08:57,366
这样我们就可以在

248
00:08:57,366 --> 0:08:58,546
屏幕的正确位置绘制它们

249
00:08:58,606 --> 0:09:00,606
将它们覆盖在

250
00:08:58,606 --> 0:09:00,606
将它们覆盖在

251
00:09:00,606 --> 0:09:01,466
图像中的实际物体上方

252
00:09:03,026 --> 0:09:04,376
接下来我们还有一个辅助函数

253
00:09:04,376 --> 0:09:06,836
可以帮助我们在屏幕上

254
00:09:07,106 --> 0:09:08,416
绘制精美的圆角矩形

255
00:09:08,416 --> 0:09:10,326
这一圆角矩形被称为 CALayer

256
00:09:10,396 --> 0:09:13,276
接下来我们将 CALayer 添加到

257
00:09:13,276 --> 0:09:15,986
屏幕上需要渲染的叠加层上

258
00:09:16,656 --> 0:09:17,886
所有这些代码都可以在

259
00:09:17,886 --> 0:09:19,276
与这一会议相关的示例 App 中找到

260
00:09:19,276 --> 0:09:22,876
大家可以去查看

261
00:09:23,136 --> 0:09:25,246
到现在为止进展顺利

262
00:09:25,486 --> 0:09:27,566
我们的 App 已经可以

263
00:09:27,566 --> 0:09:28,296
利用对象检测来计数骰子

264
00:09:29,216 --> 0:09:30,716
但你可能已经意识到或者想过

265
00:09:30,716 --> 0:09:32,686
游戏通常并不依赖于

266
00:09:32,686 --> 0:09:35,886
骰子的数量这一事实

267
00:09:35,886 --> 0:09:37,196
它们通常依赖于

268
00:09:37,236 --> 0:09:37,866
骰子上面显示的数值

269
00:09:38,796 --> 0:09:40,436
所以我们还需要更进一步

270
00:09:40,486 --> 0:09:42,416
弄清楚如何识别

271
00:09:42,416 --> 0:09:45,586
这些在骰子上显示的数值

272
00:09:45,796 --> 0:09:47,166
这是我们希望我们的 App

273
00:09:47,166 --> 0:09:49,446
最终需要实现的功能

274
00:09:49,446 --> 0:09:50,376
我们希望它可以告诉

275
00:09:50,376 --> 0:09:52,476
右侧的骰子结果是 5 

276
00:09:52,476 --> 0:09:55,156
而左侧骰子的结果是 1

277
00:09:55,366 --> 0:09:57,166
幸运的是 正如 Brent 所提到的

278
00:09:57,166 --> 0:09:59,476
对象探测器不仅可以检测物体

279
00:09:59,576 --> 0:10:01,106
它还能对物体进行分类

280
00:09:59,576 --> 0:10:01,106
它还能对物体进行分类

281
00:10:01,106 --> 0:10:02,626
因为它被构建来识别

282
00:10:02,626 --> 0:10:05,916
各种不同的物体和图像

283
00:10:06,666 --> 0:10:11,186
接下来让我们更新我们的训练数据

284
00:10:11,186 --> 0:10:14,376
将不同值的骰子视为不同类

285
00:10:14,376 --> 0:10:16,766
就像你在屏幕上看到的那样

286
00:10:18,796 --> 0:10:21,136
这听起来能够实现

287
00:10:21,136 --> 0:10:22,856
所以我们在我们的 App 中

288
00:10:22,856 --> 0:10:24,246
进行了尝试

289
00:10:24,246 --> 0:10:26,286
让我们来看看

290
00:10:26,286 --> 0:10:27,516
遇到的一些实例

291
00:10:27,566 --> 0:10:31,126
在大多数情况下它运行得很好

292
00:10:31,416 --> 0:10:32,566
正如你在我身后图片中

293
00:10:32,866 --> 0:10:34,866
所看到的那样

294
00:10:34,866 --> 0:10:36,396
我们的对象检测器可以

295
00:10:36,436 --> 0:10:38,036
正确且准确地检测和分类

296
00:10:38,036 --> 0:10:39,026
屏幕左侧出现的骰子

297
00:10:39,026 --> 0:10:42,446
但如果我们关注另一边

298
00:10:42,446 --> 0:10:44,506
我们将发现我们的对象检测器

299
00:10:44,506 --> 0:10:45,846
将 6 和 4 这两个骰子

300
00:10:45,846 --> 0:10:48,266
检测为一个骰子

301
00:10:49,816 --> 0:10:50,766
如果我们仔细考虑一些

302
00:10:50,766 --> 0:10:52,986
事情发生的原因

303
00:10:52,986 --> 0:10:54,616
很明显模型不能将它们

304
00:10:54,616 --> 0:10:56,476
分开识别成两个独立的骰子

305
00:10:56,476 --> 0:10:58,986
并且这一情况

306
00:10:58,986 --> 0:11:00,246
要归结于 4 这个骰子

307
00:10:58,986 --> 0:11:00,246
要归结于 4 这个骰子

308
00:11:00,246 --> 0:11:02,346
被出现在前面的那个骰子遮住

309
00:11:03,646 --> 0:11:05,266
所以考虑一下这件事情之后

310
00:11:05,266 --> 0:11:06,936
我们意识到我们真正关心的

311
00:11:06,936 --> 0:11:09,356
是这些骰子的顶部

312
00:11:09,356 --> 0:11:11,296
并且骰子的顶部对于我们

313
00:11:11,296 --> 0:11:12,796
来说总是可见的

314
00:11:13,946 --> 0:11:15,916
所以我们将更进一步

315
00:11:15,916 --> 0:11:17,396
给予我们的模型一点小帮助

316
00:11:17,846 --> 0:11:19,616
我们更新了所有训练数据

317
00:11:19,776 --> 0:11:21,896
关注这些骰子的顶部

318
00:11:22,566 --> 0:11:24,616
所以我们现在训练的对象检测器

319
00:11:24,616 --> 0:11:26,256
并不是为了检测骰子

320
00:11:26,256 --> 0:11:28,316
而是去检测骰子的顶部

321
00:11:29,406 --> 0:11:31,326
那么让我们来看看当我们这样做时 将会发生什么

322
00:11:31,756 --> 0:11:34,326
正如你所看到的

323
00:11:34,326 --> 0:11:36,646
我们的模型仍然能正确

324
00:11:36,766 --> 0:11:39,206
识别和分类左边这些骰子

325
00:11:39,206 --> 0:11:41,726
但现在这个模型还能够

326
00:11:41,726 --> 0:11:43,786
正确地将右边的骰子

327
00:11:43,786 --> 0:11:44,516
进行检测和分类

328
00:11:47,476 --> 0:11:49,926
今天我们还想与你分享另外一个小插曲

329
00:11:51,396 --> 0:11:53,396
在我们的探究过程中

330
00:11:53,886 --> 0:11:55,946
我们注意到了这种情况

331
00:11:55,946 --> 0:11:57,466
我们的模型一直在

332
00:11:57,726 --> 0:11:59,666
检测骰子的左侧

333
00:12:01,076 --> 0:12:02,146
在一开始这非常令人困惑

334
00:12:02,146 --> 0:12:04,096
但如果我们旋转这一个图像

335
00:12:04,096 --> 0:12:05,936
我们就能理解模型

336
00:12:06,006 --> 0:12:07,616
是如何将这些识别成顶部的

337
00:12:08,496 --> 0:12:09,816
这很容易理解

338
00:12:10,056 --> 0:12:10,986
只要我们去关注

339
00:12:10,986 --> 0:12:12,356
模型的输入是怎样的

340
00:12:13,146 --> 0:12:14,486
我们没有根据设备的方向

341
00:12:14,486 --> 0:12:15,966
调整图像的方向

342
00:12:15,966 --> 0:12:17,426
这是视觉任务中

343
00:12:17,426 --> 0:12:20,266
经常出现的一个问题

344
00:12:20,266 --> 0:12:21,926
因此这里的关键教训是

345
00:12:21,926 --> 0:12:23,506
如果你在模型的输出中

346
00:12:23,506 --> 0:12:25,046
发现了奇怪的行为

347
00:12:25,046 --> 0:12:26,056
看一下输入总没有什么坏处

348
00:12:26,896 --> 0:12:29,336
它也许就和根据设备的方向

349
00:12:29,336 --> 0:12:33,276
旋转你的图像一样简单

350
00:12:33,446 --> 0:12:35,000
让我们看看这个新模型效果如何

351
00:12:43,696 --> 0:12:45,026
还是同样的 App

352
00:12:45,686 --> 0:12:47,356
但我们进行了更新

353
00:12:47,546 --> 0:12:49,326
使得我们的模型可以对骰子

354
00:12:49,356 --> 0:12:51,666
进行检测和分类

355
00:12:51,766 --> 0:12:52,816
为了简单起见我将专注于

356
00:12:52,816 --> 0:12:53,756
三个骰子的情况

357
00:12:54,216 --> 0:12:56,286
我们可以看到我们的模型

358
00:12:56,716 --> 0:12:58,406
检测到了 6 和 5 和 2

359
00:12:59,426 --> 0:12:59,976
让我们掷一次骰子

360
00:13:02,996 --> 0:13:04,476
4 和 6 和 5

361
00:13:05,316 --> 0:13:06,936
棒极了 我们做的很好

362
00:13:07,516 --> 0:13:10,716
[鼓掌]

363
00:13:11,216 --> 0:13:12,076
我想请你关注一个

364
00:13:12,076 --> 0:13:14,856
我认为非常重要的细节

365
00:13:15,606 --> 0:13:17,296
如果我移动骰子

366
00:13:17,296 --> 0:13:18,656
你可以看到列表更新了

367
00:13:19,146 --> 0:13:20,816
我们实际上根据骰子

368
00:13:20,816 --> 0:13:22,566
在桌面上的排列顺序

369
00:13:22,566 --> 0:13:24,786
来显示值列表

370
00:13:25,476 --> 0:13:26,916
这是一个次要的设计细节

371
00:13:27,396 --> 0:13:29,426
但它确实带来了体验的一致性

372
00:13:29,426 --> 0:13:30,576
因为我们的用户

373
00:13:30,576 --> 0:13:32,166
能在桌面上看到

374
00:13:32,166 --> 0:13:33,586
这些骰子的排布情况

375
00:13:34,126 --> 0:13:36,196
所以既然我们已经将

376
00:13:36,196 --> 0:13:37,506
物理和虚拟世界进行融合

377
00:13:38,186 --> 0:13:40,976
我们实际上正在为

378
00:13:42,246 --> 0:13:44,406
用户提供非常一致的显示结果

379
00:13:45,536 --> 0:13:46,436
还有一件事情我们需要弄清楚

380
00:13:46,436 --> 0:13:48,696
什么算掷一次骰子

381
00:13:49,626 --> 0:13:51,466
与之前相同

382
00:13:51,466 --> 0:13:53,936
游戏通常不依赖于掷骰子的过程

383
00:13:53,936 --> 0:13:55,636
而是依赖掷骰子的结果

384
00:13:55,636 --> 0:13:57,086
当你进行游戏时

385
00:13:57,086 --> 0:13:58,546
你将会掷出一些骰子

386
00:13:58,546 --> 0:14:00,836
并根据投掷结果来决定

387
00:13:58,546 --> 0:14:00,836
并根据投掷结果来决定

388
00:14:00,836 --> 0:14:02,696
棋子的移动或进行决策

389
00:14:02,776 --> 0:14:04,276
在这种情况下

390
00:14:04,366 --> 0:14:05,806
我们可能要为用户制作

391
00:14:05,876 --> 0:14:06,996
动画效果或者提供反馈

392
00:14:07,276 --> 0:14:08,386
你可能已经在之前的演示中注意到

393
00:14:08,386 --> 0:14:10,036
直到掷骰子结束

394
00:14:10,036 --> 0:14:12,326
画面上才显示数字

395
00:14:13,086 --> 0:14:14,726
那么我们应该怎么做呢

396
00:14:15,656 --> 0:14:16,736
首先我们需要问自己

397
00:14:16,736 --> 0:14:18,336
我们观察到了什么

398
00:14:19,906 --> 0:14:21,756
在这一情况下我们注意到

399
00:14:21,756 --> 0:14:23,816
骰子停了下来并且

400
00:14:23,816 --> 0:14:26,026
在不同的相机帧之间值是稳定的

401
00:14:27,196 --> 0:14:28,926
机器学习能在这里帮助我们吗

402
00:14:29,966 --> 0:14:32,716
或许我们可以构建一个

403
00:14:32,716 --> 0:14:34,056
顺序模型接收帧数据

404
00:14:34,096 --> 0:14:36,026
来决定掷骰子是否已经结束

405
00:14:36,026 --> 0:14:37,636
但我们已经有了一个

406
00:14:37,636 --> 0:14:38,886
能够理解桌上骰子

407
00:14:38,886 --> 0:14:40,416
排布的模型

408
00:14:40,816 --> 0:14:42,466
所以我们真正需要做的是

409
00:14:42,466 --> 0:14:43,816
解读我们模型的输出

410
00:14:46,256 --> 0:14:47,746
那么让我们来看看

411
00:14:47,746 --> 0:14:50,386
如何在代码中执行这一操作

412
00:14:50,586 --> 0:14:51,956
这里我们有一个函数

413
00:14:51,956 --> 0:14:54,046
它接受两个对象观察列表

414
00:14:54,046 --> 0:14:55,416
一个来自当前相机帧

415
00:14:55,416 --> 0:14:56,906
另一个来自于

416
00:14:56,966 --> 0:14:58,286
前一个相机帧

417
00:14:59,336 --> 0:15:01,746
所以我们需要检查一些事情 来判断当前骰子

418
00:14:59,336 --> 0:15:01,746
所以我们需要检查一些事情 来判断当前骰子

419
00:15:01,776 --> 0:15:02,526
是否已经停止滚动

420
00:15:03,476 --> 0:15:05,396
首先我们现在拥有

421
00:15:05,396 --> 0:15:06,946
和之前一样多的骰子吗

422
00:15:07,996 --> 0:15:10,046
如果没有那么也许有一个骰子进入

423
00:15:10,046 --> 0:15:11,206
当前的相机帧里面

424
00:15:11,206 --> 0:15:12,346
于是我们有了比之前多的骰子

425
00:15:12,836 --> 0:15:14,226
如果数量比以前少了

426
00:15:14,536 --> 0:15:15,796
也许其中一个还在滚动

427
00:15:15,796 --> 0:15:17,186
所以我们的检测器

428
00:15:17,186 --> 0:15:18,526
没有将它检测出来

429
00:15:19,216 --> 0:15:21,246
因此如若我们没有和原来

430
00:15:21,376 --> 0:15:23,336
一样多的骰子 那掷骰子过程没有结束

431
00:15:23,816 --> 0:15:26,036
接下来我们将比较

432
00:15:26,036 --> 0:15:27,366
先前的预测结果

433
00:15:27,366 --> 0:15:30,136
和当前的预测结果

434
00:15:31,516 --> 0:15:32,876
如果骰子顶部显示的值

435
00:15:32,876 --> 0:15:35,606
并不相同那说明

436
00:15:35,606 --> 0:15:37,306
掷骰子过程没有结束

437
00:15:38,036 --> 0:15:40,186
我们还将检测这些预测结果

438
00:15:40,186 --> 0:15:41,456
边界框之间的重叠度

439
00:15:41,456 --> 0:15:43,366
是否超过 85%

440
00:15:44,296 --> 0:15:45,576
如果我们当前的预测结果

441
00:15:45,576 --> 0:15:46,776
和我们正在比较的预测结果

442
00:15:46,776 --> 0:15:48,036
之间的边界框并不重叠

443
00:15:48,036 --> 0:15:49,736
说明要么我们正在

444
00:15:49,736 --> 0:15:50,666
看的是两个完全不同的骰子

445
00:15:50,666 --> 0:15:54,086
要么这个骰子

446
00:15:54,086 --> 0:15:55,846
发生了明显的移动

447
00:15:57,106 --> 0:15:59,726
最后如果我们得到的

448
00:15:59,726 --> 0:16:01,306
匹配结果与桌面上骰子数量一致的话

449
00:15:59,726 --> 0:16:01,306
匹配结果与桌面上骰子数量一致的话

450
00:16:01,306 --> 0:16:02,956
代表掷骰子过程结束

451
00:16:03,466 --> 0:16:07,966
因此现在我们的 App 能够

452
00:16:08,126 --> 0:16:11,156
查找计数并识别出桌面上的骰子

453
00:16:11,196 --> 0:16:13,516
并且判定掷骰的动作已经结束

454
00:16:13,516 --> 0:16:15,486
我们有了很好的基础

455
00:16:15,756 --> 0:16:16,576
可以做更多的事情

456
00:16:17,206 --> 0:16:18,246
接下来是时候谈谈我们

457
00:16:18,246 --> 0:16:19,186
旅程的下一步了

458
00:16:19,976 --> 0:16:22,516
为此我想欢迎 Brent 重返舞台

459
00:16:23,516 --> 0:16:26,036
[鼓掌]

460
00:16:26,536 --> 0:16:30,456
&gt;&gt; 感谢 Scott 好的

461
00:16:30,456 --> 0:16:33,436
正如 Scott 所说

462
00:16:33,436 --> 0:16:34,816
我们的 App 能够识别桌上的骰子

463
00:16:35,906 --> 0:16:36,836
下面我们需要关注的

464
00:16:36,836 --> 0:16:39,426
是我们如何处理用户的输入

465
00:16:39,426 --> 0:16:42,706
我们知道我们的用户将在

466
00:16:42,706 --> 0:16:44,016
我们的 App 中输入数字

467
00:16:44,016 --> 0:16:45,776
因为我们正在练习数学技能

468
00:16:45,846 --> 0:16:48,716
我们可以在屏幕上显示

469
00:16:48,716 --> 0:16:50,146
一个数字板

470
00:16:50,146 --> 0:16:51,386
并让他们点按数字

471
00:16:51,716 --> 0:16:53,816
但我们想要促进用户与 App 之间

472
00:16:53,816 --> 0:16:55,896
更自然的交互

473
00:16:56,146 --> 0:16:58,226
请记住我们的用户是孩子

474
00:16:58,226 --> 0:17:00,116
而这些孩子也正在

475
00:16:58,226 --> 0:17:00,116
而这些孩子也正在

476
00:17:00,116 --> 0:17:01,936
练习书写数字

477
00:17:02,596 --> 0:17:04,846
所以我们想为什么不让

478
00:17:04,846 --> 0:17:06,856
他们直接在屏幕上画呢

479
00:17:06,856 --> 0:17:10,516
要做到这一点

480
00:17:10,516 --> 0:17:11,256
我们需要让我们的 App

481
00:17:11,256 --> 0:17:12,806
能识别手写数字

482
00:17:13,976 --> 0:17:15,506
幸运的是机器学习已经在

483
00:17:15,506 --> 0:17:16,695
解决这一问题上

484
00:17:16,695 --> 0:17:18,786
做得足够好

485
00:17:19,106 --> 0:17:20,236
事实上这里有一个完整的

486
00:17:20,236 --> 0:17:22,156
数据集可供你训练

487
00:17:22,156 --> 0:17:23,205
自己的模型来

488
00:17:23,266 --> 0:17:24,026
识别手写数字

489
00:17:24,026 --> 0:17:25,086
这一模型被称为 MNIST

490
00:17:26,396 --> 0:17:28,185
我们做到了这一点

491
00:17:28,185 --> 0:17:29,726
我们将它放在 Core ML

492
00:17:29,726 --> 0:17:30,406
模型页面上

493
00:17:31,576 --> 0:17:33,346
那么让我们看看如何

494
00:17:33,346 --> 0:17:34,436
在代码中使用这个模型

495
00:17:35,336 --> 0:17:36,396
我们将使用 Vision

496
00:17:36,396 --> 0:17:37,076
和 PencilKit 框架

497
00:17:37,676 --> 0:17:40,696
设置 Vision 来使用 

498
00:17:40,696 --> 0:17:42,226
Core ML 模型

499
00:17:42,226 --> 0:17:43,066
在这里的模型是 MNISTClassifier

500
00:17:43,536 --> 0:17:47,756
接下来我们从 PencilKit canvasViiew

501
00:17:47,756 --> 0:17:48,796
中获取图像

502
00:17:48,966 --> 0:17:52,876
这样我们设置好 Vision 请求处理器

503
00:17:52,876 --> 0:17:54,906
使用该图像

504
00:17:56,356 --> 0:17:59,286
接下来我们执行请求

505
00:17:59,286 --> 0:18:00,076
并得到结果

506
00:17:59,286 --> 0:18:00,076
并得到结果

507
00:18:00,076 --> 0:18:00,976
就是这么简单

508
00:18:03,576 --> 0:18:04,956
所以我们将它集成到我们的模型中

509
00:18:04,956 --> 0:18:08,616
它开始工作得非常好

510
00:18:08,616 --> 0:18:10,716
我们识别了不少

511
00:18:10,716 --> 0:18:11,596
手写的数字

512
00:18:14,276 --> 0:18:15,976
但当我们书写的

513
00:18:15,976 --> 0:18:17,506
数字变大时

514
00:18:17,506 --> 0:18:19,856
我们发现了一些很有趣的东西

515
00:18:19,856 --> 0:18:20,766
我们的模型有时候

516
00:18:20,766 --> 0:18:21,906
会得到错误的预测结果

517
00:18:22,696 --> 0:18:24,566
所以发生了什么

518
00:18:24,946 --> 0:18:27,646
要理解这一点

519
00:18:27,646 --> 0:18:30,706
我们需要查看输入到模型里面的图像

520
00:18:30,706 --> 0:18:33,186
我们可以在 Xcode 里做到这一点

521
00:18:34,286 --> 0:18:36,626
于是我们设置一个

522
00:18:36,626 --> 0:18:38,096
从 PencilKit 中获取图像的断点

523
00:18:38,096 --> 0:18:40,886
然后我们使用 Xcode 的快速预览

524
00:18:41,206 --> 0:18:42,826
来查看实际图像到底是什么

525
00:18:42,956 --> 0:18:44,996
当我们完成这些时

526
00:18:44,996 --> 0:18:47,456
我们看到了一些有趣的东西

527
00:18:47,456 --> 0:18:49,766
示例中的 7 对于模型来说

528
00:18:49,766 --> 0:18:51,126
并不像 7

529
00:18:51,786 --> 0:18:53,446
而是更像 1

530
00:18:54,006 --> 0:18:56,396
那么这里发生了什么

531
00:18:56,396 --> 0:19:00,066
我们需要考虑模型

532
00:18:56,396 --> 0:19:00,066
我们需要考虑模型

533
00:19:00,066 --> 0:19:01,506
对于输入的期望

534
00:19:02,956 --> 0:19:05,506
这个模型期望一个 28 乘以 28

535
00:19:05,506 --> 0:19:08,796
像素的图像

536
00:19:08,796 --> 0:19:10,156
但我们在屏幕上

537
00:19:10,156 --> 0:19:11,846
绘制的数字比这个大得多

538
00:19:13,096 --> 0:19:14,406
所以要获得正确格式的图像

539
00:19:14,456 --> 0:19:15,836
我们需要缩小输入

540
00:19:16,656 --> 0:19:18,716
但当我们缩小它时

541
00:19:18,716 --> 0:19:20,026
就丢失了屏幕上

542
00:19:20,026 --> 0:19:20,836
绘制的笔画的信息

543
00:19:20,836 --> 0:19:23,006
因此我们的 7 开始看起来

544
00:19:23,006 --> 0:19:24,316
更像 1

545
00:19:24,716 --> 0:19:28,376
当我们知道了这一点

546
00:19:28,406 --> 0:19:29,786
修复这个问题就变得简单

547
00:19:29,786 --> 0:19:31,476
我们需要用更粗的笔画

548
00:19:31,556 --> 0:19:35,046
这样的话

549
00:19:35,046 --> 0:19:37,006
我们输入到模型的图像

550
00:19:37,006 --> 0:19:38,806
就更接近于我们在屏幕上

551
00:19:38,806 --> 0:19:39,776
书写的图像

552
00:19:39,776 --> 0:19:41,766
并且此时模型预测出来

553
00:19:41,766 --> 0:19:43,446
的结果也变得更加正确

554
00:19:44,836 --> 0:19:46,616
PencilKit 让这一点变得很容易

555
00:19:47,786 --> 0:19:49,746
在这里我们将

556
00:19:49,746 --> 0:19:51,436
allowsFingerDrawing 设置为真

557
00:19:51,436 --> 0:19:52,726
因为我们用手指在屏幕上书写

558
00:19:52,856 --> 0:19:56,826
然后我们将工具设置为

559
00:19:56,906 --> 0:19:57,976
具有更粗笔画的马克笔

560
00:20:01,356 --> 0:20:04,416
好了 我们的模型现在

561
00:20:05,426 --> 0:20:07,706
可以很好地识别单个数字

562
00:20:08,396 --> 0:20:10,536
但我们还有别的一些挑战

563
00:20:11,396 --> 0:20:13,766
一些数字是以

564
00:20:13,766 --> 0:20:14,976
多个笔画进行书写的

565
00:20:15,506 --> 0:20:19,096
我们的模型提取数字

566
00:20:19,176 --> 0:20:20,796
的静态图像信息

567
00:20:20,796 --> 0:20:21,926
而不是关于该数字的笔画信息

568
00:20:23,016 --> 0:20:24,466
那么我们如何知道何时

569
00:20:24,766 --> 0:20:26,126
提取屏幕上书写的信息

570
00:20:26,196 --> 0:20:28,416
并将信息输入到我们模型中

571
00:20:29,126 --> 0:20:30,276
进行预测呢

572
00:20:30,276 --> 0:20:33,816
此外由于我们要对骰子的示数

573
00:20:33,816 --> 0:20:35,246
进行加法或乘法

574
00:20:35,246 --> 0:20:37,566
我们可能要处理多位数字

575
00:20:37,566 --> 0:20:39,896
而我们的模型只被训练

576
00:20:39,896 --> 0:20:41,116
用于识别单个数字

577
00:20:41,116 --> 0:20:43,236
而非多位数字

578
00:20:44,096 --> 0:20:45,726
那么我们如何处理这样的情况

579
00:20:46,496 --> 0:20:47,586
我们可以用机器学习

580
00:20:47,586 --> 0:20:48,956
来解决这些问题

581
00:20:48,956 --> 0:20:50,456
我们可以训练一个模型

582
00:20:50,456 --> 0:20:51,796
来识别关于数字的笔画信息

583
00:20:51,796 --> 0:20:54,156
或者我们可以训练

584
00:20:54,156 --> 0:20:55,686
一个模型去识别

585
00:20:55,686 --> 0:20:56,936
多位数字

586
00:20:56,986 --> 0:20:58,826
但我们已经知道了

587
00:20:58,826 --> 0:21:00,876
很多关于屏幕上书写内容的信息

588
00:20:58,826 --> 0:21:00,876
很多关于屏幕上书写内容的信息

589
00:21:01,386 --> 0:21:03,236
所以我们不使用机器学习

590
00:21:03,236 --> 0:21:04,576
而是使用程序的方法解决这一问题

591
00:21:04,876 --> 0:21:05,896
让我来向你演示如何做到

592
00:21:06,426 --> 0:21:08,676
我们来看看这个例子吧

593
00:21:09,736 --> 0:21:11,116
有人在屏幕上绘制

594
00:21:11,116 --> 0:21:12,426
1 的第一个笔画

595
00:21:12,426 --> 0:21:15,406
我们把它作为一个图像

596
00:21:15,406 --> 0:21:16,626
传递给我们的模型并得到预测结果

597
00:21:16,626 --> 0:21:17,796
这个结果就是 1 

598
00:21:19,246 --> 0:21:20,766
接下来他们绘制

599
00:21:20,766 --> 0:21:23,766
1 的底部横线

600
00:21:23,966 --> 0:21:25,616
我们看看之后的笔画

601
00:21:25,616 --> 0:21:28,216
是否与前一个笔画重叠

602
00:21:29,086 --> 0:21:30,836
因为发生重叠 所以我们知道

603
00:21:30,836 --> 0:21:32,976
这是同一个数字

604
00:21:32,976 --> 0:21:34,716
于是我们扔掉第一次预测的结果

605
00:21:34,716 --> 0:21:35,916
将第一画与第二画

606
00:21:35,916 --> 0:21:37,756
结合成同一个图片

607
00:21:37,756 --> 0:21:39,296
并将结合后的整张图片

608
00:21:39,296 --> 0:21:40,026
输入给我们的模型

609
00:21:40,136 --> 0:21:42,156
预测的结果为 1 

610
00:21:42,696 --> 0:21:45,536
接下来用户在屏幕上

611
00:21:45,536 --> 0:21:46,326
书写了新的笔画

612
00:21:47,546 --> 0:21:49,176
我们将关注第三个笔画

613
00:21:49,176 --> 0:21:51,926
查看其是否与前两个笔画中的

614
00:21:51,926 --> 0:21:52,876
任何一个重叠

615
00:21:53,746 --> 0:21:55,306
因为没有重叠

616
00:21:55,306 --> 0:21:56,906
我们知道它是一个单独的数字

617
00:21:56,906 --> 0:21:58,226
所以我们将它单独传递给模型

618
00:21:58,226 --> 0:22:02,356
并且预测它是 2 

619
00:21:58,226 --> 0:22:02,356
并且预测它是 2 

620
00:22:02,596 --> 0:22:03,516
现在我想邀请 Scott 回来

621
00:22:03,516 --> 0:22:06,126
在 App 中向你们展示

622
00:22:06,126 --> 0:22:11,416
Scott [鼓掌]

623
00:22:11,916 --> 0:22:15,166
&gt;&gt; 感谢 Brent 现在我们的 App 更新了

624
00:22:15,266 --> 0:22:16,876
它仍然保留对象探测器

625
00:22:16,876 --> 0:22:18,316
用来检测骰子

626
00:22:18,536 --> 0:22:20,716
和分类骰子上的值

627
00:22:21,136 --> 0:22:22,536
但我们还在上面添加了

628
00:22:22,606 --> 0:22:23,856
如 Brent 前面所说的

629
00:22:23,856 --> 0:22:24,486
识别手写输入的功能

630
00:22:25,716 --> 0:22:27,726
所以我觉得是时候做一些计算了

631
00:22:30,276 --> 0:22:31,796
在这里用户可以选择将

632
00:22:31,796 --> 0:22:33,426
骰子的示数

633
00:22:33,426 --> 0:22:34,986
相加或相乘

634
00:22:35,306 --> 0:22:36,726
所以为了简单起见

635
00:22:36,726 --> 0:22:37,816
我将从加法开始

636
00:22:38,426 --> 0:22:40,066
那么让我们看看输入处理

637
00:22:40,066 --> 0:22:45,036
是如何工作的 对了

638
00:22:46,516 --> 0:22:50,626
[鼓掌]

639
00:22:51,126 --> 0:22:53,516
那么如果我们将这些值相乘

640
00:22:53,516 --> 0:22:55,036
我很确定会得到 24

641
00:22:56,036 --> 0:22:57,316
这是一个有趣的数字

642
00:22:57,826 --> 0:22:58,666
我希望你密切关注

643
00:22:58,666 --> 0:23:00,146
当我在屏幕上画 4 时

644
00:22:58,666 --> 0:23:00,146
当我在屏幕上画 4 时

645
00:23:00,146 --> 0:23:01,226
发生了什么

646
00:23:02,756 --> 0:23:04,236
如果你考虑使用

647
00:23:04,236 --> 0:23:06,076
两个笔画书写 4

648
00:23:06,076 --> 0:23:07,086
那我们的模型在只看到

649
00:23:07,086 --> 0:23:08,336
第一个笔画时

650
00:23:08,456 --> 0:23:10,046
将很难识别出 4

651
00:23:10,046 --> 0:23:11,746
所以它可能会预测为其他数字

652
00:23:11,746 --> 0:23:13,966
直到我书写第二个笔画

653
00:23:15,066 --> 0:23:15,626
我们来看一下

654
00:23:21,276 --> 0:23:22,646
你是否注意到了

655
00:23:22,646 --> 0:23:24,046
这里的 4 的第一画被识别成 1 

656
00:23:24,046 --> 0:23:25,676
但当我书写了第二画时

657
00:23:25,726 --> 0:23:27,176
预测的结果立即变成了 4 

658
00:23:27,946 --> 0:23:30,646
有一个答案被设置为

659
00:23:30,716 --> 0:23:33,026
始终正确

660
00:23:33,026 --> 0:23:34,376
我只是想向你们展示更多的 4 

661
00:23:34,546 --> 0:23:34,746
让我们一起来看看

662
00:23:40,426 --> 0:23:43,846
很好 所以我们的 App 可以

663
00:23:43,846 --> 0:23:45,316
识别桌面上的骰子

664
00:23:45,316 --> 0:23:47,576
理解掷骰子行为 检查计算结果

665
00:23:47,576 --> 0:23:50,806
我们可以在屏幕上

666
00:23:50,996 --> 0:23:52,716
绘制数字作为输入

667
00:23:52,716 --> 0:23:53,896
但我们谈论的是将现实世界

668
00:23:53,896 --> 0:23:55,246
和虚拟世界进行融合

669
00:23:55,246 --> 0:23:56,846
所以我们认为

670
00:23:56,846 --> 0:23:58,526
如果孩子们在玩游戏的时候

671
00:23:58,526 --> 0:24:01,036
可以以语音的形式

672
00:23:58,526 --> 0:24:01,036
可以以语音的形式

673
00:24:01,036 --> 0:24:02,606
输入他们的答案

674
00:24:02,606 --> 0:24:04,116
那将会很有趣并且交互性很强

675
00:24:04,786 --> 0:24:07,766
那么让我们来看看

676
00:24:07,766 --> 0:24:09,416
再一次我要将这两个数

677
00:24:09,416 --> 0:24:11,516
运算来得到 24

678
00:24:11,926 --> 0:24:13,646
然后让我们用语音来做

679
00:24:14,906 --> 0:24:18,466
24 酷

680
00:24:21,276 --> 0:24:22,686
使用 Speech 框架

681
00:24:22,686 --> 0:24:23,396
让这一点变得非常容易

682
00:24:23,966 --> 0:24:29,836
今年我们在语音方面

683
00:24:29,836 --> 0:24:32,166
添加了离线语音识别

684
00:24:33,096 --> 0:24:34,406
这意味着即使你的设备

685
00:24:34,406 --> 0:24:35,756
未连接到互联网

686
00:24:36,126 --> 0:24:37,566
语音识别也可以

687
00:24:37,566 --> 0:24:38,516
在你的 App 中使用

688
00:24:39,566 --> 0:24:41,586
如果你希望将用户的数据

689
00:24:41,586 --> 0:24:43,746
保留在他们的设备上

690
00:24:43,746 --> 0:24:45,696
你实际上可以通过

691
00:24:45,696 --> 0:24:47,236
将语音识别器中的

692
00:24:47,236 --> 0:24:48,226
requiresOnDeviceRecognition

693
00:24:48,506 --> 0:24:50,026
设置为 true 来要求

694
00:24:50,026 --> 0:24:50,946
在设备上进行语音识别

695
00:24:54,406 --> 0:24:56,326
所以现在我们的 App 可以理解

696
00:24:56,326 --> 0:24:58,206
掷骰子行为

697
00:24:58,206 --> 0:25:00,716
并处理不同的输入形式

698
00:24:58,206 --> 0:25:00,716
并处理不同的输入形式

699
00:25:00,716 --> 0:25:02,706
但我们需要继续我们的旅程

700
00:25:02,796 --> 0:25:04,856
并完成任务

701
00:25:05,116 --> 0:25:06,206
所以我想欢迎

702
00:25:06,206 --> 0:25:06,956
Brent 重返舞台

703
00:25:07,516 --> 0:25:10,536
[鼓掌]

704
00:25:11,036 --> 0:25:11,546
&gt;&gt; 感谢你 Scott

705
00:25:17,576 --> 0:25:21,566
正如 Scott 所说

706
00:25:21,566 --> 0:25:24,616
我们的 App 可以识别骰子

707
00:25:24,616 --> 0:25:26,696
并且我们知道如何处理用户的输入

708
00:25:27,366 --> 0:25:29,896
但我们说这是一个游戏 对吧

709
00:25:30,626 --> 0:25:34,026
为了做到这一点

710
00:25:34,026 --> 0:25:36,066
接下来我们将整合 ARKit

711
00:25:36,066 --> 0:25:39,116
真正完成整个体验

712
00:25:39,666 --> 0:25:45,266
当然任何游戏都需要规则

713
00:25:45,546 --> 0:25:48,566
所以让我们先来看看规则

714
00:25:50,416 --> 0:25:52,706
我们的比赛是在一个

715
00:25:52,706 --> 0:25:54,516
分成九份的圆形板上进行的

716
00:25:55,206 --> 0:25:58,026
每个玩家从第一部分开始

717
00:25:58,026 --> 0:26:00,606
目标是围绕棋盘

718
00:25:58,026 --> 0:26:00,606
目标是围绕棋盘

719
00:26:00,606 --> 0:26:02,486
顺时针移动

720
00:26:02,486 --> 0:26:04,666
并刚好停在第九部分

721
00:26:05,286 --> 0:26:09,536
掷的数太小

722
00:26:09,536 --> 0:26:11,226
会让你走的不够远

723
00:26:12,656 --> 0:26:14,556
掷的数太大

724
00:26:14,556 --> 0:26:18,706
你就会越过你的目标

725
00:26:18,906 --> 0:26:20,256
在每个玩家的回合中

726
00:26:20,256 --> 0:26:22,616
他们掷骰子并且有两个选择

727
00:26:22,616 --> 0:26:25,496
他们可以取

728
00:26:25,496 --> 0:26:27,516
骰子的和

729
00:26:27,516 --> 0:26:28,836
并沿顺时针方向移动该数字

730
00:26:29,666 --> 0:26:30,856
或者他们可以取

731
00:26:30,856 --> 0:26:33,006
骰子顶部数字的差

732
00:26:33,046 --> 0:26:33,926
并沿顺时针方向移动该数字

733
00:26:35,166 --> 0:26:38,426
那么 Scott 你想要来比一比吗

734
00:26:39,516 --> 0:26:43,500
[鼓掌]

735
00:26:50,356 --> 0:26:51,496
&gt;&gt; 那么现在我们将

736
00:26:51,496 --> 0:26:53,766
虚拟棋盘集成到 ARKit 游戏中

737
00:26:53,806 --> 0:26:57,366
并且利用 Core ML 来识别骰子

738
00:26:58,036 --> 0:26:59,366
由 Brent 你来开始怎么样

739
00:26:59,666 --> 0:27:02,456
&gt;&gt; 听上去不错 好的

740
00:26:59,666 --> 0:27:02,456
&gt;&gt; 听上去不错 好的

741
00:27:02,976 --> 0:27:06,356
5 我掷到的数是 5 和 2

742
00:27:06,356 --> 0:27:09,976
很好 我认为我应该把这些数字加起来

743
00:27:15,376 --> 0:27:17,656
&gt;&gt; 很好 噢你已经接近终点了

744
00:27:17,726 --> 0:27:17,976
&gt;&gt; 很接近了

745
00:27:22,056 --> 0:27:24,996
&gt;&gt; 那么我掷了 6 和 1

746
00:27:24,996 --> 0:27:27,116
我可以将数字相减得到 5

747
00:27:27,186 --> 0:27:29,436
或者将其相加与 Brent 在 8 会合

748
00:27:29,436 --> 0:27:30,966
让我们把这些数加起来

749
00:27:37,796 --> 0:27:38,276
&gt;&gt; 很好

750
00:27:38,516 --> 0:27:42,626
我不认为 我会掷出 1

751
00:27:42,626 --> 0:27:49,826
让我们来看看 这次我要做减法 得到的是 2

752
00:27:59,676 --> 0:28:01,446
&gt;&gt; 好吧我再次掷出 6 和 1

753
00:27:59,676 --> 0:28:01,446
&gt;&gt; 好吧我再次掷出 6 和 1

754
00:28:01,686 --> 0:28:02,746
这一次我也做减法

755
00:28:02,746 --> 0:28:04,546
然后用它们得到 5 

756
00:28:05,506 --> 0:28:07,746
Brent 认为

757
00:28:08,866 --> 0:28:10,066
我画的 5 很好笑

758
00:28:10,926 --> 0:28:13,946
&gt;&gt; 你知道这个游戏可能

759
00:28:13,946 --> 0:28:16,496
会持续非常长的时间

760
00:28:16,986 --> 0:28:18,876
我认为 Scott 已经提到了

761
00:28:18,876 --> 0:28:20,786
一个始终正确的数字

762
00:28:20,786 --> 0:28:23,366
接下来让我们看看

763
00:28:23,366 --> 0:28:23,926
这个数字在游戏里是否奏效

764
00:28:28,326 --> 0:28:31,536
&gt;&gt; Brent 你发现了秘密 干得好

765
00:28:31,776 --> 0:28:37,500
&gt;&gt; 成功了 [鼓掌]

766
00:28:43,626 --> 0:28:47,466
很好 我们将多种技术结合在一起

767
00:28:47,516 --> 0:28:49,686
以将我们的物理

768
00:28:49,806 --> 0:28:52,186
和虚拟世界融合

769
00:28:53,436 --> 0:28:54,686
我们建立了超越

770
00:28:54,686 --> 0:28:56,566
任何单一技术的体验

771
00:28:57,016 --> 0:28:58,646
它让我们在这个增强的新世界中

772
00:28:58,646 --> 0:28:59,996
玩这个有趣的游戏

773
00:29:01,366 --> 0:29:03,606
我们使用对象检测

774
00:29:03,606 --> 0:29:07,326
来识别桌子上的骰子

775
00:29:07,466 --> 0:29:09,476
我们使用图像分类

776
00:29:09,476 --> 0:29:11,706
来识别屏幕上的手写数字

777
00:29:12,916 --> 0:29:14,556
我们使用语音识别作为

778
00:29:14,556 --> 0:29:15,886
与我们的 App 互动的另一种方式

779
00:29:16,266 --> 0:29:18,636
我们引入了 ARKit 

780
00:29:18,636 --> 0:29:20,666
来真正完成整个体验

781
00:29:22,376 --> 0:29:23,996
如果你想了解更多信息

782
00:29:24,766 --> 0:29:28,616
请参阅开发者网站上的 228 号会议

783
00:29:28,676 --> 0:29:30,096
或明天在实验室与我们联系

784
00:29:30,716 --> 0:29:32,756
感谢各位 并祝各位能够享受余下的会议

785
00:29:33,508 --> 0:29:35,508
[鼓掌]
