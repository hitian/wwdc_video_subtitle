1
00:00:00,506 --> 0:00:05,500
[音乐]

2
00:00:10,516 --> 0:00:13,566
[掌声]

3
00:00:14,066 --> 0:00:15,196
&gt;&gt; 大家好

4
00:00:16,146 --> 0:00:17,296
欢迎参加今天的 Metal 会议

5
00:00:18,096 --> 0:00:18,996
我是 Lionel

6
00:00:19,076 --> 0:00:20,386
我是 Apple 的 GPU

7
00:00:20,386 --> 0:00:21,766
软件性能团队中的一员

8
00:00:22,736 --> 0:00:25,546
我将与我的朋友 Max 和 Sarah 一起

9
00:00:25,546 --> 0:00:27,066
指导你如何将

10
00:00:27,066 --> 0:00:29,636
OpenGL App 带到 Metal 中

11
00:00:30,326 --> 0:00:33,496
去年 我们宣布

12
00:00:33,606 --> 0:00:36,936
OpenGL OpenGL ES 和 OpenCL

13
00:00:37,056 --> 0:00:37,966
都是不推荐的

14
00:00:38,976 --> 0:00:39,926
iOS 13 和 macOS Catalina

15
00:00:39,926 --> 0:00:43,436
将继续支持它们

16
00:00:43,436 --> 0:00:46,746
但现在是时候向前一步了

17
00:00:47,926 --> 0:00:49,476
新项目应该从一开始

18
00:00:49,476 --> 0:00:50,436
就以 Metal 为目标

19
00:00:50,816 --> 0:00:52,496
但如果你有一个

20
00:00:52,826 --> 0:00:54,176
想要移植到 Metal 的 OpenGL App

21
00:00:54,716 --> 0:00:57,696
那你就来对地方了

22
00:00:58,266 --> 0:00:59,836
我们在 2014 年

23
00:00:59,936 --> 0:01:03,266
首次引入 Metal

24
00:00:59,936 --> 0:01:03,266
首次引入 Metal

25
00:01:03,546 --> 0:01:04,635
作为我们全新的

26
00:01:04,926 --> 0:01:07,266
低成本 高效率 高性能的 GPU 编程 API

27
00:01:07,726 --> 0:01:10,936
在过去的五年里

28
00:01:11,386 --> 0:01:13,726
Apple 的核心框架

29
00:01:13,726 --> 0:01:15,706
一直采用 Metal

30
00:01:15,706 --> 0:01:17,146
并且取得了非常好的效果

31
00:01:17,586 --> 0:01:19,306
如果你的 App

32
00:01:19,306 --> 0:01:21,216
构建在 SpriteKit

33
00:01:21,546 --> 0:01:23,846
SceneKit RealityKit Core Image

34
00:01:23,846 --> 0:01:25,616
Core Animation 等层之上

35
00:01:25,616 --> 0:01:26,666
那么你已经在使用 Metal 了

36
00:01:28,796 --> 0:01:30,326
我们还与 Unity

37
00:01:30,326 --> 0:01:31,986
Unreal Engine 4 和 Lumberyard 等

38
00:01:31,986 --> 0:01:34,036
引擎厂商紧密合作

39
00:01:34,036 --> 0:01:37,326
以充分利用 Metal 的优势

40
00:01:37,836 --> 0:01:38,846
如果你正在使用这些引擎之一

41
00:01:38,846 --> 0:01:41,836
那么你已经赶上了速度

42
00:01:45,316 --> 0:01:47,656
如果你已经建立了

43
00:01:47,656 --> 0:01:49,656
自己的渲染器

44
00:01:49,656 --> 0:01:50,946
那么 Metal 会给你带来很多优势

45
00:01:51,926 --> 0:01:54,036
Metal 将 OpenGL 的图形

46
00:01:54,036 --> 0:01:56,376
和 OpenCL 的计算结合成

47
00:01:56,516 --> 0:01:57,816
一个统一的 API

48
00:01:59,336 --> 0:02:01,436
它允许你在 App 中使用

49
00:01:59,336 --> 0:02:01,436
它允许你在 App 中使用

50
00:02:01,436 --> 0:02:02,936
多线程渲染

51
00:02:04,136 --> 0:02:05,766
每当有繁复的 CPU 操作

52
00:02:05,766 --> 0:02:07,226
需要执行时

53
00:02:07,226 --> 0:02:09,096
我们都会确保这些操作

54
00:02:09,096 --> 0:02:10,366
尽可能不频繁地发生

55
00:02:10,366 --> 0:02:11,876
以减少 App

56
00:02:11,876 --> 0:02:14,616
在执行期间的消耗

57
00:02:16,666 --> 0:02:18,746
Metal 的着色语言

58
00:02:18,796 --> 0:02:20,756
是基于 C++ 的

59
00:02:20,756 --> 0:02:23,036
App 中使用的所有着色器

60
00:02:23,036 --> 0:02:25,176
都可以预编译

61
00:02:25,176 --> 0:02:27,586
例如 你可以更容易地拥有

62
00:02:27,586 --> 0:02:28,556
各种材料的着色器

63
00:02:29,066 --> 0:02:32,056
最后同样重要的是

64
00:02:32,056 --> 0:02:33,786
我们在 Xcode 中

65
00:02:33,786 --> 0:02:36,426
构建了一整套调试和优化工具

66
00:02:37,936 --> 0:02:39,316
因此 一旦你将其移植到 Metal

67
00:02:39,316 --> 0:02:40,936
你就拥有了使你的 App

68
00:02:40,936 --> 0:02:42,656
更好运行的全部支持

69
00:02:43,786 --> 0:02:46,826
让我们开始吧 在本会议中

70
00:02:46,826 --> 0:02:48,046
我们将看看从 GL

71
00:02:48,046 --> 0:02:51,376
迁移到 Metal 的步骤

72
00:02:51,376 --> 0:02:52,906
并将典型的 GL App 与 Metal App

73
00:02:52,906 --> 0:02:57,286
进行比较

74
00:02:57,706 --> 0:03:00,076
作为概述

75
00:02:57,706 --> 0:03:00,076
作为概述

76
00:03:00,736 --> 0:03:03,036
让我们快速浏览一下 GL App 的步骤

77
00:03:03,996 --> 0:03:06,686
首先 你需要设立一个窗口

78
00:03:06,686 --> 0:03:07,656
用于渲染

79
00:03:08,326 --> 0:03:09,716
然后创建缓冲区

80
00:03:09,716 --> 0:03:11,806
纹理和采样器等资源

81
00:03:12,536 --> 0:03:13,866
你可以实现所有

82
00:03:14,146 --> 0:03:15,276
用 GLSL 编写的着色器

83
00:03:16,466 --> 0:03:17,726
在你可以在 GL 中

84
00:03:17,726 --> 0:03:19,126
渲染任何东西之前

85
00:03:19,126 --> 0:03:20,746
你需要创建特定的对象状态

86
00:03:20,746 --> 0:03:22,216
比如 GL 程序

87
00:03:22,216 --> 0:03:24,736
GL 帧缓冲对象 顶点数组对象

88
00:03:25,976 --> 0:03:28,026
一旦你初始化了

89
00:03:28,106 --> 0:03:30,416
渲染循环就开始了

90
00:03:30,416 --> 0:03:32,646
你的资源就会开始绘制你的帧

91
00:03:33,356 --> 0:03:35,206
对于每个帧

92
00:03:35,206 --> 0:03:38,046
你要首先更新资源

93
00:03:38,046 --> 0:03:40,346
绑定特定的帧缓冲区

94
00:03:40,346 --> 0:03:42,526
设置图形状态并进行绘制调用

95
00:03:43,536 --> 0:03:44,756
对每个帧缓冲区

96
00:03:44,756 --> 0:03:46,156
都重复此过程

97
00:03:46,416 --> 0:03:47,816
你可能有阴影贴图

98
00:03:47,816 --> 0:03:49,906
光照通道 一些后期处理

99
00:03:50,486 --> 0:03:53,396
可能有相当多的渲染通道

100
00:03:53,936 --> 0:04:00,376
最后 呈现最终渲染出的图像十分简单

101
00:03:53,936 --> 0:04:00,376
最后 呈现最终渲染出的图像十分简单

102
00:04:01,436 --> 0:04:02,646
正如你所看到的

103
00:04:02,646 --> 0:04:04,226
Metal 流程看起来非常相似

104
00:04:04,976 --> 0:04:06,656
我们更新了一些原始的概念

105
00:04:06,656 --> 0:04:09,216
并引入了一些新的东西

106
00:04:09,446 --> 0:04:12,416
但总的来说 流程基本相同

107
00:04:12,626 --> 0:04:13,936
它不是对引擎的完全重写

108
00:04:13,936 --> 0:04:17,305
它以同样的方式工作

109
00:04:18,995 --> 0:04:21,625
我们将重新引入新的概念

110
00:04:21,625 --> 0:04:23,366
同时在 GL 和 Metal 之间

111
00:04:23,366 --> 0:04:26,216
画出平行线

112
00:04:26,216 --> 0:04:28,206
比较和对比这两个 API

113
00:04:28,206 --> 0:04:30,276
以帮助你成功地进行转换

114
00:04:30,846 --> 0:04:34,436
当你浏览

115
00:04:34,436 --> 0:04:36,496
任何的图形教程时

116
00:04:36,566 --> 0:04:39,396
首先要学习的是

117
00:04:39,636 --> 0:04:41,586
如何创建和绘制窗口

118
00:04:42,476 --> 0:04:44,046
让我们从窗口子系统开始

119
00:04:44,426 --> 0:04:45,726
GL 和 Metal 都有这个概念

120
00:04:45,726 --> 0:04:48,716
但是实现的方式略有不同

121
00:04:49,316 --> 0:04:52,226
需要对 App 设置

122
00:04:52,226 --> 0:04:54,006
并渲染一个绘图面

123
00:04:54,076 --> 0:04:55,576
视图和视图委托

124
00:04:55,606 --> 0:04:57,396
管理 API 和底层窗口系统

125
00:04:57,396 --> 0:04:59,636
之间的接口

126
00:04:59,636 --> 0:05:02,726
你可能正在使用这些框架

127
00:04:59,636 --> 0:05:02,726
你可能正在使用这些框架

128
00:05:02,726 --> 0:05:04,786
来管理 GL 视图

129
00:05:04,786 --> 0:05:06,196
我们在 Metal 中

130
00:05:06,246 --> 0:05:07,336
也有类似的框架

131
00:05:08,466 --> 0:05:12,366
NSOpenGLView 和 GLKView 映射到 MTKView

132
00:05:13,156 --> 0:05:14,306
如果你在你的 App 中

133
00:05:14,306 --> 0:05:15,866
通过 EAGLLayer

134
00:05:15,866 --> 0:05:17,636
使用 Core Animation

135
00:05:17,636 --> 0:05:19,416
那么有一个等价的 CAMetalLayer

136
00:05:19,416 --> 0:05:24,266
例如 假设你正在使用 GLKView

137
00:05:25,566 --> 0:05:27,976
它有一个单一的入口点与提取率

138
00:05:28,336 --> 0:05:29,646
你需要它来检查

139
00:05:29,646 --> 0:05:31,366
目标的分辨率

140
00:05:31,366 --> 0:05:32,876
自上一帧以来是否发生变化

141
00:05:32,996 --> 0:05:34,616
根据需要 从渲染循环中

142
00:05:34,876 --> 0:05:37,136
更新渲染目标的大小

143
00:05:38,496 --> 0:05:40,456
在 MetalKit 中有一点更新

144
00:05:40,456 --> 0:05:41,686
当 drawable 需要更改时

145
00:05:41,686 --> 0:05:44,706
例如当你旋转屏幕

146
00:05:44,706 --> 0:05:45,806
或调整窗口大小时

147
00:05:45,806 --> 0:05:48,136
有一个单独的函数进行处理

148
00:05:48,456 --> 0:05:49,876
所以你不需要检查

149
00:05:49,876 --> 0:05:51,036
你的资源是否需要

150
00:05:51,036 --> 0:05:54,076
在你的 draw 函数中重新分配

151
00:05:54,076 --> 0:05:55,956
它致力于渲染代码

152
00:05:59,276 --> 0:06:00,396
如果你需要额外的灵活性

153
00:05:59,276 --> 0:06:00,396
如果你需要额外的灵活性

154
00:06:00,396 --> 0:06:02,236
我们提供 CAMetalLayer

155
00:06:02,286 --> 0:06:05,556
你可以将其

156
00:06:05,596 --> 0:06:07,466
用作视图的支持层

157
00:06:08,876 --> 0:06:11,216
CAEAGLLayer 定义了

158
00:06:11,216 --> 0:06:12,576
可绘制的属性

159
00:06:12,656 --> 0:06:15,636
比如颜色格式

160
00:06:15,636 --> 0:06:18,186
CAMetalLayer 允许设置

161
00:06:18,186 --> 0:06:20,616
drawable 尺寸

162
00:06:20,616 --> 0:06:22,176
像素格式 颜色空间等等

163
00:06:23,146 --> 0:06:25,056
重要的是

164
00:06:25,056 --> 0:06:28,016
CAMetalLayer 保有一个纹理库

165
00:06:28,016 --> 0:06:29,646
你可以调用下一个 drawable

166
00:06:29,646 --> 0:06:31,206
从而获取 drawable 来渲染你的帧

167
00:06:31,586 --> 0:06:32,846
这是一个很重要的概念

168
00:06:32,846 --> 0:06:34,646
我们会在需要的时候

169
00:06:34,896 --> 0:06:37,876
再回顾一下

170
00:06:37,976 --> 0:06:38,986
现在我们有一个窗口

171
00:06:39,546 --> 0:06:42,066
接下来我们要介绍一些

172
00:06:42,066 --> 0:06:43,286
Metal 中的新概念

173
00:06:43,536 --> 0:06:45,006
命令队列

174
00:06:45,006 --> 0:06:46,396
命令缓冲区 命令编码器

175
00:06:46,976 --> 0:06:48,896
这些对象在 Metal 中协同工作

176
00:06:48,896 --> 0:06:50,626
并向 GPU 提交工作

177
00:06:51,436 --> 0:06:52,616
它们是新的

178
00:06:52,616 --> 0:06:55,056
因为底层的 GL Context

179
00:06:55,166 --> 0:06:56,366
为你管理着提交

180
00:06:56,366 --> 0:07:02,096
GL 是一个隐式 API

181
00:06:56,366 --> 0:07:02,096
GL 是一个隐式 API

182
00:07:02,096 --> 0:07:03,596
这意味着没有代码告诉 GL

183
00:07:03,596 --> 0:07:06,406
何时调度工作

184
00:07:06,676 --> 0:07:08,126
作为开发者

185
00:07:08,126 --> 0:07:09,626
你几乎无法控制

186
00:07:09,626 --> 0:07:11,586
图形工作何时真正发生

187
00:07:11,746 --> 0:07:13,376
比如何时编译着色器

188
00:07:13,376 --> 0:07:15,436
何时分配资源存储

189
00:07:15,436 --> 0:07:18,236
何时进行验证

190
00:07:18,236 --> 0:07:20,366
或者何时将工作

191
00:07:20,366 --> 0:07:21,576
真正地提交给 GPU

192
00:07:22,106 --> 0:07:24,106
GL Context 是一个

193
00:07:24,106 --> 0:07:25,026
大型的状态机器

194
00:07:25,026 --> 0:07:26,656
典型的工作流应该是这样的

195
00:07:27,306 --> 0:07:28,886
你的 App 创建一个 GL Context

196
00:07:28,886 --> 0:07:31,056
在线程上设置它

197
00:07:31,126 --> 0:07:33,676
然后调用任意的 GL 注释

198
00:07:34,276 --> 0:07:35,556
注释由底层的

199
00:07:35,586 --> 0:07:37,106
上下文记录

200
00:07:37,106 --> 0:07:39,056
并将在某个时间点执行

201
00:07:39,846 --> 0:07:40,966
让我们仔细看看

202
00:07:40,966 --> 0:07:41,866
到底发生了什么

203
00:07:43,186 --> 0:07:46,056
假设你的 App 只是发送 GL

204
00:07:46,056 --> 0:07:47,856
这些调用

205
00:07:47,856 --> 0:07:49,356
一些状态变化 一些 draw 调用

206
00:07:50,096 --> 0:07:51,236
在一个完美的场景中

207
00:07:51,236 --> 0:07:52,686
上下文会将其

208
00:07:52,966 --> 0:07:54,676
转换为 GPU 注释

209
00:07:54,676 --> 0:07:55,726
来填充内部缓冲区

210
00:07:56,126 --> 0:07:57,436
然后当它满了的时候

211
00:07:57,436 --> 0:07:58,786
它会把它发送到 GPU

212
00:07:59,566 --> 0:08:02,276
如果你插入一个 glFlush

213
00:07:59,566 --> 0:08:02,276
如果你插入一个 glFlush

214
00:08:02,276 --> 0:08:03,856
来强制执行

215
00:08:03,856 --> 0:08:05,876
你肯定知道它们就会在那个时候启动

216
00:08:06,456 --> 0:08:07,606
但实际上

217
00:08:07,606 --> 0:08:09,626
GPU 可以在任何时候提前开始执行

218
00:08:10,706 --> 0:08:12,766
好的 例如

219
00:08:12,766 --> 0:08:14,376
如果我们改变一个

220
00:08:14,376 --> 0:08:16,356
引入每个依赖项的绘制调用

221
00:08:16,356 --> 0:08:18,306
突然执行就会在那个时候启动

222
00:08:18,306 --> 0:08:20,036
你可能会遭受大量的停滞

223
00:08:21,476 --> 0:08:22,686
我们不得不再一次发问

224
00:08:22,686 --> 0:08:23,896
应该什么时候提交工作呢

225
00:08:23,896 --> 0:08:25,386
视情况而定

226
00:08:25,686 --> 0:08:28,956
这就是 OpenGL 的缺点之一

227
00:08:28,956 --> 0:08:30,946
性能不稳定

228
00:08:31,456 --> 0:08:33,366
任何一个小小的改变都可能

229
00:08:33,366 --> 0:08:35,676
迫使你偏离正轨

230
00:08:36,265 --> 0:08:37,916
另一方面 Metal

231
00:08:37,916 --> 0:08:39,785
是一个显式的 API

232
00:08:39,785 --> 0:08:41,256
这意味着 App 可以决定

233
00:08:41,256 --> 0:08:43,905
什么时候

234
00:08:43,986 --> 0:08:46,856
向 GPU 发送什么工作

235
00:08:47,576 --> 0:08:49,066
Metal 将 GL Context 的概念

236
00:08:49,066 --> 0:08:53,136
分解为内部工作对象的集合

237
00:08:54,026 --> 0:08:55,996
App 创建的第一个对象

238
00:08:56,766 --> 0:08:59,646
是一个 metalDevice 对象

239
00:08:59,646 --> 0:09:00,806
它是 GPU 的

240
00:08:59,646 --> 0:09:00,806
它是 GPU 的

241
00:09:01,296 --> 0:09:02,676
抽象表示

242
00:09:03,276 --> 0:09:05,666
然后 它创建一个名为

243
00:09:05,666 --> 0:09:07,006
metalCommandQueue 的键对象

244
00:09:07,656 --> 0:09:08,696
metalCommandQueue

245
00:09:08,696 --> 0:09:11,426
通过分配要填充的命令缓冲区

246
00:09:11,546 --> 0:09:13,556
来维护发送给 GPU 的

247
00:09:13,906 --> 0:09:15,016
命令的顺序

248
00:09:15,566 --> 0:09:18,596
而命令缓冲区只是一个

249
00:09:18,596 --> 0:09:19,916
GPU 命令列表

250
00:09:19,976 --> 0:09:22,106
你的 App 将填补发送给 GPU 执行

251
00:09:22,996 --> 0:09:24,286
在我们刚刚学习的 GL 例子中

252
00:09:24,286 --> 0:09:26,086
我们同样在 GL 中看到了

253
00:09:26,086 --> 0:09:27,126
这个命令缓冲区的概念

254
00:09:28,156 --> 0:09:29,536
让我们从现在开始

255
00:09:29,536 --> 0:09:32,746
处理这个命令缓冲区

256
00:09:33,066 --> 0:09:34,406
App 不会直接将命令

257
00:09:34,406 --> 0:09:35,976
写入命令缓冲区

258
00:09:35,976 --> 0:09:38,856
相反 它会创建一个

259
00:09:38,856 --> 0:09:40,016
Metal 命令编码器

260
00:09:40,886 --> 0:09:42,096
让我们看看主要的

261
00:09:42,096 --> 0:09:43,356
三种编码器

262
00:09:44,406 --> 0:09:46,236
我们使用的第一个编码器

263
00:09:46,236 --> 0:09:48,206
将充满用于复制周围资源的

264
00:09:48,206 --> 0:09:50,216
blit 命令

265
00:09:50,816 --> 0:09:53,816
这个命令编码器将 API 代码

266
00:09:53,866 --> 0:09:56,236
转换成 GPU 指令

267
00:09:56,666 --> 0:09:58,476
然后将它们写入命令缓冲区

268
00:09:59,286 --> 0:10:00,596
在一系列的命令被编码之后

269
00:09:59,286 --> 0:10:00,596
在一系列的命令被编码之后

270
00:10:00,596 --> 0:10:01,946
例如

271
00:10:01,946 --> 0:10:03,216
一系列的 blit 命令用于复制资源

272
00:10:03,216 --> 0:10:05,136
你的 App 将结束编码

273
00:10:05,136 --> 0:10:08,676
这将释放 encoder 对象

274
00:10:10,676 --> 0:10:13,136
此外 Metal 还支持

275
00:10:13,136 --> 0:10:14,786
一个计算编码器

276
00:10:14,786 --> 0:10:16,056
用于进行通常在 OpenCL 中

277
00:10:16,056 --> 0:10:17,876
已经完成的并行工作

278
00:10:19,056 --> 0:10:21,196
你需要将一些内核放入队列

279
00:10:22,096 --> 0:10:23,496
这些内核会被写入命令缓冲区

280
00:10:23,496 --> 0:10:25,046
然后你运行编码器

281
00:10:25,046 --> 0:10:26,746
并释放它

282
00:10:28,196 --> 0:10:30,336
最后 让我们使用渲染编码器

283
00:10:30,336 --> 0:10:32,936
执行你熟悉的渲染命令

284
00:10:34,336 --> 0:10:35,776
你可以对状态更改和绘制调用进行排队

285
00:10:35,776 --> 0:10:38,536
并结束编码器

286
00:10:41,356 --> 0:10:43,816
这里我们有一个充满

287
00:10:44,116 --> 0:10:45,696
不同工作负载的命令缓冲区

288
00:10:45,696 --> 0:10:47,556
但是 GPU 还没有做任何工作

289
00:10:48,346 --> 0:10:50,246
Metal 在 CPU 中

290
00:10:50,586 --> 0:10:53,036
创建了对象并编码了命令

291
00:10:53,956 --> 0:10:55,516
只有在 App

292
00:10:55,566 --> 0:10:56,946
完成注释编码

293
00:10:57,136 --> 0:10:58,556
并显式提交命令缓冲区之后

294
00:10:58,556 --> 0:11:00,456
GPU 才开始工作

295
00:10:58,556 --> 0:11:00,456
GPU 才开始工作

296
00:11:00,456 --> 0:11:03,186
并执行这些命令

297
00:11:04,376 --> 0:11:05,516
现在 我们已经编码了命令

298
00:11:05,516 --> 0:11:08,366
让我们比较

299
00:11:08,366 --> 0:11:10,996
GL 和 Metal 的命令提交

300
00:11:12,176 --> 0:11:14,006
在 GL 中 没有对工作

301
00:11:14,006 --> 0:11:16,006
何时提交给 GPU 的直接控制

302
00:11:16,006 --> 0:11:17,586
你依赖于像 glFlush

303
00:11:17,586 --> 0:11:19,456
和 glFinish 这样的字锤

304
00:11:19,456 --> 0:11:20,706
来确保代码执行

305
00:11:20,706 --> 0:11:23,196
glFlush 提交命令

306
00:11:23,196 --> 0:11:25,306
并提交 CPU 线程

307
00:11:25,306 --> 0:11:26,836
直到它们被调度

308
00:11:27,226 --> 0:11:28,806
glFinish 提交 CPU 线程

309
00:11:28,806 --> 0:11:31,586
直到 GPU 完全完成

310
00:11:32,716 --> 0:11:34,466
在这些命令发生之前

311
00:11:34,466 --> 0:11:35,936
仍然可以在任何时候提交工作

312
00:11:35,936 --> 0:11:38,096
从而导致

313
00:11:38,096 --> 0:11:39,626
潜在的停滞和减速

314
00:11:40,416 --> 0:11:42,536
Metal 也有类似的功能

315
00:11:42,536 --> 0:11:43,786
你仍然可以

316
00:11:43,786 --> 0:11:45,386
显式地提交

317
00:11:45,386 --> 0:11:46,896
并等待命令缓冲区的

318
00:11:46,896 --> 0:11:48,126
调度或完成

319
00:11:48,636 --> 0:11:51,156
但除非绝对需要

320
00:11:51,156 --> 0:11:52,976
否则不建议

321
00:11:52,976 --> 0:11:55,396
使用这些等待命令

322
00:11:55,576 --> 0:11:56,956
相反 我们建议你

323
00:11:56,956 --> 0:11:58,526
只需提交你的命令缓冲区

324
00:11:58,526 --> 0:12:01,356
然后添加一个回调函数

325
00:11:58,526 --> 0:12:01,356
然后添加一个回调函数

326
00:12:01,356 --> 0:12:02,786
以便稍后当命令缓冲区

327
00:12:02,786 --> 0:12:04,466
在 GPU 上完成时

328
00:12:04,466 --> 0:12:06,376
你的 App 可以得到通知

329
00:12:07,106 --> 0:12:08,976
这将释放你的 CPU

330
00:12:08,976 --> 0:12:09,886
来继续其他工作

331
00:12:10,486 --> 0:12:14,606
现在 我们已经回顾了

332
00:12:15,006 --> 0:12:16,686
命令队列 命令缓冲区

333
00:12:16,936 --> 0:12:19,036
命令编码器

334
00:12:19,336 --> 0:12:20,836
接下来我们讨论资源创建

335
00:12:23,196 --> 0:12:25,206
任何图形 App

336
00:12:25,206 --> 0:12:28,206
都可能使用三种

337
00:12:28,206 --> 0:12:30,166
主要类型的资源

338
00:12:30,476 --> 0:12:31,906
缓冲区 纹理 采样器

339
00:12:32,666 --> 0:12:34,426
我们先来看看缓冲区

340
00:12:35,476 --> 0:12:37,426
在 GL 中 你有一个缓冲区对象

341
00:12:37,576 --> 0:12:39,146
和与其关联的内存

342
00:12:39,716 --> 0:12:42,536
你使用的 API 代码

343
00:12:42,536 --> 0:12:45,756
可以同时或分别修改对象状态内存

344
00:12:46,366 --> 0:12:50,186
例如

345
00:12:50,186 --> 0:12:51,826
这里可以使用 glBufferData

346
00:12:51,826 --> 0:12:54,886
修改内存和对象的状态

347
00:12:55,666 --> 0:12:56,986
稍后可以通过

348
00:12:56,986 --> 0:12:58,936
调用 glBufferData

349
00:12:58,936 --> 0:13:01,696
再次修改缓冲区维度

350
00:12:58,936 --> 0:13:01,696
再次修改缓冲区维度

351
00:13:01,696 --> 0:13:03,726
在这种情况下

352
00:13:03,726 --> 0:13:06,216
旧对象及其内容将被 OpenGL 在内部丢弃

353
00:13:06,816 --> 0:13:11,036
在 Metal 中

354
00:13:11,036 --> 0:13:12,416
创建和填充缓冲区的 API

355
00:13:12,416 --> 0:13:14,406
看起来非常相似

356
00:13:14,406 --> 0:13:16,336
但主要的区别在于

357
00:13:16,336 --> 0:13:18,186
生成的主题是不可变的

358
00:13:18,556 --> 0:13:20,456
如果你在任何时候

359
00:13:20,456 --> 0:13:22,156
需要调整缓冲区的大小

360
00:13:22,156 --> 0:13:23,756
只需创建一个新的缓冲区

361
00:13:23,756 --> 0:13:25,186
并丢弃旧的缓冲区

362
00:13:26,896 --> 0:13:29,946
OpenGL 和 Metal 都有方法

363
00:13:29,946 --> 0:13:31,526
来指示你

364
00:13:31,526 --> 0:13:35,096
如何使用对象

365
00:13:35,096 --> 0:13:36,966
然而在 GL 中 enum 只是一个

366
00:13:37,346 --> 0:13:40,626
关于如何访问缓冲区对象中的

367
00:13:40,626 --> 0:13:42,166
数据的使用提示

368
00:13:42,926 --> 0:13:44,896
驱动程序使用该提示

369
00:13:44,896 --> 0:13:46,416
来决定缓冲区的

370
00:13:46,646 --> 0:13:48,106
定位内存的基础位置

371
00:13:48,106 --> 0:13:50,356
但是没有对存储的直接控制

372
00:13:51,156 --> 0:13:53,776
OpenGL 最终决定

373
00:13:53,776 --> 0:13:56,000
在哪里存储对象

374
00:13:57,386 --> 0:13:59,356
在 Metal 中

375
00:13:59,356 --> 0:14:01,716
API 允许你指定映射到

376
00:13:59,356 --> 0:14:01,716
API 允许你指定映射到

377
00:14:01,716 --> 0:14:03,296
特定内存分配行为的

378
00:14:03,296 --> 0:14:04,336
存储模式

379
00:14:05,436 --> 0:14:06,936
Metal 给予你控制

380
00:14:06,936 --> 0:14:08,746
因为你最知道

381
00:14:08,776 --> 0:14:09,696
你的对象将如何被使用

382
00:14:10,036 --> 0:14:13,026
这在对象创建中

383
00:14:13,026 --> 0:14:14,756
是一个很重要的概念

384
00:14:14,756 --> 0:14:16,816
所以我们会在看完

385
00:14:16,816 --> 0:14:20,000
纹理 API 之后马上回到这个内容

386
00:14:22,246 --> 0:14:23,916
在 GL 中

387
00:14:23,916 --> 0:14:26,196
每个纹理都有一个内部采样器对象

388
00:14:26,196 --> 0:14:28,716
App 采样模式时

389
00:14:28,716 --> 0:14:29,926
一个通常应用的采样器设置

390
00:14:30,516 --> 0:14:31,816
但是你也可以选择

391
00:14:31,816 --> 0:14:33,416
在纹理之外

392
00:14:33,646 --> 0:14:34,656
创建一个单独的采样器对象

393
00:14:35,916 --> 0:14:38,086
这里有一个

394
00:14:38,086 --> 0:14:39,236
创建和绑定纹理

395
00:14:39,836 --> 0:14:41,906
设置采样器

396
00:14:41,906 --> 0:14:44,156
最后填充数据的例子

397
00:14:44,786 --> 0:14:47,826
值得一提的是

398
00:14:47,826 --> 0:14:50,016
GL 有很多 API 调用

399
00:14:50,066 --> 0:14:53,006
来创建初始化的数据化纹理

400
00:14:54,166 --> 0:14:55,756
它还具有

401
00:14:55,866 --> 0:14:58,196
相同 API 的被命名资源版本

402
00:14:59,716 --> 0:15:01,366
在管理采样器方面

403
00:14:59,716 --> 0:15:01,366
在管理采样器方面

404
00:15:01,366 --> 0:15:02,636
还有更多的 API

405
00:15:02,636 --> 0:15:07,046
这样的例子不胜枚举

406
00:15:07,316 --> 0:15:09,116
Metal 的设计目标之一是

407
00:15:09,116 --> 0:15:11,606
提供一个更简单的 API

408
00:15:11,606 --> 0:15:14,326
能够保有所有的灵活性

409
00:15:14,976 --> 0:15:17,176
在 Metal 中

410
00:15:17,176 --> 0:15:19,386
纹理和采样器对象在创建后

411
00:15:19,386 --> 0:15:20,916
总是分离和不可变的

412
00:15:21,546 --> 0:15:25,756
为了创建纹理

413
00:15:25,756 --> 0:15:27,916
我们创建一个描述符

414
00:15:27,916 --> 0:15:29,646
设置各种属性来定义纹理尺寸

415
00:15:29,646 --> 0:15:31,476
比如 pixelFormat

416
00:15:31,476 --> 0:15:33,606
和尺寸等

417
00:15:35,096 --> 0:15:37,026
同样 我们说过的一个重要属性是

418
00:15:37,026 --> 0:15:39,016
storageMode

419
00:15:39,016 --> 0:15:41,406
用于指定在内存中存储纹理的位置

420
00:15:42,466 --> 0:15:43,736
最后 我们使用

421
00:15:43,866 --> 0:15:45,706
这个描述符

422
00:15:45,706 --> 0:15:46,526
来创建一个不可变的对象

423
00:15:47,056 --> 0:15:50,686
以类似的方式

424
00:15:51,016 --> 0:15:52,816
从 samplerDescriptor 开始

425
00:15:52,816 --> 0:15:55,206
设置其属性

426
00:15:55,726 --> 0:15:57,056
并创建不可变的 sampler 对象

427
00:15:58,086 --> 0:15:59,296
非常简单

428
00:16:00,556 --> 0:16:02,826
为了填充纹理的图像数据

429
00:16:02,946 --> 0:16:05,186
我们计算每一行的字节数

430
00:16:05,326 --> 0:16:06,896
就像我们在 OpenGL 中做的一样

431
00:16:06,956 --> 0:16:08,626
我们指定要加载的区域

432
00:16:09,486 --> 0:16:10,986
然后我们调用

433
00:16:11,086 --> 0:16:13,626
texture replaceRegion 方法

434
00:16:13,626 --> 0:16:15,676
该方法将数据从我们指定的指针

435
00:16:15,806 --> 0:16:18,066
复制到纹理中

436
00:16:21,116 --> 0:16:22,776
如果你加载了第一个纹理

437
00:16:22,776 --> 0:16:24,046
你可能会发现

438
00:16:24,046 --> 0:16:25,896
它是颠倒的

439
00:16:27,286 --> 0:16:28,656
这是因为在 Metal 中

440
00:16:28,656 --> 0:16:30,366
纹理坐标相对于 GL

441
00:16:30,366 --> 0:16:31,896
在 Y 轴上是翻转的

442
00:16:33,056 --> 0:16:34,726
值得一提的是

443
00:16:34,946 --> 0:16:38,066
Metal API 不在底层

444
00:16:38,066 --> 0:16:41,056
执行任何像素格式转换

445
00:16:41,286 --> 0:16:42,336
所以你需要

446
00:16:42,336 --> 0:16:43,896
使用你想要使用的格式

447
00:16:44,016 --> 0:16:44,976
上传你的纹理

448
00:16:49,466 --> 0:16:52,266
现在让我们回到存储模式

449
00:16:52,726 --> 0:16:55,626
如前所述 在 GL 中

450
00:16:55,626 --> 0:16:57,396
驱动程序必须

451
00:16:57,396 --> 0:16:59,456
对你希望如何使用资源做出最佳猜测

452
00:16:59,986 --> 0:17:01,396
作为开发者

453
00:16:59,986 --> 0:17:01,396
作为开发者

454
00:17:01,396 --> 0:17:03,096
你可以在某些情况下提供提示

455
00:17:03,096 --> 0:17:04,496
比如何时创建缓冲区

456
00:17:04,496 --> 0:17:07,906
或者通过为帧缓冲区附件

457
00:17:07,906 --> 0:17:09,276
创建渲染缓冲区对象

458
00:17:09,836 --> 0:17:11,856
但在所有这些例子中

459
00:17:11,856 --> 0:17:13,556
这些仍然是提示

460
00:17:13,556 --> 0:17:16,195
实现细节对你仍然是隐藏的

461
00:17:16,806 --> 0:17:18,925
几分钟前

462
00:17:18,925 --> 0:17:20,665
我们简要介绍了

463
00:17:20,695 --> 0:17:22,246
Metal 附加的存储模式属性 

464
00:17:22,246 --> 0:17:25,626
你可以在纹理描述符

465
00:17:25,626 --> 0:17:27,435
和创建缓冲区时设置它

466
00:17:28,376 --> 0:17:30,236
让我们来看看这些的主要用例

467
00:17:31,596 --> 0:17:34,536
最简单的选择是

468
00:17:34,536 --> 0:17:36,716
使用共享存储模式

469
00:17:36,716 --> 0:17:39,146
CPU 和 GPU 都将可以访问资源

470
00:17:39,806 --> 0:17:41,396
对于缓冲区而言

471
00:17:41,396 --> 0:17:43,196
这意味着你必须在这里

472
00:17:43,196 --> 0:17:44,256
指向对象的内存支持

473
00:17:45,146 --> 0:17:48,136
对于 iOS 上的纹理

474
00:17:48,636 --> 0:17:49,956
这意味着你可以调用一些

475
00:17:49,956 --> 0:17:52,706
简单易用的函数来设置和检索图像数据

476
00:17:53,356 --> 0:17:57,466
你也可以使用一个

477
00:17:57,466 --> 0:17:59,736
私有存储模式

478
00:17:59,736 --> 0:18:02,606
它让 GPU 独占访问数据

479
00:17:59,736 --> 0:18:02,606
它让 GPU 独占访问数据

480
00:18:03,156 --> 0:18:05,696
它允许 Metal 应用一些优化

481
00:18:05,696 --> 0:18:07,236
通常情况下

482
00:18:07,236 --> 0:18:09,256
如果 CPU 能够访问数据

483
00:18:09,746 --> 0:18:11,766
它是无法使用这些优化的

484
00:18:12,676 --> 0:18:14,896
只有 GPU 可以

485
00:18:14,896 --> 0:18:16,736
直接填充数据的内容

486
00:18:17,716 --> 0:18:19,046
因此 你可以使用

487
00:18:19,046 --> 0:18:21,056
来自使用共享存储的

488
00:18:21,056 --> 0:18:22,836
第二个中间资源的 blitEncoder

489
00:18:22,836 --> 0:18:26,016
来间接地填充来自 CPU 的数据

490
00:18:26,556 --> 0:18:30,256
在具有专用视频内存的语音上

491
00:18:30,256 --> 0:18:31,676
将资源设置为

492
00:18:31,676 --> 0:18:33,616
使用私有存储

493
00:18:34,256 --> 0:18:36,316
仅将其分配到视频内存中

494
00:18:36,316 --> 0:18:37,656
单个副本

495
00:18:38,236 --> 0:18:42,386
在 macOS 上

496
00:18:42,386 --> 0:18:44,176
有一个托管存储模式

497
00:18:44,176 --> 0:18:47,146
允许 CPU 和 GPU 访问对象的数据

498
00:18:48,436 --> 0:18:50,326
在具有专用视频内存的系统上

499
00:18:50,326 --> 0:18:52,526
Metal 可能需要

500
00:18:52,526 --> 0:18:55,206
创建第二个镜像内存支持

501
00:18:55,206 --> 0:18:58,516
以便两个进程都能有效地访问

502
00:18:59,276 --> 0:19:02,406
因此 显式代码是必要的

503
00:18:59,276 --> 0:19:02,406
因此 显式代码是必要的

504
00:19:02,406 --> 0:19:03,666
以确保你的数据

505
00:19:03,946 --> 0:19:06,426
被 CPU 和 GPU 同步访问

506
00:19:06,426 --> 0:19:07,976
例如使用 didModifyRange

507
00:19:11,156 --> 0:19:14,046
为了总结

508
00:19:14,046 --> 0:19:16,216
我们回顾一下每种模式的一些典型用法

509
00:19:17,306 --> 0:19:20,146
在 macOS 上

510
00:19:20,146 --> 0:19:22,176
你将为静态素材和渲染目标

511
00:19:22,176 --> 0:19:24,606
使用私有存储模式

512
00:19:25,826 --> 0:19:28,316
你的小型动态缓冲区

513
00:19:28,316 --> 0:19:30,366
可以使用共享存储模式

514
00:19:31,216 --> 0:19:32,896
带有较小更新的较大缓冲区

515
00:19:32,896 --> 0:19:35,886
将使用托管存储模式

516
00:19:36,396 --> 0:19:40,086
在 iOS 上

517
00:19:40,086 --> 0:19:42,416
静态数据和渲染目标

518
00:19:42,416 --> 0:19:43,326
可以使用私有存储模式

519
00:19:43,816 --> 0:19:47,026
由于我们的设备使用统一的内存

520
00:19:47,456 --> 0:19:50,596
任何大小的动态数据

521
00:19:50,596 --> 0:19:52,566
都可以使用共享存储模式

522
00:19:52,566 --> 0:19:55,456
并且仍然可以获得很好的性能

523
00:19:59,716 --> 0:20:02,136
接下来

524
00:19:59,716 --> 0:20:02,136
接下来

525
00:20:02,136 --> 0:20:03,896
让我们讨论一下

526
00:20:03,896 --> 0:20:05,086
为图形 App 开发着色器

527
00:20:05,086 --> 0:20:08,336
以及使用什么 API 来处理着色器

528
00:20:08,866 --> 0:20:12,326
在 GL 中

529
00:20:12,326 --> 0:20:13,996
进行着色器编译时

530
00:20:13,996 --> 0:20:17,696
你必须创建一个 shader 对象

531
00:20:17,996 --> 0:20:20,206
替换对象中的 ShaderSource

532
00:20:20,586 --> 0:20:22,756
及时进行编译

533
00:20:23,156 --> 0:20:25,806
并验证编译成功

534
00:20:25,866 --> 0:20:28,726
虽然这种工作流有它的优点

535
00:20:28,726 --> 0:20:30,586
但是你的 App

536
00:20:30,586 --> 0:20:32,176
必须为每次编译所有着色器

537
00:20:32,176 --> 0:20:36,936
付出性能的代价

538
00:20:37,056 --> 0:20:39,206
Metal 实现其效率的

539
00:20:39,206 --> 0:20:42,036
一个关键方法是

540
00:20:42,036 --> 0:20:44,596
更早 更少地工作

541
00:20:45,296 --> 0:20:46,816
在构建时

542
00:20:46,816 --> 0:20:48,346
Xcode 将编译所有

543
00:20:48,636 --> 0:20:50,096
Metal ShaderSource 文件

544
00:20:50,096 --> 0:20:52,196
到一个默认的 Metal 库文件中

545
00:20:52,196 --> 0:20:53,946
并将其放在 App 捆绑包中

546
00:20:53,946 --> 0:20:54,966
以便在运行时检索

547
00:20:55,836 --> 0:20:57,216
这消除了在运行时

548
00:20:57,216 --> 0:20:59,946
编译大量代码的需要

549
00:21:00,026 --> 0:21:01,556
并将 App 运行时的

550
00:21:02,086 --> 0:21:04,936
编译时间缩短了一半

551
00:21:05,206 --> 0:21:07,436
你所需要做的就是

552
00:21:07,436 --> 0:21:09,276
从与 App 绑定的文件中

553
00:21:09,276 --> 0:21:10,986
创建一个 Metal 库

554
00:21:11,486 --> 0:21:14,826
并从中获取着色器函数

555
00:21:17,656 --> 0:21:19,976
在 GL 中你使用 GLSL

556
00:21:19,976 --> 0:21:22,236
它基于 C 编程语言

557
00:21:23,696 --> 0:21:25,326
Metal 的着色语言

558
00:21:25,326 --> 0:21:27,536
或 MSL 是基于 C++ 的

559
00:21:27,776 --> 0:21:29,466
因此 对于大多数 GL 开发人员来说

560
00:21:29,466 --> 0:21:31,176
它应该是相当熟悉的

561
00:21:32,206 --> 0:21:34,216
它的 C++ 基础意味着

562
00:21:34,216 --> 0:21:35,446
你可以创建类

563
00:21:35,636 --> 0:21:36,726
模板和扩展

564
00:21:36,726 --> 0:21:40,000
你可以定义枚举和名称空间

565
00:21:41,216 --> 0:21:43,546
和 GLSL 一样

566
00:21:43,546 --> 0:21:45,466
也有内置的向量

567
00:21:45,516 --> 0:21:47,136
和矩阵类型

568
00:21:47,186 --> 0:21:48,726
许多内置的函数

569
00:21:48,726 --> 0:21:49,826
和操作用于图形

570
00:21:50,396 --> 0:21:52,596
还有一些类

571
00:21:52,836 --> 0:21:54,976
用于操作指定采样器状态的纹理

572
00:22:01,146 --> 0:22:03,796
与 Metal 一样

573
00:22:03,936 --> 0:22:05,936
MSL 也统一用于图形和计算

574
00:22:07,276 --> 0:22:09,156
最后

575
00:22:09,156 --> 0:22:11,776
由于着色器是预编译的

576
00:22:11,776 --> 0:22:13,586
Xcode 能够提供错误 警告和指导

577
00:22:13,586 --> 0:22:16,456
帮助你在构建时进行调试

578
00:22:17,576 --> 0:22:19,596
让我们看一下 MSL 的实际代码

579
00:22:19,596 --> 0:22:22,986
并将其与 GLSL 进行比较

580
00:22:24,176 --> 0:22:25,886
我们将通过一个

581
00:22:25,886 --> 0:22:28,436
简单的顶点着色器

582
00:22:28,436 --> 0:22:29,746
顶部是 GLSL 底部是 MSL

583
00:22:30,266 --> 0:22:34,526
让我们开始定义着色器

584
00:22:34,566 --> 0:22:35,736
这些是原型

585
00:22:36,006 --> 0:22:37,586
在 GLSL 中 void main()

586
00:22:38,266 --> 0:22:39,656
着色器中没有指定

587
00:22:39,656 --> 0:22:41,556
着色器阶段的内容

588
00:22:42,146 --> 0:22:43,656
它完全由

589
00:22:43,656 --> 0:22:46,136
传递到 glCreateShader 调用的

590
00:22:46,136 --> 0:22:47,416
着色器类型决定

591
00:22:48,776 --> 0:22:50,836
在 MSL 中 着色器阶段

592
00:22:50,836 --> 0:22:53,036
在着色器代码中显式指定

593
00:22:53,426 --> 0:22:54,916
这里的 vertex 限定符表示

594
00:22:54,916 --> 0:22:56,006
它将对生成

595
00:22:56,006 --> 0:22:57,336
完美示例的

596
00:22:57,476 --> 0:22:59,116
每个顶点执行

597
00:23:00,916 --> 0:23:03,726
在 GLSL 中

598
00:23:03,726 --> 0:23:05,486
每个着色器入口点都必须被调用 main

599
00:23:05,616 --> 0:23:06,806
并接受和返回 void

600
00:23:07,526 --> 0:23:09,866
在 MSL 中 每个入口点

601
00:23:09,866 --> 0:23:10,796
都有一个不同的名称

602
00:23:11,176 --> 0:23:13,256
当你使用 Xcode 构建着色器时

603
00:23:13,256 --> 0:23:15,076
编译器可以

604
00:23:15,076 --> 0:23:16,876
在预处理阶段

605
00:23:16,876 --> 0:23:18,926
解析 include 语句

606
00:23:18,926 --> 0:23:20,546
就像解析普通 C++ 代码一样

607
00:23:21,266 --> 0:23:22,926
在运行时

608
00:23:23,296 --> 0:23:24,916
你可以根据预先编译的

609
00:23:25,586 --> 0:23:27,596
Metal 库的不同名称查询函数

610
00:23:27,656 --> 0:23:31,376
然后我们来谈谈输入

611
00:23:32,416 --> 0:23:34,216
因为 GLSL 中的每个入口点

612
00:23:34,216 --> 0:23:35,716
都是一个没有参数的主函数

613
00:23:35,716 --> 0:23:38,016
所以所有输入

614
00:23:38,016 --> 0:23:39,476
都作为全局参数传递

615
00:23:40,226 --> 0:23:41,876
这适用于 vertex 属性

616
00:23:41,876 --> 0:23:43,836
和统一变量

617
00:23:45,056 --> 0:23:48,186
在 Metal 中

618
00:23:48,186 --> 0:23:50,266
所有到阴影阶段的输入

619
00:23:50,266 --> 0:23:51,126
都是入口函数的参数

620
00:23:51,546 --> 0:23:54,816
双括号声明 C++ 属性

621
00:23:54,916 --> 0:23:56,000
我们待会再看

622
00:23:57,676 --> 0:23:59,366
这里的一个输入

623
00:23:59,366 --> 0:24:01,496
是一个模型视图投影矩阵

624
00:23:59,366 --> 0:24:01,496
是一个模型视图投影矩阵

625
00:24:02,006 --> 0:24:05,966
在 OpenGL 中

626
00:24:05,966 --> 0:24:07,986
为了将数据绑定到这些变量上

627
00:24:08,816 --> 0:24:11,546
App 必须知道

628
00:24:11,546 --> 0:24:13,306
C++ 代码中的 GLSL 名称

629
00:24:14,146 --> 0:24:16,796
这使得着色器开发容易出错

630
00:24:17,376 --> 0:24:21,076
在 MSL 中

631
00:24:21,076 --> 0:24:22,446
统一绑定索引

632
00:24:22,446 --> 0:24:24,096
由开发者

633
00:24:24,096 --> 0:24:25,906
在着色器中显式控制

634
00:24:25,906 --> 0:24:29,156
因此 App 可以直接绑定到特定的槽

635
00:24:29,646 --> 0:24:31,376
在这个例子中 位置 1

636
00:24:32,816 --> 0:24:34,106
这里的关键字常量

637
00:24:34,106 --> 0:24:36,836
表示模型视图投影的意图

638
00:24:36,836 --> 0:24:38,446
对所有顶点

639
00:24:38,446 --> 0:24:40,256
都是一致的

640
00:24:42,276 --> 0:24:44,086
着色器的另一个输入

641
00:24:44,086 --> 0:24:45,576
是一组顶点属性

642
00:24:46,266 --> 0:24:48,136
在 GLSL 中

643
00:24:48,396 --> 0:24:50,136
通常使用单独的属性输入

644
00:24:50,476 --> 0:24:52,416
这里的主要区别是

645
00:24:52,416 --> 0:24:55,256
MSL 使用你自己设计的结构

646
00:24:56,136 --> 0:24:57,746
阶段关键字表明

647
00:24:57,826 --> 0:24:59,066
着色器的每次调用

648
00:24:59,066 --> 0:25:01,660
都将收到自己的参数

649
00:24:59,066 --> 0:25:01,660
都将收到自己的参数

650
00:25:03,806 --> 0:25:05,146
在设置好着色器的

651
00:25:05,146 --> 0:25:06,756
所有输入之后

652
00:25:06,756 --> 0:25:08,736
你就可以执行所有的计算

653
00:25:10,416 --> 0:25:12,556
至于输出 在 GLSL 中

654
00:25:12,556 --> 0:25:14,316
输出被分割为

655
00:25:14,316 --> 0:25:16,436
不同的属性

656
00:25:16,436 --> 0:25:18,866
比如 glTexCoord 和预定义的变量

657
00:25:18,866 --> 0:25:21,596
在本例中是 gl_Position

658
00:25:22,176 --> 0:25:25,886
在 MSL 中顶点着色器输出

659
00:25:26,106 --> 0:25:27,966
被合并到你自己的结构中

660
00:25:29,576 --> 0:25:31,866
我们使用了

661
00:25:31,866 --> 0:25:32,976
vertex VertexOutput 结构

662
00:25:33,406 --> 0:25:34,976
让我们向上滚动 MSL 代码

663
00:25:35,046 --> 0:25:37,386
看看它们到底是什么样子的

664
00:25:39,436 --> 0:25:41,926
如前所述

665
00:25:41,926 --> 0:25:44,536
GLSL 分别定义

666
00:25:44,536 --> 0:25:46,756
输入顶点属性

667
00:25:46,756 --> 0:25:49,166
Metal 允许你在结构中定义它们

668
00:25:49,776 --> 0:25:52,836
在 MSL 中有一些

669
00:25:52,836 --> 0:25:54,696
特殊的关键字顶点着色器输入

670
00:25:55,196 --> 0:25:57,966
我们用一个 attribute 关键字

671
00:25:57,966 --> 0:25:59,686
标记每个结构成分

672
00:25:59,686 --> 0:26:02,306
并为其分配一个属性索引

673
00:25:59,686 --> 0:26:02,306
并为其分配一个属性索引

674
00:26:02,816 --> 0:26:05,286
与 GLSL 类似

675
00:26:05,636 --> 0:26:07,296
这些索引在 Metal API 中

676
00:26:07,396 --> 0:26:09,106
用于为顶点属性

677
00:26:09,256 --> 0:26:11,836
分配顶点缓冲流

678
00:26:15,556 --> 0:26:18,066
GLSL 预先定义了

679
00:26:18,066 --> 0:26:20,456
一些特殊的关键字

680
00:26:20,456 --> 0:26:23,166
比如 gl_Position

681
00:26:23,606 --> 0:26:25,086
表示哪个变量包含了

682
00:26:25,086 --> 0:26:26,396
用模型视图投影矩阵

683
00:26:26,396 --> 0:26:27,576
转换过的顶点坐标

684
00:26:29,046 --> 0:26:30,256
类似地 对于顶点输出

685
00:26:30,256 --> 0:26:32,576
MSL 中的结构

686
00:26:32,576 --> 0:26:35,206
特殊的关键字 position

687
00:26:35,206 --> 0:26:36,506
表示顶点着色器输出位置

688
00:26:36,726 --> 0:26:39,356
存储在该结构成分中

689
00:26:42,656 --> 0:26:46,296
与 GLSL 向量类型类似

690
00:26:46,296 --> 0:26:48,326
MSL 通过 simd.h 标头

691
00:26:48,486 --> 0:26:50,996
定义了许多 simd 类型

692
00:26:50,996 --> 0:26:53,896
可以在 CPU 和 GPU 代码之间共享

693
00:26:55,186 --> 0:26:56,376
但是有几件事

694
00:26:56,376 --> 0:26:57,536
你需要记住

695
00:26:58,926 --> 0:27:01,036
缓冲区中的向量和矩阵类型

696
00:26:58,926 --> 0:27:01,036
缓冲区中的向量和矩阵类型

697
00:27:01,036 --> 0:27:03,706
被对齐到 16 字节

698
00:27:03,906 --> 0:27:05,396
或者为了获得一半的精度 对齐到 8 字节

699
00:27:06,146 --> 0:27:07,276
因此它们不一定是压缩的

700
00:27:07,276 --> 0:27:09,256
例如 float3 的大小

701
00:27:09,256 --> 0:27:11,576
为 12 字节

702
00:27:11,576 --> 0:27:12,726
但对齐为 16 字节

703
00:27:13,346 --> 0:27:15,246
这是为了确保数据

704
00:27:15,246 --> 0:27:18,276
被对齐到最佳的 CPU 和 GPU 访问

705
00:27:19,686 --> 0:27:21,486
如果需要

706
00:27:21,486 --> 0:27:23,406
你可以使用特定的支持格式

707
00:27:23,786 --> 0:27:25,406
但是在使用它们之前

708
00:27:25,466 --> 0:27:29,966
你需要在着色器中解压它们

709
00:27:30,166 --> 0:27:32,306
我们刚刚回顾了

710
00:27:32,306 --> 0:27:35,176
GLSL 和 MSL 之间的主要区别

711
00:27:35,876 --> 0:27:38,536
为了使这个过渡

712
00:27:38,536 --> 0:27:41,006
平稳且容易

713
00:27:41,006 --> 0:27:42,986
我的同事 Max 将向你展示一个

714
00:27:42,986 --> 0:27:45,426
非常酷的工具来帮助你轻松地完成它 谢谢大家

715
00:27:46,516 --> 0:27:51,796
[掌声]

716
00:27:52,296 --> 0:27:53,286
&gt;&gt; 晚上好

717
00:27:54,616 --> 0:27:57,106
Metal 不仅仅是一个 API

718
00:27:57,346 --> 0:27:59,516
和一种着色语言

719
00:27:59,516 --> 0:28:01,666
它还是一个功能强大的工具集合

720
00:27:59,516 --> 0:28:01,666
它还是一个功能强大的工具集合

721
00:28:02,686 --> 0:28:04,556
我是 Max 我会尽量减少

722
00:28:04,556 --> 0:28:07,016
你在移植到 Metal 的过程中所遇到的麻烦

723
00:28:07,586 --> 0:28:11,546
让我们来看看这个场景

724
00:28:11,846 --> 0:28:13,976
这是第一次

725
00:28:13,976 --> 0:28:16,296
从一个老的 OpenGL 演示中调用绘制

726
00:28:16,296 --> 0:28:18,376
我们在 Apple 这里将把它移植到 Metal

727
00:28:19,126 --> 0:28:21,656
它绘制了一座寺庙

728
00:28:21,656 --> 0:28:23,926
和一棵树的模型

729
00:28:23,976 --> 0:28:25,016
两者都被四处的光源照亮

730
00:28:25,316 --> 0:28:26,976
让我们一起移植片段着色器

731
00:28:31,046 --> 0:28:32,916
我做的第一件事是

732
00:28:32,916 --> 0:28:34,926
直接复制粘贴我所有的

733
00:28:34,926 --> 0:28:37,616
旧 OpenGL 代码

734
00:28:37,616 --> 0:28:38,676
到我的 Metal 着色器文件中

735
00:28:39,886 --> 0:28:41,556
基于这点

736
00:28:41,556 --> 0:28:44,476
我已经创建了输入结构

737
00:28:44,476 --> 0:28:46,026
和函数原型

738
00:28:47,536 --> 0:28:48,076
让我们开始吧

739
00:28:49,266 --> 0:28:50,896
我们要做的就是

740
00:28:50,896 --> 0:28:52,656
直接复制粘贴

741
00:28:52,656 --> 0:28:55,186
主函数的内容

742
00:28:55,396 --> 0:28:56,846
到 Metal 函数中

743
00:28:58,166 --> 0:29:00,436
这里我们看到了

744
00:28:58,166 --> 0:29:00,436
这里我们看到了

745
00:29:00,436 --> 0:29:02,016
Metal 的第一个强大之处

746
00:29:03,336 --> 0:29:06,176
因为着色器是预编译的

747
00:29:06,176 --> 0:29:07,406
我们会立即得到错误

748
00:29:07,816 --> 0:29:09,646
让我们仔细看看

749
00:29:10,456 --> 0:29:12,336
当然 构建向量类型

750
00:29:12,336 --> 0:29:13,806
现在有不同的名称

751
00:29:14,416 --> 0:29:17,276
vec2 变成了 float2

752
00:29:17,326 --> 0:29:20,616
vec3 变成了 float3

753
00:29:20,616 --> 0:29:22,786
vec4 变成了 float4

754
00:29:23,416 --> 0:29:24,776
我们很快就解决了这个问题

755
00:29:28,296 --> 0:29:29,826
下一个错误是

756
00:29:29,826 --> 0:29:31,956
我们所有的

757
00:29:31,956 --> 0:29:33,316
输入结构

758
00:29:33,316 --> 0:29:35,346
所有的全局变量

759
00:29:35,396 --> 0:29:36,496
都来自于输入结构

760
00:29:36,936 --> 0:29:38,336
因为我用了

761
00:29:38,446 --> 0:29:39,996
类似的命名方案

762
00:29:39,996 --> 0:29:40,976
这也很简单

763
00:29:48,596 --> 0:29:50,146
当然 我们也要用同样的方法

764
00:29:50,146 --> 0:29:52,716
修改 统一变量

765
00:29:58,186 --> 0:30:00,426
下一个错误有点复杂

766
00:29:58,186 --> 0:30:00,426
下一个错误有点复杂

767
00:30:01,106 --> 0:30:02,916
Metal 的取样是不同的

768
00:30:02,916 --> 0:30:04,186
让我们来看一下

769
00:30:05,336 --> 0:30:07,216
我们要从头开始

770
00:30:07,956 --> 0:30:10,406
我们可以直接调用

771
00:30:10,406 --> 0:30:12,976
colorMap 上的一个 sample 函数

772
00:30:13,136 --> 0:30:15,286
这里我们可以看到

773
00:30:15,286 --> 0:30:17,016
全自动完成是多么强大

774
00:30:18,166 --> 0:30:19,736
这个函数要求我们

775
00:30:19,736 --> 0:30:21,966
放入一个采样器和一个纹理坐标

776
00:30:21,966 --> 0:30:24,246
我们已经有了纹理坐标

777
00:30:25,416 --> 0:30:27,316
我们可以将采样器

778
00:30:27,316 --> 0:30:30,036
作为参数传递给函数

779
00:30:30,036 --> 0:30:31,636
或者在 Metal 中 我们可以像这样

780
00:30:31,636 --> 0:30:33,696
在代码中声明一个采样器

781
00:30:34,286 --> 0:30:37,556
我们需要对我们的

782
00:30:37,626 --> 0:30:39,636
normalMap 做同样的事情

783
00:30:48,236 --> 0:30:49,296
我们看到的

784
00:30:49,416 --> 0:30:52,026
最后一个错误是

785
00:30:52,026 --> 0:30:55,386
我们写进了很多 OpenGL 变量中的一个

786
00:30:55,716 --> 0:30:57,256
我们将返回

787
00:30:57,256 --> 0:30:59,846
最终计算得到的颜色

788
00:31:04,356 --> 0:31:06,036
我们还可以看到

789
00:31:06,036 --> 0:31:07,966
所有其他的函数 比如 normalize

790
00:31:08,356 --> 0:31:09,936
dot 点积 

791
00:31:09,936 --> 0:31:12,556
以及我最喜欢的函数 max 都是一样的

792
00:31:13,976 --> 0:31:15,946
现在着色器编译成功

793
00:31:16,516 --> 0:31:16,976
让我们试着运行一下

794
00:31:23,326 --> 0:31:24,486
发生了一些错误

795
00:31:25,056 --> 0:31:28,436
在 OpenGL 中

796
00:31:28,836 --> 0:31:30,256
当你的着色器出现错误时

797
00:31:30,256 --> 0:31:31,936
你通常会做的是

798
00:31:31,936 --> 0:31:33,906
查看源代码

799
00:31:33,976 --> 0:31:36,396
查看输出

800
00:31:36,836 --> 0:31:38,356
然后认真思考

801
00:31:39,146 --> 0:31:40,076
我们只需要使用

802
00:31:40,076 --> 0:31:41,266
着色器调试器

803
00:31:42,736 --> 0:31:44,106
轻点调试区域中的

804
00:31:44,106 --> 0:31:46,426
小相机图标

805
00:31:46,426 --> 0:31:47,756
将会捕获 GPU 跟踪

806
00:31:48,526 --> 0:31:51,536
这是我们对每个

807
00:31:51,536 --> 0:31:52,986
Metal API 调用的记录

808
00:31:53,876 --> 0:31:56,826
现在我们可以导航到 draw 调用

809
00:31:57,156 --> 0:31:58,376
我们在这绘制这棵树

810
00:31:59,566 --> 0:32:01,416
我们在这绘制寺庙

811
00:31:59,566 --> 0:32:01,416
我们在这绘制寺庙

812
00:32:01,926 --> 0:32:04,616
让我长按下

813
00:32:04,616 --> 0:32:06,436
寺庙的楼梯

814
00:32:06,436 --> 0:32:08,526
打开像素检查器

815
00:32:08,526 --> 0:32:10,046
它允许我们启动着色器调试器

816
00:32:14,116 --> 0:32:16,596
我们现在看到的是

817
00:32:16,596 --> 0:32:18,906
我们移植到一起的代码

818
00:32:18,906 --> 0:32:20,646
和我们刚刚选择的

819
00:32:20,646 --> 0:32:22,266
像素的每行值

820
00:32:22,266 --> 0:32:25,566
让我们先看看我们的 colorMap

821
00:32:25,976 --> 0:32:30,026
我们可以看到这看起来像一个合理的纹理

822
00:32:30,206 --> 0:32:32,066
我们还可以看到楼梯

823
00:32:32,146 --> 0:32:33,466
在这个纹理的上半部分

824
00:32:33,466 --> 0:32:36,096
然而

825
00:32:36,486 --> 0:32:37,896
如果我们看一下纹理坐标

826
00:32:37,896 --> 0:32:40,046
我们就会发现

827
00:32:40,226 --> 0:32:43,066
我们是从下半部分采样的

828
00:32:43,126 --> 0:32:45,066
让我快速验证一下是不是这样

829
00:32:46,376 --> 0:32:48,096
我们要做的是

830
00:32:48,096 --> 0:32:51,256
反转纹理的 Y 坐标

831
00:32:52,056 --> 0:32:56,966
现在我们可以更新着色器

832
00:32:57,566 --> 0:33:00,606
看起来很合理

833
00:32:57,566 --> 0:33:00,606
看起来很合理

834
00:33:00,606 --> 0:33:02,046
我们可以继续执行

835
00:33:02,506 --> 0:33:03,496
你看 现在好多了

836
00:33:03,596 --> 0:33:08,696
在从 OpenGL 移植到 Metal 时

837
00:33:08,746 --> 0:33:11,686
这是一个非常常见的错误

838
00:33:13,086 --> 0:33:16,536
当然 真正的修复是

839
00:33:16,536 --> 0:33:18,396
你进入你的纹理加载代码

840
00:33:18,446 --> 0:33:20,356
并确保你的纹理在正确的原点加载

841
00:33:20,356 --> 0:33:22,336
这样你就不必在每个着色器中都做这个修复

842
00:33:23,416 --> 0:33:25,466
然而 功能丰富的编辑器

843
00:33:25,466 --> 0:33:27,536
和强大的调试工具的组合

844
00:33:27,536 --> 0:33:29,686
最终都将帮助你

845
00:33:29,686 --> 0:33:32,256
将游戏移植到 Metal

846
00:33:33,676 --> 0:33:34,866
非常感谢

847
00:33:35,386 --> 0:33:36,796
我的同事 Sarah

848
00:33:36,846 --> 0:33:38,246
现在将引导你完成之后的幻灯片内容

849
00:33:39,516 --> 0:33:43,616
[掌声]

850
00:33:44,116 --> 0:33:45,066
&gt;&gt; 谢谢你 Max

851
00:33:45,066 --> 0:33:46,286
大家好 我是 Sarah Clawson

852
00:33:46,286 --> 0:33:48,216
我将与你讨论

853
00:33:48,216 --> 0:33:50,076
关于从 GL 移植到 Metal 的其他内容

854
00:33:50,616 --> 0:33:53,686
目前为止 在一个图形 App 的生命中

855
00:33:53,686 --> 0:33:55,366
我们已经进行了很多的设置

856
00:33:56,176 --> 0:33:57,796
我们有一个用于渲染的窗口

857
00:33:58,006 --> 0:33:59,386
一个将命令传达给 GPU 的方式

858
00:33:59,386 --> 0:34:02,156
以及一组完备的

859
00:33:59,386 --> 0:34:02,156
以及一组完备的

860
00:34:02,326 --> 0:34:03,466
资源和着色器

861
00:34:04,436 --> 0:34:05,946
接下来

862
00:34:05,946 --> 0:34:07,596
我们将讨论

863
00:34:07,596 --> 0:34:08,726
为渲染循环设置状态

864
00:34:10,826 --> 0:34:13,085
OpenGL 在状态管理方面

865
00:34:13,085 --> 0:34:14,226
有几个关键概念

866
00:34:14,976 --> 0:34:16,786
顶点数组对象定义了

867
00:34:16,815 --> 0:34:17,996
顶点属性布局

868
00:34:17,996 --> 0:34:19,556
和顶点缓冲区

869
00:34:20,396 --> 0:34:21,536
这个程序是顶点着色器

870
00:34:21,536 --> 0:34:23,735
和片段着色器的链接组合

871
00:34:24,676 --> 0:34:27,235
Framebuffer

872
00:34:27,286 --> 0:34:28,446
是 App 打算渲染的

873
00:34:28,446 --> 0:34:29,476
一组颜色

874
00:34:29,556 --> 0:34:30,876
和深度模板附件

875
00:34:31,946 --> 0:34:33,726
这些状态对象

876
00:34:33,946 --> 0:34:35,545
是在初始化过程中创建的

877
00:34:35,545 --> 0:34:36,786
并在整个帧中使用

878
00:34:37,436 --> 0:34:40,295
让我们通过一个示例

879
00:34:40,295 --> 0:34:42,946
来展示 OpenGL 如何管理状态

880
00:34:44,616 --> 0:34:46,106
这里我们有一个示例渲染循环

881
00:34:46,106 --> 0:34:48,616
其中 OpenGL App

882
00:34:48,616 --> 0:34:50,656
绑定一个 Framebuffer

883
00:34:50,656 --> 0:34:52,606
设置一个程序

884
00:34:52,606 --> 0:34:53,786
然后进行其他状态修改

885
00:34:53,786 --> 0:34:56,005
比如启用深度 人脸剔除

886
00:34:56,476 --> 0:34:57,746
或在调用 draw 之前

887
00:34:57,746 --> 0:35:00,326
更改颜色映射

888
00:34:57,746 --> 0:35:00,326
更改颜色映射

889
00:35:00,506 --> 0:35:02,216
如果你从 OpenGL 的角度

890
00:35:02,256 --> 0:35:04,176
查看相同的 API 跟踪

891
00:35:04,176 --> 0:35:06,126
它必须在每次 API 调用时

892
00:35:06,126 --> 0:35:08,116
跟踪所有这些更改

893
00:35:08,276 --> 0:35:10,596
当一个 draw 调用发生时

894
00:35:10,596 --> 0:35:12,276
它必须停止并验证

895
00:35:12,276 --> 0:35:13,496
以确保以前

896
00:35:13,496 --> 0:35:14,916
对原始程序集

897
00:35:14,916 --> 0:35:16,476
深度状态

898
00:35:16,556 --> 0:35:18,566
光栅化器和可编程阶段的更改

899
00:35:18,566 --> 0:35:20,846
都彼此兼容

900
00:35:21,436 --> 0:35:24,526
这种验证可能非常繁重

901
00:35:24,526 --> 0:35:26,296
虽然 OpenGL 确实试图

902
00:35:26,296 --> 0:35:27,676
将其负面影响最小化

903
00:35:28,066 --> 0:35:30,356
但这样做的成效是有限的

904
00:35:31,366 --> 0:35:33,496
值得注意的是

905
00:35:33,496 --> 0:35:35,036
OpenGL 状态对象

906
00:35:35,036 --> 0:35:36,556
在首次引入时就走在了前面

907
00:35:37,946 --> 0:35:39,616
Framebuffer 对象将

908
00:35:39,616 --> 0:35:40,626
附加的渲染目标

909
00:35:41,606 --> 0:35:42,936
程序链接片段

910
00:35:42,936 --> 0:35:45,906
和顶点着色器组合在一起

911
00:35:45,906 --> 0:35:47,886
顶点数组对象

912
00:35:47,886 --> 0:35:49,146
则是更大的对象

913
00:35:49,146 --> 0:35:50,876
结合了一些顶点属性 API

914
00:35:50,876 --> 0:35:52,126
和顶点缓冲区设置

915
00:35:52,896 --> 0:35:54,546
但是即使有了所有这些变化

916
00:35:54,736 --> 0:35:55,936
尽管它们产生了积极的结果

917
00:35:55,936 --> 0:35:58,106
OpenGL 仍然需要在 draw 调用中

918
00:35:58,106 --> 0:35:59,746
验证许多东西

919
00:35:59,746 --> 0:36:04,236
比如

920
00:35:59,746 --> 0:36:04,236
比如

921
00:36:04,236 --> 0:36:06,276
glColorMask 能否帮助优化片段着色器

922
00:36:06,776 --> 0:36:09,016
片段着色器输出是否

923
00:36:09,016 --> 0:36:10,716
与附加的帧缓冲区兼容

924
00:36:11,276 --> 0:36:14,156
顶点布局是否

925
00:36:14,156 --> 0:36:15,136
与绑定程序兼容

926
00:36:16,406 --> 0:36:17,526
或者附加的渲染目标

927
00:36:17,526 --> 0:36:18,346
是可混合的吗

928
00:36:18,896 --> 0:36:22,036
当我们重新设计 Metal 的

929
00:36:22,086 --> 0:36:24,206
图形状态管理时

930
00:36:24,316 --> 0:36:25,846
我们将程序着色器

931
00:36:26,206 --> 0:36:27,966
与 VertexArray 对象的

932
00:36:27,966 --> 0:36:29,556
顶点输入布局相结合

933
00:36:29,556 --> 0:36:31,906
并添加关于

934
00:36:31,906 --> 0:36:33,256
pixelFormat 附件

935
00:36:33,256 --> 0:36:35,486
和混合状态的信息

936
00:36:35,486 --> 0:36:38,486
然后将它们组合到一个

937
00:36:38,536 --> 0:36:40,686
名为 PipelineDescriptor 的对象中

938
00:36:41,556 --> 0:36:43,176
这个结构描述了

939
00:36:43,176 --> 0:36:45,596
图形管道中的所有相关状态

940
00:36:46,836 --> 0:36:48,716
为了设置描述符

941
00:36:49,106 --> 0:36:49,796
你首先要初始化它

942
00:36:50,466 --> 0:36:52,146
然后设置所有

943
00:36:52,146 --> 0:36:53,486
我们刚才讲过的状态

944
00:36:53,556 --> 0:36:54,796
比如顶点和片段着色器

945
00:36:55,686 --> 0:36:57,336
顶点信息

946
00:36:57,336 --> 0:36:58,526
像素格式 以及混合状态

947
00:36:58,626 --> 0:37:01,836
然后使用描述符

948
00:36:58,626 --> 0:37:01,836
然后使用描述符

949
00:37:01,836 --> 0:37:03,286
创建管道状态对象

950
00:37:03,286 --> 0:37:05,766
也就是 PSO

951
00:37:06,636 --> 0:37:08,406
这个不可变对象

952
00:37:08,406 --> 0:37:09,796
完全描述了渲染状态

953
00:37:09,796 --> 0:37:11,226
它的伟大之处在于

954
00:37:11,226 --> 0:37:12,846
你只需创建一次

955
00:37:12,846 --> 0:37:14,386
验证它的正确性

956
00:37:14,386 --> 0:37:15,696
然后在整个程序中使用它

957
00:37:16,276 --> 0:37:19,866
用类似的方式

958
00:37:19,866 --> 0:37:22,206
我们将所有深度和与模板相关的设置

959
00:37:22,206 --> 0:37:23,526
合并到深度/模板状态描述符中

960
00:37:24,326 --> 0:37:26,896
同样地

961
00:37:26,896 --> 0:37:28,266
它是所有深度/模板状态的集合

962
00:37:28,326 --> 0:37:30,186
使用这个描述符

963
00:37:30,186 --> 0:37:32,086
你就可以创建一个

964
00:37:32,086 --> 0:37:33,306
深度/模板状态对象

965
00:37:34,496 --> 0:37:35,996
这个对象也是不可变的

966
00:37:36,096 --> 0:37:37,876
并可在整个程序中使用

967
00:37:38,876 --> 0:37:40,756
我们在 OpenGL 中

968
00:37:40,756 --> 0:37:43,136
看到的渲染循环

969
00:37:43,136 --> 0:37:44,026
现在在 Metal 中看起来是这样的

970
00:37:44,836 --> 0:37:46,176
对于所有

971
00:37:46,246 --> 0:37:47,906
预验证的状态对象

972
00:37:47,906 --> 0:37:50,396
不再需要任何状态验证或跟踪

973
00:37:51,606 --> 0:37:55,566
让我们来比较一下

974
00:37:55,566 --> 0:37:57,436
在 Metal 中

975
00:37:57,436 --> 0:37:58,716
渲染编码器是渲染通道的开始

976
00:37:59,166 --> 0:38:00,446
类似于绑定帧缓冲区

977
00:37:59,166 --> 0:38:00,446
类似于绑定帧缓冲区

978
00:38:01,006 --> 0:38:03,196
你的深度状态已经

979
00:38:03,346 --> 0:38:05,016
预置到对象中

980
00:38:05,016 --> 0:38:06,616
只需在 renderEncoder 上设置它

981
00:38:07,176 --> 0:38:10,056
pipelineState 对象

982
00:38:10,056 --> 0:38:11,766
表示程序着色器

983
00:38:11,846 --> 0:38:13,986
VertexArray 属性

984
00:38:13,986 --> 0:38:15,716
和 pixelFormat 的组合

985
00:38:15,716 --> 0:38:18,406
它也可在 renderEncoder 上设置

986
00:38:18,406 --> 0:38:21,346
现在 renderEncoder

987
00:38:21,346 --> 0:38:23,316
直接管理你的光栅化状态

988
00:38:24,296 --> 0:38:25,746
这里需要注意的是

989
00:38:25,746 --> 0:38:27,296
管道中

990
00:38:27,296 --> 0:38:28,596
仍然具有灵活性

991
00:38:28,596 --> 0:38:30,046
因为并不是所有内容

992
00:38:30,046 --> 0:38:30,936
都被预先放入了 pipelineState 对象中

993
00:38:31,356 --> 0:38:34,156
这是我们刚刚

994
00:38:34,156 --> 0:38:35,336
讨论过的状态列表

995
00:38:35,336 --> 0:38:37,596
你可以把它预置到你的 PSO 中

996
00:38:37,596 --> 0:38:38,586
比如顶点 片段函数

997
00:38:38,586 --> 0:38:40,156
像素格式 等等

998
00:38:41,356 --> 0:38:42,956
另一方面

999
00:38:42,956 --> 0:38:44,106
这是你在绘图时

1000
00:38:44,106 --> 0:38:45,686
仍然设置的所有状态

1001
00:38:46,746 --> 0:38:47,736
比如原始剔除模式和方向

1002
00:38:47,736 --> 0:38:49,136
填充模式

1003
00:38:49,736 --> 0:38:51,216
剪刀和视图区域

1004
00:38:51,216 --> 0:38:53,156
仍然像 OpenGL 一样设置

1005
00:38:53,156 --> 0:38:57,446
重要的是绘制调用保持不变

1006
00:38:58,216 --> 0:38:59,706
这里的主要区别是

1007
00:38:59,706 --> 0:39:01,236
你无需启用新状态

1008
00:38:59,706 --> 0:39:01,236
你无需启用新状态

1009
00:39:01,396 --> 0:39:02,366
这可能导致

1010
00:39:02,366 --> 0:39:04,366
隐藏的验证成本

1011
00:39:04,446 --> 0:39:06,186
你只需要替换掉一个新的 pipelineState 对象

1012
00:39:06,186 --> 0:39:08,516
该对象在描述符中启用了混合

1013
00:39:11,186 --> 0:39:12,556
我还想讨论

1014
00:39:12,556 --> 0:39:13,876
另一种可能的优化

1015
00:39:13,876 --> 0:39:15,916
你可能在 OpenGL 中使用过它

1016
00:39:15,916 --> 0:39:18,666
来隐藏某些繁复的操作

1017
00:39:19,996 --> 0:39:21,836
作为 OpenGL 开发者

1018
00:39:21,836 --> 0:39:23,226
你可能已经看到

1019
00:39:23,296 --> 0:39:25,256
在进行了一系列状态更改之后的

1020
00:39:25,306 --> 0:39:27,316
第一次绘制调用时

1021
00:39:27,316 --> 0:39:28,206
渲染循环出现了意外的小问题

1022
00:39:29,096 --> 0:39:30,596
如果你遇到了这种情况

1023
00:39:30,596 --> 0:39:32,216
你可以使用一个

1024
00:39:32,216 --> 0:39:34,126
名为着色器预热的优化来隐藏它

1025
00:39:35,546 --> 0:39:36,726
在着色器预热中

1026
00:39:36,806 --> 0:39:38,346
App 为最常见的 GL 程序

1027
00:39:38,346 --> 0:39:39,666
使用虚拟绘制调用

1028
00:39:39,666 --> 0:39:42,276
以便 OpenGL

1029
00:39:42,606 --> 0:39:43,676
提前创建

1030
00:39:43,676 --> 0:39:44,846
所有必要的状态

1031
00:39:45,856 --> 0:39:47,246
如果你已经在

1032
00:39:47,406 --> 0:39:48,706
你的引擎中这样做了

1033
00:39:48,706 --> 0:39:50,326
那么你将会很容易

1034
00:39:50,326 --> 0:39:54,286
用 PSO 创建来替换它

1035
00:39:54,386 --> 0:39:55,966
现在 Metal 中的着色器预热

1036
00:39:56,296 --> 0:39:58,196
是通过在不同的启用状态

1037
00:39:58,196 --> 0:40:00,396
创建单独的 PSO 对象而完成的

1038
00:39:58,196 --> 0:40:00,396
创建单独的 PSO 对象而完成的

1039
00:40:00,876 --> 0:40:03,326
首先 你需要创建描述符

1040
00:40:03,326 --> 0:40:05,436
然后设置直到第一个

1041
00:40:05,436 --> 0:40:06,776
绘制调用之前的所有状态

1042
00:40:06,776 --> 0:40:09,276
并创建第一个 pipelineState 对象

1043
00:40:10,036 --> 0:40:11,596
然后 你可以使用

1044
00:40:11,596 --> 0:40:13,146
相同的描述符

1045
00:40:13,206 --> 0:40:14,306
更改它的一些状态

1046
00:40:14,306 --> 0:40:15,886
就像这里我们启用了混合

1047
00:40:15,886 --> 0:40:17,706
然后创建第二个 PipelineState 对象

1048
00:40:18,966 --> 0:40:20,506
这两个都是预验证的

1049
00:40:20,726 --> 0:40:22,736
因此在绘制期间

1050
00:40:22,736 --> 0:40:24,466
你可以在绘制调用之间交换它们

1051
00:40:25,806 --> 0:40:27,036
如果你正在从 OpenGL 移植到 Metal

1052
00:40:27,036 --> 0:40:29,796
希望这是一个简单了当的更改

1053
00:40:29,796 --> 0:40:33,666
现在我们将结束

1054
00:40:33,666 --> 0:40:35,896
App 的设置阶段

1055
00:40:35,896 --> 0:40:37,146
我想提出一点将 App

1056
00:40:37,146 --> 0:40:38,486
从 OpenGL 移植到

1057
00:40:38,516 --> 0:40:40,446
Metal 的主要好处

1058
00:40:40,446 --> 0:40:41,856
那就是 这将开始减少

1059
00:40:41,946 --> 0:40:43,896
高执行成本操作的频率

1060
00:40:44,456 --> 0:40:47,656
在 OpenGL 中

1061
00:40:47,656 --> 0:40:48,846
你的 App 必须等到绘制时间

1062
00:40:48,916 --> 0:40:50,686
才能执行编译

1063
00:40:50,826 --> 0:40:52,146
链接着色器

1064
00:40:52,146 --> 0:40:54,346
或验证状态等操作

1065
00:40:54,346 --> 0:40:55,846
这意味着这些繁复的操作

1066
00:40:55,846 --> 0:40:57,396
在每一帧中都会发生很多次

1067
00:40:57,976 --> 0:41:00,626
一旦你将 App 移植到 Metal

1068
00:40:57,976 --> 0:41:00,626
一旦你将 App 移植到 Metal

1069
00:41:01,276 --> 0:41:02,506
App 就会将这些操作

1070
00:41:02,506 --> 0:41:04,876
移动到其生命周期的不同阶段

1071
00:41:05,876 --> 0:41:07,516
使用预编译的着色器

1072
00:41:07,516 --> 0:41:09,166
着色器编译已经从初始化阶段

1073
00:41:09,166 --> 0:41:10,556
移到了构建阶段

1074
00:41:10,616 --> 0:41:11,656
因此它只需只执行一次

1075
00:41:13,046 --> 0:41:14,426
然后使用 PSO

1076
00:41:14,426 --> 0:41:16,806
将状态定义移动到内容加载

1077
00:41:17,046 --> 0:41:18,256
这样你就有足够的绘制时间

1078
00:41:18,316 --> 0:41:19,806
来调用 draw 函数

1079
00:41:19,806 --> 0:41:23,936
现在我们已经完成了

1080
00:41:23,936 --> 0:41:25,516
App 的设置阶段

1081
00:41:25,976 --> 0:41:27,416
让我们讨论一下如何使用所有这些

1082
00:41:27,956 --> 0:41:31,006
资源 着色器和对象来渲染帧

1083
00:41:33,396 --> 0:41:35,006
为了绘制一个单独的帧

1084
00:41:35,306 --> 0:41:36,916
你的 App 需要首先

1085
00:41:37,136 --> 0:41:38,586
更新纹理和缓冲区

1086
00:41:39,486 --> 0:41:40,786
然后建立一个

1087
00:41:40,786 --> 0:41:42,506
要渲染的渲染目标

1088
00:41:42,506 --> 0:41:43,836
然后在最终呈现你的工作之前

1089
00:41:43,836 --> 0:41:45,006
进行多次渲染

1090
00:41:46,236 --> 0:41:48,096
让我们讨论一下更新资源

1091
00:41:49,316 --> 0:41:50,796
通常来说

1092
00:41:50,796 --> 0:41:52,506
在整个渲染循环中

1093
00:41:52,506 --> 0:41:54,606
至少一部分资源需要不断更新

1094
00:41:55,916 --> 0:41:57,536
这样的例子有

1095
00:41:57,536 --> 0:41:59,116
着色器常量顶 顶点和索引缓冲区

1096
00:41:59,146 --> 0:42:00,436
以及纹理

1097
00:41:59,146 --> 0:42:00,436
以及纹理

1098
00:42:00,436 --> 0:42:05,476
这些修改可以通过

1099
00:42:05,806 --> 0:42:07,506
GPU 和 CPU 之间的同步

1100
00:42:07,506 --> 0:42:08,586
在帧之间完成

1101
00:42:08,586 --> 0:42:11,836
一个典型的 GL 资源更新

1102
00:42:12,096 --> 0:42:13,866
可以是

1103
00:42:13,866 --> 0:42:17,126
以下调用的任意组合

1104
00:42:17,126 --> 0:42:20,236
一个缓冲区可以由 CPU 更新

1105
00:42:20,236 --> 0:42:21,886
或者你也可以通过 GPU 凭借缓冲到缓冲的拷贝

1106
00:42:21,886 --> 0:42:23,126
来更新一个缓冲区

1107
00:42:24,436 --> 0:42:26,416
类似地

1108
00:42:26,416 --> 0:42:29,576
纹理可以由 CPU 更新

1109
00:42:29,576 --> 0:42:31,006
也可以通过 GPU 上的

1110
00:42:31,006 --> 0:42:32,076
纹理到纹理拷贝来更新

1111
00:42:32,536 --> 0:42:35,916
乍一看

1112
00:42:35,916 --> 0:42:36,966
Metal 提供了类似的功能

1113
00:42:37,386 --> 0:42:38,886
但是正如 Lionel 之前提到的

1114
00:42:39,226 --> 0:42:40,466
用于存储缓冲区和纹理的容器

1115
00:42:40,466 --> 0:42:42,426
是不可变的

1116
00:42:42,426 --> 0:42:43,826
并且是在初始化过程中创建的

1117
00:42:44,326 --> 0:42:45,736
但是 它们的内容

1118
00:42:45,736 --> 0:42:48,096
可以通过以下任意组合进行修改

1119
00:42:48,686 --> 0:42:52,306
具有共享或托管存储模式的缓冲区

1120
00:42:52,306 --> 0:42:54,086
可以通过其在 CPU 上的

1121
00:42:54,456 --> 0:42:57,246
contents 属性进行更新

1122
00:42:58,006 --> 0:43:00,786
在 GPU 上

1123
00:42:58,006 --> 0:43:00,786
在 GPU 上

1124
00:43:00,786 --> 0:43:02,946
blitEncoder 负责所有的数据复制

1125
00:43:03,506 --> 0:43:05,226
所以你可以通过 blitEncoder 上的

1126
00:43:05,226 --> 0:43:06,996
copyFromBuffer 方法

1127
00:43:07,036 --> 0:43:09,436
从 GPU 更新一个缓冲区

1128
00:43:10,896 --> 0:43:12,766
类似地

1129
00:43:12,766 --> 0:43:14,296
你可以通过 replaceRegion 方法

1130
00:43:14,296 --> 0:43:16,056
在 CPU 上更新具有共享

1131
00:43:16,056 --> 0:43:17,056
或托管存储模式的纹理

1132
00:43:18,246 --> 0:43:20,436
或者在 GPU 上

1133
00:43:20,436 --> 0:43:21,416
你可以通过 blitEncoder 上的

1134
00:43:21,706 --> 0:43:23,716
copyFromTexture 方法来更新纹理

1135
00:43:24,246 --> 0:43:27,646
值得注意的是

1136
00:43:27,726 --> 0:43:28,746
当涉及到这些更新时

1137
00:43:28,746 --> 0:43:31,236
存储模式很重要

1138
00:43:31,236 --> 0:43:32,506
因为只有具有共享或托管存储模式的

1139
00:43:32,506 --> 0:43:35,000
缓冲区和纹理可以由 CPU 更新

1140
00:43:37,326 --> 0:43:38,406
OpenGL 为你管理

1141
00:43:38,406 --> 0:43:39,906
GPU 和 CPU 之间的同步

1142
00:43:39,906 --> 0:43:41,156
尽管有时

1143
00:43:41,226 --> 0:43:42,886
在你的 App 等待一个

1144
00:43:42,886 --> 0:43:44,156
或另一个完成时

1145
00:43:44,156 --> 0:43:45,446
你的 App 会付出过高的代价

1146
00:43:46,736 --> 0:43:48,336
在 Metal 中

1147
00:43:48,396 --> 0:43:49,936
因为你可以控制内存的存储方式

1148
00:43:49,936 --> 0:43:52,606
所以还可以控制数据同步的方式和时间

1149
00:43:53,156 --> 0:43:54,926
这对于缓冲区和纹理都是适用的

1150
00:43:55,656 --> 0:43:59,676
如果你将 GL App 移植到 Metal

1151
00:43:59,676 --> 0:44:01,956
并且仅为资源更新

1152
00:43:59,676 --> 0:44:01,956
并且仅为资源更新

1153
00:44:01,956 --> 0:44:03,806
使用一个缓冲区

1154
00:44:03,806 --> 0:44:06,306
那么流程将会是这个样子

1155
00:44:06,506 --> 0:44:08,176
首先 CPU 将在

1156
00:44:08,176 --> 0:44:10,106
设置渲染通道期间更新资源

1157
00:44:10,846 --> 0:44:12,046
然后在完成之后

1158
00:44:12,046 --> 0:44:13,346
缓冲区

1159
00:44:13,346 --> 0:44:15,006
将被 GPU

1160
00:44:15,006 --> 0:44:16,326
在执行渲染通道期间消耗

1161
00:44:17,086 --> 0:44:18,886
然而

1162
00:44:18,886 --> 0:44:20,056
当 GPU 从这个缓冲区读取数据时

1163
00:44:20,056 --> 0:44:21,736
CPU 可能会开始设置

1164
00:44:21,736 --> 0:44:22,826
接下来的渲染通道

1165
00:44:22,826 --> 0:44:24,126
并需要更新相同的缓冲区

1166
00:44:25,056 --> 0:44:26,666
这是一个明显的竞争情况

1167
00:44:27,646 --> 0:44:29,606
我们来看一个解决这个问题的方法

1168
00:44:30,186 --> 0:44:32,436
一个简单的解决方案是

1169
00:44:32,436 --> 0:44:34,466
将这个资源提交给 GPU

1170
00:44:34,766 --> 0:44:36,906
并在它所使用的 commandBuffer 上

1171
00:44:37,026 --> 0:44:38,426
调用 waitUntilCompleted

1172
00:44:39,466 --> 0:44:40,766
正如我们前面讨论的

1173
00:44:40,816 --> 0:44:43,456
这类似于 glFinish

1174
00:44:43,456 --> 0:44:45,456
它在所有 CPU 工作上放置一个信号量

1175
00:44:45,456 --> 0:44:47,176
直到 GPU 完成执行

1176
00:44:47,346 --> 0:44:49,926
使用该缓冲区的渲染通道

1177
00:44:49,986 --> 0:44:52,506
执行完成后

1178
00:44:52,506 --> 0:44:54,336
从 GPU 接收回一个调用

1179
00:44:54,336 --> 0:44:56,476
通过这种方式

1180
00:44:56,476 --> 0:44:58,046
你可以确保

1181
00:44:58,046 --> 0:44:59,466
你的单个缓冲区

1182
00:44:59,466 --> 0:45:02,006
不会被 CPU 或 GPU 争夺

1183
00:44:59,466 --> 0:45:02,006
不会被 CPU 或 GPU 争夺

1184
00:45:03,536 --> 0:45:07,416
然而正如你所看到的

1185
00:45:07,416 --> 0:45:09,016
CPU 在 GPU 执行时是空闲的

1186
00:45:09,016 --> 0:45:10,996
GPU 在等待 CPU

1187
00:45:10,996 --> 0:45:12,946
提交工作时处于饥饿状态

1188
00:45:13,786 --> 0:45:15,266
因此 虽然在你开始

1189
00:45:15,266 --> 0:45:16,506
解决这些竞争情况时

1190
00:45:16,506 --> 0:45:18,036
这对你很有帮助

1191
00:45:18,036 --> 0:45:19,426
但不建议

1192
00:45:19,426 --> 0:45:20,446
使用 waitUntilCompleted

1193
00:45:20,446 --> 0:45:21,766
因为它会给程序

1194
00:45:21,766 --> 0:45:24,146
带来延迟

1195
00:45:25,136 --> 0:45:27,646
同步更新的一种有效方法是

1196
00:45:27,716 --> 0:45:29,526
根据 App 的需要

1197
00:45:29,526 --> 0:45:30,826
使用两个或多个缓冲区

1198
00:45:31,796 --> 0:45:32,986
这样 CPU 就可以

1199
00:45:32,986 --> 0:45:34,776
写一个缓冲区

1200
00:45:34,876 --> 0:45:36,946
而 GPU 可以从另一个缓冲区读取数据

1201
00:45:38,126 --> 0:45:40,286
让我们看一个简单的三重缓冲示例

1202
00:45:40,756 --> 0:45:43,736
这里我们从

1203
00:45:43,736 --> 0:45:45,596
第一个资源开始

1204
00:45:45,956 --> 0:45:48,006
准备让 GPU 使用

1205
00:45:48,856 --> 0:45:49,566
但是我们没有使用

1206
00:45:49,636 --> 0:45:51,346
waitUntilCompleted

1207
00:45:51,346 --> 0:45:53,826
而是添加了一个补全处理程序

1208
00:45:53,826 --> 0:45:55,196
这样一旦相应的帧

1209
00:45:55,196 --> 0:45:57,006
在 GPU 上完成

1210
00:45:57,006 --> 0:46:00,156
它就可以让 CPU 知道它已经完成了

1211
00:45:57,006 --> 0:46:00,156
它就可以让 CPU 知道它已经完成了

1212
00:46:00,236 --> 0:46:02,456
但现在我们不需要等待它完成

1213
00:46:03,546 --> 0:46:04,976
当 GPU 执行时

1214
00:46:04,976 --> 0:46:06,286
三重缓冲的 CPU

1215
00:46:06,286 --> 0:46:08,686
可以跳过两次更新

1216
00:46:08,686 --> 0:46:09,656
因为它在不同的缓冲区

1217
00:46:11,046 --> 0:46:12,906
这是在 GPU 上

1218
00:46:12,906 --> 0:46:15,036
完成的帧

1219
00:46:15,036 --> 0:46:17,106
这是补全处理程序

1220
00:46:17,106 --> 0:46:18,176
运行的地方

1221
00:46:19,106 --> 0:46:20,606
它通知 GPU 的工作已经完成

1222
00:46:20,606 --> 0:46:22,016
然后将缓冲区

1223
00:46:22,016 --> 0:46:24,676
返回到缓冲池

1224
00:46:24,676 --> 0:46:26,796
以便在 GPU 继续执行时

1225
00:46:26,796 --> 0:46:28,096
下一帧的 CPU

1226
00:46:28,096 --> 0:46:29,166
可以使用它

1227
00:46:29,636 --> 0:46:31,586
我认为大多数开发者会发现

1228
00:46:31,586 --> 0:46:32,456
他们需要实现

1229
00:46:32,456 --> 0:46:33,876
三重缓冲

1230
00:46:33,876 --> 0:46:35,056
才能获得最佳性能

1231
00:46:35,536 --> 0:46:38,996
至于实现

1232
00:46:38,996 --> 0:46:40,106
当然 对于三重缓冲

1233
00:46:40,106 --> 0:46:41,856
你需要从一个包含三个缓冲区的队列开始

1234
00:46:43,706 --> 0:46:45,266
你还需要初始化

1235
00:46:45,306 --> 0:46:46,726
frameBorderySemaphore

1236
00:46:46,726 --> 0:46:47,676
初始值为 3

1237
00:46:47,676 --> 0:46:49,616
当 GPU 执行完毕时

1238
00:46:49,616 --> 0:46:51,616
这个信号量会在

1239
00:46:51,616 --> 0:46:53,166
每个帧边界处发出信号

1240
00:46:54,016 --> 0:46:55,336
让 CPU 知道

1241
00:46:55,336 --> 0:46:56,596
重写缓冲区是安全的

1242
00:46:57,026 --> 0:46:59,466
最后 我们需要

1243
00:46:59,466 --> 0:47:01,016
初始化缓冲区索引

1244
00:46:59,466 --> 0:47:01,016
初始化缓冲区索引

1245
00:47:01,016 --> 0:47:04,136
以指向当前帧的缓冲区

1246
00:47:04,316 --> 0:47:06,696
在渲染循环内部

1247
00:47:06,696 --> 0:47:08,026
在写入缓冲区之前

1248
00:47:08,026 --> 0:47:09,456
我们需要确保

1249
00:47:09,546 --> 0:47:12,446
GPU 执行完成了相应的帧

1250
00:47:13,666 --> 0:47:15,086
所以在每次渲染通道的开始

1251
00:47:15,536 --> 0:47:17,746
我们需要等待

1252
00:47:17,746 --> 0:47:18,976
frameBoundarySemaphore

1253
00:47:18,976 --> 0:47:20,966
一旦接收到信号

1254
00:47:20,996 --> 0:47:23,316
我们就知道获取它的缓冲区

1255
00:47:23,376 --> 0:47:24,536
并将其用于新的帧数据

1256
00:47:24,536 --> 0:47:25,626
是安全的

1257
00:47:26,216 --> 0:47:29,946
现在我们对命令进行编码

1258
00:47:29,946 --> 0:47:31,806
并将这个资源绑定到 GPU

1259
00:47:31,806 --> 0:47:33,466
以便在下一帧中使用

1260
00:47:34,556 --> 0:47:36,026
但在提交之前

1261
00:47:36,026 --> 0:47:37,386
我们必须将完成处理程序

1262
00:47:37,386 --> 0:47:39,876
添加到 commandBuffer 中

1263
00:47:39,876 --> 0:47:40,906
然后提交它

1264
00:47:41,636 --> 0:47:43,116
一旦 GPU 完成执行

1265
00:47:43,116 --> 0:47:44,446
我们的完成处理程序

1266
00:47:44,486 --> 0:47:46,006
就会向帧信号量发出信号

1267
00:47:46,066 --> 0:47:48,436
让 CPU 知道

1268
00:47:48,436 --> 0:47:49,766
它已经完成了

1269
00:47:49,766 --> 0:47:51,596
可以重用缓冲区来进行下一帧的编码

1270
00:47:52,146 --> 0:47:54,816
这是一个简单的

1271
00:47:54,816 --> 0:47:56,886
三重缓冲区实现

1272
00:47:56,886 --> 0:47:59,256
你可以用于任何的动态资源更新

1273
00:47:59,796 --> 0:48:04,186
好的 现在我们已经更新了资源

1274
00:47:59,796 --> 0:48:04,186
好的 现在我们已经更新了资源

1275
00:48:04,186 --> 0:48:07,026
让我们来谈谈渲染目标

1276
00:48:08,196 --> 0:48:10,456
在 OpenGL 中

1277
00:48:10,456 --> 0:48:12,386
Framebuffer 对象（FBO）

1278
00:48:11,716 --> 0:48:12,386
是渲染命令的目标

1279
00:48:13,416 --> 0:48:14,896
FBO 在一个伞下

1280
00:48:14,946 --> 0:48:16,136
收集许多纹理

1281
00:48:16,136 --> 0:48:17,596
和渲染缓冲对象

1282
00:48:17,596 --> 0:48:19,516
并在其中进行渲染

1283
00:48:20,076 --> 0:48:21,576
Framebuffer 的状态是可变的

1284
00:48:21,576 --> 0:48:23,736
通过绑定 Framebuffer

1285
00:48:23,736 --> 0:48:25,116
并最终将它们交换显示

1286
00:48:25,176 --> 0:48:27,306
渲染通道得以被松散地描述

1287
00:48:27,406 --> 0:48:30,756
这是一个典型的

1288
00:48:30,756 --> 0:48:32,066
带有 Framebuffer 的 OpenGL 工作流

1289
00:48:33,566 --> 0:48:36,036
在 App 的初始化阶段

1290
00:48:36,036 --> 0:48:37,126
一个 Framebuffer 被创建

1291
00:48:37,386 --> 0:48:39,206
然后通过绑定使它运转

1292
00:48:39,206 --> 0:48:41,546
然后你附加像纹理这样的资源

1293
00:48:41,546 --> 0:48:43,106
然后检查

1294
00:48:43,106 --> 0:48:44,336
Framebuffer 状态

1295
00:48:44,336 --> 0:48:45,706
以确保它是有效的

1296
00:48:46,976 --> 0:48:49,056
在绘制期间

1297
00:48:49,056 --> 0:48:50,246
你可以通过绑定 Framebuffer 来生成一个流

1298
00:48:50,246 --> 0:48:52,466
这是渲染通道的是隐式的开始

1299
00:48:53,236 --> 0:48:54,566
然后在对它调用绘制之前

1300
00:48:55,286 --> 0:48:57,086
你必须清除它

1301
00:48:57,086 --> 0:49:01,296
最后 你可以发出信号

1302
00:48:57,086 --> 0:49:01,296
最后 你可以发出信号

1303
00:49:01,296 --> 0:49:03,276
表示可以丢弃某些附件

1304
00:49:03,276 --> 0:49:04,606
让 OpenGL 知道没有必要

1305
00:49:04,606 --> 0:49:05,976
将这些内容存储到内存中

1306
00:49:06,796 --> 0:49:08,396
这些丢弃事件可以作为

1307
00:49:09,146 --> 0:49:11,036
结束渲染通道的提示

1308
00:49:11,416 --> 0:49:12,506
但这不是一个保证

1309
00:49:15,536 --> 0:49:17,286
在 Metal 中

1310
00:49:17,286 --> 0:49:19,546
渲染命令编码器是渲染命令的目标

1311
00:49:20,506 --> 0:49:21,686
渲染命令编码器

1312
00:49:21,686 --> 0:49:22,776
是由渲染通道描述符创建的

1313
00:49:22,776 --> 0:49:24,826
与 FBO 类似

1314
00:49:24,996 --> 0:49:26,496
它为一个渲染通道

1315
00:49:26,546 --> 0:49:27,746
收集许多渲染目的地

1316
00:49:27,746 --> 0:49:29,616
并促进对它们的渲染

1317
00:49:30,966 --> 0:49:32,116
渲染命令编码器

1318
00:49:32,116 --> 0:49:33,346
直接负责

1319
00:49:33,376 --> 0:49:34,666
为 GPU 生成硬件命令

1320
00:49:34,666 --> 0:49:36,736
渲染通道

1321
00:49:36,736 --> 0:49:38,496
由编码器的开始和结束

1322
00:49:38,556 --> 0:49:39,926
显式地描述

1323
00:49:40,496 --> 0:49:43,296
这是一个 Metal 中的渲染通道

1324
00:49:44,356 --> 0:49:46,306
首先 你创建 RenderPassDescriptor

1325
00:49:46,306 --> 0:49:48,686
RenderPassDescriptor

1326
00:49:48,686 --> 0:49:49,986
描述了所有附加的资源

1327
00:49:50,176 --> 0:49:52,936
还指定了

1328
00:49:52,936 --> 0:49:54,076
在渲染通道开始和结束时

1329
00:49:54,076 --> 0:49:55,316
发生的操作

1330
00:49:55,316 --> 0:49:58,176
这些操作称为 loadAction 和 storeAction

1331
00:49:59,086 --> 0:50:01,736
与 GL 相反 在 Metal 中

1332
00:49:59,086 --> 0:50:01,736
与 GL 相反 在 Metal 中

1333
00:50:01,736 --> 0:50:03,146
你不需要直接清除资源

1334
00:50:03,216 --> 0:50:06,106
相反地

1335
00:50:06,106 --> 0:50:08,406
你可以指定一个 loadAction 来清除它和颜色

1336
00:50:08,936 --> 0:50:11,756
这里 它是黑色的

1337
00:50:11,756 --> 0:50:13,586
这里的 storeAction 是 DontCare

1338
00:50:13,626 --> 0:50:16,296
类似于 GL 示例中的

1339
00:50:16,296 --> 0:50:18,306
GL 丢弃 Framebuffer

1340
00:50:19,646 --> 0:50:21,946
如果你希望将结果存储到内存中

1341
00:50:21,946 --> 0:50:23,146
你可以使用这里的 storeAction

1342
00:50:23,686 --> 0:50:27,266
在渲染时

1343
00:50:27,266 --> 0:50:28,306
你使用描述符来创建编码器

1344
00:50:28,306 --> 0:50:31,016
这样状态就设置好了

1345
00:50:31,226 --> 0:50:33,136
你进行所有的绘制调用

1346
00:50:33,136 --> 0:50:34,956
然后显式地结束编码

1347
00:50:35,436 --> 0:50:37,436
但是在丢弃 Framebuffer

1348
00:50:37,436 --> 0:50:39,336
或结束编码之前

1349
00:50:39,676 --> 0:50:40,976
让我们先绘制一些内容

1350
00:50:41,986 --> 0:50:44,366
一系列渲染命令

1351
00:50:44,366 --> 0:50:45,706
通常称为渲染通道

1352
00:50:46,866 --> 0:50:48,336
在渲染通道中

1353
00:50:48,336 --> 0:50:49,596
你可以设置状态并绘制调用输入

1354
00:50:49,596 --> 0:50:51,186
比如纹理和缓冲区

1355
00:50:51,186 --> 0:50:52,916
然后发出绘制命令

1356
00:50:54,016 --> 0:50:56,536
这是一个典型的 OpenGL 绘制序列

1357
00:50:57,706 --> 0:50:59,606
一个表现良好的 OpenGL App

1358
00:50:59,606 --> 0:51:00,856
试图提前设置它的所有状态

1359
00:50:59,606 --> 0:51:00,856
试图提前设置它的所有状态

1360
00:51:00,896 --> 0:51:03,236
然后绑定它的目标

1361
00:51:03,566 --> 0:51:07,826
和一个 GL 程序来链接着色器

1362
00:51:08,446 --> 0:51:11,166
然后它将把

1363
00:51:11,166 --> 0:51:13,086
顶点缓冲区 统一变量

1364
00:51:13,086 --> 0:51:15,216
和纹理等资源绑定到程序的不同阶段

1365
00:51:16,576 --> 0:51:17,846
最后 它会开始绘制

1366
00:51:21,356 --> 0:51:22,806
正如我们之前讨论过的

1367
00:51:22,806 --> 0:51:25,216
OpenGL 状态更改

1368
00:51:25,216 --> 0:51:26,336
可能会导致隐藏的验证检查

1369
00:51:26,336 --> 0:51:28,266
如果你已经在 OpenGL 中

1370
00:51:28,266 --> 0:51:29,896
将状态更改

1371
00:51:29,896 --> 0:51:31,146
组合在一起

1372
00:51:31,196 --> 0:51:32,596
以避免这些性能问题

1373
00:51:32,596 --> 0:51:33,916
那么你将充分利用

1374
00:51:34,186 --> 0:51:35,456
Metal 的预验证状态对象

1375
00:51:36,846 --> 0:51:38,636
在 Metal 中

1376
00:51:38,636 --> 0:51:39,776
因为验证只在

1377
00:51:39,776 --> 0:51:41,376
创建 PipelineState 对象时发生

1378
00:51:41,376 --> 0:51:42,926
而且着色器是预编译的

1379
00:51:43,296 --> 0:51:45,276
所以渲染循环会变得更小

1380
00:51:45,866 --> 0:51:48,446
但是对于开发者来说

1381
00:51:48,476 --> 0:51:49,706
不需要做太多的更改

1382
00:51:50,866 --> 0:51:52,326
这和我们在 OpenGL 中看到的代码是一样的

1383
00:51:52,326 --> 0:51:53,846
但是现在是在 Metal 中

1384
00:51:55,586 --> 0:51:57,006
你从渲染命令编码器开始

1385
00:51:57,006 --> 0:51:58,776
这相当于设置

1386
00:51:58,776 --> 0:52:00,486
GL Framebuffer

1387
00:51:58,776 --> 0:52:00,486
GL Framebuffer

1388
00:52:00,486 --> 0:52:03,696
然后设置预构建的

1389
00:52:03,696 --> 0:52:05,026
PipelineState 对象

1390
00:52:05,026 --> 0:52:06,466
它相当于 GL use 程序

1391
00:52:06,656 --> 0:52:09,356
在那之后

1392
00:52:09,356 --> 0:52:10,776
我们为我们的 Metal 程序分配资源

1393
00:52:10,966 --> 0:52:13,346
从 VertexBuffer 和统一变量开始

1394
00:52:13,946 --> 0:52:15,366
你可以在这里注意到

1395
00:52:15,366 --> 0:52:16,986
你必须为每个着色器阶段设置统一变量

1396
00:52:17,506 --> 0:52:20,326
而不是像 GL 中那样

1397
00:52:20,326 --> 0:52:22,586
为 GL 程序设置统一变量

1398
00:52:23,726 --> 0:52:24,936
在这里 因为我们是

1399
00:52:24,936 --> 0:52:26,256
直接从 OpenGL 移植过来的

1400
00:52:26,256 --> 0:52:27,216
所以我们发送的是同样的统一变量

1401
00:52:27,216 --> 0:52:29,726
但在 Metal 中

1402
00:52:29,726 --> 0:52:30,876
你可以按你的意愿发送不同的统一变量

1403
00:52:31,236 --> 0:52:33,506
然后设置你的纹理

1404
00:52:33,506 --> 0:52:35,306
并发出绘制调用

1405
00:52:35,366 --> 0:52:36,816
最后 一旦你完成了

1406
00:52:36,876 --> 0:52:38,376
所有的绘制调用

1407
00:52:38,376 --> 0:52:39,626
你就可以结束渲染通道了

1408
00:52:41,776 --> 0:52:43,146
虽然工作被提交了

1409
00:52:43,196 --> 0:52:45,526
却仍然有呈现的问题

1410
00:52:46,156 --> 0:52:49,716
当 GPU 渲染这个场景时

1411
00:52:49,716 --> 0:52:51,136
它会写出来给 Framebuffer 来显示

1412
00:52:52,236 --> 0:52:54,516
在 OpenGL 中为了呈现

1413
00:52:54,516 --> 0:52:56,746
渲染过的帧

1414
00:52:56,746 --> 0:52:58,386
当你从 drawInRect 返回时

1415
00:52:58,746 --> 0:53:00,706
上下文会为你调用 presetRenderBuffer

1416
00:52:58,746 --> 0:53:00,706
上下文会为你调用 presetRenderBuffer

1417
00:53:01,906 --> 0:53:03,136
而 Metal

1418
00:53:03,136 --> 0:53:04,596
则直接通过 drawables 的

1419
00:53:04,656 --> 0:53:06,486
Core Animations 池来实现这一点

1420
00:53:07,296 --> 0:53:09,646
drawables 是用于屏幕显示的纹理

1421
00:53:10,206 --> 0:53:13,036
你还可以将渲染通道

1422
00:53:13,086 --> 0:53:14,076
编码为 drawables

1423
00:53:15,126 --> 0:53:16,376
获取当前 drawable

1424
00:53:16,376 --> 0:53:17,726
然后在渲染循环之后

1425
00:53:18,036 --> 0:53:22,146
告诉命令缓冲区显示它

1426
00:53:22,346 --> 0:53:24,126
还记得我们的代码吗

1427
00:53:24,126 --> 0:53:26,296
从刚开始

1428
00:53:26,296 --> 0:53:28,156
我们讲窗口子系统的时候

1429
00:53:29,006 --> 0:53:30,396
这里 我们将深入研究

1430
00:53:30,396 --> 0:53:33,856
glkView 和 drawInMTKView

1431
00:53:33,916 --> 0:53:35,196
看看如何呈现所渲染的内容

1432
00:53:35,806 --> 0:53:37,956
就是这样

1433
00:53:38,706 --> 0:53:40,396
你需要在 glkView 中

1434
00:53:40,396 --> 0:53:42,336
绑定 Framebuffer

1435
00:53:42,336 --> 0:53:43,986
执行渲染命令

1436
00:53:43,986 --> 0:53:45,466
然后当你从 drawInRect 返回时

1437
00:53:45,466 --> 0:53:46,546
显示就已经处理好了

1438
00:53:47,996 --> 0:53:49,926
在 Metal 中也是一样的

1439
00:53:49,926 --> 0:53:51,186
你创建 commandBuffer

1440
00:53:51,586 --> 0:53:52,916
通过创建结束编码器

1441
00:53:52,916 --> 0:53:55,456
来执行渲染命令

1442
00:53:55,456 --> 0:53:56,796
然后你必须执行的

1443
00:53:56,836 --> 0:53:58,966
一个额外步骤是

1444
00:53:58,966 --> 0:54:00,926
在最终提交 commandBuffer 之前

1445
00:53:58,966 --> 0:54:00,926
在最终提交 commandBuffer 之前

1446
00:54:00,926 --> 0:54:02,726
调用 presentDrawable

1447
00:54:02,776 --> 0:54:05,416
如果你的渲染循环非常简单

1448
00:54:05,416 --> 0:54:06,806
只有一个编码器

1449
00:54:07,126 --> 0:54:08,296
那么这就是全部你要做的

1450
00:54:09,066 --> 0:54:10,446
然而 如果你有一个

1451
00:54:10,446 --> 0:54:12,106
更复杂的 App

1452
00:54:12,106 --> 0:54:13,416
你可能需要查看

1453
00:54:13,416 --> 0:54:14,956
我们关于“如何处理你的 drawables 

1454
00:54:14,956 --> 0:54:17,166
优化 Metal App 和游戏” 的演讲

1455
00:54:17,166 --> 0:54:20,346
这就是我们的框架

1456
00:54:20,706 --> 0:54:21,776
我们已经展示了如何轻松地

1457
00:54:21,776 --> 0:54:23,626
迁移窗口子系统

1458
00:54:24,446 --> 0:54:26,406
我们已经讨论了资源创建步骤

1459
00:54:26,956 --> 0:54:28,456
我们已经移植了着色器

1460
00:54:28,456 --> 0:54:30,586
并使用超棒的工具来快速找到问题

1461
00:54:31,136 --> 0:54:33,596
我们创建了渲染命令队列

1462
00:54:33,656 --> 0:54:34,946
命令缓冲区和命令编码器

1463
00:54:34,946 --> 0:54:37,266
来设置渲染通道

1464
00:54:37,516 --> 0:54:39,726
我们创建了预验证状态对象

1465
00:54:40,166 --> 0:54:42,496
然后为了渲染每个帧

1466
00:54:42,496 --> 0:54:44,626
我们使用三重缓冲来更新资源

1467
00:54:45,576 --> 0:54:46,536
我们在命令中

1468
00:54:46,536 --> 0:54:47,936
使用了渲染命令编码器

1469
00:54:47,936 --> 0:54:49,706
在最终呈现渲染帧之前

1470
00:54:49,706 --> 0:54:51,776
我们在渲染通道中

1471
00:54:51,816 --> 0:54:53,156
绘制了几何图形

1472
00:54:53,696 --> 0:54:56,106
我们已经通览了

1473
00:54:56,106 --> 0:54:57,516
图形 App 的生命历程

1474
00:54:57,516 --> 0:54:59,066
并展示了 Metal 是如何自然演变的

1475
00:54:59,906 --> 0:55:01,936
OpenGL 中的

1476
00:54:59,906 --> 0:55:01,936
OpenGL 中的

1477
00:55:02,286 --> 0:55:03,866
许多已建立的概念

1478
00:55:03,866 --> 0:55:05,476
已经迁移到 Metal 中

1479
00:55:05,476 --> 0:55:07,136
并与我们

1480
00:55:07,136 --> 0:55:09,156
为解决图形社区中所提出的特定问题

1481
00:55:09,156 --> 0:55:10,066
而添加的新概念协同工作

1482
00:55:11,086 --> 0:55:12,756
如果你能从这个会议中学到一件事

1483
00:55:12,756 --> 0:55:14,296
我们希望你能知道

1484
00:55:14,296 --> 0:55:15,706
将你的 App

1485
00:55:15,706 --> 0:55:17,516
从 OpenGL 移植到 Metal

1486
00:55:17,516 --> 0:55:19,246
其实并不可怕

1487
00:55:19,246 --> 0:55:21,626
并且你的 App 将从中受益

1488
00:55:23,006 --> 0:55:24,666
但如果你还能够学一件事

1489
00:55:24,666 --> 0:55:26,596
那就是 Metal 还提供了

1490
00:55:26,596 --> 0:55:28,516
一套很棒的工具

1491
00:55:29,626 --> 0:55:31,326
来增强你的开发体验

1492
00:55:32,226 --> 0:55:34,736
Max 已经演示了

1493
00:55:34,736 --> 0:55:35,836
Xcode 的内置框架

1494
00:55:35,836 --> 0:55:38,756
捕获和着色器调试器

1495
00:55:38,756 --> 0:55:40,166
以便你更深入地了解

1496
00:55:40,166 --> 0:55:40,866
代码中的细微问题

1497
00:55:41,366 --> 0:55:43,456
Xcode 也提供了

1498
00:55:43,456 --> 0:55:46,076
新的 GPU 内存查看器

1499
00:55:46,076 --> 0:55:48,566
以理解和优化如何在你的 App 中使用内存

1500
00:55:50,026 --> 0:55:51,406
在 Instruments 中

1501
00:55:51,406 --> 0:55:52,456
我们有一个游戏性能模板

1502
00:55:52,456 --> 0:55:53,826
其中包括 Metal 系统跟踪

1503
00:55:54,256 --> 0:55:56,016
从而可视化地提交问题

1504
00:55:56,466 --> 0:55:57,826
这可能会导致帧率下降

1505
00:55:59,216 --> 0:56:02,246
今年我们还在模拟器中

1506
00:55:59,216 --> 0:56:02,246
今年我们还在模拟器中

1507
00:56:02,606 --> 0:56:04,606
添加了对 Metal 的支持

1508
00:56:06,466 --> 0:56:07,476
是的 你一定很兴奋

1509
00:56:08,016 --> 0:56:10,436
[笑声]

1510
00:56:10,936 --> 0:56:13,026
macOS Catalina 上的全新 Xcode 11 中

1511
00:56:13,026 --> 0:56:15,226
我们有完整的硬件加速

1512
00:56:15,226 --> 0:56:17,356
使你能够利用 Metal 运行

1513
00:56:17,356 --> 0:56:20,226
你的 iOS 游戏和 App

1514
00:56:20,646 --> 0:56:21,806
以及 tvOS 模拟器

1515
00:56:23,186 --> 0:56:24,356
模拟器支持

1516
00:56:24,356 --> 0:56:26,766
MTLGPUFamilyApple2 功能集

1517
00:56:26,766 --> 0:56:28,356
应该可以满足

1518
00:56:28,406 --> 0:56:30,096
在所有可用屏幕分辨率下

1519
00:56:30,166 --> 0:56:32,586
运行所有 App 和游戏的大部分需求

1520
00:56:33,086 --> 0:56:36,246
要更深入地了解模拟器

1521
00:56:36,316 --> 0:56:37,746
以及它是如何

1522
00:56:37,746 --> 0:56:39,846
实现硬件加速的

1523
00:56:39,846 --> 0:56:41,966
请在明天早上查看关于模拟器的会议

1524
00:56:42,946 --> 0:56:44,016
如果你想解决一个

1525
00:56:44,016 --> 0:56:45,946
关于 Metal 的特定问题

1526
00:56:45,946 --> 0:56:48,306
你可以在网上看到我们很多很多的会议内容

1527
00:56:50,096 --> 0:56:52,496
获取更多信息

1528
00:56:52,496 --> 0:56:54,326
你可以在我们的网站上查看我们的文档

1529
00:56:54,326 --> 0:56:56,126
或者明天上午到 Metal 实验室

1530
00:56:56,126 --> 0:56:57,386
访问我们

1531
00:56:58,416 --> 0:57:00,136
这就是今天的全部内容

1532
00:56:58,416 --> 0:57:00,136
这就是今天的全部内容

1533
00:57:00,136 --> 0:57:01,956
谢谢大家的到来 我希望能在派对上见到你们

1534
00:57:02,516 --> 0:57:05,500
[掌声]
