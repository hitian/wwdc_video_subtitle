1
00:00:00,506 --> 0:00:04,500
[ Music ]

2
00:00:10,516 --> 0:00:15,086
[ Applause ]

3
00:00:15,586 --> 0:00:16,586
&gt;&gt; Good morning and welcome

4
00:00:16,586 --> 0:00:17,136
everyone.

5
00:00:17,326 --> 0:00:18,856
I am Guillem Vinals Gangolells

6
00:00:18,856 --> 0:00:20,356
from the Metal Ecosystem Team.

7
00:00:21,086 --> 0:00:22,486
This past year, we have been

8
00:00:22,486 --> 0:00:23,406
working with many game

9
00:00:23,406 --> 0:00:25,536
developers and identified some

10
00:00:25,536 --> 0:00:26,216
common issues.

11
00:00:26,896 --> 0:00:28,836
As a result, we decided to put

12
00:00:28,836 --> 0:00:29,746
this talk together.

13
00:00:30,446 --> 0:00:32,386
Today, I will be presenting a

14
00:00:32,436 --> 0:00:34,316
total of 18 best practices to

15
00:00:34,316 --> 0:00:36,246
help you improve your Metal app.

16
00:00:37,486 --> 0:00:39,246
Notice that I will not present

17
00:00:39,456 --> 0:00:42,736
OK practices or acceptable

18
00:00:42,736 --> 0:00:45,216
practices, and most definitely

19
00:00:45,566 --> 0:00:47,316
not practices that will just do

20
00:00:47,316 --> 0:00:47,786
the trick.

21
00:00:49,056 --> 0:00:51,336
The focus today will be on Metal

22
00:00:51,336 --> 0:00:52,196
Best Practices.

23
00:00:52,616 --> 0:00:55,786
So, please follow them.

24
00:00:55,996 --> 0:00:57,346
Before we get started, I would

25
00:00:57,346 --> 0:00:58,496
like to thank our friends at

26
00:00:58,496 --> 0:01:00,356
Digital Legends, our very

27
00:00:58,496 --> 0:01:00,356
Digital Legends, our very

28
00:01:00,356 --> 0:01:01,776
talented team from Barcelona.

29
00:01:02,476 --> 0:01:03,936
They are the developers of

30
00:01:03,936 --> 0:01:04,626
Afterpulse.

31
00:01:05,146 --> 0:01:07,236
Afterpulse is an awesome great

32
00:01:07,236 --> 0:01:07,876
looking game.

33
00:01:08,406 --> 0:01:09,606
It uses many rendering

34
00:01:09,606 --> 0:01:11,266
techniques such as cascaded

35
00:01:11,266 --> 0:01:13,186
shadow maps, a fully-featured

36
00:01:13,186 --> 0:01:14,966
deferred render as well as

37
00:01:14,966 --> 0:01:16,566
post-process such as bloom and

38
00:01:16,566 --> 0:01:16,796
FXAA.

39
00:01:16,846 --> 0:01:19,356
We will use Afterpulse

40
00:01:19,356 --> 0:01:21,116
throughout this presentation to

41
00:01:21,116 --> 0:01:22,366
demo our tools and highlight

42
00:01:22,366 --> 0:01:23,606
some of our best practices.

43
00:01:25,206 --> 0:01:26,366
We have split the talk into

44
00:01:26,366 --> 0:01:28,116
three sections, general

45
00:01:28,116 --> 0:01:30,346
performance, memory bandwidth,

46
00:01:31,226 --> 0:01:32,216
and memory footprint.

47
00:01:33,056 --> 0:01:34,316
So, let's get started with some

48
00:01:34,316 --> 0:01:35,776
general performance advice.

49
00:01:40,076 --> 0:01:41,666
In this section, I will talk

50
00:01:41,666 --> 0:01:43,076
about choosing the right

51
00:01:43,076 --> 0:01:45,586
resolution, avoiding overdraw,

52
00:01:45,586 --> 0:01:46,876
reduce the amount of fragment

53
00:01:46,876 --> 0:01:48,396
shader invocations per pixel

54
00:01:48,396 --> 0:01:48,846
written.

55
00:01:49,876 --> 0:01:51,076
We'll also talk about GPU

56
00:01:51,076 --> 0:01:52,936
submissions, resource streaming,

57
00:01:53,206 --> 0:01:54,446
and also a bit about thermals.

58
00:01:55,956 --> 0:01:56,986
So, let's get started with the

59
00:01:57,086 --> 0:01:58,156
first best practice.

60
00:01:58,536 --> 0:01:59,876
Choose the right resolution.

61
00:02:01,006 --> 0:02:02,446
Notice that each effect in your

62
00:02:02,446 --> 0:02:04,036
game may require a different

63
00:02:04,036 --> 0:02:04,656
resolution.

64
00:02:05,266 --> 0:02:06,436
So, it is very important that

65
00:02:06,436 --> 0:02:07,836
you consider the image quality

66
00:02:07,836 --> 0:02:09,606
and performance trade-off of

67
00:02:09,606 --> 0:02:11,266
each resolution and choose them

68
00:02:11,296 --> 0:02:11,816
carefully.

69
00:02:12,626 --> 0:02:14,966
Also, composite the game UI at

70
00:02:14,996 --> 0:02:17,146
native resolution or close to

71
00:02:17,146 --> 0:02:18,966
native, so the UI will look

72
00:02:19,036 --> 0:02:20,526
crisp no matter the display

73
00:02:20,526 --> 0:02:20,916
size.

74
00:02:21,556 --> 0:02:23,986
We can check the resolutions

75
00:02:23,986 --> 0:02:25,226
with the Metal Frame Debugger.

76
00:02:26,676 --> 0:02:28,166
Within the metal frame debugger,

77
00:02:28,166 --> 0:02:29,086
we will want to use the

78
00:02:29,086 --> 0:02:31,066
Dependency Viewer, which will

79
00:02:31,066 --> 0:02:32,356
show a graph of every render

80
00:02:32,356 --> 0:02:32,816
pass.

81
00:02:33,486 --> 0:02:34,806
In this case, we are using a

82
00:02:34,806 --> 0:02:36,186
Metal example application.

83
00:02:37,216 --> 0:02:38,346
To access the Dependency Viewer,

84
00:02:38,346 --> 0:02:39,526
we will select the command

85
00:02:39,526 --> 0:02:39,916
buffer.

86
00:02:40,546 --> 0:02:43,626
And, in this case, you can see

87
00:02:43,626 --> 0:02:44,936
that this example Metal

88
00:02:44,936 --> 0:02:46,346
application is using several

89
00:02:46,346 --> 0:02:48,166
effects within different

90
00:02:48,166 --> 0:02:49,106
resolution each.

91
00:02:49,906 --> 0:02:51,836
For example, Shadow Maps and

92
00:02:51,976 --> 0:02:53,976
SSAO have a different resolution

93
00:02:53,976 --> 0:02:55,126
than the main lighting pass.

94
00:02:55,776 --> 0:02:57,536
Also, the UI is composed of

95
00:02:57,536 --> 0:02:58,676
native resolution, so it will

96
00:02:58,676 --> 0:02:59,336
always look sharp.

97
00:03:00,646 --> 0:03:02,696
These resolutions look great and

98
00:03:02,696 --> 0:03:04,056
perform well for this Metal

99
00:03:04,056 --> 0:03:04,716
application.

100
00:03:05,186 --> 0:03:06,306
We're asking for you to do a

101
00:03:06,306 --> 0:03:07,956
similar choice for your game.

102
00:03:08,926 --> 0:03:10,026
So, let's move on to best

103
00:03:10,026 --> 0:03:12,026
practice number 2.

104
00:03:12,436 --> 0:03:13,986
Minimize non-opaque overdraw.

105
00:03:15,086 --> 0:03:16,326
Overdraw is the amount of

106
00:03:16,416 --> 0:03:17,866
fragment shader's process for

107
00:03:17,866 --> 0:03:18,836
each pixel written.

108
00:03:19,706 --> 0:03:21,776
iOS GPUs are excellent at

109
00:03:21,776 --> 0:03:23,256
reducing opaque overdraw.

110
00:03:23,616 --> 0:03:25,006
We just need to help a bit.

111
00:03:25,606 --> 0:03:28,096
So, the best practice here is to

112
00:03:28,096 --> 0:03:30,326
render opaque meshes first and

113
00:03:30,326 --> 0:03:31,676
translucent meshes later.

114
00:03:32,296 --> 0:03:33,916
Also, do not render fully

115
00:03:33,916 --> 0:03:35,956
transparent or invisible meshes.

116
00:03:36,256 --> 0:03:38,326
We will, once again, use the

117
00:03:38,326 --> 0:03:40,006
Metal Frame Debugger to help us.

118
00:03:40,636 --> 0:03:42,176
This time, we will look at the

119
00:03:42,176 --> 0:03:44,656
GPU Counters gauge to verify the

120
00:03:44,656 --> 0:03:45,966
overdraw for a given render

121
00:03:45,966 --> 0:03:46,436
pass.

122
00:03:47,286 --> 0:03:48,486
We will want to focus on the

123
00:03:48,486 --> 0:03:49,946
main lighting pass of our Metal

124
00:03:49,946 --> 0:03:50,856
Demo application.

125
00:03:52,306 --> 0:03:54,126
In order to calculate overdraw,

126
00:03:54,506 --> 0:03:55,576
we will look at the number of

127
00:03:55,576 --> 0:03:57,036
fragment shader invocations

128
00:03:57,036 --> 0:03:58,416
divided by the amount of pixel

129
00:03:58,416 --> 0:03:58,756
store.

130
00:03:59,536 --> 0:04:00,786
We can use the filter bar at the

131
00:03:59,536 --> 0:04:00,786
We can use the filter bar at the

132
00:04:00,786 --> 0:04:02,066
bottom to quickly look for

133
00:04:02,066 --> 0:04:03,216
performance counters right

134
00:04:03,216 --> 0:04:03,596
after.

135
00:04:04,206 --> 0:04:06,866
In this case, it's a fully

136
00:04:06,866 --> 0:04:07,536
opaque scene.

137
00:04:07,536 --> 0:04:09,026
So, there's nothing else to

138
00:04:09,026 --> 0:04:09,516
verify.

139
00:04:09,516 --> 0:04:10,846
There's no overdraw and we are

140
00:04:10,846 --> 0:04:11,396
good to go.

141
00:04:11,946 --> 0:04:12,896
We're asking for you to do

142
00:04:12,896 --> 0:04:14,386
something similar with your game

143
00:04:14,756 --> 0:04:16,026
and verify that you're also good

144
00:04:16,026 --> 0:04:16,396
to go.

145
00:04:17,606 --> 0:04:19,156
So, let's move on to the next

146
00:04:20,206 --> 0:04:21,755
best practice.

147
00:04:21,846 --> 0:04:23,376
Submit GPU work early.

148
00:04:26,146 --> 0:04:27,556
Scheduling all the off-screen

149
00:04:27,556 --> 0:04:29,056
GPU work early is very

150
00:04:29,056 --> 0:04:29,706
important.

151
00:04:30,206 --> 0:04:31,576
It will improve the latency and

152
00:04:31,576 --> 0:04:33,076
responsiveness of your game and

153
00:04:33,266 --> 0:04:34,816
it will also allow the system to

154
00:04:34,816 --> 0:04:36,076
adapt to the workload much

155
00:04:36,126 --> 0:04:36,496
better.

156
00:04:37,456 --> 0:04:38,496
So, it is important that you

157
00:04:38,496 --> 0:04:40,396
have multiple GPU submissions in

158
00:04:40,396 --> 0:04:40,976
your frame.

159
00:04:41,516 --> 0:04:43,416
In particular, you will want an

160
00:04:43,456 --> 0:04:45,656
early GPU submission before

161
00:04:46,176 --> 0:04:47,626
waiting for the drawables since 

162
00:04:47,626 --> 0:04:49,546
that stall the render thread.

163
00:04:50,376 --> 0:04:52,416
And after you get the drawable

164
00:04:52,416 --> 0:04:53,336
which will be as late as

165
00:04:53,366 --> 0:04:55,116
possible in the frame, you will

166
00:04:55,116 --> 0:04:57,626
then have a late GPU submission

167
00:04:58,106 --> 0:04:59,216
where you will schedule all the

168
00:04:59,216 --> 0:05:00,986
on-screen work, potentially, the

169
00:04:59,216 --> 0:05:00,986
on-screen work, potentially, the

170
00:05:00,986 --> 0:05:02,306
UI Composition Pass.

171
00:05:03,476 --> 0:05:04,426
Since, it's a bit tricky to

172
00:05:04,426 --> 0:05:05,976
explain, we have demo prepared.

173
00:05:06,726 --> 0:05:08,186
So, let's do a quick demo and

174
00:05:08,186 --> 0:05:09,396
I'll show you how to identify

175
00:05:09,396 --> 0:05:10,746
this with Metal System Trace.

176
00:05:13,656 --> 0:05:16,316
Cool. What we see here is a

177
00:05:16,346 --> 0:05:18,366
capture of Afterpulse which we

178
00:05:18,366 --> 0:05:20,256
took last year with an older

179
00:05:20,256 --> 0:05:21,046
build of the game.

180
00:05:21,696 --> 0:05:23,096
This was taken with a game

181
00:05:23,096 --> 0:05:24,216
performance template.

182
00:05:24,446 --> 0:05:26,046
We introduced this template last

183
00:05:26,046 --> 0:05:26,296
year.

184
00:05:26,786 --> 0:05:28,036
So, you're already familiar with

185
00:05:28,036 --> 0:05:29,336
some of the instruments here.

186
00:05:29,336 --> 0:05:31,166
New this year, we have added the

187
00:05:31,166 --> 0:05:33,056
Thermal State as well as the

188
00:05:33,056 --> 0:05:34,506
Metal Resource Allocations.

189
00:05:34,676 --> 0:05:35,986
We'll talk about this later.

190
00:05:36,796 --> 0:05:38,166
For now, what we want to focus

191
00:05:38,166 --> 0:05:40,346
on, our potential stutters or

192
00:05:40,346 --> 0:05:40,816
issues.

193
00:05:41,396 --> 0:05:42,716
In this case, we want to look at

194
00:05:42,716 --> 0:05:44,196
the Display panel and see that

195
00:05:44,196 --> 0:05:46,086
there's lots of events at the

196
00:05:46,086 --> 0:05:48,006
bottom with-- where surfaces

197
00:05:48,006 --> 0:05:49,236
have been on-screen for longer

198
00:05:49,236 --> 0:05:49,986
than expected.

199
00:05:50,576 --> 0:05:51,766
So, maybe that's a problem and

200
00:05:51,766 --> 0:05:52,606
we should look at it.

201
00:05:53,276 --> 0:05:54,536
What we will do is zoom in to

202
00:05:54,536 --> 0:05:56,706
one of these regions holding the

203
00:05:56,706 --> 0:06:00,396
Option key and dragging the--

204
00:05:56,706 --> 0:06:00,396
Option key and dragging the--

205
00:06:00,836 --> 0:06:02,036
our cursor over it.

206
00:06:02,126 --> 0:06:04,806
So, in this case, we can see

207
00:06:04,806 --> 0:06:07,456
that there's two frames that

208
00:06:07,456 --> 0:06:09,536
seem to be later than we would

209
00:06:09,536 --> 0:06:12,106
expect, at the same time, that

210
00:06:12,106 --> 0:06:14,176
the GPU is idle for a long time.

211
00:06:14,756 --> 0:06:16,046
So, that potentially is the

212
00:06:16,046 --> 0:06:17,656
cause of the issue we are trying

213
00:06:17,656 --> 0:06:18,306
to debug here.

214
00:06:18,306 --> 0:06:19,756
So, let's look into more detail.

215
00:06:20,576 --> 0:06:22,736
We'll do that by disclosing all

216
00:06:22,736 --> 0:06:24,406
the tracks in Metal System Trace

217
00:06:24,406 --> 0:06:25,836
which you're already familiar

218
00:06:25,836 --> 0:06:26,086
with.

219
00:06:26,976 --> 0:06:29,236
So, what we are seeing here are

220
00:06:30,046 --> 0:06:31,616
how our application is encoding

221
00:06:31,616 --> 0:06:33,716
work and also how our GPU is

222
00:06:33,716 --> 0:06:34,756
processing this work.

223
00:06:35,286 --> 0:06:36,636
So, let's focus on this orange

224
00:06:36,636 --> 0:06:37,036
frame.

225
00:06:37,746 --> 0:06:39,006
As you can see here, there's a

226
00:06:39,006 --> 0:06:41,176
lot of work being encoded by the

227
00:06:41,176 --> 0:06:42,466
apps, so we have the Shadow

228
00:06:42,466 --> 0:06:45,066
Maps, the Deferred Pass as well

229
00:06:45,066 --> 0:06:46,366
as part of the bloom chain, et

230
00:06:46,366 --> 0:06:46,726
cetera.

231
00:06:47,436 --> 0:06:50,116
So, the GPU is not actually

232
00:06:50,116 --> 0:06:51,836
processing that work, at the

233
00:06:51,836 --> 0:06:54,396
same time that the thread is

234
00:06:54,396 --> 0:06:55,696
waiting for the drawable.

235
00:06:56,206 --> 0:06:57,426
So that's what this causing this

236
00:06:57,426 --> 0:06:59,506
idle gap, but we already have

237
00:06:59,506 --> 0:07:00,586
some work encoded.

238
00:06:59,506 --> 0:07:00,586
some work encoded.

239
00:07:00,946 --> 0:07:02,336
We just didn't submit it.

240
00:07:03,136 --> 0:07:04,056
So, that's what the best

241
00:07:04,056 --> 0:07:05,926
practice was about you

242
00:07:05,926 --> 0:07:07,286
submitting all the off-screen

243
00:07:07,286 --> 0:07:09,356
work which you can encode ahead

244
00:07:09,356 --> 0:07:10,776
of time before waiting for the

245
00:07:10,776 --> 0:07:11,256
drawable.

246
00:07:11,866 --> 0:07:13,166
So, the solution would be to do

247
00:07:13,166 --> 0:07:14,686
one GPU submission here.

248
00:07:15,296 --> 0:07:16,866
Notice that there's only one GPU

249
00:07:16,866 --> 0:07:18,696
submission which we can see here

250
00:07:19,066 --> 0:07:20,256
towards the end of the frame.

251
00:07:20,346 --> 0:07:22,126
So, all the GPU work just

252
00:07:22,126 --> 0:07:23,046
happens at the end.

253
00:07:23,836 --> 0:07:25,616
Fortunately, this is very easy

254
00:07:25,656 --> 0:07:27,656
to simple-- very easy to fix.

255
00:07:27,686 --> 0:07:29,406
And, in fact, Digital Legends

256
00:07:29,406 --> 0:07:30,266
has already fixed it.

257
00:07:30,266 --> 0:07:31,476
So, let's look at the new trace

258
00:07:31,476 --> 0:07:33,186
of Afterpulse and see how it

259
00:07:33,186 --> 0:07:33,636
looks like.

260
00:07:34,876 --> 0:07:36,486
OK. So, let's zoom in.

261
00:07:37,546 --> 0:07:38,786
In this case, we can see that

262
00:07:38,786 --> 0:07:40,926
there's no idle time while we

263
00:07:40,926 --> 0:07:42,046
are waiting for the drawable.

264
00:07:42,846 --> 0:07:44,096
So, let's disclose the Metal

265
00:07:44,096 --> 0:07:45,506
System Trace tracks as we did

266
00:07:45,506 --> 0:07:45,966
before.

267
00:07:47,196 --> 0:07:48,456
And, in this case, we can see

268
00:07:48,456 --> 0:07:50,766
that the GPU is processing the

269
00:07:50,766 --> 0:07:52,196
work that we have already

270
00:07:52,196 --> 0:07:54,946
scheduled before getting the

271
00:07:54,946 --> 0:07:55,426
drawable.

272
00:07:56,266 --> 0:07:58,126
So, in this case, the idle time

273
00:07:58,126 --> 0:07:59,766
is much smaller.

274
00:07:59,766 --> 0:08:01,216
So, this allows the system to

275
00:07:59,766 --> 0:08:01,216
So, this allows the system to

276
00:08:01,216 --> 0:08:02,316
adapt to the workload much

277
00:08:02,316 --> 0:08:04,406
better and there's no problems.

278
00:08:04,926 --> 0:08:07,486
So, after this, we know we are

279
00:08:07,486 --> 0:08:09,466
good to go and we are-- we

280
00:08:09,466 --> 0:08:11,536
already have multiple GPU

281
00:08:11,536 --> 0:08:13,676
submissions which do not cause

282
00:08:13,676 --> 0:08:15,106
any stall because we do them

283
00:08:15,296 --> 0:08:16,476
before waiting for the drawable.

284
00:08:16,526 --> 0:08:17,796
So, let's go back to the slides.

285
00:08:19,736 --> 0:08:21,356
OK. So, the fix for that is

286
00:08:21,356 --> 0:08:22,876
actually quite simple much

287
00:08:22,876 --> 0:08:23,826
easier than explaining the

288
00:08:23,866 --> 0:08:25,166
problem in the first place.

289
00:08:25,926 --> 0:08:26,976
What we will want to do is

290
00:08:26,976 --> 0:08:28,616
simply create multiple command

291
00:08:28,616 --> 0:08:29,606
buffers per frame.

292
00:08:30,356 --> 0:08:31,686
So, we'll want to first create

293
00:08:31,686 --> 0:08:33,126
the command buffer to encode all

294
00:08:33,126 --> 0:08:34,856
the off-screen work which will

295
00:08:34,856 --> 0:08:37,176
be our early GPU submission.

296
00:08:37,356 --> 0:08:38,765
We will commit the command

297
00:08:38,765 --> 0:08:40,996
buffer and then wait for the

298
00:08:40,996 --> 0:08:42,926
next drawable, which will stall

299
00:08:42,926 --> 0:08:43,336
our thread.

300
00:08:43,336 --> 0:08:45,956
After we have the drawable, we

301
00:08:45,956 --> 0:08:48,586
will create one final command

302
00:08:48,586 --> 0:08:49,946
buffer where we will encode all

303
00:08:49,946 --> 0:08:52,026
the on-screen work and present

304
00:08:52,026 --> 0:08:52,606
the drawable.

305
00:08:53,446 --> 0:08:55,776
This will be our final CPU-- GPU

306
00:08:55,776 --> 0:08:56,446
submission.

307
00:08:57,256 --> 0:08:58,736
And this will also ensure that

308
00:08:58,736 --> 0:09:00,146
the frame pacing is actually

309
00:08:58,736 --> 0:09:00,146
the frame pacing is actually

310
00:09:00,146 --> 0:09:01,096
good enough as well.

311
00:09:02,676 --> 0:09:04,126
It's as simple as that.

312
00:09:04,126 --> 0:09:05,286
Just use multiple command

313
00:09:05,286 --> 0:09:05,646
buffers.

314
00:09:06,496 --> 0:09:07,666
So, let's move on to the best

315
00:09:07,666 --> 0:09:09,716
practice number 4, stream

316
00:09:09,716 --> 0:09:10,836
resources efficiently.

317
00:09:11,746 --> 0:09:13,336
Allocating resources does take

318
00:09:13,386 --> 0:09:13,726
time.

319
00:09:14,476 --> 0:09:16,256
And streaming resources from the

320
00:09:16,256 --> 0:09:17,896
render thread may cause stalls.

321
00:09:18,346 --> 0:09:19,606
So, the best practice here is

322
00:09:19,606 --> 0:09:21,146
for you to consider the memory

323
00:09:21,146 --> 0:09:22,956
and performance trade-off of

324
00:09:22,956 --> 0:09:23,766
your resource streaming

325
00:09:23,766 --> 0:09:26,036
algorithm and make sure that you

326
00:09:26,116 --> 0:09:27,906
allocate and load GPU resources

327
00:09:27,906 --> 0:09:29,216
at launch time since you will

328
00:09:29,216 --> 0:09:30,426
not need to allocate them at

329
00:09:30,426 --> 0:09:31,006
runtime.

330
00:09:31,916 --> 0:09:33,316
And any resource that you need

331
00:09:33,316 --> 0:09:35,336
to stream at runtime, make sure

332
00:09:35,336 --> 0:09:36,826
you do so from a dedicated

333
00:09:36,886 --> 0:09:37,146
thread.

334
00:09:37,786 --> 0:09:39,266
It is very important that you do

335
00:09:39,266 --> 0:09:40,726
so in order to avoid stalls.

336
00:09:41,216 --> 0:09:43,266
We will revisit resource

337
00:09:43,266 --> 0:09:44,936
streaming later on in the memory

338
00:09:44,996 --> 0:09:47,216
footprint section and reevaluate

339
00:09:47,216 --> 0:09:48,326
the memory and performance

340
00:09:48,386 --> 0:09:48,936
trade-off.

341
00:09:49,656 --> 0:09:51,406
For now, let's just use Metal

342
00:09:51,406 --> 0:09:52,726
System Trace to tune our

343
00:09:52,726 --> 0:09:53,516
resource streaming.

344
00:09:54,516 --> 0:09:56,066
New this year, we're having an

345
00:09:56,066 --> 0:09:57,836
Allocations Track which will

346
00:09:57,836 --> 0:09:59,166
show you an event for each

347
00:09:59,166 --> 0:10:00,646
resource allocation and the

348
00:09:59,166 --> 0:10:00,646
resource allocation and the

349
00:10:00,646 --> 0:10:02,866
allocation in the same timeline

350
00:10:02,866 --> 0:10:04,116
as all the other instruments.

351
00:10:05,046 --> 0:10:06,526
This will allow you to identify

352
00:10:06,526 --> 0:10:07,746
all those resources which you

353
00:10:07,746 --> 0:10:08,866
are streaming from the main

354
00:10:08,866 --> 0:10:10,476
render thread which could

355
00:10:10,476 --> 0:10:11,676
potentially cause a stall.

356
00:10:12,786 --> 0:10:14,806
Something else you should tune

357
00:10:14,806 --> 0:10:16,686
as well is for thermals.

358
00:10:17,366 --> 0:10:18,936
It is important that you design

359
00:10:18,936 --> 0:10:20,006
your game for sustained

360
00:10:20,006 --> 0:10:20,716
performance.

361
00:10:21,206 --> 0:10:22,466
This will improve the overall

362
00:10:22,566 --> 0:10:24,466
thermals of the system as well

363
00:10:24,466 --> 0:10:25,256
as the stability and

364
00:10:25,256 --> 0:10:26,666
responsiveness of your game.

365
00:10:27,526 --> 0:10:28,736
So, the best practice will be

366
00:10:28,816 --> 0:10:31,026
for you to test your game under

367
00:10:31,026 --> 0:10:32,166
serious thermal state.

368
00:10:32,906 --> 0:10:34,856
Also, consider tuning your game

369
00:10:35,216 --> 0:10:36,666
for this serious thermal state

370
00:10:36,666 --> 0:10:38,086
since that will hopefully help

371
00:10:38,086 --> 0:10:39,756
you to know the thermal

372
00:10:39,756 --> 0:10:40,186
throttle.

373
00:10:41,656 --> 0:10:44,256
So, new this year, we're adding

374
00:10:44,256 --> 0:10:46,036
Device Conditions into Xcode,

375
00:10:46,476 --> 0:10:47,816
which will allow you to set the

376
00:10:47,876 --> 0:10:50,166
serious thermal state directly

377
00:10:50,206 --> 0:10:51,396
from the device's window.

378
00:10:52,596 --> 0:10:54,106
There is a talk at the bottom

379
00:10:54,106 --> 0:10:55,066
where this topic we'll be

380
00:10:55,066 --> 0:10:56,436
covering to more detail and I

381
00:10:56,436 --> 0:10:57,506
encourage you to watch.

382
00:10:59,896 --> 0:11:01,626
Also, we can use the Xcode

383
00:10:59,896 --> 0:11:01,626
Also, we can use the Xcode

384
00:11:01,626 --> 0:11:03,206
Energy Gauge to verify the

385
00:11:03,206 --> 0:11:04,736
thermal state that the device is

386
00:11:04,736 --> 0:11:05,166
running at.

387
00:11:05,976 --> 0:11:07,126
In this example, we are

388
00:11:07,126 --> 0:11:08,556
conditioning our device to run

389
00:11:08,556 --> 0:11:10,576
at serious thermal state and we

390
00:11:10,576 --> 0:11:11,966
are effectively verifying that

391
00:11:11,966 --> 0:11:13,406
the device get into serious

392
00:11:13,446 --> 0:11:14,056
thermal state.

393
00:11:14,416 --> 0:11:15,336
It just takes a couple of

394
00:11:15,336 --> 0:11:16,736
seconds to ramp-up to that.

395
00:11:17,906 --> 0:11:19,386
Cool. So, now let's move on to

396
00:11:19,386 --> 0:11:21,016
the second part of our talk.

397
00:11:21,816 --> 0:11:23,416
In this section, we'll talk

398
00:11:23,416 --> 0:11:25,266
about memory bandwidth.

399
00:11:27,016 --> 0:11:28,146
Memory bandwidth is very

400
00:11:28,146 --> 0:11:28,816
important.

401
00:11:29,236 --> 0:11:30,936
That is because memory transfers

402
00:11:30,936 --> 0:11:31,606
are costly.

403
00:11:32,156 --> 0:11:33,836
They consume power and generate

404
00:11:33,906 --> 0:11:34,166
heat.

405
00:11:35,206 --> 0:11:37,346
To help mitigate in that, iOS

406
00:11:37,346 --> 0:11:38,876
devices have shared system

407
00:11:38,876 --> 0:11:40,476
memory between the CPU and the

408
00:11:40,476 --> 0:11:43,056
GPU as well as dedicated Tile

409
00:11:43,056 --> 0:11:44,416
Memory for the GPU.

410
00:11:45,336 --> 0:11:46,926
Metal is designed to help you

411
00:11:46,926 --> 0:11:48,376
leverage both.

412
00:11:49,026 --> 0:11:50,786
So, now, let's see how by start

413
00:11:50,786 --> 0:11:52,416
looking into textures.

414
00:11:53,406 --> 0:11:55,166
Texture sampling is probably the

415
00:11:55,166 --> 0:11:57,026
main bandwidth consumer in your

416
00:11:57,026 --> 0:11:57,376
game.

417
00:11:57,956 --> 0:11:59,376
So, we have some best practices

418
00:11:59,376 --> 0:12:00,496
for you to configure your

419
00:11:59,376 --> 0:12:00,496
for you to configure your

420
00:12:00,496 --> 0:12:01,366
textures correctly.

421
00:12:02,416 --> 0:12:03,876
In this section, we will talk

422
00:12:03,876 --> 0:12:04,946
about offline texture

423
00:12:04,946 --> 0:12:07,466
compression for game assets, GPU

424
00:12:07,466 --> 0:12:09,486
texture compression as well as

425
00:12:09,486 --> 0:12:10,816
how to choose the correct pixel

426
00:12:10,816 --> 0:12:11,286
format.

427
00:12:11,946 --> 0:12:13,026
So, let's start with texture

428
00:12:13,026 --> 0:12:13,526
assets.

429
00:12:14,056 --> 0:12:16,756
It is very important for you to

430
00:12:16,756 --> 0:12:18,106
compress your texture assets.

431
00:12:18,846 --> 0:12:20,886
That is because sampling large

432
00:12:20,886 --> 0:12:23,066
textures may be inefficient and

433
00:12:23,066 --> 0:12:24,196
your assets may also be

434
00:12:24,196 --> 0:12:25,016
arbitrarily large.

435
00:12:25,716 --> 0:12:26,756
So make sure they are all

436
00:12:26,756 --> 0:12:29,446
compressed and also generate

437
00:12:29,446 --> 0:12:30,916
midmaps for all the textures

438
00:12:30,916 --> 0:12:31,996
which may be minified.

439
00:12:32,476 --> 0:12:34,346
So, let's see the memory savings

440
00:12:34,346 --> 0:12:35,396
of texture compression.

441
00:12:35,976 --> 0:12:38,306
This is one of the largest

442
00:12:38,336 --> 0:12:39,606
textures of Afterpulse.

443
00:12:40,486 --> 0:12:42,326
If this texture were to be

444
00:12:42,326 --> 0:12:44,226
uncompressed, it would take

445
00:12:44,226 --> 0:12:46,296
about 16 megabytes of memory to

446
00:12:46,296 --> 0:12:46,606
load.

447
00:12:47,846 --> 0:12:49,886
By using texture compression, we

448
00:12:49,886 --> 0:12:51,846
can lower let-- this to less

449
00:12:51,846 --> 0:12:54,036
than 3 megabytes including the

450
00:12:54,036 --> 0:12:55,106
full mipmap chain.

451
00:12:55,876 --> 0:12:57,446
Those are great memory savings.

452
00:12:58,546 --> 0:13:00,176
Notice though, that Afterpulse

453
00:12:58,546 --> 0:13:00,176
Notice though, that Afterpulse

454
00:13:00,176 --> 0:13:02,416
is using PVRTC because it runs

455
00:13:02,576 --> 0:13:05,496
on A7 devices such as the iPhone

456
00:13:05,496 --> 0:13:06,126
5S.

457
00:13:07,066 --> 0:13:08,496
If your game targets newer

458
00:13:08,496 --> 0:13:10,996
devices, using STC instead since

459
00:13:10,996 --> 0:13:12,496
it offers better compression

460
00:13:12,496 --> 0:13:13,726
ratio in image quality.

461
00:13:15,206 --> 0:13:16,596
To verify that our assets our

462
00:13:16,596 --> 0:13:18,736
compressed correctly, we can use

463
00:13:18,736 --> 0:13:19,596
the Memory Viewer.

464
00:13:21,026 --> 0:13:22,186
The Metal Memory Viewer is a

465
00:13:22,186 --> 0:13:23,636
great tool which I will fully

466
00:13:23,636 --> 0:13:24,636
introduce in the memory

467
00:13:24,636 --> 0:13:25,496
footprint section.

468
00:13:26,166 --> 0:13:28,446
For now, will you-- we will use

469
00:13:28,446 --> 0:13:30,086
it to inspect all of our assets.

470
00:13:30,566 --> 0:13:31,626
We can double check they are

471
00:13:31,626 --> 0:13:33,796
compressed, mipmapped, and also

472
00:13:33,796 --> 0:13:34,886
look great.

473
00:13:36,216 --> 0:13:38,246
But what happens with all those

474
00:13:38,246 --> 0:13:40,166
textures which you cannot

475
00:13:40,216 --> 0:13:42,676
compress ahead of time such as

476
00:13:42,676 --> 0:13:43,956
render targets or all the

477
00:13:43,956 --> 0:13:47,566
textures generated at runtime?

478
00:13:47,566 --> 0:13:49,316
The latest iOS GPU support

479
00:13:49,316 --> 0:13:50,626
lossless texture compression,

480
00:13:51,146 --> 0:13:52,706
which allows the GPU to compress

481
00:13:52,706 --> 0:13:54,126
textures for faster access.

482
00:13:55,486 --> 0:13:56,806
So, the next best practice is

483
00:13:57,076 --> 0:13:58,216
for you to optimize your

484
00:13:58,286 --> 0:13:59,906
textures so the GPU can have

485
00:13:59,906 --> 0:14:00,716
faster access.

486
00:13:59,906 --> 0:14:00,716
faster access.

487
00:14:01,646 --> 0:14:02,856
It is very important that you

488
00:14:02,856 --> 0:14:03,986
configure your textures

489
00:14:03,986 --> 0:14:04,466
correctly.

490
00:14:05,106 --> 0:14:06,406
You will want to use private

491
00:14:06,406 --> 0:14:08,486
storage mode, so only the GPU

492
00:14:08,486 --> 0:14:10,036
has access to the texture data

493
00:14:10,146 --> 0:14:11,986
and it allows it to optimize the

494
00:14:11,986 --> 0:14:12,506
contents.

495
00:14:12,966 --> 0:14:14,956
Also, do not set the unknown

496
00:14:14,956 --> 0:14:16,796
usage flag and avoid setting

497
00:14:16,796 --> 0:14:18,516
unnecessary usage flag such as

498
00:14:18,516 --> 0:14:21,056
shaderWrite or pixelView, since

499
00:14:21,056 --> 0:14:22,246
those may disable this

500
00:14:22,246 --> 0:14:22,836
compression.

501
00:14:23,716 --> 0:14:25,706
Shared textures which can be

502
00:14:25,706 --> 0:14:27,866
acces by the CPU and the GPU

503
00:14:28,246 --> 0:14:29,916
should explicitly be optimized

504
00:14:30,376 --> 0:14:32,166
after any CPU update on their

505
00:14:32,166 --> 0:14:32,556
data.

506
00:14:32,936 --> 0:14:34,226
It is also important for you to

507
00:14:34,226 --> 0:14:34,616
do so.

508
00:14:35,206 --> 0:14:36,516
So, let's see how can we do both

509
00:14:36,516 --> 0:14:37,446
things with a little bit of

510
00:14:37,536 --> 0:14:37,836
code.

511
00:14:38,146 --> 0:14:39,966
And it really is just a little

512
00:14:39,966 --> 0:14:40,476
bit of code.

513
00:14:41,036 --> 0:14:42,996
To create an optimal texture, we

514
00:14:42,996 --> 0:14:44,266
will want to set the storage

515
00:14:44,266 --> 0:14:45,076
mode as private.

516
00:14:45,276 --> 0:14:46,986
So, only the GPU has access to

517
00:14:48,126 --> 0:14:48,336
it.

518
00:14:48,336 --> 0:14:49,826
And also, we will want to set

519
00:14:50,296 --> 0:14:53,126
explicit yet conservative usage

520
00:14:53,126 --> 0:14:53,436
flags.

521
00:14:54,746 --> 0:14:56,156
In this case, we want to use the

522
00:14:56,156 --> 0:14:57,346
texture as an intermediate

523
00:14:57,346 --> 0:14:58,786
render targets so we do not need

524
00:14:58,786 --> 0:14:59,806
any other usage flag.

525
00:15:00,306 --> 0:15:03,106
But what about shared textures?

526
00:15:03,806 --> 0:15:05,076
Well, those are a bit trickier.

527
00:15:05,726 --> 0:15:07,016
So, shared textures can be

528
00:15:07,016 --> 0:15:08,836
accessed by both the CPU and the

529
00:15:08,836 --> 0:15:09,486
GPU.

530
00:15:10,386 --> 0:15:12,946
So, if the CPU updates a region

531
00:15:12,946 --> 0:15:14,236
of the texture or any of the

532
00:15:14,276 --> 0:15:16,906
texture data, we may need to

533
00:15:16,906 --> 0:15:18,806
explicitly ask the GPU to

534
00:15:18,806 --> 0:15:20,236
optimize its contents.

535
00:15:21,046 --> 0:15:22,406
Notice that there is a trade-off

536
00:15:22,406 --> 0:15:24,036
here between how many times does

537
00:15:24,036 --> 0:15:25,836
the CPU update the data and how

538
00:15:25,836 --> 0:15:27,336
many times does the GPU need to

539
00:15:27,336 --> 0:15:28,346
access it afterwards.

540
00:15:29,026 --> 0:15:32,096
So the Memory Viewer will

541
00:15:32,096 --> 0:15:33,556
actually be a great tool again

542
00:15:33,726 --> 0:15:34,796
to help us with this.

543
00:15:35,396 --> 0:15:37,086
That is because we can configure

544
00:15:37,086 --> 0:15:39,196
the Memory Viewer to show both

545
00:15:39,196 --> 0:15:40,756
the Storage Mode and Usage flag

546
00:15:40,826 --> 0:15:41,866
for all of our textures.

547
00:15:42,556 --> 0:15:44,096
From this single screen we can

548
00:15:44,096 --> 0:15:46,356
see our compressed textures and

549
00:15:46,356 --> 0:15:47,866
identify all of those which

550
00:15:47,946 --> 0:15:49,486
could be configured correctly.

551
00:15:50,426 --> 0:15:51,276
It is a great tool.

552
00:15:52,506 --> 0:15:54,596
At this point we are almost done

553
00:15:54,596 --> 0:15:55,796
configuring our textures.

554
00:15:56,516 --> 0:15:57,926
We just need to choose the right

555
00:15:57,926 --> 0:15:58,846
pixel format.

556
00:16:00,386 --> 0:16:02,006
Larger pixel format will use

557
00:16:02,006 --> 0:16:03,656
more bandwidth, so the best

558
00:16:03,656 --> 0:16:05,536
practice will be for you to

559
00:16:05,536 --> 0:16:07,096
avoid using pixel formats with

560
00:16:07,096 --> 0:16:09,346
unnecessary channels and also

561
00:16:09,346 --> 0:16:10,926
try to lower precision whenever

562
00:16:10,926 --> 0:16:11,436
possible.

563
00:16:12,706 --> 0:16:14,176
Notice though that the sampling

564
00:16:14,176 --> 0:16:16,166
rate itself will also depend on

565
00:16:16,166 --> 0:16:17,176
the pixel format.

566
00:16:18,176 --> 0:16:20,526
In this case, we can see how the

567
00:16:20,616 --> 0:16:22,586
pixel format has a direct impact

568
00:16:22,586 --> 0:16:24,166
on the texture sampling rate of

569
00:16:24,166 --> 0:16:24,936
our GPUs.

570
00:16:25,656 --> 0:16:27,566
Particularly, you will want to

571
00:16:27,566 --> 0:16:30,456
watch out for 128-bit formats

572
00:16:30,906 --> 0:16:33,576
such as RGBA 32-bit float, since

573
00:16:33,576 --> 0:16:34,876
those are sampled at quarter

574
00:16:34,876 --> 0:16:35,216
rate.

575
00:16:36,176 --> 0:16:37,856
Oftentimes these high precision

576
00:16:37,856 --> 0:16:39,236
formats are used for noise

577
00:16:39,236 --> 0:16:41,246
textures or lookup tables for

578
00:16:41,246 --> 0:16:43,086
the post-process effects.

579
00:16:44,406 --> 0:16:45,926
Once again we can use the Memory

580
00:16:45,926 --> 0:16:47,266
Viewer to help us with that.

581
00:16:48,116 --> 0:16:49,416
The Memory Viewer will let us

582
00:16:49,416 --> 0:16:51,276
filter textures by name or pixel

583
00:16:51,276 --> 0:16:51,726
format.

584
00:16:52,706 --> 0:16:54,046
So, we will verify that our

585
00:16:54,046 --> 0:16:56,486
Metal Demo is using 16-bit

586
00:16:56,586 --> 0:16:57,826
formats for the SSAO

587
00:16:57,826 --> 0:16:58,696
implementation.

588
00:16:59,536 --> 0:17:00,886
This is very important for the

589
00:16:59,536 --> 0:17:00,886
This is very important for the

590
00:17:00,886 --> 0:17:01,696
noise textures.

591
00:17:03,026 --> 0:17:04,296
Notice something else though,

592
00:17:04,346 --> 0:17:06,786
and this that in this example

593
00:17:07,226 --> 0:17:08,435
most of the textures are

594
00:17:08,435 --> 0:17:09,726
actually render targets.

595
00:17:10,746 --> 0:17:12,626
So as games become more complex,

596
00:17:12,626 --> 0:17:13,866
the texture used as render

597
00:17:13,945 --> 0:17:16,006
targets may actually consume a

598
00:17:16,006 --> 0:17:17,796
lot of bandwidth as well, so

599
00:17:17,796 --> 0:17:18,866
let's have a closer look.

600
00:17:19,356 --> 0:17:22,046
In this section, we will review

601
00:17:22,046 --> 0:17:23,195
render pass load and store

602
00:17:23,195 --> 0:17:25,276
actions, paying close attention

603
00:17:25,356 --> 0:17:27,695
to MSAA and also talk a bit

604
00:17:27,695 --> 0:17:28,596
about Tile Memory.

605
00:17:29,866 --> 0:17:31,006
So let's get started with

606
00:17:31,186 --> 0:17:32,446
optimizing load and store

607
00:17:32,446 --> 0:17:32,936
actions.

608
00:17:34,916 --> 0:17:36,336
You should avoid loading or

609
00:17:36,336 --> 0:17:37,546
storing render targets

610
00:17:37,546 --> 0:17:38,326
unnecessary.

611
00:17:39,356 --> 0:17:40,706
Render target load and store

612
00:17:40,706 --> 0:17:42,076
actions are very easy to

613
00:17:42,076 --> 0:17:44,026
overlook and may actually quite

614
00:17:44,026 --> 0:17:45,306
quickly become a problem.

615
00:17:45,996 --> 0:17:47,866
So please make sure to keep

616
00:17:47,866 --> 0:17:48,586
those in check.

617
00:17:49,516 --> 0:17:50,926
And it is actually quite easy to

618
00:17:50,926 --> 0:17:52,706
do so, with again just a little

619
00:17:52,706 --> 0:17:53,606
tiny bit of code.

620
00:17:54,496 --> 0:17:55,756
In this case, we are configuring

621
00:17:55,756 --> 0:17:57,806
a render pass descriptor and we

622
00:17:57,806 --> 0:17:59,296
want the color attachment 1 to

623
00:17:59,296 --> 0:18:00,656
be transient, which means we

624
00:17:59,296 --> 0:18:00,656
be transient, which means we

625
00:18:00,656 --> 0:18:01,806
don't want to load or store

626
00:18:01,806 --> 0:18:02,536
anything from it.

627
00:18:03,426 --> 0:18:05,556
It is a simple as setting the

628
00:18:05,596 --> 0:18:07,146
correct load and store actions.

629
00:18:07,706 --> 0:18:09,336
We want the load action to be

630
00:18:09,336 --> 0:18:11,136
clear, so no later gets transfer

631
00:18:12,036 --> 0:18:13,166
to the on chip GPU.

632
00:18:13,646 --> 0:18:16,296
And we want to store action to

633
00:18:16,296 --> 0:18:17,106
be, DontCare.

634
00:18:17,686 --> 0:18:19,536
So no data needs to be written

635
00:18:19,536 --> 0:18:20,716
at the end of the render pass.

636
00:18:21,536 --> 0:18:22,726
That's all there is to it,

637
00:18:23,396 --> 0:18:24,676
verifying that we have done the

638
00:18:24,676 --> 0:18:26,456
right thing is also very simple,

639
00:18:27,246 --> 0:18:28,476
we can use the Dependency

640
00:18:28,476 --> 0:18:28,846
Viewer.

641
00:18:29,416 --> 0:18:32,726
In this case, our Metal example

642
00:18:32,806 --> 0:18:34,336
is storing the color attachment

643
00:18:34,336 --> 0:18:35,876
1, even though it's not used

644
00:18:35,876 --> 0:18:36,436
later on.

645
00:18:37,246 --> 0:18:38,716
The Dependency Viewer will show

646
00:18:38,716 --> 0:18:40,286
an issue icon to highlight this

647
00:18:40,326 --> 0:18:40,786
problem.

648
00:18:41,746 --> 0:18:42,996
We should simply set the

649
00:18:42,996 --> 0:18:44,786
DontCare store action as we have

650
00:18:44,786 --> 0:18:46,216
just seen in the previous slide

651
00:18:46,216 --> 0:18:48,026
and the problem will go away.

652
00:18:48,556 --> 0:18:51,476
It is really as simple as that.

653
00:18:51,996 --> 0:18:54,016
This is particularly important

654
00:18:54,626 --> 0:18:56,006
for multi-sampled render

655
00:18:56,076 --> 0:18:56,546
targets.

656
00:18:57,076 --> 0:19:00,446
iOS devices have very fast MSAA,

657
00:18:57,076 --> 0:19:00,446
iOS devices have very fast MSAA,

658
00:19:01,116 --> 0:19:02,466
that is because the result

659
00:19:02,756 --> 0:19:04,396
happens from Tile Memory, so it

660
00:19:04,396 --> 0:19:05,946
does not consume any extra

661
00:19:05,946 --> 0:19:06,356
bandwidth.

662
00:19:07,306 --> 0:19:09,046
This also allows us to declare

663
00:19:09,176 --> 0:19:10,726
the multisampled textures fully

664
00:19:10,726 --> 0:19:11,316
transient.

665
00:19:11,836 --> 0:19:13,216
In fact, we don't even need a

666
00:19:13,216 --> 0:19:14,816
system memory allocation to back

667
00:19:14,816 --> 0:19:15,796
it in the first place.

668
00:19:15,956 --> 0:19:17,816
So the best practice will be for

669
00:19:17,816 --> 0:19:19,766
you to consider MSAA over native

670
00:19:19,766 --> 0:19:21,186
resolution, since it's very

671
00:19:21,186 --> 0:19:23,486
efficient, and also make sure to

672
00:19:23,486 --> 0:19:24,646
not load or store the

673
00:19:24,646 --> 0:19:25,876
multisample texture.

674
00:19:26,686 --> 0:19:27,876
And since you're at it set the

675
00:19:27,876 --> 0:19:29,476
storage mode of the multisample

676
00:19:29,476 --> 0:19:30,766
texture to memoryless.

677
00:19:31,766 --> 0:19:32,746
I will fully introduce

678
00:19:32,746 --> 0:19:34,246
memoryless later on the talk.

679
00:19:34,246 --> 0:19:35,726
For now, let's see how can we

680
00:19:35,726 --> 0:19:37,396
configure a multisample texture

681
00:19:37,396 --> 0:19:38,666
and the render pass that uses

682
00:19:38,666 --> 0:19:38,896
it.

683
00:19:39,376 --> 0:19:42,066
In this case, we just need to

684
00:19:42,066 --> 0:19:43,616
set the memoryless storage mode,

685
00:19:44,516 --> 0:19:46,006
and also make sure that the

686
00:19:46,006 --> 0:19:48,286
render pass is using it, clears

687
00:19:48,286 --> 0:19:49,976
its contents and discards the

688
00:19:49,976 --> 0:19:50,576
samples.

689
00:19:51,286 --> 0:19:53,076
We only want the multisample

690
00:19:53,076 --> 0:19:54,676
texture to resolve from.

691
00:19:55,086 --> 0:19:56,426
We do not need to store it.

692
00:19:56,556 --> 0:19:57,936
We do not want that intermediate

693
00:19:57,936 --> 0:19:58,806
data to be stored.

694
00:19:59,476 --> 0:20:01,446
Only the final resolve texture

695
00:19:59,476 --> 0:20:01,446
Only the final resolve texture

696
00:20:01,446 --> 0:20:02,116
should be stored.

697
00:20:03,316 --> 0:20:04,586
We can once more use the

698
00:20:04,586 --> 0:20:06,436
Dependency Viewer to help us

699
00:20:06,436 --> 0:20:08,396
verify that we are doing the

700
00:20:08,726 --> 0:20:10,046
right thing.

701
00:20:10,166 --> 0:20:12,026
In this case, our Metal example

702
00:20:12,026 --> 0:20:13,216
is loading and starting the

703
00:20:13,216 --> 0:20:15,436
multisample texture which is

704
00:20:15,436 --> 0:20:16,326
very costly.

705
00:20:17,526 --> 0:20:18,946
After setting the correct flag

706
00:20:19,056 --> 0:20:21,006
just as I've shown you, we will

707
00:20:21,006 --> 0:20:24,896
save our 85 memory, sorry, 85

708
00:20:24,966 --> 0:20:27,246
megabytes of memory bandwidth

709
00:20:27,246 --> 0:20:28,426
and also footprint.

710
00:20:29,536 --> 0:20:30,806
And this is very important for

711
00:20:30,806 --> 0:20:32,306
you to verify the multisample

712
00:20:32,306 --> 0:20:32,986
attachments.

713
00:20:33,836 --> 0:20:36,486
But notice that those savings

714
00:20:36,596 --> 0:20:39,156
are only possible because we are

715
00:20:39,156 --> 0:20:41,056
implicitly leveraging Tile

716
00:20:42,226 --> 0:20:44,386
Memory by using MSAA.

717
00:20:45,286 --> 0:20:46,776
So the next best practice is for

718
00:20:46,776 --> 0:20:48,636
you to explicitly leverage Tile

719
00:20:48,636 --> 0:20:49,036
Memory.

720
00:20:50,186 --> 0:20:51,696
Metal provides access to Tile

721
00:20:51,696 --> 0:20:53,736
Memory for several features such

722
00:20:53,736 --> 0:20:55,616
as programmable blending, image

723
00:20:55,616 --> 0:20:57,166
block, and tile shaders.

724
00:20:57,996 --> 0:21:00,256
The best practice is for you to

725
00:20:57,996 --> 0:21:00,256
The best practice is for you to

726
00:21:00,256 --> 0:21:01,646
explicitly utilize it,

727
00:21:02,146 --> 0:21:04,416
particularly to implement more

728
00:21:04,416 --> 0:21:05,886
advanced rendering techniques.

729
00:21:06,886 --> 0:21:08,926
The Modern Rendering with Metal

730
00:21:08,926 --> 0:21:10,536
talk will cover-- has covered

731
00:21:10,536 --> 0:21:11,586
some of these techniques in

732
00:21:11,586 --> 0:21:11,926
detail.

733
00:21:13,046 --> 0:21:14,366
For now we will just have a

734
00:21:14,416 --> 0:21:15,826
quick look at deferred shading.

735
00:21:17,436 --> 0:21:19,676
Deferred shading is considered

736
00:21:19,676 --> 0:21:22,206
to be very bandwidth heavy that

737
00:21:22,206 --> 0:21:24,166
is because traditionally it

738
00:21:24,166 --> 0:21:25,626
requires the application to

739
00:21:25,626 --> 0:21:27,196
store the geometry information

740
00:21:27,466 --> 0:21:29,846
or G-Buffer as a set of textures

741
00:21:29,846 --> 0:21:31,426
representing several pixel

742
00:21:31,486 --> 0:21:32,056
properties.

743
00:21:32,966 --> 0:21:34,796
Those textures are then sampled

744
00:21:34,796 --> 0:21:36,066
in the second lighting pass,

745
00:21:36,576 --> 0:21:37,826
where the final color is

746
00:21:37,826 --> 0:21:39,396
accumulated in a render target.

747
00:21:40,316 --> 0:21:42,686
Notice that we are storing and

748
00:21:42,686 --> 0:21:44,776
then loading all this data from

749
00:21:44,776 --> 0:21:46,186
the G-Buffer, so that's why it's

750
00:21:46,226 --> 0:21:47,016
bandwidth heavy.

751
00:21:47,356 --> 0:21:50,136
iOS allows you to be much more

752
00:21:50,136 --> 0:21:52,646
efficient than that.

753
00:21:53,576 --> 0:21:54,956
On iOS, we can leverage

754
00:21:54,986 --> 0:21:56,876
programmable blending, a feature

755
00:21:56,876 --> 0:21:58,606
that allows fragment shaders to

756
00:21:58,606 --> 0:22:01,076
access pixel data directly from

757
00:21:58,606 --> 0:22:01,076
access pixel data directly from

758
00:22:01,076 --> 0:22:01,746
Tile Memory.

759
00:22:02,646 --> 0:22:04,096
This means that the G-buffer

760
00:22:04,096 --> 0:22:05,756
data can be stored on Tile

761
00:22:05,756 --> 0:22:07,766
Memory and access within the

762
00:22:07,766 --> 0:22:10,026
same render pass by all the

763
00:22:10,026 --> 0:22:11,456
light accumulation shaders.

764
00:22:12,196 --> 0:22:13,896
It is a very powerful feature

765
00:22:15,116 --> 0:22:16,526
which Digital Legends has been

766
00:22:16,526 --> 0:22:17,936
utilizing for years.

767
00:22:18,776 --> 0:22:20,246
This is how the single pass

768
00:22:20,246 --> 0:22:21,946
deferred render of Afterpulse

769
00:22:22,306 --> 0:22:23,256
looks like through the

770
00:22:23,256 --> 0:22:24,726
Dependency Viewer, it's

771
00:22:24,726 --> 0:22:25,276
beautiful.

772
00:22:25,926 --> 0:22:27,296
The four G-Buffer attachments

773
00:22:27,296 --> 0:22:29,266
are fully transient, and only

774
00:22:29,266 --> 0:22:31,056
the final color and depth are

775
00:22:31,056 --> 0:22:32,146
stored, so it's not only

776
00:22:32,146 --> 0:22:33,806
beautiful it's also efficient.

777
00:22:34,686 --> 0:22:36,006
So, now, please let's welcome

778
00:22:36,006 --> 0:22:37,856
Samuel on stage for the demo of

779
00:22:37,856 --> 0:22:38,756
the Dependency Viewer.

780
00:22:39,516 --> 0:22:43,500
[ Applause ]

781
00:22:48,636 --> 0:22:49,516
&gt;&gt; Thanks Guillem.

782
00:22:50,076 --> 0:22:51,616
So, we've just captured an old

783
00:22:51,616 --> 0:22:53,206
version of Afterpulse and want

784
00:22:53,206 --> 0:22:54,106
to see if there are any

785
00:22:54,106 --> 0:22:55,746
optimizations that we can make

786
00:22:56,006 --> 0:22:57,146
to improve its performance.

787
00:22:58,556 --> 0:22:59,866
I'm now going to use the

788
00:22:59,866 --> 0:23:01,586
Dependency Viewer in the Metal

789
00:22:59,866 --> 0:23:01,586
Dependency Viewer in the Metal

790
00:23:01,586 --> 0:23:03,166
Frame Debugger to show some of

791
00:23:03,166 --> 0:23:04,536
the issues that Guillem just

792
00:23:04,536 --> 0:23:04,916
mentioned.

793
00:23:05,676 --> 0:23:08,846
So to begin, let's click on the

794
00:23:08,846 --> 0:23:10,556
CommandBuffer to open the

795
00:23:10,556 --> 0:23:12,206
Dependency Viewer.

796
00:23:12,856 --> 0:23:16,576
The Dependency Viewer shows us

797
00:23:16,576 --> 0:23:18,856
all of the GPU passes encoded by

798
00:23:19,686 --> 0:23:20,646
an app.

799
00:23:20,926 --> 0:23:22,656
We can see that Afterpulse has

800
00:23:22,656 --> 0:23:24,816
one CommandBuffer and begins its

801
00:23:24,816 --> 0:23:26,606
frame by rendering a Shadow Map.

802
00:23:27,356 --> 0:23:30,606
Followed by Deferred Phase, this

803
00:23:30,606 --> 0:23:31,596
feeds into Luminance

804
00:23:31,596 --> 0:23:33,286
Calculations, Particle

805
00:23:33,286 --> 0:23:35,286
Simulations, and a Bloom Chain

806
00:23:35,886 --> 0:23:37,196
which is used by the final

807
00:23:37,196 --> 0:23:38,646
screen pass.

808
00:23:39,516 --> 0:23:40,666
Now, the Dependency Viewer is

809
00:23:40,666 --> 0:23:42,276
much more compact this year if

810
00:23:42,276 --> 0:23:44,046
you have groups, and it's really

811
00:23:44,046 --> 0:23:46,096
easy to see at a high level, how

812
00:23:46,096 --> 0:23:46,966
the frame is rendered.

813
00:23:48,026 --> 0:23:49,806
We can even go deeper into any

814
00:23:49,806 --> 0:23:51,656
group if we want more detail.

815
00:23:52,416 --> 0:23:54,396
So, in reality this Bloom Chain

816
00:23:54,956 --> 0:23:56,496
is actually 12 passes.

817
00:23:57,066 --> 0:24:00,016
Now, the Dependency Viewer is a

818
00:23:57,066 --> 0:24:00,016
Now, the Dependency Viewer is a

819
00:24:00,016 --> 0:24:01,516
great place to find some of the

820
00:24:01,516 --> 0:24:02,656
issues that Guillem mentioned.

821
00:24:03,166 --> 0:24:04,606
And we can see a few on this

822
00:24:04,606 --> 0:24:05,296
final screen pass.

823
00:24:05,296 --> 0:24:08,026
So let's click on the issue icon

824
00:24:08,306 --> 0:24:09,106
to find out more.

825
00:24:09,746 --> 0:24:12,656
So, it looks like one of the

826
00:24:12,656 --> 0:24:14,466
load store action issues that

827
00:24:14,466 --> 0:24:15,446
Guillem mentioned earlier.

828
00:24:16,496 --> 0:24:17,856
So they've set the store action

829
00:24:17,856 --> 0:24:19,866
to store, but they're not using

830
00:24:19,866 --> 0:24:20,936
this texture again in this

831
00:24:20,936 --> 0:24:21,196
frame.

832
00:24:22,066 --> 0:24:23,626
So the issue recommends we

833
00:24:23,626 --> 0:24:24,946
should instead set it to

834
00:24:24,946 --> 0:24:27,056
DontCare and we'll get back

835
00:24:27,056 --> 0:24:28,886
almost 14 megabytes of memory

836
00:24:28,886 --> 0:24:30,806
bandwidth for these two textures

837
00:24:30,806 --> 0:24:31,286
combined.

838
00:24:31,906 --> 0:24:34,676
So this year we've made it even

839
00:24:34,676 --> 0:24:36,336
easier to find all of the issues

840
00:24:36,376 --> 0:24:38,436
in the graph, simply click on

841
00:24:38,436 --> 0:24:39,966
the new issues button on the

842
00:24:39,966 --> 0:24:42,786
bottom right to see a list of

843
00:24:46,156 --> 0:24:46,316
issues.

844
00:24:46,466 --> 0:24:47,726
Now, another best practice that

845
00:24:47,726 --> 0:24:48,956
Guillem mentioned was choosing

846
00:24:48,956 --> 0:24:51,016
the correct pixel format.

847
00:24:51,556 --> 0:24:52,936
So this year on iOS we've

848
00:24:52,936 --> 0:24:54,756
introduced the new Depth 16

849
00:24:54,756 --> 0:24:56,806
Format, so let's use the new

850
00:24:56,806 --> 0:24:58,996
search to look for Depth 32

851
00:24:58,996 --> 0:25:00,246
textures.

852
00:24:58,996 --> 0:25:00,246
textures.

853
00:25:03,266 --> 0:25:04,666
So it looks like they're using

854
00:25:04,736 --> 0:25:06,636
36 megabytes of memory for the

855
00:25:06,636 --> 0:25:07,596
Shadow Map texture.

856
00:25:08,506 --> 0:25:09,536
So when the team at Digital

857
00:25:09,536 --> 0:25:11,356
Legends gets back to Barcelona

858
00:25:11,356 --> 0:25:12,836
after Dub-Dub, they can

859
00:25:12,836 --> 0:25:14,316
investigate using this new

860
00:25:14,316 --> 0:25:16,646
format and potentially save half

861
00:25:16,686 --> 0:25:18,126
the memory if their shadow

862
00:25:18,126 --> 0:25:20,196
requirements allow for it.

863
00:25:20,746 --> 0:25:22,166
If we continue searching through

864
00:25:22,166 --> 0:25:24,046
the graph, where you can see

865
00:25:24,046 --> 0:25:25,596
that there's plenty of potential

866
00:25:25,596 --> 0:25:26,396
memory savings.

867
00:25:27,066 --> 0:25:29,436
So if you use the Dependency

868
00:25:29,436 --> 0:25:30,576
Viewer in the Metal Frame

869
00:25:30,576 --> 0:25:32,566
Debugger to find and diagnose a

870
00:25:32,616 --> 0:25:34,736
few issues in the old version of

871
00:25:34,736 --> 0:25:35,276
Afterpulse.

872
00:25:36,116 --> 0:25:37,146
So, Digital Legends have

873
00:25:37,146 --> 0:25:38,326
actually made some of these

874
00:25:38,326 --> 0:25:39,026
improvements.

875
00:25:39,386 --> 0:25:40,386
So let's take a quick look.

876
00:25:40,976 --> 0:25:43,906
We can immediately see that they

877
00:25:43,906 --> 0:25:45,226
are now using multiple command

878
00:25:45,226 --> 0:25:45,686
buffers.

879
00:25:46,376 --> 0:25:47,746
So this will fix the issue that

880
00:25:47,746 --> 0:25:49,196
Guillem showed us earlier where

881
00:25:49,196 --> 0:25:51,056
the CPU was blocked waiting for

882
00:25:51,056 --> 0:25:52,776
the next drawable and the GPU

883
00:25:52,776 --> 0:25:53,276
was idle.

884
00:25:53,866 --> 0:25:56,006
If we zoom in to the final

885
00:25:56,006 --> 0:25:58,586
screen pass, we can see that

886
00:25:58,586 --> 0:25:59,936
they've fixed the store action

887
00:25:59,936 --> 0:26:00,276
issue.

888
00:25:59,936 --> 0:26:00,276
issue.

889
00:26:01,386 --> 0:26:02,886
In fact, because these two

890
00:26:02,886 --> 0:26:04,906
textures are fully transient and

891
00:26:04,906 --> 0:26:06,136
they've set the storage mode to

892
00:26:06,136 --> 0:26:08,116
memoryless, they're not using

893
00:26:08,116 --> 0:26:09,616
any system memory at all.

894
00:26:11,016 --> 0:26:13,326
So, Dependency really is a great

895
00:26:13,366 --> 0:26:14,916
place to start debugging your

896
00:26:14,916 --> 0:26:15,636
render pipeline.

897
00:26:16,526 --> 0:26:17,856
Back to Guillem who will talk

898
00:26:17,856 --> 0:26:18,926
about some amazing best

899
00:26:18,926 --> 0:26:20,936
practices in optimizing your

900
00:26:20,936 --> 0:26:21,926
apps memory footprint.

901
00:26:22,516 --> 0:26:29,056
[ Applause ]

902
00:26:29,556 --> 0:26:30,986
&gt;&gt; Thank you Sam that was an

903
00:26:30,986 --> 0:26:31,756
awesome demo.

904
00:26:31,886 --> 0:26:33,156
I hope you guys will also use

905
00:26:33,156 --> 0:26:34,116
the Dependency Viewer.

906
00:26:35,296 --> 0:26:36,556
Cool. So, let's move on to the

907
00:26:36,556 --> 0:26:38,906
last part of the talk, memory

908
00:26:38,906 --> 0:26:39,476
footprint.

909
00:26:40,786 --> 0:26:42,216
Memory footprint is actually

910
00:26:42,216 --> 0:26:43,676
very important for your game.

911
00:26:44,616 --> 0:26:46,696
That is because iOS enforces a

912
00:26:46,696 --> 0:26:48,436
strict application memory limit

913
00:26:48,896 --> 0:26:50,506
in order to keep both the system

914
00:26:50,506 --> 0:26:52,066
on your application responsive.

915
00:26:52,756 --> 0:26:56,016
As some of you may have noticed

916
00:26:56,016 --> 0:26:58,326
iOS 12 introduce some changes in

917
00:26:58,326 --> 0:26:59,706
the way memory is accounted.

918
00:27:00,816 --> 0:27:02,606
This accounting change affects

919
00:27:02,606 --> 0:27:03,946
mostly Metal resources.

920
00:27:04,976 --> 0:27:06,736
Metal resources such as buffers

921
00:27:06,736 --> 0:27:08,836
or textures may be the bulk of

922
00:27:08,876 --> 0:27:09,976
your application's memory

923
00:27:09,976 --> 0:27:10,496
footprint.

924
00:27:10,946 --> 0:27:12,346
So, it is important for you to

925
00:27:12,346 --> 0:27:13,636
measure the memory footprint of

926
00:27:13,636 --> 0:27:14,166
your game.

927
00:27:14,916 --> 0:27:16,356
You will want to do, so using

928
00:27:16,356 --> 0:27:17,656
the Xcode Memory Gauge.

929
00:27:18,746 --> 0:27:20,486
The Xcode Memory Gauge will

930
00:27:20,516 --> 0:27:22,576
report the existing number that

931
00:27:22,576 --> 0:27:24,266
the system also uses to measure

932
00:27:24,266 --> 0:27:25,626
your game's memory footprint.

933
00:27:26,396 --> 0:27:28,036
It is very important that you

934
00:27:28,036 --> 0:27:29,536
use it to verify where your

935
00:27:29,536 --> 0:27:30,176
games at.

936
00:27:31,126 --> 0:27:32,956
Now, new this year it will also

937
00:27:32,956 --> 0:27:34,496
display the application memory

938
00:27:34,496 --> 0:27:36,656
limit as your game gets closer

939
00:27:36,736 --> 0:27:37,626
to it.

940
00:27:38,896 --> 0:27:40,566
But what if we want to focus

941
00:27:40,566 --> 0:27:43,206
specifically on the memory used

942
00:27:43,206 --> 0:27:44,546
by our Metal resources?

943
00:27:45,156 --> 0:27:47,696
New this year, we are

944
00:27:47,696 --> 0:27:49,266
introducing the Memory Viewer.

945
00:27:50,496 --> 0:27:52,366
We have added it into the Metal

946
00:27:52,366 --> 0:27:53,106
Frame Debugger.

947
00:27:54,346 --> 0:27:56,006
The Memory Viewer itself has two

948
00:27:56,006 --> 0:27:58,776
parts, first, a bar chart at the

949
00:27:58,836 --> 0:28:01,006
top which shows resources, group

950
00:27:58,836 --> 0:28:01,006
top which shows resources, group

951
00:28:01,006 --> 0:28:03,146
by categories such as type,

952
00:28:03,596 --> 0:28:05,606
storage mode, and usage.

953
00:28:06,256 --> 0:28:08,136
We can also use this bar chart

954
00:28:08,756 --> 0:28:09,966
to quickly navigate through the

955
00:28:09,966 --> 0:28:11,656
largest resources which are then

956
00:28:11,656 --> 0:28:13,006
highlighted and the time they

957
00:28:13,006 --> 0:28:13,606
were shown.

958
00:28:14,706 --> 0:28:16,346
Second, there is a table at the

959
00:28:16,346 --> 0:28:18,116
bottom which will show the

960
00:28:18,176 --> 0:28:19,726
resources that we have filtered.

961
00:28:19,726 --> 0:28:22,596
It includes several properties

962
00:28:22,646 --> 0:28:24,786
specific to resource type such

963
00:28:24,786 --> 0:28:26,506
as pixel format and resolution

964
00:28:26,506 --> 0:28:27,216
for textures.

965
00:28:28,046 --> 0:28:29,686
There is also filter bar at the

966
00:28:29,686 --> 0:28:31,606
bottom to help you narrow down

967
00:28:31,606 --> 0:28:33,156
your investigation even further.

968
00:28:33,886 --> 0:28:36,056
It is a very powerful tool and

969
00:28:36,056 --> 0:28:37,606
we hope that you will utilize it

970
00:28:37,666 --> 0:28:38,916
to understand the memory

971
00:28:38,916 --> 0:28:40,716
footprint of all your GPU

972
00:28:40,716 --> 0:28:41,326
resources.

973
00:28:43,056 --> 0:28:45,476
Also another great tool that we

974
00:28:45,476 --> 0:28:47,456
are introducing this year is the

975
00:28:47,456 --> 0:28:49,016
Metal Resource Allocation

976
00:28:49,046 --> 0:28:49,736
Instrument.

977
00:28:51,086 --> 0:28:52,076
It has three different

978
00:28:52,076 --> 0:28:54,726
components, a Metal Resources

979
00:28:54,726 --> 0:28:56,226
Allocations track which will

980
00:28:56,226 --> 0:28:57,836
show the current Metal memory

981
00:28:57,906 --> 0:29:00,226
footprint of your game, an

982
00:28:57,906 --> 0:29:00,226
footprint of your game, an

983
00:29:00,226 --> 0:29:02,056
allocations track which will

984
00:29:02,056 --> 0:29:03,546
show an event for each resource

985
00:29:03,546 --> 0:29:05,606
allocation and deallocation as

986
00:29:05,606 --> 0:29:06,856
well as some information.

987
00:29:08,106 --> 0:29:10,266
And also a detailed table view

988
00:29:10,536 --> 0:29:11,446
which will show you more

989
00:29:11,446 --> 0:29:12,816
information about all the

990
00:29:12,816 --> 0:29:14,136
allocations captured.

991
00:29:15,146 --> 0:29:16,416
Both these tools are very

992
00:29:16,416 --> 0:29:18,506
powerful and will give you great

993
00:29:18,506 --> 0:29:20,596
overview of the memory footprint

994
00:29:20,596 --> 0:29:22,006
in your game and how-- well,

995
00:29:22,006 --> 0:29:23,716
also how it changes over time.

996
00:29:24,226 --> 0:29:26,446
But some of you have also been

997
00:29:26,446 --> 0:29:28,476
asking for other features, in

998
00:29:28,476 --> 0:29:29,726
particular, one of them you have

999
00:29:29,756 --> 0:29:31,146
been asking for a long time.

1000
00:29:31,726 --> 0:29:33,006
And I'm very happy to tell you

1001
00:29:33,006 --> 0:29:34,466
that new this year, we have a

1002
00:29:34,466 --> 0:29:36,636
C-based API to query available

1003
00:29:36,636 --> 0:29:37,696
memory at runtime.

1004
00:29:38,566 --> 0:29:40,206
This will enable your game to

1005
00:29:40,206 --> 0:29:41,266
stream resources more

1006
00:29:41,266 --> 0:29:43,776
effectively and also avoid

1007
00:29:43,776 --> 0:29:46,156
memory spikes which may cause

1008
00:29:46,156 --> 0:29:47,626
the game to go over the

1009
00:29:47,626 --> 0:29:48,566
application limit.

1010
00:29:49,456 --> 0:29:51,296
Another cool API that we're

1011
00:29:51,296 --> 0:29:53,206
introducing this year is the

1012
00:29:53,286 --> 0:29:55,436
on-device GPU capture, which

1013
00:29:55,436 --> 0:29:56,116
will allow you to

1014
00:29:56,186 --> 0:29:57,816
programmatically trigger a GPU

1015
00:29:57,816 --> 0:30:00,326
capture for which Xcode is not

1016
00:29:57,816 --> 0:30:00,326
capture for which Xcode is not

1017
00:30:00,326 --> 0:30:00,856
required.

1018
00:30:01,446 --> 0:30:02,936
So we think it will be ideal for

1019
00:30:02,936 --> 0:30:04,776
game testers in the QA process.

1020
00:30:05,456 --> 0:30:07,286
To enable it you will just need

1021
00:30:07,336 --> 0:30:09,136
to add MetalCaptureEnabled into

1022
00:30:09,136 --> 0:30:10,026
the info.plist.

1023
00:30:10,026 --> 0:30:10,856
It's very simple.

1024
00:30:12,086 --> 0:30:13,206
So, now, let's see how we can

1025
00:30:13,206 --> 0:30:15,876
combine both APIs into some

1026
00:30:15,876 --> 0:30:17,466
short piece of code.

1027
00:30:18,766 --> 0:30:20,596
In this case, we will want to

1028
00:30:20,626 --> 0:30:22,196
check if the application is

1029
00:30:22,196 --> 0:30:23,856
close to the memory limit, maybe

1030
00:30:23,856 --> 0:30:25,946
because of a memory spike and

1031
00:30:25,946 --> 0:30:27,656
capture a GPU trace of our game,

1032
00:30:27,656 --> 0:30:29,136
so we can use the Memory Viewer

1033
00:30:29,196 --> 0:30:30,086
to fully debug it.

1034
00:30:30,756 --> 0:30:31,686
So let's go for it.

1035
00:30:32,116 --> 0:30:33,876
First, we'll check if the

1036
00:30:33,876 --> 0:30:35,166
application is getting close to

1037
00:30:35,166 --> 0:30:35,696
the limit.

1038
00:30:36,436 --> 0:30:38,806
And if it is we will then want

1039
00:30:39,126 --> 0:30:41,276
to capture the next frame, which

1040
00:30:41,276 --> 0:30:43,036
we will just render normally as

1041
00:30:43,036 --> 0:30:44,286
we would do so otherwise.

1042
00:30:45,716 --> 0:30:47,516
By the end of the frame, if we

1043
00:30:47,516 --> 0:30:49,636
captured it, we will then stop

1044
00:30:49,636 --> 0:30:51,486
the capture and handle the GPU

1045
00:30:51,486 --> 0:30:53,506
trace, it's up to you how you

1046
00:30:53,506 --> 0:30:54,806
handle the GPU trace.

1047
00:30:55,516 --> 0:30:57,416
Potentially you may also want to

1048
00:30:57,416 --> 0:30:59,836
either exit the game or disable

1049
00:30:59,836 --> 0:31:01,346
the GPU captures for this

1050
00:30:59,836 --> 0:31:01,346
the GPU captures for this

1051
00:31:01,346 --> 0:31:02,716
session, since you may not want

1052
00:31:02,716 --> 0:31:04,506
to capture every single frame at

1053
00:31:04,506 --> 0:31:05,026
that point.

1054
00:31:06,246 --> 0:31:08,016
So this will give you a great

1055
00:31:08,016 --> 0:31:10,536
way to use both APIs and to, you

1056
00:31:10,536 --> 0:31:12,076
know, like further drill down on

1057
00:31:12,076 --> 0:31:12,856
memory footprint.

1058
00:31:13,296 --> 0:31:15,556
Which is great, so let's do

1059
00:31:15,556 --> 0:31:16,346
exactly that.

1060
00:31:16,346 --> 0:31:17,776
Let's look into how can we

1061
00:31:17,776 --> 0:31:19,286
reduce memory footprint.

1062
00:31:19,866 --> 0:31:21,656
For that we also have a bunch of

1063
00:31:21,656 --> 0:31:22,526
best practices.

1064
00:31:23,516 --> 0:31:25,026
In this section, we will talk

1065
00:31:25,026 --> 0:31:26,886
about memoryless render targets,

1066
00:31:27,256 --> 0:31:29,486
resource streaming, a bit more

1067
00:31:29,486 --> 0:31:31,216
about game assets and also

1068
00:31:31,306 --> 0:31:32,656
memory-intensive effects.

1069
00:31:33,396 --> 0:31:34,986
So, let's get started with

1070
00:31:34,986 --> 0:31:36,406
memoryless render targets.

1071
00:31:36,786 --> 0:31:39,206
This is kind of where we left it

1072
00:31:39,206 --> 0:31:40,716
in the memory bandwidth section.

1073
00:31:42,096 --> 0:31:43,466
Notice the transient render

1074
00:31:43,466 --> 0:31:45,386
targets are not loaded or stored

1075
00:31:45,386 --> 0:31:46,316
on system memory.

1076
00:31:47,076 --> 0:31:49,056
So they actually do not need a

1077
00:31:49,056 --> 0:31:50,476
system memory allocation in the

1078
00:31:50,476 --> 0:31:52,286
first place, that's why you

1079
00:31:52,286 --> 0:31:53,816
should use memoryless storage

1080
00:31:53,816 --> 0:31:55,996
mode, in particular, for all the

1081
00:31:55,996 --> 0:31:57,456
multisampled attachments.

1082
00:31:58,316 --> 0:31:59,646
So let's see how can we do that

1083
00:31:59,646 --> 0:32:01,716
with, again, just a little bit

1084
00:31:59,646 --> 0:32:01,716
with, again, just a little bit

1085
00:32:02,116 --> 0:32:02,956
of code.

1086
00:32:03,146 --> 0:32:04,806
In this case, is as simple as

1087
00:32:04,806 --> 0:32:06,126
setting memoryless into the

1088
00:32:06,126 --> 0:32:07,096
texture descriptor.

1089
00:32:07,906 --> 0:32:09,726
Also we will want to make sure

1090
00:32:09,906 --> 0:32:11,836
that our render pass configures

1091
00:32:11,836 --> 0:32:13,066
that render target as fully

1092
00:32:13,066 --> 0:32:13,626
transient.

1093
00:32:14,106 --> 0:32:15,586
In this case, we want to

1094
00:32:15,586 --> 0:32:16,856
configure the G-Buffers

1095
00:32:16,856 --> 0:32:17,406
transients.

1096
00:32:17,406 --> 0:32:18,776
So, we just need to set the load

1097
00:32:18,776 --> 0:32:20,646
action clear and the store

1098
00:32:20,646 --> 0:32:21,606
action to DontCare.

1099
00:32:22,096 --> 0:32:23,326
So we are not storing the

1100
00:32:23,326 --> 0:32:23,856
G-buffer.

1101
00:32:24,426 --> 0:32:27,156
So we can see how Digital

1102
00:32:27,156 --> 0:32:28,686
Legends did it by having another

1103
00:32:28,686 --> 0:32:29,676
look at Afterpulse.

1104
00:32:30,516 --> 0:32:32,406
At the top we can see an older

1105
00:32:32,406 --> 0:32:35,006
version of Afterpulse, it has a

1106
00:32:35,006 --> 0:32:37,096
transient G-buffer but it's

1107
00:32:37,096 --> 0:32:38,816
being backed by system memory.

1108
00:32:39,426 --> 0:32:41,766
At the bottom, we can see a

1109
00:32:41,766 --> 0:32:43,396
newer version of Afterpulse

1110
00:32:43,796 --> 0:32:45,076
which actually has a larger

1111
00:32:45,076 --> 0:32:45,626
G-buffer.

1112
00:32:46,446 --> 0:32:48,616
But this G-buffer though is

1113
00:32:48,616 --> 0:32:51,336
fully transient and this time

1114
00:32:51,706 --> 0:32:53,306
not backed by system memory,

1115
00:32:53,766 --> 0:32:55,296
they are utilizing memoryless

1116
00:32:55,296 --> 0:32:56,936
storage mode for all the

1117
00:32:56,936 --> 0:32:57,996
intermediate G-buffer

1118
00:32:57,996 --> 0:32:58,636
attachments.

1119
00:32:58,966 --> 0:33:00,576
And this is great because the

1120
00:32:58,966 --> 0:33:00,576
And this is great because the

1121
00:33:00,576 --> 0:33:02,896
newer version of Afterpulse is

1122
00:33:02,896 --> 0:33:04,876
saving about 60 megabytes of

1123
00:33:04,906 --> 0:33:07,256
memory footprint just by setting

1124
00:33:07,256 --> 0:33:09,336
that one flag, it's awesome.

1125
00:33:10,096 --> 0:33:12,066
And it comes with no compromise,

1126
00:33:12,656 --> 0:33:13,906
there is nothing being lost

1127
00:33:13,906 --> 0:33:15,066
here, there's no trade-off to be

1128
00:33:15,066 --> 0:33:16,676
made, it just works.

1129
00:33:17,126 --> 0:33:17,676
And it's great.

1130
00:33:18,496 --> 0:33:19,976
So, now, let's move on to the

1131
00:33:19,976 --> 0:33:22,386
rest of the best practices,

1132
00:33:22,616 --> 0:33:24,126
which some of those we will do

1133
00:33:24,126 --> 0:33:26,576
come with a, you know, memory

1134
00:33:26,576 --> 0:33:27,956
and performance trade-off or

1135
00:33:27,956 --> 0:33:29,086
memory and image quality

1136
00:33:29,086 --> 0:33:29,596
trade-off.

1137
00:33:30,366 --> 0:33:31,916
In this case, we are back to

1138
00:33:31,916 --> 0:33:32,696
resource streaming.

1139
00:33:34,076 --> 0:33:35,306
Notice that loading all the

1140
00:33:35,306 --> 0:33:37,246
assets into memory will increase

1141
00:33:37,246 --> 0:33:38,806
the memory footprint, so you

1142
00:33:38,806 --> 0:33:40,216
should consider the memory and

1143
00:33:40,216 --> 0:33:42,596
performance trade-off and only

1144
00:33:42,596 --> 0:33:43,856
load all the assets that you

1145
00:33:43,856 --> 0:33:45,666
know will be used, particularly

1146
00:33:45,666 --> 0:33:46,996
when you are memory limited.

1147
00:33:48,036 --> 0:33:50,006
Also you may want to free all

1148
00:33:50,006 --> 0:33:51,856
the resources as long-- as soon

1149
00:33:51,856 --> 0:33:53,406
as they are not used anymore,

1150
00:33:53,736 --> 0:33:55,356
potentially like splash screen

1151
00:33:55,356 --> 0:33:56,796
or tutorial UI would be great

1152
00:33:56,796 --> 0:33:57,826
candidates for that.

1153
00:33:58,806 --> 0:34:00,916
And this is a hard decision to

1154
00:33:58,806 --> 0:34:00,916
And this is a hard decision to

1155
00:34:00,916 --> 0:34:03,056
make but fortunately the Memory

1156
00:34:03,056 --> 0:34:04,406
Viewer is also a great tool to

1157
00:34:04,406 --> 0:34:05,326
help us with that.

1158
00:34:06,926 --> 0:34:08,755
We can use the filters to

1159
00:34:08,755 --> 0:34:10,166
quickly focus on unused

1160
00:34:10,216 --> 0:34:10,846
resources.

1161
00:34:11,996 --> 0:34:14,016
By doing so, the table at the

1162
00:34:14,016 --> 0:34:15,716
bottom will be updated and then

1163
00:34:15,846 --> 0:34:17,085
we can focus on all these

1164
00:34:17,085 --> 0:34:18,636
resources which are not used in

1165
00:34:18,636 --> 0:34:19,146
this frame.

1166
00:34:19,315 --> 0:34:21,616
And we will talk more about this

1167
00:34:21,616 --> 0:34:22,866
and use them off the Memory

1168
00:34:22,866 --> 0:34:24,235
Viewer towards the end of the

1169
00:34:24,266 --> 0:34:24,576
talk.

1170
00:34:25,656 --> 0:34:26,976
So, now, let's move on to best

1171
00:34:26,976 --> 0:34:28,275
practice number 14.

1172
00:34:29,106 --> 0:34:30,505
Use smaller assets.

1173
00:34:31,186 --> 0:34:33,246
In fact, you should only make

1174
00:34:33,246 --> 0:34:35,426
the assets as large as necessary

1175
00:34:36,286 --> 0:34:37,726
and consider again the image

1176
00:34:37,775 --> 0:34:39,396
quality and memory trade-off of

1177
00:34:39,396 --> 0:34:40,335
your asset sizes.

1178
00:34:40,866 --> 0:34:42,335
Make sure that both textures and

1179
00:34:42,335 --> 0:34:43,406
meshes are compressed.

1180
00:34:44,196 --> 0:34:45,376
And potentially if you are

1181
00:34:45,376 --> 0:34:47,666
getting memory limited you may

1182
00:34:47,666 --> 0:34:49,886
want to only load the smaller

1183
00:34:49,886 --> 0:34:51,525
mipmap levels of your textures,

1184
00:34:52,306 --> 0:34:53,926
or the lower LODs for your

1185
00:34:53,926 --> 0:34:54,386
meshes.

1186
00:34:55,005 --> 0:34:57,456
But there is a trade-off here

1187
00:34:57,456 --> 0:34:58,426
that we are making, between

1188
00:34:58,426 --> 0:35:00,016
image quality and memory.

1189
00:34:58,426 --> 0:35:00,016
image quality and memory.

1190
00:35:00,136 --> 0:35:02,246
It's up to you to decide, when

1191
00:35:02,246 --> 0:35:03,746
do you want to take it?

1192
00:35:04,496 --> 0:35:07,026
The next best practice number 15

1193
00:35:07,106 --> 0:35:08,206
is very similar.

1194
00:35:08,666 --> 0:35:10,806
We will want to simplify

1195
00:35:10,996 --> 0:35:12,506
memory-intensive effects.

1196
00:35:12,996 --> 0:35:16,066
Some effects may require large

1197
00:35:16,066 --> 0:35:17,746
off-screen buffers, such as

1198
00:35:17,746 --> 0:35:19,416
Shadow Maps and SSAO.

1199
00:35:19,726 --> 0:35:21,956
So the best practice will be for

1200
00:35:21,956 --> 0:35:23,146
you to consider the image

1201
00:35:23,146 --> 0:35:24,736
quality and memory trade-off of

1202
00:35:24,736 --> 0:35:25,936
all of those effects.

1203
00:35:27,086 --> 0:35:28,726
Potentially lower the resolution

1204
00:35:28,726 --> 0:35:29,946
of all these large off-screen

1205
00:35:29,946 --> 0:35:30,436
buffers.

1206
00:35:31,316 --> 0:35:32,526
And if you are very memory

1207
00:35:32,526 --> 0:35:34,606
constrained then just disable

1208
00:35:34,606 --> 0:35:36,026
all those effects all together.

1209
00:35:37,506 --> 0:35:38,696
That is a trade-off to be made

1210
00:35:38,776 --> 0:35:39,906
here and you need to be

1211
00:35:39,906 --> 0:35:41,006
conscious about it.

1212
00:35:41,256 --> 0:35:42,486
But sometimes there's no other

1213
00:35:42,486 --> 0:35:42,946
choice.

1214
00:35:44,536 --> 0:35:46,476
The next best practices that we

1215
00:35:46,476 --> 0:35:48,256
are going to cover here are

1216
00:35:48,256 --> 0:35:49,336
slightly different.

1217
00:35:50,146 --> 0:35:52,896
In this last section, I will

1218
00:35:52,896 --> 0:35:54,456
introduce a couple of more

1219
00:35:54,456 --> 0:35:56,106
advanced concepts that will help

1220
00:35:56,106 --> 0:35:58,036
us further reducing the memory

1221
00:35:58,076 --> 0:35:58,586
footprint.

1222
00:35:59,526 --> 0:36:00,946
We will talk about metal

1223
00:35:59,526 --> 0:36:00,946
We will talk about metal

1224
00:36:00,986 --> 0:36:04,556
resource heaps, purgeable memory

1225
00:36:04,806 --> 0:36:06,066
as well as pipeline state

1226
00:36:06,066 --> 0:36:06,576
objects.

1227
00:36:07,476 --> 0:36:09,286
So, let's get started with metal

1228
00:36:09,286 --> 0:36:10,066
resource heaps.

1229
00:36:11,256 --> 0:36:12,746
metal resource heaps will allow

1230
00:36:12,746 --> 0:36:13,946
your application to take

1231
00:36:13,946 --> 0:36:16,346
explicit control over the large

1232
00:36:16,376 --> 0:36:18,496
memory allocation that happens

1233
00:36:18,496 --> 0:36:19,056
up front.

1234
00:36:20,016 --> 0:36:21,516
In this case, we will go from

1235
00:36:21,516 --> 0:36:23,526
three separate textures which

1236
00:36:23,526 --> 0:36:25,686
have their own allocation into a

1237
00:36:25,806 --> 0:36:28,086
single metal resource heap which

1238
00:36:28,086 --> 0:36:29,596
is a single allocation that will

1239
00:36:29,596 --> 0:36:30,886
hold these three textures

1240
00:36:30,886 --> 0:36:31,526
separately.

1241
00:36:32,536 --> 0:36:34,406
This will also allow the system

1242
00:36:34,406 --> 0:36:35,966
to pack those textures together,

1243
00:36:36,066 --> 0:36:37,346
so we're already saving some

1244
00:36:37,346 --> 0:36:37,806
memory.

1245
00:36:38,346 --> 0:36:41,986
But the great memory savings

1246
00:36:41,986 --> 0:36:45,096
will come from using aliasing.

1247
00:36:46,136 --> 0:36:47,566
So, notice that rendering a

1248
00:36:47,566 --> 0:36:49,276
frame may require a lot of

1249
00:36:49,276 --> 0:36:51,176
intermediate memory, in

1250
00:36:51,176 --> 0:36:52,886
particular, as your game scales

1251
00:36:52,886 --> 0:36:54,236
in the post-process pipeline.

1252
00:36:55,066 --> 0:36:56,486
So it is very important for you

1253
00:36:56,486 --> 0:36:58,076
to use metal resource heaps for

1254
00:36:58,076 --> 0:37:00,316
those effects and alias as much

1255
00:36:58,076 --> 0:37:00,316
those effects and alias as much

1256
00:37:00,316 --> 0:37:01,646
of that memory as possible.

1257
00:37:02,346 --> 0:37:03,596
For example, you may want to

1258
00:37:03,596 --> 0:37:05,396
reutilize the memory for all

1259
00:37:05,396 --> 0:37:06,776
those resources which have no

1260
00:37:06,776 --> 0:37:09,406
dependencies, potentially like

1261
00:37:09,406 --> 0:37:11,076
those you would find in SSAO and

1262
00:37:11,076 --> 0:37:11,756
Depth of Field.

1263
00:37:12,296 --> 0:37:15,106
So, now, let's look how would

1264
00:37:15,106 --> 0:37:15,866
that look like.

1265
00:37:16,566 --> 0:37:18,346
In this case, we have the same

1266
00:37:18,346 --> 0:37:19,946
metal resource heap as before.

1267
00:37:21,116 --> 0:37:23,136
But if the three textures are

1268
00:37:23,136 --> 0:37:24,986
not used at the same time we can

1269
00:37:24,986 --> 0:37:26,256
potentially alias them.

1270
00:37:26,796 --> 0:37:28,156
And by doing so, we will save a

1271
00:37:28,156 --> 0:37:29,076
lot of memory.

1272
00:37:30,146 --> 0:37:31,886
And this will really help your

1273
00:37:31,886 --> 0:37:33,956
game scale with a much more

1274
00:37:33,956 --> 0:37:35,786
complex post-process pipeline

1275
00:37:36,346 --> 0:37:37,946
without having to pay a huge

1276
00:37:37,946 --> 0:37:39,646
memory price for all those

1277
00:37:39,646 --> 0:37:41,136
intermediate render targets and

1278
00:37:41,136 --> 0:37:42,276
all the intermediate memory.

1279
00:37:43,266 --> 0:37:44,576
So it is great, it's a great

1280
00:37:44,576 --> 0:37:45,886
feature that you should consider

1281
00:37:45,886 --> 0:37:46,506
leveraging.

1282
00:37:47,076 --> 0:37:49,426
Now, let's talk about another

1283
00:37:49,426 --> 0:37:50,706
advanced concept that of

1284
00:37:50,856 --> 0:37:51,816
purgeable memory.

1285
00:37:53,306 --> 0:37:54,826
Purgeable memory has three

1286
00:37:54,826 --> 0:37:58,186
states, non-volatile, volatile,

1287
00:37:58,626 --> 0:37:59,336
and empty.

1288
00:38:00,576 --> 0:38:02,516
Notice that volatile and empty

1289
00:38:02,516 --> 0:38:05,156
allocations do not count towards

1290
00:38:05,156 --> 0:38:06,246
the application memory

1291
00:38:06,326 --> 0:38:06,826
footprint.

1292
00:38:07,806 --> 0:38:09,506
That is because the system can

1293
00:38:09,506 --> 0:38:10,976
either reclaim that memory at

1294
00:38:10,976 --> 0:38:12,366
some point, in the case of

1295
00:38:12,396 --> 0:38:14,366
volatile or has already

1296
00:38:14,426 --> 0:38:15,806
reclaimed it in the past, in the

1297
00:38:15,806 --> 0:38:16,676
case of empty.

1298
00:38:17,216 --> 0:38:18,766
So you may need to regenerate

1299
00:38:18,766 --> 0:38:19,656
those resources.

1300
00:38:21,106 --> 0:38:22,456
But that makes this kind of

1301
00:38:22,496 --> 0:38:24,756
memory ideal for resource

1302
00:38:24,756 --> 0:38:25,176
caches.

1303
00:38:26,226 --> 0:38:28,616
So the best practice number 17

1304
00:38:28,616 --> 0:38:30,226
is for you to mark resources as

1305
00:38:30,226 --> 0:38:30,936
volatile.

1306
00:38:31,676 --> 0:38:33,836
Temporary resources may become a

1307
00:38:33,836 --> 0:38:35,126
large part of your game's

1308
00:38:35,126 --> 0:38:35,646
footprint.

1309
00:38:36,936 --> 0:38:38,526
And Metal will allow you to

1310
00:38:38,526 --> 0:38:40,566
explicitly manage those, set the

1311
00:38:40,566 --> 0:38:41,726
purgeable state of all the

1312
00:38:41,726 --> 0:38:43,686
resources explicitly.

1313
00:38:44,516 --> 0:38:46,136
So you will want to focus on

1314
00:38:46,136 --> 0:38:48,406
your caches particularly all of

1315
00:38:48,406 --> 0:38:49,836
those which hold mostly idle

1316
00:38:49,836 --> 0:38:52,006
memory and carefully manage

1317
00:38:52,036 --> 0:38:54,076
their purgeable state, so they

1318
00:38:54,076 --> 0:38:55,066
will not count towards the

1319
00:38:55,066 --> 0:38:55,956
game's footprint.

1320
00:38:56,976 --> 0:38:59,336
Let's see a very short bit of

1321
00:38:59,446 --> 0:39:01,036
code that will give you an

1322
00:38:59,446 --> 0:39:01,036
code that will give you an

1323
00:39:01,036 --> 0:39:02,336
example on how to do so.

1324
00:39:03,026 --> 0:39:04,446
In this case, we have a texture

1325
00:39:04,446 --> 0:39:06,116
cache, could have also been a

1326
00:39:06,116 --> 0:39:06,876
buffer cache.

1327
00:39:07,686 --> 0:39:09,456
And we will set the purgeable

1328
00:39:09,456 --> 0:39:10,766
state of all the textures in

1329
00:39:11,116 --> 0:39:13,456
that cache as volatile because

1330
00:39:13,456 --> 0:39:15,716
we know that cache is mostly

1331
00:39:15,716 --> 0:39:16,086
idle.

1332
00:39:16,216 --> 0:39:18,386
We only use a texture now

1333
00:39:18,386 --> 0:39:19,836
and then but not very often.

1334
00:39:20,296 --> 0:39:22,786
So if we need to use a resource

1335
00:39:22,786 --> 0:39:24,736
from that cache, we will then

1336
00:39:24,736 --> 0:39:26,686
need to mark it as non-volatile

1337
00:39:27,246 --> 0:39:28,916
that will ensure that the system

1338
00:39:29,296 --> 0:39:30,806
doesn't remove its backing data.

1339
00:39:32,166 --> 0:39:34,166
And in the case, it was empty

1340
00:39:34,656 --> 0:39:36,636
which was the previous state

1341
00:39:36,776 --> 0:39:37,926
that the one we just said.

1342
00:39:38,556 --> 0:39:39,776
We may actually need to

1343
00:39:39,776 --> 0:39:42,256
regenerate the data potentially

1344
00:39:42,256 --> 0:39:42,496
not.

1345
00:39:42,496 --> 0:39:44,116
It depends on what type of cache

1346
00:39:44,116 --> 0:39:44,826
you're managing.

1347
00:39:45,446 --> 0:39:47,676
But after we do so, we can just

1348
00:39:47,676 --> 0:39:49,236
utilize the resource normally as

1349
00:39:49,236 --> 0:39:50,196
we would otherwise.

1350
00:39:52,256 --> 0:39:56,676
A very good practice will be for

1351
00:39:56,676 --> 0:39:58,406
you to also check the common

1352
00:39:58,406 --> 0:40:01,416
buffer completion and get to

1353
00:39:58,406 --> 0:40:01,416
buffer completion and get to

1354
00:40:01,416 --> 0:40:02,936
handle when the common buffer is

1355
00:40:02,936 --> 0:40:04,876
completed and then potentially

1356
00:40:04,876 --> 0:40:06,936
you flag that resource as

1357
00:40:06,936 --> 0:40:07,936
volatile again.

1358
00:40:08,486 --> 0:40:10,006
So it does not keep counting

1359
00:40:10,006 --> 0:40:11,346
towards your memory footprint.

1360
00:40:12,516 --> 0:40:14,786
You can be explicit and in fact

1361
00:40:14,786 --> 0:40:16,116
you should be very aggressive

1362
00:40:16,226 --> 0:40:17,926
particularly when you have lots

1363
00:40:17,926 --> 0:40:19,716
of caches of mostly idle memory.

1364
00:40:20,306 --> 0:40:23,596
So let's introduce one last

1365
00:40:23,596 --> 0:40:25,746
concept that of pipeline state

1366
00:40:25,746 --> 0:40:26,306
objects.

1367
00:40:27,486 --> 0:40:28,846
Most of you are already familiar

1368
00:40:28,846 --> 0:40:29,466
with those.

1369
00:40:29,946 --> 0:40:32,216
PSOs encapsulate most of the

1370
00:40:32,216 --> 0:40:33,226
Metal render state.

1371
00:40:34,276 --> 0:40:35,326
They are constructed with a

1372
00:40:35,326 --> 0:40:36,826
description-- a descriptor which

1373
00:40:36,826 --> 0:40:38,486
contains vertex and fragment

1374
00:40:38,486 --> 0:40:40,306
functions as well as other

1375
00:40:40,306 --> 0:40:42,366
states such as the blend state

1376
00:40:42,796 --> 0:40:44,016
and the vertex descriptor.

1377
00:40:45,026 --> 0:40:46,636
All of these will get compiled

1378
00:40:46,636 --> 0:40:48,286
into final Metal PSO.

1379
00:40:49,686 --> 0:40:51,906
We only need this final Metal

1380
00:40:51,906 --> 0:40:53,796
PSO in order to render.

1381
00:40:54,466 --> 0:40:56,466
So the next best practice is for

1382
00:40:56,466 --> 0:40:58,506
you to explicitly leverage that.

1383
00:40:59,456 --> 0:41:00,606
Since Metal allows your

1384
00:40:59,456 --> 0:41:00,606
Since Metal allows your

1385
00:41:00,606 --> 0:41:02,336
application to load most of the

1386
00:41:02,336 --> 0:41:04,176
rendering state up front, you

1387
00:41:04,176 --> 0:41:04,896
should do so.

1388
00:41:05,386 --> 0:41:06,246
That will be great for

1389
00:41:06,246 --> 0:41:07,166
performance.

1390
00:41:07,966 --> 0:41:09,536
But then consider the memory

1391
00:41:09,536 --> 0:41:10,716
trade-off of doing that.

1392
00:41:11,656 --> 0:41:12,756
If you are getting memory

1393
00:41:12,756 --> 0:41:15,016
limited make sure do not hold on

1394
00:41:15,016 --> 0:41:17,556
to PSO references that you know

1395
00:41:17,556 --> 0:41:18,856
they are not needed anymore.

1396
00:41:19,616 --> 0:41:21,876
And very important also do not

1397
00:41:21,876 --> 0:41:23,246
hold on to Metal function

1398
00:41:23,246 --> 0:41:24,946
references after you have

1399
00:41:25,026 --> 0:41:26,426
created the PSO cache.

1400
00:41:26,936 --> 0:41:28,326
Since those are not needed to

1401
00:41:28,326 --> 0:41:29,926
render they are only needed to

1402
00:41:29,926 --> 0:41:30,936
create new PSOs.

1403
00:41:31,766 --> 0:41:33,456
So let's see what I mean by

1404
00:41:33,456 --> 0:41:35,316
looking at the descriptor again.

1405
00:41:36,086 --> 0:41:37,466
This is the pipeline state

1406
00:41:37,466 --> 0:41:38,756
object as well as the pipeline

1407
00:41:38,756 --> 0:41:39,946
state object descriptor.

1408
00:41:40,326 --> 0:41:41,616
And what this best practice is

1409
00:41:41,616 --> 0:41:43,826
asking you to do is to free the

1410
00:41:43,826 --> 0:41:45,616
reference of both the vertex and

1411
00:41:45,616 --> 0:41:46,966
fragment functions after you

1412
00:41:46,966 --> 0:41:49,136
create the PSOs, potentially

1413
00:41:49,136 --> 0:41:50,356
only hold on to those when

1414
00:41:50,356 --> 0:41:52,896
you're populating the main PSO

1415
00:41:52,896 --> 0:41:53,866
cache at load time.

1416
00:41:54,926 --> 0:41:56,876
And then consider also freeing

1417
00:41:56,876 --> 0:41:58,976
the PSO itself when you are

1418
00:41:58,976 --> 0:42:00,866
getting memory limited if you

1419
00:41:58,976 --> 0:42:00,866
getting memory limited if you

1420
00:42:00,866 --> 0:42:02,736
know that that PSO is no longer

1421
00:42:03,886 --> 0:42:04,056
needed.

1422
00:42:04,616 --> 0:42:06,136
Now, let's, please welcome

1423
00:42:06,136 --> 0:42:07,716
Onyechi on stage for an awesome

1424
00:42:07,716 --> 0:42:08,936
demo of the Memory Viewer.

1425
00:42:09,516 --> 0:42:15,006
[ Applause ]

1426
00:42:15,506 --> 0:42:16,256
&gt;&gt; Thank you Guillem.

1427
00:42:16,466 --> 0:42:17,646
Hello everyone.

1428
00:42:19,086 --> 0:42:21,076
So you already have the brief

1429
00:42:21,076 --> 0:42:22,066
introduction to the Memory

1430
00:42:22,066 --> 0:42:23,136
Viewer from the previous slides.

1431
00:42:23,276 --> 0:42:24,846
Now, I'm going to show you how

1432
00:42:24,846 --> 0:42:26,246
to use it to understand your

1433
00:42:26,246 --> 0:42:27,566
memory footprint that's

1434
00:42:27,566 --> 0:42:28,746
optimized for better memory

1435
00:42:28,746 --> 0:42:29,466
performance.

1436
00:42:29,986 --> 0:42:32,816
So here we are again with a

1437
00:42:32,816 --> 0:42:34,486
capture of a frame from the same

1438
00:42:35,026 --> 0:42:36,086
early version of the game

1439
00:42:36,296 --> 0:42:37,016
Afterpulse.

1440
00:42:37,786 --> 0:42:39,026
Then the top left there are the

1441
00:42:39,026 --> 0:42:40,746
debug navigator that you'll find

1442
00:42:40,746 --> 0:42:42,716
in your Memory Gauge which when

1443
00:42:42,716 --> 0:42:44,856
I click on it, it takes me into

1444
00:42:44,856 --> 0:42:45,436
the Memory Viewer.

1445
00:42:45,436 --> 0:42:48,326
Now this shows us the state of

1446
00:42:48,326 --> 0:42:50,116
all live Metal resources for the

1447
00:42:50,116 --> 0:42:50,616
captured frame.

1448
00:42:51,386 --> 0:42:52,596
And my goal is to find

1449
00:42:52,596 --> 0:42:53,886
opportunities to reduce its

1450
00:42:53,886 --> 0:42:54,526
memory footprint.

1451
00:42:55,326 --> 0:42:57,956
So to begin, let's take a look

1452
00:42:57,956 --> 0:42:59,956
at the orange bars in the graph.

1453
00:42:59,956 --> 0:43:01,336
This shows how our resources are

1454
00:42:59,956 --> 0:43:01,336
This shows how our resources are

1455
00:43:01,336 --> 0:43:02,606
distributed by type.

1456
00:43:02,606 --> 0:43:04,856
And we can see that textures

1457
00:43:04,856 --> 0:43:05,956
make up the largest proportion,

1458
00:43:05,956 --> 0:43:06,156
right?

1459
00:43:07,186 --> 0:43:08,916
There's about 440 megabytes of

1460
00:43:08,916 --> 0:43:09,116
them.

1461
00:43:09,506 --> 0:43:10,946
Now, I want to focus in these

1462
00:43:10,946 --> 0:43:12,186
sections and I can simply do

1463
00:43:12,186 --> 0:43:14,236
that by clicking on the filter

1464
00:43:14,236 --> 0:43:14,666
button.

1465
00:43:15,046 --> 0:43:18,176
Now, both the graph and the

1466
00:43:18,176 --> 0:43:19,576
table have been updated to show

1467
00:43:19,576 --> 0:43:20,276
textures only.

1468
00:43:20,926 --> 0:43:23,266
So, next, Guillem mentioned that

1469
00:43:23,266 --> 0:43:24,336
when looking to reduce our

1470
00:43:24,336 --> 0:43:26,666
memory footprint starting at

1471
00:43:26,666 --> 0:43:28,276
unused resources that was a

1472
00:43:28,336 --> 0:43:29,346
great place to begin.

1473
00:43:29,536 --> 0:43:30,736
So, let's do that.

1474
00:43:30,736 --> 0:43:33,266
Let's look at the blue bars this

1475
00:43:33,856 --> 0:43:33,966
time.

1476
00:43:34,186 --> 0:43:36,596
This represents our usage and we

1477
00:43:36,596 --> 0:43:37,926
see that we have about 200

1478
00:43:37,926 --> 0:43:39,356
megabytes, so unused texture.

1479
00:43:40,476 --> 0:43:43,406
So as a reminder, unused

1480
00:43:43,406 --> 0:43:44,616
resources are resources that do

1481
00:43:44,616 --> 0:43:45,936
not contribute to the final

1482
00:43:45,936 --> 0:43:47,566
output of this rendered frame.

1483
00:43:47,566 --> 0:43:49,296
That means they're not accessed

1484
00:43:49,296 --> 0:43:49,996
by the GPU.

1485
00:43:51,806 --> 0:43:54,176
OK. So, I can easily do that

1486
00:43:54,176 --> 0:43:55,156
again by just clicking on the

1487
00:43:55,156 --> 0:43:56,276
unused filter, so that we're

1488
00:43:56,276 --> 0:43:57,986
looking on unused textures now.

1489
00:43:59,276 --> 0:44:01,096
Next, I will sort the table by

1490
00:43:59,276 --> 0:44:01,096
Next, I will sort the table by

1491
00:44:01,096 --> 0:44:03,076
allocated size, so that we're

1492
00:44:03,076 --> 0:44:04,286
focused in our largest texture.

1493
00:44:04,286 --> 0:44:07,046
And we can see straight away

1494
00:44:07,046 --> 0:44:08,606
that our largest texture which

1495
00:44:08,606 --> 0:44:10,956
is about 13 megabytes has an

1496
00:44:10,956 --> 0:44:11,386
issue.

1497
00:44:12,176 --> 0:44:13,816
So, issues work here just like

1498
00:44:13,816 --> 0:44:15,406
in Dependency Viewer you saw in

1499
00:44:15,406 --> 0:44:16,226
the previous demo.

1500
00:44:16,766 --> 0:44:17,856
So let's click it to see what

1501
00:44:17,856 --> 0:44:18,396
it's about.

1502
00:44:20,026 --> 0:44:21,436
OK. So, this says we have a

1503
00:44:21,436 --> 0:44:22,546
large unused texture.

1504
00:44:23,406 --> 0:44:25,106
It's not accessed by the CPU and

1505
00:44:25,556 --> 0:44:26,796
has never been bound to a

1506
00:44:26,796 --> 0:44:28,486
command encoder with a

1507
00:44:28,486 --> 0:44:30,246
recommendation to avoid loading

1508
00:44:30,246 --> 0:44:32,076
the resource or to make it

1509
00:44:32,076 --> 0:44:32,636
volatile.

1510
00:44:33,806 --> 0:44:35,476
So, we can also confront this by

1511
00:44:35,476 --> 0:44:37,256
looking at the properties, CPU

1512
00:44:37,256 --> 0:44:38,576
Access and Times since Last

1513
00:44:38,576 --> 0:44:38,976
Bound.

1514
00:44:38,976 --> 0:44:41,366
And we can clearly see that this

1515
00:44:41,366 --> 0:44:42,536
section is definitely never been

1516
00:44:42,536 --> 0:44:44,396
accessed by either the CPU or

1517
00:44:44,396 --> 0:44:44,946
the GPU.

1518
00:44:45,406 --> 0:44:46,396
So, therefore, we can say with

1519
00:44:46,396 --> 0:44:47,506
confidence now this is a

1520
00:44:47,736 --> 0:44:49,406
resource that it should be unloaded,

1521
00:44:49,406 --> 0:44:51,756
till it's actually needed.

1522
00:44:52,066 --> 0:44:53,186
OK. So, that's encouraging, we

1523
00:44:53,186 --> 0:44:54,686
very quickly identify 13

1524
00:44:54,726 --> 0:44:56,086
megabytes of memory savings.

1525
00:44:56,846 --> 0:44:58,226
Let's check out the next issue.

1526
00:44:58,866 --> 0:45:01,476
So, in this case, texture has

1527
00:44:58,866 --> 0:45:01,476
So, in this case, texture has

1528
00:45:01,476 --> 0:45:03,036
been identified as a temporary

1529
00:45:03,036 --> 0:45:03,566
resource.

1530
00:45:03,886 --> 0:45:05,726
It's not accessed by the CPU and

1531
00:45:05,726 --> 0:45:06,966
has not been bound to a command

1532
00:45:06,966 --> 0:45:08,966
encoder for over 47 seconds.

1533
00:45:09,666 --> 0:45:10,936
So, in other words, this texture

1534
00:45:10,966 --> 0:45:12,606
has not been using this frame or

1535
00:45:12,606 --> 0:45:13,986
in any other frame in the last

1536
00:45:13,986 --> 0:45:14,986
47 seconds.

1537
00:45:15,536 --> 0:45:16,606
So this is a pretty good

1538
00:45:16,606 --> 0:45:18,196
candidate for a resource that

1539
00:45:18,196 --> 0:45:19,846
should be made volatile if

1540
00:45:19,886 --> 0:45:21,796
possible since it occasionally

1541
00:45:21,796 --> 0:45:22,916
contributes to a frame.

1542
00:45:23,816 --> 0:45:26,726
OK. So, this is fantastic.

1543
00:45:27,056 --> 0:45:30,826
We've very quickly found about

1544
00:45:30,826 --> 0:45:32,526
14 megabytes of memory savings

1545
00:45:33,006 --> 0:45:35,796
and indeed when looking to

1546
00:45:35,796 --> 0:45:36,876
reduce our memory footprint

1547
00:45:37,256 --> 0:45:39,086
looking at unused resources is a

1548
00:45:39,086 --> 0:45:41,026
great place to begin, and issues

1549
00:45:41,026 --> 0:45:41,926
that will help you to quickly

1550
00:45:41,926 --> 0:45:43,586
identify the best candidates to

1551
00:45:43,586 --> 0:45:43,906
remove.

1552
00:45:44,976 --> 0:45:45,916
But you should also pay

1553
00:45:45,916 --> 0:45:47,166
attention to the properties

1554
00:45:47,566 --> 0:45:51,256
Times since Last Bound to figure

1555
00:45:51,256 --> 0:45:52,246
out which of your unused

1556
00:45:52,246 --> 0:45:53,456
resources have never been

1557
00:45:53,456 --> 0:45:55,396
submitted to the GPU even though

1558
00:45:55,396 --> 0:45:56,556
they may have been accessed by

1559
00:45:56,556 --> 0:45:57,156
the CPU.

1560
00:45:59,196 --> 0:46:00,236
OK. Let's switch things up a

1561
00:45:59,196 --> 0:46:00,236
OK. Let's switch things up a

1562
00:46:00,236 --> 0:46:00,506
bit.

1563
00:46:00,836 --> 0:46:02,726
Let's see what issues or what

1564
00:46:02,726 --> 0:46:04,736
memory savings we can discover,

1565
00:46:04,736 --> 0:46:06,096
where textures are actually in

1566
00:46:06,096 --> 0:46:06,476
used.

1567
00:46:06,786 --> 0:46:08,696
OK. I'm going to switch to the

1568
00:46:08,696 --> 0:46:09,876
used filter this time, so we're

1569
00:46:09,876 --> 0:46:11,166
looking at used textures.

1570
00:46:11,956 --> 0:46:12,996
And we see that one of our

1571
00:46:12,996 --> 0:46:14,446
largest textures which is about

1572
00:46:14,446 --> 0:46:16,536
18 megabytes has two issues.

1573
00:46:17,296 --> 0:46:18,306
So, let's see what they are.

1574
00:46:18,306 --> 0:46:20,666
OK. So, the first one is about

1575
00:46:20,736 --> 0:46:22,586
lossless compression.

1576
00:46:22,666 --> 0:46:24,176
Texture has opted out of

1577
00:46:24,206 --> 0:46:26,106
lossless compressions because of

1578
00:46:26,106 --> 0:46:27,466
the presence of a ShaderWrite

1579
00:46:27,526 --> 0:46:29,486
usage flag, even though it's

1580
00:46:29,486 --> 0:46:31,026
being used exclusively as a

1581
00:46:31,026 --> 0:46:31,696
render target.

1582
00:46:32,706 --> 0:46:34,566
The second issue is about

1583
00:46:34,566 --> 0:46:35,156
storage mode.

1584
00:46:36,086 --> 0:46:37,996
Our texture the render target

1585
00:46:37,996 --> 0:46:39,246
has been identified as being

1586
00:46:39,246 --> 0:46:41,316
transient which obviously means

1587
00:46:41,316 --> 0:46:42,766
that no loads to actions are

1588
00:46:42,766 --> 0:46:43,586
required for this texture.

1589
00:46:44,176 --> 0:46:45,586
But unfortunately it has a

1590
00:46:45,586 --> 0:46:47,496
storage mode shared when really

1591
00:46:47,496 --> 0:46:48,676
it should be memoryless.

1592
00:46:49,826 --> 0:46:51,596
So, we have two different

1593
00:46:51,596 --> 0:46:52,386
recommendations here.

1594
00:46:53,196 --> 0:46:55,186
And if you think about it, we

1595
00:46:55,186 --> 0:46:56,416
can only really choose one of

1596
00:46:56,416 --> 0:46:56,506
them.

1597
00:46:57,596 --> 0:46:58,536
But at this point I should

1598
00:46:58,536 --> 0:46:59,626
emphasize that these

1599
00:46:59,626 --> 0:47:01,446
recommendations presented by the

1600
00:46:59,626 --> 0:47:01,446
recommendations presented by the

1601
00:47:01,446 --> 0:47:03,496
Memory Viewer are based on data

1602
00:47:03,496 --> 0:47:04,686
gathered up to the current

1603
00:47:04,686 --> 0:47:04,996
frame.

1604
00:47:05,906 --> 0:47:07,836
However, you know better about how

1605
00:47:07,836 --> 0:47:09,226
you intend to use your resource

1606
00:47:09,296 --> 0:47:10,306
beyond the current frame.

1607
00:47:11,386 --> 0:47:13,876
So, with that said if we are

1608
00:47:13,876 --> 0:47:15,386
certain that this texture will

1609
00:47:15,386 --> 0:47:17,336
remain transient and say a

1610
00:47:17,336 --> 0:47:19,416
future render passes then

1611
00:47:19,556 --> 0:47:20,786
switching to memoryless is the

1612
00:47:20,786 --> 0:47:21,586
superior option.

1613
00:47:21,706 --> 0:47:23,716
And doing so would reduce our

1614
00:47:23,716 --> 0:47:24,956
memory footprint by the size of

1615
00:47:24,956 --> 0:47:26,186
the texture which is 18

1616
00:47:26,186 --> 0:47:26,736
megabytes.

1617
00:47:27,676 --> 0:47:29,426
If on the other hand, our

1618
00:47:29,426 --> 0:47:32,276
texture will not be transient in

1619
00:47:32,276 --> 0:47:34,436
future render passes then we

1620
00:47:34,436 --> 0:47:36,056
should seriously consider opting

1621
00:47:36,056 --> 0:47:37,246
into lossless compression

1622
00:47:37,876 --> 0:47:39,076
because doing so would have a

1623
00:47:39,076 --> 0:47:40,426
positive impact on our memory

1624
00:47:40,426 --> 0:47:41,656
bandwidth as suggested by

1625
00:47:41,656 --> 0:47:42,006
Guillem.

1626
00:47:42,866 --> 0:47:44,706
And, in this case, simply

1627
00:47:44,706 --> 0:47:46,016
removing the redundant

1628
00:47:46,016 --> 0:47:48,206
ShaderWrite flag should do the

1629
00:47:49,336 --> 0:47:49,476
trick.

1630
00:47:49,656 --> 0:47:52,636
So, we've only just scratched

1631
00:47:52,636 --> 0:47:54,116
the surface of what's possible

1632
00:47:54,236 --> 0:47:54,996
with the Memory Viewer.

1633
00:47:55,556 --> 0:47:56,556
You've seen how with just a few

1634
00:47:56,556 --> 0:47:57,716
mouse clicks it makes it very

1635
00:47:57,716 --> 0:47:59,496
easy for you to understand your

1636
00:47:59,496 --> 0:48:01,266
memory usage and also it makes

1637
00:47:59,496 --> 0:48:01,266
memory usage and also it makes

1638
00:48:01,266 --> 0:48:02,596
it very quick for you to

1639
00:48:02,596 --> 0:48:04,516
identify those hard to find

1640
00:48:04,516 --> 0:48:05,696
issues that may affect your

1641
00:48:05,696 --> 0:48:06,266
performance.

1642
00:48:06,536 --> 0:48:07,876
And with that I'm going to

1643
00:48:07,876 --> 0:48:09,096
welcome Guillem back to the

1644
00:48:09,096 --> 0:48:09,456
stage.

1645
00:48:09,666 --> 0:48:09,856
Thank you.

1646
00:48:10,516 --> 0:48:14,886
[ Applause ]

1647
00:48:15,386 --> 0:48:16,856
&gt;&gt; Thank you that was also an

1648
00:48:16,856 --> 0:48:17,516
awesome demo.

1649
00:48:18,856 --> 0:48:22,146
Cool. So, we have seen a lot of

1650
00:48:22,146 --> 0:48:23,126
best practices today.

1651
00:48:23,126 --> 0:48:25,666
We've been through a total of 18

1652
00:48:25,666 --> 0:48:27,146
of them which is quite a lot of

1653
00:48:27,146 --> 0:48:28,506
content to go through really.

1654
00:48:29,416 --> 0:48:30,916
Notice that most of this best

1655
00:48:30,916 --> 0:48:32,336
practices are actually quite

1656
00:48:32,336 --> 0:48:33,146
related, right?

1657
00:48:33,206 --> 0:48:35,656
So, most of the memory bandwidth

1658
00:48:35,656 --> 0:48:37,426
best practices, will also help

1659
00:48:37,426 --> 0:48:38,416
you reducing the memory

1660
00:48:38,466 --> 0:48:39,086
footprint.

1661
00:48:39,866 --> 0:48:42,496
So, maybe the best way to

1662
00:48:42,496 --> 0:48:44,056
actually think about all this

1663
00:48:44,056 --> 0:48:46,506
content, this is a checklist of

1664
00:48:46,506 --> 0:48:48,166
optimizations for your Metal

1665
00:48:48,166 --> 0:48:49,236
game or application.

1666
00:48:50,386 --> 0:48:53,416
And when you carefully take all

1667
00:48:53,416 --> 0:48:56,076
of these elements, you too will

1668
00:48:56,076 --> 0:48:58,236
be delivering optimized Metal

1669
00:48:58,266 --> 0:49:00,396
games and apps, which was all

1670
00:48:58,266 --> 0:49:00,396
games and apps, which was all

1671
00:49:00,396 --> 0:49:02,486
that this talk is all about.

1672
00:49:02,836 --> 0:49:05,026
For more information please see

1673
00:49:05,026 --> 0:49:07,146
our documentation online and

1674
00:49:07,146 --> 0:49:08,996
come visit us at the lab today

1675
00:49:08,996 --> 0:49:09,406
at 3.

1676
00:49:10,456 --> 0:49:11,696
Thank you very much and I hope

1677
00:49:11,696 --> 0:49:12,766
you enjoy the rest of the show.

1678
00:49:12,766 --> 0:49:12,956
Thank you.

1679
00:49:13,508 --> 0:49:15,508
[ Applause ]
