1
00:00:01,176 --> 0:00:04,500
[音乐]

2
00:00:07,296 --> 0:00:08,966
&gt;&gt; 大家好 我是 Jonathan Davis

3
00:00:08,966 --> 0:00:10,626
Web 技术的传播者

4
00:00:10,626 --> 0:00:12,196
来自 Safari 和 WebKit 团队

5
00:00:12,686 --> 0:00:14,376
欢迎观看“使用网页检查器

6
00:00:14,376 --> 0:00:15,976
了解 CPU 使用率”

7
00:00:17,666 --> 0:00:20,676
众所周知 用户很在乎电池续航

8
00:00:20,676 --> 0:00:22,516
或许你们仅凭直觉就能猜到

9
00:00:22,516 --> 0:00:23,646
在我们的设备上

10
00:00:23,646 --> 0:00:25,726
网页浏览器是最常使用的 App 之一

11
00:00:26,236 --> 0:00:28,686
但除此之外 网页内容

12
00:00:28,686 --> 0:00:30,366
也出现在许多流行的

13
00:00:30,366 --> 0:00:32,616
iOS App 和 macOS App 里

14
00:00:33,226 --> 0:00:34,626
这意味着网页内容

15
00:00:34,626 --> 0:00:36,276
会显著影响用户的电池续航

16
00:00:36,276 --> 0:00:38,376
所以使它更节能

17
00:00:38,376 --> 0:00:40,246
会有很大影响

18
00:00:41,346 --> 0:00:42,736
Safari 浏览器和 Webkit 

19
00:00:42,736 --> 0:00:43,706
早就提供了这种功能

20
00:00:43,706 --> 0:00:45,226
也就是尽可能地

21
00:00:45,226 --> 0:00:47,096
自动为用户节能

22
00:00:47,096 --> 0:00:48,746
例如 当一个网页在后台运行时

23
00:00:48,746 --> 0:00:49,556
会调用节流定时器

24
00:00:50,456 --> 0:00:51,896
加上内容拦截插件的支持

25
00:00:51,896 --> 0:00:53,716
用户得以自行

26
00:00:53,716 --> 0:00:55,156
拦截不想加载的内容

27
00:00:55,156 --> 0:00:56,646
那些内容往往是垃圾信息

28
00:00:56,646 --> 0:00:58,006
拖慢浏览器速度

29
00:00:58,006 --> 0:00:59,976
甚至会追踪用户行为

30
00:01:01,896 --> 0:01:03,316
然而 即使 Safari 浏览器

31
00:01:03,316 --> 0:01:05,025
有内置的节能特性

32
00:01:05,275 --> 0:01:06,766
仍然有很多事

33
00:01:06,766 --> 0:01:08,616
是网页开发者能做的

34
00:01:08,616 --> 0:01:10,126
这对我们大家来说都是一个好机会

35
00:01:10,126 --> 0:01:11,646
来改善网页表现

36
00:01:11,646 --> 0:01:13,566
为用户构建节能的网页

37
00:01:14,786 --> 0:01:18,376
好消息是 你所知道的所有

38
00:01:18,376 --> 0:01:20,796
优化网页表现的做法

39
00:01:20,796 --> 0:01:22,896
同时也是最好的节能手段

40
00:01:23,486 --> 0:01:24,946
我们听说过的所有

41
00:01:24,946 --> 0:01:26,716
关于提升网页加载速度

42
00:01:27,166 --> 0:01:29,346
优化 JavaScript

43
00:01:29,346 --> 0:01:31,476
使用 CSS 动画属性与过渡属性

44
00:01:31,886 --> 0:01:33,496
都有助于延长电池续航

45
00:01:34,606 --> 0:01:35,756
无论你对所有这些

46
00:01:35,756 --> 0:01:36,976
提升网页表现的

47
00:01:36,976 --> 0:01:38,606
最优做法烂熟于心

48
00:01:38,606 --> 0:01:40,306
还是刚刚入门 我都会向你们展示

49
00:01:40,306 --> 0:01:42,056
网页检查器里的一款强大的新工具

50
00:01:42,056 --> 0:01:43,546
它会赋予你超能力

51
00:01:43,546 --> 0:01:45,996
便于你找出哪些表现尚有不足

52
00:01:45,996 --> 0:01:47,586
并以此延长电池续航

53
00:01:48,426 --> 0:01:50,406
我们叫它 CPU 使用率时间线

54
00:01:50,406 --> 0:01:52,676
它是网页检查器的一项新功能

55
00:01:52,676 --> 0:01:55,316
你会在 macOS 上的 Safari 13 里找到它

56
00:01:55,826 --> 0:01:57,336
它有一个电量使用窗口  

57
00:01:57,336 --> 0:01:58,906
使你能轻易发现

58
00:01:58,906 --> 0:02:00,036
那些导致 CPU 高使用率的

59
00:01:58,906 --> 0:02:00,036
那些导致 CPU 高使用率的

60
00:02:00,036 --> 0:02:01,926
行为带来的影响

61
00:02:03,996 --> 0:02:05,556
今天 我将向你们展示

62
00:02:05,556 --> 0:02:07,206
如何使用新的 CPU 使用率时间线

63
00:02:07,206 --> 0:02:11,846
发现 CPU 使用时的耗电问题

64
00:02:11,846 --> 0:02:13,386
接着我会简述一些策略

65
00:02:13,386 --> 0:02:16,276
使你的基于网页的项目变得更节能

66
00:02:17,276 --> 0:02:18,536
在你使用这个时间线之前

67
00:02:18,536 --> 0:02:20,066
你需要启用“开发”菜单

68
00:02:20,066 --> 0:02:22,156
来访问网页检查器

69
00:02:23,946 --> 0:02:25,616
只需打开 Safari 浏览器的偏好设置

70
00:02:25,936 --> 0:02:28,496
点击 高级

71
00:02:28,496 --> 0:02:31,506
点击 在菜单栏中显示“开发”菜单来启用它

72
00:02:33,256 --> 0:02:35,356
接着 打开一个网页

73
00:02:35,356 --> 0:02:36,546
从“开发”菜单中打开

74
00:02:36,546 --> 0:02:40,116
网页检查器 或者使用快捷键

75
00:02:40,116 --> 0:02:41,016
Command 加 Option 加 I

76
00:02:41,256 --> 0:02:44,056
接下来我会使用新的

77
00:02:44,056 --> 0:02:45,936
CPU 使用率时间线来寻找 webkit.org 上

78
00:02:45,936 --> 0:02:48,196
有哪些可以改善能耗的地方

79
00:02:48,326 --> 0:02:50,356
主页非常简单

80
00:02:50,676 --> 0:02:51,826
但也挺有趣

81
00:02:51,906 --> 0:02:54,186
还是有一些动态元素

82
00:02:54,186 --> 0:02:56,256
比如背景里不显眼的 logo 动画

83
00:02:58,776 --> 0:03:00,646
现在网页检查器已经打开

84
00:02:58,776 --> 0:03:00,646
现在网页检查器已经打开

85
00:03:00,646 --> 0:03:02,036
点击时间线标签页

86
00:03:05,206 --> 0:03:07,716
左上角是不同时间线的列表

87
00:03:08,056 --> 0:03:10,246
也有其他时间线可用

88
00:03:10,246 --> 0:03:11,886
但是默认时间线下寻找

89
00:03:11,886 --> 0:03:13,826
如何改善 CPU 使用率就够了

90
00:03:16,236 --> 0:03:17,656
要想开始录制

91
00:03:17,656 --> 0:03:19,276
你可以点这个红色的“录制”按钮

92
00:03:19,276 --> 0:03:20,606
或者按下“空格”键

93
00:03:20,606 --> 0:03:21,876
但我会点击“刷新”按钮

94
00:03:21,876 --> 0:03:23,336
它会自动开始录制

95
00:03:23,336 --> 0:03:25,986
并且捕获页面加载情况

96
00:03:27,536 --> 0:03:29,736
当检查 CPU 使用率时

97
00:03:29,736 --> 0:03:32,766
一定要记住录制至少 15 秒

98
00:03:32,766 --> 0:03:35,186
以得到一次有效的测量

99
00:03:36,116 --> 0:03:37,616
我会让这次录制稍长一些

100
00:03:37,616 --> 0:03:39,396
来获取足够的数据

101
00:03:41,326 --> 0:03:42,306
在时间线上滚动滚轮

102
00:03:42,306 --> 0:03:43,796
来放大一些

103
00:03:43,796 --> 0:03:44,536
我就能看到所有细节

104
00:03:47,106 --> 0:03:48,786
点击 CPU 时间线

105
00:03:48,786 --> 0:03:50,356
你可以看到该网页

106
00:03:50,356 --> 0:03:51,466
CPU 使用率的细节

107
00:03:52,416 --> 0:03:54,136
只瞟一眼 我就能判断

108
00:03:54,136 --> 0:03:55,176
该网页表现不错

109
00:03:55,176 --> 0:03:56,576
能耗保持得很低

110
00:03:57,326 --> 0:03:58,896
加载时间短很有用

111
00:03:59,256 --> 0:04:01,346
如果页面闲置

112
00:03:59,256 --> 0:04:01,346
如果页面闲置

113
00:04:01,676 --> 0:04:03,096
时间线显示该网页

114
00:04:03,096 --> 0:04:04,386
基本上什么都没有运行

115
00:04:05,016 --> 0:04:06,236
很棒 因为这意味着

116
00:04:06,236 --> 0:04:07,976
即使用户把网页开一天

117
00:04:07,976 --> 0:04:10,006
CPU 使用率也会掉到

118
00:04:10,006 --> 0:04:11,856
一个非常低的状态

119
00:04:11,856 --> 0:04:14,086
网页内容带来的功耗可忽略不计

120
00:04:16,416 --> 0:04:17,875
网页内容中许多有趣的事情

121
00:04:17,875 --> 0:04:20,005
都发生在主线程

122
00:04:20,596 --> 0:04:22,055
主线程图表显示了

123
00:04:22,055 --> 0:04:23,336
在主线程上完成的

124
00:04:23,496 --> 0:04:24,486
不同种类的工作

125
00:04:24,486 --> 0:04:26,056
包含 JavaScript 处理

126
00:04:26,466 --> 0:04:28,796
绘制 布局 以及

127
00:04:28,796 --> 0:04:30,846
布局服务内的 例如页面重绘

128
00:04:31,806 --> 0:04:32,896
基于这些 我们能看到

129
00:04:32,896 --> 0:04:34,336
大多数工作

130
00:04:34,336 --> 0:04:35,286
都花在了绘制上

131
00:04:35,756 --> 0:04:37,556
在指示器的中间

132
00:04:37,556 --> 0:04:38,826
显示了主线程

133
00:04:38,826 --> 0:04:40,046
完成工作所花的时间

134
00:04:40,326 --> 0:04:42,286
整个录制时间大概有 20 秒

135
00:04:42,286 --> 0:04:45,456
但是主线程只花了 100 毫秒

136
00:04:45,456 --> 0:04:46,306
就完成了工作

137
00:04:48,586 --> 0:04:50,146
在主线程图表的下方

138
00:04:50,146 --> 0:04:51,906
是 CPU 使用率的详解

139
00:04:51,906 --> 0:04:53,596
含括了所有

140
00:04:53,596 --> 0:04:55,616
为网页内容工作的线程

141
00:04:55,816 --> 0:04:58,036
要了解详细信息的话

142
00:04:58,036 --> 0:04:59,516
你可以在时间线上点击 拖拽

143
00:04:59,516 --> 0:05:02,986
来选择完成任务时的时间范围

144
00:04:59,516 --> 0:05:02,986
来选择完成任务时的时间范围

145
00:05:04,396 --> 0:05:06,306
在 CPU 使用率图的下方

146
00:05:06,306 --> 0:05:09,176
这个窄条是主线程指示器

147
00:05:09,176 --> 0:05:11,826
显示了在不同时间点

148
00:05:11,826 --> 0:05:14,166
主线程上处理过的各种工作

149
00:05:14,636 --> 0:05:16,866
在这片逐渐活跃的区域

150
00:05:16,866 --> 0:05:18,406
这里有一些

151
00:05:18,406 --> 0:05:19,716
红色的布局事件 后面

152
00:05:19,716 --> 0:05:21,446
跟着大量的绘制工作

153
00:05:21,446 --> 0:05:22,636
就像上面的图表

154
00:05:22,636 --> 0:05:23,706
但是这里显示了发生的时间

155
00:05:26,216 --> 0:05:28,306
但功耗影响计量表把这些

156
00:05:28,306 --> 0:05:29,446
统统算了进来

157
00:05:29,736 --> 0:05:31,386
它的数值基于

158
00:05:31,386 --> 0:05:33,426
所有 CPU 核心在这段时间内的

159
00:05:33,426 --> 0:05:35,806
总体平均使用率

160
00:05:38,016 --> 0:05:39,536
能耗计量表

161
00:05:39,536 --> 0:05:41,256
是可交互的

162
00:05:41,256 --> 0:05:42,786
而且作为总平均数

163
00:05:42,786 --> 0:05:44,086
会根据选择的时间范围变化

164
00:05:44,446 --> 0:05:46,366
在页面加载期间

165
00:05:46,366 --> 0:05:47,886
计量表显示出中等能耗

166
00:05:47,886 --> 0:05:49,866
但是加载本就是一个相当耗能的过程

167
00:05:49,866 --> 0:05:51,706
所以结果可以预期

168
00:05:52,156 --> 0:05:54,236
至少没有达到高能耗

169
00:05:54,236 --> 0:05:55,176
那原本可能会有问题

170
00:05:55,176 --> 0:05:57,086
但双击时间线区域

171
00:05:57,086 --> 0:05:58,666
选择整条录制

172
00:05:58,666 --> 0:06:00,396
这里显示总体的

173
00:05:58,666 --> 0:06:00,396
这里显示总体的

174
00:06:00,396 --> 0:06:02,276
CPU 均值还是很低

175
00:06:02,906 --> 0:06:04,536
我可以通过点击和拖拽

176
00:06:04,536 --> 0:06:06,386
时间线来选定

177
00:06:06,386 --> 0:06:08,126
录制中的某段时间

178
00:06:08,126 --> 0:06:09,566
观察均值的变化

179
00:06:11,286 --> 0:06:13,416
现在 当我点击并抓取所选区域

180
00:06:13,416 --> 0:06:14,876
将它滑动到

181
00:06:14,876 --> 0:06:16,246
网页闲置期间

182
00:06:16,666 --> 0:06:18,166
能耗降到极低

183
00:06:18,816 --> 0:06:19,836
这真的很棒

184
00:06:20,316 --> 0:06:21,856
当网页闲置时

185
00:06:21,856 --> 0:06:23,316
我们不希望用户

186
00:06:23,316 --> 0:06:25,496
为没有在使用的内容耗能

187
00:06:27,266 --> 0:06:29,116
闲置时 CPU 的使用率保持在较低范围

188
00:06:29,116 --> 0:06:30,456
即使页面背景上

189
00:06:30,456 --> 0:06:32,966
有个旋转的 logo 动画

190
00:06:33,316 --> 0:06:34,376
那是因为它使用了

191
00:06:34,376 --> 0:06:36,556
简单的 CSS 动画属性

192
00:06:36,556 --> 0:06:38,396
能在低功耗下运行

193
00:06:38,396 --> 0:06:40,976
同时让网页有良好的视觉表现

194
00:06:42,156 --> 0:06:43,606
Webkit.org 到现在为止都表现得不错

195
00:06:43,606 --> 0:06:45,056
当你检查功耗问题时

196
00:06:45,056 --> 0:06:47,076
推荐优先检查

197
00:06:47,076 --> 0:06:48,406
加载和闲置

198
00:06:49,016 --> 0:06:50,926
为了顾及所有方面

199
00:06:50,926 --> 0:06:51,716
我们也需要获得一些

200
00:06:51,716 --> 0:06:52,726
交互时的数据

201
00:06:54,406 --> 0:06:56,396
Webkit 特性状态网页

202
00:06:56,396 --> 0:06:57,756
能够让你了解到

203
00:06:57,756 --> 0:06:59,256
WebKit 对于你最喜欢的

204
00:06:59,256 --> 0:07:00,506
网页特性的最新支持情况

205
00:06:59,256 --> 0:07:00,506
网页特性的最新支持情况

206
00:07:00,926 --> 0:07:02,266
你可以用它筛选和搜索

207
00:07:02,266 --> 0:07:03,676
这用来捕获交互数据

208
00:07:03,676 --> 0:07:04,646
再完美不过了

209
00:07:04,936 --> 0:07:07,296
我会录制一段时间线

210
00:07:07,296 --> 0:07:09,036
然后与网页进行一些交互

211
00:07:09,036 --> 0:07:10,456
下滑到底部

212
00:07:15,766 --> 0:07:17,976
接着快速搜索

213
00:07:17,976 --> 0:07:19,346
到处点几下

214
00:07:19,986 --> 0:07:22,796
重申 我们至少

215
00:07:22,796 --> 0:07:24,236
要录 15 秒

216
00:07:24,736 --> 0:07:26,256
既然我们在一个新的网页上

217
00:07:26,256 --> 0:07:28,086
所以也应该包括一段闲置期

218
00:07:29,066 --> 0:07:30,466
我让它继续录制

219
00:07:30,466 --> 0:07:32,976
直到获得足够的闲置时间的数据

220
00:07:37,346 --> 0:07:38,556
好了 这样看起来不错

221
00:07:39,436 --> 0:07:40,476
我选中整段录制

222
00:07:40,476 --> 0:07:42,636
滚动光标

223
00:07:42,636 --> 0:07:43,966
将时间线缩小一些

224
00:07:43,966 --> 0:07:49,186
这样就能看到完整的 CPU 使用率细节了

225
00:07:53,756 --> 0:07:55,186
我们开始分析这些区域

226
00:07:55,186 --> 0:07:56,956
从加载开始

227
00:07:58,836 --> 0:08:00,526
在快速加载期间

228
00:07:58,836 --> 0:08:00,526
在快速加载期间

229
00:08:00,526 --> 0:08:01,876
网页成功避开了高功耗区域

230
00:08:01,876 --> 0:08:03,596
这里没问题

231
00:08:05,206 --> 0:08:07,326
接下来我们来看交互时的功耗

232
00:08:08,236 --> 0:08:11,406
功耗影响保持在中等区域

233
00:08:11,406 --> 0:08:12,976
即使有这么多进程正在处理

234
00:08:12,976 --> 0:08:14,346
你可以从 JavaScript 与事件

235
00:08:14,346 --> 0:08:15,986
时间线上看到 滚动和交互时

236
00:08:15,986 --> 0:08:18,186
有许多脚本被触发

237
00:08:18,866 --> 0:08:19,976
让 CPU 在滚动时做无用功

238
00:08:19,976 --> 0:08:21,646
是我们想极力避免的

239
00:08:21,646 --> 0:08:23,996
因为滚动非常耗能

240
00:08:24,956 --> 0:08:26,076
让我们看看是否有必要

241
00:08:26,076 --> 0:08:27,366
进行这项工作

242
00:08:28,156 --> 0:08:29,796
统计与源数据

243
00:08:29,796 --> 0:08:31,086
这两块区域可以告诉我们一些事

244
00:08:31,936 --> 0:08:33,376
在选中的录制时间里

245
00:08:33,376 --> 0:08:34,895
有超过 1200 个

246
00:08:34,895 --> 0:08:37,405
JavaScript 里的条目

247
00:08:37,405 --> 0:08:38,916
有 594 个请求动画的定时器被启动

248
00:08:38,916 --> 0:08:41,836
还有 647 个滚动事件

249
00:08:42,716 --> 0:08:44,226
我知道减少定时器的数量

250
00:08:44,226 --> 0:08:45,516
和不滚动

251
00:08:45,516 --> 0:08:46,786
能有更好的功耗表现

252
00:08:46,786 --> 0:08:47,946
但是我们需要看看代码

253
00:08:47,946 --> 0:08:49,946
来了解是否必要或者是否能够提升

254
00:08:50,876 --> 0:08:52,666
在统计区域

255
00:08:52,666 --> 0:08:54,236
你可以点击计时器或事件

256
00:08:54,236 --> 0:08:55,616
来筛选右边的数据源

257
00:08:55,666 --> 0:08:57,556
从而找到触发它的代码

258
00:08:57,556 --> 0:08:59,106
点击数据源

259
00:08:59,106 --> 0:09:00,276
会直接让你在 JavaScript 调试器里

260
00:08:59,106 --> 0:09:00,276
会直接让你在 JavaScript 调试器里

261
00:09:00,276 --> 0:09:01,286
看到代码

262
00:09:04,316 --> 0:09:06,236
好 看起来

263
00:09:06,236 --> 0:09:07,936
请求动画帧的定时器

264
00:09:07,936 --> 0:09:09,776
在调用 updateImages

265
00:09:09,806 --> 0:09:11,406
会在所有图片上重复应用

266
00:09:11,466 --> 0:09:12,706
检查它们是否在视图中

267
00:09:12,806 --> 0:09:14,076
如果在的话 就加载

268
00:09:14,676 --> 0:09:16,286
这是个非常基本的

269
00:09:16,286 --> 0:09:18,426
减少加载图像的特性

270
00:09:18,426 --> 0:09:19,916
但是在调试器里的暗色代码

271
00:09:20,256 --> 0:09:22,076
告诉我们 inView 和 loadImage

272
00:09:22,076 --> 0:09:22,966
从来没有被调用

273
00:09:24,506 --> 0:09:25,496
即使我们滚动到

274
00:09:25,496 --> 0:09:27,616
页面底部

275
00:09:27,616 --> 0:09:29,446
又回到顶部

276
00:09:29,446 --> 0:09:30,666
但这很合理

277
00:09:30,666 --> 0:09:32,236
因为该页面基本没有图片

278
00:09:32,736 --> 0:09:34,386
所以延迟加载图片的代码

279
00:09:34,386 --> 0:09:36,186
在该页面根本不该被触发

280
00:09:36,996 --> 0:09:38,446
我们切回代码看看

281
00:09:38,656 --> 0:09:40,816
图像和事件

282
00:09:40,816 --> 0:09:42,046
处理器在这里

283
00:09:43,346 --> 0:09:44,996
所以看一眼代码

284
00:09:44,996 --> 0:09:46,306
它在这段时间里

285
00:09:46,306 --> 0:09:47,916
一直在设置

286
00:09:47,916 --> 0:09:48,586
处理滚动和调整大小的处理器

287
00:09:49,246 --> 0:09:50,746
为了避免这种事情

288
00:09:50,746 --> 0:09:52,366
我们只需添加一个条件防护器

289
00:09:53,666 --> 0:09:55,206
好了 来试试吧

290
00:09:58,656 --> 0:10:00,406
我们来录制一条

291
00:09:58,656 --> 0:10:00,406
我们来录制一条

292
00:10:00,406 --> 0:10:01,526
经过修改的时间线

293
00:10:02,236 --> 0:10:03,586
接下来我点回到

294
00:10:03,586 --> 0:10:06,246
时间线标签 开始新的录制

295
00:10:06,246 --> 0:10:11,086
我会快速滚动一下

296
00:10:13,996 --> 0:10:15,216
你可以看到在时间线里

297
00:10:15,216 --> 0:10:17,306
没有任何 JavaScript 条目

298
00:10:17,496 --> 0:10:19,296
全部都只是绘制

299
00:10:19,296 --> 0:10:20,566
所以我们的防护器

300
00:10:20,566 --> 0:10:21,986
有效在没有任何延迟加载的页面上

301
00:10:21,986 --> 0:10:23,676
滚动的时候

302
00:10:23,676 --> 0:10:24,726
阻止了额外的 JavaScript 工作

303
00:10:26,316 --> 0:10:27,866
这样一来能耗就降低了

304
00:10:27,866 --> 0:10:30,566
主线程的所有工作只有

305
00:10:30,566 --> 0:10:32,276
对滚动的绘制 但是我们

306
00:10:32,276 --> 0:10:33,586
需要确保那些

307
00:10:33,586 --> 0:10:35,846
用了延迟加载图像的网页仍然正常

308
00:10:37,636 --> 0:10:39,036
再一次 有了这个修改

309
00:10:39,306 --> 0:10:41,156
我会在一个底部有

310
00:10:41,156 --> 0:10:42,756
MotionMark 图标的网页上录制

311
00:10:42,756 --> 0:10:44,176
一条新的时间线

312
00:10:44,176 --> 0:10:45,236
这次应该会用到延迟加载

313
00:10:47,016 --> 0:10:49,446
完美 MotionMark 图片加载成功

314
00:10:49,736 --> 0:10:51,126
我会继续滚动

315
00:10:51,126 --> 0:10:52,416
得到新行为的 CPU 测量

316
00:10:52,416 --> 0:10:54,076
然后点击 CPU 时间线

317
00:10:54,076 --> 0:10:57,866
看看怎么样

318
00:10:58,136 --> 0:11:00,936
我们减少了定时器和事件

319
00:10:58,136 --> 0:11:00,936
我们减少了定时器和事件

320
00:11:00,936 --> 0:11:03,146
让页面刚好够用

321
00:11:03,476 --> 0:11:07,916
这很棒 但是对于有延迟加载的图像的网页

322
00:11:07,916 --> 0:11:10,436
仍然有很多条目在 Script 里

323
00:11:11,286 --> 0:11:12,756
Safari 中有一个可用的 API

324
00:11:12,756 --> 0:11:14,276
我们可以用它来

325
00:11:14,276 --> 0:11:15,636
完善这种解决方案

326
00:11:16,176 --> 0:11:17,406
我们可以替换掉

327
00:11:17,406 --> 0:11:18,956
请求动画帧的相关实现

328
00:11:19,076 --> 0:11:21,126
使用 Intersection Observer

329
00:11:22,526 --> 0:11:24,016
Intersection Observer 可以告诉我们

330
00:11:24,016 --> 0:11:25,446
一个元素什么时候进入视图

331
00:11:25,686 --> 0:11:27,046
这样你可以把工作

332
00:11:27,046 --> 0:11:28,196
限制在仅当元素可见的时候

333
00:11:28,436 --> 0:11:29,766
一旦不在屏幕上显示

334
00:11:29,766 --> 0:11:31,466
你可以立即让它停止工作

335
00:11:31,466 --> 0:11:33,026
使 CPU 回到低功耗状态

336
00:11:33,026 --> 0:11:34,306
从而实现节能

337
00:11:36,256 --> 0:11:37,176
当 Intersection Observer

338
00:11:37,176 --> 0:11:38,816
生效后 我们再来

339
00:11:38,816 --> 0:11:40,536
录制一段时间线

340
00:11:40,536 --> 0:11:41,776
做一些滚动来观察

341
00:11:41,776 --> 0:11:42,856
这种方案的表现

342
00:11:44,016 --> 0:11:45,196
当我开始滚动

343
00:11:45,456 --> 0:11:46,736
这里只有一个单独的条目进入了 JavaScript

344
00:11:46,736 --> 0:11:48,526
而其余的时间里 

345
00:11:48,526 --> 0:11:50,516
当我滚动的时候 只有绘制

346
00:11:57,516 --> 0:11:58,686
最终 Intersection Observer 的

347
00:11:58,686 --> 0:12:02,666
方案使 CPU 平均使用率

348
00:11:58,686 --> 0:12:02,666
方案使 CPU 平均使用率

349
00:12:02,666 --> 0:12:04,796
从 16.3% 降到了 9.5%

350
00:12:05,276 --> 0:12:06,596
一点一滴都有所帮助

351
00:12:06,596 --> 0:12:08,086
得到的提升非常可观

352
00:12:08,516 --> 0:12:10,816
综上 有许多方法可以

353
00:12:10,816 --> 0:12:12,246
为网页内容节能

354
00:12:13,586 --> 0:12:15,436
使用 CPU 使用率时间线来

355
00:12:15,436 --> 0:12:17,076
观察网页内容

356
00:12:17,076 --> 0:12:18,676
在交互与闲置时的表现

357
00:12:18,676 --> 0:12:19,966
来改善网页的功耗

358
00:12:21,096 --> 0:12:23,176
请记得降低 CPU 使用率

359
00:12:23,176 --> 0:12:24,906
就等同于为用户节能和减少

360
00:12:24,906 --> 0:12:25,906
电量消耗

361
00:12:27,586 --> 0:12:29,586
CSS 动画属性与过渡属性

362
00:12:29,586 --> 0:12:31,146
能够在低功耗下

363
00:12:31,146 --> 0:12:34,176
提供动态效果

364
00:12:34,176 --> 0:12:36,026
在滚动时免除了一些工作

365
00:12:36,196 --> 0:12:38,426
使用 Intersection Observer API 作为替代

366
00:12:39,506 --> 0:12:41,306
用户想要的是一种有吸引力的 动态的

367
00:12:41,306 --> 0:12:43,056
网页内容体验

368
00:12:43,056 --> 0:12:44,086
但是最佳的体验

369
00:12:44,086 --> 0:12:45,916
是那种尽可能

370
00:12:45,916 --> 0:12:47,086
少占用 CPU 的做法

371
00:12:48,386 --> 0:12:49,106
在 Webkit Blog 上还有更多

372
00:12:49,106 --> 0:12:50,476
提供给网页开发者的

373
00:12:50,476 --> 0:12:52,006
节能小技巧

374
00:12:52,516 --> 0:12:53,416
你们可以在视频附带的

375
00:12:53,416 --> 0:12:56,016
资源区找到链接

376
00:12:57,866 --> 0:12:59,196
希望你们会在自己的网页内容上

377
00:12:59,196 --> 0:13:00,776
试试这些工具

378
00:12:59,196 --> 0:13:00,776
试试这些工具

379
00:13:00,776 --> 0:13:02,476
并将本视频给出的建议

380
00:13:02,476 --> 0:13:03,816
作为起步

381
00:13:03,816 --> 0:13:05,526
寻求如何优化

382
00:13:05,526 --> 0:13:06,646
你的网页内容

383
00:13:06,646 --> 0:13:08,496
和我们一起

384
00:13:08,496 --> 0:13:10,016
通过使网页更节能

385
00:13:10,016 --> 0:13:11,976
来使其更强大
