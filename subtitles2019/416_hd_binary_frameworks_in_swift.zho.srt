1
00:00:01,176 --> 0:00:06,516
[音乐]

2
00:00:07,516 --> 0:00:11,906
[掌声和欢呼]

3
00:00:12,406 --> 0:00:13,346
&gt;&gt; 大家下午好

4
00:00:14,286 --> 0:00:15,266
我叫 Harlan

5
00:00:15,266 --> 0:00:16,966
我非常高兴能和

6
00:00:16,966 --> 0:00:19,296
你们讨论 Xcode 11 是如何允许

7
00:00:19,296 --> 0:00:20,886
你们在 Swift 中创建和分发

8
00:00:21,156 --> 0:00:22,896
二进制框架的

9
00:00:24,126 --> 0:00:25,376
在讨论二进制框架之前

10
00:00:25,376 --> 0:00:26,856
我想先花点时间

11
00:00:26,856 --> 0:00:29,106
谈谈 Swift 包

12
00:00:30,196 --> 0:00:31,386
借助 Xcode 11 中

13
00:00:31,386 --> 0:00:33,926
对 Swift 包的新支持

14
00:00:33,926 --> 0:00:35,616
你们可以轻松地在项目中

15
00:00:35,616 --> 0:00:38,136
创建和使用它们并将其分发给其他人

16
00:00:38,586 --> 0:00:41,196
Swift 包是

17
00:00:41,196 --> 0:00:42,416
分发代码的好方法

18
00:00:42,756 --> 0:00:43,956
因为 Xcode 知道如何

19
00:00:43,956 --> 0:00:45,746
管理它们的依赖关系

20
00:00:45,746 --> 0:00:47,696
它会自动找出

21
00:00:47,696 --> 0:00:49,626
要使用的包版本

22
00:00:50,236 --> 0:00:52,346
由于它们是以

23
00:00:52,346 --> 0:00:54,716
源代码形式进行分发的

24
00:00:54,716 --> 0:00:56,396
因此无需保持

25
00:00:56,396 --> 0:00:57,946
与客户端的二进制兼容性

26
00:00:58,676 --> 0:01:00,536
如果你有能力

27
00:00:58,676 --> 0:01:00,536
如果你有能力

28
00:01:00,716 --> 0:01:02,146
提供项目的源代码

29
00:01:02,746 --> 0:01:04,775
那么 Swift 包

30
00:01:04,936 --> 0:01:06,266
真的很棒

31
00:01:07,496 --> 0:01:09,166
但并不是每个人都有能力

32
00:01:09,166 --> 0:01:10,226
发布其库的源代码

33
00:01:10,226 --> 0:01:12,366
如果你没有这个能力

34
00:01:13,376 --> 0:01:14,646
那么 Xcode 11 支持使用

35
00:01:14,646 --> 0:01:16,386
新的 XC 框架格式

36
00:01:16,456 --> 0:01:18,616
分发二进制库

37
00:01:19,516 --> 0:01:24,186
[掌声]

38
00:01:24,686 --> 0:01:25,766
因此在这次演讲中

39
00:01:25,766 --> 0:01:27,766
我将向你介绍 XC 框架

40
00:01:28,106 --> 0:01:29,486
这是一种受支持的

41
00:01:29,486 --> 0:01:31,116
分发二进制框架的新方法

42
00:01:31,856 --> 0:01:33,156
我还将讨论一些

43
00:01:33,156 --> 0:01:34,566
客户在选择

44
00:01:34,566 --> 0:01:36,096
使用第三方代码时

45
00:01:36,096 --> 0:01:38,956
应该考虑的事情

46
00:01:39,166 --> 0:01:40,756
接下来

47
00:01:40,816 --> 0:01:43,026
我将讨论 XC 框中的内容

48
00:01:43,026 --> 0:01:44,346
以及如何为项目

49
00:01:44,346 --> 0:01:45,116
创建一个 XC 框架

50
00:01:46,476 --> 0:01:48,466
最后我的同事

51
00:01:48,466 --> 0:01:50,126
Jordan 会来和你们讨论

52
00:01:50,126 --> 0:01:51,106
一些框架作者

53
00:01:51,106 --> 0:01:52,176
应该考虑的事情

54
00:01:52,176 --> 0:01:53,996
以便让他们的

55
00:01:53,996 --> 0:01:55,926
框架尽可能的顺畅

56
00:01:58,476 --> 0:02:02,056
XC 框架是一种新的方法

57
00:01:58,476 --> 0:02:02,056
XC 框架是一种新的方法

58
00:02:02,056 --> 0:02:04,186
这个方法可以将

59
00:02:04,186 --> 0:02:06,876
框架的多个变体捆绑在一起

60
00:02:06,876 --> 0:02:08,786
使其能够在以后的

61
00:02:08,786 --> 0:02:09,526
Xcode 版本中工作

62
00:02:10,166 --> 0:02:13,836
单个 XC 框架可以

63
00:02:13,836 --> 0:02:16,776
包含模拟器和设备的变体

64
00:02:17,516 --> 0:02:21,606
[掌声]

65
00:02:22,106 --> 0:02:24,856
还没有结束 因为单个 XC 框架 

66
00:02:24,856 --> 0:02:26,866
也可以包含

67
00:02:26,866 --> 0:02:28,926
Xcode 支持的任何平台的变体

68
00:02:29,516 --> 0:02:33,546
[掌声]

69
00:02:34,046 --> 0:02:35,376
对于使用 AppKit 的 Mac App

70
00:02:35,376 --> 0:02:37,676
你也可以有一个变体

71
00:02:37,676 --> 0:02:38,866
对于使用 UIKit 的 Mac App

72
00:02:38,866 --> 0:02:39,406
你也可以有一个变体

73
00:02:39,806 --> 0:02:41,136
因此无论你的客户端

74
00:02:41,136 --> 0:02:42,986
想要使用哪种 API

75
00:02:42,986 --> 0:02:44,256
他们都能够有效地

76
00:02:44,256 --> 0:02:44,876
使用你的框架

77
00:02:45,406 --> 0:02:48,396
你不仅可以捆绑框架

78
00:02:48,396 --> 0:02:50,556
还可以使用

79
00:02:50,556 --> 0:02:53,656
XC 框架捆绑静态库及其

80
00:02:53,656 --> 0:02:54,746
相应的头文件

81
00:02:54,956 --> 0:02:56,096
Xcode 将自动设置

82
00:02:56,096 --> 0:02:57,806
客户端的搜索板

83
00:02:59,046 --> 0:02:59,936
而且当然 - 

84
00:03:00,516 --> 0:03:03,576
[掌声]

85
00:03:04,076 --> 0:03:05,636
XC 框架支持

86
00:03:05,636 --> 0:03:07,356
基于 Swift 和 C 代码的

87
00:03:07,426 --> 0:03:10,306
二进制分发

88
00:03:10,516 --> 0:03:11,706
现在我想向

89
00:03:11,706 --> 0:03:13,126
你们展示使用

90
00:03:13,126 --> 0:03:14,926
XC 框架是多么容易

91
00:03:17,936 --> 0:03:19,576
这里我有一个

92
00:03:19,606 --> 0:03:20,646
非常简单的 iOS App

93
00:03:20,646 --> 0:03:22,906
我将继续并单击

94
00:03:22,906 --> 0:03:24,916
Run 以在 iPad

95
00:03:24,916 --> 0:03:25,436
模拟器上运行它

96
00:03:25,616 --> 0:03:27,096
你可以看到

97
00:03:27,096 --> 0:03:28,266
它有一个很大的蓝色启动按钮

98
00:03:28,296 --> 0:03:30,336
当你点击它时它什么都不做

99
00:03:30,336 --> 0:03:32,516
这是因为它

100
00:03:32,516 --> 0:03:33,956
连接到这个发射方法

101
00:03:33,956 --> 0:03:36,246
它的主体是空的

102
00:03:37,466 --> 0:03:39,046
我有一个很棒的 XC 框架

103
00:03:39,166 --> 0:03:40,766
我想使用它

104
00:03:40,766 --> 0:03:42,666
它的名字是 FlightKit

105
00:03:44,646 --> 0:03:46,106
FlightKit 给了我

106
00:03:46,306 --> 0:03:47,416
一些我想要在我

107
00:03:47,416 --> 0:03:48,156
App 中呈现的 UI

108
00:03:49,136 --> 0:03:50,706
因此为了能够实际使用

109
00:03:50,736 --> 0:03:52,976
FlightKit XC 框架

110
00:03:52,976 --> 0:03:54,496
我只需单击

111
00:03:54,496 --> 0:03:55,566
项目导航栏中的项目

112
00:03:55,566 --> 0:03:58,396
选择我的 Target

113
00:03:58,396 --> 0:04:00,006
并确保选择了 General 选项卡

114
00:03:58,396 --> 0:04:00,006
并确保选择了 General 选项卡

115
00:04:01,286 --> 0:04:02,576
然后我将向下

116
00:04:02,576 --> 0:04:04,996
滚动到

117
00:04:07,176 --> 0:04:10,916
然后我将只是拖入我的 XC 框架

118
00:04:10,916 --> 0:04:12,276
并且已经自动连接

119
00:04:12,276 --> 0:04:13,766
为我的 Target 的依赖项

120
00:04:15,076 --> 0:04:16,226
让我们回到代码

121
00:04:16,226 --> 0:04:17,486
并开始使用它

122
00:04:18,516 --> 0:04:20,576
就像你已经习惯

123
00:04:20,576 --> 0:04:21,696
使用的任何框架一样

124
00:04:21,875 --> 0:04:23,766
你要做的第一件事就是导入它

125
00:04:25,196 --> 0:04:26,356
现在我想继续

126
00:04:26,356 --> 0:04:27,556
使用 FlightKit

127
00:04:27,556 --> 0:04:28,816
的一些 API

128
00:04:29,366 --> 0:04:30,456
所以要么我可以

129
00:04:30,456 --> 0:04:33,446
去查看文档

130
00:04:33,446 --> 0:04:34,376
要么我可以按住 Command 单击

131
00:04:34,376 --> 0:04:35,546
名称 FlightKit

132
00:04:35,546 --> 0:04:36,166
然后单击 Jump to Definition

133
00:04:37,146 --> 0:04:38,106
这会把我带到为

134
00:04:38,106 --> 0:04:41,156
FlightKit 生成的接口

135
00:04:42,136 --> 0:04:44,146
这显示了所有公共 API

136
00:04:44,146 --> 0:04:47,626
每个公共类型 公共方法

137
00:04:47,626 --> 0:04:49,116
我导入 FlightKit 时可以使用的所有内容

138
00:04:49,856 --> 0:04:52,006
我可以看到

139
00:04:52,126 --> 0:04:53,606
这有一个 LaunchViewController

140
00:04:53,606 --> 0:04:55,116
它是 UIViewController 的子类

141
00:04:55,976 --> 0:04:57,226
这似乎是我可能

142
00:04:57,226 --> 0:04:58,786
希望展示的一小部分 UI

143
00:05:00,026 --> 0:05:02,386
太好了

144
00:05:02,386 --> 0:05:03,406
所以现在我需要知道

145
00:05:03,406 --> 0:05:05,026
如何创建这些

146
00:05:05,026 --> 0:05:06,176
我可以看到在界面

147
00:05:06,176 --> 0:05:07,606
有一个初始化程序

148
00:05:07,606 --> 0:05:08,256
需要构造一个 Spaceship

149
00:05:08,846 --> 0:05:10,216
Spaceship 也是 

150
00:05:10,216 --> 0:05:10,766
FlightKit 的一部分

151
00:05:12,196 --> 0:05:13,666
如果我跳转到它的定义

152
00:05:13,776 --> 0:05:15,106
它将进一步将我

153
00:05:15,106 --> 0:05:16,816
代入到生成的界面中

154
00:05:16,816 --> 0:05:17,946
并向我展示所有我可以

155
00:05:17,946 --> 0:05:19,456
在 Spaceship 中使用的内容

156
00:05:20,006 --> 0:05:23,746
我可以看到

157
00:05:23,746 --> 0:05:26,926
有一个称为 name 的公共存储属性

158
00:05:26,926 --> 0:05:28,396
并且还有一个输入 name 的公共 init 程序

159
00:05:29,836 --> 0:05:31,246
好吧这样我就可以创建

160
00:05:31,246 --> 0:05:32,766
一个太空船

161
00:05:32,766 --> 0:05:34,166
并且我可以创建一个 LaunchViewController

162
00:05:34,166 --> 0:05:34,796
然后我可以呈现它

163
00:05:36,186 --> 0:05:37,396
那么让我们回到代码中

164
00:05:37,396 --> 0:05:38,346
并准确地做到这一点

165
00:05:39,376 --> 0:05:40,576
首先我要创建一个船

166
00:05:41,576 --> 0:05:42,566
我可以看到

167
00:05:42,566 --> 0:05:43,886
自动补全已经向我

168
00:05:43,886 --> 0:05:45,446
暗示了所有在

169
00:05:45,446 --> 0:05:47,326
FlightKit 中的成分

170
00:05:47,326 --> 0:05:48,306
就像你已经习惯

171
00:05:48,306 --> 0:05:49,336
使用的框架一样

172
00:05:50,276 --> 0:05:51,186
我可以接受自动补全

173
00:05:51,186 --> 0:05:53,086
然后我将为我的船

174
00:05:53,086 --> 0:05:53,866
选择一个名字

175
00:05:54,506 --> 0:05:55,456
好吧我已经有了

176
00:05:55,456 --> 0:05:57,066
这一数组的船名

177
00:05:57,066 --> 0:05:58,186
其中任何一个

178
00:05:58,186 --> 0:05:58,696
都将是这艘船的好名字

179
00:05:59,646 --> 0:06:02,896
我将从船名数组中

180
00:05:59,646 --> 0:06:02,896
我将从船名数组中

181
00:06:02,896 --> 0:06:03,716
随机抽取一个元素

182
00:06:04,306 --> 0:06:07,206
现在我将创建

183
00:06:07,206 --> 0:06:10,506
一个 LaunchViewController

184
00:06:10,676 --> 0:06:12,416
并将它传递给我刚刚创建的船

185
00:06:12,956 --> 0:06:15,776
最后并显示

186
00:06:15,776 --> 0:06:18,136
控制器自己作为发送者

187
00:06:18,706 --> 0:06:21,866
在创建了一艘船和一些 UI 之后

188
00:06:21,866 --> 0:06:23,666
我现在将进行展示

189
00:06:24,706 --> 0:06:26,866
我将构建并在模拟器中运行我的程序

190
00:06:26,866 --> 0:06:28,776
当我点击启 Launch 时

191
00:06:28,776 --> 0:06:30,416
它会随机选择一个名字

192
00:06:30,416 --> 0:06:31,466
然后启动 UI

193
00:06:31,466 --> 0:06:34,586
如果我再次点击它

194
00:06:34,586 --> 0:06:37,896
它会选择一个名字和另一个名字 你懂了吧

195
00:06:39,186 --> 0:06:41,636
这就是如何在一个平台上

196
00:06:41,636 --> 0:06:43,136
使用 XC 框架

197
00:06:43,136 --> 0:06:44,436
但 XC 框架的一大优点是

198
00:06:44,546 --> 0:06:47,526
可以将多个变体

199
00:06:47,526 --> 0:06:48,916
放在同一个包中

200
00:06:49,606 --> 0:06:50,996
因此只需将一个

201
00:06:50,996 --> 0:06:52,956
XC 框架拖入其中

202
00:06:52,956 --> 0:06:54,036
我不仅能够为

203
00:06:54,036 --> 0:06:57,196
模拟器构建和运行

204
00:06:57,196 --> 0:07:00,356
而且如果我选择 Generic iOS Device

205
00:06:57,196 --> 0:07:00,356
而且如果我选择 Generic iOS Device

206
00:07:00,356 --> 0:07:02,326
那么我可以转到

207
00:07:02,326 --> 0:07:03,686
Product Archive

208
00:07:03,686 --> 0:07:04,006
并为 App Store 构建存档

209
00:07:04,676 --> 0:07:10,036
从代码中使用 XC 框架

210
00:07:10,036 --> 0:07:11,456
是多么容易啊

211
00:07:12,516 --> 0:07:18,546
[掌声]

212
00:07:19,046 --> 0:07:20,206
因此当你选择

213
00:07:20,206 --> 0:07:23,346
使用框架时

214
00:07:23,386 --> 0:07:24,766
了解你向第三方代码

215
00:07:24,766 --> 0:07:27,046
提供哪些内容非常重要

216
00:07:28,426 --> 0:07:30,196
重要的是

217
00:07:30,196 --> 0:07:33,156
你希望确保信任框架的来源

218
00:07:34,156 --> 0:07:35,226
你相信他们不会

219
00:07:35,226 --> 0:07:36,986
给你的 App 带来漏洞或不稳定

220
00:07:36,986 --> 0:07:38,946
你相信他们

221
00:07:38,946 --> 0:07:40,806
会尊重你用户的隐私

222
00:07:41,346 --> 0:07:44,366
例如如果你

223
00:07:44,366 --> 0:07:47,546
已经为你的 App 授予了权限

224
00:07:47,546 --> 0:07:49,626
并且你使用了一个框架

225
00:07:49,696 --> 0:07:51,276
那么该框架也将被授予这些权限

226
00:07:51,806 --> 0:07:53,416
以及那些许可也是一样

227
00:07:53,416 --> 0:07:54,766
如果你的用户给了许可的话

228
00:07:56,736 --> 0:07:58,716
此外如果你采用的框架

229
00:07:58,716 --> 0:08:00,256
需要某种权限才能使用

230
00:07:58,716 --> 0:08:00,256
需要某种权限才能使用

231
00:08:00,256 --> 0:08:01,246
那么你需要负责

232
00:08:01,246 --> 0:08:06,186
将该权限添加到你的 App 中

233
00:08:07,836 --> 0:08:09,786
关于使用框架

234
00:08:09,786 --> 0:08:11,036
需要考虑的另一件事是

235
00:08:11,586 --> 0:08:12,436
有时你会使用

236
00:08:12,436 --> 0:08:16,466
一个带有自己依赖项的框架

237
00:08:16,466 --> 0:08:20,396
这些依赖项可能也有自己的依赖项

238
00:08:20,396 --> 0:08:21,966
你不仅有义务要

239
00:08:21,966 --> 0:08:23,276
将所有这些添加到项目中

240
00:08:23,966 --> 0:08:25,836
还要对它们每个部分

241
00:08:25,836 --> 0:08:27,966
扩展同样的信任

242
00:08:27,966 --> 0:08:30,896
现在值得注意的是

243
00:08:30,966 --> 0:08:34,086
这种信任也扩展到了

244
00:08:34,086 --> 0:08:35,186
使用 Swift 包

245
00:08:36,126 --> 0:08:38,525
包相对于二进制框架的一个优点是

246
00:08:38,525 --> 0:08:40,116
你可以检查代码

247
00:08:40,116 --> 0:08:41,676
并且可以在调试时深入查看

248
00:08:42,285 --> 0:08:43,716
如果你想了解

249
00:08:43,716 --> 0:08:45,006
更多关于在 Xcode

250
00:08:45,046 --> 0:08:47,066
中使用 Swift 包的信息

251
00:08:47,066 --> 0:08:48,066
我向你推荐本周早些时候的会议

252
00:08:48,666 --> 0:08:52,126
但无论你使用的

253
00:08:52,126 --> 0:08:54,096
是包还是二进制框架

254
00:08:54,516 --> 0:08:56,606
Xcode 11 都可以让你

255
00:08:56,606 --> 0:09:00,686
轻松使用你信任的第三方代码

256
00:08:56,606 --> 0:09:00,686
轻松使用你信任的第三方代码

257
00:09:02,206 --> 0:09:03,846
现在我想谈谈

258
00:09:03,846 --> 0:09:05,706
如何创建一个 XC 框架

259
00:09:06,846 --> 0:09:08,226
你要做的第一件事

260
00:09:08,226 --> 0:09:10,086
就是有一些你

261
00:09:10,086 --> 0:09:11,386
想要发布的源代码

262
00:09:11,386 --> 0:09:14,196
让我们来看一下

263
00:09:14,196 --> 0:09:16,826
早前 FlightKit 的一些源代码

264
00:09:18,056 --> 0:09:21,666
这只是 FlightKit 中对象的子集 仅仅用来举例

265
00:09:22,346 --> 0:09:24,886
但是你可以

266
00:09:24,916 --> 0:09:26,686
看到我们之前看过的 Spaceship 类型

267
00:09:28,136 --> 0:09:29,806
你还可以看到

268
00:09:29,806 --> 0:09:31,606
一个名为 Speed 的枚举

269
00:09:31,606 --> 0:09:32,716
它描述了事物在太空中移动的速度

270
00:09:34,066 --> 0:09:35,296
你还会看到一个名为

271
00:09:35,296 --> 0:09:36,926
Location 的结构体

272
00:09:36,926 --> 0:09:38,676
用于描述对象在空间中的位置

273
00:09:40,156 --> 0:09:42,566
太好了 我们有这个代码

274
00:09:43,196 --> 0:09:44,336
现在我们将如何确保

275
00:09:44,336 --> 0:09:45,736
我们构建此库

276
00:09:45,736 --> 0:09:46,496
是用于分发？

277
00:09:47,446 --> 0:09:49,436
在 Xcode 11 中

278
00:09:49,436 --> 0:09:51,046
有一个新的构建设置

279
00:09:51,046 --> 0:09:52,576
称为 Build Libraries for Distribution

280
00:09:53,556 --> 0:09:54,786
它做的确实是这件事

281
00:09:54,966 --> 0:09:58,116
它开启了所有构建库所需的特性

282
00:09:58,116 --> 0:10:00,496
以便以一种可分发的方式构建库

283
00:09:58,116 --> 0:10:00,496
以便以一种可分发的方式构建库

284
00:10:02,046 --> 0:10:04,166
现在我们来谈谈

285
00:10:04,166 --> 0:10:05,386
其中一个特性

286
00:10:06,906 --> 0:10:08,536
如果你以前尝试过

287
00:10:08,756 --> 0:10:10,586
向某人发送已构建的 Swift 框架

288
00:10:11,286 --> 0:10:13,536
那么你可能已经看到了这种错误的变体

289
00:10:14,956 --> 0:10:17,126
已编译模块是由

290
00:10:17,126 --> 0:10:18,446
较新版本的编译器创建的

291
00:10:18,986 --> 0:10:21,976
这个错误到底意味着什么

292
00:10:23,506 --> 0:10:24,626
当 Swift 编译器

293
00:10:24,626 --> 0:10:26,656
导入一个模块时

294
00:10:26,656 --> 0:10:27,956
它会为这个库

295
00:10:27,956 --> 0:10:30,156
查找一个名为 Compiled Module 的文件

296
00:10:31,676 --> 0:10:33,286
如果找到其中一个文件

297
00:10:33,646 --> 0:10:35,206
它将读取可以调用的

298
00:10:35,246 --> 0:10:36,946
公共 API 的 Manifest

299
00:10:36,946 --> 0:10:39,996
并让你使用它们

300
00:10:40,326 --> 0:10:45,746
现在这个已编译模块格式是二进制格式

301
00:10:45,746 --> 0:10:47,876
基本上包含

302
00:10:47,876 --> 0:10:49,236
内部编译器数据结构

303
00:10:50,096 --> 0:10:52,996
由于它们只是内部数据结构

304
00:10:52,996 --> 0:10:55,116
所以随着 Swift 编译器的每个版本

305
00:10:55,116 --> 0:10:58,986
它们都可能发生变化 这意味着

306
00:10:59,216 --> 0:11:00,756
如果一个人试图

307
00:10:59,216 --> 0:11:00,756
如果一个人试图

308
00:11:00,756 --> 0:11:02,566
用一个版本的 Swift 

309
00:11:02,566 --> 0:11:04,436
导入一个模块

310
00:11:04,496 --> 0:11:05,596
而这个模块是由

311
00:11:05,596 --> 0:11:07,666
另一个版本的 Swift 创建的

312
00:11:07,666 --> 0:11:08,806
他们的编译器将无法理解这个模块

313
00:11:08,806 --> 0:11:10,126
他们也无法使用这个模块

314
00:11:11,176 --> 0:11:13,516
为了解决

315
00:11:13,516 --> 0:11:16,406
这个版本锁定问题

316
00:11:16,406 --> 0:11:17,916
Xcode 11 为 Swift 模块

317
00:11:17,916 --> 0:11:19,586
引入了一种新的格式

318
00:11:19,586 --> 0:11:20,746
称为 Swift 模块接口

319
00:11:21,886 --> 0:11:23,186
就像已编译模块格式一样

320
00:11:23,186 --> 0:11:27,756
它们列出了模块的所有公共 API

321
00:11:27,756 --> 0:11:29,956
但使用的是

322
00:11:29,956 --> 0:11:30,966
更像源代码的文本形式

323
00:11:32,086 --> 0:11:33,356
由于它们的行为

324
00:11:33,356 --> 0:11:35,546
类似于源代码

325
00:11:35,546 --> 0:11:37,006
那么 Swift 编译器的未来版本

326
00:11:37,436 --> 0:11:39,026
将能够导入

327
00:11:39,026 --> 0:11:41,066
使用旧版本创建的模块接口

328
00:11:41,716 --> 0:11:46,696
当你启用 Build Libraries for Distribution 时

329
00:11:47,416 --> 0:11:48,606
你是在告诉编译器

330
00:11:48,606 --> 0:11:50,076
在编译器构建框架时

331
00:11:50,076 --> 0:11:52,926
去生成一个稳定的接口

332
00:11:53,606 --> 0:11:57,406
那么这些接口

333
00:11:57,406 --> 0:11:58,836
实际上是什么样的呢？

334
00:11:59,586 --> 0:12:01,176
让我们再次看看

335
00:11:59,586 --> 0:12:01,176
让我们再次看看

336
00:12:01,176 --> 0:12:02,566
FlightKit 的源代码

337
00:12:03,716 --> 0:12:05,326
这就是来自 FlightKit 的源代码

338
00:12:05,326 --> 0:12:08,116
在右侧你将

339
00:12:08,116 --> 0:12:09,606
看到 FlightKit 的模块接口

340
00:12:10,286 --> 0:12:11,546
现在这有点多

341
00:12:11,546 --> 0:12:12,816
而且它从屏幕上消失了

342
00:12:12,816 --> 0:12:15,206
所以我们要一块一块地看

343
00:12:15,416 --> 0:12:17,916
首先你会看到这部分元数据

344
00:12:18,826 --> 0:12:22,116
这包括生成这个接口的编译器版本

345
00:12:22,116 --> 0:12:24,276
但它也包含

346
00:12:24,306 --> 0:12:26,026
命令行标记的子集

347
00:12:26,316 --> 0:12:27,696
Swift 编译器需要

348
00:12:27,696 --> 0:12:29,256
将其作为模块导入

349
00:12:32,156 --> 0:12:34,636
接下来你将看到

350
00:12:34,636 --> 0:12:36,986
这个框架导入的所有模块

351
00:12:37,836 --> 0:12:39,306
然后我们将开始

352
00:12:39,306 --> 0:12:41,096
查看作为该接口一部分的一些类型

353
00:12:42,356 --> 0:12:44,846
这是 Spaceship 类的公共 API

354
00:12:44,976 --> 0:12:46,926
现在我希望

355
00:12:46,926 --> 0:12:48,126
你注意到这三件事

356
00:12:48,766 --> 0:12:50,516
第一

357
00:12:50,516 --> 0:12:52,706
公共 name 属性

358
00:12:52,706 --> 0:12:54,806
包含在接口中

359
00:12:54,806 --> 0:12:56,706
但是私有 currentLocation 属性不包含

360
00:12:57,896 --> 0:13:00,686
它不是公共 API 的一部分

361
00:12:57,896 --> 0:13:00,686
它不是公共 API 的一部分

362
00:13:01,426 --> 0:13:04,176
接下来

363
00:13:04,216 --> 0:13:06,356
请注意接口中包含了公共初始化器

364
00:13:06,496 --> 0:13:07,876
和 fly 方法

365
00:13:09,006 --> 0:13:10,796
但是它们的主体

366
00:13:10,796 --> 0:13:11,986
没有被包括进去

367
00:13:11,986 --> 0:13:14,116
同样也是因为它们不是公共 API 的一部分

368
00:13:15,276 --> 0:13:16,656
最后请注意

369
00:13:16,656 --> 0:13:18,596
该类在接口中

370
00:13:18,596 --> 0:13:20,286
有一个取消初始化程序

371
00:13:20,286 --> 0:13:21,416
但是在原始源代码中

372
00:13:21,416 --> 0:13:22,626
却没有进行写入

373
00:13:23,186 --> 0:13:27,676
现在当你在 Swift 中编写类

374
00:13:27,676 --> 0:13:29,456
并且没有提供显式取消初始化程序时

375
00:13:29,456 --> 0:13:31,086
编译器将为你生成一个

376
00:13:31,616 --> 0:13:35,666
这强调了模块接口

377
00:13:35,666 --> 0:13:36,606
的一个基本原则

378
00:13:37,146 --> 0:13:38,416
如果这种格式

379
00:13:38,416 --> 0:13:42,156
在编译器的不同版本之间

380
00:13:42,156 --> 0:13:43,976
应该是稳定的

381
00:13:44,196 --> 0:13:45,886
那么编译器不应该对底层源代码做任何假设

382
00:13:46,786 --> 0:13:48,926
因此我们将其包含在模块接口中

383
00:13:49,506 --> 0:13:53,516
接下来让我们看一下 Speed 枚举

384
00:13:54,466 --> 0:13:55,666
首先要看到的是

385
00:13:55,666 --> 0:13:58,316
两个枚举都被包含了

386
00:13:58,506 --> 0:14:02,086
这些是公共 API 的一部分

387
00:13:58,506 --> 0:14:02,086
这些是公共 API 的一部分

388
00:14:02,086 --> 0:14:03,956
然而在接口中

389
00:14:03,956 --> 0:14:06,316
对于哈希需要明确的遵守

390
00:14:07,116 --> 0:14:08,876
我们列出了

391
00:14:08,876 --> 0:14:11,476
遵循哈希和相等

392
00:14:11,476 --> 0:14:12,566
所需的方法

393
00:14:13,396 --> 0:14:14,846
这是因为在 Swift 中

394
00:14:15,146 --> 0:14:16,666
如果你生成了一个

395
00:14:16,666 --> 0:14:19,496
没有任何关联值的枚举

396
00:14:19,496 --> 0:14:22,626
那么编译器就会隐式地

397
00:14:22,626 --> 0:14:24,546
使其符合哈希和相等

398
00:14:24,546 --> 0:14:26,276
并自动派生出所需的方法

399
00:14:26,916 --> 0:14:29,306
因此本着明确的精神

400
00:14:29,306 --> 0:14:32,576
它被包含在模块接口中

401
00:14:33,956 --> 0:14:36,476
最后 Location 结构体

402
00:14:36,656 --> 0:14:38,746
以现在方式包含在内

403
00:14:38,746 --> 0:14:39,876
因为它只有

404
00:14:39,876 --> 0:14:41,626
公共存储的属性

405
00:14:41,626 --> 0:14:42,696
并且不声明任何遵循

406
00:14:43,326 --> 0:14:46,976
以上就是 FlightKit 的模块接口

407
00:14:51,496 --> 0:14:54,966
现在你已经了解了框架内部的内容

408
00:14:54,966 --> 0:14:56,296
接下来让我们

409
00:14:56,336 --> 0:14:58,766
讨论如何自己构建一个

410
00:14:58,766 --> 0:14:59,156
可分发的二进制 XC 框架

411
00:14:59,746 --> 0:15:03,936
构建框架的第一步

412
00:14:59,746 --> 0:15:03,936
构建框架的第一步

413
00:15:03,936 --> 0:15:04,406
是构建存档

414
00:15:05,326 --> 0:15:06,626
归档你的框架

415
00:15:06,626 --> 0:15:08,656
将在发布模式下构建它

416
00:15:08,656 --> 0:15:09,576
并将其打包以进行分发

417
00:15:09,576 --> 0:15:12,716
你可以在管理器窗口中看到它

418
00:15:13,746 --> 0:15:15,636
此外作为附加优势

419
00:15:15,686 --> 0:15:17,376
此存档还将包含

420
00:15:17,376 --> 0:15:18,776
与框架的该版本

421
00:15:18,776 --> 0:15:20,196
对应的调试信息

422
00:15:20,196 --> 0:15:21,906
这意味着

423
00:15:21,906 --> 0:15:23,776
如果客户端有任何崩溃

424
00:15:26,526 --> 0:15:27,936
他们将能够将其

425
00:15:27,936 --> 0:15:29,056
发送给你

426
00:15:29,146 --> 0:15:31,606
而你将能够查看符号并调试它

427
00:15:32,336 --> 0:15:34,626
要存档框架

428
00:15:34,626 --> 0:15:36,776
你可以使用 xcodebuild 存档命令

429
00:15:37,836 --> 0:15:39,166
你将输入项目中

430
00:15:39,166 --> 0:15:40,596
框架的 scheme

431
00:15:41,606 --> 0:15:44,406
并列出要为其编译的目标

432
00:15:45,186 --> 0:15:46,606
因此如果你正在为 iOS 构建

433
00:15:46,976 --> 0:15:47,836
可以是一个用于模拟器

434
00:15:47,836 --> 0:15:49,676
一个用于设备以及

435
00:15:50,266 --> 0:15:52,216
一个用于运行 UIKit 的 Mac

436
00:15:52,836 --> 0:15:55,486
你还需要通过

437
00:15:55,486 --> 0:15:57,416
Skip Install 生成设置

438
00:15:57,416 --> 0:15:58,276
并将其设置为 No

439
00:15:59,096 --> 0:16:01,316
这告诉 xcodebuild 存档

440
00:15:59,096 --> 0:16:01,316
这告诉 xcodebuild 存档

441
00:16:01,316 --> 0:16:04,286
在生成的存档中安装框架

442
00:16:04,926 --> 0:16:09,276
因此通过执行此操作

443
00:16:09,276 --> 0:16:11,636
你将构建框架的

444
00:16:11,636 --> 0:16:13,666
每个变体的存档

445
00:16:13,666 --> 0:16:15,056
这些存档

446
00:16:15,056 --> 0:16:17,186
将在 Preference 窗口中的

447
00:16:17,186 --> 0:16:20,096
Location 选项卡中的 Archive 目录可用

448
00:16:20,606 --> 0:16:24,186
构建这些存档后

449
00:16:24,186 --> 0:16:25,966
你可以提取框架

450
00:16:25,966 --> 0:16:27,456
并将它们捆绑在

451
00:16:27,456 --> 0:16:29,546
一个 XC 框架中

452
00:16:30,056 --> 0:16:32,486
为此你将运行 

453
00:16:32,486 --> 0:16:35,366
xcodebuild -create-xcframework 命令

454
00:16:36,456 --> 0:16:40,186
你将输入磁盘上每个框架的路径

455
00:16:40,186 --> 0:16:41,956
然后提供你希望

456
00:16:42,006 --> 0:16:46,456
输出 XC 框架输出到的路径

457
00:16:46,696 --> 0:16:49,526
以上就是如何构建 XC 框架

458
00:16:49,526 --> 0:16:51,946
总而言之请记住

459
00:16:51,946 --> 0:16:53,916
你需要启用

460
00:16:53,916 --> 0:16:55,626
Build Libraries for Distribution

461
00:16:55,626 --> 0:16:57,356
以确保你的库是为了分发而构建的

462
00:16:57,436 --> 0:17:00,996
你将运行 xcodebuild 归档

463
00:16:57,436 --> 0:17:00,996
你将运行 xcodebuild 归档

464
00:17:01,536 --> 0:17:02,536
以构建框架的归档

465
00:17:02,536 --> 0:17:05,576
最后运行 

466
00:17:05,576 --> 0:17:06,536
xcodebuild -create-xcframework

467
00:17:06,566 --> 0:17:10,705
将其打包以便分发

468
00:17:11,146 --> 0:17:12,165
然后你可以开始

469
00:17:12,165 --> 0:17:13,205
将其发送给你的客户

470
00:17:13,205 --> 0:17:14,586
然后他们可以开始采用它

471
00:17:15,195 --> 0:17:16,925
这就是 XC 框架

472
00:17:18,326 --> 0:17:19,846
现在我的同事 Jordan 

473
00:17:19,846 --> 0:17:21,026
将向你介绍作为一个框架作者

474
00:17:21,026 --> 0:17:22,656
你应该考虑哪些内容

475
00:17:22,656 --> 0:17:26,185
以使你的框架尽可能

476
00:17:26,185 --> 0:17:26,685
顺畅地使用

477
00:17:28,516 --> 0:17:34,546
[掌声和欢呼]

478
00:17:35,046 --> 0:17:35,736
&gt;&gt; 谢谢 Harlan

479
00:17:36,006 --> 0:17:38,086
好的 我们看到

480
00:17:38,376 --> 0:17:39,876
将这些 XC 框架中的一个

481
00:17:40,066 --> 0:17:42,256
引入作为框架客户端的 App

482
00:17:42,256 --> 0:17:43,906
是多么容易

483
00:17:43,906 --> 0:17:45,556
我们看到了生成

484
00:17:45,586 --> 0:17:46,276
XC 框架所需的步骤

485
00:17:47,016 --> 0:17:48,316
但这只是第一步

486
00:17:48,576 --> 0:17:49,476
因为你是框架作者

487
00:17:49,476 --> 0:17:53,326
并且你每年都在开发新功能

488
00:17:53,326 --> 0:17:55,446
并为客户端做得更好

489
00:17:56,236 --> 0:17:57,296
因此在这一节中

490
00:17:57,296 --> 0:17:58,926
我将讨论

491
00:17:58,926 --> 0:17:59,456
三件主要的事情

492
00:18:00,386 --> 0:18:01,556
从不断的发布中

493
00:18:01,556 --> 0:18:02,556
逐步发展你的框架

494
00:18:03,366 --> 0:18:05,936
利用 Swift 提供的一些灵活性

495
00:18:05,936 --> 0:18:07,546
来优化客户端

496
00:18:08,296 --> 0:18:09,536
并帮助客户端

497
00:18:09,536 --> 0:18:10,606
获得尽可能

498
00:18:10,606 --> 0:18:11,196
平稳流畅的体验

499
00:18:11,736 --> 0:18:14,596
因此请从发展你的框架开始

500
00:18:15,196 --> 0:18:17,186
当我说要发展你的框架时

501
00:18:17,186 --> 0:18:18,456
我是什么意思呢

502
00:18:19,496 --> 0:18:22,966
好吧就像我说的

503
00:18:22,966 --> 0:18:24,366
每次你发布新版本的框架时

504
00:18:24,366 --> 0:18:25,736
它都会有新的功能

505
00:18:25,736 --> 0:18:27,746
新的 API

506
00:18:27,746 --> 0:18:29,936
可能还有一些漏洞修复

507
00:18:29,936 --> 0:18:31,866
我们希望能够

508
00:18:31,866 --> 0:18:33,736
在不破坏源代码

509
00:18:33,736 --> 0:18:34,726
或二进制兼容性的情况下做到这一点

510
00:18:35,586 --> 0:18:37,776
那么为什么二进制兼容性

511
00:18:37,776 --> 0:18:38,686
在这里很重要呢

512
00:18:39,876 --> 0:18:41,156
这是因为你

513
00:18:41,156 --> 0:18:42,766
不一定知道

514
00:18:42,766 --> 0:18:44,256
你的客户是谁

515
00:18:44,746 --> 0:18:47,266
很多时候它只是一个 App Target

516
00:18:47,576 --> 0:18:48,526
它们会使用你的框架

517
00:18:48,766 --> 0:18:50,956
打包然后送到商店

518
00:18:52,246 --> 0:18:53,806
但有时你的客户

519
00:18:53,836 --> 0:18:55,396
本身就是二进制框架

520
00:18:55,476 --> 0:18:57,246
要么来自你的公司

521
00:18:57,246 --> 0:18:59,846
要么完全来自另一家公司

522
00:18:59,896 --> 0:19:02,756
在这种情况下

523
00:18:59,896 --> 0:19:02,756
在这种情况下

524
00:19:02,836 --> 0:19:04,396
你们两个可能

525
00:19:04,396 --> 0:19:04,926
有不同的发布时间表

526
00:19:05,576 --> 0:19:06,596
他们可能会

527
00:19:06,596 --> 0:19:08,896
一直升级到 2.1 版

528
00:19:08,896 --> 0:19:10,816
而你还在开发最新的版本

529
00:19:10,816 --> 0:19:16,246
当你最终发布 1.1 版本时

530
00:19:16,246 --> 0:19:17,566
他们不应该再为采用它

531
00:19:17,566 --> 0:19:18,636
而付出任何额外的努力

532
00:19:19,116 --> 0:19:19,906
你不希望陷入

533
00:19:19,906 --> 0:19:21,946
两个二进制框架

534
00:19:21,946 --> 0:19:23,436
彼此版本锁定的情况

535
00:19:23,436 --> 0:19:26,506
因为使用它们的 App 可能

536
00:19:26,506 --> 0:19:30,766
决定不更新

537
00:19:30,976 --> 0:19:32,266
所以我在这里说

538
00:19:32,266 --> 0:19:33,426
你的框架版本很重要

539
00:19:33,426 --> 0:19:35,366
你不仅想

540
00:19:35,366 --> 0:19:38,556
把它放在你的网站和你的文档上

541
00:19:38,806 --> 0:19:40,066
而且你还应该

542
00:19:40,066 --> 0:19:41,686
把它放在框架本身里

543
00:19:41,686 --> 0:19:43,736
并且能这样做的地方是

544
00:19:43,736 --> 0:19:45,426
框架的 Info.plist 中的

545
00:19:45,426 --> 0:19:46,636
Bundle 版本字符串设置

546
00:19:47,486 --> 0:19:49,326
这是人类可读版本号

547
00:19:49,326 --> 0:19:52,886
你可以在这里与客户交流

548
00:19:52,886 --> 0:19:55,396
自上次发布以来所做的更改

549
00:19:55,986 --> 0:19:58,576
我们推荐的方法

550
00:19:58,576 --> 0:20:00,966
是使用语义版本控制

551
00:19:58,576 --> 0:20:00,966
是使用语义版本控制

552
00:20:01,616 --> 0:20:02,416
如果你之前

553
00:20:02,416 --> 0:20:04,156
没参加包讨论的话

554
00:20:04,246 --> 0:20:05,446
我现在将快速回顾一下

555
00:20:05,446 --> 0:20:06,866
什么是语义版本控制

556
00:20:07,676 --> 0:20:09,326
最小的组成部分是

557
00:20:09,326 --> 0:20:11,306
补丁版本

558
00:20:11,456 --> 0:20:12,856
它表示何时对框架进行漏洞修复

559
00:20:12,856 --> 0:20:14,156
或实现更改

560
00:20:14,156 --> 0:20:15,886
而这些更改

561
00:20:15,886 --> 0:20:17,266
不应该影响客户

562
00:20:18,076 --> 0:20:20,216
中间组成部分用于

563
00:20:20,416 --> 0:20:22,106
向后兼容的版本

564
00:20:22,466 --> 0:20:24,746
新 API 或新功能

565
00:20:25,386 --> 0:20:28,796
而主要的组成部分

566
00:20:28,796 --> 0:20:30,416
是你必须做的

567
00:20:30,416 --> 0:20:32,356
任何中断更改

568
00:20:32,436 --> 0:20:34,486
不管是源代码中断

569
00:20:34,486 --> 0:20:37,016
二进制中断

570
00:20:37,506 --> 0:20:38,986
还是语义中断

571
00:20:39,046 --> 0:20:41,916
在某种程度上

572
00:20:41,916 --> 0:20:43,606
客户将不得不重新构建

573
00:20:43,606 --> 0:20:45,216
甚至可能重做一些客户端代码

574
00:20:45,216 --> 0:20:46,156
以采用新版本的框架

575
00:20:46,586 --> 0:20:49,036
让我们看一下 

576
00:20:49,036 --> 0:20:50,746
FlightKit 模型对象

577
00:20:50,746 --> 0:20:51,676
在实践中的效果

578
00:20:52,586 --> 0:20:53,826
所以左边的情况

579
00:20:53,826 --> 0:20:56,096
与我们之前的情况相同

580
00:20:57,366 --> 0:20:59,136
现在在右边

581
00:20:59,136 --> 0:21:00,946
我对这个框架进行了一系列更改

582
00:20:59,136 --> 0:21:00,946
我对这个框架进行了一系列更改

583
00:21:02,096 --> 0:21:03,406
让我们逐个讨论它们

584
00:21:03,476 --> 0:21:06,526
看看每个更改如何影响

585
00:21:06,526 --> 0:21:07,246
框架的版本号

586
00:21:08,506 --> 0:21:09,446
我们将从顶部开始

587
00:21:10,466 --> 0:21:12,286
我已经为 Spaceship 船类

588
00:21:12,286 --> 0:21:13,896
添加了一个新的私有属性

589
00:21:14,396 --> 0:21:15,966
而我正在 Spaceship 的

590
00:21:15,966 --> 0:21:17,226
初始化器中使用它

591
00:21:18,556 --> 0:21:20,996
目前这些东西

592
00:21:20,996 --> 0:21:22,506
都不会出现

593
00:21:22,506 --> 0:21:23,156
在模块界面中

594
00:21:23,466 --> 0:21:24,446
它们并不是你框架

595
00:21:24,446 --> 0:21:25,696
的公共 API 的一部分

596
00:21:26,976 --> 0:21:28,796
因此这种更改

597
00:21:28,796 --> 0:21:30,556
只需要更新次要部分

598
00:21:30,556 --> 0:21:32,116
或补丁版本部分

599
00:21:33,916 --> 0:21:36,086
请记住

600
00:21:36,146 --> 0:21:37,786
虽然我确实改变了

601
00:21:37,786 --> 0:21:39,776
初始化程序的行为

602
00:21:39,776 --> 0:21:42,536
如果之前记录了这种行为

603
00:21:42,536 --> 0:21:43,806
那么这将是

604
00:21:43,856 --> 0:21:45,826
一个语义突破的变化

605
00:21:45,826 --> 0:21:48,866
客户必须考虑是否更新

606
00:21:48,866 --> 0:21:50,386
因此我应该

607
00:21:50,386 --> 0:21:51,356
更改主版本号

608
00:21:51,986 --> 0:21:55,206
现在我在这里

609
00:21:55,206 --> 0:21:57,376
做的下一个更改

610
00:21:57,376 --> 0:21:58,496
是向 Spaceship 类添加一个新方法

611
00:21:58,796 --> 0:22:00,616
这是一个新的公共方法

612
00:21:58,796 --> 0:22:00,616
这是一个新的公共方法

613
00:22:00,616 --> 0:22:01,926
这意味着客户

614
00:22:01,926 --> 0:22:02,886
将开始使用它并依赖它

615
00:22:03,846 --> 0:22:05,566
因此正确的做法

616
00:22:05,566 --> 0:22:07,636
是增加次要版本号

617
00:22:08,146 --> 0:22:09,676
你会注意到

618
00:22:09,676 --> 0:22:13,846
我还将补丁版本重置为零

619
00:22:13,966 --> 0:22:16,516
最后我还在 fly 方法

620
00:22:16,516 --> 0:22:18,406
中添加了一个新参数

621
00:22:19,356 --> 0:22:21,486
我已经给了它一个默认值

622
00:22:21,486 --> 0:22:23,536
这样大多数的使用站点

623
00:22:23,586 --> 0:22:24,206
就不必更改了

624
00:22:24,986 --> 0:22:27,126
但在 Swift 中

625
00:22:27,126 --> 0:22:29,686
函数的名称和参数

626
00:22:30,216 --> 0:22:31,466
是唯一标识的

627
00:22:31,466 --> 0:22:33,616
参数标签和类型

628
00:22:34,286 --> 0:22:36,626
所以这里我已经破坏了

629
00:22:36,966 --> 0:22:39,726
源代码和二进制兼容性

630
00:22:39,726 --> 0:22:41,706
所以这需要

631
00:22:41,706 --> 0:22:43,636
更新主版本号

632
00:22:43,636 --> 0:22:44,926
并要求任何客户端重新编译

633
00:22:45,616 --> 0:22:46,696
也许我应该

634
00:22:46,696 --> 0:22:47,686
做一个新的过载

635
00:22:48,286 --> 0:22:51,426
现在这些都是

636
00:22:51,426 --> 0:22:52,856
对 Spaceship 类的更改

637
00:22:52,856 --> 0:22:54,266
但我也更改了

638
00:22:54,266 --> 0:22:55,796
FlightKit 中的一些值类型

639
00:22:55,796 --> 0:22:58,786
我在 Speed 枚举中添加了一个新案例

640
00:23:00,256 --> 0:23:02,516
我已经使 Loacation 变得可哈希

641
00:23:02,516 --> 0:23:03,836
这样客户端就可以拥有它们的集合

642
00:23:03,836 --> 0:23:06,436
这是我最喜欢的更改

643
00:23:06,436 --> 0:23:08,726
我在不破坏源代码

644
00:23:08,726 --> 0:23:10,626
或二进制兼容性的情况下

645
00:23:10,896 --> 0:23:12,516
向 Location 结构添加了

646
00:23:12,516 --> 0:23:13,816
一个新的存储属性

647
00:23:14,516 --> 0:23:19,546
[掌声]

648
00:23:20,046 --> 0:23:21,706
现在在 Swift 中

649
00:23:21,706 --> 0:23:23,126
所有这些更改

650
00:23:23,166 --> 0:23:24,866
都是向后兼容的

651
00:23:24,866 --> 0:23:26,606
所以我只需要修改次要版本号

652
00:23:27,186 --> 0:23:30,266
现在这种灵活性

653
00:23:30,266 --> 0:23:31,866
对如何设计框架的

654
00:23:31,866 --> 0:23:33,906
API 有一些影响

655
00:23:34,616 --> 0:23:36,426
最重要的是

656
00:23:36,426 --> 0:23:37,536
从小处着手

657
00:23:38,086 --> 0:23:39,436
如果你发现

658
00:23:39,436 --> 0:23:41,026
你需要新功能

659
00:23:41,026 --> 0:23:42,736
或者你的客户文件

660
00:23:42,736 --> 0:23:44,896
反馈说需要更多的功能

661
00:23:44,896 --> 0:23:46,526
那么添加新功能是很容易的

662
00:23:47,086 --> 0:23:48,576
但是很难

663
00:23:48,626 --> 0:23:50,296
删除某些东西

664
00:23:50,296 --> 0:23:51,946
因为它很可能会破坏

665
00:23:51,946 --> 0:23:53,816
至少一个客户的源代码

666
00:23:53,816 --> 0:23:55,326
或二进制兼容性

667
00:23:56,316 --> 0:23:57,866
对于那些你在事后

668
00:23:57,866 --> 0:23:59,016
无法更改的东西

669
00:23:59,526 --> 0:24:00,906
比如你的类型的名称

670
00:23:59,526 --> 0:24:00,906
比如你的类型的名称

671
00:24:01,276 --> 0:24:02,366
请确保你

672
00:24:02,366 --> 0:24:04,136
预先仔细考虑过它们

673
00:24:04,136 --> 0:24:05,286
这些名称不仅在

674
00:24:05,286 --> 0:24:07,666
这个版本中有意义

675
00:24:07,666 --> 0:24:09,076
而且在所有将来的版本中都有意义

676
00:24:09,616 --> 0:24:13,386
最后不要过早地

677
00:24:13,386 --> 0:24:15,026
添加可扩展性

678
00:24:15,606 --> 0:24:16,556
你不需要在框架的

679
00:24:16,556 --> 0:24:18,406
第一个版本中

680
00:24:18,406 --> 0:24:20,476
将类设为开放

681
00:24:20,476 --> 0:24:21,756
提供任意的回调

682
00:24:22,666 --> 0:24:23,706
为什么这很重要

683
00:24:24,386 --> 0:24:25,806
因为当你必须

684
00:24:25,876 --> 0:24:27,926
考虑客户可能

685
00:24:27,996 --> 0:24:29,986
同时在做什么时

686
00:24:29,986 --> 0:24:31,526
对框架行为的推理

687
00:24:31,526 --> 0:24:32,516
会变得更加困难

688
00:24:33,666 --> 0:24:35,776
你总是可以在

689
00:24:35,776 --> 0:24:37,226
将来开放类

690
00:24:37,826 --> 0:24:39,196
你总是可以添加

691
00:24:39,196 --> 0:24:40,146
表示额外回调的属性

692
00:24:40,146 --> 0:24:42,696
但在默认情况下

693
00:24:42,696 --> 0:24:44,396
不能删除

694
00:24:44,396 --> 0:24:45,036
所添加的灵活性

695
00:24:45,706 --> 0:24:49,336
那么这一切是如何运作的呢

696
00:24:50,546 --> 0:24:53,906
间接 这仅仅只是一个单词而已

697
00:24:53,906 --> 0:24:55,226
让我们现在来看一个例子

698
00:24:55,356 --> 0:24:58,166
在左边这里

699
00:24:58,446 --> 0:24:59,796
我有 Spaceship 类

700
00:24:59,796 --> 0:25:03,206
这次剥离到它的模块接口

701
00:24:59,796 --> 0:25:03,206
这次剥离到它的模块接口

702
00:25:03,206 --> 0:25:04,806
在右边我使用了 fly 方法

703
00:25:06,106 --> 0:25:07,396
这是来自 FlightKit 

704
00:25:07,516 --> 0:25:09,456
框架外部的客户代码

705
00:25:10,536 --> 0:25:11,936
运行时

706
00:25:11,936 --> 0:25:13,616
客户端会问

707
00:25:13,616 --> 0:25:15,526
哪个方法

708
00:25:15,526 --> 0:25:17,266
是 fly 方法

709
00:25:17,786 --> 0:25:20,176
框架会回应

710
00:25:20,756 --> 0:25:22,326
是第二个

711
00:25:23,076 --> 0:25:25,556
这就是 Swift 

712
00:25:25,556 --> 0:25:27,766
确保二进制兼容性的方式

713
00:25:27,766 --> 0:25:28,866
即使在向类添加新方法时也是如此

714
00:25:30,156 --> 0:25:31,826
它基本上

715
00:25:32,026 --> 0:25:33,526
与 Objective-C

716
00:25:33,566 --> 0:25:35,776
进行消息调度的方式相同

717
00:25:36,046 --> 0:25:40,156
在从一个库到另一个库的调用中执行它

718
00:25:40,196 --> 0:25:43,766
但 Swift 仅在你跨越此客户框架边界时执行此操作

719
00:25:45,716 --> 0:25:46,876
还有另一种

720
00:25:46,876 --> 0:25:48,396
间接的形式

721
00:25:48,796 --> 0:25:51,786
当客户使用框架中

722
00:25:52,086 --> 0:25:53,466
定义的结构体或枚举时

723
00:25:54,536 --> 0:25:55,826
在本例中

724
00:25:55,826 --> 0:25:57,906
fly 方法的一个参数

725
00:25:57,906 --> 0:26:00,546
是来自 speed 枚举的 fast case

726
00:25:57,906 --> 0:26:00,546
是来自 speed 枚举的 fast case

727
00:26:01,176 --> 0:26:03,506
我之前说过

728
00:26:03,506 --> 0:26:05,046
枚举可以在

729
00:26:05,326 --> 0:26:06,316
不破坏二进制兼容性的情况下

730
00:26:06,316 --> 0:26:07,106
添加新 case

731
00:26:08,576 --> 0:26:10,296
这意味着

732
00:26:10,296 --> 0:26:12,906
客户端不能假设

733
00:26:12,906 --> 0:26:14,936
它知道枚举在内存中的大小

734
00:26:16,026 --> 0:26:18,286
因此枚举的这种使用

735
00:26:18,286 --> 0:26:19,836
要求客户端

736
00:26:20,586 --> 0:26:21,396
询问框架有多大

737
00:26:22,236 --> 0:26:25,546
框架回应它只有一个字节

738
00:26:26,976 --> 0:26:29,386
这里的另一种可能性是

739
00:26:29,386 --> 0:26:30,876
将来添加的新 case 之一

740
00:26:30,876 --> 0:26:33,316
可能具有相关的值

741
00:26:34,156 --> 0:26:35,636
那些相关的值

742
00:26:35,636 --> 0:26:37,396
可能需要一些清理

743
00:26:38,606 --> 0:26:40,376
因此客户端也会

744
00:26:40,376 --> 0:26:41,906
要求框架在完成时

745
00:26:41,906 --> 0:26:43,606
清除枚举值

746
00:26:43,606 --> 0:26:45,526
并且框架也将这样做

747
00:26:46,106 --> 0:26:48,986
此时观众中

748
00:26:48,986 --> 0:26:50,596
的一些人

749
00:26:50,596 --> 0:26:52,206
可能会变得有些烦躁

750
00:26:52,766 --> 0:26:54,446
因为我们谈论的

751
00:26:54,446 --> 0:26:56,436
是客户端和框架之间的

752
00:26:56,436 --> 0:26:57,716
所有这些额外的通信

753
00:26:58,766 --> 0:26:59,796
那是因为你有

754
00:26:59,986 --> 0:27:01,076
对性能敏感的框架

755
00:26:59,986 --> 0:27:01,076
对性能敏感的框架

756
00:27:01,076 --> 0:27:02,636
这就是为什么下一节 

757
00:27:02,636 --> 0:27:04,086
是关于牺牲

758
00:27:04,086 --> 0:27:05,506
Swift 提供的灵活性

759
00:27:05,506 --> 0:27:07,206
来换取

760
00:27:07,206 --> 0:27:12,966
给客户的优化

761
00:27:14,416 --> 0:27:16,696
这是一个权衡

762
00:27:17,386 --> 0:27:19,156
作为框架的作者

763
00:27:19,156 --> 0:27:20,586
我们希望

764
00:27:20,586 --> 0:27:22,046
能够在不破坏源代码

765
00:27:22,046 --> 0:27:24,626
或二进制兼容性的情况下

766
00:27:24,626 --> 0:27:26,556
灵活地更改 添加和改进

767
00:27:27,976 --> 0:27:29,616
但是为了让编译器

768
00:27:29,616 --> 0:27:31,356
尽可能快地

769
00:27:31,356 --> 0:27:33,356
生成客户代码

770
00:27:33,356 --> 0:27:35,556
它需要对框架中的内容做出假设

771
00:27:35,996 --> 0:27:40,146
所以 Swift 需要同时

772
00:27:40,146 --> 0:27:42,656
处理这两方面的问题

773
00:27:43,066 --> 0:27:45,646
它的工作方式是

774
00:27:45,676 --> 0:27:46,866
通过 Build Libraries for Distribution

775
00:27:46,866 --> 0:27:48,186
的构建设置

776
00:27:48,826 --> 0:27:50,046
Harlan 之前说过

777
00:27:50,046 --> 0:27:53,426
除了生成模块接口文件之外

778
00:27:53,426 --> 0:27:55,576
它还有多种效果

779
00:27:55,886 --> 0:27:57,446
其中一种效果是

780
00:27:57,446 --> 0:27:59,426
将默认值设置为偏向灵活性

781
00:28:00,736 --> 0:28:02,736
但同样 Swift 需要

782
00:28:02,736 --> 0:28:04,576
能够处理所有这些用例

783
00:28:04,576 --> 0:28:06,646
因此在本节中

784
00:28:06,816 --> 0:28:07,966
我将讨论一下

785
00:28:07,966 --> 0:28:10,306
一旦你从外部

786
00:28:10,506 --> 0:28:11,906
分析了框架的行为

787
00:28:11,906 --> 0:28:13,466
并且看到你需要额外的性能

788
00:28:13,466 --> 0:28:14,956
你可以做些什么

789
00:28:15,046 --> 0:28:16,346
有三种方法

790
00:28:16,346 --> 0:28:18,206
可以做到这一点

791
00:28:18,876 --> 0:28:20,756
内联函数

792
00:28:20,756 --> 0:28:21,326
冻结枚举和冻结结构

793
00:28:21,926 --> 0:28:24,836
因此我们将从

794
00:28:24,836 --> 0:28:26,576
内联函数开始

795
00:28:26,576 --> 0:28:28,536
这是去年在 Swift 4.2 中引入的一个特性

796
00:28:29,426 --> 0:28:31,526
在这个例子中

797
00:28:31,526 --> 0:28:33,326
我有一个 cargoship 子类

798
00:28:33,326 --> 0:28:35,286
这是我们之前看到

799
00:28:35,286 --> 0:28:37,376
的 Spaceship 类的一个子类

800
00:28:37,376 --> 0:28:39,466
它有一个方法 canCarry

801
00:28:39,826 --> 0:28:41,606
它只决定货船

802
00:28:41,606 --> 0:28:42,076
是否能够装载一些货物

803
00:28:43,376 --> 0:28:45,046
我把它变成了内联的

804
00:28:45,416 --> 0:28:46,426
因为我认为

805
00:28:46,426 --> 0:28:47,726
这对我的客户

806
00:28:47,726 --> 0:28:48,576
表现很重要

807
00:28:49,736 --> 0:28:51,986
这将使这个方法

808
00:28:51,986 --> 0:28:54,056
成为我的公共接口的一部分

809
00:28:54,056 --> 0:28:55,906
不仅是它的声明

810
00:28:55,906 --> 0:28:57,806
而且是它的主体

811
00:28:58,916 --> 0:29:00,486
这样做的效果是

812
00:28:58,916 --> 0:29:00,486
这样做的效果是

813
00:29:00,486 --> 0:29:02,636
将主体复制到

814
00:29:02,636 --> 0:29:03,646
模块接口文件中

815
00:29:04,236 --> 0:29:07,076
如果你看得比较快

816
00:29:07,366 --> 0:29:08,876
你还会看到这个方法

817
00:29:08,946 --> 0:29:10,836
引用 CargoShip 类

818
00:29:11,026 --> 0:29:12,356
的一个内部属性

819
00:29:13,766 --> 0:29:15,326
这是可能的

820
00:29:15,326 --> 0:29:16,936
因为我已将

821
00:29:16,936 --> 0:29:18,296
该属性标记为可从内联使用

822
00:29:19,386 --> 0:29:20,786
这可以让你

823
00:29:20,786 --> 0:29:21,516
充分利用这两个世界

824
00:29:22,246 --> 0:29:24,046
作为框架的公共接口的一部分

825
00:29:24,096 --> 0:29:25,446
该属性是可用的

826
00:29:25,446 --> 0:29:27,526
但仅对

827
00:29:27,526 --> 0:29:29,656
可内联代码可用

828
00:29:29,956 --> 0:29:31,476
它仍然受到保护

829
00:29:31,476 --> 0:29:33,736
不受外部客户端

830
00:29:33,736 --> 0:29:34,866
任意读取或写入

831
00:29:35,426 --> 0:29:37,556
所以它仍然是内部的

832
00:29:37,556 --> 0:29:38,556
但可以从内联中使用

833
00:29:39,876 --> 0:29:41,866
值得注意的是

834
00:29:41,866 --> 0:29:43,906
这是一个声明决定

835
00:29:44,486 --> 0:29:46,016
此处的 currentCargo 属性

836
00:29:46,016 --> 0:29:47,986
也是内部的

837
00:29:47,986 --> 0:29:49,476
不包含在模块界面中

838
00:29:51,936 --> 0:29:54,336
我们在模块接口中

839
00:29:54,336 --> 0:29:56,676
有 canCarry 方法的主体

840
00:29:57,366 --> 0:29:59,046
当客户端根据

841
00:29:59,046 --> 0:30:00,746
该接口进行编译时

842
00:29:59,046 --> 0:30:00,746
该接口进行编译时

843
00:30:00,746 --> 0:30:02,146
他们将能够将

844
00:30:02,296 --> 0:30:03,916
该主体直接复制到自己的代码中

845
00:30:04,326 --> 0:30:05,896
如果他们了解

846
00:30:05,966 --> 0:30:07,486
正在检查的

847
00:30:07,486 --> 0:30:08,676
货物的一些信息

848
00:30:09,706 --> 0:30:09,826
还可能进一步优化它

849
00:30:10,376 --> 0:30:12,046
但是如果框架所有者

850
00:30:12,046 --> 0:30:14,126
更改了方法的主体

851
00:30:14,126 --> 0:30:15,926
而客户没有重新编译

852
00:30:15,986 --> 0:30:17,136
会发生什么呢

853
00:30:17,826 --> 0:30:21,466
例如

854
00:30:21,466 --> 0:30:22,756
如果有一条新规定说

855
00:30:22,756 --> 0:30:24,116
货船不允许

856
00:30:24,116 --> 0:30:25,686
装载放射性物质怎么办

857
00:30:26,936 --> 0:30:28,556
在这种情况下

858
00:30:28,556 --> 0:30:29,476
我们会遇到麻烦

859
00:30:29,906 --> 0:30:31,266
因为现在程序的

860
00:30:31,266 --> 0:30:32,516
两个不同部分

861
00:30:32,516 --> 0:30:34,216
对这个方法应该做什么

862
00:30:34,216 --> 0:30:34,976
有不同的想法

863
00:30:35,946 --> 0:30:37,296
对于一些输入

864
00:30:37,296 --> 0:30:39,766
它们仍然会同意

865
00:30:39,766 --> 0:30:42,196
对于一些常规的货物

866
00:30:42,976 --> 0:30:46,166
客户端和框架

867
00:30:46,706 --> 0:30:47,076
都会说没问题

868
00:30:47,076 --> 0:30:48,196
但是如果

869
00:30:48,196 --> 0:30:50,616
我们试图测试放射性货物

870
00:30:50,616 --> 0:30:52,426
那么客户端代码会说没问题

871
00:30:52,426 --> 0:30:54,336
因为这是

872
00:30:54,336 --> 0:30:55,566
它在编译模块

873
00:30:55,566 --> 0:30:56,326
接口时看到的

874
00:30:57,376 --> 0:30:58,846
虽然框架

875
00:30:58,846 --> 0:31:00,706
具有该方法的新版本

876
00:30:58,846 --> 0:31:00,706
具有该方法的新版本

877
00:31:00,706 --> 0:31:01,556
但仍然将不允许它

878
00:31:02,216 --> 0:31:03,946
这可能表明

879
00:31:03,946 --> 0:31:05,456
程序中存在严重的逻辑错误

880
00:31:06,526 --> 0:31:08,566
因此作为一个经验法则

881
00:31:08,566 --> 0:31:09,646
如果你是一个框架作者

882
00:31:09,646 --> 0:31:11,116
并且使一个函数可以内联

883
00:31:11,666 --> 0:31:13,236
那么请确保

884
00:31:13,236 --> 0:31:14,976
不要更改输出或可观察的行为

885
00:31:16,176 --> 0:31:17,606
你可以添加

886
00:31:17,606 --> 0:31:19,966
一个更好的算法

887
00:31:20,036 --> 0:31:21,866
或者一些额外的快速填充

888
00:31:21,866 --> 0:31:23,166
但是如果你

889
00:31:23,166 --> 0:31:25,286
改变了函数的可观察行为

890
00:31:25,286 --> 0:31:26,256
那么你最终

891
00:31:26,256 --> 0:31:27,836
可能会遇到这些非常微妙的问题

892
00:31:27,836 --> 0:31:29,776
这些问题只在运行时可见

893
00:31:29,776 --> 0:31:30,796
而且可能只在某些输入下可见

894
00:31:31,096 --> 0:31:32,556
如果你需要这样做

895
00:31:32,556 --> 0:31:34,096
则需要重新编译所有客户端

896
00:31:34,686 --> 0:31:39,836
接下来我想谈谈枚举

897
00:31:40,946 --> 0:31:43,756
Swift 枚举很棒 我爱它们

898
00:31:44,556 --> 0:31:45,496
我们在这里谈到的一件事是

899
00:31:45,496 --> 0:31:47,036
你可以在

900
00:31:47,036 --> 0:31:48,946
不破坏源代码或

901
00:31:48,976 --> 0:31:50,236
二进制兼容性的情况下

902
00:31:50,236 --> 0:31:51,096
将新 case 添加到枚举中

903
00:31:51,946 --> 0:31:53,796
这对客户端意味着

904
00:31:53,796 --> 0:31:54,996
当切换枚举时

905
00:31:54,996 --> 0:31:57,566
它们总是必须有一个默认情况

906
00:31:58,346 --> 0:31:59,976
在这个客户端中

907
00:31:59,976 --> 0:32:03,276
他们决定使用 Swift 4.2 中引入的

908
00:31:59,976 --> 0:32:03,276
他们决定使用 Swift 4.2 中引入的

909
00:32:03,276 --> 0:32:06,276
未知默认语法

910
00:32:06,516 --> 0:32:08,466
这意味着它们已经处理了

911
00:32:08,466 --> 0:32:10,766
枚举中所有已知的情况

912
00:32:10,766 --> 0:32:13,506
但是仍然会

913
00:32:13,506 --> 0:32:15,146
处理将来添加的任何情况

914
00:32:15,616 --> 0:32:16,906
这在切换 C 枚举

915
00:32:16,906 --> 0:32:22,906
和构建在二进制框架中的枚举时是必要的

916
00:32:23,456 --> 0:32:26,346
这就是我之前

917
00:32:26,576 --> 0:32:28,026
谈到的另一个影响

918
00:32:28,376 --> 0:32:30,026
客户端和框架

919
00:32:30,026 --> 0:32:31,286
之间的这种交流

920
00:32:31,586 --> 0:32:33,446
关于枚举的大小

921
00:32:33,446 --> 0:32:34,866
以及是否需要进行任何清理

922
00:32:35,306 --> 0:32:37,826
但我在这里选择

923
00:32:37,826 --> 0:32:38,946
的例子是飞行计划

924
00:32:39,746 --> 0:32:41,666
你只能乘坐单程

925
00:32:41,666 --> 0:32:43,446
或往返航班

926
00:32:44,826 --> 0:32:46,666
因此通过使用

927
00:32:46,666 --> 0:32:49,336
冻结属性标记此枚举

928
00:32:49,336 --> 0:32:50,786
我作为框架作者

929
00:32:51,906 --> 0:32:53,286
可以保证

930
00:32:53,286 --> 0:32:55,526
在框架的未来版本中不会添加新 case

931
00:32:56,956 --> 0:32:58,796
这样做的第一个影响是

932
00:32:58,796 --> 0:33:00,436
客户端不再需要

933
00:32:58,796 --> 0:33:00,436
客户端不再需要

934
00:33:00,436 --> 0:33:01,406
编写该默认情况

935
00:33:01,596 --> 0:33:02,686
它可以自行消失

936
00:33:04,276 --> 0:33:07,316
接下来编译器

937
00:33:07,316 --> 0:33:09,226
可以更有效地编译它

938
00:33:09,946 --> 0:33:12,476
客户端可以假设

939
00:33:12,976 --> 0:33:14,266
这个枚举不会

940
00:33:14,266 --> 0:33:16,236
有任何额外的情况

941
00:33:16,236 --> 0:33:17,436
也不需要进行任何清理

942
00:33:18,756 --> 0:33:22,346
这太好了 只是我忘了一件事

943
00:33:22,996 --> 0:33:24,786
还有另一种飞行计划

944
00:33:24,786 --> 0:33:26,026
多程航班

945
00:33:27,186 --> 0:33:28,246
现在我们遇到了麻烦

946
00:33:28,746 --> 0:33:30,546
因为客户端代码

947
00:33:30,546 --> 0:33:32,956
不再具有默认情况

948
00:33:32,956 --> 0:33:35,206
因此在冻结枚举

949
00:33:35,206 --> 0:33:37,946
中添加新 case

950
00:33:37,946 --> 0:33:39,476
既包括源代码

951
00:33:39,476 --> 0:33:41,006
和二进制代码中断

952
00:33:41,326 --> 0:33:42,706
并且需要迭代主要版本

953
00:33:42,706 --> 0:33:48,296
并要求所有客户端重新编译 现在在冷冻枚举后

954
00:33:48,296 --> 0:33:49,946
冷冻结构大致相同

955
00:33:50,516 --> 0:33:52,886
默认情况下

956
00:33:52,886 --> 0:33:54,646
二进制框架中的结构

957
00:33:54,646 --> 0:33:55,756
可以添加新的存储属性

958
00:33:55,756 --> 0:33:57,686
或者对现有的属性

959
00:33:57,686 --> 0:33:59,856
进行重新排序

960
00:33:59,916 --> 0:34:01,716
而不会有任何问题

961
00:33:59,916 --> 0:34:01,716
而不会有任何问题

962
00:34:02,096 --> 0:34:03,066
但这确实会导致

963
00:34:03,066 --> 0:34:04,856
相同类型的交流

964
00:34:05,136 --> 0:34:06,036
以及客户端和框架之间的额外通信

965
00:34:06,746 --> 0:34:10,485
因此为了避免这种情况

966
00:34:10,485 --> 0:34:12,386
对于已知

967
00:34:12,386 --> 0:34:14,956
具有冻结布局的结构

968
00:34:14,956 --> 0:34:16,926
可以使用冻结属性

969
00:34:17,216 --> 0:34:19,306
来保证存储的属性不会更改

970
00:34:19,616 --> 0:34:20,936
它们不会被添加

971
00:34:20,936 --> 0:34:22,166
重新排序或删除

972
00:34:22,835 --> 0:34:25,596
这样做的另一件事是

973
00:34:25,656 --> 0:34:27,726
要求存储的属性

974
00:34:27,726 --> 0:34:30,126
都具有公共的类型

975
00:34:30,126 --> 0:34:32,315
或者内联的可用类型

976
00:34:32,876 --> 0:34:34,775
因为记住这里的目标是什么

977
00:34:35,156 --> 0:34:37,146
我们希望编译器

978
00:34:37,146 --> 0:34:39,505
在处理客户端代码时

979
00:34:39,505 --> 0:34:40,846
能够直接操作

980
00:34:40,846 --> 0:34:42,045
这个结构的存储属性

981
00:34:42,045 --> 0:34:43,616
以便在客户端

982
00:34:43,616 --> 0:34:46,926
生成更有效的代码

983
00:34:47,815 --> 0:34:49,966
这还具有语义效应

984
00:34:50,386 --> 0:34:51,416
即框架作者

985
00:34:51,416 --> 0:34:53,936
现在可以编写可内联的初始化器

986
00:34:54,525 --> 0:34:55,996
设置结构中的

987
00:34:55,996 --> 0:34:57,836
所有存储属性

988
00:34:57,836 --> 0:34:59,256
已经需要一个初始化器

989
00:34:59,826 --> 0:35:01,866
但是现在编译器

990
00:34:59,826 --> 0:35:01,866
但是现在编译器

991
00:35:02,066 --> 0:35:03,726
可以确保

992
00:35:03,726 --> 0:35:04,816
在框架的未来版本

993
00:35:04,816 --> 0:35:05,236
中也会这样做

994
00:35:05,326 --> 0:35:11,156
现在我想提醒你

995
00:35:11,156 --> 0:35:13,036
出于某些原因灵活性是默认的

996
00:35:13,036 --> 0:35:13,736
来结束这部分话题

997
00:35:14,536 --> 0:35:15,896
其中最主要的一点是

998
00:35:15,896 --> 0:35:17,656
中断更改对客户

999
00:35:17,656 --> 0:35:19,226
来说非常不方便

1000
00:35:20,136 --> 0:35:21,926
客户可能会

1001
00:35:21,926 --> 0:35:23,516
重新考虑是否

1002
00:35:23,516 --> 0:35:25,026
采用新版本的框架

1003
00:35:25,026 --> 0:35:26,606
因为框架可能会以

1004
00:35:26,606 --> 0:35:27,686
某种方式破坏它们自身

1005
00:35:28,366 --> 0:35:29,446
当一个二进制框架

1006
00:35:29,446 --> 0:35:31,316
依赖于另一个二进制框架时

1007
00:35:31,316 --> 0:35:32,706
你也可能会遇到麻烦

1008
00:35:34,136 --> 0:35:35,666
同样值得提醒的是

1009
00:35:36,836 --> 0:35:39,286
这些属性只影响客户端代码

1010
00:35:39,696 --> 0:35:41,196
在你的框架中

1011
00:35:41,196 --> 0:35:44,186
你仍然可以获得编译器优化的全部功能

1012
00:35:45,586 --> 0:35:47,856
因此在使用冻结

1013
00:35:47,856 --> 0:35:49,716
或内联之前

1014
00:35:49,716 --> 0:35:51,156
请确保你已经

1015
00:35:51,156 --> 0:35:52,826
从外部描述了框架的行为

1016
00:35:53,256 --> 0:35:54,636
并证明你需要

1017
00:35:54,636 --> 0:35:56,216
额外的性能

1018
00:35:56,796 --> 0:35:58,936
否则保持灵活性

1019
00:35:58,936 --> 0:36:00,546
因为你可能需要它

1020
00:35:58,936 --> 0:36:00,546
因为你可能需要它

1021
00:36:02,696 --> 0:36:04,106
现在我想谈的最后一部分

1022
00:36:04,106 --> 0:36:05,836
是确保客户的

1023
00:36:05,836 --> 0:36:08,516
体验是最好的

1024
00:36:09,266 --> 0:36:11,086
这与 Harlan 

1025
00:36:11,086 --> 0:36:12,826
前半部分的

1026
00:36:12,826 --> 0:36:13,916
内容非常相似

1027
00:36:14,496 --> 0:36:16,726
我们将从授权开始

1028
00:36:17,636 --> 0:36:19,036
如果你的框架

1029
00:36:19,036 --> 0:36:20,276
具有完成其工作

1030
00:36:20,276 --> 0:36:22,316
所需的某些权利

1031
00:36:22,316 --> 0:36:23,216
那么让我们从基础开始

1032
00:36:23,456 --> 0:36:24,636
请你确保记录它们

1033
00:36:24,636 --> 0:36:26,226
以便任何潜在客户知道

1034
00:36:26,226 --> 0:36:28,146
成功采用你的框架

1035
00:36:28,456 --> 0:36:30,096
需要做什么

1036
00:36:30,606 --> 0:36:34,536
此外尽量减少

1037
00:36:34,536 --> 0:36:38,486
特定框架的授权请求

1038
00:36:38,486 --> 0:36:39,676
因为这意味着

1039
00:36:39,676 --> 0:36:41,676
它将适用于更多的上下文

1040
00:36:42,126 --> 0:36:43,816
你可以使用你的框架

1041
00:36:44,086 --> 0:36:45,056
获得更多客户

1042
00:36:45,516 --> 0:36:49,636
最后请记住

1043
00:36:49,636 --> 0:36:51,486
虽然框架和 App 

1044
00:36:51,486 --> 0:36:53,036
都可以向用户

1045
00:36:53,096 --> 0:36:54,656
请求权限

1046
00:36:54,726 --> 0:36:56,686
但最终是否

1047
00:36:57,286 --> 0:36:58,446
授予权限是用户的选择

1048
00:36:59,606 --> 0:37:00,976
因此如果你被

1049
00:36:59,606 --> 0:37:00,976
因此如果你被

1050
00:37:00,976 --> 0:37:02,746
拒绝了某个特定的权限

1051
00:37:02,746 --> 0:37:04,016
请确保你的框架

1052
00:37:04,016 --> 0:37:05,026
能够优雅地处理该拒绝

1053
00:37:05,316 --> 0:37:07,026
它不应该使 App 崩溃

1054
00:37:07,026 --> 0:37:08,156
也不应该停止工作

1055
00:37:08,646 --> 0:37:09,716
确保它仍然做

1056
00:37:09,756 --> 0:37:11,456
一些有用的事情

1057
00:37:11,456 --> 0:37:12,916
以便你的客户

1058
00:37:13,236 --> 0:37:15,166
可以使用框架而不必放弃

1059
00:37:16,996 --> 0:37:19,186
现在依赖关系

1060
00:37:19,186 --> 0:37:20,416
与权限有很多

1061
00:37:20,416 --> 0:37:21,176
相同的问题

1062
00:37:21,926 --> 0:37:23,506
因为就像权限一样

1063
00:37:23,506 --> 0:37:25,416
框架的依赖关系

1064
00:37:25,416 --> 0:37:26,986
变成了 App 的依赖关系

1065
00:37:27,986 --> 0:37:30,136
因此你应该

1066
00:37:30,136 --> 0:37:31,906
首先记录它们

1067
00:37:31,906 --> 0:37:33,816
以便潜在客户

1068
00:37:33,816 --> 0:37:34,826
知道他们注册了什么

1069
00:37:35,486 --> 0:37:36,776
而且你应该尽量

1070
00:37:36,776 --> 0:37:38,156
减少你的依赖关系

1071
00:37:38,156 --> 0:37:39,796
这样你对客户的要求就会更少

1072
00:37:40,106 --> 0:37:42,036
在扩展信任方面

1073
00:37:42,036 --> 0:37:43,986
你对客户的要求也要更少

1074
00:37:43,986 --> 0:37:45,696
甚至在实际问题上

1075
00:37:45,696 --> 0:37:46,346
比如依赖项占用的代码大小方面

1076
00:37:48,006 --> 0:37:51,876
最后 所有的依赖项都必须使用

1077
00:37:52,106 --> 0:37:53,216
Build Libraries for Distribution

1078
00:37:53,216 --> 0:37:55,096
构建设置来构建

1079
00:37:55,096 --> 0:37:56,416
以便获得我们

1080
00:37:56,416 --> 0:37:59,926
所讨论的二进制兼容性保证

1081
00:38:00,476 --> 0:38:02,096
这确实有一个特殊含义

1082
00:38:02,096 --> 0:38:04,156
即二进制

1083
00:38:04,156 --> 0:38:06,436
框架不能依赖于包

1084
00:38:07,446 --> 0:38:08,936
让我们看一个依赖关系图

1085
00:38:10,366 --> 0:38:11,946
几分钟前我说过

1086
00:38:12,276 --> 0:38:14,706
框架的依赖关系

1087
00:38:14,706 --> 0:38:15,746
成为 App 的依赖关系

1088
00:38:15,976 --> 0:38:18,326
但是当一个 

1089
00:38:18,326 --> 0:38:19,926
App 构建一个包时

1090
00:38:19,926 --> 0:38:21,586
它必须选择一个特定的标签来执行此操作

1091
00:38:22,416 --> 0:38:23,496
这可能与你

1092
00:38:23,496 --> 0:38:25,746
构建框架的版本不匹配

1093
00:38:26,076 --> 0:38:27,686
它可能根本不兼容

1094
00:38:28,596 --> 0:38:30,806
除此之外

1095
00:38:30,806 --> 0:38:32,666
并非所有框架都必须

1096
00:38:32,666 --> 0:38:34,036
以与 Build Libraries for Distribution

1097
00:38:34,036 --> 0:38:36,406
兼容的模式构建

1098
00:38:37,246 --> 0:38:39,626
所以我们不支持这种配置

1099
00:38:39,626 --> 0:38:42,776
现在我想谈的最后一件事

1100
00:38:42,776 --> 0:38:45,216
是你们的 Objective-C 接口

1101
00:38:45,986 --> 0:38:47,546
是的你

1102
00:38:47,546 --> 0:38:49,416
Swift 框架的作者

1103
00:38:49,416 --> 0:38:51,546
你有一个 Objective-C 接口

1104
00:38:51,546 --> 0:38:53,216
很有可能因为 Xcode 的默认模板

1105
00:38:53,216 --> 0:38:54,906
是为一个混合源框架设置的

1106
00:38:55,096 --> 0:38:56,346
它有一个 

1107
00:38:56,346 --> 0:38:58,616
Objective-C Umbrella Header

1108
00:38:58,616 --> 0:38:59,486
和一个生成的 Header

1109
00:38:59,486 --> 0:39:01,206
位于你的框架中 Swift 包含

1110
00:38:59,486 --> 0:39:01,206
位于你的框架中 Swift 包含

1111
00:39:01,206 --> 0:39:01,926
的 Objective-C 部分

1112
00:39:02,566 --> 0:39:05,456
但是如果你的 

1113
00:39:05,456 --> 0:39:07,326
Swift 代码没有任何它

1114
00:39:07,566 --> 0:39:09,716
试图发布的 Objective-C API

1115
00:39:09,916 --> 0:39:12,116
那么你根本不需要安装第二个 Header

1116
00:39:12,476 --> 0:39:14,066
这里有一个你可以直接关闭的

1117
00:39:14,066 --> 0:39:17,156
Install Objective-C Compatibility Header

1118
00:39:17,156 --> 0:39:20,686
构建设置 如果你的框架

1119
00:39:20,686 --> 0:39:23,386
没有提供任何 Objective-C API

1120
00:39:23,386 --> 0:39:24,216
那就没有理由

1121
00:39:24,216 --> 0:39:25,866
支持 Objective-C 导入语法

1122
00:39:25,866 --> 0:39:27,596
你也可以通过

1123
00:39:27,596 --> 0:39:29,186
Defines Module Build

1124
00:39:29,186 --> 0:39:30,186
设置关闭它

1125
00:39:30,846 --> 0:39:32,666
将其设置为 No

1126
00:39:32,666 --> 0:39:33,976
这将不再支持有效

1127
00:39:33,976 --> 0:39:34,306
的 Objective-C 代码

1128
00:39:35,386 --> 0:39:36,856
在你完成此操作后

1129
00:39:36,856 --> 0:39:38,886
你可以删除 Xcode 

1130
00:39:38,886 --> 0:39:40,716
为你生成的 Umbrella Header

1131
00:39:42,376 --> 0:39:43,966
所以让我们总结一下

1132
00:39:44,576 --> 0:39:45,756
我们今天谈了很多

1133
00:39:45,756 --> 0:39:49,046
但最重要的是 XC 框架

1134
00:39:49,376 --> 0:39:50,516
它们是一种新的捆绑包格式

1135
00:39:50,516 --> 0:39:51,606
用于以一种用户

1136
00:39:51,606 --> 0:39:53,496
非常容易使用的方式

1137
00:39:53,496 --> 0:39:55,376
分发多个框架变体

1138
00:39:56,606 --> 0:39:57,506
为了构建 XC 框架

1139
00:39:57,506 --> 0:39:58,996
你需要打开

1140
00:39:58,996 --> 0:40:00,076
Build Libraries for Distribution

1141
00:39:58,996 --> 0:40:00,076
Build Libraries for Distribution

1142
00:40:00,076 --> 0:40:01,176
构建设置

1143
00:40:01,476 --> 0:40:02,656
这将激活你获得

1144
00:40:02,656 --> 0:40:04,896
正确的二进制兼容

1145
00:40:04,896 --> 0:40:05,886
框架所需的一切

1146
00:40:06,426 --> 0:40:08,876
作为框架所有者

1147
00:40:08,876 --> 0:40:11,186
请确保你了解你对客户的责任

1148
00:40:11,186 --> 0:40:12,676
以便你可以

1149
00:40:12,676 --> 0:40:14,826
为他们提供最好的服务

1150
00:40:14,996 --> 0:40:16,096
Harlan 和我将在

1151
00:40:16,096 --> 0:40:17,536
本节会议结束后

1152
00:40:17,536 --> 0:40:19,376
立即进入实验室

1153
00:40:19,376 --> 0:40:20,656
对于所有来到这里参会的人

1154
00:40:20,716 --> 0:40:21,506
非常感谢你们

1155
00:40:21,506 --> 0:40:21,966
让我们看看这些很棒的框架

1156
00:40:22,516 --> 0:40:25,500
[掌声和欢呼]
