1
00:00:00,506 --> 0:00:04,516
[音乐]

2
00:00:05,516 --> 0:00:07,546
[掌声]

3
00:00:08,045 --> 0:00:10,456
&gt;&gt; 大家好 欢迎大家来到 

4
00:00:10,456 --> 0:00:11,786
《Advances in Networking》的第二部分

5
00:00:12,356 --> 0:00:13,686
如果你没有来听第一部分

6
00:00:13,686 --> 0:00:17,046
应该很快就能在 App 和网页上看到视频

7
00:00:18,486 --> 0:00:20,456
我叫 Eric Kinnear 来自网络技术部

8
00:00:20,706 --> 0:00:21,866
一会将加入讲演的是

9
00:00:21,866 --> 0:00:23,506
我的同事 Tommy 和 Stuart

10
00:00:23,986 --> 0:00:26,746
我们会介绍很多东西

11
00:00:27,226 --> 0:00:28,336
首先 我们会介绍 

12
00:00:28,336 --> 0:00:31,466
如何更加充分地利用 Bonjour 搜索

13
00:00:32,235 --> 0:00:35,236
我们会介绍 如何通过搭建框架协议

14
00:00:35,236 --> 0:00:37,726
高效简便得传递消息

15
00:00:38,406 --> 0:00:39,556
我们会看一些新的 

16
00:00:39,726 --> 0:00:41,126
升级的指标收集

17
00:00:41,356 --> 0:00:42,746
最后我们会介绍一些

18
00:00:42,746 --> 0:00:44,286
状态更新和一些操作

19
00:00:44,286 --> 0:00:47,986
让你的 App 实现最佳联网性能

20
00:00:49,476 --> 0:00:51,246
开始之前 我要提醒大家

21
00:00:52,646 --> 0:00:54,506
如果你在用 URLSession

22
00:00:54,506 --> 0:00:55,876
和 Network.framework

23
00:00:55,876 --> 0:00:56,786
你可以充分利用

24
00:00:56,876 --> 0:00:58,166
我们今天讲的一切东西

25
00:00:59,116 --> 0:01:00,826
如果你还没有用

26
00:00:59,116 --> 0:01:00,826
如果你还没有用

27
00:01:00,826 --> 0:01:02,146
这就是为什么

28
00:01:02,146 --> 0:01:05,525
你应该改用更现代的网络 API

29
00:01:05,786 --> 0:01:09,876
我们直接从 Bonjour 搜索开始

30
00:01:09,986 --> 0:01:11,666
Bonjour 能在网络上

31
00:01:11,666 --> 0:01:13,256
发布和发现服务

32
00:01:13,656 --> 0:01:15,666
每当你用隔空打印  

33
00:01:15,666 --> 0:01:17,886
连接隔空播放设备

34
00:01:17,886 --> 0:01:19,906
用 HomeKit 让你的家自动化时

35
00:01:19,906 --> 0:01:21,356
你都需要 Bonjour

36
00:01:21,776 --> 0:01:23,356
每次你在连接时

37
00:01:23,356 --> 0:01:24,726
却无需输入 IP 地址或主机名时

38
00:01:24,726 --> 0:01:26,946
你都在用 Bonjour

39
00:01:27,766 --> 0:01:29,306
如你所知 Bonjour 

40
00:01:29,306 --> 0:01:30,976
在所有的 Apple 平台上都可用

41
00:01:31,546 --> 0:01:36,226
它在 Linux Android Chrome OS 上同样可用

42
00:01:36,226 --> 0:01:37,566
Chromecast 就是用它发现设备的

43
00:01:38,486 --> 0:01:39,886
你可能不知道 

44
00:01:39,886 --> 0:01:41,476
早在 2015 年

45
00:01:41,476 --> 0:01:43,346
微软也悄悄将 Bonjour 支持

46
00:01:43,346 --> 0:01:44,426
添加到 Windows 10

47
00:01:45,316 --> 0:01:47,216
从那时起 Bonjour 的实施就已经成熟

48
00:01:48,066 --> 0:01:49,416
这就意味着 Bonjour 

49
00:01:49,416 --> 0:01:51,456
现在在各大主平台均可用

50
00:01:53,876 --> 0:01:55,866
今天 我们将分享一些

51
00:01:55,866 --> 0:01:57,196
这个领域的最新进展

52
00:01:57,706 --> 0:01:59,416
有时 你在一个网络

53
00:02:00,006 --> 0:02:03,016
想要发现另一个网络上的设备

54
00:02:03,606 --> 0:02:04,996
比如说你有一台设备 

55
00:02:04,996 --> 0:02:06,226
想要连接到

56
00:02:06,726 --> 0:02:08,286
另一个网络上的打印机

57
00:02:08,286 --> 0:02:09,356
二者之间有多个跳跃

58
00:02:10,196 --> 0:02:11,616
现在 如果你在局域网上

59
00:02:11,616 --> 0:02:13,286
发送多点传送数据包

60
00:02:13,286 --> 0:02:15,436
你不会得到任何回应

61
00:02:16,606 --> 0:02:18,386
Discovery Proxy 解决这个问题

62
00:02:19,356 --> 0:02:22,486
现在你可以发送单点传送数据包到 Discovery Proxy

63
00:02:22,956 --> 0:02:24,176
它会把多点传送数据包

64
00:02:24,176 --> 0:02:27,556
发送到目标子网络接收响应

65
00:02:27,556 --> 0:02:28,806
将结果代理给你

66
00:02:29,636 --> 0:02:30,956
现在你就可以直接连接到打印机

67
00:02:30,956 --> 0:02:32,736
看 我们已经

68
00:02:32,736 --> 0:02:34,976
收到了文件

69
00:02:35,516 --> 0:02:37,946
[掌声]

70
00:02:38,446 --> 0:02:39,756
我们很高兴地宣布

71
00:02:39,756 --> 0:02:42,776
客户端上这个的代码 

72
00:02:42,776 --> 0:02:44,846
已经在你的开发者版本里了

73
00:02:44,846 --> 0:02:47,846
服务器实施和操作指南

74
00:02:48,106 --> 0:02:49,176
都可以在 GitHub 上找到

75
00:02:49,786 --> 0:02:52,596
我们来看一下

76
00:02:52,596 --> 0:02:53,346
这对你的 App 来说意味什么

77
00:02:54,686 --> 0:02:55,956
之前比较推荐的做法是 

78
00:02:55,956 --> 0:02:57,436
当你搜索时

79
00:02:57,436 --> 0:02:59,416
你需要将域设置为 nil

80
00:03:00,166 --> 0:03:01,236
一直都是如此  

81
00:03:01,236 --> 0:03:02,836
对于几乎每一种情况

82
00:03:02,836 --> 0:03:03,986
这种做法都是正确的

83
00:03:05,096 --> 0:03:06,156
以前你不觉得

84
00:03:06,156 --> 0:03:07,596
有多大的不同

85
00:03:07,596 --> 0:03:08,546
但是现在它开始有更大的影响

86
00:03:08,546 --> 0:03:13,716
指定本地会直接阻止发现

87
00:03:13,806 --> 0:03:15,896
任何远程或者代理服务

88
00:03:16,716 --> 0:03:18,316
这也许不是你想要的结果

89
00:03:18,316 --> 0:03:19,856
所以要好好检查

90
00:03:19,856 --> 0:03:21,226
你的搜索调用是不是无意间

91
00:03:21,226 --> 0:03:22,136
指定了一个域

92
00:03:23,546 --> 0:03:25,316
当你创建 App 搜索服务时

93
00:03:25,746 --> 0:03:26,616
让我们来看一下

94
00:03:26,616 --> 0:03:27,486
Network.framework 的

95
00:03:27,486 --> 0:03:29,366
一些新功能

96
00:03:29,486 --> 0:03:31,346
它们使得 Bonjour 搜索更加简便

97
00:03:31,596 --> 0:03:32,696
尤其是在 Swift 里

98
00:03:34,226 --> 0:03:35,536
去年我们介绍了

99
00:03:35,536 --> 0:03:37,276
NWListener 和 NWConnection

100
00:03:37,516 --> 0:03:38,586
以及 Network.framework

101
00:03:39,286 --> 0:03:40,876
比如 你可以让

102
00:03:40,876 --> 0:03:42,646
NWListener 发布一个 Bonjour 服务

103
00:03:42,646 --> 0:03:45,886
你可以让 NWConnection 连接到

104
00:03:45,886 --> 0:03:46,996
Bonjour 服务端点

105
00:03:47,986 --> 0:03:49,056
但是如果想要

106
00:03:49,056 --> 0:03:50,666
发现可用服务

107
00:03:50,666 --> 0:03:52,366
你就需要其他 Bonjour 搜索 API

108
00:03:53,006 --> 0:03:54,426
一旦发现了一个

109
00:03:54,426 --> 0:03:55,616
你就需要做很多工作

110
00:03:55,616 --> 0:03:56,696
将它转换为

111
00:03:56,696 --> 0:03:57,786
一个可用于连接的端点

112
00:03:59,046 --> 0:04:00,596
今天 我们宣布

113
00:03:59,046 --> 0:04:00,596
今天 我们宣布

114
00:04:00,596 --> 0:04:02,246
通过 NWBrowser 对象

115
00:04:02,466 --> 0:04:03,526
Network.framework 

116
00:04:03,526 --> 0:04:04,826
自带搜索支持

117
00:04:06,016 --> 0:04:07,786
NWBrowser 可以连接

118
00:04:07,786 --> 0:04:09,416
并监听其他服务   

119
00:04:09,416 --> 0:04:11,536
覆盖整个工作流

120
00:04:11,536 --> 0:04:13,866
从发布 到发现 再到连接

121
00:04:13,866 --> 0:04:14,876
用的都是大家早已熟悉的

122
00:04:14,906 --> 0:04:15,966
Network.framework 对象 

123
00:04:19,156 --> 0:04:20,916
浏览器在 Network.framework 中   

124
00:04:20,916 --> 0:04:22,616
用现代基于调度的 API

125
00:04:23,276 --> 0:04:25,386
提供发现服务的功能

126
00:04:25,386 --> 0:04:27,176
这个 API 已经优化 

127
00:04:27,176 --> 0:04:28,686
特别适合 Swift

128
00:04:29,486 --> 0:04:30,796
它还包括可选择的

129
00:04:30,796 --> 0:04:32,596
TXT 记录支持

130
00:04:33,426 --> 0:04:34,816
如果你的 App 需要

131
00:04:34,996 --> 0:04:37,936
你可以为每个发现的端点 

132
00:04:37,936 --> 0:04:38,736
请求 TXT 记录

133
00:04:39,226 --> 0:04:42,846
让我们看一下如何使用 browser

134
00:04:43,866 --> 0:04:45,596
我们可以用你想发现的 Bonjour 服务类

135
00:04:45,596 --> 0:04:46,946
和一些 NWParameters 

136
00:04:46,946 --> 0:04:48,696
将它初始化

137
00:04:48,696 --> 0:04:50,026
你可以通过 NWParameters 告诉它

138
00:04:50,026 --> 0:04:51,016
你想如何搜索

139
00:04:51,016 --> 0:04:52,426
和你处理其他所有的 

140
00:04:52,426 --> 0:04:53,896
Network.framework 对象一样

141
00:04:54,506 --> 0:04:55,596
接着 你可以创建一个

142
00:04:55,596 --> 0:04:56,916
browseResultsChangedHandler

143
00:04:57,876 --> 0:05:00,806
它可以被调用传输已发现的

144
00:04:57,876 --> 0:05:00,806
它可以被调用传输已发现的

145
00:05:00,806 --> 0:05:01,546
所有可用端点的列表

146
00:05:02,306 --> 0:05:03,856
最后 就像其他

147
00:05:03,856 --> 0:05:05,206
Network.framework 对象一样

148
00:05:05,206 --> 0:05:07,866
你可以在想要接收回调的队列上

149
00:05:07,866 --> 0:05:08,956
创建你的 browser

150
00:05:09,486 --> 0:05:11,906
我们仔细来看一下

151
00:05:11,906 --> 0:05:13,026
browseResultsChangedHandler

152
00:05:13,946 --> 0:05:14,846
你有两个选择

153
00:05:15,176 --> 0:05:17,026
其一 你可以

154
00:05:17,366 --> 0:05:18,846
用一个句柄

155
00:05:18,846 --> 0:05:19,966
接收更新里

156
00:05:19,966 --> 0:05:20,786
所有变化的详单

157
00:05:21,436 --> 0:05:23,206
这与低级 API   

158
00:05:23,206 --> 0:05:24,546
非常一致

159
00:05:24,546 --> 0:05:26,066
你可以清楚地看到

160
00:05:26,276 --> 0:05:27,496
所有的变化

161
00:05:28,056 --> 0:05:29,696
端点可以被添加或移除 

162
00:05:29,696 --> 0:05:31,686
而且还可以

163
00:05:31,686 --> 0:05:32,886
改变它们的内部细节

164
00:05:33,716 --> 0:05:35,546
这些变化通过 Flag 声明

165
00:05:36,436 --> 0:05:38,076
在这种情况下  

166
00:05:38,076 --> 0:05:39,696
随着端点在其他接口上被发现

167
00:05:39,696 --> 0:05:42,586
我们会查看接口是否被添加或移除

168
00:05:43,136 --> 0:05:45,996
你也可以选择

169
00:05:45,996 --> 0:05:49,916
只用句柄查看最新的

170
00:05:49,956 --> 0:05:50,596
发现结果列表

171
00:05:51,476 --> 0:05:52,786
这么做要小心

172
00:05:52,986 --> 0:05:53,916
因为随着可用端点列表改变

173
00:05:53,916 --> 0:05:57,076
这个句柄会重复被调用

174
00:05:57,676 --> 0:05:58,516
所以确保 你更新

175
00:05:58,516 --> 0:06:01,246
App 的状态和其他东西的方式是恰当的

176
00:05:58,516 --> 0:06:01,246
App 的状态和其他东西的方式是恰当的

177
00:06:05,096 --> 0:06:06,566
我们来看一个

178
00:06:06,566 --> 0:06:07,576
正在运行的 NWBrowser 的例子

179
00:06:08,476 --> 0:06:09,976
我们准备做一个 App 

180
00:06:09,976 --> 0:06:12,126
可以在两个设备之间

181
00:06:12,126 --> 0:06:14,246
发现服务和安全连接的 App

182
00:06:15,206 --> 0:06:16,236
在我们的例子中 

183
00:06:16,236 --> 0:06:17,426
我将做一个井字游戏

184
00:06:17,856 --> 0:06:19,846
你也可以做其他很多东西

185
00:06:21,136 --> 0:06:22,516
我们会用 NWListener

186
00:06:22,516 --> 0:06:23,666
把游戏发布给周围玩家

187
00:06:23,666 --> 0:06:26,866
我们会用 NWBrowser 

188
00:06:26,866 --> 0:06:28,746
搜索附近可用游戏

189
00:06:29,036 --> 0:06:30,346
一旦用户选择一个

190
00:06:30,346 --> 0:06:31,416
他们想加入的游戏

191
00:06:31,416 --> 0:06:32,856
我们就会取其中一个搜索结果 

192
00:06:32,856 --> 0:06:34,486
传送给 NWConnection

193
00:06:34,486 --> 0:06:36,946
回连到我们的监听器

194
00:06:36,946 --> 0:06:39,976
在 Xcode 中看一下

195
00:06:47,416 --> 0:06:49,376
App 已经在这儿了

196
00:06:49,376 --> 0:06:50,476
我们已经写了一些代码

197
00:06:50,516 --> 0:06:52,716
去处理不同的视图

198
00:06:52,716 --> 0:06:54,706
为用户展示

199
00:06:54,706 --> 0:06:56,006
一系列可玩的游戏

200
00:06:56,006 --> 0:06:58,366
让他们创建游戏 诸如此类

201
00:06:58,626 --> 0:07:00,286
所以这里就只关注浏览器本身

202
00:06:58,626 --> 0:07:00,286
所以这里就只关注浏览器本身

203
00:07:00,856 --> 0:07:02,816
我已经有了一个类 PeerBrowser

204
00:07:02,886 --> 0:07:04,656
我会用这个类

205
00:07:04,656 --> 0:07:06,676
管理我的 NWBrowser 

206
00:07:06,676 --> 0:07:08,006
并且提供一个 PeerBrowserDelegate

207
00:07:08,006 --> 0:07:09,716
它也会传送发现端点的列表 

208
00:07:09,716 --> 0:07:11,406
这样 UI 就可以

209
00:07:11,406 --> 0:07:12,846
将它们展现给用户

210
00:07:14,536 --> 0:07:15,936
首先 我要把我的 NWBrowser 

211
00:07:15,936 --> 0:07:17,656
作为一个实例属性

212
00:07:17,656 --> 0:07:18,806
添加到 PeerBrowser 上 

213
00:07:21,216 --> 0:07:24,706
然后 当 PeerBrowser 被初始化时

214
00:07:24,706 --> 0:07:26,166
它会立即调用 startBrowsing

215
00:07:27,126 --> 0:07:28,666
我们要把这个填上

216
00:07:29,916 --> 0:07:31,846
首先 我要创建

217
00:07:31,846 --> 0:07:33,576
一些 NWParameters

218
00:07:33,576 --> 0:07:36,206
它们和其他 Network.framework 对象一样 

219
00:07:36,206 --> 0:07:38,126
用来描述你想如何与网络互动

220
00:07:38,716 --> 0:07:39,636
在我们的例子里

221
00:07:39,636 --> 0:07:41,146
默认 parameter 就可以

222
00:07:41,376 --> 0:07:43,046
但是要设置 includePeerToPeer 为真

223
00:07:43,046 --> 0:07:45,276
这样 即使设备

224
00:07:45,276 --> 0:07:46,926
不在同一个网络上

225
00:07:46,926 --> 0:07:49,066
我们也能发现其他可玩的游戏

226
00:07:52,576 --> 0:07:55,006
接着 我们创建 NWBrowser

227
00:07:56,236 --> 0:07:58,076
搜索服务类型 

228
00:07:58,126 --> 0:07:59,216
_tictactoe._tcp

229
00:07:59,216 --> 0:08:01,356
我们要确保 

230
00:07:59,216 --> 0:08:01,356
我们要确保 

231
00:08:01,356 --> 0:08:02,286
将域设置为 nil

232
00:08:03,616 --> 0:08:04,856
用之前创建的 parameters 

233
00:08:04,856 --> 0:08:07,296
将其存入 PeerBrowser

234
00:08:07,806 --> 0:08:10,066
接下来 我们设置一个

235
00:08:10,066 --> 0:08:11,876
stateUpdateHandler 

236
00:08:11,876 --> 0:08:12,826
就像我们处理

237
00:08:12,826 --> 0:08:14,756
其他 Network.framework 对象一样   

238
00:08:14,756 --> 0:08:15,966
用来接收浏览器状态的更新

239
00:08:15,966 --> 0:08:17,366
有无错误 运行状况如何

240
00:08:17,366 --> 0:08:18,866
诸如此类

241
00:08:20,936 --> 0:08:23,166
然后我们设置 browseResultsChangedHandler

242
00:08:24,226 --> 0:08:28,216
非常简单 我们将结果列表传送给代理

243
00:08:28,216 --> 0:08:29,776
让它呈现在 UI 中

244
00:08:29,776 --> 0:08:30,806
确保代理是这样编码的

245
00:08:30,806 --> 0:08:32,826
这样 每当发生变化时

246
00:08:32,826 --> 0:08:34,275
它就会刷新 UI 

247
00:08:34,275 --> 0:08:35,275
所以我们可以一直呈现

248
00:08:35,275 --> 0:08:37,736
发现端点的最新列表

249
00:08:41,556 --> 0:08:44,996
最后 在主队列启动浏览器

250
00:08:44,996 --> 0:08:46,276
因为想在主队列接收更新

251
00:08:46,786 --> 0:08:49,696
就是这样

252
00:08:50,236 --> 0:08:51,726
通过这样一组代码

253
00:08:51,726 --> 0:08:53,546
我们可以搭建一个 NWBrowser

254
00:08:53,546 --> 0:08:54,996
让它通过 P2P 连接

255
00:08:55,256 --> 0:08:56,376
发现附近的游戏

256
00:08:56,376 --> 0:08:58,076
并为用户展示

257
00:08:58,076 --> 0:08:59,626
一系列可玩的游戏

258
00:08:59,626 --> 0:09:00,856
让用户自己选择连接哪个

259
00:08:59,626 --> 0:09:00,856
让用户自己选择连接哪个

260
00:09:00,856 --> 0:09:05,466
一会我们再介绍

261
00:09:05,466 --> 0:09:07,796
监听器和连接这些代码

262
00:09:07,796 --> 0:09:08,846
这个例子的代码

263
00:09:08,846 --> 0:09:10,376
可以从网站下载

264
00:09:10,376 --> 0:09:12,266
在我们继续之前

265
00:09:12,266 --> 0:09:13,846
我想先说一件事 

266
00:09:14,786 --> 0:09:16,966
我们已经有了 NWParameters 

267
00:09:16,966 --> 0:09:18,926
可以用在监听器和连接上

268
00:09:19,506 --> 0:09:20,536
刚才我提到

269
00:09:20,536 --> 0:09:21,806
我们想确保

270
00:09:21,806 --> 0:09:23,416
设备间的连接是安全的

271
00:09:23,416 --> 0:09:24,866
没有人能看到

272
00:09:24,866 --> 0:09:26,066
我们在做什么

273
00:09:26,246 --> 0:09:28,296
更没有人能干扰我们的操作

274
00:09:29,586 --> 0:09:30,676
要实现这个目标

275
00:09:30,676 --> 0:09:31,736
我们要为 NWParameters 

276
00:09:31,736 --> 0:09:34,526
定义一个扩展

277
00:09:34,526 --> 0:09:35,666
并创建一个便利构造函数

278
00:09:36,976 --> 0:09:38,386
它将密码设为字符串

279
00:09:39,396 --> 0:09:42,836
我们会给游戏的创建人 一个密码

280
00:09:42,896 --> 0:09:45,146
让其他想加入游戏的人输入密码

281
00:09:45,146 --> 0:09:46,976
这样就生成了一个

282
00:09:46,976 --> 0:09:48,436
预共享密码

283
00:09:48,436 --> 0:09:50,346
用 TLS 确保连接安全

284
00:09:50,346 --> 0:09:53,556
要实现这个  

285
00:09:53,556 --> 0:09:55,956
我们需要在构造函数中 

286
00:09:56,336 --> 0:09:57,236
创建 TCP 和 TLS 选项

287
00:09:57,966 --> 0:09:59,666
从 TLS 开始

288
00:10:01,726 --> 0:10:03,046
我们定义了一个函数

289
00:10:03,046 --> 0:10:04,266
它创建了 TLS 选项

290
00:10:04,476 --> 0:10:06,126
密码做好了

291
00:10:06,126 --> 0:10:07,076
现在我们只是

292
00:10:07,076 --> 0:10:08,226
默认 TLS 选项

293
00:10:09,656 --> 0:10:11,786
接下来 我们用新的 CryptoKit 框架

294
00:10:11,786 --> 0:10:12,976
这个框架今年刚出的

295
00:10:12,976 --> 0:10:14,586
从那个密码中 

296
00:10:14,586 --> 0:10:20,656
生成一个验证密钥和验证码

297
00:10:20,776 --> 0:10:22,326
把那个预共享密码

298
00:10:22,326 --> 0:10:24,066
添加到设置协议选项

299
00:10:24,266 --> 0:10:25,556
还要确保添加一个

300
00:10:25,556 --> 0:10:27,186
TLS 密钥算法套件 

301
00:10:27,186 --> 0:10:28,236
用来支持预共享密码

302
00:10:28,816 --> 0:10:31,716
现在可以回到 TLS 选项

303
00:10:32,266 --> 0:10:35,836
在这儿我们可以做 TCP 选项

304
00:10:38,456 --> 0:10:40,146
大部分情况下

305
00:10:40,146 --> 0:10:41,276
我们会用默认 TCP 选项

306
00:10:41,276 --> 0:10:41,966
但是也要保证 enableKeepalive 为真

307
00:10:43,186 --> 0:10:45,026
接着我们用 

308
00:10:45,026 --> 0:10:46,276
刚才在下面创建的 TLS 选项

309
00:10:46,276 --> 0:10:47,966
和基本上是默认的 TCP 选项

310
00:10:47,966 --> 0:10:51,396
初始化 NWParameters

311
00:10:51,516 --> 0:10:52,656
最后一件要做的事是

312
00:10:52,656 --> 0:10:55,786
在这里设置 includePeerToPeer

313
00:10:55,786 --> 0:10:57,486
这样即便不在同一个网络

314
00:10:57,486 --> 0:11:00,006
我们的连接和监听器

315
00:10:57,486 --> 0:11:00,006
我们的连接和监听器

316
00:11:00,006 --> 0:11:01,976
也可以连接到附近设备

317
00:11:02,506 --> 0:11:07,546
就是这样 我们试一下

318
00:11:07,756 --> 0:11:10,276
这里 可以看到有两台设备

319
00:11:10,586 --> 0:11:11,966
正在运行 App

320
00:11:11,966 --> 0:11:13,856
我们已经准备好 UI 创建游戏了

321
00:11:14,416 --> 0:11:17,236
浏览器已经开始搜索

322
00:11:17,236 --> 0:11:18,476
正显示 搜索游戏中

323
00:11:18,476 --> 0:11:20,266
因为我们还没找到游戏

324
00:11:21,276 --> 0:11:23,106
如果我输入名字   

325
00:11:24,376 --> 0:11:26,516
点按创建游戏 你可以看到

326
00:11:26,596 --> 0:11:28,316
我拿到了一个密码

327
00:11:28,316 --> 0:11:29,726
通过发现的端点列表

328
00:11:29,726 --> 0:11:31,396
在这里是我创建的游戏

329
00:11:31,396 --> 0:11:34,296
browseResultsChangedHandler 被调用

330
00:11:34,516 --> 0:11:35,806
我们把界面展示给用户

331
00:11:36,116 --> 0:11:36,716
就是这么简单

332
00:11:37,316 --> 0:11:41,526
如果我点按加入游戏

333
00:11:41,526 --> 0:11:45,526
就会显示输入密码

334
00:11:45,526 --> 0:11:47,386
现在我确认密码

335
00:11:47,806 --> 0:11:49,276
可以看到我们创建了

336
00:11:49,276 --> 0:11:51,166
一个预共享密码

337
00:11:51,166 --> 0:11:52,276
用它回连到监听器

338
00:11:52,746 --> 0:11:54,366
一切正常的话 页面翻转

339
00:11:54,366 --> 0:11:57,036
游戏就可以玩了 就是这样

340
00:11:58,516 --> 0:12:01,500
[掌声]

341
00:11:58,516 --> 0:12:01,500
[掌声]

342
00:12:08,236 --> 0:12:09,756
到现在为止 

343
00:12:09,756 --> 0:12:11,426
我们已经搭建了 App 的开头

344
00:12:11,426 --> 0:12:13,646
在两个设备间建立了连接

345
00:12:14,386 --> 0:12:15,846
我们用 NWListener 

346
00:12:15,846 --> 0:12:17,276
发布一个 Bonjour 

347
00:12:17,316 --> 0:12:18,246
_tictactoe._tcp 服务

348
00:12:18,246 --> 0:12:21,856
用 NWBrowser 

349
00:12:21,856 --> 0:12:24,016
搜索可玩的游戏 展示给用户

350
00:12:24,456 --> 0:12:25,866
我们可以选取一个结果

351
00:12:25,866 --> 0:12:27,236
从浏览器返回

352
00:12:27,236 --> 0:12:29,186
直接传送给 NWConnection

353
00:12:29,186 --> 0:12:30,956
回连到监听器

354
00:12:30,996 --> 0:12:32,346
在两个设备之间

355
00:12:32,346 --> 0:12:34,546
建立一个安全的连接

356
00:12:35,596 --> 0:12:36,816
当然 为了玩游戏

357
00:12:36,816 --> 0:12:38,336
两个设备要能交流

358
00:12:38,336 --> 0:12:39,446
分享游戏状态 

359
00:12:39,686 --> 0:12:42,666
告诉彼此玩家们的操作

360
00:12:42,666 --> 0:12:44,456
诸如此类

361
00:12:45,276 --> 0:12:46,726
要演示这一点

362
00:12:46,726 --> 0:12:48,216
我想请 Tommy 上台

363
00:12:48,216 --> 0:12:50,466
带大家搭建自定义框架协议

364
00:12:51,516 --> 0:12:56,316
[掌声]

365
00:12:56,816 --> 0:12:57,556
&gt;&gt; 好的

366
00:12:57,556 --> 0:12:58,786
谢谢你 Eric

367
00:12:59,796 --> 0:13:01,416
今天 我想给大家分享 

368
00:12:59,796 --> 0:13:01,416
今天 我想给大家分享 

369
00:13:01,466 --> 0:13:04,006
一些新的方法

370
00:13:04,006 --> 0:13:05,846
可以用你写的

371
00:13:05,846 --> 0:13:08,786
自定义协议框架代码

372
00:13:08,786 --> 0:13:10,776
来扩展网络连接  

373
00:13:10,776 --> 0:13:12,916
它和网络栈的

374
00:13:12,916 --> 0:13:13,956
其他协议一样

375
00:13:13,956 --> 0:13:15,706
在同一线程上运行

376
00:13:16,116 --> 0:13:17,806
所以 要做完 Eric 

377
00:13:17,806 --> 0:13:19,666
开始做的那个游戏

378
00:13:19,666 --> 0:13:21,236
我们需要为两个游戏定义一个 

379
00:13:21,236 --> 0:13:23,236
互相发送指令的方法

380
00:13:23,856 --> 0:13:24,966
当一个玩家要操作时

381
00:13:24,966 --> 0:13:27,066
他需要给另一端发送消息

382
00:13:28,206 --> 0:13:30,386
这时我们就需要一个协议

383
00:13:30,966 --> 0:13:33,546
我们的协议

384
00:13:33,546 --> 0:13:34,276
看起来是这样的

385
00:13:34,836 --> 0:13:37,686
它是个简单的 类-长度-值

386
00:13:37,686 --> 0:13:38,996
也就是 TLV 协议

387
00:13:40,016 --> 0:13:42,196
类型占用 4 字节

388
00:13:42,196 --> 0:13:44,156
可能意味着走一步棋

389
00:13:44,936 --> 0:13:47,116
玩家想要把一个给定符号

390
00:13:47,116 --> 0:13:49,716
放在我们井字盘的给定位置

391
00:13:50,296 --> 0:13:52,796
长度也占用 4 字节

392
00:13:52,796 --> 0:13:54,626
声明其他消息

393
00:13:55,166 --> 0:13:58,726
然后是消息体

394
00:13:59,086 --> 0:14:00,326
在我们的例子中

395
00:13:59,086 --> 0:14:00,326
在我们的例子中

396
00:14:00,436 --> 0:14:03,696
它可能是把猴子脸放在第 1 行第 2 列

397
00:14:04,506 --> 0:14:05,456
然后它会在 TLS 字节流上

398
00:14:05,456 --> 0:14:07,546
像这样重复

399
00:14:10,196 --> 0:14:11,706
你可能已经发现 

400
00:14:11,956 --> 0:14:13,906
尽管我们是在 

401
00:14:13,906 --> 0:14:15,736
TLS 字节流上运行的

402
00:14:15,736 --> 0:14:17,456
这个字节流本身没有被结构化

403
00:14:17,456 --> 0:14:20,946
但它在使用结构化消息

404
00:14:21,556 --> 0:14:25,026
App 并不是 以字节流的方式思考

405
00:14:25,026 --> 0:14:27,506
而是通过清晰的消息

406
00:14:28,696 --> 0:14:29,976
几乎所有的联网 App

407
00:14:29,976 --> 0:14:31,616
都会这么做

408
00:14:32,806 --> 0:14:34,666
它们有一个 Header 或 Body

409
00:14:34,666 --> 0:14:37,246
或分隔符

410
00:14:37,666 --> 0:14:40,336
用来定义消息的界限

411
00:14:41,756 --> 0:14:45,446
但是 传统通讯网络 API

412
00:14:45,446 --> 0:14:47,266
比如套接字

413
00:14:47,536 --> 0:14:49,986
读取连接上的消息

414
00:14:49,986 --> 0:14:52,336
并不简单

415
00:14:52,536 --> 0:14:53,586
你要在 App 中

416
00:14:53,586 --> 0:14:54,236
亲自做这件事

417
00:14:55,166 --> 0:14:57,436
在看这个问题之前  

418
00:14:57,466 --> 0:14:59,646
我们先来看一下

419
00:14:59,646 --> 0:15:03,526
你的 App 和其他网络栈的关系

420
00:14:59,646 --> 0:15:03,526
你的 App 和其他网络栈的关系

421
00:15:03,666 --> 0:15:06,006
上面是你的 App

422
00:15:07,186 --> 0:15:08,746
它通过 API

423
00:15:08,746 --> 0:15:10,586
和网络栈交流

424
00:15:11,806 --> 0:15:13,846
所以在 Network.framework 里

425
00:15:14,366 --> 0:15:18,086
TLS 和 TCP 都在 App 的

426
00:15:18,086 --> 0:15:20,936
同一共享线程里运行

427
00:15:21,346 --> 0:15:22,486
这就是我们去年介绍的

428
00:15:22,486 --> 0:15:24,706
用户空间网络栈

429
00:15:25,786 --> 0:15:27,896
让我们近距离看一下

430
00:15:27,896 --> 0:15:30,266
当 App 在一个字节流上方时

431
00:15:30,266 --> 0:15:33,196
是如何读取信息的

432
00:15:33,376 --> 0:15:34,916
如果我们有一个协议

433
00:15:34,916 --> 0:15:36,146
和刚才井字游戏一样的协议

434
00:15:36,146 --> 0:15:39,086
那你可能有一个固定长度的 Header

435
00:15:39,796 --> 0:15:41,056
这里你可以简单地

436
00:15:41,056 --> 0:15:44,186
准确读取 Header 的长度

437
00:15:45,246 --> 0:15:46,336
收到 8 个字节

438
00:15:47,236 --> 0:15:48,286
所以是固定长度

439
00:15:48,286 --> 0:15:49,266
你知道会发生什么

440
00:15:49,796 --> 0:15:51,456
当你读取完整长度时

441
00:15:51,456 --> 0:15:52,716
栈会回调你 

442
00:15:53,396 --> 0:15:55,156
这就让你可以确定

443
00:15:55,156 --> 0:15:56,436
剩余消息的长度

444
00:15:56,786 --> 0:15:58,776
你可以准确读取

445
00:15:58,776 --> 0:16:00,216
然后读取 Header-Body-Header-Body

446
00:15:58,776 --> 0:16:00,216
然后读取 Header-Body-Header-Body

447
00:16:00,216 --> 0:16:03,296
如此循环往复

448
00:16:03,826 --> 0:16:07,796
这很棒

449
00:16:07,796 --> 0:16:08,966
但是你可能已经注意到

450
00:16:08,966 --> 0:16:10,816
我们要循环多次 

451
00:16:10,816 --> 0:16:13,226
每条消息至少循环两次

452
00:16:13,776 --> 0:16:15,356
如果你的协议更复杂

453
00:16:15,356 --> 0:16:16,896
如果是一个

454
00:16:16,896 --> 0:16:18,936
可变长度 Header 

455
00:16:18,936 --> 0:16:20,576
或者如果是分隔符 

456
00:16:20,576 --> 0:16:22,226
这甚至会变得更没效率

457
00:16:22,726 --> 0:16:23,876
尽管对于你的 App 来说

458
00:16:23,876 --> 0:16:25,786
写这个逻辑很简单

459
00:16:27,056 --> 0:16:28,716
如果你特别重视效率

460
00:16:28,716 --> 0:16:30,206
你有另一个选择

461
00:16:30,836 --> 0:16:33,436
你可以一次接收很多内容

462
00:16:34,176 --> 0:16:35,936
但是现在

463
00:16:35,936 --> 0:16:36,906
你有其他几个问题要处理

464
00:16:37,766 --> 0:16:39,506
首次 你要解决

465
00:16:39,506 --> 0:16:40,716
没能在一个数据块里

466
00:16:40,716 --> 0:16:42,396
接收一条完整消息

467
00:16:43,226 --> 0:16:44,476
或者你在一口气

468
00:16:44,476 --> 0:16:46,856
接收了几条消息

469
00:16:46,856 --> 0:16:48,976
或者你只接收了 Header 的一部分

470
00:16:48,976 --> 0:16:51,936
或者你只有长度域的两三个字节

471
00:16:51,936 --> 0:16:53,186
你需要保存

472
00:16:53,186 --> 0:16:55,796
重建域 然后重新解析出来

473
00:16:56,926 --> 0:16:58,876
要做到完全正确

474
00:16:58,876 --> 0:17:00,356
处理好每一种可能的特殊情况

475
00:16:58,876 --> 0:17:00,356
处理好每一种可能的特殊情况

476
00:17:00,356 --> 0:17:02,776
是非常困难的

477
00:17:03,186 --> 0:17:04,486
情况通常是这样的

478
00:17:04,486 --> 0:17:06,256
一些小的 Bug

479
00:17:06,256 --> 0:17:07,656
只有在用户使用 App 的时候

480
00:17:07,656 --> 0:17:08,685
才会显现出来

481
00:17:10,756 --> 0:17:14,106
好 情况看起来有些不妙

482
00:17:14,506 --> 0:17:16,695
如何才能两全呢

483
00:17:16,695 --> 0:17:18,786
如果能够既保证高效

484
00:17:18,786 --> 0:17:21,425
又保证代码简单

485
00:17:21,425 --> 0:17:23,256
易于验证和组合呢

486
00:17:24,056 --> 0:17:25,915
我很高兴能分享给大家一个消息

487
00:17:25,915 --> 0:17:28,215
现在 在 iOS 13 和 macOS Catalina

488
00:17:28,215 --> 0:17:29,986
你可以自己写

489
00:17:29,986 --> 0:17:32,226
在同一网络线程上运行的

490
00:17:32,756 --> 0:17:35,986
协议代码 来解决这个问题

491
00:17:36,376 --> 0:17:38,116
所以如果你要在

492
00:17:38,116 --> 0:17:39,916
通信网络 API 里定义消息

493
00:17:39,916 --> 0:17:41,446
这个方法 

494
00:17:41,446 --> 0:17:43,796
让这件事变得

495
00:17:43,796 --> 0:17:44,976
前所未有得简单

496
00:17:44,976 --> 0:17:45,706
[掌声]

497
00:17:45,706 --> 0:17:51,386
谢谢 你要在 NWConnection 里

498
00:17:51,386 --> 0:17:52,926
做这些事情

499
00:17:53,086 --> 0:17:54,546
对于上方的 App 来说

500
00:17:54,546 --> 0:17:56,126
你好像只是

501
00:17:56,126 --> 0:17:57,596
在基本连接上

502
00:17:57,596 --> 0:17:59,206
读写数据包一样

503
00:18:00,736 --> 0:18:02,356
现在我们来看一下

504
00:18:03,066 --> 0:18:04,116
这里依旧是 App 

505
00:18:04,166 --> 0:18:05,686
依旧在发送和接收

506
00:18:05,816 --> 0:18:07,456
但是现在你的框架代码

507
00:18:07,456 --> 0:18:09,556
正运行在

508
00:18:09,556 --> 0:18:11,736
和 TLS 和 TCP 相同的线程中

509
00:18:12,216 --> 0:18:13,146
所以现在你可以调用

510
00:18:13,886 --> 0:18:14,846
receiveMessage

511
00:18:15,226 --> 0:18:16,596
当你有一个

512
00:18:16,596 --> 0:18:17,626
App 可以处理的

513
00:18:17,976 --> 0:18:19,346
完整消息时

514
00:18:19,346 --> 0:18:20,966
它会准确地得到一个回调

515
00:18:21,596 --> 0:18:22,976
你可以多次重复这个过程

516
00:18:23,266 --> 0:18:25,466
每个消息一个调用

517
00:18:25,466 --> 0:18:27,246
调试就变得非常简单

518
00:18:27,246 --> 0:18:28,386
很容易就知道发生了什么

519
00:18:28,926 --> 0:18:31,696
所以 这很棒

520
00:18:31,866 --> 0:18:33,966
现在你可能会问

521
00:18:33,966 --> 0:18:35,916
这个框架协议

522
00:18:35,916 --> 0:18:38,796
可以真正实现些什么

523
00:18:38,796 --> 0:18:39,746
有什么限制

524
00:18:39,856 --> 0:18:42,076
好消息是 基本上所有

525
00:18:42,276 --> 0:18:43,786
数据包和编码 App 数据

526
00:18:43,786 --> 0:18:45,976
去传输数据的

527
00:18:45,976 --> 0:18:47,636
都可以被写为

528
00:18:48,176 --> 0:18:50,466
框架协议

529
00:18:51,146 --> 0:18:53,146
如果你进行一次握手   

530
00:18:53,146 --> 0:18:54,916
或者如果你想在连接上

531
00:18:55,026 --> 0:18:56,736
实现 KeepAlive 连接

532
00:18:56,736 --> 0:18:58,886
你甚至可以发送

533
00:18:59,076 --> 0:19:00,336
和 App 数据不对应的 

534
00:18:59,076 --> 0:19:00,336
和 App 数据不对应的 

535
00:19:00,376 --> 0:19:01,606
自己的消息

536
00:19:02,156 --> 0:19:04,436
你在这里实现的协议

537
00:19:04,436 --> 0:19:09,026
可以是标准 IETF 官方协议

538
00:19:09,616 --> 0:19:12,016
也可以是为你的 App 自定义的

539
00:19:12,066 --> 0:19:13,326
我们接下来就会给井字游戏

540
00:19:13,326 --> 0:19:14,226
做一个自定义的协议

541
00:19:15,096 --> 0:19:16,456
如果你想搭建一个协议

542
00:19:16,456 --> 0:19:17,776
需要两步

543
00:19:18,446 --> 0:19:21,116
首先 实现一条可重复使用的代码

544
00:19:21,116 --> 0:19:23,286
定义你的消息框架

545
00:19:23,836 --> 0:19:24,796
这是协议

546
00:19:25,716 --> 0:19:28,486
然后把这个协议

547
00:19:28,886 --> 0:19:30,776
添加到连接协议栈

548
00:19:30,776 --> 0:19:34,366
你就可以用它建立连接

549
00:19:34,366 --> 0:19:36,626
发送和接收消息

550
00:19:37,176 --> 0:19:40,786
好了 进入第一步

551
00:19:41,016 --> 0:19:41,596
我们开始实现

552
00:19:41,696 --> 0:19:43,446
框架协议

553
00:19:44,786 --> 0:19:47,096
你要做的是 创建一个类

554
00:19:47,096 --> 0:19:48,926
让它遵循

555
00:19:48,926 --> 0:19:51,066
ProtocolFramerImplementation

556
00:19:51,896 --> 0:19:54,166
你可以在这个类里做很多事情

557
00:19:55,136 --> 0:19:56,886
但是要记住 

558
00:19:56,886 --> 0:19:58,216
最重要的两件事是

559
00:19:58,216 --> 0:20:00,456
handleOutput 发送消息

560
00:19:58,216 --> 0:20:00,456
handleOutput 发送消息

561
00:20:00,786 --> 0:20:02,956
和 handleInput 解析消息

562
00:20:03,516 --> 0:20:04,926
如果你可以做到这两件事

563
00:20:05,256 --> 0:20:06,546
太好了 它就是一个 Framer 了

564
00:20:07,736 --> 0:20:08,806
让我们看一下代码

565
00:20:09,506 --> 0:20:11,636
这是协议

566
00:20:12,266 --> 0:20:13,486
它要遵循

567
00:20:13,486 --> 0:20:15,276
ProtocolFramerImplementation

568
00:20:16,526 --> 0:20:21,346
我推荐你先创建一个定义对象

569
00:20:21,446 --> 0:20:23,476
这是你协议的句柄

570
00:20:23,476 --> 0:20:25,046
你可以在整个 App 的其他部分

571
00:20:25,366 --> 0:20:26,476
使用这个句柄

572
00:20:27,096 --> 0:20:28,826
它指的是

573
00:20:28,826 --> 0:20:30,166
你可以添加到连接的协议

574
00:20:30,626 --> 0:20:34,106
接下来你可以处理很多的

575
00:20:34,106 --> 0:20:36,156
基本回调事件

576
00:20:36,626 --> 0:20:39,226
这里最重要的是 start

577
00:20:39,576 --> 0:20:41,576
每当协议载入到连接时 

578
00:20:41,576 --> 0:20:43,436
start 都会被调用 

579
00:20:43,436 --> 0:20:46,286
用来发起连接

580
00:20:47,036 --> 0:20:48,706
如果你想做一个握手

581
00:20:48,706 --> 0:20:49,806
和另一端交换什么东西

582
00:20:49,806 --> 0:20:51,726
你可以在这里实现

583
00:20:52,626 --> 0:20:54,636
如果你的协议很简单  

584
00:20:54,636 --> 0:20:55,916
像我们的井字游戏一样

585
00:20:56,016 --> 0:20:57,386
不需要设置

586
00:20:57,726 --> 0:20:59,636
只需立刻标记连接就绪

587
00:21:00,896 --> 0:21:02,806
一旦你做了这个

588
00:21:02,806 --> 0:21:05,356
现在你需要 handleOutput 和 handleInput

589
00:21:05,686 --> 0:21:06,796
我们深入来看一下

590
00:21:09,196 --> 0:21:11,666
handleOutput 看起来这样

591
00:21:12,416 --> 0:21:13,316
每当 App 发送消息时 

592
00:21:13,316 --> 0:21:16,036
你就会被

593
00:21:16,036 --> 0:21:17,966
handleOutput 调用

594
00:21:18,546 --> 0:21:19,906
如果你需要的话

595
00:21:19,906 --> 0:21:22,116
你会收到消息元数据

596
00:21:22,116 --> 0:21:25,036
还有一些自定义值

597
00:21:25,036 --> 0:21:26,106
以及 App 正尝试发送的

598
00:21:26,106 --> 0:21:27,356
消息长度

599
00:21:27,986 --> 0:21:31,016
所以 如果你有一个

600
00:21:31,016 --> 0:21:32,626
Header-Body 协议 就像我们刚才用的

601
00:21:33,686 --> 0:21:35,886
你可以先创建 Header 结构

602
00:21:35,886 --> 0:21:38,666
试着序列化一些数据

603
00:21:39,686 --> 0:21:41,266
所以这会包括类型

604
00:21:41,846 --> 0:21:42,836
也许是从消息元数据中

605
00:21:42,836 --> 0:21:44,666
得到的类型

606
00:21:44,666 --> 0:21:47,166
还有传送给你

607
00:21:47,166 --> 0:21:48,036
到 handleOutput 的长度

608
00:21:48,476 --> 0:21:51,086
你可以组合这些数据

609
00:21:51,086 --> 0:21:52,466
然后调用 writeOutput

610
00:21:52,896 --> 0:21:54,656
writeOutput 会将字节

611
00:21:54,656 --> 0:21:56,506
排列到输出流

612
00:21:56,876 --> 0:22:00,706
但是实际上它们还没有发出去

613
00:21:56,876 --> 0:22:00,706
但是实际上它们还没有发出去

614
00:22:00,986 --> 0:22:03,086
然后你需要写主体

615
00:22:03,226 --> 0:22:04,876
在这个例子中 

616
00:22:04,876 --> 0:22:06,916
我们完全不需要转存 App 数据

617
00:22:07,316 --> 0:22:09,876
我们可以只调用 writeOutputNoCopy

618
00:22:11,086 --> 0:22:13,236
它让我们直接

619
00:22:13,236 --> 0:22:15,686
将 App 字节排列到输出流

620
00:22:16,496 --> 0:22:17,476
当我们从 handleOutput 返回时

621
00:22:17,476 --> 0:22:20,116
所有的字节都会被

622
00:22:20,166 --> 0:22:21,536
发送出去连接

623
00:22:22,016 --> 0:22:25,636
好了 我们接着处理输入

624
00:22:26,416 --> 0:22:28,606
处理输入和处理输出类似

625
00:22:28,606 --> 0:22:29,806
但是略微复杂

626
00:22:30,856 --> 0:22:36,806
每当你的 App 接收到连接上的新字节时

627
00:22:36,806 --> 0:22:37,896
你会被 handleInput 调用

628
00:22:38,506 --> 0:22:40,346
如果你做的是 

629
00:22:40,496 --> 0:22:42,956
Header-Body 类型协议 你有两件事要做

630
00:22:42,956 --> 0:22:45,206
你需要解析 Header

631
00:22:45,206 --> 0:22:46,306
然后你需要解析 Body

632
00:22:46,966 --> 0:22:48,756
我们先解析 Header

633
00:22:49,376 --> 0:22:50,986
这儿 我们的协议有一个

634
00:22:50,986 --> 0:22:52,036
固定长度的 Header

635
00:22:52,036 --> 0:22:53,726
正好是 8 个字节

636
00:22:54,216 --> 0:22:55,526
我们做的是

637
00:22:55,606 --> 0:22:57,436
调用 parseInput 开始检查

638
00:22:57,436 --> 0:22:59,486
已经进入连接的字节流

639
00:23:00,406 --> 0:23:03,556
我们可以用最小和最大 8 字节调用它

640
00:23:03,586 --> 0:23:05,026
因为我们希望准确查看

641
00:23:05,026 --> 0:23:05,826
8 字节 Header

642
00:23:06,456 --> 0:23:09,076
如果成功了

643
00:23:09,076 --> 0:23:10,796
你会在组块里被调用

644
00:23:10,796 --> 0:23:12,066
你能看到真正的缓冲字节

645
00:23:12,066 --> 0:23:13,826
解析你的值

646
00:23:13,826 --> 0:23:15,796
如果需要的话 

647
00:23:15,796 --> 0:23:17,576
将它们存到本地变量

648
00:23:18,156 --> 0:23:20,706
解析输入的返回值

649
00:23:21,416 --> 0:23:22,786
表示你想用多少字节 

650
00:23:22,786 --> 0:23:25,086
增量输入光标 

651
00:23:25,186 --> 0:23:27,846
我处理完了这 8 个字节

652
00:23:27,916 --> 0:23:29,046
我们不需要再看到它们了

653
00:23:29,046 --> 0:23:30,896
不需要将它们传送给 App

654
00:23:31,306 --> 0:23:34,936
继续 现在你可以处理

655
00:23:34,936 --> 0:23:36,986
不是所有的 8 个字节

656
00:23:36,986 --> 0:23:37,806
都可用的情况

657
00:23:38,296 --> 0:23:41,346
在这种情况下 

658
00:23:41,416 --> 0:23:43,416
parseInput 函数会失效

659
00:23:43,506 --> 0:23:45,936
你只需等待更多字节可用

660
00:23:46,726 --> 0:23:48,616
handleInput 的返回值表明

661
00:23:48,616 --> 0:23:52,786
要有足够的字节数量

662
00:23:52,786 --> 0:23:54,546
然后你才能做更多工作

663
00:23:54,976 --> 0:23:56,476
所以在这个例子中

664
00:23:56,476 --> 0:23:57,796
我们是在告诉连接 

665
00:23:57,796 --> 0:23:59,496
在你再次唤醒我之前

666
00:23:59,496 --> 0:24:01,376
确保有 8 个字节

667
00:23:59,496 --> 0:24:01,376
确保有 8 个字节

668
00:24:01,556 --> 0:24:06,706
如果你能成功读出 Header

669
00:24:06,706 --> 0:24:09,426
你可以创建一个消息对象

670
00:24:09,426 --> 0:24:10,276
可以和数据一起

671
00:24:10,276 --> 0:24:11,826
传送给 App

672
00:24:12,456 --> 0:24:14,796
这让你可以放入任何

673
00:24:14,796 --> 0:24:16,846
你想要发送到 App 的

674
00:24:16,896 --> 0:24:19,326
自定义值 类型 或其他指针

675
00:24:19,936 --> 0:24:23,766
最后 在这种情况下

676
00:24:23,766 --> 0:24:25,326
你可以调用 deliverInput 

677
00:24:25,326 --> 0:24:27,506
或者 deliverInputNoCopy 

678
00:24:28,096 --> 0:24:29,866
这可以让你将

679
00:24:29,866 --> 0:24:31,656
下一段确定范围的字节

680
00:24:31,656 --> 0:24:32,916
标记为应该

681
00:24:32,916 --> 0:24:35,186
直接传送给 App 的 App 数据

682
00:24:35,736 --> 0:24:39,086
它返回 Boolean 值

683
00:24:39,086 --> 0:24:41,446
去显示是不是 

684
00:24:41,446 --> 0:24:43,006
所有的字节都是可用的 

685
00:24:43,136 --> 0:24:45,296
是否成功发送

686
00:24:45,296 --> 0:24:46,656
连接需不需要再等

687
00:24:47,096 --> 0:24:48,766
所以如果你需要的话

688
00:24:48,766 --> 0:24:50,116
你真的可以

689
00:24:50,116 --> 0:24:51,506
传送输入消息

690
00:24:51,506 --> 0:24:53,476
兆甚至千兆字节长

691
00:24:53,476 --> 0:24:54,866
那些字节作为信息的一部分 

692
00:24:54,866 --> 0:24:56,336
会持续流出

693
00:24:56,336 --> 0:24:57,426
你无需等待所有的字节都可用

694
00:24:57,426 --> 0:24:59,956
或者亲自处理这些

695
00:25:02,466 --> 0:25:04,676
我知道代码很多

696
00:25:04,676 --> 0:25:06,176
但是我们马上就可以

697
00:25:06,176 --> 0:25:09,786
为井字游戏实施协议了

698
00:25:19,176 --> 0:25:22,546
好 这就是之前 

699
00:25:22,666 --> 0:25:24,076
Eric 做的游戏

700
00:25:24,906 --> 0:25:26,676
现在我要创建一个新类

701
00:25:26,816 --> 0:25:28,326
命名为游戏协议

702
00:25:28,396 --> 0:25:31,766
它会遵循 NWProtocolFramerImplementation

703
00:25:32,266 --> 0:25:34,786
我已经为这个游戏定义了

704
00:25:34,786 --> 0:25:36,616
两个不同的类型

705
00:25:36,616 --> 0:25:37,836
我想要发送两个

706
00:25:37,836 --> 0:25:38,726
不同的指令

707
00:25:39,696 --> 0:25:41,336
一个是选择角色

708
00:25:41,826 --> 0:25:43,826
游戏的第一步是

709
00:25:43,826 --> 0:25:45,176
玩家需要选择 

710
00:25:45,276 --> 0:25:46,976
他们想用哪个表情符号

711
00:25:46,976 --> 0:25:48,726
他们想当猴子还是当鸟

712
00:25:49,986 --> 0:25:53,566
然当玩家选择了他们的角色后

713
00:25:53,566 --> 0:25:55,216
就开始发送走棋操作

714
00:25:55,516 --> 0:25:57,006
这就会变成更长的 Body

715
00:25:57,006 --> 0:26:02,026
它会包括角色和行 列值

716
00:25:57,006 --> 0:26:02,026
它会包括角色和行 列值

717
00:26:03,996 --> 0:26:06,826
好 我记得 

718
00:26:06,826 --> 0:26:07,936
当我实施协议时 

719
00:26:07,936 --> 0:26:10,836
我要做的第一件事就是

720
00:26:11,046 --> 0:26:12,126
创建一个定义

721
00:26:12,126 --> 0:26:15,446
这是基于我的对象的句柄

722
00:26:15,446 --> 0:26:17,846
它在系统中注册对象

723
00:26:17,896 --> 0:26:21,796
让我可以在连接中使用这个

724
00:26:26,476 --> 0:26:29,226
接下来 我要处理所有的基本回调

725
00:26:29,576 --> 0:26:30,876
这里再一次

726
00:26:30,876 --> 0:26:32,646
因为我不需要自己的握手

727
00:26:32,926 --> 0:26:34,456
当我被启动调用时

728
00:26:35,026 --> 0:26:37,806
我可以返回一个就绪的启动结果

729
00:26:40,026 --> 0:26:42,246
接着 我们来处理

730
00:26:42,246 --> 0:26:43,796
发送和打包消息

731
00:26:47,616 --> 0:26:49,696
我将在这里定义

732
00:26:49,696 --> 0:26:51,296
handleOutput 的实现

733
00:26:55,696 --> 0:26:58,416
所以头部是一个 8 字节 Header

734
00:26:58,666 --> 0:27:00,436
包括一个类型和长度

735
00:26:58,666 --> 0:27:00,436
包括一个类型和长度

736
00:27:00,626 --> 0:27:02,366
首先我要知道我的类型是什么

737
00:27:02,366 --> 0:27:04,786
我从 App 发送的消息中

738
00:27:04,786 --> 0:27:06,636
得知类型

739
00:27:06,636 --> 0:27:08,426
我们稍后会看这个

740
00:27:08,926 --> 0:27:12,376
我已经给 framer 消息

741
00:27:12,376 --> 0:27:14,386
创建了一个自定义扩展 

742
00:27:14,426 --> 0:27:16,456
用来提取特定枚举类型

743
00:27:16,886 --> 0:27:18,646
这样我就可以知道

744
00:27:18,686 --> 0:27:20,356
是选棋还是走棋

745
00:27:21,096 --> 0:27:22,896
有了类型

746
00:27:22,896 --> 0:27:25,426
我就可以在 handleOutput  中

747
00:27:25,426 --> 0:27:27,126
通过传输的类型和长度

748
00:27:27,906 --> 0:27:29,956
实例化我的结构

749
00:27:29,956 --> 0:27:30,796
我的游戏协议 Header 

750
00:27:32,096 --> 0:27:33,736
我已经写了代码

751
00:27:34,096 --> 0:27:35,776
编码那份

752
00:27:35,776 --> 0:27:38,286
类型和长度为 

753
00:27:38,476 --> 0:27:39,466
8 字节范围的数据

754
00:27:39,786 --> 0:27:42,006
我调用 writeOutput 

755
00:27:42,006 --> 0:27:43,356
把那个数据加入到输出流队列中

756
00:27:43,856 --> 0:27:47,676
现在我要做最后一件事

757
00:27:47,706 --> 0:27:48,896
既然我已经写了 Header

758
00:27:49,116 --> 0:27:50,516
现在就要写 Body

759
00:27:50,986 --> 0:27:51,846
这里我只需调用

760
00:27:51,846 --> 0:27:53,606
writeOutputNoCopy 

761
00:27:53,606 --> 0:27:55,956
表明下一个宽度的字节 

762
00:27:55,956 --> 0:27:57,516
是这个消息的 Body

763
00:27:58,736 --> 0:28:00,256
一旦这个返回

764
00:27:58,736 --> 0:28:00,256
一旦这个返回

765
00:28:00,256 --> 0:28:01,586
这些字节就会被发送  

766
00:28:01,586 --> 0:28:03,306
我就可以处理更多的信息

767
00:28:03,306 --> 0:28:04,086
不论是输入还是输出

768
00:28:04,676 --> 0:28:08,656
好 写入就完成了

769
00:28:08,656 --> 0:28:10,746
现在来看读取 

770
00:28:10,746 --> 0:28:11,646
我要处理输入

771
00:28:14,536 --> 0:28:16,886
首先我要读出 

772
00:28:16,886 --> 0:28:17,676
解析 Header

773
00:28:18,126 --> 0:28:19,836
先是一个固定大小的 Header

774
00:28:20,066 --> 0:28:21,346
8 个字节

775
00:28:22,546 --> 0:28:24,486
我将尝试解析出

776
00:28:24,486 --> 0:28:26,696
最小 8 个字节 最大 8 个字节

777
00:28:26,696 --> 0:28:32,276
每当有 8 个字节可用时

778
00:28:32,276 --> 0:28:34,296
我都会被缓冲调用 

779
00:28:34,916 --> 0:28:37,156
这里我确认

780
00:28:37,156 --> 0:28:39,196
缓冲是有效的

781
00:28:39,196 --> 0:28:42,296
然后创建结构 

782
00:28:42,296 --> 0:28:44,776
将那 8 个字节解析为类型和长度域

783
00:28:46,716 --> 0:28:47,746
一旦这一步成功了

784
00:28:47,746 --> 0:28:51,996
就表明我想用 8 个字节增量光标

785
00:28:52,056 --> 0:28:54,166
说明我已经使用了这些字节

786
00:28:54,276 --> 0:28:59,036
这些字节没用了

787
00:28:59,256 --> 0:29:01,236
现在我同样需要处理

788
00:28:59,256 --> 0:29:01,236
现在我同样需要处理

789
00:29:01,236 --> 0:29:02,746
没有成功解析

790
00:29:02,746 --> 0:29:04,596
所有 8 个字节的情况

791
00:29:04,786 --> 0:29:06,596
可能只有 5 个字节是可用的

792
00:29:07,636 --> 0:29:08,876
所以解析失败

793
00:29:09,436 --> 0:29:10,926
我将从处理输入返回

794
00:29:10,926 --> 0:29:13,726
表明我需要

795
00:29:13,726 --> 0:29:15,246
等待 8 个字节可用

796
00:29:15,246 --> 0:29:18,166
然后才能继续

797
00:29:18,716 --> 0:29:20,026
但是如果我真的过了这一步

798
00:29:20,066 --> 0:29:21,786
我就知道 Header 是有效的

799
00:29:21,786 --> 0:29:23,886
我可以用它

800
00:29:23,886 --> 0:29:25,976
传送剩余的 App 数据

801
00:29:29,756 --> 0:29:32,516
所以现在我要创建一个信息对象

802
00:29:32,806 --> 0:29:34,326
我要将我的特定消息类型

803
00:29:34,326 --> 0:29:37,986
存储在那个消息对象中

804
00:29:40,176 --> 0:29:44,066
最后我会调用

805
00:29:44,066 --> 0:29:47,006
deliverInputNoCopy

806
00:29:47,006 --> 0:29:48,976
直接告诉连接

807
00:29:48,976 --> 0:29:50,706
接下来的那些

808
00:29:50,746 --> 0:29:53,506
每当有 是 App 数据

809
00:29:53,506 --> 0:29:55,256
当你的 App 收到消息时

810
00:29:55,256 --> 0:29:56,586
它们会准确接收到

811
00:29:56,586 --> 0:29:58,106
那个组块

812
00:29:59,026 --> 0:30:00,266
这就是我要做的

813
00:29:59,026 --> 0:30:00,266
这就是我要做的

814
00:30:00,396 --> 0:30:01,606
这就是完整的协议

815
00:30:01,606 --> 0:30:04,236
接下来我会介绍

816
00:30:04,346 --> 0:30:05,846
如何初始化 把它输入到游戏连接中去

817
00:30:09,181 --> 0:30:11,181
[掌声]

818
00:30:11,346 --> 0:30:16,706
好 好消息是

819
00:30:16,706 --> 0:30:17,826
这部分比较简单

820
00:30:18,516 --> 0:30:21,116
要把协议添加到连接 并重复使用它 

821
00:30:21,116 --> 0:30:23,966
你只需要选取

822
00:30:23,966 --> 0:30:25,426
之前做的定义

823
00:30:26,316 --> 0:30:28,306
用那个定义

824
00:30:28,396 --> 0:30:29,516
创建一些协议选项

825
00:30:30,016 --> 0:30:32,426
协议选项

826
00:30:32,476 --> 0:30:34,426
是协议栈的组成部分

827
00:30:35,036 --> 0:30:38,546
有 TCP 选项 TLS 选项 

828
00:30:38,546 --> 0:30:40,396
现在有自己的自定义协议选项

829
00:30:41,036 --> 0:30:42,576
当你为连接

830
00:30:42,576 --> 0:30:43,816
创建 parameters 时

831
00:30:43,996 --> 0:30:45,766
比如说你在用 TLS 

832
00:30:45,766 --> 0:30:46,946
因为它可以确保通信安全

833
00:30:48,226 --> 0:30:50,806
以及协议栈里的 TLS 

834
00:30:50,806 --> 0:30:53,096
你可以直接

835
00:30:53,096 --> 0:30:54,446
将自己的协议

836
00:30:54,446 --> 0:30:56,926
添加到 applicationProtocols 数组的顶部

837
00:30:57,696 --> 0:30:58,736
你可以添加多个

838
00:30:58,736 --> 0:31:01,406
运行多层框架

839
00:30:58,736 --> 0:31:01,406
运行多层框架

840
00:31:02,046 --> 0:31:03,206
如果你想用 WebSocket

841
00:31:03,206 --> 0:31:04,806
也是在这个地方

842
00:31:05,346 --> 0:31:06,676
WebSocket 是一个今年

843
00:31:06,676 --> 0:31:07,996
新的系统实施

844
00:31:07,996 --> 0:31:10,496
你可以将它添加到你的连接

845
00:31:11,886 --> 0:31:14,586
WebSocket 本身

846
00:31:14,766 --> 0:31:16,976
作为协议框架被实施

847
00:31:17,266 --> 0:31:19,226
和你现在可用的

848
00:31:19,556 --> 0:31:21,036
使用的相同的 API

849
00:31:21,356 --> 0:31:22,506
它向你展示了

850
00:31:22,506 --> 0:31:25,006
一个框架协议有多强大

851
00:31:25,736 --> 0:31:27,556
如果你不想自己写

852
00:31:27,556 --> 0:31:29,386
那你可以用 WebSocket

853
00:31:33,546 --> 0:31:34,726
在这里我想说的是

854
00:31:34,726 --> 0:31:36,666
一些 App  

855
00:31:36,666 --> 0:31:38,926
在不同的情况下

856
00:31:39,256 --> 0:31:40,456
需要使用不同的协议栈

857
00:31:41,366 --> 0:31:43,156
框架协议真的是一个

858
00:31:43,156 --> 0:31:46,136
在 App 和网络连接之间

859
00:31:46,136 --> 0:31:47,436
建立合约的好方法

860
00:31:47,436 --> 0:31:48,806
即便你在使用 

861
00:31:48,806 --> 0:31:51,006
不同的协议栈

862
00:31:51,006 --> 0:31:52,596
依旧如此

863
00:31:53,466 --> 0:31:54,916
为给大家举个例子

864
00:31:54,916 --> 0:31:58,026
我们在 DNS 系统上使用这个

865
00:31:58,936 --> 0:32:01,506
DNS 通常通过 UDP

866
00:31:58,936 --> 0:32:01,506
DNS 通常通过 UDP

867
00:32:01,506 --> 0:32:04,206
发送数据包消息

868
00:32:05,876 --> 0:32:08,306
但是偶尔 DNS 会和 TCP 一样 

869
00:32:08,306 --> 0:32:10,736
需要在流的上端运行

870
00:32:11,236 --> 0:32:12,846
当它这么做时 

871
00:32:12,846 --> 0:32:14,596
会有一个 Body 格式

872
00:32:14,596 --> 0:32:17,356
它只有一个非常基本的长度

873
00:32:17,356 --> 0:32:19,726
用 TCP 编码 DNS 

874
00:32:20,726 --> 0:32:23,206
所以我们写了一个 framer

875
00:32:23,206 --> 0:32:26,216
用来定义这个简单的数据包

876
00:32:26,216 --> 0:32:28,106
这样在上方就有相同的代码

877
00:32:28,106 --> 0:32:32,716
发送 DNS 数据包不需要考虑

878
00:32:32,716 --> 0:32:34,626
它用的是 UDP 还是 TCP 

879
00:32:34,626 --> 0:32:36,876
它是同样的逻辑

880
00:32:37,396 --> 0:32:40,676
这样你就无需担心太多

881
00:32:40,676 --> 0:32:41,946
可以分开调试

882
00:32:41,946 --> 0:32:43,196
App 的不同部分

883
00:32:43,766 --> 0:32:47,506
我们已经将框架协议

884
00:32:47,506 --> 0:32:48,776
添加到连接

885
00:32:48,776 --> 0:32:50,706
现在准备发送和接收消息

886
00:32:50,706 --> 0:32:52,306
我们可以使用自定义值 

887
00:32:52,306 --> 0:32:55,086
接下来我们就会在游戏里

888
00:32:55,086 --> 0:32:56,166
用自定义值

889
00:32:57,476 --> 0:33:00,256
Framer.Message 

890
00:32:57,476 --> 0:33:00,256
Framer.Message 

891
00:33:00,256 --> 0:33:02,896
让你可以存储

892
00:33:02,896 --> 0:33:05,436
任何对象类型的键值对

893
00:33:05,436 --> 0:33:07,366
所以你可以添加到自定义值

894
00:33:07,886 --> 0:33:10,586
去修饰你的发送操作

895
00:33:10,586 --> 0:33:12,646
接收协议的消息

896
00:33:13,586 --> 0:33:15,416
你可以创建一条消息

897
00:33:15,486 --> 0:33:16,906
按你喜欢的方式设置好它

898
00:33:16,906 --> 0:33:18,516
将它发送到

899
00:33:18,546 --> 0:33:22,126
你正在传送数据的上下文上

900
00:33:22,676 --> 0:33:25,006
所以每个发送操作 

901
00:33:25,006 --> 0:33:28,186
都已经有了内容和上下文

902
00:33:28,526 --> 0:33:31,396
上下文会描述你想要如何发送数据

903
00:33:31,856 --> 0:33:33,546
Framer.Message 只是

904
00:33:33,546 --> 0:33:37,096
发送数据的新方式

905
00:33:37,276 --> 0:33:38,936
接收也很相似

906
00:33:39,046 --> 0:33:40,936
当调用 receiveMessage 时

907
00:33:41,776 --> 0:33:43,196
在接收内容的同时

908
00:33:43,196 --> 0:33:44,936
还能接收到上下文

909
00:33:44,936 --> 0:33:47,276
它用来描述数据是如何被接收的

910
00:33:48,056 --> 0:33:49,746
你可以用协议的定义

911
00:33:49,746 --> 0:33:52,026
查看协议 framer 

912
00:33:52,126 --> 0:33:57,116
上下文会描述特定消息值

913
00:33:58,006 --> 0:34:00,786
接下来我们就要

914
00:33:58,006 --> 0:34:00,786
接下来我们就要

915
00:34:00,936 --> 0:34:04,556
完成这个井字游戏了

916
00:34:05,316 --> 0:34:09,565
好 我们已经做好了游戏协议

917
00:34:10,206 --> 0:34:12,985
要把它加入到连接中

918
00:34:13,045 --> 0:34:17,025
我将返回 Eric 刚才设置的参数

919
00:34:17,025 --> 0:34:18,166
他已经用 TCP 和 TLS

920
00:34:18,166 --> 0:34:22,216
设置好了有密码的连接

921
00:34:24,106 --> 0:34:28,085
现在我要做的只是

922
00:34:28,085 --> 0:34:29,036
把这两行加进去

923
00:34:29,036 --> 0:34:32,286
我要基于游戏协议定义

924
00:34:32,286 --> 0:34:34,696
创建一些选项 

925
00:34:34,696 --> 0:34:36,485
将它们插入到

926
00:34:36,485 --> 0:34:38,716
我想要用在连接里的 App 协议数组

927
00:34:39,386 --> 0:34:41,036
现在当两设备间启动连接时

928
00:34:41,036 --> 0:34:42,396
它会准备就绪 

929
00:34:42,646 --> 0:34:46,616
在流上编码消息

930
00:34:47,096 --> 0:34:51,576
现在我要在连接中

931
00:34:51,576 --> 0:34:53,346
做几个便捷函数

932
00:34:53,346 --> 0:34:54,676
让 App 更简单地

933
00:34:54,746 --> 0:34:56,116
发送和接收

934
00:34:56,116 --> 0:34:58,786
自定义消息类型

935
00:34:59,836 --> 0:35:01,326
这里有一个连接对象

936
00:34:59,836 --> 0:35:01,326
这里有一个连接对象

937
00:35:01,326 --> 0:35:03,856
它用刚才

938
00:35:03,856 --> 0:35:05,646
定义的参数

939
00:35:05,646 --> 0:35:07,216
设置了一个 NWConnection

940
00:35:08,346 --> 0:35:09,726
每当连接就绪时

941
00:35:09,726 --> 0:35:11,326
它就开始从 peer

942
00:35:11,326 --> 0:35:13,786
接收消息

943
00:35:15,286 --> 0:35:16,746
我们需要接收下一个消息

944
00:35:16,746 --> 0:35:17,876
来实施这个

945
00:35:21,376 --> 0:35:23,316
我现在做的是

946
00:35:23,316 --> 0:35:24,776
获取连接 在连接上

947
00:35:24,776 --> 0:35:25,766
调用 receiveMessage 

948
00:35:26,716 --> 0:35:29,656
我将得到内容和上下文

949
00:35:30,516 --> 0:35:31,596
我将用上下文

950
00:35:31,596 --> 0:35:34,506
查看我的协议

951
00:35:34,506 --> 0:35:37,086
特定的元数据

952
00:35:37,086 --> 0:35:38,476
和游戏协议定义

953
00:35:39,516 --> 0:35:40,856
这会给我消息对象

954
00:35:40,856 --> 0:35:43,266
让我把消息类型

955
00:35:43,266 --> 0:35:44,986
和数据一起

956
00:35:44,986 --> 0:35:46,146
向上传送到 App 

957
00:35:47,116 --> 0:35:48,436
当然 接下来 如果我

958
00:35:48,436 --> 0:35:49,616
成功接收到一条消息

959
00:35:49,616 --> 0:35:51,136
我会调用 receiveNextMessage 

960
00:35:51,136 --> 0:35:53,236
再次重复这个过程

961
00:35:56,016 --> 0:35:57,676
我还要给发送

962
00:35:57,946 --> 0:35:59,236
定义一些 Helper

963
00:35:59,646 --> 0:36:01,096
所以每当 App 判定

964
00:35:59,646 --> 0:36:01,096
所以每当 App 判定

965
00:36:01,096 --> 0:36:02,206
玩家是在选择角色时

966
00:36:02,206 --> 0:36:04,466
我们可以创建一个消息

967
00:36:04,466 --> 0:36:07,716
将所选的角色作为类型

968
00:36:07,716 --> 0:36:09,306
添加到这个消息

969
00:36:10,096 --> 0:36:12,406
并将其发送到上下文中

970
00:36:12,916 --> 0:36:15,826
发送走棋操作

971
00:36:15,826 --> 0:36:16,816
也是这样的 

972
00:36:16,816 --> 0:36:18,486
在这里创建一个便捷函数 

973
00:36:18,486 --> 0:36:20,106
声明我想发送走棋操作

974
00:36:20,106 --> 0:36:21,846
然后只需获取 App 数据

975
00:36:22,316 --> 0:36:23,556
将它向下传送给连接

976
00:36:24,626 --> 0:36:25,626
这就是我们要做的

977
00:36:25,886 --> 0:36:27,606
现在就可以玩游戏了

978
00:36:27,606 --> 0:36:29,416
玩游戏需要两个人

979
00:36:29,416 --> 0:36:30,626
Eric 请回到台上

980
00:36:32,456 --> 0:36:35,896
好的 Eric 已经在这里

981
00:36:35,896 --> 0:36:38,476
创建了一个游戏

982
00:36:38,476 --> 0:36:39,546
但是我想自己创建一个

983
00:36:40,726 --> 0:36:41,136
我们来做这一步

984
00:36:41,136 --> 0:36:42,946
Eric 我们输入密码

985
00:36:42,946 --> 0:36:47,406
5176

986
00:36:47,906 --> 0:36:48,686
不要告诉别人 [笑声]

987
00:36:49,906 --> 0:36:51,116
好了

988
00:36:51,116 --> 0:36:52,826
现在我们已经设置了一个

989
00:36:52,826 --> 0:36:53,896
安全的连接

990
00:36:54,286 --> 0:36:55,336
它在用 TLS

991
00:36:55,826 --> 0:36:57,666
当 Eric 选择一个角色时

992
00:36:57,666 --> 0:36:59,746
他选择鸟

993
00:37:00,536 --> 0:37:02,136
他就是在发送

994
00:37:02,636 --> 0:37:04,556
选择符号信息

995
00:37:04,556 --> 0:37:06,806
我调用 receiveMessage 

996
00:37:06,806 --> 0:37:07,926
收到 他选择了鸟

997
00:37:07,926 --> 0:37:08,936
然后我要选择猴子

998
00:37:08,936 --> 0:37:10,246
为什么不呢

999
00:37:11,066 --> 0:37:13,566
现在 Eric 选择一个位置

1000
00:37:14,326 --> 0:37:16,806
然后选择一个符号

1001
00:37:17,846 --> 0:37:21,276
好的 他将走棋动作发送给了我

1002
00:37:21,626 --> 0:37:22,616
我收到一个消息

1003
00:37:22,616 --> 0:37:23,846
我知道他走了一步棋

1004
00:37:23,846 --> 0:37:25,946
我知道他把棋放在了哪儿

1005
00:37:25,946 --> 0:37:29,606
我要把猴子

1006
00:37:29,606 --> 0:37:30,936
放在上面

1007
00:37:31,386 --> 0:37:32,476
他下一步会怎么走呢

1008
00:37:33,786 --> 0:37:35,066
哦 看起来

1009
00:37:35,106 --> 0:37:36,866
他要赢了 我不知道

1010
00:37:36,906 --> 0:37:38,336
我玩不了这个

1011
00:37:38,756 --> 0:37:39,896
井字游戏太难了

1012
00:37:40,376 --> 0:37:42,736
好像鸟赢了

1013
00:37:43,446 --> 0:37:45,636
但是可以看出来

1014
00:37:45,636 --> 0:37:47,496
这种类型的游戏搭建起来非常简单

1015
00:37:47,496 --> 0:37:50,076
你还可以用这个

1016
00:37:50,076 --> 0:37:51,666
搭建更多的小游戏

1017
00:37:51,666 --> 0:37:53,846
还有很多其他的 App

1018
00:37:53,846 --> 0:37:54,896
我们很期待

1019
00:37:54,896 --> 0:37:55,236
你们的作品

1020
00:37:56,516 --> 0:38:02,616
[掌声]

1021
00:37:56,516 --> 0:38:02,616
[掌声]

1022
00:38:03,116 --> 0:38:08,856
好的 在我继续之前 

1023
00:38:08,856 --> 0:38:10,276
关于框架协议 我想再说

1024
00:38:10,276 --> 0:38:11,316
最后一件事

1025
00:38:11,936 --> 0:38:14,156
很多人都在问

1026
00:38:14,156 --> 0:38:16,976
如何用技术 比如

1027
00:38:17,136 --> 0:38:20,326
在 NWConnection 中采用 STARTTLS

1028
00:38:20,776 --> 0:38:23,406
STARTTLS 是来自 

1029
00:38:23,406 --> 0:38:25,556
SMTP 邮箱协议的技术

1030
00:38:25,556 --> 0:38:29,586
它让你可以与较早的服务器交流

1031
00:38:29,586 --> 0:38:31,406
你并不知道

1032
00:38:31,406 --> 0:38:32,916
这个服务器

1033
00:38:32,996 --> 0:38:35,186
是否支持 TLS 和安全连接

1034
00:38:35,186 --> 0:38:36,576
你可以和它做一个初次握手

1035
00:38:37,106 --> 0:38:39,096
如果它支持 TLS 

1036
00:38:39,096 --> 0:38:41,586
你可以部分通过你的连接添加它 

1037
00:38:41,856 --> 0:38:43,476
之前没有什么好方法

1038
00:38:43,476 --> 0:38:45,196
来做这一步 

1039
00:38:45,196 --> 0:38:46,876
但是现在我们有了框架协议

1040
00:38:47,856 --> 0:38:50,726
所以 如果你创建一个

1041
00:38:50,726 --> 0:38:52,206
STARTTLS 框架协议

1042
00:38:52,206 --> 0:38:53,526
将它添加到连接

1043
00:38:53,526 --> 0:38:55,806
当 App 启动时

1044
00:38:55,916 --> 0:38:57,186
你可以和服务器握手

1045
00:38:57,186 --> 0:38:59,606
确定它是否支持 TLS

1046
00:39:00,416 --> 0:39:01,386
然后你可以 

1047
00:39:01,386 --> 0:39:02,956
在表明就绪之前 

1048
00:39:02,956 --> 0:39:04,836
在框架协议上 

1049
00:39:04,836 --> 0:39:07,286
动态添加协议到栈

1050
00:39:07,956 --> 0:39:09,156
这样 App 就会保持不变

1051
00:39:09,156 --> 0:39:11,736
不需要担心

1052
00:39:11,736 --> 0:39:13,866
部分添加 TLS 

1053
00:39:14,216 --> 0:39:15,926
这个过程会自动

1054
00:39:16,226 --> 0:39:17,446
通过框架协议进行

1055
00:39:18,246 --> 0:39:19,216
所以我们觉得这是一个

1056
00:39:19,216 --> 0:39:19,936
干净利落的方法

1057
00:39:21,516 --> 0:39:24,366
好 我们继续

1058
00:39:25,006 --> 0:39:27,146
我们已经介绍了 Bonjour

1059
00:39:27,146 --> 0:39:28,836
如果做更好的 P2P 连接

1060
00:39:28,836 --> 0:39:31,456
以及使用广域发现

1061
00:39:31,686 --> 0:39:34,136
我们介绍了框架协议

1062
00:39:35,086 --> 0:39:36,136
但是现在我想退一步

1063
00:39:36,136 --> 0:39:38,166
看看如何收集

1064
00:39:38,166 --> 0:39:40,096
你的 App 里

1065
00:39:40,096 --> 0:39:42,306
连接的指标

1066
00:39:43,356 --> 0:39:45,726
收集指标非常重要

1067
00:39:46,876 --> 0:39:50,006
当你给 App 或服务器

1068
00:39:50,006 --> 0:39:52,836
添加新功能

1069
00:39:52,836 --> 0:39:54,736
以实现更好的效果时

1070
00:39:55,446 --> 0:39:57,546
它让你确认这些功能

1071
00:39:57,546 --> 0:39:58,656
确实在发挥作用

1072
00:39:58,656 --> 0:40:00,566
你确实实现了自己想要的效果

1073
00:39:58,656 --> 0:40:00,566
你确实实现了自己想要的效果

1074
00:40:01,526 --> 0:40:03,756
它可以帮助你发现 

1075
00:40:04,346 --> 0:40:06,196
用户在真实使用中

1076
00:40:06,196 --> 0:40:08,016
可能遭遇的问题

1077
00:40:08,016 --> 0:40:12,056
这些问题在设计时并没有发现

1078
00:40:12,516 --> 0:40:14,606
今年我们有很多

1079
00:40:14,606 --> 0:40:16,206
新的指标

1080
00:40:16,206 --> 0:40:17,696
帮你更好地分析连接

1081
00:40:18,446 --> 0:40:20,426
URLSession 已经有了很多

1082
00:40:20,426 --> 0:40:22,236
很好的指标

1083
00:40:22,236 --> 0:40:23,476
但是其实还有更多

1084
00:40:23,546 --> 0:40:24,996
第一次 在 Network.framework 里

1085
00:40:24,996 --> 0:40:26,496
你可以检查连接

1086
00:40:26,496 --> 0:40:28,286
更全面地了解

1087
00:40:28,286 --> 0:40:31,166
它们的表现

1088
00:40:32,926 --> 0:40:35,326
在 URLSession 中

1089
00:40:35,326 --> 0:40:37,016
你已经得到一个 

1090
00:40:37,286 --> 0:40:40,896
DNS TCP TLS 和 HTTP 消息的

1091
00:40:40,896 --> 0:40:43,016
时间细分

1092
00:40:44,456 --> 0:40:46,086
现在你可以

1093
00:40:46,386 --> 0:40:48,726
在你的 App 里自检

1094
00:40:49,706 --> 0:40:53,006
更多的连接属性

1095
00:40:53,006 --> 0:40:54,146
和个人请求和响应 

1096
00:40:54,146 --> 0:40:56,546
正在发送的数据

1097
00:40:58,816 --> 0:41:00,376
在 Network.framework 里

1098
00:40:58,816 --> 0:41:00,376
在 Network.framework 里

1099
00:41:00,376 --> 0:41:01,856
你可以访问

1100
00:41:01,856 --> 0:41:03,506
连接建立报告

1101
00:41:03,506 --> 0:41:06,396
它总结了连接中发生的一切

1102
00:41:06,396 --> 0:41:08,966
以及数据传输报告

1103
00:41:08,966 --> 0:41:10,946
让你可以查看

1104
00:41:10,946 --> 0:41:12,236
连接过程中

1105
00:41:12,346 --> 0:41:15,036
各个时间段的性能

1106
00:41:15,106 --> 0:41:16,666
很多这些过程

1107
00:41:16,666 --> 0:41:17,836
同时进行

1108
00:41:18,426 --> 0:41:21,546
我们先从 URLSession 开始

1109
00:41:21,996 --> 0:41:25,116
我要提醒大家

1110
00:41:25,116 --> 0:41:26,596
URLSession 里所有的指标

1111
00:41:26,596 --> 0:41:27,356
在 didFinishCollecting 指标

1112
00:41:27,356 --> 0:41:30,116
代理调用里 都是可用的

1113
00:41:32,096 --> 0:41:34,086
这里有一些

1114
00:41:34,086 --> 0:41:36,016
你可以访问的新东西

1115
00:41:36,016 --> 0:41:37,326
连接的端点

1116
00:41:38,276 --> 0:41:41,236
本地和远程地址以及端口

1117
00:41:41,646 --> 0:41:43,756
你还可以查看

1118
00:41:43,756 --> 0:41:45,036
安全属性

1119
00:41:45,396 --> 0:41:48,836
有没有用 TLS 1.3

1120
00:41:48,836 --> 0:41:50,986
它是 TLS 最新的 最安全的 

1121
00:41:50,986 --> 0:41:52,436
性能最好的版本

1122
00:41:52,436 --> 0:41:56,666
你还可以用它查看路径属性

1123
00:41:57,636 --> 0:41:59,546
它会告诉你 比如说

1124
00:41:59,796 --> 0:42:01,606
你的连接用的是

1125
00:41:59,796 --> 0:42:01,606
你的连接用的是

1126
00:42:01,606 --> 0:42:03,446
约束低数据模式网络

1127
00:42:03,446 --> 0:42:05,656
还是一个

1128
00:42:05,656 --> 0:42:07,586
比较贵的蜂窝数据网络

1129
00:42:10,216 --> 0:42:14,586
Network.framework 里的等价指标

1130
00:42:14,586 --> 0:42:15,506
是在建立报告里面的

1131
00:42:16,346 --> 0:42:17,776
每当连接进入稳定状态

1132
00:42:17,776 --> 0:42:20,816
你就可以使用这些指标

1133
00:42:20,926 --> 0:42:23,416
这会给你一个细分

1134
00:42:23,486 --> 0:42:26,426
你的 DNS 次数 

1135
00:42:26,426 --> 0:42:29,216
协议和 TCP 和 TLS 的握手

1136
00:42:29,216 --> 0:42:31,006
以及你是否使用了代理

1137
00:42:31,536 --> 0:42:33,576
在代码里它看起来是这样的

1138
00:42:33,856 --> 0:42:35,476
获取连接 并调用

1139
00:42:35,676 --> 0:42:37,146
requestEstablishmentReport

1140
00:42:37,806 --> 0:42:39,886
这里有一个队列

1141
00:42:39,886 --> 0:42:41,516
它会把报告加入到队列里

1142
00:42:42,696 --> 0:42:43,986
有了这个 你就可以查看

1143
00:42:43,986 --> 0:42:45,776
连接花费的所有时间 

1144
00:42:46,296 --> 0:42:49,626
你可以查看各个解决步骤

1145
00:42:49,836 --> 0:42:51,306
如果一个 Bonjour 名称连接到你

1146
00:42:51,306 --> 0:42:53,416
它可能会解析 Bonjour 名称

1147
00:42:53,416 --> 0:42:55,056
为主机名

1148
00:42:55,056 --> 0:42:56,886
再把主机名解析为地址

1149
00:42:56,886 --> 0:42:58,756
你可以查看

1150
00:42:58,786 --> 0:43:00,626
每个步骤的时间细分

1151
00:42:58,786 --> 0:43:00,626
每个步骤的时间细分

1152
00:43:01,136 --> 0:43:03,806
你还可以查看

1153
00:43:03,806 --> 0:43:06,286
TCP 的 TLS 的 

1154
00:43:06,346 --> 0:43:08,256
和往返次数的

1155
00:43:08,256 --> 0:43:09,126
单独计时

1156
00:43:09,346 --> 0:43:13,476
我想强调一点

1157
00:43:13,476 --> 0:43:15,386
这一点对于连接建立的

1158
00:43:15,386 --> 0:43:16,566
整体表现来说

1159
00:43:16,566 --> 0:43:18,936
非常重要

1160
00:43:18,936 --> 0:43:20,756
这一点就是它 

1161
00:43:20,886 --> 0:43:23,376
解析 DNS 的时间

1162
00:43:23,376 --> 0:43:25,166
以及 DNS 解析的来源

1163
00:43:27,386 --> 0:43:30,286
很多服务器 

1164
00:43:30,286 --> 0:43:32,876
只有很短的时间 

1165
00:43:32,876 --> 0:43:34,046
在 DNS 记录上配置

1166
00:43:34,446 --> 0:43:36,846
它们这样做的目的是

1167
00:43:36,846 --> 0:43:39,866
当服务器发生故障

1168
00:43:39,866 --> 0:43:40,886
或者想在另一个 IP 地址上

1169
00:43:40,946 --> 0:43:43,246
平衡负载时

1170
00:43:43,246 --> 0:43:44,956
它可以快速改变 IP 地址记录

1171
00:43:44,956 --> 0:43:47,546
调整客户端

1172
00:43:47,546 --> 0:43:49,056
使用新地址

1173
00:43:50,166 --> 0:43:52,116
但是 缺点是

1174
00:43:52,116 --> 0:43:54,546
这会影响客户端性能

1175
00:43:55,736 --> 0:43:57,666
在很短的时间内

1176
00:43:57,666 --> 0:43:59,546
客户端需要往返

1177
00:43:59,616 --> 0:44:01,646
做 DNS 域名解析

1178
00:43:59,616 --> 0:44:01,646
做 DNS 域名解析

1179
00:44:01,646 --> 0:44:04,236
请求你要连接的

1180
00:44:04,236 --> 0:44:06,766
主机名地址

1181
00:44:07,286 --> 0:44:11,066
对于要连接到

1182
00:44:11,366 --> 0:44:12,866
高延迟链接的客户端来说 

1183
00:44:12,866 --> 0:44:13,636
这就特别糟糕

1184
00:44:14,286 --> 0:44:16,396
这将会延长连接时间

1185
00:44:16,396 --> 0:44:17,946
增加数百毫秒

1186
00:44:17,946 --> 0:44:19,156
甚至好几秒

1187
00:44:19,786 --> 0:44:22,126
最糟糕的是 大部分时间  

1188
00:44:22,126 --> 0:44:23,816
服务器地址并没有改变

1189
00:44:23,816 --> 0:44:26,256
所以这就是一个

1190
00:44:26,256 --> 0:44:27,296
没用的往返

1191
00:44:28,426 --> 0:44:33,016
我们 去年发布了 Optimistic DNS

1192
00:44:33,016 --> 0:44:34,256
可以解决这个问题

1193
00:44:35,786 --> 0:44:37,636
Optimistic DNS 

1194
00:44:37,636 --> 0:44:39,636
让你连接到 

1195
00:44:39,916 --> 0:44:42,376
主机名的最后一个

1196
00:44:42,376 --> 0:44:43,846
已知良好的 IP 地址

1197
00:44:44,816 --> 0:44:49,766
同时请求主机名的当前地址

1198
00:44:51,146 --> 0:44:52,776
大部分情况下

1199
00:44:52,776 --> 0:44:55,246
都没有什么改变

1200
00:44:55,246 --> 0:44:56,456
连接还是建立在

1201
00:44:56,456 --> 0:44:58,356
之前的 IP 地址

1202
00:44:58,676 --> 0:45:00,016
如果有变化

1203
00:44:58,676 --> 0:45:00,016
如果有变化

1204
00:45:00,016 --> 0:45:01,266
你会得到一个新的 IP 地址

1205
00:45:01,266 --> 0:45:02,776
转而连接到新地址

1206
00:45:03,376 --> 0:45:06,676
我们一直在测试它

1207
00:45:07,206 --> 0:45:09,456
它真的是一个好方法

1208
00:45:09,456 --> 0:45:11,126
所以今年 对于使用 

1209
00:45:11,126 --> 0:45:12,976
Network.framework 

1210
00:45:12,976 --> 0:45:14,156
和 URLSession 的连接

1211
00:45:14,156 --> 0:45:14,936
它是默认开启的

1212
00:45:16,736 --> 0:45:17,866
当你查看

1213
00:45:17,866 --> 0:45:19,146
连接报告时 

1214
00:45:19,146 --> 0:45:21,046
你可以通过查看来源

1215
00:45:21,046 --> 0:45:23,636
辨认你用的是不是 Optimistic DNS

1216
00:45:24,116 --> 0:45:25,216
如果是来自过期缓存

1217
00:45:25,216 --> 0:45:27,746
这就意味着

1218
00:45:27,746 --> 0:45:30,966
我们用的是 Optimistic DNS

1219
00:45:31,726 --> 0:45:34,566
我想向大家展示一下

1220
00:45:34,566 --> 0:45:36,416
如何使用指标

1221
00:45:36,416 --> 0:45:38,196
查看连接性能

1222
00:45:38,196 --> 0:45:39,926
以及 Optimistic DNS

1223
00:45:39,926 --> 0:45:47,196
和 TLS 1.3 的优点

1224
00:45:47,426 --> 0:45:49,766
好 我这里有一个 App

1225
00:45:49,766 --> 0:45:51,556
一款非常基本的 App

1226
00:45:51,556 --> 0:45:54,216
用来收集指标

1227
00:45:54,346 --> 0:45:57,286
只需要对一个给定网站运行 probe

1228
00:45:57,756 --> 0:46:00,186
好 有了

1229
00:45:57,756 --> 0:46:00,186
好 有了

1230
00:46:00,186 --> 0:46:01,836
我点按“Run Probe”

1231
00:46:01,836 --> 0:46:03,306
连接上了 非常快

1232
00:46:03,306 --> 0:46:07,916
Wi-Fi 信号非常好

1233
00:46:08,506 --> 0:46:10,336
如果你想在一个

1234
00:46:10,336 --> 0:46:12,176
更现实的场景中测试它

1235
00:46:12,176 --> 0:46:13,496
或者看它在

1236
00:46:13,496 --> 0:46:15,606
不同网络条件下的表现

1237
00:46:16,146 --> 0:46:18,026
你现在可以到设备内部

1238
00:46:18,026 --> 0:46:20,806
在 Xcode 的模拟器面板中

1239
00:46:20,806 --> 0:46:23,226
访问设备条件

1240
00:46:23,646 --> 0:46:25,626
模拟不同的网络连接环境

1241
00:46:25,806 --> 0:46:26,886
这样你就可以看到

1242
00:46:26,886 --> 0:46:29,226
不同的情景下

1243
00:46:29,446 --> 0:46:30,416
用户的体验 [掌声]

1244
00:46:31,196 --> 0:46:33,286
这很棒

1245
00:46:35,736 --> 0:46:37,126
我们看一下如果是高延迟 DNS 链接

1246
00:46:37,296 --> 0:46:39,096
会发生什么

1247
00:46:40,256 --> 0:46:41,826
我点按 Start  

1248
00:46:41,826 --> 0:46:42,936
可以看出它在运行

1249
00:46:42,936 --> 0:46:45,496
因为左上角有一个

1250
00:46:45,496 --> 0:46:46,426
灰色框

1251
00:46:47,546 --> 0:46:50,716
现在 再次运行 probe

1252
00:46:50,716 --> 0:46:53,086
很快

1253
00:46:53,796 --> 0:46:55,926
很好 你会发现 

1254
00:46:55,926 --> 0:46:57,486
它来自过期缓存

1255
00:46:57,966 --> 0:46:59,226
也就是说 我们用的是

1256
00:46:59,276 --> 0:47:00,616
Optimistic DNS

1257
00:46:59,276 --> 0:47:00,616
Optimistic DNS

1258
00:47:01,486 --> 0:47:04,476
Optimistic DNS 是默认运行的

1259
00:47:04,476 --> 0:47:06,196
如果你觉得

1260
00:47:06,196 --> 0:47:07,626
它不适合你的服务器的话

1261
00:47:07,626 --> 0:47:09,236
但是你可以关掉它

1262
00:47:09,956 --> 0:47:11,186
再次运行 probe 

1263
00:47:11,836 --> 0:47:14,796
你可以感受到几秒钟过去了

1264
00:47:15,796 --> 0:47:18,606
也许我有点夸张

1265
00:47:18,696 --> 0:47:19,936
希望你的用户不会遭遇

1266
00:47:19,936 --> 0:47:21,986
3 秒 DNS 延迟的情况

1267
00:47:21,986 --> 0:47:23,526
但是两种情况是很不一样的

1268
00:47:24,146 --> 0:47:26,956
现在我们尝试一个

1269
00:47:26,956 --> 0:47:30,086
更加现实的场景

1270
00:47:30,086 --> 0:47:31,836
比如常用的 3G 网络

1271
00:47:32,496 --> 0:47:35,956
启动

1272
00:47:35,956 --> 0:47:37,166
再一次运行 probe 

1273
00:47:37,766 --> 0:47:40,436
不像第一次运行的时候

1274
00:47:40,436 --> 0:47:41,356
那么快了

1275
00:47:42,096 --> 0:47:43,726
总的来说 你可以看到

1276
00:47:43,726 --> 0:47:45,866
建立连接

1277
00:47:45,866 --> 0:47:46,846
要 600 毫秒

1278
00:47:47,306 --> 0:47:51,786
TLS 花了不到

1279
00:47:51,786 --> 0:47:53,416
300 毫秒

1280
00:47:53,416 --> 0:47:56,826
也就是说差不多一半

1281
00:47:57,016 --> 0:47:59,006
所以我们的服务器被配置成

1282
00:47:59,006 --> 0:48:00,506
支持 TLS 1.3

1283
00:47:59,006 --> 0:48:00,506
支持 TLS 1.3

1284
00:48:00,906 --> 0:48:04,166
现在 TLS 1.3 通常只需要一个往返

1285
00:48:04,206 --> 0:48:06,486
就可以完成一次握手

1286
00:48:06,776 --> 0:48:08,146
这是很大的进步

1287
00:48:09,086 --> 0:48:10,286
但是如果你的服务器

1288
00:48:10,286 --> 0:48:11,946
不支持 TLS 1.3

1289
00:48:11,946 --> 0:48:14,806
如果它只支持 TLS 1.2 

1290
00:48:14,806 --> 0:48:18,416
如果你 App 上使用的 API 

1291
00:48:18,416 --> 0:48:22,476
不支持 TLS 1.3

1292
00:48:22,476 --> 0:48:24,836
你可能会看到这种情况

1293
00:48:24,836 --> 0:48:27,326
TLS 自己花去 500 毫秒

1294
00:48:27,616 --> 0:48:30,246
多进行一轮往返

1295
00:48:31,166 --> 0:48:31,906
你可以看到

1296
00:48:31,906 --> 0:48:34,286
连接时间已经超过了

1297
00:48:34,286 --> 0:48:35,576
四分之三秒

1298
00:48:35,656 --> 0:48:36,496
差不多要一秒了

1299
00:48:36,926 --> 0:48:37,946
如果你有很多连接

1300
00:48:37,946 --> 0:48:39,796
用户会感受到

1301
00:48:39,796 --> 0:48:42,466
更久的延迟

1302
00:48:43,216 --> 0:48:44,376
所以我们建议

1303
00:48:44,376 --> 0:48:45,326
每当你测试 App 时

1304
00:48:45,326 --> 0:48:47,576
通过网络连接模拟器

1305
00:48:47,576 --> 0:48:49,276
运行它

1306
00:48:49,276 --> 0:48:50,856
测试一些场景

1307
00:48:50,856 --> 0:48:53,026
验证 App 是否运行良好

1308
00:49:01,196 --> 0:49:02,476
另一类指标

1309
00:49:02,476 --> 0:49:04,546
和建立连接后的

1310
00:49:04,546 --> 0:49:07,186
数据传输有关

1311
00:49:08,356 --> 0:49:10,576
所以在 URLSession 中 

1312
00:49:10,576 --> 0:49:12,456
现在你可以访问更多指标

1313
00:49:12,456 --> 0:49:13,566
数量相当于

1314
00:49:13,566 --> 0:49:15,496
你发送到请求的

1315
00:49:15,496 --> 0:49:17,186
Header 和 Body 的字节数

1316
00:49:17,186 --> 0:49:19,606
以及你从

1317
00:49:19,606 --> 0:49:21,356
请求的 Header 和 Body

1318
00:49:21,356 --> 0:49:24,686
收到的字节数

1319
00:49:25,606 --> 0:49:27,286
如果你选的是不同的 URL 

1320
00:49:27,286 --> 0:49:29,866
在一个低数据模式网络环境 

1321
00:49:30,126 --> 0:49:32,916
来下载较少的数据

1322
00:49:32,916 --> 0:49:35,946
这个就非常重要 

1323
00:49:36,026 --> 0:49:37,196
你要用它确认 

1324
00:49:37,256 --> 0:49:40,106
确实存储了用户的字节

1325
00:49:42,796 --> 0:49:44,616
在 Network.framework 中

1326
00:49:44,616 --> 0:49:46,506
你现在可以访问数据传输报告

1327
00:49:46,506 --> 0:49:48,426
这个报告总结了运行情况

1328
00:49:48,426 --> 0:49:52,886
包括字节 数据包 

1329
00:49:53,416 --> 0:49:56,606
和给定时间段内的往返次数

1330
00:49:56,986 --> 0:49:58,136
多个这些过程 

1331
00:49:58,136 --> 0:49:59,156
会同时运行 

1332
00:49:59,246 --> 0:50:00,976
并且它们要与 App 活动相对应

1333
00:49:59,246 --> 0:50:00,976
并且它们要与 App 活动相对应

1334
00:50:01,236 --> 0:50:03,116
所以如果你要突然发送一段流

1335
00:50:03,116 --> 0:50:06,236
把它放入数据传输报告里

1336
00:50:06,896 --> 0:50:11,446
它不如闲置时间报告有趣

1337
00:50:11,976 --> 0:50:14,176
你要做的是  

1338
00:50:14,176 --> 0:50:15,956
在任何时间 你都可以在连接上

1339
00:50:15,956 --> 0:50:18,776
调用 startDataTransferReport 

1340
00:50:19,286 --> 0:50:21,896
首先 收集连接的

1341
00:50:21,896 --> 0:50:23,366
运行情况数据

1342
00:50:24,336 --> 0:50:25,946
发完一堆数据后

1343
00:50:25,946 --> 0:50:27,606
调用 collect

1344
00:50:28,316 --> 0:50:29,746
这会总结所有数据

1345
00:50:29,746 --> 0:50:31,606
给你一个报告

1346
00:50:32,836 --> 0:50:34,936
如果你用的是多路径协议

1347
00:50:34,996 --> 0:50:36,996
它会给你一个细分 

1348
00:50:36,996 --> 0:50:39,446
多路径线程

1349
00:50:39,446 --> 0:50:41,456
每条链接上正在使用的

1350
00:50:41,456 --> 0:50:42,976
数量细分

1351
00:50:43,896 --> 0:50:45,006
但是你们很多人 

1352
00:50:45,006 --> 0:50:47,316
只对聚合路径报告有兴趣

1353
00:50:48,716 --> 0:50:50,506
这里你可以查看

1354
00:50:50,506 --> 0:50:51,566
发送和接收的数据包数

1355
00:50:51,566 --> 0:50:53,386
传输的字节数

1356
00:50:53,386 --> 0:50:55,036
以及你观察到的

1357
00:50:55,036 --> 0:50:57,336
往返时间详细信息

1358
00:50:58,806 --> 0:51:00,756
这就是指标

1359
00:50:58,806 --> 0:51:00,756
这就是指标

1360
00:51:00,756 --> 0:51:02,306
我们特别想看到大家

1361
00:51:02,306 --> 0:51:04,316
用更多的指标

1362
00:51:04,416 --> 0:51:06,076
并且提升 App 的性能

1363
00:51:06,966 --> 0:51:08,726
现在我想把 Stuart 请上台

1364
00:51:08,726 --> 0:51:10,386
他将为大家带来

1365
00:51:10,386 --> 0:51:11,856
好的建议和新的更新

1366
00:51:12,516 --> 0:51:14,866
[掌声]

1367
00:51:15,366 --> 0:51:16,116
&gt;&gt; 谢谢你 Tommy

1368
00:51:17,516 --> 0:51:19,286
很荣幸

1369
00:51:19,606 --> 0:51:21,306
我能总结

1370
00:51:21,306 --> 0:51:23,326
我的同伴们 

1371
00:51:23,326 --> 0:51:24,766
用两个小时介绍的

1372
00:51:24,766 --> 0:51:26,046
联网信息

1373
00:51:26,916 --> 0:51:29,986
首先 我要介绍

1374
00:51:29,986 --> 0:51:30,906
Mac 版的 iPad App

1375
00:51:31,956 --> 0:51:33,666
我知道你们很多人对此很感兴趣

1376
00:51:34,206 --> 0:51:36,936
说到联网在 Apple 平台上

1377
00:51:36,936 --> 0:51:38,726
没有多大的区别

1378
00:51:39,536 --> 0:51:41,056
你需要注意的一件事是

1379
00:51:41,056 --> 0:51:44,626
在你的 Xcode 设置里

1380
00:51:44,626 --> 0:51:47,166
当你选择 Mac 的复选框时

1381
00:51:47,166 --> 0:51:51,826
现在你可以看到更多新选项

1382
00:51:52,216 --> 0:51:56,306
默认允许传出连接

1383
00:51:56,366 --> 0:51:57,636
如果你也想要传入连接

1384
00:51:57,636 --> 0:51:59,916
你要勾选那个复选框

1385
00:52:05,696 --> 0:52:07,976
在 watchOS 上 

1386
00:52:07,976 --> 0:52:09,396
我们有新的联网功能

1387
00:52:11,036 --> 0:52:12,946
用 AVFoundation 

1388
00:52:12,946 --> 0:52:16,016
做音频流的 App

1389
00:52:16,016 --> 0:52:18,756
现在可以使用直接联网

1390
00:52:18,756 --> 0:52:20,696
只要用的是 URLSession

1391
00:52:21,046 --> 0:52:22,136
或 Network.framework

1392
00:52:23,036 --> 0:52:24,576
Sockets 不可用

1393
00:52:30,156 --> 0:52:33,226
我们也介绍了 TLS 1.3

1394
00:52:33,636 --> 0:52:35,196
它会给你带来很多好处

1395
00:52:36,136 --> 0:52:38,866
TLS 1.3 联网性能更出色

1396
00:52:39,036 --> 0:52:42,106
TLS 1.2 一般需要两个往返 

1397
00:52:42,106 --> 0:52:43,466
才能建立一个连接

1398
00:52:43,546 --> 0:52:46,806
TLS 1.3 基本只需一个往返

1399
00:52:48,146 --> 0:52:51,646
TLS 1.2 用的是加密算法

1400
00:52:51,646 --> 0:52:53,236
我们曾经认为

1401
00:52:53,236 --> 0:52:54,896
加密算法很好

1402
00:52:54,896 --> 0:52:56,586
但是出现了问题

1403
00:52:56,586 --> 0:52:58,756
这不只是一个学术问题

1404
00:52:58,806 --> 0:53:00,486
这些都是实践出来的

1405
00:52:58,806 --> 0:53:00,486
这些都是实践出来的

1406
00:53:01,676 --> 0:53:03,566
这些问题都不会出现在

1407
00:53:03,566 --> 0:53:07,026
TLS 1.3 中

1408
00:53:07,026 --> 0:53:08,866
TLS 1.3 中所有的加密算法

1409
00:53:08,866 --> 0:53:13,696
都支持相关数据的认证加密

1410
00:53:13,986 --> 0:53:14,996
增强安全性

1411
00:53:16,176 --> 0:53:18,626
最后 大家都知道

1412
00:53:18,626 --> 0:53:20,466
对于 Apple 来说 隐私非常重要

1413
00:53:20,986 --> 0:53:23,416
TLS 1.3 在隐私方面做得更好

1414
00:53:24,176 --> 0:53:26,796
在 TLS 1.2 中 

1415
00:53:27,006 --> 0:53:30,166
很多 Header 域和证书

1416
00:53:30,166 --> 0:53:30,706
都是明文发送的

1417
00:53:31,186 --> 0:53:34,076
在 TLS 1.3 中都加密了

1418
00:53:34,686 --> 0:53:38,276
所以我们希望

1419
00:53:38,276 --> 0:53:39,736
大家都开始 

1420
00:53:39,736 --> 0:53:41,856
在 App 上用 TLS 1.3

1421
00:53:41,856 --> 0:53:43,456
当然也要确保服务器已更新 

1422
00:53:43,456 --> 0:53:46,996
支持 TLS 1.3

1423
00:53:47,616 --> 0:53:49,476
现在 大家都知道了

1424
00:53:49,476 --> 0:53:50,476
对于 Apple 来说隐私的重要性

1425
00:53:51,146 --> 0:53:52,936
我们意识到

1426
00:53:52,936 --> 0:53:56,416
接入 Wi-Fi

1427
00:53:56,416 --> 0:53:59,286
可能会暴露位置

1428
00:53:59,916 --> 0:54:02,936
从现在开始   

1429
00:53:59,916 --> 0:54:02,936
从现在开始   

1430
00:54:02,936 --> 0:54:05,066
要访问那个 Wi-Fi 信息

1431
00:54:05,456 --> 0:54:07,586
和获取其他位置信息一样

1432
00:54:07,586 --> 0:54:09,736
你需要同样的权限

1433
00:54:10,786 --> 0:54:12,626
第一步是 

1434
00:54:12,626 --> 0:54:14,716
在 Xcode 里

1435
00:54:14,716 --> 0:54:16,846
添加访问 Wi-Fi 信息的能力

1436
00:54:16,846 --> 0:54:18,666
添加权限到你的项目

1437
00:54:18,666 --> 0:54:22,266
然后你的 App 必须满足

1438
00:54:22,266 --> 0:54:23,706
其他三个标准之一

1439
00:54:23,706 --> 0:54:26,086
其一 如果用户已经给了你的 App

1440
00:54:26,386 --> 0:54:28,496
位置访问权限 

1441
00:54:28,496 --> 0:54:30,416
那么你可以访问 Wi-Fi 网络信息

1442
00:54:31,556 --> 0:54:33,356
其二 如果你的 App 是设备上

1443
00:54:33,356 --> 0:54:35,766
当前启用的 VPN App

1444
00:54:36,376 --> 0:54:37,816
你可以访问信息

1445
00:54:37,986 --> 0:54:40,146
最后 如果你的 App 

1446
00:54:40,146 --> 0:54:42,276
是任何热点配置 App 

1447
00:54:42,676 --> 0:54:44,036
它可以访问信息 

1448
00:54:44,036 --> 0:54:45,396
但是只能访问

1449
00:54:45,396 --> 0:54:47,276
配置的网络信息

1450
00:54:48,496 --> 0:54:49,896
如果想要了解更多

1451
00:54:49,896 --> 0:54:51,436
可以看一下 Wi-Fi 框架

1452
00:54:52,066 --> 0:54:55,996
今天你已经听到过很多次了

1453
00:54:55,996 --> 0:54:57,096
最后我要再提一下

1454
00:54:57,096 --> 0:55:00,356
使用网络模拟工具的重要性

1455
00:54:57,096 --> 0:55:00,356
使用网络模拟工具的重要性

1456
00:55:02,166 --> 0:55:03,716
当你在 Mac 上开发 App 时

1457
00:55:03,716 --> 0:55:05,446
如果模拟器是千兆以太网

1458
00:55:05,446 --> 0:55:08,666
或在环回接口上

1459
00:55:08,666 --> 0:55:10,296
与本地服务器对话时

1460
00:55:10,296 --> 0:55:12,816
就会很简单

1461
00:55:13,396 --> 0:55:15,686
如果你的服务器没有延迟

1462
00:55:15,786 --> 0:55:18,216
带宽是无限的

1463
00:55:18,776 --> 0:55:20,496
那毫无疑问 性能会很好

1464
00:55:20,496 --> 0:55:23,276
但是如果你按这种条件搭建 App

1465
00:55:23,276 --> 0:55:25,996
那就大错特错了

1466
00:55:25,996 --> 0:55:27,836
当用户真正开始

1467
00:55:27,836 --> 0:55:29,186
使用你的 App 时 

1468
00:55:29,186 --> 0:55:30,336
你就会发现性能并不好

1469
00:55:31,006 --> 0:55:33,566
如果你从 

1470
00:55:33,826 --> 0:55:36,736
一开始开发 App

1471
00:55:37,406 --> 0:55:40,706
就养成习惯 

1472
00:55:40,706 --> 0:55:44,056
到设备情况里选择现实的

1473
00:55:44,056 --> 0:55:46,396
网络连接环境 

1474
00:55:46,396 --> 0:55:47,626
一直模拟真实的网络环境

1475
00:55:47,936 --> 0:55:49,516
检测运行你的 App

1476
00:55:49,516 --> 0:55:52,866
那么那些 Bug

1477
00:55:52,866 --> 0:55:57,106
就根本不会出现

1478
00:55:57,186 --> 0:55:59,056
多年来 我们一直向大家传递的 

1479
00:55:59,056 --> 0:56:01,706
另一个信息是

1480
00:55:59,056 --> 0:56:01,706
另一个信息是

1481
00:56:01,706 --> 0:56:04,966
避免启动时检查

1482
00:56:05,186 --> 0:56:08,936
使用蜂窝数据

1483
00:56:08,936 --> 0:56:10,696
或较贵的网络之类的约束

1484
00:56:10,696 --> 0:56:13,216
实现更好的控制

1485
00:56:13,366 --> 0:56:14,756
这样就简单多了

1486
00:56:14,926 --> 0:56:16,606
一旦你开始这样开发 App

1487
00:56:16,606 --> 0:56:18,606
你就会问自己

1488
00:56:18,606 --> 0:56:19,986
为什么之前要启动时检查

1489
00:56:20,236 --> 0:56:22,326
而且启动时检查

1490
00:56:22,326 --> 0:56:24,156
并不可靠 

1491
00:56:24,156 --> 0:56:25,636
因为它们总是带来问题

1492
00:56:26,526 --> 0:56:28,666
我举个例子

1493
00:56:28,666 --> 0:56:30,556
来说明这一点

1494
00:56:30,556 --> 0:56:32,776
这个是我很喜欢的一个 App

1495
00:56:33,316 --> 0:56:36,136
因为要说明这个情况 

1496
00:56:36,636 --> 0:56:38,356
我故意做了一个

1497
00:56:38,626 --> 0:56:41,366
夸张的例子 看看

1498
00:56:41,366 --> 0:56:42,506
如果这个 App 写的不好 

1499
00:56:42,506 --> 0:56:43,166
会发生什么

1500
00:56:43,736 --> 0:56:45,036
这是在告诉用户

1501
00:56:45,176 --> 0:56:46,646
确保连接了 Wi-Fi 

1502
00:56:46,646 --> 0:56:47,376
然后点按按钮

1503
00:56:48,056 --> 0:56:49,536
但是用户并不能

1504
00:56:49,536 --> 0:56:51,836
控制选择

1505
00:56:51,836 --> 0:56:52,926
哪条联网路径

1506
00:56:53,366 --> 0:56:55,556
他们一般会

1507
00:56:55,556 --> 0:56:57,406
找 Wi-Fi 栏 希望连接到最佳网络

1508
00:56:58,226 --> 0:57:00,016
但是今天你知道了

1509
00:56:58,226 --> 0:57:00,016
但是今天你知道了

1510
00:57:01,536 --> 0:57:03,336
在测试之前 

1511
00:57:03,336 --> 0:57:06,776
你不可能知道 Wi-Fi 情况是什么样

1512
00:57:07,516 --> 0:57:09,696
设备可能以为自己连接了 Wi-Fi

1513
00:57:09,696 --> 0:57:11,286
但是当它想用的时候

1514
00:57:11,286 --> 0:57:13,396
发现  Wi-Fi 不能用

1515
00:57:13,496 --> 0:57:15,906
现在 当 Wi-Fi Assist

1516
00:57:15,906 --> 0:57:18,036
把你从 Wi-Fi 转换到蜂窝数据时

1517
00:57:18,036 --> 0:57:19,776
那些 Wi-Fi 栏都消失了

1518
00:57:20,236 --> 0:57:21,496
但是已经晚了

1519
00:57:21,496 --> 0:57:22,746
你已经开始连接了

1520
00:57:23,546 --> 0:57:28,816
所以不要让用户猜测

1521
00:57:29,256 --> 0:57:30,436
不要只是

1522
00:57:30,436 --> 0:57:31,136
期待最优的网络

1523
00:57:31,706 --> 0:57:32,576
我来演示一下

1524
00:57:32,576 --> 0:57:35,096
这个 App 实际上是什么样

1525
00:57:35,386 --> 0:57:36,886
它将连接限制到

1526
00:57:37,796 --> 0:57:40,576
不允许访问蜂窝数据

1527
00:57:41,176 --> 0:57:44,816
在 iOS 13 里启动它

1528
00:57:44,816 --> 0:57:47,186
实际上 它使用

1529
00:57:47,186 --> 0:57:49,036
allowsExpensiveNetworkAccess 控件

1530
00:57:49,186 --> 0:57:50,956
让系统选择

1531
00:57:51,096 --> 0:57:52,486
哪个是较贵的网络

1532
00:57:53,666 --> 0:57:55,226
它还设置

1533
00:57:55,226 --> 0:57:57,076
waitsForConnectivity 为真

1534
00:57:57,466 --> 0:57:58,866
这意味着 

1535
00:57:59,196 --> 0:58:01,276
App 不需要反复重试

1536
00:57:59,196 --> 0:58:01,276
App 不需要反复重试

1537
00:58:01,586 --> 0:58:02,766
系统会一直

1538
00:58:02,766 --> 0:58:04,046
耐心等待

1539
00:58:04,046 --> 0:58:05,726
直到成功连接

1540
00:58:07,306 --> 0:58:09,876
当 App 尝试连接时

1541
00:58:09,876 --> 0:58:11,896
如果没有 Wi-Fi

1542
00:58:12,526 --> 0:58:14,506
它的 taskIsWaitingForConnectivity 代理

1543
00:58:14,506 --> 0:58:16,776
会被调用 

1544
00:58:16,776 --> 0:58:18,616
这时它会显示 UI

1545
00:58:18,616 --> 0:58:20,906
让用户选择

1546
00:58:20,906 --> 0:58:22,516
要么移步到有 Wi-Fi 的地方

1547
00:58:22,516 --> 0:58:23,986
要么按下按钮

1548
00:58:23,986 --> 0:58:25,576
使用蜂窝数据

1549
00:58:26,896 --> 0:58:29,126
一些关于弃用的消息

1550
00:58:30,236 --> 0:58:31,786
如果还有人在用 PAC 文件 

1551
00:58:31,786 --> 0:58:35,046
用这种文件 或者 FTP URL 方案

1552
00:58:35,226 --> 0:58:37,476
要注意 我们已经不支持这些了

1553
00:58:38,656 --> 0:58:40,366
SPDY 曾是非常好的

1554
00:58:40,366 --> 0:58:41,906
实验协议

1555
00:58:41,906 --> 0:58:44,176
如果还有人用 SPDY 要注意

1556
00:58:44,176 --> 0:58:46,496
SPDY 现在已经被 HTTP 2 取代了

1557
00:58:47,006 --> 0:58:48,786
Apple 现在支持的是 HTTP 2

1558
00:58:48,786 --> 0:58:50,726
一切都应朝着这个方向发展

1559
00:58:51,516 --> 0:58:54,066
而且 Secure Transport 

1560
00:58:54,066 --> 0:58:56,906
不支持 TLS 1.3 

1561
00:58:56,906 --> 0:58:59,636
永远也不会支持 TLS 1.3 

1562
00:58:59,636 --> 0:59:01,646
这也是选择 URLSession 或

1563
00:58:59,636 --> 0:59:01,646
这也是选择 URLSession 或

1564
00:59:01,646 --> 0:59:02,536
Network.framework 的另一原因

1565
00:59:03,066 --> 0:59:08,156
所以 总的来说 今天早晨

1566
00:59:08,156 --> 0:59:10,606
我们介绍了广域 Bonjour 发现  

1567
00:59:10,606 --> 0:59:17,756
以及如何发布一个

1568
00:59:17,756 --> 0:59:18,796
井字游戏 

1569
00:59:19,076 --> 0:59:22,386
有些人可能会想

1570
00:59:22,386 --> 0:59:23,816
serviceType_tictactoe

1571
00:59:23,816 --> 0:59:26,796
是否注册到了 Ayana

1572
00:59:27,056 --> 0:59:28,786
答案是肯定的

1573
00:59:28,786 --> 0:59:29,716
你可以去网站上看看 [笑声]

1574
00:59:33,376 --> 0:59:34,736
Tommy 介绍了

1575
00:59:34,736 --> 0:59:37,086
搭建协议框架

1576
00:59:37,086 --> 0:59:39,436
收集指标

1577
00:59:39,436 --> 0:59:40,936
让你写 App 变得更容易

1578
00:59:41,396 --> 0:59:43,616
也更容易考量性能

1579
00:59:44,226 --> 0:59:48,226
今天早晨 我们还讨论了

1580
00:59:48,226 --> 0:59:50,506
低数据模式

1581
00:59:50,506 --> 0:59:52,206
要尊重用户

1582
00:59:52,206 --> 0:59:53,836
何时保存数据的需求

1583
00:59:54,526 --> 0:59:56,006
我们还讨论了

1584
00:59:56,006 --> 0:59:57,636
结合 URLSession 

1585
00:59:57,636 --> 0:59:59,866
可以很好地链接异步操作

1586
00:59:59,866 --> 1:00:01,976
我们还讨论了 WebSocket

1587
00:59:59,866 --> 1:00:01,976
我们还讨论了 WebSocket

1588
01:00:02,046 --> 1:00:04,776
如果你的 App 是基于网页的

1589
01:00:04,776 --> 1:00:06,466
它用 WebSocket

1590
01:00:06,466 --> 1:00:08,126
和服务器交流

1591
01:00:08,126 --> 1:00:09,726
现在你可以在本地 iOS App 中

1592
01:00:09,726 --> 1:00:11,876
使用同一台服务器

1593
01:00:12,886 --> 1:00:14,816
Christoph Paasch 

1594
01:00:14,816 --> 1:00:16,376
介绍了所有的移动改进

1595
01:00:16,376 --> 1:00:20,626
通过多路径 TCP 和 Wi-Fi Assist 实现

1596
01:00:21,486 --> 1:00:23,946
关于这一点

1597
01:00:24,456 --> 1:00:27,446
你们很多人会知道 ACM SIGCOMM 

1598
01:00:27,806 --> 1:00:30,906
是世界上最重要的

1599
01:00:31,116 --> 1:00:32,546
网络研究学术会议

1600
01:00:34,036 --> 1:00:35,686
每年都有

1601
01:00:35,686 --> 1:00:37,446
网络系统奖

1602
01:00:37,446 --> 1:00:39,366
选出网络领域

1603
01:00:39,366 --> 1:00:42,586
最有影响力的成就

1604
01:00:43,336 --> 1:00:45,286
今年 今天

1605
01:00:45,516 --> 1:00:47,536
他们宣布 今年的奖颁给了 

1606
01:00:47,996 --> 1:00:49,566
Christoph Paasch

1607
01:00:49,566 --> 1:00:51,676
以及多路径 TCP 团队的其他人

1608
01:00:52,516 --> 1:01:00,886
[掌声]

1609
01:00:52,516 --> 1:01:00,886
[掌声]

1610
01:01:01,386 --> 1:01:02,606
我们希望在明天的

1611
01:01:02,606 --> 1:01:04,376
网络实验室看到大家

1612
01:01:04,986 --> 1:01:07,036
如果你们有人现在在写

1613
01:01:07,036 --> 1:01:08,076
网络内核扩展的话

1614
01:01:08,076 --> 1:01:09,786
明天一定要去参加

1615
01:01:09,786 --> 1:01:11,746
《Network Extensions for Modern macOS》

1616
01:01:11,746 --> 1:01:13,976
这一场会议 谢谢大家

1617
01:01:14,516 --> 1:01:17,500
[掌声]
